URL: ftp://ftp.cs.washington.edu/tr/1993/07/UW-CSE-93-07-02.PS.Z
Refering-URL: http://www.cs.washington.edu/research/tr/tr-by-date.html
Root-URL: http://www.cs.washington.edu
Title: Specification, Simulation, and Verification of Timing Behavior  
Author: by Tod Amon 
Degree: A dissertation submitted in partial fulfillment of the requirements for the degree of Doctor of Philosophy  Approved by (Chairperson of Supervisory Committee)  
Note: Program Authorized to Offer Degree Date  
Date: 1993  
Affiliation: University of Washington  
Abstract-found: 0
Intro-found: 1
Reference: [Aho et al. 74] <author> A. V. Aho, J. E. Hopcroft, and J. D. Ullman. </author> <title> The Design and Analysis of Computer Algorithms. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, MA, </address> <year> 1974. </year>
Reference-contexts: The elements of I, 0 and 1, are the identity elements for function maximization and composition, respectively. We have 0 = fh1; 1ig and 1 = fh0; 1ig (note that 0 is an annihilator for function composition). A matrix closure algorithm <ref> [Aho et al. 74] </ref> can be used to compute S fl , the middle part of (7.7), because in this context, function maximization and composition form a closed semi-ring. This is the key observation that allows us to implicitly compute an infinite number of ff values.
Reference: [Ajmone Marsan 89] <author> M. Ajmone Marsan. </author> <title> Stochastic Petri nets: An elementary introduction. </title> <editor> In G. Rozenberg, editor, </editor> <booktitle> Advances in Petri Nets 1989, number 424 in Lecture Notes in Computer Science, </booktitle> <pages> pages 1-29. </pages> <publisher> Springer-Verlag, </publisher> <year> 1989. </year>
Reference-contexts: Many different models of time have been defined for Petri nets, the most popular being stochastic delays used for probabilistic performance evaluation (see <ref> [Ajmone Marsan 89] </ref>). A number of timed Petri net models have been developed that incorporate non-probabilistic (e.g., fixed or bounded) delays, e.g., [Ramamoorthry & Ho 80], [Ramchandani 74], [Merlin 74], [Coolahan & Roussopoulos 85], [Cohen et al. 89], [Andre 91], [Zuberek 91].
Reference: [Allen 83] <author> J. F. Allen. </author> <title> Maintaining knowledge about temporal intervals. </title> <journal> Communications of the ACM, </journal> <volume> 26(11), </volume> <month> November </month> <year> 1983. </year>
Reference-contexts: Interval temporal logics have been developed to address the problem of specifying that an action should occur in a specific time interval <ref> [Allen 83, Moszkowski 85] </ref>.
Reference: [Alur & Dill 90] <author> R. Alur and D. L. Dill. </author> <title> Automata for modeling real-time systems. </title> <booktitle> In 17th International Colloquium on Automata, Languages, and Programming. Springer-Verlag Lecture Notes in Computer Science 443, </booktitle> <year> 1990. </year>
Reference-contexts: An example of their use can be found in [Katzenelson & Kurshan 86] in which several commercial communication protocols are verified. These techniques have also been used to produce finite automata models for analog circuits [Kurshan & McMillan 91]. Timed Automata are a class of finite automata defined by <ref> [Alur & Dill 90] </ref> that can express hard real-time constraints, e.g., "the acknowledgment should occur within 5 seconds." They are based on !-automata augmented with a finite set of timers that record the passage of time.
Reference: [Alur & Henzinger 89] <author> R. Alur and T. A. Henzinger. </author> <title> A really temporal logic. </title> <booktitle> In Proceedings of the 30th Annual IEEE Symposium on Foundations of Computer Science, </booktitle> <year> 1989. </year>
Reference-contexts: They have been used to reason about MOS VLSI circuits at the transistor level [Leeser 89], but many other logics which address the problem of modeling timing behavior have recently been developed: <ref> [Alur & Henzinger 89] </ref>, [Alur & Henzinger 90], [Alur et al. 89], [Coen et al. 90], [Hansen et al. 92], [Harel et al. 90], [Koymans 89], [Koymans 90], [Lewis 90], [Narain et al. 92], [Ostroff 90].
Reference: [Alur & Henzinger 90] <author> R. Alur and T. A. Henzinger. </author> <title> Real-time logics: Complexity and expressiveness. </title> <booktitle> In Fifth Annual IEEE Symposium on Logic in Computer Science, </booktitle> <year> 1990. </year>
Reference-contexts: They have been used to reason about MOS VLSI circuits at the transistor level [Leeser 89], but many other logics which address the problem of modeling timing behavior have recently been developed: [Alur & Henzinger 89], <ref> [Alur & Henzinger 90] </ref>, [Alur et al. 89], [Coen et al. 90], [Hansen et al. 92], [Harel et al. 90], [Koymans 89], [Koymans 90], [Lewis 90], [Narain et al. 92], [Ostroff 90].
Reference: [Alur & Henzinger 92] <author> R. Alur and T. A. Henzinger. </author> <title> Logics and models of real time: A survey. </title> <editor> In J. W. de Bakker, K. Huizing, W. de Roever, and G. Rozenberg, editors, </editor> <title> Real Time: </title> <booktitle> Theory in Practice. Springer-Verlag Lecture Notes in Computer Science 600, </booktitle> <year> 1992. </year>
Reference-contexts: Many of these logics use a continuous model of time and emphasize realistic modeling, others use a more restricted model to obtain feasible verification procedures. Work in this area is proceeding at a very rapid pace, and readers are referred to <ref> [Alur & Henzinger 92] </ref> for a summary of some of the more recent work. Higher order logics (e.g., HOL [Gordon 86]) are popular languages that can be used to express complex timing relationships.
Reference: [Alur et al. 89] <author> R. Alur, T. Feder, and T. A. Henzinger. </author> <title> The benefits of relaxing punctuality. </title> <booktitle> In Proceedings of the 10th Principles of Distributed Computing, </booktitle> <year> 1989. </year>
Reference-contexts: They have been used to reason about MOS VLSI circuits at the transistor level [Leeser 89], but many other logics which address the problem of modeling timing behavior have recently been developed: [Alur & Henzinger 89], [Alur & Henzinger 90], <ref> [Alur et al. 89] </ref>, [Coen et al. 90], [Hansen et al. 92], [Harel et al. 90], [Koymans 89], [Koymans 90], [Lewis 90], [Narain et al. 92], [Ostroff 90].
Reference: [Amon & Borriello 91a] <author> T. Amon and G. Borriello. OEsim: </author> <title> A simulator for timing behavior. </title> <booktitle> In 28th ACM/IEEE Design Automation Conference, </booktitle> <month> June </month> <year> 1991. </year> <month> 138 </month>
Reference-contexts: The major contributions are briefly described in the following two subsections, which summarize the content of this dissertation as a whole. Various aspects of this work have been presented to the research community and reported in the literature: [Amon et al. 91], <ref> [Amon & Borriello 91a] </ref>, [Amon & Borriello 91b], [Amon & Borriello 92], [Amon et al. 93]. 1.2.1 Specification and Validation The primary contribution is the presentation of a formal and general representation for timing specification based on a bipartite graph model augmented with a restricted first-order predicate calculus to specify timing
Reference: [Amon & Borriello 91b] <author> T. Amon and G. Borriello. </author> <title> Sizing synchronization queues: A case study in higher level synthesis. </title> <booktitle> In 28th ACM/IEEE Design Automation Conference, </booktitle> <month> June </month> <year> 1991. </year>
Reference-contexts: The major contributions are briefly described in the following two subsections, which summarize the content of this dissertation as a whole. Various aspects of this work have been presented to the research community and reported in the literature: [Amon et al. 91], [Amon & Borriello 91a], <ref> [Amon & Borriello 91b] </ref>, [Amon & Borriello 92], [Amon et al. 93]. 1.2.1 Specification and Validation The primary contribution is the presentation of a formal and general representation for timing specification based on a bipartite graph model augmented with a restricted first-order predicate calculus to specify timing relationships between signal events. <p> Traditionally, verification is thought of as a post-synthesis step, in which an implementation is verified with respect to a specification. In this dissertation, verification is viewed quite differently, in that it provides guarantees regarding temporal behavior, and these guarantees are quite useful for synthesis. For example, in <ref> [Amon & Borriello 91b] </ref>, we present a synthesis task, the sizing of synchronization queues for concurrent systems, based entirely upon timing information provided either manually by the user or automatically by verification tools.
Reference: [Amon & Borriello 92] <author> T. Amon and G. Borriello. </author> <title> An approach to symbolic timing verification. </title> <booktitle> In 29th ACM/IEEE Design Automation Conference. </booktitle> <address> ACM/IEEE, </address> <month> June </month> <year> 1992. </year>
Reference-contexts: Various aspects of this work have been presented to the research community and reported in the literature: [Amon et al. 91], [Amon & Borriello 91a], [Amon & Borriello 91b], <ref> [Amon & Borriello 92] </ref>, [Amon et al. 93]. 1.2.1 Specification and Validation The primary contribution is the presentation of a formal and general representation for timing specification based on a bipartite graph model augmented with a restricted first-order predicate calculus to specify timing relationships between signal events. <p> Our verifier has been used to analyze several real-world examples containing inter-process communication and cross-process constraints. The largest being a partial specification of the Intel Multibus which consisted of five communicating processes containing a total of 75 events, 65 operations, and 35 timing constraints (this example is discussed in <ref> [Amon & Borriello 92] </ref>). The computational complexity of our methodology has not been studied in great detail.
Reference: [Amon et al. 91] <author> T. Amon, G. Borriello, and C. Sequin. </author> <title> Operation/Event graphs: A design representation for timing behavior. </title> <booktitle> In 1991 IFIP Conference on Hardware Description Languages (CHDL), </booktitle> <year> 1991. </year>
Reference-contexts: The major contributions are briefly described in the following two subsections, which summarize the content of this dissertation as a whole. Various aspects of this work have been presented to the research community and reported in the literature: <ref> [Amon et al. 91] </ref>, [Amon & Borriello 91a], [Amon & Borriello 91b], [Amon & Borriello 92], [Amon et al. 93]. 1.2.1 Specification and Validation The primary contribution is the presentation of a formal and general representation for timing specification based on a bipartite graph model augmented with a restricted first-order predicate <p> the timing constraints do not compose modularly as one might assume. 71 4.4 Discussion We have used OEsim to describe a wide range of examples derived from real circuits or extracted from the specification and synthesis literature | the largest being the specification and simulation of the Intel Multibus (see <ref> [Amon et al. 91] </ref>) for which we were able to include all of the constraints described in the databook specification, many of which can not be expressed using more restrictive event-based specification languages (such as the event-graphs of [Borriello 88b]).
Reference: [Amon et al. 93] <author> T. Amon, H. Hulgaard, S. Burns, and G. Borriello. </author> <title> An algorithm for exact bounds on the time separation of events in concurrent systems. </title> <booktitle> In IEEE International Conference on Computer Design (ICCD), </booktitle> <month> October </month> <year> 1993. </year>
Reference-contexts: Various aspects of this work have been presented to the research community and reported in the literature: [Amon et al. 91], [Amon & Borriello 91a], [Amon & Borriello 91b], [Amon & Borriello 92], <ref> [Amon et al. 93] </ref>. 1.2.1 Specification and Validation The primary contribution is the presentation of a formal and general representation for timing specification based on a bipartite graph model augmented with a restricted first-order predicate calculus to specify timing relationships between signal events.
Reference: [Andre 91] <author> C. Andre. </author> <title> Delays in synchronized elementary net systems. </title> <editor> In G. Rozenberg, editor, </editor> <booktitle> Advances in Petri Nets 1991, number 524 in Lecture Notes in Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1991. </year>
Reference-contexts: A number of timed Petri net models have been developed that incorporate non-probabilistic (e.g., fixed or bounded) delays, e.g., [Ramamoorthry & Ho 80], [Ramchandani 74], [Merlin 74], [Coolahan & Roussopoulos 85], [Cohen et al. 89], <ref> [Andre 91] </ref>, [Zuberek 91]. Some specification languages are based on the event paradigm but are also closely related to the paradigms previously discussed. Timing diagrams are, in fact, essentially event-based specifications event graphs are used to provide a formal underlying semantics (e.g., [Borriello 88b, Khordoc et al. 91]).
Reference: [Arnold 85] <author> J. Arnold. </author> <title> The knowledge-based test assistant's wave/signal editor: An interface for the management of timing constraints. </title> <booktitle> In Second Conference on Artificial Intelligence Applications, </booktitle> <month> December </month> <year> 1985. </year>
Reference-contexts: For example, if two signal transitions are constrained relative to a common transition, it is possible that a constraint between the two signals could result in an inconsistency. Timing diagram editors have also been developed for use as an interface to circuit testers <ref> [Arnold 85, Lai 83] </ref>. Timing diagrams constrain circuit behavior in a specific context, i.e., they represent 17 one possible execution, assuming that a particular sequence of signal transitions occur.
Reference: [Augustin 89] <author> L. M. Augustin. </author> <title> An algebra of waveforms. </title> <editor> In L. Claesen, editor, </editor> <booktitle> Proceedings of the IFIP International Workshop on Applied Formal Methods For Correct VLSI Design, </booktitle> <pages> pages 159-168, </pages> <address> Leuven, Belgium, </address> <month> November </month> <year> 1989. </year> <pages> North-Holland. </pages>
Reference-contexts: These languages are in fact quite flexible and are used extensively for formal verification. Their complexity, however, requires that proofs be constructed by hand, with the assistance of "theorem provers," which are essentially proof managers augmented with some automated reasoning capabilities. A related formalism is Waveform Algebra <ref> [Augustin 89] </ref>, which extends Boolean algebra to include time. Waveform Algebra is applicable to a smaller subset of behavior than that of temporal or higher-order logic (which was used to formalize the algebra).
Reference: [Augustin et al. 88] <author> L. Augustin, B. Gennart, Y. Huh, D. Luckham, and A. Stanculescu. </author> <title> An overview of VAL. </title> <type> Technical Report CSL-TR-88-367, </type> <institution> Stanford University, </institution> <year> 1988. </year>
Reference-contexts: Temporal logic has been used to specify and verify the temporal behavior of Statecharts [Harel et al. 88], and Waveform Algebra has 21 been used to annotate VHDL <ref> [Augustin et al. 88] </ref>. There are various timing relationships that cannot be specified using the different formalisms (e.g. fairness constraints are not easily specified in CTL) and there are many well known limitations to the expressiviness of propositional temporal logic (see [Wolper 81]). <p> One serious limitation is that timing constraints are not allowed to cross the hierarchy and must be local with respect to each basic block (i.e., each acyclic data flow graph). More complex constraints can be specified in languages that use some other form of annotation. For example, VAL <ref> [Augustin et al. 88] </ref> is an annotation language based on Waveform Algebra that can be used to specify timing constraints for VHDL. Hardware description languages are very popular.
Reference: [Barbacci 81] <author> M. Barbacci. </author> <title> Instruction set processor specification (ISPS): The notation and its applications. </title> <journal> IEEE Transactions on Computers, </journal> <month> January </month> <year> 1981. </year>
Reference: [Bennett 86] <author> M. J. Bennett. </author> <title> Proving Correcness of Asynchronous Circuits Using Temporal Logic. </title> <type> PhD dissertation, </type> <institution> University of California at Los Angeles, </institution> <month> April </month> <year> 1986. </year>
Reference-contexts: They have been used by many different researchers for specifying and verifying hardware (e.g., <ref> [Bennett 86] </ref>, [Bochmann 82], [Browne et al. 86], [Clarke et al. 86], [Dill & Clarke 85], [Fujita et al. 83], [Fusaoka et al. 84], [Malachi & Owicki 81]). Figure 2.3 contains a four phase communication protocol specified using the linear-time propositional temporal logic of Bochmann.
Reference: [Bestavros 90] <author> A. A. Bestavros. </author> <title> The input output timed automaton: A model for real-time parallel computation. </title> <booktitle> First International Workshop on Timing Issues in the Specification and Synthesis of Digital Systems (Tau '90), </booktitle> <month> August </month> <year> 1990. </year> <month> 139 </month>
Reference-contexts: The Input/Output Automata of [Lynch & Tuttle 89] have been extended to support more exact timing requirements by <ref> [Bestavros 90] </ref>, [Merritt et al. 91], and [Lynch & Attiya 92]. One advantage of this specification language is that complex systems can be 22 specified by composing together simpler system components.
Reference: [Bochmann 82] <author> G. V. Bochmann. </author> <title> Hardware specification with temporal logic: An example. </title> <journal> IEEE Transactions on Computers, </journal> <volume> C-31(3), </volume> <month> March </month> <year> 1982. </year>
Reference-contexts: They have been used by many different researchers for specifying and verifying hardware (e.g., [Bennett 86], <ref> [Bochmann 82] </ref>, [Browne et al. 86], [Clarke et al. 86], [Dill & Clarke 85], [Fujita et al. 83], [Fusaoka et al. 84], [Malachi & Owicki 81]). Figure 2.3 contains a four phase communication protocol specified using the linear-time propositional temporal logic of Bochmann.
Reference: [Borriello 88a] <author> G. Borriello. </author> <title> Combining event and data-flow graphs in behavioral synthesis. </title> <booktitle> Proceedings of the International Conference on Computer Aided Design, </booktitle> <month> November </month> <year> 1988. </year>
Reference-contexts: Most of the existing event graph representations are acyclic and represent one execution of a particular system behavior. Some of the representations using this paradigm include: <ref> [Borriello 88a] </ref>, [Gahlinger 90], [Hayati et al. 88], [Khordoc et al. 91], [Martello et al. 90], [Sherman 88], [Zahir & Fichtner 90]. Cyclic event graphs are far less common, and have been used primarily to represent asynchronous circuits, e.g., [Chu 87], and to analyze their performance, e.g., [Burns 91].
Reference: [Borriello 88b] <author> G. Borriello. </author> <title> A New Interface Specification Methodology and its Application to Transducer Synthesis. </title> <type> PhD dissertation, </type> <institution> University of California at Berkeley, </institution> <year> 1988. </year>
Reference-contexts: Figure 2.2 contains two interconnected diagrams that together formally specify the master read operation on the Intel Multibus. These timing diagrams were produced by the editor WAVES, which is a part of an interface synthesis tool that uses formalized timing diagrams as an input specification language <ref> [Borriello 88b] </ref>. Formalized timing diagrams have also been used in timing verification to specify timing constraints which should be checked during simulation [Khordoc et al. 91]. Even though few existing tools use timing diagrams as a specification language, the paradigm has the potential to be very well accepted by designers. <p> Designers currently specify complex timing relationships by annotating diagrams with informal text. These constraints need to be formally specified, but there are many complex timing relationships that cannot be specified using the languages of <ref> [Borriello 88b] </ref> or [Khordoc et al. 91]. These languages and their underlying internal representations lack the necessary expressive power. Furthermore, timing diagrams specify signal waveforms, not circuit functionality or structure. <p> Some specification languages are based on the event paradigm but are also closely related to the paradigms previously discussed. Timing diagrams are, in fact, essentially event-based specifications event graphs are used to provide a formal underlying semantics (e.g., <ref> [Borriello 88b, Khordoc et al. 91] </ref>). In order to capture more complicated timing constraints (e.g., ones that appear as annotations to timing diagrams) event graphs are not sufficient, and thus more powerful specification languages are needed. <p> Many representations can express most aspects of a particular circuit's timing behavior, but find that there are some specific timing constraints or functionalities they cannot express (e.g., <ref> [Borriello 88b] </ref>, [Khordoc et al. 91], [Martello et al. 90]). Another serious problem is that structure cannot be explicitly represented in the specification. <p> The event Y is on a loop, and thus there will potentially be many more occurrences of Y than of either X or Z during any execution of the system. The restricted semantics might assume (e.g., as in <ref> [Borriello 88b] </ref>), that a constraint "from X to Y " relates X to the first Y occurring in the loop, and that a constraint "from Y to Z" relates the last Y occurring in the loop to Z. <p> Most constraints, like this one, have a simple semantics (e.g., setup and hold) and parameterized subroutines for constraint specification can be defined using OEgraphs. Other higher-level specifications (e.g., timing diagram editors <ref> [Borriello 88b] </ref>) 3 We also allow x to occur at the same time as y. <p> the largest being the specification and simulation of the Intel Multibus (see [Amon et al. 91]) for which we were able to include all of the constraints described in the databook specification, many of which can not be expressed using more restrictive event-based specification languages (such as the event-graphs of <ref> [Borriello 88b] </ref>). At the University of California at Berkeley, OEsim has been used to represent and simulate the abstract interfaces of complex components that are interconnected on a printed circuit board or multi-chip module (see [Sun & Brodersen 92]). <p> An event graph (see Section 2.3) is used to capture the events and propagation delays of the system. Shortest path algorithms have been used to solve problems that contain only linear 79 constraints, e.g., <ref> [Borriello 88b] </ref> and [Brzozowski et al. 91]. Both [McMillan & Dill 92] and [Vanbekbergen et al. 92] provide an overview of the various types of event graphs and timing constraints for which verification algorithms have been developed (both authors present algorithms for handling non-linear constraints).
Reference: [Brauer et al. 87] <editor> W. Brauer, W. Reisig, and G. Rozenberg, editors. </editor> <booktitle> Advances in Petri Nets 1986. Number 254 in Lecture Notes in Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1987. </year> <title> Part I: Petri Nets: Central Models and their Properties, Part II: Petri Nets: Applications and Relationships to Other Models of Concurrency. </title>
Reference-contexts: A closely related and well known representation is the Petri net, which has been used extensively to model concurrent systems (see [Murata 89] or <ref> [Brauer et al. 87] </ref> for a summary). Many different models of time have been defined for Petri nets, the most popular being stochastic delays used for probabilistic performance evaluation (see [Ajmone Marsan 89]).
Reference: [Browne et al. 86] <author> M. C. Browne, E. M. Clarke, D. L. Dill, and B. Mishra. </author> <title> Automatic verification of sequential circuits using temporal logic. </title> <journal> IEEE Transactions on Computers, </journal> <volume> C-35(12), </volume> <month> December </month> <year> 1986. </year>
Reference-contexts: They have been used by many different researchers for specifying and verifying hardware (e.g., [Bennett 86], [Bochmann 82], <ref> [Browne et al. 86] </ref>, [Clarke et al. 86], [Dill & Clarke 85], [Fujita et al. 83], [Fusaoka et al. 84], [Malachi & Owicki 81]). Figure 2.3 contains a four phase communication protocol specified using the linear-time propositional temporal logic of Bochmann.
Reference: [Bryant & Seger 91] <author> R. E. Bryant and C.-J. H. Seger. </author> <title> Formal hardware verification by symbolic trajectory evaluation. </title> <booktitle> In 28th ACM/IEEE Design Automation Conference, </booktitle> <month> June </month> <year> 1991. </year>
Reference-contexts: Verification tools based on this methodology can disregard aspects 75 of the design which are not important (e.g., in some cases data values can be ignored if only temporal correctness is being verified). This approach has been used to improve the efficiency of verification techniques for synchronous systems (see <ref> [Bryant & Seger 91] </ref>). Due to the inherent complexity of verification, some verification tools are incomplete, in that they verify a design's specification against an incomplete set of all possible behaviors of the implementation. Incomplete verifiers formally compare the results of simulation with the design specification.
Reference: [Bryant 86] <author> R. E. Bryant. </author> <title> Graph-based algorithms for boolean function manipulation. </title> <journal> IEEE Transactions on Computers, </journal> <month> August </month> <year> 1986. </year>
Reference-contexts: Frequently, the specifications represent designs at two different levels of abstraction, i.e., a design specification is compared to a design implementation. Verification techniques are then used to establish that the implementation satisfies the requirements defined by the specification. For example, in combinational logic verification (see <ref> [Bryant 86] </ref>), the Boolean function that specifies the functionality of a piece of combination logic is compared with the gate level implementation (see Figure 5.1). f (a,b,c) = a b + b c b For example, we could formally prove that the combinational logic on the right implements the functionality of <p> In one simulation, a symbolic simulator can compute results that would require many simulation runs using a conventional simulator because each input would need to be completely specified. This technique is quite adequate for verifying combinational logic circuits <ref> [Bryant 86] </ref>. A Boolean function is obtained from the gate-level implementation via symbolic simulation, and verification is successful if the resulting function is equivalent to that of the specification. <p> One well known approach, model checking, verifies properties expressed using temporal logic. For example, [Burch et al. 90] use the temporal logic CTL [Dill & Clarke 85] to verify properties of sequential circuits. Recent work in this area relies on symbolic state encoding using Binary Decision Diagrams (BDDs) <ref> [Bryant 86] </ref>. This allows systems with large numbers of states to be verified (e.g., systems with 10 20 or in some cases even 10 120 states [Burch et al. 91]).
Reference: [Brzozowski et al. 91] <author> J. A. Brzozowski, T. Gahlinger, and F. Mavaddat. </author> <title> Consistency and satisfiability of waveform timing specifications. Networks, </title> <month> January </month> <year> 1991. </year>
Reference-contexts: An event graph (see Section 2.3) is used to capture the events and propagation delays of the system. Shortest path algorithms have been used to solve problems that contain only linear 79 constraints, e.g., [Borriello 88b] and <ref> [Brzozowski et al. 91] </ref>. Both [McMillan & Dill 92] and [Vanbekbergen et al. 92] provide an overview of the various types of event graphs and timing constraints for which verification algorithms have been developed (both authors present algorithms for handling non-linear constraints).
Reference: [Buck et al. 91] <author> J. Buck, S. Ha, E. Lee, and D. Messerschmitt. Ptolemy: </author> <title> A platform for heterogeneous simulation and prototyping. </title> <booktitle> Proceedings of the European Simulation Conference, </booktitle> <month> June </month> <year> 1991. </year>
Reference-contexts: A modified form of our restricted event-logic has also been incorporated (see [Ortega 92]) into the heterogenous simulation framework of Ptolemy <ref> [Buck et al. 91] </ref> to support the specification and checking of timing constraints when working within its event-driven simulation domain. We have not analyzed the performance of OEsim in detail, but have found it to be efficient and capable.
Reference: [Burch 92] <author> J. R. Burch. </author> <title> Trace Algebra for Automatic Verification of Real-Time Concurrent Systems. </title> <type> PhD dissertation, </type> <institution> Carnegie Mellon University, </institution> <month> August </month> <year> 1992. </year>
Reference-contexts: A more realistic approach based on a continuous model of time uses timed traces in which every transition is labeled with a real number. A summary of the many different timing models (i.e., quantized vs. continuous, interleaving vs. simultaneity, etc.) can be found in <ref> [Burch 92] </ref> which presents a unifying theory for trace algebras that are used to specify temporal behavior. There are close relationships between finite automata, trace theory (algebra), and the formal logics and algebras described in the previous subsection. <p> The expressive power of these formalisms is in many cases well understood (e.g., trace algebra cannot be used to adequately model branching time properties <ref> [Burch 92] </ref>), but more theoretical work relating the formalisms to the specification of timing behavior needs to be done. Some of these specification languages are limited with regards to their expressiviness (e.g., the fictitious clock models, and BFSMs in which only simple linear timing constraints can be specified). <p> Many verification problems can be expressed and solved using algorithms for language containment. In this approach, a formal language is used to express both the specification and the implementation. Trace theory has been used quite succesfully to verify speed independent asynchronous circuits [Dill 88], and in <ref> [Burch 92] </ref>, timed asynchronous circuits are verified using extensions to the verifier of [Dill 88]. Finite automata are used to specify the sets of acceptable traces, and the verification algorithms are also state based.
Reference: [Burch et al. 90] <author> J. R. Burch, E. M. Clarke, D. L. Dill, and K. L. McMillan. </author> <title> Sequential circuit verification using symbolic model checking. </title> <booktitle> In 27th ACM/IEEE Design Automation Conference, </booktitle> <month> June </month> <year> 1990. </year>
Reference-contexts: This methodology has been used for a variety of 77 verification tools. The major limitation is that the state exploration algorithms become computationally infeasible as the number of states becomes very large. One well known approach, model checking, verifies properties expressed using temporal logic. For example, <ref> [Burch et al. 90] </ref> use the temporal logic CTL [Dill & Clarke 85] to verify properties of sequential circuits. Recent work in this area relies on symbolic state encoding using Binary Decision Diagrams (BDDs) [Bryant 86].
Reference: [Burch et al. 91] <author> J. R. Burch, E. M. Clarke, and D. E. </author> <title> Long. Representing circuits more efficiently in symbolic model checking. </title> <booktitle> In 28th ACM/IEEE Design Automation Conference, </booktitle> <month> June </month> <year> 1991. </year> <month> 140 </month>
Reference-contexts: Recent work in this area relies on symbolic state encoding using Binary Decision Diagrams (BDDs) [Bryant 86]. This allows systems with large numbers of states to be verified (e.g., systems with 10 20 or in some cases even 10 120 states <ref> [Burch et al. 91] </ref>). Model checking has typically been used to verify systems in which propagation delays between circuit elements do not vary and are assumed to be unit delays. Many verification problems can be expressed and solved using algorithms for language containment.
Reference: [Burns 91] <author> S. M. Burns. </author> <title> Performance Analysis and Optimization of Asynchronous Circuits. </title> <type> PhD dissertation, </type> <institution> California Institute of Technology, </institution> <year> 1991. </year> <month> CS-TR-91-1. </month>
Reference-contexts: Cyclic event graphs are far less common, and have been used primarily to represent asynchronous circuits, e.g., [Chu 87], and to analyze their performance, e.g., <ref> [Burns 91] </ref>. A closely related and well known representation is the Petri net, which has been used extensively to model concurrent systems (see [Murata 89] or [Brauer et al. 87] for a summary). <p> Both [McMillan & Dill 92] and [Vanbekbergen et al. 92] handle only acyclic graphs. However, they provide a theoretical foundation upon which our solution is built. Both [Cohen et al. 89] and <ref> [Burns 91] </ref> use cyclic graph models but they deal only with fixed delays between events. 107 7.1 Problem Formalization We could express our concurrent system as an operation-event graph using two different operations for modeling synchronization and computation, e.g., see Figure 7.2. <p> The process graph for our example (see Figure 7.1) is shown in Figure 7.3. [1; 2] [1; 6] number of lines drawn through an edge indicates the value of the occurrence index offset. To formalize the problem we use a simple modification of the event-rule system developed in <ref> [Burns 91] </ref> 1 . Let G 0 = hE 0 ; R 0 i denote a process graph composed of * a finite set of (repeatable) events E 0 , the vertices of the graph. * a finite set of rule templates R 0 , the edges of the graph. <p> The model can also be viewed as an extension of [McMillan & Dill 92] and [Vanbekbergen et al. 92], where we consider cyclic max-only or type-2 graphs. To remain consistent with the notation of <ref> [Burns 91] </ref> we introduce G 0 before G, E 0 before E, etc., i.e., primed variables are introduced before unprimed variables. 109 The occurrence index offset is used to specify how much the occurrence index is incremented when the edge is executed|see Section 7.1.2. <p> The size of the representation of a particular function may be as large as the number of paths between the two events related by the function. Point 1 is potentially serious, however in most process graphs derived from circuits, " ? = 1 (see <ref> [Burns 91] </ref>). k ? is more of a concern because it can be large if there exists a cycle c such that d (c)="(c) is almost equal to r ? . Although of theoretical interest, point 2 is not likely to be of practical concern.
Reference: [Chu 87] <author> T.-A. Chu. </author> <title> Synthesis of Self-timed VLSI Circuits from Graph-theoretic Specifications. </title> <type> PhD dissertation, </type> <institution> Massachusetts Institute of Technology, </institution> <year> 1987. </year> <month> MIT/LCS/TR-393. </month>
Reference-contexts: Some of the representations using this paradigm include: [Borriello 88a], [Gahlinger 90], [Hayati et al. 88], [Khordoc et al. 91], [Martello et al. 90], [Sherman 88], [Zahir & Fichtner 90]. Cyclic event graphs are far less common, and have been used primarily to represent asynchronous circuits, e.g., <ref> [Chu 87] </ref>, and to analyze their performance, e.g., [Burns 91]. A closely related and well known representation is the Petri net, which has been used extensively to model concurrent systems (see [Murata 89] or [Brauer et al. 87] for a summary). <p> Modularity from a behavioral as well as structural perspective is thus also quite important. Some existing representations are not expressive because their development has been too closely guided by synthesis concerns. For example, in State Transition Graphs (STGs) <ref> [Chu 87] </ref>, there can only be 31 one rising and falling transition on each signal (e.g., one A+ and one A- in the graph). From a high-level perspective, however, there may be two unique independent contexts in which a signal should be raised, and thus two distinct events are needed.
Reference: [Clark et al. 86] <author> E. Clark, E. Emerson, and A. Sistla. </author> <title> Automatic verification of finite-state concurrent systems using temporal logic specifications. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 8(2), </volume> <month> April </month> <year> 1986. </year>
Reference: [Clarke et al. 86] <author> E. M. Clarke, E. A. Emerson, and A. P. Sistla. </author> <title> Automatic verification of finite-state concurrent systems using temporal logic specifications. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 8(2), </volume> <month> April </month> <year> 1986. </year>
Reference-contexts: They have been used by many different researchers for specifying and verifying hardware (e.g., [Bennett 86], [Bochmann 82], [Browne et al. 86], <ref> [Clarke et al. 86] </ref>, [Dill & Clarke 85], [Fujita et al. 83], [Fusaoka et al. 84], [Malachi & Owicki 81]). Figure 2.3 contains a four phase communication protocol specified using the linear-time propositional temporal logic of Bochmann.
Reference: [Coen et al. 90] <author> A. Coen, A. Morzentia, and D. Sciuto. </author> <title> Hardware specification with the temporal logic language TRIO. </title> <booktitle> First International Workshop on Timing Issues in the Specification and Synthesis of Digital Systems (Tau '90), </booktitle> <month> August </month> <year> 1990. </year>
Reference-contexts: They have been used to reason about MOS VLSI circuits at the transistor level [Leeser 89], but many other logics which address the problem of modeling timing behavior have recently been developed: [Alur & Henzinger 89], [Alur & Henzinger 90], [Alur et al. 89], <ref> [Coen et al. 90] </ref>, [Hansen et al. 92], [Harel et al. 90], [Koymans 89], [Koymans 90], [Lewis 90], [Narain et al. 92], [Ostroff 90]. Many of these logics use a continuous model of time and emphasize realistic modeling, others use a more restricted model to obtain feasible verification procedures.
Reference: [Cohen 90] <author> J. Cohen. </author> <title> Constraint logic programming languages. </title> <journal> Communications of the ACM, </journal> <volume> 33(7), </volume> <month> July </month> <year> 1990. </year>
Reference-contexts: See <ref> [Cohen 90] </ref> for a comprehensive introduction and overview of this programming paradigm. We chose the language CLP (R) because it provides an ideal framework for exploring this methodology. CLP (R) incorporates an incremental version of the standard simplex linear programming algorithm and a goal based programming language akin to Prolog.
Reference: [Cohen et al. 89] <author> G. Cohen, P. Moller, J. P. Quadrat, and M. Viot. </author> <title> Evaluation of discrete event systems. </title> <booktitle> Proceedings of the IEEE, </booktitle> <volume> 77(1) </volume> <pages> 39-58, </pages> <month> Jan </month> <year> 1989. </year>
Reference-contexts: A number of timed Petri net models have been developed that incorporate non-probabilistic (e.g., fixed or bounded) delays, e.g., [Ramamoorthry & Ho 80], [Ramchandani 74], [Merlin 74], [Coolahan & Roussopoulos 85], <ref> [Cohen et al. 89] </ref>, [Andre 91], [Zuberek 91]. Some specification languages are based on the event paradigm but are also closely related to the paradigms previously discussed. <p> Both [McMillan & Dill 92] and [Vanbekbergen et al. 92] handle only acyclic graphs. However, they provide a theoretical foundation upon which our solution is built. Both <ref> [Cohen et al. 89] </ref> and [Burns 91] use cyclic graph models but they deal only with fixed delays between events. 107 7.1 Problem Formalization We could express our concurrent system as an operation-event graph using two different operations for modeling synchronization and computation, e.g., see Figure 7.2.
Reference: [Coolahan & Roussopoulos 85] <author> J. E. Coolahan, Jr. and N. Roussopoulos. </author> <title> A timed Petri net methodology for specifying real-time system timing requirements. </title> <booktitle> In [TPN 85], </booktitle> <pages> pages 24-31, </pages> <year> 1985. </year>
Reference-contexts: A number of timed Petri net models have been developed that incorporate non-probabilistic (e.g., fixed or bounded) delays, e.g., [Ramamoorthry & Ho 80], [Ramchandani 74], [Merlin 74], <ref> [Coolahan & Roussopoulos 85] </ref>, [Cohen et al. 89], [Andre 91], [Zuberek 91]. Some specification languages are based on the event paradigm but are also closely related to the paradigms previously discussed.
Reference: [Devadas et al. 92] <author> S. Devadas, K. Keutzer, S. Malik, and A. Wang. </author> <title> Verification of asynchronous interface circuits with bounded wire delays. </title> <booktitle> In IEEE International Conference on Computer-Aided Design (ICCAD), </booktitle> <month> November </month> <year> 1992. </year>
Reference-contexts: This technique creates a state transition graph, but only creates new states when the operation of the system will change based on different choices for propagation delays. Examples of this approach are <ref> [Devadas et al. 92] </ref> and [Martello & Levitan 93]. 5.4 Timing Verification Timing verification is able to provide guarantees about the temporal behavior of a system and is thus very useful in design synthesis, because these guarantees can be used to help guide the process of transforming a design from an
Reference: [Dill & Clarke 85] <author> D. L. Dill and E. M. Clarke. </author> <title> Automatic verification of asynchronous circuits using temporal logic. </title> <booktitle> 1985 Chapel Hill Conference on VLSI, </booktitle> <year> 1985. </year>
Reference-contexts: They have been used by many different researchers for specifying and verifying hardware (e.g., [Bennett 86], [Bochmann 82], [Browne et al. 86], [Clarke et al. 86], <ref> [Dill & Clarke 85] </ref>, [Fujita et al. 83], [Fusaoka et al. 84], [Malachi & Owicki 81]). Figure 2.3 contains a four phase communication protocol specified using the linear-time propositional temporal logic of Bochmann. <p> Identifying which specific transitions are being constrained is difficult in these languages because levels and not events are the focus of the specification. Many of these languages are used to specify the temporal behavior of a circuit defined using another specification language. For example, computation tree logic (CTL) <ref> [Dill & Clarke 85] </ref>, is used to specify temporal behavior with respect to a state graph which can be derived from a circuit specification. <p> The major limitation is that the state exploration algorithms become computationally infeasible as the number of states becomes very large. One well known approach, model checking, verifies properties expressed using temporal logic. For example, [Burch et al. 90] use the temporal logic CTL <ref> [Dill & Clarke 85] </ref> to verify properties of sequential circuits. Recent work in this area relies on symbolic state encoding using Binary Decision Diagrams (BDDs) [Bryant 86].
Reference: [Dill 88] <author> D. L. Dill. </author> <title> Trace Theory for Automatic Hierarchical Verification of Speed-Independent Circuits. </title> <type> PhD dissertation, </type> <institution> Carnegie Mellon University, </institution> <year> 1988. </year> <month> CMU-CS-88-119. </month>
Reference-contexts: For example, a legal trace of the four cycle communication protocol of Figure 2.3 would be: "R" ; A" ; R# ; A# ; R" ; A" ; R# ; A# : : :" Trace theory has been used extensively to verify asynchronous speed-independent circuits <ref> [Dill 88] </ref>, [Rem et al. 83], [van de Snepscheut 85], [Ebergen 87]. There are a variety of extensions to this body of theory that handle more detailed timing requirements. One approach introduces a fictitious clock and a special tick transition that is used to measure elapsed time. <p> Many verification problems can be expressed and solved using algorithms for language containment. In this approach, a formal language is used to express both the specification and the implementation. Trace theory has been used quite succesfully to verify speed independent asynchronous circuits <ref> [Dill 88] </ref>, and in [Burch 92], timed asynchronous circuits are verified using extensions to the verifier of [Dill 88]. Finite automata are used to specify the sets of acceptable traces, and the verification algorithms are also state based. <p> In this approach, a formal language is used to express both the specification and the implementation. Trace theory has been used quite succesfully to verify speed independent asynchronous circuits <ref> [Dill 88] </ref>, and in [Burch 92], timed asynchronous circuits are verified using extensions to the verifier of [Dill 88]. Finite automata are used to specify the sets of acceptable traces, and the verification algorithms are also state based. Another approach to the verification of systems with variable propagation delays is based on the idea of bifurcation.
Reference: [Doc 89] <institution> Doctor Design, Inc., La Jolla, California. </institution> <note> dV/dt User's Guide, </note> <year> 1989. </year>
Reference-contexts: Specifications of this nature are not formal. They are used primarily by designers to communicate and document the temporal aspects of their designs. Timing diagram editors have recently been developed to help designers create timing diagrams. These editors typically are commercial products (e.g., dV/dt available for DOS and Macintosh <ref> [Doc 89] </ref>) or are part of in-house CAD systems (e.g., BNR's Shadow). These editors typ ically operate like spreadsheets, and often provide some form of constraint propagation and consistency checking.
Reference: [Doukas & LaPaugh 91] <author> D. Doukas and A. S. LaPaugh. CLOVER: </author> <title> a timing constraints verification system. </title> <booktitle> In 28th ACM/IEEE Design Automation Conference, </booktitle> <month> June </month> <year> 1991. </year> <month> 141 </month>
Reference-contexts: Most incomplete verifiers (e.g., SCALD [McWilliams 80], and TDS [Kara et al. 88]) provide little support for specifying and verifying temporal properties other than simple setup and hold constraints. One incomplete verifier that supports a more expressive specification language is CLOVER <ref> [Doukas & LaPaugh 91] </ref>, which uses an event-based specification language (ATCSL) that relies on event indexing to identify the discrete events being constrained.
Reference: [Doukas 91] <author> D. A. Doukas. </author> <title> A new specification model for timing constraints and efficient methods for their verification. </title> <type> PhD dissertation, </type> <institution> Princeton University, </institution> <year> 1991. </year> <month> CS-TR-297-90. </month>
Reference-contexts: The logic supports both existential and universal quantification of integer variables that are used to identify events by their occurrence index. This indexing approach is also used in the language ATCSL <ref> [Doukas 91] </ref>. The language CPA [McFarland 90] is another formal logic based on the event paradigm. It uses a fully declarative semantics to describe a large class of system behaviors. <p> Each occurrence of an event has an index, and this index can be used to specify which discrete events are being constrained. In this case, (e.g., Real-Time Logic [Jahanian & Mok 86], or ATCSL <ref> [Doukas 91] </ref>) one could specify a constraint "from X to the 2 nd occurrence of Y in the loop" by constraining the i th occurrence of X with the ((i 1)n + 2) th occurrence of Y where n is the fixed iteration count for the loop (n 2).
Reference: [Ebergen 87] <author> J. C. Ebergen. </author> <title> Translating Programs into Delay-Insensitive Circuits. </title> <type> PhD dissertation, </type> <institution> Technische Universiteit Eindhoven, </institution> <year> 1987. </year>
Reference-contexts: of the four cycle communication protocol of Figure 2.3 would be: "R" ; A" ; R# ; A# ; R" ; A" ; R# ; A# : : :" Trace theory has been used extensively to verify asynchronous speed-independent circuits [Dill 88], [Rem et al. 83], [van de Snepscheut 85], <ref> [Ebergen 87] </ref>. There are a variety of extensions to this body of theory that handle more detailed timing requirements. One approach introduces a fictitious clock and a special tick transition that is used to measure elapsed time.
Reference: [Eilenberg 74] <author> S. Eilenberg. </author> <title> Automata, </title> <journal> Languages, and Machines, </journal> <volume> Vol. </volume> <editor> A. </editor> <publisher> Academic Press, </publisher> <year> 1974. </year>
Reference-contexts: The formal language accepted by these automata defines the set of legal/possible system behaviors. Because legal system behaviors are often infinite, automata that accept infinite strings (e.g., !- automata) are often needed. We refer readers to an introductory text on automata theory (e.g., <ref> [Eilenberg 74] </ref> or [Hopcroft & Ullman 79]) for a more complete discussion of the models that support only sequencing relationships. An example of their use can be found in [Katzenelson & Kurshan 86] in which several commercial communication protocols are verified.
Reference: [Emerson & Halpern 86] <author> E. A. Emerson and J. Y. Halpern. </author> <title> "sometimes" and "not never" revisited: On branching versus linear time temporal logic. </title> <journal> Journal of the Association for Computing Machinery, </journal> <volume> 33(1), </volume> <month> January </month> <year> 1986. </year>
Reference-contexts: Comparisons of the formal expressive power of some of these logics have been made (e.g., for a comparison of branching vs. linear-time temporal logic see [Lamport 80] or <ref> [Emerson & Halpern 86] </ref>). 2.2.3 Automata and Trace Algebras As in the case of temporal logics, simple automata models can be used for abstract temporal modeling, in which only the sequence of events is important. The formal language accepted by these automata defines the set of legal/possible system behaviors.
Reference: [Fourman 90] <author> M. P. Fourman. </author> <title> Formal system design. </title> <editor> In J. Staunstrup, editor, </editor> <title> Formal Methods for VLSI Design. </title> <publisher> North Holland, </publisher> <year> 1990. </year>
Reference-contexts: Therefore, most individuals use only one theorem prover. Although the formal differences between the various provers are in many cases well understood, there is little practical difference between them. Theorem provers used for circuit verification include HOL [Gordon 88], LP [Garland & Guttag 89], LAMBDA <ref> [Fourman 90] </ref>, and Boyer-Moore (see [Hunt 85]). The primary advantage of this approach to verification is the flexibility and expressiveness of the specification paradigm. Temporal issues can be fully taken into account, and complex circuits can be verified through the use of modularity and abstraction.
Reference: [Fujita et al. 83] <author> M. Fujita, H. Tanaka, and T. Moto-oka. </author> <title> Verification with Prolog and temporal logic. </title> <booktitle> Proceedings of the 1983 IFIP Conference on Hardware Description Languages (CHDL), </booktitle> <year> 1983. </year>
Reference-contexts: They have been used by many different researchers for specifying and verifying hardware (e.g., [Bennett 86], [Bochmann 82], [Browne et al. 86], [Clarke et al. 86], [Dill & Clarke 85], <ref> [Fujita et al. 83] </ref>, [Fusaoka et al. 84], [Malachi & Owicki 81]). Figure 2.3 contains a four phase communication protocol specified using the linear-time propositional temporal logic of Bochmann.
Reference: [Fusaoka et al. 84] <author> A. Fusaoka, H. Seki, and K. Takahashi. </author> <title> Description and reasoning of VLSI circuit in temporal logic. </title> <journal> New Generation Computing, </journal> <volume> 2, </volume> <year> 1984. </year>
Reference-contexts: They have been used by many different researchers for specifying and verifying hardware (e.g., [Bennett 86], [Bochmann 82], [Browne et al. 86], [Clarke et al. 86], [Dill & Clarke 85], [Fujita et al. 83], <ref> [Fusaoka et al. 84] </ref>, [Malachi & Owicki 81]). Figure 2.3 contains a four phase communication protocol specified using the linear-time propositional temporal logic of Bochmann.
Reference: [Gahlinger 90] <author> T. Gahlinger. </author> <title> Coherence and satisfiability of waveform timing specifications. </title> <type> PhD dissertation, </type> <institution> University of Waterloo, </institution> <year> 1990. </year> <note> Research Report CS-90-11. </note>
Reference-contexts: Most of the existing event graph representations are acyclic and represent one execution of a particular system behavior. Some of the representations using this paradigm include: [Borriello 88a], <ref> [Gahlinger 90] </ref>, [Hayati et al. 88], [Khordoc et al. 91], [Martello et al. 90], [Sherman 88], [Zahir & Fichtner 90]. Cyclic event graphs are far less common, and have been used primarily to represent asynchronous circuits, e.g., [Chu 87], and to analyze their performance, e.g., [Burns 91].
Reference: [Garland & Guttag 89] <author> S. J. Garland and J. V. Guttag. </author> <title> An overview of LP: the Larch Prover. </title> <booktitle> In Proceedings of the Third International Conference on Rewriting Techniques and Applications. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1989. </year>
Reference-contexts: Therefore, most individuals use only one theorem prover. Although the formal differences between the various provers are in many cases well understood, there is little practical difference between them. Theorem provers used for circuit verification include HOL [Gordon 88], LP <ref> [Garland & Guttag 89] </ref>, LAMBDA [Fourman 90], and Boyer-Moore (see [Hunt 85]). The primary advantage of this approach to verification is the flexibility and expressiveness of the specification paradigm. Temporal issues can be fully taken into account, and complex circuits can be verified through the use of modularity and abstraction.
Reference: [Gordon 86] <author> M. Gordon. </author> <title> Why higher-order logic is a good formalism for specifying and verifying hardware. </title> <editor> In G. Milne and P. A. Subrahmanyam, editors, </editor> <title> Formal Aspects of VLSI Design. </title> <publisher> North-Holland, </publisher> <year> 1986. </year>
Reference-contexts: Work in this area is proceeding at a very rapid pace, and readers are referred to [Alur & Henzinger 92] for a summary of some of the more recent work. Higher order logics (e.g., HOL <ref> [Gordon 86] </ref>) are popular languages that can be used to express complex timing relationships. Unlike the temporal logics, in which time is represented implicitly, time is usually represented by an explicit variable.
Reference: [Gordon 88] <author> M. Gordon. </author> <title> HOL: A proof generating system for higher-order logic. </title> <editor> In G. Milne and P. A. Subrahmanyam, editors, </editor> <title> VLSI Specification, Verification and Synthesis. </title> <publisher> Kluwer Academic Publishers, </publisher> <year> 1988. </year>
Reference-contexts: Therefore, most individuals use only one theorem prover. Although the formal differences between the various provers are in many cases well understood, there is little practical difference between them. Theorem provers used for circuit verification include HOL <ref> [Gordon 88] </ref>, LP [Garland & Guttag 89], LAMBDA [Fourman 90], and Boyer-Moore (see [Hunt 85]). The primary advantage of this approach to verification is the flexibility and expressiveness of the specification paradigm.
Reference: [Granacki 86] <author> J. J. J. Granacki. </author> <title> Understanding Digital System Specifications Written in Natural Language. </title> <type> PhD dissertation, </type> <institution> University of Southern California, </institution> <month> Decem-ber </month> <year> 1986. </year> <month> 142 </month>
Reference-contexts: It is, however, a very elegant and simple specification language which, like timing diagrams, is more natural and appealing. Another interesting language that should be mentioned is PHRAN <ref> [Granacki 86] </ref>, a formal language designed to read like English. One characteristic of all of these specification languages is their focus on signal levels.
Reference: [Hansen et al. 92] <author> M. R. Hansen, Z. Chacochen, and J. Staunstrup. </author> <title> A real-time duration semantics for circuits. </title> <booktitle> Second International Workshop on Timing Issues in the Specification and Synthesis of Digital Systems (Tau), </booktitle> <month> March </month> <year> 1992. </year>
Reference-contexts: They have been used to reason about MOS VLSI circuits at the transistor level [Leeser 89], but many other logics which address the problem of modeling timing behavior have recently been developed: [Alur & Henzinger 89], [Alur & Henzinger 90], [Alur et al. 89], [Coen et al. 90], <ref> [Hansen et al. 92] </ref>, [Harel et al. 90], [Koymans 89], [Koymans 90], [Lewis 90], [Narain et al. 92], [Ostroff 90]. Many of these logics use a continuous model of time and emphasize realistic modeling, others use a more restricted model to obtain feasible verification procedures.
Reference: [Harel 92] <author> D. Harel. </author> <title> Biting the silver bullet: Toward a brighter future for system development. </title> <booktitle> IEEE Computer, </booktitle> <month> January </month> <year> 1992. </year>
Reference-contexts: Executable specification languages have recently become quite popular, because the benefits of simulation have become quite apparent. Readers may want to consult <ref> [Harel 92] </ref> for a more in-depth discussion. 4.1 OEsim: A Simulator for OEgraphs OEsim is a compiled simulator that takes as input an OEgraph (our textual specification language based on operation-event graphs) and generates an executable program linked to a simulation front-end.
Reference: [Harel et al. 88] <author> D. Harel, H. Lachover, A. Naamad, A. Pnueli, M. Politi, R. Sherman, and A. Shtul-Trauring. Statemate: </author> <title> A working environment for the development of complex reactive systems. </title> <booktitle> Proceedings of the 10th IEEE International Conference on Software Engineering, </booktitle> <month> April </month> <year> 1988. </year>
Reference-contexts: For example, computation tree logic (CTL) [Dill & Clarke 85], is used to specify temporal behavior with respect to a state graph which can be derived from a circuit specification. Temporal logic has been used to specify and verify the temporal behavior of Statecharts <ref> [Harel et al. 88] </ref>, and Waveform Algebra has 21 been used to annotate VHDL [Augustin et al. 88].
Reference: [Harel et al. 90] <author> E. Harel, O. Lichtenstein, and A. Pneulli. </author> <title> Explicit-clock temporal logic. </title> <booktitle> In Fifth Annual IEEE Symposium on Logic in Computer Science, </booktitle> <year> 1990. </year>
Reference-contexts: been used to reason about MOS VLSI circuits at the transistor level [Leeser 89], but many other logics which address the problem of modeling timing behavior have recently been developed: [Alur & Henzinger 89], [Alur & Henzinger 90], [Alur et al. 89], [Coen et al. 90], [Hansen et al. 92], <ref> [Harel et al. 90] </ref>, [Koymans 89], [Koymans 90], [Lewis 90], [Narain et al. 92], [Ostroff 90]. Many of these logics use a continuous model of time and emphasize realistic modeling, others use a more restricted model to obtain feasible verification procedures.
Reference: [Hayati et al. 88] <author> S. A. Hayati, A. C. Parker, and J. Granacki. </author> <title> Representation of control and timing behavior with applications to interface synthesis. </title> <booktitle> In IEEE International Conference on Computer Design (ICCD), </booktitle> <year> 1988. </year>
Reference-contexts: Most of the existing event graph representations are acyclic and represent one execution of a particular system behavior. Some of the representations using this paradigm include: [Borriello 88a], [Gahlinger 90], <ref> [Hayati et al. 88] </ref>, [Khordoc et al. 91], [Martello et al. 90], [Sherman 88], [Zahir & Fichtner 90]. Cyclic event graphs are far less common, and have been used primarily to represent asynchronous circuits, e.g., [Chu 87], and to analyze their performance, e.g., [Burns 91].
Reference: [Herstein 64] <author> I. N. Herstein. </author> <title> Topics in Algebra. </title> <publisher> Blaisdell Publishing Company, </publisher> <year> 1964. </year>
Reference-contexts: Notice that we use left-to-right function composition <ref> [Herstein 64] </ref>.
Reference: [Hopcroft & Ullman 79] <author> J. E. Hopcroft and J. D. Ullman. </author> <title> Introduction to Automata Theory, Languages, and Computation. </title> <publisher> Addison-Wesley Publishing Company, </publisher> <year> 1979. </year>
Reference-contexts: The formal language accepted by these automata defines the set of legal/possible system behaviors. Because legal system behaviors are often infinite, automata that accept infinite strings (e.g., !- automata) are often needed. We refer readers to an introductory text on automata theory (e.g., [Eilenberg 74] or <ref> [Hopcroft & Ullman 79] </ref>) for a more complete discussion of the models that support only sequencing relationships. An example of their use can be found in [Katzenelson & Kurshan 86] in which several commercial communication protocols are verified.
Reference: [Hulgaard et al. 93] <author> H. Hulgaard, S. M. Burns, T. Amon, and G. Borriello. </author> <title> Practical applications of an efficient time separation of events algorithm. </title> <booktitle> In IEEE International Conference on Computer-Aided Design (ICCAD), </booktitle> <month> November </month> <year> 1993. </year>
Reference-contexts: results in the removal of six edges from the process graph (the dotted edges in same result as in [Myers & Meng 92]. 7.3.2 Asynchronous Microprocessor A subset of the Caltech Asynchronous Microprocessor [Martin et al. 89] has been mod-elled and analyzed using the techniques described in this chapter (see <ref> [Hulgaard et al. 93] </ref>). The process graph for this simplified model consists of 60 events and 127 edges, and has " ? = 1 and k ? 3. <p> Furthermore, our algorithm handles a wide range of process graphs and is thus useful in a variety of domains. We presented two applications in the area of asynchronous circuit synthesis and analysis. Several other practical applications have been identified, and are discussed in <ref> [Hulgaard et al. 93] </ref>. Because this work addresses a fundamental problem in the analysis of concurrent systems, i.e., determining how synchronization affects temporal behavior, it may serve as a foundation upon which other analysis tools can be built. <p> For example, the verification algorithm of Chapter 7 can be used to optimize the synthesis of asynchronous circuits, simplify combinational and sequential 134 logic by extracting temporal don't care information, and focus optimization efforts in data-path synthesis by generating useful scheduling constraints (see <ref> [Hulgaard et al. 93] </ref>). 8.1.4 Verification Timing verification is a very difficult problem, and often NP-complete even when both the functionality and the timing constraints are specified using a very simple and restrictive semantics (e.g., see [McMillan & Dill 92]).
Reference: [Hunt 85] <author> W. A. Hunt, Jr. FM8501: </author> <title> a verified microprocessor. </title> <type> Technical Report ICSCA-CMP-47, </type> <institution> University of Texas at Austin, </institution> <year> 1985. </year>
Reference-contexts: Although the formal differences between the various provers are in many cases well understood, there is little practical difference between them. Theorem provers used for circuit verification include HOL [Gordon 88], LP [Garland & Guttag 89], LAMBDA [Fourman 90], and Boyer-Moore (see <ref> [Hunt 85] </ref>). The primary advantage of this approach to verification is the flexibility and expressiveness of the specification paradigm. Temporal issues can be fully taken into account, and complex circuits can be verified through the use of modularity and abstraction.
Reference: [Ishiura et al. 89] <author> N. Ishiura, M. Takahashi, and S. Yajima. </author> <title> Time-symbolic simulation for accurate timing verification of asynchronous behavior of logic circuits. </title> <booktitle> In 26th ACM/IEEE Design Automation Conference, </booktitle> <month> June </month> <year> 1989. </year>
Reference-contexts: If propagation delays of the gates are taken into account, hazards can be detected using a symbolic simulation technique in which the propagation delays are considered to be symbolic variables (see <ref> [Ishiura et al. 89] </ref>). A related technique involves the use of an extended value system, in which special values are used to indicate unknown or indeterminate values (e.g., the value X is used to indicate inputs which are either zero or one).
Reference: [Ishiura et al. 90] <author> N. Ishiura, H. Yasuura, and S. Yajima. NES: </author> <title> The behavioral model for the formal semantics of a hardware design language UDL/I. </title> <booktitle> In 27th ACM/IEEE Design Automation Conference, </booktitle> <month> June </month> <year> 1990. </year>
Reference-contexts: However, zero delay elements are very valuable because they support modularity (i.e., the ability to hook two components together) and abstraction. Many specification languages support the specification of zero delay elements. Zero delay semantics are often quite subtle (e.g., see <ref> [Ishiura et al. 90] </ref>) yet removing them can create other problems. For example, the language VHDL does not support a zero time delay. This has caused problems for translation schemes from domain specific application languages with zero time delay into VHDL [Vahid & Gajski 91].
Reference: [Jaffar et al. 92] <author> J. Jaffar, S. Michaylov, P. Stuckey, and R. Yap. </author> <title> The CLP(R) language and system. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 14(3) </volume> <pages> 339-395, </pages> <month> July </month> <year> 1992. </year> <month> 143 </month>
Reference-contexts: It is possible that a more efficient version of the verifier could be constructed but the version of CLP (R) that we have used <ref> [Jaffar et al. 92] </ref> has proven to be quite adequate. The verification tool takes as input a description of the process and a list of constraints to be verified.
Reference: [Jahanian & Mok 86] <author> F. Jahanian and A. K.-L. Mok. </author> <title> Safety analysis of timing properties of real-time systems. </title> <journal> IEEE Transactions on Software Engineering, </journal> <month> September </month> <year> 1986. </year>
Reference-contexts: In order to capture more complicated timing constraints (e.g., ones that appear as annotations to timing diagrams) event graphs are not sufficient, and thus more powerful specification languages are needed. An approach that uses timing diagrams and annotated event structures is presented in [Subramanyam 90]. Real-Time Logic <ref> [Jahanian & Mok 86] </ref> is a formal logic based on the event paradigm that is quite unlike the temporal logics previously described. <p> Each occurrence of an event has an index, and this index can be used to specify which discrete events are being constrained. In this case, (e.g., Real-Time Logic <ref> [Jahanian & Mok 86] </ref>, or ATCSL [Doukas 91]) one could specify a constraint "from X to the 2 nd occurrence of Y in the loop" by constraining the i th occurrence of X with the ((i 1)n + 2) th occurrence of Y where n is the fixed iteration count for
Reference: [Kara et al. 88] <author> A. Kara, R. Rastogi, and K. Kawamura. </author> <title> An expert system to automate timing design. </title> <booktitle> IEEE Design and Test of Computers, </booktitle> <pages> pages 28 - 40, </pages> <month> Oct </month> <year> 1988. </year>
Reference-contexts: If some of the inputs (such as data) are not fully specified, and some support for symbolic simulation is included, these tools can analyze a large set of system behaviors. Most incomplete verifiers (e.g., SCALD [McWilliams 80], and TDS <ref> [Kara et al. 88] </ref>) provide little support for specifying and verifying temporal properties other than simple setup and hold constraints.
Reference: [Katzenelson & Kurshan 86] <author> J. Katzenelson and R. P. Kurshan. </author> <title> S/R: A language for specifying protocols and other coordinating processes. </title> <booktitle> In Proceedings of the 5th Annual IEEE International Conference on Computer Communication, </booktitle> <year> 1986. </year>
Reference-contexts: We refer readers to an introductory text on automata theory (e.g., [Eilenberg 74] or [Hopcroft & Ullman 79]) for a more complete discussion of the models that support only sequencing relationships. An example of their use can be found in <ref> [Katzenelson & Kurshan 86] </ref> in which several commercial communication protocols are verified. These techniques have also been used to produce finite automata models for analog circuits [Kurshan & McMillan 91].
Reference: [Khordoc et al. 91] <author> K. Khordoc, M. Dufresne, and E. Cerny. </author> <title> A stimulus response system based on hierarchical timing diagrams. </title> <booktitle> Proceedings of the International Conference on Computer Aided Design, </booktitle> <month> November </month> <year> 1991. </year>
Reference-contexts: Formalized timing diagrams have also been used in timing verification to specify timing constraints which should be checked during simulation <ref> [Khordoc et al. 91] </ref>. Even though few existing tools use timing diagrams as a specification language, the paradigm has the potential to be very well accepted by designers. <p> Designers currently specify complex timing relationships by annotating diagrams with informal text. These constraints need to be formally specified, but there are many complex timing relationships that cannot be specified using the languages of [Borriello 88b] or <ref> [Khordoc et al. 91] </ref>. These languages and their underlying internal representations lack the necessary expressive power. Furthermore, timing diagrams specify signal waveforms, not circuit functionality or structure. <p> Most of the existing event graph representations are acyclic and represent one execution of a particular system behavior. Some of the representations using this paradigm include: [Borriello 88a], [Gahlinger 90], [Hayati et al. 88], <ref> [Khordoc et al. 91] </ref>, [Martello et al. 90], [Sherman 88], [Zahir & Fichtner 90]. Cyclic event graphs are far less common, and have been used primarily to represent asynchronous circuits, e.g., [Chu 87], and to analyze their performance, e.g., [Burns 91]. <p> Some specification languages are based on the event paradigm but are also closely related to the paradigms previously discussed. Timing diagrams are, in fact, essentially event-based specifications event graphs are used to provide a formal underlying semantics (e.g., <ref> [Borriello 88b, Khordoc et al. 91] </ref>). In order to capture more complicated timing constraints (e.g., ones that appear as annotations to timing diagrams) event graphs are not sufficient, and thus more powerful specification languages are needed. <p> Many representations can express most aspects of a particular circuit's timing behavior, but find that there are some specific timing constraints or functionalities they cannot express (e.g., [Borriello 88b], <ref> [Khordoc et al. 91] </ref>, [Martello et al. 90]). Another serious problem is that structure cannot be explicitly represented in the specification. <p> Of course, one advantage of these restrictions is that the timing constraints are simple and easy to understand. Timing analysis algorithms can then be borrowed from graph theory, e.g., longest paths, PERT analysis, compaction, etc. ([Borriello 88b], <ref> [Khordoc et al. 91] </ref>, [Martello et al. 90]). 2.3.3 Extending the Basic Model An expressive event-based representation must contain three important elements: * the ability to express a rich functional semantics, * a clean integration of structural aspects into the specification, and * a syntax to describe timing constraints between events. <p> This approach is of limited use in a specification language since it assumes that the circuit's behavior can be statically described. This approach may have some use in validating simulations with known expected behavior <ref> [Khordoc et al. 91] </ref>. However, if circuit behavior is repetitive then the representation will be cyclic. Thus, event nodes inevitably represent more than one signal transition and the problems described above must be addressed.
Reference: [Koymans 89] <author> R. Koymans. </author> <title> Specifying Message Passing and Time Critical Systems with Temporal Logic. </title> <type> PhD dissertation, </type> <institution> Eindhoven University of Technology, </institution> <year> 1989. </year>
Reference-contexts: about MOS VLSI circuits at the transistor level [Leeser 89], but many other logics which address the problem of modeling timing behavior have recently been developed: [Alur & Henzinger 89], [Alur & Henzinger 90], [Alur et al. 89], [Coen et al. 90], [Hansen et al. 92], [Harel et al. 90], <ref> [Koymans 89] </ref>, [Koymans 90], [Lewis 90], [Narain et al. 92], [Ostroff 90]. Many of these logics use a continuous model of time and emphasize realistic modeling, others use a more restricted model to obtain feasible verification procedures.
Reference: [Koymans 90] <author> R. Koymans. </author> <title> Specifying real-time properties with metric temporal logic. </title> <journal> Journal of Real-time Systems, </journal> <volume> 2, </volume> <year> 1990. </year>
Reference-contexts: VLSI circuits at the transistor level [Leeser 89], but many other logics which address the problem of modeling timing behavior have recently been developed: [Alur & Henzinger 89], [Alur & Henzinger 90], [Alur et al. 89], [Coen et al. 90], [Hansen et al. 92], [Harel et al. 90], [Koymans 89], <ref> [Koymans 90] </ref>, [Lewis 90], [Narain et al. 92], [Ostroff 90]. Many of these logics use a continuous model of time and emphasize realistic modeling, others use a more restricted model to obtain feasible verification procedures.
Reference: [Ku & de Micheli 90] <author> D. Ku and G. de Micheli. </author> <title> HardwareC | A language for hardware design, version 2.0. </title> <type> Technical Report TR CSL-TR-90-419, </type> <institution> Computer Systems Laboratory, Stanford University, </institution> <month> April </month> <year> 1990. </year>
Reference-contexts: Minimum and maximum separation times between system activites are specified using labels attached to program statements. A similar approach 25 (see Figure 2.4) is used by the more recent language HardwareC <ref> [Ku & de Micheli 90] </ref>. - /* perform tasks */ rd: data = read (input_port); op: result = some_function (data); wr: write output_port = result; /* specify timing constraints */ constraint mintime from rd to op = 3 cycles; constraint maxtime from op to wr = 5 cycles; constraint maxtime from
Reference: [Ku 91] <author> D. C.-L. Ku. </author> <title> Constrained Synthesis and Optimization of Digital Integrated Circuits from Behavioral Specifications. </title> <type> PhD dissertation, </type> <institution> Stanford University, </institution> <year> 1991. </year> <month> CSL-TR-91-476. </month>
Reference-contexts: Scheduling algorithms are used to assign each program statement to a specific control step (cycle). The algorithm used for HardwareC is quite novel in that it can handle external synchronizations and unbounded delays between system activities <ref> [Ku 91] </ref>. Of course, in both cases, the timing constraints need to be taken into account in order to produce a valid schedule. Iterative and conditional behavior are specified using hierarchy.
Reference: [Kurshan & McMillan 91] <author> R. Kurshan and K. L. McMillan. </author> <title> Analysis of digital circuits through symbolic reduction. </title> <journal> IEEE Transactions on Computer-Aided Design of Integrated Circuits, </journal> <month> November </month> <year> 1991. </year>
Reference-contexts: An example of their use can be found in [Katzenelson & Kurshan 86] in which several commercial communication protocols are verified. These techniques have also been used to produce finite automata models for analog circuits <ref> [Kurshan & McMillan 91] </ref>. Timed Automata are a class of finite automata defined by [Alur & Dill 90] that can express hard real-time constraints, e.g., "the acknowledgment should occur within 5 seconds." They are based on !-automata augmented with a finite set of timers that record the passage of time.
Reference: [Lai 83] <author> K.-W. Lai. </author> <title> Test program compiler a high level test program specification language. </title> <booktitle> In IEEE International Conference on Computer-Aided Design (ICCAD), </booktitle> <pages> pages 30-31, </pages> <month> November </month> <year> 1983. </year>
Reference-contexts: For example, if two signal transitions are constrained relative to a common transition, it is possible that a constraint between the two signals could result in an inconsistency. Timing diagram editors have also been developed for use as an interface to circuit testers <ref> [Arnold 85, Lai 83] </ref>. Timing diagrams constrain circuit behavior in a specific context, i.e., they represent 17 one possible execution, assuming that a particular sequence of signal transitions occur.
Reference: [Lamport 80] <author> L. Lamport. </author> <title> "sometime" is sometimes "not never". </title> <booktitle> ACM 7th Principles of Programming Languages, </booktitle> <year> 1980. </year>
Reference-contexts: Comparisons of the formal expressive power of some of these logics have been made (e.g., for a comparison of branching vs. linear-time temporal logic see <ref> [Lamport 80] </ref> or [Emerson & Halpern 86]). 2.2.3 Automata and Trace Algebras As in the case of temporal logics, simple automata models can be used for abstract temporal modeling, in which only the sequence of events is important.
Reference: [Lawler 76] <author> E. L. Lawler. </author> <title> Combinatorial Optimization: Networks and Matroids. </title> <publisher> Holt, Rinehart and Winston, </publisher> <address> New York, </address> <year> 1976. </year>
Reference-contexts: A 123 maximum ratio cycle c is a cycle with ratio d (c)="(c) equal to that of the maximum ratio r ? : c a simple cycle in G 0 d (c) : The behavior of the m-values is best illustrated by a classical graph problem <ref> [Lawler 76] </ref>. port 1 day circuit 1 day circuit $110 1 day circuit $10 $100 Consider a cargo steamer whose purpose is to maximize profit over an n-day voyage.
Reference: [Lazowska et al. 84] <author> E. Lazowska, J. Zahorjan, G. S. Graham, and K. C. Sevcik. </author> <title> Quantitative System Performance: Computer System Analysis Using Queing Network Models. </title> <publisher> Prentice Hall, </publisher> <year> 1984. </year> <month> 144 </month>
Reference-contexts: At higher levels of abstraction, response time constraints and communication protocols require that constraints must always be met, i.e., it is not acceptable to meet the constraints "97% of the time." Our emphasis is thus on non-stochastic models, and not on queueing networks and quantitative performance evaluation (e.g., <ref> [Lazowska et al. 84] </ref>). The expressive power of a specification language greatly affects the complexity of the formal methods for which it is the base. For example, consider a specification language for circuits that will be implemented using a microcontroller.
Reference: [Leeser 89] <author> M. E. Leeser. </author> <title> Reasoning about the function and timing of integrated circuits with interval temporal logic. </title> <journal> IEEE Transactions on Computer-Aided Design of Integrated Circuits, </journal> <volume> 8(12), </volume> <month> December </month> <year> 1989. </year>
Reference-contexts: Interval temporal logics have been developed to address the problem of specifying that an action should occur in a specific time interval [Allen 83, Moszkowski 85]. They have been used to reason about MOS VLSI circuits at the transistor level <ref> [Leeser 89] </ref>, but many other logics which address the problem of modeling timing behavior have recently been developed: [Alur & Henzinger 89], [Alur & Henzinger 90], [Alur et al. 89], [Coen et al. 90], [Hansen et al. 92], [Harel et al. 90], [Koymans 89], [Koymans 90], [Lewis 90], [Narain et al. <p> Higher order logics (e.g., HOL [Gordon 86]) are popular languages that can be used to express complex timing relationships. Unlike the temporal logics, in which time is represented implicitly, time is usually represented by an explicit variable. For example (see <ref> [Leeser 89] </ref>), consider the definition of an inverter having a propagation delay of m 20 time units: invert (In; Out; m) j 8t Out (t + m) = :In (t): Time is explicitly quantified in this formulation.
Reference: [Leeser et al. 91] <author> M. Leeser, A. Takach, and W. Wolf. </author> <title> Behavior FSMs for high-level synthesis and verification. </title> <editor> In P. A. Subrahmanyam, editor, </editor> <title> Formal Methods in VLSI Design. </title> <publisher> Springer-Verlag, </publisher> <year> 1991. </year>
Reference-contexts: One advantage of this specification language is that complex systems can be 22 specified by composing together simpler system components. A new model for concurrent systems, behavior finite-state machines (BFSMs) <ref> [Leeser et al. 91] </ref> has special language constructs for specifying communication between interacting automata.
Reference: [Lewis 90] <author> H. R. Lewis. </author> <title> A logic of concrete time intervals. </title> <booktitle> In Fifth Annual IEEE Symposium on Logic in Computer Science, </booktitle> <year> 1990. </year>
Reference-contexts: at the transistor level [Leeser 89], but many other logics which address the problem of modeling timing behavior have recently been developed: [Alur & Henzinger 89], [Alur & Henzinger 90], [Alur et al. 89], [Coen et al. 90], [Hansen et al. 92], [Harel et al. 90], [Koymans 89], [Koymans 90], <ref> [Lewis 90] </ref>, [Narain et al. 92], [Ostroff 90]. Many of these logics use a continuous model of time and emphasize realistic modeling, others use a more restricted model to obtain feasible verification procedures.
Reference: [Lynch & Attiya 92] <author> N. Lynch and H. Attiya. </author> <title> Using mappings to prove timing properties. </title> <journal> Distributed Computing, </journal> <volume> 6, </volume> <year> 1992. </year>
Reference-contexts: The Input/Output Automata of [Lynch & Tuttle 89] have been extended to support more exact timing requirements by [Bestavros 90], [Merritt et al. 91], and <ref> [Lynch & Attiya 92] </ref>. One advantage of this specification language is that complex systems can be 22 specified by composing together simpler system components. A new model for concurrent systems, behavior finite-state machines (BFSMs) [Leeser et al. 91] has special language constructs for specifying communication between interacting automata.
Reference: [Lynch & Tuttle 89] <author> N. A. Lynch and M. R. Tuttle. </author> <title> An introduction to input/output automata. </title> <journal> CWI Quarterly, </journal> <volume> 2(3), </volume> <month> September </month> <year> 1989. </year>
Reference-contexts: The Input/Output Automata of <ref> [Lynch & Tuttle 89] </ref> have been extended to support more exact timing requirements by [Bestavros 90], [Merritt et al. 91], and [Lynch & Attiya 92]. One advantage of this specification language is that complex systems can be 22 specified by composing together simpler system components.
Reference: [Malachi & Owicki 81] <author> Y. Malachi and S. S. Owicki. </author> <title> Temporal Specifications of Self-Timed Systems. </title> <editor> In H. T. Kung et al., editors, </editor> <title> VLSI Systems and Computations. </title> <publisher> Computer Science Press, </publisher> <address> Rockville MD, </address> <year> 1981. </year>
Reference-contexts: They have been used by many different researchers for specifying and verifying hardware (e.g., [Bennett 86], [Bochmann 82], [Browne et al. 86], [Clarke et al. 86], [Dill & Clarke 85], [Fujita et al. 83], [Fusaoka et al. 84], <ref> [Malachi & Owicki 81] </ref>). Figure 2.3 contains a four phase communication protocol specified using the linear-time propositional temporal logic of Bochmann.
Reference: [Martello & Levitan 93] <author> A. Martello and S. Levitan. </author> <title> Temporal analysis of time bounded digital systems. </title> <booktitle> In Proceedings of the IFIP WG10.2 Advanced Research Working Conference on Correct Hardware Design Methodologies (CHARME), </booktitle> <month> May </month> <year> 1993. </year>
Reference-contexts: This technique creates a state transition graph, but only creates new states when the operation of the system will change based on different choices for propagation delays. Examples of this approach are [Devadas et al. 92] and <ref> [Martello & Levitan 93] </ref>. 5.4 Timing Verification Timing verification is able to provide guarantees about the temporal behavior of a system and is thus very useful in design synthesis, because these guarantees can be used to help guide the process of transforming a design from an abstract specification into a realizable
Reference: [Martello et al. 90] <author> A. Martello, S. Levitan, and D. Chiarulli. </author> <title> Timing verification using hdtv. </title> <booktitle> In 27th ACM/IEEE Design Automation Conference, </booktitle> <month> June </month> <year> 1990. </year>
Reference-contexts: Most of the existing event graph representations are acyclic and represent one execution of a particular system behavior. Some of the representations using this paradigm include: [Borriello 88a], [Gahlinger 90], [Hayati et al. 88], [Khordoc et al. 91], <ref> [Martello et al. 90] </ref>, [Sherman 88], [Zahir & Fichtner 90]. Cyclic event graphs are far less common, and have been used primarily to represent asynchronous circuits, e.g., [Chu 87], and to analyze their performance, e.g., [Burns 91]. <p> Many representations can express most aspects of a particular circuit's timing behavior, but find that there are some specific timing constraints or functionalities they cannot express (e.g., [Borriello 88b], [Khordoc et al. 91], <ref> [Martello et al. 90] </ref>). Another serious problem is that structure cannot be explicitly represented in the specification. Events are "logical transitions on wires," but there are a number of problems resolving the basic issue that a wire is a continuous entity, not a collection of discrete events. <p> Of course, one advantage of these restrictions is that the timing constraints are simple and easy to understand. Timing analysis algorithms can then be borrowed from graph theory, e.g., longest paths, PERT analysis, compaction, etc. ([Borriello 88b], [Khordoc et al. 91], <ref> [Martello et al. 90] </ref>). 2.3.3 Extending the Basic Model An expressive event-based representation must contain three important elements: * the ability to express a rich functional semantics, * a clean integration of structural aspects into the specification, and * a syntax to describe timing constraints between events. <p> Alternatively, we could use formal verification techniques (the subject of the next two chapters) to detect the original problem and verify that the proposed solution is correct. This is precisely the approach taken by <ref> [Martello et al. 90] </ref> from which we have taken this example. We should point out, however, that verification is not a substitute for simulation. Simulation allows us to validate our specification and to understand how to use the LS222 in our design. <p> Most of the analysis in this area has dealt with acyclic event graphs, and unfortunately even apparently simple classes of verification problems are NP-complete [McMillan & Dill 92]. In <ref> [Martello et al. 90] </ref> a cyclic system representing the LS222 of Section 4.3 is verified, but the verification technique is of limited applicability due to a restricted semantics that requires systems to be specified using a very simple event-graph.
Reference: [Martin et al. 89] <author> A. Martin, S. Burns, T. Lee, D. Borkovic, and P. Hazewindus. </author> <title> The design of an asynchronous microprocessor. </title> <editor> In C. Seitz, editor, </editor> <booktitle> Advanced Research in VLSI: Proceedings of the Decennial Caltech Conference on VLSI, </booktitle> <pages> pages 351-373, </pages> <address> Cambridge, MA, 1989. </address> <publisher> MIT Press. </publisher>
Reference-contexts: Clearly, being able to obtain tight bounds potentially enables the removal of more edges. One of the examples in [Myers & Meng 92] is a memory management unit (MMU) designed to interface to the Caltech Asynchronous Microprocessor <ref> [Martin et al. 89] </ref>. The process graph (for one of the possible execution modes of the MMU) consists of 16 events and 23 edges and is shown in Figure 7.18. For the chosen delay intervals, k ? = 1 and " ? = 1. <p> The analysis results in the removal of six edges from the process graph (the dotted edges in same result as in [Myers & Meng 92]. 7.3.2 Asynchronous Microprocessor A subset of the Caltech Asynchronous Microprocessor <ref> [Martin et al. 89] </ref> has been mod-elled and analyzed using the techniques described in this chapter (see [Hulgaard et al. 93]). The process graph for this simplified model consists of 60 events and 127 edges, and has " ? = 1 and k ? 3.
Reference: [McFarland 78] <author> M. C. McFarland. </author> <title> The value trace: A database for automated digital design. </title> <type> Technical Report TR DRC-01-04-80, </type> <institution> Engineering Design Research Center, Carnegie Mellon University, </institution> <month> December </month> <year> 1978. </year>
Reference-contexts: This approach is, however, very ad-hoc, and a more structured and organized method for expressing constraints is clearly needed. Behavioral Synthesis with Interfaces (BSI) [Nestor 87] is an extension to ISPS [Bar-bacci 81] and the Value-Trace <ref> [McFarland 78] </ref> that has a higher-level construct for specifying timing constraints. Minimum and maximum separation times between system activites are specified using labels attached to program statements.
Reference: [McFarland 90] <author> M. C. McFarland. Cpa: </author> <title> Giving an account of timed system behavior. </title> <booktitle> First International Workshop on Timing Issues in the Specification and Synthesis of Digital Systems (Tau '90), </booktitle> <month> August </month> <year> 1990. </year>
Reference-contexts: The logic supports both existential and universal quantification of integer variables that are used to identify events by their occurrence index. This indexing approach is also used in the language ATCSL [Doukas 91]. The language CPA <ref> [McFarland 90] </ref> is another formal logic based on the event paradigm. It uses a fully declarative semantics to describe a large class of system behaviors.
Reference: [McFarland et al. 90] <author> M. McFarland, A. Parker, and R. Camposano. </author> <title> The high-level synthesis of digital systems. </title> <booktitle> In Proceedings of the IEEE, </booktitle> <volume> volume 78, </volume> <month> Feb </month> <year> 1990. </year>
Reference-contexts: Hardware description languages characteristically include very little support for the specification of timing requirements. Most are based on a synchronous model that limits the circuits that can be described. HDLs are typically used to generate data-flow graphs which have formed the basis of most high-level synthesis research (see <ref> [McFarland et al. 90] </ref>). Because HDLs have been designed to express circuit functionality, temporal constraints are often simply embedded in the design specification. In order to describe the constraints on an interface, a specification that exhibits proper behavior is specified.
Reference: [McGeer & Brayton 91] <author> P. C. McGeer and R. K. Brayton. </author> <title> Integrating functional and temporal domains in logic design. </title> <publisher> Kluwer Academic Publishers, </publisher> <year> 1991. </year> <month> 145 </month>
Reference-contexts: Some of these tools require human assistance (e.g., in CRYSTAL [Ousterhout 85] users need to identify the direction of current flow for some transistors) but most are fully automated. Many interesting problems with respect to timing analysis have been explored (e.g., the false-path problem, see <ref> [McGeer & Brayton 91] </ref>) and we will not attempt to further categorize work in this area. Our interests with respect to timing analysis are in the area of interface verification, which relies on event-based abstractions as opposed to gates and transistors.
Reference: [McMillan & Dill 92] <author> K. McMillan and D. L. Dill. </author> <title> Algorithms for interface timing verification. </title> <booktitle> In IEEE International Conference on Computer Design (ICCD), </booktitle> <year> 1992. </year>
Reference-contexts: An event graph (see Section 2.3) is used to capture the events and propagation delays of the system. Shortest path algorithms have been used to solve problems that contain only linear 79 constraints, e.g., [Borriello 88b] and [Brzozowski et al. 91]. Both <ref> [McMillan & Dill 92] </ref> and [Vanbekbergen et al. 92] provide an overview of the various types of event graphs and timing constraints for which verification algorithms have been developed (both authors present algorithms for handling non-linear constraints). <p> Most of the analysis in this area has dealt with acyclic event graphs, and unfortunately even apparently simple classes of verification problems are NP-complete <ref> [McMillan & Dill 92] </ref>. In [Martello et al. 90] a cyclic system representing the LS222 of Section 4.3 is verified, but the verification technique is of limited applicability due to a restricted semantics that requires systems to be specified using a very simple event-graph. <p> Loose bounds that may not enable all possible optimizations were obtained by [Myers & Meng 92] who used the analysis to optimize the implementation of speed-dependent asynchronous circuits (see Section 7.3). Both <ref> [McMillan & Dill 92] </ref> and [Vanbekbergen et al. 92] handle only acyclic graphs. However, they provide a theoretical foundation upon which our solution is built. <p> For our example, we have E 0 = fa; bg ae [4;10];1 [1;2];0 [1;6];1 [5;20];1 oe 1 [Myers & Meng 92] introduced a similarly modified system. The model can also be viewed as an extension of <ref> [McMillan & Dill 92] </ref> and [Vanbekbergen et al. 92], where we consider cyclic max-only or type-2 graphs. <p> from the transformation o (s ff ) o (t ff (fi) ) ffi (i.e., by swapping s and t, negating fi, and negating the solution ). 7.1.4 Algorithm for a Finite Unfolded Process Graph We build our solution to this problem on a variation of a graph algorithm developed in <ref> [McMillan & Dill 92] </ref> that applies only to finite unfolded graphs. In Section 7.2 we will generalize this algorithm to infinite unfolded graphs. <p> We will not provide a formal proof of this algorithm (see <ref> [McMillan & Dill 92] </ref>) but do provide an informal explanation. 7.1.5 Informal Justification of the Algorithm Informally, to maximize the value of o (t ff ) o (s fffi ) we need to "find an execution" that maximizes o (t ff ) and minimizes o (s fffi ). <p> information, and focus optimization efforts in data-path synthesis by generating useful scheduling constraints (see [Hulgaard et al. 93]). 8.1.4 Verification Timing verification is a very difficult problem, and often NP-complete even when both the functionality and the timing constraints are specified using a very simple and restrictive semantics (e.g., see <ref> [McMillan & Dill 92] </ref>). In this dissertation, we have presented two theoretically exponential algorithms for verifying the timing behavior of concurrent systems. However, in practice, both algorithms are quite efficient, and represent major contributions.
Reference: [McWilliams 80] <author> T. McWilliams. </author> <title> Verification of Timing Constraints on Large Digital Systems. </title> <type> PhD dissertation, </type> <institution> Lawrence Livermore Laboratory, </institution> <month> May </month> <year> 1980. </year>
Reference-contexts: Incomplete verifiers formally compare the results of simulation with the design specification. If some of the inputs (such as data) are not fully specified, and some support for symbolic simulation is included, these tools can analyze a large set of system behaviors. Most incomplete verifiers (e.g., SCALD <ref> [McWilliams 80] </ref>, and TDS [Kara et al. 88]) provide little support for specifying and verifying temporal properties other than simple setup and hold constraints.
Reference: [Merlin 74] <author> P. Merlin. </author> <title> A study of the recoverability of computer systems. </title> <type> PhD dissertation, </type> <institution> University of California, </institution> <year> 1974. </year>
Reference-contexts: A number of timed Petri net models have been developed that incorporate non-probabilistic (e.g., fixed or bounded) delays, e.g., [Ramamoorthry & Ho 80], [Ramchandani 74], <ref> [Merlin 74] </ref>, [Coolahan & Roussopoulos 85], [Cohen et al. 89], [Andre 91], [Zuberek 91]. Some specification languages are based on the event paradigm but are also closely related to the paradigms previously discussed.
Reference: [Merritt et al. 91] <author> M. Merritt, F. Modugno, and M. Tuttle. </author> <title> Time constrained automata. </title> <editor> In J. Beaten and J. Groote, editors, </editor> <booktitle> Proceedings of CONCUR 91, volume 257 of Lecture Notes in Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1991. </year>
Reference-contexts: The Input/Output Automata of [Lynch & Tuttle 89] have been extended to support more exact timing requirements by [Bestavros 90], <ref> [Merritt et al. 91] </ref>, and [Lynch & Attiya 92]. One advantage of this specification language is that complex systems can be 22 specified by composing together simpler system components.
Reference: [Meyer 85] <author> B. Meyer. </author> <title> On formalism in specification. </title> <journal> IEEE Software, </journal> <month> January </month> <year> 1985. </year>
Reference-contexts: One of the primary benefits of formalizing a specification is that any ambiguity can be resolved. Specification languages thus need to be structured so that every "well formed" specification is inherently unambiguous. There are many other benefits of formal specification. We refer readers to <ref> [Meyer 85] </ref> for a more detailed discussion. We also refer readers to [Wing 90] for a summary of formal methods and formal design specification. 2.1.2 Expressiveness Specification languages are designed for a particular domain of applicability, and need to have enough expressive power to represent designs from that domain.
Reference: [Moszkowski 85] <author> B. Moszkowski. </author> <title> A temporal logic for multilevel reasoning about hardware. </title> <booktitle> IEEE Computer, </booktitle> <month> February </month> <year> 1985. </year>
Reference-contexts: Interval temporal logics have been developed to address the problem of specifying that an action should occur in a specific time interval <ref> [Allen 83, Moszkowski 85] </ref>.
Reference: [Moszkowski 86] <author> B. Moszkowski. </author> <title> Executing temporal logic programs. </title> <type> Technical report, </type> <institution> Cambridge University, U.K., </institution> <year> 1986. </year>
Reference-contexts: For example, how does a designer specify a set of acceptable transition sequences/traces? Almost all of these languages provide very little with respect to user validation of the specification. There are, of course, some notable exceptions (e.g., the simulator Tempura for Interval Temporal Logic <ref> [Moszkowski 86] </ref>), and in many cases there is no reason that a validation tool could not be built, it is just that this area has yet to reach maturity. 2.2.4 Hardware Description Languages Our next paradigm of interest is quite dissimilar, in that the specification languages are weak with regard to
Reference: [Murata 89] <author> T. Murata. </author> <title> Petri nets: properties, analysis, </title> <booktitle> and applications. Proceedings of the IEEE, </booktitle> <volume> 77(4) </volume> <pages> 541-580, </pages> <month> April </month> <year> 1989. </year>
Reference-contexts: Cyclic event graphs are far less common, and have been used primarily to represent asynchronous circuits, e.g., [Chu 87], and to analyze their performance, e.g., [Burns 91]. A closely related and well known representation is the Petri net, which has been used extensively to model concurrent systems (see <ref> [Murata 89] </ref> or [Brauer et al. 87] for a summary). Many different models of time have been defined for Petri nets, the most popular being stochastic delays used for probabilistic performance evaluation (see [Ajmone Marsan 89]).
Reference: [Myers & Meng 92] <author> C. Myers and T. H.-Y. Meng. </author> <title> Synthesis of timed asynchronous circuits. </title> <booktitle> In IEEE International Conference on Computer Design (ICCD), </booktitle> <month> Septem-ber </month> <year> 1992. </year>
Reference-contexts: Other approaches to the problem of finding bounds on the separation in time of two events have either been inexact or based on a more restrictive graph topology. Loose bounds that may not enable all possible optimizations were obtained by <ref> [Myers & Meng 92] </ref> who used the analysis to optimize the implementation of speed-dependent asynchronous circuits (see Section 7.3). Both [McMillan & Dill 92] and [Vanbekbergen et al. 92] handle only acyclic graphs. However, they provide a theoretical foundation upon which our solution is built. <p> Each edge is labelled with two objects, the delay range [d; D] (integers with 0 d D), and the occurrence index offset ". For our example, we have E 0 = fa; bg ae [4;10];1 [1;2];0 [1;6];1 [5;20];1 oe 1 <ref> [Myers & Meng 92] </ref> introduced a similarly modified system. The model can also be viewed as an extension of [McMillan & Dill 92] and [Vanbekbergen et al. 92], where we consider cyclic max-only or type-2 graphs. <p> This idea can be used to remove redundant circuitry in asynchronous circuits given (conservative) bounds on the actual delays of a speed-independent design. Superfluous edges can be removed by analyzing the process graph corresponding to the circuit. This approach has been taken by Myers and Meng <ref> [Myers & Meng 92] </ref> who use an inexact timing analysis algorithm, i.e., the algorithm doesn't necessarily give tight bounds on separation times. Clearly, being able to obtain tight bounds potentially enables the removal of more edges. One of the examples in [Myers & Meng 92] is a memory management unit (MMU) <p> This approach has been taken by Myers and Meng <ref> [Myers & Meng 92] </ref> who use an inexact timing analysis algorithm, i.e., the algorithm doesn't necessarily give tight bounds on separation times. Clearly, being able to obtain tight bounds potentially enables the removal of more edges. One of the examples in [Myers & Meng 92] is a memory management unit (MMU) designed to interface to the Caltech Asynchronous Microprocessor [Martin et al. 89]. The process graph (for one of the possible execution modes of the MMU) consists of 16 events and 23 edges and is shown in Figure 7.18. <p> Analyzing the 23 edges using our exact algorithm takes on average :1 CPU seconds on a SPARC 2 for each edge. The analysis results in the removal of six edges from the process graph (the dotted edges in same result as in <ref> [Myers & Meng 92] </ref>. 7.3.2 Asynchronous Microprocessor A subset of the Caltech Asynchronous Microprocessor [Martin et al. 89] has been mod-elled and analyzed using the techniques described in this chapter (see [Hulgaard et al. 93]).
Reference: [Narain et al. 92] <author> S. Narain, J. Cameron, Y.-J. Lin, and R. C. Sekar. </author> <title> A high-level real-time temporal logic. Bellcore Internal Publication, </title> <month> March </month> <year> 1992. </year>
Reference-contexts: transistor level [Leeser 89], but many other logics which address the problem of modeling timing behavior have recently been developed: [Alur & Henzinger 89], [Alur & Henzinger 90], [Alur et al. 89], [Coen et al. 90], [Hansen et al. 92], [Harel et al. 90], [Koymans 89], [Koymans 90], [Lewis 90], <ref> [Narain et al. 92] </ref>, [Ostroff 90]. Many of these logics use a continuous model of time and emphasize realistic modeling, others use a more restricted model to obtain feasible verification procedures.
Reference: [Nestor 87] <author> J. Nestor. </author> <title> Specification and Synthesis of Digital Systems with Interfaces. </title> <type> PhD dissertation, </type> <institution> Carnegie-Mellon University, </institution> <year> 1987. </year> <month> CMUCAD-87-10. </month>
Reference-contexts: For example, in VHDL, a separate process can monitor the two signal transitions and report an error (during simulation) when a timing violation occurs. This approach is, however, very ad-hoc, and a more structured and organized method for expressing constraints is clearly needed. Behavioral Synthesis with Interfaces (BSI) <ref> [Nestor 87] </ref> is an extension to ISPS [Bar-bacci 81] and the Value-Trace [McFarland 78] that has a higher-level construct for specifying timing constraints. Minimum and maximum separation times between system activites are specified using labels attached to program statements.
Reference: [Ortega 92] <author> R. Ortega. </author> <title> Operation event timing constraints in Ptolemy. </title> <type> Technical report, </type> <institution> Department of Computer Science and Engineering, University of Washington, </institution> <month> November </month> <year> 1992. </year>
Reference-contexts: At the University of California at Berkeley, OEsim has been used to represent and simulate the abstract interfaces of complex components that are interconnected on a printed circuit board or multi-chip module (see [Sun & Brodersen 92]). A modified form of our restricted event-logic has also been incorporated (see <ref> [Ortega 92] </ref>) into the heterogenous simulation framework of Ptolemy [Buck et al. 91] to support the specification and checking of timing constraints when working within its event-driven simulation domain. We have not analyzed the performance of OEsim in detail, but have found it to be efficient and capable.
Reference: [Ostroff 90] <author> J. Ostroff. </author> <title> Temporal Logic of Real-Time Systems. </title> <publisher> Research Studies Press, </publisher> <year> 1990. </year>
Reference-contexts: but many other logics which address the problem of modeling timing behavior have recently been developed: [Alur & Henzinger 89], [Alur & Henzinger 90], [Alur et al. 89], [Coen et al. 90], [Hansen et al. 92], [Harel et al. 90], [Koymans 89], [Koymans 90], [Lewis 90], [Narain et al. 92], <ref> [Ostroff 90] </ref>. Many of these logics use a continuous model of time and emphasize realistic modeling, others use a more restricted model to obtain feasible verification procedures.
Reference: [Ousterhout 85] <author> J. Ousterhout. </author> <title> A switch-level timing verifier for digital MOS VLSI. </title> <journal> IEEE Transactions on Computer-Aided Design of Integrated Circuits, </journal> <volume> 4(3), </volume> <month> July </month> <year> 1985. </year> <month> 146 </month>
Reference-contexts: Because of the very limited semantics of both the system and the behavior that is verified, analytical techniques which do not require state-based exploration or symbolic simulation often suffice. Some of these tools require human assistance (e.g., in CRYSTAL <ref> [Ousterhout 85] </ref> users need to identify the direction of current flow for some transistors) but most are fully automated.
Reference: [Park & Shaw 91] <author> C.-Y. Park and A. C. Shaw. </author> <title> Experiments with a program timing tool based on source-level timing schema. </title> <journal> IEEE Computer, </journal> <volume> 25(5) </volume> <pages> 48-57, </pages> <month> May </month> <year> 1991. </year>
Reference-contexts: The dotted edges are superfluous and can be removed without affecting the behavior of the system. 130 type <ref> [Park & Shaw 91] </ref>.
Reference: [Parker & Wallace 81] <author> A. Parker and J. Wallace. SLIDE: </author> <title> An I/O hardware description language. </title> <journal> IEEE Transactions on Computers, </journal> <month> June </month> <year> 1981. </year>
Reference-contexts: Because HDLs have been designed to express circuit functionality, temporal constraints are often simply embedded in the design specification. In order to describe the constraints on an interface, a specification that exhibits proper behavior is specified. For example, the language SLIDE <ref> [Parker & Wallace 81] </ref> has delay and delay until statements which can be used to specify the interface from a functional perspective.
Reference: [Pneuli 77] <author> A. Pneuli. </author> <title> The temporal logic of programs. </title> <booktitle> Proceedings of the 18th IEEE Symposium on Foundations of Computer Science, </booktitle> <year> 1977. </year>
Reference-contexts: Labels on two of the waveforms (e.g., (NOT Address)) specify the flow of data values across the interfaces." 2.2.2 Formal Logics and Related Algebras Temporal Logics are a specification language based on first order logic with special logical operators for reasoning about time <ref> [Pneuli 77, Rescher & Urquart 71] </ref>. They have been used by many different researchers for specifying and verifying hardware (e.g., [Bennett 86], [Bochmann 82], [Browne et al. 86], [Clarke et al. 86], [Dill & Clarke 85], [Fujita et al. 83], [Fusaoka et al. 84], [Malachi & Owicki 81]).
Reference: [Ramamoorthry & Ho 80] <author> C. Ramamoorthry and G. S. Ho. </author> <title> Performance evaluation of asynchronous conncurrent systems using Petri nets. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> SE-6:440-449, </volume> <month> September </month> <year> 1980. </year>
Reference-contexts: Many different models of time have been defined for Petri nets, the most popular being stochastic delays used for probabilistic performance evaluation (see [Ajmone Marsan 89]). A number of timed Petri net models have been developed that incorporate non-probabilistic (e.g., fixed or bounded) delays, e.g., <ref> [Ramamoorthry & Ho 80] </ref>, [Ramchandani 74], [Merlin 74], [Coolahan & Roussopoulos 85], [Cohen et al. 89], [Andre 91], [Zuberek 91]. Some specification languages are based on the event paradigm but are also closely related to the paradigms previously discussed.
Reference: [Ramchandani 74] <author> C. Ramchandani. </author> <title> Analysis of asynchronous concurrent systems by Petri nets. Technical Report Project MAC TR-120, </title> <publisher> M.I.T., </publisher> <address> Cambridge, MA, </address> <year> 1974. </year>
Reference-contexts: Many different models of time have been defined for Petri nets, the most popular being stochastic delays used for probabilistic performance evaluation (see [Ajmone Marsan 89]). A number of timed Petri net models have been developed that incorporate non-probabilistic (e.g., fixed or bounded) delays, e.g., [Ramamoorthry & Ho 80], <ref> [Ramchandani 74] </ref>, [Merlin 74], [Coolahan & Roussopoulos 85], [Cohen et al. 89], [Andre 91], [Zuberek 91]. Some specification languages are based on the event paradigm but are also closely related to the paradigms previously discussed.
Reference: [Rem et al. 83] <author> M. Rem, J. L. van de Snepscheut, and J. T. Udding. </author> <title> Trace theory and the definition of hierarchical components. </title> <editor> In R. Bryant, editor, </editor> <booktitle> Third CalTech Conference on VLSI, </booktitle> <pages> pages 225-239. </pages> <publisher> Computer Science Press, </publisher> <year> 1983. </year>
Reference-contexts: For example, a legal trace of the four cycle communication protocol of Figure 2.3 would be: "R" ; A" ; R# ; A# ; R" ; A" ; R# ; A# : : :" Trace theory has been used extensively to verify asynchronous speed-independent circuits [Dill 88], <ref> [Rem et al. 83] </ref>, [van de Snepscheut 85], [Ebergen 87]. There are a variety of extensions to this body of theory that handle more detailed timing requirements. One approach introduces a fictitious clock and a special tick transition that is used to measure elapsed time.
Reference: [Rescher & Urquart 71] <author> N. Rescher and A. Urquart. </author> <title> Temporal Logic. </title> <publisher> Springer-Verlag, </publisher> <year> 1971. </year>
Reference-contexts: Labels on two of the waveforms (e.g., (NOT Address)) specify the flow of data values across the interfaces." 2.2.2 Formal Logics and Related Algebras Temporal Logics are a specification language based on first order logic with special logical operators for reasoning about time <ref> [Pneuli 77, Rescher & Urquart 71] </ref>. They have been used by many different researchers for specifying and verifying hardware (e.g., [Bennett 86], [Bochmann 82], [Browne et al. 86], [Clarke et al. 86], [Dill & Clarke 85], [Fujita et al. 83], [Fusaoka et al. 84], [Malachi & Owicki 81]).
Reference: [Sherman 88] <author> S. K. Sherman. </author> <title> Algorithms for timing requirement analysis and generation. </title> <booktitle> In 25th ACM/IEEE Design Automation Conference, </booktitle> <year> 1988. </year>
Reference-contexts: Most of the existing event graph representations are acyclic and represent one execution of a particular system behavior. Some of the representations using this paradigm include: [Borriello 88a], [Gahlinger 90], [Hayati et al. 88], [Khordoc et al. 91], [Martello et al. 90], <ref> [Sherman 88] </ref>, [Zahir & Fichtner 90]. Cyclic event graphs are far less common, and have been used primarily to represent asynchronous circuits, e.g., [Chu 87], and to analyze their performance, e.g., [Burns 91].
Reference: [Subramanyam 90] <author> P. A. Subramanyam. </author> <title> Tales: Event-based semantics for timing specification (with applications to synthesis, verification and analysis). </title> <booktitle> First International Workshop on Timing Issues in the Specification and Synthesis of Digital Systems (Tau '90), </booktitle> <month> August </month> <year> 1990. </year>
Reference-contexts: In order to capture more complicated timing constraints (e.g., ones that appear as annotations to timing diagrams) event graphs are not sufficient, and thus more powerful specification languages are needed. An approach that uses timing diagrams and annotated event structures is presented in <ref> [Subramanyam 90] </ref>. Real-Time Logic [Jahanian & Mok 86] is a formal logic based on the event paradigm that is quite unlike the temporal logics previously described.
Reference: [Sun & Brodersen 92] <author> J. S. Sun and R. W. Brodersen. </author> <title> Design of system interface modules. </title> <booktitle> In IEEE International Conference on Computer-Aided Design (ICCAD), </booktitle> <month> November </month> <year> 1992. </year>
Reference-contexts: At the University of California at Berkeley, OEsim has been used to represent and simulate the abstract interfaces of complex components that are interconnected on a printed circuit board or multi-chip module (see <ref> [Sun & Brodersen 92] </ref>). A modified form of our restricted event-logic has also been incorporated (see [Ortega 92]) into the heterogenous simulation framework of Ptolemy [Buck et al. 91] to support the specification and checking of timing constraints when working within its event-driven simulation domain.
Reference: [TPN 85] <institution> International Workshop on Timed Petri Nets. IEEE Computer Society Press, </institution> <month> July </month> <year> 1985. </year>
Reference: [Vahid & Gajski 91] <author> F. Vahid and D. D. Gajski. </author> <title> Obtaining functionally equivalent simulations using VHDL and a time-shift transformation. </title> <booktitle> In IEEE International Conference on Computer-Aided Design (ICCAD), </booktitle> <pages> pages 362-365, </pages> <month> November </month> <year> 1991. </year>
Reference-contexts: For example, the language VHDL does not support a zero time delay. This has caused problems for translation schemes from domain specific application languages with zero time delay into VHDL <ref> [Vahid & Gajski 91] </ref>. Our solution to this problem is to create additional rules to handle constraints when the from event is an input to a zero delay operation.
Reference: [van de Snepscheut 85] <author> J. van de Snepscheut. </author> <title> Trace theory and VLSI design. </title> <booktitle> In Lecture Notes Computer Science 200. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1985. </year> <month> 147 </month>
Reference-contexts: example, a legal trace of the four cycle communication protocol of Figure 2.3 would be: "R" ; A" ; R# ; A# ; R" ; A" ; R# ; A# : : :" Trace theory has been used extensively to verify asynchronous speed-independent circuits [Dill 88], [Rem et al. 83], <ref> [van de Snepscheut 85] </ref>, [Ebergen 87]. There are a variety of extensions to this body of theory that handle more detailed timing requirements. One approach introduces a fictitious clock and a special tick transition that is used to measure elapsed time.
Reference: [Vanbekbergen et al. 92] <author> P. Vanbekbergen, G. Goossens, and H. D. Man. </author> <title> Specification and analysis of timing constraints in signal transition graphs. </title> <booktitle> In European Design Automation Conference, </booktitle> <month> March </month> <year> 1992. </year>
Reference-contexts: An event graph (see Section 2.3) is used to capture the events and propagation delays of the system. Shortest path algorithms have been used to solve problems that contain only linear 79 constraints, e.g., [Borriello 88b] and [Brzozowski et al. 91]. Both [McMillan & Dill 92] and <ref> [Vanbekbergen et al. 92] </ref> provide an overview of the various types of event graphs and timing constraints for which verification algorithms have been developed (both authors present algorithms for handling non-linear constraints). <p> Loose bounds that may not enable all possible optimizations were obtained by [Myers & Meng 92] who used the analysis to optimize the implementation of speed-dependent asynchronous circuits (see Section 7.3). Both [McMillan & Dill 92] and <ref> [Vanbekbergen et al. 92] </ref> handle only acyclic graphs. However, they provide a theoretical foundation upon which our solution is built. <p> For our example, we have E 0 = fa; bg ae [4;10];1 [1;2];0 [1;6];1 [5;20];1 oe 1 [Myers & Meng 92] introduced a similarly modified system. The model can also be viewed as an extension of [McMillan & Dill 92] and <ref> [Vanbekbergen et al. 92] </ref>, where we consider cyclic max-only or type-2 graphs.
Reference: [Wing 90] <author> J. M. Wing. </author> <title> A specifier's introduction to formal methods. </title> <booktitle> IEEE Computer, </booktitle> <month> September </month> <year> 1990. </year>
Reference-contexts: Specification languages thus need to be structured so that every "well formed" specification is inherently unambiguous. There are many other benefits of formal specification. We refer readers to [Meyer 85] for a more detailed discussion. We also refer readers to <ref> [Wing 90] </ref> for a summary of formal methods and formal design specification. 2.1.2 Expressiveness Specification languages are designed for a particular domain of applicability, and need to have enough expressive power to represent designs from that domain.
Reference: [Wolper 81] <author> P. Wolper. </author> <title> Temporal logic can be more expressive. </title> <booktitle> Proceedings of the 22nd IEEE Symposium on Foundations of Computer Science, </booktitle> <year> 1981. </year>
Reference-contexts: There are various timing relationships that cannot be specified using the different formalisms (e.g. fairness constraints are not easily specified in CTL) and there are many well known limitations to the expressiviness of propositional temporal logic (see <ref> [Wolper 81] </ref>).
Reference: [Zahir & Fichtner 90] <author> R. Zahir and W. Fichtner. </author> <title> Specification of timing constraints for controller synthesis. </title> <booktitle> First International Workshop on Timing Issues in the Specification and Synthesis of Digital Systems (Tau '90), </booktitle> <month> August </month> <year> 1990. </year>
Reference-contexts: Most of the existing event graph representations are acyclic and represent one execution of a particular system behavior. Some of the representations using this paradigm include: [Borriello 88a], [Gahlinger 90], [Hayati et al. 88], [Khordoc et al. 91], [Martello et al. 90], [Sherman 88], <ref> [Zahir & Fichtner 90] </ref>. Cyclic event graphs are far less common, and have been used primarily to represent asynchronous circuits, e.g., [Chu 87], and to analyze their performance, e.g., [Burns 91].
Reference: [Zuberek 91] <author> W. M. Zuberek. </author> <title> Timed Petri nets definitions, properties and applications. </title> <journal> Microelectronics and Reliability, </journal> <volume> 31(4) </volume> <pages> 627-644, </pages> <year> 1991. </year>
Reference-contexts: A number of timed Petri net models have been developed that incorporate non-probabilistic (e.g., fixed or bounded) delays, e.g., [Ramamoorthry & Ho 80], [Ramchandani 74], [Merlin 74], [Coolahan & Roussopoulos 85], [Cohen et al. 89], [Andre 91], <ref> [Zuberek 91] </ref>. Some specification languages are based on the event paradigm but are also closely related to the paradigms previously discussed. Timing diagrams are, in fact, essentially event-based specifications event graphs are used to provide a formal underlying semantics (e.g., [Borriello 88b, Khordoc et al. 91]).
References-found: 127

