URL: ftp://flint.cs.yale.edu/pub/flint/publications/imp.ps.gz
Refering-URL: http://daffy.cs.yale.edu/users/shao-zhong/papers.html
Root-URL: http://www.cs.yale.edu
Email: fshao,league,monnierg@cs.yale.edu.  
Title: Implementing Typed Intermediate Languages  
Author: Zhong Shao Christopher League Stefan Monnier 
Address: New Haven, CT 06520  
Affiliation: Dept. of Computer Science Yale University  
Abstract: Recent advances in compiler technology have demonstrated the benefits of using strongly typed intermediate languages to compile richly typed source languages (e.g., ML). A type-preserving compiler can use types to guide advanced optimizations and to help generate provably secure mobile code. Types, unfortunately, are very hard to represent and manipulate efficiently; a naive implementation can easily add exponential overhead to the compilation and execution of a program. This paper describes our experience with implementing the FLINT typed intermediate language in the SML/NJ production compiler. We observe that a type-preserving compiler will not scale to handle large types unless all of its type-preserving stages preserve the asymptotic time and space usage in representing and manipulating types. We present a series of novel techniques for achieving this property and give empirical evidence of their effectiveness. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> M. Abadi, L. Cardelli, P. Curien, and J. Levy. </author> <title> Explicit substitutions. </title> <booktitle> In Seventeenth Annual ACM Symp. on Principles of Prog. Languages, </booktitle> <pages> pages 31-46, </pages> <address> New York, Jan 1990. </address> <publisher> ACM Press. </publisher>
Reference-contexts: To achieve this property, we present a novel and efficient representation scheme for the FLINT type calculus. Our main idea is to combine hash-consing, memoization, and advanced lambda encoding <ref> [24, 1, 9] </ref> to ensure that (1) types are always represented as dags; (2) type reductions are done on a by-need basis; and (3) the cost of handling types is proportional to the size of the dag representations. <p> 42] have also used typed intermediate languages, but none of them have attempted to scale their implementations to handle large types; in fact, all these compilers have reported extremely slow compilation times as a result of keeping types during compilation. 2 * We combine hash-consing, memoization, and advanced lambda encoding <ref> [24, 1, 9] </ref> to support efficient type representation and manipulation. Although each of these techniques has been researched and implemented before, nobody has ever tried to combine them to represent compiler type information. <p> The main contribution of our work is to combine Nadathur's encoding with hash-consing and memoization, and then apply it to the context of typed intermediate languages. Combining these techniques is non-trivial because of the presence of higher-order types and the need to memoize intermediate reduction results. Explicit substitutions <ref> [9, 1] </ref> is another related lambda encoding scheme. Cardelli's Quest compiler [1] contains an implementation of this encoding; however, he did not combine it with other techniques we used. Nor was he working in the context of type-preserving compilers. <p> Combining these techniques is non-trivial because of the presence of higher-order types and the need to memoize intermediate reduction results. Explicit substitutions [9, 1] is another related lambda encoding scheme. Cardelli's Quest compiler <ref> [1] </ref> contains an implementation of this encoding; however, he did not combine it with other techniques we used. Nor was he working in the context of type-preserving compilers. <p> Intuitively, a suspension represents an unevaluated type "()"; it corresponds to the intermediate result of some unevaluated type applications. The substitutions involved () are also known as explicit substitutions <ref> [1, 9] </ref>: (constructor) ::= #n j Int j 1 ! 2 j : j 1 [ 2 ] j Env (; ) (substitution) ::= (i; j; env) (environment) env ::= nil j j :: env j (j; ) :: env Following Nadathur [24, 25], we represent each such substitution as a
Reference: [2] <author> A. W. Appel. </author> <title> Compiling with Continuations. </title> <publisher> Cambridge University Press, </publisher> <year> 1992. </year>
Reference-contexts: 1 Introduction Compilers for richly typed languages (e.g., ML [21]) have long used variants of the untyped -calculus <ref> [2, 10] </ref> as their intermediate languages. An untyped compiler first type-checks the source program, and then translates the program to the intermediate language, discarding all the type information. <p> So it is not clear that the lettype scheme will (kind) ::= j 1 ! 2 (tycon) ::= t j Int j 1 ! 2 j t :: : j 1 <ref> [ 2 ] </ref> (type) ::= T () j 1 ! 2 j 8t :: : (term) e ::= i j x j x : :e j @x 1 x 2 j flt :: :e j x [] j let x = e 1 in e 2 address issues such as compilation <p> Constructors of kind name monotypes. The monotypes are generated from variables, from Int, and through the ! constructor. As in F ! , the application and abstraction constructors (i.e., 1 <ref> [ 2 ] </ref> and t :: :) correspond to the function kind 1 ! 2 . Types in Core-FLINT include the monotypes, and are closed under function spaces and polymorphic quantification. We use T () to denote the type corresponding to the constructor when is of kind . <p> n i and the n-th element of env is j 0 (r6) Env (#n; (i; j; env)) =) Env (; (0; j j 0 ; nil)) if n i and the n-th element of env is (j 0 ; ) (r7) Env (Int; ) =) Int (r9) Env ( 1 <ref> [ 2 ] </ref>; ) =) (Env ( 1 ; ))[Env ( 2 ; )] (r11) Env (Env (; (i; j; env)); (0; j 0 ; nil)) =) Env (; (i; j + j 0 ; env)) tion. <p> Intuitively, a suspension represents an unevaluated type "()"; it corresponds to the intermediate result of some unevaluated type applications. The substitutions involved () are also known as explicit substitutions [1, 9]: (constructor) ::= #n j Int j 1 ! 2 j : j 1 <ref> [ 2 ] </ref> j Env (; ) (substitution) ::= (i; j; env) (environment) env ::= nil j j :: env j (j; ) :: env Following Nadathur [24, 25], we represent each such substitution as a triple (i; j; env) where the first index i indicates the current embedding level of
Reference: [3] <author> A. W. Appel and D. B. MacQueen. </author> <title> Standard ML of New Jersey. </title> <editor> In M. Wirsing, editor, </editor> <booktitle> Third Int'l Symp. on Prog. Lang. Implementation and Logic Programming, </booktitle> <pages> pages 1-13, </pages> <address> New York, </address> <month> August </month> <year> 1991. </year> <note> Springer-Verlag. </note>
Reference-contexts: This paper describes our experience with implementing the FLINT typed intermediate language [36] in the SML/NJ production compiler <ref> [39, 3] </ref>. FLINT is based on a pred-icative variant of the polymorphic -calculus F ! [12, 32, 15], extended with a rich set of primitive types and functions. FLINT supports both polymorphic types and higher-order type constructors, so the type language itself is a full-scale -calculus.
Reference: [4] <author> M. Blume. </author> <title> A compilation manager for SML/NJ. as part of SML/NJ User's Guide, </title> <year> 1995. </year>
Reference-contexts: For example, a 200-line ML program cm.sml in the SML/NJ compilation manager (CM) <ref> [4] </ref> contains more than 36 functor applications and more than 80 structure references; each of these modules may contain a dag of sub-structures or func-tors. <p> Figure 1 gives a profile of types built while compiling two large ML applications in our type-preserving compiler (see later sections for details about the compiler). Here, CM is the compilation manager <ref> [4] </ref> and eXene is an ML-based X window system tool-kit [31]. If we use tree representations, a single type can contain more than 45,518 nodes for CM and 379,315 nodes for eXene. These large types can be dramatically reduced in size if we use dag representations.
Reference: [5] <author> L. Damas and R. Milner. </author> <title> Principal type-schemes for functional programs. </title> <booktitle> In Ninth Annual ACM Symp. on Principles of Prog. Languages, </booktitle> <pages> pages 207-212, </pages> <address> New York, Jan 1982. </address> <publisher> ACM Press. </publisher>
Reference-contexts: Suppose we apply f to itself n times as shown. According to the ML type inference algorithm <ref> [5] </ref>, the rightmost f has type T 1 = ff ! ff, while the leftmost f gets instantiated to T n = T n1 ! T n1 .
Reference: [6] <author> O. Danvy. </author> <title> Type-directed partial evaluation. </title> <booktitle> In Proc. 23rd Annual ACM SIGPLAN-SIGACT Symp. on Principles of Programming Languages, </booktitle> <pages> pages 242-257. </pages> <publisher> ACM Press, </publisher> <year> 1996. </year>
Reference-contexts: A type-preserving compiler type-checks the source program, but then translates both the program and the (inferred) type information into the intermediate language. The rest of the compiler can use types to guide advanced optimizations <ref> [28, 16, 22, 34, 6] </ref> and to help generate provably secure mobile code [13, 26, 19, 23, 17]. The compiler can also propagate the type information into the target code to support sophisticated run-time type dispatches and garbage collection [14, 22, 34, 43].
Reference: [7] <author> N. de Bruijn. </author> <title> A survey of the project AUTOMATH. In To H. </title> <editor> B. </editor> <booktitle> Curry: Essays on Combinatory Logic, Lambda Calculus and Formalism, </booktitle> <pages> pages 579-606. </pages> <note> Edited by J. </note> <editor> P. Seldin and J. R. Hindley, </editor> <publisher> Academic Press, </publisher> <year> 1980. </year>
Reference-contexts: Under the syntax in Figure 2, testing the equality of ff-convertible constructors such as 1 = t 1 :: :t 1 ! t 1 and 2 = t 2 :: :t 2 ! t 2 is non-trivial. We use de Bruijn indices <ref> [7] </ref> to represent type variables, so that ff-equivalent constructors always have the same representation. For example, both 1 and 2 are represented as :(#1 ! #1). The no longer binds any named type variables (though the kind is still retained).
Reference: [8] <author> A. Dimock, R. Muller, F. Turbak, and J. B. Wells. </author> <title> Strongly typed flow-directed representation transformations. </title> <booktitle> In Proc. 1997 ACM SIGPLAN International Conference on Functional Programming (ICFP'97), </booktitle> <pages> pages 11-24. </pages> <publisher> ACM Press, </publisher> <month> June </month> <year> 1997. </year>
Reference-contexts: However, recent work <ref> [14, 22, 36, 30, 8, 29, 23] </ref> has mostly focused on the theoretical foundations or other language design issues. This paper complements previous work by showing that typed intermediate languages can indeed have practical and scalable implementations, but only if extreme care is taken.
Reference: [9] <author> J. </author> <title> Field. On laziness and optimality in lambda interpreters: Tools for specification and analysis. </title> <booktitle> In Seventeenth Annual ACM Symp. on Principles of Prog. Languages, </booktitle> <pages> pages 1-15, </pages> <address> New York, Jan 1990. </address> <publisher> ACM Press. </publisher>
Reference-contexts: To achieve this property, we present a novel and efficient representation scheme for the FLINT type calculus. Our main idea is to combine hash-consing, memoization, and advanced lambda encoding <ref> [24, 1, 9] </ref> to ensure that (1) types are always represented as dags; (2) type reductions are done on a by-need basis; and (3) the cost of handling types is proportional to the size of the dag representations. <p> 42] have also used typed intermediate languages, but none of them have attempted to scale their implementations to handle large types; in fact, all these compilers have reported extremely slow compilation times as a result of keeping types during compilation. 2 * We combine hash-consing, memoization, and advanced lambda encoding <ref> [24, 1, 9] </ref> to support efficient type representation and manipulation. Although each of these techniques has been researched and implemented before, nobody has ever tried to combine them to represent compiler type information. <p> The main contribution of our work is to combine Nadathur's encoding with hash-consing and memoization, and then apply it to the context of typed intermediate languages. Combining these techniques is non-trivial because of the presence of higher-order types and the need to memoize intermediate reduction results. Explicit substitutions <ref> [9, 1] </ref> is another related lambda encoding scheme. Cardelli's Quest compiler [1] contains an implementation of this encoding; however, he did not combine it with other techniques we used. Nor was he working in the context of type-preserving compilers. <p> Intuitively, a suspension represents an unevaluated type "()"; it corresponds to the intermediate result of some unevaluated type applications. The substitutions involved () are also known as explicit substitutions <ref> [1, 9] </ref>: (constructor) ::= #n j Int j 1 ! 2 j : j 1 [ 2 ] j Env (; ) (substitution) ::= (i; j; env) (environment) env ::= nil j j :: env j (j; ) :: env Following Nadathur [24, 25], we represent each such substitution as a
Reference: [10] <author> C. Flanagan, A. Sabry, B. F. Duba, and M. Felleisen. </author> <title> The essence of compiling with continuations. </title> <booktitle> In Proc. ACM SIG-PLAN '93 Conf. on Prog. Lang. Design and Implementation, </booktitle> <pages> pages 237-247, </pages> <address> New York, June 1993. </address> <publisher> ACM Press. </publisher>
Reference-contexts: 1 Introduction Compilers for richly typed languages (e.g., ML [21]) have long used variants of the untyped -calculus <ref> [2, 10] </ref> as their intermediate languages. An untyped compiler first type-checks the source program, and then translates the program to the intermediate language, discarding all the type information. <p> Shao and Appel [39] used hash-consing to enforce dag representations for types; however, their intermediate language is only monomorphically typed, so it is much easier to support than FLINT-like languages. Tarditi [40] used the lettype constructs (in both the constructor calculus and the term language) to A-normalize <ref> [10] </ref> all types in order to express sharing explicitly. But he relies on a separate common sub-expression elimination phase to identify the sharing information. <p> A more detailed comparison between our scheme and the lettype scheme is given in Section 8. 3 An Overview of FLINT The core language of FLINT is based on a predicative variant of the Girard-Reynolds polymorphic -calculus F ! [12, 32], with the term language written in A-normal form <ref> [10] </ref>. It contains the following four syntactic classes: kinds (), type constructors (), types (), terms (e), as shown in classify terms. Constructors of kind name monotypes. The monotypes are generated from variables, from Int, and through the ! constructor.
Reference: [11] <author> L. George, F. Guillaume, and J. Reppy. </author> <title> A portable and optimizing backend for the SML/NJ compiler. </title> <booktitle> In Proceedings of the 1994 International Conference on Compiler Construction, </booktitle> <pages> pages 83-97. </pages> <publisher> Springer-Verlag, </publisher> <month> April </month> <year> 1994. </year>
Reference-contexts: The back end compiles FLINT into machine code through the usual phases such as representation analysis [34], safe-for-space closure conversion [38], register allocation, instruction scheduling, and machine-code generation <ref> [11] </ref>. 3 Of course, we could always expand out the lettype definitions to get to a normal form, but this eliminates the benefit of using lettype and is equivalent to using tree representations. 3 signature LTYEXTERN = sig (* abstract types *) type tkind (* *) type tyc (* *) type
Reference: [12] <author> J. Y. Girard. </author> <title> Interpretation Fonctionnelle et Elimination des Coupures dans l'Arithmetique d'Ordre Superieur. </title> <type> PhD thesis, </type> <institution> University of Paris VII, </institution> <year> 1972. </year>
Reference-contexts: This paper describes our experience with implementing the FLINT typed intermediate language [36] in the SML/NJ production compiler [39, 3]. FLINT is based on a pred-icative variant of the polymorphic -calculus F ! <ref> [12, 32, 15] </ref>, extended with a rich set of primitive types and functions. FLINT supports both polymorphic types and higher-order type constructors, so the type language itself is a full-scale -calculus. To support various type-directed optimizations [14, 34], we perform a large number of type-related operations during compilation. <p> A more detailed comparison between our scheme and the lettype scheme is given in Section 8. 3 An Overview of FLINT The core language of FLINT is based on a predicative variant of the Girard-Reynolds polymorphic -calculus F ! <ref> [12, 32] </ref>, with the term language written in A-normal form [10]. It contains the following four syntactic classes: kinds (), type constructors (), types (), terms (e), as shown in classify terms. Constructors of kind name monotypes. The monotypes are generated from variables, from Int, and through the ! constructor.
Reference: [13] <author> J. Gosling, B. Joy, and G. Steele. </author> <title> The Java Language Specification. </title> <publisher> Addison-Wesley, </publisher> <year> 1996. </year>
Reference-contexts: A type-preserving compiler type-checks the source program, but then translates both the program and the (inferred) type information into the intermediate language. The rest of the compiler can use types to guide advanced optimizations [28, 16, 22, 34, 6] and to help generate provably secure mobile code <ref> [13, 26, 19, 23, 17] </ref>. The compiler can also propagate the type information into the target code to support sophisticated run-time type dispatches and garbage collection [14, 22, 34, 43].
Reference: [14] <author> R. Harper and G. Morrisett. </author> <title> Compiling polymorphism using intensional type analysis. </title> <booktitle> In Twenty-second Annual ACM Symp. on Principles of Prog. Languages, </booktitle> <pages> pages 130-141, </pages> <address> New York, Jan 1995. </address> <publisher> ACM Press. </publisher>
Reference-contexts: The compiler can also propagate the type information into the target code to support sophisticated run-time type dispatches and garbage collection <ref> [14, 22, 34, 43] </ref>. Unfortunately, type information is very hard to represent and manipulate efficiently, especially when the underlying type system involves ML-like polymorphic types and module types [21]. A naive implementation can easily add exponential overhead to the compilation and execution of a program. <p> FLINT is based on a pred-icative variant of the polymorphic -calculus F ! [12, 32, 15], extended with a rich set of primitive types and functions. FLINT supports both polymorphic types and higher-order type constructors, so the type language itself is a full-scale -calculus. To support various type-directed optimizations <ref> [14, 34] </ref>, we perform a large number of type-related operations during compilation. The main challenge is to represent complex FLINT types (which can be arbitrary lambda terms) as compact dags so that common type-related operations (e.g., lambda reductions, equality) can always work efficiently and yet still preserve sharing. <p> However, recent work <ref> [14, 22, 36, 30, 8, 29, 23] </ref> has mostly focused on the theoretical foundations or other language design issues. This paper complements previous work by showing that typed intermediate languages can indeed have practical and scalable implementations, but only if extreme care is taken.
Reference: [15] <editor> G. Huet. </editor> <booktitle> Logical Foundations of Functional Programming. </booktitle> <publisher> Addison-Wesley, </publisher> <year> 1990. </year>
Reference-contexts: This paper describes our experience with implementing the FLINT typed intermediate language [36] in the SML/NJ production compiler [39, 3]. FLINT is based on a pred-icative variant of the polymorphic -calculus F ! <ref> [12, 32, 15] </ref>, extended with a rich set of primitive types and functions. FLINT supports both polymorphic types and higher-order type constructors, so the type language itself is a full-scale -calculus. To support various type-directed optimizations [14, 34], we perform a large number of type-related operations during compilation.
Reference: [16] <author> X. Leroy. </author> <title> Unboxed objects and polymorphic typing. </title> <booktitle> In Nineteenth Annual ACM Symp. on Principles of Prog. Languages, </booktitle> <pages> pages 177-188, </pages> <address> New York, </address> <month> Jan </month> <year> 1992. </year> <note> ACM Press. Longer version available as INRIA Tech Report. </note>
Reference-contexts: A type-preserving compiler type-checks the source program, but then translates both the program and the (inferred) type information into the intermediate language. The rest of the compiler can use types to guide advanced optimizations <ref> [28, 16, 22, 34, 6] </ref> and to help generate provably secure mobile code [13, 26, 19, 23, 17]. The compiler can also propagate the type information into the target code to support sophisticated run-time type dispatches and garbage collection [14, 22, 34, 43].
Reference: [17] <author> X. Leroy and F. Rouaix. </author> <title> Security properties of typed applets. </title> <booktitle> In Twenty-fifth Annual ACM Symp. on Principles of Prog. Languages, page (to appear), </booktitle> <address> New York, Jan 1998. </address> <publisher> ACM Press. </publisher>
Reference-contexts: A type-preserving compiler type-checks the source program, but then translates both the program and the (inferred) type information into the intermediate language. The rest of the compiler can use types to guide advanced optimizations [28, 16, 22, 34, 6] and to help generate provably secure mobile code <ref> [13, 26, 19, 23, 17] </ref>. The compiler can also propagate the type information into the target code to support sophisticated run-time type dispatches and garbage collection [14, 22, 34, 43].
Reference: [18] <author> J.-J. Levy. </author> <title> Optimal reductions in the lambda calculus. In To H. </title> <editor> B. </editor> <booktitle> Curry: Essays on Combinatory Logic, Lambda Calculus and Formalism. </booktitle> <editor> Edited by J. P. Seldin and J. R. Hindley, </editor> <publisher> Academic Press, </publisher> <year> 1980. </year>
Reference-contexts: This leads to a very practical implementation that approximates optimal lambda reductions <ref> [18] </ref>, with the caveat of using hash-consing, of course. The combination of these techniques has proven to be very effective.
Reference: [19] <author> T. Lindholm and F. Yellin. </author> <title> The Java Virtual Machine Specification. </title> <publisher> Addison-Wesley, </publisher> <year> 1997. </year> <month> 10 </month>
Reference-contexts: A type-preserving compiler type-checks the source program, but then translates both the program and the (inferred) type information into the intermediate language. The rest of the compiler can use types to guide advanced optimizations [28, 16, 22, 34, 6] and to help generate provably secure mobile code <ref> [13, 26, 19, 23, 17] </ref>. The compiler can also propagate the type information into the target code to support sophisticated run-time type dispatches and garbage collection [14, 22, 34, 43].
Reference: [20] <author> H. G. Mairson. </author> <title> Deciding ML typability is complete for de--terminsitic exponential time. </title> <booktitle> In Proc. 17th Annual ACM SIGPLAN-SIGACT Symp. on Principles of Programming Languages, </booktitle> <pages> pages 382-401. </pages> <publisher> ACM Press, </publisher> <year> 1990. </year>
Reference-contexts: Although the preceding example is a bit contrived, 1 large 1 It is well known that ML type inference can take exponential time and space on certain kinds of ML programs <ref> [20] </ref>; the toy function defined here, however, does not belong to this category.
Reference: [21] <author> R. Milner, M. Tofte, R. Harper, and D. MacQueen. </author> <title> The Definition of Standard ML (Revised). </title> <publisher> MIT Press, </publisher> <address> Cambridge, Massachusetts, </address> <year> 1997. </year>
Reference-contexts: 1 Introduction Compilers for richly typed languages (e.g., ML <ref> [21] </ref>) have long used variants of the untyped -calculus [2, 10] as their intermediate languages. An untyped compiler first type-checks the source program, and then translates the program to the intermediate language, discarding all the type information. <p> The compiler can also propagate the type information into the target code to support sophisticated run-time type dispatches and garbage collection [14, 22, 34, 43]. Unfortunately, type information is very hard to represent and manipulate efficiently, especially when the underlying type system involves ML-like polymorphic types and module types <ref> [21] </ref>. A naive implementation can easily add exponential overhead to the compilation and execution of a program.
Reference: [22] <author> G. Morrisett. </author> <title> Compiling with Types. </title> <type> PhD thesis, </type> <institution> School of Computer Science, Carnegie Mellon University, </institution> <address> Pittsburgh, PA, </address> <month> December </month> <year> 1995. </year> <note> Tech Report CMU-CS-95-226. </note>
Reference-contexts: A type-preserving compiler type-checks the source program, but then translates both the program and the (inferred) type information into the intermediate language. The rest of the compiler can use types to guide advanced optimizations <ref> [28, 16, 22, 34, 6] </ref> and to help generate provably secure mobile code [13, 26, 19, 23, 17]. The compiler can also propagate the type information into the target code to support sophisticated run-time type dispatches and garbage collection [14, 22, 34, 43]. <p> The compiler can also propagate the type information into the target code to support sophisticated run-time type dispatches and garbage collection <ref> [14, 22, 34, 43] </ref>. Unfortunately, type information is very hard to represent and manipulate efficiently, especially when the underlying type system involves ML-like polymorphic types and module types [21]. A naive implementation can easily add exponential overhead to the compilation and execution of a program. <p> However, recent work <ref> [14, 22, 36, 30, 8, 29, 23] </ref> has mostly focused on the theoretical foundations or other language design issues. This paper complements previous work by showing that typed intermediate languages can indeed have practical and scalable implementations, but only if extreme care is taken.
Reference: [23] <author> G. Morrisett, D. Walker, K. Crary, and N. Glew. </author> <title> From system F to typed assembly language. </title> <booktitle> In Proc. 25rd Annual ACM SIGPLAN-SIGACT Symp. on Principles of Programming Languages, page (to appear). </booktitle> <publisher> ACM Press, </publisher> <year> 1998. </year>
Reference-contexts: A type-preserving compiler type-checks the source program, but then translates both the program and the (inferred) type information into the intermediate language. The rest of the compiler can use types to guide advanced optimizations [28, 16, 22, 34, 6] and to help generate provably secure mobile code <ref> [13, 26, 19, 23, 17] </ref>. The compiler can also propagate the type information into the target code to support sophisticated run-time type dispatches and garbage collection [14, 22, 34, 43]. <p> However, recent work <ref> [14, 22, 36, 30, 8, 29, 23] </ref> has mostly focused on the theoretical foundations or other language design issues. This paper complements previous work by showing that typed intermediate languages can indeed have practical and scalable implementations, but only if extreme care is taken. <p> Equality checking is often used by type-directed optimizations. For example, representation analysis [34] uses equality to determine where wrapping is necessary. Moreover, two compelling operations made possible by type-preserving compilation perform equality tests repeat edly: type-checking intermediate phases and certifying object code <ref> [26, 23] </ref>. Thus, the implementation should support efficient equality tests. Simple Interface. The software engineering benefits of hiding implementation details from clients are widely recognized.
Reference: [24] <author> G. Nadathur. </author> <title> A notation for lambda terms II: Refinements and applications. </title> <type> Technical Report CS-1994-01, </type> <institution> Duke University, Durham, NC, </institution> <month> January </month> <year> 1994. </year>
Reference-contexts: To achieve this property, we present a novel and efficient representation scheme for the FLINT type calculus. Our main idea is to combine hash-consing, memoization, and advanced lambda encoding <ref> [24, 1, 9] </ref> to ensure that (1) types are always represented as dags; (2) type reductions are done on a by-need basis; and (3) the cost of handling types is proportional to the size of the dag representations. <p> 42] have also used typed intermediate languages, but none of them have attempted to scale their implementations to handle large types; in fact, all these compilers have reported extremely slow compilation times as a result of keeping types during compilation. 2 * We combine hash-consing, memoization, and advanced lambda encoding <ref> [24, 1, 9] </ref> to support efficient type representation and manipulation. Although each of these techniques has been researched and implemented before, nobody has ever tried to combine them to represent compiler type information. <p> However, none of them has seriously addressed the problem of how to handle large types, nor do they support efficient run-time type passing. The suspension-based lambda encoding used in our implementation is directly borrowed from Nadathur's recent work on efficient lambda representations <ref> [25, 24] </ref>. In addition to doing an in-depth theoretical study of the underlying encoding calculus, Nadathur [24] has also used his encoding to implement the -Prolog system. <p> The suspension-based lambda encoding used in our implementation is directly borrowed from Nadathur's recent work on efficient lambda representations [25, 24]. In addition to doing an in-depth theoretical study of the underlying encoding calculus, Nadathur <ref> [24] </ref> has also used his encoding to implement the -Prolog system. The main contribution of our work is to combine Nadathur's encoding with hash-consing and memoization, and then apply it to the context of typed intermediate languages. <p> Instead, we use a positive integer #n to denote the variable bound by the nth surrounding -binder. Another important requirement is that type reduction should be done lazily. To achieve this, we enrich the constructor calculus to support a new suspension term <ref> [25, 24] </ref> of the form Env (; ). Intuitively, a suspension represents an unevaluated type "()"; it corresponds to the intermediate result of some unevaluated type applications. <p> involved () are also known as explicit substitutions [1, 9]: (constructor) ::= #n j Int j 1 ! 2 j : j 1 [ 2 ] j Env (; ) (substitution) ::= (i; j; env) (environment) env ::= nil j j :: env j (j; ) :: env Following Nadathur <ref> [24, 25] </ref>, we represent each such substitution as a triple (i; j; env) where the first index i indicates the current embedding level of bound type variables, the second index j indicates its new embedding level, and the environment env contains the actual bindings of all i bound variables. <p> Rule (r11) is a simple optimization to merge two nested substitutions. Notice that because all intermediate results are expressible in our calculus, the reduction rules do not involve any external substitution machinery. More details about the suspension-based calculus can be found in Nadathur's excellent paper <ref> [24] </ref>. 5.2 Hash-consing and memoization After we choose the appropriate encoding scheme, we hash-cons all FLINT kinds, type constructors (including substitutions), and types into three separate hash tables. Under hash-consing, all FLINT types built during the compilation are guaranteed to use the most compact dag representation.
Reference: [25] <author> G. Nadathur and D. S. Wilson. </author> <title> A representation of lambda terms suitable for operations on their intensions. </title> <booktitle> In 1990 ACM Conference on Lisp and Functional Programming, </booktitle> <pages> pages 341-348, </pages> <address> New York, June 1990. </address> <publisher> ACM Press. </publisher>
Reference-contexts: However, none of them has seriously addressed the problem of how to handle large types, nor do they support efficient run-time type passing. The suspension-based lambda encoding used in our implementation is directly borrowed from Nadathur's recent work on efficient lambda representations <ref> [25, 24] </ref>. In addition to doing an in-depth theoretical study of the underlying encoding calculus, Nadathur [24] has also used his encoding to implement the -Prolog system. <p> Instead, we use a positive integer #n to denote the variable bound by the nth surrounding -binder. Another important requirement is that type reduction should be done lazily. To achieve this, we enrich the constructor calculus to support a new suspension term <ref> [25, 24] </ref> of the form Env (; ). Intuitively, a suspension represents an unevaluated type "()"; it corresponds to the intermediate result of some unevaluated type applications. <p> involved () are also known as explicit substitutions [1, 9]: (constructor) ::= #n j Int j 1 ! 2 j : j 1 [ 2 ] j Env (; ) (substitution) ::= (i; j; env) (environment) env ::= nil j j :: env j (j; ) :: env Following Nadathur <ref> [24, 25] </ref>, we represent each such substitution as a triple (i; j; env) where the first index i indicates the current embedding level of bound type variables, the second index j indicates its new embedding level, and the environment env contains the actual bindings of all i bound variables.
Reference: [26] <author> G. Necula. </author> <title> Proof-carrying code. </title> <booktitle> In Twenty-Fourth Annual ACM Symp. on Principles of Prog. Languages, </booktitle> <address> New York, Jan 1997. </address> <publisher> ACM Press. </publisher>
Reference-contexts: A type-preserving compiler type-checks the source program, but then translates both the program and the (inferred) type information into the intermediate language. The rest of the compiler can use types to guide advanced optimizations [28, 16, 22, 34, 6] and to help generate provably secure mobile code <ref> [13, 26, 19, 23, 17] </ref>. The compiler can also propagate the type information into the target code to support sophisticated run-time type dispatches and garbage collection [14, 22, 34, 43]. <p> Equality checking is often used by type-directed optimizations. For example, representation analysis [34] uses equality to determine where wrapping is necessary. Moreover, two compelling operations made possible by type-preserving compilation perform equality tests repeat edly: type-checking intermediate phases and certifying object code <ref> [26, 23] </ref>. Thus, the implementation should support efficient equality tests. Simple Interface. The software engineering benefits of hiding implementation details from clients are widely recognized.
Reference: [27] <author> S. Peyton Jones. </author> <title> Implementing lazy functional languages on stock hardware: </title> <journal> the Spineless Tagless G-machine. Journal of Functional Programming, </journal> <volume> 2(2) </volume> <pages> 127-202, </pages> <month> April </month> <year> 1992. </year>
Reference-contexts: The main contributions of this paper are: * As far as we know, our work is the first comprehensive study on how to build scalable implementations of type-preserving production compilers. Several existing compilers <ref> [41, 27, 42] </ref> have also used typed intermediate languages, but none of them have attempted to scale their implementations to handle large types; in fact, all these compilers have reported extremely slow compilation times as a result of keeping types during compilation. 2 * We combine hash-consing, memoization, and advanced lambda <p> In fact, most of the techniques described in this paper have been incorporated into the SML/NJ production compiler since version 109.24 (Jan-uary 1997). Many results reported here are inspired by feedback from the SML/NJ user community. Several existing compilers such as TIL [41], GHC <ref> [27] </ref>, and ML-Kit [42] have also used an F ! -like calculus as their typed intermediate languages. However, none of them has seriously addressed the problem of how to handle large types, nor do they support efficient run-time type passing.
Reference: [28] <author> S. Peyton Jones and J. Launchbury. </author> <title> Unboxed values as first class citizens in a non-strict functional language. </title> <booktitle> In The Fifth International Conference on Functional Programming Languages and Computer Architecture, </booktitle> <pages> pages 636-666, </pages> <address> New York, </address> <month> August </month> <year> 1991. </year> <note> ACM Press. </note>
Reference-contexts: A type-preserving compiler type-checks the source program, but then translates both the program and the (inferred) type information into the intermediate language. The rest of the compiler can use types to guide advanced optimizations <ref> [28, 16, 22, 34, 6] </ref> and to help generate provably secure mobile code [13, 26, 19, 23, 17]. The compiler can also propagate the type information into the target code to support sophisticated run-time type dispatches and garbage collection [14, 22, 34, 43].
Reference: [29] <author> S. Peyton Jones, J. Launchbury, M. Shields, and A. Tol-mach. </author> <title> Bridging the gulf: a common intermediate language for ML and Haskell. </title> <booktitle> In Proc. 25rd Annual ACM SIGPLAN-SIGACT Symp. on Principles of Programming Languages, page (to appear). </booktitle> <publisher> ACM Press, </publisher> <year> 1998. </year>
Reference-contexts: However, recent work <ref> [14, 22, 36, 30, 8, 29, 23] </ref> has mostly focused on the theoretical foundations or other language design issues. This paper complements previous work by showing that typed intermediate languages can indeed have practical and scalable implementations, but only if extreme care is taken.
Reference: [30] <author> S. Peyton Jones and E. Meijer. Henk: </author> <title> a typed intermediate language. </title> <booktitle> In Proc. 1997 ACM SIGPLAN Workshop on Types in Compilation, </booktitle> <month> June </month> <year> 1997. </year>
Reference-contexts: However, recent work <ref> [14, 22, 36, 30, 8, 29, 23] </ref> has mostly focused on the theoretical foundations or other language design issues. This paper complements previous work by showing that typed intermediate languages can indeed have practical and scalable implementations, but only if extreme care is taken.
Reference: [31] <author> J. H. Reppy and E. R. Gansner. </author> <title> The eXene library manual. </title> <institution> Cornell Univ. Dept. of Computer Science, </institution> <month> March </month> <year> 1991. </year>
Reference-contexts: Figure 1 gives a profile of types built while compiling two large ML applications in our type-preserving compiler (see later sections for details about the compiler). Here, CM is the compilation manager [4] and eXene is an ML-based X window system tool-kit <ref> [31] </ref>. If we use tree representations, a single type can contain more than 45,518 nodes for CM and 379,315 nodes for eXene. These large types can be dramatically reduced in size if we use dag representations.
Reference: [32] <author> J. C. Reynolds. </author> <title> Towards a theory of type structure. </title> <booktitle> In Proceedings, Colloque sur la Programmation, Lecture Notes in Computer Science, </booktitle> <volume> volume 19, </volume> <pages> pages 408-425. </pages> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1974. </year>
Reference-contexts: This paper describes our experience with implementing the FLINT typed intermediate language [36] in the SML/NJ production compiler [39, 3]. FLINT is based on a pred-icative variant of the polymorphic -calculus F ! <ref> [12, 32, 15] </ref>, extended with a rich set of primitive types and functions. FLINT supports both polymorphic types and higher-order type constructors, so the type language itself is a full-scale -calculus. To support various type-directed optimizations [14, 34], we perform a large number of type-related operations during compilation. <p> A more detailed comparison between our scheme and the lettype scheme is given in Section 8. 3 An Overview of FLINT The core language of FLINT is based on a predicative variant of the Girard-Reynolds polymorphic -calculus F ! <ref> [12, 32] </ref>, with the term language written in A-normal form [10]. It contains the following four syntactic classes: kinds (), type constructors (), types (), terms (e), as shown in classify terms. Constructors of kind name monotypes. The monotypes are generated from variables, from Int, and through the ! constructor.
Reference: [33] <author> B. Saha and Z. Shao. </author> <title> Optimal type lifting. </title> <booktitle> In Proc. 1998 International Workshop on Types in Compilation, </booktitle> <month> March </month> <year> 1998. </year>
Reference-contexts: In a companion paper <ref> [33] </ref>, we have presented a new optimal type-lifting algorithm that lifts all run-time type constructions to the top level; in fact, we can guarantee that the number of types built at run time is a compile-time constant; furthermore, all of them are represented as efficiently as their compile-time counterparts.
Reference: [34] <author> Z. Shao. </author> <title> Flexible representation analysis. </title> <booktitle> In Proc. 1997 ACM SIGPLAN International Conference on Functional Programming (ICFP'97), </booktitle> <pages> pages 85-98. </pages> <publisher> ACM Press, </publisher> <month> June </month> <year> 1997. </year>
Reference-contexts: A type-preserving compiler type-checks the source program, but then translates both the program and the (inferred) type information into the intermediate language. The rest of the compiler can use types to guide advanced optimizations <ref> [28, 16, 22, 34, 6] </ref> and to help generate provably secure mobile code [13, 26, 19, 23, 17]. The compiler can also propagate the type information into the target code to support sophisticated run-time type dispatches and garbage collection [14, 22, 34, 43]. <p> The compiler can also propagate the type information into the target code to support sophisticated run-time type dispatches and garbage collection <ref> [14, 22, 34, 43] </ref>. Unfortunately, type information is very hard to represent and manipulate efficiently, especially when the underlying type system involves ML-like polymorphic types and module types [21]. A naive implementation can easily add exponential overhead to the compilation and execution of a program. <p> FLINT is based on a pred-icative variant of the polymorphic -calculus F ! [12, 32, 15], extended with a rich set of primitive types and functions. FLINT supports both polymorphic types and higher-order type constructors, so the type language itself is a full-scale -calculus. To support various type-directed optimizations <ref> [14, 34] </ref>, we perform a large number of type-related operations during compilation. The main challenge is to represent complex FLINT types (which can be arbitrary lambda terms) as compact dags so that common type-related operations (e.g., lambda reductions, equality) can always work efficiently and yet still preserve sharing. <p> The middle end does conventional dataflow optimizations, type specializations, and -calculus-based contractions and reductions, producing an optimized version of the FLINT code. The back end compiles FLINT into machine code through the usual phases such as representation analysis <ref> [34] </ref>, safe-for-space closure conversion [38], register allocation, instruction scheduling, and machine-code generation [11]. 3 Of course, we could always expand out the lettype definitions to get to a normal form, but this eliminates the benefit of using lettype and is equivalent to using tree representations. 3 signature LTYEXTERN = sig (* <p> In order to maintain reasonable compilation time, such operations must traverse the representation linearly. Fast equality. Checking the equivalence of two types can be non-trivial, because there are many ways to represent the same type. Equality checking is often used by type-directed optimizations. For example, representation analysis <ref> [34] </ref> uses equality to determine where wrapping is necessary. Moreover, two compelling operations made possible by type-preserving compilation perform equality tests repeat edly: type-checking intermediate phases and certifying object code [26, 23]. Thus, the implementation should support efficient equality tests. Simple Interface.
Reference: [35] <author> Z. Shao. </author> <title> An overview of the FLINT/ML compiler. </title> <booktitle> In Proc. 1997 ACM SIGPLAN Workshop on Types in Compilation, </booktitle> <month> June </month> <year> 1997. </year>
Reference-contexts: All techniques have been implemented in the FLINT/ML compiler <ref> [35] </ref> and in the SML/NJ production compiler since version 109.24 (January 9, 1997). All tests were performed on a Pentium Pro 200 Linux workstation with 64M physical RAM. a summary of their salient features, including the size of the types. <p> We believe what we learned from our implementation will be valuable to future implementations of other emerging typed intermediate languages. Availability The implementation discussed in this paper is now released with the Standard ML of New Jersey (SML/NJ) compiler and the FLINT/ML compiler <ref> [35] </ref>. SML/NJ is a joint work by Lucent, Princeton, Yale and AT&T. FLINT is a modern compiler infrastructure developed at Yale University.
Reference: [36] <author> Z. Shao. </author> <title> Typed common intermediate format. </title> <booktitle> In Proc. 1997 USENIX Conference on Domain Specific Languages, </booktitle> <pages> pages 89-102, </pages> <month> October </month> <year> 1997. </year>
Reference-contexts: This paper describes our experience with implementing the FLINT typed intermediate language <ref> [36] </ref> in the SML/NJ production compiler [39, 3]. FLINT is based on a pred-icative variant of the polymorphic -calculus F ! [12, 32, 15], extended with a rich set of primitive types and functions. <p> However, recent work <ref> [14, 22, 36, 30, 8, 29, 23] </ref> has mostly focused on the theoretical foundations or other language design issues. This paper complements previous work by showing that typed intermediate languages can indeed have practical and scalable implementations, but only if extreme care is taken.
Reference: [37] <author> Z. Shao. </author> <title> Typed cross-module compilation. </title> <booktitle> In Proc. 1998 ACM SIGPLAN International Conference on Functional Programming (ICFP'98). </booktitle> <publisher> ACM Press, </publisher> <month> September </month> <year> 1998. </year>
Reference-contexts: The actual FLINT language contains other familiar constructs such as record, recursive datatype, and a rich set of primitive types and operators. Large types mainly come from ML-style modules (which are represented as FLINT records <ref> [37] </ref>) and recursive datatypes, but the challenge of implementing FLINT still lies on how we handle three forms of type abstractions, i.e., constructor function (t :: :), polymorphic type (8t :: :), and polymorphic function (flt :: :e). We present our solutions in Sections 5 and 6.
Reference: [38] <author> Z. Shao and A. W. Appel. </author> <title> Space-efficient closure representations. </title> <booktitle> In 1994 ACM Conference on Lisp and Functional Programming, </booktitle> <pages> pages 150-161, </pages> <address> New York, June 1994. </address> <publisher> ACM Press. </publisher>
Reference-contexts: The middle end does conventional dataflow optimizations, type specializations, and -calculus-based contractions and reductions, producing an optimized version of the FLINT code. The back end compiles FLINT into machine code through the usual phases such as representation analysis [34], safe-for-space closure conversion <ref> [38] </ref>, register allocation, instruction scheduling, and machine-code generation [11]. 3 Of course, we could always expand out the lettype definitions to get to a normal form, but this eliminates the benefit of using lettype and is equivalent to using tree representations. 3 signature LTYEXTERN = sig (* abstract types *) type
Reference: [39] <author> Z. Shao and A. W. Appel. </author> <title> A type-based compiler for Standard ML. </title> <booktitle> In Proc. ACM SIGPLAN '95 Conf. on Prog. Lang. Design and Implementation, </booktitle> <pages> pages 116-129. </pages> <publisher> ACM Press, </publisher> <year> 1995. </year>
Reference-contexts: This paper describes our experience with implementing the FLINT typed intermediate language [36] in the SML/NJ production compiler <ref> [39, 3] </ref>. FLINT is based on a pred-icative variant of the polymorphic -calculus F ! [12, 32, 15], extended with a rich set of primitive types and functions. FLINT supports both polymorphic types and higher-order type constructors, so the type language itself is a full-scale -calculus. <p> Explicit substitutions [9, 1] is another related lambda encoding scheme. Cardelli's Quest compiler [1] contains an implementation of this encoding; however, he did not combine it with other techniques we used. Nor was he working in the context of type-preserving compilers. Shao and Appel <ref> [39] </ref> used hash-consing to enforce dag representations for types; however, their intermediate language is only monomorphically typed, so it is much easier to support than FLINT-like languages.
Reference: [40] <author> D. Tarditi. </author> <title> Design and Implementation of Code Optimizations for a Type-Directed Compiler for Standard ML. </title> <type> PhD thesis, </type> <institution> School of Computer Science, Carnegie Mellon University, </institution> <address> Pittsburgh, PA, </address> <month> December </month> <year> 1996. </year> <note> Tech Report CMU-CS-97-108. </note>
Reference-contexts: of these techniques can reduce the total compilation time by up to 72% on large applications (a reduction of 93% in the type-preserving phases). * We also present a detailed comparison between our scheme and the lettype scheme used in the TIL/ML compiler (also informally described in Tarditi's the sis <ref> [40] </ref>). 2 Related Work Typed intermediate languages have received much attention lately, especially in the HOT (higher-order and typed) language community. However, recent work [14, 22, 36, 30, 8, 29, 23] has mostly focused on the theoretical foundations or other language design issues. <p> Nor was he working in the context of type-preserving compilers. Shao and Appel [39] used hash-consing to enforce dag representations for types; however, their intermediate language is only monomorphically typed, so it is much easier to support than FLINT-like languages. Tarditi <ref> [40] </ref> used the lettype constructs (in both the constructor calculus and the term language) to A-normalize [10] all types in order to express sharing explicitly. But he relies on a separate common sub-expression elimination phase to identify the sharing information. <p> Here also, our experience has shown that it is not a serious issue. Our choice of techniques to provide efficient type manipulation should be contrasted with the lettype scheme used in the TIL compiler <ref> [40] </ref>. It should be noted here that very little has been published about the lettype scheme, so this comparison is based on our own understanding of what lettype could look like under the ideal scenario rather than any existing implementation such as the one in the TIL compiler.
Reference: [41] <author> D. Tarditi, G. Morrisett, P. Cheng, C. Stone, R. Harper, and P. Lee. </author> <title> TIL: A type-directed optimizing compiler for ML. </title> <booktitle> In Proc. ACM SIGPLAN '96 Conf. on Prog. Lang. Design and Implementation, </booktitle> <pages> pages 181-192. </pages> <publisher> ACM Press, </publisher> <year> 1996. </year>
Reference-contexts: The main contributions of this paper are: * As far as we know, our work is the first comprehensive study on how to build scalable implementations of type-preserving production compilers. Several existing compilers <ref> [41, 27, 42] </ref> have also used typed intermediate languages, but none of them have attempted to scale their implementations to handle large types; in fact, all these compilers have reported extremely slow compilation times as a result of keeping types during compilation. 2 * We combine hash-consing, memoization, and advanced lambda <p> In fact, most of the techniques described in this paper have been incorporated into the SML/NJ production compiler since version 109.24 (Jan-uary 1997). Many results reported here are inspired by feedback from the SML/NJ user community. Several existing compilers such as TIL <ref> [41] </ref>, GHC [27], and ML-Kit [42] have also used an F ! -like calculus as their typed intermediate languages. However, none of them has seriously addressed the problem of how to handle large types, nor do they support efficient run-time type passing.
Reference: [42] <author> M. Tofte. </author> <title> Region-based memory management (invited talk). </title> <booktitle> In Proc. 1998 International Workshop on Types in Compilation, </booktitle> <month> March </month> <year> 1998. </year>
Reference-contexts: The main contributions of this paper are: * As far as we know, our work is the first comprehensive study on how to build scalable implementations of type-preserving production compilers. Several existing compilers <ref> [41, 27, 42] </ref> have also used typed intermediate languages, but none of them have attempted to scale their implementations to handle large types; in fact, all these compilers have reported extremely slow compilation times as a result of keeping types during compilation. 2 * We combine hash-consing, memoization, and advanced lambda <p> In fact, most of the techniques described in this paper have been incorporated into the SML/NJ production compiler since version 109.24 (Jan-uary 1997). Many results reported here are inspired by feedback from the SML/NJ user community. Several existing compilers such as TIL [41], GHC [27], and ML-Kit <ref> [42] </ref> have also used an F ! -like calculus as their typed intermediate languages. However, none of them has seriously addressed the problem of how to handle large types, nor do they support efficient run-time type passing.
Reference: [43] <author> A. Tolmach. </author> <title> Tag-free garbage collection using explicit type parameters. </title> <booktitle> In Proc. 1994 ACM Conf. on Lisp and Functional Programming, </booktitle> <pages> pages 1-11, </pages> <address> New York, June 1994. </address> <publisher> ACM Press. </publisher> <pages> 11 </pages>
Reference-contexts: The compiler can also propagate the type information into the target code to support sophisticated run-time type dispatches and garbage collection <ref> [14, 22, 34, 43] </ref>. Unfortunately, type information is very hard to represent and manipulate efficiently, especially when the underlying type system involves ML-like polymorphic types and module types [21]. A naive implementation can easily add exponential overhead to the compilation and execution of a program.
References-found: 43

