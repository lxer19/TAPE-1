URL: http://kirmes.inferenzsysteme.informatik.tu-darmstadt.de/~reports/notes/ibn-96-34.ps
Refering-URL: http://www.inferenzsysteme.informatik.tu-darmstadt.de/~reports/
Root-URL: http://www.aic.nrl.navy.mil/~aha/people.html
Email: E-mail: thomas@cs.ruu.nl  E-mail: giesl@inferenzsysteme.informatik.th-darmstadt.de  
Phone: 2  
Title: Termination of Constructor Systems  
Author: Thomas Arts and Jurgen Giesl 
Address: P.O. Box 80.089, 3508 TB Utrecht, The Netherlands,  Alexanderstr. 10, 64283 Darmstadt, Germany,  
Affiliation: 1 Dept. of Computer Science, Utrecht University,  FB Informatik, TH Darmstadt,  
Abstract: We present a method to prove termination of constructor systems automatically. Our approach takes advantage of the special form of these rewrite systems because for constructor systems instead of left- and right-hand sides of rules it is sufficient to compare so-called dependency pairs [Art96]. Unfortunately, standard techniques for the generation of well-founded orderings cannot be directly used for the automation of the dependency pair approach. To solve this problem we have developed a transformation technique which enables the application of known synthesis methods for well-founded orderings to prove that dependency pairs are decreasing. In this way termination of many (also non-simply termi nating) constructor systems can be proved fully automatically.
Abstract-found: 1
Intro-found: 1
Reference: [Art96] <author> T. </author> <title> Arts. Termination by absence of infinite chains of dependency pairs. </title> <booktitle> In Proc. Coll. Trees in Algebra and Programming, </booktitle> <address> Linkoping, Sweden, </address> <year> 1996. </year>
Reference-contexts: Due to the special form of these rewrite systems it is possible to use a different approach for CSs than is necessary for termination of general rewrite systems. Therefore, in this paper we focus on a technique specially tailored for CSs, viz. the so-called dependency pair approach <ref> [Art96] </ref>. With this approach it is also possible to prove termination of systems where all simplification orderings fail. In Sect. 2 we describe which steps have to be performed (automatically) to verify termination of CSs using this approach. <p> The proofs of all theorems of this section are based on semantic labelling [Zan95] and can be found in <ref> [Art96] </ref>. <p> For the first task, in <ref> [Art96] </ref> a method is presented to generate suitable CSs E for a subclass of CSs R automatically. <p> This subclass consists of non-overlapping 2 hierarchical combinations [KR95] (a CS is a hierarchical combination of two CSs 1 In many examples it is sufficient if only certain dependency pairs are decreasing and several methods to determine those dependency pairs have been suggested in <ref> [Art96] </ref>. 2 This requirement can even be weakened to overlay systems with joinable critical pairs. 3 if defined symbols of the first CS occur as constructors in the second CS, but not vice versa) without nested defined symbols in the second CS (i.e. the rules do not contain subterms of the <p> Our method works as follows: For a CS R a ground-convergent CS E is synthesized in which R is contained. (For CSs that are hierarchical combinations of a certain type, a suitable E can be immediately obtained automatically, cf. <ref> [Art96] </ref>.) Let DP be the set of inequalities which ensure that all dependency pairs are decreasing. Then by application of the estimation technique DP is trans formed into a new set of inequalities DP 0 without defined symbols. <p> For every CS, a set of dependency pairs is given. Note that not all dependency pairs are given. Only those dependency pairs that are relevant are listed. For more information about which dependency pairs are relevant and which are not, we refer to <ref> [Art96] </ref>. 1 Division, Version 1 This is the running example of this report.
Reference: [AG96] <author> T. Arts & J. Giesl. </author> <title> Termination of constructor systems. </title> <booktitle> In Proceedings of the 7th International Conference on Rewriting Techniques and Applications, </booktitle> <publisher> LNCS, </publisher> <address> New Brunswick, NJ, USA, </address> <year> 1996. </year>
Reference-contexts: Although the dependency pair approach may be used for arbitrary CSs, in this paper we focus on special hierarchical combinations of CSs ensuring that all steps can be performed automatically. ? Technical Report IBN 96/34, Technische Hochschule Darmstadt. This is an extended version of a paper <ref> [AG96] </ref> which appeared in the Proceedings of the 7th International Conference on Rewriting Techniques and Applications, New Brunswick, NJ, USA, LNCS, Springer-Verlag, 1996. This work was supported by the Deutsche Forschungsgemeinschaft under grant no. Wa 652/7-1 as part of the focus program "Deduktion".
Reference: [BD86] <author> L. Bachmair & N. Dershowitz. </author> <title> Commutation, transformation and termination. </title> <booktitle> In Proc. 8th CADE, </booktitle> <publisher> LNCS 230, Oxford, </publisher> <address> England, </address> <year> 1986. </year>
Reference-contexts: While in general this problem is undecidable [HL78], several methods for proving termination have been developed (e.g. path orderings [Pla78, Der82, Ges94, DH95, Ste95b], Knuth-Bendix orderings [KB70, Mar87], semantic interpretations [MN70, Lan79, BCL87, BL93, Ste94, Zan94, Gie95b], transformation orderings <ref> [BD86, BL90, Ste95a] </ref>, semantic labelling [Zan95] etc. | for surveys see e.g. [Der87, Ste95b]). In this paper we are concerned with the automation of termination proofs for constructor systems (CS for short).
Reference: [BL90] <author> F. Bellegarde & P. Lescanne. </author> <title> Termination by completion. Applicable Algebra in Engineering, </title> <journal> Communication and Computing, </journal> <volume> 1 </volume> <pages> 79-96, </pages> <year> 1990. </year>
Reference-contexts: While in general this problem is undecidable [HL78], several methods for proving termination have been developed (e.g. path orderings [Pla78, Der82, Ges94, DH95, Ste95b], Knuth-Bendix orderings [KB70, Mar87], semantic interpretations [MN70, Lan79, BCL87, BL93, Ste94, Zan94, Gie95b], transformation orderings <ref> [BD86, BL90, Ste95a] </ref>, semantic labelling [Zan95] etc. | for surveys see e.g. [Der87, Ste95b]). In this paper we are concerned with the automation of termination proofs for constructor systems (CS for short).
Reference: [BL93] <author> E. Bevers & J. Lewi. </author> <title> Proving termination of (conditional) rewrite systems. </title> <journal> Acta Informatica, </journal> <volume> 30 </volume> <pages> 537-568, </pages> <year> 1993. </year>
Reference-contexts: 1 Introduction One of the most interesting properties of a term rewriting system is termination, cf. e.g. [DJ90]. While in general this problem is undecidable [HL78], several methods for proving termination have been developed (e.g. path orderings [Pla78, Der82, Ges94, DH95, Ste95b], Knuth-Bendix orderings [KB70, Mar87], semantic interpretations <ref> [MN70, Lan79, BCL87, BL93, Ste94, Zan94, Gie95b] </ref>, transformation orderings [BD86, BL90, Ste95a], semantic labelling [Zan95] etc. | for surveys see e.g. [Der87, Ste95b]). In this paper we are concerned with the automation of termination proofs for constructor systems (CS for short). <p> Our approach fails if a well-founded quasi-ordering satisfying the generated constraints DP 0 cannot be found automatically. Therefore apart from the estimation technique we plan to examine alternative possibilities to derive suitable constraints DP 0 , which may be advantageous for further sophisticated termination proofs (cf. <ref> [BM79, BL93, Wal94, Gie95d] </ref>). For that purpose, future work will include an investigation on possible combinations of our method with induction theorem proving systems (e.g. [BM79, BHHW86, KZ89, BHHS90, BKR92]).
Reference: [BCL87] <author> A. Ben Cherifa & P. Lescanne. </author> <title> Termination of rewriting systems by polynomial interpretations and its implementation. </title> <booktitle> Science of Computer Programming, </booktitle> <volume> 9(2) </volume> <pages> 137-159, </pages> <year> 1987. </year>
Reference-contexts: 1 Introduction One of the most interesting properties of a term rewriting system is termination, cf. e.g. [DJ90]. While in general this problem is undecidable [HL78], several methods for proving termination have been developed (e.g. path orderings [Pla78, Der82, Ges94, DH95, Ste95b], Knuth-Bendix orderings [KB70, Mar87], semantic interpretations <ref> [MN70, Lan79, BCL87, BL93, Ste94, Zan94, Gie95b] </ref>, transformation orderings [BD86, BL90, Ste95a], semantic labelling [Zan95] etc. | for surveys see e.g. [Der87, Ste95b]). In this paper we are concerned with the automation of termination proofs for constructor systems (CS for short).
Reference: [BHHW86] <author> S. Biundo, B. Hummel, D. Hutter & C. Walther. </author> <title> The Karlsruhe induction theorem proving system. </title> <booktitle> 8th CADE, </booktitle> <publisher> LNCS 230, Oxford, </publisher> <address> England, </address> <year> 1986. </year>
Reference-contexts: For that purpose, future work will include an investigation on possible combinations of our method with induction theorem proving systems (e.g. <ref> [BM79, BHHW86, KZ89, BHHS90, BKR92] </ref>). Acknowledgements Thanks are due to Hans Zantema and Thomas Kolbe for the discussions we have had on the subjects described in this paper and for their very helpful criticism. Appendix This appendix contains a collection of examples which demonstrate the power of the described method.
Reference: [BKR92] <author> A. Bouhoula, E. Kounalis & M. Rusinowitch. spike: </author> <title> an automatic theorem prover. </title> <booktitle> In Proceedings of the Conference on Logic Programming and Automated Reasoning, </booktitle> <publisher> LNAI 624, </publisher> <address> St. Petersburg, Russia, </address> <year> 1992. </year>
Reference-contexts: For that purpose, future work will include an investigation on possible combinations of our method with induction theorem proving systems (e.g. <ref> [BM79, BHHW86, KZ89, BHHS90, BKR92] </ref>). Acknowledgements Thanks are due to Hans Zantema and Thomas Kolbe for the discussions we have had on the subjects described in this paper and for their very helpful criticism. Appendix This appendix contains a collection of examples which demonstrate the power of the described method.
Reference: [BM79] <author> R. S. Boyer & J S. Moore. </author> <title> A computational logic. </title> <publisher> Academic Press, </publisher> <year> 1979. </year>
Reference-contexts: Our approach fails if a well-founded quasi-ordering satisfying the generated constraints DP 0 cannot be found automatically. Therefore apart from the estimation technique we plan to examine alternative possibilities to derive suitable constraints DP 0 , which may be advantageous for further sophisticated termination proofs (cf. <ref> [BM79, BL93, Wal94, Gie95d] </ref>). For that purpose, future work will include an investigation on possible combinations of our method with induction theorem proving systems (e.g. [BM79, BHHW86, KZ89, BHHS90, BKR92]). <p> For that purpose, future work will include an investigation on possible combinations of our method with induction theorem proving systems (e.g. <ref> [BM79, BHHW86, KZ89, BHHS90, BKR92] </ref>). Acknowledgements Thanks are due to Hans Zantema and Thomas Kolbe for the discussions we have had on the subjects described in this paper and for their very helpful criticism. Appendix This appendix contains a collection of examples which demonstrate the power of the described method. <p> The rest of the ordering is as in the preceding examples (i.e. pred (x) and minus (x; y) are mapped to x and all remaining function symbols are mapped to 0). This example was taken from <ref> [BM79] </ref> resp. [Wal91]. <p> All remaining function symbols are mapped to the constant 0. This example is inspired by an algorithm from <ref> [BM79] </ref> and [Wal94]. In the corresponding example from [Ste92] the rules for le, eq, if rm and if min were missing. 11 Quicksort The quicksort CS is used to sort a list by the well-known quicksort-algorithm.
Reference: [BHHS90] <author> A. Bundy, F. van Harmelen, C. Horn & A. Smaill. </author> <title> The oyster-clam system. </title> <booktitle> In Proc. 10th CADE, </booktitle> <publisher> LNAI 449, </publisher> <address> Kaiserslautern, Germany, </address> <year> 1990. </year>
Reference-contexts: For that purpose, future work will include an investigation on possible combinations of our method with induction theorem proving systems (e.g. <ref> [BM79, BHHW86, KZ89, BHHS90, BKR92] </ref>). Acknowledgements Thanks are due to Hans Zantema and Thomas Kolbe for the discussions we have had on the subjects described in this paper and for their very helpful criticism. Appendix This appendix contains a collection of examples which demonstrate the power of the described method.
Reference: [Der79] <author> N. Dershowitz. </author> <title> A note on simplification orderings. </title> <journal> Information Processing Letters, </journal> <volume> 9(5) </volume> <pages> 212-215, </pages> <year> 1979. </year>
Reference-contexts: following CS: minus (x; 0) ! x; minus (succ (x); succ (y)) ! minus (x; y); quot (0; succ (y)) ! 0; quot (succ (x); succ (y)) ! succ (quot (minus (x; y); succ (y))): Most methods for automated termination proofs of term rewriting systems are restricted to simplification orderings <ref> [Der79, Ste95b] </ref>. These methods cannot prove termination of the above CS, because no simplification ordering can orient the fourth rule if y is instantiated to succ (x).
Reference: [Der82] <author> N. Dershowitz. </author> <title> Orderings for term-rewriting systems. </title> <journal> Theoretical Computer Science, </journal> <volume> 17 </volume> <pages> 279-301, </pages> <year> 1982. </year>
Reference-contexts: 1 Introduction One of the most interesting properties of a term rewriting system is termination, cf. e.g. [DJ90]. While in general this problem is undecidable [HL78], several methods for proving termination have been developed (e.g. path orderings <ref> [Pla78, Der82, Ges94, DH95, Ste95b] </ref>, Knuth-Bendix orderings [KB70, Mar87], semantic interpretations [MN70, Lan79, BCL87, BL93, Ste94, Zan94, Gie95b], transformation orderings [BD86, BL90, Ste95a], semantic labelling [Zan95] etc. | for surveys see e.g. [Der87, Ste95b]). <p> The reason is that arbitrary orderings do not respect the equalities induced by E. 3 This can for instance be done with standard techniques like e.g. the recursive path ordering <ref> [Der82] </ref> or again by the dependency pair approach. <p> The constraint DP = fF (succ (x)) F (double (x))g is for instance satisfied by the recursive path ordering rpo , cf. <ref> [Der82] </ref>. Nevertheless, R is not terminating (e.g. f (succ (succ (0))) starts an infinite reduction). This direct application of orderings is not possible because the constraints in DP only compare the terms s and t but not their E -interpretations. <p> consist of the two minus-rules and we obtain the constraint DP = fQ (succ (x); succ (y)) Q (minus (x; y); succ (y))g: (4) None of the well-founded quasi-orderings that can be generated automatically by the usual techniques satisfies DP [ EQ: Virtually all of those quasi-orderings are quasi-simplification-orderings 4 <ref> [Der82] </ref>. Hence, if % is a quasi-simplification-ordering satisfying EQ, then we have Q (minus (x; y); succ (y)) ~ Q (minus (succ (x); succ (y)); succ (y)) (as minus (x; y) ~ minus (succ (x); succ (y)) holds and as quasi-simplification-or-derings are (weakly) monotonic).
Reference: [Der87] <author> N. Dershowitz. </author> <title> Termination of rewriting. </title> <journal> Journal of Symbolic Computation, </journal> <volume> 3(1, </volume> 2):69-115, 1987. 
Reference-contexts: in general this problem is undecidable [HL78], several methods for proving termination have been developed (e.g. path orderings [Pla78, Der82, Ges94, DH95, Ste95b], Knuth-Bendix orderings [KB70, Mar87], semantic interpretations [MN70, Lan79, BCL87, BL93, Ste94, Zan94, Gie95b], transformation orderings [BD86, BL90, Ste95a], semantic labelling [Zan95] etc. | for surveys see e.g. <ref> [Der87, Ste95b] </ref>). In this paper we are concerned with the automation of termination proofs for constructor systems (CS for short). Due to the special form of these rewrite systems it is possible to use a different approach for CSs than is necessary for termination of general rewrite systems.
Reference: [DJ90] <author> N. Dershowitz & J.-P. Jouannaud. </author> <title> Rewrite systems. Handbook of Theoret. Comp. Sc., </title> <editor> J. van Leeuwen, ed., </editor> <volume> vol. </volume> <editor> B, ch. </editor> <volume> 6, </volume> <pages> pp. 243-320, </pages> <publisher> Elsevier, </publisher> <year> 1990. </year>
Reference-contexts: 1 Introduction One of the most interesting properties of a term rewriting system is termination, cf. e.g. <ref> [DJ90] </ref>.
Reference: [DH95] <author> N. Dershowitz & C. Hoot. </author> <title> Natural Termination. </title> <journal> Theoretical Computer Science, </journal> <volume> 142(2) </volume> <pages> 179-207, </pages> <year> 1995. </year>
Reference-contexts: 1 Introduction One of the most interesting properties of a term rewriting system is termination, cf. e.g. [DJ90]. While in general this problem is undecidable [HL78], several methods for proving termination have been developed (e.g. path orderings <ref> [Pla78, Der82, Ges94, DH95, Ste95b] </ref>, Knuth-Bendix orderings [KB70, Mar87], semantic interpretations [MN70, Lan79, BCL87, BL93, Ste94, Zan94, Gie95b], transformation orderings [BD86, BL90, Ste95a], semantic labelling [Zan95] etc. | for surveys see e.g. [Der87, Ste95b]).
Reference: [FZ95] <author> M. C. F. Ferreira & H. Zantema. </author> <title> Dummy elimination: making termination easier. </title> <booktitle> In Proceedings of the 10th International Conference on Fundamentals of Computation Theory, LNCS 965, </booktitle> <address> Dresden, Germany, </address> <year> 1995 </year> <month> 30 </month>
Reference-contexts: The reason is that simplification orderings are monotonic and satisfy the subterm property and this implies succ (quot (minus (x; succ (x)); succ (succ (x)))) quot (succ (x); succ (succ (x))). All other known techniques for automated termination proofs of non-simply terminating systems <ref> [Zan94, Ste95a, Ken95, FZ95] </ref> fail with this example, too. However, with the dependency pair approach an automated termination proof of the above CS is possible.
Reference: [Ges94] <author> A. Geser. </author> <title> An improved general path order. </title> <type> Technical Report MIP-9407, </type> <institution> Universitat Passau, Germany. </institution> <note> To appear in Applicable Algebra in Engineering, Communication, and Computation. </note>
Reference-contexts: 1 Introduction One of the most interesting properties of a term rewriting system is termination, cf. e.g. [DJ90]. While in general this problem is undecidable [HL78], several methods for proving termination have been developed (e.g. path orderings <ref> [Pla78, Der82, Ges94, DH95, Ste95b] </ref>, Knuth-Bendix orderings [KB70, Mar87], semantic interpretations [MN70, Lan79, BCL87, BL93, Ste94, Zan94, Gie95b], transformation orderings [BD86, BL90, Ste95a], semantic labelling [Zan95] etc. | for surveys see e.g. [Der87, Ste95b]).
Reference: [Gie95a] <institution> J. Giesl, Automatisierung von Terminierungsbeweisen fur rekursiv definier-te Algorithmen. Doctoral Dissertation, Technische Hochschule Darmstadt, Germany, </institution> <year> 1995. </year>
Reference-contexts: x + y. 13 Reachability on Directed Graphs To check whether there is a path from the node x to the node y in a directed graph g, the term reach (x; y; g; *) must be reducible to true with the rules of the CS of this example from <ref> [Gie95a] </ref>. The fourth argument of reach is used to store edges that have already been examined but that are not included in the actual solution path. If an edge from u to v (with x 6= u) is found, then it is rejected at first.
Reference: [Gie95b] <author> J. Giesl. </author> <title> Generating polynomial orderings for termination proofs. </title> <booktitle> In Proc. 6th RTA, LNCS 914, </booktitle> <address> Kaiserslautern, Germany, </address> <year> 1995. </year>
Reference-contexts: 1 Introduction One of the most interesting properties of a term rewriting system is termination, cf. e.g. [DJ90]. While in general this problem is undecidable [HL78], several methods for proving termination have been developed (e.g. path orderings [Pla78, Der82, Ges94, DH95, Ste95b], Knuth-Bendix orderings [KB70, Mar87], semantic interpretations <ref> [MN70, Lan79, BCL87, BL93, Ste94, Zan94, Gie95b] </ref>, transformation orderings [BD86, BL90, Ste95a], semantic labelling [Zan95] etc. | for surveys see e.g. [Der87, Ste95b]). In this paper we are concerned with the automation of termination proofs for constructor systems (CS for short). <p> Methods for the automated generation of such polynomial orderings have for instance been developed in <ref> [Ste94, Gie95b] </ref>. In this way termination of the CS for minus and quot can be proved fully automatically. 5 Conclusion and Further Work We have developed a method for automated termination proofs of constructor systems which uses an estimation technique to automate the analysis of dependency pairs. <p> Our method has been tested on numerous practically relevant CSs from different areas of computer science (using a system for the automated generation of polynomial orderings <ref> [Gie95b] </ref>) and proved successful. A collection of examples which demonstrate the power of our method (including arithmetical operations such as gcd and logarithm, several sorting algorithms such as quicksort or selection sort as well as functions on trees and graphs (e.g. a reachability algorithm)) can be found in the appendix. <p> These orderings trivially always have a minimal element and the ordering is weakly monotonic as long as the interpreted functions are weakly monotonic. Several techniques exist to derive the interpretations automatically <ref> [Gie95b, Ste94] </ref>. To easy readability the CSs are presented as two sets of rewrite rules separated by some vertical space. The upper system will always denote R 0 , whereas the bottom rules will denote R 1 . For every CS, a set of dependency pairs is given.
Reference: [Gie95c] <author> J. Giesl. </author> <title> Automated termination proofs with measure functions. </title> <booktitle> In Proc. 19th Annual German Conf. on AI, </booktitle> <publisher> LNAI 981, </publisher> <address> Bielefeld, Germany, </address> <year> 1995. </year>
Reference-contexts: Therefore in Sect. 4 we suggest a new technique to enable the application of standard methods for the generation of well-founded orderings to prove that dependency pairs are decreasing. For that purpose we transfer a variant of the estimation method <ref> [Wal94, Gie95c, Gie95d] </ref>, which was originally developed for termination proofs of functional programs, to rewrite systems.
Reference: [Gie95d] <author> J. Giesl. </author> <title> Termination analysis for functional programs using term order-ings. </title> <booktitle> In Proceedings of the Second International Static Analysis Symposium, LNCS 983, </booktitle> <address> Glasgow, Scotland, </address> <year> 1995. </year>
Reference-contexts: Therefore in Sect. 4 we suggest a new technique to enable the application of standard methods for the generation of well-founded orderings to prove that dependency pairs are decreasing. For that purpose we transfer a variant of the estimation method <ref> [Wal94, Gie95c, Gie95d] </ref>, which was originally developed for termination proofs of functional programs, to rewrite systems. <p> But for instance, IN minus % minus does not guarantee minus (0; succ (0)) % minus (0; succ (0)). 5 While in the original estimation method for functional programs <ref> [Gie95d] </ref> functions had to be completely defined, here we have to extend the estimation method to incompletely defined functions. <p> Our approach fails if a well-founded quasi-ordering satisfying the generated constraints DP 0 cannot be found automatically. Therefore apart from the estimation technique we plan to examine alternative possibilities to derive suitable constraints DP 0 , which may be advantageous for further sophisticated termination proofs (cf. <ref> [BM79, BL93, Wal94, Gie95d] </ref>). For that purpose, future work will include an investigation on possible combinations of our method with induction theorem proving systems (e.g. [BM79, BHHW86, KZ89, BHHS90, BKR92]).
Reference: [HL78] <author> G. Huet & D. S. Lankford. </author> <title> On the uniform halting problem for term rewriting systems. </title> <institution> Rapport Laboria 283, Institut de Recherche d'Informatique et d'Automatique, Le Chesnay, France, </institution> <year> 1978. </year>
Reference-contexts: 1 Introduction One of the most interesting properties of a term rewriting system is termination, cf. e.g. [DJ90]. While in general this problem is undecidable <ref> [HL78] </ref>, several methods for proving termination have been developed (e.g. path orderings [Pla78, Der82, Ges94, DH95, Ste95b], Knuth-Bendix orderings [KB70, Mar87], semantic interpretations [MN70, Lan79, BCL87, BL93, Ste94, Zan94, Gie95b], transformation orderings [BD86, BL90, Ste95a], semantic labelling [Zan95] etc. | for surveys see e.g. [Der87, Ste95b]).
Reference: [KZ89] <author> D. Kapur & H. Zhang. </author> <title> An overview of Rewrite Rule Laboratory (rrl). </title> <booktitle> In Proc. 3rd RTA, LNCS 355, </booktitle> <address> Chapel Hill, NC, </address> <year> 1989. </year>
Reference-contexts: For that purpose, future work will include an investigation on possible combinations of our method with induction theorem proving systems (e.g. <ref> [BM79, BHHW86, KZ89, BHHS90, BKR92] </ref>). Acknowledgements Thanks are due to Hans Zantema and Thomas Kolbe for the discussions we have had on the subjects described in this paper and for their very helpful criticism. Appendix This appendix contains a collection of examples which demonstrate the power of the described method.
Reference: [Ken95] <author> R. Kennaway. </author> <title> Complete term rewrite systems for decimal arithmetic and other total recursive functions. </title> <booktitle> Presented at the Second International Workshop on Termination, </booktitle> <address> La Bresse, France, </address> <year> 1995. </year>
Reference-contexts: The reason is that simplification orderings are monotonic and satisfy the subterm property and this implies succ (quot (minus (x; succ (x)); succ (succ (x)))) quot (succ (x); succ (succ (x))). All other known techniques for automated termination proofs of non-simply terminating systems <ref> [Zan94, Ste95a, Ken95, FZ95] </ref> fail with this example, too. However, with the dependency pair approach an automated termination proof of the above CS is possible.
Reference: [KB70] <author> D. E. Knuth & P. B. Bendix. </author> <title> Simple word problems in universal algebras. Computational Problems in Abstract Algebra, </title> <editor> J. Leech, ed., </editor> <publisher> Pergamon Press, </publisher> <pages> pp. 263-297, </pages> <year> 1970. </year>
Reference-contexts: 1 Introduction One of the most interesting properties of a term rewriting system is termination, cf. e.g. [DJ90]. While in general this problem is undecidable [HL78], several methods for proving termination have been developed (e.g. path orderings [Pla78, Der82, Ges94, DH95, Ste95b], Knuth-Bendix orderings <ref> [KB70, Mar87] </ref>, semantic interpretations [MN70, Lan79, BCL87, BL93, Ste94, Zan94, Gie95b], transformation orderings [BD86, BL90, Ste95a], semantic labelling [Zan95] etc. | for surveys see e.g. [Der87, Ste95b]). In this paper we are concerned with the automation of termination proofs for constructor systems (CS for short).
Reference: [KR95] <author> M. R. K. Krishna Rao. </author> <title> Modular proofs for completeness of hierarchical term rewriting systems. </title> <journal> Theoretical Computer Science, </journal> <volume> 151 </volume> <pages> 487-512, </pages> <year> 1995. </year>
Reference-contexts: For the first task, in [Art96] a method is presented to generate suitable CSs E for a subclass of CSs R automatically. This subclass consists of non-overlapping 2 hierarchical combinations <ref> [KR95] </ref> (a CS is a hierarchical combination of two CSs 1 In many examples it is sufficient if only certain dependency pairs are decreasing and several methods to determine those dependency pairs have been suggested in [Art96]. 2 This requirement can even be weakened to overlay systems with joinable critical pairs. <p> We remark that the hierarchical combinations that we focus on, differ from the proper-extensions defined by Krishna Rao <ref> [KR95] </ref>. If R is such a hierarchical combination of R 0 with R 1 and R 0 is terminating, then it suffices if just the subsystem R 0 is contained in E and hence, one can simply define E to be R 0 .
Reference: [Lan79] <author> D. S. Lankford. </author> <title> On proving term rewriting systems are noetherian. </title> <type> Tech. Report Memo MTP-3, </type> <institution> Louisiana Tech. University, Ruston, LA, </institution> <year> 1979. </year>
Reference-contexts: 1 Introduction One of the most interesting properties of a term rewriting system is termination, cf. e.g. [DJ90]. While in general this problem is undecidable [HL78], several methods for proving termination have been developed (e.g. path orderings [Pla78, Der82, Ges94, DH95, Ste95b], Knuth-Bendix orderings [KB70, Mar87], semantic interpretations <ref> [MN70, Lan79, BCL87, BL93, Ste94, Zan94, Gie95b] </ref>, transformation orderings [BD86, BL90, Ste95a], semantic labelling [Zan95] etc. | for surveys see e.g. [Der87, Ste95b]). In this paper we are concerned with the automation of termination proofs for constructor systems (CS for short). <p> Hence, demanding DP [ EQ is too strong, i.e. in this way most termination proofs will not succeed. 4 DP [ EQ is not satisfied by polynomial orderings <ref> [Lan79] </ref> either (which do not have to be quasi-simplification-orderings). 6 3.3 Constraints Without Defined Symbols In Sect. 3.1 we showed that the existence of a well-founded quasi-ordering % satisfying DP is in general not sufficient for the termination of R, because % does not necessarily respect the equalities induced by E <p> For instance, we can use a polynomial ordering <ref> [Lan79] </ref> where the function symbol 0 is mapped to the number 0, succ (x) is mapped to x + 1 and Q (x; y) and minus (x; y) are both mapped to the polynomial x. <p> Suitable interpretations of the function symbols lift these orderings to orderings on ground terms. The use, in particular, of polynomial interpretations that map terms into the natural numbers was developed by Lankford <ref> [Lan79] </ref>. These orderings trivially always have a minimal element and the ordering is weakly monotonic as long as the interpreted functions are weakly monotonic. Several techniques exist to derive the interpretations automatically [Gie95b, Ste94].
Reference: [MN70] <author> Z. Manna & S. Ness. </author> <title> On the termination of Markov algorithms. </title> <booktitle> In Proc. of the 3rd Hawaii Int. Conf. on System Science, </booktitle> <address> Honolulu, HI, </address> <year> 1970. </year>
Reference-contexts: 1 Introduction One of the most interesting properties of a term rewriting system is termination, cf. e.g. [DJ90]. While in general this problem is undecidable [HL78], several methods for proving termination have been developed (e.g. path orderings [Pla78, Der82, Ges94, DH95, Ste95b], Knuth-Bendix orderings [KB70, Mar87], semantic interpretations <ref> [MN70, Lan79, BCL87, BL93, Ste94, Zan94, Gie95b] </ref>, transformation orderings [BD86, BL90, Ste95a], semantic labelling [Zan95] etc. | for surveys see e.g. [Der87, Ste95b]). In this paper we are concerned with the automation of termination proofs for constructor systems (CS for short).
Reference: [Mar87] <author> U. Martin. </author> <title> How to choose weights in the Knuth-Bendix ordering. </title> <booktitle> In Proc. 2nd RTA, LNCS 256, </booktitle> <address> Bordeaux, France, </address> <year> 1987. </year>
Reference-contexts: 1 Introduction One of the most interesting properties of a term rewriting system is termination, cf. e.g. [DJ90]. While in general this problem is undecidable [HL78], several methods for proving termination have been developed (e.g. path orderings [Pla78, Der82, Ges94, DH95, Ste95b], Knuth-Bendix orderings <ref> [KB70, Mar87] </ref>, semantic interpretations [MN70, Lan79, BCL87, BL93, Ste94, Zan94, Gie95b], transformation orderings [BD86, BL90, Ste95a], semantic labelling [Zan95] etc. | for surveys see e.g. [Der87, Ste95b]). In this paper we are concerned with the automation of termination proofs for constructor systems (CS for short).
Reference: [Pla78] <author> D. A. Plaisted. </author> <title> A recursively defined ordering for proving termination of term rewriting systems. </title> <type> Report R-78-943, </type> <institution> Dept. of Computer Science, University of Illinois, Urbana, IL, </institution> <year> 1978. </year>
Reference-contexts: 1 Introduction One of the most interesting properties of a term rewriting system is termination, cf. e.g. [DJ90]. While in general this problem is undecidable [HL78], several methods for proving termination have been developed (e.g. path orderings <ref> [Pla78, Der82, Ges94, DH95, Ste95b] </ref>, Knuth-Bendix orderings [KB70, Mar87], semantic interpretations [MN70, Lan79, BCL87, BL93, Ste94, Zan94, Gie95b], transformation orderings [BD86, BL90, Ste95a], semantic labelling [Zan95] etc. | for surveys see e.g. [Der87, Ste95b]).
Reference: [Pla85] <author> D. A. Plaisted. </author> <title> Semantic confluence tests and completion methods. </title> <journal> Inform. and Control, </journal> 65(2/3):182-215, 1985. 
Reference-contexts: This allows to prove termination of CSs that are not sufficiently complete <ref> [Pla85] </ref>, too. 10 Therefore we additionally have to demand that irreducible ground terms with a defined root symbol are minimal, i.e. we also demand the constraints MIN = ft % f (r fl )jf 2 D; t; r fl are ground terms; f (r fl ) is E-normal formg: If MIN
Reference: [Ste92] <author> J. Steinbach. </author> <title> Notes on Transformation Orderings. </title> <address> SEKI-Report SR-92-23, Universitat Kaiserslautern, Germany, </address> <year> 1992. </year>
Reference-contexts: All remaining function symbols are mapped to the constant 0. This example is inspired by an algorithm from [BM79] and [Wal94]. In the corresponding example from <ref> [Ste92] </ref> the rules for le, eq, if rm and if min were missing. 11 Quicksort The quicksort CS is used to sort a list by the well-known quicksort-algorithm.
Reference: [Ste94] <author> J. Steinbach. </author> <title> Generating polynomial orderings. </title> <journal> Information Processing Letters, </journal> <volume> 49 </volume> <pages> 85-93, </pages> <year> 1994. </year>
Reference-contexts: 1 Introduction One of the most interesting properties of a term rewriting system is termination, cf. e.g. [DJ90]. While in general this problem is undecidable [HL78], several methods for proving termination have been developed (e.g. path orderings [Pla78, Der82, Ges94, DH95, Ste95b], Knuth-Bendix orderings [KB70, Mar87], semantic interpretations <ref> [MN70, Lan79, BCL87, BL93, Ste94, Zan94, Gie95b] </ref>, transformation orderings [BD86, BL90, Ste95a], semantic labelling [Zan95] etc. | for surveys see e.g. [Der87, Ste95b]). In this paper we are concerned with the automation of termination proofs for constructor systems (CS for short). <p> Methods for the automated generation of such polynomial orderings have for instance been developed in <ref> [Ste94, Gie95b] </ref>. In this way termination of the CS for minus and quot can be proved fully automatically. 5 Conclusion and Further Work We have developed a method for automated termination proofs of constructor systems which uses an estimation technique to automate the analysis of dependency pairs. <p> These orderings trivially always have a minimal element and the ordering is weakly monotonic as long as the interpreted functions are weakly monotonic. Several techniques exist to derive the interpretations automatically <ref> [Gie95b, Ste94] </ref>. To easy readability the CSs are presented as two sets of rewrite rules separated by some vertical space. The upper system will always denote R 0 , whereas the bottom rules will denote R 1 . For every CS, a set of dependency pairs is given.
Reference: [Ste95a] <author> J. Steinbach. </author> <title> Automatic termination proofs with transformation orderings. </title> <booktitle> In Proc. 6th RTA, LNCS 914, </booktitle> <address> Kaiserslautern, Germany, </address> <year> 1995. </year>
Reference-contexts: While in general this problem is undecidable [HL78], several methods for proving termination have been developed (e.g. path orderings [Pla78, Der82, Ges94, DH95, Ste95b], Knuth-Bendix orderings [KB70, Mar87], semantic interpretations [MN70, Lan79, BCL87, BL93, Ste94, Zan94, Gie95b], transformation orderings <ref> [BD86, BL90, Ste95a] </ref>, semantic labelling [Zan95] etc. | for surveys see e.g. [Der87, Ste95b]). In this paper we are concerned with the automation of termination proofs for constructor systems (CS for short). <p> The reason is that simplification orderings are monotonic and satisfy the subterm property and this implies succ (quot (minus (x; succ (x)); succ (succ (x)))) quot (succ (x); succ (succ (x))). All other known techniques for automated termination proofs of non-simply terminating systems <ref> [Zan94, Ste95a, Ken95, FZ95] </ref> fail with this example, too. However, with the dependency pair approach an automated termination proof of the above CS is possible. <p> This example was taken from [BM79] resp. [Wal91]. A variant of this example could be proved terminating using Steinbach's method for the automated generation of transformation orderings <ref> [Ste95a] </ref>, but there the rules for le and minus were missing. 6 Logarithm, Version 1 The following CS computes the dual logarithm. half (0) ! 0 half (succ (succ (x))) ! succ (half (x)) log (0) ! 0 log (succ (succ (x))) ! succ (log (succ (half (x)))) The relevant dependency <p> All remaining function symbols are mapped to 0. 22 This example comes from [Wal91] and a similar example was mentioned in <ref> [Ste95a] </ref>, but in Steinbach's version the rules for eq and if rm were missing. <p> All remaining function symbols are mapped to the constant 0. Steinbach could prove termination of a corresponding example with transformation orderings <ref> [Ste95a] </ref>, but in his example the rules for le, if low if high and app were omitted.
Reference: [Ste95b] <author> J. Steinbach. </author> <title> Simplification orderings: history of results. </title> <journal> Fundamenta In-formaticae, </journal> <volume> 24 </volume> <pages> 47-87, </pages> <year> 1995. </year>
Reference-contexts: 1 Introduction One of the most interesting properties of a term rewriting system is termination, cf. e.g. [DJ90]. While in general this problem is undecidable [HL78], several methods for proving termination have been developed (e.g. path orderings <ref> [Pla78, Der82, Ges94, DH95, Ste95b] </ref>, Knuth-Bendix orderings [KB70, Mar87], semantic interpretations [MN70, Lan79, BCL87, BL93, Ste94, Zan94, Gie95b], transformation orderings [BD86, BL90, Ste95a], semantic labelling [Zan95] etc. | for surveys see e.g. [Der87, Ste95b]). <p> in general this problem is undecidable [HL78], several methods for proving termination have been developed (e.g. path orderings [Pla78, Der82, Ges94, DH95, Ste95b], Knuth-Bendix orderings [KB70, Mar87], semantic interpretations [MN70, Lan79, BCL87, BL93, Ste94, Zan94, Gie95b], transformation orderings [BD86, BL90, Ste95a], semantic labelling [Zan95] etc. | for surveys see e.g. <ref> [Der87, Ste95b] </ref>). In this paper we are concerned with the automation of termination proofs for constructor systems (CS for short). Due to the special form of these rewrite systems it is possible to use a different approach for CSs than is necessary for termination of general rewrite systems. <p> following CS: minus (x; 0) ! x; minus (succ (x); succ (y)) ! minus (x; y); quot (0; succ (y)) ! 0; quot (succ (x); succ (y)) ! succ (quot (minus (x; y); succ (y))): Most methods for automated termination proofs of term rewriting systems are restricted to simplification orderings <ref> [Der79, Ste95b] </ref>. These methods cannot prove termination of the above CS, because no simplification ordering can orient the fourth rule if y is instantiated to succ (x).
Reference: [Wal91] <author> C. Walther. </author> <title> Automatisierung von Terminierungsbeweisen. </title> <publisher> Vieweg Verlag, </publisher> <address> Braunschweig, Germany, </address> <year> 1991. </year>
Reference-contexts: The rest of the ordering is as in the preceding examples (i.e. pred (x) and minus (x; y) are mapped to x and all remaining function symbols are mapped to 0). This example was taken from [BM79] resp. <ref> [Wal91] </ref>. <p> All remaining function symbols are mapped to 0. 22 This example comes from <ref> [Wal91] </ref> and a similar example was mentioned in [Ste95a], but in Steinbach's version the rules for eq and if rm were missing.
Reference: [Wal94] <author> C. Walther. </author> <title> On proving the termination of algorithms by machine. </title> <journal> Artificial Intelligence, </journal> <volume> 71(1) </volume> <pages> 101-157, </pages> <year> 1994. </year> <month> 31 </month>
Reference-contexts: Therefore in Sect. 4 we suggest a new technique to enable the application of standard methods for the generation of well-founded orderings to prove that dependency pairs are decreasing. For that purpose we transfer a variant of the estimation method <ref> [Wal94, Gie95c, Gie95d] </ref>, which was originally developed for termination proofs of functional programs, to rewrite systems. <p> Our approach fails if a well-founded quasi-ordering satisfying the generated constraints DP 0 cannot be found automatically. Therefore apart from the estimation technique we plan to examine alternative possibilities to derive suitable constraints DP 0 , which may be advantageous for further sophisticated termination proofs (cf. <ref> [BM79, BL93, Wal94, Gie95d] </ref>). For that purpose, future work will include an investigation on possible combinations of our method with induction theorem proving systems (e.g. [BM79, BHHW86, KZ89, BHHS90, BKR92]). <p> But this version here is even more difficult: Termination of the corresponding algorithm cannot be proved by the method of <ref> [Wal94] </ref>, because this method cannot deal with permutations of arguments.) 19 The relevant dependency pairs of this CS are hLE (succ (x); succ (y); LE (x; y)i hM (x; succ (y)); M (x; y)i hGCD (succ (x); succ (y)); IF gcd (le (y; x); succ (x); succ (y))i hIF gcd (true; <p> of the last rule, add (n; purge (rm (n; x))), the n would be replaced by a term containing add (n; x) then we would obtain a non-simply terminating CS, but termination could still be proved with our method in the same way. 9 Selection Sort The CS below, from <ref> [Wal94] </ref>, is obviously not simply terminating. The CS can be used to sort a list by repeatedly replacing the minimum of the list by the head of the list. <p> All remaining function symbols are mapped to the constant 0. This example is inspired by an algorithm from [BM79] and <ref> [Wal94] </ref>. In the corresponding example from [Ste92] the rules for le, eq, if rm and if min were missing. 11 Quicksort The quicksort CS is used to sort a list by the well-known quicksort-algorithm. <p> With our method termination could still be proved in the same way. 12 Permutation of Lists This example is a CS from <ref> [Wal94] </ref> to compute a permutation of a list, for instance, shu*e ([1; 2; 3; 4; 5]) reduces to [1; 5; 2; 4; 3]. app (empty; y) ! y app (add (n; x); y) ! add (n; app (x; y)) reverse (empty) ! empty reverse (add (n; x)) ! app (reverse (x);
Reference: [Zan94] <author> H. Zantema. </author> <title> Termination of term rewriting: interpretation and type elimi-nation. </title> <journal> Journal of Symbolic Computation 17 </journal> <pages> 23-50, </pages> <year> 1994. </year>
Reference-contexts: 1 Introduction One of the most interesting properties of a term rewriting system is termination, cf. e.g. [DJ90]. While in general this problem is undecidable [HL78], several methods for proving termination have been developed (e.g. path orderings [Pla78, Der82, Ges94, DH95, Ste95b], Knuth-Bendix orderings [KB70, Mar87], semantic interpretations <ref> [MN70, Lan79, BCL87, BL93, Ste94, Zan94, Gie95b] </ref>, transformation orderings [BD86, BL90, Ste95a], semantic labelling [Zan95] etc. | for surveys see e.g. [Der87, Ste95b]). In this paper we are concerned with the automation of termination proofs for constructor systems (CS for short). <p> The reason is that simplification orderings are monotonic and satisfy the subterm property and this implies succ (quot (minus (x; succ (x)); succ (succ (x)))) quot (succ (x); succ (succ (x))). All other known techniques for automated termination proofs of non-simply terminating systems <ref> [Zan94, Ste95a, Ken95, FZ95] </ref> fail with this example, too. However, with the dependency pair approach an automated termination proof of the above CS is possible.
Reference: [Zan95] <author> H. Zantema. </author> <title> Termination of term rewriting by semantic labelling. </title> <journal> Funda-menta Informaticae, </journal> <volume> 24 </volume> <pages> 89-105, </pages> <year> 1995. </year> <month> 32 </month>
Reference-contexts: While in general this problem is undecidable [HL78], several methods for proving termination have been developed (e.g. path orderings [Pla78, Der82, Ges94, DH95, Ste95b], Knuth-Bendix orderings [KB70, Mar87], semantic interpretations [MN70, Lan79, BCL87, BL93, Ste94, Zan94, Gie95b], transformation orderings [BD86, BL90, Ste95a], semantic labelling <ref> [Zan95] </ref> etc. | for surveys see e.g. [Der87, Ste95b]). In this paper we are concerned with the automation of termination proofs for constructor systems (CS for short). <p> If there exists a well-founded ordering on ground terms such that (s) # E (t) # E holds for all 1 dependency pairs hs; ti and all ground substitutions , then R is terminating. The proofs of all theorems of this section are based on semantic labelling <ref> [Zan95] </ref> and can be found in [Art96].
References-found: 39

