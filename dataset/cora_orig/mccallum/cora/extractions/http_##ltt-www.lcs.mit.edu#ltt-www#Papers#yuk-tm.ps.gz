URL: http://ltt-www.lcs.mit.edu/ltt-www/Papers/yuk-tm.ps.gz
Refering-URL: http://ltt-www.lcs.mit.edu/ltt-www/Papers/Papers.html
Root-URL: 
Title: Application of Minimal Perfect Hashing in Main Memory Indexing  
Author: Jerome H. Saltzer 
Degree: by Submitted to the Department of Electrical Engineering and Computer Science in Partial Fulfillment of the Requirements for the Degrees of Bachelor of Science in Computer Science and Engineering and Master of Engineering in Electrical Engineering and Computer Science at the  All rights reserved. The author hereby grants to M.I.T. permission to reproduce and to distribute copies of this thesis document in whole or in part, and to grant others the right to do so. Author  Certified by  Thesis Supervisor Accepted by F. R. Morgenthaler Chairman, Department Committee on Graduate Theses  
Note: Copyright Yuk Ho  
Date: May 1994  1994.  May 20, 1994  
Affiliation: MASSACHUSETTS INSTITUTE OF TECHNOLOGY  Department of Electrical Engineering and Computer Science  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> Jerome H. Saltzer. </author> <title> Technology, Networks, </title> <booktitle> and the Library of the Year 2000. Proceedings of the International Conference on the Occasion of the 25th Anniversary of Insti-tut National de Recherche en Informatique et Automatique, </booktitle> <address> Paris, France, </address> <month> December, </month> <year> 1992, </year> <pages> pages 51-67. </pages>
Reference-contexts: While reading a document, one can follow citations and references by point-and-click, and the selected document will pop up immediately in an adjacent window <ref> [1] </ref>. 1.2 Main Memory Indexing One essential module of an on-line digital library system is the index search engine. With an extremely large amount of information stored in the library system, it is very important that we can access these information efficiently.
Reference: [2] <institution> Library 2000. MIT Laboratory for Computer Science Progress Report, </institution> <note> Vol. 30, </note> <month> July </month> <year> 1992 </year> <month> June </month> <year> 1993, </year> <pages> pages 147-158. </pages>
Reference-contexts: Introduction 1.1 Library 2000 Project Overview The research work on this thesis is a part of the Library 2000 project. As stated in the 1993 annual progress report of the project <ref> [2] </ref>, the basic hypothesis of the project is that the technology of on-line storage, display, and communications will, by the year 2000, make it economically possible to place the entire contents of a library on-line and accessible from computer workstations located anywhere.
Reference: [3] <author> George Havas, Bohdan S. Majewski, Nicholas C. Wormald and Zbigniew J. </author> <title> Czech. Graphs, Hypergraphs and Hashing. </title> <booktitle> Proceedings of 19th International Workshop on Graph-Theoretic Concepts in Computer Science, </booktitle> <address> Utrecht, The Netherlands, </address> <month> June </month> <year> 1993. </year>
Reference-contexts: But the open-addressing scheme does offer more exibility for incremental keyword set updates than the minimal perfect hashing algorithm. 4.2 Implementation The minimal perfect hashing algorithm studied in this thesis is developed by George Havas, Bohdan S. Majewski, Nicholas C. Wormald and Zbigniew J. Czech <ref> [3] </ref>. Bohdan S. Majewski has implemented this algorithm in the C language. Permission has been obtained from him to use the source code in the Library 2000 project for research purposes. This section will give an overview of this algorithm as described in [3,4]. <p> Permission has been obtained from him to use the source code in the Library 2000 project for research purposes. This section will give an overview of this algorithm as described in [3,4]. A family of minimal perfect hashing algorithms based on random r-graphs is presented in <ref> [3] </ref>. An r-graph is a graph G = (V, E), where each e E is an r-subset of V. This means that each edge of the graph has r vertices. Majewskis C language code uses a 3-graph implementation. <p> The value of n depends on m, and the method to determine it will be explained later in this section. The mapping has to satisfy one requirement: the edges of the 3-graph must be inde pendent. The edge independence criterion is defined in <ref> [3] </ref> as: Edges of an r-graph G = (V, E) are independent if and only if repeated deletion of edges containing vertices of degree 1 results in a graph with no edges in it. For a 2-graph, that means that the graph has to acyclic. <p> T i is a two dimensional array of random integers, indexed by a character and the position of the character in a keyword. The value of n determines the probability of generating an edge independent graph. Theorem 4 in <ref> [3] </ref> states that For any r-graph three exists a constant c inv depending only f i w ( ) T i j w j [ ],( ) w 232323 on r such that if m c inv n the probability that a random r-graph has independent edges tends to 1 (as <p> For a 3-graph, the value of c inv is experimentally determined to be 1.23 <ref> [3] </ref>. 4.2.2 Assignment In the assignment step, we find a function g that maps V into the range [0, m-1]. The function g needs to satisfy the requirement that the function h defined as (4.3) is a bijective mapping from E to the range of integers [0, m-1]. <p> This assignment problem can be solved easily given that the graph G is edge independent. The solution is outlined in <ref> [3] </ref> as follows: Associate with each edge a unique number h (e) [0, m-1] in any order. Consider the edges in reverse order to the order of deletion during a test of independence, and assign values to each as yet unassigned vertex in that edge. <p> w ( ) g f 1 w ( )( ) g f 2 w ( )( ) g f 3 w ( )( )= 242424 4.3 Time Bound on Hash Table Generation The expected time complexity of generating the minimal perfect hash function is proven to be O (rm+n) in <ref> [3] </ref>. For the 3-graph implementation, r = 3 and n = 1.23m. Therefore the time bound on hash function generation is O (m). In this section we will verify this result experimentally. <p> We map the keyword set into a 2-graph using the random number tables T 1 and T 2 , and repeat that process until we get an acyclic graph. The probability of getting an acyclic graph depends on the value of n. Theorem 3 in <ref> [3] </ref> states that Let G be a random graph with n vertices and m edges obtained by choosing m random edges with repetitions. <p> For sufficiently large keyword sets, the probability value is approximately 0.81. Therefore the expected number of iterations needed to generate an acyclic graph is 1.24. The total time used by the mapping and assignment steps to generate the hash function is bounded by O (m) <ref> [3] </ref>. Compared with the 3-graph implementation, the hash function generation time of the 2-graph implementation is about 10% slower.
Reference: [4] <author> Zbigniew J. Czech, George Havas and Bohdan S. Majewski. </author> <title> An optimal algorithm for generating minimal perfect hash functions. </title> <journal> Information Processing Letters, </journal> <volume> Vol. 43, No. 5, </volume> <month> October </month> <year> 1992, </year> <pages> pages 257-264. </pages>
Reference-contexts: The goal of this modification is to reduce the number of memory accesses needed by the hash function. A 2-graph is a graph in which every edge consists of two vertices. A detailed description of the 2-graph implementation of the minimal perfect hashing algorithm can be found in <ref> [4] </ref>. It is very similar to the 3-graph implementation. For a keyword set W with m keywords, the function bijectively maps W into the set of integers -0, ... , m-1-.
Reference: [5] <author> Ted G. Lewis and Curtis R. Cook. </author> <title> Hashing for Dynamic and Static Internal Tables. </title> <journal> Computer, </journal> <volume> Vol. 21, </volume> <publisher> No.10. IEEE Computer Society, </publisher> <month> October </month> <year> 1988, </year> <pages> pages 45-56. </pages>
Reference-contexts: This calls for the need of the second step collision resolution. Open addressing is one of the common collision resolution schemes being employed. It uses an offset rule to find empty cells within the hash table <ref> [5] </ref>. 3.1.1 Hash Function The hash function is a function that maps a keyword into a hash table index. The function does this in two steps. It first converts the alphanumeric keyword into an integer, and then maps the integer into a hash table index. <p> This scheme converts the keyword to a base K number by treating each character in the key as a digit in a base K number, where K is the total number of distinct characters. It then applies a modulo operation on this number with a large prime <ref> [5] </ref>. The character range of the keywords includes 26 alphabets, 10 digits, and the punctuation .. Therefore the value of K is chosen to be 37. The large prime used to reduce the converted number is the hash table size. <p> Therefore we need some method for resolving collision. The Library 2000 search engine uses the open-addressing scheme. This scheme searches through the table entries to find an empty cell. The search pattern is specified by an offset rule that generates the sequence of table locations to be searched <ref> [5] </ref>. The current implementation uses a simple linear offset search pattern to search forward from the a collision point. Consider a keyword w and a hash function h. <p> This resolution scheme scans the hash table linearly until it finds an empty space. The hash table size n needs to be a prime number so that the offset will cause every possible table position to be considered <ref> [5] </ref>. When the search engine builds the hash table, it first copies the keyword from the word-location pair to the wordstore. Then it passes the keyword to the hash function, which returns an integer i.
Reference: [6] <author> Tobin J. Lehman and Michael J. Carey. </author> <title> A Study of Index Structures for Main Memory Database Management Systems. </title> <booktitle> Proceedings of the 12th International Conference on Very Large Data Bases, </booktitle> <address> Kyoto, </address> <month> August </month> <year> 1986, </year> <pages> pages 294-303. </pages>
Reference: [7] <author> Anastasia Analyti and Sakti Pramanik. </author> <title> Fast Search in Main Memory Databases. </title> <booktitle> Proceedings of the ACM SIGMOD International Conference on Management of Data, </booktitle> <year> 1992, </year> <pages> pages 215-224. </pages>
Reference: [8] <editor> IBM AIX Version 3.2 for RISC System/6000. </editor> <title> Optimization and Tuning Guide for the XL FORTRAN and XL C Compilers. </title> <booktitle> First Edition, </booktitle> <month> September </month> <year> 1992. </year>
Reference-contexts: The IBM RISC/ 6000 530H workstation uses a 64KB 4-way set associative data cache. A memory access with cache hit takes 1 cycle, while each data cache miss costs a delay of approximately 8 clock cycles <ref> [8] </ref>. The total size of the random number tables T 1 , T 2 and T 3 is 14.3KB. Therefore these tables will fit into the data cache. <p> The workstation uses a two-way set associative TLB with 64 entries in each set [9]. Thus the TLB can cache the page number translations for 128 pages. At 4KB per page, that is equivalent to 512KB of data <ref> [8] </ref>. Thus when we are doing random access over the 5.6MB g-table, it is highly likely for TLB misses to occur. A TLB miss will incur a delay of at least 36 clock cycles [8]. <p> At 4KB per page, that is equivalent to 512KB of data <ref> [8] </ref>. Thus when we are doing random access over the 5.6MB g-table, it is highly likely for TLB misses to occur. A TLB miss will incur a delay of at least 36 clock cycles [8].
Reference: [9] <author> IBM RISC System/6000 POWERstation and POWERserver. </author> <title> Hardware Technical Reference General Information. </title> <booktitle> First Edition, </booktitle> <year> 1990 </year>
Reference-contexts: The memory access may even cause a TLB (Translation Lookaside Buffer) miss. The TLB caches the translation of virtual page numbers into physical page numbers of the recently accessed memory pages. The workstation uses a two-way set associative TLB with 64 entries in each set <ref> [9] </ref>. Thus the TLB can cache the page number translations for 128 pages. At 4KB per page, that is equivalent to 512KB of data [8]. Thus when we are doing random access over the 5.6MB g-table, it is highly likely for TLB misses to occur.
Reference: [10] <author> Thomas H. Cormen, Charles E. Leiserson and Ronald L. Rivest. </author> <title> Introduction to Algorithms. </title> <publisher> MIT Press, McGraw-Hill, </publisher> <year> 1990. </year>
Reference-contexts: When searching a keyword, we can check the midpoint of the array against the keyword and eliminate half of the array from further consideration. Then we repeat this procedure, halving the size of the remaining array each time <ref> [10] </ref>. This algorithm runs in O (lg n) time. 777 1.3.2 B-tree In a B-tree, each node contains t key-location pointer pairs in sorted order. The node also contains t+1 pointer to its children. <p> The node also contains t+1 pointer to its children. The keys in the node are used as dividing points separating the range of keys handled by the node into t+1 sub-ranges, each handled by one child of the node <ref> [10] </ref>. During a keyword search, we make a (t+1)-way branching decision at each node of the B-tree. The time bound of this algorithm is O (lg n), but the base of the logarithm can be many times larger.
Reference: [11] <author> Donald E. Knuth. </author> <title> The Art of Computer Programming, Volume 3 / Sorting and Searching. </title> <publisher> Addison-Wesley Publishing Company, </publisher> <year> 1973. </year>
Reference-contexts: If the hash function is not perfect, then keyword searches will have the extra overhead of collision resolution. The number of probes needed for keyword searches using a linear-probing open-addressing scheme is approximately: <ref> [11] </ref> (1.1) a is defined as the ratio , where n is the number of keywords, and m is the number of entries in the hash table.
References-found: 11

