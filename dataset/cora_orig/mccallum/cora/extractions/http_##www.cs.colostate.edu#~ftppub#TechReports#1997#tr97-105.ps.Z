URL: http://www.cs.colostate.edu/~ftppub/TechReports/1997/tr97-105.ps.Z
Refering-URL: http://www.cs.colostate.edu/~ftppub/
Root-URL: 
Email: najjar@cs.colostate.edu  
Phone: Phone: (970) 491-5792 Fax: (970) 491-2466  
Title: Evaluation of a Split Scalar/Array Cache Architecture  
Author: Michelle Tomasko, Simos Hadjiyiannis and Walid A. Najjar 
Note: This work was supported in part by DARPA Contract DABT63-95-0093  
Web: WWW: http://www.cs.colostate.edu  
Address: Ft. Collins, CO 80523  Fort Collins, CO 80523-1873  
Affiliation: Department of Computer Science Colorado State University  Computer Science Department Colorado State University  
Pubnum: Technical Report CS-97-105  
Abstract: Computer Science Technical Report 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Wm. A. Wulf and S. A. McKee. </author> <title> Hitting the memory wall: Implications of the obvious. Computer Architecture News, </title> <month> December </month> <year> 1994. </year>
Reference-contexts: 1 Introduction As the gap between the CPU speed and the memory access latency keeps widening, as argued by Wulf and McKee <ref> [1] </ref>, the performance of the first level cache architecture becomes even more critical to the overall performance of the processor. The objective of existing cache memory architectures is to exploit the locality of reference in both the data and instruction address streams.
Reference: [2] <author> J. R. Larus. </author> <title> Abstract execution: A techniques for efficiently tracing programs. </title> <journal> Software Practice and Experience, </journal> 20(12) 1241-1258, Decem-ber 1990. 
Reference-contexts: 243087010 72.88 27.12 SU2COR 209392603 46.27 53.73 SWIM 243023561 32.46 67.54 TOMCATV 203607050 62.69 37.31 NAS (FORTRAN) APPSP 347077931 69.09 30.91 BUK 51225081 88.84 11.16 EMBAR 665704522 96.62 3.37 Table 1: SPEC and NAS benchmarks used in the experimental evaluation 2 The executables of these benchmarks were processed by QPT2 <ref> [2, 3] </ref>, a fast program profiling and tracing system. QPT2 instruments a binary executable file by inserting code to trace its execution, producing a new executable file a.out.qpt.
Reference: [3] <author> T. Ball and J. R. Larus. </author> <title> Optimally profiling and tracing programs. </title> <journal> ACM Trans. on Programming Languages and Systems, </journal> <volume> 16(4) </volume> <pages> 1319-1360, </pages> <month> July </month> <year> 1994. </year>
Reference-contexts: 243087010 72.88 27.12 SU2COR 209392603 46.27 53.73 SWIM 243023561 32.46 67.54 TOMCATV 203607050 62.69 37.31 NAS (FORTRAN) APPSP 347077931 69.09 30.91 BUK 51225081 88.84 11.16 EMBAR 665704522 96.62 3.37 Table 1: SPEC and NAS benchmarks used in the experimental evaluation 2 The executables of these benchmarks were processed by QPT2 <ref> [2, 3] </ref>, a fast program profiling and tracing system. QPT2 instruments a binary executable file by inserting code to trace its execution, producing a new executable file a.out.qpt.
Reference: [4] <author> M. D. Hill. </author> <title> Test driving your next cache. </title> <journal> Magazine of Intelligent Personal Systems, </journal> <pages> pages 84-92, </pages> <month> August </month> <year> 1989. </year>
Reference-contexts: The detection program also handles COMMON block arrays in FORTRAN. The trace regeneration program source code is then compiled with a driver program (din.c) which reads the trace file and writes the address trace in a format suitable for the dineroIII cache simulator <ref> [4, 5] </ref> For a split cache it is necessary to distinguish between an array and a scalar reference in the address trace. The din driver program has been modified to check each data reference against the list of array memory ranges that it has available.
Reference: [5] <author> M. D. Hill and A. J. Smith. </author> <title> Experimental evaluation of on-chip microprocessor cache memories. </title> <booktitle> In Proc. Int. Symp. on Computer Architecture, </booktitle> <pages> pages 158-174, </pages> <address> Ann Arbor, MI, </address> <month> June </month> <year> 1984. </year>
Reference-contexts: The detection program also handles COMMON block arrays in FORTRAN. The trace regeneration program source code is then compiled with a driver program (din.c) which reads the trace file and writes the address trace in a format suitable for the dineroIII cache simulator <ref> [4, 5] </ref> For a split cache it is necessary to distinguish between an array and a scalar reference in the address trace. The din driver program has been modified to check each data reference against the list of array memory ranges that it has available.
Reference: [6] <author> J. L. Hennessy and D. A. Patterson. </author> <title> Computer Architecture: A Quantitative Approach. </title> <publisher> Morgan Kaufmann Publishers Inc., </publisher> <year> 1995. </year>
Reference-contexts: The purpose of this section is to analyze the cost trade-offs of a split data cache architecture based on the experimental data presented so far. The expression for the CPU time including the cache performance <ref> [6] </ref> is: CP U time = IC fi Clock Cycle time fi [CP I + ( M em access Instruction fi M iss rate fi M iss penalty)] (where IC is the instruction count and CPI is the cycles per instruction).
Reference: [7] <author> A. Gonzales, C. Aliagas, and M. Valero. </author> <title> A data cache with multiple caching strategies tuned to different types of locality. </title> <booktitle> In Proc. Int. Conf. on Supercomputing, </booktitle> <pages> pages 338-347, </pages> <year> 1995. </year>
Reference-contexts: The concept of a dual data cache was first introduced by Gonzales et al. in <ref> [7] </ref>. The dual data cache consists of a spatial cache designed to exploit mostly spatial locality and some temporal locality and a temporal cache designed exclusively for temporal locality. <p> The main difference between this work and the one reported here is the dynamic categorization of data accesses as temporal or spatial and the non-exclusivity of the two caches. The results reported in <ref> [7] </ref>, however, are very similar to the ones reported here. A split temporal/spatial cache architecture relying on a compile time tagging of the data is described and analyzed in [11, 12, 13].
Reference: [8] <author> J-L. Baer and T-F Chen. </author> <title> An effective on-chip preloading scheme to reduce data access penalty. </title> <booktitle> In Proc. Supercomputing'91 Conf., </booktitle> <pages> pages 176-186, </pages> <year> 1991. </year>
Reference-contexts: In this scheme the type of access is determined dynamically using a locality prediction table which is similar in nature to the schemes proposed in <ref> [8, 9, 10] </ref>. Furthermore, the temporal and spatial caches are not exclusive in that a data element could be present in both.
Reference: [9] <author> J. W. Fu, J. H. Patel, and B. L. Jansen. </author> <title> Stride directed prefetching in scalar processors. </title> <booktitle> In Proc. Int. Symp. on Microarchitecture (MICRO-25), </booktitle> <pages> pages 102-110, </pages> <year> 1992. </year>
Reference-contexts: In this scheme the type of access is determined dynamically using a locality prediction table which is similar in nature to the schemes proposed in <ref> [8, 9, 10] </ref>. Furthermore, the temporal and spatial caches are not exclusive in that a data element could be present in both.
Reference: [10] <author> Y. Jegou and O. Temam. </author> <title> Speculative prefetch-ing. </title> <booktitle> In Proc. Int. Conf. on Supercomputing, </booktitle> <pages> pages 57-66, </pages> <year> 1993. </year>
Reference-contexts: In this scheme the type of access is determined dynamically using a locality prediction table which is similar in nature to the schemes proposed in <ref> [8, 9, 10] </ref>. Furthermore, the temporal and spatial caches are not exclusive in that a data element could be present in both.
Reference: [11] <author> V. Milutinovic, M. Tomasevic, B. Markovic, and M. Tremblay. </author> <title> A new cache architecture concept: The split temporal/spatial cache. </title> <booktitle> In Proc. of the IEEE/MELECON-96, </booktitle> <year> 1996. </year>
Reference-contexts: The results reported in [7], however, are very similar to the ones reported here. A split temporal/spatial cache architecture relying on a compile time tagging of the data is described and analyzed in <ref> [11, 12, 13] </ref>. This scheme includes a second level temporal cache as well as a mechanism for moving data between the temporal and spatial caches at run time. The performance of four variants of the split cache architecture are reported for the ATUM traces.
Reference: [12] <author> V. Milutinovic, B. Markovic, M. Tomasevic, and M. Tremblay. </author> <title> The split temporal/spatial cache: Initial performance analysis. </title> <booktitle> In Proc. of the SCIzzL-5, </booktitle> <month> March </month> <year> 1996. </year>
Reference-contexts: The results reported in [7], however, are very similar to the ones reported here. A split temporal/spatial cache architecture relying on a compile time tagging of the data is described and analyzed in <ref> [11, 12, 13] </ref>. This scheme includes a second level temporal cache as well as a mechanism for moving data between the temporal and spatial caches at run time. The performance of four variants of the split cache architecture are reported for the ATUM traces.
Reference: [13] <author> V. Milutinovic, B. Markovic, M. Tomasevic, and M. Tremblay. </author> <title> The split temporal/spatial cache: A complexity analysis. </title> <booktitle> In Proc. of the SCIzzL-6, </booktitle> <month> September </month> <year> 1996. </year> <month> 11 </month>
Reference-contexts: The results reported in [7], however, are very similar to the ones reported here. A split temporal/spatial cache architecture relying on a compile time tagging of the data is described and analyzed in <ref> [11, 12, 13] </ref>. This scheme includes a second level temporal cache as well as a mechanism for moving data between the temporal and spatial caches at run time. The performance of four variants of the split cache architecture are reported for the ATUM traces.
References-found: 13

