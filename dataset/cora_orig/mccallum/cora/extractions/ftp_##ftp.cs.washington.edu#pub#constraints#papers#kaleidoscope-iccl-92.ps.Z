URL: ftp://ftp.cs.washington.edu/pub/constraints/papers/kaleidoscope-iccl-92.ps.Z
Refering-URL: http://www.cs.washington.edu/research/constraints/cip/kaleidoscope-iccl-92.html
Root-URL: 
Email: bnfb@csr.uvic.ca borning@cs.washington.edu  
Phone: 3055  
Title: The Design and Implementation of Kaleidoscope'90, A Constraint Imperative Programming Language There is a strong
Author: Bjorn N. Freeman-Benson Alan Borning 
Note: maintained constraints (relations that should hold).  while other portions are most clearly described  can be used as appropriate.  
Address: FR-35 Box  Victoria, B.C. V8W 3P6 Seattle, Washington 98195 CANADA USA  
Affiliation: University of Victoria Department of Computer Science Department of Computer Science and Engineering,  University of Washington  
Abstract: languages are imperative and declarative programming. We describe a scheme for languages that integrate specific features from these two paradigms into a new framework: Constraint Imperative Programming. Along with the framework, we discuss the design and implementation of a particular instance of this framework, Kaleidoscope'90. From the imperative paradigm, constraint imperative programming adopts explicit control flow, state, and assignment. From the declarative paradigm, it adopts explicit, system 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Daniel G. Bobrow, Linda G. DeMichiel, Richard P. Gabriel, Sonya E. Keene, Gregor Kiczales, and David A. Moon. </author> <title> Common Lisp Object System Specification X3J13. </title> <journal> SIGPLAN Notices, </journal> <month> September </month> <year> 1988. </year>
Reference-contexts: constructor sum ( a:Array, s:Number ) var i, partial : Number; partial := 0; for i := a.first to a.last do partial := partial + a [i]; end for; always: s = partial; end sum; than just the first. (Multi-methods were first used in the CLOS extension to Common Lisp <ref> [1] </ref>.) another that iteratively defines the "sum" constraint for arrays. 4 A Prototype Implementation In [11] we describe the design and implementation of a prototype constraint imperative language, Kaleidoscope'90.
Reference: [2] <author> Alan Borning, Michael Maher, Amy Martindale, and Molly Wilson. </author> <title> Constraint Hierarchies and Logic Programming. </title> <booktitle> In Proceedings of the Sixth International Conference on Logic Programming, </booktitle> <pages> pages 149-164, </pages> <address> Lisbon, </address> <month> June </month> <year> 1989. </year>
Reference-contexts: For example, the following constraint states that the default background color of the display is gray: always: weak Display.color = Gray; Stronger constraints (such as the constraint on the color of the thumb in the scrollbar example) would locally override this weak constraint. References <ref> [2, 11] </ref> present a formal description of the theory of constraint hierarchies, while [9, 10] describe two algorithms, DeltaBlue and DeltaStar respectively, for finding solutions to them. 3.2 Storage Model Integration Integrating the time aspect of the imperative storage model and the constraint graph aspect of the constraint storage model results <p> A number of instances of this scheme have now been implemented, including CLP (R) [12], Prolog III [5], and CHIP [6, 26]. Two generalizations of the CLP scheme are CLP* [13], which generalizes CLP by allowing predicates to be defined dynamically as first class objects, and HCLP <ref> [2, 28] </ref>, which generalizes CLP by including constraint hierarchies rather than just required constraints. Fi nally, in the cc languages [23, 24] the conventional store of a Von Neumann computer is replaced by one that holds constraints.
Reference: [3] <author> Alan Borning, Molly Wilson, and Bjorn Freeman-Benson. </author> <title> Read-Only Annotations in Constraint Hierarchies. </title> <type> Technical Report 91-07-04, </type> <institution> Department of Computer Science and Engineering, University of Washington, </institution> <month> July </month> <year> 1991. </year>
Reference-contexts: value is equivalent to adding a required constraint that the pellucid variable be equal to a constant, i.e., x t = c.) To prevent various paradoxes in which the future modifies the past, synchronic constraints are annotated with read-only annotations so that values can flow only forward in time. (See <ref> [3] </ref> for a formal definition of read-only annotations in constraint hierarchies.) Thus x:=x+1 actually becomes x t+1 = x t ? + 1, where x t ? denotes a read-only use of the pellucid variable x t . 3.3 Objects Modern programming languages support user-defined data types (often including abstract data
Reference: [4] <author> Jacques Cohen. </author> <title> Constraint Logic Programming Languages. </title> <journal> Communications of the ACM, </journal> <pages> pages 52-68, </pages> <month> July </month> <year> 1990. </year>
Reference-contexts: Jaffar and Lassez have defined a general scheme, Constraint Logic Programming (CLP), for integrating constraints with logic programming <ref> [4, 16] </ref>. A number of instances of this scheme have now been implemented, including CLP (R) [12], Prolog III [5], and CHIP [6, 26].
Reference: [5] <author> Alain Colmerauer. </author> <title> An Introduction to Prolog III. </title> <journal> Communications of the ACM, </journal> <pages> pages 69-90, </pages> <month> July </month> <year> 1990. </year>
Reference-contexts: Jaffar and Lassez have defined a general scheme, Constraint Logic Programming (CLP), for integrating constraints with logic programming [4, 16]. A number of instances of this scheme have now been implemented, including CLP (R) [12], Prolog III <ref> [5] </ref>, and CHIP [6, 26]. Two generalizations of the CLP scheme are CLP* [13], which generalizes CLP by allowing predicates to be defined dynamically as first class objects, and HCLP [2, 28], which generalizes CLP by including constraint hierarchies rather than just required constraints.
Reference: [6] <author> M. Dincbas, P. Van Hentenryck, H. Simonis, A. Aggoun, T. Graf, and F. Bertheir. </author> <title> The Constraint Logic Programming Language CHIP. </title> <booktitle> In Proceedings Fifth Generation Computer Systems--88, </booktitle> <year> 1988. </year>
Reference-contexts: Jaffar and Lassez have defined a general scheme, Constraint Logic Programming (CLP), for integrating constraints with logic programming [4, 16]. A number of instances of this scheme have now been implemented, including CLP (R) [12], Prolog III [5], and CHIP <ref> [6, 26] </ref>. Two generalizations of the CLP scheme are CLP* [13], which generalizes CLP by allowing predicates to be defined dynamically as first class objects, and HCLP [2, 28], which generalizes CLP by including constraint hierarchies rather than just required constraints.
Reference: [7] <author> Bjorn Freeman-Benson. </author> <title> Kaleidoscope: Mixing Objects, Constraints, and Imperative Programming. </title> <booktitle> In Proceedings of the 1990 Conference on Object-Oriented Programming Systems, Languages, and Applications, and European Conference on Object-Oriented Programming, </booktitle> <pages> pages 77-88, </pages> <address> Ottawa, Canada, </address> <month> October </month> <year> 1990. </year> <note> ACM. </note>
Reference-contexts: We also present a new programming language, Kaleidoscope'90, that is an instance of this framework. Kaleidoscope'90 has been implemented, and various sample programs have been executed. This paper is based primarily on Freeman-Benson's recently completed Ph.D. dissertation [11]. Reference <ref> [7] </ref> is a preliminary conference paper on Kaleidoscope, while [8] discusses in detail issues that arise when integrating objects and constraints. 2 A Motivating Example Consider the scroll bar shown on the left.
Reference: [8] <author> Bjorn Freeman-Benson and Alan Borning. </author> <title> Integrating Constraints with an Object-Oriented Language. </title> <booktitle> In Proceedings of the 1992 European Conference on Object-Oriented Languages, </booktitle> <month> June </month> <year> 1992. </year> <note> To appear. </note>
Reference-contexts: We also present a new programming language, Kaleidoscope'90, that is an instance of this framework. Kaleidoscope'90 has been implemented, and various sample programs have been executed. This paper is based primarily on Freeman-Benson's recently completed Ph.D. dissertation [11]. Reference [7] is a preliminary conference paper on Kaleidoscope, while <ref> [8] </ref> discusses in detail issues that arise when integrating objects and constraints. 2 A Motivating Example Consider the scroll bar shown on the left.
Reference: [9] <author> Bjorn Freeman-Benson, John Maloney, and Alan Borning. </author> <title> An Incremental Constraint Solver. </title> <journal> Communications of the ACM, </journal> <volume> 33(1) </volume> <pages> 54-63, </pages> <month> Jan-uary </month> <year> 1990. </year>
Reference-contexts: References [2, 11] present a formal description of the theory of constraint hierarchies, while <ref> [9, 10] </ref> describe two algorithms, DeltaBlue and DeltaStar respectively, for finding solutions to them. 3.2 Storage Model Integration Integrating the time aspect of the imperative storage model and the constraint graph aspect of the constraint storage model results in a value store defined as a sequence of constraint graphs, one for <p> Applications have included interactive graphics, layout systems, user interface con struction systems, various artificial intelligence systems, and design, analysis, and simulation systems. See <ref> [9, 11, 21] </ref> for citations and a comparative discussion of these applications. (Due to space limitations we don't describe them here.) In the programming language arena, one of the earliest efforts was that of Steele [25], whose dissertation describes work on a general-purpose constraint language using local propagation to find solutions.
Reference: [10] <author> Bjorn Freeman-Benson and Molly Wilson. DeltaStar, </author> <title> How I Wonder What You Are: A General Algorithm for Incremental Satisfaction of Constraint Hierarchies. </title> <type> Technical Report 90-05-02, </type> <institution> Department of Computer Science and Engineering, University of Washington, </institution> <month> May </month> <year> 1990. </year>
Reference-contexts: References [2, 11] present a formal description of the theory of constraint hierarchies, while <ref> [9, 10] </ref> describe two algorithms, DeltaBlue and DeltaStar respectively, for finding solutions to them. 3.2 Storage Model Integration Integrating the time aspect of the imperative storage model and the constraint graph aspect of the constraint storage model results in a value store defined as a sequence of constraint graphs, one for
Reference: [11] <author> Bjorn N. Freeman-Benson. </author> <title> Constraint Imperative Programming. </title> <type> PhD thesis, </type> <institution> University of Wash-ington, Department of Computer Science and Engineering, </institution> <month> July </month> <year> 1991. </year> <note> Published as Department of Computer Science and Engineering technical report 91-07-02. </note>
Reference-contexts: We also present a new programming language, Kaleidoscope'90, that is an instance of this framework. Kaleidoscope'90 has been implemented, and various sample programs have been executed. This paper is based primarily on Freeman-Benson's recently completed Ph.D. dissertation <ref> [11] </ref>. Reference [7] is a preliminary conference paper on Kaleidoscope, while [8] discusses in detail issues that arise when integrating objects and constraints. 2 A Motivating Example Consider the scroll bar shown on the left. <p> For example, the following constraint states that the default background color of the display is gray: always: weak Display.color = Gray; Stronger constraints (such as the constraint on the color of the thumb in the scrollbar example) would locally override this weak constraint. References <ref> [2, 11] </ref> present a formal description of the theory of constraint hierarchies, while [9, 10] describe two algorithms, DeltaBlue and DeltaStar respectively, for finding solutions to them. 3.2 Storage Model Integration Integrating the time aspect of the imperative storage model and the constraint graph aspect of the constraint storage model results <p> i := a.first to a.last do partial := partial + a [i]; end for; always: s = partial; end sum; than just the first. (Multi-methods were first used in the CLOS extension to Common Lisp [1].) another that iteratively defines the "sum" constraint for arrays. 4 A Prototype Implementation In <ref> [11] </ref> we describe the design and implementation of a prototype constraint imperative language, Kaleidoscope'90. Kaleidoscope'90 is an integration of a typed dialect of Smalltalk-80 [17] and an enhanced version of the constraint system from ThingLab II [22]. <p> Applications have included interactive graphics, layout systems, user interface con struction systems, various artificial intelligence systems, and design, analysis, and simulation systems. See <ref> [9, 11, 21] </ref> for citations and a comparative discussion of these applications. (Due to space limitations we don't describe them here.) In the programming language arena, one of the earliest efforts was that of Steele [25], whose dissertation describes work on a general-purpose constraint language using local propagation to find solutions. <p> An obvious example of this optimization is assignment to an otherwise unconstrained variable: a simple load-store instruction pair is a better choice than constructing a full compound graph, reducing it, and then solving the resulting equality constraint. Chapter 7 of <ref> [11] </ref> discusses other compilation opportunities. Our goal is to provide an implementation of the general model (i.e., CIP) in such a way that any given program pays the cost of only the features that it uses.
Reference: [12] <author> Nevin Heintze, Joxan Jaffar, Spiro Michaylov, Peter Stuckey, and Roland Yap. </author> <title> The CLP(R) Programmer's Manual Version 1.1. </title> <type> Technical report, </type> <institution> IBM T.J. Watson Research Center, </institution> <month> Novem-ber </month> <year> 1991. </year>
Reference-contexts: Jaffar and Lassez have defined a general scheme, Constraint Logic Programming (CLP), for integrating constraints with logic programming [4, 16]. A number of instances of this scheme have now been implemented, including CLP (R) <ref> [12] </ref>, Prolog III [5], and CHIP [6, 26]. Two generalizations of the CLP scheme are CLP* [13], which generalizes CLP by allowing predicates to be defined dynamically as first class objects, and HCLP [2, 28], which generalizes CLP by including constraint hierarchies rather than just required constraints.
Reference: [13] <author> Timothy J. Hickey. </author> <title> CLP* and Constraint Abstraction. </title> <booktitle> In Proceedings of the Sixteenth Annual Principles of Programming Languages Symposium, </booktitle> <pages> pages 125-133, </pages> <address> Austin, Texas, </address> <month> January </month> <year> 1989. </year> <note> ACM. </note>
Reference-contexts: A number of instances of this scheme have now been implemented, including CLP (R) [12], Prolog III [5], and CHIP [6, 26]. Two generalizations of the CLP scheme are CLP* <ref> [13] </ref>, which generalizes CLP by allowing predicates to be defined dynamically as first class objects, and HCLP [2, 28], which generalizes CLP by including constraint hierarchies rather than just required constraints.
Reference: [14] <author> Bruce Horn. </author> <title> Thesis Proposal: A Constrained-Object Language for Reactive Program Implementation. </title> <institution> Carnegie Mellon University, </institution> <month> May </month> <year> 1990. </year>
Reference-contexts: Lamport and Schneider [20] propose adding constraints to an imperative language, as a uniform approach encompassing both aliasing and typing. Their primary motivation is the development of proof systems. Perhaps the closest work to that described here is Horn's Siri language <ref> [14, 15] </ref>, which is also a hybrid object-oriented constraint imperative language. There are a number of differences between Siri and CIP. First, Siri uses only required constraints, rather than a constraint hierarchy. Therefore, the user must explicitly indicate when values are to remain the same as time advances.
Reference: [15] <author> Bruce Horn. </author> <title> Properties of User Interface Systems and the Siri Programming Language. </title> <editor> In Brad Myers, editor, </editor> <title> Languages for Developing User Interfaces. </title> <publisher> Jones and Bartlett, </publisher> <address> Boston, </address> <year> 1992. </year>
Reference-contexts: Lamport and Schneider [20] propose adding constraints to an imperative language, as a uniform approach encompassing both aliasing and typing. Their primary motivation is the development of proof systems. Perhaps the closest work to that described here is Horn's Siri language <ref> [14, 15] </ref>, which is also a hybrid object-oriented constraint imperative language. There are a number of differences between Siri and CIP. First, Siri uses only required constraints, rather than a constraint hierarchy. Therefore, the user must explicitly indicate when values are to remain the same as time advances.
Reference: [16] <author> Joxan Jaffar and Jean-Louis Lassez. </author> <title> Constraint Logic Programming. </title> <booktitle> In Proceedings of the 14th ACM Principles of Programming Languages Conference, </booktitle> <address> Munich, </address> <month> January </month> <year> 1987. </year>
Reference-contexts: Jaffar and Lassez have defined a general scheme, Constraint Logic Programming (CLP), for integrating constraints with logic programming <ref> [4, 16] </ref>. A number of instances of this scheme have now been implemented, including CLP (R) [12], Prolog III [5], and CHIP [6, 26].
Reference: [17] <author> Ralph E. Johnson. </author> <title> Type-Checking Smalltalk. </title> <booktitle> In Proceedings of the 1986 ACM Conference on Object-Oriented Programming Systems, Languages and Applications, </booktitle> <pages> pages 315-321, </pages> <address> Port-land, Oregon, </address> <month> November </month> <year> 1986. </year> <note> ACM. </note>
Reference-contexts: Kaleidoscope'90 is an integration of a typed dialect of Smalltalk-80 <ref> [17] </ref> and an enhanced version of the constraint system from ThingLab II [22]. This initial implementation interprets the constraint imperative programming semantics directly, resulting in a robust but very slow implementation. The interpreter is divided into three sections: a pre-compiler, an imperative engine, and a constraint-based value store.
Reference: [18] <author> Glenn Kramer, Jahir Pabon, Walid Keirouz, and Robert Young. </author> <title> Geometric Constraint Satisfaction Problems. </title> <booktitle> In Working Notes of the AAAI Spring Symposium on Constraint-Based Reasoning, </booktitle> <pages> pages 242-251, </pages> <address> Stanford, </address> <month> March </month> <year> 1991. </year>
Reference-contexts: We could limit the kinds of user-definable constraints (e.g., to equality constraints only) or the power of the solver (e.g., to local propagation only). We could define a new solver, e.g., Kramer's solver for geometric constraint satisfaction <ref> [18] </ref>, and link it to the existing solvers in some fashion. Finally, we could define the geometric constraints in terms of primitive constraints and data types, in this case algebraically using the real numbers.
Reference: [19] <author> Bent Bruun Kristensen, Ole Lehrmann Madsen, Birger Moller-Pederson, and Kirsten Nygaard. </author> <title> Abstraction Mechanisms in the BETA Programming Language. </title> <booktitle> In Proceedings of the Tenth Annual Principles of Programming Languages Symposium, </booktitle> <address> Austin, Texas, </address> <month> January </month> <year> 1983. </year> <note> ACM. </note>
Reference-contexts: Third, Siri uses a single abstraction mechanism, a constraint pattern, for object description, modification, and evaluation, rather than more standard approach taken here of using separate mechanisms for these tasks. (This uniform use of patterns is analogous to their use in the BETA language <ref> [19] </ref>.) Most of the current activity in constraint languages is based on logic programming. Jaffar and Lassez have defined a general scheme, Constraint Logic Programming (CLP), for integrating constraints with logic programming [4, 16].
Reference: [20] <author> Leslie Lamport and Fred B. Schneider. </author> <title> Constraints: A Uniform Approach to Aliasing and Typing. </title> <booktitle> In Proceedings of the Twelfth Annual Principles of Programming Languages Symposium, </booktitle> <pages> pages 205-216, </pages> <address> New Orleans, Louisiana, </address> <month> January </month> <year> 1985. </year> <note> ACM. </note>
Reference-contexts: Subsequently, Leler [21] designed and implemented a constraint language based on augmented term rewrit ing. Lamport and Schneider <ref> [20] </ref> propose adding constraints to an imperative language, as a uniform approach encompassing both aliasing and typing. Their primary motivation is the development of proof systems. Perhaps the closest work to that described here is Horn's Siri language [14, 15], which is also a hybrid object-oriented constraint imperative language.
Reference: [21] <author> William Leler. </author> <title> Constraint Programming Languages. </title> <publisher> Addison-Wesley, </publisher> <year> 1987. </year>
Reference-contexts: Applications have included interactive graphics, layout systems, user interface con struction systems, various artificial intelligence systems, and design, analysis, and simulation systems. See <ref> [9, 11, 21] </ref> for citations and a comparative discussion of these applications. (Due to space limitations we don't describe them here.) In the programming language arena, one of the earliest efforts was that of Steele [25], whose dissertation describes work on a general-purpose constraint language using local propagation to find solutions. <p> Subsequently, Leler <ref> [21] </ref> designed and implemented a constraint language based on augmented term rewrit ing. Lamport and Schneider [20] propose adding constraints to an imperative language, as a uniform approach encompassing both aliasing and typing. Their primary motivation is the development of proof systems.
Reference: [22] <author> John Maloney, Alan Borning, and Bjorn Freeman-Benson. </author> <title> Constraint Technology for User-Interface Construction in ThingLab II. </title> <booktitle> In Proceedings of the 1989 ACM Conference on Object-Oriented Programming Systems, Languages and Applications, </booktitle> <address> New Orleans, </address> <month> October </month> <year> 1989. </year> <note> ACM. </note>
Reference-contexts: Kaleidoscope'90 is an integration of a typed dialect of Smalltalk-80 [17] and an enhanced version of the constraint system from ThingLab II <ref> [22] </ref>. This initial implementation interprets the constraint imperative programming semantics directly, resulting in a robust but very slow implementation. The interpreter is divided into three sections: a pre-compiler, an imperative engine, and a constraint-based value store. The pre-compiler converts the Kaleidoscope'90 source program into a K-code object program.
Reference: [23] <author> Vijay A. Saraswat, Martin Rinard, and Prakash Panangaden. </author> <title> Semantic foundations of concurrent constraint programming. </title> <booktitle> In Proceedings of the 18th Annual Principles of Programming Languages Symposium. ACM, </booktitle> <year> 1991. </year>
Reference-contexts: Two generalizations of the CLP scheme are CLP* [13], which generalizes CLP by allowing predicates to be defined dynamically as first class objects, and HCLP [2, 28], which generalizes CLP by including constraint hierarchies rather than just required constraints. Fi nally, in the cc languages <ref> [23, 24] </ref> the conventional store of a Von Neumann computer is replaced by one that holds constraints. Concurrently executing agents communicate by asking and telling constraints to this store. 6 Future Work We are currently redesigning and simplifying our language to produce Kaleidoscope'91.
Reference: [24] <author> Vijay Anand Saraswat. </author> <title> Concurrent Constraint Programming Languages. </title> <type> PhD thesis, </type> <institution> Carnegie-Mellon University, Computer Science Department, </institution> <month> January </month> <year> 1989. </year>
Reference-contexts: Two generalizations of the CLP scheme are CLP* [13], which generalizes CLP by allowing predicates to be defined dynamically as first class objects, and HCLP [2, 28], which generalizes CLP by including constraint hierarchies rather than just required constraints. Fi nally, in the cc languages <ref> [23, 24] </ref> the conventional store of a Von Neumann computer is replaced by one that holds constraints. Concurrently executing agents communicate by asking and telling constraints to this store. 6 Future Work We are currently redesigning and simplifying our language to produce Kaleidoscope'91.
Reference: [25] <author> Guy L. Steele. </author> <title> The Definition and Implementation of a Computer Programming Language Based on Constraints. </title> <type> PhD thesis, </type> <institution> MIT, </institution> <month> August </month> <year> 1980. </year> <note> Published as MIT-AI TR 595, </note> <month> August </month> <year> 1980. </year>
Reference-contexts: See [9, 11, 21] for citations and a comparative discussion of these applications. (Due to space limitations we don't describe them here.) In the programming language arena, one of the earliest efforts was that of Steele <ref> [25] </ref>, whose dissertation describes work on a general-purpose constraint language using local propagation to find solutions. Subsequently, Leler [21] designed and implemented a constraint language based on augmented term rewrit ing.
Reference: [26] <author> Pascal Van Hentenryck. </author> <title> Constraint Satisfaction in Logic Programming. </title> <publisher> MIT Press, </publisher> <address> Cambridge, MA, </address> <year> 1989. </year>
Reference-contexts: Jaffar and Lassez have defined a general scheme, Constraint Logic Programming (CLP), for integrating constraints with logic programming [4, 16]. A number of instances of this scheme have now been implemented, including CLP (R) [12], Prolog III [5], and CHIP <ref> [6, 26] </ref>. Two generalizations of the CLP scheme are CLP* [13], which generalizes CLP by allowing predicates to be defined dynamically as first class objects, and HCLP [2, 28], which generalizes CLP by including constraint hierarchies rather than just required constraints.
Reference: [27] <author> William W. Wadge and Edward A. Ashcroft. </author> <title> Lucid, the Dataflow Programming Language. </title> <publisher> Academic Press, </publisher> <address> London, </address> <year> 1985. </year>
Reference-contexts: We have also found it useful to visualize the variables in a constraint imperative program as streams of pellucid variables, i.e., x 7! hx 1 ; x 2 ; x 3 ; : : :i. (This way of visualizing variables as holding streams of values is taken from Lucid <ref> [27] </ref>.) In a constraint program, adding a constraint to the constraint graph asserts the constraint for the duration of the program (because there is only one such graph). However, in a CIP program, there is a separate graph for each time interval (at least conceptually).
Reference: [28] <author> Molly Wilson and Alan Borning. </author> <title> Extending Hierarchical Constraint Logic Programming: Non-monotonicity and Inter-Hierarchy Comparison. </title> <booktitle> In Proceedings of the North American Conference on Logic Programming, </booktitle> <address> Cleveland, </address> <month> October </month> <year> 1989. </year>
Reference-contexts: A number of instances of this scheme have now been implemented, including CLP (R) [12], Prolog III [5], and CHIP [6, 26]. Two generalizations of the CLP scheme are CLP* [13], which generalizes CLP by allowing predicates to be defined dynamically as first class objects, and HCLP <ref> [2, 28] </ref>, which generalizes CLP by including constraint hierarchies rather than just required constraints. Fi nally, in the cc languages [23, 24] the conventional store of a Von Neumann computer is replaced by one that holds constraints.
References-found: 28

