URL: ftp://ftp.swiss.ai.mit.edu/pub/users/ziggy/Papers/Thesis/SM/rpt-fx.ps
Refering-URL: http://www.swiss.ai.mit.edu/~ziggy/papers.html
Root-URL: 
Email: [ziggy@lcs.mit.edu]  
Title: Raw, Pickled and Textured Static Side-Effect Analysis in FX-87 (DRAFT: To become an LCS or
Author: Michael R. Blair 
Note: Lucassen and Gifford introduced polymorphic effect systems to alleviate this problem. However, their approach has been shown to suffer a couple shortcomings [Harrison 89,  This research was supported in part by the Defense Advanced Research Projects Agency of the Department of Defense and was monitored by the Office of Naval Research under contract number N00014-83-K-0125.  
Affiliation: MIT Laboratory for Computer Science  
Pubnum: AI Technical Memo)  
Abstract: A kernel language, fl-TREK, with a polymorphic region-based effect system is introduced. Using it as a framework, four different views of region-based effects are developed and used to attack four aspects of providing an effective and efficient region-based effect system. Specifically, region-based effects are viewed as annotating run-time properties of programs ranging from: storage cell usage, to process synchronization requirements, to manipulation of aggregate data, to patterns of data sharing and interference. These views are used in turn to safely permit: disregarding of (many) unobservable local side effects, subtyping in passing procedural arguments, assignment in the face of subtyping coercions, and compile-time coordination of concurrency. 
Abstract-found: 1
Intro-found: 1
Reference: [Aho & Ullman 86] <author> Alfred V. Aho and Jeffrey D. </author> <title> Ullman Compilers: Principles, Techniques and Tools Addison-Wesley, 1986 [Banning 78/79] John P. Banning An Efficient Way to Find the Side Effects of Procedure Calls and the Aliases of Variables In Proc. </title> <note> ACM POPL 1979, pp.29-41, as condensed from </note>
Reference-contexts: of the scope of their definition (i.e., those of local extent), memoization (software caching) of pure expressions, common subexpression elimination of pure expressions, dead-code elimination of expressions whose value is not used and which do not mutate the store, code motion within side-effect synchronization contours, and concurrent evaluation non-interfering expressions <ref> [Aho & Ullman 86] </ref>. <p> Unfortunately, this level of analysis must be sensitive to the specific flow of control during program execution to detect information like READ after WRITE and the like <ref> [Aho & Ullman 86, Chapt.10] </ref>. Unfortunately, in a language which supports procedure parameters with potential side-effects, this sort of analysis becomes excruciatingly difficult.
References-found: 1

