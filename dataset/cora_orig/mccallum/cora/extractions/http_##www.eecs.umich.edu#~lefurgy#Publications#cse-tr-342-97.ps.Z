URL: http://www.eecs.umich.edu/~lefurgy/Publications/cse-tr-342-97.ps.Z
Refering-URL: http://www.eecs.umich.edu/~lefurgy/Publications/index.html
Root-URL: http://www.eecs.umich.edu
Email: -lefurgy,icheng,pbird,tnm-@eecs.umich.edu  
Title: Improving Code Density Using Compression Techniques  
Author: Charles Lefurgy, Peter Bird, I-Cheng Chen, and Trevor Mudge 
Keyword: Compression, Code Density, Code Space Optimization, Embedded Systems  
Address: 1301 Beal Ave., Ann Arbor, MI 48109-2122  
Affiliation: EECS Department, University of Michigan  
Abstract: We propose a method for compressing programs in embedded processors where instruction memory size dominates cost. A post-compilation analyzer examines a program and replaces common sequences of instructions with a single instruction codeword. A microprocessor executes the compressed instruction sequences by fetching codewords from the instruction memory, expanding them back to the original sequence of instructions in the decode stage, and issuing them to the execution stages. We apply our technique to the PowerPC instruction set and achieve 30% to 50% reduction in size for SPEC CINT95 programs. 
Abstract-found: 1
Intro-found: 1
Reference: [Aho86] <author> A. Aho, R. Sethi and J. Ullman, </author> <title> Compiler: </title> <booktitle> Principles, Techniques and Tools , Addison-Wesley, </booktitle> <year> 1986. </year>
Reference-contexts: We demonstrate our technique by applying it to the PowerPC instruction set. Improving Code Density Using Compression Techniques 2 1.1 Code generation Compilers generate code using a Syntax Directed Translation Scheme (SDTS) <ref> [Aho86] </ref>. Syn tactic source code patterns are mapped onto templates of instructions which implement the appro priate semantics.
Reference: [ARM95] <institution> Advanced RISC Machines Ltd., </institution> <note> An Introduction to Thumb , March 1995. </note>
Reference-contexts: The instructions included in Thumb either do not require a full 32-bits, are frequently used, or are important to the compiler for generating small object code. Programs compiled for Thumb achieve 30% smaller code in comparison to the standard ARM instruction set <ref> [ARM95] </ref>. MIPS16 defines a 16-bit fixed-length instruction set architecture (ISA) that is a subset of MIPS-III. The instructions used in MIPS16 were chosen by statistically analyzing a wide range of application programs for the instructions most frequently generated by compilers.
Reference: [Bell90] <author> T. Bell, J. Cleary, I. Witten, </author> <title> Text Compression , Prentice Hall, </title> <year> 1990. </year>
Reference-contexts: It can be shown that for every dictionary method there is an equivalent statistical method which achieves equal compression and can be improved upon to give better compression <ref> [Bell90] </ref>. Thus statistical methods can always achieve better compression than dictionary methods albeit at the expense of additional computation requirements for decompression. It should be noted, however, that dictionary compression yields good results in systems with memory and time constraints because one entry expands to several characters.
Reference: [Bird96] <author> P. Bird and T. Mudge, </author> <title> An Instruction Stream Compression Technique CSE-TR-319-96, </title> <institution> EECS Department, University of Michigan, </institution> <month> November </month> <year> 1996. </year>
Reference: [Chen97a] <author> I. Chen, P. Bird, and T. Mudge, </author> <title> The Impact of Instruction Compression on I-cache Performance , CSE-TR-330-97, </title> <institution> EECS Department, University of Michigan, </institution> <year> 1997. </year>
Reference: [Chen97b] <author> I. Chen, </author> <title> Enhancing Instruction Fetching Mechanism Using Data Com pression , Dissertation, </title> <institution> University of Michigan, </institution> <year> 1997. </year>
Reference-contexts: This problem will only increase as the gap between processor performance and memory performance grows. Reducing program size is one way to reduce instruction cache misses and achieve higher performance <ref> [Chen97b] </ref>. This paper focuses on compression for embedded applications, where execution speed can be traded for compression. We borrow concepts from the field of text compression and apply them to the compression of instruction sequences. We propose modifications at the microarchitecture level to support compressed programs.
Reference: [Kissell97] <author> K. Kissell, MIPS16: </author> <title> High-density MIPS for the Embedded Market , Silicon Graphics MIPS Group, </title> <year> 1997. </year>
Reference-contexts: In general, dictionary compression provides for faster (and simpler) decoding, while statistical compression yields a better compression ratio. 2.2 Compression for RISC instruction sets Although a RISC instruction set is easy to decode, its fixed-length instruction formats are wasteful of program memory. Thumb [ARM95][MPR95] and MIPS16 <ref> [Kissell97] </ref> are two compression ratio compressed size original size -= Improving Code Density Using Compression Techniques 5 recently proposed instruction set modifications which define reduced instruction word sizes in an effort to reduce the overall size of compiled programs. <p> The instructions used in MIPS16 were chosen by statistically analyzing a wide range of application programs for the instructions most frequently generated by compilers. Code written for 32-bit MIPS-III is typically reduced 40% in size when compiled for MIPS16 <ref> [Kissell97] </ref>. Both Thumb and MIPS16 act as preprocessors for their underlying architectures. In each case, a 16-bit instruction is fetched from the instruction memory, expanded into a 32-bit wide instruction, and passed to the base processor core for execution.
Reference: [Liao96] <author> S. Liao, </author> <title> Code Generation and Optimization for Embedded Digital Signal Processors , Dissertation, </title> <institution> Massachusetts Institute of Technology, </institution> <month> June </month> <year> 1996. </year>
Reference-contexts: In addition, our compression method does not need a LAT mechanism since we patch all branches to use the new instruction addresses in the compressed program. 2.4 Liao et al. A purely software method of supporting compressed code is proposed in <ref> [Liao96] </ref>. The author finds mini-subroutines which are common sequences of instructions in the program. Each instance of a mini-subroutine is removed from the program and replaced with a call instruction. The mini-subroutine is placed once in the text of the program and ends with a return instruction. <p> Mini-subroutines are not constrained to basic blocks and may contain branch instructions under restricted conditions. The prime advantage of this compression method is that it requires no hardware support. However, the subroutine call overhead will slow program execution. <ref> [Liao96] </ref> suggests a hardware modification to support code compression consisting primarily of a call-dictionary instruction. This instruction takes two arguments: location length mon instruction sequences in the program are saved in a dictionary, and the sequence is replaced in the program with the call-dictionary instruction. <p> During execution, the processor jumps to the point in the dictionary indicated by location and executes length instructions before implicitly returning. <ref> [Liao96] </ref> limits the dictionary to use sequences of instructions within basic blocks only. [Liao96] does not explore the trade-off of the field widths for the location length arguments in the call-dictionary instruction. Only codewords that are 1 or 2 instruction words in size are considered. <p> During execution, the processor jumps to the point in the dictionary indicated by location and executes length instructions before implicitly returning. <ref> [Liao96] </ref> limits the dictionary to use sequences of instructions within basic blocks only. [Liao96] does not explore the trade-off of the field widths for the location length arguments in the call-dictionary instruction. Only codewords that are 1 or 2 instruction words in size are considered. <p> Figure 7 shows which dictionary entries contribute the most to compression. Dictionary entries with 1 instruction achieve between 48% and 60% of the compression savings. The short entries contribute to a larger portion of the savings as the size of the dictionary increases. The compression method in <ref> [Liao96] </ref> cannot take advantage of Table 2: Maximum number of codewords used in baseline compression (max. dictionary entry size = 4) Bench Maximum Number of Codewords Used compress 647 gcc 7927 ijpeg 2107 li 1104 m88ksim 1729 perl 2970 vortex 3545 compress gcc go ijpeg li m88ksim perl vortex Benchmarks 10% <p> Our approach combines elements of two previous proposals. First we use a dictionary compression method (as in <ref> [Liao96] </ref>) that allows codewords to expand to several instructions. Second, we allow the codewords to be smaller than a single instruction (as in [Wolfe94]). We find that the size of the dictionary is the single most important parameter in attaining a better compression ratio.
Reference: [MPR95] <institution> Thumb Squeezes ARM Code Size, </institution> <type> Microprocessor Report 9(4), </type> <month> 27 March </month> <year> 1995. </year>
Reference: [Perl96] <author> S. Perl and R. </author> <title> Sites, Studies of Windows NT performance using dynamic execution traces , Proceedings of the USENIX 2nd Symposium on Operat ing Systems Design and Implementation, </title> <month> October </month> <year> 1996. </year>
Reference-contexts: Thus, the ability to compress instruction code is important, even at the cost of execution speed. High performance systems are also impacted by program size due to the delays incurred by instruction cache misses. A study at Digital <ref> [Perl96] </ref> showed that an SQL server on a DEC 21064 Alpha, is bandwidth limited by a factor of two on instruction cache misses alone. This problem will only increase as the gap between processor performance and memory performance grows.
Reference: [SPEC95] <institution> SPEC CPU95, </institution> <note> Technical Manual, </note> <month> August </month> <year> 1995. </year>
Reference-contexts: Indeed, we found that a small number of instruction encodings are highly reused in most programs. To illustrate the redundancy of instruction encodings, we profiled the SPEC CINT95 benchmarks <ref> [SPEC95] </ref>. The benchmarks were compiled for PowerPC with GCC 2.7.2 using -O2 optimization. Figure 1 shows that compiled programs consist of many instructions that have identical encodings. On average, less than 20% of the instructions in the benchmarks have bit pattern encodings which are used exactly once in the program.
Reference: [Storer77] <author> J. Storer, </author> <title> NP-completeness results concerning data compression, </title> <type> Technical Report 234, </type> <institution> Department of Electrical Engineering and Computer Sci ence, Princeton University, </institution> <year> 1977. </year>
Reference-contexts: Build the dictionary 2. Replace instruction sequences with codewords Improving Code Density Using Compression Techniques 7 3. Encode the codewords 3.1.1 Dictionary content For an arbitrary text, choosing those entries of a dictionary that achieve maximum compres sion is NP-complete in the size of the text <ref> [Storer77] </ref>. As with most dictionary methods, we use a greedy algorithm to quickly determine the dictionary entries . On every iteration of the algorithm, we examine each potential dictionary entry and find the one that results in the largest immediate savings.
Reference: [Szymanski78] <author> T. G. Szymanski, </author> <title> Assembling code for machines with span-dependent instructions, </title> <journal> Communications of the ACM 21:4 , pp. </journal> <pages> 300-308, </pages> <month> April </month> <year> 1978. </year> <title> Improving Code Density Using Compression Techniques 17 </title>
Reference-contexts: If we allowed compression of relative branches, we might need to rewrite codewords representing relative branches after a compression pass; but this would affect relative branch targets thus requiring a rewrite of codewords, etc. The result is a NP-complete problem <ref> [Szymanski78] </ref>. Indirect branches are compressed in our study. Since these branches take their target from a register, the branch instruction itself does not need to be patched after compression, so it cannot create the codeword rewriting problem outlined above.
Reference: [Wolfe92] <author> A. Wolfe and A. Chanin, </author> <booktitle> Executing Compressed Programs on an Embed ded RISC Architecture , Proceedings of the 25th Annual International Sym posium on Microarchitecture, </booktitle> <month> December </month> <year> 1992. </year>
Reference-contexts: This token is replaced with an efficient encoding in the encoding step. 3.1.3 Encoding Encoding refers to the representation of the codewords in the compressed program. As discussed in Section 2.1, variable-length codewords, (such as those used in the Huffman encoding in <ref> [Wolfe92] </ref>) are expensive to decode. A fixed-length codeword, on the other hand, can be used directly as an index into the dictionary making decoding a simple table lookup operation. Our baseline compression method uses a fixed-length codeword to enable fast decoding. We also investigate a variable-length scheme.
Reference: [Wolfe94] <author> M. Kozuch and A. Wolfe, </author> <booktitle> Compression of Embedded System Programs IEEE International Conference on Computer Design, </booktitle> <year> 1994. </year>
Reference-contexts: Although there is a higher decode penalty for using variable-length codewords, we are able to achieve better compression. By restricting the codewords to integer multiples of 4-bits, we have given the decoding process regularity that the 1-bit aligned Huffman encoding in <ref> [Wolfe94] </ref> lacks. Our choice of encoding is based on SPEC CINT95 benchmarks. We present only the best encoding choice we have discovered. We use codewords that are 4-bits, 8-bits, 12-bits, and 16-bits in length. Other programs may benefit from different encodings. <p> Our approach combines elements of two previous proposals. First we use a dictionary compression method (as in [Liao96]) that allows codewords to expand to several instructions. Second, we allow the codewords to be smaller than a single instruction (as in <ref> [Wolfe94] </ref>). We find that the size of the dictionary is the single most important parameter in attaining a better compression ratio. The second most important factor is reducing the codeword size below the size of a single instruction.
References-found: 15

