URL: ftp://ftp.cs.brown.edu/pub/techreports/92/cs92-55.ps.Z
Refering-URL: http://www.cs.brown.edu/publications/techreports/reports/CS-92-55.html
Root-URL: http://www.cs.brown.edu/
Abstract-found: 0
Intro-found: 1
Reference: 1. <author> Todd R. Allen and David A. Padua, </author> <title> ``Debugging Fortran on a Shared Memory Machine,'' </title> <booktitle> 1987 Intl. Conf. on Parallel Processing, </booktitle> <pages> pp. </pages> <address> 721-727 St. Charles, IL, </address> <month> (August </month> <year> 1987). </year>
Reference-contexts: This example shows that the set of detected races can contain artifacts, and that race refinement is necessary to filter out irrelevant information and pinpoint race-causing bugs. Existing data race detection methods <ref> [3, 6, 7, 1, 11, 12, 5, 2, 4] </ref> work by first instrumenting the program so that information about its execution is recorded, then executing the program, and finally analyzing the collected information.
Reference: 2. <author> Jong-Deok Choi and Sang Lyul Min, </author> <title> ``Race Frontier: Reproducing Data Races in Parallel Program Debugging,'' </title> <booktitle> 3rd ACM Symposium on Principles and Practice of Parallel Programming, </booktitle> <pages> pp. </pages> <address> 145-154 Williamsburg, VA, </address> <month> (April </month> <year> 1991). </year>
Reference-contexts: This example shows that the set of detected races can contain artifacts, and that race refinement is necessary to filter out irrelevant information and pinpoint race-causing bugs. Existing data race detection methods <ref> [3, 6, 7, 1, 11, 12, 5, 2, 4] </ref> work by first instrumenting the program so that information about its execution is recorded, then executing the program, and finally analyzing the collected information.
Reference: 3. <author> Anne Dinning and Edith Schonberg, </author> <title> ``An Empirical Comparison of Monitoring Algorithms for Access Anomaly Detection,'' </title> <booktitle> 2nd ACM Symposium on Principles and Practice of Parallel Programming, </booktitle> <pages> pp. </pages> <address> 1-10 Seattle, WA, </address> <month> (March </month> <year> 1990). </year>
Reference-contexts: This example shows that the set of detected races can contain artifacts, and that race refinement is necessary to filter out irrelevant information and pinpoint race-causing bugs. Existing data race detection methods <ref> [3, 6, 7, 1, 11, 12, 5, 2, 4] </ref> work by first instrumenting the program so that information about its execution is recorded, then executing the program, and finally analyzing the collected information.
Reference: 4. <author> Perry A. Emrath, Sanjoy Ghosh, and David A. Padua, </author> <title> ``Detecting Non-Determinacy in Parallel Programs,'' </title> <journal> IEEE Software 9(1) pp. </journal> <month> 69-77 (January </month> <year> 1992). </year>
Reference-contexts: This example shows that the set of detected races can contain artifacts, and that race refinement is necessary to filter out irrelevant information and pinpoint race-causing bugs. Existing data race detection methods <ref> [3, 6, 7, 1, 11, 12, 5, 2, 4] </ref> work by first instrumenting the program so that information about its execution is recorded, then executing the program, and finally analyzing the collected information.
Reference: 5. <author> David P. Helmbold, Charles E. McDowell, and Jian-Zhong Wang, </author> <title> ``Analyzing Traces with Anonymous Synchronization,'' </title> <booktitle> 1990 Intl. Conf. on Parallel Processing, </booktitle> <pages> pp. </pages> <address> 70-77 St. Charles, IL, </address> <month> (August </month> <year> 1990). </year>
Reference-contexts: This example shows that the set of detected races can contain artifacts, and that race refinement is necessary to filter out irrelevant information and pinpoint race-causing bugs. Existing data race detection methods <ref> [3, 6, 7, 1, 11, 12, 5, 2, 4] </ref> work by first instrumenting the program so that information about its execution is recorded, then executing the program, and finally analyzing the collected information.
Reference: 6. <author> Robert Hood, Ken Kennedy, and John Mellor-Crummey, </author> <title> ``Parallel Program Debugging with On-the-y Anomaly Detection,'' </title> <booktitle> Supercomputing '90, </booktitle> <pages> pp. </pages> <address> 74-81 New York, NY, </address> <month> (November </month> <year> 1990). </year>
Reference-contexts: This example shows that the set of detected races can contain artifacts, and that race refinement is necessary to filter out irrelevant information and pinpoint race-causing bugs. Existing data race detection methods <ref> [3, 6, 7, 1, 11, 12, 5, 2, 4] </ref> work by first instrumenting the program so that information about its execution is recorded, then executing the program, and finally analyzing the collected information.
Reference: 7. <author> Barton P. Miller and Jong-Deok Choi, </author> <title> ``A Mechanism for Efficient Debugging of Parallel Programs,'' </title> <booktitle> SIGPLAN Conf. on Programming Language Design and Implementation, </booktitle> <pages> pp. </pages> <address> 135-144 Atlanta, GA, </address> <month> (June </month> <year> 1988). </year> <note> Also appears in SIGPLAN Notices 23(7) (July 1988). </note>
Reference-contexts: This example shows that the set of detected races can contain artifacts, and that race refinement is necessary to filter out irrelevant information and pinpoint race-causing bugs. Existing data race detection methods <ref> [3, 6, 7, 1, 11, 12, 5, 2, 4] </ref> work by first instrumenting the program so that information about its execution is recorded, then executing the program, and finally analyzing the collected information.
Reference: 8. <author> Robert H. B. Netzer and Barton P. Miller, </author> <title> ``Detecting Data Races in Parallel Program Executions,'' pp. </title> <booktitle> 109-129 in Advances in Languages and Compilers for Parallel Processing, </booktitle> <editor> ed. A. Nicolau, D. Gelernter, T. Gross, and D. Padua, </editor> <publisher> MIT Press (1991). </publisher>
Reference-contexts: False alarms can occur because recording every detail about the execution is impractical and because some races can be artifacts of others. In this paper we present results of experiments with two techniques, called ordering and validation <ref> [8, 9] </ref>, and study their behavior as we vary the amount of run-time event ordering information provided to them. These techniques refine the set of all detected races down to a smaller set that should be investigated, mostly containing direct manifestations of bugs. <p> Then, some races can be certified feasible by searching for strongly connected components in the resulting graph. Each connected component encompasses a set of tangled races, at least one of which must be feasible <ref> [8] </ref>. Races that are non-tangled (involving events belonging to no cycle) are guaranteed to be feasible. An optimization to validation involves adding edges only between racing events that event-control one another and then searching for slightly smaller cycles [9].
Reference: 9. <author> Robert H. B. Netzer and Barton P. Miller, </author> <title> ``Improving the Accuracy of Data Race Detection,'' </title> <booktitle> 3rd ACM Symposium on Principles and Practice of Parallel Programming, </booktitle> <pages> pp. </pages> <address> 133-144 Williamsburg, VA, </address> <month> (April </month> <year> 1991). </year>
Reference-contexts: False alarms can occur because recording every detail about the execution is impractical and because some races can be artifacts of others. In this paper we present results of experiments with two techniques, called ordering and validation <ref> [8, 9] </ref>, and study their behavior as we vary the amount of run-time event ordering information provided to them. These techniques refine the set of all detected races down to a smaller set that should be investigated, mostly containing direct manifestations of bugs. <p> This estimation becomes hard when a pair of races is ``tangled'', where each race has an event that precedes an event in the other, making it unclear which race affected the other. In previous work we presented two refinement techniques, ordering and validation, that conservatively locate non-artifact races <ref> [9] </ref>. Although tangled races and partial information mean that we cannot always exactly pinpoint these races, we can order partitions of races to identify first partitions, each of which is guaranteed to contain at least one non-artifact race. <p> Sufficient information then exists to partially order races in different partitions. We can thus identify the first partitions, which are those containing no races that may have been affected by races in any other partition. We have proven that each first partition always contains at least one non-artifact race <ref> [9] </ref>. 3.2. Data Race Validation Data race validation can sometimes further refine the first partitions identified by data race ordering. Validation attempts to determine which races in each first partition are feasible. <p> Races that are non-tangled (involving events belonging to no cycle) are guaranteed to be feasible. An optimization to validation involves adding edges only between racing events that event-control one another and then searching for slightly smaller cycles <ref> [9] </ref>. Given the races in each first partition, validation can sometimes certify some of them as feasible, providing useful debugging information. For example, if ordering identifies a first partition with 10 races, it is unknown which of the 10 are non-artifacts.
Reference: 10. <author> Robert H. B. Netzer and Barton P. Miller, </author> <title> ``What are Race Conditions? Some Issues and Formalizations,'' </title> <journal> ACM Letters on Programming Languages and Systems 1(1)(March 1992). </journal>
Reference: 11. <author> Itzhak Nudler and Larry Rudolph, </author> <title> ``Tools for the Efficient Development of Efficient Parallel Programs,'' </title> <booktitle> 1st Israeli Conf. on Computer System Engineering, </booktitle> <year> (1988). </year>
Reference-contexts: This example shows that the set of detected races can contain artifacts, and that race refinement is necessary to filter out irrelevant information and pinpoint race-causing bugs. Existing data race detection methods <ref> [3, 6, 7, 1, 11, 12, 5, 2, 4] </ref> work by first instrumenting the program so that information about its execution is recorded, then executing the program, and finally analyzing the collected information.
Reference: 12. <author> Guy L. Steele, </author> <title> ``Making Asynchronous Parallelism Safe for the World,'' </title> <booktitle> 17th Annual ACM Symp. on Principles of Programming Languages, </booktitle> <pages> pp. </pages> <address> 218-231 San Francisco, CA, </address> <month> (January </month> <year> 1990). </year> <pages> 15 16 </pages>
Reference-contexts: This example shows that the set of detected races can contain artifacts, and that race refinement is necessary to filter out irrelevant information and pinpoint race-causing bugs. Existing data race detection methods <ref> [3, 6, 7, 1, 11, 12, 5, 2, 4] </ref> work by first instrumenting the program so that information about its execution is recorded, then executing the program, and finally analyzing the collected information.
References-found: 12

