URL: http://www.neci.nj.nec.com/tr/neci-tr-96-3.ps
Refering-URL: http://www.neci.nj.nec.com/tr/index.html
Root-URL: 
Email: cher@cemi.msk.su  avg@research.nj.nec.com  
Title: Negative-Cycle Detection Algorithms  
Author: Boris V. Cherkassky Andrew V. Goldberg 
Note: This work was done while the author was visiting NEC Research Institute, Inc.  
Date: March 1996  
Address: Krasikova St. 32 117418, Moscow, Russia  4 Independence Way Princeton, NJ 08540  
Affiliation: Central Economics and Mathematics Institute  NEC Research Institute  
Abstract: We study the problem of finding a negative length cycle in a network. An algorithm for the negative cycle problem combines a shortest path algorithm and a cycle detection strategy. We study various combinations of shortest path algorithms and cycle detection strategies and find the best combinations. One of our discoveries is that a cycle detection strategy of Tarjan greatly improves practical performance of a classical shortest path algorithm, making it competitive with the fastest known algorithms on a wide range of problems. As a part of our study, we develop problem families for testing negative cycle algorithms. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> R. E. Bellman. </author> <title> On a Routing Problem. </title> <journal> Quart. Appl. Math., </journal> <volume> 16 </volume> <pages> 87-90, </pages> <year> 1958. </year>
Reference-contexts: 1 Introduction The negative cycle problem is the problem of finding a negative length cycle in a network or proving that there are none (see e.g. [15]). The problem is closely related to the shortest path problem (see e.g. <ref> [1, 7, 16, 18, 19, 20] </ref>) of finding shortest path distances in a network with no negative cycles. The negative cycle problem comes up both directly, for example in currency arbitrage, and as a subproblem in algorithms for other network problems, for example the minimum-cost flow problem [14]. <p> The negative cycle problem comes up both directly, for example in currency arbitrage, and as a subproblem in algorithms for other network problems, for example the minimum-cost flow problem [14]. The best theoretical time bound, O (nm), for the shortest path problem is achieved by the Bellman-Ford-Moore algorithm <ref> [1, 7, 18] </ref>. Here n and m denote the number of vertices and arcs in the network, respectively. <p> We do not discuss some of the algorithms such as the Pape-Levit algorithm [16, 20] and the threshold algorithm [9, 10], which were not as robust as other algorithms in our previous study [2]. 5.1 The Bellman-Ford-Moore Algorithm The Bellman-Ford-Moore algorithm, due to Bellman <ref> [1] </ref>, Ford [7], and Moore [18], maintains the set of labeled vertices in a FIFO queue. <p> In addition there is a source connected to all vertices with x = 0. Layer arc lengths are chosen uniformly at random from the interval <ref> [1; 000; 10; 000] </ref>. Inter-layer arc lengths are chosen uniformly at random from 21 the interval [1; 100]. We use two types of grid networks in our experiment. Skeletons of SQNC** problems are square grids with X = Y . <p> In addition there is a source connected to all vertices with x = 0. Layer arc lengths are chosen uniformly at random from the interval [1; 000; 10; 000]. Inter-layer arc lengths are chosen uniformly at random from 21 the interval <ref> [1; 100] </ref>. We use two types of grid networks in our experiment. Skeletons of SQNC** problems are square grids with X = Y . Skeletons of LNC** problems are long grids with Y = 16. Layered networks consist of layers 0; : : : ; X 1. <p> Layered networks consist of layers 0; : : : ; X 1. Each layer is a simple cycle plus a collection of arcs connecting randomly selected pairs of vertices on the cycle. The lengths of the arcs inside a layer are chosen uniformly at random from the interval <ref> [1; 100] </ref>. There are arcs from one layer to the next one, and, in addition, there are arcs from a layer to "forward" layers. Consider an inter-layer arc (u; v) which goes x layers forward. <p> There are arcs from one layer to the next one, and, in addition, there are arcs from a layer to "forward" layers. Consider an inter-layer arc (u; v) which goes x layers forward. The length of this arc is selected uniformly at random from the interval <ref> [1; 10; 000] </ref> and multiplied by x 2 . In addition there is a source connected to all vertices with x = 0. These networks are similar to the Grid-PHard networks of [2], except inter-layer arcs "wrap around" modulo X.
Reference: [2] <author> B. V. Cherkassky, A. V. Goldberg, and T. Radzik. </author> <title> Shortest Paths Algorithms: Theory and Experimental Evaluation. </title> <booktitle> In Proc. 5th ACM-SIAM Symposium on Discrete Algorithms, </booktitle> <pages> pages 516-525, </pages> <year> 1994. </year> <note> To appear in Math. Prog. </note>
Reference-contexts: We also prove another basic result that appears to be new: If the input graph has a negative cycle, the distance labels maintained by the labeling method (with no cycle detection) will get arbitrarily negative. Most experimental studies of shortest path algorithms, such as <ref> [2, 5, 8, 17] </ref>, were conducted on graphs with no negative cycles. In this paper we study the practical performance of algorithms for the negative cycle problem. We also show that a cycle detection strategy of Tarjan [21] leads to improved algorithms for the shortest path problem. <p> The previously known shortest path algorithms we study are the classical Bellman-Ford-Moore algorithm; the Goldberg-Radzik algorithm [12], which on shortest path problems per 1 formed very well in a previous study <ref> [2] </ref>; an incremental graph algorithm of Pallottino [19], which performs well on some classes of shortest path problems; and an algorithm of Tarjan [21], which is a combination of the Bellman-Ford-Moore algorithm and a subtree-disassembly strategy for cycle detection. We also study several new algorithm variations. <p> In this section we discuss some of these strategies and algorithms. We do not discuss some of the algorithms such as the Pape-Levit algorithm [16, 20] and the threshold algorithm [9, 10], which were not as robust as other algorithms in our previous study <ref> [2] </ref>. 5.1 The Bellman-Ford-Moore Algorithm The Bellman-Ford-Moore algorithm, due to Bellman [1], Ford [7], and Moore [18], maintains the set of labeled vertices in a FIFO queue. <p> We implemented these algorithms only with their natural cycle detection mechanisms. The resulting codes are gorc and simp, respectively. In our study of shortest path algorithms <ref> [2] </ref>, we concluded that the Goldberg-Radzik algorithm is the best overall on problems with negative-length arcs. Data of this paper confirms this conclusion. Consider the Bellman-Ford-Moore algorithm. We implemented it with walk to the root, amortized search, subtree disassembly, and subtree disassembly with update strategies. <p> Table 9 summarizes these problem families. The first generator we use is SPRAND <ref> [2] </ref>. <p> The maximum arc length U is fixed at 32; 000, and the minimum arc length L varies from 0 to 64; 000. The second generator we use is TOR, derived from the SPGRID generator of <ref> [2] </ref>. We use this generator to produce two types of skeleton networks: grid networks and layered networks. The skeleton networks have no negative cycles. Grid networks are grids embedded in a torus. <p> The length of this arc is selected uniformly at random from the interval [1; 10; 000] and multiplied by x 2 . In addition there is a source connected to all vertices with x = 0. These networks are similar to the Grid-PHard networks of <ref> [2] </ref>, except inter-layer arcs "wrap around" modulo X. Skeletons of PNC** problems are layered networks with each layer containing 32 vertices and X = n=32. Arcs forming vertex-disjoint negative cycles are added after the skeleton network has been generated. <p> To see if this is the case, we ran the bfct code on a subset of shortest path problem families from <ref> [2] </ref>. The families we use are Grid-SSquare (square grids), Grid-SSquare-S (square grids with an artificial source), Grid-PHard (layered graphs with nonnegative arc lengths), Grid-NHard (layered graphs with arbitrary arc lengths), Rand-4 (random graphs of degree 4), Rand-1:4 (random graphs of degree n=4), and Acyc-Neg (acyclic graphs with negative arc lengths. <p> For detailed description of these problem families, see <ref> [2] </ref>. An interesting question is how much the subtree disassembly used by Tarjan's algorithm improves the Bellman-Ford-Moore algorithm, and how much this strategy improves Pallottino's algorithm. We also evaluate the optimized network simplex algorithm. <p> To answer these questions, we include gorc, simp, and palt in these experiments. (The former code is almost the same as gor of <ref> [2] </ref>.) We also use an implementation bfp of the Bellman-Ford-Moore algorithm, and an implementation two-q of Pallottino's algorithm. We use the same codes as in [2]. Results of the follow-up experiment appear in Tables 17 - 23. <p> To answer these questions, we include gorc, simp, and palt in these experiments. (The former code is almost the same as gor of <ref> [2] </ref>.) We also use an implementation bfp of the Bellman-Ford-Moore algorithm, and an implementation two-q of Pallottino's algorithm. We use the same codes as in [2]. Results of the follow-up experiment appear in Tables 17 - 23. First we observe that bfct outperforms bfp on all problem families, often by a very wide margin. This is due to the reduction in the number of scan operations due to subtree disassembly. <p> Both algorithms are very robust, although the former is somewhat more robust. The variant of Tarjan's algorithm implemented by bfcm and bfctn performed similarly to Tarjan's algorithm. Because the Goldberg-Radzik algorithm performed so well on shortest path problems with negative length arcs in <ref> [2] </ref>, we expected that it would perform well on many negative cycle problems. The good performance of Tarjan's algorithm was a surprise. This algorithm was motivated by adding immediate cycle detection to the Bellman-Ford-Moore algorithm so that the additional work can be amortized over the work done by labeling operations.
Reference: [3] <author> T. H. Cormen, C. E. Leiserson, and R. L. Rivest. </author> <title> Introduction to Algorithms. </title> <publisher> MIT Press, </publisher> <address> Cambridge, MA, </address> <year> 1990. </year> <month> 50 </month>
Reference-contexts: rooted at s such that for any v 2 V , the s to v path in the tree is a shortest path from s to v. 3 Labeling Method In this section we briefly outline the general labeling method [6, 7] for solving the shortest path problem. (See e.g. <ref> [3, 8, 22] </ref> for more detail.) Most shortest path algorithms, and all those which we study in this paper, are based on the labeling method. For every vertex v, the method maintains its distance label d (v) and parent p (v).
Reference: [4] <author> G. B. Dantzig. </author> <title> Application of the Simplex Method to a Transportation Problem. </title> <editor> In T. C. Koopmans, editor, </editor> <booktitle> Activity Analysis and Production and Allocation, </booktitle> <pages> pages 359-373. </pages> <publisher> Wiley, </publisher> <address> New York, </address> <year> 1951. </year>
Reference-contexts: We also study several new algorithm variations. We develop a version of the network simplex method <ref> [4] </ref> optimized specifically for the negative cycle problem. We note that a simple modification of Tarjan's algorithm gives the "ideal" version of the Bellman-Ford-Moore algorithm and study this version. <p> Theorem 5.3 [19] Pallottino's algorithm runs in O (n 2 m) time in the worst case, assuming no negative cycles. 5.4 Network Simplex Algorithm In this section we describe a specialization of the network simplex method <ref> [4] </ref> to the shortest path problem. The resulting algorithm is a labeling algorithm, but not a scanning algorithm. The main invariant maintained by the network simplex method is that the current tree arcs have zero reduced costs.
Reference: [5] <author> R. B. Dial, F. Glover, D. Karney, and D. Klingman. </author> <title> A Computational Analysis of Alternative Algorithms and Labeling Techniques for Finding Shortest Path Trees. </title> <journal> Networks, </journal> <volume> 9 </volume> <pages> 215-248, </pages> <year> 1979. </year>
Reference-contexts: We also prove another basic result that appears to be new: If the input graph has a negative cycle, the distance labels maintained by the labeling method (with no cycle detection) will get arbitrarily negative. Most experimental studies of shortest path algorithms, such as <ref> [2, 5, 8, 17] </ref>, were conducted on graphs with no negative cycles. In this paper we study the practical performance of algorithms for the negative cycle problem. We also show that a cycle detection strategy of Tarjan [21] leads to improved algorithms for the shortest path problem.
Reference: [6] <author> L. Ford. </author> <title> Network Flow Theory. </title> <type> Technical Report P-932, </type> <institution> The Rand Corporation, </institution> <year> 1956. </year>
Reference-contexts: All known algorithms for the negative cycle problem combine a shortest path algorithm and a cycle detection strategy. We study combinations of shortest path algorithms and cycle detection strategies to determine the best combination. The shortest path algorithms we study are based on the labeling method of Ford <ref> [6, 7] </ref>. Most cycle detection strategies for the labeling method look for cycles in the graph of parent pointers maintained by the method. <p> A shortest path tree of G is a spanning tree rooted at s such that for any v 2 V , the s to v path in the tree is a shortest path from s to v. 3 Labeling Method In this section we briefly outline the general labeling method <ref> [6, 7] </ref> for solving the shortest path problem. (See e.g. [3, 8, 22] for more detail.) Most shortest path algorithms, and all those which we study in this paper, are based on the labeling method.
Reference: [7] <author> L. R. Ford, Jr. and D. R. Fulkerson. </author> <title> Flows in Networks. </title> <publisher> Princeton Univ. Press, </publisher> <address> Princeton, NJ, </address> <year> 1962. </year>
Reference-contexts: 1 Introduction The negative cycle problem is the problem of finding a negative length cycle in a network or proving that there are none (see e.g. [15]). The problem is closely related to the shortest path problem (see e.g. <ref> [1, 7, 16, 18, 19, 20] </ref>) of finding shortest path distances in a network with no negative cycles. The negative cycle problem comes up both directly, for example in currency arbitrage, and as a subproblem in algorithms for other network problems, for example the minimum-cost flow problem [14]. <p> The negative cycle problem comes up both directly, for example in currency arbitrage, and as a subproblem in algorithms for other network problems, for example the minimum-cost flow problem [14]. The best theoretical time bound, O (nm), for the shortest path problem is achieved by the Bellman-Ford-Moore algorithm <ref> [1, 7, 18] </ref>. Here n and m denote the number of vertices and arcs in the network, respectively. <p> All known algorithms for the negative cycle problem combine a shortest path algorithm and a cycle detection strategy. We study combinations of shortest path algorithms and cycle detection strategies to determine the best combination. The shortest path algorithms we study are based on the labeling method of Ford <ref> [6, 7] </ref>. Most cycle detection strategies for the labeling method look for cycles in the graph of parent pointers maintained by the method. <p> A shortest path tree of G is a spanning tree rooted at s such that for any v 2 V , the s to v path in the tree is a shortest path from s to v. 3 Labeling Method In this section we briefly outline the general labeling method <ref> [6, 7] </ref> for solving the shortest path problem. (See e.g. [3, 8, 22] for more detail.) Most shortest path algorithms, and all those which we study in this paper, are based on the labeling method. <p> We do not discuss some of the algorithms such as the Pape-Levit algorithm [16, 20] and the threshold algorithm [9, 10], which were not as robust as other algorithms in our previous study [2]. 5.1 The Bellman-Ford-Moore Algorithm The Bellman-Ford-Moore algorithm, due to Bellman [1], Ford <ref> [7] </ref>, and Moore [18], maintains the set of labeled vertices in a FIFO queue. The next vertex to be scanned is removed from the head of the queue; a vertex that becomes labeled is added to the tail of the queue if it is not already on the queue.
Reference: [8] <author> G. Gallo and S. Pallottino. </author> <title> Shortest Paths Algorithms. </title> <journal> Annals of Oper. Res., </journal> <volume> 13 </volume> <pages> 3-79, </pages> <year> 1988. </year>
Reference-contexts: We also prove another basic result that appears to be new: If the input graph has a negative cycle, the distance labels maintained by the labeling method (with no cycle detection) will get arbitrarily negative. Most experimental studies of shortest path algorithms, such as <ref> [2, 5, 8, 17] </ref>, were conducted on graphs with no negative cycles. In this paper we study the practical performance of algorithms for the negative cycle problem. We also show that a cycle detection strategy of Tarjan [21] leads to improved algorithms for the shortest path problem. <p> rooted at s such that for any v 2 V , the s to v path in the tree is a shortest path from s to v. 3 Labeling Method In this section we briefly outline the general labeling method [6, 7] for solving the shortest path problem. (See e.g. <ref> [3, 8, 22] </ref> for more detail.) Most shortest path algorithms, and all those which we study in this paper, are based on the labeling method. For every vertex v, the method maintains its distance label d (v) and parent p (v). <p> Our codes are written in C and compiled with the LINUX gcc compiler using the O4 optimization option. Our implementations use the adjacency list representation of the input graph, similar to that of <ref> [8] </ref>. We attempted to make our implementations of different algorithms uniform to make the running time comparisons more meaningful. We also tried to make the implementations efficient.
Reference: [9] <author> F. Glover, R. Glover, and D. Klingman. </author> <title> Computational Study of an Improved Shortest Path Algorithm. </title> <journal> Networks, </journal> <volume> 14 </volume> <pages> 25-37, </pages> <year> 1984. </year>
Reference-contexts: In this section we discuss some of these strategies and algorithms. We do not discuss some of the algorithms such as the Pape-Levit algorithm [16, 20] and the threshold algorithm <ref> [9, 10] </ref>, which were not as robust as other algorithms in our previous study [2]. 5.1 The Bellman-Ford-Moore Algorithm The Bellman-Ford-Moore algorithm, due to Bellman [1], Ford [7], and Moore [18], maintains the set of labeled vertices in a FIFO queue.
Reference: [10] <author> F. Glover, D. Klingman, and N. Phillips. </author> <title> A New Polynomially Bounded Shortest Paths Algorithm. </title> <journal> Oper. Res., </journal> <volume> 33 </volume> <pages> 65-73, </pages> <year> 1985. </year>
Reference-contexts: In this section we discuss some of these strategies and algorithms. We do not discuss some of the algorithms such as the Pape-Levit algorithm [16, 20] and the threshold algorithm <ref> [9, 10] </ref>, which were not as robust as other algorithms in our previous study [2]. 5.1 The Bellman-Ford-Moore Algorithm The Bellman-Ford-Moore algorithm, due to Bellman [1], Ford [7], and Moore [18], maintains the set of labeled vertices in a FIFO queue. <p> In addition there is a source connected to all vertices with x = 0. Layer arc lengths are chosen uniformly at random from the interval <ref> [1; 000; 10; 000] </ref>. Inter-layer arc lengths are chosen uniformly at random from 21 the interval [1; 100]. We use two types of grid networks in our experiment. Skeletons of SQNC** problems are square grids with X = Y . <p> There are arcs from one layer to the next one, and, in addition, there are arcs from a layer to "forward" layers. Consider an inter-layer arc (u; v) which goes x layers forward. The length of this arc is selected uniformly at random from the interval <ref> [1; 10; 000] </ref> and multiplied by x 2 . In addition there is a source connected to all vertices with x = 0. These networks are similar to the Grid-PHard networks of [2], except inter-layer arcs "wrap around" modulo X.
Reference: [11] <author> A. V. Goldberg. </author> <title> Scaling Algorithms for the Shortest Paths Problem. </title> <journal> SIAM J. Comput., </journal> <volume> 24 </volume> <pages> 494-504, </pages> <year> 1995. </year>
Reference-contexts: Here n and m denote the number of vertices and arcs in the network, respectively. With the additional assumption that arc lengths are integers bounded below by N 2, the O ( p nm log N ) bound of Goldberg <ref> [11] </ref> improves the Bellman-Ford-Moore bound unless N is very large. The same bounds hold for the negative cycle problem. All known algorithms for the negative cycle problem combine a shortest path algorithm and a cycle detection strategy. <p> If, however, G d has a negative length cycle, we can terminate the computation. If G d has zero length cycles, we can contract such cycles and continue the computation. This can be easily done while maintaining the O (nm) time bound. (See e.g. <ref> [11] </ref>.) Our implementation of the Goldberg-Radzik algorithm has one simplification. The implementation uses depth-first search to compute topological ordering of the admissible graph. Instead of contracting zero length cycles, we simply ignore the back arcs discovered during the depth-first search. <p> Furthermore, since cycles in G p can disappear, we are not guaranteed to find a cycle at the first search after the first cycle in G p appears. In fact, the cycle can be found much later. 6.5 Admissible Graph Search This method, due to Goldberg <ref> [11] </ref>, is based on the fact that the arcs in G p are admissible. Therefore if G p contains a cycle, the admissible graph G d contains a negative cycle.
Reference: [12] <author> A. V. Goldberg and T. Radzik. </author> <title> A Heuristic Improvement of the Bellman-Ford Algorithm. </title> <journal> Applied Math. Let., </journal> <volume> 6 </volume> <pages> 3-6, </pages> <year> 1993. </year>
Reference-contexts: These algorithms are usually competitive with the fastest previous codes and are a good choice for many practical situations. The previously known shortest path algorithms we study are the classical Bellman-Ford-Moore algorithm; the Goldberg-Radzik algorithm <ref> [12] </ref>, which on shortest path problems per 1 formed very well in a previous study [2]; an incremental graph algorithm of Pallottino [19], which performs well on some classes of shortest path problems; and an algorithm of Tarjan [21], which is a combination of the Bellman-Ford-Moore algorithm and a subtree-disassembly strategy <p> Theorem 5.1 (i) Each pass takes O (m) time. (ii) The number of passes is bounded by the depth of a shortest path tree. (iii) The algorithm runs in O (nm) time in the worst case. 5.2 The Goldberg-Radzik Algorithm Goldberg and Radzik <ref> [12] </ref> suggested the following improvement of the Bellman-Ford-Moore algorithm that achieves the same worst-case time bound but usually outperforms the Bellman-Ford-Moore algorithm in practice. The algorithm maintains the set of labeled vertices in two sets, A and B. Each labeled vertex is in exactly one set. <p> The algorithm achieves the same bound as the Bellman-Ford-Moore algorithm, again assuming no negative cycles. Theorem 5.2 <ref> [12] </ref> The Goldberg-Radzik algorithm runs in O (nm) time. Now suppose G has cycles of zero or negative length. In this case G d need not be acyclic. If, however, G d has a negative length cycle, we can terminate the computation.
Reference: [13] <author> J. L. Kennington and R. V. Helgason. </author> <title> Algorithms for Network Programming. </title> <publisher> John Wiley and Sons, </publisher> <year> 1980. </year>
Reference-contexts: This is equivalent to traversing the subtree and applying labeling operations to the tree arcs. We implement this tree traversal procedure by maintaining an in-order list of tree nodes, as in many network simplex codes. See e.g. <ref> [13] </ref>. At every step, a generic network simplex algorithm for shortest paths finds an arc (u; v) with negative reduced cost, applies a labeling operation to it, and updates distance labels of vertices in v's subtree. <p> In general, subtree traversal needs to be applied after every labeling operation and increases the cost of a labeling operation to O (n). (A good way to implement subtree traversal is using standard techniques from the network simplex method for minimum-cost flows; see e.g. <ref> [13] </ref>.) With this strategy, cycle detection is immediate. This strategy fits naturally with the network simplex method. During a pivot on (u; v), we already traverse the subtree rooted at v.
Reference: [14] <author> M. Klein. </author> <title> A Primal Method for Minimal Cost Flows with Applications to the Assignment and Transportation Problems. </title> <journal> Management Science, </journal> <volume> 14 </volume> <pages> 205-220, </pages> <year> 1967. </year>
Reference-contexts: The negative cycle problem comes up both directly, for example in currency arbitrage, and as a subproblem in algorithms for other network problems, for example the minimum-cost flow problem <ref> [14] </ref>. The best theoretical time bound, O (nm), for the shortest path problem is achieved by the Bellman-Ford-Moore algorithm [1, 7, 18]. Here n and m denote the number of vertices and arcs in the network, respectively.
Reference: [15] <author> E. L. Lawler. </author> <title> Combinatorial Optimization: Networks and Matroids. </title> <publisher> Holt, Reinhart, and Winston, </publisher> <address> New York, NY., </address> <year> 1976. </year>
Reference-contexts: 1 Introduction The negative cycle problem is the problem of finding a negative length cycle in a network or proving that there are none (see e.g. <ref> [15] </ref>). The problem is closely related to the shortest path problem (see e.g. [1, 7, 16, 18, 19, 20]) of finding shortest path distances in a network with no negative cycles.
Reference: [16] <author> B. Ju. Levit and B. N. Livshits. Nelineinye Setevye Transportnye Zadachi. </author> <title> Transport, </title> <address> Moscow, </address> <year> 1972. </year> <note> In Russian. 51 </note>
Reference-contexts: 1 Introduction The negative cycle problem is the problem of finding a negative length cycle in a network or proving that there are none (see e.g. [15]). The problem is closely related to the shortest path problem (see e.g. <ref> [1, 7, 16, 18, 19, 20] </ref>) of finding shortest path distances in a network with no negative cycles. The negative cycle problem comes up both directly, for example in currency arbitrage, and as a subproblem in algorithms for other network problems, for example the minimum-cost flow problem [14]. <p> In this section we discuss some of these strategies and algorithms. We do not discuss some of the algorithms such as the Pape-Levit algorithm <ref> [16, 20] </ref> and the threshold algorithm [9, 10], which were not as robust as other algorithms in our previous study [2]. 5.1 The Bellman-Ford-Moore Algorithm The Bellman-Ford-Moore algorithm, due to Bellman [1], Ford [7], and Moore [18], maintains the set of labeled vertices in a FIFO queue.
Reference: [17] <author> J-F. Mondou, T.G. Crainic, and S. Nguyen. </author> <title> Shortest Path Algorithms: A Computational Study with the C Progremming Language. </title> <journal> Computers and Oper. Res., </journal> <volume> 18 </volume> <pages> 767-786, </pages> <year> 1991. </year>
Reference-contexts: We also prove another basic result that appears to be new: If the input graph has a negative cycle, the distance labels maintained by the labeling method (with no cycle detection) will get arbitrarily negative. Most experimental studies of shortest path algorithms, such as <ref> [2, 5, 8, 17] </ref>, were conducted on graphs with no negative cycles. In this paper we study the practical performance of algorithms for the negative cycle problem. We also show that a cycle detection strategy of Tarjan [21] leads to improved algorithms for the shortest path problem.
Reference: [18] <author> E. F. Moore. </author> <title> The Shortest Path Through a Maze. </title> <booktitle> In Proc. of the Int. Symp. on the Theory of Switching, </booktitle> <pages> pages 285-292. </pages> <publisher> Harvard University Press, </publisher> <year> 1959. </year>
Reference-contexts: 1 Introduction The negative cycle problem is the problem of finding a negative length cycle in a network or proving that there are none (see e.g. [15]). The problem is closely related to the shortest path problem (see e.g. <ref> [1, 7, 16, 18, 19, 20] </ref>) of finding shortest path distances in a network with no negative cycles. The negative cycle problem comes up both directly, for example in currency arbitrage, and as a subproblem in algorithms for other network problems, for example the minimum-cost flow problem [14]. <p> The negative cycle problem comes up both directly, for example in currency arbitrage, and as a subproblem in algorithms for other network problems, for example the minimum-cost flow problem [14]. The best theoretical time bound, O (nm), for the shortest path problem is achieved by the Bellman-Ford-Moore algorithm <ref> [1, 7, 18] </ref>. Here n and m denote the number of vertices and arcs in the network, respectively. <p> We do not discuss some of the algorithms such as the Pape-Levit algorithm [16, 20] and the threshold algorithm [9, 10], which were not as robust as other algorithms in our previous study [2]. 5.1 The Bellman-Ford-Moore Algorithm The Bellman-Ford-Moore algorithm, due to Bellman [1], Ford [7], and Moore <ref> [18] </ref>, maintains the set of labeled vertices in a FIFO queue. The next vertex to be scanned is removed from the head of the queue; a vertex that becomes labeled is added to the tail of the queue if it is not already on the queue.
Reference: [19] <author> S. Pallottino. </author> <title> Shortest-Path Methods: Complexity, Interrelations and New Propositions. </title> <journal> Networks, </journal> <volume> 14 </volume> <pages> 257-267, </pages> <year> 1984. </year>
Reference-contexts: 1 Introduction The negative cycle problem is the problem of finding a negative length cycle in a network or proving that there are none (see e.g. [15]). The problem is closely related to the shortest path problem (see e.g. <ref> [1, 7, 16, 18, 19, 20] </ref>) of finding shortest path distances in a network with no negative cycles. The negative cycle problem comes up both directly, for example in currency arbitrage, and as a subproblem in algorithms for other network problems, for example the minimum-cost flow problem [14]. <p> The previously known shortest path algorithms we study are the classical Bellman-Ford-Moore algorithm; the Goldberg-Radzik algorithm [12], which on shortest path problems per 1 formed very well in a previous study [2]; an incremental graph algorithm of Pallottino <ref> [19] </ref>, which performs well on some classes of shortest path problems; and an algorithm of Tarjan [21], which is a combination of the Bellman-Ford-Moore algorithm and a subtree-disassembly strategy for cycle detection. We also study several new algorithm variations. <p> We count the latter only if a depth-first search completed processing a vertex and backtracked from it. 5.3 Incremental-Graph Algorithms In this section we describe the incremental graph framework and Pallottino's algorithm <ref> [19] </ref>. An algorithm in the restricted scan framework maintains a set W of vertices and scans only labeled vertices in W . The set W is monotone: once a vertex is added to W , it remains in W . <p> The algorithm terminates when both queues are empty. As the above discussion of the restricted scan algorithms suggests, the worst-case running time of two q is polynomial. Theorem 5.3 <ref> [19] </ref> Pallottino's algorithm runs in O (n 2 m) time in the worst case, assuming no negative cycles. 5.4 Network Simplex Algorithm In this section we describe a specialization of the network simplex method [4] to the shortest path problem.
Reference: [20] <author> U. Pape. </author> <title> Implementation and Efficiency of Moore Algorithms for the Shortest Root Problem. </title> <journal> Math. Prog., </journal> <volume> 7 </volume> <pages> 212-222, </pages> <year> 1974. </year>
Reference-contexts: 1 Introduction The negative cycle problem is the problem of finding a negative length cycle in a network or proving that there are none (see e.g. [15]). The problem is closely related to the shortest path problem (see e.g. <ref> [1, 7, 16, 18, 19, 20] </ref>) of finding shortest path distances in a network with no negative cycles. The negative cycle problem comes up both directly, for example in currency arbitrage, and as a subproblem in algorithms for other network problems, for example the minimum-cost flow problem [14]. <p> In this section we discuss some of these strategies and algorithms. We do not discuss some of the algorithms such as the Pape-Levit algorithm <ref> [16, 20] </ref> and the threshold algorithm [9, 10], which were not as robust as other algorithms in our previous study [2]. 5.1 The Bellman-Ford-Moore Algorithm The Bellman-Ford-Moore algorithm, due to Bellman [1], Ford [7], and Moore [18], maintains the set of labeled vertices in a FIFO queue.
Reference: [21] <author> R. E. Tarjan. </author> <title> Shortest Paths. </title> <type> Technical report, </type> <institution> AT&T Bell Laboratories, </institution> <address> Murray Hill, NJ, </address> <year> 1981. </year>
Reference-contexts: Most experimental studies of shortest path algorithms, such as [2, 5, 8, 17], were conducted on graphs with no negative cycles. In this paper we study the practical performance of algorithms for the negative cycle problem. We also show that a cycle detection strategy of Tarjan <ref> [21] </ref> leads to improved algorithms for the shortest path problem. These algorithms are usually competitive with the fastest previous codes and are a good choice for many practical situations. <p> path algorithms we study are the classical Bellman-Ford-Moore algorithm; the Goldberg-Radzik algorithm [12], which on shortest path problems per 1 formed very well in a previous study [2]; an incremental graph algorithm of Pallottino [19], which performs well on some classes of shortest path problems; and an algorithm of Tarjan <ref> [21] </ref>, which is a combination of the Bellman-Ford-Moore algorithm and a subtree-disassembly strategy for cycle detection. We also study several new algorithm variations. We develop a version of the network simplex method [4] optimized specifically for the negative cycle problem. <p> The subtree traversal strategy allows the method to detect cycles at essentially no extra cost. 14 We use the subtree traversal strategy only with the network simplex method. 6.7 Subtree Disassembly This method, due to Tarjan <ref> [21] </ref>, is a variation of the subtree traversal strategy that allows one to amortize the subtree traversal work over the work of building the subtree. The method is a variation of the scanning method where some unreached vertices may have finite labels but null parents. <p> However, since the vertices whose status changes have distance labels greater than their true distances, this tends to speed the algorithm up. A combination of the FIFO selection rule and subtree disassembly yields Tarjan's algorithm <ref> [21] </ref> for the negative cycle problem. A variation of subtree disassembly is subtree disassembly with update. This strategy can be viewed as the network simplex method with subtree disassembly strategy. <p> We implemented it with walk to the root, amortized search, subtree disassembly, and subtree disassembly with update strategies. The corresponding codes are bfcf, bfcs, bfct, and bfctn, respectively. As we shall see, the first two codes are not good. The third code, bfct, implements Tarjan's algorithm <ref> [21] </ref>. This code performed very well in our study, greatly outperforming implementations of the Bellman-Ford-Moore algorithm with scan order unaffected by cycle detection strategies. This is an interesting example of how the subtree disassembly strategy improves the performance of the underlying algorithm.
Reference: [22] <author> R. E. Tarjan. </author> <title> Data Structures and Network Algorithms. </title> <institution> Society for Industrial and Applied Mathematics, </institution> <address> Philadelphia, PA, </address> <year> 1983. </year> <month> 52 </month>
Reference-contexts: rooted at s such that for any v 2 V , the s to v path in the tree is a shortest path from s to v. 3 Labeling Method In this section we briefly outline the general labeling method [6, 7] for solving the shortest path problem. (See e.g. <ref> [3, 8, 22] </ref> for more detail.) Most shortest path algorithms, and all those which we study in this paper, are based on the labeling method. For every vertex v, the method maintains its distance label d (v) and parent p (v). <p> At every step, the method selects an arc (u; v) such that d (u) &lt; 1 and d (u) + `(u; v) &lt; d (v) and sets d (v) = d (u) + `(u; v), p (v) = u. Lemma 3.1 (See e.g. <ref> [22] </ref>) The labeling method terminates if and only if G contains no negative cycle. If the method terminates, then d gives correct distances and the parent pointers give a correct shortest path tree. The method terminates if and only if G does not have negative length cycles. <p> We also allow vertices to be scanned several times during a pass. This definition of a pass is more general than the one used in the context of the Bellman-Ford-Moore algorithm 1 . (see e.g. <ref> [22] </ref>). For this algorithm, a pass consists of scanning vertices that are labeled at the end of the previous pass. Our definition allows scans of other labeled vertices (as in the Goldberg-Radzik algorithm) and no scans of vertices with distance labels greater than the true distances (as in Tarjan's algorithm). <p> An efficient pass is a pass such that each vertex is scanned at most once. Passes of the Bellman-Ford-Moore, the Goldberg-Radzik, and Tarjan's algorithms are efficient and take O (m) time. The following lemma is the key to the analysis of these algorithms. Lemma 3.2 (See e.g. <ref> [22] </ref>) If there are no negative cycles reachable from s, then the scanning method terminates after at most n 1 passes. 1 The algorithms mentioned here are described in Section 5 4 Proof. <p> To discuss cycle detection strategies, we need the following definition. The parent graph G p is the subgraph of G induced by the arcs (p (v); v) for all v : p (v) 6= null. This graph has the following properties. Lemma 4.1 (See e.g. <ref> [22] </ref>) Arcs of G p have nonpositive reduced costs. Any cycle in G p is negative. If G p is acyclic, then its arcs form a tree rooted at s. <p> Any cycle in G p is negative. If G p is acyclic, then its arcs form a tree rooted at s. In the presence of negative cycles, it is relatively easy to show that after a finite number of labeling operations, G p must contain a cycle. See e.g. <ref> [22] </ref>. However, a cycle in G p can appear after a labeling operation and disappear after a later labeling operation: see Figure 2. Surprisingly, it seems that this fact has not been known. In particular, we were unable to find Theorem 4.2 in the literature.
References-found: 22

