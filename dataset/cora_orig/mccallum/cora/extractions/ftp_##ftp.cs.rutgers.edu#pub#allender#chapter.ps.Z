URL: ftp://ftp.cs.rutgers.edu/pub/allender/chapter.ps.Z
Refering-URL: http://www.cs.rutgers.edu/~allender/publications/
Root-URL: http://www.cs.rutgers.edu
Email: allender@cs.rutgers.edu  
Title: Applications of Time-Bounded Kolmogorov Complexity in Complexity Theory  
Author: Eric Allender 
Address: New Brunswick, NJ 08903, USA  
Affiliation: Department of Computer Science Rutgers University  
Abstract: This paper presents one method of using time-bounded Kol-mogorov complexity as a measure of the complexity of sets, and outlines a number of applications of this approach to different questions in complexity theory. Connections will be drawn among the following topics: NE predicates, ranking functions, pseudorandom generators, and hier archy theorems in circuit complexity.
Abstract-found: 1
Intro-found: 1
Reference: [All85] <author> E. Allender. </author> <title> Invertible Functions. </title> <type> PhD thesis, </type> <institution> Georgia Institute of Technology, </institution> <year> 1985. </year>
Reference-contexts: Ranking functions were first studied in [GS91] in connection with data compression. Other material on ranking may be found in <ref> [All85, BGS91, BGM90, Huy90a, HR90] </ref>. A number of classes of sets (including the unambiguous context-free languages [GS91]) have been shown to have easy ranking functions. <p> If L has an easy ranking function, then a simple binary search procedure enables one to quickly locate the lexicographically least element of L =n . It thus follows that any such L has K L (n) = O (log n). Thus all the classes of sets shown in <ref> [All85, BGS91, BGM90, Huy90a, GS91] </ref> to have easy ranking functions are also classes of sets with low K L complexity. It is worth noting, however, that the class of sets in P with low K L complexity is somewhat larger than the class of sets with easy ranking functions. <p> For example, it is not hard to see that if L is a context-free language, then K L (n) = O (log n). (The proof is quite similar to the proof of Theorem 4 in [AR88]; see also <ref> [All85, Huy90b] </ref>.) However, it was shown in [Huy90a] that if P 6= PP there are context-free languages that have hard ranking functions. <p> In <ref> [All85] </ref> a number of classes of automata are exhibited that compute only easy-to-invert functions. 5 If L is a language accepted by any machine in one of these classes, then K L (n) = O (log n). The connection to invertible functions was stated more precisely in [AW90].
Reference: [All89a] <author> E. Allender. </author> <title> Some consequences of the existence of pseudorandom generators. </title> <journal> J. Comput. System Sci. </journal> <volume> 39 </volume> <pages> 101-124, </pages> <year> 1989. </year>
Reference-contexts: Pointers to other approaches to time-bounded Kolmogorov complexity may be found in <ref> [All89a, LV90] </ref>. ? Supported in part by the National Science Foundation under Grant CCR-9000045. 2 Eric Allender The variants of time-bounded Kolmogorov complexity mentioned in the preceding paragraph all suffer from certain drawbacks. <p> It is often useful, however, to consider the complexity of the individual strings in a language L, as opposed to the characteristic sequence of L. This leads us to the following definitions <ref> [All89a] </ref>. Definition 3. Let L f0; 1g fl . <p> If f passes all statistical tests in P/poly, then f is said to be secure. That is, f is secure if the pseudorandom output it produces "looks random" to all tests in P/poly. In <ref> [All89a] </ref>, it was shown that most ways of formalizing the hypothesis that secure pseudorandom generators exist have as a consequence that K L (n) grows slowly for all dense sets L in P. 7 For the purposes of this section, the following x in the image of f. 7 In the <p> That is, L is dense if it contains many strings of length n, if it contains any at all. Time-Bounded Kolmogorov Complexity in Complexity Theory 9 result is illustrative. Theorem 10. <ref> [All89a] </ref> If there are pseudorandom generators that are secure against P/poly statistical tests, then K L (n) = O (n * ) for all dense sets L in P/poly, and for all * &gt; 0. Variants of Theorem 10 were used in [All89a] to show new inclusion relations among complexity classes, <p> Theorem 10. <ref> [All89a] </ref> If there are pseudorandom generators that are secure against P/poly statistical tests, then K L (n) = O (n * ) for all dense sets L in P/poly, and for all * &gt; 0. Variants of Theorem 10 were used in [All89a] to show new inclusion relations among complexity classes, under various assumptions about the security of pseudorandom generators. It is known that pseudorandom generators exist if and only if one-way functions exist that are hard to invert over a significant fraction of their range [ILL89, H-as90]. <p> be any easy-to-compute function of the form f (n) = 2 g (n) , and let L = fy : y = xz for some z 2 C with jzj = g (jyj)g Then d L (n) 1=f (n), and K L (n) g (n)=5 2 log n. ut In <ref> [All89a] </ref>, some hope is held out that it might be possible to show that there are relatively dense sets L in P/poly such that K L (n) grows somewhat quickly. (There would have been interesting consequences for the theory of pseudorandom generators, if such sets could have been shown to exist.) <p> that K L (n) grows somewhat quickly. (There would have been interesting consequences for the theory of pseudorandom generators, if such sets could have been shown to exist.) The preceding theorem dashes these hopes (at least as far as relativizing proof techniques are concerned), since the sort of bounds that <ref> [All89a] </ref> discussed the possibility of exceeding are exactly the bounds shown above to hold relative to a random oracle.
Reference: [All89b] <author> E. Allender. </author> <title> The generalized Kolmogorov complexity of sets. </title> <booktitle> In Proc. 4th IEEE Structure in Complexity Theory Conf., </booktitle> <pages> pages 186-194, </pages> <year> 1989. </year>
Reference-contexts: Bennett and Gill observed in [BG81] that for most complexity-theoretic statements C of interest (e.g., for C equal to any of the statements "P=BPP," "P=NP " coNP," 8 Some of the material in Section 4.1 originally appeared in <ref> [All89b] </ref>. 10 Eric Allender etc.), the set of oracles relative to which C holds satisfies Kolmogorov's zero-one law (see, e.g., [Oxt80](Theorem 21.3)). As a consequence, for statements C of this sort, either C holds with probability one or with probability zero, relative to a random oracle.
Reference: [AG91] <author> E. Allender and V. Gore. </author> <title> On strong separations from AC 0 . In Proc. Fundamentals of Computation Theory, Springer-Verlag, </title> <booktitle> Lecture Notes in Computer Science 529 </booktitle> <pages> 1-15, </pages> <year> 1991. </year>
Reference-contexts: It is not known if P-Uniform AC 0 = AC 0 ; the P-uniformity condition just described is much less restrictive than the uniformity condition of [BIS90]. This is addressed by the following theorem: Theorem 14. <ref> [AG91] </ref> P-Uniform AC 0 = AC 0 iff E = S k k time (n). 10 This may be taken as evidence that AC 0 is properly contained in P-uniform AC 0 , because E = S k k time (n) implies that E = DSPACE (n) = NSPACE (n), as <p> Assuming E = S k k time (n) thus says that E is "not very powerful" in some sense, and it seems difficult to imagine that exponential time could simultaneously be powerful enough to solve all NE predicates. Nonetheless, it is shown in <ref> [AG91] </ref> that: Theorem 16. [AG91] There is an oracle relative to which all NE predicates are solvable in exponential time and E = S k k time (n). <p> Assuming E = S k k time (n) thus says that E is "not very powerful" in some sense, and it seems difficult to imagine that exponential time could simultaneously be powerful enough to solve all NE predicates. Nonetheless, it is shown in <ref> [AG91] </ref> that: Theorem 16. [AG91] There is an oracle relative to which all NE predicates are solvable in exponential time and E = S k k time (n). Thus it would represent a significant advance at this time to show that there are sets in NP that are immune to AC 0 . <p> Thus it would represent a significant advance at this time to show that there are sets in NP that are immune to AC 0 . The oracle construction in <ref> [AG91] </ref> makes heavy use of the notions of time-bounded Kolmogorov complexity surveyed here. Conversely, it was observed in [AG91] that if P=NP, then there is a set in P that is immune to AC 0 (because P=NP implies there is a set in E that is immune to S k k <p> Thus it would represent a significant advance at this time to show that there are sets in NP that are immune to AC 0 . The oracle construction in <ref> [AG91] </ref> makes heavy use of the notions of time-bounded Kolmogorov complexity surveyed here. Conversely, it was observed in [AG91] that if P=NP, then there is a set in P that is immune to AC 0 (because P=NP implies there is a set in E that is immune to S k k time (n), and this gives rise to a tally set in P that is immune to AC 0
Reference: [AR88] <author> E. Allender and R. Rubinstein. </author> <title> P-printable sets. </title> <journal> SIAM J. Comput. </journal> <volume> 17 </volume> <pages> 1193-1202, </pages> <year> 1988. </year>
Reference-contexts: However, it is suspected that there are sparse sets in P that are not P-printable. P-printable sets were defined in [HY84] and have been studied in many papers; for further information see [Boo92]. It was shown in <ref> [AR88] </ref> (see also [HH88]) that L is P-printable iff L is in P and K L (n) = O (log n). Many of the papers that consider P-printable sets ask if every infinite set in P has an infinite P-printable subset. <p> It is an easy observation that a set L in P has an infinite P-printable subset iff K L (n) 6= !(log n). Furthermore, it was observed by Russo (see <ref> [AR88] </ref>) that sets in NP are similar to sets in P in this regard: every set in P has an infinite P-printable subset iff every set in NP has an infinite P-printable subset. <p> For example, it is not hard to see that if L is a context-free language, then K L (n) = O (log n). (The proof is quite similar to the proof of Theorem 4 in <ref> [AR88] </ref>; see also [All85, Huy90b].) However, it was shown in [Huy90a] that if P 6= PP there are context-free languages that have hard ranking functions.
Reference: [AW90] <author> E. Allender and O. Watanabe. </author> <title> Kolmogorov complexity and degrees of tally sets. </title> <journal> Inform. and Computation 86 </journal> <pages> 160-178, </pages> <year> 1990. </year>
Reference-contexts: The connections between NE predicates and Kolmogorov complexity were first drawn in <ref> [AW90] </ref>; the following theorem is a slight generalization of the results presented there. In short, it says that there are hard NE predicates if and only if there are sets L in P such that K L (n) grows quickly. <p> It is natural to ask if it is in fact equivalent to E=NE. Note that if every NE predicate is solvable in exponential time, then E=NE is a trivial consequence; does the converse hold? This question was explicitly raised in <ref> [AW90] </ref> as a result of an investigation using Kolmogorov complexity as a tool for answering certain questions concern ing classes of sets equivalent to tally sets 3 under varying notions of reducibility. 3 A set is a tally set if it is a subset of 0 fl . 6 Eric Allender <p> In [All85] a number of classes of automata are exhibited that compute only easy-to-invert functions. 5 If L is a language accepted by any machine in one of these classes, then K L (n) = O (log n). The connection to invertible functions was stated more precisely in <ref> [AW90] </ref>.
Reference: [AFH87] <author> K. Ambos-Spies, H. Fleischhack, and H. Huwig. </author> <title> Diagonalizations over polynomial-time computable sets. </title> <journal> Theoret. Comput. Sci. </journal> <volume> 51 </volume> <pages> 177-204, </pages> <year> 1987. </year>
Reference-contexts: Different notions of genericity (for different classes ) have been studied by <ref> [Maa82, AFH87, Dow82, Poi86, BI87, Fen91] </ref>. Observe that if 0 , then G 0 -generic implies G -generic.
Reference: [BGS75] <author> T. Baker, J. Gill, and R. Solovay. </author> <title> Relativizations of the P=?NP question. </title> <journal> SIAM J. Comput. </journal> <volume> 4 </volume> <pages> 431-444, </pages> <year> 1975. </year>
Reference-contexts: For example, if is the class of recursive extension functions and G is -generic, then P G 6= NP G 6= coNP G (because the standard diag-onalization argument showing the existence of oracles satisfying this property <ref> [BGS75] </ref> can be modelled in this way). Different notions of genericity (for different classes ) have been studied by [Maa82, AFH87, Dow82, Poi86, BI87, Fen91]. Observe that if 0 , then G 0 -generic implies G -generic.
Reference: [BDG87] <author> J. Balcazar, J. Daz, and J. Gabarro. </author> <title> Characterizations of the class PSPACE/poly. </title> <journal> Theoret. Comput. Sci. </journal> <volume> 52 </volume> <pages> 251-267, </pages> <year> 1987. </year>
Reference-contexts: Investigations of this sort may be found in <ref> [Ko86, Huy85, Huy86, BDG87, MS90, Lut91] </ref>. For example, in [BDG87], it was shown that PSPACE/poly is the class of all languages L such that each finite prefix of the characteristic sequence of L has small space-bounded Kolmogorov complexity. <p> Investigations of this sort may be found in [Ko86, Huy85, Huy86, BDG87, MS90, Lut91]. For example, in <ref> [BDG87] </ref>, it was shown that PSPACE/poly is the class of all languages L such that each finite prefix of the characteristic sequence of L has small space-bounded Kolmogorov complexity.
Reference: [BG81] <author> C. Bennett and J. Gill. </author> <title> Relative to a random oracle, P(A) 6= NP(A) 6= Co-NP(A) with probability 1. </title> <journal> SIAM J. Comput. </journal> <volume> 10 </volume> <pages> 96-113, </pages> <year> 1981. </year>
Reference-contexts: In the following paragraphs, we turn to the study of random and generic oracles for help in hypothesis formation. 8 4.1 Random and Generic Oracles The study of random oracles in complexity theory was initiated in <ref> [BG81] </ref>. There, among other results, it was shown that with probability one, P A 6= NP A , relative to a random oracle A. <p> Bennett and Gill observed in <ref> [BG81] </ref> that for most complexity-theoretic statements C of interest (e.g., for C equal to any of the statements "P=BPP," "P=NP " coNP," 8 Some of the material in Section 4.1 originally appeared in [All89b]. 10 Eric Allender etc.), the set of oracles relative to which C holds satisfies Kolmogorov's zero-one law <p> Thus C S The result follows. To see part 2, note that, with probability one, there is a set B in NTIME A (2 n ) that has no infinite subset in DTIME A (2 2 n1 ) <ref> [BG81, Gas87] </ref>.
Reference: [BGM90] <author> A. Bertoni, M. Goldwurm, and P. Massazza. </author> <title> Counting problems and algebraic formal power series in noncommuting variables. </title> <journal> Inform. Processing Letters 34 </journal> <pages> 117-121, </pages> <year> 1990. </year>
Reference-contexts: Ranking functions were first studied in [GS91] in connection with data compression. Other material on ranking may be found in <ref> [All85, BGS91, BGM90, Huy90a, HR90] </ref>. A number of classes of sets (including the unambiguous context-free languages [GS91]) have been shown to have easy ranking functions. <p> If L has an easy ranking function, then a simple binary search procedure enables one to quickly locate the lexicographically least element of L =n . It thus follows that any such L has K L (n) = O (log n). Thus all the classes of sets shown in <ref> [All85, BGS91, BGM90, Huy90a, GS91] </ref> to have easy ranking functions are also classes of sets with low K L complexity. It is worth noting, however, that the class of sets in P with low K L complexity is somewhat larger than the class of sets with easy ranking functions.
Reference: [BGS91] <author> A. Bertoni, M. Goldwurm, and N. Sabadini. </author> <title> The complexity of computing the number of strings of given length in context-free languages. </title> <journal> Theoret. Comput. Sci. </journal> <volume> 86 </volume> <pages> 325-342, </pages> <year> 1991. </year>
Reference-contexts: Ranking functions were first studied in [GS91] in connection with data compression. Other material on ranking may be found in <ref> [All85, BGS91, BGM90, Huy90a, HR90] </ref>. A number of classes of sets (including the unambiguous context-free languages [GS91]) have been shown to have easy ranking functions. <p> If L has an easy ranking function, then a simple binary search procedure enables one to quickly locate the lexicographically least element of L =n . It thus follows that any such L has K L (n) = O (log n). Thus all the classes of sets shown in <ref> [All85, BGS91, BGM90, Huy90a, GS91] </ref> to have easy ranking functions are also classes of sets with low K L complexity. It is worth noting, however, that the class of sets in P with low K L complexity is somewhat larger than the class of sets with easy ranking functions.
Reference: [BIS90] <author> D. Mix Barrington, N. Immerman, and H. Straubing. </author> <title> On uniformity within N C 1 . J. </title> <journal> Comput. System Sci. </journal> <volume> 41 </volume> <pages> 274-306, </pages> <year> 1990. </year>
Reference-contexts: The issue of choosing the correct notion of uniformity for AC 0 has been addressed by <ref> [BIS90] </ref>. Throughout the rest of this paper, we will consider only "uniform" AC 0 . <p> Call the set of languages accepted by circuits of this type P-Uniform AC 0 . It is not known if P-Uniform AC 0 = AC 0 ; the P-uniformity condition just described is much less restrictive than the uniformity condition of <ref> [BIS90] </ref>.
Reference: [Blu67] <author> M. Blum. </author> <title> A machine-independent theory of the complexity of recursive functions. </title> <editor> J. </editor> <booktitle> ACM 14 </booktitle> <pages> 322-336, </pages> <year> 1967. </year>
Reference-contexts: Levin also used this approach to provide bounds on "speed-up" (in the sense of Blum's speed-up theorem <ref> [Blu67] </ref>) possible for the problem of inverting a polynomial-time computable permutation.
Reference: [BI87] <author> M. Blum and R. Impagliazzo. </author> <title> Generic oracles and oracle classes. </title> <booktitle> In Proc. 28th IEEE Symp. Foundations of Computer Science, </booktitle> <pages> pages 118-126, </pages> <year> 1987. </year> <note> Time-Bounded Kolmogorov Complexity in Complexity Theory 17 </note>
Reference-contexts: Different notions of genericity (for different classes ) have been studied by <ref> [Maa82, AFH87, Dow82, Poi86, BI87, Fen91] </ref>. Observe that if 0 , then G 0 -generic implies G -generic. <p> Different notions of genericity (for different classes ) have been studied by [Maa82, AFH87, Dow82, Poi86, BI87, Fen91]. Observe that if 0 , then G 0 -generic implies G -generic. In <ref> [BI87] </ref> Blum and Impagliazzo promoted the study of complexity classes relative to generic oracles specifically as an alternative to random oracles. (They focused primarily on the notion of genericity that results when is the class of extension functions expressible in the first-order theory of arithmetic; for the rest of this paper, <p> In <ref> [BI87] </ref>, Blum and Impagliazzo make the case that generic oracles are perhaps more likely than random oracles to give correct intuition concerning inclusions among complexity classes; they prove a number of theorems to support this case. <p> However, every infinite set in P A contains infinitely many simple strings. Proof. Part 2 follows from a proof very similar to that of Theorem 2.7 in <ref> [BI87] </ref>. To see part 1, we let L be the generic oracle A itself. Thus, we need to show that, for a generic oracle A, there are infinitely many n such that d A (n) 1 2 n=2 , and K A Let G be any finite oracle. <p> By construction, G 0 contains many strings of length n, but contains no string of length n with Kt A -complexity n=4. It follows by the results and definitions of <ref> [BI87] </ref> that, since any finite oracle can be extended in this way, any generic oracle has the properties claimed in the statement of the theorem. ut 14 Eric Allender Corollary 13. Relative to a generic oracle, there is no pseudorandom generator that is secure against P/poly adversaries. Proof.
Reference: [Boo91] <author> R. </author> <title> Book. Some observations on separating complexity classes. </title> <journal> SIAM J. Comput. </journal> <volume> 20 </volume> <pages> 246-258, </pages> <year> 1991. </year>
Reference-contexts: That 9 A number of other papers discuss in depth the interpretation that should be given to results concerning random oracles. The reader is referred to <ref> [KMR89, KMR91, Cai89, Boo91] </ref>. Time-Bounded Kolmogorov Complexity in Complexity Theory 11 is, the construction is the description of an extension function.
Reference: [Boo92] <author> R. </author> <title> Book. On sets with small information content. </title> <booktitle> In this volume. </booktitle>
Reference-contexts: Sets with this property have been studied extensively in recent years; the interested reader will find material concerning these sets, along with pointers to the relevant literature, in the survey article by R. V. Book <ref> [Boo92] </ref>. Because of this, we will not dwell on the K L measure, and will focus instead on the K L measure throughout the rest of this paper. <p> a result of an investigation using Kolmogorov complexity as a tool for answering certain questions concern ing classes of sets equivalent to tally sets 3 under varying notions of reducibility. 3 A set is a tally set if it is a subset of 0 fl . 6 Eric Allender (See <ref> [Boo92] </ref> for a discussion.) The question was essentially answered by Im-pagliazzo and Tardos [IT89]; they present an oracle relative to which E=NE but there are NE predicates that cannot be solved in exponential time. <p> An immediate consequence of this definition is that all P-printable sets are sparse and are in P. However, it is suspected that there are sparse sets in P that are not P-printable. P-printable sets were defined in [HY84] and have been studied in many papers; for further information see <ref> [Boo92] </ref>. It was shown in [AR88] (see also [HH88]) that L is P-printable iff L is in P and K L (n) = O (log n). Many of the papers that consider P-printable sets ask if every infinite set in P has an infinite P-printable subset.
Reference: [BH88] <author> R. Boppana and R. </author> <title> Hirschfeld. Pseudorandom generators and complexity classes. </title> <booktitle> In Advances in Computing Research. Volume 5: Randomness and Computation, </booktitle> <pages> pages 1-26. </pages> <editor> Edited by S. Micali. </editor> <publisher> JAI Press, </publisher> <address> Greenwich, CT, </address> <year> 1988. </year>
Reference-contexts: A pseudorandom generator is secure if the output produced passes all "feasible" statistical tests for randomness. Pseudorandom generators are the object of much study in the theory of cryptography; an excellent introduction to the theory of pseudorandom generators may be found in <ref> [BH88] </ref>. There are many different ways of formalizing the hypothesis "secure pseudorandom generators exist", depending on the particular notion of statistical test being used, and depending on the desired degree of "security".
Reference: [BS90] <author> R. Boppana and M. Sipser. </author> <title> The complexity of finite functions. </title> <booktitle> In Handbook of Theoretical Computer Science. Vol. A: Algorithms and Complexity, </booktitle> <pages> pages 757-804. </pages> <note> Edited by J. </note> <editor> van Leeuwen. </editor> <publisher> MIT Press (in the United States, </publisher> <address> Canada, and Japan), </address> <publisher> and Elsevier Science Publishers (in other countries), </publisher> <year> 1990. </year>
Reference-contexts: First let us present some basic definitions. (For more background on circuit complexity the reader is referred to the excellent exposition in <ref> [BS90] </ref>.) A language L is said to be accepted by a family of circuits fC n g if each circuit C n takes inputs of length n, and for each x of length n, x 2 L iff C n outputs 1 when given input x.
Reference: [Cai89] <author> J.-Y. Cai. </author> <title> With probability one, a random oracle separates PSPACE from the polynomial-time hierarchy. </title> <journal> J. Comput. System Sci. </journal> <volume> 38 </volume> <pages> 68-85, </pages> <year> 1989. </year>
Reference-contexts: That 9 A number of other papers discuss in depth the interpretation that should be given to results concerning random oracles. The reader is referred to <ref> [KMR89, KMR91, Cai89, Boo91] </ref>. Time-Bounded Kolmogorov Complexity in Complexity Theory 11 is, the construction is the description of an extension function.
Reference: [CGH90] <author> B. Chor, O. Goldreich, and J. H-astad. </author> <title> The random oracle hypothesis is false. </title> <type> Technical report 631, </type> <institution> Department of Computer Science, Technion - Israel Institute of Technology, </institution> <year> 1990. </year>
Reference-contexts: Bennett and Gill went on to conjecture that complexity theoretic statements that hold with probability one relative to a random oracle also hold in the unrel-ativized case. Although their conjecture has been disproved <ref> [Kur83, HCRR90, CGH90] </ref>, it is at least true that the study of complexity-theoretic statements that hold relative to a random oracle provides an internally consistent world view, which sometimes seems useful in gaining intuition concerning the unrelativized case. 9 Thus we will examine the K L complexity of sets L in <p> In fact, at the time of this writing, there is no statement C concerning inclusions among "familiar" complexity classes that is known to hold relative to a generic oracle and known not to hold relative to a random oracle, or vice-versa. Furthermore, the statements C that are shown in <ref> [HCRR90, CGH90] </ref> to hold relative to a random oracle but to be false in the unrelativized case, also hold relative to generic oracles. That is, neither random nor generic oracles give reliable information about which statements hold in the unrelativized case.
Reference: [Dow82] <author> M. Dowd. </author> <title> Forcing and the P hierarchy. </title> <type> Technical report LCSR-TR-35, </type> <institution> Laboratory for Computer Science Research, Rutgers University, </institution> <year> 1982. </year>
Reference-contexts: Different notions of genericity (for different classes ) have been studied by <ref> [Maa82, AFH87, Dow82, Poi86, BI87, Fen91] </ref>. Observe that if 0 , then G 0 -generic implies G -generic.
Reference: [Fen91] <author> S. Fenner. </author> <title> Notions of resource-bounded category and genericity. </title> <booktitle> In Proc. 6th IEEE Structure in Complexity Theory Conf., </booktitle> <pages> pages 196-212, </pages> <year> 1991. </year>
Reference-contexts: A development along this line leads to notions of effective and resource-bounded category (see <ref> [Meh73, Lut90, Fen91] </ref>). Let be a class of extension functions. Then an oracle G is -generic if G is not an element of any -nowhere-dense set. <p> Different notions of genericity (for different classes ) have been studied by <ref> [Maa82, AFH87, Dow82, Poi86, BI87, Fen91] </ref>. Observe that if 0 , then G 0 -generic implies G -generic.
Reference: [Gas87] <author> W. Gasarch. </author> <title> Oracles: three new results. </title> <booktitle> In Mathematical Logic and Theoretical Computer Science, </booktitle> <publisher> Marcel Dekker, </publisher> <address> Inc., </address> <booktitle> Lecture Notes in Pure and Applied Mathematics 106 </booktitle> <pages> 219-251, </pages> <year> 1987. </year>
Reference-contexts: Thus C S The result follows. To see part 2, note that, with probability one, there is a set B in NTIME A (2 n ) that has no infinite subset in DTIME A (2 2 n1 ) <ref> [BG81, Gas87] </ref>.
Reference: [GS91] <author> A. Goldberg and M. Sipser. </author> <title> Compression and ranking. </title> <journal> SIAM J. Comput. </journal> <volume> 20 </volume> <pages> 524-536, </pages> <year> 1991. </year>
Reference-contexts: If L contains only a small fraction of the words of each length and has an easily-computed ranking function this clearly places bounds on the Kt-complexity of any string in L. Ranking functions were first studied in <ref> [GS91] </ref> in connection with data compression. Other material on ranking may be found in [All85, BGS91, BGM90, Huy90a, HR90]. A number of classes of sets (including the unambiguous context-free languages [GS91]) have been shown to have easy ranking functions. <p> Ranking functions were first studied in <ref> [GS91] </ref> in connection with data compression. Other material on ranking may be found in [All85, BGS91, BGM90, Huy90a, HR90]. A number of classes of sets (including the unambiguous context-free languages [GS91]) have been shown to have easy ranking functions. If L has an easy ranking function, then a simple binary search procedure enables one to quickly locate the lexicographically least element of L =n . It thus follows that any such L has K L (n) = O (log n). <p> If L has an easy ranking function, then a simple binary search procedure enables one to quickly locate the lexicographically least element of L =n . It thus follows that any such L has K L (n) = O (log n). Thus all the classes of sets shown in <ref> [All85, BGS91, BGM90, Huy90a, GS91] </ref> to have easy ranking functions are also classes of sets with low K L complexity. It is worth noting, however, that the class of sets in P with low K L complexity is somewhat larger than the class of sets with easy ranking functions.
Reference: [Gor90] <author> V. </author> <title> Gore. </title> <type> Personal communication. </type>
Reference-contexts: As another example, it was shown in [Huy90a] that if every set in NTIME (log n) has an easy ranking function, 4 then P = PP, although Gore has observed <ref> [Gor90] </ref> that K L (n) = O (log n) for all L 2 NTIME (log n).
Reference: [Har83] <author> J. Hartmanis. </author> <title> Generalized Kolmogorov complexity and the structure of feasible computations. </title> <booktitle> In Proc. 24th IEEE Symp. Foundations of Computer Science, </booktitle> <pages> pages 439-445, </pages> <year> 1983. </year>
Reference-contexts: A related (and much more influential) definition due to Hartmanis <ref> [Har83] </ref> yields sets of the form K [g (n); G (n)], consisting of all strings x that can be produced from a description of length g (jxj) in time G (jxj).
Reference: [HCRR90] <author> J. Hartmanis, R. Chang, D. Ranjan, and P. Rohatgi. </author> <title> Structural complexity theory: recent surprises. </title> <booktitle> In Proc. 2nd Scandinavian Workshop on Algorithm Theory, Springer-Verlag, Lecture Notes in Computer Science 447 </booktitle> <pages> 1-12, </pages> <year> 1990. </year>
Reference-contexts: Bennett and Gill went on to conjecture that complexity theoretic statements that hold with probability one relative to a random oracle also hold in the unrel-ativized case. Although their conjecture has been disproved <ref> [Kur83, HCRR90, CGH90] </ref>, it is at least true that the study of complexity-theoretic statements that hold relative to a random oracle provides an internally consistent world view, which sometimes seems useful in gaining intuition concerning the unrelativized case. 9 Thus we will examine the K L complexity of sets L in <p> In fact, at the time of this writing, there is no statement C concerning inclusions among "familiar" complexity classes that is known to hold relative to a generic oracle and known not to hold relative to a random oracle, or vice-versa. Furthermore, the statements C that are shown in <ref> [HCRR90, CGH90] </ref> to hold relative to a random oracle but to be false in the unrelativized case, also hold relative to generic oracles. That is, neither random nor generic oracles give reliable information about which statements hold in the unrelativized case.
Reference: [HH88] <author> J. Hartmanis and L. Hemachandra. </author> <title> On sparse oracles separating feasible complexity classes. </title> <journal> Inform. Processing Letters 28 </journal> <pages> 291-296, </pages> <year> 1988. </year>
Reference-contexts: However, it is suspected that there are sparse sets in P that are not P-printable. P-printable sets were defined in [HY84] and have been studied in many papers; for further information see [Boo92]. It was shown in [AR88] (see also <ref> [HH88] </ref>) that L is P-printable iff L is in P and K L (n) = O (log n). Many of the papers that consider P-printable sets ask if every infinite set in P has an infinite P-printable subset.
Reference: [HY84] <author> J. Hartmanis and Y. Yesha. </author> <title> Computation times of NP sets of different densities. </title> <journal> Theoret. Comput. Sci. </journal> <volume> 34 </volume> <pages> 17-32, </pages> <year> 1984. </year>
Reference-contexts: An immediate consequence of this definition is that all P-printable sets are sparse and are in P. However, it is suspected that there are sparse sets in P that are not P-printable. P-printable sets were defined in <ref> [HY84] </ref> and have been studied in many papers; for further information see [Boo92]. It was shown in [AR88] (see also [HH88]) that L is P-printable iff L is in P and K L (n) = O (log n).
Reference: [H-as86] <author> J. H-astad. </author> <title> Computational Limitations for Small-Depth Circuits. </title> <publisher> MIT Press, </publisher> <year> 1986. </year>
Reference-contexts: The class AC 0 is the class of languages that can be recognized by families of circuits of polynomial size and constant depth, where these circuits consist of unbounded fan-in AND and OR gates. Powerful combinatorial lower bound techniques have been developed in <ref> [H-as86] </ref> (among others), showing that many very simple sets (notably the set PARITY consisting of all strings with an odd number of 1s) cannot be computed by constant depth circuits of such gates of less than exponential size.
Reference: [H-as90] <author> J. H-astad. </author> <title> Pseudo-random generators under uniform assumptions. </title> <booktitle> In Proc. 22nd ACM Symp. Theory of Computing, </booktitle> <pages> pages 395-404, </pages> <year> 1990. </year>
Reference-contexts: It is known that pseudorandom generators exist if and only if one-way functions exist that are hard to invert over a significant fraction of their range <ref> [ILL89, H-as90] </ref>. Thus the existence of this sort of one-way function implies that K L cannot grow too quickly for any dense set L in P.
Reference: [HR90] <author> L. Hemachandra and S. Rudich. </author> <title> On the complexity of ranking. </title> <journal> J. Comput. System Sci. </journal> <volume> 41 </volume> <pages> 251-271, </pages> <year> 1990. </year>
Reference-contexts: Rephrasing Russo's observation in terms of Kolmogorov complexity, we get: Theorem 8. (a) K L (n) 6= !(log n) for all L in P iff K L (n) 6= !(log n) for all L in NP 3.2 Ranking The property of having an infinite P-printable subset was called "tangibility" in <ref> [HR90] </ref>. It was studied there as a very weak notion related to a concept known as ranking. As there are other connections with ranking to explore, let us consider ranking more closely. Definition 9. Let L be a language. <p> Ranking functions were first studied in [GS91] in connection with data compression. Other material on ranking may be found in <ref> [All85, BGS91, BGM90, Huy90a, HR90] </ref>. A number of classes of sets (including the unambiguous context-free languages [GS91]) have been shown to have easy ranking functions.
Reference: [Huy85] <author> D. Huynh. </author> <title> Non-uniform complexity and the randomness of certain complete languages. </title> <type> Technical report TR 85-34, </type> <institution> Computer Science Department, Iowa State University, </institution> <year> 1985. </year>
Reference-contexts: Investigations of this sort may be found in <ref> [Ko86, Huy85, Huy86, BDG87, MS90, Lut91] </ref>. For example, in [BDG87], it was shown that PSPACE/poly is the class of all languages L such that each finite prefix of the characteristic sequence of L has small space-bounded Kolmogorov complexity.
Reference: [Huy86] <author> D. Huynh. </author> <title> Resource-bounded Kolmogorov complexity of hard languages. </title> <booktitle> In Proc. Structure in Complexity Theory, Springer-Verlag, Lecture Notes in Computer Science 223 </booktitle> <pages> 184-195, </pages> <year> 1986. </year> <note> 18 Eric Allender </note>
Reference-contexts: Investigations of this sort may be found in <ref> [Ko86, Huy85, Huy86, BDG87, MS90, Lut91] </ref>. For example, in [BDG87], it was shown that PSPACE/poly is the class of all languages L such that each finite prefix of the characteristic sequence of L has small space-bounded Kolmogorov complexity.
Reference: [Huy90a] <author> D. Huynh. </author> <title> The complexity of ranking simple languages. </title> <journal> Math. Systems Theory 23 </journal> <pages> 1-20, </pages> <year> 1990. </year>
Reference-contexts: Ranking functions were first studied in [GS91] in connection with data compression. Other material on ranking may be found in <ref> [All85, BGS91, BGM90, Huy90a, HR90] </ref>. A number of classes of sets (including the unambiguous context-free languages [GS91]) have been shown to have easy ranking functions. <p> If L has an easy ranking function, then a simple binary search procedure enables one to quickly locate the lexicographically least element of L =n . It thus follows that any such L has K L (n) = O (log n). Thus all the classes of sets shown in <ref> [All85, BGS91, BGM90, Huy90a, GS91] </ref> to have easy ranking functions are also classes of sets with low K L complexity. It is worth noting, however, that the class of sets in P with low K L complexity is somewhat larger than the class of sets with easy ranking functions. <p> For example, it is not hard to see that if L is a context-free language, then K L (n) = O (log n). (The proof is quite similar to the proof of Theorem 4 in [AR88]; see also [All85, Huy90b].) However, it was shown in <ref> [Huy90a] </ref> that if P 6= PP there are context-free languages that have hard ranking functions. As another example, it was shown in [Huy90a] that if every set in NTIME (log n) has an easy ranking function, 4 then P = PP, although Gore has observed [Gor90] that K L (n) = <p> L (n) = O (log n). (The proof is quite similar to the proof of Theorem 4 in [AR88]; see also [All85, Huy90b].) However, it was shown in <ref> [Huy90a] </ref> that if P 6= PP there are context-free languages that have hard ranking functions. As another example, it was shown in [Huy90a] that if every set in NTIME (log n) has an easy ranking function, 4 then P = PP, although Gore has observed [Gor90] that K L (n) = O (log n) for all L 2 NTIME (log n). On the other hand, Huynh's techniques [Huy90a] can easily be used to <p> example, it was shown in <ref> [Huy90a] </ref> that if every set in NTIME (log n) has an easy ranking function, 4 then P = PP, although Gore has observed [Gor90] that K L (n) = O (log n) for all L 2 NTIME (log n). On the other hand, Huynh's techniques [Huy90a] can easily be used to prove that there are sets S 2 coNTIME (log n) with K S 6= O (log n) unless K L (n) = O (log n) for all L 2 P (which is to say, unless all NE predicates are solvable in exponential time). 3.3 Invertibility
Reference: [Huy90b] <author> D. Huynh. </author> <title> Efficient detectors and constructors for simple languages. </title> <type> Technical report UTDCS-26-90, </type> <institution> Computer Science Program, University of Texas at Dallas, </institution> <year> 1990. </year>
Reference-contexts: For example, it is not hard to see that if L is a context-free language, then K L (n) = O (log n). (The proof is quite similar to the proof of Theorem 4 in [AR88]; see also <ref> [All85, Huy90b] </ref>.) However, it was shown in [Huy90a] that if P 6= PP there are context-free languages that have hard ranking functions. <p> Clearly, if L has a PTC, then K L (n) = O (log n), and if L is in P, then L has a PTC iff K L (n) = O (log n). (Additional work dealing with constructors is reported in <ref> [Huy90b] </ref>.) It is noted in [SF90] that most "natural" sets of interest in practical situations are easily seen to have PTCs.
Reference: [IT89] <author> R. Impagliazzo and G. Tardos. </author> <title> Decision versus search in super-polynomial time. </title> <booktitle> In Proc. 30th IEEE Symp. Foundations of Computer Science, </booktitle> <pages> pages 222-227, </pages> <year> 1989. </year>
Reference-contexts: certain questions concern ing classes of sets equivalent to tally sets 3 under varying notions of reducibility. 3 A set is a tally set if it is a subset of 0 fl . 6 Eric Allender (See [Boo92] for a discussion.) The question was essentially answered by Im-pagliazzo and Tardos <ref> [IT89] </ref>; they present an oracle relative to which E=NE but there are NE predicates that cannot be solved in exponential time.
Reference: [ILL89] <author> R. Impagliazzo, L. Levin, and M. Luby. </author> <title> Pseudo-random generation from one-way functions. </title> <booktitle> In Proc. 21st ACM Symp. Theory of Computing, </booktitle> <pages> pages 12-24, </pages> <year> 1989. </year>
Reference-contexts: It is known that pseudorandom generators exist if and only if one-way functions exist that are hard to invert over a significant fraction of their range <ref> [ILL89, H-as90] </ref>. Thus the existence of this sort of one-way function implies that K L cannot grow too quickly for any dense set L in P.
Reference: [KGY89] <author> M. Kharitonov, A. Goldberg, and M. Yung. </author> <title> Lower bounds for pseudorandom number generators. </title> <booktitle> In Proc. 30th IEEE Symp. Foundations of Computer Science, </booktitle> <pages> pages 242-247, </pages> <year> 1989. </year>
Reference-contexts: This model is commonly used when using the Turing machine formalism to characterize circuit complexity classes. 5 In a related result, some of these same classes of machines were shown in <ref> [KGY89] </ref> to be unable to compute pseudorandom generators. 6 A function f is honest if jf (x)j is polynomially related to jxj; f is weakly invertible if there is a function g computable in polynomial time such that f (g (x)) = x for all 8 Eric Allender 3.4 Generation In
Reference: [Ko86] <author> K. Ko. </author> <title> On the notion of infinite pseudorandom sequences. </title> <journal> Theoret. Com-put. Sci. </journal> <volume> 48 </volume> <pages> 9-33, </pages> <year> 1986. </year>
Reference-contexts: Many alternate approaches exist for adding a time-complexity component to Kolmogorov complexity. Sipser [Sip83] and Ko <ref> [Ko86] </ref> proposed essentially identical definitions, allowing one to define, for each function f, a f (n) time-bounded Kolmogorov complexity measure K f , where K f (x) is the length of the shortest description of x from which x can be produced in f (jxj) steps. <p> Investigations of this sort may be found in <ref> [Ko86, Huy85, Huy86, BDG87, MS90, Lut91] </ref>. For example, in [BDG87], it was shown that PSPACE/poly is the class of all languages L such that each finite prefix of the characteristic sequence of L has small space-bounded Kolmogorov complexity.
Reference: [Kur83] <author> S. Kurtz. </author> <title> Notions of weak genericity. </title> <journal> J. Symbolic Logic 48 </journal> <pages> 764-770, </pages> <year> 1983. </year>
Reference-contexts: Bennett and Gill went on to conjecture that complexity theoretic statements that hold with probability one relative to a random oracle also hold in the unrel-ativized case. Although their conjecture has been disproved <ref> [Kur83, HCRR90, CGH90] </ref>, it is at least true that the study of complexity-theoretic statements that hold relative to a random oracle provides an internally consistent world view, which sometimes seems useful in gaining intuition concerning the unrelativized case. 9 Thus we will examine the K L complexity of sets L in
Reference: [KMR89] <author> S. Kurtz, S. Mahaney, and J. Royer. </author> <title> The isomorphism conjecture fails relative to a random oracle. </title> <booktitle> In Proc. 21st ACM Symp. Theory of Computing, </booktitle> <pages> pages 157-166, </pages> <year> 1989. </year>
Reference-contexts: That 9 A number of other papers discuss in depth the interpretation that should be given to results concerning random oracles. The reader is referred to <ref> [KMR89, KMR91, Cai89, Boo91] </ref>. Time-Bounded Kolmogorov Complexity in Complexity Theory 11 is, the construction is the description of an extension function.
Reference: [KMR91] <author> S. Kurtz, S. Mahaney, and J. Royer. </author> <title> Average dependence and random oracles. </title> <type> Technical report SU-CIS-91-03, </type> <institution> School of Computer and Information Science, Syracuse University, </institution> <year> 1991. </year>
Reference-contexts: That 9 A number of other papers discuss in depth the interpretation that should be given to results concerning random oracles. The reader is referred to <ref> [KMR89, KMR91, Cai89, Boo91] </ref>. Time-Bounded Kolmogorov Complexity in Complexity Theory 11 is, the construction is the description of an extension function.
Reference: [Kur83] <author> S. Kurtz. </author> <title> On the random oracle hypothesis. </title> <journal> Inform. and Control 57 </journal> <pages> 40-47, </pages> <year> 1983. </year>
Reference-contexts: Bennett and Gill went on to conjecture that complexity theoretic statements that hold with probability one relative to a random oracle also hold in the unrel-ativized case. Although their conjecture has been disproved <ref> [Kur83, HCRR90, CGH90] </ref>, it is at least true that the study of complexity-theoretic statements that hold relative to a random oracle provides an internally consistent world view, which sometimes seems useful in gaining intuition concerning the unrelativized case. 9 Thus we will examine the K L complexity of sets L in
Reference: [Lev73] <author> L. Levin. </author> <title> Universal sequential search problems. </title> <journal> Problems Inform. </journal> <volume> Transmission 9 </volume> <pages> 265-266, </pages> <year> 1973. </year>
Reference-contexts: Thus we turn to another version of time-bounded Kolmogorov complexity: a definition due to Levin [Lev84] (see also <ref> [Lev73] </ref>). Definition 1. [Lev84] For any strings x and z, and for any Turing machine M v , define Kt v (xjz) to be minfjyj + log t : M v (y; z) = x in at most t stepsg. <p> When searching through all the 2 n possible assignments to the variables of , what is the optimal search strategy that will lead to a satisfying assignment as quickly as any? The answer, as noted by Levin <ref> [Lev73] </ref> is to consider each string z 2 n in order of increasing Kt (zj). Levin also used this approach to provide bounds on "speed-up" (in the sense of Blum's speed-up theorem [Blu67]) possible for the problem of inverting a polynomial-time computable permutation.
Reference: [Lev84] <author> L. Levin. </author> <title> Randomness conservation inequalities; information and independence in mathematical theories. </title> <journal> Inform. and Control 61 </journal> <pages> 15-37, </pages> <year> 1984. </year>
Reference-contexts: Thus we turn to another version of time-bounded Kolmogorov complexity: a definition due to Levin <ref> [Lev84] </ref> (see also [Lev73]). Definition 1. [Lev84] For any strings x and z, and for any Turing machine M v , define Kt v (xjz) to be minfjyj + log t : M v (y; z) = x in at most t stepsg. <p> Thus we turn to another version of time-bounded Kolmogorov complexity: a definition due to Levin <ref> [Lev84] </ref> (see also [Lev73]). Definition 1. [Lev84] For any strings x and z, and for any Turing machine M v , define Kt v (xjz) to be minfjyj + log t : M v (y; z) = x in at most t stepsg.
Reference: [LV90] <author> M. Li and P. Vitanyi. </author> <title> Applications of Kolmogorov Complexity in the Theory of Computation. </title> <booktitle> In Complexity Theory Retrospective, </booktitle> <pages> pages 147-203. </pages> <editor> Edited by A. Selman. </editor> <publisher> Springer-Verlag, </publisher> <year> 1990. </year>
Reference-contexts: Pointers to other approaches to time-bounded Kolmogorov complexity may be found in <ref> [All89a, LV90] </ref>. ? Supported in part by the National Science Foundation under Grant CCR-9000045. 2 Eric Allender The variants of time-bounded Kolmogorov complexity mentioned in the preceding paragraph all suffer from certain drawbacks.
Reference: [Lut90] <author> J. Lutz. </author> <title> Category and measure in complexity classes. </title> <journal> SIAM J. Comput. </journal> <volume> 19 </volume> <pages> 1100-1131, </pages> <year> 1990. </year>
Reference-contexts: A development along this line leads to notions of effective and resource-bounded category (see <ref> [Meh73, Lut90, Fen91] </ref>). Let be a class of extension functions. Then an oracle G is -generic if G is not an element of any -nowhere-dense set.
Reference: [Lut91] <author> J. Lutz. </author> <title> Almost everywhere high nonuniform complexity. </title> <journal> J. Comput. System Sci., </journal> <note> to appear. A preliminary version appeared in Proc. 4th IEEE Structure in Complexity Theory Conf., pages 37-53, </note> <year> 1989. </year>
Reference-contexts: Investigations of this sort may be found in <ref> [Ko86, Huy85, Huy86, BDG87, MS90, Lut91] </ref>. For example, in [BDG87], it was shown that PSPACE/poly is the class of all languages L such that each finite prefix of the characteristic sequence of L has small space-bounded Kolmogorov complexity.
Reference: [Maa82] <author> W. Maass. </author> <title> Recursively enumerable generic sets. </title> <journal> J. Symbolic Logic 47 </journal> <pages> 809-823, </pages> <year> 1982. </year>
Reference-contexts: Different notions of genericity (for different classes ) have been studied by <ref> [Maa82, AFH87, Dow82, Poi86, BI87, Fen91] </ref>. Observe that if 0 , then G 0 -generic implies G -generic.
Reference: [Meh73] <author> K. Mehlhorn. </author> <title> On the size of sets of computable functions. </title> <booktitle> In Proc. 14th IEEE Symp. Switching and Automata Theory, </booktitle> <pages> pages 190-196, </pages> <year> 1973. </year>
Reference-contexts: A development along this line leads to notions of effective and resource-bounded category (see <ref> [Meh73, Lut90, Fen91] </ref>). Let be a class of extension functions. Then an oracle G is -generic if G is not an element of any -nowhere-dense set.
Reference: [MS90] <author> M. Mundhenk and R. Schuler. </author> <title> Non-uniform complexity classes and random languages. </title> <booktitle> In Proc. 5th IEEE Structure in Complexity Theory Conf., </booktitle> <pages> pages 110-119, </pages> <year> 1990. </year>
Reference-contexts: Investigations of this sort may be found in <ref> [Ko86, Huy85, Huy86, BDG87, MS90, Lut91] </ref>. For example, in [BDG87], it was shown that PSPACE/poly is the class of all languages L such that each finite prefix of the characteristic sequence of L has small space-bounded Kolmogorov complexity.
Reference: [Oxt80] <author> J. Oxtoby. </author> <title> Measure and Category (second edition). </title> <publisher> Springer-Verlag, </publisher> <year> 1980. </year>
Reference-contexts: Thus C is nowhere-dense if for every finite oracle F , there is a finite extension F 0 F such that every extension of F 0 is in the complement of C. This corresponds to the classical definition (e.g., as presented in <ref> [Oxt80] </ref>), but for our purposes we will want to require that the function (called an extension function) that produces F 0 from input F be describable in first-order logic, or even be computable. A development along this line leads to notions of effective and resource-bounded category (see [Meh73, Lut90, Fen91]).
Reference: [Poi86] <author> B. Poizat. Q = NQ? J. </author> <booktitle> Symbolic Logic 51 </booktitle> <pages> 22-32, </pages> <year> 1986. </year>
Reference-contexts: Different notions of genericity (for different classes ) have been studied by <ref> [Maa82, AFH87, Dow82, Poi86, BI87, Fen91] </ref>. Observe that if 0 , then G 0 -generic implies G -generic.
Reference: [SF90] <author> L. Sanchis and M. Fulk. </author> <title> On the efficient generation of language instances. </title> <journal> SIAM J. Comput. </journal> <volume> 19 </volume> <pages> 281-296, </pages> <year> 1990. </year>
Reference-contexts: related to jxj; f is weakly invertible if there is a function g computable in polynomial time such that f (g (x)) = x for all 8 Eric Allender 3.4 Generation In work originally motivated by the problem of generating test data for heuristic testing and evaluation, Sanchis and Fulk <ref> [SF90] </ref> defined the notion of a polynomial-time constructor (PTC) for a language L, which is a routine running in polynomial time that on input 1 n either produces an element of L =n or announces that L =n = ;. <p> Clearly, if L has a PTC, then K L (n) = O (log n), and if L is in P, then L has a PTC iff K L (n) = O (log n). (Additional work dealing with constructors is reported in [Huy90b].) It is noted in <ref> [SF90] </ref> that most "natural" sets of interest in practical situations are easily seen to have PTCs.
Reference: [Sip83] <author> M. Sipser. </author> <title> A complexity theoretic approach to randomness. </title> <booktitle> In Proc. 15th ACM Symp. Theory of Computing, </booktitle> <pages> pages 330-335, </pages> <year> 1983. </year> <note> Time-Bounded Kolmogorov Complexity in Complexity Theory 19 </note>
Reference-contexts: Many alternate approaches exist for adding a time-complexity component to Kolmogorov complexity. Sipser <ref> [Sip83] </ref> and Ko [Ko86] proposed essentially identical definitions, allowing one to define, for each function f, a f (n) time-bounded Kolmogorov complexity measure K f , where K f (x) is the length of the shortest description of x from which x can be produced in f (jxj) steps.
Reference: [Yao82] <author> A. Yao. </author> <title> Theory and applications of trapdoor functions. </title> <booktitle> In Proc. 23rd IEEE Symp. Foundations of Computer Science, </booktitle> <pages> pages 80-91, </pages> <year> 1982. </year> <title> This article was processed using the L A T E X macro package with LMAMULT style </title>
Reference-contexts: In this overview, we will try to present material on an intuitive level; the reader is invited to consult the cited references for more precise definitions. For the purposes of this section we will use the definitions of <ref> [Yao82] </ref>. A statistical test is a language L in P/poly (that is, a set accepted by a (possibly nonuniform) family of polynomial-size circuits). For each input length n, the probability that L contains a random input of length n is simply kL =n k=2 n .
References-found: 58

