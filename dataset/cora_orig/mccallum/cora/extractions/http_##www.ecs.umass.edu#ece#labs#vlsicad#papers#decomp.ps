URL: http://www.ecs.umass.edu/ece/labs/vlsicad/papers/decomp.ps
Refering-URL: http://www.ecs.umass.edu/ece/labs/vlsicad/ciesielski.html
Root-URL: 
Title: Decomposition Functional Verification of FSMs 1  
Author: Zafar Hasan Maciej J. Ciesielski 
Address: Amherst, MA 01003  
Affiliation: Department of Electrical Computer Engineering University of Massachusetts  
Abstract: In this paper we present a new method for the decomposition of a Finite State Machine (FSM) into a network of interacting FSMs and a framework for the functional verification and simulation of the FSM network at different levels of abstraction. The problem of decomposition is solved using a multiway graph partitioning technique. The number of submachines is determined dynamically during the partitioning process. The verification algorithm is used to verify the correctness of the FSM network at any stage of the synthesis process. It can be used to verify (a) the result of FSM decomposition on a behavioral level, (b) the encoded FSM network, and (c) the network after logic optimization. Our verification technique is based on an efficient enumeration-simulation method which involves traversal of the state transition graph of the prototype machine in a depth first fashion and simulation of the decomposed machine network. Both the decompostion and verification/simulation algorithms have been implemented as a computer system and tested on a set of benchmark examples. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> D.B. Armstrong, </author> <title> "A programmed algorithm for assigning internal codes to sequential machines," </title> <journal> IRE Trans. Electron. Computers, </journal> <volume> vol. EC-11, no. 4, </volume> <pages> pp 466-472, </pages> <month> August </month> <year> 1962. </year>
Reference-contexts: The rules described above to assign positive weights are aimed at the minimization of the combinational logic component of the FSM. These rules were employed in the past to create a code adjacency graph and used to find the state assignment which minimizes the logic complexity of the machine <ref> [1] </ref>, [19]. To obtain the state assignment the adjacency graph was embedded on a minimum-dimension boolean cube so as to minimize the weighted distance on the cube. Example 3: Consider the partial truth table shown in Figure 3.
Reference: [2] <author> P. Ashar, S. Devadas, and A.R. </author> <title> Newton, "A Unified Approach to the Decomposition and Re-decomposition of Sequential Machines," </title> <booktitle> 27th ACM/IEEE Design Automation Conference, </booktitle> <pages> pages 601-606, </pages> <month> June </month> <year> 1990. </year>
Reference: [3] <author> P. Ashar, S. Devadas, and A.R. </author> <title> Newton, "Optimum and heuristic algorithms for an approach to finite state machine decomposition," </title> <journal> IEEE Trans. Computer-Aided Design, </journal> <volume> vol. 10, </volume> <pages> pages 296-310, </pages> <month> March </month> <year> 1991. </year>
Reference-contexts: Multiway partitioning has been used here to optimally determine both the outputs and the internal states of the submachines. Several algorithms have been proposed to decompose an FSM into two interacting sub-machines [16], [9], <ref> [3] </ref>, [13], but no significant results have been achieved in the field of multi-machine decomposition. Here we present an algorithm to decompose an FSM into an arbitrary number of submachines. The primary goal of this method is the improvement of performance and/or the area of the final implementation. <p> Here we present an algorithm to decompose an FSM into an arbitrary number of submachines. The primary goal of this method is the improvement of performance and/or the area of the final implementation. This is in contrast with other methods, such as <ref> [3] </ref>, where the emphasis is on reduction of circuit area only. Our approach is unique in that the number of submachines is not predetermined, but is determined dynamically, depending on the characteristics of the original machine. <p> The occurrence of these factors become calls to the factoring machine from the factored machine. This method does not have a definite cost function to optimize and does not guarantee anything about the quality of the decomposition. Ashar et al. in <ref> [3] </ref> presented another decomposition method where the topology of the decomposed machine is a general decomposition topology as shown in Fig. 1. <p> All the above mentioned decomposition methods basically aim at two-way partition. There is no significant work done on multi-way partitioning of sequential machines. Although in principal, the general decomposition method described by Ashar et al. in <ref> [3] </ref> can be extended to multi-way partitioning, the method is not clearly indicated. Further, none of 6 the published work aim at minimizing the delay of the decomposed machine. The problem of verification of single FSMs has been under investigation for a long time. <p> Area Delay Area Delay bbara 97 30.30 106 14.00 cse 249 69.10 349 31.00 planet 849 140.40 978 24.10 pma 385 62.30 400 34.30 indust1 606 74.00 783 25.80 indust2 137 35.20 193 17.50 indust3 1070 101.00 1325 36.10 compared with previously reported data on the two-way decomposition schemes of <ref> [3] </ref> and [13]. Comparing the results reported here with those in [13] our program gives lower delay in all, and lower area in the majority of the examples tried. The method of [3] gives slightly better areas for two-way decomposition. However, delay estimates were not available for comparison. <p> 193 17.50 indust3 1070 101.00 1325 36.10 compared with previously reported data on the two-way decomposition schemes of <ref> [3] </ref> and [13]. Comparing the results reported here with those in [13] our program gives lower delay in all, and lower area in the majority of the examples tried. The method of [3] gives slightly better areas for two-way decomposition. However, delay estimates were not available for comparison. It should be noted that the primary goal in [3] was to reduce area. In this new technique, both area and delay are considered. <p> The method of <ref> [3] </ref> gives slightly better areas for two-way decomposition. However, delay estimates were not available for comparison. It should be noted that the primary goal in [3] was to reduce area. In this new technique, both area and delay are considered. As the number of submachines is usually larger in the proposed technique, it can be expected that the delays reported here are better than those using the method in [3]. <p> noted that the primary goal in <ref> [3] </ref> was to reduce area. In this new technique, both area and delay are considered. As the number of submachines is usually larger in the proposed technique, it can be expected that the delays reported here are better than those using the method in [3]. The data obtained could not be compared with other data on multiway FSM decomposition since none has been published to date. 14 5 Verification We now formally define the verification problem.
Reference: [4] <author> M.C. Browne, E.M. Clarke, D.L. Dill and B. Mishra, </author> <title> "Automatic verification of sequential circuits using temporal logic," </title> <journal> IEEE Trans. Computers, </journal> <volume> vol. C-35, </volume> <pages> pages 1035-1044, </pages> <month> December </month> <year> 1986. </year>
Reference-contexts: Thus this method is not very useful for our framework. There exist some other algorithms that can verify single FSMs but require huge amount of memory for storage and can be used only for small machines, <ref> [4] </ref> [20]. Most of the above mentioned algorithms verify two implementations of a single FSM at the logic level. They do not address the problem of verifying a network of FSMs at the symbolic level.
Reference: [5] <author> R.E. Bryant, </author> <title> "Symbolic verification of MOS circuits," </title> <booktitle> Proc. of the 1985 Chapel Hill Conference on VLSI, </booktitle> <pages> pages 419-438, </pages> <month> December </month> <year> 1985. </year>
Reference-contexts: In these approaches, a breadth-first technique is used and the input as well as the state space is implicitly enumerated. The algorithms are best implemented using Binary Decision Diagrams (BDD) <ref> [5] </ref>. These methods work best for circuits that have certain regularity in the structure of the STG. However, for certain circuits, the BDDs are so large that they cannot be built and stored in the computer.
Reference: [6] <author> J.R. Burch, E.M. Clarke, K.L. McMillan and D.L. Dill, </author> <title> "Sequential circuit verification using symbolic model checking," </title> <booktitle> Proc. 27th ACM/IEEE Design Automation Conference, </booktitle> <pages> pages 46-51, </pages> <month> June </month> <year> 1990. </year>
Reference-contexts: We extend the idea to handle the verification of decomposed machines. Recently, efficient symbolic STG traversal algorithms have been developed that can be used to traverse the STG of a machine and verify whether a certain property is true for all the valid states of the machine <ref> [6] </ref> [7]. In these approaches, a breadth-first technique is used and the input as well as the state space is implicitly enumerated. The algorithms are best implemented using Binary Decision Diagrams (BDD) [5]. These methods work best for circuits that have certain regularity in the structure of the STG.
Reference: [7] <author> O. Coudert, C. Berthet and J.C. Madre, </author> <title> "Verification of sequential machines using symbolic execution," Proc. of the Workshop on Automatic Verification Methods for Finite State Machines, </title> <booktitle> 1989, </booktitle> <address> Grenoble, France. </address>
Reference-contexts: The problem of verification of single FSMs has been under investigation for a long time. Some of these algorithms are based on the product of the two machines to be verified [12]. Some others are based on graph traversal, enumeration-simulation [10] and symbolic STG traversal <ref> [7] </ref>. Most previous work on FSM verification deal with equivalence checking and few of these techniques have been widely used in practice due to their low efficiency. The enumeration-simulation approach was first presented in [10]. <p> We extend the idea to handle the verification of decomposed machines. Recently, efficient symbolic STG traversal algorithms have been developed that can be used to traverse the STG of a machine and verify whether a certain property is true for all the valid states of the machine [6] <ref> [7] </ref>. In these approaches, a breadth-first technique is used and the input as well as the state space is implicitly enumerated. The algorithms are best implemented using Binary Decision Diagrams (BDD) [5]. These methods work best for circuits that have certain regularity in the structure of the STG.
Reference: [8] <author> S. Devadas, </author> <title> "Optimizing Interacting Finite State Machines Using Sequential Don't Cares," </title> <journal> IEEE Trans. Computer-Aided Design, </journal> <pages> pages 1473-1484, </pages> <month> December </month> <year> 1991. </year>
Reference: [9] <author> S. Devadas, </author> <title> A.R. Newton, "Decomposition and factorization of sequential finite state machines," </title> <journal> IEEE Trans. Computer-Aided Design, </journal> <volume> vol. 8, </volume> <pages> pp 1206-1217, </pages> <month> Nov. </month> <year> 1989. </year> <month> 28 </month>
Reference-contexts: Multiway partitioning has been used here to optimally determine both the outputs and the internal states of the submachines. Several algorithms have been proposed to decompose an FSM into two interacting sub-machines [16], <ref> [9] </ref>, [3], [13], but no significant results have been achieved in the field of multi-machine decomposition. Here we present an algorithm to decompose an FSM into an arbitrary number of submachines. The primary goal of this method is the improvement of performance and/or the area of the final implementation. <p> Previous approaches to FSM decomposition have used the number of states and the number of edges in the resulting submachines as their cost function (e.g. [16], <ref> [9] </ref>). Given that the logic implementation of an FSM is derived from its state transition graph (STG) specification, followed by state assignment and intensive logic optimization, this cost function does not reflect the true complexity of the eventual logic-level implementation and is often far from accurate. <p> However the transmission of state information is serial. A submachine requires state information of its own states and about the states of its predecessors. It feeds its own state information to its successor machines only. Another form of decomposition was presented by Devadas and Newton in <ref> [9] </ref>. Here both components of the decomposed machine interact with each other. This form of decomposition involves identifying subroutines or factors in the original machine, extracting these factors and representing them as a separate factoring machine.
Reference: [10] <author> S. Devadas, H-K. T. Ma, and A.R. </author> <title> Newton, "On the verification of sequential machines at differing levels of abstraction," </title> <journal> IEEE Trans. Computer-Aided Design, </journal> <pages> pages 713-722, </pages> <month> June </month> <year> 1988. </year>
Reference-contexts: The method is general enough to be used at different stages of the design process. The need for an algorithm to verify two circuits at differing levels of abstraction was shown in [20], <ref> [10] </ref>. Our verification/simulation algorithm has been implemented in a system called V erSim. It can be used for formal design verification after decomposition of the prototype machine, or for simulating the design. Implementation verification can be done after encoding the submachines. <p> The problem of verification of single FSMs has been under investigation for a long time. Some of these algorithms are based on the product of the two machines to be verified [12]. Some others are based on graph traversal, enumeration-simulation <ref> [10] </ref> and symbolic STG traversal [7]. Most previous work on FSM verification deal with equivalence checking and few of these techniques have been widely used in practice due to their low efficiency. The enumeration-simulation approach was first presented in [10]. <p> Some others are based on graph traversal, enumeration-simulation <ref> [10] </ref> and symbolic STG traversal [7]. Most previous work on FSM verification deal with equivalence checking and few of these techniques have been widely used in practice due to their low efficiency. The enumeration-simulation approach was first presented in [10]. In this approach all state transitions of one machine are enumerated and simultaneously simulated on the other machine. During enumeration every path in the STG and all valid states have to be visited. <p> This is in contrast to some other enumeration-simulation approaches where every path (rather than edge) of the STG has to be traversed <ref> [10] </ref>. Thus we can see that the complexity of our algorithm is in fi (E + N ), the complexity of depth-first search. Here, E is the number of transition edges and N the number of nodes in the STG. For comparison, the complexity of the approach in [10] is in <p> be traversed <ref> [10] </ref>. Thus we can see that the complexity of our algorithm is in fi (E + N ), the complexity of depth-first search. Here, E is the number of transition edges and N the number of nodes in the STG. For comparison, the complexity of the approach in [10] is in (E + N ) Our approach is more efficient because we verify the output and the next state of each transition of the machine under test, while the approach in [10] verifies only the outputs in each path of the machine. <p> For comparison, the complexity of the approach in <ref> [10] </ref> is in (E + N ) Our approach is more efficient because we verify the output and the next state of each transition of the machine under test, while the approach in [10] verifies only the outputs in each path of the machine. The verification of the next state at each transition removes the need for traversing every path in the STG. It becomes sufficient to traverse every edge of the STG only once to verify the entire machine.
Reference: [11] <author> A. Ghosh, S. Devadas, and A.R. </author> <title> Newton, Sequential Logic Testing and Verification, </title> <publisher> Kluwer Academic Publishers, </publisher> <year> 1992. </year>
Reference-contexts: Implementation verification is the process of determining whether the designed circuit meets the original specification. Logic verification is the process of verifying the equivalence of two logic-level circuits, usually the optimized and the unoptimized one <ref> [11] </ref>. Reliable verification tools are necessary to ensure the correctness of the final design. Given a specification of a sequential machine and its decomposed version the goal of the functional verification is to verify the correctness of the design with respect to the original specification.
Reference: [12] <author> G.D. Hachtel and R.M. </author> <title> Jacoby, "Verification Algorithms for VLSI Synthesis," </title> <journal> IEEE Trans. Computer-Aided Design, </journal> <pages> pages 616-640, </pages> <month> May </month> <year> 1988. </year>
Reference-contexts: Further, none of 6 the published work aim at minimizing the delay of the decomposed machine. The problem of verification of single FSMs has been under investigation for a long time. Some of these algorithms are based on the product of the two machines to be verified <ref> [12] </ref>. Some others are based on graph traversal, enumeration-simulation [10] and symbolic STG traversal [7]. Most previous work on FSM verification deal with equivalence checking and few of these techniques have been widely used in practice due to their low efficiency. The enumeration-simulation approach was first presented in [10].
Reference: [13] <author> Z. Hasan and M.J. Ciesielski, </author> <title> "FSM decomposition for performance optimization," </title> <type> Technical Report TR-91-CSE-14, </type> <institution> Department of Electrical & Computer Engineering, University of Massachusetts, Amherst. </institution>
Reference-contexts: Multiway partitioning has been used here to optimally determine both the outputs and the internal states of the submachines. Several algorithms have been proposed to decompose an FSM into two interacting sub-machines [16], [9], [3], <ref> [13] </ref>, but no significant results have been achieved in the field of multi-machine decomposition. Here we present an algorithm to decompose an FSM into an arbitrary number of submachines. The primary goal of this method is the improvement of performance and/or the area of the final implementation. <p> In the table, S represents the number of states, O the number of outputs and P the number of product terms. Techniques described in [21] were used to carry out the encoding of states in the communicating machines. Delay and area were calculated as described in <ref> [13] </ref>. The results for multilevel implementation are shown in Table 2. The multilevel implementation was done using MISII and the results shown are as reported by the program. The results from both table indicate that the delay of the decomposed machine is always reduced. <p> Area Delay bbara 97 30.30 106 14.00 cse 249 69.10 349 31.00 planet 849 140.40 978 24.10 pma 385 62.30 400 34.30 indust1 606 74.00 783 25.80 indust2 137 35.20 193 17.50 indust3 1070 101.00 1325 36.10 compared with previously reported data on the two-way decomposition schemes of [3] and <ref> [13] </ref>. Comparing the results reported here with those in [13] our program gives lower delay in all, and lower area in the majority of the examples tried. The method of [3] gives slightly better areas for two-way decomposition. However, delay estimates were not available for comparison. <p> 69.10 349 31.00 planet 849 140.40 978 24.10 pma 385 62.30 400 34.30 indust1 606 74.00 783 25.80 indust2 137 35.20 193 17.50 indust3 1070 101.00 1325 36.10 compared with previously reported data on the two-way decomposition schemes of [3] and <ref> [13] </ref>. Comparing the results reported here with those in [13] our program gives lower delay in all, and lower area in the majority of the examples tried. The method of [3] gives slightly better areas for two-way decomposition. However, delay estimates were not available for comparison. <p> The decomposed machine may have several states which are unused. This can be observed in most examples shown earlier in the decomposition section and among the examples of <ref> [13] </ref>. This makes the verification of a decomposed machine a very difficult task. Usual verification techniques may waste a large amount of time checking the larger state space.
Reference: [14] <author> Z. Hasan, D. Harrison and M.J. Ciesielski, </author> <title> "A fast partitioning method for PLA-based FPGAs", </title> <booktitle> IEEE Design & Test of Computers, </booktitle> <month> December </month> <year> 1992, </year> <pages> pp 34-39. </pages>
Reference-contexts: The logic in FPGA and PLD technologies is realized by means of interacting logic blocks, with restrictions on the number of I/O lines per block and sometimes on the number of product terms per block <ref> [14] </ref>. In many cases, it is desirable for reasons of clock-skew minimization or simplifying the layout to distribute the control logic for a data path in such a manner that the portions of the data path and control that interact closely are placed next to each other.
Reference: [15] <author> S. H. Hwang and A. R. </author> <title> Newton, "An efficient verifier for finite state machines," </title> <journal> IEEE Trans. Computer-Aided Design, </journal> <pages> pages 326-334, </pages> <month> March </month> <year> 1991. </year>
Reference-contexts: A depth-first enumeration approach is used whereby only one path in the STG has to be stored at any point of time, making the approach memory efficient. Our method is based on a modification of this approach to make it more efficient. A similar approach was presented in <ref> [15] </ref>. However, the system described in [15] does the verification of a single machine after it is encoded. We extend the idea to handle the verification of decomposed machines. <p> Our method is based on a modification of this approach to make it more efficient. A similar approach was presented in <ref> [15] </ref>. However, the system described in [15] does the verification of a single machine after it is encoded. We extend the idea to handle the verification of decomposed machines.
Reference: [16] <author> J. Hartmanis and R.E. Stearns, </author> <title> Algebraic Structure Theory of Sequential Machines. </title> <address> Englewood Cliffs, NJ. </address> <publisher> Prentice-Hall, </publisher> <year> 1966. </year>
Reference-contexts: Multiway partitioning has been used here to optimally determine both the outputs and the internal states of the submachines. Several algorithms have been proposed to decompose an FSM into two interacting sub-machines <ref> [16] </ref>, [9], [3], [13], but no significant results have been achieved in the field of multi-machine decomposition. Here we present an algorithm to decompose an FSM into an arbitrary number of submachines. The primary goal of this method is the improvement of performance and/or the area of the final implementation. <p> Previous approaches to FSM decomposition have used the number of states and the number of edges in the resulting submachines as their cost function (e.g. <ref> [16] </ref>, [9]). Given that the logic implementation of an FSM is derived from its state transition graph (STG) specification, followed by state assignment and intensive logic optimization, this cost function does not reflect the true complexity of the eventual logic-level implementation and is often far from accurate. <p> Two states are said to be output-equivalent or single-cycle equivalent if they are 1-equivalent [18]. 5 3 Previous Work The decomposition of sequential machines was first treated in a formal way by Hartmanis and Stearns in <ref> [16] </ref>. They proposed two types of decomposition, parallel and cascade, based on the topology of the decomposed machine. One of the simplest ways in which a machine can be broken up into submachines is the parallel decomposition.
Reference: [17] <author> B. W. Kernighan and S. Lin, </author> <title> "An Efficient Heuristic Procedure for Partitioning Graphs", </title> <journal> Bell System Technical Journal, </journal> <volume> Vol. 49, </volume> <month> Feb. </month> <year> 1970, </year> <pages> pp 291-307. </pages>
Reference-contexts: This is to keep the number of internal states small since that too affects the performance and area. The algorithm for multiway graph partitioning uses ideas from the Kernighan and Lin min-cut algorithm <ref> [17] </ref> for two-way graph partitioning. The graph partitioning algorithm is used to determine the internal states of a submachine. The goal is to create a set of partitions, whose product is equal to 0 .
Reference: [18] <author> Z. Kohavi, </author> <title> Switching and Finite Automata Theory, </title> <publisher> McGraw-Hill, </publisher> <year> 1978. </year>
Reference-contexts: M is said to be a closed partition if and only if for any two states s and t which are in the same block of , and for any input i 2 I, the next states ffi (s; i) and ffi (t; i) are in a common block of <ref> [18] </ref>. A partition is a general partition if it is not closed. We refer to the original machine as the prototype machine, and to the individual machines that make up the overall realization as submachines. <p> Therefore each machine is assumed to have a reset state. The problem of verification of sequential machines is thereby reduced to the problem of determining the equivalence of the reset states of the two machines <ref> [18] </ref>. What this implies is the verification of all possible transitions of the machine starting from the reset state which effectively verifies the equivalence of the two machines. <p> If a finite differentiating sequence does not exist for a state pair, the states in the pair are said to be equivalent. Two states are said to be output-equivalent or single-cycle equivalent if they are 1-equivalent <ref> [18] </ref>. 5 3 Previous Work The decomposition of sequential machines was first treated in a formal way by Hartmanis and Stearns in [16]. They proposed two types of decomposition, parallel and cascade, based on the topology of the decomposed machine.
Reference: [19] <author> G. Saucier, </author> <title> "State minimization of asynchronous sequential machines using graph techniques," </title> <journal> IEEE Trans. Computing, </journal> <volume> vol. C-21, </volume> <pages> pp 282-288, </pages> <month> March </month> <year> 1972. </year>
Reference-contexts: These rules were employed in the past to create a code adjacency graph and used to find the state assignment which minimizes the logic complexity of the machine [1], <ref> [19] </ref>. To obtain the state assignment the adjacency graph was embedded on a minimum-dimension boolean cube so as to minimize the weighted distance on the cube. Example 3: Consider the partial truth table shown in Figure 3.
Reference: [20] <author> K.J. Supowit, and S.J. Friedman, </author> <title> "A new method for verifying sequential circuits," </title> <booktitle> Proc. 23rd Design Automation Conference, </booktitle> <pages> pages 200-207, </pages> <month> June </month> <year> 1986. </year>
Reference-contexts: The method is general enough to be used at different stages of the design process. The need for an algorithm to verify two circuits at differing levels of abstraction was shown in <ref> [20] </ref>, [10]. Our verification/simulation algorithm has been implemented in a system called V erSim. It can be used for formal design verification after decomposition of the prototype machine, or for simulating the design. Implementation verification can be done after encoding the submachines. <p> Thus this method is not very useful for our framework. There exist some other algorithms that can verify single FSMs but require huge amount of memory for storage and can be used only for small machines, [4] <ref> [20] </ref>. Most of the above mentioned algorithms verify two implementations of a single FSM at the logic level. They do not address the problem of verifying a network of FSMs at the symbolic level.
Reference: [21] <author> J.J. Shen, Z. Hasan and M.J. </author> <title> Ciesielski,"State Assignment for General Finite State Machine Networks", </title> <booktitle> Proc. of EDAC '92, </booktitle> <address> Brussels, Belgium, </address> <month> March </month> <year> 1992, </year> <pages> pp 245-249. </pages>
Reference-contexts: The current version of the program puts greater emphasis on improving performance than on area. The results for 2-level implementation are shown in Table 1. In the table, S represents the number of states, O the number of outputs and P the number of product terms. Techniques described in <ref> [21] </ref> were used to carry out the encoding of states in the communicating machines. Delay and area were calculated as described in [13]. The results for multilevel implementation are shown in Table 2. The multilevel implementation was done using MISII and the results shown are as reported by the program.
Reference: [22] <author> M. Yajnik and M.J. Ciesielski, </author> <title> "Finite state machine decomposition using multiway partitioning," </title> <booktitle> Proc. Int'l Conference on Computer Design, </booktitle> <year> 1992. </year>
Reference: [23] <author> C.Yeh and C. Cheng, </author> <title> "A General Purpose Multiple Way Partitioning Algorithm", </title> <booktitle> 28th ACM/IEEE Design Automation Conference Proceedings, </booktitle> <year> 1991. </year> <month> 29 </month>
References-found: 23

