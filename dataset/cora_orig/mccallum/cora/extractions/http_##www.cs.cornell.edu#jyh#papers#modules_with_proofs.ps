URL: http://www.cs.cornell.edu/jyh/papers/modules_with_proofs.ps
Refering-URL: http://www.cs.cornell.edu/jyh/cornell-papers.html
Root-URL: 
Title: Modules With Proofs  
Author: Jason J. Hickey 
Affiliation: Department of Computer Science Cornell University  
Abstract: The ML module system provides proven mechanisms for organizing and maintaining large programs through the use of structures, to implement program units, and signatures, that give an abstract specification of structures. A signature is a partial specification: it simply lists the components of the structure together with their types. For domains with security or timing requirements, it is important to give stronger guarantees about program behavior. We address this issue by augmenting program signatures with formal specifications, and structures with proofs. Security specifications are given in terms of a type theoretic interpretation of the program implementation. The type theory required to support this extension is the translucent sum calculus of Harper and Lillibridge extended with equality and constraint types. The Curry-Howard isomorphism provides a correspondence between executable programs and their proofs, allowing control over the degree of security desired. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Stuart F. Allen. </author> <title> A non-type-theoretic definition of martin-lof's types. </title> <booktitle> In Proceedings of the Second Conference on Logic in Computer Science, </booktitle> <pages> pages 215-224, </pages> <month> June </month> <year> 1987. </year>
Reference: [2] <author> Robert L. Constable. </author> <title> Expressing computational complexity in constructive type theory. </title> <booktitle> In LNCS/LNAI Proceedings, </booktitle> <pages> pages 131-144. </pages> <publisher> Springer, </publisher> <year> 1994. </year>
Reference-contexts: By separating the languages, we provide an expressive meta language embedded in a type theory that can state properties of security, optimization, and even computational complexity <ref> [2] </ref>. The connection between these languages is expressed through a type theoretic semantics based on the translucent sum calculus of Harper and Lillib-ridge [7] (hereafter called F fl ), given a constructive interpretation, and extended with equality types and total types.
Reference: [3] <author> Karl Crary. </author> <title> Foundations for the implementation of higher-order subtyping. </title> <booktitle> In ACM SIG-PLAN International Conference on Functional Programming, </booktitle> <pages> pages 125-135, </pages> <address> Amster-dam, </address> <year> 1997. </year>
Reference-contexts: The results we have shown apply to any module system that uses the Harper-Lillibridge module calculus, such as the SML module system, or the KML <ref> [3] </ref> language, which provides higher-order modules with subtyping and first class polymor-phism. Our implementation, called Nuprl-Light, is based on the Objective Caml programming language [25] from INRIA. The module system extension is implemented as a front end to the OCaml compiler using the Camlp4 preprocessor [18].
Reference: [4] <author> Karl Crary. </author> <title> Recursive computation in foundational type theory. </title> <type> Technical report, </type> <institution> Department of Computer Science, Cornell University, Forthcoming. </institution>
Reference-contexts: To address this problem, we introduce total types; programs have partial types, and propositions use total types to make statements about partial programs. The complete treatment of partial types is based on the work of Crary <ref> [4] </ref>, which simplifies the results of Smith [26; 27]. This treatment of partial type provides an induction principle expressed with the following rule for a fixpoint combinator fix (x: A): ` x: A ! A F-FIX The relation between partial and total types is expressed with rules for halting.
Reference: [5] <author> N. G. de Bruijn. </author> <title> Telescopic mappings in typed lambda calculus. </title> <journal> Information and Computation, </journal> <volume> 91(2) </volume> <pages> 189-204, </pages> <month> April </month> <year> 1991. </year>
Reference-contexts: Another influential logical framework is the Edinburgh Logical Framework (LF), which can be found in Harper [6]. Harper and Pfenning [8] have proposed a module system for the Elf programming language. Module systems with formal specifications have a long history. For instance, in automath, DeBruijn's telescopes <ref> [5] </ref> provide first class contexts. The closest relation to the system we present is the Extended ML systems implemented by Sannella et.al. [14; 15]. While both systems add specifications to modules, the approach is quite different.
Reference: [6] <author> Rober Harper, Furio Honsell, and Gordon Plotkin. </author> <title> A framework for defining logics. </title> <journal> Journal of the ACM, </journal> <volume> 40(1), </volume> <month> January </month> <year> 1993. </year>
Reference-contexts: While both systems provide a generic framework for constructing type theories, logics, and deductions systems, the Nuprl-Light systems places more emphasis on integrating the theorem prover with the module system. Another influential logical framework is the Edinburgh Logical Framework (LF), which can be found in Harper <ref> [6] </ref>. Harper and Pfenning [8] have proposed a module system for the Elf programming language. Module systems with formal specifications have a long history. For instance, in automath, DeBruijn's telescopes [5] provide first class contexts.
Reference: [7] <author> Robert Harper and Mark Lillibridge. </author> <title> A type-theoretic approach to higher-order modules with sharing. </title> <booktitle> In 21st Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 123-137. </pages> <publisher> ACM, </publisher> <month> January </month> <year> 1994. </year>
Reference-contexts: By separating the languages, we provide an expressive meta language embedded in a type theory that can state properties of security, optimization, and even computational complexity [2]. The connection between these languages is expressed through a type theoretic semantics based on the translucent sum calculus of Harper and Lillib-ridge <ref> [7] </ref> (hereafter called F fl ), given a constructive interpretation, and extended with equality types and total types. We use the Curry-Howard isomorphism to allow formal specifications to be interleaved with their standard counterparts. The main contribution of this paper is this formal extension to the ML module system. <p> We are currently using this type of optimization for the Ensemble [9; 16] group communications system. 5. RELATED WORK As we have mentioned before, we are extending the calculus of Harper and Lillib-ridge <ref> [7] </ref>. The module theorem prover is also related to the class of logical frameworks, and bears some resemblance to the Isabelle generic theorem prover [24; 22].
Reference: [8] <author> Robert Harper and Frank Pfenning. </author> <title> A module system for a programming language based on the LF logical framework. </title> <journal> Journal of Logic and Computation, </journal> <note> To appear. A preliminary version is available as Technical Report CMU-CS-92-191. </note>
Reference-contexts: Another influential logical framework is the Edinburgh Logical Framework (LF), which can be found in Harper [6]. Harper and Pfenning <ref> [8] </ref> have proposed a module system for the Elf programming language. Module systems with formal specifications have a long history. For instance, in automath, DeBruijn's telescopes [5] provide first class contexts. The closest relation to the system we present is the Extended ML systems implemented by Sannella et.al. [14; 15].
Reference: [9] <author> Mark Hayden. </author> <title> Ensemble tutorial. </title> <note> Available at the Ensemble home page through www.cs.cornell.edu, 1997. </note>
Reference-contexts: Currently, our implementation is not complete. Although the formal reasoning part of the module system is implemented, the OCaml semantics is based on an interpretation of OCaml with limited effects by Kreitz [16], which is being used to verify the Ensemble <ref> [9] </ref> group membership system. While we do not plan to implement a complete semantics of OCaml, the present semantics can be usefully expanded. <p> With the additional constraint specification, it can be shown that both implementations are purely functional, and the implementations can be interchanged. We are currently using this type of optimization for the Ensemble <ref> [9; 16] </ref> group communications system. 5. RELATED WORK As we have mentioned before, we are extending the calculus of Harper and Lillib-ridge [7]. The module theorem prover is also related to the class of logical frameworks, and bears some resemblance to the Isabelle generic theorem prover [24; 22].
Reference: [10] <author> Jason J. Hickey. </author> <title> Formal objects in type theory using very dependent types. </title> <booktitle> In Foundations of Object Oriented Languages 3, </booktitle> <year> 1996. </year> <note> Available electronically through the FOOL 3 home page at Williams College. </note>
Reference-contexts: The extension we propose to ML modules also apply to objects and classes. Hofmann et.al. [13] have implemented a system in LEGO [17] for adding proofs to classes. An interpretation of objects with proofs in the Nuprl type theory is presented in Hickey <ref> [10; 12] </ref>. 6. CONCLUSION The main contribution of this paper is an extension of the F fl calculus to provide ML modules containing formal specifications and proofs. The Curry-Howard iso-morphism serves to relate proofs with programs, providing complete control over the level of formality desired by the programmer.
Reference: [11] <author> Jason J. Hickey. Nuprl-Light: </author> <title> An implementation framework for higher-order logics. </title> <booktitle> In 14th International Conference on Automated Deduction. </booktitle> <publisher> Springer, </publisher> <year> 1997. </year>
Reference-contexts: One of the intents of our system is to enhance the module system to the extent that it can be used to implement type theories. An initial summary of the logical framework is described in Hickey <ref> [11] </ref>. The semantics we use for the calculus is actually based on the Nuprl type theory. The Nuprl type theory is an expressive, predicative type theory with untyped terms. <p> Rather than giving a complete simplification for translucent sums, we restrict the algorithm 3 As described in Hickey <ref> [11] </ref>, the axiom mechanism is also used to define inference rules. In our implementation the module system is used both to define the type theory and the semantics of the programming language.
Reference: [12] <author> Jason J. Hickey. </author> <title> A semantics of objects in type theory. </title> <note> Available through the Cornell home page www.cs.cornell.edu, 1997. </note>
Reference-contexts: The extension we propose to ML modules also apply to objects and classes. Hofmann et.al. [13] have implemented a system in LEGO [17] for adding proofs to classes. An interpretation of objects with proofs in the Nuprl type theory is presented in Hickey <ref> [10; 12] </ref>. 6. CONCLUSION The main contribution of this paper is an extension of the F fl calculus to provide ML modules containing formal specifications and proofs. The Curry-Howard iso-morphism serves to relate proofs with programs, providing complete control over the level of formality desired by the programmer.
Reference: [13] <author> M. Hofmann, W. Naraschewski, M. Steffen, and T. Stroup. </author> <title> Inheritance of proofs. In TAPOS. </title> <publisher> Wiley, forthcoming. </publisher>
Reference-contexts: There is a tradeoff: the Nuprl-Light programmer can express specifications in a powerful type theory, at the expense of having to learn the type theory. The extension we propose to ML modules also apply to objects and classes. Hofmann et.al. <ref> [13] </ref> have implemented a system in LEGO [17] for adding proofs to classes. An interpretation of objects with proofs in the Nuprl type theory is presented in Hickey [10; 12]. 6.
Reference: [14] <author> S. Kahrs, D. Sannella, and A. Tarlecki. </author> <title> The definition of Extended ML. </title> <type> Technical Report ECS-LFCS-94-300, </type> <institution> Laboratory for Foundations of Computer Science, University of Ed-inburgh, </institution> <year> 1994. </year>
Reference-contexts: The extension is conservative, allowing security proofs to be added incrementally: as a program is developed, as security and efficiency requirements increase, and as the programmer develops proficiency. To some degree, our purposes align with those of Extended ML <ref> [14; 15] </ref>. However, unlike Extended ML, we divide the language into two parts: a meta language for formal specifications, and the ML object language to express executable programs. <p> Module systems with formal specifications have a long history. For instance, in automath, DeBruijn's telescopes [5] provide first class contexts. The closest relation to the system we present is the Extended ML systems implemented by Sannella et.al. <ref> [14; 15] </ref>. While both systems add specifications to modules, the approach is quite different. The Extended ML system is intended to preserve the feel of Standard ML, and the specification language is closely modeled on the Standard ML language.
Reference: [15] <author> S. Kahrs, D. Sannella, and A. Tarlecki. </author> <title> The definition of Extended ML: a gentle introduction. </title> <journal> Theoretical Computer Science, </journal> <volume> 173 </volume> <pages> 445-484, </pages> <year> 1997. </year>
Reference-contexts: The extension is conservative, allowing security proofs to be added incrementally: as a program is developed, as security and efficiency requirements increase, and as the programmer develops proficiency. To some degree, our purposes align with those of Extended ML <ref> [14; 15] </ref>. However, unlike Extended ML, we divide the language into two parts: a meta language for formal specifications, and the ML object language to express executable programs. <p> Module systems with formal specifications have a long history. For instance, in automath, DeBruijn's telescopes [5] provide first class contexts. The closest relation to the system we present is the Extended ML systems implemented by Sannella et.al. <ref> [14; 15] </ref>. While both systems add specifications to modules, the approach is quite different. The Extended ML system is intended to preserve the feel of Standard ML, and the specification language is closely modeled on the Standard ML language.
Reference: [16] <author> Christoph Kreitz. </author> <title> Formal reasoning about communication systems i: Embedding ML into type theory. </title> <type> Technical report, </type> <institution> Department of Computer Science, Cornell University, Forthcoming. </institution>
Reference-contexts: In practice, this introduces few problems, although it does prevent self-application. Currently, our implementation is not complete. Although the formal reasoning part of the module system is implemented, the OCaml semantics is based on an interpretation of OCaml with limited effects by Kreitz <ref> [16] </ref>, which is being used to verify the Ensemble [9] group membership system. While we do not plan to implement a complete semantics of OCaml, the present semantics can be usefully expanded. <p> With the additional constraint specification, it can be shown that both implementations are purely functional, and the implementations can be interchanged. We are currently using this type of optimization for the Ensemble <ref> [9; 16] </ref> group communications system. 5. RELATED WORK As we have mentioned before, we are extending the calculus of Harper and Lillib-ridge [7]. The module theorem prover is also related to the class of logical frameworks, and bears some resemblance to the Isabelle generic theorem prover [24; 22].
Reference: [17] <author> Zhaohui Luo and Randy Pollack. </author> <title> LEGO Proof Development System: User's Manual. </title> <type> Technical Report ECS-LFCS-92-202, </type> <institution> University of Edinburgh, </institution> <year> 1992. </year>
Reference-contexts: There is a tradeoff: the Nuprl-Light programmer can express specifications in a powerful type theory, at the expense of having to learn the type theory. The extension we propose to ML modules also apply to objects and classes. Hofmann et.al. [13] have implemented a system in LEGO <ref> [17] </ref> for adding proofs to classes. An interpretation of objects with proofs in the Nuprl type theory is presented in Hickey [10; 12]. 6. CONCLUSION The main contribution of this paper is an extension of the F fl calculus to provide ML modules containing formal specifications and proofs.
Reference: [18] <author> Michael Mauny and Daniel de Ranglaudre. </author> <title> A complete and realistic implementation of quotations for ML. </title> <note> Camlp4 is available online ftp.inria.fr. </note>
Reference-contexts: Our implementation, called Nuprl-Light, is based on the Objective Caml programming language [25] from INRIA. The module system extension is implemented as a front end to the OCaml compiler using the Camlp4 preprocessor <ref> [18] </ref>. One of the intents of our system is to enhance the module system to the extent that it can be used to implement type theories. An initial summary of the logical framework is described in Hickey [11].
Reference: [19] <author> G. Morrisett, D. Walker, and K. Crary. </author> <title> From System-F to typed assembly language. </title> <year> 1997. </year>
Reference-contexts: To produce a proof at the target level, the proof must be transformed by the compiler. Although we do not address this issue here, a promising path is suggested by Morrisett et al. <ref> [19] </ref>, where type information is propagated by the compiler all the way to the assembly level. Another use of the theorem prover is for optimization at the source level, based on program equivalence.
Reference: [20] <author> George Necula and Peter Lee. </author> <title> Safe kernel extensions without run-time checking. </title> <booktitle> In Proceedings of Operating System Design and Implementation, </booktitle> <year> 1996. </year> <note> 14 Jason Hickey </note>
Reference-contexts: In general, modular systems exhibit a tension between program efficiency and program security, suggesting that one way to improve efficiency is by static security verification. An example of this is given by Necula and Lee <ref> [20; 21] </ref>, who suggest the use of Proof Carrying Code to deliver a proof of secure behavior along with the migrant program, reducing the cost of secure evaluation to the one-time cost of proof checking. Contact information: Jason J.
Reference: [21] <author> George C. Necula. </author> <title> Proof-carrying code. </title> <booktitle> In ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 106-119, </pages> <year> 1997. </year>
Reference-contexts: In general, modular systems exhibit a tension between program efficiency and program security, suggesting that one way to improve efficiency is by static security verification. An example of this is given by Necula and Lee <ref> [20; 21] </ref>, who suggest the use of Proof Carrying Code to deliver a proof of secure behavior along with the migrant program, reducing the cost of secure evaluation to the one-time cost of proof checking. Contact information: Jason J.
Reference: [22] <author> Tobias Nipkow and Lawrence C. Paulson. Isabelle-91. </author> <booktitle> In Proceedings of the 11th International Conference on Automated Deduction, </booktitle> <pages> pages 673-676, </pages> <year> 1992. </year>
Reference-contexts: RELATED WORK As we have mentioned before, we are extending the calculus of Harper and Lillib-ridge [7]. The module theorem prover is also related to the class of logical frameworks, and bears some resemblance to the Isabelle generic theorem prover <ref> [24; 22] </ref>. While both systems provide a generic framework for constructing type theories, logics, and deductions systems, the Nuprl-Light systems places more emphasis on integrating the theorem prover with the module system. Another influential logical framework is the Edinburgh Logical Framework (LF), which can be found in Harper [6].
Reference: [23] <author> Lawrence C. Paulson. </author> <title> Logic and Computation: Interactive proof with Cambridge LCF. </title> <publisher> Cam-bridge Univ. Press, </publisher> <year> 1987. </year>
Reference-contexts: In our experience using the Nuprl theorem prover, we have found the need to combine interactive proof with proof automation. The Nuprl-Light system is a tactic-oriented theorem prover, in the style of LCF <ref> [23] </ref>. A tactic is an ML program that implements a backward-chaining step of logical reasoning. Tactics are generated using the module mechanism with the axiom form.
Reference: [24] <author> Lawrence C. Paulson. </author> <title> Isabelle: A Generic Theorem Prover. </title> <publisher> Springer LNCS 828, </publisher> <year> 1994. </year>
Reference-contexts: RELATED WORK As we have mentioned before, we are extending the calculus of Harper and Lillib-ridge [7]. The module theorem prover is also related to the class of logical frameworks, and bears some resemblance to the Isabelle generic theorem prover <ref> [24; 22] </ref>. While both systems provide a generic framework for constructing type theories, logics, and deductions systems, the Nuprl-Light systems places more emphasis on integrating the theorem prover with the module system. Another influential logical framework is the Edinburgh Logical Framework (LF), which can be found in Harper [6].
Reference: [25] <author> Didier Remy and Jerome Vouillon. </author> <title> Objective ML: A simple object-oriented extension of ML. </title> <booktitle> In ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 40-53, </pages> <year> 1997. </year>
Reference-contexts: The results we have shown apply to any module system that uses the Harper-Lillibridge module calculus, such as the SML module system, or the KML [3] language, which provides higher-order modules with subtyping and first class polymor-phism. Our implementation, called Nuprl-Light, is based on the Objective Caml programming language <ref> [25] </ref> from INRIA. The module system extension is implemented as a front end to the OCaml compiler using the Camlp4 preprocessor [18]. One of the intents of our system is to enhance the module system to the extent that it can be used to implement type theories.
Reference: [26] <author> Scott F. Smith and Robert L. Constable. </author> <title> Partial objects in constructive type theory. </title> <booktitle> In Proceedings of Second Symposium on Logic in Computer Science, </booktitle> <pages> pages 183-193. </pages> <publisher> IEEE, </publisher> <year> 1987. </year>
Reference-contexts: To address this problem, we introduce total types; programs have partial types, and propositions use total types to make statements about partial programs. The complete treatment of partial types is based on the work of Crary [4], which simplifies the results of Smith <ref> [26; 27] </ref>. This treatment of partial type provides an induction principle expressed with the following rule for a fixpoint combinator fix (x: A): ` x: A ! A F-FIX The relation between partial and total types is expressed with rules for halting.
Reference: [27] <author> Scott Fraser Smith. </author> <title> Partial Objects in Type Theory. </title> <type> PhD thesis, </type> <institution> Department of Computer Science, Cornell University, </institution> <address> Ithaca, NY, </address> <year> 1989. </year>
Reference-contexts: To address this problem, we introduce total types; programs have partial types, and propositions use total types to make statements about partial programs. The complete treatment of partial types is based on the work of Crary [4], which simplifies the results of Smith <ref> [26; 27] </ref>. This treatment of partial type provides an induction principle expressed with the following rule for a fixpoint combinator fix (x: A): ` x: A ! A F-FIX The relation between partial and total types is expressed with rules for halting.

References-found: 27

