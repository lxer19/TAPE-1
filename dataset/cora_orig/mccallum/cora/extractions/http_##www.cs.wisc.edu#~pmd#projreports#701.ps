URL: http://www.cs.wisc.edu/~pmd/projreports/701.ps
Refering-URL: http://www.cs.wisc.edu/~pmd/pmd.html
Root-URL: 
Email: pmd@cs.wisc.edu  somani@cs.wisc.edu  
Title: A Study and Analysis of Function Inlining  
Author: Prasad Deshpande Amit Somani 
Abstract: Function inlining is a widely known technique which has been used to improve program performance. Inlining replaces a function call by the body of the function. In this report, we study the effects of inline function expansion by observing the empirical behavior of a set of C and C++ programs. Our results indicate that for the average C program improvements in timings due to inlining are not much (2-3%). However, C++ programs benefit much more (up to 46%) from inlining due to smaller average function size and a larger call stack depth.
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Chow F. C., </author> <title> Minimizing Register Usage Penalty at Procedure Calls, </title> <booktitle> Proceedings of SIGPLAN '88 Conference on Programming Language Design and Implementation, </booktitle> <month> June </month> <year> 1988. </year> <month> 15 </month>
Reference-contexts: There are software schemes too which attempt to address this problem. Most prominently, inter-procedural analysis has been used to reduce the overhead involved in function calls. In particular, <ref> [1] </ref> shows that inter-procedural register allocation can be used to reduce the register save/restore calls across function call boundaries. By combining profiling and inline expansion, link-time register allocation can lead to a similar performance as hardware register window schemes [9].
Reference: [2] <author> Cooper Keith D., Hall Mary W., and Torczon Linda, </author> <title> Unexpected Side Effects of Inline Substi--tution: A Case Study, </title> <journal> ACM Letters on Programming Languages and Systems, </journal> <month> March </month> <year> 1992, </year> <pages> pp. 23-32. </pages>
Reference-contexts: If the register allocator decides to spill a heavily used variable which was previously in a register, the number of load/stores would increase significantly. Depending on the nuances of a particular compiler, there might be other side-effects which affect the performance of the program <ref> [2] </ref>. In the rest of the report, we study the effects of programs inlining on program execution behavior and optimizer effectiveness. 2 Benchmark Programs We have measured 10 programs written in C and C++.
Reference: [3] <author> Davidson J. W. and Holler A. M., </author> <title> A Study of a C Function Inliner, </title> <journal> Software Practice Experience, </journal> <month> August </month> <year> 1988, </year> <pages> pp. 775-790. </pages>
Reference-contexts: Increase in code size could lead to more page faults and cache misses. But Davidson et al. argue that these do not have a significant effect on the execution times of the programs ([6], <ref> [3] </ref>). Static information about the programs studied is provided in Table 4. From the table we see that there is a moderate increase in the code size for inlined code. This is due to selective inlining of only the most frequently called functions.
Reference: [4] <author> Emer J. and Clark D., </author> <title> A Characterization of Processor Performance in the VAX-11/780, </title> <booktitle> Proceedings of the 11th Annual Symposium on Computer Architecture, </booktitle> <month> June </month> <year> 1984. </year>
Reference: [5] <author> Grunwald Dirk, </author> <title> et al Quantifying Behavioral Differences Between C and C++ Programs, </title> <journal> Journal of Programming Languages, </journal> <volume> Vol 2, Num 4, </volume> <year> 1994. </year>
Reference-contexts: From the tables it is clear that for most of the benchmark programs (except for 022.LI) there is no significant improvement in the execution times whereas the C++ programs do show some improvement due to inlining. This difference between difference C and C++ program behavior (see <ref> [5] </ref>) is due to the following reasons: * The average function size in C++ programs is lesser than that in C programs. As discussed previously, it would be preferable to inline smaller functions with fewer local variables. <p> So, inlining is recommended for functions which are small in size and have a few local variables. Register window architecture works well when the call stack depth is less than the number of windows. More depth would lead to register window traps which are costly. Grunwald et al <ref> [5] </ref> observe that C programs tend to have smaller call stack than C++ programs (median of 9.9 versus 12.1). Also as compared to C programs, C++ programs have order of magnitude more procedure calls. C++ procedures on the average tend to be smaller compared to C procedures.
Reference: [6] <author> Holler A. M., </author> <title> A Study of the Effects of Subprogram inlining, </title> <type> Ph.D. Thesis, </type> <month> March </month> <year> 1991 </year>
Reference-contexts: We discuss the number of loads and store instructions with respect to the register allocation in both the inlined and the non-inlined versions of the code. From previously published work <ref> [6] </ref>, it is currently believed that, except for some cases, the number of loads/stores in a program should actually decrease 3 The exact heuristics are listed in the file integrate.c of the gcc source. 6 Program Total Dynamic Instructions Total Calls Total Returns NonInlined Inlined NonInlined Inlined NonInlined Inlined 026.COMPRESS 77501763
Reference: [7] <author> Hwu W. W. and Chang P. P., </author> <title> Inline Function Expansion for Inlining C Programs, </title> <booktitle> In Proc. of the ACM SIGPLAN '89 Conference on Programming Language Design and Implementation, </booktitle> <month> July </month> <year> 1989, </year> <pages> pp. 246-257. </pages>
Reference: [8] <author> Richardson S. and Ganapathi M., </author> <title> Interprocedural Analysis versus Procedural Integration, </title> <journal> Information Processing Letters, </journal> <month> August </month> <year> 1989, </year> <pages> pp. 137-142. </pages>
Reference: [9] <author> Wall D. W., </author> <title> Register Windows vs. Register Allocation, </title> <booktitle> Proceedings of SIGPLAN '88 Conference on Programming Language Design and Implementation, </booktitle> <month> June </month> <year> 1988. </year> <month> 16 </month>
Reference-contexts: In particular, [1] shows that inter-procedural register allocation can be used to reduce the register save/restore calls across function call boundaries. By combining profiling and inline expansion, link-time register allocation can lead to a similar performance as hardware register window schemes <ref> [9] </ref>. However, most of the schemes used in software are complex in nature. Subroutine inlining (also referred to as inline function expansion or procedure integration) provides a simple method to attack this problem.
References-found: 9

