URL: ftp://ftp.research.microsoft.com/users/palarson/cascon95_bls.ps
Refering-URL: http://www.research.microsoft.com/~palarson/publications.htm
Root-URL: http://www.research.microsoft.com
Title: Transaction Scheduling in Dynamic Composite Multidatabase Systems multidatabase concurrency control algorithms guarantee global serializability during
Author: Dexter P. Bradshaw Per -Ake Larson Jacob Slonim 
Note: Some  This research is supported by IBM Canada Ltd. and by the Natural Sciences and Engineering Research Council (NSERC) of Canada. position through transaction ordering is proposed. This algorithm permits the mixing and  
Address: Waterloo, Waterloo, Ontario N2L 3G1  
Affiliation: Department of Computer Science University of  
Abstract: This paper proposes composite multidatabase architecture consisting of multiple, possibly heterogeneous, peer multidatabase servers distributed on a communications network. The domain of each multidatabase server is treated as a multidatabase cell. Global transactions could span multiple multidatabase cells, sometimes forcing multidatabase servers to act as component database systems. Although each multidatabase server guarantees serializable execution histories for transactions under its control, concurrent global transactions spanning multiple multidatabase systems may lead to non-serializable global histories. y Jacob Slonim is an adjunct Professor at the University of Waterloo. Jacob Slonim is the IBM contact for this paper at the Centre for Advanced Studies, IBM Toronto Labs, 844 Don Mills, North York, Ontario, M3C 1V7. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> R. Alonso, H. Garcia-Molina, and K. Salem. </author> <title> Concurrency Control and Recovery for Global Procedures in Federated Database Systems. </title> <booktitle> In Proceedings of the IEEE Conference on Data Engineering, </booktitle> <pages> pages 5-11. </pages> <publisher> IEEE Computer Society Press, </publisher> <month> September </month> <year> 1987. </year>
Reference-contexts: By serializing the submission of global transactions, the global commit history is also serialized. Most concur-rency control techniques serialize transactions through mutual exclusion. Exclusion prevents more than one transaction from executing at two or more sites, inherently preventing indirect conflicts through local transactions <ref> [1, 10, 26] </ref>. Multidatabase concurrency control techniques based on ticketing force global transactions to conflict directly at each component database site by forcing them to update a common ticket data item. Certification of consistent relative ticket orders at each component database site before atomic commitment guarantees serializ-ability [16]. <p> Both cases lead to serializable global histories. The CTO algorithm is one case of an algorithm based on submission orders and strong recoverability. Other variants of this class of algorithms based on site locking <ref> [1] </ref> and altruistic locking [26] work similarly. 5.3 Composite Forced Conflicts Algorithm The rigorous history condition and strong re-coverability condition in Theorem 1 and Theorem 2, respectively, have limited applicability because some component databases may not support these history properties.
Reference: [2] <author> G. Attaluri and D. P. Bradshaw. </author> <title> Architecture for Transaction Management in the CORDS Multidatabase System. </title> <editor> In A. Gawman, W. Morven Gentleman, E. Kidd, P. A. Larson, and J. Slonim, editors, </editor> <booktitle> Proceedings of CASCON'93, Volume II: Distributed Computing, </booktitle> <pages> pages 873-887, </pages> <month> October </month> <year> 1993. </year>
Reference-contexts: The agents and cell servers are all multi-threaded and communicate via OSF 8 DCE remote procedure calls (RPC). Details of the transaction management architecture are described in <ref> [2] </ref>. Currently, all three algorithms have been successfully implemented and integrated with the CFC and CTO algorithms to the MCC schedulers of a prototype multidatabase cell server [3]. Initial tests validate both the correctness and viability of the algorithms. These tests also validate the following performance issues. 1.
Reference: [3] <author> G. Attaluri, D. P. Bradshaw, N. Coburn, P. A. Larson, P. Martin, A. Silberschatz, J. Slonim, and Q. Zhu. </author> <title> CORDS Multidata-base Project. </title> <journal> IBM Systems Journal, </journal> <volume> 34(1), </volume> <month> January </month> <year> 1995. </year>
Reference-contexts: The minimality of the cascade-less property can be used as another approach to deriving and proving Corollary 1. 6 Implementation Issues Our investigation in transaction management for multidatabase composition falls under the CORDS Multidatabase project <ref> [3] </ref>. A mul-tidatabase prototype that provides transparent transactional access to DB2/6000 2 and Oracle 3 V7 component database systems has been built to run under the AIX 4 3.2.5 operating system on a set of RS/6000s. <p> Details of the transaction management architecture are described in [2]. Currently, all three algorithms have been successfully implemented and integrated with the CFC and CTO algorithms to the MCC schedulers of a prototype multidatabase cell server <ref> [3] </ref>. Initial tests validate both the correctness and viability of the algorithms. These tests also validate the following performance issues. 1. Dynamic Composition and Scalability : In our prototype, multidatabase composition is dynamic and depends on collective runtime access patterns of all global transactions.
Reference: [4] <author> C. Beeri, P. A. Bernstein, and N. Good-man. </author> <title> A Model for Concurrency Control in Nested Transaction Systems. </title> <journal> JACM, </journal> <volume> 36 </volume> <pages> 230-269, </pages> <year> 1989. </year>
Reference-contexts: Rigorousness combined with an atomic commit protocol guarantees serializ-ability [11, 16]. In Bradshaw [6], work on concurrency control in open nested transaction systems <ref> [4] </ref> was combined with the notion of multidatabase seri-alizability [20] to derive the concept of open nested multidatabase serializability (ONMSR). ONMSR is not a new serializability class. It generalizes two-level multidatabase serializabil-ity to asymmetric execution hierarchies of arbitrary depths.
Reference: [5] <author> P. A. Bernstein, V. Hadzilacos, and N. Goodman. </author> <title> Concurrency Control and Recovery in Database Systems. Addison-Wesley Series in Computer Science. </title> <type> Addison-Wesley, </type> <institution> United States of America, </institution> <year> 1987. </year>
Reference-contexts: All multidatabase cells guarantee multidata-base serializable histories [20]. Since mul-tidatabase serializability is a more restrictive form of two-level serializability [8], this subsumes locally serializable schedules at all component database systems. Global atomicity between a multidatabase server and its component sites is guaranteed with the two-phase commit (2PC) protocol <ref> [5, 17, 18] </ref>. Local deadlock is assumed to be resolved by deadlock resolution mechanisms at component database sites while global deadlock is heuristically detected through transaction timeouts. Other assumptions about the relationship between multidata-base servers and their component database systems depend on global concurrency control algorithm in use. <p> Proof The inheritance of timestamps by subtransac-tions from parent transactions coupled with the validations in the NEW, PREPARE and COMMIT steps of CTO guarantees that multicellular transactions are committed in timestamp order. The rest of this proof follows the contradiction argument of TO in <ref> [5] </ref>. If the global committed history H CM is not serializ-able, its serialization graph SG CM has a cycle. The histories at all component databases are strongly recoverable, therefore, the serialization order of the multicellular transactions corresponds to their commit order.
Reference: [6] <author> D. P. Bradshaw. </author> <title> Open Nested Serializabil-ity in Multidatabase Systems. </title> <editor> In M. Bauer, J. Botsford, P. A. Larson, and J. Slonim, editors, </editor> <booktitle> Proceedings of the 1992 CAS Conference, </booktitle> <pages> pages 93-109, </pages> <address> Toronto, Canada, </address> <month> November </month> <year> 1992. </year> <institution> IBM Toronto Labs, IBM Centre for Advanced Studies. </institution>
Reference-contexts: Rigorousness is a subclass of strong recoverabil-ity in which component databases guarantee that a transaction cannot execute a conflicting operation on data items until the transaction that last operated on them is either committed or aborted. Rigorousness combined with an atomic commit protocol guarantees serializ-ability [11, 16]. In Bradshaw <ref> [6] </ref>, work on concurrency control in open nested transaction systems [4] was combined with the notion of multidatabase seri-alizability [20] to derive the concept of open nested multidatabase serializability (ONMSR). ONMSR is not a new serializability class. It generalizes two-level multidatabase serializabil-ity to asymmetric execution hierarchies of arbitrary depths.
Reference: [7] <author> D. P. Bradshaw. </author> <title> Failure Isolation and Recovery in Composite Multidatabase Systems. </title> <editor> In J. Botsford, A. Gawman, M. Gentleman, E. Kidd, K. Lyons, and J. Slonim, editors, </editor> <booktitle> Proceedings of CASCON'94: Integrated Solutions, </booktitle> <month> October </month> <year> 1994. </year> <note> In CDROM Issue of the Proceedings. </note>
Reference-contexts: We expect abort frequencies to increase significantly as the locality of mul-ticellular transactions increases and their 9 Pu cited this as a major reason maintaining a static hierarchy of superdatabases. read/write ratios decrease. A smart recovery/resubmission algorithm can avert these effects <ref> [7] </ref>. However, the design of the recovery algorithm may be limited by the properties of the underlying multidatabase concurrency control mechanism and the ability to track value dependencies among multicellular transactions.
Reference: [8] <author> Y. Breitbart and H. Garcia-Molina. </author> <title> Overview of Multidatabase Transaction Management. </title> <type> Technical Report TR-92-21, </type> <institution> Department of Computer Services, University of Texas, Austin, Texas 78712, </institution> <month> May </month> <year> 1992. </year>
Reference-contexts: Usually, the correctness of multidatabase algorithms is based on the classical notion of seri-alizability. Several algorithms have been proposed in the literature to guarantee serializab-ility; these usually fall into one of three classes of mechanisms: submission ordering <ref> [8, 11, 23] </ref>, ticketing [16, 15], and rigorous scheduling [11, 16]. Strong recoverability (or commitment ordering) at component database systems guarantee that transactions are serialized in the same order in which they are executed. By serializing the submission of global transactions, the global commit history is also serialized. <p> The catalogue in a multidatabase server may import mappings to views and base tables managed by another mul-tidatabase server. All multidatabase cells guarantee multidata-base serializable histories [20]. Since mul-tidatabase serializability is a more restrictive form of two-level serializability <ref> [8] </ref>, this subsumes locally serializable schedules at all component database systems. Global atomicity between a multidatabase server and its component sites is guaranteed with the two-phase commit (2PC) protocol [5, 17, 18].
Reference: [9] <author> Y. Breitbart, D. Georgakopoulos, M. Ru--sinkiewicz, and A. Silberschatz. </author> <title> On Rigorous Transaction Scheduling. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 17(4) </volume> <pages> 954-960, </pages> <month> September </month> <year> 1991. </year>
Reference-contexts: This result is significant because the ticketing approach allows any set of serializable cells to be composed while still guaranteeing a globally serial-izable history. 5.1 Composite Rigorous Schedul ing Algorithm The algorithm described in this section shows that the rigorous multidatabase scheduling algorithm <ref> [9, 16, 24] </ref> scales to composite mul-tidatabase environments.
Reference: [10] <author> Y. Breitbart and A. Silberschatz. </author> <title> Mul-tidatabase Update Issues. </title> <booktitle> In Proceedings of the ACM SIGMOD Conference on the Management of Data, </booktitle> <pages> pages 135-142. </pages> <publisher> ACM, ACM Press, </publisher> <month> June </month> <year> 1988. </year>
Reference-contexts: By serializing the submission of global transactions, the global commit history is also serialized. Most concur-rency control techniques serialize transactions through mutual exclusion. Exclusion prevents more than one transaction from executing at two or more sites, inherently preventing indirect conflicts through local transactions <ref> [1, 10, 26] </ref>. Multidatabase concurrency control techniques based on ticketing force global transactions to conflict directly at each component database site by forcing them to update a common ticket data item. Certification of consistent relative ticket orders at each component database site before atomic commitment guarantees serializ-ability [16].
Reference: [11] <author> Y. Breitbart and A. Silberschatz. </author> <title> Strong Recoverability in Multidatabase Systems. </title> <editor> In P. S. Yu, editor, </editor> <booktitle> Second International Workshop on Research Issues on Data Engineering: Transaction and Query Processing, </booktitle> <pages> pages 170-175, </pages> <address> Los Alamitos, Ca, </address> <month> February </month> <year> 1992. </year> <booktitle> IEEE Computer Society Technical Committee on Data Engineering, </booktitle> <publisher> IEEE Computer Society Press. </publisher>
Reference-contexts: Usually, the correctness of multidatabase algorithms is based on the classical notion of seri-alizability. Several algorithms have been proposed in the literature to guarantee serializab-ility; these usually fall into one of three classes of mechanisms: submission ordering <ref> [8, 11, 23] </ref>, ticketing [16, 15], and rigorous scheduling [11, 16]. Strong recoverability (or commitment ordering) at component database systems guarantee that transactions are serialized in the same order in which they are executed. By serializing the submission of global transactions, the global commit history is also serialized. <p> Usually, the correctness of multidatabase algorithms is based on the classical notion of seri-alizability. Several algorithms have been proposed in the literature to guarantee serializab-ility; these usually fall into one of three classes of mechanisms: submission ordering [8, 11, 23], ticketing [16, 15], and rigorous scheduling <ref> [11, 16] </ref>. Strong recoverability (or commitment ordering) at component database systems guarantee that transactions are serialized in the same order in which they are executed. By serializing the submission of global transactions, the global commit history is also serialized. Most concur-rency control techniques serialize transactions through mutual exclusion. <p> Rigorousness is a subclass of strong recoverabil-ity in which component databases guarantee that a transaction cannot execute a conflicting operation on data items until the transaction that last operated on them is either committed or aborted. Rigorousness combined with an atomic commit protocol guarantees serializ-ability <ref> [11, 16] </ref>. In Bradshaw [6], work on concurrency control in open nested transaction systems [4] was combined with the notion of multidatabase seri-alizability [20] to derive the concept of open nested multidatabase serializability (ONMSR). ONMSR is not a new serializability class. <p> Rig--orous histories are a subclass of strongly recoverable histories. Therefore, they inherit the property that the serialization order of any two transactions is equivalent to their commitment order <ref> [11] </ref>. We use this property to guarantee consistent global transaction orders across mul-tidatabase cells. The following theorem is an application of the rigorous scheduling algorithm for simple mul-tidatabase systems to composite multidatabase environments.
Reference: [12] <author> N. Coburn and P. A. Larson. </author> <title> Multidata-base Services: Issues and Architectural Design. </title> <editor> In M. Bauer, J. Botsford, P. A. Larson, and J. Slonim, editors, </editor> <booktitle> Proceedings of the 1992 CAS Conference, </booktitle> <pages> pages 57-66, </pages> <address> Toronto, Canada, </address> <month> November </month> <year> 1992. </year> <institution> IBM Toronto Labs, IBM Centre for Advanced Studies. </institution>
Reference-contexts: Although DB2/6000 and Oracle V7 are used in particular, nothing restricts the use of other X/Open 5 XA compliant databases. For details on the CORDS Multidata-base architecture and prototypes, see <ref> [12, 14] </ref>. Multidatabase cells are accessed through multidatabase servers that export an ODBC 6 interface to applications and other multidata-base servers. Global distributed transaction processing functionality is provided by the Encina 7 transaction toolkit facility.
Reference: [13] <author> X/Open Company. </author> <title> CAE Specification. Distributed Transaction Processing: The XA Specification. </title> <publisher> X/Open Company Limited, </publisher> <address> United Kingdom, </address> <year> 1991. </year>
Reference-contexts: is a trademark of the Oracle Corporation. 4 AIX is a trademark of the IBM Corporation. 5 X/Open is a trademark of the X/OPEN company. 6 Open Database Connect from the Microsoft Corporation. 7 Encina is a trademark of Transarc Corporation. uted transaction management, 2PC through the X/Open XA standard <ref> [13] </ref>, distributed deployment of the system, and fault tolerance. The agents and cell servers are all multi-threaded and communicate via OSF 8 DCE remote procedure calls (RPC). Details of the transaction management architecture are described in [2].
Reference: [14] <author> D. L. Erickson, P. J. Finnigan, G. K. Attaluri, M. A. Bauer, D. P. Bradshaw, N. Coburn, M. P. Consens, M. Z. Hasan, J. W. Hong, K. A. Lyons, T. P. Martin, G. W. Neufeld, W. Powley, D. Rappaport, D. J. Taylor, T. J. Teorey, and Y. Yemini. CORDS: </author> <title> An Update to Prototypes. </title> <type> Technical Report TR-74.120, </type> <institution> Centre for Advanced Studies, IBM Toronto Labs, </institution> <month> August </month> <year> 1993. </year>
Reference-contexts: Although DB2/6000 and Oracle V7 are used in particular, nothing restricts the use of other X/Open 5 XA compliant databases. For details on the CORDS Multidata-base architecture and prototypes, see <ref> [12, 14] </ref>. Multidatabase cells are accessed through multidatabase servers that export an ODBC 6 interface to applications and other multidata-base servers. Global distributed transaction processing functionality is provided by the Encina 7 transaction toolkit facility.
Reference: [15] <author> D. Georgakopoulos, M. Rusinkiewicsz, and A. P. Sheth. </author> <title> Using Tickets to Enforce the Serializability of Multidatabase Transactions. </title> <journal> IEEE Transactions on Knowledge and Data Engineering, </journal> <volume> 6(1) </volume> <pages> 166-180, </pages> <month> Feb-ruary </month> <year> 1994. </year>
Reference-contexts: Usually, the correctness of multidatabase algorithms is based on the classical notion of seri-alizability. Several algorithms have been proposed in the literature to guarantee serializab-ility; these usually fall into one of three classes of mechanisms: submission ordering [8, 11, 23], ticketing <ref> [16, 15] </ref>, and rigorous scheduling [11, 16]. Strong recoverability (or commitment ordering) at component database systems guarantee that transactions are serialized in the same order in which they are executed. By serializing the submission of global transactions, the global commit history is also serialized. <p> Certification of consistent relative ticket orders at each component database site before atomic commitment guarantees serializ-ability [16]. Unfortunately, ticketing creates artificial hot spots in ticket tables and ticket certification requires the maintenance of a centralized global serialization graph. Conservative and cascadeless ticketing schemes, introduced by Georgakopoulos et. al. in <ref> [15] </ref> eliminate the latter while the former is solved through implicit ticketing or rigorous scheduling.
Reference: [16] <author> D. Georgakopoulos, M. Rusinkiewicz, and A. Sheth. </author> <title> On Serializability of Multidata-base Transactions Through Forced Local Conflicts. </title> <booktitle> In Proceedings of the Seventh International Conference on Data Engineering, </booktitle> <pages> pages 314-323, </pages> <address> Los Alamitos, Ca, April 1991. </address> <publisher> IEEE, IEEE Computer Society Press. </publisher>
Reference-contexts: Usually, the correctness of multidatabase algorithms is based on the classical notion of seri-alizability. Several algorithms have been proposed in the literature to guarantee serializab-ility; these usually fall into one of three classes of mechanisms: submission ordering [8, 11, 23], ticketing <ref> [16, 15] </ref>, and rigorous scheduling [11, 16]. Strong recoverability (or commitment ordering) at component database systems guarantee that transactions are serialized in the same order in which they are executed. By serializing the submission of global transactions, the global commit history is also serialized. <p> Usually, the correctness of multidatabase algorithms is based on the classical notion of seri-alizability. Several algorithms have been proposed in the literature to guarantee serializab-ility; these usually fall into one of three classes of mechanisms: submission ordering [8, 11, 23], ticketing [16, 15], and rigorous scheduling <ref> [11, 16] </ref>. Strong recoverability (or commitment ordering) at component database systems guarantee that transactions are serialized in the same order in which they are executed. By serializing the submission of global transactions, the global commit history is also serialized. Most concur-rency control techniques serialize transactions through mutual exclusion. <p> Multidatabase concurrency control techniques based on ticketing force global transactions to conflict directly at each component database site by forcing them to update a common ticket data item. Certification of consistent relative ticket orders at each component database site before atomic commitment guarantees serializ-ability <ref> [16] </ref>. Unfortunately, ticketing creates artificial hot spots in ticket tables and ticket certification requires the maintenance of a centralized global serialization graph. Conservative and cascadeless ticketing schemes, introduced by Georgakopoulos et. al. in [15] eliminate the latter while the former is solved through implicit ticketing or rigorous scheduling. <p> Rigorousness is a subclass of strong recoverabil-ity in which component databases guarantee that a transaction cannot execute a conflicting operation on data items until the transaction that last operated on them is either committed or aborted. Rigorousness combined with an atomic commit protocol guarantees serializ-ability <ref> [11, 16] </ref>. In Bradshaw [6], work on concurrency control in open nested transaction systems [4] was combined with the notion of multidatabase seri-alizability [20] to derive the concept of open nested multidatabase serializability (ONMSR). ONMSR is not a new serializability class. <p> This result is significant because the ticketing approach allows any set of serializable cells to be composed while still guaranteeing a globally serial-izable history. 5.1 Composite Rigorous Schedul ing Algorithm The algorithm described in this section shows that the rigorous multidatabase scheduling algorithm <ref> [9, 16, 24] </ref> scales to composite mul-tidatabase environments.
Reference: [17] <author> J. N. Gray. </author> <title> Notes on Database Operating Systems. </title> <editor> In R. Bayer, R. M. Graham, and G. Seegmuller, editors, </editor> <booktitle> Operating Systems: An Advanced Course, </booktitle> <pages> pages 393-481. </pages> <publisher> Springer-Verlag, </publisher> <address> Berlin, Germany, </address> <year> 1978. </year>
Reference-contexts: All multidatabase cells guarantee multidata-base serializable histories [20]. Since mul-tidatabase serializability is a more restrictive form of two-level serializability [8], this subsumes locally serializable schedules at all component database systems. Global atomicity between a multidatabase server and its component sites is guaranteed with the two-phase commit (2PC) protocol <ref> [5, 17, 18] </ref>. Local deadlock is assumed to be resolved by deadlock resolution mechanisms at component database sites while global deadlock is heuristically detected through transaction timeouts. Other assumptions about the relationship between multidata-base servers and their component database systems depend on global concurrency control algorithm in use.
Reference: [18] <author> J. N. Gray and A. Reuter. </author> <title> Transaction Processing: Concepts and Techniques. Morgan Kaufmann Series in Data Management Systems. </title> <publisher> Morgan Kaufmann Publishers, </publisher> <address> San Mateo, Ca, </address> <year> 1993. </year>
Reference-contexts: All multidatabase cells guarantee multidata-base serializable histories [20]. Since mul-tidatabase serializability is a more restrictive form of two-level serializability [8], this subsumes locally serializable schedules at all component database systems. Global atomicity between a multidatabase server and its component sites is guaranteed with the two-phase commit (2PC) protocol <ref> [5, 17, 18] </ref>. Local deadlock is assumed to be resolved by deadlock resolution mechanisms at component database sites while global deadlock is heuristically detected through transaction timeouts. Other assumptions about the relationship between multidata-base servers and their component database systems depend on global concurrency control algorithm in use. <p> T 261 (c) c T 2 H C 21 : r T 251 (g) w T 251 (h) c T 2 w T 131 (g) c T 1 Notice that the local histories in this example are possible only if the component database systems support Level 2 isolation or lower <ref> [18] </ref>. If all transactions at component databases are at Level 3 or Level 4 isolation these cyclic histories would not exist. This property is the basis of the first algorithm outlined in Section 5.1.
Reference: [19] <author> A. Leff and C. Pu. </author> <title> Classification of Transaction Processing Systems. </title> <journal> IEEE Computer, </journal> <volume> 24(6) </volume> <pages> 63-76, </pages> <month> June </month> <year> 1991. </year>
Reference-contexts: For example, the timestamps in CTO can be propagated from one multidatabase cell to the next as transaction properties tagged onto a transaction during transaction propagation among cells. The algorithms do not suffer from the communication limitations of explicitly communicating global ordering data structures like O-vectors in <ref> [19, 21] </ref>. 9 3. Global Aborts: Each of the algorithms guarantees serializable global transaction orders through the preemption of non-serializable transactions by global aborts. The CRS and CFC algorithms work by creating a deadlock among non-serializable multicellular transactions.
Reference: [20] <author> S. Mehrotra, R. Rastogi, Y. Breitbart, H. F. Korth, and A. Silberschatz. </author> <title> Ensuring Transaction Atomicity in Multidata-base Systems. </title> <type> Technical Report TR-92-12, </type> <institution> Department of Computer Sciences, University of Texas at Austin, Austin, Texas, </institution> <month> 78712, June </month> <year> 1992. </year>
Reference-contexts: Rigorousness combined with an atomic commit protocol guarantees serializ-ability [11, 16]. In Bradshaw [6], work on concurrency control in open nested transaction systems [4] was combined with the notion of multidatabase seri-alizability <ref> [20] </ref> to derive the concept of open nested multidatabase serializability (ONMSR). ONMSR is not a new serializability class. It generalizes two-level multidatabase serializabil-ity to asymmetric execution hierarchies of arbitrary depths. <p> It implies that distributed or replicated component databases are treated as single component database systems. The catalogue in a multidatabase server may import mappings to views and base tables managed by another mul-tidatabase server. All multidatabase cells guarantee multidata-base serializable histories <ref> [20] </ref>. Since mul-tidatabase serializability is a more restrictive form of two-level serializability [8], this subsumes locally serializable schedules at all component database systems. Global atomicity between a multidatabase server and its component sites is guaranteed with the two-phase commit (2PC) protocol [5, 17, 18].
Reference: [21] <author> C. Pu. </author> <booktitle> Superdatabases for Composition of Heterogeneous Databases . In Proceedings of the Fourth International Conference on Data Engineering, </booktitle> <pages> pages 548-555, </pages> <address> Los Alamitos, Ca, </address> <month> May </month> <year> 1988. </year> <title> IEEE, </title> <publisher> IEEE Computer Society Press. </publisher>
Reference-contexts: Section 6 highlights the effect of multicellular transaction ordering on performance in composite systems. Finally, Section 7 concludes with a summary of this work and its significance. 2 Related Work The only known published work on multidata-base composition is on superdatabases <ref> [21] </ref>. A superdatabase is analogous to a composite multidatabase system. Superdatabases form a static hierarchy with a master superdatabase at the root composed of other superdatabases and component database systems. Each intermediate superdatabase has its own superdata-base hierarchy with component database systems occupying the leaves. <p> These tests also validate the following performance issues. 1. Dynamic Composition and Scalability : In our prototype, multidatabase composition is dynamic and depends on collective runtime access patterns of all global transactions. This is unlike the static hierarchies required by Schek and Weikum in [27] and by Pu in <ref> [21] </ref>. This feature allows the dynamic removal and addition of mul-tidatabase cell servers from a composite environment. Transaction access patterns are also dynamically controlled at runtime by manipulating catalogue data at active multidatabase cell servers. Dynamic composition facilitates scalability. <p> For example, the timestamps in CTO can be propagated from one multidatabase cell to the next as transaction properties tagged onto a transaction during transaction propagation among cells. The algorithms do not suffer from the communication limitations of explicitly communicating global ordering data structures like O-vectors in <ref> [19, 21] </ref>. 9 3. Global Aborts: Each of the algorithms guarantees serializable global transaction orders through the preemption of non-serializable transactions by global aborts. The CRS and CFC algorithms work by creating a deadlock among non-serializable multicellular transactions.
Reference: [22] <author> Y. Raz. </author> <title> Guaranteeing global serializabil-ity via Commitment Ordering. </title> <type> Technical Report DEC-TR 843, </type> <institution> Digital Equipment Corporation, 151 Taylor St, Littleton, </institution> <address> Ma 01460, </address> <month> December </month> <year> 1991. </year>
Reference-contexts: Global transactions are serialized relative to each other top-down as opposed to bottom-up. Furthermore, like CRS, these algorithms do not depend on artificial conflicts or hot spots in ticketing databases. In <ref> [22] </ref>, Raz outlines a commitment ordering mechanism for imposing strong recov-erability on any serializable component database system. However, this mechanism generates additional transaction restarts while enforcing the strong recoverability property at component database schedulers. The CTO algorithm assigns and validates timestamp orders as follows.
Reference: [23] <author> Y. Raz. </author> <title> Principle of Commitment Ordering. </title> <type> Technical Report DEC-TR 841, </type> <institution> Digital Equipment Corporation, 151 Taylor St, Littleton, </institution> <address> Ma 01460, </address> <month> November </month> <year> 1991. </year>
Reference-contexts: Usually, the correctness of multidatabase algorithms is based on the classical notion of seri-alizability. Several algorithms have been proposed in the literature to guarantee serializab-ility; these usually fall into one of three classes of mechanisms: submission ordering <ref> [8, 11, 23] </ref>, ticketing [16, 15], and rigorous scheduling [11, 16]. Strong recoverability (or commitment ordering) at component database systems guarantee that transactions are serialized in the same order in which they are executed. By serializing the submission of global transactions, the global commit history is also serialized.
Reference: [24] <author> Y. Raz. </author> <title> Locking Based Strict Commitment Ordering. </title> <type> Technical Report DEC-TR 844, </type> <institution> Digital Equipment Corporation, 151 Taylor St, Littleton, </institution> <address> Ma 01460, </address> <month> Feb-ruary </month> <year> 1992. </year>
Reference-contexts: This result is significant because the ticketing approach allows any set of serializable cells to be composed while still guaranteeing a globally serial-izable history. 5.1 Composite Rigorous Schedul ing Algorithm The algorithm described in this section shows that the rigorous multidatabase scheduling algorithm <ref> [9, 16, 24] </ref> scales to composite mul-tidatabase environments.
Reference: [25] <author> D. Reed. </author> <title> Naming and Synchronization in a Decentralized Computer System. </title> <type> PhD thesis, </type> <institution> Massachussetts Institute of Technology, </institution> <year> 1978. </year> <note> Also available as Technical Report MIT-LCS-205, </note> <institution> Massachussetts Institute of Technology, </institution> <year> 1978. </year>
Reference-contexts: Timestamps with these properties can be generated by concatenating the global time from a synchronized global distributed time service with a site-dependent identifier at each site <ref> [25] </ref>. Only transactions with the same global time component in their timestamp are prioritized on the site identifier. A higher resolution on the global clock reduces global time conflicts on timestamps and therefore the likelihood of starvation resulting from the prioritization of transaction execution on site identifiers.
Reference: [26] <author> K. Salem, H. Garcia-Molina, and R. Alonso. </author> <title> Altruistic Locking: A Startegy for Coping with Long-Lived Transactions. </title> <editor> In D. Gawlick, M. Haynie, and A. Reu-ter, editors, </editor> <booktitle> Lecture Notes in Computer Sciences, High Performance Transaction Processing Systems, </booktitle> <volume> volume 359, </volume> <pages> pages 175-199. </pages> <publisher> Springer-Verlag, </publisher> <year> 1989. </year>
Reference-contexts: By serializing the submission of global transactions, the global commit history is also serialized. Most concur-rency control techniques serialize transactions through mutual exclusion. Exclusion prevents more than one transaction from executing at two or more sites, inherently preventing indirect conflicts through local transactions <ref> [1, 10, 26] </ref>. Multidatabase concurrency control techniques based on ticketing force global transactions to conflict directly at each component database site by forcing them to update a common ticket data item. Certification of consistent relative ticket orders at each component database site before atomic commitment guarantees serializ-ability [16]. <p> Both cases lead to serializable global histories. The CTO algorithm is one case of an algorithm based on submission orders and strong recoverability. Other variants of this class of algorithms based on site locking [1] and altruistic locking <ref> [26] </ref> work similarly. 5.3 Composite Forced Conflicts Algorithm The rigorous history condition and strong re-coverability condition in Theorem 1 and Theorem 2, respectively, have limited applicability because some component databases may not support these history properties.
Reference: [27] <author> H-J. Schek, G. Weikum, and W. </author> <month> Schaad. </month>
Reference-contexts: These tests also validate the following performance issues. 1. Dynamic Composition and Scalability : In our prototype, multidatabase composition is dynamic and depends on collective runtime access patterns of all global transactions. This is unlike the static hierarchies required by Schek and Weikum in <ref> [27] </ref> and by Pu in [21]. This feature allows the dynamic removal and addition of mul-tidatabase cell servers from a composite environment. Transaction access patterns are also dynamically controlled at runtime by manipulating catalogue data at active multidatabase cell servers. Dynamic composition facilitates scalability.
References-found: 27

