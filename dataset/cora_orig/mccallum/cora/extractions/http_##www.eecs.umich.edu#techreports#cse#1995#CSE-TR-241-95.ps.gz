URL: http://www.eecs.umich.edu/techreports/cse/1995/CSE-TR-241-95.ps.gz
Refering-URL: http://www.eecs.umich.edu/home/techreports/cse95.html
Root-URL: http://www.eecs.umich.edu
Email: e-mail: kuno@umich.edu, ygra@umich.edu, rundenst@umich.edu  
Phone: fax: (313) 763-1503, phone: (313) 936-2971  
Title: The Object-Slicing Technique: A Flexible Object Representation and Its Evaluation  
Author: Harumi A. Kuno, Young-Gook Ra, and Elke A. Rundensteiner 
Keyword: Multiple classification, object-oriented database models, performance evaluation, object clustering, benchmarking.  
Note: This work was supported in part by the NSF RIA grant #IRI-9309076, the NSF NYI grant #IRI-9457609, and the University of Michigan Faculty Award Program. Harumi Kuno is also grateful for support from the NASA Graduate Student Researchers Program.  
Address: 1301 Beal Avenue Ann Arbor, MI 48109-2122  
Affiliation: Dept. of Elect. Engineering and Computer Science Software Systems Research Laboratory The University of Michigan,  
Abstract: Recently much work has been done towards extending object-oriented database systems (OODBs) with advanced tools such as view technology, advanced schema evolution support, and role modeling systems. These extensions all require that the underlying database system supports more powerful and flexible modeling constructs than are currently supported by existing OODB systems. In this paper, we identify these features as multiple classification, dynamic reclassification, and dynamic restructuring. We then describe a methodology known as object-slicing that is capable of extending data models to support these required features. We have successfully implemented an object-slicing software layer using the GemStone system, which while still providing full access to all GemStone DBMS functions, now also offers all required modeling features. In this paper, we describe our experimental results evaluating the relative costs and benefits of adopting the object-slicing technique. This includes an analytical assessment of the storage overhead of the object-slicing representation, and its comparison against the conventional representational models. As clustering is critical to optimizing queries on such models, we present the results of using OO7 benchmark test suites evaluating various clustering strategies for the object-slicing model. We find that for certain types of queries (e.g., those that benefit from the superior blocking factor at the local attribute level resulting from clustering object-slices together by class), the object-slicing model outperforms the conventional approach in spite of its storage overhead, while queries involving inherited attributes with low selectivity are better serviced using a conventional object-clustering approach. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> S. Abiteboul and A. Bonner. </author> <title> Objects and views. </title> <booktitle> SIGMOD, </booktitle> <pages> pages 238-247, </pages> <year> 1991. </year>
Reference-contexts: Thus they adhere to the invariant that an object belongs to exactly one class at a time | as well as indirectly to all of that class's superclasses <ref> [1] </ref>.
Reference: [2] <author> M. Atkinson, F. Bancilhon, D. DeWitt, K. Dittrich, D. Maier, and S. Zdonic. </author> <title> The object-oriented database system manifesto. </title> <editor> In F. Bancilhon, C. Delobel, and P. Kanellakis, editors, </editor> <title> Building an Object-Oriented Database System: The Story of O2, </title> <booktitle> chapter 1, </booktitle> <pages> pages 3 - 20. </pages> <publisher> Morgan Kaufmann Pub., </publisher> <year> 1992. </year>
Reference-contexts: In spite of this work, the object representation assumptions underlying most OODB systems are of a different nature. Current OODB systems allow only one most-specific type per object and the object type is determined and fixed at object-creation time <ref> [2, 18, 12] </ref>. The Iris functional database system is the most well-known exception to this; i.e., it is a DBMS system that supports multiple classification.
Reference: [3] <author> J. Banerjee, H. Chou, J. F. Garza, W. Kim, D. Woelk, N. Ballou, and H. J. Kim. </author> <title> Data model issues for object-oriented applications. </title> <editor> In S. B. Zdonik and D. Maier, editors, </editor> <booktitle> Readings in Object-Oriented Database Systems, </booktitle> <pages> pages 197-208. </pages> <publisher> Morgan Kaufmann Pub., </publisher> <year> 1990. </year> <month> 17 </month>
Reference-contexts: These extensions all require that the underlying database system supports flexible and powerful modeling constructs that are currently not supported by most existing OODB systems <ref> [3, 5, 15] </ref>.
Reference: [4] <author> E. Bertino. </author> <title> A view mechanism for object-oriented databases. </title> <booktitle> In 3rd International Conference on Extending Database Technology, </booktitle> <pages> pages 136-151, </pages> <month> March </month> <year> 1992. </year>
Reference-contexts: 1 Introduction Recently much work has been done towards extending object-oriented database systems (OODBs) with advanced tools such as view technology, advanced schema evolution tools, and role modeling systems <ref> [4, 7, 10, 13, 19, 21, 22, 25] </ref>. These extensions all require that the underlying database system supports flexible and powerful modeling constructs that are currently not supported by most existing OODB systems [3, 5, 15]. <p> View System Needs. In recent years, object-oriented view technology has been touted as an important technique for integrating heterogeneous and distributed systems, for achieving interoperability by hiding idiosyncrasies of component systems to be integrated into one unified, yet federated system, and for security <ref> [23, 22, 4, 7, 13] </ref>. View mechanisms typically provide the functionality to restructure a base schema by hiding classes, by adding classes, by customizing the behavior or extent of classes, and by rearranging the generalization hierarchy. <p> Extending Views for Schema Evolution. The use of view mechanisms to achieve schema evolution has been advocated by a number of researchers <ref> [25, 7, 4, 21] </ref>. The basic principle is that given a schema change request on a view schema, the system|rather than modifying the view schema in place|computes a new view that reflects the semantics of the schema change. This approach provides several advantages over direct modification.
Reference: [5] <author> P. Butterworth, A. Otis, and J. Stein. </author> <title> The gemstone object database management system. </title> <journal> Communications of the ACM, </journal> <volume> 34(10) </volume> <pages> 64-77, </pages> <month> October </month> <year> 1991. </year>
Reference-contexts: These extensions all require that the underlying database system supports flexible and powerful modeling constructs that are currently not supported by most existing OODB systems <ref> [3, 5, 15] </ref>.
Reference: [6] <author> M. J. Carey, D. J. DeWitt, and J. F. Naughton. </author> <title> The OO7 benchmark. </title> <booktitle> SIGMOD, </booktitle> <year> 1993. </year>
Reference-contexts: overhead is ameliorated by an increased object size/decreased schema size (depth of schema) ratio. 6 Evaluation of Object-Slicing Approach Using the OO7 Benchmark In order to determine the base cost of implementing the object-slicing representation paradigm, we have run several test queries from the University of Wisconsin's OO7 benchmark suite <ref> [6] </ref> with the intention of comparing GemStone's native implementation versus our object-slicing extension to GemStone. GemStone is a Smalltalk-based system, while the four systems compared in the OO7 benchmark paper [6] are all C++ based. <p> of implementing the object-slicing representation paradigm, we have run several test queries from the University of Wisconsin's OO7 benchmark suite <ref> [6] </ref> with the intention of comparing GemStone's native implementation versus our object-slicing extension to GemStone. GemStone is a Smalltalk-based system, while the four systems compared in the OO7 benchmark paper [6] are all C++ based. Because GemStone thus supports dynamic method resolution, run-time augmentation of the schema with new methods, etc., we did not compare GemStone against other systems, and instead limited our study to comparing "pure" GemStone with MultiView. <p> First, we compare results for navigation-type queries, e.g., for the "Traversal 1" query. The "Traversal 1" query tests raw pointer traversal speed with a high degree of locality <ref> [6] </ref>.
Reference: [7] <author> C. Souza dos Santos, S. Abiteboul, and C. Delobel. </author> <title> Virtual schemas and bases. </title> <booktitle> International Conference on Extending Database Technology (EDBT), </booktitle> <year> 1994. </year>
Reference-contexts: 1 Introduction Recently much work has been done towards extending object-oriented database systems (OODBs) with advanced tools such as view technology, advanced schema evolution tools, and role modeling systems <ref> [4, 7, 10, 13, 19, 21, 22, 25] </ref>. These extensions all require that the underlying database system supports flexible and powerful modeling constructs that are currently not supported by most existing OODB systems [3, 5, 15]. <p> View System Needs. In recent years, object-oriented view technology has been touted as an important technique for integrating heterogeneous and distributed systems, for achieving interoperability by hiding idiosyncrasies of component systems to be integrated into one unified, yet federated system, and for security <ref> [23, 22, 4, 7, 13] </ref>. View mechanisms typically provide the functionality to restructure a base schema by hiding classes, by adding classes, by customizing the behavior or extent of classes, and by rearranging the generalization hierarchy. <p> Extending Views for Schema Evolution. The use of view mechanisms to achieve schema evolution has been advocated by a number of researchers <ref> [25, 7, 4, 21] </ref>. The basic principle is that given a schema change request on a view schema, the system|rather than modifying the view schema in place|computes a new view that reflects the semantics of the schema change. This approach provides several advantages over direct modification.
Reference: [8] <author> D.H. Fishman. </author> <title> Iris: An object oriented database management system. </title> <journal> In ACM Transactions on Office Information Systems, </journal> <volume> volume 5, </volume> <pages> pages 48-69, </pages> <month> January </month> <year> 1987. </year>
Reference-contexts: To the best of our knowledge, no current OODB system supports all of these features. Furthermore, with the exception of the IRIS functional database system <ref> [8] </ref>, which uses a relational database as storage structure and stores data from one object across many relations, most OODBs represent each database object as a chunk of contiguous storage determined at object creation time. <p> The Iris functional database system is the most well-known exception to this; i.e., it is a DBMS system that supports multiple classification. However, IRIS, being built on top of a relational engine, distributes its data over several relational tables <ref> [8] </ref>, and hence can support multiple states per object. There are, however, several significant differences between our work and IRIS. For one, our object-slicing representation is built on top of a pure object-oriented kernel rather than a relational system.
Reference: [9] <author> C. Gerlhof, A. Kemper, C. Kilger, and G. Moerkotte. </author> <title> Partition-based clustering in object bases: From theory to practice. </title> <booktitle> In Foundations of Data Organization and Algorithms, 3rd International Conference, </booktitle> <pages> pages 301-316, </pages> <month> October </month> <year> 1993. </year>
Reference-contexts: Instead, we are interested in understanding what the innate differences are between the conventional and the object-slicing representation | and whether the flexibility gained comes with an added cost. Furthermore, previous work in the area of clustering such as <ref> [9, 17] </ref>, is still applicable in our representation model.
Reference: [10] <author> G. Gottlob, P. Paolini, and R. Zicari. </author> <title> "Properties and Update Semantics of Consistent Views". </title> <journal> ACM Trans. on Database Systems, </journal> <volume> vol.13(4):486-524, </volume> <month> December </month> <year> 1988. </year>
Reference-contexts: 1 Introduction Recently much work has been done towards extending object-oriented database systems (OODBs) with advanced tools such as view technology, advanced schema evolution tools, and role modeling systems <ref> [4, 7, 10, 13, 19, 21, 22, 25] </ref>. These extensions all require that the underlying database system supports flexible and powerful modeling constructs that are currently not supported by most existing OODB systems [3, 5, 15].
Reference: [11] <author> G. Gottlob, M. Schrefl, and B. Rock. </author> <title> Extending object-oriented systems with roles. </title> <type> manuscript, </type> <year> 1993. </year>
Reference-contexts: Similarly, the flexibility offered by the object-slicing approach naturally lends itself to implementing role systems: object-slicing's implementation objects can easily be adapted to represent the various roles of objects in a role system <ref> [11] </ref>. We examine the object-slicing representation in the context of the University of Michigan's MultiView project, an on-going NSF-funded view management system capable of supporting updatable materialized views and transparent schema evolution. <p> It is to be expected that extending an existing system with object-slicing techniques involves the potential overhead of additional data structures, maintenance costs, and processing time. Although object-slicing is a known technique that is being utilized for view systems [14], schema evolution [21], and role systems <ref> [11] </ref>, to the best of our knowledge no work has been done evaluating the costs of object-slicing. The purpose of this paper is to provide such an evaluation. <p> Thus the underlying view system providing such capacity-augmenting views does require the dynamic restructuring of objects in addition to the features of multiple classification and dynamic reclassification. Role Modeling System Needs. Finally, role modeling approaches have become increasingly popular <ref> [11, 19] </ref>. Role systems strive to increase the flexibility of the model by enabling objects to dynamically change types and class membership. In role modeling systems, objects dynamically gain and lose multiple interfaces (a.k.a. roles) throughout their lifetimes, hence the need for multiple classification. <p> Identified features include multiple classification, dynamic reclassification, and dynamic restructuring. We are not the first who have identified the utility of such flexible modeling constructs. One example of this is the work by Scholl et. al. on object-oriented views [23]. Other examples are recently emerging role modeling approaches <ref> [11, 19] </ref>. In role modeling systems, objects dynamically gain and lose multiple interfaces (aka roles) throughout their lifetimes. These roles can be compared to the implementation objects of an object-slicing implementation, in that both permit objects to belong to multiple classes and change types dynamically. <p> Although our implementation objects resemble object hierarchy objects in that they inherit from each other, objects in our implementation always conform to the existing global class hierarchy. The role system proposed by Gottlob et al. <ref> [11] </ref> was implemented using techniques similar to object-slicing . This system, like ours, is implemented in Smalltalk by overriding the doesNotUnderstand: method. Unlike many role systems, which allow object hierarchies to exist independently from class hierarchies [24], objects in our model always conform to the existing global class hierarchy. <p> This achieves an efficient and uniform inheritance scheme. Also, unlike many role systems, in our implementation conceptual objects can be associated with at most one implementation object of a given type <ref> [11] </ref>. Our proposed object-slicing approach is thus a compromise between extremely flexible role models on the one side and rigid class-based data models on the other side. <p> Extending an existing DBMS with object-slicing techniques necessarily involves the overhead of additional data structures, maintenance costs, and processing time. However, although object-slicing is a known technique that is being utilized for view systems [14], schema evolution [21], and role systems <ref> [11] </ref>, to our knowledge no work has been done evaluating the costs of object-slicing. In this paper, we therefore provide an in depth evaluation of the object-slicing technique. We describe our experimental results evaluating the relative costs and benefits of adopting the object-slicing techniques.
Reference: [12] <author> W. Kim, J. F. Garza, N. Ballou, and D. Woelk. </author> <title> Architecture of the orion next-generation database system. </title> <journal> IEEE Transactions on Knowledge and Data Engineering, </journal> <volume> 2(1), </volume> <month> March </month> <year> 1990. </year>
Reference-contexts: In spite of this work, the object representation assumptions underlying most OODB systems are of a different nature. Current OODB systems allow only one most-specific type per object and the object type is determined and fixed at object-creation time <ref> [2, 18, 12] </ref>. The Iris functional database system is the most well-known exception to this; i.e., it is a DBMS system that supports multiple classification.
Reference: [13] <author> H. A. Kuno and E. A. Rundensteiner. </author> <title> Implementation experience with building an object-oriented view management system. </title> <type> Technical Report CSE-TR-191-93, </type> <institution> University of Michigan, </institution> <address> Ann Arbor, </address> <month> August </month> <year> 1993. </year>
Reference-contexts: 1 Introduction Recently much work has been done towards extending object-oriented database systems (OODBs) with advanced tools such as view technology, advanced schema evolution tools, and role modeling systems <ref> [4, 7, 10, 13, 19, 21, 22, 25] </ref>. These extensions all require that the underlying database system supports flexible and powerful modeling constructs that are currently not supported by most existing OODB systems [3, 5, 15]. <p> View System Needs. In recent years, object-oriented view technology has been touted as an important technique for integrating heterogeneous and distributed systems, for achieving interoperability by hiding idiosyncrasies of component systems to be integrated into one unified, yet federated system, and for security <ref> [23, 22, 4, 7, 13] </ref>. View mechanisms typically provide the functionality to restructure a base schema by hiding classes, by adding classes, by customizing the behavior or extent of classes, and by rearranging the generalization hierarchy.
Reference: [14] <author> H. A. Kuno and E. A. Rundensteiner. </author> <title> Materialized object-oriented views in MultiView. </title> <booktitle> In ACM Research Issues in Data Engineering, </booktitle> <month> March </month> <year> 1995. </year>
Reference-contexts: In addition, object-slicing facilitates the maintenance of materialized views in that (1) it elegantly avoids the need to duplicate data for materialized classes and (2) any update to an object will take place at a unique location determined by the property involved regardless of the source of the update request <ref> [14] </ref>. Similarly, the flexibility offered by the object-slicing approach naturally lends itself to implementing role systems: object-slicing's implementation objects can easily be adapted to represent the various roles of objects in a role system [11]. <p> It is to be expected that extending an existing system with object-slicing techniques involves the potential overhead of additional data structures, maintenance costs, and processing time. Although object-slicing is a known technique that is being utilized for view systems <ref> [14] </ref>, schema evolution [21], and role systems [11], to the best of our knowledge no work has been done evaluating the costs of object-slicing. The purpose of this paper is to provide such an evaluation. <p> Extending an existing DBMS with object-slicing techniques necessarily involves the overhead of additional data structures, maintenance costs, and processing time. However, although object-slicing is a known technique that is being utilized for view systems <ref> [14] </ref>, schema evolution [21], and role systems [11], to our knowledge no work has been done evaluating the costs of object-slicing. In this paper, we therefore provide an in depth evaluation of the object-slicing technique.
Reference: [15] <author> C. Lecluse, P. Richard, and F. Velez. </author> <title> o 2 , an object-oriented data model. </title> <booktitle> SIGMOD, </booktitle> <pages> pages 424-433, </pages> <year> 1988. </year>
Reference-contexts: These extensions all require that the underlying database system supports flexible and powerful modeling constructs that are currently not supported by most existing OODB systems <ref> [3, 5, 15] </ref>.
Reference: [16] <author> J. Martin and J. Odell. </author> <title> Object-Oriented Analysis and Design. </title> <publisher> Prentice-Hall, Inc., </publisher> <year> 1992. </year>
Reference-contexts: In fact, the object representation assumptions underlying most commercial OODB systems, namely, one most-specific type per object, object type determined at object-creation time, fixed typing, and upwards inheritance, conflict with the requirements of such systems. The object-slicing technique <ref> [16] </ref> is one particularly promising approach of extending an existing OODB system to support the identified required features. <p> In object-slicing, a real-world object corresponds to a hierarchy of implementation objects (one for each class whose type the object possesses) linked to a conceptual object (used to represent the object-itself) rather than associating a single implementation with each real-world object, as is commonly assumed in conventional OODB systems <ref> [16] </ref>. This technique of using implementation objects to represent an object's membership in multiple classes is extremely flexible, and provides a solution that extends an OODB system to support capacity-augmenting virtual classes, multiple classification, dynamic reclassification, and dynamic restructuring of objects and classes. <p> We present detailed comparison studies by benchmark experiments and simulations that confirm this hypothesis in Section 6. * Changing an object from being an instance of one class (C1) to being an instance of another class (C2) is called dynamic classification <ref> [16] </ref>. In the object-slicing approach, when an object is dynamically reclassified to be an instance of the class C2 rather than one of class C1, the object instance takes an implementation object of the class C2 and discards that of the class C1.
Reference: [17] <author> S. Navathe, S. Ceri, G. Wiederhold, and J. Dou. </author> <title> Vertical partitioning algorithms for database design. </title> <journal> ACM Transactions on Database Systems, </journal> <volume> 9(4) </volume> <pages> 680-710, </pages> <month> December </month> <year> 1984. </year>
Reference-contexts: Instead, we are interested in understanding what the innate differences are between the conventional and the object-slicing representation | and whether the flexibility gained comes with an added cost. Furthermore, previous work in the area of clustering such as <ref> [9, 17] </ref>, is still applicable in our representation model.
Reference: [18] <author> O2 Technology. </author> <title> O2 Views User Manual, </title> <note> version 1 edition, </note> <month> December </month> <year> 1993. </year>
Reference-contexts: In spite of this work, the object representation assumptions underlying most OODB systems are of a different nature. Current OODB systems allow only one most-specific type per object and the object type is determined and fixed at object-creation time <ref> [2, 18, 12] </ref>. The Iris functional database system is the most well-known exception to this; i.e., it is a DBMS system that supports multiple classification.
Reference: [19] <author> M. P. Papazoglou. </author> <title> Roles: A methodology for representing multifaceted objects. </title> <booktitle> In International Conference on Database and Expert Systems Applications, </booktitle> <pages> pages 7-12. </pages> <publisher> Springer-Verlag, </publisher> <year> 1991. </year>
Reference-contexts: 1 Introduction Recently much work has been done towards extending object-oriented database systems (OODBs) with advanced tools such as view technology, advanced schema evolution tools, and role modeling systems <ref> [4, 7, 10, 13, 19, 21, 22, 25] </ref>. These extensions all require that the underlying database system supports flexible and powerful modeling constructs that are currently not supported by most existing OODB systems [3, 5, 15]. <p> Thus the underlying view system providing such capacity-augmenting views does require the dynamic restructuring of objects in addition to the features of multiple classification and dynamic reclassification. Role Modeling System Needs. Finally, role modeling approaches have become increasingly popular <ref> [11, 19] </ref>. Role systems strive to increase the flexibility of the model by enabling objects to dynamically change types and class membership. In role modeling systems, objects dynamically gain and lose multiple interfaces (a.k.a. roles) throughout their lifetimes, hence the need for multiple classification. <p> Identified features include multiple classification, dynamic reclassification, and dynamic restructuring. We are not the first who have identified the utility of such flexible modeling constructs. One example of this is the work by Scholl et. al. on object-oriented views [23]. Other examples are recently emerging role modeling approaches <ref> [11, 19] </ref>. In role modeling systems, objects dynamically gain and lose multiple interfaces (aka roles) throughout their lifetimes. These roles can be compared to the implementation objects of an object-slicing implementation, in that both permit objects to belong to multiple classes and change types dynamically.
Reference: [20] <author> Y. G. Ra, H. A. Kuno, and E. A. Rundensteiner. </author> <title> A flexible object-oriented database model and implementation for capacity-augmenting views. </title> <type> Technical Report CSE-TR-215-94, </type> <institution> University of Michigan, </institution> <year> 1994. </year>
Reference-contexts: In order to support the features required by views and schema evolution, we have successfully implemented an object-slicing layer <ref> [20] </ref> on top of the GemStone OODB system 1 . Based on this flexible foundation, we have been able to rapidly prototype the MultiView system providing capacity-augmenting virtual classes, updatable materialized virtual classes, and view schemata. <p> It is relatively straightforward to see how one could implement the object-slicing model on top of an existing OODB. In our technical report <ref> [20] </ref>, we describe our solution of realizing the model using a Smalltalk-based OODB, GemStone system. Due to space limitations, a discussion of these implementation issues is not repeated here. 5 Object-Slicing Storage Costs In evaluating the performance of databases, I/O operation time typically dominates CPU operation time.
Reference: [21] <author> Y. G. Ra and E. A. Rundensteiner. </author> <title> A transparent object-oriented schema change approach using view schema evolution. </title> <booktitle> In IEEE International Conference on Data Engineering, </booktitle> <month> March </month> <year> 1995. </year>
Reference-contexts: 1 Introduction Recently much work has been done towards extending object-oriented database systems (OODBs) with advanced tools such as view technology, advanced schema evolution tools, and role modeling systems <ref> [4, 7, 10, 13, 19, 21, 22, 25] </ref>. These extensions all require that the underlying database system supports flexible and powerful modeling constructs that are currently not supported by most existing OODB systems [3, 5, 15]. <p> It is to be expected that extending an existing system with object-slicing techniques involves the potential overhead of additional data structures, maintenance costs, and processing time. Although object-slicing is a known technique that is being utilized for view systems [14], schema evolution <ref> [21] </ref>, and role systems [11], to the best of our knowledge no work has been done evaluating the costs of object-slicing. The purpose of this paper is to provide such an evaluation. <p> Extending Views for Schema Evolution. The use of view mechanisms to achieve schema evolution has been advocated by a number of researchers <ref> [25, 7, 4, 21] </ref>. The basic principle is that given a schema change request on a view schema, the system|rather than modifying the view schema in place|computes a new view that reflects the semantics of the schema change. This approach provides several advantages over direct modification. <p> Extending an existing DBMS with object-slicing techniques necessarily involves the overhead of additional data structures, maintenance costs, and processing time. However, although object-slicing is a known technique that is being utilized for view systems [14], schema evolution <ref> [21] </ref>, and role systems [11], to our knowledge no work has been done evaluating the costs of object-slicing. In this paper, we therefore provide an in depth evaluation of the object-slicing technique. We describe our experimental results evaluating the relative costs and benefits of adopting the object-slicing techniques.
Reference: [22] <author> E. A. Rundensteiner. </author> <title> MultiView: A methodology for supporting multiple views in object-oriented databases. </title> <booktitle> In 18th VLDB Conference, </booktitle> <pages> pages 187-198, </pages> <year> 1992. </year>
Reference-contexts: 1 Introduction Recently much work has been done towards extending object-oriented database systems (OODBs) with advanced tools such as view technology, advanced schema evolution tools, and role modeling systems <ref> [4, 7, 10, 13, 19, 21, 22, 25] </ref>. These extensions all require that the underlying database system supports flexible and powerful modeling constructs that are currently not supported by most existing OODB systems [3, 5, 15]. <p> View System Needs. In recent years, object-oriented view technology has been touted as an important technique for integrating heterogeneous and distributed systems, for achieving interoperability by hiding idiosyncrasies of component systems to be integrated into one unified, yet federated system, and for security <ref> [23, 22, 4, 7, 13] </ref>. View mechanisms typically provide the functionality to restructure a base schema by hiding classes, by adding classes, by customizing the behavior or extent of classes, and by rearranging the generalization hierarchy.
Reference: [23] <author> M. H. Scholl, C. Laasch, and M. Tresch. </author> <title> Updatable views in object-oriented databases. </title> <booktitle> In Proceedings of the Second DOOD Conference, </booktitle> <month> December </month> <year> 1991. </year>
Reference-contexts: View System Needs. In recent years, object-oriented view technology has been touted as an important technique for integrating heterogeneous and distributed systems, for achieving interoperability by hiding idiosyncrasies of component systems to be integrated into one unified, yet federated system, and for security <ref> [23, 22, 4, 7, 13] </ref>. View mechanisms typically provide the functionality to restructure a base schema by hiding classes, by adding classes, by customizing the behavior or extent of classes, and by rearranging the generalization hierarchy. <p> Identified features include multiple classification, dynamic reclassification, and dynamic restructuring. We are not the first who have identified the utility of such flexible modeling constructs. One example of this is the work by Scholl et. al. on object-oriented views <ref> [23] </ref>. Other examples are recently emerging role modeling approaches [11, 19]. In role modeling systems, objects dynamically gain and lose multiple interfaces (aka roles) throughout their lifetimes.
Reference: [24] <author> E. Sciore. </author> <title> Object specialization. </title> <journal> ACM Transactions on Information Systems, </journal> <pages> pages 103-122, </pages> <month> April </month> <year> 1989. </year>
Reference-contexts: In some sense, accessing an object through one of its implementation objects is like accessing an object while it is playing one of its roles. In <ref> [24] </ref>, Sciore proposed an object specialization approach, in which a real world entity is modeled by multiple objects arranged in an object hierarchy. These object hierarchy objects inherit from each other, enabling each individual entity object to decide its own inheritance hierarchy. <p> The role system proposed by Gottlob et al. [11] was implemented using techniques similar to object-slicing . This system, like ours, is implemented in Smalltalk by overriding the doesNotUnderstand: method. Unlike many role systems, which allow object hierarchies to exist independently from class hierarchies <ref> [24] </ref>, objects in our model always conform to the existing global class hierarchy. To recap, if an object possesses an implementation object of a given class's type, it must also possess an implementation object for every class that is a superclass of that given type.
Reference: [25] <author> M. Tresch and M. H. Scholl. </author> <title> Schema Transformation without Database Reorganization. </title> <booktitle> In SIGMOD RECORD, </booktitle> <pages> pages 21-27, </pages> <year> 1993. </year>
Reference-contexts: 1 Introduction Recently much work has been done towards extending object-oriented database systems (OODBs) with advanced tools such as view technology, advanced schema evolution tools, and role modeling systems <ref> [4, 7, 10, 13, 19, 21, 22, 25] </ref>. These extensions all require that the underlying database system supports flexible and powerful modeling constructs that are currently not supported by most existing OODB systems [3, 5, 15]. <p> Extending Views for Schema Evolution. The use of view mechanisms to achieve schema evolution has been advocated by a number of researchers <ref> [25, 7, 4, 21] </ref>. The basic principle is that given a schema change request on a view schema, the system|rather than modifying the view schema in place|computes a new view that reflects the semantics of the schema change. This approach provides several advantages over direct modification.
Reference: [26] <author> M. M. Tsangaris and J. F. Naughton. </author> <title> A stochastic approach to clustering in object bases. </title> <booktitle> SIGMOD, </booktitle> <pages> pages 12-21, </pages> <year> 1991. </year>
Reference-contexts: In this paper, we address this issue. More precisely, we present results from our evaluation of the performance costs incurred by object-slicing, and examine the potential of various clustering techniques to alleviate this cost. Unlike previous work on the clustering and partitioning of OODBs <ref> [26, 27] </ref>, our goals are not to invent new clustering strategies to dynamically adapt to various access patterns. Instead, we are interested in understanding what the innate differences are between the conventional and the object-slicing representation | and whether the flexibility gained comes with an added cost.
Reference: [27] <author> M. M. Tsangaris and J. F. Naughton. </author> <title> On the performance of object clustering techniques. </title> <booktitle> SIGMOD, </booktitle> <pages> pages 144-153, </pages> <year> 1992. </year> <month> 18 </month>
Reference-contexts: In this paper, we address this issue. More precisely, we present results from our evaluation of the performance costs incurred by object-slicing, and examine the potential of various clustering techniques to alleviate this cost. Unlike previous work on the clustering and partitioning of OODBs <ref> [26, 27] </ref>, our goals are not to invent new clustering strategies to dynamically adapt to various access patterns. Instead, we are interested in understanding what the innate differences are between the conventional and the object-slicing representation | and whether the flexibility gained comes with an added cost.
References-found: 27

