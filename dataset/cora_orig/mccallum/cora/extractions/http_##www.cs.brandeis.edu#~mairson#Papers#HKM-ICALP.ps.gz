URL: http://www.cs.brandeis.edu/~mairson/Papers/HKM-ICALP.ps.gz
Refering-URL: http://www.cs.brandeis.edu/~mairson/
Root-URL: http://www.cs.brandeis.edu
Title: An Analysis of the Core-ML Language: Expressive Power and Type Reconstruction (invited paper)  
Author: Paris C. Kanellakis Gerd G. Hillebrand Harry G. Mairson 
Abstract: Core-ML is a basic subset of most functional programming languages. It consists of the simply typed (or monomorphic) -calculus, simply typed equality over atomic constants, and let as the only polymorphic construct. We present a synthesis of recent results which characterize this "toy" language's expressive power as well as its type reconstruction (or type inference) problem. More specifically: (1) Core-ML can express exactly the ELEMENTARY queries, where a program input is a database encoded as a -term and a query program is a -term whose application to the input normalizes to the output database. In addition, it is possible to express all the PTIME queries so that this normalization process is polynomial in the input size. (2) The polymorphism of let can be explained using a simple algorithmic reduction to monomorphism, and provides flexibility, without affecting expressibility. Algorithms for type reconstruction offer the additional convenience of static typing without type declarations. Given polymorphism, the price of this convenience is an increase in complexity from linear-time in the size of the program typed (without let) to completeness in exponential-time (with let). (3) Fragments of Core-ML, based on the order of functionalities used, can be fairly expressive. For example, order 5 suffices for the PTIME queries, even without let or equality. Also, for each fixed order, type reconstruction is polynomial in program size. Programming by using low order functionalities and type reconstruction is common in functional languages. Thus, our analysis partly explains the wide use and efficiency of such programming practices.
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> S. Abiteboul and C. Beeri. </author> <title> On the Power of Languages for the Manipulation of Complex Objects. </title> <note> INRIA Research Report 846, </note> <year> 1988. </year>
Reference-contexts: In addition, extensions have been proposed to this framework to manipulate complex-object databases, based on high-order formulas over finite structures, e.g., <ref> [1, 2] </ref>. The study of functional database query languages is more recent, see [6, 8, 7, 28], and is also part of the research on complex-object databases. In [23] we showed that TLC (without additions, but with different I/O conventions) can express exactly the ELEMENTARY database queries. <p> It follows that Core-ML can only express such functions. This is no real limitation, since all practical functions are ELEMENTARY and, as shown in [23], all ELEMENTARY functions are expressible. This was shown using an alternative characterization of the Abiteboul-Beeri (AB) complex object algebra, <ref> [1] </ref>. Theorem 6. Let (R 1 ; : : : ; R l ) be an AB complex object algebra expression over the relational schema S = (R 1 ; : : : ; R l ).
Reference: 2. <author> S. Abiteboul and P. Kanellakis. </author> <title> Database Theory Column: Query Languages for Complex Object Databases. </title> <journal> SIGACT News, </journal> <volume> 21 (1990), </volume> <pages> pp. 9-18. </pages>
Reference-contexts: In addition, extensions have been proposed to this framework to manipulate complex-object databases, based on high-order formulas over finite structures, e.g., <ref> [1, 2] </ref>. The study of functional database query languages is more recent, see [6, 8, 7, 28], and is also part of the research on complex-object databases. In [23] we showed that TLC (without additions, but with different I/O conventions) can express exactly the ELEMENTARY database queries.
Reference: 3. <author> S. Abiteboul and V. Vianu. </author> <title> Datalog Extensions for Database Queries and Updates. </title> <journal> J. Comput. System Sci., </journal> <volume> 43 (1991), </volume> <pages> pp. 62-124. </pages>
Reference-contexts: The main motivation has been that common relational database queries are expressible in relational calculus/algebra [13], Datalog : and various fixpoint logics <ref> [3, 32, 9, 10] </ref>. Most importantly, as shown in [27, 47], every PTIME query can be expressed using fixpoints of first-order formulas on ordered structures; and, as shown in [3], it suffices to use Datalog : syntax under a variety of semantics to express various fixpoint logics. <p> Most importantly, as shown in [27, 47], every PTIME query can be expressed using fixpoints of first-order formulas on ordered structures; and, as shown in <ref> [3] </ref>, it suffices to use Datalog : syntax under a variety of semantics to express various fixpoint logics. In addition, extensions have been proposed to this framework to manipulate complex-object databases, based on high-order formulas over finite structures, e.g., [1, 2].
Reference: 4. <author> H. Barendregt. </author> <title> The Lambda Calculus: Its Syntax and Semantics. </title> <publisher> North Holland, </publisher> <year> 1984. </year>
Reference-contexts: Research sup ported by NSF Grant CCR-9216185 and ONR Contract N00014-93-1-1015. For notational convenience, we use TLC = , the typed -calculus with atomic con-stants and an equality on them, and the associated delta-reduction of <ref> [4, 11] </ref>. For the necessary background on TLC see Section 2.1. We call Core-ML the "toy" language resulting from the addition of let-polymorphism to TLC = (see Section 2.2). <p> We include some of the basic expressibility analysis in Section3. For more details on the analysis of express-ibility we refer the reader to [44, 45, 17, 37, 23, 24, 25]. The expressive power of TLC was originally analyzed in terms of computations on simply typed Church numerals (see, e.g., <ref> [4, 17, 44] </ref>). Unfortunately, the simply typed Church numeral input-output convention imposes severe limitations on expressive power. Only a fragment of PTIME is expressible this way (called the extended polynomials) and this does not illustrate the full capabilities of TLC. <p> We write e ) fi e 0 (fi-reduction) when e 0 can be derived from e by replacing a subterm in e of the form (x: E)E 0 by [E 0 =x]E (E with E 0 substituted for all free occurrences of x in E). See <ref> [4] </ref> for standard definitions of substitution and reduction for both the typed and untyped -calculus. Let ) be the reflexive, transitive closure of ) ff and ) fi . Note that, reduction preserves types. <p> TLC and TLC = enjoy the following properties, see <ref> [11, 4] </ref>: Church-Rosser: If e ) e 0 and e ) e 00 , then there exists a -term e 000 such that e 0 ) e 000 and e 00 ) e 000 .
Reference: 5. <author> S. Bellantoni and S. Cook. </author> <title> A New Recursion-Theoretic Characterization of the Polytime Functions. </title> <booktitle> In Proceedings of the 24th ACM STOC (1992), </booktitle> <pages> pp. 283-293. </pages>
Reference-contexts: For example, order 5 suffices for the PTIME queries, even without let or equality. (Note that, in this sense equality is only a notational convenience). Since Cobham's early work there have been a number of interesting functional characterizations of PTIME, e.g., <ref> [12, 20, 19, 5, 35] </ref>. In Section 5.1 we add to this literature. In Section 5.2, we argue that fixed order type reconstruction is in polynomial time. This has some practical significance.
Reference: 6. <author> V. Breazu-Tannen, P. Buneman, and S. Naqvi. </author> <title> Structural Recursion as a Query Language. </title> <booktitle> In Proceedings DBPL3, </booktitle> <pages> pp. 9-19. </pages> <publisher> Morgan-Kaufmann, </publisher> <year> 1991. </year>
Reference-contexts: In addition, extensions have been proposed to this framework to manipulate complex-object databases, based on high-order formulas over finite structures, e.g., [1, 2]. The study of functional database query languages is more recent, see <ref> [6, 8, 7, 28] </ref>, and is also part of the research on complex-object databases. In [23] we showed that TLC (without additions, but with different I/O conventions) can express exactly the ELEMENTARY database queries. The basic idea was to use the framework of finite model theory instead of Church numerals. <p> Some progress on this is reported in [25]. involving functional characterizations of other complexity classes, in particular PSPACE and EXPTIME. (2) Study optimal reduction strategies [36] in the TLC. (3) Study languages that combine list iterators and set iterators ala <ref> [6, 8, 7, 28] </ref>. One consequence of the limitations of computing on Church numerals was a focus on the expressive power of typed calculi with more primitives and more complex type disciplines.
Reference: 7. <author> V. Breazu-Tannen, P. Buneman, and L. Wong. </author> <title> Naturally Embedded Query Languages. </title> <booktitle> In Proceedings 4th ICDT, </booktitle> <pages> pp. 140-154. </pages> <publisher> LNCS 646, Springer Verlag, </publisher> <year> 1992. </year>
Reference-contexts: In addition, extensions have been proposed to this framework to manipulate complex-object databases, based on high-order formulas over finite structures, e.g., [1, 2]. The study of functional database query languages is more recent, see <ref> [6, 8, 7, 28] </ref>, and is also part of the research on complex-object databases. In [23] we showed that TLC (without additions, but with different I/O conventions) can express exactly the ELEMENTARY database queries. The basic idea was to use the framework of finite model theory instead of Church numerals. <p> Some progress on this is reported in [25]. involving functional characterizations of other complexity classes, in particular PSPACE and EXPTIME. (2) Study optimal reduction strategies [36] in the TLC. (3) Study languages that combine list iterators and set iterators ala <ref> [6, 8, 7, 28] </ref>. One consequence of the limitations of computing on Church numerals was a focus on the expressive power of typed calculi with more primitives and more complex type disciplines.
Reference: 8. <author> V. Breazu-Tannen and R. Subrahmanyam. </author> <title> Logical and Computational Aspects of Programming with Sets/Bags/Lists. </title> <booktitle> In Proceedings of the 18th ICALP, </booktitle> <pages> pp. 60-75. </pages> <publisher> LNCS 510, Springer Verlag, </publisher> <year> 1991. </year>
Reference-contexts: In addition, extensions have been proposed to this framework to manipulate complex-object databases, based on high-order formulas over finite structures, e.g., [1, 2]. The study of functional database query languages is more recent, see <ref> [6, 8, 7, 28] </ref>, and is also part of the research on complex-object databases. In [23] we showed that TLC (without additions, but with different I/O conventions) can express exactly the ELEMENTARY database queries. The basic idea was to use the framework of finite model theory instead of Church numerals. <p> Some progress on this is reported in [25]. involving functional characterizations of other complexity classes, in particular PSPACE and EXPTIME. (2) Study optimal reduction strategies [36] in the TLC. (3) Study languages that combine list iterators and set iterators ala <ref> [6, 8, 7, 28] </ref>. One consequence of the limitations of computing on Church numerals was a focus on the expressive power of typed calculi with more primitives and more complex type disciplines.
Reference: 9. <author> A. Chandra and D. Harel. </author> <title> Structure and Complexity of Relational Queries. </title> <journal> J. Comput. System Sci., </journal> <volume> 25 (1982), </volume> <pages> pp. 99-128. </pages>
Reference-contexts: Relational algebra and fixpoint formulas over finite structures have been 4 From [41]: "The optimism in this term [ELEMENTARY] may seem a little over stated; the term was introduced in the context of undecidability." the principal vehicles of theoretical research in database query languages; see <ref> [13, 16, 9] </ref> for some of its earlier formulations. The main motivation has been that common relational database queries are expressible in relational calculus/algebra [13], Datalog : and various fixpoint logics [3, 32, 9, 10]. <p> The main motivation has been that common relational database queries are expressible in relational calculus/algebra [13], Datalog : and various fixpoint logics <ref> [3, 32, 9, 10] </ref>. Most importantly, as shown in [27, 47], every PTIME query can be expressed using fixpoints of first-order formulas on ordered structures; and, as shown in [3], it suffices to use Datalog : syntax under a variety of semantics to express various fixpoint logics. <p> In this section we will examine the expressibility of various TLI = i fragments of these languages. We will use expressibility results and terminology from the theory of database queries, e.g., <ref> [9] </ref>. We first argue that TLI = 0 can express relational algebra queries and then that TLI = 1 can express fixpoints (on ordered structures) or PTIME queries. It turns out, although we do not outline the argument here, that these are exact characterizations of these fragments, see [24, 25].
Reference: 10. <author> A. Chandra and D. Harel. </author> <title> Horn Clause Queries and Generalizations. </title> <journal> J. Logic Programming, </journal> <volume> 2 (1985), </volume> <pages> pp. 1-15. </pages>
Reference-contexts: The main motivation has been that common relational database queries are expressible in relational calculus/algebra [13], Datalog : and various fixpoint logics <ref> [3, 32, 9, 10] </ref>. Most importantly, as shown in [27, 47], every PTIME query can be expressed using fixpoints of first-order formulas on ordered structures; and, as shown in [3], it suffices to use Datalog : syntax under a variety of semantics to express various fixpoint logics.
Reference: 11. <author> A. Church. </author> <title> The Calculi of Lambda-Conversion. </title> <publisher> Princeton University Press, </publisher> <year> 1941. </year>
Reference-contexts: 1 Introduction The simply typed -calculus <ref> [11] </ref> (typed -calculus or TLC for short) with its syntax and beta-reduction operational semantics is an essential part of any functional programming language. <p> Research sup ported by NSF Grant CCR-9216185 and ONR Contract N00014-93-1-1015. For notational convenience, we use TLC = , the typed -calculus with atomic con-stants and an equality on them, and the associated delta-reduction of <ref> [4, 11] </ref>. For the necessary background on TLC see Section 2.1. We call Core-ML the "toy" language resulting from the addition of let-polymorphism to TLC = (see Section 2.2). <p> TLC and TLC = enjoy the following properties, see <ref> [11, 4] </ref>: Church-Rosser: If e ) e 0 and e ) e 00 , then there exists a -term e 000 such that e 0 ) e 000 and e 00 ) e 000 .
Reference: 12. <author> A. Cobham. </author> <title> The Intrinsic Computational Difficulty of Functions. </title> <editor> In Y. Bar-Hillel, editor, </editor> <booktitle> International Conference on Logic, Methodology, and Philosophy of Science, </booktitle> <pages> pp. 24-30. </pages> <publisher> North Holland, </publisher> <year> 1964. </year>
Reference-contexts: For example, order 5 suffices for the PTIME queries, even without let or equality. (Note that, in this sense equality is only a notational convenience). Since Cobham's early work there have been a number of interesting functional characterizations of PTIME, e.g., <ref> [12, 20, 19, 5, 35] </ref>. In Section 5.1 we add to this literature. In Section 5.2, we argue that fixed order type reconstruction is in polynomial time. This has some practical significance.
Reference: 13. <author> E. Codd. </author> <title> Relational Completeness of Database Sublanguages. </title> <editor> In R. Rustin, editor, </editor> <booktitle> Database Systems, </booktitle> <pages> pp. 65-98. </pages> <publisher> Prentice Hall, </publisher> <year> 1972. </year>
Reference-contexts: Relational algebra and fixpoint formulas over finite structures have been 4 From [41]: "The optimism in this term [ELEMENTARY] may seem a little over stated; the term was introduced in the context of undecidability." the principal vehicles of theoretical research in database query languages; see <ref> [13, 16, 9] </ref> for some of its earlier formulations. The main motivation has been that common relational database queries are expressible in relational calculus/algebra [13], Datalog : and various fixpoint logics [3, 32, 9, 10]. <p> The main motivation has been that common relational database queries are expressible in relational calculus/algebra <ref> [13] </ref>, Datalog : and various fixpoint logics [3, 32, 9, 10].
Reference: 14. <author> L. Damas and R. Milner. </author> <title> Principal Type Schemes for Functional Programs. </title> <booktitle> In Proceedings of the 9th ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pp. 207-212, </pages> <month> January </month> <year> 1982. </year>
Reference-contexts: ML's let-polymorphism is considered as one of the most successful definitions of polymorphism in programming languages and is widely used. Our TLC = primitives are part of every functional language. Note that, our TLC = definition is minimal, in the sense of not including the monomorphic fixpoints of ML <ref> [40, 14, 21] </ref>. The theme of our paper is: an exploration of the Core-ML language and a demonstration that, as far as "toy" languages go, this one has nontrivial expressive power and an interesting type reconstruction problem. <p> This connection has been in the folklore for some years and is now better understood [38]. We include a short, but self-contained description in Section 4.1. For a complete description of syntax and semantics we refer the reader to <ref> [40, 14, 29, 38] </ref>. The problem of Core-ML (TLC) type reconstruction is: "given a -term without any/some type annotations find if it is typable using the ML (TLC) typing rules". <p> Note the minimal element of T is 8t: t, since h8t: ti = T 0 . Expressions are associated with types using a fixed set of inference rules. We describe the standard standard inference system given by Damas and Milner <ref> [14] </ref> which we call the polytype system, as distinguished from the earlier-described monotype system. We want to identify exactly in what sense the implied restrictiveness of the monotype system is a constraint on expressiveness.
Reference: 15. <author> C. Dwork, P. C. Kanellakis, and J. C. Mitchell. </author> <title> On the Sequential Nature of Unification. </title> <journal> Journal of Logic Programming 1 (1984), </journal> <pages> pp. 35-50. </pages>
Reference-contexts: The problem of Core-ML (TLC) type reconstruction is: "given a -term without any/some type annotations find if it is typable using the ML (TLC) typing rules". For TLC this is an efficiently solvable problem in linear-time [48], by reduction to first-order unification <ref> [43, 15] </ref>, but it is also PTIME-complete. For Core-ML it is EXPTIME-complete in the size of the program typed, see [29, 30]. The proof sketch we present in Section 4.2 is based on [22]. <p> Dwork, Kanellakis, and Mitchell proved that first-order unification was complete for PTIME, by showing how unification on first-order terms could simulate circuits <ref> [15] </ref>; the proof followed by reduction from the Circuit Value Problem [34]. <p> As a consequence, type inference for the simply-typed case is complete for PTIME. By adding the polymorphic let and iterating its use, it is possible to write a program that generates a unification problem of exponential size. Bootstrapping the ideas of <ref> [15] </ref>, one may then simulate an exponential-size circuit and use standard complexity theory techniques [41]. For realism, we use genuine Standard ML scripts (with compiler-generated type information) to outline the proof, which can in fact be fully automated. <p> To avoid conflict with ML reserved words, examples using ML capitalize the names of declared functions. Unification is PTIME-complete We first show how the theorem of <ref> [15] </ref> could have been proved by writing an ML program using the half-century old, classic -calculus encodings of the logical operations. Here are Church's standard definitions of the Boolean constants and functions, coded in ML. The Standard ML compiler responds with typings of the expressions entered by the user. <p> -&gt; 'j -&gt; 'j) -&gt; 'k -&gt; ('l -&gt; 'm -&gt; 'm) -&gt; ((('n -&gt; ('u -&gt; 'v -&gt; 'v) -&gt; 'w) -&gt; 'w) -&gt; ('c -&gt; (('x -&gt; 'y -&gt; 'x) -&gt; 'z -&gt; -&gt; 'z -&gt; 'ba The type of Circuit is the equivalent of the construction in <ref> [15] </ref> of the circuit as a first-order term.
Reference: 16. <author> R. Fagin. </author> <title> Generalized First-Order Spectra and Polynomial-Time Recognizable Sets. </title> <booktitle> SIAM-AMS Proceedings, 7 (1974), </booktitle> <pages> pp. 43-73. </pages>
Reference-contexts: Relational algebra and fixpoint formulas over finite structures have been 4 From [41]: "The optimism in this term [ELEMENTARY] may seem a little over stated; the term was introduced in the context of undecidability." the principal vehicles of theoretical research in database query languages; see <ref> [13, 16, 9] </ref> for some of its earlier formulations. The main motivation has been that common relational database queries are expressible in relational calculus/algebra [13], Datalog : and various fixpoint logics [3, 32, 9, 10].
Reference: 17. <author> S. Fortune, D. Leivant, and M. O'Donnell. </author> <title> The Expressiveness of Simple and Second-Order Type Structures. </title> <journal> J. of the ACM, </journal> <volume> 30 (1983), </volume> <pages> pp. 151-185. </pages>
Reference-contexts: We include some of the basic expressibility analysis in Section3. For more details on the analysis of express-ibility we refer the reader to <ref> [44, 45, 17, 37, 23, 24, 25] </ref>. The expressive power of TLC was originally analyzed in terms of computations on simply typed Church numerals (see, e.g., [4, 17, 44]). Unfortunately, the simply typed Church numeral input-output convention imposes severe limitations on expressive power. <p> We include some of the basic expressibility analysis in Section3. For more details on the analysis of express-ibility we refer the reader to [44, 45, 17, 37, 23, 24, 25]. The expressive power of TLC was originally analyzed in terms of computations on simply typed Church numerals (see, e.g., <ref> [4, 17, 44] </ref>). Unfortunately, the simply typed Church numeral input-output convention imposes severe limitations on expressive power. Only a fragment of PTIME is expressible this way (called the extended polynomials) and this does not illustrate the full capabilities of TLC. <p> That more expressive power is possible follows from the fact that provably hard decision problems can be embedded in TLC, see [39, 45, 37], and that different typings allow exponentiation <ref> [17] </ref>. One way of expressing all of PTIME, while avoiding the anomalies associated with representations over Church numerals was recently demonstrated by Leivant and Marion [35]. <p> Remark: In the setting of these query languages input and output terms are monomorphically typed, i.e., they have simple types which are the same for all inputs/outputs. However, unlike <ref> [17, 44] </ref>, we allow that the monomorphic types of inputs and outputs differ. Outputs are always typed as o t k but inputs can be typed as o fl k . This convention is necessary for expressing all of PTIME. <p> The normal form of ( r 1 : : : r l ) can be computed in time and reductions polynomial in the size of r 1 ; : : : ; r l . 3.3 Elementary Functions = Core-ML In <ref> [17] </ref>, a bound is given that any -term of size s and order d has a normal form of size at most e (s; d) where e (a; 0) = a, e (a; b + 1) = 2 e (a;b) .
Reference: 18. <institution> J.-Y. Girard. Interpretation Fonctionnelle et Elimination des Coupures de l'Arithmetique d'Ordre Superieur. These de Doctorat d'Etat, Universite de Paris VII, </institution> <year> 1972. </year>
Reference-contexts: One consequence of the limitations of computing on Church numerals was a focus on the expressive power of typed calculi with more primitives and more complex type disciplines. Examples are the Girard-Reynolds second-order typed -calculus or System F <ref> [18, 42] </ref> (adding type polymorphism via type quantification) or Milner's ML [40] (adding monomorphic fixpoints and let-polymorphism).
Reference: 19. <author> J.-Y. Girard, A. Scedrov, P.J. Scott. </author> <title> Bounded Linear Logic: a Modular Approach to Polynomial Time Computatability. In Feasible Mathematics, </title> <editor> ed. Samuel R. Buss and Philip J. Scott, </editor> <booktitle> Birkhauser 1990, </booktitle> <pages> pp. 195-210. </pages>
Reference-contexts: For example, order 5 suffices for the PTIME queries, even without let or equality. (Note that, in this sense equality is only a notational convenience). Since Cobham's early work there have been a number of interesting functional characterizations of PTIME, e.g., <ref> [12, 20, 19, 5, 35] </ref>. In Section 5.1 we add to this literature. In Section 5.2, we argue that fixed order type reconstruction is in polynomial time. This has some practical significance.
Reference: 20. <author> Y. Gurevich. </author> <title> Algebras of Feasible Functions. </title> <booktitle> In Proc. of the 24th IEEE FOCS (1983), </booktitle> <pages> pp. 210-214. </pages>
Reference-contexts: For example, order 5 suffices for the PTIME queries, even without let or equality. (Note that, in this sense equality is only a notational convenience). Since Cobham's early work there have been a number of interesting functional characterizations of PTIME, e.g., <ref> [12, 20, 19, 5, 35] </ref>. In Section 5.1 we add to this literature. In Section 5.2, we argue that fixed order type reconstruction is in polynomial time. This has some practical significance.
Reference: 21. <author> R. Harper, R. Milner, M. Tofte. </author> <title> The Definition of Standard ML. </title> <publisher> MIT Press, </publisher> <year> 1990. </year>
Reference-contexts: For the necessary background on TLC see Section 2.1. We call Core-ML the "toy" language resulting from the addition of let-polymorphism to TLC = (see Section 2.2). The primary reason for studying Core-ML is that it seems to be the essential part of the (Standard) ML language <ref> [40, 21] </ref>. <p> ML's let-polymorphism is considered as one of the most successful definitions of polymorphism in programming languages and is widely used. Our TLC = primitives are part of every functional language. Note that, our TLC = definition is minimal, in the sense of not including the monomorphic fixpoints of ML <ref> [40, 14, 21] </ref>. The theme of our paper is: an exploration of the Core-ML language and a demonstration that, as far as "toy" languages go, this one has nontrivial expressive power and an interesting type reconstruction problem.
Reference: 22. <author> F. Henglein and H. G. Mairson. </author> <title> The Complexity of Type Inference for Higher-Order Typed Lambda Calculi. </title> <booktitle> In Proceedings of the 18th ACM Symposium on the Principles of Programming Languages, </booktitle> <pages> pp. 119-130, </pages> <month> January </month> <year> 1991. </year>
Reference-contexts: For TLC this is an efficiently solvable problem in linear-time [48], by reduction to first-order unification [43, 15], but it is also PTIME-complete. For Core-ML it is EXPTIME-complete in the size of the program typed, see [29, 30]. The proof sketch we present in Section 4.2 is based on <ref> [22] </ref>. Fixed Functionality: In [24, 25] we continued the investigation of expressibility and type reconstruction, but for low functionality orders. Fragments of Core-ML, based on the order of functionalities used, can be fairly expressive. <p> ffi 0 in let val ffi 2 = compose ffi 1 ffi 1 in : : : let val ffi k1 = compose ffi k2 ffi k2 in compose ffi k1 ffi k1 end end ... end 5 We omit the technical details of coding; the interested reader should consult <ref> [29, 22] </ref>. The function ffi k applies delta 2 k times to its argument, and moreover has a definition of length O (k). Notice that compose is used to compose a function with itself, even though the types of the domain and range of are different. <p> Recognizing the typable Core ML expressions is DTIME [2 n t ]-hard for any integer t 1 under logspace reduction. Proof. Using coding techniques described above (see <ref> [22, 29] </ref> for more details), we code in ML a transition function delta of an arbitrary Turing machine M , an arbitrary initial configuration initial-ID for M , and a function accept? where accept? ID has the type of True if ID codes an accepting ID of M , and has
Reference: 23. <author> G. Hillebrand, P. Kanellakis, and H. Mairson. </author> <title> Database Query Languages Embedded in the Typed Lambda Calculus. </title> <booktitle> In Proceedings of the 8th IEEE LICS (1993), </booktitle> <pages> pp. 332-343. </pages>
Reference-contexts: We include some of the basic expressibility analysis in Section3. For more details on the analysis of express-ibility we refer the reader to <ref> [44, 45, 17, 37, 23, 24, 25] </ref>. The expressive power of TLC was originally analyzed in terms of computations on simply typed Church numerals (see, e.g., [4, 17, 44]). Unfortunately, the simply typed Church numeral input-output convention imposes severe limitations on expressive power. <p> By augmenting the simply typed lambda calculus with a pairing operator and a "bottom tier" consisting of the free algebra of words over f0; 1g with associated constructor, destructor, and discriminator functions, they obtained various calculi for PTIME. In <ref> [23, 24, 25] </ref> we proposed and analysed a different approach to TLC (and Core-ML) expressibility. This is the approach we survey here. It is based on the theory of database queries or equivalently on finite model theory. Our framework is explained in detail in Sections 2.3-2.5. <p> In addition, extensions have been proposed to this framework to manipulate complex-object databases, based on high-order formulas over finite structures, e.g., [1, 2]. The study of functional database query languages is more recent, see [6, 8, 7, 28], and is also part of the research on complex-object databases. In <ref> [23] </ref> we showed that TLC (without additions, but with different I/O conventions) can express exactly the ELEMENTARY database queries. The basic idea was to use the framework of finite model theory instead of Church numerals. <p> However, some care is needed if one is to maintain typedness <ref> [23] </ref>. We briefly review how list iteration works. <p> The ones we use here are similar with those in <ref> [23] </ref>, but more economical in order of functionality. Inputs and outputs are encodings of a set of relations (or a first-order structure or a finite model or a database). Relations are represented as follows. <p> It turns out, although we do not outline the argument here, that these are exact characterizations of these fragments, see [24, 25]. By increasing the order of functionality one can express all ELEMENTARY queries and no other queries are expressible. 3.1 Embedding Relational Algebra in TLI = 0 In <ref> [23] </ref>, we showed how to express relational algebra (i.e., the operations of Select, Project, Difference, Union, Intersection, Times) using list iteration. Due to a different input/output format, our encodings involved -terms of order 5. <p> Due to a different input/output format, our encodings involved -terms of order 5. With straightforward modifications, these terms work under the present input/output conventions and the order drops down to 3. Here, we give the Cartesian product (Times) and Intersection operators as examples and refer the reader to <ref> [23] </ref> for the other operators. <p> In fact, the length of the reduction sequence typically matches the running time of a naive implementation of the operator in question. From <ref> [23] </ref>, we have the following theorem. Theorem 4. Let (R 1 ; : : : ; R l ) be a relational algebra expression over relational schema S = (R 1 ; : : :; R l ). <p> It is necessary to go to TLI = 1 so as to iterate mappings from relations to relations. 3.2 Embedding PTIME/Fixpoint Queries in TLI = 1 That TLI = 1 is sufficient to express the Fixpoint queries (and by [27, 47] the PTIME queries) follows from the encodings given in <ref> [23] </ref>, plus the fact that over a known domain, relations can be represented by order-one objects, namely characteristic functions. <p> As explained in <ref> [23] </ref>, additional care is necessary to make typable using monomorphic types. This is because the inputs R 1 ; : : : ; R l are used to iterate both over order-one objects (in Crank) and over order-zero objects (in Q). With monomorphic types, this is normally impossible. However, [23] shows <p> in <ref> [23] </ref>, additional care is necessary to make typable using monomorphic types. This is because the inputs R 1 ; : : : ; R l are used to iterate both over order-one objects (in Crank) and over order-zero objects (in Q). With monomorphic types, this is normally impossible. However, [23] shows how to get around this problem by introducing a "type-laundering" operator that essentially turns iterations over order-zero objects into iterations over order-one objects. By using this operator inside Q, the term becomes typable in the monomorphic type system. <p> The ELEMENTARY functions are those contained in union over d of DTIME [e (n; d)]. It follows that Core-ML can only express such functions. This is no real limitation, since all practical functions are ELEMENTARY and, as shown in <ref> [23] </ref>, all ELEMENTARY functions are expressible. This was shown using an alternative characterization of the Abiteboul-Beeri (AB) complex object algebra, [1]. Theorem 6.
Reference: 24. <author> G. Hillebrand, P. Kanellakis. </author> <title> Functional Database Query Languages as Typed Lambda Calculi of Fixed Order. </title> <booktitle> In Proceedings of the 13th ACM PODS (1994). </booktitle>
Reference-contexts: We include some of the basic expressibility analysis in Section3. For more details on the analysis of express-ibility we refer the reader to <ref> [44, 45, 17, 37, 23, 24, 25] </ref>. The expressive power of TLC was originally analyzed in terms of computations on simply typed Church numerals (see, e.g., [4, 17, 44]). Unfortunately, the simply typed Church numeral input-output convention imposes severe limitations on expressive power. <p> By augmenting the simply typed lambda calculus with a pairing operator and a "bottom tier" consisting of the free algebra of words over f0; 1g with associated constructor, destructor, and discriminator functions, they obtained various calculi for PTIME. In <ref> [23, 24, 25] </ref> we proposed and analysed a different approach to TLC (and Core-ML) expressibility. This is the approach we survey here. It is based on the theory of database queries or equivalently on finite model theory. Our framework is explained in detail in Sections 2.3-2.5. <p> Interestingly, it is possible to express all the PTIME queries so that this normalization process is polynomial in the input size. In <ref> [24, 25] </ref> these results were refined to fragments of Core-ML of low functionality. In our presentation we discuss relational algebra, using order 3 functionalities and equality (Section3.1) and fixpoint queries, using order 4 functionalities and equality (Section3.2). The ability to encode Powerset extends these results to ELEMENTARY (Section3.3). <p> For Core-ML it is EXPTIME-complete in the size of the program typed, see [29, 30]. The proof sketch we present in Section 4.2 is based on [22]. Fixed Functionality: In <ref> [24, 25] </ref> we continued the investigation of expressibility and type reconstruction, but for low functionality orders. Fragments of Core-ML, based on the order of functionalities used, can be fairly expressive. <p> Also, all inputs of this term can be typed with the same type. An analogous set of query languages: MLI = i (the languages of typed list iteration of order i + 3 with equality) can be defined using Core-ML instead TLC = and ML-typedness instead of typedness (see <ref> [24] </ref>). 3 Core-ML Expressibility Recall that Core-ML and TLC = have the same expressive power. In this section we will examine the expressibility of various TLI = i fragments of these languages. We will use expressibility results and terminology from the theory of database queries, e.g., [9]. <p> We first argue that TLI = 0 can express relational algebra queries and then that TLI = 1 can express fixpoints (on ordered structures) or PTIME queries. It turns out, although we do not outline the argument here, that these are exact characterizations of these fragments, see <ref> [24, 25] </ref>. By increasing the order of functionality one can express all ELEMENTARY queries and no other queries are expressible. 3.1 Embedding Relational Algebra in TLI = 0 In [23], we showed how to express relational algebra (i.e., the operations of Select, Project, Difference, Union, Intersection, Times) using list iteration. <p> This was just an example of the fair amount of flexibility provided by the let construct (which is a very common programming feature). The let construct is used in the various MLI's of <ref> [24] </ref> to receive the inputs, but also can be used in the body of the program. The occurrences of let in the program body can be eliminated by reduction at the expense of program body length [29].
Reference: 25. <author> G. Hillebrand. </author> <title> Finite Model Theory in the Simply Typed Lambda Calculus. </title> <type> PhD Thesis Brown Univ. </type> <year> (1994). </year>
Reference-contexts: We include some of the basic expressibility analysis in Section3. For more details on the analysis of express-ibility we refer the reader to <ref> [44, 45, 17, 37, 23, 24, 25] </ref>. The expressive power of TLC was originally analyzed in terms of computations on simply typed Church numerals (see, e.g., [4, 17, 44]). Unfortunately, the simply typed Church numeral input-output convention imposes severe limitations on expressive power. <p> By augmenting the simply typed lambda calculus with a pairing operator and a "bottom tier" consisting of the free algebra of words over f0; 1g with associated constructor, destructor, and discriminator functions, they obtained various calculi for PTIME. In <ref> [23, 24, 25] </ref> we proposed and analysed a different approach to TLC (and Core-ML) expressibility. This is the approach we survey here. It is based on the theory of database queries or equivalently on finite model theory. Our framework is explained in detail in Sections 2.3-2.5. <p> Interestingly, it is possible to express all the PTIME queries so that this normalization process is polynomial in the input size. In <ref> [24, 25] </ref> these results were refined to fragments of Core-ML of low functionality. In our presentation we discuss relational algebra, using order 3 functionalities and equality (Section3.1) and fixpoint queries, using order 4 functionalities and equality (Section3.2). The ability to encode Powerset extends these results to ELEMENTARY (Section3.3). <p> For Core-ML it is EXPTIME-complete in the size of the program typed, see [29, 30]. The proof sketch we present in Section 4.2 is based on [22]. Fixed Functionality: In <ref> [24, 25] </ref> we continued the investigation of expressibility and type reconstruction, but for low functionality orders. Fragments of Core-ML, based on the order of functionalities used, can be fairly expressive. <p> We first argue that TLI = 0 can express relational algebra queries and then that TLI = 1 can express fixpoints (on ordered structures) or PTIME queries. It turns out, although we do not outline the argument here, that these are exact characterizations of these fragments, see <ref> [24, 25] </ref>. By increasing the order of functionality one can express all ELEMENTARY queries and no other queries are expressible. 3.1 Embedding Relational Algebra in TLI = 0 In [23], we showed how to express relational algebra (i.e., the operations of Select, Project, Difference, Union, Intersection, Times) using list iteration. <p> Much is now known about expressibility, but some interesting problems remain open. (a) Determine the exact expressive power of the various fragments of Core-ML. Analogous results exist for higher orders in other languages see [31, 26, 33]. Some progress on this is reported in <ref> [25] </ref>. involving functional characterizations of other complexity classes, in particular PSPACE and EXPTIME. (2) Study optimal reduction strategies [36] in the TLC. (3) Study languages that combine list iterators and set iterators ala [6, 8, 7, 28].
Reference: 26. <author> R. Hull and J. Su. </author> <title> On the Expressive Power of Database Queries with Intermediate Types. </title> <journal> J. Comput. System Sci., </journal> <volume> 43 (1991), </volume> <pages> pp. 219-267. </pages>
Reference-contexts: Much is now known about expressibility, but some interesting problems remain open. (a) Determine the exact expressive power of the various fragments of Core-ML. Analogous results exist for higher orders in other languages see <ref> [31, 26, 33] </ref>. Some progress on this is reported in [25]. involving functional characterizations of other complexity classes, in particular PSPACE and EXPTIME. (2) Study optimal reduction strategies [36] in the TLC. (3) Study languages that combine list iterators and set iterators ala [6, 8, 7, 28].
Reference: 27. <author> N. Immerman. </author> <title> Relational Queries Computable in PTIME. </title> <journal> Info. and Comp., </journal> <volume> 68 (1986), </volume> <pages> pp. 86-104. </pages>
Reference-contexts: The main motivation has been that common relational database queries are expressible in relational calculus/algebra [13], Datalog : and various fixpoint logics [3, 32, 9, 10]. Most importantly, as shown in <ref> [27, 47] </ref>, every PTIME query can be expressed using fixpoints of first-order formulas on ordered structures; and, as shown in [3], it suffices to use Datalog : syntax under a variety of semantics to express various fixpoint logics. <p> It is necessary to go to TLI = 1 so as to iterate mappings from relations to relations. 3.2 Embedding PTIME/Fixpoint Queries in TLI = 1 That TLI = 1 is sufficient to express the Fixpoint queries (and by <ref> [27, 47] </ref> the PTIME queries) follows from the encodings given in [23], plus the fact that over a known domain, relations can be represented by order-one objects, namely characteristic functions.
Reference: 28. <author> N. Immerman, S. Patnaik, and D. Stemple. </author> <title> The Expressiveness of a Family of Finite Set Languages. </title> <booktitle> In Proceedings of the 10th ACM PODS (1991), </booktitle> <pages> pp. 37-52. </pages>
Reference-contexts: In addition, extensions have been proposed to this framework to manipulate complex-object databases, based on high-order formulas over finite structures, e.g., [1, 2]. The study of functional database query languages is more recent, see <ref> [6, 8, 7, 28] </ref>, and is also part of the research on complex-object databases. In [23] we showed that TLC (without additions, but with different I/O conventions) can express exactly the ELEMENTARY database queries. The basic idea was to use the framework of finite model theory instead of Church numerals. <p> Some progress on this is reported in [25]. involving functional characterizations of other complexity classes, in particular PSPACE and EXPTIME. (2) Study optimal reduction strategies [36] in the TLC. (3) Study languages that combine list iterators and set iterators ala <ref> [6, 8, 7, 28] </ref>. One consequence of the limitations of computing on Church numerals was a focus on the expressive power of typed calculi with more primitives and more complex type disciplines.
Reference: 29. <author> P. Kanellakis, H. Mairson, and J. Mitchell. </author> <title> Unification and ML-type Reconstruction. </title> <booktitle> In Computational Logic: Essays in Honor of Alan Robinson, </booktitle> <pages> pp. 444-478. </pages> <publisher> MIT Press, </publisher> <year> 1991. </year> <note> (Final version of: </note> <author> P. C. Kanellakis and J. C. Mitchell. </author> <title> Polymorphic Unification and ML Typing. </title> <booktitle> In Proceedings of the 16th ACM Symposium on the Principles of Programming Languages, </booktitle> <pages> pp. 105-115, </pages> <month> January </month> <year> 1989. </year> <editor> H. G. Mair-son. </editor> <title> Deciding ML Typability is Complete for Deterministic Exponential Time. </title> <booktitle> In Proceedings of the 17th ACM Symposium on the Principles of Programming Languages, </booktitle> <pages> pp. 382-401, </pages> <month> January </month> <year> 1990.) </year>
Reference-contexts: This connection has been in the folklore for some years and is now better understood [38]. We include a short, but self-contained description in Section 4.1. For a complete description of syntax and semantics we refer the reader to <ref> [40, 14, 29, 38] </ref>. The problem of Core-ML (TLC) type reconstruction is: "given a -term without any/some type annotations find if it is typable using the ML (TLC) typing rules". <p> For TLC this is an efficiently solvable problem in linear-time [48], by reduction to first-order unification [43, 15], but it is also PTIME-complete. For Core-ML it is EXPTIME-complete in the size of the program typed, see <ref> [29, 30] </ref>. The proof sketch we present in Section 4.2 is based on [22]. Fixed Functionality: In [24, 25] we continued the investigation of expressibility and type reconstruction, but for low functionality orders. Fragments of Core-ML, based on the order of functionalities used, can be fairly expressive. <p> Also, given &gt; E: t 0 it is decidable if this statement is derivable by the above rules. (Both these algorithms use first-order unification, e.g., see <ref> [29] </ref> and reconstruct types. They work with or without type annotations and with or without constants in the 's). <p> ML-typedness: This involves the same monomorphic types and inference rules for TLC and the constants used for TLC = , with one additional rule that captures some polymorphism (see <ref> [29] </ref>): (let M ) &gt; let x = E in B: t We call a -term E ML-typed if &gt; E: t 0 is derivable by the inference rules (var M ), (abs M ), (app M ), (let M ) for some and t 0 . <p> Note that, Core-ML has all the properties of TLC = , i.e., Church-Rosser, Strong Normalization, Principal Type and Type Reconstruction. There is only one difference: Type reconstruction is no longer in linear-time but EXPTIME-complete <ref> [29, 30] </ref>. 2.3 Functionality Order For a finer analysis of expressibility we partition types according to functionality order. <p> Note that in the case of a closed term E with empty contexts, we have ` P ; &gt; E: t iff ` M ; &gt; E: t , as in <ref> [29] </ref>. However, inspired by the example of Tait's strong normalization theorem for the first order typed -calculus [46], we facilitate the proof by strengthening the induction hypothesis of what is to be a syntax directed induction on E. <p> True) (Pair False False); val Fanout = fn : (((('a -&gt; 'b -&gt; 'a) -&gt; ('c -&gt; 'd -&gt; 'c) -&gt; 'e) -&gt; 'e) -&gt; ((('f -&gt; 'g -&gt; 'g) -&gt; ('h -&gt; 'i -&gt; 'i) -&gt; 'j) -&gt; 'j) -&gt; 'k) -&gt; 'k The importance of Fanout, as in <ref> [29] </ref>, is that it produces two copies of a logic value which do not share type variables. <p> ffi 0 in let val ffi 2 = compose ffi 1 ffi 1 in : : : let val ffi k1 = compose ffi k2 ffi k2 in compose ffi k1 ffi k1 end end ... end 5 We omit the technical details of coding; the interested reader should consult <ref> [29, 22] </ref>. The function ffi k applies delta 2 k times to its argument, and moreover has a definition of length O (k). Notice that compose is used to compose a function with itself, even though the types of the domain and range of are different. <p> Recognizing the typable Core ML expressions is DTIME [2 n t ]-hard for any integer t 1 under logspace reduction. Proof. Using coding techniques described above (see <ref> [22, 29] </ref> for more details), we code in ML a transition function delta of an arbitrary Turing machine M , an arbitrary initial configuration initial-ID for M , and a function accept? where accept? ID has the type of True if ID codes an accepting ID of M , and has <p> The let construct is used in the various MLI's of [24] to receive the inputs, but also can be used in the body of the program. The occurrences of let in the program body can be eliminated by reduction at the expense of program body length <ref> [29] </ref>. A problem with use of let in the program body is that type inference may become inefficient. We show, however, that the fixed order restriction can be used to eliminate this inefficiency. Theorem 12.
Reference: 30. <author> A. Kfoury, J. Tiuryn, and P. Urzyczyn. </author> <title> An Analysis of ML Typability. </title> <booktitle> In Proceedings 17th Colloquium on Trees, Algebra and Programming, </booktitle> <pages> pp. 206-220. </pages> <publisher> LNCS 431, Springer Verlag, </publisher> <year> 1990. </year>
Reference-contexts: For TLC this is an efficiently solvable problem in linear-time [48], by reduction to first-order unification [43, 15], but it is also PTIME-complete. For Core-ML it is EXPTIME-complete in the size of the program typed, see <ref> [29, 30] </ref>. The proof sketch we present in Section 4.2 is based on [22]. Fixed Functionality: In [24, 25] we continued the investigation of expressibility and type reconstruction, but for low functionality orders. Fragments of Core-ML, based on the order of functionalities used, can be fairly expressive. <p> Note that, Core-ML has all the properties of TLC = , i.e., Church-Rosser, Strong Normalization, Principal Type and Type Reconstruction. There is only one difference: Type reconstruction is no longer in linear-time but EXPTIME-complete <ref> [29, 30] </ref>. 2.3 Functionality Order For a finer analysis of expressibility we partition types according to functionality order.
Reference: 31. <author> A. Kfoury, J. Tiuryn, and P. Urzyczyn. </author> <title> The Hierarchy of Finitely Typed Functional Programs. </title> <booktitle> In Proceedings 2nd IEEE LICS (1987), </booktitle> <pages> pp. 225-235. </pages>
Reference-contexts: Much is now known about expressibility, but some interesting problems remain open. (a) Determine the exact expressive power of the various fragments of Core-ML. Analogous results exist for higher orders in other languages see <ref> [31, 26, 33] </ref>. Some progress on this is reported in [25]. involving functional characterizations of other complexity classes, in particular PSPACE and EXPTIME. (2) Study optimal reduction strategies [36] in the TLC. (3) Study languages that combine list iterators and set iterators ala [6, 8, 7, 28].
Reference: 32. <author> P. Kolaitis and C. Papadimitriou. </author> <title> Why Not Negation By Fixpoint? J. </title> <journal> Comput. System Sci., </journal> <volume> 43 (1991), </volume> <pages> pp. 125-144. </pages>
Reference-contexts: The main motivation has been that common relational database queries are expressible in relational calculus/algebra [13], Datalog : and various fixpoint logics <ref> [3, 32, 9, 10] </ref>. Most importantly, as shown in [27, 47], every PTIME query can be expressed using fixpoints of first-order formulas on ordered structures; and, as shown in [3], it suffices to use Datalog : syntax under a variety of semantics to express various fixpoint logics.
Reference: 33. <author> G. Kuper and M. Vardi. </author> <title> On the Complexity of Queries in the Logical Data Model. </title> <journal> Theoretical Comput. Sci., </journal> <volume> 116 (1993), </volume> <pages> pp. 33-57. </pages>
Reference-contexts: Much is now known about expressibility, but some interesting problems remain open. (a) Determine the exact expressive power of the various fragments of Core-ML. Analogous results exist for higher orders in other languages see <ref> [31, 26, 33] </ref>. Some progress on this is reported in [25]. involving functional characterizations of other complexity classes, in particular PSPACE and EXPTIME. (2) Study optimal reduction strategies [36] in the TLC. (3) Study languages that combine list iterators and set iterators ala [6, 8, 7, 28].
Reference: 34. <author> R. E. Ladner. </author> <title> The Circuit Value Problem is Logspace Complete for P. </title> <journal> SIGACT News 7:1, </journal> <year> 1975, </year> <pages> pp. 18-20. </pages>
Reference-contexts: Dwork, Kanellakis, and Mitchell proved that first-order unification was complete for PTIME, by showing how unification on first-order terms could simulate circuits [15]; the proof followed by reduction from the Circuit Value Problem <ref> [34] </ref>. Type inference for ML programs without let (equivalently, simply-typed lambda calculus) is easily reduced to first-order unification, where a program is transformed to a unification problem of size linear in the size of the original program [48] and vice versa.
Reference: 35. <author> D. Leivant and J.-Y. Marion. </author> <title> Lambda Calculus Characterizations of Poly-Time. </title> <booktitle> In Proc. of the Inter. Conf. on Typed Lambda Calculi and Applications, </booktitle> <address> Utrecht 1993. </address> <note> (To appear in Fundamenta Informaticae.) </note>
Reference-contexts: One way of expressing all of PTIME, while avoiding the anomalies associated with representations over Church numerals was recently demonstrated by Leivant and Marion <ref> [35] </ref>. By augmenting the simply typed lambda calculus with a pairing operator and a "bottom tier" consisting of the free algebra of words over f0; 1g with associated constructor, destructor, and discriminator functions, they obtained various calculi for PTIME. <p> For example, order 5 suffices for the PTIME queries, even without let or equality. (Note that, in this sense equality is only a notational convenience). Since Cobham's early work there have been a number of interesting functional characterizations of PTIME, e.g., <ref> [12, 20, 19, 5, 35] </ref>. In Section 5.1 we add to this literature. In Section 5.2, we argue that fixed order type reconstruction is in polynomial time. This has some practical significance.
Reference: 36. <author> J.-J. Levy. </author> <title> Optimal Reductions in the Lambda-Calculus. </title> <editor> In J. Seldin and J. Hindley, editors, To H. B. </editor> <booktitle> Curry: Essays in Combinatory Logic, Lambda Calculus and Formalism, </booktitle> <pages> pp. 159-191. </pages> <publisher> Academic Press, </publisher> <year> 1980. </year>
Reference-contexts: Analogous results exist for higher orders in other languages see [31, 26, 33]. Some progress on this is reported in [25]. involving functional characterizations of other complexity classes, in particular PSPACE and EXPTIME. (2) Study optimal reduction strategies <ref> [36] </ref> in the TLC. (3) Study languages that combine list iterators and set iterators ala [6, 8, 7, 28]. One consequence of the limitations of computing on Church numerals was a focus on the expressive power of typed calculi with more primitives and more complex type disciplines.
Reference: 37. <author> H.G. Mairson. </author> <title> A Simple Proof of a Theorem of Statman. </title> <journal> TCS, </journal> <volume> 103 (1992), </volume> <pages> pp. 387-394. </pages>
Reference-contexts: We include some of the basic expressibility analysis in Section3. For more details on the analysis of express-ibility we refer the reader to <ref> [44, 45, 17, 37, 23, 24, 25] </ref>. The expressive power of TLC was originally analyzed in terms of computations on simply typed Church numerals (see, e.g., [4, 17, 44]). Unfortunately, the simply typed Church numeral input-output convention imposes severe limitations on expressive power. <p> Only a fragment of PTIME is expressible this way (called the extended polynomials) and this does not illustrate the full capabilities of TLC. That more expressive power is possible follows from the fact that provably hard decision problems can be embedded in TLC, see <ref> [39, 45, 37] </ref>, and that different typings allow exponentiation [17]. One way of expressing all of PTIME, while avoiding the anomalies associated with representations over Church numerals was recently demonstrated by Leivant and Marion [35]. <p> M ), (abs M ), (app M ), (let M ) but with all types restricted to order k. 2.4 The Basic Programming Technique: List Iteration List iteration is a powerful programming technique, which can be used in the context of TLC and TLC = to encode any elementary recursion <ref> [45, 37] </ref>. However, some care is needed if one is to maintain typedness [23]. We briefly review how list iteration works.
Reference: 38. <author> H. G. Mairson. </author> <title> Quantifier Elimination and Parametric Polymorphism in Program--ming Languages. </title> <editor> J. </editor> <booktitle> Functional Programming bf 2:2 (April 1992), </booktitle> <pages> pp. 213-226. </pages>
Reference-contexts: The ability to encode Powerset extends these results to ELEMENTARY (Section3.3). Type Reconstruction: There is a subtle connection between let-polymorphism in ML and monomorphism, which we use here as a definition. This connection has been in the folklore for some years and is now better understood <ref> [38] </ref>. We include a short, but self-contained description in Section 4.1. For a complete description of syntax and semantics we refer the reader to [40, 14, 29, 38]. <p> This connection has been in the folklore for some years and is now better understood [38]. We include a short, but self-contained description in Section 4.1. For a complete description of syntax and semantics we refer the reader to <ref> [40, 14, 29, 38] </ref>. The problem of Core-ML (TLC) type reconstruction is: "given a -term without any/some type annotations find if it is typable using the ML (TLC) typing rules". <p> We first introduce a standard structural lemma allowing us to "normalize" derivations in the polytype system for use in a syntax-directed proof. See, for example, <ref> [38] </ref> for the proof. Lemma 8. Let ` P &gt; E: 8: t where is a context, t is a monotype, and 8 denotes a (possibly empty) list of quantified variables.
Reference: 39. <author> A. R. Meyer. </author> <title> The Inherent Computational Complexity of Theories of Ordered Sets. </title> <booktitle> Proceedings of the International Congress of Mathematicians, </booktitle> <year> 1974, </year> <pages> pp. 477-482. </pages>
Reference-contexts: Only a fragment of PTIME is expressible this way (called the extended polynomials) and this does not illustrate the full capabilities of TLC. That more expressive power is possible follows from the fact that provably hard decision problems can be embedded in TLC, see <ref> [39, 45, 37] </ref>, and that different typings allow exponentiation [17]. One way of expressing all of PTIME, while avoiding the anomalies associated with representations over Church numerals was recently demonstrated by Leivant and Marion [35].
Reference: 40. <author> R. Milner. </author> <title> A Theory of Type Polymorphism in Programming. </title> <journal> J. Comput. System Sci., </journal> <volume> 17 (1978), </volume> <pages> pp. 348-375. </pages>
Reference-contexts: For the necessary background on TLC see Section 2.1. We call Core-ML the "toy" language resulting from the addition of let-polymorphism to TLC = (see Section 2.2). The primary reason for studying Core-ML is that it seems to be the essential part of the (Standard) ML language <ref> [40, 21] </ref>. <p> ML's let-polymorphism is considered as one of the most successful definitions of polymorphism in programming languages and is widely used. Our TLC = primitives are part of every functional language. Note that, our TLC = definition is minimal, in the sense of not including the monomorphic fixpoints of ML <ref> [40, 14, 21] </ref>. The theme of our paper is: an exploration of the Core-ML language and a demonstration that, as far as "toy" languages go, this one has nontrivial expressive power and an interesting type reconstruction problem. <p> This connection has been in the folklore for some years and is now better understood [38]. We include a short, but self-contained description in Section 4.1. For a complete description of syntax and semantics we refer the reader to <ref> [40, 14, 29, 38] </ref>. The problem of Core-ML (TLC) type reconstruction is: "given a -term without any/some type annotations find if it is typable using the ML (TLC) typing rules". <p> One consequence of the limitations of computing on Church numerals was a focus on the expressive power of typed calculi with more primitives and more complex type disciplines. Examples are the Girard-Reynolds second-order typed -calculus or System F [18, 42] (adding type polymorphism via type quantification) or Milner's ML <ref> [40] </ref> (adding monomorphic fixpoints and let-polymorphism). However, the expressibility analysis here indicates that the case for more powerful programming languages should be made on the basis of flexibility and not expressibility (since all PTIME queries can be representable in TLC).
Reference: 41. <author> C.H. Papadimitriou. </author> <title> Computational Complexity. </title> <publisher> Addison Wesley, </publisher> <year> 1994. </year>
Reference-contexts: Expressive Power: The computations expressed in Core-ML (or TLC) are all ELEMENTARY functions (where this class of functions includes PTIME, NP, PSPACE, EXPTIME, 2-EXPTIME etc, see <ref> [41] </ref>) 4 . We include some of the basic expressibility analysis in Section3. For more details on the analysis of express-ibility we refer the reader to [44, 45, 17, 37, 23, 24, 25]. <p> This is the approach we survey here. It is based on the theory of database queries or equivalently on finite model theory. Our framework is explained in detail in Sections 2.3-2.5. Relational algebra and fixpoint formulas over finite structures have been 4 From <ref> [41] </ref>: "The optimism in this term [ELEMENTARY] may seem a little over stated; the term was introduced in the context of undecidability." the principal vehicles of theoretical research in database query languages; see [13, 16, 9] for some of its earlier formulations. <p> By adding the polymorphic let and iterating its use, it is possible to write a program that generates a unification problem of exponential size. Bootstrapping the ideas of [15], one may then simulate an exponential-size circuit and use standard complexity theory techniques <ref> [41] </ref>. For realism, we use genuine Standard ML scripts (with compiler-generated type information) to outline the proof, which can in fact be fully automated.
Reference: 42. <author> J. C. Reynolds. </author> <title> Towards a Theory of Type Structure. </title> <booktitle> In Proceedings of the Paris Colloquium on Programming, Lecture Notes in Computer Science 19, </booktitle> <publisher> Springer Ver-lag, </publisher> <pages> pp. 408-425, </pages> <year> 1974. </year>
Reference-contexts: One consequence of the limitations of computing on Church numerals was a focus on the expressive power of typed calculi with more primitives and more complex type disciplines. Examples are the Girard-Reynolds second-order typed -calculus or System F <ref> [18, 42] </ref> (adding type polymorphism via type quantification) or Milner's ML [40] (adding monomorphic fixpoints and let-polymorphism).
Reference: 43. <author> J. A. Robinson. </author> <title> A Machine Oriented Logic Based on the Resolution Principle. </title> <journal> Journal of the ACM 12:1 (1965), </journal> <pages> pp. 23-41. </pages>
Reference-contexts: The problem of Core-ML (TLC) type reconstruction is: "given a -term without any/some type annotations find if it is typable using the ML (TLC) typing rules". For TLC this is an efficiently solvable problem in linear-time [48], by reduction to first-order unification <ref> [43, 15] </ref>, but it is also PTIME-complete. For Core-ML it is EXPTIME-complete in the size of the program typed, see [29, 30]. The proof sketch we present in Section 4.2 is based on [22].
Reference: 44. <author> H. Schwichtenberg. </author> <title> Definierbare Funktionen im -Kalkul mit Typen. </title> <journal> Archiv fur mathematische Logik und Grundlagenforschung, </journal> <volume> 17 (1976), </volume> <pages> pp. 113-114. </pages>
Reference-contexts: We include some of the basic expressibility analysis in Section3. For more details on the analysis of express-ibility we refer the reader to <ref> [44, 45, 17, 37, 23, 24, 25] </ref>. The expressive power of TLC was originally analyzed in terms of computations on simply typed Church numerals (see, e.g., [4, 17, 44]). Unfortunately, the simply typed Church numeral input-output convention imposes severe limitations on expressive power. <p> We include some of the basic expressibility analysis in Section3. For more details on the analysis of express-ibility we refer the reader to [44, 45, 17, 37, 23, 24, 25]. The expressive power of TLC was originally analyzed in terms of computations on simply typed Church numerals (see, e.g., <ref> [4, 17, 44] </ref>). Unfortunately, the simply typed Church numeral input-output convention imposes severe limitations on expressive power. Only a fragment of PTIME is expressible this way (called the extended polynomials) and this does not illustrate the full capabilities of TLC. <p> Remark: In the setting of these query languages input and output terms are monomorphically typed, i.e., they have simple types which are the same for all inputs/outputs. However, unlike <ref> [17, 44] </ref>, we allow that the monomorphic types of inputs and outputs differ. Outputs are always typed as o t k but inputs can be typed as o fl k . This convention is necessary for expressing all of PTIME.
Reference: 45. <author> R. Statman. </author> <title> The Typed -Calculus is not Elementary Recursive. </title> <journal> Theoretical Computer Sci., </journal> <volume> 9 (1979), </volume> <pages> pp. 73-81. </pages>
Reference-contexts: We include some of the basic expressibility analysis in Section3. For more details on the analysis of express-ibility we refer the reader to <ref> [44, 45, 17, 37, 23, 24, 25] </ref>. The expressive power of TLC was originally analyzed in terms of computations on simply typed Church numerals (see, e.g., [4, 17, 44]). Unfortunately, the simply typed Church numeral input-output convention imposes severe limitations on expressive power. <p> Only a fragment of PTIME is expressible this way (called the extended polynomials) and this does not illustrate the full capabilities of TLC. That more expressive power is possible follows from the fact that provably hard decision problems can be embedded in TLC, see <ref> [39, 45, 37] </ref>, and that different typings allow exponentiation [17]. One way of expressing all of PTIME, while avoiding the anomalies associated with representations over Church numerals was recently demonstrated by Leivant and Marion [35]. <p> M ), (abs M ), (app M ), (let M ) but with all types restricted to order k. 2.4 The Basic Programming Technique: List Iteration List iteration is a powerful programming technique, which can be used in the context of TLC and TLC = to encode any elementary recursion <ref> [45, 37] </ref>. However, some care is needed if one is to maintain typedness [23]. We briefly review how list iteration works.
Reference: 46. <author> W. W. Tait. </author> <title> Intensional Interpretation of Functionals of Finite Type I. </title> <journal> J. Symbolic Logic 32 (1967) pp. </journal> <pages> 198-212. </pages>
Reference-contexts: Note that in the case of a closed term E with empty contexts, we have ` P ; &gt; E: t iff ` M ; &gt; E: t , as in [29]. However, inspired by the example of Tait's strong normalization theorem for the first order typed -calculus <ref> [46] </ref>, we facilitate the proof by strengthening the induction hypothesis of what is to be a syntax directed induction on E. We first introduce a standard structural lemma allowing us to "normalize" derivations in the polytype system for use in a syntax-directed proof. See, for example, [38] for the proof.
Reference: 47. <author> M.Y. Vardi. </author> <title> The Complexity of Relational Query Languages. </title> <booktitle> In Proceedings of the 14th ACM STOC (1982), </booktitle> <pages> pp. 137-146. </pages>
Reference-contexts: The main motivation has been that common relational database queries are expressible in relational calculus/algebra [13], Datalog : and various fixpoint logics [3, 32, 9, 10]. Most importantly, as shown in <ref> [27, 47] </ref>, every PTIME query can be expressed using fixpoints of first-order formulas on ordered structures; and, as shown in [3], it suffices to use Datalog : syntax under a variety of semantics to express various fixpoint logics. <p> It is necessary to go to TLI = 1 so as to iterate mappings from relations to relations. 3.2 Embedding PTIME/Fixpoint Queries in TLI = 1 That TLI = 1 is sufficient to express the Fixpoint queries (and by <ref> [27, 47] </ref> the PTIME queries) follows from the encodings given in [23], plus the fact that over a known domain, relations can be represented by order-one objects, namely characteristic functions.
Reference: 48. <author> M. Wand. </author> <title> A Simple Algorithm and Proof for Type Inference. Fundamenta Infor-maticae 10 (1987). This article was processed using the L a T E X macro package with LLNCS style </title>
Reference-contexts: The problem of Core-ML (TLC) type reconstruction is: "given a -term without any/some type annotations find if it is typable using the ML (TLC) typing rules". For TLC this is an efficiently solvable problem in linear-time <ref> [48] </ref>, by reduction to first-order unification [43, 15], but it is also PTIME-complete. For Core-ML it is EXPTIME-complete in the size of the program typed, see [29, 30]. The proof sketch we present in Section 4.2 is based on [22]. <p> Type inference for ML programs without let (equivalently, simply-typed lambda calculus) is easily reduced to first-order unification, where a program is transformed to a unification problem of size linear in the size of the original program <ref> [48] </ref> and vice versa. As a consequence, type inference for the simply-typed case is complete for PTIME. By adding the polymorphic let and iterating its use, it is possible to write a program that generates a unification problem of exponential size.
References-found: 48

