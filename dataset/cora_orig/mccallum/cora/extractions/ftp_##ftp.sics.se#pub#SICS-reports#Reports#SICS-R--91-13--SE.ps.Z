URL: ftp://ftp.sics.se/pub/SICS-reports/Reports/SICS-R--91-13--SE.ps.Z
Refering-URL: http://www.sics.se/libindex.html
Root-URL: 
Title: The External Storage Facility in SICStus Prolog Abstract The SICStus Prolog External Database implements an
Author: Hans Nilsson 
Note: are given.  
Date: 19 October 1995  
Address: Box 1263, S-164 28 Kista, Sweden  ELLEMTEL AB Box 1505, S-125 25 Alvsjo, Sweden  
Affiliation: Swedish Institute of Computer Science, SICS  and  
Pubnum: R91:13  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> Mats Carlsson et al. </author> <title> Industrial SICStus Prolog User's Manual. </title> <institution> Swedish Institute of Computer Science, </institution> <year> 1990. </year>
Reference-contexts: 1 Introduction This work is a part of the project Industrialization of SICStus Prolog <ref> [1] </ref> which is a project aiming at making an industrial quality prolog system. The part External Database has as goal to make a "continuation of the Prolog database out onto the disk". That is, to be able to handle disk storage of Prolog terms efficiently. <p> That is, to be able to handle disk storage of Prolog terms efficiently. The goals of this report is twofold, namely to: 1. describe the method and to give some performance results 2. describe the implementation The user interface to the database is described in <ref> [1] </ref> 2 Background There are two common ways of enhancing a Prolog with an external database: * Attaching an existing DBMS (Data Base Managment System) to Prolog. * Making a special handler, integrated with the Prolog system.
Reference: [2] <author> Robert M. Colomb. </author> <title> Enhancing unification in prolog through clause indexing. </title> <journal> Journal of Logic Programming, </journal> <volume> 10 </volume> <pages> 23-24, </pages> <year> 1991. </year>
Reference-contexts: the argument: C (f (a; b; C)) (The function C with a Prolog term as argument) or C (a i ). * The symbol is a binary operator combining two keys into one. 4 The Design The SICStus external database uses a modified version of the superimposed codewords in NU-Prolog <ref> [10, 2] </ref> and dynamic hashing (survey in [5]). 4.1 Superimposed Codewords Superimposed Codewords is a way resembling hash coding of making integer keys to compound terms [7].
Reference: [3] <institution> Department of Computer Science, University of Melbourne. NU-Prolog, </institution> <note> Reference Manual, </note> <month> May </month> <year> 1987. </year>
Reference-contexts: We can however write programs that uses full Prolog terms containing variables, lists structures etc. The indexing mechanism could be made more flexible and take care of the special Prolog situation. This approach is taken in NU-Prolog <ref> [3] </ref>. Other work include Aditi [11] were they build a deductive DBMS with a Prolog-like query language. SICStus already has an interface to the DBMS Oracle [9]. This report describes the special database handler that was developed for SICStus.
Reference: [4] <author> Christoph Draxler. </author> <title> Logic programming and databases. </title> <type> Technical Report 90.09, </type> <institution> In-stitut fur Informatik der Universitat Zurich, </institution> <month> September </month> <year> 1990. </year>
Reference-contexts: If an argument is a Prolog variable or a structure, it is very difficult to represent that in the database. In practice, one is limited to using structures with atoms as arguments. An overview of Prologs attached to DBMSs can be found in <ref> [4] </ref>. The other method | making a special handler | gives the possibility of using any Prolog term giving the power of a general language. However, we miss the great development efforts already put into DBMS and we can't process already existing data.
Reference: [5] <author> R.J. Enbody and H.C. Du. </author> <title> Dynamic hashing schemes. </title> <journal> ACM Computing Surveys, </journal> <volume> 20(2), </volume> <month> June </month> <year> 1988. </year>
Reference-contexts: (The function C with a Prolog term as argument) or C (a i ). * The symbol is a binary operator combining two keys into one. 4 The Design The SICStus external database uses a modified version of the superimposed codewords in NU-Prolog [10, 2] and dynamic hashing (survey in <ref> [5] </ref>). 4.1 Superimposed Codewords Superimposed Codewords is a way resembling hash coding of making integer keys to compound terms [7]. <p> The operators = bitwise OR and f = bitwise AND fulfills the requirements (equations 1 and 2) above because f OR (a OR b; a) = (a OR b) AND a = true. 2 4.2 Dynamic Hashing Dynamic Hashing <ref> [6, 5] </ref> is a collection of methods for dynamically changing hash coding schemes when the table grows. This is done without rehashing of the old contents. In figure 1 is the principle of a directory based scheme shown. This is the basic idea for the version in SICStus. <p> When a bucket is full, if the local depth is less than the global depth the bucket will be split, otherwise the directory will expand. In <ref> [5] </ref> more details are presented as well as some more efficient directory-less methods. 4.3 The algorithm in SICStus 4.3.1 Modifications to the Superimposed Codewords Algorithm In SICStus, the algorithm is modified in the following way: * When storing a term, all possible query keys are generated by replacing non-variables with variables <p> In diagram 1 (appendix D) we can see that the indexing time is nearly constant regardless of the database size. This shows that the dynamic hashing performs well. Since the time is almost constant, there is probably no need for a directory-less <ref> [5] </ref> approach of the dynamic hashing. 6.2 The Hardware All tests except the Oracle timings are done on the same machine. The machine is a SUN-3/60 with 8 Mbyte memory and a local disk.
Reference: [6] <author> R. Fagin et al. </author> <title> Extendible hashing a fast access method for dynamic files. </title> <journal> ACM Transaction on Database System, </journal> <volume> 4, </volume> <month> September </month> <year> 1979. </year>
Reference-contexts: The operators = bitwise OR and f = bitwise AND fulfills the requirements (equations 1 and 2) above because f OR (a OR b; a) = (a OR b) AND a = true. 2 4.2 Dynamic Hashing Dynamic Hashing <ref> [6, 5] </ref> is a collection of methods for dynamically changing hash coding schemes when the table grows. This is done without rehashing of the old contents. In figure 1 is the principle of a directory based scheme shown. This is the basic idea for the version in SICStus.
Reference: [7] <author> Donald E. Knuth. </author> <title> The Art of Computer Programming, volume 3, Sorting and Searching. </title> <publisher> Addison-Wesley Publishing Company, </publisher> <year> 1973. </year>
Reference-contexts: binary operator combining two keys into one. 4 The Design The SICStus external database uses a modified version of the superimposed codewords in NU-Prolog [10, 2] and dynamic hashing (survey in [5]). 4.1 Superimposed Codewords Superimposed Codewords is a way resembling hash coding of making integer keys to compound terms <ref> [7] </ref>. It works briefly in the following way in NU-Prolog [10] (which is modified in the SICStus External Database): the key is formed out of many components in the stored item in such a way that one can later check if some component was present.
Reference: [8] <author> Donald E. Knuth. </author> <booktitle> The Art of Computer Programming, </booktitle> <volume> volume 1. </volume> <publisher> Addison-Wesley Publishing Company, </publisher> <year> 1973. </year>
Reference-contexts: The terms were different from the other tests: test (abc0), test (abc1) : : : test (abc6000). The Specification was on (on). The tested algorithms were: * Just the sum of ascii values. This is expected to be poor <ref> [8] </ref>. * The product of the ascii values. This should be better since the values are uniformly distributed ([8]). * The sum used as seed for a pseudo random number generator. This was proposed in [10].
Reference: [9] <author> Rob Lucas. </author> <title> Manual for a prolog-oracle link. </title> <booktitle> Unknown title. </booktitle>
Reference-contexts: The indexing mechanism could be made more flexible and take care of the special Prolog situation. This approach is taken in NU-Prolog [3]. Other work include Aditi [11] were they build a deductive DBMS with a Prolog-like query language. SICStus already has an interface to the DBMS Oracle <ref> [9] </ref>. This report describes the special database handler that was developed for SICStus. Note that the SICStus External Database is optimized for retrieving one tuple a time, while relational DBMS retreives a whole relation.
Reference: [10] <author> Kotagiri Ramamohanarao and John Shepard. </author> <title> A superimposed codeword indexing scheme for very large prolog databases. </title> <booktitle> In Proceedings of the third International Conference of Logic Programming, </booktitle> <month> July </month> <year> 1986. </year>
Reference-contexts: the argument: C (f (a; b; C)) (The function C with a Prolog term as argument) or C (a i ). * The symbol is a binary operator combining two keys into one. 4 The Design The SICStus external database uses a modified version of the superimposed codewords in NU-Prolog <ref> [10, 2] </ref> and dynamic hashing (survey in [5]). 4.1 Superimposed Codewords Superimposed Codewords is a way resembling hash coding of making integer keys to compound terms [7]. <p> It works briefly in the following way in NU-Prolog <ref> [10] </ref> (which is modified in the SICStus External Database): the key is formed out of many components in the stored item in such a way that one can later check if some component was present. <p> The stored codewords are investigated to find out the set of potential matches and they are read on backtracking to find the terms which actually unifies the query. In <ref> [10] </ref> some optimizations are described which improves this linear search strategy significantly. Example 1: Codewords. Assume the term is f (a (1)) with indexing on all elements, that is, of f, a and 1. <p> This is expected to be poor [8]. * The product of the ascii values. This should be better since the values are uniformly distributed ([8]). * The sum used as seed for a pseudo random number generator. This was proposed in <ref> [10] </ref>. The reason was to get a codeword with just a few bits set. * The product used as seed. * As a "best value" the keys were leap numbered so they all got a unique key. This is of course not useful in practice.
Reference: [11] <editor> Jayen Vaghani et al. </editor> <title> Design overview of the aditi deductive database system. </title> <editor> In Jan Chomicki, editor, </editor> <booktitle> Proceedings of the NACLP'90 Workshop on deductive databases. </booktitle> <institution> Kansas State University report TR-CS-90-14, </institution> <month> October </month> <year> 1990. </year> <month> 15 </month>
Reference-contexts: We can however write programs that uses full Prolog terms containing variables, lists structures etc. The indexing mechanism could be made more flexible and take care of the special Prolog situation. This approach is taken in NU-Prolog [3]. Other work include Aditi <ref> [11] </ref> were they build a deductive DBMS with a Prolog-like query language. SICStus already has an interface to the DBMS Oracle [9]. This report describes the special database handler that was developed for SICStus.
References-found: 11

