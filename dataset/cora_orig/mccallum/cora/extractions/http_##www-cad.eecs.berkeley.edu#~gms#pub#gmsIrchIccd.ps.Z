URL: http://www-cad.eecs.berkeley.edu/~gms/pub/gmsIrchIccd.ps.Z
Refering-URL: http://www-cad.eecs.berkeley.edu:80/~gms/projects/research.html
Root-URL: 
Title: Incremental Methods for FSM Traversal  
Author: Gitanjali M. Swamy Vigyan Singhal Robert K. Brayton 
Address: Berkeley, CA 94720  
Affiliation: Department of Electrical Engineering and Computer Science. University of California at Berkeley  
Abstract: Computing the set of reachable states of a finite state machine is an important component of many problems in the synthesis, and formal verification of digital systems. Computing the reachable states is computationally expensive due to the "explosion" in the number of states in real designs. However, the process of design is usually iterative, and the designer may modify and recompute information many times. Unfortunately, the reachability computation is called each time the designer modifies the system, because current methods for reachability analysis are not incremental. The current method for representation of the reachable states is inherently non-updatable. We solve this problem by presenting alternate ways to represent the reachable set, and incremental algorithms that can update the new representation each time the designer changes the system. The incremental algorithms use the reachable set computed at a previous iteration and information about the changes to the system to update it, rather than compute the reachable set from the beginning. Our experimental results demonstrate that this may result in considerable savings in time. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> H. Touati, R. K. Brayton, and R. P. Kurshan, </author> <title> "Checking Language Containment using BDDs," </title> <booktitle> in Proc. of Intl. Workshop on Formal Methods in VLSI Design, </booktitle> <address> (Miami, FL), </address> <month> Jan. </month> <year> 1990. </year>
Reference-contexts: 1 Introduction Reachability is an essential computation in both formal verification <ref> [1] </ref> as well as sequential synthesis [2] and [3]. Given a directed graph, and a set of initial nodes in the graph, reachability computes the set of nodes on some path from the initial nodes.
Reference: [2] <author> E. M. Sentovich, K. J. Singh, C. Moon, H. Savoj, R. K. Brayton, and A. L. Sangiovanni-Vincentelli, </author> <title> "Sequential Circuit Design Using Synthesis and Optimization," </title> <booktitle> in Proc. Intl. Conf. on Computer Design, </booktitle> <pages> pp. 328-333, </pages> <month> Oct. </month> <year> 1992. </year>
Reference-contexts: 1 Introduction Reachability is an essential computation in both formal verification [1] as well as sequential synthesis <ref> [2] </ref> and [3]. Given a directed graph, and a set of initial nodes in the graph, reachability computes the set of nodes on some path from the initial nodes. A finite state machine (or FSM) can be represented by a directed graph, which is also called a state transition graph.
Reference: [3] <author> H. Cho, G. D. Hachtel, and F. Somenzi, </author> <title> "Redundancy Identification and Removal Based on Implicit State Enumeration," </title> <booktitle> in Proc. Intl. Conf. on Computer Design, </booktitle> <pages> pp. 77-80, </pages> <month> Oct. </month> <year> 1991. </year>
Reference-contexts: 1 Introduction Reachability is an essential computation in both formal verification [1] as well as sequential synthesis [2] and <ref> [3] </ref>. Given a directed graph, and a set of initial nodes in the graph, reachability computes the set of nodes on some path from the initial nodes. A finite state machine (or FSM) can be represented by a directed graph, which is also called a state transition graph.
Reference: [4] <author> R. Bryant, </author> <title> "Graph-based Algorithms for Boolean Function Manipulation," </title> <journal> IEEE Trans. Computers, </journal> <volume> vol. C-35, </volume> <pages> pp. 677-691, </pages> <month> Aug. </month> <year> 1986. </year>
Reference-contexts: Unfortunately this computation explodes when the number of states in the finite state machine becomes very large. This is often called the state explosion problem. To overcome this problem, an implicit representation called binary decision diagrams or BDDs <ref> [4] </ref>, is sometimes used to implicitly represent needed relations and sets; e.g. the transition relation of the FSM, the set of reachable states or the set of initial states. <p> An additional bonus of using this way of storing the reachable states is that the BDD variable ordering <ref> [4] </ref> for a finite state machine is often chosen according to the transition relation. This may not be a good ordering for the reachable states.
Reference: [5] <author> H. Touati, H. Savoj, B. Lin, R. K. Brayton, and A. L. Sangiovanni-Vincentelli, </author> <title> "Implicit State Enumeration of Finite State Machines using BDD's," </title> <booktitle> in Proc. Intl. Conf. on Computer-Aided Design, </booktitle> <pages> pp. 130-133, </pages> <month> Nov. </month> <year> 1990. </year>
Reference-contexts: This traversal may be breadth first or depth first. Touati et al <ref> [5] </ref> , Coudert and Madre [6], and McMillan [10] extended this concept to handle reachability in larger systems, by using implicit methods.
Reference: [6] <author> O. Coudert and J. C. Madre, </author> <title> "A Unified Framework for the Formal Verification of Sequential Circuits," </title> <booktitle> in Proc. Intl. Conf. on Computer-Aided Design, </booktitle> <pages> pp. 126-129, </pages> <month> Nov. </month> <year> 1990. </year>
Reference-contexts: This traversal may be breadth first or depth first. Touati et al [5] , Coudert and Madre <ref> [6] </ref>, and McMillan [10] extended this concept to handle reachability in larger systems, by using implicit methods. All quantities (transition relations, sets of states etc.) are represented by BDDs (binary decision diagrams), and the algorithm is represented by a fixed point computation (refer to section 2).
Reference: [7] <author> G. M. Swamy, V. Singhal, and R. K. Brayton, </author> <title> "Incremental methods for Fsm Traversal," </title> <type> Tech. Rep. </type> <institution> UCB/ERL M95/, Electronics Research Lab, Univ. of California, Berkeley, </institution> <address> CA 94720, </address> <year> 1995. </year>
Reference-contexts: We present some results in section 5. Finally, we conclude our paper by presenting our conclusions, and future directions for this work. For brevity, details of proofs of theorems have been omitted; they may be found in <ref> [7] </ref>. 2 Definitions Definition 1 Finite State Machine: A finite state machine or finite automaton M is a 5-tuple (Q; ; ; T ; I) where * Q is a finite set of states * is a finite set of input values * is a finite set of output values *
Reference: [8] <author> E. A. Emerson, </author> <title> "Temporal and Modal Logic," in Formal Models and Semantics (J. </title> <editor> van Leeuwen, ed.), </editor> <volume> vol. </volume> <booktitle> B of Handbook of Theoretical Computer Science, </booktitle> <pages> pp. 996-1072, </pages> <publisher> Elsevier Science, </publisher> <year> 1990. </year> <month> 14 </month>
Reference-contexts: Fixed point Let f (x) be a monotone (increasing or decreasing) function, the fixedpoint F P of f given I is given by the set Q = f i (I ), where f (Q) = Q (refer to <ref> [8] </ref>). If f is monotonically increasing, then the fixed point is called the least fixed point or LF P , and if f is monotonically decreasing, it is called the greatest fixed point or GF P .
Reference: [9] <author> G. M. Swamy and R. K. Brayton, </author> <title> "Incremental Formal Design Verification," </title> <booktitle> in Proc. Intl. Conf. on Computer-Aided Design, </booktitle> <pages> pp. 458-465, </pages> <month> Nov. </month> <year> 1994. </year>
Reference-contexts: Figure 3 illustrates this point. A similar statement can be made about GFP computations, as shown by Swamy and Brayton <ref> [9] </ref>. 3 Previous work Computing the set of reachable states in the transition relation of a finite state machine is equivalent to doing a traversal of the state transition graph, beginning at the initial states. This traversal may be breadth first or depth first. <p> If = input + output , and input is the change in the input to the program, output is the change that results in the output, then the complexity is O (f ()). This criterion for incrementality is too stringent for our purposes. In Swamy and Brayton <ref> [9] </ref>, incremental algorithms for methods of formal verification are described. Although reachability 5 is an essential part of any formal verification procedure, the issue of how the reachability computation might be made incremental is not discussed; we intend to address this issue here.
Reference: [10] <author> K. L. McMillan, </author> <title> Symbolic Model Checking. </title> <publisher> Kluwer Academic Publishers, </publisher> <year> 1993. </year>
Reference-contexts: This traversal may be breadth first or depth first. Touati et al [5] , Coudert and Madre [6], and McMillan <ref> [10] </ref> extended this concept to handle reachability in larger systems, by using implicit methods. All quantities (transition relations, sets of states etc.) are represented by BDDs (binary decision diagrams), and the algorithm is represented by a fixed point computation (refer to section 2).
Reference: [11] <author> G. Ramalingam and T. Reps, </author> <title> "On the Computational Complexity of Incremental Algorithms," </title> <type> Tech. Rep. TR 1033, </type> <institution> University of Wisconsion, Madison, University of Wisconsion, Madison, </institution> <year> 1991. </year>
Reference-contexts: Incremental algorithms for certain graph problems were examined by Ramalingam and Reps <ref> [11] </ref>. They defined incremental algorithms as algorithms, whose complexity was a function of the size of the change to the system alone.
Reference: [12] <author> B. Lin and F. Somenzi, </author> <title> "Minimization of Symbolic Relations," </title> <booktitle> in Proc. Intl. Conf. on Computer-Aided Design, </booktitle> <pages> pp. 88-91, </pages> <month> Nov. </month> <year> 1990. </year>
Reference-contexts: This returns a spanning tree graph that spans all the reachable states of this FSM. In order to decide which edge to choose as the representative edge, any selector function like "cproject" may be used. * Cproject Operator <ref> [12] </ref>: The cproject operator, when supplied a general acyclic graph, can be used to extract a tree graph that is a subset of the original input graph.
Reference: [13] <author> R. Brayton et al., "HSIS: </author> <title> A BDD-Based Environment for Formal Verification," </title> <booktitle> in Proc. of the Design Automation Conf., </booktitle> <pages> pp. 454-459, </pages> <month> June </month> <year> 1994. </year> <month> 15 </month>
Reference-contexts: (T new (x; y); P 0+ (x; y)) Here P 0 (x; y) denotes the spanning graph before the change, T new is the new transition relation, and I (x) the initial set of states. 5 Results We have implemented the algorithms described in the previous sections, in the HSIS <ref> [13] </ref> environment, and tested these on some ISCAS 89 benchmarks. Each example was modified, and the new reachable set was computed for a general change consisting of both addition and subtraction of a large set of edges. This is iterated many times.
References-found: 13

