URL: http://www.ri.cmu.edu/afs/cs.cmu.edu/Web/People/ph/shadow104.bw.ps.gz
Refering-URL: http://www.ri.cmu.edu/afs/cs.cmu.edu/Web/People/ph/shadow.html
Root-URL: 
Title: Simulating Soft Shadows with Graphics Hardware  
Author: Paul S. Heckbert and Michael Herf 
Keyword: World Wide Web: http://www.cs.cmu.edu/~ph  
Note: This work was supported by NSF Young Investigator award CCR-9357763. The views and conclusions contained in this document are those of the authors and should not be interpreted as representing the official policies, either expressed or implied, of NSF or the U.S. government.  
Address: Pittsburgh, PA 15213  
Affiliation: School of Computer Science Carnegie Mellon University  
Pubnum: CMU-CS-97-104  
Email: email: ph@cs.cmu.edu, herf+@cmu.edu  
Date: January 15, 1997  
Abstract: This paper was written in April 1996. An abbreviated version appeared in [Michael Herf and Paul S. Heckbert, Fast Soft Shadows, Visual Proceedings, SIGGRAPH 96, Aug. 1996, p. 145]. Abstract This paper describes an algorithm for simulating soft shadows at interactive rates using graphics hardware. On current graphics workstations, the technique can calculate the soft shadows cast by moving, complex objects onto multiple planar surfaces in about a second. In a static, diffuse scene, these high quality shadows can then be displayed at 30 Hz, independent of the number and size of the light sources. For a diffuse scene, the method precomputes a radiance texture that captures the shadows and other brightness variations on each polygon. The texture for each polygon is computed by creating registered projections of the scene onto the polygon from multiple sample points on each light source, and averaging the resulting hard shadow images to compute a soft shadow image. After this precomputation, soft shadows in a static scene can be displayed in real-time with simple texture mapping of the radiance textures. All pixel operations employed by the algorithm are supported in hardware by existing graphics workstations. The technique can be generalized for the simulation of shadows on specular surfaces. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Kurt Akeley. </author> <title> RealityEngine graphics. </title> <booktitle> In SIGGRAPH '93 Proc., </booktitle> <pages> pages 109-116, </pages> <month> Aug. </month> <year> 1993. </year>
Reference-contexts: Our own method can be categorized next to hemicube radiosity methods, since it also precomputes visibility discretely. Its technique for computing visibility also has parallels to the method of flattening objects to a plane. 2.2 Graphics Hardware Current graphics hardware, such as the Silicon Graphics Reality Engine <ref> [1] </ref>, can projective-transform, clip, shade, scan convert, and texture tens of thousands of polygons in real-time (in 1/30 sec.). We would like to exploit the speed of this hardware to simulate soft shadows.
Reference: [2] <author> James Arvo and David Kirk. </author> <title> A survey of ray tracing acceleration techniques. </title> <editor> In Andrew S. Glassner, editor, </editor> <title> An introduction to ray tracing, </title> <address> pages 201-262. </address> <publisher> Academic Press, </publisher> <year> 1989. </year>
Reference-contexts: Because the angle of view of most of the shadow projection pyramids is narrow, only a small fraction of the polygons in a scene shadow a given polygon, on average. Using spatial data structures, entire objects can be culled with a few quick tests <ref> [2] </ref>, obviating transformation and clipping of most of the scene, speeding the rendering of each hard shadow image from O (s+t=s) to O (s ff +t=s), where ff :3 or so.
Reference: [3] <author> James F. </author> <title> Blinn. Me and my (fake) shadow. </title> <journal> IEEE Computer Graphics and Applications, </journal> <volume> 8(1) </volume> <pages> 82-86, </pages> <month> Jan. </month> <year> 1988. </year>
Reference-contexts: A simple, brute force approach, good for casting shadows of objects onto a plane, is to find the projective transformation that projects objects from a point light onto a plane, and to use it to draw each squashed, blackened object on top of the plane <ref> [3] </ref>, [15, p. 401]. This algorithm effectively multiplies the number of objects in the scene by the number of light sources times the number of receiver polygons onto which shadows are being cast, however, so it is typically practical only for very small numbers of light sources and receivers. <p> xx ff x n xy ff x n xz ff x n x b 0 0 0 1 9 ; where n x = e w fie y n w = e y fie x ff x = 1=n x e x ff w = 1=n w e w Blinn <ref> [3] </ref> uses a related projective transformation for the genera tion of shadows on a plane, but his is a projection (it collapses 3-D to 2-D), while ours is 3-D to 3-D.
Reference: [4] <author> Lynne Shapiro Brotman and Norman I. Badler. </author> <title> Generating soft shadows with a depth buffer algorithm. </title> <journal> IEEE Computer Graphics and Applications, </journal> <volume> 4(10) </volume> <pages> 5-24, </pages> <month> Oct. </month> <year> 1984. </year>
Reference-contexts: Determining if a point is in shadow then reduces to point-in-volume testing. Brotman and Badler used an extended z-buffer algorithm with linked lists at each pixel to support soft shadows using this approach <ref> [4] </ref>. The shadow volume method has also been used in two hardware implementations. Fuchs et al. used the pixel processors of the Pixel Planes machine to simulate hard shadows in real-time [10]. Heidmann used the stencil buffer in advanced SGI machines [13].
Reference: [5] <author> Shenchang Eric Chen. </author> <title> Incremental radiosity: An extension of progressive radiosity to an interactive image synthesis system. </title> <booktitle> Computer Graphics (SIGGRAPH '90 Proceedings), </booktitle> <volume> 24(4) </volume> <pages> 135-144, </pages> <month> August </month> <year> 1990. </year>
Reference-contexts: Radiosity meshes typically do not resolve shadows well, however. Typical artifacts are Mach bands along the mesh element boundaries and excessively blurry shadows. Most radiosity methods are not fast enough to support interactive changes to the geometry, however. Chen's incremental radiosity method is an exception <ref> [5] </ref>. Our own method can be categorized next to hemicube radiosity methods, since it also precomputes visibility discretely.
Reference: [6] <author> Norman Chin and Steven Feiner. </author> <title> Fast object-precision shadow generation for area light sources using BSP trees. </title> <booktitle> In 1992 Symp. on Interactive 3D Graphics, </booktitle> <pages> pages 21-30. </pages> <publisher> ACM SIGGRAPH, </publisher> <month> Mar. </month> <year> 1992. </year>
Reference-contexts: With this approach, surfaces are subdivided into fully lit, penumbra, and umbra regions by splitting along lines or curves where visibility changes. In Chin and Feiner's soft shadow method, polygons are split using BSP trees, and these sub-polygons are then pre-shaded <ref> [6] </ref>. They achieved rendering times of under a minute for simple scenes. Drettakis and Fiume used more sophisticated computational geometry techniques to precompute their subdivision, and reported rendering times of several seconds [9].
Reference: [7] <author> Michael F. Cohen and Donald P. Greenberg. </author> <title> The hemi-cube: A ra-diosity solution for complex environments. </title> <booktitle> Computer Graphics (SIG-GRAPH '85 Proceedings), </booktitle> <volume> 19(3) </volume> <pages> 31-40, </pages> <month> July </month> <year> 1985. </year>
Reference-contexts: In order to simulate extended light sources, we approximate them with a number of light sample points, and we do visibility tests between a given surface point and each light sample. To keep as many operations in hardware as possible, however, we do not use a hemicube <ref> [7] </ref> to determine visibility. Instead, to compute the shadows for a single polygon, we render the scene into a scratch buffer, with all polygons except the one being shaded appropriately blackened, using a special projective projection from the point of view of each light sample. <p> Most radiosity methods discretize each surface into a mesh of elements and then use discrete methods such as ray tracing or hemicubes to compute visibility. The hemicube method computes visibility from a light source point to an entire hemisphere by projecting the scene onto a half-cube <ref> [7] </ref>. Much of this computation can be done in hardware. Radiosity meshes typically do not resolve shadows well, however. Typical artifacts are Mach bands along the mesh element boundaries and excessively blurry shadows. Most radiosity methods are not fast enough to support interactive changes to the geometry, however. <p> it appears slower than our technique for scenes of moderate complexity because every pixel-level operation in our algorithm can be done in hardware, but this is not the case with hemicubes, since the process of summing differential form factors while reading out of the hemicube must be done in software <ref> [7] </ref>. 4 Scenes with General Reflectance Shadows on specular surfaces, or surfaces with more general reflectance, can be simulated with a generalization of the diffuse algorithm, but not without added time and memory costs.
Reference: [8] <author> Robert L. Cook. </author> <title> Stochastic sampling in computer graphics. </title> <journal> ACM Trans. on Graphics, </journal> <volume> 5(1) </volume> <pages> 51-72, </pages> <month> Jan. </month> <year> 1986. </year>
Reference-contexts: Shadows are computed on a point-by-point basis by tracing rays between the surface point and a point on each light source to check for occluders. Soft shadows can be simulated by tracing rays to a number of points distributed across the light source <ref> [8] </ref>. The shadow volume approach is another method for computing shadows on the fly. With this method, one constructs imaginary surfaces that bound the shadowed volume of space with respect to each point light source. Determining if a point is in shadow then reduces to point-in-volume testing. <p> For example, if a uniform grid of mfim samples is used on a parallelogram light source, an occluder edge coplanar with one of the light source edges will cause m big steps, while an occluder edge in general position will cause m 2 small steps. Stochastic sampling <ref> [8] </ref> with the same number of samples yields smoother penumbra than a uniform grid, because the steps no longer coincide. We use a jittered uniform grid because it gives good results and is very easy to compute. Using a fixed number of samples on each light source is inefficient.
Reference: [9] <author> George Drettakis and Eugene Fiume. </author> <title> A fast shadow algorithm for area light sources using backprojection. </title> <booktitle> In SIGGRAPH '94 Proc., </booktitle> <pages> pages 223-230, </pages> <year> 1994. </year> <note> http://safran.imag.fr/Membres/George.Drettakis/ pub.html. </note>
Reference-contexts: They achieved rendering times of under a minute for simple scenes. Drettakis and Fiume used more sophisticated computational geometry techniques to precompute their subdivision, and reported rendering times of several seconds <ref> [9] </ref>. Most radiosity methods discretize each surface into a mesh of elements and then use discrete methods such as ray tracing or hemicubes to compute visibility. The hemicube method computes visibility from a light source point to an entire hemisphere by projecting the scene onto a half-cube [7].
Reference: [10] <author> Henry Fuchs, Jack Goldfeather, Jeff P. Hultquist, Susan Spach, John D. Austin, Frederick P. Brooks, Jr., John G. Eyles, and John Poulton. </author> <title> Fast spheres, shadows, textures, transparencies, and image enhancements in Pixel-Planes. </title> <booktitle> Computer Graphics (SIGGRAPH '85 Proceedings), </booktitle> <volume> 19(3) </volume> <pages> 111-120, </pages> <month> July </month> <year> 1985. </year>
Reference-contexts: The shadow volume method has also been used in two hardware implementations. Fuchs et al. used the pixel processors of the Pixel Planes machine to simulate hard shadows in real-time <ref> [10] </ref>. Heidmann used the stencil buffer in advanced SGI machines [13]. With Heidmann's algorithm, the scene must be rendered through the stencil created from each light source, so the cost per frame is proportional to the number of light sources times the number of polygons.
Reference: [11] <author> Paul Haeberli and Kurt Akeley. </author> <title> The accumulation buffer: Hardware support for high-quality rendering. </title> <booktitle> Computer Graphics (SIGGRAPH '90 Proceedings), </booktitle> <volume> 24(4) </volume> <pages> 309-318, </pages> <month> Aug. </month> <year> 1990. </year>
Reference-contexts: Soft shadows can be generated on a graphics workstation by rendering the scene multiple times, using different points on the extended light source, averaging the resulting images using accumulation buffer hardware <ref> [11] </ref>. A variation of the shadow volume approach is to intersect these volumes with surfaces in the scene to precompute the umbra and penumbra regions on each surface [16]. During the final rendering pass, illumination integrals are evaluated at a sparse sampling of pixels. Precomputation of Shading. <p> So when we speak of a computation being done in hardware, that is true only on high end machines. The accumulation buffer <ref> [11] </ref>, another feature of some graphics workstations, is hardware that allows a linear combination of images to be easily computed.
Reference: [12] <author> Paul S. Heckbert. </author> <title> Adaptive radiosity textures for bidirectional ray tracing. </title> <booktitle> Computer Graphics (SIGGRAPH '90 Proceedings), </booktitle> <volume> 24(4) </volume> <pages> 145-154, </pages> <month> Aug. </month> <year> 1990. </year>
Reference: [13] <author> Tim Heidmann. </author> <title> Real shadows, real time. </title> <journal> Iris Universe, </journal> <volume> 18 </volume> <pages> 28-31, </pages> <year> 1991. </year> <title> Silicon Graphics, </title> <publisher> Inc. </publisher>
Reference-contexts: The shadow volume method has also been used in two hardware implementations. Fuchs et al. used the pixel processors of the Pixel Planes machine to simulate hard shadows in real-time [10]. Heidmann used the stencil buffer in advanced SGI machines <ref> [13] </ref>. With Heidmann's algorithm, the scene must be rendered through the stencil created from each light source, so the cost per frame is proportional to the number of light sources times the number of polygons.
Reference: [14] <author> Karol Myszkowski and Tosiyasu L. Kunii. </author> <title> Texture mapping as an alternative for meshing during walkthrough animation. </title> <booktitle> In Fifth Euro-graphics Workshop on Rendering, </booktitle> <pages> pages 375-388, </pages> <month> June </month> <year> 1994. </year>
Reference: [15] <author> Jackie Neider, Tom Davis, and Mason Woo. </author> <title> OpenGL Programming Guide. </title> <publisher> Addison-Wesley, </publisher> <address> Reading MA, </address> <year> 1993. </year>
Reference-contexts: A simple, brute force approach, good for casting shadows of objects onto a plane, is to find the projective transformation that projects objects from a point light onto a plane, and to use it to draw each squashed, blackened object on top of the plane [3], <ref> [15, p. 401] </ref>. This algorithm effectively multiplies the number of objects in the scene by the number of light sources times the number of receiver polygons onto which shadows are being cast, however, so it is typically practical only for very small numbers of light sources and receivers. <p> Most systems also support Phong illumination, which has an additional specular term that we have not shown. The most advanced, expensive machines support all of these functions in hardware, while the cheaper machines do some of these calculations in software. Since the graphics subroutine interface, such as OpenGL <ref> [15] </ref>, is typically identical on any machine, these differences are transparent to the user, except for the dramatic differences in running speed. So when we speak of a computation being done in hardware, that is true only on high end machines.
Reference: [16] <author> Tomoyuki Nishita and Eihachiro Nakamae. </author> <title> Half-tone representation of 3-D objects illuminated by area sources or polyhedron sources. </title> <booktitle> In COMPSAC '83, Proc. IEEE 7th Intl. Comp. Soft. and Applications Conf., </booktitle> <pages> pages 237-242, </pages> <month> Nov. </month> <year> 1983. </year> <month> 7 </month>
Reference-contexts: A variation of the shadow volume approach is to intersect these volumes with surfaces in the scene to precompute the umbra and penumbra regions on each surface <ref> [16] </ref>. During the final rendering pass, illumination integrals are evaluated at a sparse sampling of pixels. Precomputation of Shading. Precomputation can be taken further, computing not just visibility but also shading. This is most relevant to diffuse scenes, since their shading is view-independent.
Reference: [17] <author> Mark Segal, Carl Korobkin, Rolf van Widenfelt, Jim Foran, and Paul Haeberli. </author> <title> Fast shadows and lighting effects using texture mapping. </title> <booktitle> Computer Graphics (SIGGRAPH '92 Proceedings), </booktitle> <volume> 26(2) </volume> <pages> 249-252, </pages> <month> July </month> <year> 1992. </year>
Reference-contexts: The transformation of points from one coordinate system to another can be accelerated using texture mapping hardware <ref> [17] </ref>. This latter method, by Segal et al., achieves real-time rates, and is the other leading method for interactive shadows.
Reference: [18] <author> Lance Williams. </author> <title> Casting curved shadows on curved surfaces. </title> <booktitle> Computer Graphics (SIGGRAPH '78 Proceedings), </booktitle> <volume> 12(3) </volume> <pages> 270-274, </pages> <month> Aug. </month> <year> 1978. </year>
Reference-contexts: Precomputation of Visibility. Instead of computing visibility on the fly, one can precompute visibility from the point of view of each light source. The z-buffer shadow algorithm uses two (or more) passes of z-buffer rendering, first from the light sources, and then from the eye <ref> [18] </ref>. The z-buffers from the light views are used in the final 1 on receiver.
Reference: [19] <author> Andrew Woo, Pierre Poulin, and Alain Fournier. </author> <title> A survey of shadow algorithms. </title> <journal> IEEE Computer Graphics and Applications, </journal> <volume> 10(6) </volume> <pages> 13-32, </pages> <month> Nov. </month> <year> 1990. </year> <month> 8 </month>
Reference-contexts: previous shadow algorithms, we present our method for diffuse scenes in more detail, we discuss generalizations to scenes with specular and general reflectance, we present our implementation and results, and we offer some concluding remarks. 2 Previous Work 2.1 Shadow Algorithms Woo et al. surveyed a number of shadow algorithms <ref> [19] </ref>. Here we summarize soft shadows methods and methods that run at interactive rates. Shadow algorithms can be divided into three categories: those that compute everything on the fly, those that precompute just visibility, and those that precompute shading. Computation on the Fly.
References-found: 19

