URL: http://www.cs.indiana.edu/database/Publications/Unnesting.ps
Refering-URL: http://www.cs.indiana.edu/database/Publications/index.html
Root-URL: http://www.cs.indiana.edu
Email: E-mail: srao@cs.indiana.edu  
Phone: Phone: 812-855-4318 Fax: 812-855-4829  
Title: Number: 1029 Unnesting and Optimization Techniques for Extended-SQL Queries Containing Generalized Quantifiers  
Author: Sudhir G. Rao 
Address: Lindley Hall  Bloomington, IN 47405  
Affiliation: 215  Computer Science Department Indiana University  
Abstract: Relational database systems do not effectively support complex queries containing quantifiers (quantified queries). Quantified queries are becoming increasingly important in decision support applications in general, and health-care information systems in particular. Recently, it has been shown that generalized quantifiers provide an effective way of expressing such queries naturally, and that generalized quantifiers can be efficiently supported in query processors. In this paper, we present unnesting and optimization techniques for an extended-SQL language, that supports generalized quantifier constructs, to translate extended-SQL queries to algebraic expressions. We introduce a new algebraic operator that captures the operational semantics of a wide range of generalized quantifiers. Furthermore, our optimization technique can also be applied during the unnesting of conventional nested SQL queries. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Badia, A., Gyssens, M., and Van Gucht, D. </author> <title> Query Languages with Generalized Quantifiers. In Applications of Logic Databases, </title> <editor> R. Ramakrishnan, Ed. </editor> <publisher> Kluwer Academic Publishers, </publisher> <year> 1995, </year> <pages> pp. 235-258. </pages>
Reference-contexts: Our paper attempts to make a contribution in the area of optimization for quantified queries expressed in a recently proposed extension of SQL [12], that supports more natural constructs for ad-hoc querying. Recently, Hsu and Parker [12] and, independently, Badia, Van Gucht, and Gyssens <ref> [1] </ref>, have shown that generalized quantifiers are an effective and natural way of expressing quantified queries. Furthermore, Rao, Badia, and Van Gucht [20] have demonstrated that a superior performance can be achieved on quantified queries with database system kernels that support generalized quantifier operations directly. <p> It is often argued that these features enhance the declarativeness of the query language. In two recent papers, Hsu and Parker [12] and, independently, Badia, Van Gucht, and Gyssens <ref> [1] </ref>, validated this argument by establishing a link between the phenomenon of sub-query syntax in query languages and the theory of generalized quantifiers as it was introduced by Barwise and Cooper [2] for natural language formalization. <p> The first order logic quantifiers, exists (9) and all (8), were shown to be only two among many of the generalized quantifiers possible <ref> [1, 12] </ref>. Other examples are: (exists) exactly one, (exists) at least ten, at least 2 We use one operator for binary generalized quantifiers. <p> The syntactic mechanisms that they used for SQL GQ were similar to those used in SQL for (NOT) EXISTS predicates containing a subquery. Note that (NOT) EXISTS is a unary quantifier (i.e., it takes only one subquery as an argument) while the more useful generalized quantifier examples indicated in <ref> [1, 12] </ref> are binary quantifiers. In the rest of the paper, the discussion supposes the more general binary generalized quantifiers and not the unary (NOT) EXISTS. Note that queries with EXISTS (NOT EXISTS) can be easily posed as queries with the binary some (no) quantifiers.
Reference: [2] <author> Barwise, J., and Cooper, R. </author> <title> Generalized Quantifiers and Natural Language. </title> <booktitle> In Linguistic and Philosophy (1981), </booktitle> <pages> pp. 159-219. </pages>
Reference-contexts: In two recent papers, Hsu and Parker [12] and, independently, Badia, Van Gucht, and Gyssens [1], validated this argument by establishing a link between the phenomenon of sub-query syntax in query languages and the theory of generalized quantifiers as it was introduced by Barwise and Cooper <ref> [2] </ref> for natural language formalization. The first order logic quantifiers, exists (9) and all (8), were shown to be only two among many of the generalized quantifiers possible [1, 12].
Reference: [3] <author> Carlis, J. V. </author> <title> HAS: A Relational Algebra Operator, or Divide is Not Enough to Conquer. </title> <booktitle> In IEEE Data Engineering (1986), </booktitle> <address> p. </address> <month> 254. </month>
Reference-contexts: involve the determination of the most often (least often, etc.) used health-care services, the percentage degree of donor-recipient typing matches for organ transplants, the cases of diseases not seen in the last five years, and so on. 1 support the operational semantics for high level constructs in the query language <ref> [8, 7, 3] </ref>. This approach has led to an easing of the problem of query transformation and optimization [8]. We choose this latter approach to solve the query transformation and optimization problem for queries in Hsu and Parker's extended-SQL (SQL GQ for short). <p> A system, which translates SQL queries to algebraic expressions, that is intended to support SQL GQ also can very well use the existing ag gregation operator. Algebraic operators that are similar to b 1 are the generalized join operator [8], relational division operator, and the extended division operators <ref> [3, 7] </ref>. Dayal's generalized join operator can perform only variations of outerjoins and joins.
Reference: [4] <author> Cattell, R., Ed. </author> <title> The Object Database Standard: ODMG-93. </title> <publisher> Morgan Kaufmann, </publisher> <year> 1994. </year>
Reference-contexts: Declarative query languages use embedded sub-queries and some form of quantification or set predicates to express relationships between sets of the sort just described (SQL [13], OQL <ref> [4] </ref>, CORAL [19], RC/S [17] etc.). It is often argued that these features enhance the declarativeness of the query language.
Reference: [5] <author> Ceri, S., and Gottlob, G. </author> <title> Translating SQL Into Relational Algebra: Optimization, Semantics, and Equivalence of SQL Queries. </title> <journal> IEEE Transactions on Software Engineering 11, </journal> <month> 4 (April </month> <year> 1985). </year>
Reference-contexts: Their translation mechanism causes the introduction of multiple subqueries with extensive usage of SQL2's EXCEPT predicate. There have been many papers on transformations and optimizations for quantified queries in SQL <ref> [5, 10, 8, 18] </ref>. Pirahesh et. al. presented query transformation and optimization rules for quantified queries and some performance results of an implementation [18]. As they point out in [18], there has not been any implementation for performance testing before theirs. <p> ~x " V ~u j = 0" case. */ |||||||||| (7) return result of the unary operator and a variant of the b 1 operator that demonstrated a superior performance when compared to current relational systems. 4 Remark 3.1 The relational algebra has been extended before to handle aggregate functions <ref> [5, 15] </ref>. The projection operator was introduced by Dayal in [8] to handle duplicates. An operator similar to that corresponds to the GROUP BY and aggregation constructs of SQL is included in the algebra used in [5]. <p> The projection operator was introduced by Dayal in [8] to handle duplicates. An operator similar to that corresponds to the GROUP BY and aggregation constructs of SQL is included in the algebra used in <ref> [5] </ref>. Dayal uses a generalized aggregation operator which applies aggregate functions from SQL and additionally includes boolean-valued aggregate functions EXISTS and NOTEXISTS [8]. A system, which translates SQL queries to algebraic expressions, that is intended to support SQL GQ also can very well use the existing ag gregation operator. <p> SQL query into an algebraic expression [8], (b) Ganski-Wong's recursive unnesting algorithm [10] to transform the SQL query to a conjunctive (Select-Project-Join) query followed by the Wong-Youssefi algorithm [23, 24] or System R techniques for access path selection [21], or (c) Ceri-Gottlob's translation of SQL queries to relational algebra expressions <ref> [5] </ref>. Dayal provides the most complete treatment for unnesting and optimizing SQL queries [8].
Reference: [6] <author> Chaudhuri, S., and Shim, K. </author> <title> Including Group-By in Query Optimization. </title> <booktitle> In Proc. of the 20th Int'l Conf. on VLDB (1994), </booktitle> <pages> pp. 354-366. </pages>
Reference-contexts: 1 Introduction Several recent papers have pointed out that users often use embedded and correlated queries <ref> [6, 16] </ref>. These queries seek to aggregate data into sets of entities and - 1) to retrieve a summary by applying aggregate functions on these sets or 2) to show complex relationships amongst such sets of entities.
Reference: [7] <author> Dadashzadez, M. </author> <title> An Improved Division Operator for Relational Algebra. </title> <booktitle> Information Systems 14, 5 (1989), </booktitle> <pages> 431-437. </pages>
Reference-contexts: involve the determination of the most often (least often, etc.) used health-care services, the percentage degree of donor-recipient typing matches for organ transplants, the cases of diseases not seen in the last five years, and so on. 1 support the operational semantics for high level constructs in the query language <ref> [8, 7, 3] </ref>. This approach has led to an easing of the problem of query transformation and optimization [8]. We choose this latter approach to solve the query transformation and optimization problem for queries in Hsu and Parker's extended-SQL (SQL GQ for short). <p> A system, which translates SQL queries to algebraic expressions, that is intended to support SQL GQ also can very well use the existing ag gregation operator. Algebraic operators that are similar to b 1 are the generalized join operator [8], relational division operator, and the extended division operators <ref> [3, 7] </ref>. Dayal's generalized join operator can perform only variations of outerjoins and joins.
Reference: [8] <author> Dayal, U. </author> <title> Of Nests and Trees: A Unified Approach to Processing Queries that contain Nested Sub-queries, Aggregates, and Quantifiers. </title> <booktitle> In Proc. of the 13th Int'l Conf. on VLDB (1987), </booktitle> <pages> pp. 197-208. </pages>
Reference-contexts: Their translation mechanism causes the introduction of multiple subqueries with extensive usage of SQL2's EXCEPT predicate. There have been many papers on transformations and optimizations for quantified queries in SQL <ref> [5, 10, 8, 18] </ref>. Pirahesh et. al. presented query transformation and optimization rules for quantified queries and some performance results of an implementation [18]. As they point out in [18], there has not been any implementation for performance testing before theirs. <p> involve the determination of the most often (least often, etc.) used health-care services, the percentage degree of donor-recipient typing matches for organ transplants, the cases of diseases not seen in the last five years, and so on. 1 support the operational semantics for high level constructs in the query language <ref> [8, 7, 3] </ref>. This approach has led to an easing of the problem of query transformation and optimization [8]. We choose this latter approach to solve the query transformation and optimization problem for queries in Hsu and Parker's extended-SQL (SQL GQ for short). <p> This approach has led to an easing of the problem of query transformation and optimization <ref> [8] </ref>. We choose this latter approach to solve the query transformation and optimization problem for queries in Hsu and Parker's extended-SQL (SQL GQ for short). The work in [20] provides us with a suite of certain basic operators that can be used to efficiently support generalized quantifiers. <p> The projection operator was introduced by Dayal in <ref> [8] </ref> to handle duplicates. An operator similar to that corresponds to the GROUP BY and aggregation constructs of SQL is included in the algebra used in [5]. Dayal uses a generalized aggregation operator which applies aggregate functions from SQL and additionally includes boolean-valued aggregate functions EXISTS and NOTEXISTS [8]. <p> Dayal in <ref> [8] </ref> to handle duplicates. An operator similar to that corresponds to the GROUP BY and aggregation constructs of SQL is included in the algebra used in [5]. Dayal uses a generalized aggregation operator which applies aggregate functions from SQL and additionally includes boolean-valued aggregate functions EXISTS and NOTEXISTS [8]. A system, which translates SQL queries to algebraic expressions, that is intended to support SQL GQ also can very well use the existing ag gregation operator. Algebraic operators that are similar to b 1 are the generalized join operator [8], relational division operator, and the extended division operators [3, 7]. <p> SQL and additionally includes boolean-valued aggregate functions EXISTS and NOTEXISTS <ref> [8] </ref>. A system, which translates SQL queries to algebraic expressions, that is intended to support SQL GQ also can very well use the existing ag gregation operator. Algebraic operators that are similar to b 1 are the generalized join operator [8], relational division operator, and the extended division operators [3, 7]. Dayal's generalized join operator can perform only variations of outerjoins and joins. <p> Remark 4.1 The resulting SQL query can be optimized and translated using any of the following algorithms: (a) Dayal's algorithms and operators to translate an SQL query into an algebraic expression <ref> [8] </ref>, (b) Ganski-Wong's recursive unnesting algorithm [10] to transform the SQL query to a conjunctive (Select-Project-Join) query followed by the Wong-Youssefi algorithm [23, 24] or System R techniques for access path selection [21], or (c) Ceri-Gottlob's translation of SQL queries to relational algebra expressions [5]. <p> Dayal provides the most complete treatment for unnesting and optimizing SQL queries <ref> [8] </ref>. <p> Most of the current work on the transformation and optimization of nested SQL or SQL2 queries have not discussed implementations or given any performance results on queries containing NOT IN, NOT EXISTS or EXCEPT predicates <ref> [10, 8, 18] </ref>. In this paper, we presented an unnesting technique and a recursive algorithm for directly translating nested SQL GQ queries containing generalized quantifiers to an extended relational algebra expression. We introduced a quantifier operator that captures the operational semantics of a wide range of generalized quantifiers.
Reference: [9] <author> Database Research: </author> <title> Achievements and Opportunities Into the 21st Century. Report of an NSF Workshop on the Future of Database Systems Research, </title> <note> May, 1995. </note> <author> Avi Silberschatz, Mike Stonebraker, Jeff Ullman, </author> <title> editors. </title>
Reference-contexts: 1 A recent report has identified health-care information systems as part of the next-generation application areas for database systems, while continuing to lay emphasis on the need for better optimization techniques for complex queries and on the need for more high-level query languages that support nonexpert users making ad-hoc queries <ref> [9] </ref>. It is also significant that the TPC-D benchmark for Decision Support Queries includes queries involving various combinations of all of the above SQL clauses [22].
Reference: [10] <author> Ganski, R. A., and Wong, H. K. T. </author> <title> Optimization of Nested SQL Queries Revisited. </title> <booktitle> In Proc. of ACM-SIGMOD Int'l Conf. on Management of Data (1987), </booktitle> <pages> pp. 23-33. </pages>
Reference-contexts: Their translation mechanism causes the introduction of multiple subqueries with extensive usage of SQL2's EXCEPT predicate. There have been many papers on transformations and optimizations for quantified queries in SQL <ref> [5, 10, 8, 18] </ref>. Pirahesh et. al. presented query transformation and optimization rules for quantified queries and some performance results of an implementation [18]. As they point out in [18], there has not been any implementation for performance testing before theirs. <p> Remark 4.1 The resulting SQL query can be optimized and translated using any of the following algorithms: (a) Dayal's algorithms and operators to translate an SQL query into an algebraic expression [8], (b) Ganski-Wong's recursive unnesting algorithm <ref> [10] </ref> to transform the SQL query to a conjunctive (Select-Project-Join) query followed by the Wong-Youssefi algorithm [23, 24] or System R techniques for access path selection [21], or (c) Ceri-Gottlob's translation of SQL queries to relational algebra expressions [5]. <p> the R 2 :C i attributes (1 i n), i.e., the attributes that participate in free-predicates, resulting in groups (sets) that are parameterized by the R 2 :C i attributes. 5 Ganski and Wong have presented a recursive unnesting algorithm that has rectified some of the bugs in Kim's algorithms <ref> [10] </ref>. They have modified Kim's technique for unnesting Type-JA queries. For our discussion, however, we are not so much concerned with the correctness of Kim's technique for all Type-JA cases. <p> Most of the current work on the transformation and optimization of nested SQL or SQL2 queries have not discussed implementations or given any performance results on queries containing NOT IN, NOT EXISTS or EXCEPT predicates <ref> [10, 8, 18] </ref>. In this paper, we presented an unnesting technique and a recursive algorithm for directly translating nested SQL GQ queries containing generalized quantifiers to an extended relational algebra expression. We introduced a quantifier operator that captures the operational semantics of a wide range of generalized quantifiers.
Reference: [11] <author> Graefe, G. </author> <title> Query Evaluation Techniques for Large Databases. </title> <journal> ACM Computing Surveys, </journal> <month> 2 </month> <year> (1993). </year>
Reference-contexts: In terms of algorithms and efficient implementations, , 1, [, , and are supported in some form or the other in current relational database systems. A good survey on algorithms and implementation issues can be found in <ref> [11] </ref>. 3 Of the operators that b 1 uses, the only operator that is new is the (unary) . Although the (unary) - operator can be derived in terms of the fi and (difference) operators, employing the cartesian product operation on relational structures makes this complement operation expensive.
Reference: [12] <author> Hsu, P., and Parker, D. </author> <title> Improving SQL with Generalized Quantifiers. </title> <booktitle> In Proc. of the 10th Int'l Conf. on Data Engineering (1995). </booktitle>
Reference-contexts: It is also significant that the TPC-D benchmark for Decision Support Queries includes queries involving various combinations of all of the above SQL clauses [22]. Our paper attempts to make a contribution in the area of optimization for quantified queries expressed in a recently proposed extension of SQL <ref> [12] </ref>, that supports more natural constructs for ad-hoc querying. Recently, Hsu and Parker [12] and, independently, Badia, Van Gucht, and Gyssens [1], have shown that generalized quantifiers are an effective and natural way of expressing quantified queries. <p> Our paper attempts to make a contribution in the area of optimization for quantified queries expressed in a recently proposed extension of SQL <ref> [12] </ref>, that supports more natural constructs for ad-hoc querying. Recently, Hsu and Parker [12] and, independently, Badia, Van Gucht, and Gyssens [1], have shown that generalized quantifiers are an effective and natural way of expressing quantified queries. <p> Furthermore, Rao, Badia, and Van Gucht [20] have demonstrated that a superior performance can be achieved on quantified queries with database system kernels that support generalized quantifier operations directly. Hsu and Parker <ref> [12] </ref> syntactically extended SQL to support generalized quantifiers and provided a translation mechanism from extended-SQL to SQL2 [13]. Their translation mechanism causes the introduction of multiple subqueries with extensive usage of SQL2's EXCEPT predicate. <p> With this algebra we show a way whereby almost all generalized quantifiers can be processed with the addition of just a few operators. 2 The paper is organized as follows. In Section 2 we review generalized quantifiers and SQL GQ as proposed in <ref> [12] </ref>. In Section 3 we present the new operators that are introduced in the extended-relational algebra. The translation algorithm with the associated optimization techniques are discussed in Section 4. Finally, we present our conclusion in Section 5. <p> It is often argued that these features enhance the declarativeness of the query language. In two recent papers, Hsu and Parker <ref> [12] </ref> and, independently, Badia, Van Gucht, and Gyssens [1], validated this argument by establishing a link between the phenomenon of sub-query syntax in query languages and the theory of generalized quantifiers as it was introduced by Barwise and Cooper [2] for natural language formalization. <p> The first order logic quantifiers, exists (9) and all (8), were shown to be only two among many of the generalized quantifiers possible <ref> [1, 12] </ref>. Other examples are: (exists) exactly one, (exists) at least ten, at least 2 We use one operator for binary generalized quantifiers. <p> Hsu and Parker discussed the syntactic limitations of SQL to express queries simulating generalized quantifiers <ref> [12] </ref>. To overcome these limitations, they syntactically extended SQL and provided a translation mechanism from their extended-SQL (SQL GQ ) to SQL2 [13]. The syntactic mechanisms that they used for SQL GQ were similar to those used in SQL for (NOT) EXISTS predicates containing a subquery. <p> The syntactic mechanisms that they used for SQL GQ were similar to those used in SQL for (NOT) EXISTS predicates containing a subquery. Note that (NOT) EXISTS is a unary quantifier (i.e., it takes only one subquery as an argument) while the more useful generalized quantifier examples indicated in <ref> [1, 12] </ref> are binary quantifiers. In the rest of the paper, the discussion supposes the more general binary generalized quantifiers and not the unary (NOT) EXISTS. Note that queries with EXISTS (NOT EXISTS) can be easily posed as queries with the binary some (no) quantifiers. <p> Note that it is not difficult to extend this operator to handle generalized quantifier expressions like "more than k and at most l" as described in <ref> [12] </ref>. The b 1 operator (refer Figure 2) uses the following operators: , 1, fi, [, , , and (unary) . In terms of algorithms and efficient implementations, , 1, [, , and are supported in some form or the other in current relational database systems. <p> It should be clear that given these constraints on Type-J SQL queries, certain redundant joins as described earlier can be eliminated from the queries. 5 Conclusion The extended-SQL language (SQL GQ ), supporting generalized quantifiers, was proposed by Hsu and Parker for making ad-hoc querying more effective and natural <ref> [12] </ref>. Hsu and Parker presented a mechanism for translating nested SQL GQ queries to nested SQL2 queries with extensive usage of the EXCEPT predicate. Queries simulating generalized quantifiers in SQL require the usage of GROUP BY, (NOT) EXISTS, or (NOT) IN clauses.
Reference: [13] <author> International Organization of Standardization (ISO). </author> <title> Database Language SQL. </title> <journal> Document ISO/IEC 9075:1992. </journal> <volume> 15 </volume>
Reference-contexts: Furthermore, Rao, Badia, and Van Gucht [20] have demonstrated that a superior performance can be achieved on quantified queries with database system kernels that support generalized quantifier operations directly. Hsu and Parker [12] syntactically extended SQL to support generalized quantifiers and provided a translation mechanism from extended-SQL to SQL2 <ref> [13] </ref>. Their translation mechanism causes the introduction of multiple subqueries with extensive usage of SQL2's EXCEPT predicate. There have been many papers on transformations and optimizations for quantified queries in SQL [5, 10, 8, 18]. <p> Declarative query languages use embedded sub-queries and some form of quantification or set predicates to express relationships between sets of the sort just described (SQL <ref> [13] </ref>, OQL [4], CORAL [19], RC/S [17] etc.). It is often argued that these features enhance the declarativeness of the query language. <p> Hsu and Parker discussed the syntactic limitations of SQL to express queries simulating generalized quantifiers [12]. To overcome these limitations, they syntactically extended SQL and provided a translation mechanism from their extended-SQL (SQL GQ ) to SQL2 <ref> [13] </ref>. The syntactic mechanisms that they used for SQL GQ were similar to those used in SQL for (NOT) EXISTS predicates containing a subquery.
Reference: [14] <author> Kim, W. </author> <title> On Optimizing an SQL-like Nested Query. </title> <journal> ACM Transactions on Database Systems 7, </journal> <volume> 3 (1982), </volume> <pages> 443-469. </pages>
Reference-contexts: If Dayal's algorithm, for translating a conventional SQL query to expressions in an extended-relational algebra were to be used, then the algebra would additionally have to include Dayal's generalized join, aggregation, and restrict operators. 4.1 Unnesting Technique Our translation algorithm uses an unnesting technique similar to that used by Kim <ref> [14] </ref>. Kim classifies nested SQL queries as being of Type-A, Type-N, Type-J, Type-JA, and so on. A nested SQL query with depth 1, for instance, has an outer query block and an inner query block (the subquery). <p> Our optimization technique can also be employed during the unnesting of conjunctive SQL queries with Type-J nesting <ref> [14] </ref> (refer Section 4.1), in which duplicates get eliminated if they do occur. The results of unnested subqueries should also represent duplicate-free relations. All the other constraints placed on SQL GQ queries do apply in this case also.
Reference: [15] <author> Klug, A. </author> <title> Equivalence of relational algebra and relational calculus query languages having aggregate functions. </title> <journal> Journal of the ACM 29, </journal> <month> 3 (July </month> <year> 1982). </year>
Reference-contexts: ~x " V ~u j = 0" case. */ |||||||||| (7) return result of the unary operator and a variant of the b 1 operator that demonstrated a superior performance when compared to current relational systems. 4 Remark 3.1 The relational algebra has been extended before to handle aggregate functions <ref> [5, 15] </ref>. The projection operator was introduced by Dayal in [8] to handle duplicates. An operator similar to that corresponds to the GROUP BY and aggregation constructs of SQL is included in the algebra used in [5].
Reference: [16] <author> Lu, H., Chan, H. C., and Wei, K. K. </author> <title> A Survey on Usage of SQL. </title> <booktitle> SIGMOD Record (1993), </booktitle> <pages> 60-65. </pages>
Reference-contexts: 1 Introduction Several recent papers have pointed out that users often use embedded and correlated queries <ref> [6, 16] </ref>. These queries seek to aggregate data into sets of entities and - 1) to retrieve a summary by applying aggregate functions on these sets or 2) to show complex relationships amongst such sets of entities.
Reference: [17] <author> Ozsoyo glu, G., and Wang, H. </author> <title> A Relational Calculus with Set Operators, Its Safety, and Equivalent Graphical Languages. </title> <journal> IEEE Transactions on Software Engineering (1989), </journal> <pages> 1038-1052. </pages>
Reference-contexts: Declarative query languages use embedded sub-queries and some form of quantification or set predicates to express relationships between sets of the sort just described (SQL [13], OQL [4], CORAL [19], RC/S <ref> [17] </ref> etc.). It is often argued that these features enhance the declarativeness of the query language.
Reference: [18] <author> Pirahesh, H., Hellerstein, J. M., and Hasan, W. </author> <title> Extensible/Rule Based Query Rewrite Optimization in Starburst. </title> <booktitle> In Proc. of ACM SIGMOD Int'l Conf. on Management of Data (1992), </booktitle> <pages> pp. 39-48. </pages>
Reference-contexts: Their translation mechanism causes the introduction of multiple subqueries with extensive usage of SQL2's EXCEPT predicate. There have been many papers on transformations and optimizations for quantified queries in SQL <ref> [5, 10, 8, 18] </ref>. Pirahesh et. al. presented query transformation and optimization rules for quantified queries and some performance results of an implementation [18]. As they point out in [18], there has not been any implementation for performance testing before theirs. <p> There have been many papers on transformations and optimizations for quantified queries in SQL [5, 10, 8, 18]. Pirahesh et. al. presented query transformation and optimization rules for quantified queries and some performance results of an implementation <ref> [18] </ref>. As they point out in [18], there has not been any implementation for performance testing before theirs. Even their paper does not discuss performance benefits for NOT EXISTS and EXCEPT predicates in SQL2. <p> There have been many papers on transformations and optimizations for quantified queries in SQL [5, 10, 8, 18]. Pirahesh et. al. presented query transformation and optimization rules for quantified queries and some performance results of an implementation <ref> [18] </ref>. As they point out in [18], there has not been any implementation for performance testing before theirs. Even their paper does not discuss performance benefits for NOT EXISTS and EXCEPT predicates in SQL2. <p> Most of the current work on the transformation and optimization of nested SQL or SQL2 queries have not discussed implementations or given any performance results on queries containing NOT IN, NOT EXISTS or EXCEPT predicates <ref> [10, 8, 18] </ref>. In this paper, we presented an unnesting technique and a recursive algorithm for directly translating nested SQL GQ queries containing generalized quantifiers to an extended relational algebra expression. We introduced a quantifier operator that captures the operational semantics of a wide range of generalized quantifiers.
Reference: [19] <author> Ramakrishnan, R., Seshadri, P., Srivastava, D., and Sudarshan, S. </author> <title> The CORAL User Manual: </title>
Reference-contexts: Declarative query languages use embedded sub-queries and some form of quantification or set predicates to express relationships between sets of the sort just described (SQL [13], OQL [4], CORAL <ref> [19] </ref>, RC/S [17] etc.). It is often argued that these features enhance the declarativeness of the query language.
References-found: 19

