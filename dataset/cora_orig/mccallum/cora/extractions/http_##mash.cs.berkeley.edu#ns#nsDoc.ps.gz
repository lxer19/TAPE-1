URL: http://mash.cs.berkeley.edu/ns/nsDoc.ps.gz
Refering-URL: http://mash.cs.berkeley.edu/ns/ns-documentation.html
Root-URL: http://www.cs.berkeley.edu
Title: ns c is LBNL's Network Simulator [11]. The simulator is written in C++; it uses
Author: Kevin 
Date: August 31, 1998  
Affiliation: UC Berkeley, LBL, USC/ISI, and Xerox PARC.  
Note: ns Notes and Documentation The VINT Project A Collaboration between researchers at  Fall hkfall@ee.lbl.govi, Editor Kannan Varadhan hkannan@catarina.usc.edui, Editor  1 The VINT project is a joint effort by people from UC Berkeley, USC/ISI, LBL, and Xerox PARC. The project is supported by the Defense Advanced Research Projects Agency (DARPA) at LBL under DARPA grant DABT63-96-C-0105, at USC/ISI under DARPA grant ABT63-96-C-0054, at Xerox PARC under DARPA grant DABT63-96-C-0105. Any opinions, findings, and conclusions or recommendations expressed in this material are those of the author(s) and do not necessarily reflect the views of the DARPA.  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> C. Alaettino ff glu, A.U. Shankar, K. Dussa-Zeiger, and I. Matta. </author> <title> Design and implementation of MaRS: A routing testbed. </title> <journal> Internetwork-ing: Research and Experience, </journal> <volume> 5:1741, </volume> <year> 1994. </year>
Reference-contexts: to set this variable. * tcl.result (const char* s) Pass the result string s back to the interpreter. * tcl.resultf (const char* fmt, . . . ) varargs (3) variant of above to format the result using vsprintf (3), pass the result string back to the interpreter. if (strcmp (argv <ref> [1] </ref>, "now") == 0) - tcl.resultf ("%.17g", clock ()); return TCL_OK; - tcl.result ("Invalid operation specified"); return TCL_ERROR; Likewise, when a C++ method invokes an OTcl command, the interpreter returns the result in tcl_-&gt;result. * tcl.result (void) must be used to retrieve the result. <p> exists distanceCache_ ($addr)] - set distanceCache_ ($addr) [$self cmd distance? $addr] - set distanceCache_ ($addr) - We now illustrate how the command () method using ASRMAgent::command () as an example. int ASRMAgent::command (int argc, const char*const*argv) - Tcl& tcl = Tcl::instance (); if (argc == 3) - if (strcmp (argv <ref> [1] </ref>, "distance?") == 0) - int sender = atoi (argv [2]); SRMinfo* sp = get_state (sender); tcl.tesultf ("%f", sp-&gt;distance_); return TCL_OK; - return (SRMAgent::command (argc, argv)); - We can make the following observations from this piece of code: * The function is called with two arguments: The first argument (argc) indicates <p> The command line arguments vector (argv) consists of argv [0] contains the name of the method, cmd. argv <ref> [1] </ref> specifies the desired operation. If the user specified any arguments, then they are placed in argv [2...(argc - 1)]. <p> This structure is superior to the list structure for a large number of events, as insertion and deletion times are in O (log n) for n events. This implementation in ns v2 is borrowed from the MaRS-2.0 simulator <ref> [1] </ref>; it is believed that MaRS itself borrowed the code from NetSim [7], although this lineage has not been completely verified. 3.2.3 The Calendar Queue Scheduler The calendar queue scheduler (class Scheduler/Calendar) uses a data structure analogous to a one-year desk calendar, in which events on the same month/day of multiple <p> (node = slot_ [cl]) == 0) - Tcl::instance ().evalf ("%s no-slot %d", name (), cl); Packet::free (p); 35 return; - node-&gt;recv (p); - int Classifier::command (int argc, const char*const* argv) - Tcl& tcl = Tcl::instance (); if (argc == 3) - /* * $classifier clear $slot */ if (strcmp (argv <ref> [1] </ref>, "clear") == 0) - int slot = atoi (argv [2]); clear (slot); return (TCL_OK); - * $classifier installNext $node */ if (strcmp (argv [1], "installNext") == 0) - int slot = maxslot_ + 1; NsObject* node = (NsObject*)TclObject::lookup (argv [2]); install (slot, node); tcl.resultf ("%u", slot); return TCL_OK; - if <p> Classifier::command (int argc, const char*const* argv) - Tcl& tcl = Tcl::instance (); if (argc == 3) - /* * $classifier clear $slot */ if (strcmp (argv <ref> [1] </ref>, "clear") == 0) - int slot = atoi (argv [2]); clear (slot); return (TCL_OK); - * $classifier installNext $node */ if (strcmp (argv [1], "installNext") == 0) - int slot = maxslot_ + 1; NsObject* node = (NsObject*)TclObject::lookup (argv [2]); install (slot, node); tcl.resultf ("%u", slot); return TCL_OK; - if (strcmp (argv [1], "slot") == 0) - int slot = atoi (argv [2]); if ((slot &gt;= 0) || (slot &lt; nslot_)) - tcl.resultf ("%s", <p> 0) - int slot = atoi (argv [2]); clear (slot); return (TCL_OK); - * $classifier installNext $node */ if (strcmp (argv <ref> [1] </ref>, "installNext") == 0) - int slot = maxslot_ + 1; NsObject* node = (NsObject*)TclObject::lookup (argv [2]); install (slot, node); tcl.resultf ("%u", slot); return TCL_OK; - if (strcmp (argv [1], "slot") == 0) - int slot = atoi (argv [2]); if ((slot &gt;= 0) || (slot &lt; nslot_)) - tcl.resultf ("%s", slot_ [slot]-&gt;name ()); return TCL_OK; - tcl.resultf ("Classifier: no object at slot %d", slot); return (TCL_ERROR); - else if (argc == 4) - /* * $classifier install $slot $node <p> int slot = atoi (argv [2]); if ((slot &gt;= 0) || (slot &lt; nslot_)) - tcl.resultf ("%s", slot_ [slot]-&gt;name ()); return TCL_OK; - tcl.resultf ("Classifier: no object at slot %d", slot); return (TCL_ERROR); - else if (argc == 4) - /* * $classifier install $slot $node */ if (strcmp (argv <ref> [1] </ref>, "install") == 0) - int slot = atoi (argv [2]); NsObject* node = (NsObject*)TclObject::lookup (argv [3]); install (slot, node); return (TCL_OK); - return (NsObject::command (argc, argv)); - When a classifier recv ()'s a packet, it hands it to the classify () method. <p> In our present example, we may wish to be able to start the ping query agent from OTcl using a start directive. This may be implemented as follows: int ECHO_Agent::command (int argc, const char*const* argv) - if (argc == 2) - if (strcmp (argv <ref> [1] </ref>, "start") == 0) - timeout (0); return (TCL_OK); - return (Agent::command (argc, argv)); - Here, the start () method available to OTcl simply calls the C++ member function timeout () which initiates the first packet generation and schedules the next. <p> x, double y) - lastx_ = x; lasty_ = y; sum_ = 0.; void Integrator::newPoint (double x, double y) - sum_ += (x - lastx_) * lasty_; lastx_ = x; lasty_ = y; - int Integrator::command (int argc, const char*const* argv) - if (argc == 4) - if (strcmp (argv <ref> [1] </ref>, "newpoint") == 0) - double x = atof (argv [2]); 90 double y = atof (argv [3]); newPoint (x, y); return (TCL_OK); - return (TclObject::command (argc, argv)); - This class provides a base class used by other classes such as QueueMonitor that keep running sums.
Reference: [2] <author> L.S. Brakmo, S. O'Malley, and L.L. Peterson. </author> <title> TCP vegas: New techniques for congestion detection and avoidance. </title> <booktitle> In Proceedings of the ACM SIGCOMM, </booktitle> <pages> pages 2435, </pages> <month> October </month> <year> 1994. </year>
Reference-contexts: $addr] - set distanceCache_ ($addr) - We now illustrate how the command () method using ASRMAgent::command () as an example. int ASRMAgent::command (int argc, const char*const*argv) - Tcl& tcl = Tcl::instance (); if (argc == 3) - if (strcmp (argv [1], "distance?") == 0) - int sender = atoi (argv <ref> [2] </ref>); SRMinfo* sp = get_state (sender); tcl.tesultf ("%f", sp-&gt;distance_); return TCL_OK; - return (SRMAgent::command (argc, argv)); - We can make the following observations from this piece of code: * The function is called with two arguments: The first argument (argc) indicates the number of arguments specified in the command line to <p> no-slot %d", name (), cl); Packet::free (p); 35 return; - node-&gt;recv (p); - int Classifier::command (int argc, const char*const* argv) - Tcl& tcl = Tcl::instance (); if (argc == 3) - /* * $classifier clear $slot */ if (strcmp (argv [1], "clear") == 0) - int slot = atoi (argv <ref> [2] </ref>); clear (slot); return (TCL_OK); - * $classifier installNext $node */ if (strcmp (argv [1], "installNext") == 0) - int slot = maxslot_ + 1; NsObject* node = (NsObject*)TclObject::lookup (argv [2]); install (slot, node); tcl.resultf ("%u", slot); return TCL_OK; - if (strcmp (argv [1], "slot") == 0) - int slot = <p> - /* * $classifier clear $slot */ if (strcmp (argv [1], "clear") == 0) - int slot = atoi (argv <ref> [2] </ref>); clear (slot); return (TCL_OK); - * $classifier installNext $node */ if (strcmp (argv [1], "installNext") == 0) - int slot = maxslot_ + 1; NsObject* node = (NsObject*)TclObject::lookup (argv [2]); install (slot, node); tcl.resultf ("%u", slot); return TCL_OK; - if (strcmp (argv [1], "slot") == 0) - int slot = atoi (argv [2]); if ((slot &gt;= 0) || (slot &lt; nslot_)) - tcl.resultf ("%s", slot_ [slot]-&gt;name ()); return TCL_OK; - tcl.resultf ("Classifier: no object at slot %d", slot); return (TCL_ERROR); <p> return (TCL_OK); - * $classifier installNext $node */ if (strcmp (argv [1], "installNext") == 0) - int slot = maxslot_ + 1; NsObject* node = (NsObject*)TclObject::lookup (argv <ref> [2] </ref>); install (slot, node); tcl.resultf ("%u", slot); return TCL_OK; - if (strcmp (argv [1], "slot") == 0) - int slot = atoi (argv [2]); if ((slot &gt;= 0) || (slot &lt; nslot_)) - tcl.resultf ("%s", slot_ [slot]-&gt;name ()); return TCL_OK; - tcl.resultf ("Classifier: no object at slot %d", slot); return (TCL_ERROR); - else if (argc == 4) - /* * $classifier install $slot $node */ if (strcmp (argv [1], "install") == 0) - int <p> || (slot &lt; nslot_)) - tcl.resultf ("%s", slot_ [slot]-&gt;name ()); return TCL_OK; - tcl.resultf ("Classifier: no object at slot %d", slot); return (TCL_ERROR); - else if (argc == 4) - /* * $classifier install $slot $node */ if (strcmp (argv [1], "install") == 0) - int slot = atoi (argv <ref> [2] </ref>); NsObject* node = (NsObject*)TclObject::lookup (argv [3]); install (slot, node); return (TCL_OK); - return (NsObject::command (argc, argv)); - When a classifier recv ()'s a packet, it hands it to the classify () method. This is defined differently in each type of classifier derived from the base class. <p> sum_ = 0.; void Integrator::newPoint (double x, double y) - sum_ += (x - lastx_) * lasty_; lastx_ = x; lasty_ = y; - int Integrator::command (int argc, const char*const* argv) - if (argc == 4) - if (strcmp (argv [1], "newpoint") == 0) - double x = atof (argv <ref> [2] </ref>); 90 double y = atof (argv [3]); newPoint (x, y); return (TCL_OK); - return (TclObject::command (argc, argv)); - This class provides a base class used by other classes such as QueueMonitor that keep running sums.
Reference: [3] <author> L.S. Brakmo, S. O'Malley, and L.L. Peterson. </author> <title> TCP vegas: New techniques for congestion detection and avoidance. </title> <type> Technical Report TR 94 04, </type> <institution> Department of Computer Science, The University of Arizona, </institution> <address> Tucson, AZ 85721, </address> <month> February </month> <year> 1994. </year>
Reference-contexts: ("%s", slot_ [slot]-&gt;name ()); return TCL_OK; - tcl.resultf ("Classifier: no object at slot %d", slot); return (TCL_ERROR); - else if (argc == 4) - /* * $classifier install $slot $node */ if (strcmp (argv [1], "install") == 0) - int slot = atoi (argv [2]); NsObject* node = (NsObject*)TclObject::lookup (argv <ref> [3] </ref>); install (slot, node); return (TCL_OK); - return (NsObject::command (argc, argv)); - When a classifier recv ()'s a packet, it hands it to the classify () method. This is defined differently in each type of classifier derived from the base class. <p> double y) - sum_ += (x - lastx_) * lasty_; lastx_ = x; lasty_ = y; - int Integrator::command (int argc, const char*const* argv) - if (argc == 4) - if (strcmp (argv [1], "newpoint") == 0) - double x = atof (argv [2]); 90 double y = atof (argv <ref> [3] </ref>); newPoint (x, y); return (TCL_OK); - return (TclObject::command (argc, argv)); - This class provides a base class used by other classes such as QueueMonitor that keep running sums. Each new element of the running sum is added by the newPoint (x, y) function.
Reference: [4] <author> R. Brown. </author> <title> Calendar queues: A fast O(1) priority queue implementation for the simulation event set problem. </title> <journal> Communications of the ACM, </journal> <volume> 31(10):12201227, </volume> <month> October </month> <year> 1988. </year>
Reference-contexts: When the user specifies new Agent/TCP/Reno, the routine RenoTcpClass::create is invoked. 7. The arguments vector (argv) consists of argv [0] contains the name of the object. 21 argv [2...4] contain $self, $class, and $proc. Since create is called through the instance procedure create-shadow, argv <ref> [4] </ref> contains create-shadow. argv [5...] contain any additional arguments provided by the user. <p> The class Trace illustrates argument handling by TclClass methods. class TraceClass : public TclClass - public: TraceClass () : TclClass ("Trace") -- TclObject* create (int args, const char*const* argv) - if (args &gt;= 5) return (new Trace (*argv <ref> [4] </ref>)); else return NULL; - - trace_class; A new Trace object is created as new Trace "X" Finally, the nitty-gritty details of how the interpreted class hierarchy is constructed: 1. The object constructor is executed when ns first starts. 2. <p> It is formally described in <ref> [4] </ref>, and informally described in Jain (p. 410) [8]. The implementation of Calendar queues in ns v2 was contributed by David Wetherall (presently at MIT/LCS). 3.2.4 The Real-Time Scheduler The real-time scheduler (class Scheduler/RealTime) attempts to synchronize the execution of events with real-time.
Reference: [5] <author> S. Deering, D. Estrin, D. Farinacci, V. Jacobson, Ching-Gung Liu, and L. Wei. </author> <title> An architecture for wise-area multicast routing. </title> <type> Technical Report USC-SC-94-565, </type> <institution> Computer Science Department, University of Southern California, </institution> <address> Los Angeles, CA 90089., </address> <year> 1994. </year>
Reference-contexts: Centralized Multicast The centralized multicast is a sparse mode implementation of multicast similar to PIM-SM <ref> [5] </ref>. A Rendezvous Point (RP) rooted shared tree is built for a multicast group. The actual sending of prune, join messages etc. to set up state at the nodes is not simulated.
Reference: [6] <author> S. Floyd, V. Jacobson, C. Liu, S. McCanne, and L. Zhang. </author> <title> A reliable multicast framework for light-weight sessions and application level framing. </title> <booktitle> In Proceedings of the ACM SIGCOMM, </booktitle> <pages> pages 342356, </pages> <month> August </month> <year> 1995. </year>
Reference-contexts: Changing the instance variable of a particular agent only affects the values used by that agent. For example, Agent/SRM set D1_ 2.0 ;# Changes the class variable $srm set D1_ 2.0 ;# Changes D1_ for the particular $srm object only The default request and repair timer parameters <ref> [6] </ref> for each SRM agent are: Agent/SRM set C1_ 2.0 ;# request parameters Agent/SRM set C2_ 2.0 Agent/SRM set D1_ 1.0 ;# repair parameters Agent/SRM set D2_ 1.0 It is thus possible to trivially obtain two flavors of SRM agents based on whether the agents use probabilistic or deterministic suppression by <p> In addition, there are methods to access other information from the agent. Data Loss The statistics to measure the response to data losses tracks the duplicate requests (and repairs), and the average request (and repair) delay. The algorithm used is documented in Floyd et al <ref> [6] </ref>. In this algorithm, each new request (or repair) starts a new request (or repair) period. <p> The indirection allows individual simulation scripts to override the recv-- as needed. 3 Note that this implementation of session message handling is subtly different from that used in wb or described in <ref> [6] </ref>. In principle, an agent disseminates a list of the data it has actually received. Our implementation, on the other hand, only disseminates a count of the last message sequence number per source that the agent knows that that the source has sent. <p> Apart from these differences, the calling sequence for events in a repair object is similar to that of a request object. Mechanisms for Statistics The agent, in concert with the request and repair objects, collect statistics about their response to data loss <ref> [6] </ref>. Each call to the agent request-- procedure marks a new period. At the start of a new period, mark-period-- computes the moving average of the number of duplicates in the last period.
Reference: [7] <author> A. Heybey. </author> <title> Netsim Manual. </title> <publisher> MIT, </publisher> <year> 1989. </year>
Reference-contexts: This implementation in ns v2 is borrowed from the MaRS-2.0 simulator [1]; it is believed that MaRS itself borrowed the code from NetSim <ref> [7] </ref>, although this lineage has not been completely verified. 3.2.3 The Calendar Queue Scheduler The calendar queue scheduler (class Scheduler/Calendar) uses a data structure analogous to a one-year desk calendar, in which events on the same month/day of multiple years can be recorded in one day.
Reference: [8] <author> R. Jain. </author> <title> The Art of Computer Systems Performance Analysis. </title> <publisher> John Wiley and Sons, Inc., </publisher> <year> 1996. </year>
Reference-contexts: It is formally described in [4], and informally described in Jain (p. 410) <ref> [8] </ref>. The implementation of Calendar queues in ns v2 was contributed by David Wetherall (presently at MIT/LCS). 3.2.4 The Real-Time Scheduler The real-time scheduler (class Scheduler/RealTime) attempts to synchronize the execution of events with real-time. It is currently implemented as a subclass of the list scheduler. <p> Note that a new point in the sum can be added either by the C++ member newPoint or the OTcl member newpoint. The use of integrals to compute certain types of averages (e.g. mean queue lengths) is given in (pp. 429430, <ref> [8] </ref>). 91 Chapter 14 Trace and Monitoring Support The procedures and functions described in this chapter can be found in ~ns/trace.-cc, h-, ~ns/tcl/lib/ns-trace.tcl, ~ns/queue-monitor.-cc, h-, ~ns/tcl/lib/ns-link.tcl, ~ns/packet.h, ~ns/flowmon.cc, and ~ns/classifier-hash.cc. There are a number of ways of collecting output or trace data on a simulation.
Reference: [9] <author> M. Mathis and J. Mahdavi. </author> <title> Forward acknowledgement: Refining TCP congestion control. </title> <booktitle> In Proceedings of the ACM SIGCOMM, </booktitle> <month> August </month> <year> 1996. </year>
Reference-contexts: Sack TCP This agent implements selective repeat, based on selective ACKs provided by the receiver. It follows the ACK scheme described in [10], and was developed with Matt Mathis and Jamshid Mahdavi. Fack TCP This agent implements forward ACK TCP, a modification of Sack TCP described in <ref> [9] </ref>. 19.2 TCP Receivers (sinks) The TCP senders described above represent one-way data senders. They must peer with a TCP sink object. 132 19.2.1 The Base TCP Sink The base TCP sink object (Agent/TCPSink) is responsible for returning ACKs to a peer TCP source object.
Reference: [10] <author> M. Mathis, J. Mahdavi, S. Floyd, and A. Romanov. </author> <title> TCP Selective Acknowledgement Options, </title> <address> RFC 2018 edition, </address> <year> 1996. </year>
Reference-contexts: The currently defined distributions, and their associated parameters are: class UniformRandomVariable min_, max_ class ExponentialRandomVariable avg_ class ParetoRandomVariable avg_, shape_ class ConstantRandomVariable val_ class HyperExponentialRandomVariable avg_, cov_ The RandomVariable class is available in OTcl. For instance, to create a random variable that generates number uniformly on <ref> [10, 20] </ref>: set u [new RandomVariable/Uniform] $u set min_ 10 $u value By default, RandomVariable objects use the default random number generator described in the previous section. <p> Vegas TCP This agent implements Vegas TCP ([2, 3]). It was contributed by Ted Kuo. Sack TCP This agent implements selective repeat, based on selective ACKs provided by the receiver. It follows the ACK scheme described in <ref> [10] </ref>, and was developed with Matt Mathis and Jamshid Mahdavi. Fack TCP This agent implements forward ACK TCP, a modification of Sack TCP described in [9]. 19.2 TCP Receivers (sinks) The TCP senders described above represent one-way data senders.
Reference: [11] <author> S. McCanne and S. Floyd. </author> <note> nsNetwork Simulator. http://www-mash.cs.berkeley.edu/ns/. </note>
Reference: [12] <author> S. McCanne and V. Jacobson. </author> <title> The bsd packet filter: A new architecture for user-level packet capture. </title> <booktitle> pages 259269, </booktitle> <month> January </month> <year> 1993. </year>
Reference-contexts: The packet capture library works on several UNIX-based platforms. It is optimized for use with the Berkeley Packet Filter (BPF) <ref> [12] </ref>, and provides a filter compiler for the BPF pseudomachine machine code. On most systems supporting it, a kernel-resident BPF implementation processes the filter code, and applies the resulting pattern matching instructions to received frames.
Reference: [13] <author> S.K. Park and R.W. Miller. </author> <title> Random number generation: Good ones are hard to find. </title> <journal> Communications of the ACM, </journal> <volume> 31(10):11921201, </volume> <month> October </month> <year> 1988. </year>
Reference-contexts: The procedures and functions described in this chapter can be found in ~ns/random.-cc, h-, ~ns/ranvar.-cc, h-, ~ns/pareto.-cc, h-, ~ns/expoo.-cc, h-, ~ns/tcl/lib/ns-random.cc, and ~ns/integrator.-cc, h-. 13.1 Random Number Generation The RNG class contains an implementation of the minimal standard multiplicative linear congruential generator of Park et al <ref> [13] </ref>. Multiple instances of the RNG class can be created to allow a simulation to draw random numbers from independent random number streams.
Reference: [14] <author> D. Waitzman, C. Partridge, and S.E. Deering. </author> <title> Distance Vector Multicast Routing Protocol, RFC 1075 edition, </title> <booktitle> 1988. </booktitle> <pages> 178 </pages>
Reference-contexts: $mrthandle get_c_rp $node0 $group ;# get the current RP ??? $mrthandle get_c_bsr $node0 ;# get the current BSR $mrthandle switch-treetype $group ;# to source specific or shared tree $mrthandle compute-mroutes ;# recompute routes usually invoked automatically as needed; Static Dense Mode The Static Dense Mode protocol is based on DVMRP <ref> [14] </ref> with the exception that it does not adapt to network dynamics. It uses parent-child lists as in DVMRP to reduce the number of links over which the data packets are broadcast.
References-found: 14

