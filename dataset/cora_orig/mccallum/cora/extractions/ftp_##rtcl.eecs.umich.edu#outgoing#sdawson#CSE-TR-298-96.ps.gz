URL: ftp://rtcl.eecs.umich.edu/outgoing/sdawson/CSE-TR-298-96.ps.gz
Refering-URL: http://www.eecs.umich.edu/RTCL/projects/orchestra/publications.html
Root-URL: http://www.cs.umich.edu
Email: fsdawson,farnam,mittong@eecs.umich.edu  
Title: Experiments on Six Commercial TCP Implementations Using a Software Fault Injection Tool  
Author: Scott Dawson, Farnam Jahanian, and Todd Mitton 
Keyword: TCP, distributed systems, communication protocols, fault injection tool, protocol testing  
Address: Ann Arbor, MI 48109-2122 USA  
Affiliation: Real-Time Computing Laboratory Department of Electrical Engineering and Computer Science University of Michigan  
Abstract: This is a technical report version of a paper that will appear in Software Practice & Experience in late 1997. ABSTRACT TCP, the de facto standard transport protocol in today's operating systems, is a very robust protocol that adapts to various network characteristics, packet loss, link congestion, and even significant differences in vendor implementations. This paper describes a set of experiments performed on six different vendor TCP implementations using orchestra, a tool for testing and fault injection of communication protocols. These experiments uncovered violations of the TCP protocol specification, and illustrated differences in the philosophies of various vendors in their implementations of TCP. The paper summarizes several lessons learned about the TCP implementations through these experiments. This work is supported in part by a research grant from the U.S. Office of Naval Research, N0014-95-1-0261, and a research grant from the National Science Foundation, CCR-9502341. This paper is a major extension of an earlier conference paper that reported on a preliminary set of experiments on TCP[1]. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Scott Dawson and Farnam Jahanian, </author> <title> `Probing and Fault Injection of Protocol Implementations', </title> <booktitle> Proc. Int. Conf. on Distributed Computer Systems, </booktitle> <month> 351-359 </month> <year> (1995). </year>
Reference: [2] <author> Scott Dawson, Farnam Jahanian, and Todd Mitton, </author> <title> `Testing of Fault-Tolerant and Real-Time Distributed Systems via Protocol Fault Injection', </title> <booktitle> International Symposium on Fault-Tolerant Computing, Sendai, </booktitle> <address> Japan, </address> <month> June </month> <year> 1996, </year> <pages> pp. 404-414. </pages>
Reference-contexts: The effectiveness of this approach, as demonstrated by the TCP experiments, is consistent with our experience on fault injection of other distributed protocols <ref> [2, 3] </ref>. Some of the weaknesses of the tool are that it is not easy to port it into different (non-x-kernel protocol) stacks. Furthermore, until recently, it has been necessary to hand craft all of the fault injection scripts in Tcl. <p> This tool has been used to build two different fault injection layers. The first is a layer that can be used for testing applications and protocols that use sockets for inter-process communication <ref> [2] </ref>, and runs on Mach and Solaris. The second is built as an x-kernel layer on the Open Group MK kernel (Mach with real-time extensions), and can be used to test protocols that run on this platform.
Reference: [3] <author> Scott Dawson, Farnam Jahanian, and Todd Mitton, </author> <title> `A Software Fault-Injection Tool on Real-Time Mach', </title> <booktitle> IEEE Real-Time Systems Symposium, </booktitle> <address> Pisa, Italy, </address> <month> December </month> <year> 1995. </year>
Reference-contexts: The effectiveness of this approach, as demonstrated by the TCP experiments, is consistent with our experience on fault injection of other distributed protocols <ref> [2, 3] </ref>. Some of the weaknesses of the tool are that it is not easy to port it into different (non-x-kernel protocol) stacks. Furthermore, until recently, it has been necessary to hand craft all of the fault injection scripts in Tcl.
Reference: [4] <author> J. Mogul, R. Rashid, and M. Accetta, </author> <title> `The packet filter: An efficient mechanism for user-level network code', </title> <booktitle> Proc. ACM Symp. on Operating Systems Principles, </booktitle> <address> Austin, TX, </address> <month> November </month> <year> 1987, </year> <pages> pp. 39-51. </pages> <publisher> ACM. </publisher>
Reference-contexts: To minimize data copying across kernel/user-space protection boundaries, a kernel agent, called a packet filter, is often used to discard unwanted packets as early as possible. Past work on packet filters, including the pioneering work on the CMU/Stanford Packet Filter <ref> [4] </ref>, a more recent work on BSD Packet Filter (BPF) which uses a register-based filter evaluator [5], and the Mach Packet Filter (MPF)[6] which is an extension of the BPF, are related to the work presented in this paper.
Reference: [5] <author> Steven McCanne and Van Jacobson, </author> <title> `The BSD Packet Filter: A New Architecture for User-level Packet Capture', </title> <booktitle> Winter USENIX Conference, </booktitle> <month> January </month> <year> 1993, </year> <pages> pp. 259-269. </pages>
Reference-contexts: Past work on packet filters, including the pioneering work on the CMU/Stanford Packet Filter [4], a more recent work on BSD Packet Filter (BPF) which uses a register-based filter evaluator <ref> [5] </ref>, and the Mach Packet Filter (MPF)[6] which is an extension of the BPF, are related to the work presented in this paper. In the same spirit as packet filtration methods for network monitoring, our approach inserts a filter to intercept messages that arrive from the network. <p> After 30 ACKs have been delayed, the send filter triggers the receive filter to begin dropping incoming segments. Each incoming segment (both the dropped and non dropped ones) are logged by the receive filter with a timestamp. It is noteworthy that approaches depending on packet filtering <ref> [5, 7] </ref> cannot perform this type of experiment because they do not have the ability to manipulate messages. In particular, they cannot direct the system to perform a task such as delaying ACK segments.
Reference: [6] <author> Masanobu Yuhara, Brian N. Bershad, Chris Maeda, and J. Eliot B. Moss, </author> <title> `Efficient packet de-multiplexing for multiple endpoints and large messages', </title> <booktitle> Winter USENIX Conference, </booktitle> <month> January </month> <year> 1994. </year> <note> Second Edition. </note>
Reference: [7] <author> Douglas E. Comer and John C. Lin, </author> <title> `Probing TCP implementations', </title> <booktitle> Proc. Summer USENIX Conference, </booktitle> <month> June </month> <year> 1994. </year>
Reference-contexts: After 30 ACKs have been delayed, the send filter triggers the receive filter to begin dropping incoming segments. Each incoming segment (both the dropped and non dropped ones) are logged by the receive filter with a timestamp. It is noteworthy that approaches depending on packet filtering <ref> [5, 7] </ref> cannot perform this type of experiment because they do not have the ability to manipulate messages. In particular, they cannot direct the system to perform a task such as delaying ACK segments.
Reference: [8] <author> David B. Ingham and Graham D. Parrington, `Delayline: </author> <title> A Wide-Area Network Emulation Tool', </title> <journal> Computing Systems, </journal> <volume> 7(3), </volume> <month> 313-332 </month> <year> (1994). </year>
Reference-contexts: Nevertheless, many interesting facts about different TCPs were discovered in the work presented in Reference 7. 3 The Delayline <ref> [8] </ref> tool allows the user to introduce delays into user-level protocols. However, the tool is intended to be used for emulating a wide-area network in a local network development environment, and allows only for delay specification on a per path basis.
Reference: [9] <author> Klaus Echtle and Martin Leu, </author> <title> `The EFA Fault Injector for Fault-Tolerant Distributed System Testing', </title> <booktitle> Workshop on Fault-Tolerant Parallel and Distributed Systems. IEEE, </booktitle> <year> 1992, </year> <pages> pp. 28-35. </pages>
Reference-contexts: It does not allow the user to delay messages on a per message basis, nor is it intended for manipulating or injecting new messages. Much work has been performed in the area of fault injection. In communication fault injection, two tools, EFA <ref> [9] </ref> and DOCTOR [10], are most closely related to this work. EFA differs from the work presented in this paper on several key points. The first is that their fault injection layer is driven by a program compiled into the fault injection layer.
Reference: [10] <author> Seungjae Han, Kang G. Shin, and Harold A. Rosenberg, `DOCTOR: </author> <title> an integrateD sOftware fault injeCTiOn enviRonment for distributed real-time systems', </title> <booktitle> Proceedings of the IEEE International Computer Performance and Dependability Symposium, </booktitle> <publisher> Erlangen, </publisher> <address> Germany, </address> <year> 1995, </year> <pages> pp. 204-213. </pages>
Reference-contexts: It does not allow the user to delay messages on a per message basis, nor is it intended for manipulating or injecting new messages. Much work has been performed in the area of fault injection. In communication fault injection, two tools, EFA [9] and DOCTOR <ref> [10] </ref>, are most closely related to this work. EFA differs from the work presented in this paper on several key points. The first is that their fault injection layer is driven by a program compiled into the fault injection layer. <p> This allows the user to focus only on the messages being sent and received by the target layer, rather than having to parse each message sent and received at the data link layer. The DOCTOR system <ref> [10] </ref> runs on a real-time multicomputer platform called HARTS. It allows the user to inject memory, CPU, and communication faults into the system. Communication faults are injected according to probability distributions. There are several differences between orchestra and DOCTOR.
Reference: [11] <author> Christopher Schmechel and Steve Parker. </author> <title> The packet shell. Presented at IETF TCP Working Group Meeting, </title> <note> slides available at ftp://playground.sun.com/pub/sparker/psh-ietf-pres.fm.ps, </note> <month> December </month> <year> 1996. </year>
Reference: [12] <author> Vern Paxson, </author> <title> `Measurements and analysis of end-to-end internet dynamics', </title> <type> Ph.D. Thesis, </type> <institution> University of California, Berkeley, </institution> <year> 1997. </year>
Reference-contexts: Instead, orchestra only manipulates messages that the protocol participants have already generated, or generates new messages. In some cases, if orchestra is being used to generate all protocol messages (effectively cutting off the local protocol participant), then orchestra scripts may be as complex as psh scripts. The tcpanaly <ref> [12] </ref> tool was created for performing analysis on output traces of TCP behavior. The traces are generated by the tcpdump utility [13]. After a packet trace has been captured by tcpdump, tcpanaly automatically analyzes the implementation's behavior by inspecting the trace. <p> In some cases, analysis tools may already exist; it would be desirable to allow the user to filter orchestra output through such tools. One example of this would be generating output that could be interpreted by a tool such as tcpanaly <ref> [12] </ref>. * At this time, the writing of the fault injection scripts is done either by using a graphical script generator or by writing Tcl by hand.
Reference: [13] <author> V. Jacobson, C. Leres, and S. McCanne. tcpdump. </author> <note> Available via anonymous ftp to ftp.ee.lbl.gov, </note> <month> June </month> <year> 1989. </year>
Reference-contexts: The tcpanaly [12] tool was created for performing analysis on output traces of TCP behavior. The traces are generated by the tcpdump utility <ref> [13] </ref>. After a packet trace has been captured by tcpdump, tcpanaly automatically analyzes the implementation's behavior by inspecting the trace.
Reference: [14] <author> Jon Postel, `RFC-793: </author> <title> Transmission control protocol', Request for Comments (1981). Network Information Center. </title>
Reference-contexts: It is connection-oriented, uses flow-control between protocol participants, and can operate over network connections that are inherently unreliable. Because TCP is designed to operate over links of different speeds and reliability, it is widely used on the Internet. TCP was originally defined in RFC-793 <ref> [14] </ref> and was updated in RFC-1122 [15]. To meet the TCP standard, an implementation must follow both RFCs. As mentioned in the previous section, vendor implementations of TCP were tested without access to the source code. <p> If the sender sends more data than the receiver is willing to receive, the receiver may drop the data (unless the 14 window has reopened). Probing of zero size receive windows must be supported <ref> [14, 15] </ref> because an ACK segment which reopens the window may be lost if it contains no data. The reason for this is that ACK segments that carry no data are not transmitted reliably. <p> This is probably to allow Windows 95 to operate over highly congested networks and networks prone to connection outages, such as networks supporting mobile hosts. Relation of RTO to RTT TCP implementations adapt to different network speeds and conditions by adjusting the retransmission timeout. In RFC-793 <ref> [14] </ref>, it was recommended to set RT O = fiRT T , with a recommended fi = 2. Since then, Van Jacobson has shown that this will adapt to load increases of at most 30%[16].
Reference: [15] <author> R. Braden, `RFC-1122: </author> <title> Requirements for internet hosts', Request for Comments (1989). Network Information Center. </title>
Reference-contexts: Because TCP is designed to operate over links of different speeds and reliability, it is widely used on the Internet. TCP was originally defined in RFC-793 [14] and was updated in RFC-1122 <ref> [15] </ref>. To meet the TCP standard, an implementation must follow both RFCs. As mentioned in the previous section, vendor implementations of TCP were tested without access to the source code. For this reason, it was not possible to instrument the protocol stack on the vendor platforms. <p> If the sender sends more data than the receiver is willing to receive, the receiver may drop the data (unless the 14 window has reopened). Probing of zero size receive windows must be supported <ref> [14, 15] </ref> because an ACK segment which reopens the window may be lost if it contains no data. The reason for this is that ACK segments that carry no data are not transmitted reliably.
Reference: [16] <author> Van Jacobson, </author> <title> `Congestion avoidance and control', </title> <booktitle> Proc. of ACM SIGCOMM, </booktitle> <month> August </month> <year> 1988, </year> <pages> pp. 314-329. </pages>
Reference-contexts: The RTO value for a TCP connection is calculated based on the measured round trip time (RTT) from the time each segment is sent until the ACK for the segment is received. RFC-1122 specifies that a TCP must use Jacobson's algorithm <ref> [16] </ref> for computing the RTO coupled with Karn's algorithm [17] for selecting the RTT measurements. Karn's algorithm ensures that ambiguous round-trip times will not corrupt the calculation of the smoothed round-trip time.
Reference: [17] <author> Phil Karn and Craig Partridge, </author> <title> `Round trip time estimation', </title> <booktitle> Proc. SIGCOMM 87, </booktitle> <address> Stowe, Vermont, </address> <month> August </month> <year> 1987. </year>
Reference-contexts: RFC-1122 specifies that a TCP must use Jacobson's algorithm [16] for computing the RTO coupled with Karn's algorithm <ref> [17] </ref> for selecting the RTT measurements. Karn's algorithm ensures that ambiguous round-trip times will not corrupt the calculation of the smoothed round-trip time.
Reference: [18] <author> W. Richard Stevens, </author> <title> TCP Illustrated, Volume 3: TCP for Transactions, HTTP, NNTP, and the UNIX Domain Protocols, </title> <publisher> Addison Wesley, </publisher> <year> 1996. </year> <month> 25 </month>
Reference: [19] <author> Scott Dawson and Farnam Jahanian and Todd Mitton, `ORCHESTRA: </author> <title> A fault injection en-vironment for distributed systems', </title> <type> Technical report, </type> <institution> University of Michigan, </institution> <month> November </month> <year> 1996. </year>
Reference-contexts: In testing such protocols, it is important that the fault injection mechanism not introduce delays that would cause errors in the protocol participants under test. This is particularly true in testing of real-time protocols. In a recent report <ref> [19] </ref>, we have shown that one can make use of support provided by a real-time operating system to effectively quantify and compensate for the intrusiveness of fault injection. The main source of overhead in an orchestra fault injection layer, the cost of interpreting the Tcl fault injection scripts, is quantified. <p> Recently, we have been focusing on the design of a portable fault injection core that can be used to build fault injection layers for insertion into different protocol stacks <ref> [19] </ref>. This tool has been used to build two different fault injection layers. The first is a layer that can be used for testing applications and protocols that use sockets for inter-process communication [2], and runs on Mach and Solaris.
Reference: [20] <author> Adam Sah and Jon Blow, </author> <title> `A compiler for the Tcl language', </title> <booktitle> Proceedings of the Tcl'93 Workshop, </booktitle> <address> Berkeley, California, </address> <month> June </month> <year> 1993. </year> <month> 26 </month>
References-found: 20

