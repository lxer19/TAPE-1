URL: http://www.eecs.umich.edu/techreports/cse/1994/CSE-TR-198-94.ps.gz
Refering-URL: http://www.eecs.umich.edu/home/techreports/cse94.html
Root-URL: http://www.eecs.umich.edu
Email: waleed@fiddler.eecs.umich.edu davidson@eecs.umich.edu  
Title: Optimal Local Register Allocation for a Multiple-Issue Machine  
Author: Waleed M. Meleis Edward S. Davidson 
Address: Ann Arbor, MI 48109-2122  
Affiliation: Advanced Computer Architecture Lab Department of Electrical Engineering and Computer Science University of Michigan  
Abstract: This paper presents an algorithm that allocates registers optimally for straight-line code running on a generic multi-issue computer. On such a machine, an optimal register allocation is one that minimizes the number of issue slots that the code requires. Optimal spill selection and load/store placement are used to minimize the number of additional issue slots needed, given a schedule for the non-memory reference instructions and a fixed number of available physical registers. The generic multi-issue machine model closely models the operation of vector and VLIW processors, and could be extended to model super-scalar processors. The algorithm uses dynamic programming to search the state space of plausible register allocations; implicit and explicit state pruning are used to make the problem tractable. The optimal allocation produced by the algorithm for a substantial example is presented. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> A. V. Aho, R. Sethi, and J. D. Ullman. </author> <booktitle> Compilers: Principles, Techniques, and Tools. </booktitle> <publisher> Addison-Wesley, </publisher> <address> Reading, Massachusetts, </address> <year> 1988. </year>
Reference-contexts: Heuristic solutions to local and global register allocation problem for single-issue machines have been discussed by Chaitin et al [6], [7], Chow et al [4], and Aho et al <ref> [1] </ref>. Horwitz et al. [8] first addressed the problem of finding an allocation of index variables to registers that minimizes the number of load and store spills that are required for a basic block. This approach is extended in Hsu et al. [9] to handle a wider class of schedules.
Reference: [2] <author> L. A. Belady. </author> <title> A study of replacement algorithms for a virtual storage computer. </title> <journal> IBM Systems Journal, </journal> <volume> 5 </volume> <pages> 78-101, </pages> <year> 1966. </year>
Reference-contexts: ex value x value y Both values are in MEM state, and x has a later reload deadline. def def use value x value y use state, y is in REG state, and x has a later reload deadline a b This rule is an application of Belady's MIN algorithm <ref> [2] </ref>. Rule 2: If value x is in MEM state or BOTH state, value y is in REG state, value y has a single use remaining, and NEXTREAD (x) &gt; NEXTREAD (y) (see Figure 4), then x O y.
Reference: [3] <author> E. L. Boyd. </author> <title> Hierarchical performance modeling with MACS: A case study of the Convex C-240. </title> <booktitle> In Proc. 20th Intl Symposium on Computer Architecture, </booktitle> <pages> pages 203-212, </pages> <year> 1993. </year>
Reference-contexts: The generic multi-issue machine/code model described above is based on the Convex C2 machine model described in <ref> [3] </ref>. This C2 model assumes that a set of 1 to 3 vector instructions, referred to as a chime, can be issued to different vector functional units simultaneously. Chimes are analogous to slots in the generic machine model.
Reference: [4] <author> F. C. Chow and J. L. Hennessy. </author> <title> The priority-based approach to register allocation. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 12 </volume> <pages> 503-536, </pages> <year> 1990. </year>
Reference-contexts: Heuristic solutions to local and global register allocation problem for single-issue machines have been discussed by Chaitin et al [6], [7], Chow et al <ref> [4] </ref>, and Aho et al [1]. Horwitz et al. [8] first addressed the problem of finding an allocation of index variables to registers that minimizes the number of load and store spills that are required for a basic block. <p> Algorithms based on Chaitin's work use heuristics to determine which nodes to delete and then generate spill code each time those values are referenced. Deleting the minimum number of nodes from a graph to make it k-colorable is also NP-complete. Heuristics for register allocation are also described in <ref> [4] </ref>. While register coloring can be adapted to perform local allocation, it has traditionally been used in global allocation across multiple basic blocks. The spill insertion problem is to insert the minimum amount of spill code into a given initial schedule.
Reference: [5] <institution> CONVEX Computer Corporation. CONVEX Theory of Operation - C200, volume 081-005030-000. </institution> <year> 1990. </year>
Reference-contexts: no empty slots in this range. final allocation than the best allocation for P 1 . 4.3 Optimal Allocation for the Convex C2 Vector Processor 4.3.1 Machine Model The multi-issue allocation algorithm has been used to improve the performance of a Fortran code running on a Convex C2 vector supercomputer <ref> [5] </ref>. The generic multi-issue machine/code model described above is based on the Convex C2 machine model described in [3]. This C2 model assumes that a set of 1 to 3 vector instructions, referred to as a chime, can be issued to different vector functional units simultaneously.
Reference: [6] <author> G. J. Chaitin et al. </author> <title> Register allocation via coloring. </title> <journal> Computer Languages, </journal> <volume> 6 </volume> <pages> 47-57, </pages> <year> 1981. </year>
Reference-contexts: Heuristic solutions to local and global register allocation problem for single-issue machines have been discussed by Chaitin et al <ref> [6] </ref>, [7], Chow et al [4], and Aho et al [1]. Horwitz et al. [8] first addressed the problem of finding an allocation of index variables to registers that minimizes the number of load and store spills that are required for a basic block. <p> The class of routines that can be scheduled optimally without needing to spill values temporarily to memory is quite small, so we concluded that a general treatment of the scheduling problem must address spilling. Chaitin et al. described the application of graph coloring to global register allocation in <ref> [6] </ref>. Values that are live in the same basic block cannot be assigned to the same register and are said to interfere with one another. Values are associated with nodes of a graph, and edges between the nodes indicate value interference.
Reference: [7] <author> G. J. Chaitin et al. </author> <title> Register allocation and spilling via graph coloring. </title> <booktitle> In Proc. ACM SIGPLAN '86 Symp. Compiler Construction, </booktitle> <pages> pages 98-105, </pages> <address> New York, </address> <year> 1982. </year>
Reference-contexts: Heuristic solutions to local and global register allocation problem for single-issue machines have been discussed by Chaitin et al [6], <ref> [7] </ref>, Chow et al [4], and Aho et al [1]. Horwitz et al. [8] first addressed the problem of finding an allocation of index variables to registers that minimizes the number of load and store spills that are required for a basic block.
Reference: [8] <author> L. P. Horwitz, R. M. Karp, R. E. Miller, and S. Winograd. </author> <title> Index register allocation. </title> <journal> Journal of the Association of Computing Machinery, </journal> <volume> 13 </volume> <pages> 43-61, </pages> <year> 1966. </year>
Reference-contexts: Heuristic solutions to local and global register allocation problem for single-issue machines have been discussed by Chaitin et al [6], [7], Chow et al [4], and Aho et al [1]. Horwitz et al. <ref> [8] </ref> first addressed the problem of finding an allocation of index variables to registers that minimizes the number of load and store spills that are required for a basic block. This approach is extended in Hsu et al. [9] to handle a wider class of schedules. <p> The spill insertion problem is to insert the minimum amount of spill code into a given initial schedule. Horwitz et al, and Hsu et al show that the spill insertion problem is NP-complete in <ref> [8] </ref> and [9] when multiple-use values (common subexpressions) are present. This is a striking result because it demonstrates that optimal code generation is difficult even when the instruction schedule is fixed. They derive pruning rules for optimal spilling and present heuristics. <p> We discuss optimal allocation for single-issue machines in section 4.1, optimal allocation for multi-issue machines in section 4.2, and the results of applying the allocation algorithm to sample code in section 4.3. 4.1 Optimal Single-Issue Register Allocation Our algorithm is an extension of the algorithms described by Horwitz <ref> [8] </ref> and Hsu [9] for the minimization of loads and stores in straight-line single-issue code. <p> Both problems have efficient solutions when each data value is used at most once, but in the general multi-use case they are NP complete. We begin by summarizing the work done in <ref> [8] </ref> and [9] to efficiently solve the single-issue load/store minimization problem using dynamic programming and pruning rules. We then describe our extension of their algorithm. <p> Here the legality of an allocation is defined in the same way as for multi-issue allocation above; however the cost of an allocation is simply the number of loads and stores. The algorithm in <ref> [8] </ref> reduces spill selection to a graph traversal problem, where each node of the graph represents the state of the values at the current point in the schedule. <p> As in our algorithm only the instructions (slots) in the initial schedule, not the load/store instructions (extra slots in our algorithm) are numbered. The rules described in <ref> [8] </ref> and [9] are slightly different because the instructions access pseudo-registers that can be written multiple times. The algorithm constructs all legal configurations for each instruction and finds a cheapest path from the initial configuration (before the first instruction) to a final configuration for the last instruction. <p> The required loads and stores are then implied by the sequence of configurations along this path. The number of configurations considered by this algorithm grows exponentially with the number of instructions. Horwitz <ref> [8] </ref> describes a set of pruning rules that eliminate configurations that cannot lie on a cheapest path and merges equivalent configurations.
Reference: [9] <author> W. Hsu, C. N. Fischer, and J. R. Goodman. </author> <title> On the minimization of loads/stores in local register allocation. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 15 </volume> <pages> 1252-1260, </pages> <year> 1989. </year> <month> 18 </month>
Reference-contexts: Horwitz et al. [8] first addressed the problem of finding an allocation of index variables to registers that minimizes the number of load and store spills that are required for a basic block. This approach is extended in Hsu et al. <ref> [9] </ref> to handle a wider class of schedules. A single-issue machine is assumed in each case, so the goal of the algorithm is to minimize the number of loads and stores that are needed. This paper discusses the extension of the single-issue load/store minimization algorithm for a multi-issue machine. <p> The spill insertion problem is to insert the minimum amount of spill code into a given initial schedule. Horwitz et al, and Hsu et al show that the spill insertion problem is NP-complete in [8] and <ref> [9] </ref> when multiple-use values (common subexpressions) are present. This is a striking result because it demonstrates that optimal code generation is difficult even when the instruction schedule is fixed. They derive pruning rules for optimal spilling and present heuristics. <p> discuss optimal allocation for single-issue machines in section 4.1, optimal allocation for multi-issue machines in section 4.2, and the results of applying the allocation algorithm to sample code in section 4.3. 4.1 Optimal Single-Issue Register Allocation Our algorithm is an extension of the algorithms described by Horwitz [8] and Hsu <ref> [9] </ref> for the minimization of loads and stores in straight-line single-issue code. <p> Both problems have efficient solutions when each data value is used at most once, but in the general multi-use case they are NP complete. We begin by summarizing the work done in [8] and <ref> [9] </ref> to efficiently solve the single-issue load/store minimization problem using dynamic programming and pruning rules. We then describe our extension of their algorithm. The single-issue local register allocation problem is to insert the minimum number of loads and stores into a given schedule so that the resulting allocation is legal. <p> As in our algorithm only the instructions (slots) in the initial schedule, not the load/store instructions (extra slots in our algorithm) are numbered. The rules described in [8] and <ref> [9] </ref> are slightly different because the instructions access pseudo-registers that can be written multiple times. The algorithm constructs all legal configurations for each instruction and finds a cheapest path from the initial configuration (before the first instruction) to a final configuration for the last instruction. <p> The pruning rules discussed below define this partial ordering so that the optimality of the resulting register allocation will not be sacrificed. Several pruning rules used in the multi-issue register allocation algorithm are similar to those described in <ref> [9] </ref>. In that work the spill candidates are partitioned into 4 sets, dead values, live values not written to memory with a single use remaining, live values not written to memory with more than one use remaining, and live values that have been written to memory. <p> These rules are called implicit because they eliminate exclusion sets before they are actually considered by the algorithm. The first three rules follow the 2nd, 3rd and 4th observations in <ref> [9] </ref>. The other three rules are new.
References-found: 9

