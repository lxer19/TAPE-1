URL: http://www.cs.sunysb.edu/~juliana/iclp97.ps.gz
Refering-URL: http://www.cs.sunysb.edu/~juliana/
Root-URL: http://www.aic.nrl.navy.mil/~aha/people.html
Email: fjuliana,tswift,warreng@cs.sunysb.edu  
Title: Taking I/O Seriously: Resolution Reconsidered for Disk  
Author: Juliana Freire, Terrance Swift and David S. Warren 
Affiliation: Department of Computer Science State University of New York at Stony Brook  
Note: To appear in Proceedings of the International Conference on Logic Programming (ICLP) 97  
Abstract: Modern compilation techniques can give Prolog programs, in the best cases, a speed comparable to C. However, Prolog has proven to be unacceptable for data-oriented queries for two major reasons: its poor termination and complexity properties for Datalog, and its tuple-at-a-time strategy. A number of tabling frameworks and systems have addressed the first problem, including the XSB system which has achieved Prolog speeds for tabled programs. Yet tabling systems such as XSB continue to use the tuple-at-a-time paradigm. As a result, these systems are not amenable to a tight interconnection with disk-resident data. However, in a tabling framework the difference between tuple-at-a-time behavior and set-at-a-time can be viewed as one of scheduling. Accordingly, we define a breadth-first set-at-a-time tabling strategy and prove it iteration equivalent to a form of semi-naive magic evaluation. That is, we extend the well-known asymptotic results of Seki [10] by proving that each iteration of the tabling strategy produces the same information as semi-naive magic. Further, this set-at-a-time scheduling is amenable to implementation in an engine that uses Prolog compilation. We describe both the engine and its performance, which is comparable with the tuple-at-a-time strategy even for in-memory Datalog queries. Because of its performance and its fine level of integration of Prolog with a database-style search, the set-at-a-time engine appears as an important key to linking logic programming and deductive databases. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> H. At-Kaci. </author> <title> WAM: A Tutorial Reconstruction. </title> <publisher> MIT Press, </publisher> <year> 1991. </year>
Reference-contexts: A table entry is created when a new tabled subgoal S is called during the Subgoal Call operation. At this time a generator choice point and a completion frame are created for S. The choice point frame contains a superset of the information present in a regular WAM <ref> [1] </ref> choice point, and is used to schedule program clause resolution for S. One important difference is that the trust instruction sets a completion instruction onto the instruction field of the generator choice point, rather than disposing of the choice point as in the WAM.
Reference: [2] <author> W. Chen, M. Kifer, and D.S. Warren. HiLog: </author> <title> A foundation for higher-order logic programming. </title> <journal> Journal of Logic Programming, </journal> <volume> 15(3) </volume> <pages> 187-230, </pages> <year> 1993. </year>
Reference-contexts: the shortest-path (of length 24) between "words" and "spots" in Words1000, XSB v. 1.4 takes 15.67 seconds, whereas Breadth-First takes just 0.34 seconds. (a) (b) shows the CPU time to compute sp (there,white)(D) 1000 times 5 It is worth pointing out that XSB provides an efficient implementation aggregates using HiLog <ref> [2] </ref> syntax. For more information on these aggregate predicates, consult the XSB Manual (available at http://www.cs.sunysb.edu/~ sbprolog/manual/manual.html). 6 It was not possible to run this program with XSB v. 1.4 for bigger graphs (with more than 1000 words), due to memory limitations.
Reference: [3] <author> D. Chimenti, R. Gamboa, R. Krishnamurthy, S. Naqvi, S. Tsur, and C. Zaniolo. </author> <title> The LDL system prototype. </title> <journal> IEEE Trans. on Knowledge and Data Eng., </journal> <volume> 2 </volume> <pages> 76-90, </pages> <year> 1990. </year>
Reference-contexts: Indeed, for range-restricted programs, they have been proven to be asymptotically equivalent [10, 8] under certain assumptions. Despite these well-known equivalences, magic-style systems have traditionally differed from tabling systems. Magic-style systems, such as Aditi [15], CORAL [7], and LDL <ref> [3] </ref>, are built upon set-at-a-time semi-naive engines, while tabling systems, such as XSB [9], use a tuple-at-a-time strategy that reflects their genesis in the logic programming community. Each class of systems has its advantages and disadvantages.
Reference: [4] <author> J. Freire, T. Swift, and D.S. Warren. </author> <title> Beyond depth-first: Improving tabled logic programs through alternative scheduling strategies. </title> <booktitle> In 8th International Symposium PLILP, </booktitle> <pages> pages 243-258. </pages> <publisher> Springer-Verlag, </publisher> <year> 1996. </year>
Reference-contexts: Because of space limitations, some implementation details have been omitted; more details on scheduling in the SLG-WAM can be found in <ref> [4] </ref>, and in the full version of this paper. We begin by briefly presenting some data structures used by the SLG-WAM engine. The table maintains information about all (tabled) subgoals encountered by the evaluation as well as answers for each subgoal. <p> All benchmark programs were run on a SPARC 2 with 64MB of memory, and the engines considered in this section are: * XSB v. 1.4: uses Single Stack Scheduling <ref> [4] </ref>, the original depth-first (tuple at-a-time) strategy for the SLG-WAM. * Breadth-First: breadth-first (set-at-a-time) strategy described in Section 3. It is worth pointing out that these two emulators differ only in the scheduling strategy. <p> the fact that, by batching answers (and not returning them eagerly as XSB v. 1.4), the breadth-first engine reduces the amount of movement in the search space, consequently decreasing the need to freeze branches and decreasing the number of trapped nodes in the stacks (more details can be found in <ref> [4] </ref>). However, if there are suspensions (e.g., right-recursive transitive closure), Breadth-First can use a much larger amount of memory, since suspended subgoals usually lead to a bigger number of consuming nodes.
Reference: [5] <author> D. E. Knuth. </author> <title> The Stanford GraphBase: A Platform for Combinatorial Computing. </title> <publisher> Addison Wesley, </publisher> <year> 1993. </year>
Reference-contexts: Next we examine some different and ostensibly more realistic graphs. Words and subsets of it with fewer vertices and edges, and Roget were generated with Knuth's Stanford Graph Base <ref> [5] </ref>. Genome is a piece of a DNA sequence, while Cylinder is a 24x24 (2-connected) cylinder.
Reference: [6] <author> R. Ramakrishnan. </author> <title> Magic templates: A spellbinding approach to logic programs. </title> <journal> Journal of Logic Programming, </journal> <volume> 11 </volume> <pages> 189-216, </pages> <year> 1991. </year>
Reference-contexts: A central difficulty of pure bottom-up evaluation, such as semi-naive, is that it is not goal-oriented: to answer a query, the entire model of a program must be constructed. Magic templates rewriting (see e.g. <ref> [6] </ref>) avoids this problem by means of a program transformation. Magic is well-discussed in the literature; here we present only the magic templates transformation along with an example of its use. Note that this transformation requires a statically-determined computation rule.
Reference: [7] <author> R. Ramakrishnan, D. Srivastava, and S. Sudarshan. </author> <title> CORAL: Control, relations, </title> <booktitle> and logic. In Proceedings of the 18th VLDB, </booktitle> <pages> pages 238-250, </pages> <year> 1992. </year>
Reference-contexts: Both magic and tabling combine top-down goal orientation with bottom-up redundancy checking. Indeed, for range-restricted programs, they have been proven to be asymptotically equivalent [10, 8] under certain assumptions. Despite these well-known equivalences, magic-style systems have traditionally differed from tabling systems. Magic-style systems, such as Aditi [15], CORAL <ref> [7] </ref>, and LDL [3], are built upon set-at-a-time semi-naive engines, while tabling systems, such as XSB [9], use a tuple-at-a-time strategy that reflects their genesis in the logic programming community. Each class of systems has its advantages and disadvantages.
Reference: [8] <author> K.A. Ross. </author> <title> Modular stratification and magic sets for datalog programs with negation. </title> <journal> JACM, </journal> <volume> 41(6) </volume> <pages> 1216-1266, </pages> <year> 1994. </year>
Reference-contexts: While magic adds goal-orientation to database evaluation, tabling methods have added features of database evaluation to logic programming languages. Magic evaluation closely resembles tabling. Both magic and tabling combine top-down goal orientation with bottom-up redundancy checking. Indeed, for range-restricted programs, they have been proven to be asymptotically equivalent <ref> [10, 8] </ref> under certain assumptions. Despite these well-known equivalences, magic-style systems have traditionally differed from tabling systems.
Reference: [9] <author> K. Sagonas, T. Swift, and D.S. Warren. </author> <title> XSB as an efficient deductive database engine. </title> <booktitle> In Proceedings of SIGMOD, </booktitle> <pages> pages 442-453, </pages> <year> 1994. </year>
Reference-contexts: Despite these well-known equivalences, magic-style systems have traditionally differed from tabling systems. Magic-style systems, such as Aditi [15], CORAL [7], and LDL [3], are built upon set-at-a-time semi-naive engines, while tabling systems, such as XSB <ref> [9] </ref>, use a tuple-at-a-time strategy that reflects their genesis in the logic programming community. Each class of systems has its advantages and disadvantages. <p> Each class of systems has its advantages and disadvantages. Presently for in-memory Datalog queries, the fastest tabling systems show an order of magnitude speedup over magic-style systems due to the tabling systems' use of Prolog compilation technology <ref> [9] </ref>. However, the tuple-at-a-time strategy of tabling systems is not efficiently extendible to disk. A close look at tabling indicates that there is no reason why a set-at-a-time strategy cannot be closely integrated into a tabling engine. Doing so offers tremendous advantages. <p> The completion instruction for the leader will continue failing back to itself until a fixpoint is reached and the query is completely evaluated. 5 Performance Analysis In previous papers <ref> [13, 9] </ref> the WAM-style tabling implementation of XSB v. 1.4 was shown to be about an order of magnitude faster than other deductive database systems for a variety of in-memory queries.
Reference: [10] <author> H. Seki. </author> <title> On the power of Alexander templates. </title> <booktitle> In Proceedings of PODS, </booktitle> <pages> pages 150-159, </pages> <year> 1989. </year>
Reference-contexts: While magic adds goal-orientation to database evaluation, tabling methods have added features of database evaluation to logic programming languages. Magic evaluation closely resembles tabling. Both magic and tabling combine top-down goal orientation with bottom-up redundancy checking. Indeed, for range-restricted programs, they have been proven to be asymptotically equivalent <ref> [10, 8] </ref> under certain assumptions. Despite these well-known equivalences, magic-style systems have traditionally differed from tabling systems. <p> The major results of this paper are: * Derivation of a Tight Equivalence between Tabling and the Semi-Naive Evaluation of a Magic-Transformed Program (SNMT). Broad equivalences between tabling and magic-style methods have long been known. In <ref> [10] </ref> Seki obtained an asymptotic equivalence between a naive evaluation of a program rewritten using Alexander Templates and a version of a tabling method. After specifying a breadth-first search strategy for tabling, we extend the equivalence of Seki in two ways.
Reference: [11] <author> S. Sudarshan. </author> <title> Optimizing Bottom-up Query Evaluation for Deductive Databases. </title> <type> PhD thesis, </type> <institution> University of Wisconsin, </institution> <year> 1992. </year>
Reference-contexts: Note that this transformation requires a statically-determined computation rule. We assume without loss of generality that all such computation rules have a left-to-right order. Definition 2.1 (Magic Templates Rewriting <ref> [11] </ref>) Let P be a program and let Q be a query to P. The magic rewrite of P for Q, or M (P; Q) is constructed as follows. 1. Add a seed fact magic (Q). 2. <p> Differences between the two methods arise in non-ground programs, but we believe that these these differences can be obviated by the use of alternate magic rewriting techniques developed to reduce the complexity of magic with respect to Prolog <ref> [11] </ref>. the environment in which the subgoal was called, so that answers can be returned to this environment as they are derived.
Reference: [12] <author> T. Swift and D. S. Warren. </author> <title> An Abstract Machine for SLG Resolution: Definite Programs. </title> <booktitle> In Proceedings ILPS, </booktitle> <pages> pages 633-654, </pages> <year> 1994. </year>
Reference-contexts: long been known that logic is an expressive data query language, these results now indicate that compilation techniques of logic programming can have a direct practical impact on implementing database queries. 4 The Breadth-First SLG-WAM In this section we describe the changes to make the search procedure of the SLG-WAM <ref> [12] </ref> breadth-first. Because of space limitations, some implementation details have been omitted; more details on scheduling in the SLG-WAM can be found in [4], and in the full version of this paper. We begin by briefly presenting some data structures used by the SLG-WAM engine. <p> These suspended subgoals are reinvoked at the next iteration (through the completion instruction) when the engine exhausts all program and answer clauses from the previous iteration. New Answer: In the strategy of the original SLG-WAM <ref> [12] </ref> bindings are shared between the calling environment of a subgoal and the root node of the tree for that subgoal (e.g., under tuple-at-a-time, in Figure 1, the variable Y p in node 1 would be the same as the variable Y in node 2).
Reference: [13] <author> T. Swift and D. S. Warren. </author> <title> Analysis of sequential SLG evaluation. </title> <booktitle> In Proceedings of ILPS, </booktitle> <pages> pages 219-238, </pages> <year> 1994. </year>
Reference-contexts: Other tabling methods with set-at-a-time properties have been developed, most notably the SLD-AL strategy of [16]. In addition to iteration equivalence to magic, the engine described here has the advantage of using the low-level data structures and compilation techniques of Prolog technology. As presented in <ref> [13] </ref>, this technology, as implemented in the SLG-WAM, leads to an extremely fast, robust, and flexible implementation of a deductive database engine. The resulting implementation of the Breadth-First XSB is available upon request. <p> The completion instruction for the leader will continue failing back to itself until a fixpoint is reached and the query is completely evaluated. 5 Performance Analysis In previous papers <ref> [13, 9] </ref> the WAM-style tabling implementation of XSB v. 1.4 was shown to be about an order of magnitude faster than other deductive database systems for a variety of in-memory queries. <p> Since many deductive databases, including XSB, are under continual development, the difference in speed may change over time; nevertheless the comparisons of <ref> [13] </ref> indicate the importance of compilation technology and of low-level engine optimizations.
Reference: [14] <author> J. Ullman. </author> <title> Principles of Data and Knowledge-base Systems Vol I. </title> <publisher> Computer Science Press, </publisher> <year> 1989. </year>
Reference-contexts: An analysis of the performance of different engines is presented. 2 Preliminaries In this section we give a brief description of magic templates and introduce the basic ideas of tabling. Semi-Naive Evaluation and Magic Rewriting The well-known semi-naive evaluation algorithm <ref> [14] </ref> is an incremental iterative fixpoint algorithm. It is iterative in that it repeatedly generates facts by applying program rules. It is incremental in the sense that a given rule uses a given fact in a given position only once for further derivation.
Reference: [15] <author> J. Vaghani, K. Ramamohanarao, D.B. Kemp, Z. Somogyi, P.J. Stuckey, T.S. Leask, and J. Harland. </author> <title> The Aditi deductive database system. </title> <journal> The VLDB Journal, </journal> <volume> 3(2) </volume> <pages> 245-288, </pages> <year> 1994. </year>
Reference-contexts: Both magic and tabling combine top-down goal orientation with bottom-up redundancy checking. Indeed, for range-restricted programs, they have been proven to be asymptotically equivalent [10, 8] under certain assumptions. Despite these well-known equivalences, magic-style systems have traditionally differed from tabling systems. Magic-style systems, such as Aditi <ref> [15] </ref>, CORAL [7], and LDL [3], are built upon set-at-a-time semi-naive engines, while tabling systems, such as XSB [9], use a tuple-at-a-time strategy that reflects their genesis in the logic programming community. Each class of systems has its advantages and disadvantages.
Reference: [16] <author> L. Vieille. </author> <title> Recursive query processing: The power of logic. </title> <journal> Theoretical Computer Science, </journal> <volume> 69 </volume> <pages> 1-53, </pages> <year> 1989. </year>
Reference-contexts: Using iteration equivalence, we demonstrate that every answer of each iteration of our tabling strategy is produced at the corresponding iteration of SNMT. * Design and Implementation of an Engine to Evaluate Breadth-First Tabling. Other tabling methods with set-at-a-time properties have been developed, most notably the SLD-AL strategy of <ref> [16] </ref>. In addition to iteration equivalence to magic, the engine described here has the advantage of using the low-level data structures and compilation techniques of Prolog technology.
References-found: 16

