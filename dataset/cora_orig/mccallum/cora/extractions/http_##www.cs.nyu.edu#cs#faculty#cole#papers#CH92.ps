URL: http://www.cs.nyu.edu/cs/faculty/cole/papers/CH92.ps
Refering-URL: http://www.cs.nyu.edu/cs/faculty/cole/string.html
Root-URL: http://www.cs.nyu.edu
Title: Tighter Upper Bounds on The Exact Complexity of String Matching and O(m 2 time for
Author: Richard Cole Ramesh Hariharan 
Keyword: 3(m+1) (n m) character comparisons.  
Note: This bound is achieved by an online algorithm which performs O(n) work in total, requires O(m) space  1.  
Date: September 18, 1996  
Abstract: This paper considers how many character comparisons are needed to find all occurrences of a pattern of length m in a text of length n. The main contribution is to show an upper bound of the form n+O(n=m) character comparisons, following preprocessing. Specifically, we show an upper bound of n + 8 
Abstract-found: 1
Intro-found: 1
Reference: [AC89] <author> A. Apostolico, M. </author> <title> Crochemore Optimal Canonization of all substrings of a string, </title> <type> Technical Report No. TR 89-75, </type> <institution> LITP, Universite Paris 7, FRANCE, </institution> <month> October </month> <year> 1989. </year>
Reference: [AG86] <author> A. Apostolico, R. </author> <title> Giancarlo The Boyer-Moore-Galil string searching strategies revisited, </title> <journal> SIAM Journal on Computing, Vol.15, </journal> <volume> 1(1986), </volume> <pages> pp. 98-105. </pages>
Reference-contexts: Cole [Co91] finally proved an essentially tight bound of 3n (n=m) comparisons for the BM algorithm, whether or not the pattern occurs in the text. Colussi [Col91] gave a simple variant of the KMP algorithm which makes at most 3 2 n comparisons. Apostolico and Giancarlo <ref> [AG86] </ref> gave a variant of the BM algorithm which makes at most 2n m + 1 comparisons. Crochemore et al. [CCG92] showed that remembering just the most recently matched portion reduces the upper bound of BM from 3n to 2n comparisons.
Reference: [BM77] <author> R. Boyer, S. </author> <title> Moore A fast string matching algorithm, </title> <journal> CACM, </journal> <volume> 20(1977), </volume> <pages> pp. 762-772. </pages>
Reference-contexts: However, in this case the running time depends on the alphabet size. Perhaps the most widely known linear time algorithms for string matching are the Knuth-Morris-Pratt [KMP77] and Boyer-Moore <ref> [BM77] </ref> algorithms. We refer to them as the KMP and BM algorithms, respectively. The KMP algorithm makes at most 2n m + 1 comparisons and this bound is tight. The exact complexity of the BM algorithm was an open question until recently.
Reference: [B94] <author> D. </author> <title> Breslauer Saving comparisons in the Crochemore-Perrin string matching algorithm, </title> <type> Manuscript, </type> <year> 1994. </year>
Reference-contexts: i = fu i v k i i ; ; u i v i ; u i g, where k i 1 is maximal, u i is a proper suffix of v i , and v i is primitive. 2 Actually, a sharper bound of log m groups is known <ref> [KMP77, B94] </ref>, where is the golden ratio. 7 Proof: The proof is by construction. The groups are constructed in left to right order.
Reference: [BCT93] <author> D. Breslauer, L. Colussi, L. </author> <title> Toniolo Tight comparison bounds for the string prefix-matching problem, </title> <journal> Information Processing Letters, </journal> <volume> 47(1993), </volume> <pages> pp. 51-57. </pages>
Reference-contexts: Independently, Breslauer and Galil discovered a similar algorithm which performs at most n + O ( n log m m ) com parisons [BG92]; this algorithm requires O (m) preprocessing space and time and runs in linear time. Recently, Hancart [Ha93] and Breslauer et al. <ref> [BCT93] </ref> have independently shown an upper and lower bound of (2 1 m )n on the number of comparisons required for string matching when comparisons must involve only text characters in a window of size one sliding monotonically to the right.
Reference: [BG92] <author> D. Breslauer, Z. </author> <title> Galil Closing the gap in the exact complexity of string matching, </title> <note> To appear, Journal of Complexity. </note>
Reference-contexts: Our algorithm requires O (m) space and O (m 2 ) preprocessing time and runs in O (m + n) time overall (exclusive of preprocessing). Independently, Breslauer and Galil discovered a similar algorithm which performs at most n + O ( n log m m ) com parisons <ref> [BG92] </ref>; this algorithm requires O (m) preprocessing space and time and runs in linear time.
Reference: [Co91] <author> R. </author> <title> Cole Tight Bounds on the complexity of the Boyer-Moore algorithm, </title> <journal> SIAM Journal on Computing, </journal> <volume> Vol. 23, No. 5, </volume> <year> 1994, </year> <pages> pp. 1075-1091. </pages>
Reference-contexts: This work was done when the author was at Courant Institute of Mathematical Sciences, New York University. 1 the pattern does not occur in the text. Guibas and Odlyzko [GO80] reduced this to 4n under the same assumption. Cole <ref> [Co91] </ref> finally proved an essentially tight bound of 3n (n=m) comparisons for the BM algorithm, whether or not the pattern occurs in the text. Colussi [Col91] gave a simple variant of the KMP algorithm which makes at most 3 2 n comparisons.
Reference: [CHPZ92] <author> R. Cole, R. Hariharan, M. Paterson, U. </author> <title> Zwick Tighter lower bounds on the exact complexity of string matching, </title> <journal> SIAM Journal on Computing, </journal> <volume> Vol. 24, No. 1, </volume> <year> 1995, </year> <pages> pp. 30-45. </pages>
Reference-contexts: Nearly matching lower bounds are given in a companion paper <ref> [CHPZ92] </ref>. <p> The presuf handler copes with presufs; its design constituted the main challenge in this work. Understanding the structure of the presufs was a key ingredient in its design. Understanding this structure also led to the new lower bound constructions given in <ref> [CHPZ92] </ref>. The flavor of the algorithm is as follows. Initially, the pattern is aligned with the left end of the text. Repeatedly, an attempt to match the pattern against the text is made. When a 1 Presufs are also called borders in literature.
Reference: [CCG92] <author> M. Crochemore, A. Czumaj, L. Gasiniec, S. Jarominek, T. Lecroq, W. Plandowski, W. </author> <title> Rytter Speeding Up Two String-Matching Algorithms, </title> <journal> Al-gorithmica, </journal> <volume> 5(1994), </volume> <pages> pp. 247-267. 56 </pages>
Reference-contexts: Colussi [Col91] gave a simple variant of the KMP algorithm which makes at most 3 2 n comparisons. Apostolico and Giancarlo [AG86] gave a variant of the BM algorithm which makes at most 2n m + 1 comparisons. Crochemore et al. <ref> [CCG92] </ref> showed that remembering just the most recently matched portion reduces the upper bound of BM from 3n to 2n comparisons. Recently, Galil and Giancarlo [GG92] gave a string matching algorithm which makes at most 4 3 n comparisons.
Reference: [Col91] <author> L. </author> <title> Colussi Correctness and efficiency of pattern matching algorithms, </title> <journal> Information and Computing, </journal> <volume> Vol. 5, </volume> <year> 1991, </year> <pages> pp. 225-251. </pages>
Reference-contexts: Guibas and Odlyzko [GO80] reduced this to 4n under the same assumption. Cole [Co91] finally proved an essentially tight bound of 3n (n=m) comparisons for the BM algorithm, whether or not the pattern occurs in the text. Colussi <ref> [Col91] </ref> gave a simple variant of the KMP algorithm which makes at most 3 2 n comparisons. Apostolico and Giancarlo [AG86] gave a variant of the BM algorithm which makes at most 2n m + 1 comparisons. <p> of u i , u 1 &gt; u 2 and k 1 ; k 2 2, then either u 1 is cyclic in u 2 or both u 1 and u 2 are cyclic in some smaller string. 3 The Basic Algorithm The algorithm in this section also appears in <ref> [Col91] </ref> and is also exposed in [GG92]. We describe it again for the sake of completeness. 4 If all the characters in p are identical then it is easily seen that the KMP algorithm makes at most n character comparisons.
Reference: [CGG90] <author> L. Colussi, Z. Galil, R. </author> <title> Giancarlo On the Exact Complexity of String Matching, </title> <booktitle> Proceedings of the Thirty First Annual IEEE Symposium on the Foundations of Computer Science, </booktitle> <year> 1990, </year> <pages> pp. 135-143. </pages>
Reference: [CP89] <author> M. Crochemore, D. Perrin. </author> <title> Two-way pattern matching, </title> <type> Technical Report, </type> <institution> Labor-atoire Informatique, Theorique et Programmation, Universite Paris 7, </institution> <year> 1989. </year>
Reference-contexts: This results in an algorithm that performs at most n comparisons if the pattern has no presuf (the algorithms of [GG92] and <ref> [CP89] </ref> have this property too). The presuf handler cannot quite match the performance of the basic algorithm (which is not surprising given that the lower bounds for this problem are larger than n comparisons).
Reference: [FW65] <author> N. Fine, H. </author> <title> Wilf Uniqueness theorem for periodic functions, </title> <journal> American Mathematical Society, </journal> <volume> 16(1965), </volume> <pages> pp. 109-114. </pages>
Reference-contexts: Let u denote the suffix of v 0 of length s. An easy induction shows that v = xu k for some k 2, where x is a proper suffix of u. 2 The following appear in different forms in [Lo82] (see Proposition 1.3.2, 1.3.4, and 1.3.5). Lemma 2.2 <ref> [LS62, FW65] </ref> If x; y are two distinct periods of a string v such that x + y m + gcdfx; yg then gcdfx; yg is also a period of v. Lemma 2.3 Suppose that v = xy where both x and y are presufs of v.
Reference: [GG91] <author> Z. Galil, R. </author> <title> Giancarlo On the Exact Complexity of String Matching: Lower Bounds, </title> <journal> SIAM Journal on Computing, </journal> <volume> 6(1991), </volume> <pages> pp. 1008-1020. </pages>
Reference-contexts: In fact, [GG92] give this bound in a sharper form as a function of the period z of the pattern; the bound becomes n + minf 1 3 ; minfz;mzg+2 2m g (n m). Galil and Giancarlo <ref> [GG91] </ref> gave a lower bound of n (1 + 1 2m ) comparisons. For online algorithms [GG91] showed an additional lower bound of n (1 + 2 m+3 ). <p> Galil and Giancarlo <ref> [GG91] </ref> gave a lower bound of n (1 + 1 2m ) comparisons. For online algorithms [GG91] showed an additional lower bound of n (1 + 2 m+3 ).
Reference: [GG92] <author> Z. Galil, R. </author> <title> Giancarlo On the Exact Complexity of String Matching: Upper Bounds, </title> <journal> SIAM Journal on Computing, </journal> <volume> 3(1993), </volume> <pages> pp. 407-437. </pages>
Reference-contexts: Apostolico and Giancarlo [AG86] gave a variant of the BM algorithm which makes at most 2n m + 1 comparisons. Crochemore et al. [CCG92] showed that remembering just the most recently matched portion reduces the upper bound of BM from 3n to 2n comparisons. Recently, Galil and Giancarlo <ref> [GG92] </ref> gave a string matching algorithm which makes at most 4 3 n comparisons. This was the strongest upper bound for string matching known prior to our work. In fact, [GG92] give this bound in a sharper form as a function of the period z of the pattern; the bound becomes <p> Recently, Galil and Giancarlo <ref> [GG92] </ref> gave a string matching algorithm which makes at most 4 3 n comparisons. This was the strongest upper bound for string matching known prior to our work. In fact, [GG92] give this bound in a sharper form as a function of the period z of the pattern; the bound becomes n + minf 1 3 ; minfz;mzg+2 2m g (n m). Galil and Giancarlo [GG91] gave a lower bound of n (1 + 1 2m ) comparisons. <p> This results in an algorithm that performs at most n comparisons if the pattern has no presuf (the algorithms of <ref> [GG92] </ref> and [CP89] have this property too). The presuf handler cannot quite match the performance of the basic algorithm (which is not surprising given that the lower bounds for this problem are larger than n comparisons). <p> &gt; u 2 and k 1 ; k 2 2, then either u 1 is cyclic in u 2 or both u 1 and u 2 are cyclic in some smaller string. 3 The Basic Algorithm The algorithm in this section also appears in [Col91] and is also exposed in <ref> [GG92] </ref>. We describe it again for the sake of completeness. 4 If all the characters in p are identical then it is easily seen that the KMP algorithm makes at most n character comparisons.
Reference: [GS80] <author> Z. Galil, J. </author> <title> Seiferas Saving space in fast string-matching, </title> <journal> SIAM Journal on Computing, </journal> <volume> 2(1980), </volume> <pages> pp. 417-438. </pages>
Reference: [GO80] <author> L. J. Guibas, A. M. </author> <title> Odlyzko A new proof of the linearity of the Boyer-Moore string searching algorithm, </title> <journal> SIAM Journal on Computing, Vol.9, </journal> <volume> 4(1980), </volume> <pages> pp. 672-682. </pages>
Reference-contexts: This work was done when the author was at Courant Institute of Mathematical Sciences, New York University. 1 the pattern does not occur in the text. Guibas and Odlyzko <ref> [GO80] </ref> reduced this to 4n under the same assumption. Cole [Co91] finally proved an essentially tight bound of 3n (n=m) comparisons for the BM algorithm, whether or not the pattern occurs in the text.
Reference: [Ha93] <author> C. </author> <title> Hancart On Simon's string searching algorithm, </title> <journal> Information Processing Letters, </journal> <year> 1993. </year>
Reference-contexts: Independently, Breslauer and Galil discovered a similar algorithm which performs at most n + O ( n log m m ) com parisons [BG92]; this algorithm requires O (m) preprocessing space and time and runs in linear time. Recently, Hancart <ref> [Ha93] </ref> and Breslauer et al. [BCT93] have independently shown an upper and lower bound of (2 1 m )n on the number of comparisons required for string matching when comparisons must involve only text characters in a window of size one sliding monotonically to the right.
Reference: [KMP77] <author> D. E. Knuth, J. Morris, V. </author> <title> Pratt Fast pattern matching in strings, </title> <journal> SIAM Journal on Computing, </journal> <volume> 6(1973), </volume> <pages> pp. 323-350. </pages>
Reference-contexts: Note that if the algorithm is permitted to know the alphabet, then there is a finite automaton which performs string matching by reading each text character exactly once (which can be obtained from the failure function of <ref> [KMP77] </ref>). However, in this case the running time depends on the alphabet size. Perhaps the most widely known linear time algorithms for string matching are the Knuth-Morris-Pratt [KMP77] and Boyer-Moore [BM77] algorithms. We refer to them as the KMP and BM algorithms, respectively. <p> a finite automaton which performs string matching by reading each text character exactly once (which can be obtained from the failure function of <ref> [KMP77] </ref>). However, in this case the running time depends on the alphabet size. Perhaps the most widely known linear time algorithms for string matching are the Knuth-Morris-Pratt [KMP77] and Boyer-Moore [BM77] algorithms. We refer to them as the KMP and BM algorithms, respectively. The KMP algorithm makes at most 2n m + 1 comparisons and this bound is tight. The exact complexity of the BM algorithm was an open question until recently. It was shown in [KMP77] that <p> Knuth-Morris-Pratt <ref> [KMP77] </ref> and Boyer-Moore [BM77] algorithms. We refer to them as the KMP and BM algorithms, respectively. The KMP algorithm makes at most 2n m + 1 comparisons and this bound is tight. The exact complexity of the BM algorithm was an open question until recently. It was shown in [KMP77] that the BM algorithm makes at most 6n comparisons if fl The work was supported in part by NSF grants CCR-8902221 and CCR-8906949. y Courant Institute of Mathematical Sciences, New York University. z Max-Planck Institut fur Informatik, Germany. <p> i = fu i v k i i ; ; u i v i ; u i g, where k i 1 is maximal, u i is a proper suffix of v i , and v i is primitive. 2 Actually, a sharper bound of log m groups is known <ref> [KMP77, B94] </ref>, where is the golden ratio. 7 Proof: The proof is by construction. The groups are constructed in left to right order.
Reference: [Lo82] <author> M. </author> <title> Lothaire Combinatorics on words, </title> <journal> Encyclopaedia of Mathematics and its Applications, Addison-Wesley, </journal> <volume> Vol. 17, </volume> <year> 1982. </year>
Reference-contexts: Let u denote the suffix of v 0 of length s. An easy induction shows that v = xu k for some k 2, where x is a proper suffix of u. 2 The following appear in different forms in <ref> [Lo82] </ref> (see Proposition 1.3.2, 1.3.4, and 1.3.5). Lemma 2.2 [LS62, FW65] If x; y are two distinct periods of a string v such that x + y m + gcdfx; yg then gcdfx; yg is also a period of v.
Reference: [LS62] <author> R. Lyndon, M. </author> <title> Schutzenberger The equation a m = b n c p is a free group, </title> <journal> Journal of Michigan Mathematics, </journal> <volume> 9(1962), </volume> <pages> pp. 289-298. </pages>
Reference-contexts: Let u denote the suffix of v 0 of length s. An easy induction shows that v = xu k for some k 2, where x is a proper suffix of u. 2 The following appear in different forms in [Lo82] (see Proposition 1.3.2, 1.3.4, and 1.3.5). Lemma 2.2 <ref> [LS62, FW65] </ref> If x; y are two distinct periods of a string v such that x + y m + gcdfx; yg then gcdfx; yg is also a period of v. Lemma 2.3 Suppose that v = xy where both x and y are presufs of v.
Reference: [Vi85] <author> U. </author> <title> Vishkin Optimal parallel pattern matching in strings, </title> <journal> Information and Control, </journal> <volume> 67(1985), </volume> <pages> pp. 91-113. </pages>
Reference-contexts: So long as the overlap is not a presuf of p, there will be a difference point. This is exactly the notion of duelling introduced by Vishkin <ref> [Vi85] </ref>. More formally, let p a and p b be the two leftmost surviving pattern instances, where p b is not a presuf overlap of p a .
Reference: [ZP92] <author> U. Zwick, M. </author> <title> Paterson Lower bounds for string matching in the sequential comparison model, </title> <type> Manuscript. 57 </type>
Reference-contexts: Recently, Zwick and Paterson gave additional lower bounds, including a bound of 4n 3 for patterns of length 3 in the general case <ref> [ZP92] </ref>. Our contribution is a linear time online algorithm for string matching which makes at most n (1 + 8 3 (m+1) ) character comparisons. Our algorithm requires O (m) space and O (m 2 ) preprocessing time and runs in O (m + n) time overall (exclusive of preprocessing).
References-found: 23

