URL: ftp://ftp.cs.brown.edu/pub/techreports/93/cs93-45.ps.Z
Refering-URL: http://www.cs.brown.edu/publications/techreports/reports/CS-93-45.html
Root-URL: http://www.cs.brown.edu/
Abstract-found: 0
Intro-found: 0
Reference: [1] <author> P. A. Bernstein, V. Hadzilacos, and N. Goodman. </author> <title> Concurreny Control and Recovery in Database Systems. </title> <publisher> Addison Westley, </publisher> <year> 1987. </year>
Reference-contexts: It is the coordination of the log and the heap of base versions that provides full persistence. ObServer2 introduces a recovery algorithm called No-Redo Write Ahead Logging (NR-WAL) as a way to reduce the overhead of recovery. Intentions lists are used to eliminate the undo phase of recovery <ref> [1] </ref>. There is no redo phase because NR-WAL does not require the current state of an object to be stored stably, so the stable state does not need to be recovered immediately after a crash. The most recent state before the crash can be reconstructed later on demand. <p> A further explanation of NR-WAL requires a discussion of our concurrency control algorithm. ObServer2 uses a timestamp based, optimistic concurrency control algorithm [12]. A transaction collects its operations in an intentions list <ref> [1] </ref>. During the transaction the operations are incrementally written to a sequential log in stable storage. Figure 4 shows the Transaction Table and two Intention Records in the log. A record in the log is addressed by its Log Sequence Number (LSN).
Reference: [2] <author> Toby Bloom and Stanley B. Zdonik. </author> <booktitle> Issues in the Design of Object-Oriented Database Programming Languages. In OOPSLA, </booktitle> <pages> pages 441-451. </pages> <publisher> ACM, </publisher> <month> October </month> <year> 1987. </year> <note> [3] et al. </note> <author> C. Mohan. </author> <title> Aries: A transaction recovery method supporting fine-granularity locking and partial rollbacks using write-ahead logging. </title> <journal> ACM TODS, </journal> <volume> 17(1), </volume> <year> 1992. </year>
Reference: [4] <author> Michael J. Carey et al. </author> <title> Object and file management in the EXODUS extensible database system. </title> <booktitle> In Proceedings of the Twelfth International Conference on Very Large Data Bases, </booktitle> <pages> pages 91-100, </pages> <address> Kyoto, Japan, </address> <month> August </month> <year> 1986. </year> <month> 26 </month>
Reference-contexts: There are a number of other systems that serve objects or pages. These include Mneme [15], ESM <ref> [4] </ref>, and the original ObServer [13]. Postgres [18] and Starburst [9] are two extensible relational database systems. Object servers draw from file system technology for persistent storage and cache coherency. <p> Much of the functionality that ObServer offered is encapsulated in one storage class within ObServer 2. The ability to add new storage structures allows ObServer2 to be specialized for high performance on specific applications. 23 The Exodus Storage Manager (ESM) <ref> [4] </ref>, a page server developed at Wisconsin, provides support for values and indices. It generalizes the Aries Transaction Recovery System [3] to operate in the client-server model.
Reference: [5] <author> G. Delott. </author> <title> Performance improvements in the observer object server. </title> <type> Masters thesis, </type> <institution> Department of Computer Science, Brown University, </institution> <year> 1989. </year>
Reference-contexts: The experiments described here will shed light on the implementation of all database systems and offer insight into the construction of high performance database systems. * Naming Our experiments with the original ObServer showed that object naming and location is an important performance parameter <ref> [5] </ref>. In the ObServer2 prototype, the storage class mechanism allows experimentation with alternative naming strategies. * Caching Some work at Brown on intelligent, predictive caching algorithms has shown their theoretic importance and simulations have shown that they will have a practical application [16, 19].
Reference: [6] <editor> J. L. Eppinger, L. B. Mummert, and A. Z. Spector, editors. Camelot and Avalon. </editor> <publisher> Morgan Kaufmann, </publisher> <year> 1991. </year>
Reference-contexts: It does not provide recovery. Mneme semantics could possibly be provided by on storage class in an ObServer2 configuration. This would provide the benefits of a Mneme system and in addition recovery and the availability of other storage classes for specialized purposes. Camelot <ref> [6] </ref> is another system that could be classified as a page server, but with a slightly different computation model. Camelot provides the abstraction of persistent virtual memory to data servers that run on the same node as the persistent data is stored. <p> However there is a major difference. The Camelot grid an index structure stored in volatile memory and must be reconstructed after a failure. The update and intentions lists in ObServer2 are stored persistently in the log and do not need to be recovered after a failure. The Avalon <ref> [6] </ref> language uses Camelot to provide a persistent C++. Because Camelot provides only persistent virtual memory, the semantics of the objects implemented in Avalon are lost at the persistence layer.
Reference: [7] <author> B. Liskov et al. </author> <title> Replication in the harp file system. </title> <booktitle> In 13th ACM SOSP, </booktitle> <year> 1991. </year>
Reference-contexts: Postgres [18] and Starburst [9] are two extensible relational database systems. Object servers draw from file system technology for persistent storage and cache coherency. The section closes with a comparison between ObServer2 and the Andrew File System [8], the Harp replicated file system <ref> [7] </ref>, and a Log Structured File System [17]. 8.1 Object & Page Servers The basic service ObServer2 provides is transactional support for persistent objects in a distributed client-server environment. There are two different sorts of systems which provide this service, page servers and object servers.
Reference: [8] <author> J. H. Howard et al. </author> <title> Scale and performance in a distributed file system. </title> <journal> ACM TOCS, </journal> <volume> 6, </volume> <year> 1988. </year>
Reference-contexts: These include Mneme [15], ESM [4], and the original ObServer [13]. Postgres [18] and Starburst [9] are two extensible relational database systems. Object servers draw from file system technology for persistent storage and cache coherency. The section closes with a comparison between ObServer2 and the Andrew File System <ref> [8] </ref>, the Harp replicated file system [7], and a Log Structured File System [17]. 8.1 Object & Page Servers The basic service ObServer2 provides is transactional support for persistent objects in a distributed client-server environment. <p> In an object store the problem would be even worse because of the finer granularity of naming. Also, garbage collection is much more complex than segment compaction. AFS is interesting for its distribution properties. AFS 3.x <ref> [8] </ref> is a distributed file system that serves a similar purpose to Sun's NFS. However, the scale of the distributed system that AFS can operate within is much larger than Sun's NFS. NFS was meant to operate within a single organization, while AFS can handle global distribution.
Reference: [9] <author> P. Schawarz et al. </author> <title> Extensibility in the starburst datbase system. </title> <booktitle> In Intl. Workshop on Object-Oriented Database Systems, </booktitle> <year> 1986. </year>
Reference-contexts: There are a number of other systems that serve objects or pages. These include Mneme [15], ESM [4], and the original ObServer [13]. Postgres [18] and Starburst <ref> [9] </ref> are two extensible relational database systems. Object servers draw from file system technology for persistent storage and cache coherency. <p> Because Camelot provides only persistent virtual memory, the semantics of the objects implemented in Avalon are lost at the persistence layer. ObServer2 captures semantics within the persistence layer to allow for special memory management policies or type specific concurrency control. 8.2 Extended Relational Starburst <ref> [9] </ref> extends relational databases in five areas, external data storage, storage management, access methods, abstract types, and complex objects. Many of the issues that Starburst address are at the data model level and should be compared to an OODB, not to an object store.
Reference: [10] <author> M. Franklin and M. Carey. </author> <title> Client-server caching revisited. </title> <booktitle> In Int'l Workshop on Distributed Object Management, </booktitle> <address> Edmonton, Canada, </address> <year> 1992. </year>
Reference-contexts: In a client-server distributed system, there is the problem of keeping cached copies of data up-to-date with respect to the primary copy at the server. This problem is particularly acute in database systems which provide strict correctness guarantees <ref> [10] </ref>. The communication cost of keeping these caches up-to-date becomes a performance bottleneck. 2. A traditional implementation of the most popular and efficient recovery mechanism in database systems, Write Ahead Logging, requires either a redo phase or an undo phase or both during recovery. <p> ObServer2 informs client caches of updates asynchronously. In ObServer2, cache coherency is not required for correctness because each object is tagged with a version number. In many systems cache coherency is required for correctness and the required synchronous communication becomes a bottleneck <ref> [10] </ref>. This allows ObServer2 to construct larger messages containing more updates and make more efficient use of the network. ObServer2 informs the clients of updates by periodically broadcasting recent updates to the Version Table. <p> Data can be cached on a client's local disk for extended periods of time. Cache coherency becomes a problem when caching data for long periods of time. AFS introduced call back locking which caches locks as well as data at clients. Franklin <ref> [10] </ref> shows that this is a desirable protocol for database systems as well. Failures cause problems with consistency when locks are cached. AFS solves this problem by using locks that expire after a well known period of time. ObServer2 does not require that the cache be kept perfectly coherent.
Reference: [11] <author> J. </author> <title> Grey. Notes on database operating systems. </title> <editor> In R. Bayer, editor, </editor> <booktitle> Lecture Notes in Computer Science. </booktitle> <publisher> Springer Verlag, </publisher> <year> 1978. </year>
Reference-contexts: The object is up-to-date if they are the same. Otherwise, the Version Table points to the operations that need to be applied. If the transaction spans multiple servers, a 2-phase commit algorithm is used <ref> [11] </ref>. The first and second phases of 2-phase commit modify the tables to indicate their current state. It is worth noting that updates do not lock the entire Version Table or Transaction Table at once. <p> The version table serves several purposes. An entry in the version table consists of the LSN of the last operation performed on an object and a flag to support 2-phase commit <ref> [11] </ref>. Because this operation could have occurred in a previous wrap of the log, the entire LSN is stored. The version table must contain an entry for every object whose stable copy is not up-to-date. <p> Prepare and commit do not bring the entire database into a consistent state. That is done sometime later by a background process. Figures 6 and 7 show the basic flow of information and control during a transaction. The 2-phase commit algorithm described in <ref> [11] </ref> describes how to synchronize the servers. This section describes what happens within the phases. 16 Before a client transaction manager sends a commit record to the server it has sent all the intention records.
Reference: [12] <author> M. Herlihy. </author> <title> Apologising versus asking permission: Optimistic concurrency control for abstract datatypes. </title> <journal> ACM Trans. on Database Systems, </journal> <volume> 15(1) </volume> <pages> 96-124, </pages> <month> March </month> <year> 1990. </year>
Reference-contexts: The core of NR-WAL algorithm is based on a set of data structures that determine when to apply an operation to an object. A further explanation of NR-WAL requires a discussion of our concurrency control algorithm. ObServer2 uses a timestamp based, optimistic concurrency control algorithm <ref> [12] </ref>. A transaction collects its operations in an intentions list [1]. During the transaction the operations are incrementally written to a sequential log in stable storage. Figure 4 shows the Transaction Table and two Intention Records in the log. <p> An LSN is a tuple, where the low order bits encode a memory address in the log. Interpreted as an integer this number strictly increases as the log is written until the log wraps around. Our concurrency control algorithm <ref> [12] </ref> requires a time stamp that increases strictly over all time, not in a piece meal fashion. To correct this, the memory address is augmented with a count of how many times the log has wrapped around.
Reference: [13] <author> M. F. Hornik and S. B. Zdonik. </author> <title> A shared, segmented memory system for and object-oriented database. </title> <journal> ACM Transactions on Office Information Systems, </journal> <volume> 5(1) </volume> <pages> 70-85, </pages> <month> January </month> <year> 1987. </year>
Reference-contexts: There are a number of other systems that serve objects or pages. These include Mneme [15], ESM [4], and the original ObServer <ref> [13] </ref>. Postgres [18] and Starburst [9] are two extensible relational database systems. Object servers draw from file system technology for persistent storage and cache coherency. <p> It is easier to move an object in an Object store because object identity is independent of object location. This comes at the cost of added complexity in dereferencing an object. ObServer <ref> [13] </ref>, the precursor to ObServer2, introduced several features: semantic clustering of related objects, a novel lock set for cooperative work, and a notification system which also supports cooperative work. ObServer2 improves on ObServer in the areas of distribution, extensibility, and performance. ObServer offered only multi-client, single-server distribution.
Reference: [14] <author> B. Liskov. </author> <title> A highly available object repository for use in a hetrogenous distributed system. </title> <booktitle> In Persistent Object Systems Workshop, </booktitle> <month> September </month> <year> 1990. </year>
Reference: [15] <author> E. Moss. </author> <title> The mneme persistent object store. </title> <type> Technical Report TR 89-107, COINS, </type> <institution> University of Massachusetts at Amherst, </institution> <month> October </month> <year> 1989. </year>
Reference-contexts: There are a number of other systems that serve objects or pages. These include Mneme <ref> [15] </ref>, ESM [4], and the original ObServer [13]. Postgres [18] and Starburst [9] are two extensible relational database systems. Object servers draw from file system technology for persistent storage and cache coherency. <p> The ObServer2 storage class mechanism serves as a test bed which allows new memory management policies to be experimented in the context of an operating database. The Mneme Persistent Object Store <ref> [15] </ref> explores the integration of an object store with a persistent programming language. It provides a persistent heap of objects that are available in a distributed system. The object model for Mneme is fixed, but it does offer some support for specialized buffering policies.
Reference: [16] <author> M. Palmer and S. Zdonik. </author> <title> Fido: A cache that learns how to fetch. </title> <booktitle> In VLDB, </booktitle> <year> 1991. </year>
Reference-contexts: In the ObServer2 prototype, the storage class mechanism allows experimentation with alternative naming strategies. * Caching Some work at Brown on intelligent, predictive caching algorithms has shown their theoretic importance and simulations have shown that they will have a practical application <ref> [16, 19] </ref>. There are a number of issues to be resolved in actually incorporating an intelligent, predictive cache in a database.
Reference: [17] <author> M. Rosenblum and J. K. Ousterhout. </author> <title> The design and implementation of a log-structured file system. </title> <booktitle> In 13th SOSP, </booktitle> <year> 1991. </year>
Reference-contexts: Object servers draw from file system technology for persistent storage and cache coherency. The section closes with a comparison between ObServer2 and the Andrew File System [8], the Harp replicated file system [7], and a Log Structured File System <ref> [17] </ref>. 8.1 Object & Page Servers The basic service ObServer2 provides is transactional support for persistent objects in a distributed client-server environment. There are two different sorts of systems which provide this service, page servers and object servers. <p> LFS is interesting because it shows the feasibility of reading from a log given a reasonable cache. ObServer2 uses this facility to delay writes to the stable store. LFS <ref> [17] </ref> keeps all data in a log, significantly reducing the cost of a write. The disadvantage of a log is that it cannot be accessed quickly. A large RAM cache contains all the access structures to find data in the log and the most recently used data.
Reference: [18] <author> M. Stonebraker. </author> <title> The design of the postgres storage system. </title> <booktitle> In Proc. 13th VLDB, </booktitle> <year> 1987. </year>
Reference-contexts: There are a number of other systems that serve objects or pages. These include Mneme [15], ESM [4], and the original ObServer [13]. Postgres <ref> [18] </ref> and Starburst [9] are two extensible relational database systems. Object servers draw from file system technology for persistent storage and cache coherency. <p> The storage class implementor has exact control over whether parts of the abstraction are built up at the client or the server. The goals of the Postgres Storage Manager are instantaneous recovery, historical access, and utilization of new technology <ref> [18] </ref>. Postgres provides a linear history and allows more than one version of an object to be viewed in a transaction. Since Postgres keeps the entire history of all its data, the recovery system differs from conventional systems.
Reference: [19] <author> J. S. Vitter and P. Krishnan. </author> <title> Optimal prefetching via data compression. </title> <booktitle> In ACM FOCS, </booktitle> <year> 1991. </year>
Reference-contexts: In the ObServer2 prototype, the storage class mechanism allows experimentation with alternative naming strategies. * Caching Some work at Brown on intelligent, predictive caching algorithms has shown their theoretic importance and simulations have shown that they will have a practical application <ref> [16, 19] </ref>. There are a number of issues to be resolved in actually incorporating an intelligent, predictive cache in a database.
Reference: [20] <author> W. Weihl. </author> <title> Concurrency Control For Abstract Data Types. </title> <type> PhD thesis, </type> <institution> MIT, </institution> <month> 19?? </month>
Reference-contexts: The redos are applied on demand as the objects are read or asynchronously after recovery by the same background process that normally applies updates. 3. Local Concurrency Control The design of ObServer2 applies the theory of local concurrency control to separate concurrency control and storage management concerns <ref> [20] </ref>. Objects in ObServer2 are fully abstract with respect to the transaction manager. Objects can be implemented in different ways or offer different operations. This allows support for all existing database access methods as well as any that may be invented in the future.
Reference: [21] <author> W. Weihl and B. Liskov. </author> <title> Implementation of resilient atomic data types. </title> <booktitle> In ACM Transactions on Programing Languages and Systems, </booktitle> <month> April </month> <year> 1985. </year>
Reference-contexts: All copies of an object with 5 the same Version Number and the same OID have the same state. Each storage class defines its own type specific concurrency control. The advantages of type specific concurrency control are discussed at length in <ref> [21] </ref>. In short, higher potential concurrency can be achieved by taking advantage of the semantics of the various operations that can be performed on an object. Concurrency control and recovery are performed on a per object basis within a class. <p> The conflict operation takes two arguments, an OID and an operation: bool Conflict (OID o, Object () *Op1); The Conflict operation determines if Op could invalidate the committed state of o based on the semantics of the operation and the arguments to the operation <ref> [21] </ref>. The operation cannot access the state of the object or the state of objects to which the object under consideration refers, but the arguments to the operation are available.
Reference: [22] <author> Stanley Zdonik and Gail Mitchell. ENCORE: </author> <title> An Object-Oriented Approach to Database Modelling and Querying. </title> <journal> IEEE Data Engineering Bulletin, </journal> <volume> 14(2), </volume> <month> June </month> <year> 1991. </year> <month> 27 </month>
References-found: 21

