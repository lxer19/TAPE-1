URL: http://www.cs.iastate.edu/tech-reports/TR92-23.ps
Refering-URL: http://www.cs.iastate.edu/tech-reports/catalog.html
Root-URL: http://www.cs.iastate.edu
Title: The Complexity and Distribution of Hard Problems  
Author: TR - David W. Juedes and Jack H. Lutz 
Address: 226 Atanasoff Ames, IA 50011  
Affiliation: Iowa State University of Science and Technology Department of Computer Science  
Date: August 13, 1992  
Abstract-found: 0
Intro-found: 1
Reference: [Amb86] <author> K. Ambos-Spies. </author> <title> Randomness, relativizations, and polynomial re-ducibilities. </title> <booktitle> In Proceedings of the First Structure in Complexity Theory Conference, </booktitle> <pages> pages 23-34, </pages> <year> 1986. </year>
Reference-contexts: It follows by Lemma 3.1 that p (P 1 m (A) fi fi E) = 0. This completes the proof of 1. The proof of 2 is identical. One need only note that, if A 2 E 2 , then d 2 p 2 . 2 Remark. Ambos-Spies <ref> [Amb86] </ref> has shown that P m (A) has Lebesgue measure 0 whenever A 62 P. Lemma 5.2 obtains a stronger conclusion (resource-bounded measure 0) from a stronger hypothesis on A. It is now straightforward to derive consequences of these results for the structure of E and E 2 .
Reference: [BD87] <author> R. Book and D.-Z. Du. </author> <title> The existence and density of generalized complexity cores. </title> <journal> Journal of the ACM, </journal> <volume> 34 </volume> <pages> 718-730, </pages> <year> 1987. </year>
Reference-contexts: We prove that P m -hard problems are rare, in the sense that they form a p-measure 0 set; and that every P m -degree has measure 0 in exponential time. Complexity cores, first introduced by Lynch [Lyn75] have been studied extensively <ref> [Du85, ESY85, Orp86, OS86, BD87, Huy87, RO87, BDR88, DB89, Ye90, etc.] </ref>. Intuitively, a complexity core of a language A is a fixed set K of inputs such that every machine whose decisions are consistent with A fails to decide efficiently on all but finitely many elements of K.
Reference: [BDG88] <author> J. L. Balcazar, J. Daz, and J. Gabarro. </author> <title> Structural Complexity I. </title> <publisher> Springer-Verlag, </publisher> <year> 1988. </year>
Reference-contexts: We write P and PF for the set of languages and functions, respectively, that are computable in polynomial time. We are especially interested in the classes of languages computable in exponential time. Our notation for the exponential time classes differs slightly from that of <ref> [BDG88, BDG90] </ref>. We write E = c=1 DTIME (2 cn ) and E 2 = c=1 DTIME (2 n c ) for the classes of languages computable in DTIME (2 linear ) and DTIME (2 polynomial ), respectively. <p> The other standard complexity classes that we use here, such as NP, PH, PSPACE, etc., are defined precisely as in <ref> [BDG88, BDG90] </ref>. If A and B are languages, then a polynomial time, many-one reduction (briefly P m reduction) of A to B is a function f 2 PF such that A = f 1 (B) = fx j f (x) 2 Bg.
Reference: [BDG90] <author> J. L. Balcazar, J. Daz, and J. Gabarro. </author> <title> Structural Complexity II. </title> <publisher> Springer-Verlag, </publisher> <year> 1990. </year>
Reference-contexts: We write P and PF for the set of languages and functions, respectively, that are computable in polynomial time. We are especially interested in the classes of languages computable in exponential time. Our notation for the exponential time classes differs slightly from that of <ref> [BDG88, BDG90] </ref>. We write E = c=1 DTIME (2 cn ) and E 2 = c=1 DTIME (2 n c ) for the classes of languages computable in DTIME (2 linear ) and DTIME (2 polynomial ), respectively. <p> The other standard complexity classes that we use here, such as NP, PH, PSPACE, etc., are defined precisely as in <ref> [BDG88, BDG90] </ref>. If A and B are languages, then a polynomial time, many-one reduction (briefly P m reduction) of A to B is a function f 2 PF such that A = f 1 (B) = fx j f (x) 2 Bg. <p> Intuitively, a P-complexity core of A is a set of infeasible instances of A, while an exponential complexity core of A is a set of extremely hard instances of A. Remark. The above definition quantifies over all machines consistent with A, while the standard definition of complexity cores (cf. <ref> [BDG90] </ref>) quantifies only over machines that decide A. This difference renders our definition stronger than the standard definition when A is not recursive. For example, consider tally languages (i.e., languages A f0g fl ).
Reference: [BDR88] <author> R. Book, D.-Z Du, and D. Russo. </author> <title> On polynomial and generalized complexity cores. </title> <booktitle> In Proceedings of the Third Structure in Complexity Theory Conference, </booktitle> <pages> pages 236-250, </pages> <year> 1988. </year>
Reference-contexts: We prove that P m -hard problems are rare, in the sense that they form a p-measure 0 set; and that every P m -degree has measure 0 in exponential time. Complexity cores, first introduced by Lynch [Lyn75] have been studied extensively <ref> [Du85, ESY85, Orp86, OS86, BD87, Huy87, RO87, BDR88, DB89, Ye90, etc.] </ref>. Intuitively, a complexity core of a language A is a fixed set K of inputs such that every machine whose decisions are consistent with A fails to decide efficiently on all but finitely many elements of K.
Reference: [Ber76] <author> L. Berman. </author> <title> On the structure of complete sets: Almost everywhere complexity and infinitely often speedup. </title> <booktitle> In Proceedings of the Seventeenth Annual Conference on Foundations of Computer Science, </booktitle> <pages> pages 76-80, </pages> <year> 1976. </year>
Reference-contexts: Languages that are P m -hard for E are typically considered "at least as complex as" any element of E. Very early, Berman <ref> [Ber76] </ref> established limits to this interpretation by proving that no P m -complete language is P-immune, even though E contains P-immune languages. (In fact, Mayor-domo [May92] has recently shown that almost every language in E is P-bi-immune.) In section 6 below we prove a much stronger limitation on the complexity of <p> Corollary 5.4.(Mayordomo [May92]). Let C E , C E 2 be the sets of languages that are P m -complete for E, E 2 , respectively. Then (C E jE) = (C E 2 jE 2 ) = 0. 2 (Mayordomo's proof of Corollary 5.4 used Berman's result <ref> [Ber76] </ref>, that no P m -complete language for E is P-immune.) As it turns out, Corollary 5.4 is only a special case of the following general result. All P m -degrees have measure 0 in E and in E 2 : Theorem 5.5.
Reference: [BH77] <author> L. Berman and J. Hartmanis. </author> <title> On isomorphism and density of NP and other complete sets. </title> <journal> SIAM Journal on Computing, </journal> <volume> 6 </volume> <pages> 305-322, </pages> <year> 1977. </year>
Reference: [BS85] <author> J. L. Balcazar and U. Schoning. </author> <title> Bi-immune sets for complexity classes. </title> <journal> Mathematical Systems Theory, </journal> <volume> 18 </volume> <pages> 1-10, </pages> <year> 1985. </year>
Reference-contexts: This enables one to eliminate the extraneous hypothesis that A is recursive from several results. In some cases (e.g., the fact that A is P-bi-immune if and only if f0; 1g fl is a P-complexity core for A <ref> [BS85] </ref>), this improvement is of little interest. However in section 6 below, we show that every P m -hard language H for E has unusually small complexity cores. This upper bound holds regardless of whether H is recursive. <p> Our first observation, an obvious generalization of a result of Balcazar and Schoning <ref> [BS85] </ref> (see Corollary 4.2 below), relates incompressibility to complexity cores. Lemma 4.1. If t : N ! N is time constructible then every language that is incompressible by DTIME (t) m -reductions has f0; 1g fl as a DTIME (t)- complexity core. Proof. <p> Since F is infinite, at least one of the sets f 1 (fug), f 1 (fvg) is infinite, so the collision set C f is infinite. Thus A is not incompressible by DTIME (t) m -reductions. 2 Corollary 4.2. Let c 2 N. 1. (Balcazar and Schoning <ref> [BS85] </ref>). Every language that is incompress ible by P m -reductions has f0; 1g fl as a P-complexity core. 2. Every language that is incompressible by DTIME (2 cn ) m -reductions has f0; 1g fl as a DTIME (2 cn )-complexity core. 11 3.
Reference: [DB89] <author> D.-Z. Du and R. </author> <title> Book. On inefficient special cases of NP-complete problems. </title> <journal> Theoretical Computer Science, </journal> <volume> 63 </volume> <pages> 239-252, </pages> <year> 1989. </year>
Reference-contexts: We prove that P m -hard problems are rare, in the sense that they form a p-measure 0 set; and that every P m -degree has measure 0 in exponential time. Complexity cores, first introduced by Lynch [Lyn75] have been studied extensively <ref> [Du85, ESY85, Orp86, OS86, BD87, Huy87, RO87, BDR88, DB89, Ye90, etc.] </ref>. Intuitively, a complexity core of a language A is a fixed set K of inputs such that every machine whose decisions are consistent with A fails to decide efficiently on all but finitely many elements of K.
Reference: [Du85] <author> D.-Z. Du. </author> <title> Generalized complexity cores and levelability of intractable sets. </title> <type> PhD thesis, </type> <institution> University of California, Santa Barbara, </institution> <year> 1985. </year>
Reference-contexts: We prove that P m -hard problems are rare, in the sense that they form a p-measure 0 set; and that every P m -degree has measure 0 in exponential time. Complexity cores, first introduced by Lynch [Lyn75] have been studied extensively <ref> [Du85, ESY85, Orp86, OS86, BD87, Huy87, RO87, BDR88, DB89, Ye90, etc.] </ref>. Intuitively, a complexity core of a language A is a fixed set K of inputs such that every machine whose decisions are consistent with A fails to decide efficiently on all but finitely many elements of K.
Reference: [ESY85] <author> S. Even, A. Selman, and Y. Yacobi. </author> <title> Hard core theorems for complexity classes. </title> <journal> Journal of the ACM, </journal> <volume> 35 </volume> <pages> 205-217, </pages> <year> 1985. </year>
Reference-contexts: We prove that P m -hard problems are rare, in the sense that they form a p-measure 0 set; and that every P m -degree has measure 0 in exponential time. Complexity cores, first introduced by Lynch [Lyn75] have been studied extensively <ref> [Du85, ESY85, Orp86, OS86, BD87, Huy87, RO87, BDR88, DB89, Ye90, etc.] </ref>. Intuitively, a complexity core of a language A is a fixed set K of inputs such that every machine whose decisions are consistent with A fails to decide efficiently on all but finitely many elements of K.
Reference: [GJ79] <author> M. R. Garey and D. S. Johnson. </author> <title> Computers and Intractability: </title>
Reference-contexts: A language C is P m complete for C if C 2 C and C is P m -hard for C. If C = NP, this is the usual notion of NP-completeness <ref> [GJ79] </ref>. In this paper we are especially concerned with languages that are P m -hard or P m -complete for E or E 2 . 3 Resource-Bounded Measure In this section we review some fundamentals of the resource-bounded measure formulated by Lutz in [Lut92a, Lut92c].
References-found: 12

