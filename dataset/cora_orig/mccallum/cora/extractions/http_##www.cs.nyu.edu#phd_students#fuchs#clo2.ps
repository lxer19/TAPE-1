URL: http://www.cs.nyu.edu/phd_students/fuchs/clo2.ps
Refering-URL: http://www.cs.nyu.edu/phd_students/fuchs/index.html
Root-URL: http://www.cs.nyu.edu
Email: matt@wdi.disney.com  
Title: Using Scoping Rules as a Distributed Coordination Language  
Author: Matthew Fuchs Walt Disney Imagineering 
Address: Flower St., POB 25020 Glendale, CA 91221-5020  
Affiliation: 1401  
Abstract: Essential to coordinating a distributed application is organizing and traversing the distributed application graph. Lexical scoping performs this function among modern high-level programming languages, but does not have the same distinction in distributed programming systems, where it competes with various forms of associative and object-oriented binding. We will show that distributed lexical scop-ing, combined with closures, provides a powerful means of coordinating communication in distributed computations and can significantly reduce the complexity for developing certain types of applications vis-a-vis other coordination paradigms/languages. These results are not dependent on a particular programming language, and can be combined with existing paradigms. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Nicholas Carriero and David Gelernter. </author> <title> How to write parallel programs: A guide to the perplexed. </title> <journal> ACM Computing Surveys, </journal> <volume> 21(3), </volume> <year> 1989. </year>
Reference-contexts: 1 Introduction A distributed application is inherently a directed graph, with spatially separated computing nodes communicating over network nodes. A primary challenge in coordinating distributed systems is organizing and traversing this graph. This challenge was crystallized in the idea of coordination languages <ref> [1, 8] </ref>, languages for describing the network component of the application distinct, and possibly completely different, from the computing component. Distributed computing has had a number of these languages, whether they fl Copyright 1996 IEEE. Published in the Proceeding of the Hawaii International Conference on System Sciences, 1/7/97-1/10/97, Maui, Hawaii. <p> Consequently, expanding an application, or merging two applications, requires examining the global tuple space. As loose binding is the virtue of the Linda model, Linda is most appropriate when the application can be expressed in terms of the concurrent manipulation of large distributed data structures <ref> [1] </ref>. The processes that build and modify the data structure can function in complete isolation from each other. Even so, the complexity of the data structure must be reflected in the complexity of the tuple space operations.
Reference: [2] <author> Nicholas Carriero and David Gelernter. </author> <title> Linda in context. </title> <journal> Communications of the ACM, </journal> <volume> 32(4), </volume> <year> 1989. </year>
Reference-contexts: They could also be Scheme objects, or a combination. 3.2 Associative Memory The paradigmatic example of the associative memory paradigm for concurrent/distributed systems is Linda [8]. In the taxonomy of <ref> [2] </ref>, Linda is a coordination languages. Coordination languages coordinate communication among processes running in a conventional serial language and are generally (as in the case of Linda) of small size.
Reference: [3] <author> Nicholas Carriero, David Gelernter, and Lenore Zuck. Bauhaus linda. In Paolo Ciancarini and others, </author> <title> editor, Object-Based Models for Concurrent Systems. </title> <publisher> LNCS 924, Springer-Verlag, </publisher> <year> 1995. </year>
Reference: [4] <editor> William Clinger, Jonathan Rees, et al. </editor> <title> Revised 4 Report on the Algorithmic Language Scheme. </title> <year> 1991. </year>
Reference-contexts: Lexical scoping has been a common feature of sequential higher-level programming languages since Algol 60 and has been in the functional programming world at least since the development of Scheme <ref> [4] </ref>. Lexical scoping has also been a feature of concurrent languages, particularly where shared memory is available. Given the success of lexical scoping in programming language development and its much touted benefits for program clarity, one would expect it to be widely used in distributed systems. <p> Scheme includes six scoping constructs, of which we will require only let, letrec, let* and lambda. The remaining two, begin and do, are not necessary for this exercise <ref> [4] </ref>. All of these can actually be reduced to lambda. The first three have the same syntax, a list of (name, expression) pairs followed by a body.
Reference: [5] <author> Digital Equipment Corporation et al. </author> <title> The Common Object Request Broker: architecture and specification. </title> <booktitle> Object Management Group, </booktitle> <year> 1991. </year>
Reference-contexts: Examples of this model are Mentat [9], which provides concurrent and distributed C++ services, and CORBA <ref> [5] </ref>, a language independent industry standard for remote invocation. Emerald [12], an object-oriented language with mobile objects, is an interesting forerunner.
Reference: [6] <author> Matthew Fuchs. Dreme: </author> <title> for Life in the Net. </title> <type> PhD thesis, </type> <address> New York University, </address> <year> 1995. </year>
Reference-contexts: In the object model, an object in one process uses a reference to an object in another process to invoke a method. In the ideal case, objects are treated the same whether they are co-located with the invoker or on another node of the network. Our experiments with Dreme <ref> [6] </ref>, a distributed dialect of Scheme with fully mobile objects, indicates that lexical scoping, with the addition of first-class closures, is not only an effective structure for coordinating distributed applications, but is superior to these alternatives in its ability to concisely describe arbitrary application graphs.
Reference: [7] <author> Matthew Fuchs. </author> <title> Escaping the event loop: an alternative control structure for multi-threaded guis. </title> <editor> In Carl Unger and Len Bass, editor, </editor> <booktitle> Engineering for HCI. </booktitle> <publisher> Chapman and Hall, </publisher> <year> 1996. </year>
Reference-contexts: As we will see, this flexibility allows us to embed any directed graph into this framework. This approach is not necessarily restricted to a particular language. In the bridge example we have experimented with using lexical scopes to control distributed events <ref> [7] </ref>. Events are grouped in scopes, with each event having certain synchronization characteristics that can apply to other events within the same scope. Scopes and events are all first class objects, so they can be queried and manipulated by the application.
Reference: [8] <author> David Gelernter. </author> <title> Generative communication in Linda. </title> <journal> Transactions on Programming Languages and Systems, </journal> <volume> 7(1), </volume> <year> 1985. </year>
Reference-contexts: 1 Introduction A distributed application is inherently a directed graph, with spatially separated computing nodes communicating over network nodes. A primary challenge in coordinating distributed systems is organizing and traversing this graph. This challenge was crystallized in the idea of coordination languages <ref> [1, 8] </ref>, languages for describing the network component of the application distinct, and possibly completely different, from the computing component. Distributed computing has had a number of these languages, whether they fl Copyright 1996 IEEE. Published in the Proceeding of the Hawaii International Conference on System Sciences, 1/7/97-1/10/97, Maui, Hawaii. <p> They could also be Scheme objects, or a combination. 3.2 Associative Memory The paradigmatic example of the associative memory paradigm for concurrent/distributed systems is Linda <ref> [8] </ref>. In the taxonomy of [2], Linda is a coordination languages. Coordination languages coordinate communication among processes running in a conventional serial language and are generally (as in the case of Linda) of small size.
Reference: [9] <author> A. S. Grimshaw and J. W. S. Liu. </author> <title> Mentat: An object-oriented macro data flow system. </title> <booktitle> In OOPSLA Proceedings, </booktitle> <year> 1987. </year>
Reference-contexts: Although it better supports alternatives, BL still appears targeted towards the kind of application Linda handles best, small independent processes communicating in an anonymous fashion. 3.3 Object Communication In the object model, communication is point-to-point between objects in a distributed data space. Examples of this model are Mentat <ref> [9] </ref>, which provides concurrent and distributed C++ services, and CORBA [5], a language independent industry standard for remote invocation. Emerald [12], an object-oriented language with mobile objects, is an interesting forerunner.
Reference: [10] <author> Henry Cejtin and others. </author> <title> Higher-order distributed objects. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 17(5), </volume> <year> 1995. </year>
Reference-contexts: Lexical scoping compares favorably with associative memory and remote method invocation as means for describing intra-application communication. Ultimately, the greatest strength will come from combining techniques to exploit their differing strengths. Dreme is not alone in supporting distributed lexical scop-ing as a primary means of controlling distributed communication. Kali <ref> [10] </ref> is another distributed dialect of Scheme with very similar features to Dreme. Both support the dynamic movement of all types of Scheme objects around a network as components of messages, with correct communication among mobile objects ensured by Scheme's lexical scoping rules.
Reference: [11] <author> Suresh Jagannathan. </author> <title> Customization of first-class tuple-spaces in a higher-order language. </title> <booktitle> In PARLE '91. </booktitle> <publisher> Springer Verlag, </publisher> <year> 1991. </year>
Reference-contexts: If we combine lexical scoping and tuple spaces, there is the possibility of a system that combines the best of both worlds. The lexical scoping would keep the name space manageable, while named tuple spaces provide uncoupled communication among processes in the same scope. <ref> [11] </ref> provides first-class tuple spaces in a Scheme-like language. Linda's originators have recently proposed an extension to Linda, called Bauhaus Linda (BL)[3].
Reference: [12] <author> R. K. Raj et al. </author> <title> Emerald: A general-purpose programming language. </title> <journal> Software Practice and Experience, </journal> <volume> 21(1), </volume> <year> 1991. </year>
Reference-contexts: Examples of this model are Mentat [9], which provides concurrent and distributed C++ services, and CORBA [5], a language independent industry standard for remote invocation. Emerald <ref> [12] </ref>, an object-oriented language with mobile objects, is an interesting forerunner.
References-found: 12

