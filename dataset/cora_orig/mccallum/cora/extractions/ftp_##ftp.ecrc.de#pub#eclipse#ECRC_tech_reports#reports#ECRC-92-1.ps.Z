URL: ftp://ftp.ecrc.de/pub/eclipse/ECRC_tech_reports/reports/ECRC-92-1.ps.Z
Refering-URL: http://www.ecrc.de/eclipse/html/CHIC_Methodology.html
Root-URL: http://www.aic.nrl.navy.mil/~aha/people.html
Phone: TEL +49 89/926 99 0 FAX 926 99 170 TLX 521 6910  
Title: Generalised Constraint Propagation Over the CLP Scheme  
Author: Thierry Le Provost Mark Wallace 
Address: ARABELLASTR. 17 D-8000 M UNCHEN 81, GERMANY  
Affiliation: EUROPEAN COMPUTER-INDUSTRY RESEARCH CENTRE ECRC GMBH,  
Abstract: technical report ECRC-92-1 
Abstract-found: 1
Intro-found: 1
Reference: [Ber87] <author> H. Berghel. </author> <title> Crossword compilation with Horn clauses. </title> <journal> The Computer Journal, </journal> <volume> 30(2) </volume> <pages> 183-188, </pages> <year> 1987. </year>
Reference-contexts: In fact a meta-program has been written which takes any crossword drawn as a grid and generates such a program automatically. Yet generalised propagation applied to the resulting program happens to yield a crossword compilation algorithm very similar to one developed specially for crosswords and described in <ref> [Ber87] </ref>.
Reference: [BPM92] <author> S. Bressan, T. Le Provost, and O. Monteil. </author> <title> Experiments with set-oriented propagation. Experiments performed at ECRC: </title> <note> report in preparation, </note> <year> 1992. </year>
Reference-contexts: Moreover we have been experimenting with generalised propagation in a database context, with favourable early results <ref> [BPM92] </ref>.
Reference: [Cla79] <author> K.L. Clark. </author> <title> Predicate logic as a computational formalism. </title> <type> Technical Report 79/59, </type> <institution> Imperial College, </institution> <address> London, </address> <year> 1979. </year>
Reference-contexts: Notice that the information thus extracted could not be expressed using variable domains. The practical relevance of generalised propagation has been tested by implementing it in the underlying constraint theory of first-order terms with syntactic equality <ref> [Cla79] </ref>, which is GP (HU ). Programs are just sets of Prolog rules with annotations identifying the goals to be used for propagation.
Reference: [Col85] <author> A. Colmerauer. </author> <booktitle> Theoretical Model of Prolog II, </booktitle> <pages> pages 3-31. </pages> <publisher> Ablex Publishing Corporation, </publisher> <year> 1985. </year>
Reference-contexts: We shall often refer to constraints in the CSP framework as "propagation constraints". For solving CSP problems in traditional logic programming systems, backtrack search is used. The aim is to perform relevant "tests" as soon as possible after instantiating a variable. Dynamic computation rules, such as freeze <ref> [Col85] </ref> and delay [Nai86, MAC + 89] can be used to determine which goal to evaluate next. However even such dynamic rules can only postpone evaluation until the propagation constraints are partially or fully instantiated.
Reference: [Dav87] <author> E. Davis. </author> <title> Constraint propagation with interval labels. </title> <journal> Artificial Intelligence, </journal> <volume> 32 </volume> <pages> 281-331, </pages> <year> 1987. </year>
Reference-contexts: Traditionally [Mac77, HE80] this is a finite domain, though more recently continuous intervals have been studied <ref> [Dav87] </ref>. Up to now, constraint logic programming systems based on the CSP paradigm (eg CHIP [DVS + 88]) have only been defined for finite domain variables. For each problem variable a finite domain declaration is required. <p> It approximates each of the basic equality constraints X = 1, X = 2 and X = 3. Approximation constraints are a generalisation of Davis' labels <ref> [Dav87] </ref>. The approximation constraints and the basic constraints need not be disjoint: in other words basic constraints could approximate themselves. A GP (X) program is a set of clauses of the form Head Goal 1 ; : : : ; Goal s The head Head is a user atom. <p> This is 1 X 2^1 Y 3^X Y . This is a simple example showing the difference between approximation constraints and "labels" as described by Davis <ref> [Dav87] </ref>. The last atom X Y cannot be expressed by any label on individual variables. We now show that propagation on a given agent is monotonic in the sense that if there is more information in the constraint store then more information will be extracted by propagation.
Reference: [DSV90] <author> M. Dincbas, H. Simonis, and P. Van Hentenryck. </author> <title> Solving large combinatorial problems in logic programming. </title> <journal> Journal of Logic Programming, </journal> <volume> 8 </volume> <pages> 74-94, </pages> <year> 1990. </year>
Reference-contexts: However such propagation techniques can have a dramatic effect in cutting down the size of the search space. Evidence of the practical effectiveness of constraints propagation in logic programming is given in <ref> [DSV90] </ref>. 1.3 Restrictions on Propagation in Logic Programming One prerequisite for applying CSP techniques is that problem variables should have an associated domain of possible values. Traditionally [Mac77, HE80] this is a finite domain, though more recently continuous intervals have been studied [Dav87].
Reference: [DSVX91] <author> M. Dorochevsky, K. Schuermann, A. Veron, and J. Xu. </author> <title> Constraints Handling, Garbage Collection and Execution Model Issues in ElipSys. </title> <editor> In A. Beaumont and G. Gupta, editors, </editor> <booktitle> Proceedings of the ICLP'91 Pre-Conference Workshop on Parallel Execution of Logic Programs, </booktitle> <address> Paris, </address> <month> June </month> <year> 1991. </year> <note> LNCS 569. </note>
Reference-contexts: This will be illustrated using the member predicate in section 4.2 below. 4 Some Instances of GP (X) Two implementations of generalised propagation over the Herbrand universe have been completed. One implementation is in the Elipsys system <ref> [DSVX91] </ref> which runs on a parallel machine. Using finite domains as the approximation language, it has achieved good speedups on disjunctive scheduling programs [PV92] and for temporal reasoning [Lev91]. In the paper we describe the other implementation which is embedded in a sequential prolog compiler system.
Reference: [DVS + 88] <author> M. Dincbas, P. Van Hentenryck, H. Simonis, A. Aggoun, T. Graf, and F. Berthier. </author> <title> The constraint logic programming language CHIP. </title> <booktitle> In Proceedings of the International Conference on Fifth Generation Computer Systems (FGCS'88), </booktitle> <pages> pages 693-702, </pages> <address> Tokyo, Japan, </address> <month> November </month> <year> 1988. </year>
Reference-contexts: Traditionally [Mac77, HE80] this is a finite domain, though more recently continuous intervals have been studied [Dav87]. Up to now, constraint logic programming systems based on the CSP paradigm (eg CHIP <ref> [DVS + 88] </ref>) have only been defined for finite domain variables. For each problem variable a finite domain declaration is required. <p> This has meant that the two approaches to integrating constraints into logic programming, as basic constraints and as propagation constraints, have had to remain quite separate. Even in the CHIP system <ref> [DVS + 88] </ref> which utilises both types of integration, propagation is excluded from those parts of the programs involving new computation domains, such as Boolean algebra or linear rational arithmetic. In this paper we alleviate two restrictions. Firstly we lift the restriction to finite domains, for propagation in logic programming.
Reference: [Fik70] <author> R.E. Fikes. REF-ARF: </author> <title> A system for solving problems stated as procedures. </title> <journal> Artificial Intelligence, </journal> <volume> 1 </volume> <pages> 27-120, </pages> <year> 1970. </year>
Reference-contexts: This check must, in theory, be effective. 1.2 CSP in Logic Programming There is another, very different, CLP paradigm which is based on constraint satisfaction techniques dating back to 1965 <ref> [GB65, Fik70, Mon74] </ref>. In the constraint satisfaction problem (CSP) paradigm the constraints are problem-specific, and defined by sets of tuples. When CSP is embedded into logic programming, a constraint can be defined in the program as a set of facts, or even as a set of rules [Van89]. <p> This is provided by techniques developed for solving constraint satisfaction problems. It should be noted that constraint solving over a computation domain, as described in section 1.1 above, is replaced in this paradigm by constraint propagation over value domains <ref> [Fik70, Mon74, Mac77, HE80] </ref>. Informally constraint propagation operates by looking ahead at yet unsolved goals to see what locally consistent valuations there remain for individual problem variables.
Reference: [Fru92] <author> T. Fruehwirth. </author> <title> Constraint simplification rules. </title> <type> Technical Report ECRC-92-18, </type> <institution> ECRC, </institution> <month> July </month> <year> 1992. </year>
Reference-contexts: The set of interesting constraint stores to be analysed soon grows prohibitively large for non-trivial constraints (see also above section 4.1.2). A form of guarded rules with multiple heads is being investigated at ECRC <ref> [Fru92] </ref>, which provides a language for expressing constraint simplification. The rules are called simplification rules. In many cases it would be practical to express certain interesting propagations as simplification rules.
Reference: [Gal85] <editor> H. Gallaire. </editor> <booktitle> Logic programming: further developments. In IEEE Symposium on Logic Programming, </booktitle> <pages> pages 88-99, </pages> <address> Boston, </address> <month> July </month> <year> 1985. </year> <type> Invited paper. </type>
Reference-contexts: Waiting till the constraint is ground before evaluating, is to use it as an a posteriori test. To summarise, logic programs can only use propagation constraints passively. Our motivation for constraints logic programming is to support the active use of constraints <ref> [Gal85] </ref>. This is provided by techniques developed for solving constraint satisfaction problems. It should be noted that constraint solving over a computation domain, as described in section 1.1 above, is replaced in this paradigm by constraint propagation over value domains [Fik70, Mon74, Mac77, HE80].
Reference: [GB65] <author> S.W. Golomb and L.D. Baumert. </author> <title> Backtrack programming. </title> <journal> Journal of the ACM, </journal> <volume> 12 </volume> <pages> 516-524, </pages> <year> 1965. </year>
Reference-contexts: This check must, in theory, be effective. 1.2 CSP in Logic Programming There is another, very different, CLP paradigm which is based on constraint satisfaction techniques dating back to 1965 <ref> [GB65, Fik70, Mon74] </ref>. In the constraint satisfaction problem (CSP) paradigm the constraints are problem-specific, and defined by sets of tuples. When CSP is embedded into logic programming, a constraint can be defined in the program as a set of facts, or even as a set of rules [Van89].
Reference: [HD91] <author> P. Van Hentenryck and Y. Deville. </author> <title> Operational semantics of constraint logic programming over finite domains. </title> <booktitle> In Proc. </booktitle> <address> PLILP'91, Passau, Germany, </address> <month> Aug </month> <year> 1991. </year>
Reference-contexts: program P , a solution to a query G under a constraint S is an valuation for which X j= S and P j= X G 3.2.3 Operational Semantics for GP (X) We have chosen a transformational semantics for our constraint logic programming system following the approach of [Sar89] and <ref> [HD91] </ref>. <p> It is the spontaneous production of new information, in the form of approximation constraints, that we call generalised propagation. Generalised propagation can be seen as an example of the relaxed tell operation of <ref> [HD91] </ref> which is discussed in more detail in section 5.2, below. <p> This condition is not satisfied by relaxed tell <ref> [HD91] </ref>, which is an abstraction of generalised propagation (see below 5.2). 4.0.8 Propagation as Consistency Checking Various alternative approximation languages are available in Propia. The more expressive the approximation language the more information is extracted, but the costlier the propagation. <p> propagation yields Z2 = t, however if X is instantiated to f then propagation yields information about Z1 instead! Finally generalised propagation offers the possibility to interleave propagation and search, and a propagation agent may be involved in many different propagation sequences during a single derivation. 5.2 Relaxed Tell In <ref> [HD91] </ref> an operational semantics for constraint logic programming is introduced which offers an operation called relaxed tell. The relaxed tell operation extracts from a non-basic constraint an approximation.
Reference: [HE80] <author> R.M. Haralick and G.L. Elliot. </author> <title> Increasing tree search efficiency for constraint satisfaction problems. </title> <journal> Artificial Intelligence, </journal> <volume> 14 </volume> <pages> 263-314, </pages> <month> October </month> <year> 1980. </year>
Reference-contexts: This is provided by techniques developed for solving constraint satisfaction problems. It should be noted that constraint solving over a computation domain, as described in section 1.1 above, is replaced in this paradigm by constraint propagation over value domains <ref> [Fik70, Mon74, Mac77, HE80] </ref>. Informally constraint propagation operates by looking ahead at yet unsolved goals to see what locally consistent valuations there remain for individual problem variables. <p> Evidence of the practical effectiveness of constraints propagation in logic programming is given in [DSV90]. 1.3 Restrictions on Propagation in Logic Programming One prerequisite for applying CSP techniques is that problem variables should have an associated domain of possible values. Traditionally <ref> [Mac77, HE80] </ref> this is a finite domain, though more recently continuous intervals have been studied [Dav87]. Up to now, constraint logic programming systems based on the CSP paradigm (eg CHIP [DVS + 88]) have only been defined for finite domain variables. <p> This has lead to various consistency algorithms for networks of constraints, the most widely applicable of these being arc-consistency [RHZ75, Mon74]. Consistency can be applied as a preliminary to the search steps or interleaved with them <ref> [HE80] </ref>. The application of these techniques in logic programming can be related back to the enforcement of link consistency in connections graphs [Kow79].
Reference: [HJ90] <author> Seif Haridi and Sverker Janson. </author> <title> Kernel Andorra Prolog and its computation model. </title> <booktitle> In Proc. of the 7 th Int. Conf. on Logic Programming [ICL90], </booktitle> <pages> pages 31-46. </pages>
Reference-contexts: Based on Warren's extended Andorra model [War90], the language AKL has been defined <ref> [HJ90] </ref>. In this section we compare generalised propagation with AKL. Andorra promotes deterministic computations. The control of how hard to work to find subcomputations that yield deterministic results has reached a considerable degree of sophistication.
Reference: [ICL87] <institution> Proceedings of the 4 th International Conference on Logic Programming, </institution> <address> Melbourne, 1987. </address> <publisher> MIT Press. </publisher>
Reference: [ICL88] <institution> Proceedings of the 5 th International Conference and Symposium on Logic Programming, </institution> <address> Seat-tle, 1988. </address> <publisher> MIT Press. </publisher>
Reference: [ICL90] <institution> Proceedings of the 7 th International Conference on Logic Programming, Jerusalem, Israel, </institution> <address> 1990. </address> <publisher> MIT Press. </publisher> <pages> 33 </pages>
Reference: [JL86] <author> J. Jaffar and J-L. Lassez. </author> <title> Constraint logic programming. </title> <type> Draft Technical Report, </type> <institution> Monash University, </institution> <month> June </month> <year> 1986. </year>
Reference-contexts: "expenditure (Company; E)" are user atoms, and "P = I E" is a basic constraint. 3.2 Declarative and Operational Semantics for GP (X) 3.2.1 A Framework for Evaluation in GP (X) The framework for evaluation in GP (X) is based on the constraint logic programming scheme of Jaffar and Lassez <ref> [JL87, JL86] </ref>, extended with the concept of propagation agents. An evaluation in GP (X) involves at any time a current goal, a current set of propagation agents, and a current constraint store. <p> Thus the state of an evaluation is represented by a triple &lt; Goal; Agents; Store &gt;. 3.2.2 Declarative Semantics for GP (X) We base our semantics on that introduced for the CLP scheme in <ref> [JL86] </ref>. The computation domain X provides an interpretation for the interpreted predicates, functions, and constants. The language L P of a CLP (X) program includes uninterpreted predicates, functions and constants. <p> In particular the order of selection of goals is immaterial, and the order, "timing" and number of propagation steps makes no difference to the set of reachable success states. Our approach is based on that of Jaffar and Lassez <ref> [JL86] </ref> where the computation domain is a predefined structure. Later papers, after [Mah87], specify the domain as a theory and thus obtain a stronger completeness result. <p> Theorem 4 For any CLP (X) program P , the set of P -computed answers to any query G under with any constraint store S 0 represents the set of solutions to G under 9 nG S 0 . Proof For unconstrained queries, the proof is in <ref> [JL86] </ref>, and sketched as part of the proof of theorem 1 in [Mah87].
Reference: [JL87] <author> J. Jaffar and J.-L. Lassez. </author> <title> Constraint logic programming. </title> <booktitle> In Proceedings of the Fourteenth ACM Symposium on Principles of Programming Languages (POPL'87), </booktitle> <address> Munich, FRG, </address> <month> Jan-uary </month> <year> 1987. </year>
Reference-contexts: 1 Introduction 1.1 The CLP Scheme Constraint logic programming is often described as logic programming with unification replaced by constraint solving over a computation domain. This is captured in a theoretical framework called the CLP scheme <ref> [JL87] </ref>. A CLP (X) program comprises rules of the form h c 1 ; : : : c n ; b 1 ; : : : b m where the c i are constraints over the domain X and the b j are (user-defined or built-in) logic programming goals. <p> "expenditure (Company; E)" are user atoms, and "P = I E" is a basic constraint. 3.2 Declarative and Operational Semantics for GP (X) 3.2.1 A Framework for Evaluation in GP (X) The framework for evaluation in GP (X) is based on the constraint logic programming scheme of Jaffar and Lassez <ref> [JL87, JL86] </ref>, extended with the concept of propagation agents. An evaluation in GP (X) involves at any time a current goal, a current set of propagation agents, and a current constraint store. <p> However in this case no pruning information could be extracted from propagation constraints! For our purposes it would therefore be necessary to use some form of minimal model semantics for constraint logic programs, with all the restrictions this entails <ref> [JL87] </ref>. Apart from the restriction to built-in constraints, relaxed tell is an abstraction of generalised propagation. The inclusion of a relaxation function makes it strictly more powerful than generalised propagation, whose "relaxation function" is just the identity function.
Reference: [Kow79] <author> R. A. Kowalski. </author> <title> Logic for Problem Solving, chapter 8. </title> <publisher> North-Holland, </publisher> <year> 1979. </year>
Reference-contexts: Consistency can be applied as a preliminary to the search steps or interleaved with them [HE80]. The application of these techniques in logic programming can be related back to the enforcement of link consistency in connections graphs <ref> [Kow79] </ref>.
Reference: [Lev91] <author> J. Lever. </author> <title> Temporal reasoning a progress report. </title> <booktitle> Presented at the CHIC workshop, </booktitle> <institution> Imperial College, </institution> <year> 1991. </year>
Reference-contexts: One implementation is in the Elipsys system [DSVX91] which runs on a parallel machine. Using finite domains as the approximation language, it has achieved good speedups on disjunctive scheduling programs [PV92] and for temporal reasoning <ref> [Lev91] </ref>. In the paper we describe the other implementation which is embedded in a sequential prolog compiler system. It is an implementation of generalised propagation over the Herbrand universe GP (HU ), and it is called P ropia.
Reference: [Llo84] <author> J.W. Lloyd. </author> <title> Foundations Of Logic Programming. </title> <publisher> Springer-Verlag, </publisher> <year> 1984. </year>
Reference-contexts: We must then show that no computed answers are lost as a result of propagation. The first requirement can be met at once. By modifying the switching lemma of Lloyd <ref> [Llo84] </ref> to admit constraints on any computation domain X, we conclude that the order in which goals are unfolded cannot change a CLP (X) refutation into a failed derivation. Moreover the computed answer returned by the changed refutation is logically equivalent to the original computed answer.
Reference: [Mac77] <author> A.K. Mackworth. </author> <title> Consistency in networks of relations. </title> <journal> Artificial Intelligence, </journal> <volume> 8(1) </volume> <pages> 99-118, </pages> <year> 1977. </year>
Reference-contexts: This is provided by techniques developed for solving constraint satisfaction problems. It should be noted that constraint solving over a computation domain, as described in section 1.1 above, is replaced in this paradigm by constraint propagation over value domains <ref> [Fik70, Mon74, Mac77, HE80] </ref>. Informally constraint propagation operates by looking ahead at yet unsolved goals to see what locally consistent valuations there remain for individual problem variables. <p> Evidence of the practical effectiveness of constraints propagation in logic programming is given in [DSV90]. 1.3 Restrictions on Propagation in Logic Programming One prerequisite for applying CSP techniques is that problem variables should have an associated domain of possible values. Traditionally <ref> [Mac77, HE80] </ref> this is a finite domain, though more recently continuous intervals have been studied [Dav87]. Up to now, constraint logic programming systems based on the CSP paradigm (eg CHIP [DVS + 88]) have only been defined for finite domain variables. <p> Essentially the evaluation of a propagation sequence for generalised propagation can be obtained from the AC-3 algorithm of Mackworth <ref> [Mac77] </ref> by replacing REV ISE with topological branch and bound. A feature of AC-3 is that after propagating on a constraint C, C is removed from the list of constraints to be dealt with in the current propagation sequence.
Reference: [MAC + 89] <author> M. Meier, A. Aggoun, D. Chan, P. Dufresne, R. Enders, D. De Villeneuve, A. Herold, P. Kay, B. Perez, E.Van Rossum, and J. Schimpf. </author> <title> Sepia an extendible prolog system. </title> <editor> In G. X. Ritter, editor, </editor> <booktitle> Information Processing 89, </booktitle> <address> San Francisco, </address> <month> September </month> <year> 1989. </year> <institution> Elsevier Science Publisher B.V. </institution>
Reference-contexts: For solving CSP problems in traditional logic programming systems, backtrack search is used. The aim is to perform relevant "tests" as soon as possible after instantiating a variable. Dynamic computation rules, such as freeze [Col85] and delay <ref> [Nai86, MAC + 89] </ref> can be used to determine which goal to evaluate next. However even such dynamic rules can only postpone evaluation until the propagation constraints are partially or fully instantiated. Evaluating partially instantiated propagation constraints will generate values for variables, usually creating undesirable branches in the search tree. <p> It is an implementation of generalised propagation over the Herbrand universe GP (HU ), and it is called P ropia. Propia extracts information about equalities from propagation constraints, and it offers a number of approximation languages some of which will be described below. Propia is implemented in Sepia <ref> [MAC + 89] </ref> with the help of some special added built-ins. An important requirement for the efficient implementation of generalised propagation is a sophisticated coroutining facility.
Reference: [Mah87] <author> M. J. Maher. </author> <title> Logic semantics for a class of committed-choice programs. </title> <booktitle> In Proc. of the 4 th Int. Conf. on Logic Programming [ICL87], </booktitle> <pages> pages 858-876. </pages>
Reference-contexts: One point to note is that the basic constraint predicates are built-into the system, and cannot be defined by program clauses. A second point is that the consistency check covers all the basic constraints which have been collected up during the computation (which distinguishes constraints from ordinary built-in predicates <ref> [Mah87] </ref>). This check must, in theory, be effective. 1.2 CSP in Logic Programming There is another, very different, CLP paradigm which is based on constraint satisfaction techniques dating back to 1965 [GB65, Fik70, Mon74]. <p> Our approach is based on that of Jaffar and Lassez [JL86] where the computation domain is a predefined structure. Later papers, after <ref> [Mah87] </ref>, specify the domain as a theory and thus obtain a stronger completeness result. However standard domains, such as the Herbrand domain, cannot be defined precisely enough for our needs by a theory, so we have returned to the earlier formalisation. <p> Proof For unconstrained queries, the proof is in [JL86], and sketched as part of the proof of theorem 1 in <ref> [Mah87] </ref>. The presence of constraints S 0 in the initial store only cuts off derivations 12 which yield a computed answer inconsistent with S 0 (since in the CLP transitions defined above only the tell operation is affected by the current constraint store).
Reference: [MF85] <author> A.K. </author> <title> Mackworth and E.C. Freuder. The complexity of some polynomial network consistency algorithms for constraint satisfaction problems. </title> <journal> Artificial Intelligence, </journal> <volume> 25 </volume> <pages> 65-74, </pages> <year> 1985. </year>
Reference-contexts: In this case AC i is indeed the result of propagation on A i . 23 4.0.7 Evaluating Propagation Sequences In the case of finite domain propagation, the procedure for performing propagation on a single constraint is called REV ISE <ref> [MF85] </ref>. Essentially the evaluation of a propagation sequence for generalised propagation can be obtained from the AC-3 algorithm of Mackworth [Mac77] by replacing REV ISE with topological branch and bound.
Reference: [MNL88] <author> K. Marriott, L. Naish, and J.-L. Lassez. </author> <title> Most specific logic programs. </title> <booktitle> In Proc. of the 5 th Int. Conf. and Symp. on Logic Programming [ICL88], </booktitle> <pages> pages 909-923. </pages>
Reference-contexts: However even in the short list considered here, there are many points on which our comparison could be greatly expanded. 5.1 Most Specific Logic Programs The instance GP (HU ) of generalised propagation extracts information from propagation constraints which is precisely the most specific generalisation described in <ref> [MNL88] </ref>. In this earlier work, the most specific generalisation of a set of possible solutions was calculated in advance of execution, so as to transform a program statically into one which was more efficient and had other better properties.
Reference: [Mon74] <author> U. Montanari. </author> <title> Networks of constraints : Fundamental properties and applications to picture processing. </title> <journal> Information Science, </journal> <volume> 7(2) </volume> <pages> 95-132, </pages> <year> 1974. </year>
Reference-contexts: This check must, in theory, be effective. 1.2 CSP in Logic Programming There is another, very different, CLP paradigm which is based on constraint satisfaction techniques dating back to 1965 <ref> [GB65, Fik70, Mon74] </ref>. In the constraint satisfaction problem (CSP) paradigm the constraints are problem-specific, and defined by sets of tuples. When CSP is embedded into logic programming, a constraint can be defined in the program as a set of facts, or even as a set of rules [Van89]. <p> This is provided by techniques developed for solving constraint satisfaction problems. It should be noted that constraint solving over a computation domain, as described in section 1.1 above, is replaced in this paradigm by constraint propagation over value domains <ref> [Fik70, Mon74, Mac77, HE80] </ref>. Informally constraint propagation operates by looking ahead at yet unsolved goals to see what locally consistent valuations there remain for individual problem variables. <p> This has lead to various consistency algorithms for networks of constraints, the most widely applicable of these being arc-consistency <ref> [RHZ75, Mon74] </ref>. Consistency can be applied as a preliminary to the search steps or interleaved with them [HE80]. The application of these techniques in logic programming can be related back to the enforcement of link consistency in connections graphs [Kow79].
Reference: [MR91] <author> I. Mitterreiter and F. J. Radermacher. </author> <title> Experiments on the running time behaviour of some algorithms solving propositional calculus problems. </title> <type> Technical Report Draft, </type> <institution> FAW, Ulm, </institution> <year> 1991. </year>
Reference-contexts: The language has enabled us to write programs which are simple, yet efficient, without the need to resort to constructs without a clear declarative semantics such as demons. Applications tackled include a set of propositional satisfiability problems collected as a benchmark for theorem provers <ref> [MR91] </ref>, temporal reasoning, and disjunctive scheduling problems. The performance results have been very encouraging. In the next section we shall describe finite domain propagation in logic programming, and introduce generalised propagation with an example. <p> Though in this case the "calculation of the best approximation" for each agent and constraint store has already been done by the programmer, it is interesting to record that Propia when applied to a benchmark of propositional satisfiability problems <ref> [MR91] </ref>, had execution times on the same hardware similar to that obtained using CHIP's demons. This reflects the performance of the Sepia engine and the efficiency of the topological branch and bound algorithm. We now consider what happens when functors appear in the approximation constraints.
Reference: [NAC90] <institution> Proceedings of the 1990 North American Conference on Logic Programming. MIT Press, </institution> <year> 1990. </year>
Reference: [Nai86] <author> L. Naish. </author> <title> Negation and Control in Prolog, </title> <booktitle> volume 238 of Lecture Notes in Computer Science. </booktitle> <publisher> Springer, </publisher> <year> 1986. </year> <type> PhD. Thesis, </type> <institution> Melbourne Univ. </institution>
Reference-contexts: For solving CSP problems in traditional logic programming systems, backtrack search is used. The aim is to perform relevant "tests" as soon as possible after instantiating a variable. Dynamic computation rules, such as freeze [Col85] and delay <ref> [Nai86, MAC + 89] </ref> can be used to determine which goal to evaluate next. However even such dynamic rules can only postpone evaluation until the propagation constraints are partially or fully instantiated. Evaluating partially instantiated propagation constraints will generate values for variables, usually creating undesirable branches in the search tree. <p> In many applications it is of interest to detect the success or failure of membership as soon as possible, instead of just using member as a check. Yet even this is a serious problem (see for example <ref> [Nai86] </ref>). For example even if the tail of the list is known most control regimes require the check to delay until the head of the list either equals or fails to unify with the first argument. Generalised propagation can be applied to any member propagation constraint without fear of non-termination.
Reference: [PV92] <author> T. Le Provost and A. Veron. </author> <title> Boosting an application via constraints prototyping and or-parallelism. </title> <type> Forthcoming ECRC report, </type> <year> 1992. </year>
Reference-contexts: One implementation is in the Elipsys system [DSVX91] which runs on a parallel machine. Using finite domains as the approximation language, it has achieved good speedups on disjunctive scheduling programs <ref> [PV92] </ref> and for temporal reasoning [Lev91]. In the paper we describe the other implementation which is embedded in a sequential prolog compiler system. It is an implementation of generalised propagation over the Herbrand universe GP (HU ), and it is called P ropia.
Reference: [RHZ75] <author> A. Rosenfeld, A. Hummel, </author> <title> and S.W. Zucker. Scene labelling by relaxation operations. </title> <type> Technical Report TR-379, </type> <institution> Computer Science Department, University of Maryland, </institution> <year> 1975. </year>
Reference-contexts: This has lead to various consistency algorithms for networks of constraints, the most widely applicable of these being arc-consistency <ref> [RHZ75, Mon74] </ref>. Consistency can be applied as a preliminary to the search steps or interleaved with them [HE80]. The application of these techniques in logic programming can be related back to the enforcement of link consistency in connections graphs [Kow79].
Reference: [Sar89] <author> V.A. Saraswat. </author> <title> Concurrent Constraint Programming Languages. </title> <type> PhD thesis, </type> <institution> Carnegie-Mellon University, </institution> <address> Pittsburgh, Pa, </address> <month> January </month> <year> 1989. </year>
Reference-contexts: GP (X) program P , a solution to a query G under a constraint S is an valuation for which X j= S and P j= X G 3.2.3 Operational Semantics for GP (X) We have chosen a transformational semantics for our constraint logic programming system following the approach of <ref> [Sar89] </ref> and [HD91]. <p> If the program definition of p is empty, then the atom p (t1; : : :; tm) is replaced in the goal by false. Otherwise, each clause in the definition of p defines an alternative transition. The transition can be expressed in the following form (based on <ref> [Sar89] </ref>): (p (u1; : : : ; um) B1; : : : ; Bn) 2 P and &lt; (G [ fp (t1; : : : ; tm)g); A; S &gt;7!&lt; (G [ ff alseg); A; S &gt; Against our example program, a possible transition is &lt; fp1 (X; Y ); p2
Reference: [SD87a] <author> H. Simonis and M. Dincbas. </author> <title> Using an extended prolog for digital circuit design. </title> <booktitle> In IEEE International Workshop on AI Applications to CAD Systems for Electronics, </booktitle> <pages> pages 165-188, </pages> <address> Munich, W.Germany, </address> <month> October </month> <year> 1987. </year>
Reference-contexts: In this case both Y and Z could take either value true or f alse. For real problems in the applications listed above, the extraction of information of the form Z = Y is essential for performance reasons. To obtain such a behaviour on these applications in CHIP <ref> [SD90, SD87b, SD87a, Sim88, SP89] </ref> it was necessary to use a form of guarded clause called "demons". The demon clauses defining the and predicate explicitly use the constraints in the "Constraint Store" column above as guards. Each demon remains idle, until the current constraint store logically implies its guard.
Reference: [SD87b] <author> H. Simonis and M. Dincbas. </author> <title> Using logic programming for fault diagnosis in digital circuits. </title> <booktitle> In German Workshop on Artificial Intelligence (GWAI-87), </booktitle> <pages> pages 139-148, </pages> <editor> Geseke, W. Ger-many, </editor> <month> September </month> <year> 1987. </year>
Reference-contexts: In this case both Y and Z could take either value true or f alse. For real problems in the applications listed above, the extraction of information of the form Z = Y is essential for performance reasons. To obtain such a behaviour on these applications in CHIP <ref> [SD90, SD87b, SD87a, Sim88, SP89] </ref> it was necessary to use a form of guarded clause called "demons". The demon clauses defining the and predicate explicitly use the constraints in the "Constraint Store" column above as guards. Each demon remains idle, until the current constraint store logically implies its guard.
Reference: [SD90] <author> H. Simonis and M. Dincbas. </author> <title> Propositional calculus problems in CHIP. </title> <editor> In H. Kirchner, editor, </editor> <booktitle> Proceedings of the 2nd International Conf on Algebraic and Logic Programming, </booktitle> <address> Nancy, France, </address> <month> October </month> <year> 1990. </year> <note> CRIN and INRIA-Lorraine, Springer Verlag. (to appear). </note>
Reference-contexts: In this case both Y and Z could take either value true or f alse. For real problems in the applications listed above, the extraction of information of the form Z = Y is essential for performance reasons. To obtain such a behaviour on these applications in CHIP <ref> [SD90, SD87b, SD87a, Sim88, SP89] </ref> it was necessary to use a form of guarded clause called "demons". The demon clauses defining the and predicate explicitly use the constraints in the "Constraint Store" column above as guards. Each demon remains idle, until the current constraint store logically implies its guard.
Reference: [Sim88] <author> H. Simonis. </author> <title> Test pattern generation with logic programming. In New Aspects of Research for Testing of VLSI Circuits, Ising, </title> <publisher> W. </publisher> <address> Germany, </address> <month> March </month> <year> 1988. </year> <month> 34 </month>
Reference-contexts: In this case both Y and Z could take either value true or f alse. For real problems in the applications listed above, the extraction of information of the form Z = Y is essential for performance reasons. To obtain such a behaviour on these applications in CHIP <ref> [SD90, SD87b, SD87a, Sim88, SP89] </ref> it was necessary to use a form of guarded clause called "demons". The demon clauses defining the and predicate explicitly use the constraints in the "Constraint Store" column above as guards. Each demon remains idle, until the current constraint store logically implies its guard.
Reference: [Smo91] <author> G. Smolka. </author> <title> Residuation and guarded rules for constraint logic programming. </title> <type> Technical Report 12, </type> <institution> Digital PRL, </institution> <month> June </month> <year> 1991. </year>
Reference-contexts: However standard domains, such as the Herbrand domain, cannot be defined precisely enough for our needs by a theory, so we have returned to the earlier formalisation. Our completeness requirement is expressed as follows (see <ref> [Smo91] </ref>): Definition 4 Over the computation domain X, a set of computed answers R represents a set of solutions fi, if, for every solution 2 fi, there is a computed answer r 2 R such that X j= r. <p> There is a "logical subset" of guarded clause programs that have a logical semantics. It is possible to state when a set of "logical" guarded clauses is sound with respect to a logic program specification as in <ref> [Smo91] </ref>. However even for such logically sound guarded clauses there remains the question of completeness. There seems no simple way to determine when the behaviour of a set of clauses is equivalent to the behaviour of generalised propagation.
Reference: [SP89] <author> H. Simonis and T. Le Provost. </author> <title> Circuit verification in CHIP: Benchmark results. </title> <editor> In L.J.M. Claesen, editor, </editor> <booktitle> Proceedings of the IFIP TC10/WG10.2/WG10.5 Workshop on Applied Formal Methods for Correct VLSI Design, </booktitle> <address> Leuven, Belgium, </address> <month> November </month> <year> 1989. </year> <title> IFIP, </title> <publisher> North Hol-land, Elsevier Science Publishers. </publisher>
Reference-contexts: In this case both Y and Z could take either value true or f alse. For real problems in the applications listed above, the extraction of information of the form Z = Y is essential for performance reasons. To obtain such a behaviour on these applications in CHIP <ref> [SD90, SD87b, SD87a, Sim88, SP89] </ref> it was necessary to use a form of guarded clause called "demons". The demon clauses defining the and predicate explicitly use the constraints in the "Constraint Store" column above as guards. Each demon remains idle, until the current constraint store logically implies its guard.
Reference: [Van89] <author> P. Van Hentenryck. </author> <title> Constraint Satisfaction in Logic Programming. Logic Programming Series. </title> <publisher> The MIT Press, </publisher> <year> 1989. </year>
Reference-contexts: In the constraint satisfaction problem (CSP) paradigm the constraints are problem-specific, and defined by sets of tuples. When CSP is embedded into logic programming, a constraint can be defined in the program as a set of facts, or even as a set of rules <ref> [Van89] </ref>. We shall often refer to constraints in the CSP framework as "propagation constraints". For solving CSP problems in traditional logic programming systems, backtrack search is used. The aim is to perform relevant "tests" as soon as possible after instantiating a variable. <p> The application of these techniques in logic programming can be related back to the enforcement of link consistency in connections graphs [Kow79]. Finite domain propagation in logic programming was accomplished through two complementary extensions <ref> [VD86, Van89] </ref> * explicit finite domains of values to allow the expression of range restrictions, together with the corresponding extension of unification (FD-resolution) * new inference rules, based on looking ahead at "future" computations, to reduce finite domains in a deterministic way The effect of looking ahead on a goal is <p> For example the removal of rare letters such as x from the domains of the variables provides little useful "pruning" of the search space. Nevertheless finite domain propagation in logic programming has been applied to the problem of crossword compilation <ref> [Van89] </ref>. A successful CLP program was written in which a domain variable was associated with each blank word in the crossword, whose domain was the set of words in the lexicon that could fit there. The correct choice of words was enforced by constraints on their intersections.
Reference: [VD86] <author> P. Van Hentenryck and M. Dincbas. </author> <title> Domains in logic programming. </title> <booktitle> In Proceedings of the Fifth National Conference on Artificial Intelligence (AAAI'86), </booktitle> <address> Philadelphia, PA, </address> <month> August </month> <year> 1986. </year>
Reference-contexts: The application of these techniques in logic programming can be related back to the enforcement of link consistency in connections graphs [Kow79]. Finite domain propagation in logic programming was accomplished through two complementary extensions <ref> [VD86, Van89] </ref> * explicit finite domains of values to allow the expression of range restrictions, together with the corresponding extension of unification (FD-resolution) * new inference rules, based on looking ahead at "future" computations, to reduce finite domains in a deterministic way The effect of looking ahead on a goal is
Reference: [War88] <author> D.H.D. Warren. </author> <title> The Andorra Model. </title> <booktitle> Presented at the Gigalips Workshop, </booktitle> <institution> Univ. of Manch-ester, </institution> <year> 1988. </year>
Reference-contexts: Consequently the whole range of possibilities on the continuum between compilation and interpretation of generalised propagation would be available in one system. 5.4 Andorra A relationship has been often pointed out between David Warren's Andorra principle <ref> [War88] </ref> and the preference for deterministic computation which underlies constraint propagation. Based on Warren's extended Andorra model [War90], the language AKL has been defined [HJ90]. In this section we compare generalised propagation with AKL. Andorra promotes deterministic computations.
Reference: [War90] <author> D.H.D. Warren. </author> <title> The Extended Andorra Model with implicit control. </title> <booktitle> Presented at the ICLP'90 workshop on Parallel Logic Programming, </booktitle> <address> Isreal, </address> <month> June </month> <year> 1990. </year> <note> 35 Other Reports Available from ECRC </note>
Reference-contexts: Based on Warren's extended Andorra model <ref> [War90] </ref>, the language AKL has been defined [HJ90]. In this section we compare generalised propagation with AKL. Andorra promotes deterministic computations. The control of how hard to work to find subcomputations that yield deterministic results has reached a considerable degree of sophistication.
Reference: [ECRC-TR-LP-60] <author> Mireille Ducasse and Anna-Maria Emde. </author> <title> Opium 3.1 User Manual A High-level Debugging Environment for Prolog. </title> <year> 1991. </year>
Reference: [ECRC-TR-LP-61] <author> E. Yardeni, T. Fruhwirth, and E. Shapiro. </author> <title> Polymorphically Typed Logic Programs. </title> <year> 1991. </year>
Reference: [ECRC-TR-DPS-81] <author> U. Baron, S. Bescos, and S. </author> <title> Delgado. </title> <booktitle> The ElipSys Logic Programming Language. </booktitle> <volume> 17. 01. </volume> <year> 1991. </year>
Reference: [ECRC-TR-DPS-82] <author> Sergio Delgado, Michel Dorochevsky, and Kees Schuerman. </author> <title> A Shared Environment Parallel Logic Programming System On Distributed Memory Architectures. </title> <type> 18. 01. </type> <year> 1991. </year>
Reference: [ECRC-TR-DPS-83] <author> Andre Veron, Jiyang Xu, and Kees Schuerman. </author> <title> Virtual Memory Support for OR-Parallel Logic Programming Systems. </title> <type> 05. 03. </type> <year> 1991. </year>
Reference: [ECRC-TR-DPS-85] <author> Michel Dorochevsky. </author> <title> Garbage Collection in the OR-Parallel Logic Programming. </title> <type> 15. 03. </type> <year> 1991. </year>
Reference: [ECRC-TR-DPS-100] <author> Alan Sexton. </author> <title> KCM Kernel Implementation Report. </title> <type> 22. 05. </type> <year> 1991. </year>
Reference: [ECRC-TR-DPS-103] <author> Michel Dorochevsky. </author> <title> Key Features of a Prolog Module System. </title> <type> 08. 03. </type> <year> 1991. </year>
Reference: [ECRC-TR-DPS-104] <author> Michel Dorochevsky, Kees Schuerman, and Andre Veron. ElipSys: </author> <title> An Integrated Platform for Building Large Decision Support Systems. </title> <type> 29. 01. </type> <year> 1991. </year>
Reference: [ECRC-TR-DPS-105] <author> Jiyang Xu and Andre Veron. </author> <title> Types and Constraints in the Parallel Logic Programming System ElipSys. </title> <type> 15. 03. </type> <year> 1991. </year>
Reference: [ECRC-TR-DPS-107] <author> Olivier Thibault. </author> <title> Design and Evaluation of a Symbolic Processor. </title> <type> 13. 06. </type> <year> 1991. </year>
Reference: [ECRC-TR-DPS-112] <author> Michel Dorochevsky, Jacques Noye, and Olivier Thibault. </author> <title> Has Dedicated Hardware for Prolog a Future ? 14. </title> <type> 09. </type> <year> 1991. </year>
Reference: [ECRC-91-1] <author> Norbert Eisinger and Hans Jurgen Ohlbach. </author> <title> Deduction Systems Based on Resolution. </title> <type> 29. 10. </type> <year> 1991. </year>
Reference: [ECRC-91-2] <author> Michel Kuntz. </author> <title> The Gist of GIUKU: Graphical Interactive Intelligent Utilities for Knowledgeable Users of Data Base Systems. </title> <type> 4. 11. </type> <year> 1991. </year>
Reference: [ECRC-91-3] <author> Michel Kuntz. </author> <title> An Introduction to GIUKU: Graphical Interactive Intelligent Utilities for Knowledgeable Users of Data Base Systems. </title> <type> 4. 11. </type> <year> 1991. </year>
Reference: [ECRC-91-4] <author> Michel Kuntz. </author> <title> Enhanced Graphical Browsing Techniques for Collections of Structured Data. </title> <type> 4. 11. </type> <year> 1991. </year>
Reference: [ECRC-91-5] <author> Michel Kuntz. </author> <title> A Graphical Syntax Facility for Knowledge Base Languages. </title> <type> 4. 11. </type> <year> 1991. </year>
Reference: [ECRC-91-6] <author> Michel Kuntz. </author> <title> A Versatile Browser-Editor for NF2 Relations. </title> <type> 4. 11. </type> <year> 1991. </year>
Reference: [ECRC-91-7] <author> Norbert Eisinger, Nabiel Elshiewy, and Remo Pareschi. </author> <title> Distributed Artificial Intelligence An Overview. </title> <type> 4. 11. </type> <year> 1991. </year>
Reference: [ECRC-91-8] <author> Norbert Eisinger. </author> <title> An Approach to Multi-Agent Problem-Solving. </title> <type> 11. 11. </type> <year> 1991. </year>
Reference: [ECRC-91-9] <author> Klaus H. Ahlers, Michael Fendt, Marc Herrmann, Isabelle Hounieu, and Philippe Marchal. </author> <title> TUBE Implementor's Manual. </title> <type> 21. 11. </type> <year> 1991. </year>
Reference: [ECRC-91-10] <author> Klaus H. Ahlers, Michael Fendt, Marc Herrmann, Isabelle Hounieu, and Philippe Marchal. </author> <title> TUBE Programmer's Manual. </title> <type> 21. 11. </type> <year> 1991. </year>
Reference: [ECRC-91-11] <author> Michael Dahmen. </author> <title> A Debugger for Constraints in Prolog. </title> <type> 26. 11. </type> <year> 1991. </year>
Reference: [ECRC-91-12] <author> Jean-Marc Andreoli and Remo Pareschi. </author> <title> Communication as Fair Distribution of Knowledge. </title> <type> 26. 11. </type> <year> 1991. </year> <month> 36 </month>
Reference: [ECRC-91-13] <author> Jean-Marc Andreoli, Remo Pareschi, and Marc Bourgois. </author> <title> Dynamic Programming as Multiagent Programming. </title> <type> 26. 11. </type> <year> 1991. </year>
Reference: [ECRC-91-14] <author> Volker Kuchenhoff. </author> <title> On the Efficient Computation of the Difference Between Consecutive Database States. </title> <type> 5. 12. </type> <year> 1991. </year>
Reference: [ECRC-91-15] <author> Sylvie Bescos and Michael Ratcliffe. </author> <title> Secondary Structure Prediction of rRNA Molecules Using ElipSys. </title> <type> 16. 12. </type> <year> 1991. </year>
Reference: [ECRC-91-16] <author> Michael Dahmen. </author> <title> Abstract Debugging of Coroutines and Constraints in Prolog. </title> <type> 30. 12. </type> <year> 1991. </year>
Reference: [ECRC-92-1] <author> Thierry Le Provost and Mark Wallace. </author> <title> Constraint Satisfaction Over the CLP Scheme. </title> <type> 30. 1. </type> <year> 1992. </year>
Reference: [ECRC-92-2] <author> Gerard Comyn, M. Jarke, and Suryanarayana M. </author> <title> Sripada. </title> <booktitle> Proceedings of the 1st Com-pulog Net meeting on Knowledge Bases (CNKBS'92). </booktitle> <volume> 30. 1. </volume> <year> 1992. </year>
Reference: [ECRC-92-3] <author> Jesper Larsson Traeff and Steven David Prestwich. </author> <title> Meta-programming for reordering Literals in Deductive Databases. </title> <type> 30. 1. </type> <year> 1992. </year>
Reference: [ECRC-92-4] <author> Beat Wuthrich. </author> <title> Update Realizations Drawn from Knowledge Base Schemas and Executed by Dialog. </title> <type> 4. 2. </type> <year> 1992. </year>
Reference: [ECRC-92-5] <author> Lone Leth. </author> <title> A New Direction in Functions as Processes. </title> <type> 25. 2. </type> <year> 1992. </year>
Reference: [ECRC-92-6] <author> Steven David Prestwich. </author> <title> The PADDY Partial Deduction System. </title> <type> 23. 3. </type> <year> 1992. </year>
Reference: [ECRC-92-7] <author> Andrei Voronkov. </author> <title> Extracting Higher Order Functions from First Order Proofs. </title> <type> 23. 3. </type> <year> 1992. </year>
Reference: [ECRC-92-8] <editor> Andrei Voronkov. </editor> <booktitle> On Computability by Logic Programs. </booktitle> <volume> 23. 3. </volume> <year> 1992. </year>
Reference: [ECRC-92-9] <author> Beat Wuthrich. </author> <title> Towards Probabilistic Knowledge Bases. </title> <type> 02. 4. </type> <year> 1992. </year>
Reference: [ECRC-92-10] <author> Petra Bayer. </author> <title> Update Propagation for Integrity Checking, Materialized View Maintenance and Production Rule Triggering. </title> <type> 08. 4. </type> <year> 1992. </year>
Reference: [ECRC-92-11] <author> Mireille Ducasse. </author> <title> Abstract views of Prolog executions in Opium. </title> <type> 15. 4. </type> <year> 1992. </year>
Reference: [ECRC-92-12] <author> Alexandre Lefebvre. </author> <title> Towards an Efficient Evaluation of Recursive Aggregates in Deductive Databases. </title> <type> 30. 4. </type> <year> 1992. </year>
Reference: [ECRC-92-13] <author> Udo W. Lipeck and Rainer Manthey (Hrsg.). </author> <title> Kurzfassungen des 4. GI-Workshops "Grundlagen von Datenbanken", </title> <journal> Barsinghausen, 9.-12.6.1992. </journal> <volume> 12. 05. </volume> <year> 1992. </year>
Reference: [ECRC-92-14] <author> Lone Leth and Bent Thomsen. </author> <title> Some Facile Chemistry. </title> <type> 26. 05. </type> <year> 1992. </year>
Reference: [ECRC-92-15] <editor> Jacques Noye (Ed.). </editor> <booktitle> Proceedings of the International KCM User Group Meeting,Munich, 7 and 8 October 1991. </booktitle> <volume> 03. 06. </volume> <year> 1992. </year>
Reference: [ECRC-92-16] <author> Frederick Knabe. </author> <title> A Distributed Protocol for Channel-Based Communication with Choice. </title> <type> 10. 06. </type> <year> 1992. </year>
Reference: [ECRC-92-17] <author> Benoit Baurens, Petra Bayer, Luis Hermosilla, and Andrea Sikeler. </author> <title> Publication Management: A Requirements Analysis. </title> <type> 03. 07. </type> <year> 1992. </year>
Reference: [ECRC-92-18] <author> Thom Fruhwirth. </author> <title> Constraint Simplification Rules. </title> <type> 28. 07. </type> <year> 1992. </year>
Reference: [ECRC-92-19] <author> Mark Wallace. </author> <title> Compiling Integrity Checking into Update Procedures. </title> <type> 29. 07. </type> <year> 1992. </year>
Reference: [ECRC-92-20] <author> Petra Bayer. </author> <title> Data and Knowledge for Medical Applications: A Case Study. </title> <type> 30. 07. </type> <year> 1992. </year>
Reference: [ECRC-92-21] <author> Michel Dorochevsky and Andre Veron. </author> <title> Binding Techniques and Garbage Collection for OR-Parallel CLP Systems. </title> <type> 11. 08. </type> <year> 1992. </year> <month> 37 </month>
Reference: [ECRC-92-22] <author> Shan-Wen Yan. </author> <title> Efficiently Estimating Relative Grain Size for Logic Programs on Basis of Abstract Interpretation. </title> <type> 25. 08. </type> <year> 1992. </year>
Reference: [ECRC-92-23] <author> Jean-Marc Andreoli, Paolo Ciancarini, and Remo Pareschi. </author> <title> Interaction Abstract Machines. </title> <type> 25. 08. </type> <year> 1992. </year>
Reference: [ECRC-92-24] <author> Jean-Marc Andreoli and Remo Pareschi. </author> <title> Associative Communication and its Optimization via Abstract Interpretation. </title> <type> 25. 08. </type> <year> 1992. </year>
Reference: [ECRC-92-25] <author> Jean-Marc Andreoli, Lone Leth, Remo Pareschi, and Bent Thomsen. </author> <title> On the Chemistry of Broadcasting. </title> <type> 25. 08. </type> <year> 1992. </year>
Reference: [ECRC-92-26] <author> Marc Bourgois, Jean-Marc Andreoli, and Remo Pareschi. </author> <title> Extending Objects with Rules, </title> <journal> Composition and Concurrency : the LO Experience. </journal> <volume> 25. 08. </volume> <year> 1992. </year>
Reference: [ECRC-92-27] <author> Benoit Dageville and Kam-Fai Wong. </author> <title> SIM: A C-based SIMulation Package. </title> <type> 28. 09. </type> <year> 1992. </year>
Reference: [ECRC-92-28] <author> Beat Wuthrich. </author> <title> On the Efficient Distribution-free Learning of Rule Uncertainties and their Integration into Probabilistic Knowledge Bases. </title> <type> 29. 09. </type> <year> 1992. </year>
Reference: [ECRC-92-29] <author> Andrei Voronkov. </author> <title> Logic Programming with Bounded Quantifiers. </title> <type> 29. 09. </type> <year> 1992. </year>
Reference: [ECRC-92-30] <author> Eric Monfroy. </author> <title> Grobner Bases: </title> <booktitle> Strategies and Applications. </booktitle> <volume> 30. 09. </volume> <year> 1992. </year>
Reference: [ECRC-92-31] <author> Eric Monfroy. </author> <title> Specification of Geometrical Constraints. </title> <type> 30. 09. </type> <year> 1992. </year>
Reference: [ECRC-92-32] <author> Bent Thomsen, Lone Leth, and Alessandro Giacalone. </author> <title> Some Issues in the Semantics of Facile Distributed Programming. </title> <type> 22. 10. </type> <year> 1992. </year>
Reference: [ECRC-92-33] <author> Mireille Ducasse. </author> <title> An Extendable Trace Analyser to Support Automated Debugging. </title> <type> 04. 12. </type> <year> 1992. </year>
Reference: [ECRC-92-34] <author> Jorge Bocca and Luis Hermosilla. </author> <title> A Preliminary Study of the Performance of MegaLog. </title> <type> 20. 12. </type> <year> 1992. </year>
Reference: [ECRC-93-1] <author> Benoit Dageville and Kam-Fai Wong. </author> <title> Supporting Thousands of Threads Using a Hybrid Stack Sharing Scheme. </title> <type> 18. 01. </type> <year> 1993. </year>
Reference: [ECRC-93-2] <author> Steven Prestwich. </author> <booktitle> ElipSys Programming Tutorial. </booktitle> <volume> 18. 01. </volume> <year> 1993. </year>
Reference: [ECRC-93-3] <author> Beat Wuthrich. </author> <title> Learning Probabilistic Rules. </title> <type> 28. 01. </type> <year> 1993. </year>
Reference: [ECRC-93-4] <author> Eric Monfroy. </author> <title> A Survey of Non-Linear Solvers. </title> <type> 02. 02. </type> <year> 1993. </year>
Reference: [ECRC-93-5] <author> Thom Fruhwirth, Alexander Herold, Volker Kuchenhoff, Thierry Le Provost, Pierre Lim, Eric Monfroy, and Mark Wallace. </author> <title> Constraint Logic Programming An Informal Introduction. </title> <type> 02. 02. </type> <year> 1993. </year> <month> 38 </month>
References-found: 112

