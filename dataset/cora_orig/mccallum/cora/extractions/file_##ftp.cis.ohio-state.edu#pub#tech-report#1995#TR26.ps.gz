URL: file://ftp.cis.ohio-state.edu/pub/tech-report/1995/TR26.ps.gz
Refering-URL: ftp://ftp.cis.ohio-state.edu/pub/tech-report/TRList.html
Root-URL: 
Title: A Timing-based Schema for Stabilizing Information Exchange  
Author: Anish Arora David M. Poduska 
Keyword: stabilization, timing-based protocols, fault-tolerance, adaptivity, high speed networks, formal methods, verification  
Address: Columbus, OH 43210  
Affiliation: Dept. of Comp. Sc., The Ohio State University,  
Note: 0 Contact Address: Dreese 395,  Supported in part by NSF Grant CCR-93-08640 and OSU Grant 221506  
Email: Email: anish@cis.ohio-state.edu  
Phone: Tel: (614)292-1836 Fax: (614)292-2911  
Date: December 1994 Revised: March 1995  
Abstract: The paradigm of information exchange provides a basis for nodes in a network to stay uptodate with the recent information in the network. In this paradigm, nodes cooperate to share their current information with each other. We present a simple and uniform schema for building information exchange protocols that are stabilizing, in the following strong sense. Starting from arbitrary state, the protocols reach within bounded real-time a state wherefrom all nodes remain uptodate with the recent information in the network. The ability to stabilize in bounded time is achieved by using timing-based actions. The timing constraints on these actions can be systematically adapted to suit a variety of network loads, delay requirements, and scheduling restrictions and to tolerate out-of-phase and drift-prone node clocks. Our schema also tolerates any number of topological changes in the network. Moreover, it accommodates information that is time-varying as well as it does information that is fixed. It is thus well-suited to dynamic high speed networks. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> M. G. Gouda and N. </author> <title> Multari. </title> <journal> Stabilizing communication protocols IEEE Transactions on Computers, </journal> <volume> 40(4) </volume> <pages> 448-458, </pages> <year> 1991. </year>
Reference-contexts: We also describe in this paper a simple and uniform verification schema to demonstrate the correctness of the resulting protocols. Previous Work. Gouda and Multari <ref> [1] </ref> present an indepth study of stabilization in networks protocols, although the protocols they consider are not explicitly timing-based. In fact, we have found only a few stabilizing protocols in the literature that are explicitly timing-based.
Reference: [2] <author> G. Varghese. </author> <title> Self-stabilization by local checking and correction Ph.D. </title> <type> Dissertation, </type> <institution> 1992. Massachusetts Institute of Technology. </institution>
Reference-contexts: Previous Work. Gouda and Multari [1] present an indepth study of stabilization in networks protocols, although the protocols they consider are not explicitly timing-based. In fact, we have found only a few stabilizing protocols in the literature that are explicitly timing-based. Varghese <ref> [2] </ref> discusses how propagation of information with feedback may be achieved in a stabilizing fashion using timing-based actions on a tree network. He also refers to timing-based stabilizing solutions for maintaining spanning trees (due to Perlman), data links and virtual circuits (due to Spinelli).
Reference: [3] <author> E. A. Ashcroft. </author> <title> Proving assertions about parallel programs. </title> <journal> Journal of Computer and System Sciences, </journal> <volume> 10 </volume> <pages> 110-135, </pages> <year> 1975. </year>
Reference-contexts: Intuitively, the state invariant of a protocol is a state predicate that characterizes the "intended" states of protocol execution <ref> [3, 4, 5] </ref>. Thus, every computation of an untimed protocol that starts at a state where its state invariant holds is an intended computation, one that meets the (safety and progress properties of the) problem specification that the protocol satisfies. This method of state invariants remains valid for timing-based protocols.
Reference: [4] <author> E. W. Dijkstra. </author> <title> A Discipline of Programming, chapter 14. </title> <publisher> Prentice-Hall, </publisher> <address> Englewood Cliffs, N. J., </address> <year> 1976. </year>
Reference-contexts: Intuitively, the state invariant of a protocol is a state predicate that characterizes the "intended" states of protocol execution <ref> [3, 4, 5] </ref>. Thus, every computation of an untimed protocol that starts at a state where its state invariant holds is an intended computation, one that meets the (safety and progress properties of the) problem specification that the protocol satisfies. This method of state invariants remains valid for timing-based protocols.
Reference: [5] <editor> D. Gries. </editor> <booktitle> The Science of Programming. </booktitle> <publisher> Springer-Verlag, </publisher> <address> New York, </address> <year> 1981. </year>
Reference-contexts: Intuitively, the state invariant of a protocol is a state predicate that characterizes the "intended" states of protocol execution <ref> [3, 4, 5] </ref>. Thus, every computation of an untimed protocol that starts at a state where its state invariant holds is an intended computation, one that meets the (safety and progress properties of the) problem specification that the protocol satisfies. This method of state invariants remains valid for timing-based protocols.
Reference: [6] <author> F. Jahanian and A. Mok. </author> <title> Safety analysis of timing properties in real-time systems. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 12(9) </volume> <pages> 890-904, </pages> <year> 1986. </year>
Reference-contexts: This method of state invariants remains valid for timing-based protocols. However, the task of exhibiting the state invariant of timing-based protocols requires knowledge of timing dependencies in the protocol. These timing dependencies can be incorporated within the state invariant, as in <ref> [6, 7] </ref>, or within a separate assertion containing timing properties [8]. We prefer to separate timing assertions from state assertions: first, we exhibit a timing invariant, named T I, and then using T I we exhibit a state invariant, named SI.
Reference: [7] <author> R. Alur and T. A. Henzinger. </author> <title> Real-time logics: Complexity and expressiveness. </title> <booktitle> Proceedings of the Fifth Annual Symposium on Logic in Computer Science, </booktitle> <pages> pages 390-401, </pages> <year> 1990. </year>
Reference-contexts: This method of state invariants remains valid for timing-based protocols. However, the task of exhibiting the state invariant of timing-based protocols requires knowledge of timing dependencies in the protocol. These timing dependencies can be incorporated within the state invariant, as in <ref> [6, 7] </ref>, or within a separate assertion containing timing properties [8]. We prefer to separate timing assertions from state assertions: first, we exhibit a timing invariant, named T I, and then using T I we exhibit a state invariant, named SI.
Reference: [8] <author> N. A. Lynch and H. Attiya. </author> <title> Using mappings to prove timing properties. </title> <booktitle> In Proceedings of the 9th ACM Symposium on Principles of Distributed Computing (PODC), </booktitle> <pages> pages 265-280, </pages> <address> Quebec City, PQ CDN, 1990. </address> <publisher> ACM Press, </publisher> <address> New York, NY, USA. </address>
Reference-contexts: However, the task of exhibiting the state invariant of timing-based protocols requires knowledge of timing dependencies in the protocol. These timing dependencies can be incorporated within the state invariant, as in [6, 7], or within a separate assertion containing timing properties <ref> [8] </ref>. We prefer to separate timing assertions from state assertions: first, we exhibit a timing invariant, named T I, and then using T I we exhibit a state invariant, named SI. <p> Our schema is based on well-established concepts. The protocol notation uses a modified form of Dijkstra's guarded commands [13]; the use of upper and lower time bounds on statement execution is based on earlier work <ref> [8, 10, 14] </ref>; protocols are verified by exhibiting 20 a state invariant and a timing invariant; and, timing invariants are proven using a small number of well understood temporal concepts [10]. Our schema accommodates the exchange of both fixed and time-varying information.
Reference: [9] <author> R. Koymans, J. Vytopil, and W. P. de Roever. </author> <title> Real-time programming and asynchronous message passing. </title> <booktitle> In 2nd ACM SIGACT-SIGOPS Symposium on Principles of Distributed Computing, </booktitle> <year> 1983. </year>
Reference-contexts: We choose these two operators because they are well understood and suffice for our purposes. Note also that the fl operator is equivalent to a bounded version of the F operator and the = operator corresponds to a bounded version of the S operator in temporal logic <ref> [9, 10] </ref>. 2.3 Network Assumptions A computer network consists of N nodes and some number of communication channels that each connect a unique pair of nodes.
Reference: [10] <author> T. A. Henzinger, Z. Manna, and A. Pnueli. </author> <title> Temporal proof methodologies for time transition systems. </title> <booktitle> In Lecture Notes in Computer Science, </booktitle> <volume> Vol. 600: </volume> <booktitle> Real Time: Theory in Practice, </booktitle> <pages> pages 226-251, </pages> <year> 1992. </year>
Reference-contexts: We choose these two operators because they are well understood and suffice for our purposes. Note also that the fl operator is equivalent to a bounded version of the F operator and the = operator corresponds to a bounded version of the S operator in temporal logic <ref> [9, 10] </ref>. 2.3 Network Assumptions A computer network consists of N nodes and some number of communication channels that each connect a unique pair of nodes. <p> Our schema is based on well-established concepts. The protocol notation uses a modified form of Dijkstra's guarded commands [13]; the use of upper and lower time bounds on statement execution is based on earlier work <ref> [8, 10, 14] </ref>; protocols are verified by exhibiting 20 a state invariant and a timing invariant; and, timing invariants are proven using a small number of well understood temporal concepts [10]. Our schema accommodates the exchange of both fixed and time-varying information. <p> Dijkstra's guarded commands [13]; the use of upper and lower time bounds on statement execution is based on earlier work [8, 10, 14]; protocols are verified by exhibiting 20 a state invariant and a timing invariant; and, timing invariants are proven using a small number of well understood temporal concepts <ref> [10] </ref>. Our schema accommodates the exchange of both fixed and time-varying information. While protocols for both types of information are developed in the same manner, their implementation is potentially different.
Reference: [11] <author> A. Arora and D. M. Poduska. </author> <title> A logic for real-time fault-tolerant programs. </title> <type> Unpublished manuscript, </type> <year> 1995. </year>
Reference-contexts: As regards verification methods, our approach builds on previous work [3-10]. We restrict our proofs of timing properties to the use of two bounded temporal concepts, namely bounded response and bounded invariance. These two concepts appear to be sufficient for reasoning about the timing properties of fault-tolerant protocols <ref> [11] </ref>. We use timing properties essentially to exhibit bounds on the convergence time and to deduce untimed properties. A discussion of information exchange protocols appears in Segall [12]. His protocols are not stabilizing.
Reference: [12] <author> A. </author> <title> Segall. </title> <journal> Distributed network protocols IEEE Transactions on Information Theory, </journal> <volume> IT-29:23-35, </volume> <year> 1983 </year>
Reference-contexts: These two concepts appear to be sufficient for reasoning about the timing properties of fault-tolerant protocols [11]. We use timing properties essentially to exhibit bounds on the convergence time and to deduce untimed properties. A discussion of information exchange protocols appears in Segall <ref> [12] </ref>. His protocols are not stabilizing. They do, however, tolerate topological changes, although unlike our protocols, they use messages of unbounded size to achieve fault-tolerance. Overview of the paper.
Reference: [13] <author> E. W. Dijkstra. </author> <title> Guarded commands, nondeterminacy and formal derivation of programs. </title> <journal> Communications of the ACM, </journal> <volume> 18(8) </volume> <pages> 453-457, </pages> <year> 1975. </year>
Reference-contexts: Our schema is based on well-established concepts. The protocol notation uses a modified form of Dijkstra's guarded commands <ref> [13] </ref>; the use of upper and lower time bounds on statement execution is based on earlier work [8, 10, 14]; protocols are verified by exhibiting 20 a state invariant and a timing invariant; and, timing invariants are proven using a small number of well understood temporal concepts [10].

References-found: 13

