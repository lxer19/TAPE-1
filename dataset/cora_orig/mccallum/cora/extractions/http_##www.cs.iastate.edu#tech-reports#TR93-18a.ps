URL: http://www.cs.iastate.edu/tech-reports/TR93-18a.ps
Refering-URL: http://www.cs.iastate.edu/tech-reports/catalog.html
Root-URL: 
Title: A Quick Overview of Larch/C++  
Author: Yoonsik Cheon and Gary T. Leavens TR #-a 
Keyword: interface specification, Larch/C++, C++, subtype, specification inheritance, verification. 1993 CR Categories: D.2.1 [Software Engineering] Requirements/Specifications Languages; F.3.1 [Logics and Meaning of Programs] Specifying and verifying and reasoning about programs Assertions, invariants, pre- and post-conditions, specification techniques.  
Address: 226 Atanasoff Hall  Ames, Iowa 50011-1040, USA  
Affiliation: Department of Computer Science  Iowa Sate University  
Note: 1994)  Submitted for publication.  
Date: June, 1993 (Revised June  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> Pierre America. </author> <title> Inheritance and subtyping in a parallel object-oriented language. </title> <editor> In Jean Bezivin et al., editors, </editor> <booktitle> ECOOP '87, European Conference on Object-Oriented Programming, Paris, France, </booktitle> <pages> pages 234-242, </pages> <address> New York, N.Y., </address> <month> June </month> <year> 1987. </year> <title> Springer-Verlag. </title> <booktitle> Lecture Notes in Computer Science, </booktitle> <volume> Volume 276. </volume> <pages> 31 </pages>
Reference-contexts: To make reasoning about a program that uses message passing and subtyping tractable, one should ensure that the member functions of the base class have an appropriate specification in the derived class [24] <ref> [1] </ref> [19] [3] [17]. This is almost automatic if one inherits the specifications, except that one has to ensure that the trait functions used in the base classes' specifications have the appropriate meaning [18]. See the references for more details. Larch/C ++ allows multiple inheritance. <p> The simulates clause says that each directed graph abstract value, d, simulates the graph abstract value, toG (d). That is, the trait function toG can be used as a coercion function from directed graphs to graphs. Having such coercion functions is useful in dealing with subtyping [5] <ref> [1] </ref> [2] [4] [20] [21]. In Larch/C ++ , one can specify a trait function that acts as a coercion for each base type. This coercion function helps to define the semantics of inherited Larch/C++ specifications.
Reference: [2] <author> Pierre America. </author> <title> A behavioural approach to subtyping in object-oriented programming languages. </title> <type> Technical Report 443, </type> <institution> Philips Research Laboratories, Nederlandse Philips Bedrijven B. V., </institution> <month> April </month> <year> 1989. </year> <note> Revised from the January 1989 version. </note>
Reference-contexts: The simulates clause says that each directed graph abstract value, d, simulates the graph abstract value, toG (d). That is, the trait function toG can be used as a coercion function from directed graphs to graphs. Having such coercion functions is useful in dealing with subtyping [5] [1] <ref> [2] </ref> [4] [20] [21]. In Larch/C ++ , one can specify a trait function that acts as a coercion for each base type. This coercion function helps to define the semantics of inherited Larch/C++ specifications.
Reference: [3] <author> Pierre America. </author> <title> A parallel object-oriented language with inheritance and subtyping. </title> <journal> ACM SIGPLAN Notices, </journal> <volume> 25(10) </volume> <pages> 161-168, </pages> <month> October </month> <year> 1990. </year> <booktitle> OOPSLA ECOOP '90 Proceedings, N. Meyrowitz (editor). </booktitle>
Reference-contexts: To make reasoning about a program that uses message passing and subtyping tractable, one should ensure that the member functions of the base class have an appropriate specification in the derived class [24] [1] [19] <ref> [3] </ref> [17]. This is almost automatic if one inherits the specifications, except that one has to ensure that the trait functions used in the base classes' specifications have the appropriate meaning [18]. See the references for more details. Larch/C ++ allows multiple inheritance.
Reference: [4] <author> Pierre America. </author> <title> Designing an object-oriented programming language with behavioural subtyping. </title> <editor> In J. W. de Bakker, W. P. de Roever, and G. Rozenberg, editors, </editor> <booktitle> Foundations of Object-Oriented Languages, REX School/Workshop, Noordwijkerhout, The Netherlands, May/June 1990, volume 489 of Lecture Notes in Computer Science, </booktitle> <pages> pages 60-90. </pages> <publisher> Springer-Verlag, </publisher> <address> New York, N.Y., </address> <year> 1991. </year>
Reference-contexts: The simulates clause says that each directed graph abstract value, d, simulates the graph abstract value, toG (d). That is, the trait function toG can be used as a coercion function from directed graphs to graphs. Having such coercion functions is useful in dealing with subtyping [5] [1] [2] <ref> [4] </ref> [20] [21]. In Larch/C ++ , one can specify a trait function that acts as a coercion for each base type. This coercion function helps to define the semantics of inherited Larch/C++ specifications.
Reference: [5] <author> Kim B. Bruce and Peter Wegner. </author> <title> An algebraic model of subtype and inheritance. </title> <editor> In Francois Ban~cilhon and Peter Buneman, editors, </editor> <booktitle> Advances in Database Programming Languages, </booktitle> <pages> pages 75-96. </pages> <publisher> Addison-Wesley, </publisher> <address> Reading, Mass., </address> <month> August </month> <year> 1990. </year>
Reference-contexts: The simulates clause says that each directed graph abstract value, d, simulates the graph abstract value, toG (d). That is, the trait function toG can be used as a coercion function from directed graphs to graphs. Having such coercion functions is useful in dealing with subtyping <ref> [5] </ref> [1] [2] [4] [20] [21]. In Larch/C ++ , one can specify a trait function that acts as a coercion for each base type. This coercion function helps to define the semantics of inherited Larch/C++ specifications.
Reference: [6] <author> Yoonsik Cheon. Larch/Smalltalk: </author> <title> A specification language for Smalltalk. </title> <type> Technical Report 91-15, </type> <institution> Department of Computer Science; Iowa State University, Ames, IA, </institution> <month> June </month> <year> 1991. </year>
Reference-contexts: This idea lead to the specification languages VDM [14] and Z [12] [25] and the family of Larch interface specification languages [29] [11] [27] <ref> [6] </ref> [8] [9] [15] [10]. This style of specification is called "model-oriented" in [28], because behavior is described by abstract values taken from some mathematical model. <p> Each Larch/C ++ specification uses a trait in this way. LSL is called a "shared language" because it also plays the same role for other Larch family languages, such as Larch/C [10], Larch/Modula-3 [15][10], and Larch/Smalltalk <ref> [6] </ref>. For example, Figure 1 shows a simple Larch/C ++ specification. The first line is like a C ++ #include line; it says that the interface specification in the file IntStack.lcc is to be read for type information. Presumably, IntStack.lcc specifies the class IntStack (see uses. <p> Distinguishing features of Larch/C ++ from other Larch interface specification languages are as follows. * Inheritance of specification. A derived class (subclass) inherits its base classes' (su-perclasses') specifications. (Inheritance is also present in Larch/Smalltalk <ref> [6] </ref> and Larch/Modula-3 [15].) 3 * Multiple interfaces for class. A class specification has three different interfaces: one for clients (public), another for derived classes (protected), the third for the imple mentor and friends (private). * Compatibility with LCL [8], a Larch interface specification language for C.
Reference: [7] <author> Marshall P. Cline and Doug Lea. </author> <title> The behavior of c++ classes. </title> <booktitle> In Proceedings of the Symposium on Object Oriented Programming Emphasizing Practical Applications, </booktitle> <address> Marist College, </address> <year> 1990, 1990. </year> <note> To appear. </note>
Reference-contexts: Although Larch/C ++ does not suffer from the above problems, it may be more difficult for the average programmer to use and understand than Eiffel's specifications. Only more experience will tell. A refinement of the Eiffel specification language is found in the specification language Annotated C ++ (called A++) <ref> [7] </ref>. Assertions in A++ may use universal and existential quantification, and hence are not generally executable, although they are still expressed using the expressions of C ++ .
Reference: [8] <author> J. V. Guttag and J. J. Horning. </author> <title> Introduction to LCL, a Larch/C interface language. </title> <type> Technical Report 74, </type> <institution> Digital Equipment Corporation, Systems Research Center, </institution> <month> July </month> <year> 1991. </year>
Reference-contexts: This idea lead to the specification languages VDM [14] and Z [12] [25] and the family of Larch interface specification languages [29] [11] [27] [6] <ref> [8] </ref> [9] [15] [10]. This style of specification is called "model-oriented" in [28], because behavior is described by abstract values taken from some mathematical model. In Larch/C ++ an interface specification consists of two parts: some Larch/C ++ specific text, and some text in the Larch Shared Language (LSL) [10]. <p> A class specification has three different interfaces: one for clients (public), another for derived classes (protected), the third for the imple mentor and friends (private). * Compatibility with LCL <ref> [8] </ref>, a Larch interface specification language for C. Most parts of LCL specifications are legal Larch/C ++ syntax and have the same meaning. A discussion of our reasons for making certain decisions in the design of Larch/C ++ are described elsewhere [18]. <p> An extended Larch/C ++ example specification is given in Section 7. 2 Larch/C++ Interface Modules A Larch/C ++ specification typically consists of several specification units called interface modules. An interface module is the unit of specification in Larch/C ++ and is stored in a separate file. As in LCL <ref> [8] </ref>, some part of an implementation file will be automatically generated from the corresponding interface module. For example, suppose we have an interface module named foo.lcc. A header file named foo.lh will be automatically generated from foo.lcc by planned Larch/C ++ tools.
Reference: [9] <author> J. V. Guttag and J. J. Horning. </author> <title> A tutorial on Larch and LCL, a Larch/C interface language. </title> <editor> In S. Prehn and W. J. Toetenel, editors, </editor> <booktitle> VDM '91 Formal Software Development Methods 4th International Symposium of VDM Europe Noordwijkerhout, The Netherlands, Volume 2: Tutorials, volume 552 of Lecture Notes in Computer Science, </booktitle> <pages> pages 1-78. </pages> <publisher> Springer-Verlag, </publisher> <address> New York, N.Y., </address> <month> October </month> <year> 1991. </year> <month> 32 </month>
Reference-contexts: This idea lead to the specification languages VDM [14] and Z [12] [25] and the family of Larch interface specification languages [29] [11] [27] [6] [8] <ref> [9] </ref> [15] [10]. This style of specification is called "model-oriented" in [28], because behavior is described by abstract values taken from some mathematical model. In Larch/C ++ an interface specification consists of two parts: some Larch/C ++ specific text, and some text in the Larch Shared Language (LSL) [10].
Reference: [10] <author> John V. Guttag, James J. Horning, S.J. Garland, K.D. Jones, A. Modet, and J.M. Wing. </author> <title> Larch: Languages and Tools for Formal Specification. </title> <publisher> Springer-Verlag, </publisher> <address> New York, N.Y., </address> <year> 1993. </year>
Reference-contexts: The details of how to call a C ++ function, the name, return type, and argument types, are called the interface of that function. Since Larch/C ++ specifies both a C ++ interface and behavior, it is an interface specification language [29] [27] [16] <ref> [10] </ref>. The word "Larch" in Larch/C ++ refers to the use of the Larch Shared Language [10] to precisely describe behavior. The approach dates back to Hoare's work [13] on verification of programs that use abstract data types (ADTs). <p> Since Larch/C ++ specifies both a C ++ interface and behavior, it is an interface specification language [29] [27] [16] <ref> [10] </ref>. The word "Larch" in Larch/C ++ refers to the use of the Larch Shared Language [10] to precisely describe behavior. The approach dates back to Hoare's work [13] on verification of programs that use abstract data types (ADTs). <p> This idea lead to the specification languages VDM [14] and Z [12] [25] and the family of Larch interface specification languages [29] [11] [27] [6] [8] [9] [15] <ref> [10] </ref>. This style of specification is called "model-oriented" in [28], because behavior is described by abstract values taken from some mathematical model. In Larch/C ++ an interface specification consists of two parts: some Larch/C ++ specific text, and some text in the Larch Shared Language (LSL) [10]. <p> [6] [8] [9] [15] <ref> [10] </ref>. This style of specification is called "model-oriented" in [28], because behavior is described by abstract values taken from some mathematical model. In Larch/C ++ an interface specification consists of two parts: some Larch/C ++ specific text, and some text in the Larch Shared Language (LSL) [10]. The LSL text is called a trait; it describes the abstract values, and some vocabulary that is used to manipulate those abstract values, that are used in the Larch/C ++ part. Each Larch/C ++ specification uses a trait in this way. <p> Each Larch/C ++ specification uses a trait in this way. LSL is called a "shared language" because it also plays the same role for other Larch family languages, such as Larch/C <ref> [10] </ref>, Larch/Modula-3 [15][10], and Larch/Smalltalk [6]. For example, Figure 1 shows a simple Larch/C ++ specification. The first line is like a C ++ #include line; it says that the interface specification in the file IntStack.lcc is to be read for type information. <p> The function sorted_interval, specified in Figure 4, checks if a given interval of an array is sorted. The pre-condition says that l and u together denote a legal slice of the array x. The notation /" means conjunction. The trait function maxIndex denotes the upper bound of an array <ref> [10] </ref>. <p> This follows LCL <ref> [10] </ref>.) Similarly the universally quantified variables i and j are also names of abstract values, not names of objects. However, since 1 The identifier int is used in four different ways: (1) type name, (2) trait function, (3) sort name, and (4) trait name. <p> An edge E is again a tuple of nodes N, whose first and second elements are denoted by head and tail respectively. The tuple definition is LSL shorthand notation for introducing fixed-length tuples <ref> [10] </ref>. For example, "G tuple of nodes: SN, edges: SE" is equivalent to including a trait with body shown in Figure 10. All the information specified in the trait GraphTrait is only about nodes, since it is not yet known whether edges are directed or undirected. <p> The trait Set defines a mathematical model for sets and with typical set operations; "U ([), "I ("), - (set-difference), etc. Some of these set operations are used in the specifications of classes Graph, DirectedGraph, and UndirectedGraph. The trait Set is found in the Larch Shared Language Handbook <ref> [10, 21 introduces [__,__] </ref>: SN, SE -&gt; G __.nodes: G -&gt; SN __.edges: G -&gt; SE set_nodes: G, SN -&gt; G set_edges: G, SE -&gt; G asserts G generated by [__,__] G partitioned by __.nodes, __.edges "forall g:G, n,n1: SN, e,e1: SE [n,e].nodes == n; [n,e].edges == e; set_nodes ([n,e],n1) ==
Reference: [11] <author> John V. Guttag, James J. Horning, and Jeannette M. Wing. </author> <title> The Larch family of specification languages. </title> <journal> IEEE Software, </journal> <volume> 2(4), </volume> <month> September </month> <year> 1985. </year>
Reference-contexts: This idea lead to the specification languages VDM [14] and Z [12] [25] and the family of Larch interface specification languages [29] <ref> [11] </ref> [27] [6] [8] [9] [15] [10]. This style of specification is called "model-oriented" in [28], because behavior is described by abstract values taken from some mathematical model.
Reference: [12] <author> I. Hayes, </author> <title> editor. Specification Case Studies. </title> <booktitle> International Series in Computer Science. </booktitle> <publisher> Prentice-Hall, Inc., </publisher> <year> 1987. </year>
Reference-contexts: Hoare's idea was to describe the behavior of an operation of an ADT, not in terms of the bits in the representation of an ADT, but in terms of "abstract values" such as mathematical sets or stacks. This idea lead to the specification languages VDM [14] and Z <ref> [12] </ref> [25] and the family of Larch interface specification languages [29] [11] [27] [6] [8] [9] [15] [10]. This style of specification is called "model-oriented" in [28], because behavior is described by abstract values taken from some mathematical model.
Reference: [13] <author> C. A. R. Hoare. </author> <title> Proof of correctness of data representations. </title> <journal> Acta Informatica, </journal> <volume> 1(4) </volume> <pages> 271-281, </pages> <year> 1972. </year>
Reference-contexts: Since Larch/C ++ specifies both a C ++ interface and behavior, it is an interface specification language [29] [27] [16] [10]. The word "Larch" in Larch/C ++ refers to the use of the Larch Shared Language [10] to precisely describe behavior. The approach dates back to Hoare's work <ref> [13] </ref> on verification of programs that use abstract data types (ADTs). Hoare's idea was to describe the behavior of an operation of an ADT, not in terms of the bits in the representation of an ADT, but in terms of "abstract values" such as mathematical sets or stacks.
Reference: [14] <author> Cliff B. Jones. </author> <title> Systematic software development using VDM. </title> <booktitle> International Series in Computer Science. </booktitle> <publisher> Prentice-Hall, Inc., </publisher> <address> Englewood Cliffs, N.J., </address> <year> 1986. </year>
Reference-contexts: Hoare's idea was to describe the behavior of an operation of an ADT, not in terms of the bits in the representation of an ADT, but in terms of "abstract values" such as mathematical sets or stacks. This idea lead to the specification languages VDM <ref> [14] </ref> and Z [12] [25] and the family of Larch interface specification languages [29] [11] [27] [6] [8] [9] [15] [10]. This style of specification is called "model-oriented" in [28], because behavior is described by abstract values taken from some mathematical model.
Reference: [15] <author> Kevin D. Jones. LM3: </author> <title> A Larch interface language for Modula-3: A definition and introduction: Version 1.0. </title> <type> Technical Report 72, </type> <institution> Digital Equipment Corporation, Systems Research Center, </institution> <address> 130 Lytton Avenue Palo Alto, CA 94301, </address> <month> June </month> <year> 1991. </year>
Reference-contexts: This idea lead to the specification languages VDM [14] and Z [12] [25] and the family of Larch interface specification languages [29] [11] [27] [6] [8] [9] <ref> [15] </ref> [10]. This style of specification is called "model-oriented" in [28], because behavior is described by abstract values taken from some mathematical model. In Larch/C ++ an interface specification consists of two parts: some Larch/C ++ specific text, and some text in the Larch Shared Language (LSL) [10]. <p> Distinguishing features of Larch/C ++ from other Larch interface specification languages are as follows. * Inheritance of specification. A derived class (subclass) inherits its base classes' (su-perclasses') specifications. (Inheritance is also present in Larch/Smalltalk [6] and Larch/Modula-3 <ref> [15] </ref>.) 3 * Multiple interfaces for class. A class specification has three different interfaces: one for clients (public), another for derived classes (protected), the third for the imple mentor and friends (private). * Compatibility with LCL [8], a Larch interface specification language for C.
Reference: [16] <author> Leslie Lamport. </author> <title> A simple approach to specifying concurrent systems. </title> <journal> Communications of the ACM, </journal> <volume> 32(1) </volume> <pages> 32-45, </pages> <month> January </month> <year> 1989. </year>
Reference-contexts: The details of how to call a C ++ function, the name, return type, and argument types, are called the interface of that function. Since Larch/C ++ specifies both a C ++ interface and behavior, it is an interface specification language [29] [27] <ref> [16] </ref> [10]. The word "Larch" in Larch/C ++ refers to the use of the Larch Shared Language [10] to precisely describe behavior. The approach dates back to Hoare's work [13] on verification of programs that use abstract data types (ADTs).
Reference: [17] <author> Gary T. Leavens. </author> <title> Modular specification and verification of object-oriented programs. </title> <journal> IEEE Software, </journal> <volume> 8(4) </volume> <pages> 72-80, </pages> <month> July </month> <year> 1991. </year>
Reference-contexts: To make reasoning about a program that uses message passing and subtyping tractable, one should ensure that the member functions of the base class have an appropriate specification in the derived class [24] [1] [19] [3] <ref> [17] </ref>. This is almost automatic if one inherits the specifications, except that one has to ensure that the trait functions used in the base classes' specifications have the appropriate meaning [18]. See the references for more details. Larch/C ++ allows multiple inheritance.
Reference: [18] <author> Gary T. Leavens and Yoonsik Cheon. </author> <title> Preliminary design of Larch/C++. </title> <editor> In U. Martin and J. Wing, editors, </editor> <booktitle> Proceedings of the First International Workshop on Larch, </booktitle> <month> July, </month> <year> 1992, </year> <title> Workshops in Computing. </title> <publisher> Springer-Verlag, </publisher> <address> New York, N.Y., </address> <year> 1993. </year>
Reference-contexts: Most parts of LCL specifications are legal Larch/C ++ syntax and have the same meaning. A discussion of our reasons for making certain decisions in the design of Larch/C ++ are described elsewhere <ref> [18] </ref>. In this paper we confine ourselves to informally describing how to write Larch/C ++ specifications. In the following section, Larch/C ++ interface modules are explained. In Section 3, declarations are described. In Section 4 and Section 5, function specifications and class specifications are explained. <p> Such declarations must appear in the implementation, and are used to record implementation decisions <ref> [18] </ref>. 3.1 Constant Declarations A Larch/C ++ constant declaration is like a const variable declaration of C ++ with an initializer. The initializer must be an LSL term. <p> This is almost automatic if one inherits the specifications, except that one has to ensure that the trait functions used in the base classes' specifications have the appropriate meaning <ref> [18] </ref>. See the references for more details. Larch/C ++ allows multiple inheritance. A class can be specified to have more than one direct base class. The ambiguity resolution rules for multiple occurrence of a base class are the same as those of C ++ .
Reference: [19] <author> Gary T. Leavens and William E. Weihl. </author> <title> Reasoning about object-oriented programs that use subtypes (extended abstract). </title> <journal> ACM SIGPLAN Notices, </journal> <volume> 25(10) </volume> <pages> 212-223, </pages> <month> October </month> <year> 1990. </year> <booktitle> OOPSLA ECOOP '90 Proceedings, N. Meyrowitz (editor). </booktitle>
Reference-contexts: To make reasoning about a program that uses message passing and subtyping tractable, one should ensure that the member functions of the base class have an appropriate specification in the derived class [24] [1] <ref> [19] </ref> [3] [17]. This is almost automatic if one inherits the specifications, except that one has to ensure that the trait functions used in the base classes' specifications have the appropriate meaning [18]. See the references for more details. Larch/C ++ allows multiple inheritance.
Reference: [20] <author> Barbara Liskov and Jeannette M. Wing. </author> <title> A new definition of the subtype relation. Programming Methodology Group Memo 76, </title> <institution> Massachusetts Institute of Technology, 33 Laboratory for Computer Science, </institution> <month> May </month> <year> 1993. </year> <note> To appear in the proceedings of ECOOP '93. </note>
Reference-contexts: That is, the trait function toG can be used as a coercion function from directed graphs to graphs. Having such coercion functions is useful in dealing with subtyping [5] [1] [2] [4] <ref> [20] </ref> [21]. In Larch/C ++ , one can specify a trait function that acts as a coercion for each base type. This coercion function helps to define the semantics of inherited Larch/C++ specifications. The invariant clause introduces a predicate that must be preserved by all objects of the specified class.
Reference: [21] <author> Barbara Liskov and Jeannette M. Wing. </author> <title> Specifications and their use in defining sub-types. </title> <booktitle> To appear in the proceedings of OOPSLA '93. Obtained from the Authors, </booktitle> <month> May </month> <year> 1993. </year>
Reference-contexts: That is, the trait function toG can be used as a coercion function from directed graphs to graphs. Having such coercion functions is useful in dealing with subtyping [5] [1] [2] [4] [20] <ref> [21] </ref>. In Larch/C ++ , one can specify a trait function that acts as a coercion for each base type. This coercion function helps to define the semantics of inherited Larch/C++ specifications. The invariant clause introduces a predicate that must be preserved by all objects of the specified class.
Reference: [22] <author> Bertrand Meyer. </author> <title> Object-oriented Software Construction. </title> <publisher> Prentice Hall, </publisher> <address> New York, N.Y., </address> <year> 1988. </year>
Reference-contexts: The post-condition describes the relationship between s^ and the abstract value of the object s after the execution of pop_twice terminates, written s'. The pre- and post-conditions use the trait functions size and pop from the trait StackTrait. In Eiffel <ref> [22, Chapter 7] </ref> [23, Chapter 9], one can also use a model-oriented style, but there is no separate mathematical specification of abstract values. That is, there are no traits. Instead, the concrete values of the programming language play the role of abstract values. <p> Both member functions return references to the object self. The const member function adjacentNodes returns a reference to a new set containing all the adjacent nodes of a given node. 8 Related Work Larch/C ++ solves the following problems with Eiffel's style of specification <ref> [22, Chapter 7] </ref> [23, Chapter 9]. In Eiffel, 1. There is no way to express universally or existentially quantified assertions. 2. One is sometimes forced to export more operations than one would like in order to specify some types.
Reference: [23] <author> Bertrand Meyer. </author> <title> Eiffel: The Language. Object-Oriented Series. </title> <publisher> Prentice Hall, </publisher> <address> New York, N.Y., </address> <year> 1992. </year>
Reference-contexts: The post-condition describes the relationship between s^ and the abstract value of the object s after the execution of pop_twice terminates, written s'. The pre- and post-conditions use the trait functions size and pop from the trait StackTrait. In Eiffel [22, Chapter 7] <ref> [23, Chapter 9] </ref>, one can also use a model-oriented style, but there is no separate mathematical specification of abstract values. That is, there are no traits. Instead, the concrete values of the programming language play the role of abstract values. <p> Both member functions return references to the object self. The const member function adjacentNodes returns a reference to a new set containing all the adjacent nodes of a given node. 8 Related Work Larch/C ++ solves the following problems with Eiffel's style of specification [22, Chapter 7] <ref> [23, Chapter 9] </ref>. In Eiffel, 1. There is no way to express universally or existentially quantified assertions. 2. One is sometimes forced to export more operations than one would like in order to specify some types. <p> One is sometimes forced to export more operations than one would like in order to specify some types. For example, to specify a statistical database with instance operations insert, mean, and variance, one would also need to export operations that enumerate the elements to state the post-condition of insert <ref> [23, section 9.8] </ref>. However, a designer may wish to hide such operations for other reasons. 3. The meaning of an assertion is unclear if the operations involved fail to terminate or use non-portable parts of the language.
Reference: [24] <author> Craig Schaffert, Topher Cooper, Bruce Bullis, Mike Kilian, and Carrie Wilpolt. </author> <title> An introduction to Trellis/Owl. </title> <journal> ACM SIGPLAN Notices, </journal> <volume> 21(11) </volume> <pages> 9-16, </pages> <month> November </month> <year> 1986. </year> <booktitle> OOPSLA '86 Conference Proceedings, </booktitle> <editor> Norman Meyrowitz (editor), </editor> <month> September </month> <year> 1986, </year> <institution> Portland, Oregon. </institution>
Reference-contexts: To make reasoning about a program that uses message passing and subtyping tractable, one should ensure that the member functions of the base class have an appropriate specification in the derived class <ref> [24] </ref> [1] [19] [3] [17]. This is almost automatic if one inherits the specifications, except that one has to ensure that the trait functions used in the base classes' specifications have the appropriate meaning [18]. See the references for more details. Larch/C ++ allows multiple inheritance.
Reference: [25] <author> J. Michael Spivey. </author> <title> The Z Notation: A Reference Manual. </title> <booktitle> International Series in Computer Science. </booktitle> <publisher> Prentice-Hall, </publisher> <address> New York, N.Y., </address> <year> 1989. </year> <note> ISBN 013983768X. </note>
Reference-contexts: Hoare's idea was to describe the behavior of an operation of an ADT, not in terms of the bits in the representation of an ADT, but in terms of "abstract values" such as mathematical sets or stacks. This idea lead to the specification languages VDM [14] and Z [12] <ref> [25] </ref> and the family of Larch interface specification languages [29] [11] [27] [6] [8] [9] [15] [10]. This style of specification is called "model-oriented" in [28], because behavior is described by abstract values taken from some mathematical model.
Reference: [26] <author> Bjarne Stroustrup. </author> <title> The C++ Programming Language: Second Edition. </title> <publisher> Addison-Wesley Publishing Co., </publisher> <address> Reading, Mass., </address> <year> 1991. </year>
Reference-contexts: 1 Introduction Object-oriented programming languages, such as C ++ <ref> [26] </ref>, are good for building reusable components. The reuse of program components requires adequate documentation. The specification language Larch/C ++ allows interfaces of C ++ classes and functions to be documented in a way that is unambiguous and concise. <p> The suffix "any is like ' or ^, and extracts the value of this in some visible state; since in a member function of a class named X, this is implicitly declared as X *const this <ref> [26, Section r.9.3.1] </ref>, it is a constant, and so its value is the same in all states. Both data members and member functions can be public, protected, or private. tells Larch/C ++ that the specification is expressed with the vocabulary of the LSL trait StackTrait (see Figure 7).
Reference: [27] <author> Jeannette M. Wing. </author> <title> Writing Larch interface language specifications. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 9(1) </volume> <pages> 1-24, </pages> <month> January </month> <year> 1987. </year>
Reference-contexts: The details of how to call a C ++ function, the name, return type, and argument types, are called the interface of that function. Since Larch/C ++ specifies both a C ++ interface and behavior, it is an interface specification language [29] <ref> [27] </ref> [16] [10]. The word "Larch" in Larch/C ++ refers to the use of the Larch Shared Language [10] to precisely describe behavior. The approach dates back to Hoare's work [13] on verification of programs that use abstract data types (ADTs). <p> This idea lead to the specification languages VDM [14] and Z [12] [25] and the family of Larch interface specification languages [29] [11] <ref> [27] </ref> [6] [8] [9] [15] [10]. This style of specification is called "model-oriented" in [28], because behavior is described by abstract values taken from some mathematical model.
Reference: [28] <author> Jeannette M. Wing. </author> <title> A specifier's introduction to formal methods. </title> <journal> Computer, </journal> <volume> 23(9) </volume> <pages> 8-24, </pages> <month> September </month> <year> 1990. </year>
Reference-contexts: This idea lead to the specification languages VDM [14] and Z [12] [25] and the family of Larch interface specification languages [29] [11] [27] [6] [8] [9] [15] [10]. This style of specification is called "model-oriented" in <ref> [28] </ref>, because behavior is described by abstract values taken from some mathematical model. In Larch/C ++ an interface specification consists of two parts: some Larch/C ++ specific text, and some text in the Larch Shared Language (LSL) [10].
Reference: [29] <author> Jeannette Marie Wing. </author> <title> A two-tiered approach to specifying programs. </title> <type> Technical Report TR-299, </type> <institution> Massachusetts Institute of Technology, Laboratory for Computer Science, </institution> <year> 1983. </year>
Reference-contexts: The details of how to call a C ++ function, the name, return type, and argument types, are called the interface of that function. Since Larch/C ++ specifies both a C ++ interface and behavior, it is an interface specification language <ref> [29] </ref> [27] [16] [10]. The word "Larch" in Larch/C ++ refers to the use of the Larch Shared Language [10] to precisely describe behavior. The approach dates back to Hoare's work [13] on verification of programs that use abstract data types (ADTs). <p> This idea lead to the specification languages VDM [14] and Z [12] [25] and the family of Larch interface specification languages <ref> [29] </ref> [11] [27] [6] [8] [9] [15] [10]. This style of specification is called "model-oriented" in [28], because behavior is described by abstract values taken from some mathematical model.
References-found: 29

