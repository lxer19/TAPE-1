URL: http://www.cse.ogi.edu/Sparse/paper/stoltz.scalardd.94.ps
Refering-URL: http://www.cse.ogi.edu/~stoltz/
Root-URL: http://www.cse.ogi.edu
Email: fstoltz,mwolfeg@cse.ogi.edu  
Phone: (503) 690-1121 ext. 7404  
Title: Detecting Value-Based Scalar Dependence  
Author: Eric Stoltz and Michael Wolfe 
Date: April 29, 1994  
Address: P.O. Box 91000 Portland, OR 97291-1000  
Affiliation: Department of Computer Science and Engineering Oregon Graduate Institute of Science Technology  
Abstract: Precise value-based data dependence analysis for scalars is useful for advanced compiler optimizations. The new method presented here for flow and output dependence uses Factored Use and Def chains (FUD chains), our interpretation and extension of Static Single Assignment. It is precise with respect to conditional control flow and dependence vectors. Our method detects dependences which are independent with respect to arbitrary loop nesting, as well as loop-carried dependences. A loop-carried dependence is further classified as being carried by the previous iteration, with distance 1, or by any previous iteration, with direction &lt;. This precision cannot be achieved by traditional analysis, such as dominator information or reaching definitions. To compute anti-dependence, we use Factored Redef-Use chains, which are related to FUD chains. We are not aware of any prior work which explicitly deals with scalar data dependence utilizing a sparse graph representation.
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> A. V. Aho, R. Sethi, and J. D. Ullman. </author> <booktitle> Compilers: Principles, Techniques, and Tools. </booktitle> <publisher> Addison-Wesley, </publisher> <address> Reading, MA, </address> <year> 1986. </year>
Reference-contexts: Irreducible Graphs Since we identify natural loops in the CFG, cycles may still exist which do not include a loop-header -function. This occurs in irreducible flow graphs <ref> [1] </ref>. Informally, a directed graph is irreducible when there exists a cycle with more than one entry. This corresponds to unstructured code in which a loop has multiple points of entry. <p> Scientific codes, such as Spice in the Perfect Club Benchmark suite [6], may contain numerous such anomalies. Natural loops in our CFG are identified by a back edge in which the head dominates the tail <ref> [1] </ref>. Thus, a cycle with more than one entry point will not be classified as a loop in our intermediate representation. However, definitions may still occur within these cycles, which will result in a -function being placed at the merge.
Reference: [2] <author> J. R. Allen. </author> <title> Dependence analysis for subscripted variables and its application to program transformations. </title> <type> PhD dissertation, </type> <institution> Rice Univ., Dept. Mathematical Sciences, </institution> <month> April </month> <year> 1983. </year> <note> (available from Univ. Microfilms Inc., document 83-14916). </note>
Reference-contexts: In some sense, our technique gives the advantages of syntax-based analysis for unstructured programs, just as interval methods do for data flow analysis. We employ standard terminology for data dependence. The common address-based definitions of flow, output and anti-dependence can be found in many references <ref> [2, 3, 16, 18] </ref>. Value-based dependence relations are a subset of the address-based dependence relations [11].
Reference: [3] <author> John R. Allen and Ken Kennedy. </author> <title> Automatic translation of Fortran programs to vector form. </title> <journal> ACM Trans. on Programming Languages and Systems, </journal> <volume> 9(4) </volume> <pages> 491-542, </pages> <month> October </month> <year> 1987. </year>
Reference-contexts: In some sense, our technique gives the advantages of syntax-based analysis for unstructured programs, just as interval methods do for data flow analysis. We employ standard terminology for data dependence. The common address-based definitions of flow, output and anti-dependence can be found in many references <ref> [2, 3, 16, 18] </ref>. Value-based dependence relations are a subset of the address-based dependence relations [11].
Reference: [4] <author> Robert A. Ballance, Arthur B. Maccabe, and Karl J. Ottenstein. </author> <title> The program dependence web: A representation supporting control-, data-, and demand-driven interpretation of imperative languages. </title> <booktitle> In Proc. ACM SIGPLAN '90 Conf. on Programming Language Design and Implementation, </booktitle> <pages> pages 257-271, </pages> <address> White Plains, NY, </address> <month> June </month> <year> 1990. </year>
Reference-contexts: We have previously described how to use FUD chains for other scalar analysis methods, such as induction variable detection and constant propagation [9, 13]. The concepts of FUD chains are described in Section 2. Other intermediate representations, such as dependence flow graphs [10] or the program dependence web <ref> [4] </ref>, could also be used with similar algorithms; these representations contain enough information to find the actual dependences, though they do not represent the dependence relations explicitly.
Reference: [5] <author> Jong-Deok Choi, Ron Cytron, and Jeanne Ferrante. </author> <title> Automatic construction of sparse data flow evaluation graphs. </title> <booktitle> In Conf. Record 18th Annual ACM Symp. Principles of Programming Languages, </booktitle> <pages> pages 55-66, </pages> <address> Orlando, Florida, </address> <month> January </month> <year> 1991. </year>
Reference-contexts: The -placement algorithm [7] is used (with slight modifications) to place -functions wherever two or more downward-exposed uses or definitions merge. (To be precise, -functions are placed wherever two basic block nodes with non-identity transfer functions for "reaching uses" meet, similar to the technique employed by sparse evaluation graphs <ref> [5] </ref>.) The chaining algorithm (originally called "renaming") is modified to keep a stack of current uses for each 13 S 1 : T ? = : : : S 2 : loop S 3 : (T ? ,T 8 ) S 4 : if : : : then S 5 :
Reference: [6] <author> George Cybenko, Lyle Kipp, Lynn Pointer, and David Kuck. </author> <title> Supercomputer performance evaluation and the Perfect Benchmarks. </title> <booktitle> In International Conference on Supercomputing, </booktitle> <pages> pages 254 - 266, </pages> <month> March </month> <year> 1990. </year>
Reference-contexts: This corresponds to unstructured code in which a loop has multiple points of entry. Although it has been shown that irreducible flow graphs do not occur with high frequency, we must still address the problem. Scientific codes, such as Spice in the Perfect Club Benchmark suite <ref> [6] </ref>, may contain numerous such anomalies. Natural loops in our CFG are identified by a back edge in which the head dominates the tail [1]. Thus, a cycle with more than one entry point will not be classified as a loop in our intermediate representation. <p> How often does this case occur? To discover the usefulness of our method, we ran our algorithm over the scientific benchmarks contained in the Perfect Club <ref> [6] </ref>, RiCEPS, and Mendez suites. In order to keep the investigation at a level which is easy to analyze, this set of data only counted flow dependences in which the source and sink of the dependence were within the same inner loop.
Reference: [7] <author> Ron Cytron, Jeanne Ferrante, Barry K. Rosen, Mark N. Wegman, and F. Kenneth Zadeck. </author> <title> Efficiently computing Static Single Assignment form and the control dependence graph. </title> <journal> ACM Trans. on Programming Languages and Systems, </journal> <volume> 13(4) </volume> <pages> 451-490, </pages> <month> October </month> <year> 1991. </year>
Reference-contexts: We will show this situation occurs frequently in our benchmark programs. Our analysis is based on Factored Use and Definition chains (FUD chains). FUD chains are our implementation and interpretation of the Static Single Assignment (SSA) form <ref> [7] </ref> of a program, with extensions. We have previously described how to use FUD chains for other scalar analysis methods, such as induction variable detection and constant propagation [9, 13]. The concepts of FUD chains are described in Section 2. <p> In this way, use-def and def-def chains factor the graph into a sparse representation for each variable. This gives rise to the FUD chains referred to in the previous section. For theoretical details on SSA graph construction the reader is referred to the paper by Cytron et al. <ref> [7] </ref>, while details of FUD chain construction are provided in an earlier paper [12]. Reference Chaining The general process of providing pointers (links) between arbitrary pairs of definition sites and usage sites of a variable is called reference chaining. <p> Since -functions are placed at dominance frontiers <ref> [7] </ref> of variable definition sites, and the loop-header basic block dominates all blocks contained within the loop, we note a crucial property of loop-header - functions: a loop-header -function for variable v exists iff there is a definition of v within the loop. <p> This structure, which we call factored redef-use chains (FRDU chains) links each definition to the closest preceding downward-exposed use. FRDU chains are built with the same methods used to build FUD chains, except uses are treated like non-killing definitions and definitions are treated like uses. The -placement algorithm <ref> [7] </ref> is used (with slight modifications) to place -functions wherever two or more downward-exposed uses or definitions merge. (To be precise, -functions are placed wherever two basic block nodes with non-identity transfer functions for "reaching uses" meet, similar to the technique employed by sparse evaluation graphs [5].) The chaining algorithm (originally
Reference: [8] <author> Paul Feautrier. </author> <title> Dataflow analysis of array and scalar references. </title> <journal> International Journal of Parallel Programming, </journal> <volume> 20(1) </volume> <pages> 23-54, </pages> <year> 1991. </year>
Reference-contexts: A great deal of work has also been done to find dependence due to pointer aliasing. Little has been written about data dependence analysis for scalar references, except to refer to standard data flow analysis [14], to treat a scalar as a degenerate array <ref> [8] </ref>, or to use simple methods based on the dominator relationship or the syntactic structure of the program. In this paper, we present a new approach to finding data dependence for scalars. Our approach has several features, one of which is that it computes value-based dependence, not just address-based dependence.
Reference: [9] <author> Michael P. Gerlek, Eric Stoltz, and Michael Wolfe. </author> <title> Beyond induction variables: Detecting and classifying sequences using a demand-driven SSA form. </title> <note> submitted for publication, </note> <month> March </month> <year> 1994. </year>
Reference-contexts: FUD chains are our implementation and interpretation of the Static Single Assignment (SSA) form [7] of a program, with extensions. We have previously described how to use FUD chains for other scalar analysis methods, such as induction variable detection and constant propagation <ref> [9, 13] </ref>. The concepts of FUD chains are described in Section 2.
Reference: [10] <author> Richard Johnson and Keshav Pingali. </author> <title> Dependence-based program analysis. </title> <booktitle> In Proc. ACM SIGPLAN '93 Conf. on Programming Language Design and Implementation, </booktitle> <pages> pages 78-89, </pages> <address> Albuquerque, NM, </address> <month> June </month> <year> 1993. </year>
Reference-contexts: We have previously described how to use FUD chains for other scalar analysis methods, such as induction variable detection and constant propagation [9, 13]. The concepts of FUD chains are described in Section 2. Other intermediate representations, such as dependence flow graphs <ref> [10] </ref> or the program dependence web [4], could also be used with similar algorithms; these representations contain enough information to find the actual dependences, though they do not represent the dependence relations explicitly.
Reference: [11] <author> Vadim Maslov. </author> <title> Lazy array data-flow dependence analysis. </title> <booktitle> In Conf. Record 21st Annual ACM Symp. Principles of Programming Languages, </booktitle> <pages> pages 311-325, </pages> <address> Portland, OR, </address> <month> January </month> <year> 1994. </year>
Reference-contexts: In this paper, we present a new approach to finding data dependence for scalars. Our approach has several features, one of which is that it computes value-based dependence, not just address-based dependence. Value-based dependence is a more precise definition <ref> [11] </ref>; using value-based dependence reduces the number of dependence relations and may allow more optimizations. Another feature is that our method computes precise dependence distance, when precision is possible, or imprecise dependence vectors otherwise. Precise dependence distance is important for many optimizations, such as instruction scheduling, software pipelining and parallelization. <p> We employ standard terminology for data dependence. The common address-based definitions of flow, output and anti-dependence can be found in many references [2, 3, 16, 18]. Value-based dependence relations are a subset of the address-based dependence relations <ref> [11] </ref>. The difference is explained by a simple example: S 1 : A = B - 1 S 3 : A = B + C The address-based definition of dependence includes S 1 ffi f S 4 for A and S 1 ffi a S 4 for B.
Reference: [12] <author> Eric Stoltz, Michael P. Gerlek, and Michael Wolfe. </author> <title> Extended SSA with factored use-def chains to support optimization and parallelism. </title> <booktitle> In Proc. of 27th Annual Hawaii International Conference on System Sciences, </booktitle> <pages> pages 43-52, </pages> <month> January </month> <year> 1994. </year>
Reference-contexts: This gives rise to the FUD chains referred to in the previous section. For theoretical details on SSA graph construction the reader is referred to the paper by Cytron et al. [7], while details of FUD chain construction are provided in an earlier paper <ref> [12] </ref>. Reference Chaining The general process of providing pointers (links) between arbitrary pairs of definition sites and usage sites of a variable is called reference chaining. <p> An examination of Table 1 reveals that some codes possess structure in which this class of dependence is quite significant. 3.2 Discussion of Algorithm 1 An algorithm for detection of scalar flow dependences within a single loop has been presented previously <ref> [12] </ref>. To extend this algorithm for nested loops, several issues need to be addressed. First, we must provide a recursive routine, to allow arbitrary nesting. Second, distance and/or direction of the dependence must be accurate in terms of all loops which contain the dependence.
Reference: [13] <author> Eric Stoltz, Michael Wolfe, and Michael P. Gerlek. </author> <title> Constant propagation: A fresh, demand-driven look. </title> <booktitle> In Symposium on Applied Computing, </booktitle> <address> Phoenix, AZ, </address> <month> March </month> <year> 1994. </year> <note> ACM SIGAPP. </note>
Reference-contexts: FUD chains are our implementation and interpretation of the Static Single Assignment (SSA) form [7] of a program, with extensions. We have previously described how to use FUD chains for other scalar analysis methods, such as induction variable detection and constant propagation <ref> [9, 13] </ref>. The concepts of FUD chains are described in Section 2.
Reference: [14] <author> Chau-Wen Tseng. </author> <title> An optimizing Fortran D compiler for MIMD distributed-memory machines. </title> <type> PhD Dissertation TR93-199, </type> <institution> Rice University, Depeartmentof Computer Science, </institution> <month> January </month> <year> 1993. </year> <month> 15 </month>
Reference-contexts: A great deal of work has also been done to find dependence due to pointer aliasing. Little has been written about data dependence analysis for scalar references, except to refer to standard data flow analysis <ref> [14] </ref>, to treat a scalar as a degenerate array [8], or to use simple methods based on the dominator relationship or the syntactic structure of the program. In this paper, we present a new approach to finding data dependence for scalars. <p> Precise dependence distance is important for many optimizations, such as instruction scheduling, software pipelining and parallelization. For example, privitization of scalar variables is possible when they are detected as being involved in only loop-independent dependences <ref> [14] </ref>.
Reference: [15] <author> Michael Wolfe. </author> <title> Techniques for improving the inherent parallelism in programs. M.S. </title> <type> thesis UIUCDCS-R-78-929, </type> <institution> Univ. Illinois, Dept. Computer Science, </institution> <month> July </month> <year> 1978. </year>
Reference-contexts: Sometimes an exact distance cannot be computed; in that case, a less precise abstraction is used, called a direction vector <ref> [15, 17] </ref>.
Reference: [16] <author> Michael Wolfe. </author> <title> Optimizing supercompilers for supercomputers. </title> <type> PhD Dissertation UIUCDCS-R-82-1105, </type> <institution> Univ. Illinois, Dept. Computer Science, </institution> <month> October </month> <year> 1982. </year> <note> (available from Univ. Microfilms Inc., document 83-03027). </note>
Reference-contexts: In some sense, our technique gives the advantages of syntax-based analysis for unstructured programs, just as interval methods do for data flow analysis. We employ standard terminology for data dependence. The common address-based definitions of flow, output and anti-dependence can be found in many references <ref> [2, 3, 16, 18] </ref>. Value-based dependence relations are a subset of the address-based dependence relations [11].
Reference: [17] <author> Michael Wolfe. </author> <title> Optimizing Supercompilers for Supercomputers. </title> <booktitle> Research Monographs in Parallel and Distributed Computing. </booktitle> <publisher> Pitman Publishing, </publisher> <address> London, </address> <year> 1989. </year> <note> (also available from MIT Press). </note>
Reference-contexts: Sometimes an exact distance cannot be computed; in that case, a less precise abstraction is used, called a direction vector <ref> [15, 17] </ref>.
Reference: [18] <author> Michael Wolfe and Utpal Banerjee. </author> <title> Data dependence and its application to parallel processing. </title> <journal> International J. Parallel Programming, </journal> <volume> 16(2) </volume> <pages> 137-178, </pages> <month> April </month> <year> 1987. </year> <month> 16 </month>
Reference-contexts: In some sense, our technique gives the advantages of syntax-based analysis for unstructured programs, just as interval methods do for data flow analysis. We employ standard terminology for data dependence. The common address-based definitions of flow, output and anti-dependence can be found in many references <ref> [2, 3, 16, 18] </ref>. Value-based dependence relations are a subset of the address-based dependence relations [11].
References-found: 18

