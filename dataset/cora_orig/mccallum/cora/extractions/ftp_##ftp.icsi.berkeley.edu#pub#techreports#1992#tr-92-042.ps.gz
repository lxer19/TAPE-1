URL: ftp://ftp.icsi.berkeley.edu/pub/techreports/1992/tr-92-042.ps.gz
Refering-URL: http://www.icsi.berkeley.edu/techreports/1992.html
Root-URL: http://www.icsi.berkeley.edu
Title: A Framework for Cumulative Default Logics  
Author: Gerhard Brewka 
Date: July 1992  
Pubnum: TR-92-042  
Abstract: We present a framework for default reasoning which has its roots in Reiter's Default Logic. Contrary to Reiter, however, we do not consider defaults as inference rules used to generate extensions of a classical set of facts. In our approach defaults are elements of the logical language, and we will define inference rules on defaults. This has several advantages. First of all, we can reason about defaults, not just with defaults. This makes it easy to include different intuitions about the right behaviour of a default logic in an explicit form. Secondly, we can show how some of the problems of Reiter's logic and of some recent proposals to solve them can be handled adequately by exploiting the dependency information contained in derived defaults. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Bidoit, Nicole, Froidevaux, Christine, </author> <title> Negation by Default and Non-Stratifiable Logic Programs, </title> <type> Research Report 437, </type> <institution> Universite Paris Sud, Centre d'Orsay, LRI, </institution> <year> 1988 </year>
Reference-contexts: Secondly, DL is very expressive. It can, for instance, be used to formalize logic programs with negation <ref> [1] </ref>, a task for which some of its competitor's, e.g. circumscription, turn out to be insufficient. This expressiveness is mainly due to the representation of defaults as inference rules which makes it possible to avoid problems with contraposition of defaults.
Reference: [2] <author> Brewka, Gerhard: </author> <title> Cumulative Default Logic In Defense of Nonmonotonic Inference Rules, </title> <booktitle> Artificial Intelligence 50, </booktitle> <year> 1991 </year>
Reference-contexts: Unfortunately, Reiter's logic also has its drawbacks, as has been discussed in various papers, e.g. <ref> [13, 9, 2, 5] </ref>: 1. Existence of extensions is not guaranteed. 2. The consistency conditions (justifications) of defaults applied within one Reiter extension are not jointly consistent with the generated extension. Reiter's fixed point definition only guarantees that each consistency condition in isolation is consistent with the extension. <p> Note that cumulativity is an essential property if we want to be able to use derived formulas as Lemmata. 2 In an earlier paper <ref> [2] </ref> we have particularly addressed problems 2) and 4) of the above enumeration. The solution of these problems, the logic CDL, was based on a shift from simple propositions to more complicated structures called assertions. <p> Given an assertional default theory (D; W ), where D is a set of Reiter defaults and W a set of assertions, extensions can be defined using a Reiter-like fixed point construction as follows <ref> [2] </ref>: Definition 2 (CDL extension) An extension of an assertional default theory (D; W ) is a fixed point of the operator which, given a set of assertions S, produces the smallest set of assertions S 0 such that 1. <p> ; J 1 ); : : : ; (p k ; J k ) 2 T h S (A) and p 1 ; : : : ; p k ` q, then (q; J 1 [ : : : [ J k ) 2 T h S (A). 1 In <ref> [2] </ref> CDL is shown to satisfy existence of extensions, semi-monotony, and cumu-lativity. A further advantage of the logic is that it allows for a syntactic distinction between hard facts and weak conclusions. An Etherington-style semantics for CDL has been presented in [16]. <p> E Ass (C), that is E consists of assumables in C, 2. Kern (C) E, 3. J ust (E) [ Cons (E) is consistent. 10 This definition is, contrary to Reiter's original one and the one used for CDL in <ref> [2] </ref>, not based on a fixed point construction. This is possible since the derived defaults carry sufficient dependency information with them. <p> Every extension then has to be consistent with J ust (S) [ Cons (S). This can, for instance, be used to model Poole-systems with constraints [12] or CDL <ref> [2] </ref> in our framework. Another idea would be to use explicit priority orderings of defaults instead of the implicit orderings induced by semi-normal defaults.
Reference: [3] <author> Brewka, Gerhard, </author> <title> Assertional Default Theories, </title> <booktitle> Proc. </booktitle> <address> ECSQAU, Marseille 91, </address> <publisher> Springer Verlag, </publisher> <year> 1991 </year>
Reference: [4] <author> Brewka, Gerhard; Makinson, David; Schlechta, Karl, </author> <title> Cumulative Inference Relations for JTMS and Logic Programming, </title> <booktitle> Proc. First International Workshop on Logic Programming and Non-Monotonic Reasoning, </booktitle> <address> Washington, </address> <year> 1991, </year> <note> full version to appear in Proc. </note> <editor> NIL-90, </editor> <booktitle> Workshop on Nonmonotonic and Inductive Logics, </booktitle> <address> Karlsruhe 1990, </address> <year> 1991 </year>
Reference-contexts: A further advantage of the logic is that it allows for a syntactic distinction between hard facts and weak conclusions. An Etherington-style semantics for CDL has been presented in [16]. The ideas underlying CDL have been applied in <ref> [4] </ref> to define a cumulative inference relation for TMS and logic programs. Unfortunately CDL's solution to problems 2) and 4) introduces a new problem [4]: the floating conclusions problem. Floating conclusions are conclusions that appear in every extension, but with different supports. <p> An Etherington-style semantics for CDL has been presented in [16]. The ideas underlying CDL have been applied in <ref> [4] </ref> to define a cumulative inference relation for TMS and logic programs. Unfortunately CDL's solution to problems 2) and 4) introduces a new problem [4]: the floating conclusions problem. Floating conclusions are conclusions that appear in every extension, but with different supports. <p> Application of R4 leads to the derivation of runs=runs in the closure. This default is also contained in the single extension, that is runs is derivable since it is consistent with what is derivable. Example 4: Floating conclusions <ref> [4] </ref> 1) :a=b 3) a ! c We can apply R3 to 1) and 4) to obtain (after equivalence transformations using R4) 5) :a=c Similarly, we apply R3 to 2) and 3) to obtain 6) :b=c From 5) and 6) we derive using R5 7) (:a _ :b)=c We obtain two
Reference: [5] <author> Delgrande, J.P., Jackson, </author> <title> W.K., Default Logic Revisited, </title> <booktitle> Proc. Second International Conference on Principles of Knowledge Representation and Reasoning, </booktitle> <year> 1991 </year>
Reference-contexts: Unfortunately, Reiter's logic also has its drawbacks, as has been discussed in various papers, e.g. <ref> [13, 9, 2, 5] </ref>: 1. Existence of extensions is not guaranteed. 2. The consistency conditions (justifications) of defaults applied within one Reiter extension are not jointly consistent with the generated extension. Reiter's fixed point definition only guarantees that each consistency condition in isolation is consistent with the extension. <p> The modification will, among other things, concern the treatment of implicit priorities in defaults. 2 2 In a recent paper, Delgrande and Jackson address the problem of reasoning by cases in DL and claim to have solved it in a modified version of DL called PJ-logic <ref> [5] </ref>. Their solution is unsatisfactory for the following reasons: they use prerequisite-free defaults and represent a default "A's are typically B" for which contraposition is unwanted as true: B (x)=A (x) B (x).
Reference: [6] <author> Gelfond, M., Lifschitz, V., Przymusinska, H.,Truszczynski, M., </author> <title> Disjunctive Defaults, </title> <booktitle> Proc. Second International Conference on Principles of Knowledge Representation and Reasoning, </booktitle> <year> 1991 </year>
Reference-contexts: In L3 reasoning by cases in an unrestricted form is possible. Many ideas underlying this approach are not entirely new, and the presented work has benefitted from various sources. Gelfond and colleagues <ref> [6] </ref>, for instance, have considered facts as special kinds of defaults in their variant of DL. They have not considered using inference rules on defaults, however. There is also a close relationship between our framework and earlier work in the area of belief revision, in particular [10].
Reference: [7] <author> Kraus, S., Lehmann, D., Magidor, M., </author> <title> Nonmonotonic Reasoning, Preferential Models and Cumulative Logics, </title> <journal> Artificial Intelligence, </journal> <year> 1990 </year>
Reference-contexts: These authors, however, focus on monotonic dependencies, whereas we take nonmonotonic dependencies into account. Another related area is the work on conditional approaches to nonmonotonic reasoning, in particular the work of Kraus, Lehmann and Magidor <ref> [7] </ref> [8]. Here inference rules on conditionals are used to formalize cumulative inference relations. Using defaults instead of conditionals gives us an additional "degree of freedom" in the definition of default logics. This makes it, for instance, possible to model Reiter-like default logics without giving up cumulativity.
Reference: [8] <author> Lehmann, D., </author> <title> What Does a Conditional Knowledge Base Entail?, </title> <booktitle> Proc. First International Conference on Principles of Knowledge Representation and Reasoning, </booktitle> <year> 1990 </year> <month> 22 </month>
Reference-contexts: These authors, however, focus on monotonic dependencies, whereas we take nonmonotonic dependencies into account. Another related area is the work on conditional approaches to nonmonotonic reasoning, in particular the work of Kraus, Lehmann and Magidor [7] <ref> [8] </ref>. Here inference rules on conditionals are used to formalize cumulative inference relations. Using defaults instead of conditionals gives us an additional "degree of freedom" in the definition of default logics. This makes it, for instance, possible to model Reiter-like default logics without giving up cumulativity.
Reference: [9] <author> Makinson, David, </author> <title> General Theory of Cumulative Inference, </title> <booktitle> Proceedings 2nd International Workshop on Non-Monotonic Reasoning, </booktitle> <address> Grassau, Germany, </address> <publisher> Springer, </publisher> <address> LNAI 346 (1989) 1-18. </address>
Reference-contexts: Unfortunately, Reiter's logic also has its drawbacks, as has been discussed in various papers, e.g. <ref> [13, 9, 2, 5] </ref>: 1. Existence of extensions is not guaranteed. 2. The consistency conditions (justifications) of defaults applied within one Reiter extension are not jointly consistent with the generated extension. Reiter's fixed point definition only guarantees that each consistency condition in isolation is consistent with the extension. <p> In DL, however, a default can only be applied if its prerequisite has already been derived. 4. DL's skeptical inference relation is not cumulative <ref> [9] </ref>, that is the addition of formulas contained in all extensions of a default theory (D; W ) to W may change the set of generated extensions and hence the skeptically derivable formulas. <p> L DL , by keeping track of consistency assumptions in the justifications of derived defaults, marks this distinction and thus can satisfy cumulativity. Consider the reformulation of Makinson's original example showing the failure of cumulativity for DL <ref> [9] </ref>: ftrue: p=p; p _ q: :p=:pg The closure contains true:p=p _ q (application of DL 1 to the first default). This default is also contained in the single L DL extension, i.e. we derive: p _ q since p is consistent.
Reference: [10] <author> Martins, Joao; Shapiro, Stuart C., </author> <title> A Model for Belief Revision, </title> <booktitle> Artificial Intelligence 35, </booktitle> <year> 1988 </year>
Reference-contexts: Gelfond and colleagues [6], for instance, have considered facts as special kinds of defaults in their variant of DL. They have not considered using inference rules on defaults, however. There is also a close relationship between our framework and earlier work in the area of belief revision, in particular <ref> [10] </ref>. These authors, however, focus on monotonic dependencies, whereas we take nonmonotonic dependencies into account. Another related area is the work on conditional approaches to nonmonotonic reasoning, in particular the work of Kraus, Lehmann and Magidor [7] [8]. Here inference rules on conditionals are used to formalize cumulative inference relations.
Reference: [11] <author> Nait Abdallah, Areski, </author> <title> Syntax and Semantics of a Monotonic Framework for Non-monotonic Reasoning, </title> <institution> Univ. of Western Ontario, London, Ontario, Dep. of Comp. Science, </institution> <type> Report Nr. 293, </type> <year> 1991 </year>
Reference-contexts: This makes it, for instance, possible to model Reiter-like default logics without giving up cumulativity. The presented work is probably closest in some of its basic intuitions to Nait Abdallah's ionic logic <ref> [11] </ref>. This logic is based on so-called ions, that is structures of the form (X; p) fl which directly correspond to our assumables. Ionic logic allows for arbitrary nesting of ions and is more general than our approach in this respect. The rules presented in [11] have some similarity to our <p> to Nait Abdallah's ionic logic <ref> [11] </ref>. This logic is based on so-called ions, that is structures of the form (X; p) fl which directly correspond to our assumables. Ionic logic allows for arbitrary nesting of ions and is more general than our approach in this respect. The rules presented in [11] have some similarity to our L1 rules, and the theorems of ionic logic roughly correspond to our potential belief set. However, Nait Abdallah abandons nonmonotonicity and thus seems to throw out the baby with the bath 21 water.
Reference: [12] <author> Poole, David, </author> <title> A Logical Framework for Default Reasoning, </title> <booktitle> Artificial Intelligence 36 (1988) 27-47. </booktitle>
Reference-contexts: Every extension then has to be consistent with J ust (S) [ Cons (S). This can, for instance, be used to model Poole-systems with constraints <ref> [12] </ref> or CDL [2] in our framework. Another idea would be to use explicit priority orderings of defaults instead of the implicit orderings induced by semi-normal defaults.
Reference: [13] <author> Poole, David, </author> <title> What the Lottery Paradox Tells Us About Default Reasoning, </title> <booktitle> Proceedings First International Conference on Principles of Knowledge Representation and Reasoning, </booktitle> <address> Toronto (1989) 333-340. </address>
Reference-contexts: Unfortunately, Reiter's logic also has its drawbacks, as has been discussed in various papers, e.g. <ref> [13, 9, 2, 5] </ref>: 1. Existence of extensions is not guaranteed. 2. The consistency conditions (justifications) of defaults applied within one Reiter extension are not jointly consistent with the generated extension. Reiter's fixed point definition only guarantees that each consistency condition in isolation is consistent with the extension. <p> The consistency conditions (justifications) of defaults applied within one Reiter extension are not jointly consistent with the generated extension. Reiter's fixed point definition only guarantees that each consistency condition in isolation is consistent with the extension. This leads to counterintuitive conclusions as discussed in <ref> [13] </ref>. 3. The use of inference rules as defaults makes it impossible to reason by cases in DL. <p> If instead of 4a we add 4b) P eng (T w): :F lies (T w)=:F lies (T w) we get two extensions, one containing F lies (T w)=F lies (T w); the other one :F lies (T w)=:F lies (T w): The next example has been used in <ref> [13] </ref> to illustrate DL's problems with mutually inconsistent justifications of defaults. Example 2: Broken arms 11 1) usable (x) ^ :broken (x)=usable (x) 2) broken (lef t) _ broken (right) We obtain two extensions. <p> The second extension contains usable (right) ^ :broken (right)=usable (right) Contrary to DL, L1 produces no extension in which both arms are usable. The next example is also taken from <ref> [13] </ref>. It shows that a limited form of reasoning by cases is possible in L1: Example 3: Reasoning by cases 1) emu:runs=runs 2) ostrich: runs=runs 3) emu _ ostrich We apply R6 to 1) and 2), and R3 to the result and 3).
Reference: [14] <author> Reiter, Raymond, </author> <title> A Logic for Default Reasoning, </title> <booktitle> Artificial Intelligence 13 (1980) 81-132. </booktitle>
Reference-contexts: 1 Background and Motivation Reiter's Default Logic DL <ref> [14] </ref> is currently one of the most popular and most widely used formalizations of default reasoning. There are at least two reasons for this popularity. <p> According to <ref> [14, Theorem 2.1] </ref> F is an extension of (D; W ) iff F = i=0 F i where F 0 = W where DF (F i ; D) = fs j p: q 1 ; : : : ; q n =s 2 D; p 2 F i ; :q i
Reference: [15] <author> Reiter, Raymond, Criscuolo, G., </author> <title> On Interacting Defaults, </title> <booktitle> Proc. IJCAI 81, </booktitle> <year> 1981 </year>
Reference-contexts: In our example we get two extensions, that is 2) may be preferred to 1). The reason is that in L1 not only consequents, but also justifications have the power to block conflicting defaults. As shown by Reiter and Criscuolo <ref> [15] </ref> it is sometimes useful to keep the ability of expressing default priorities via semi-normal defaults. We will therefore define a logic L2 in which such priorities are preserved. L2 will be based on a new definition of extensions. <p> The exclusion of 2) is sanctioned since the second alternative in Definition 13 applies. The second L1 extension is an L2 extension for symmetrical reasons. Unfortunately, the (re)introduction of implicit priorities destroys, like in DL, the existence of extensions for semi-normal theories. The following example was originally used in <ref> [15] </ref> to show non-existence of extensions for semi-normal DL theories and can be used to illustrate this: 1) true::a ^ b=b 2) true::b ^ c=c 3) true::c ^ a=a In L1 three extensions are obtained, each of which is generated by one of the premises.
Reference: [16] <author> Schaub, Torsten, </author> <title> Assertional Default Theories: A Semantical View, </title> <booktitle> Proc. Second International Conference on Principles of Knowledge Representation and Reasoning (KR-2), </booktitle> <year> 1991 </year> <month> 23 </month>
Reference-contexts: A further advantage of the logic is that it allows for a syntactic distinction between hard facts and weak conclusions. An Etherington-style semantics for CDL has been presented in <ref> [16] </ref>. The ideas underlying CDL have been applied in [4] to define a cumulative inference relation for TMS and logic programs. Unfortunately CDL's solution to problems 2) and 4) introduces a new problem [4]: the floating conclusions problem.
References-found: 16

