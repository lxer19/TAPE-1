URL: file://ftp.irisa.fr/local/lande/pfdlm-popl97.ps.gz
Refering-URL: http://www.irisa.fr/lande/LeMetayer.html
Root-URL: http://www.aic.nrl.navy.mil/~aha/people.html
Email: [fradet,lemetayer]@irisa.fr  
Title: Shape Types  
Author: Pascal Fradet and Daniel Le Metayer Irisa/Inria 
Address: 35042 Rennes, France  
Affiliation: Campus de Beaulieu,  
Abstract: Type systems currently available for imperative languages are too weak to detect a significant class of programming errors. For example, they cannot express the property that a list is doubly-linked or circular. We propose a solution to this problem based on a notion of shape types defined as context-free graph grammars. We define graphs in set-theoretic terms, and graph modifications as multiset rewrite rules. These rules can be checked statically to ensure that they preserve the structure of the graph specified by the grammar. We provide a syntax for a smooth integration of shape types in C. The programmer can still express pointer manipulations with the expected constant time execution and benefits from the additional guarantee that the property specified by the shape type is an invariant of the program. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> L. Andersen, </author> <title> Program analysis and specialization for the C programming language, </title> <type> Ph.D Thesis, </type> <institution> DIKU, University of Copenhagen, </institution> <month> May </month> <year> 1994. </year>
Reference: [2] <author> J.-P. Ban^atre and D. Le Metayer, </author> <title> Programming by multiset transformation, </title> <journal> Communications of the ACM, </journal> <volume> Vol. </volume> <pages> 36-1, pp. 98-111, </pages> <month> January </month> <year> 1993. </year>
Reference-contexts: The expressive power of this new formalism and the context-free graph grammars are incomparable. 3 Shapes Our notion of shape is inspired by previous work on the chemical reaction model <ref> [2, 8] </ref> and set-theoretic graph rewriting [19]. Formally, a graph is defined as a multiset of relation tuples noted R a 1 : : : a n where R is a n-ary relation name and a i 2 V with V a countable set of variables.
Reference: [3] <author> D. Chase, M. Wegman and F. Zadeck, </author> <title> Analysis of pointers and structures, </title> <booktitle> in Proc. ACM Conf. on Programming Language Design and Implementation, Vol. 25(6) of SIGPLAN Notices, </booktitle> <pages> pp. 296-310, </pages> <year> 1990. </year>
Reference-contexts: An analyzer automatically infers properties about shapes at all program points. Most storage analyses and alias analyses belong to this class <ref> [3, 7, 9, 10, 14, 17, 21] </ref>. These analyses are based on various models of "shapes" (k-limited graphs, regular tree grammars, access path matrices, points-to relationships, . . . ).
Reference: [4] <author> T. H. Cormen, C. E. Leiserson and R. L. Rivest, </author> <title> Introduction to algorithms, </title> <publisher> MIT Press, </publisher> <year> 1990. </year>
Reference-contexts: This property is expressed in the shape. The left-child, right-sibling trees (Lcrs-trees) are binary trees used to represent trees with unbounded branching <ref> [4] </ref>. Note, that each node has a parent pointer and a pointer (leftc) to its leftmost child and a pointer (rights) to its sibling immediately to the right. The grammars can be intuitively explained by attaching a meaning to each nonterminal. <p> We should stress that, due to their precise characterization of data structures, shape types should be a very useful facility for the construction of safe programs. Most efficient versions of algorithms are based on complex data structures which must be maintained throughout the execution of the program <ref> [4] </ref> [22]. Ensuring the invariance of their representation is an error-prone activity. Shape types can be used to describe these invariants in a natural way (see Figure 1 for instance) and have them automatically verified.
Reference: [5] <author> B. Courcelle, </author> <title> Graph rewriting: an algebraic and logic approach, </title> <booktitle> Handbook of Theoretical Computer Science, Chapter 5, </booktitle> <editor> J. van Leeuwen (ed.), </editor> <publisher> Elsevier Science Publishers, </publisher> <year> 1990. </year>
Reference-contexts: We specify such a class as a context-free graph grammar and we call it a shape. Different notions of context-free graph grammars have been studied in the literature. They are defined either in terms of node replacement [6] or in terms of hyper-edge replacement <ref> [5] </ref>. Our definition of graphs as multisets allows us to express hyper-edge replacement in a very natural 2 way.
Reference: [6] <author> P. Della Vigna and C. Ghezzi, </author> <title> Context-free graph grammars, </title> <journal> Information and Control, </journal> <volume> Vol. 37, </volume> <pages> pp. 207-233, </pages> <year> 1978. </year>
Reference-contexts: We specify such a class as a context-free graph grammar and we call it a shape. Different notions of context-free graph grammars have been studied in the literature. They are defined either in terms of node replacement <ref> [6] </ref> or in terms of hyper-edge replacement [5]. Our definition of graphs as multisets allows us to express hyper-edge replacement in a very natural 2 way.
Reference: [7] <author> A. Deutsch, </author> <title> Semantic models and abstract interpretation techniques for inductive data structures and pointers, </title> <booktitle> in Proc. ACM SIGPLAN Symposium on Partial Evaluation and Semantics-Based Program Manipulation PEPM'95, </booktitle> <pages> pp. 226-229, </pages> <year> 1995. </year>
Reference-contexts: An analyzer automatically infers properties about shapes at all program points. Most storage analyses and alias analyses belong to this class <ref> [3, 7, 9, 10, 14, 17, 21] </ref>. These analyses are based on various models of "shapes" (k-limited graphs, regular tree grammars, access path matrices, points-to relationships, . . . ). <p> These analyses are based on various models of "shapes" (k-limited graphs, regular tree grammars, access path matrices, points-to relationships, . . . ). A short survey of this trend of work can be found in <ref> [7] </ref>. * In the "programming language" approach, the programmer can specify the properties of shapes; these properties can then be checked, either statically or dynamically, and used by an optimizing compiler. This approach has been less popular until recently. It involves programming language extensions to describe properties of shapes.
Reference: [8] <author> P. Fradet and D. Le Metayer, </author> <title> Structured Gamma, </title> <institution> Irisa Research Report PI-989, </institution> <month> March </month> <year> 1996. </year>
Reference-contexts: The expressive power of this new formalism and the context-free graph grammars are incomparable. 3 Shapes Our notion of shape is inspired by previous work on the chemical reaction model <ref> [2, 8] </ref> and set-theoretic graph rewriting [19]. Formally, a graph is defined as a multiset of relation tuples noted R a 1 : : : a n where R is a n-ary relation name and a i 2 V with V a countable set of variables.
Reference: [9] <author> P. Fradet, R. Gaugne and D. Le Metayer, </author> <title> Detection of pointer errors: an axiomatisation and a checking algorithm, </title> <booktitle> Proc. European Symposium on Programming, </booktitle> <publisher> Springer Verlag, LNCS 1058, </publisher> <pages> pp. 125-140, </pages> <year> 1996. </year>
Reference-contexts: An analyzer automatically infers properties about shapes at all program points. Most storage analyses and alias analyses belong to this class <ref> [3, 7, 9, 10, 14, 17, 21] </ref>. These analyses are based on various models of "shapes" (k-limited graphs, regular tree grammars, access path matrices, points-to relationships, . . . ).
Reference: [10] <author> R. Ghiya and L. J. Hendren, </author> <title> Is it a tree, a dag, or a cyclic graph? A shape analysis for heap-directed pointers in C, </title> <booktitle> in Proc. ACM Principles of Programming Languages, </booktitle> <pages> pp. 1-15, </pages> <year> 1996. </year> <month> 9 </month>
Reference-contexts: An analyzer automatically infers properties about shapes at all program points. Most storage analyses and alias analyses belong to this class <ref> [3, 7, 9, 10, 14, 17, 21] </ref>. These analyses are based on various models of "shapes" (k-limited graphs, regular tree grammars, access path matrices, points-to relationships, . . . ).
Reference: [11] <author> J. Grosch, </author> <title> Tool support for data structures, </title> <journal> Structured Programming, </journal> <volume> Vol. 12, </volume> <pages> pp. 31-38, </pages> <year> 1991. </year>
Reference-contexts: A quite different formalism is proposed in [20] to specify checkable interfaces as constraints on scalars, sets and multisets. Graph-like data structures are also supported by <ref> [11] </ref>, but the formalism used is akin to more traditional tree grammars. It should be clear that both approaches are in fact complementary since the shape information provided by language extensions can be used to increase the accurateness of automatic alias analyses [13] (or to make them more efficient).
Reference: [12] <author> L. J. Hendren, J. Hummel and A. Nicolau, </author> <title> Abstractions for recursive pointer data structures: improving the analysis and transformation of imperative programs, </title> <booktitle> in Proc. ACM Conf. on Programming Language Design and Implementation, </booktitle> <pages> pp. 249-260, </pages> <year> 1992. </year>
Reference-contexts: This approach has been less popular until recently. It involves programming language extensions to describe properties of shapes. These extensions are usually based on traditional (tree-like) recursive data structures enhanced with properties on pointers. ADDS <ref> [12, 13] </ref> associates directions (forward, backward) with pointers, making it possible to distinguish, for instance, trees and doubly-linked lists. Graph types [15] are spanning trees augmented with extra links defined using regular routing expressions.
Reference: [13] <author> J. Hummel, L. J. Hendren and A. Nicolau, </author> <title> Abstract description of pointer data structures: an approach for improving the analysis and optimisation of imperative programs, </title> <journal> ACM Letters on Programming Languages and Systems, </journal> <volume> Vol. 1, No 3, </volume> <pages> pp. 243-260, </pages> <month> September </month> <year> 1992. </year>
Reference-contexts: This approach has been less popular until recently. It involves programming language extensions to describe properties of shapes. These extensions are usually based on traditional (tree-like) recursive data structures enhanced with properties on pointers. ADDS <ref> [12, 13] </ref> associates directions (forward, backward) with pointers, making it possible to distinguish, for instance, trees and doubly-linked lists. Graph types [15] are spanning trees augmented with extra links defined using regular routing expressions. <p> Graph-like data structures are also supported by [11], but the formalism used is akin to more traditional tree grammars. It should be clear that both approaches are in fact complementary since the shape information provided by language extensions can be used to increase the accurateness of automatic alias analyses <ref> [13] </ref> (or to make them more efficient). The work described in this paper falls into the second category. We believe that the programming language approach is worthwhile because it makes it possible to get accurate information about the shape of the store at a reasonable cost. <p> The main difference between this work and ADDS is that we specify the links in a shape very precisely (a data structure conforming to a shape must include exactly the links specified by the shape, and no more) whereas the forward and backward attributes of <ref> [13] </ref> characterize the authorized links in a less constrained way. This difference reflects the intended application of the description, which is mainly program optimization in [13], whereas our work on shape types is first directed towards a more robust style of programming through type checking. <p> data structure conforming to a shape must include exactly the links specified by the shape, and no more) whereas the forward and backward attributes of <ref> [13] </ref> characterize the authorized links in a less constrained way. This difference reflects the intended application of the description, which is mainly program optimization in [13], whereas our work on shape types is first directed towards a more robust style of programming through type checking. The graph types introduced in [15] are defined as traditional recursive data types enhanced with a notation for expressing the sharing between subterms through auxiliary pointers.
Reference: [14] <author> N. Jones and S. Muchnick, </author> <title> Flow analysis and optimization of Lisp-like structures, in Program Flow Analysis: Theory and Applications, </title> <address> New Jersey 1981, </address> <publisher> Prentice-Hall, </publisher> <pages> pp. 102-131. </pages>
Reference-contexts: An analyzer automatically infers properties about shapes at all program points. Most storage analyses and alias analyses belong to this class <ref> [3, 7, 9, 10, 14, 17, 21] </ref>. These analyses are based on various models of "shapes" (k-limited graphs, regular tree grammars, access path matrices, points-to relationships, . . . ).
Reference: [15] <author> N. Klarlund and M. Schwartzbach, </author> <title> Graph types, </title> <booktitle> Proc. ACM Principles of Programming Languages, </booktitle> <pages> pp. 196-205, </pages> <year> 1993. </year>
Reference-contexts: The contributions can be classified in two categories, 1 We use the expression "shape types" for the notion of types introduced here, keeping the denomination "graph types" to refer to <ref> [15] </ref> depending on the level of cooperation required from the pro- grammer: * In the "fully automatic approach", no help is expected from the programmer. An analyzer automatically infers properties about shapes at all program points. <p> It involves programming language extensions to describe properties of shapes. These extensions are usually based on traditional (tree-like) recursive data structures enhanced with properties on pointers. ADDS [12, 13] associates directions (forward, backward) with pointers, making it possible to distinguish, for instance, trees and doubly-linked lists. Graph types <ref> [15] </ref> are spanning trees augmented with extra links defined using regular routing expressions. The class of graphs considered in [16] is also based on spanning trees, but auxiliary edges are specified by constraints in monadic second-order logic. <p> This difference reflects the intended application of the description, which is mainly program optimization in [13], whereas our work on shape types is first directed towards a more robust style of programming through type checking. The graph types introduced in <ref> [15] </ref> are defined as traditional recursive data types enhanced with a notation for expressing the sharing between subterms through auxiliary pointers. <p> For example, it does not seem natural to distinguish one particular pointer in a circular list, neither from the perspective of program reasoning nor from the implementation point of view. Shapes are also more expressive because the extra edges of <ref> [15] </ref> depend functionally on the backbone, which makes it impossible, for instance, to specify a list with an extra link from the head to a random element.
Reference: [16] <author> N. Klarlund and M. Schwartzbach, </author> <title> Graphs and decidable transductions based on edge constraints, </title> <booktitle> in Proc. Trees in Algebra and Programming - CAAP'94, </booktitle> <publisher> Springer Verlag, LNCS 787, </publisher> <pages> pp. 187-201, </pages> <year> 1994. </year>
Reference-contexts: ADDS [12, 13] associates directions (forward, backward) with pointers, making it possible to distinguish, for instance, trees and doubly-linked lists. Graph types [15] are spanning trees augmented with extra links defined using regular routing expressions. The class of graphs considered in <ref> [16] </ref> is also based on spanning trees, but auxiliary edges are specified by constraints in monadic second-order logic. A quite different formalism is proposed in [20] to specify checkable interfaces as constraints on scalars, sets and multisets. <p> Shapes are also more expressive because the extra edges of [15] depend functionally on the backbone, which makes it impossible, for instance, to specify a list with an extra link from the head to a random element. This limitation is lifted in <ref> [16] </ref> which proposes a more general way of specifying classes of graphs as spanning forests enhanced with auxiliary edge constraints expressed in monadic second-order logic.
Reference: [17] <author> W. Landi and B. Ryder, </author> <title> Pointer induced aliasing, a problem classification, </title> <booktitle> Proc. ACM Principles of Programming Languages, </booktitle> <pages> pp. 93-103, </pages> <year> 1991. </year>
Reference-contexts: An analyzer automatically infers properties about shapes at all program points. Most storage analyses and alias analyses belong to this class <ref> [3, 7, 9, 10, 14, 17, 21] </ref>. These analyses are based on various models of "shapes" (k-limited graphs, regular tree grammars, access path matrices, points-to relationships, . . . ).
Reference: [18] <author> W. Pugh, </author> <title> Skip lists: a probabilistic alternative to balanced trees, </title> <journal> Communications of the ACM, </journal> <volume> Vol. </volume> <pages> 33-6, pp. 668-676, </pages> <month> June </month> <year> 1990. </year>
Reference-contexts: In order to enhance the intuition about shapes, Figure 1 gathers a few examples illustrating their use to describe pointer structures. Skip lists are used as an alternative to balanced trees for more efficient data insertions and deletions <ref> [18] </ref>. Red-black trees are binary search trees whose links are either "black" or "red" [22]. A property of red-black trees is that there are never two successive red links along a path from the root to a leaf (red links are represented as dotted lines in the figure).
Reference: [19] <author> J.-C. Raoult and F. Voisin, </author> <title> Set-theoretic graph rewriting, </title> <booktitle> Proc. int. Workshop on Graph Transformations in Computer Science, </booktitle> <publisher> Springer Verlag, LNCS 776, </publisher> <pages> pp. 312-325, </pages> <year> 1993. </year>
Reference-contexts: The expressive power of this new formalism and the context-free graph grammars are incomparable. 3 Shapes Our notion of shape is inspired by previous work on the chemical reaction model [2, 8] and set-theoretic graph rewriting <ref> [19] </ref>. Formally, a graph is defined as a multiset of relation tuples noted R a 1 : : : a n where R is a n-ary relation name and a i 2 V with V a countable set of variables. <p> The last condition in Definition 1 ensures that new variables occurring on the right-hand side of a rule of the grammar are instantiated with variables which are distinct from all other existing variables. This constraint, which is usual in graph rewriting <ref> [19] </ref>, is necessary to avoid unexpected variable sharing.
Reference: [20] <author> J. R. Russel, R. E. Storm and D. M. Yellin, </author> <title> A checkable interface language for pointer-based structures, </title> <booktitle> Proc. Workshop on Interface Declaration Languages, ACM Sigplan Notices, </booktitle> <volume> Vol. 29, No. 8, </volume> <month> August </month> <year> 1994. </year>
Reference-contexts: Graph types [15] are spanning trees augmented with extra links defined using regular routing expressions. The class of graphs considered in [16] is also based on spanning trees, but auxiliary edges are specified by constraints in monadic second-order logic. A quite different formalism is proposed in <ref> [20] </ref> to specify checkable interfaces as constraints on scalars, sets and multisets. Graph-like data structures are also supported by [11], but the formalism used is akin to more traditional tree grammars.
Reference: [21] <author> M. Sagiv, T. Reps and R. Wilhelm, </author> <title> Solving shape-analysis problems in languages with destructive updating, </title> <booktitle> Proc. ACM Principles of Programming Languages, </booktitle> <pages> pp. 16-31, </pages> <year> 1996. </year>
Reference-contexts: An analyzer automatically infers properties about shapes at all program points. Most storage analyses and alias analyses belong to this class <ref> [3, 7, 9, 10, 14, 17, 21] </ref>. These analyses are based on various models of "shapes" (k-limited graphs, regular tree grammars, access path matrices, points-to relationships, . . . ).
Reference: [22] <author> R. Sedgewick, </author> <title> Algorithms in C, </title> <publisher> Addison-Wesley publishing company, </publisher> <year> 1990. </year>
Reference-contexts: Skip lists are used as an alternative to balanced trees for more efficient data insertions and deletions [18]. Red-black trees are binary search trees whose links are either "black" or "red" <ref> [22] </ref>. A property of red-black trees is that there are never two successive red links along a path from the root to a leaf (red links are represented as dotted lines in the figure). This property is expressed in the shape. <p> We should stress that, due to their precise characterization of data structures, shape types should be a very useful facility for the construction of safe programs. Most efficient versions of algorithms are based on complex data structures which must be maintained throughout the execution of the program [4] <ref> [22] </ref>. Ensuring the invariance of their representation is an error-prone activity. Shape types can be used to describe these invariants in a natural way (see Figure 1 for instance) and have them automatically verified.
Reference: [23] <author> J. H. Siekmann, </author> <title> Unification theory, </title> <booktitle> Advances in Artificial Intelligence, II, </booktitle> <publisher> Elsevier Science Publishers, </publisher> <pages> pp. 365-400, </pages> <year> 1987. </year>
References-found: 23

