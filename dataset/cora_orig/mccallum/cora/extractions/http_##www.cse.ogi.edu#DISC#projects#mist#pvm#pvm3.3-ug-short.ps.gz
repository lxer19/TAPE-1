URL: http://www.cse.ogi.edu/DISC/projects/mist/pvm/pvm3.3-ug-short.ps.gz
Refering-URL: http://www.cse.ogi.edu/DISC/projects/mist/pvm/ug.html
Root-URL: http://www.cse.ogi.edu
Email: pvm@msr.epm.ornl.gov  
Title: PVM 3 USER'S GUIDE AND REFERENCE MANUAL  
Author: Al Geist Adam Beguelin Jack Dongarra flflfl Weicheng Jiang flfl Robert Manchek flfl Vaidy Sunderam 
Date: May, 1994  
Note: Date Published:  Research was supported by the Applied Mathematical Sciences Research Program of the Office of Energy Research, U.S. Department of Energy, the National Science Foundation, and the State of Tennessee. Prepared by the  operated by Martin Marietta Energy Systems, Inc. for the U.S. DEPARTMENT OF ENERGY under Contract No. DE-AC05-84OR21400  
Address: Oak Ridge, TN 37831-6367  Knoxville, TN 37996-1301  Pittsburgh, PA 15213-3890  Atlanta, GA 30322  Oak Ridge, Tennessee 37831  
Affiliation: Engineering Physics and Mathematics Division Mathematical Sciences Section  Oak Ridge National Laboratory  flfl University of Tennessee  Carnegie Mellon University and Pittsburgh Supercomputing Center  Emory University  Oak Ridge National Laboratory  
Pubnum: ORNL/TM-12187  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> Beguelin, Dongarra, Geist, Manchek, </author> <title> Sunderam A User's Guide to PVM (Parallel Virtual Machine) ORNL/TM-11826, </title> <month> July </month> <year> 1991. </year>
Reference-contexts: This library contains user callable routines for message passing, spawning processes, coordinating tasks, and modifying the virtual machine. Application programs must be linked with this library to use PVM. 2. Features in PVM 3 PVM version 3 has many improvements over version 2 <ref> [1] </ref>. The following sections describe the features that are available in PVM 3. 2.1. Updated User interface There are name conflicts between PVM 2.x routines and some multiprocessor libraries supplied by computer vendors. <p> This creates an interface for advanced batch schedulers (examples include Condor [2], DQS <ref> [1] </ref>, and LSF [4]) to plug into PVM and run PVM jobs in batch mode. These register routines also allow debugger writers to plug into PVM and create sophisticated debuggers for PVM. 2.4. <p> tids [0] = pvm_parent (); /* FIND OUT IF I AM PARENT OR CHILD */ if ( tids [0] &lt; 0 )- /* THEN I AM THE PARENT */ tids [0] = mytid; me = 0; /* START UP COPIES OF MYSELF */ pvm_spawn ("spmd", (char**)0, 0, "", NPROC-1, &tids <ref> [1] </ref>); pvm_initsend ( PvmDataDefault ); /* SEND TIDS ARRAY */ pvm_pkint (tids, NPROC, 1); /* TO CHILDREN */ pvm_mcast (&tids [1], NPROC-1, 0); - else/* I AM A CHILD */ pvm_recv (tids [0], 0); /* RECEIVE TIDS ARRAY */ pvm_upkint (tids, NPROC, 1); for ( i=1; i&lt;NPROC ; i++ ) if <p> 0 )- /* THEN I AM THE PARENT */ tids [0] = mytid; me = 0; /* START UP COPIES OF MYSELF */ pvm_spawn ("spmd", (char**)0, 0, "", NPROC-1, &tids <ref> [1] </ref>); pvm_initsend ( PvmDataDefault ); /* SEND TIDS ARRAY */ pvm_pkint (tids, NPROC, 1); /* TO CHILDREN */ pvm_mcast (&tids [1], NPROC-1, 0); - else/* I AM A CHILD */ pvm_recv (tids [0], 0); /* RECEIVE TIDS ARRAY */ pvm_upkint (tids, NPROC, 1); for ( i=1; i&lt;NPROC ; i++ ) if ( mytid == tids [i] )- me = i; break; - - /* All NPROC tasks are equal now *
Reference: [1] <author> T. Green, J. </author> <booktitle> Pasko DQS 2.x/3.0 Proceedings of Cluster Workshop '93 at SCRI Florida State University. </booktitle> <month> Dec. </month> <year> 1993. </year>
Reference-contexts: This library contains user callable routines for message passing, spawning processes, coordinating tasks, and modifying the virtual machine. Application programs must be linked with this library to use PVM. 2. Features in PVM 3 PVM version 3 has many improvements over version 2 <ref> [1] </ref>. The following sections describe the features that are available in PVM 3. 2.1. Updated User interface There are name conflicts between PVM 2.x routines and some multiprocessor libraries supplied by computer vendors. <p> This creates an interface for advanced batch schedulers (examples include Condor [2], DQS <ref> [1] </ref>, and LSF [4]) to plug into PVM and run PVM jobs in batch mode. These register routines also allow debugger writers to plug into PVM and create sophisticated debuggers for PVM. 2.4. <p> tids [0] = pvm_parent (); /* FIND OUT IF I AM PARENT OR CHILD */ if ( tids [0] &lt; 0 )- /* THEN I AM THE PARENT */ tids [0] = mytid; me = 0; /* START UP COPIES OF MYSELF */ pvm_spawn ("spmd", (char**)0, 0, "", NPROC-1, &tids <ref> [1] </ref>); pvm_initsend ( PvmDataDefault ); /* SEND TIDS ARRAY */ pvm_pkint (tids, NPROC, 1); /* TO CHILDREN */ pvm_mcast (&tids [1], NPROC-1, 0); - else/* I AM A CHILD */ pvm_recv (tids [0], 0); /* RECEIVE TIDS ARRAY */ pvm_upkint (tids, NPROC, 1); for ( i=1; i&lt;NPROC ; i++ ) if <p> 0 )- /* THEN I AM THE PARENT */ tids [0] = mytid; me = 0; /* START UP COPIES OF MYSELF */ pvm_spawn ("spmd", (char**)0, 0, "", NPROC-1, &tids <ref> [1] </ref>); pvm_initsend ( PvmDataDefault ); /* SEND TIDS ARRAY */ pvm_pkint (tids, NPROC, 1); /* TO CHILDREN */ pvm_mcast (&tids [1], NPROC-1, 0); - else/* I AM A CHILD */ pvm_recv (tids [0], 0); /* RECEIVE TIDS ARRAY */ pvm_upkint (tids, NPROC, 1); for ( i=1; i&lt;NPROC ; i++ ) if ( mytid == tids [i] )- me = i; break; - - /* All NPROC tasks are equal now *
Reference: [2] <author> M. Litzkow, M. Livny, and M. </author> <title> Mutka. Condor | A hunder of idle workstations. </title> <booktitle> In Proceedings of the Eighth Conference on Distributed Computing Systems, </booktitle> <address> San Jose, California, </address> <month> June </month> <year> 1988. </year> <month> - 72 </month> - 
Reference-contexts: This creates an interface for advanced batch schedulers (examples include Condor <ref> [2] </ref>, DQS [1], and LSF [4]) to plug into PVM and run PVM jobs in batch mode. These register routines also allow debugger writers to plug into PVM and create sophisticated debuggers for PVM. 2.4.
Reference: [3] <author> R. </author> <title> Manchek PVM Design Master's Thesis University of Tennessee, </title> <month> June </month> <year> 1994. </year>
Reference-contexts: Implementation Details This section gives a glimpse at the design goals and implementation details of the single-cpu Unix (generic) version of PVM. A complete technical description of PVM can be found in <ref> [3] </ref>. There were three main goals under consideration while building version 3. We wanted the virtual machine to be able to scale to hundreds of hosts and thousands of tasks.
Reference: [4] <institution> Platform Computing Corporation 203 College St. </institution> <address> Suite 303. Toronto Ontario. </address>
Reference-contexts: This creates an interface for advanced batch schedulers (examples include Condor [2], DQS [1], and LSF <ref> [4] </ref>) to plug into PVM and run PVM jobs in batch mode. These register routines also allow debugger writers to plug into PVM and create sophisticated debuggers for PVM. 2.4. Fault Tolerance If a host fails, PVM will automatically detect this and deleted the host from the virtual machine.
Reference: [5] <author> B. Schmidt, V. </author> <title> Sunderam Empirical Analysis of Overheads in Cluster Environments Concurrency: </title> <note> Practice and Experience 6 (1), pp 1-32 February 1994. </note>
Reference-contexts: The next section describes some of the popular load balancing methods. 8.3. Load Balancing In a multiuser network environment we have found that load balancing can be the single most important performance enhancer. <ref> [5] </ref>. There are many load balancing schemes for parallel programs. In this section we will describe the three most common schemes used in network computing. The simplest method is static load balancing. In this method the problem is divided up, and tasks are assigned to processors only once.
References-found: 6

