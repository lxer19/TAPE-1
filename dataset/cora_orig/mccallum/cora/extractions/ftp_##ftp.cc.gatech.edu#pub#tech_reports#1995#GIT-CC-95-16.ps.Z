URL: ftp://ftp.cc.gatech.edu/pub/tech_reports/1995/GIT-CC-95-16.ps.Z
Refering-URL: http://www.cs.wustl.edu/~schmidt/dove.html
Root-URL: 
Title: Progress: a Toolkit for Interactive Program Steering  
Author: Jeffrey Vetter Karsten Schwan 
Keyword: steering, dynamic, visualization, monitoring, environments.  
Address: Atlanta, GA 30332-0280  
Affiliation: College of Computing Georgia Institute of Technology  
Pubnum: Technical Report GIT-CC-95-16,  
Email: vetter@cc.gatech.edu,  schwan@cc.gatech.edu, 404/894-2589  
Phone: 404/853-9389, Fax: 404/853-9378  
Date: August 1995  
Abstract: Interactive program steering permits researchers to monitor and guide their applications during runtime. Interactive steering can help make end users more effective in addressing the scientific or engineering questions being solved with these programs, and it may be used to improve the performance of complex parallel and distributed codes. Progress is a toolkit for developing steerable applications. Users instrument their applications with library calls and then steer parallel applications with Progress runtime system. Progress provides steerable objects which encapsulate program abstractions for monitoring and steering during program execution. Once created, steering objects are known to and manipulated by Progress' two components: (1) a server executing in the same memory space as the target program and capable of inspecting and manipulating program state, and (2) a potentially remote client providing command and graphical interfaces. Developers instrument their applications with the Progress toolkit library to create and maintain these steering objects. The server maintains information about the steering objects and performs steering actions on the application. This toolkit provides sensors, probes, actuators, function hooks, complex actions, and synchronization points. Progress server is built on a Mach-compatible Cthreads library; it is a general toolkit for use with a variety of multithreaded, C programs executing on multiprocessors. Progress has been applied to several large-scale parallel application programs, including a molecular dynamics code and an N bodies simulation. It is currently being used with a complex global atmospheric modeling code. 
Abstract-found: 1
Intro-found: 1
Reference: [Appelbe91] <author> William F. Appelbe, John T. Stasko, Eileen Kraemer. </author> <title> "Applying Program Visualization Techniques to Aid Parallel and Distributed Program Development." </title> <type> Report GIT-CC 91/34, </type> <institution> College of Computing, Georgia Institute of Technology. </institution> <month> July </month> <year> 1991. </year>
Reference: [Bates86] <author> Peter Bates. </author> <title> "Debugging Heterogeneous Distributed Systems Using Event-Based Models of Behavior." </title> <booktitle> ACM/ONR Workshop on Parallel and Distributed Debugging (1988), </booktitle> <pages> pp. 11-22. </pages>
Reference-contexts: This prompts us to adopt the Falcon system's [weiming] event-and view-based models of program monitoring first advocated by Bates <ref> [Bates86] </ref> and Snodgrass for the collection of program state in Progress. Similarly, the Progress toolkit assumes that users employ visualization and animation toolkits [Ribarsky94,Kra93] for constructing the applicationspecific displays of program behavior required for steering.
Reference: [Bem93] <author> Thomas Bemmerl, Peter Braun. </author> <title> "Visualization of Message Passing Programs with the TOPSYS Parallel Programming Environment." </title> <journal> Journal of Parallel and Distributed Computing , 18(2) </journal> <pages> 118-128, </pages> <month> June </month> <year> 1993. </year>
Reference: [Bihari91] <author> Thomas E. Bihari, Karsten Schwan. </author> <title> "Dynamic Adaptation of Real-Time Software." </title> <journal> IEEE Transactions on Computer Systems , 9(2) </journal> <pages> 143-174, </pages> <month> May </month> <year> 1991. </year> <title> Progress: a Toolkit for Interactive Program Steering Page 21 </title>
Reference-contexts: Program steering affects the programs producing data, whereas data navigation is usually performed after program execution has completed. Similarly, a distinction of program steering from research in online program adaptation <ref> [Mukherjee93, Bihari91] </ref> is that steering enables both algorithms and users "in the loop" when application programs take actions in response to changes in program state or output. Our hope is to utilize this interactivity to improve productivity in the specific scientific and engineering processes being undertaken. <p> A higher frequency of these actuate calls allows steering objects to respond more rapidly to user steering requests. As with sense, each individual actuate call cannot be disabled. Actuators also have pre and post-conditions <ref> [Bihari91] </ref>. Preconditions allow a binary test to check a state within the application before firing the actuator. Post conditions execute a function after the actuator has modified the application state. Postconditions usually update application state based on the change performed by the actuator.
Reference: [Cou93] <author> Alva L. Couch. </author> <title> "Categories and Context in Scalable Execution Visualization." </title> <journal> Journal of Parallel and Distributed Computing , 18(2) </journal> <pages> 195-204, </pages> <month> June </month> <year> 1993. </year> <note> [Eisenhauer94]Greg Eisenhauer, </note> <author> Weiming Gu, Karsten Schwan, and Niru Mallavarupu. </author> <title> Falcon - toward interactive parallel programs: The online steering of a molecular dynamics application. </title> <booktitle> In Proceedings of The Third International Symposium on High-Performance Distributed Computing , San Francisco, </booktitle> <address> CA, </address> <month> August </month> <year> 1994. </year>
Reference: [Greengard90] <author> Leslie Greengard. </author> <title> The Numerical Solution of the N-Body Problem. </title> <booktitle> Computers in Physics , March/April 1990, </booktitle> <pages> pp. 142-152. </pages>
Reference-contexts: Additional functionality of Progress is evaluated by demonstrating new techniques of interacting with the executing application. Performance is important because this toolkit cannot prohibitively degrade performance of the application. Users will not tolerate excessive performance penalties. 3.1 N-body The numerical N-body of gravitation <ref> [Greengard90] </ref> simulates dynamical behavior of large stars with only gravitational forces acting between them. This simulator uses a straightforward N 2 algorithm for calculating pairwise gravitational forces and updating the velocities and positions of the bodies.
Reference: [Gu94] <author> Weiming Gu, Jeffrey Vetter, and Karsten Schwan. </author> <title> An Annotated Bibliography of Interactive Program Steering." </title> <journal> ACM SIGPLAN Notices, </journal> <volume> 29(9) </volume> <pages> 140-148, </pages> <month> September </month> <year> 1994. </year>
Reference-contexts: Data interpretation also has an extensive past with visualization and other techniques such as filtering, clustering, and queries [Bates86,Snodgrass88]. Steering, however, is rather immature. We review several systems in the Section 4 (Related Work); a complete review of systems related to this topic is available in <ref> [Gu94] </ref>. To summarize, program steering permits users to control program execution in terms of program abstractions familiar to them. Such abstractions may be encapsulations of computations producing program output like 'constituent concentration', or they may address program resource usage like 'average thread wait times' (typically of interest to program developers). <p> Related Work Several steering systems exist <ref> [Gu94] </ref> as well as research in dynamic applications and adaptable systems. Because Progress focuses on interactive systems, we limit our review to systems that allow interactivity. Functionality and generality of these systems vary but they are consistent with Progress goals of performing interactive program steering.
Reference: [Gu95] <author> Weiming Gu, Greg Eisenhauer, Eileen Kraemer, Karsten Schwan, John Stasko, Jeffrey Vetter, and Nirupama Mallavarupu. </author> <title> "Falcon: Online Monitoring and Steering of Large-Scale Parallel Programs. </title> <booktitle> Proceedings of FRONTIERS'95 , February 1995. </booktitle>
Reference-contexts: With the server on the same machine as the application, the server can access and control the application with low latency <ref> [Gu95] </ref>. Because the client is remote, latencies introduce network delays. These network delays are closer to human interactive response times; however, they are burdensome for the server. This architecture is also advantageous because the server must exist through the applications lifetime while the client does not.
Reference: [Hollingsworth93] <author> Jeffrey K. Hollingsworth, Barton P. Miller. </author> <title> "Dynamic Control of Performance Monitoring on Large Scale Parallel Systems." </title> <booktitle> Proceedings of International Conference on Supercomputing (1993). </booktitle>
Reference: [Jablonowski93] <author> David Jablonowski, John Bruner, Brian Bliss, and Robert Haber. VASE: </author> <title> The Visualization and Application Steering Environment. </title> <booktitle> In Proceedings of Supercomputing 93 , pp. </booktitle> <pages> 560-569. </pages>
Reference-contexts: Progress focuses both the developers and users attention on the steering objects allowing efficient and meaningful access to program components. The VASE system <ref> [Jablonowski93] </ref> presents an abstraction for a steerable program and offers tools that create and manage collections of steerable codes. VASE annotates existing Fortran code to create a high-level model of the application; therefore, users do not have to work at the source code level.
Reference: [Kerlick93] <author> David Kerlick and Eliabeth Kirby. </author> <title> Towards Interactive Steering, Visualization and Animation of Unsteady Finite Element Simulations. </title> <booktitle> In Proceedings of Visualization 93 </booktitle> . 
Reference-contexts: The application developer is responsible for instrumenting the application code so that the end user can control the application with a general steering interface. DYNA3D and AVS (Application Visualization System from AVS Inc.) are combined with customized interactive steering code to produce a time-accurate, unsteady finite-element simulation in <ref> [Kerlick93] </ref>. Rudimentary steering is demonstrated in a distributed environment consisting of a supercomputer and multiple graphics workstations. Although steering was demonstrated, [Kerlick93] did not present a general toolkit for steering any application program. <p> DYNA3D and AVS (Application Visualization System from AVS Inc.) are combined with customized interactive steering code to produce a time-accurate, unsteady finite-element simulation in <ref> [Kerlick93] </ref>. Rudimentary steering is demonstrated in a distributed environment consisting of a supercomputer and multiple graphics workstations. Although steering was demonstrated, [Kerlick93] did not present a general toolkit for steering any application program. Progress attempts to define a library and runtime system that will work with a variety of MIMD applications. [Parris93] describes challenges for a real-time visualization of a complex physical simulation.
Reference: [Kilpatrick91] <author> Carol E. Kilpatrick, Karsten Schwan. </author> <title> "ChaosMON - ApplicationSpecific Monitoring and Display of Performance Information for Parallel and Distributed Systems." </title> <booktitle> ACM/ONR Workshop on Parallel and Distributed Debugging (1991). </booktitle>
Reference: [Kra93] <author> Eileen Kraemer, John T. Stasko. </author> <title> "The Visualization of Parallel Systems: An Overview." </title> <journal> Journal of Parallel and Distributed Computing , ():, May 1993. </journal>
Reference-contexts: Operations on steering objects are consistent between different applications. From the steering interface, the user should be able to selectively monitor and modify steering objects within the application. Also, the interface must provide ways of interpreting and analyzing large amounts of data produced by the steering system <ref> [Kra93] </ref>. 2.2 Steering Object Model An object model allows the steering system (and the user) to concentrate on only those components of the application that the developer explicitly declared prior to execution. <p> An additional task of the steering client is easy manipulation of possibly large datasets resulting from monitoring. If a user selects monitoring for an object at a high frequency, simple textual display of the results Progress: a Toolkit for Interactive Program Steering Page 12 fails <ref> [Kra93] </ref>. However, because the structure of the steering object is known to the client, the client can map the objects updates onto a simple graph or other visualization. The clients user interface is build with Motif to present steering objects in a consistent and general manner.
Reference: [LeBlanc87] <author> Thomas J. LeBlanc, John M. Mellor-Crummey. </author> <title> "Debugging Parallel Programs with Instant Replay." </title> <journal> IEEE Transactions on Computers , C-36(4):471-481, </journal> <month> April </month> <year> 1987. </year>
Reference-contexts: Furthermore, since steering is online, Progress cannot utilize existing post mortem methods for trace analysis as used in program debugging Progress: a Toolkit for Interactive Program Steering Page 4 and in offline monitoring <ref> [LeBlanc87, Mal91] </ref>. This prompts us to adopt the Falcon system's [weiming] event-and view-based models of program monitoring first advocated by Bates [Bates86] and Snodgrass for the collection of program state in Progress. <p> Progress does not support inheritance and other characteristics of object oriented languages; Progress object model encapsulates and identifies components of the program for monitoring and steering. This concept is identical to LeBlancs instant replay mechanism <ref> [LeBlanc87] </ref>, where the user identifies objects within the code. Replays guarantee to simulate interactions between these objects, but not between every program component. An object becomes known to the steering server (and the user) when the object is registered.
Reference: [Mal91] <author> Allen D. Malony, David H. Hammerslag, David J. Jablownski. </author> <title> "Traceview: A Trace Visualization Tool." </title> <booktitle> IEEE Software , 8(5) </booktitle> <pages> 29-38, </pages> <month> September </month> <year> 1991. </year>
Reference-contexts: Furthermore, since steering is online, Progress cannot utilize existing post mortem methods for trace analysis as used in program debugging Progress: a Toolkit for Interactive Program Steering Page 4 and in offline monitoring <ref> [LeBlanc87, Mal91] </ref>. This prompts us to adopt the Falcon system's [weiming] event-and view-based models of program monitoring first advocated by Bates [Bates86] and Snodgrass for the collection of program state in Progress.
Reference: [Malony92] <author> Allen D. Malony, Daniel A. Reed, Harry A. G. Wijshoff. </author> <title> "Performance Measurement Intrusion and Perturbation Analysis." </title> <journal> IEEE Transactions on Parallel and Distributed Systems , 3(4) </journal> <pages> 433-450, </pages> <month> July </month> <year> 1992. </year>
Reference: [Marinescu90] <author> Dan C. Marinescu, James E. Lumpp, Thomas L. Casavant, Howard Jay Siegel. </author> <title> "Models for Monitoring and Debugging Tools for Parallel and Distributed Software." </title> <journal> Journal of Parallel and Distributed Computing </journal> , (9):171-183, 1990. 
Reference: [McCormick88] <author> B. H. McCormick, T. A. DeFanti, M. D. Brown. </author> <title> "Visualization in Scientific Computing." </title> <booktitle> ACM SIGGRAPH Computer Graphics , 21(6):, </booktitle> <month> November </month> <year> 1988. </year>
Reference-contexts: 1. Introduction If high performance computing continues to remain noninteractive <ref> [McCormick88] </ref>, end-users and program developers alike will not capitalize on new techniques for interactive data visualization and program animation [Jablonowski93,Stasko90], remote and collaborative work, interactive debugging and monitoring [Gu95,Ogle93], and online program adaptation [Mukherjee93]. <p> More specifically, the Progress toolkit presented and evaluated in this paper provides facilities through which existing high performance multiprocessor programs are extended for increased interactivity <ref> [McCormick88, Jablanowski93, Eisenhauer94] </ref>. Once these extensions have been performed on a target application, a user can connect to her high performance program, extract applicationspecific data regarding the program's execution state, perform steering actions, if desired, and then disconnect from the program.
Reference: [McDowell89] <author> Charles E. McDowell, David P. Helmbold. </author> <title> "Debugging Concurrent Programs." </title> <journal> ACM Computing Surveys , 21(4) </journal> <pages> 593-622, </pages> <month> December </month> <year> 1989. </year>
Reference-contexts: Steering concentrates on observing and changing parameters of a correct application which is contrary to debugging in that debugging focuses attempts to locate faults in an application <ref> [McDowell89] </ref>. Types should not be limited to standard data types provided by the language. User-defined types including structures and arrays must be accessible to allow complex steering operations on arrays and structures of data.
Reference: [Mukherjee93] <author> Bodhisattwa Mukherjee and Karsten Schwan. </author> <title> "Improving Performance by Use of Adaptive Objects: Experimentation with a Configurable Multiprocessor Thread Package . Proc. </title> <booktitle> of Second International Symposium on High Performance Distributed Computing (HPDC-2), </booktitle> <month> July </month> <year> 1993, </year> <pages> pp. 59-66. </pages>
Reference-contexts: 1. Introduction If high performance computing continues to remain noninteractive [McCormick88], end-users and program developers alike will not capitalize on new techniques for interactive data visualization and program animation [Jablonowski93,Stasko90], remote and collaborative work, interactive debugging and monitoring [Gu95,Ogle93], and online program adaptation <ref> [Mukherjee93] </ref>. For example, when run in 'batch mode', erroneous or uninteresting results produced by large-scale scientific or engineering simulations are not apparent until after the computations complete, sometimes days or weeks after program initiation. <p> Program steering affects the programs producing data, whereas data navigation is usually performed after program execution has completed. Similarly, a distinction of program steering from research in online program adaptation <ref> [Mukherjee93, Bihari91] </ref> is that steering enables both algorithms and users "in the loop" when application programs take actions in response to changes in program state or output. Our hope is to utilize this interactivity to improve productivity in the specific scientific and engineering processes being undertaken.
Reference: [Ogle93] <author> David M. Ogle, Karsten Schwan, Richard Snodgrass. </author> <title> "Application Dependent Dynamic Monitoring of Distributed and Parallel Systems." </title> <journal> IEEE Transactions on Parallel and Distributed Systems , 4(7) </journal> <pages> 762-778, </pages> <month> July </month> <year> 1993. </year>
Reference-contexts: Because sense is executed within the control flow of the application, sense is synchronous. The steering server can enable or disable Sense for each particular steering object. Both probes and sensors are investigated in <ref> [Ogle93] </ref> as part of an application specific monitoring system. In Progress, these mechanisms monitor steering objects instead of language specific application components. Actuate performs a modification on the steering object.
Reference: [Parris93] <author> Mark Parris, Carl Mueller, Jan Prins, Adam Duggan, Quan Zhou, Erik Erikson. </author> <title> A Distributed Implementation of an N-body Virtual World Simulation. </title> <booktitle> In Proceedings of The Workshop on Parallel and Distributed Real-Time Systems (April 1993), </booktitle> <pages> pp. 66-70. </pages>
Reference-contexts: Although steering was demonstrated, [Kerlick93] did not present a general toolkit for steering any application program. Progress attempts to define a library and runtime system that will work with a variety of MIMD applications. <ref> [Parris93] </ref> describes challenges for a real-time visualization of a complex physical simulation. The goal of this real-time visualization is a virtual world where human users interact with the visualization in a 3D environment. The implementation spans a network of several specialized computer systems. [Parris93] is interesting in the context of Progress <p> work with a variety of MIMD applications. <ref> [Parris93] </ref> describes challenges for a real-time visualization of a complex physical simulation. The goal of this real-time visualization is a virtual world where human users interact with the visualization in a 3D environment. The implementation spans a network of several specialized computer systems. [Parris93] is interesting in the context of Progress because of the feedback techniques used.
Reference: [Ribarsky94] <author> William Ribarsky, Eric Ayers, John Eble, </author> <title> Sougata Mukherjea . "Using Glyphmaker to Create Customized Visualizations of Complex Data ." IEEE Computer, </title> <month> June </month> <year> 1994. </year>
Reference-contexts: The client provides command, recording, scripting, and user interface facilities, and it interfaces to existing program animation or data visualization facilities offered by the Falcon monitoring system [Eisenhauer94FAL] and by data visualizers <ref> [Ribarsky94] </ref> employed by Progress users. This paper explores the requirements and opportunities of online program steering. Its contributions focus on the usage of steering during the execution of high performance parallel programs, similar to ongoing research on dynamic program monitoring [Eisenhauer94FAL,Hollingsworth93].
Reference: [Schwan88] <author> Karsten Schwan, Rajiv Ramnath, Sridhar Vasudevan, David Ogle. </author> <title> "A Language and System for the Construction and Timing of Parallel Programs." </title> <journal> IEEE Transactions on Software Engineering , 14(4):455 471, </journal> <month> April </month> <year> 1988. </year>
Reference: [Snodgrass88] <author> Richard Snodgrass. </author> <title> "A Relational Approach to Monitoring Complex Systems." </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 6(2) </volume> <pages> 157-196, </pages> <month> May </month> <year> 1988. </year>
Reference: [Sosic92] <author> R. Sosic. Dynascope: </author> <title> A Tool for Program Directing. </title> <booktitle> In Proceedings of SIGPLAN'92 Conference on Programming Language Design and Implementation, SIGPLAN Notices, </booktitle> <volume> 27(7) </volume> <pages> 12-21, </pages> <month> July </month> <year> 1992. </year> <title> Progress: a Toolkit for Interactive Program Steering Page 22 </title>
Reference: [Stasko90] <author> John T. Stasko, Charles Patterson. </author> <title> "Understanding and Classifying Systems for the Visualization of Computer Data Structures, Programs, and Process." </title> <type> Report GIT-CC 90/66, </type> <institution> College of Computing, Georgia Institute of Technology. </institution> <year> 1991. </year>
Reference: [Tuchman91] <author> Allan Tuchman, David Jablonowski, George Cybenko. </author> <title> "Run-Time Visualization of Program Data." </title> <booktitle> Proceedings of Visualization '91 (1991), </booktitle> <pages> pp. 255-261. </pages>
Reference-contexts: As discussed earlier, interactive program steering implies that human users have the option of interpreting program data and providing feedback to the program during its execution. Other research on dynamic systems discusses feedback and adaptation; however, the feedback is usually the product of an algorithm. Tuchman, et al. <ref> [Tuchman91] </ref> created the Vista system for simulation-time visualization of data. Vista provides a window into the application by showing program data automatically during execution. The system architecture is designed for a distributed or remotely executing application.
References-found: 28

