URL: ftp://ftp.cs.ucsd.edu/pub/team/cesiumicdcs.ps.Z
Refering-URL: http://www.cs.ucsd.edu/users/flaviu/publications.html
Root-URL: http://www.cs.ucsd.edu
Title: Centralized Failure Injection for Distributed, Fault-Tolerant Protocol Testing  
Author: Guillermo A. Alvarez Flaviu Cristian 
Address: La Jolla, CA 920930114, USA  
Affiliation: Dept. of Computer Science and Engineering, Univ. of California, San Diego  
Date: May 1997.  
Note: Published in Proc. of the 17th IEEE International Conference on Distributed Computing Systems (ICDCS'97), Baltimore, Maryland,  
Abstract: We describe a centralized approach to testing that distributed fault-tolerant protocols satisfy their safety and timeliness specifications in the presence of the very failures they are designed to tolerate. Cesium is a testing environment based on the centralized simulation of distributed executions and failures. Processes are run in a single address space while providing the appearance of a truly distributed execution. The human tester can force the occurrence of arbitrary failures and security attacks. The implementations under test are not instrumented for testing purposes, and their source codes need not be available. We prove that Cesium can execute exactly the set of runs feasible in the real distributed system being simulated. We also show that there are safety and timeliness properties in the specifications of many existing distributed protocols that cannot be tested in practical distributed systems. All of these properties can, however, be accurately tested by Cesium without introducing any perturbation in test experiments. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> G. Alvarez and F. Cristian. </author> <title> Simulation-based test of fault-tolerant group membership services. </title> <booktitle> In Proc. of the 12th Annual Conf. on Computer Assurance, </booktitle> <month> Jun. </month> <year> 1997. </year>
Reference-contexts: Given Java's dynamic linking/loading semantics, it is not necessary to recompile the code under test or the L-servers between experiments, resulting in short turnaround times. So far, Cesium has proven itself very effective for debugging two locally-developed implementations of fault-tolerant group membership protocols <ref> [1] </ref>. We found several errors in the implementations of both protocols; two of them would have been quite difficult to detect by testing on a network of workstations.
Reference: [2] <author> G. Alvarez and F. Cristian. </author> <title> A centralized failure injection environment for the validation of distributed fault-tolerant protocols. </title> <type> UCSD TR CS95-458, </type> <month> Nov. </month> <year> 1995. </year> <note> ftp:// cs.ucsd.edu/ pub/ galvarez/ papers/ failsim.ps.Z. </note>
Reference-contexts: The full treatment of the definitions and the proofs of the theorems can be found in <ref> [2] </ref>. We represent a clock-communication failure (cc-failure) as a special kind of event, that upon its occurrence eliminates some input events that would have occurred in the future, and creates other new ones. <p> If a timeliness property restricts the real time of occurrence of events, then its evaluation may not be possible in a real distributed system for the reasons already discussed in Section 7.1. In <ref> [2] </ref> we give an example of a timeliness property that is very difficult to test even though it only mentions local times; its evaluation requires supplementary system resources to be available. On the other hand, Cesium does not share these limitations.
Reference: [3] <author> G. Alvarez, F. Cristian, and S. Mishra. </author> <title> On-demand asynchronous atomic broadcast. </title> <booktitle> In Proc. of the 5th IFIP Working Conf. on Dependable Computing for Critical Applications, </booktitle> <month> Sep. </month> <year> 1995. </year>
Reference-contexts: A service provides two kinds of operations; standard operations that provide its clients with standard, or failure-free service, and failure operations that can be triggered by the "adverse environment" to simulate failures among those specified for the service [9]. Consider the example in which an atomic broadcast service <ref> [3] </ref> must be tested, that depends upon an asynchronous datagram communication service with omission/performance failure semantics.
Reference: [4] <author> J. Arlat, A. Costes, Y. Crouzet, J.-C. Laprie, and D. Pow-ell. </author> <title> Fault injection and dependability evaluation of fault-tolerant systems. </title> <journal> IEEE Trans. on Computers, </journal> <volume> 42(8) </volume> <pages> 913-23, </pages> <month> Aug. </month> <year> 1993. </year>
Reference-contexts: The Messaline tool <ref> [4] </ref> performs hardware-level fault injection to evaluate statistical dependability measures. Echtle and Chen [14] describe heuristics for achieving control path coverage by manipulating the messages exchanged between tasks. Fiat [17] and Doctor [15] rely on a central process to control fault injection and monitoring agents at each participating node.
Reference: [5] <author> E. Brewer, C. Dellarocas, A. Colbrook, and W. Weihl. Pro-teus: </author> <title> A high-performance parallel-architecture simulator. </title> <booktitle> In Proc. of ACM SIGMETRICS, </booktitle> <month> May </month> <year> 1992. </year>
Reference-contexts: To return realistic values to the user, clocks are incremented between successive readings according to the amount of time used by the host computer to execute the intervening instructions. Cesium does not add additional instructions to the code under test like other approaches <ref> [5, 11] </ref>; therefore the code is not instrumented for testing purposes, and the unaltered delays of the real system are observable. In this sense, Cesium provides totally nonintrusive monitoring of the system, and does not suffer from the probe effect. <p> A node of the real system needs not be available for testing: the tester can specify a constant k for each experiment, with the relative execution speeds of the real nodes and Cesium's host machine. Previous research in the simulation field <ref> [5] </ref> shows that a single constant gives a good approximation to the real system's execution times. For Cesium's purposes, a real system is characterized by its values of N , ffi u , ffi l , and k. <p> Another difference is that Orchestra will, in general, interfere with the execution by introducing additional overhead; Cesium runs the simulation at its own pace and can therefore make any testing activity undetectable from the implementation under test. Regarding simulators, Proteus <ref> [5] </ref> and Tango [11] are centralized simulators of MIMD parallel architectures. Even though they are well suited for debugging and performance evaluation, they cannot simulate the occurrence of any failure, and do not provide support for timely testing of protocol properties. <p> The cost of keeping the nodes synchronized within a bounded simulation lag make parallel simulators useful only for experiments involving very large numbers of simulated nodes, or large amounts of memory|for smaller experiments centralized simulators are more efficient <ref> [5] </ref>. 9 Conclusions The development of fault-tolerant distributed protocols poses nontrivial challenges that make the process cumbersome and error-prone, such as the inaccessibility of the global system state and the difficulties inherent in executing and re-executing a particular computation path. To overcome them, we propose a centralized protocol testing environment.
Reference: [6] <author> S. Budkowski. </author> <title> Estelle development toolset. </title> <journal> Computer Networks and ISDN Systems, </journal> <volume> 25(1) </volume> <pages> 63-82, </pages> <month> Aug. </month> <year> 1992. </year>
Reference-contexts: Even though they are well suited for debugging and performance evaluation, they cannot simulate the occurrence of any failure, and do not provide support for timely testing of protocol properties. The Wisconsin Wind Tunnel [16] performs a similar function, but runs on a parallel machine. EDT <ref> [6] </ref> simulates the execution of specifications written in the Estelle language; the tester has access to the global state, and safety properties can be tested.
Reference: [7] <author> P. Ciarfella, L. Moser, P. Melliar-Smith, and D. Agarwal. </author> <title> The Totem protocol development environment. </title> <booktitle> In Proc. of the Int. Conf. on Network Protocols, </booktitle> <month> Oct. </month> <year> 1994. </year>
Reference-contexts: The Wisconsin Wind Tunnel [16] performs a similar function, but runs on a parallel machine. EDT [6] simulates the execution of specifications written in the Estelle language; the tester has access to the global state, and safety properties can be tested. Totem <ref> [7] </ref> is a centralized simulation of a token-passing atomic broadcast protocol; communication failures occur at random during the execution, and there are no local clocks. Both EDT and Totem are not well suited for testing timeliness properties, as relevant events can be arbitrarily late.
Reference: [8] <author> F. Cristian. </author> <title> Synchronous and asynchronous group communication. </title> <journal> Comm. of the ACM, </journal> <volume> 39(4) </volume> <pages> 88-97, </pages> <month> Apr. </month> <year> 1996. </year>
Reference-contexts: This exact synchronization among actions in different processors is impossible to achieve in the presence of communication delay uncertainty [13]. As another example, consider the "stability of local views" safety property of an asynchronous group membership service <ref> [8] </ref>: if the system is stable (i.e. the reach-ability relation among nodes does not change, and there are no failures or restarts) during a sufficiently long time interval, then no correct processor leaves its group.
Reference: [9] <author> F. Cristian. </author> <title> A rigorous approach to fault-tolerant programming. </title> <journal> IEEE Trans. on Software Engineering, </journal> <volume> SE-11(1):23-31, </volume> <month> Jan. </month> <year> 1985. </year>
Reference-contexts: The service under test receives requests from a centralized test controller, and in turn invokes operations on lower-level services. In addition to standard operations defined for the tested service, the test program can also invoke failure operations <ref> [9] </ref> that simulate the occurrence of intended failures. All nodes have local clocks, and a global simulation clock corresponding to real time is also maintained; failures of local clocks such as crashes or excessive drifts are easily simulated. <p> A service provides two kinds of operations; standard operations that provide its clients with standard, or failure-free service, and failure operations that can be triggered by the "adverse environment" to simulate failures among those specified for the service <ref> [9] </ref>. Consider the example in which an atomic broadcast service [3] must be tested, that depends upon an asynchronous datagram communication service with omission/performance failure semantics.
Reference: [10] <author> F. Cristian and C. </author> <title> Fetzer. Fault-tolerant external clock synchronization. </title> <booktitle> In Proc. of the 15th Int. Conf. on Distributed Computing Systems, </booktitle> <month> May </month> <year> 1995. </year>
Reference-contexts: However, in some situations this property must be relaxed. The service being tested may place weaker assumptions on the local clocks, as in the case of a clock synchronization protocol <ref> [10] </ref>. Typical failure semantics include an excessive drift from real time, stuck bits, and clock crashes. Cesium provides two ways of implementing clock failures. First, the driver can change the local clocks at will by invoking primitive functions. <p> For instance, consider the "bounded maximum internal deviation" safety property of an external clock synchronization protocol <ref> [10] </ref>. Let C T (t) denote the value of task T 's local clock at real time t, and ffi denote the maximum allowable deviation between any two correct local clocks.
Reference: [11] <author> H. Davis, S. Goldschmidt, and J. Hennessy. </author> <title> Tango: A multiprocessor simulation and tracing system. </title> <booktitle> In Proc. of the Int. Conf. on Parallel Processing, </booktitle> <month> Aug. </month> <year> 1991. </year>
Reference-contexts: To return realistic values to the user, clocks are incremented between successive readings according to the amount of time used by the host computer to execute the intervening instructions. Cesium does not add additional instructions to the code under test like other approaches <ref> [5, 11] </ref>; therefore the code is not instrumented for testing purposes, and the unaltered delays of the real system are observable. In this sense, Cesium provides totally nonintrusive monitoring of the system, and does not suffer from the probe effect. <p> Another difference is that Orchestra will, in general, interfere with the execution by introducing additional overhead; Cesium runs the simulation at its own pace and can therefore make any testing activity undetectable from the implementation under test. Regarding simulators, Proteus [5] and Tango <ref> [11] </ref> are centralized simulators of MIMD parallel architectures. Even though they are well suited for debugging and performance evaluation, they cannot simulate the occurrence of any failure, and do not provide support for timely testing of protocol properties.
Reference: [12] <author> S. Dawson, F. Jahanian, T. Mitton, and T. Tung. </author> <title> Testing of fault-tolerant and real-time distributed systems via protocol fault injection. </title> <booktitle> In Proc, of the 26th Int. Symp. on Fault-Tolerant Computing, </booktitle> <month> Jun. </month> <year> 1996. </year>
Reference-contexts: Both require some instrumentation in the code under test; Doctor allows a greater degree of control over the experiment, and uses separate communication and process hardware to diminish the interference on the system being tested. The SockPFI/Orchestra tool <ref> [12] </ref> is closest to our approach to protocol testing. Orchestra inserts an additional layer below the layer under test by reimplementing the standard socket interface, and can simulate communication failures by filtering and altering the messages that pass through the test layer.
Reference: [13] <author> D. Dolev, J. Halpern, and R. </author> <title> Strong. On the possibility and impossibility of achieving clock synchronization. </title> <journal> Journal of Computer and System Sciences, </journal> <volume> 32(2) </volume> <pages> 230-250, </pages> <year> 1986. </year>
Reference-contexts: To do so, every task T would have to take a snapshot of its local clock at the same real time t, and then compare the values against each other. This exact synchronization among actions in different processors is impossible to achieve in the presence of communication delay uncertainty <ref> [13] </ref>.
Reference: [14] <author> K. Echtle and Y. Chen. </author> <title> Evaluation of deterministic fault injection for fault-tolerant protocol testing. </title> <booktitle> In Proc. of the 21st Int. Symp. on Fault-Tolerant Computing, </booktitle> <month> Jun. </month> <year> 1991. </year>
Reference-contexts: The Messaline tool [4] performs hardware-level fault injection to evaluate statistical dependability measures. Echtle and Chen <ref> [14] </ref> describe heuristics for achieving control path coverage by manipulating the messages exchanged between tasks. Fiat [17] and Doctor [15] rely on a central process to control fault injection and monitoring agents at each participating node.
Reference: [15] <author> S. Han, K. Shin, and H. Rosenberg. Doctor: </author> <title> An integrated software fault injection environment for distributed real-time systems. </title> <booktitle> In Proc. of the Int. Computer Performance and Dependability Symp., </booktitle> <month> Apr. </month> <year> 1995. </year>
Reference-contexts: The Messaline tool [4] performs hardware-level fault injection to evaluate statistical dependability measures. Echtle and Chen [14] describe heuristics for achieving control path coverage by manipulating the messages exchanged between tasks. Fiat [17] and Doctor <ref> [15] </ref> rely on a central process to control fault injection and monitoring agents at each participating node.
Reference: [16] <author> S. Reinhardt, M. Hill, J. Larus, A. Lebeck, J. Lewis, and D. Wood. </author> <title> The Wisconsin Wind Tunnel: Virtual prototyp-ing of parallel computers. </title> <booktitle> In Proc. of ACM SIGMETRICS, </booktitle> <month> May </month> <year> 1993. </year>
Reference-contexts: Regarding simulators, Proteus [5] and Tango [11] are centralized simulators of MIMD parallel architectures. Even though they are well suited for debugging and performance evaluation, they cannot simulate the occurrence of any failure, and do not provide support for timely testing of protocol properties. The Wisconsin Wind Tunnel <ref> [16] </ref> performs a similar function, but runs on a parallel machine. EDT [6] simulates the execution of specifications written in the Estelle language; the tester has access to the global state, and safety properties can be tested. <p> Simulation environments perform repeatable executions, but do not allow a tight degree of control over the experiments. In order to use parallel and distributed simulators like WWT <ref> [16] </ref> for protocol validation, they need to rely on conservative parallel discrete-event simulation techniques.
Reference: [17] <author> Z. Segall, D. Vrsalovic, D. Siewiorek, D. Yaskin, J. Kow-nacki, J. Barton, R. Dancey, A. Robinson, and T. Lin. FIAT: </author> <title> Fault-injection based automated testing environment. </title> <booktitle> In Proc. of the 18th Int. Symp. on Fault-Tolerant Computing, </booktitle> <month> Jun. </month> <year> 1988. </year>
Reference-contexts: The Messaline tool [4] performs hardware-level fault injection to evaluate statistical dependability measures. Echtle and Chen [14] describe heuristics for achieving control path coverage by manipulating the messages exchanged between tasks. Fiat <ref> [17] </ref> and Doctor [15] rely on a central process to control fault injection and monitoring agents at each participating node.
Reference: [18] <author> Sun Microsystems, Inc. </author> <title> The Java Language Specification, </title> <month> Aug. </month> <year> 1996. </year> <note> http:// java.sun.com/ doc/ language specification.html. </note>
Reference-contexts: We argue that a centralized environment is the right approach for testing distributed fault-tolerant protocols, since it overcomes all the hurdles discussed above. We present an environment called Cesium (Centralized Distributed-Execution Simulation with Failure M odeling). Cesium is implemented in Java <ref> [18] </ref>. Its core is a simulator that provides the illusion of distributed execution while really multiplexing all distributed processes in a single address space. The service under test receives requests from a centralized test controller, and in turn invokes operations on lower-level services. <p> This feature attains our initial goal of making executions repeatable, and is very valuable for confirming that an error detected in a prior experiment has indeed been corrected. 5 Implementation Cesium has been implemented in Java <ref> [18] </ref>. Our implementation is portable, and provides an object-oriented interface for Java programs. The tester supplies a Java im plementation of the protocol under test, and the driver and L-servers, written using the interface primitives.
References-found: 18

