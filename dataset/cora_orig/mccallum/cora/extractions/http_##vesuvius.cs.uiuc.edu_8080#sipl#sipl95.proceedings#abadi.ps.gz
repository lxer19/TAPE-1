URL: http://vesuvius.cs.uiuc.edu:8080/sipl/sipl95.proceedings/abadi.ps.gz
Refering-URL: http://vesuvius.cs.uiuc.edu:8080/sipl/sipl95.proceedings.html
Root-URL: http://www.cs.uiuc.edu
Title: Page 1 An Imperative Object Calculus Basic Typing and Soundness  
Author: Martn Abadi and Luca Cardelli 
Affiliation: Digital Equipment Corporation, Systems Research Center  
Abstract: We develop an imperative calculus of objects that is both tiny and expressive. Our calculus provides a minimal setting in which to study the operational semantics and the typing rules of objectoriented languages. We prove type soundness using a simple subject-reduction approach. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Abadi, M., </author> <title> Baby Modula-3 and a theory of objects. </title> <journal> Journal of Functional Programming 4(2), </journal> <pages> 249-283. </pages> <year> 1994. </year>
Reference-contexts: In further work [5] we treat second-order type structures (with Self types) for an imperative calculus. A few other object formalisms have been defined and studied. Many of these rely on purely functional models, with an emphasis on types <ref> [1, 8, 10, 12, 17, 19-21, 27] </ref>. Others deal with imperative features in the context of concurrency; see for example [29]. The works most closely related to ours are that of Eifrig et al. on LOOP [15] and that of Bruce and van Gent on TOIL [9].
Reference: [2] <author> Abadi, M. and L. Cardelli, </author> <title> A semantics of object types. </title> <booktitle> Proc. IEEE Symposium on Logic in Computer Science. </booktitle> <year> 1994. </year>
Reference: [3] <author> Abadi, M. and L. Cardelli, </author> <title> A theory of primitive objects: second-order systems. </title> <booktitle> Proc. ESOP94 - European Symposium on Programming. </booktitle> <publisher> Springer-Verlag. </publisher> <year> 1994. </year>
Reference: [4] <author> Abadi, M. and L. Cardelli, </author> <title> A theory of primitive objects: untyped and first-order systems. </title> <booktitle> Proc. Theoretical Aspects of Computer Software. </booktitle> <publisher> Springer-Verlag. </publisher> <year> 1994. </year>
Reference-contexts: The initial syntax is minimal, but in sections 2.2 and 2.3 we show how to express convenient constructs such as fields and procedures. We omit how to encode basic data types, control structures, and classes, which can be treated much as in <ref> [4] </ref>. In section 2.5 we give an operational semantics. <p> Typing We define a type system for the untyped calculus of section 2, and give a typed example. 3.1 Typing Rules The typing rules for objects are the same ones we would have for a functional semantics. They are in fact a superset of those of <ref> [4] </ref>, except that terms do not contain type annotations (to match our untyped operational semantics). <p> In this example we rely on fields and procedures, as encoded in section 2. The encoding of procedures type-checks with AfiB translated as [arg:A, val:B]. Trivial as it may seem, the example of movable points has been a notorious source of difficulties in functional settings (see <ref> [4] </ref>). These difficulties have resulted in the use of sophisticated type theories. In an imperative setting, however, some of these difficulties can be avoided altogether. Consider one-dimensional and two-dimensional points, with coordinate fields (x and y) and methods that modify these fields (mv_x and mv_y). The coordinates are integers. <p> The calculus is not class-based, since classes are not built-in, nor delegation-based [25], since the method-lookup mechanism does not delegate invocations. However, the calculus models class-based languages well, as we show in <ref> [4, 5] </ref>. In delegation-based languages, traits play the role of classes. Our calculus can model traits just as easily as classes, along with dynamic delegation based on traits. Interpreting delegation fully, though, would require significant formal complications, because of the complexity of method lookup in delegation.
Reference: [5] <author> Abadi, M. and L. Cardelli, </author> <title> An imperative object calculus. </title> <note> Proc. TAPSOFT95 (to appear). Springer-Verlag. </note> <year> 1995. </year>
Reference-contexts: This approach yields a manageable proof for a realistic implementation strategy. Elsewhere we have considered functional calculi [2-4]. The main novelty here is the treatment of imperative features, with corresponding proof techniques. In further work <ref> [5] </ref> we treat second-order type structures (with Self types) for an imperative calculus. A few other object formalisms have been defined and studied. Many of these rely on purely functional models, with an emphasis on types [1, 8, 10, 12, 17, 19-21, 27]. <p> The calculus is not class-based, since classes are not built-in, nor delegation-based [25], since the method-lookup mechanism does not delegate invocations. However, the calculus models class-based languages well, as we show in <ref> [4, 5] </ref>. In delegation-based languages, traits play the role of classes. Our calculus can model traits just as easily as classes, along with dynamic delegation based on traits. Interpreting delegation fully, though, would require significant formal complications, because of the complexity of method lookup in delegation.
Reference: [6] <editor> Birtwistle, G.M., O.-J. Dahl, B. Myhrhaug, and K. Nygaard, Simula Begin. Studentlitteratur. </editor> <year> 1979. </year>
Reference-contexts: However, method update can be seen as a form of dynamic inheritance [25], which is a feature found in object-based languages [7] but not yet in class-based languages <ref> [6] </ref>. Like other forms of dynamic inheritance, method update supports the dynamic modification of object behavior allowing objects, in a sense, to change their class dynamically.
Reference: [7] <author> Borning, A.H., </author> <title> Classes versus prototypes in objectoriented languages. </title> <booktitle> Proc. ACM/IEEE Fall Joint Computer Conference. </booktitle> <year> 1986. </year>
Reference-contexts: Page 2 The reliance on method update is one of the most unusual aspects of our formal treatment: this operation is not normally found in programming languages. However, method update can be seen as a form of dynamic inheritance [25], which is a feature found in object-based languages <ref> [7] </ref> but not yet in class-based languages [6]. Like other forms of dynamic inheritance, method update supports the dynamic modification of object behavior allowing objects, in a sense, to change their class dynamically.
Reference: [8] <author> Bruce, K., </author> <title> A paradigmatic objectoriented programming language: design, static typing and semantics. </title> <journal> Journal of Functional Programming 4(2), </journal> <pages> 127-206. </pages> <year> 1994. </year>
Reference-contexts: In further work [5] we treat second-order type structures (with Self types) for an imperative calculus. A few other object formalisms have been defined and studied. Many of these rely on purely functional models, with an emphasis on types <ref> [1, 8, 10, 12, 17, 19-21, 27] </ref>. Others deal with imperative features in the context of concurrency; see for example [29]. The works most closely related to ours are that of Eifrig et al. on LOOP [15] and that of Bruce and van Gent on TOIL [9].
Reference: [9] <author> Bruce, K. and R. van Gent, </author> <title> TOIL: A new typesafe objectoriented imperative language. </title> <type> Manuscript. </type> <year> 1993. </year>
Reference-contexts: Others deal with imperative features in the context of concurrency; see for example [29]. The works most closely related to ours are that of Eifrig et al. on LOOP [15] and that of Bruce and van Gent on TOIL <ref> [9] </ref>. LOOP and TOIL are typed, imperative, objectoriented languages with procedures, objects, and classes. Both take procedures, objects, and classes as primitive, with fairly complex rules; they also distinguish methods from fields. LOOP is translated into a somewhat simpler calculus, which includes record, function, reference, recursive, and F-bounded types.
Reference: [10] <author> Cardelli, L., </author> <title> Extensible records in a pure calculus of subtyping. In Theoretical Aspects of ObjectOriented Programming, C.A. </title> <editor> Gunter and J.C. Mitchell, ed. </editor> <publisher> MIT Press. </publisher> <pages> 373-425. </pages> <year> 1994. </year>
Reference-contexts: In further work [5] we treat second-order type structures (with Self types) for an imperative calculus. A few other object formalisms have been defined and studied. Many of these rely on purely functional models, with an emphasis on types <ref> [1, 8, 10, 12, 17, 19-21, 27] </ref>. Others deal with imperative features in the context of concurrency; see for example [29]. The works most closely related to ours are that of Eifrig et al. on LOOP [15] and that of Bruce and van Gent on TOIL [9].
Reference: [11] <author> Cardelli, L., Obliq: </author> <title> A language with distributed scope. </title> <type> Report n.122. </type> <institution> Digital Equipment Corporation, Systems Research Center. </institution> <year> 1994. </year>
Reference-contexts: Conclusions We view our calculus as a small kernel for objectoriented languages. (In fact, its primitives have been used in the Obliq distributed scripting language <ref> [11] </ref>.). The calculus is not class-based, since classes are not built-in, nor delegation-based [25], since the method-lookup mechanism does not delegate invocations. However, the calculus models class-based languages well, as we show in [4, 5]. In delegation-based languages, traits play the role of classes.
Reference: [12] <author> Cardelli, L. and J.C. Mitchell, </author> <title> Operations on records. </title> <booktitle> Mathematical Structures in Computer Science 1(1), </booktitle> <pages> 3-48. </pages> <year> 1991. </year> <pages> Page 14 </pages>
Reference-contexts: In further work [5] we treat second-order type structures (with Self types) for an imperative calculus. A few other object formalisms have been defined and studied. Many of these rely on purely functional models, with an emphasis on types <ref> [1, 8, 10, 12, 17, 19-21, 27] </ref>. Others deal with imperative features in the context of concurrency; see for example [29]. The works most closely related to ours are that of Eifrig et al. on LOOP [15] and that of Bruce and van Gent on TOIL [9].
Reference: [13] <author> Chambers, C., D. Ungar, B.-W. Chang, and U. Hlzle, </author> <title> Parents are shared parts of objects: inheritance and encapsulation in Self. </title> <booktitle> Lisp and Symbolic Computation 4(3). </booktitle> <year> 1991. </year>
Reference-contexts: These concerns have led to the search for better-behaved, restricted, dynamic inheritance mechanisms [23]. Method update is one of these better-behaved mechanisms, especially in the absence of delegation, as in our calculus. Method update is statically typable, and can be used to emulate the modeswitching applications of dynamic inheritance <ref> [13] </ref>. With method update we avoid some dangerous aspects of dynamic inheritance [14, 23], while maintaining its dynamic specialization aspects originally advocated by the Treaty of Orlando [22]. In this paper, we study an untyped calculus (section 2), and then we present a type structure for it (section 3).
Reference: [14] <author> Dony, C., J. Malenfant, and P. Cointe, </author> <title> Prototype-based languages: from a new taxonomy to constructive proposals and their validation. </title> <booktitle> Proc. </booktitle> <address> OOPSLA92. </address> <year> 1992. </year>
Reference-contexts: Method update is one of these better-behaved mechanisms, especially in the absence of delegation, as in our calculus. Method update is statically typable, and can be used to emulate the modeswitching applications of dynamic inheritance [13]. With method update we avoid some dangerous aspects of dynamic inheritance <ref> [14, 23] </ref>, while maintaining its dynamic specialization aspects originally advocated by the Treaty of Orlando [22]. In this paper, we study an untyped calculus (section 2), and then we present a type structure for it (section 3).
Reference: [15] <author> Eifrig, J., S. Smith, V. Trifonov, and A. Zwarico, </author> <title> An interpretation of typed OOP in a language with state. </title> <institution> Dept. of Computer Science, The Johns Hopkins University. </institution> <year> 1993. </year>
Reference-contexts: Many of these rely on purely functional models, with an emphasis on types [1, 8, 10, 12, 17, 19-21, 27]. Others deal with imperative features in the context of concurrency; see for example [29]. The works most closely related to ours are that of Eifrig et al. on LOOP <ref> [15] </ref> and that of Bruce and van Gent on TOIL [9]. LOOP and TOIL are typed, imperative, objectoriented languages with procedures, objects, and classes. Both take procedures, objects, and classes as primitive, with fairly complex rules; they also distinguish methods from fields.
Reference: [16] <author> Harper, R., </author> <title> A simplified account of polymorphic references. </title> <journal> Information Processing Letters 51(4). </journal> <year> 1994. </year>
Reference-contexts: A subtyping relation between object types supports object sub-sumption, which allows an object to be used where an object with fewer methods is expected. We prove the consistency of our rules using a subject-reduction approach (section 4). Our technique is an extension of Harpers <ref> [16] </ref>, using closures and stacks instead of formal substitutions. This approach yields a manageable proof for a realistic implementation strategy. Elsewhere we have considered functional calculi [2-4]. The main novelty here is the treatment of imperative features, with corresponding proof techniques. <p> With this definition, all the typing difficulties common in functional settings resurface. 4. Soundness We show the type soundness of our operational semantics, using an approach similar to subject reduction. We build on the techniques developed by Tofte, Wright and Felleisen, Leroy, and Harper <ref> [16, 18, 24, 28] </ref>. Our proof technique is an extension of Harpers, in that we deal with closures and stacks and thus avoid introducing locations into the term language. The typing of results with respect to stores is delicate.
Reference: [17] <author> Harper, R. and B. Pierce, </author> <title> A record calculus based on symmetric concatenation. </title> <booktitle> Proc. 18th Annual ACM Symposium on Principles of Programming Languages. </booktitle> <year> 1991. </year>
Reference-contexts: In further work [5] we treat second-order type structures (with Self types) for an imperative calculus. A few other object formalisms have been defined and studied. Many of these rely on purely functional models, with an emphasis on types <ref> [1, 8, 10, 12, 17, 19-21, 27] </ref>. Others deal with imperative features in the context of concurrency; see for example [29]. The works most closely related to ours are that of Eifrig et al. on LOOP [15] and that of Bruce and van Gent on TOIL [9].
Reference: [18] <author> Leroy, X., </author> <title> Polymorphic typing of an algorithmic language. </title> <type> Rapport de Recherche no.1778 (Ph.D Thesis). </type> <institution> INRIA. </institution> <year> 1992. </year>
Reference-contexts: With this definition, all the typing difficulties common in functional settings resurface. 4. Soundness We show the type soundness of our operational semantics, using an approach similar to subject reduction. We build on the techniques developed by Tofte, Wright and Felleisen, Leroy, and Harper <ref> [16, 18, 24, 28] </ref>. Our proof technique is an extension of Harpers, in that we deal with closures and stacks and thus avoid introducing locations into the term language. The typing of results with respect to stores is delicate.
Reference: [19] <author> Mitchell, J.C., F. Honsell, and K. Fisher, </author> <title> A lambda calculus of objects and method specialization. </title> <booktitle> Proc. 8th Annual IEEE Symposium on Logic in Computer Science. </booktitle> <year> 1993. </year>
Reference: [20] <author> Pierce, B.C. and D.N. Turner, </author> <title> Simple type-theoretic foundations for objectoriented programming. </title> <journal> Journal of Functional Programming 4(2), </journal> <pages> 207-247. </pages> <year> 1994. </year>
Reference: [21] <author> Rmy, D., </author> <title> Typechecking records and variants in a natural extension of ML. </title> <booktitle> Proc. 16th Annual ACM Symposium on Principles of Programming Languages. </booktitle> <year> 1989. </year>
Reference: [22] <author> Stein, L.A., H. Lieberman, and D. Ungar, </author> <title> A shared view of sharing: the treaty of Orlando. In Objectoriented concepts, applications, and databases, </title> , <editor> W. Kim, andF. Lochowsky, ed. </editor> <publisher> Addison-Wesley. </publisher> <pages> 31-48. </pages> <year> 1988. </year>
Reference-contexts: Method update is statically typable, and can be used to emulate the modeswitching applications of dynamic inheritance [13]. With method update we avoid some dangerous aspects of dynamic inheritance [14, 23], while maintaining its dynamic specialization aspects originally advocated by the Treaty of Orlando <ref> [22] </ref>. In this paper, we study an untyped calculus (section 2), and then we present a type structure for it (section 3). The only type constructor is one for object types: an object type is a list of method names and method result types.
Reference: [23] <author> Taivalsaari, A., </author> <title> Objectoriented programming with modes. </title> <booktitle> Journal of Object Oriented Programming 6(3), </booktitle> <pages> 25-32. </pages> <year> 1993. </year>
Reference-contexts: A further justification for method update can be found in the desire to tame dynamic inheritance. Dynamic inheritance has potentially unpredictable effects, due to the updating of shared state. These concerns have led to the search for better-behaved, restricted, dynamic inheritance mechanisms <ref> [23] </ref>. Method update is one of these better-behaved mechanisms, especially in the absence of delegation, as in our calculus. Method update is statically typable, and can be used to emulate the modeswitching applications of dynamic inheritance [13]. <p> Method update is one of these better-behaved mechanisms, especially in the absence of delegation, as in our calculus. Method update is statically typable, and can be used to emulate the modeswitching applications of dynamic inheritance [13]. With method update we avoid some dangerous aspects of dynamic inheritance <ref> [14, 23] </ref>, while maintaining its dynamic specialization aspects originally advocated by the Treaty of Orlando [22]. In this paper, we study an untyped calculus (section 2), and then we present a type structure for it (section 3).
Reference: [24] <author> Tofte, M., </author> <title> Type inference for polymorphic references. </title> <booktitle> Information and Computation 89, </booktitle> <pages> 1-34. </pages> <year> 1990. </year>
Reference-contexts: With this definition, all the typing difficulties common in functional settings resurface. 4. Soundness We show the type soundness of our operational semantics, using an approach similar to subject reduction. We build on the techniques developed by Tofte, Wright and Felleisen, Leroy, and Harper <ref> [16, 18, 24, 28] </ref>. Our proof technique is an extension of Harpers, in that we deal with closures and stacks and thus avoid introducing locations into the term language. The typing of results with respect to stores is delicate.
Reference: [25] <author> Ungar, D. and R.B. Smith, </author> <title> Self: the power of simplicity. </title> <journal> Proc. OOPSLA87. ACM SIGPLAN Notices 2(12). </journal> <year> 1987. </year>
Reference-contexts: Page 2 The reliance on method update is one of the most unusual aspects of our formal treatment: this operation is not normally found in programming languages. However, method update can be seen as a form of dynamic inheritance <ref> [25] </ref>, which is a feature found in object-based languages [7] but not yet in class-based languages [6]. Like other forms of dynamic inheritance, method update supports the dynamic modification of object behavior allowing objects, in a sense, to change their class dynamically. <p> Conclusions We view our calculus as a small kernel for objectoriented languages. (In fact, its primitives have been used in the Obliq distributed scripting language [11].). The calculus is not class-based, since classes are not built-in, nor delegation-based <ref> [25] </ref>, since the method-lookup mechanism does not delegate invocations. However, the calculus models class-based languages well, as we show in [4, 5]. In delegation-based languages, traits play the role of classes. Our calculus can model traits just as easily as classes, along with dynamic delegation based on traits.
Reference: [26] <author> Ungar, D. and R.B. Smith, </author> <title> Self: the power of simplicity. </title> <booktitle> Lisp and Symbolic Computation 4(3). </booktitle> <year> 1991. </year>
Reference-contexts: Such interference would derail recursive invocations. (This encoding has similarities with the mechanism of method activation in the Self language <ref> [26] </ref>.) 2.4 A Small Example We give a trivial example as a notation drill.
Reference: [27] <author> Wand, M., </author> <title> Type inference for record concatenation and multiple inheritance. </title> <booktitle> Proc. 4th Annual IEEE Symposium on Logic in Computer Science. </booktitle> <year> 1989. </year>
Reference-contexts: In further work [5] we treat second-order type structures (with Self types) for an imperative calculus. A few other object formalisms have been defined and studied. Many of these rely on purely functional models, with an emphasis on types <ref> [1, 8, 10, 12, 17, 19-21, 27] </ref>. Others deal with imperative features in the context of concurrency; see for example [29]. The works most closely related to ours are that of Eifrig et al. on LOOP [15] and that of Bruce and van Gent on TOIL [9].
Reference: [28] <author> Wright, A.K. and M. Felleisen, </author> <title> A syntactic approach to type soundness. </title> <booktitle> Information and Computation 115(1), </booktitle> <pages> 38-94. </pages> <year> 1994. </year>
Reference-contexts: With this definition, all the typing difficulties common in functional settings resurface. 4. Soundness We show the type soundness of our operational semantics, using an approach similar to subject reduction. We build on the techniques developed by Tofte, Wright and Felleisen, Leroy, and Harper <ref> [16, 18, 24, 28] </ref>. Our proof technique is an extension of Harpers, in that we deal with closures and stacks and thus avoid introducing locations into the term language. The typing of results with respect to stores is delicate.
Reference: [29] <editor> Yonezawa, A. and M. Tokoro, ed. </editor> <booktitle> Objectoriented concurrent programming. </booktitle> <publisher> MIT Press. </publisher> <year> 1987. </year>
Reference-contexts: A few other object formalisms have been defined and studied. Many of these rely on purely functional models, with an emphasis on types [1, 8, 10, 12, 17, 19-21, 27]. Others deal with imperative features in the context of concurrency; see for example <ref> [29] </ref>. The works most closely related to ours are that of Eifrig et al. on LOOP [15] and that of Bruce and van Gent on TOIL [9]. LOOP and TOIL are typed, imperative, objectoriented languages with procedures, objects, and classes.
References-found: 29

