URL: ftp://haskell.systemsz.cs.yale.edu/pub/tullsen/imlforpt.ps
Refering-URL: http://www.cs.yale.edu/~tullsen/
Root-URL: http://www.cs.yale.edu
Email: mark.tullsen@yale.edu, paul.hudak@yale.edu  
Title: An Intermediate Meta-Language for Program Transformation  
Author: Mark Tullsen Paul Hudak 
Date: June 1998  
Address: New Haven CT 06520-8285  
Affiliation: Department of Computer Science Yale University  
Pubnum: Research Report YALEU/DCS/RR-1154  
Abstract: As part of an effort to bridge the gap between the theory and practice of program transformation, we have designed a meta-language for transforming functional programs. The meta-language is sound in preserving both value and termination properties of programs (and is thus superior to the unfold/fold methodology). Our key contribution is an equational specification of Scherlis's expression procedures, in which we express the essence of expression procedures as a single transformation rule. Our approach has the following advantages over both unfold/fold and expression procedures: (1) all program derivations are reversible; (2) many transformations can be done which unfold/fold and expression procedures cannot do; and (3) the proof of correctness is far simpler.
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> J. Arsac and Y. Kodratoff. </author> <title> Some techniques for recursion removal from recursive functions. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 4(2) </volume> <pages> 295-322, </pages> <month> April </month> <year> 1982. </year>
Reference-contexts: If we did so we would have this rule C [f.D [f]] = g.E [g] if C [D [f]] = E [C [f]], C [] strict which is valid, it is simply a free theorem [22] of . This theorem is found in numerous places <ref> [1, 7, 20, 13] </ref>; we take its name, Fix-Point Fusion, from Meijer et al [13] where the power of the theorem is exploited considerably: most of their transformations are instances of this one general theorem.
Reference: [2] <author> Richard Bird and Oege de Moor. </author> <title> Algebra of Programming. </title> <publisher> Prentice Hall, </publisher> <year> 1997. </year>
Reference-contexts: The Bird-Meertens Formalism (or Squiggol) <ref> [2, 12, 13] </ref> is an example of the former. Unfold/fold and expression procedures are examples of the latter.
Reference: [3] <author> R. M. Burstall and John Darlington. </author> <title> A transformation system for developing recursive programs. </title> <journal> Journal of the ACM, </journal> <volume> 24(1) </volume> <pages> 44-67, </pages> <month> January </month> <year> 1977. </year>
Reference-contexts: This paper is about how, guided by these principles, we designed the intermediate meta-language for PATH. 2 2 Approaches to Program Transformation 2.1 Unfold/Fold The best known approach to program transformation is the unfold/fold methodology of Burstall and Darlington <ref> [3] </ref>.
Reference: [4] <author> Wei Ngan Chin and John Darlington. </author> <title> Schematic rules within unfold/fold approach to program transformation. </title> <booktitle> In TENCON '89: Fourth IEEE Region 10 International Conference, </booktitle> <year> 1989. </year>
Reference-contexts: The advantages of the generative set approach are generality and ease of use|there is no need to search a catalog. A disadvantage is that derivations are more verbose: many of the same steps (unfold, simplify, fold) are taken again and again. Chin and Darlington <ref> [4] </ref> noted the need to integrate these two approaches and added schematic rules to unfold/fold and a method to generate new schematic rules using unfold/fold. In contrast, our method of integration is to start with the schematic approach and integrate the generative set approach by adding one very general law.
Reference: [5] <author> M. A. Firth. </author> <title> A Fold/Unfold Transformation System for a Non-Strict Language. </title> <type> PhD thesis, </type> <institution> University of York, </institution> <year> 1990. </year>
Reference-contexts: Although each of these examples is by necessity short, each demonstrates a transformation which is problematic with other approaches. 6.1 Transforming an Infinite List Here we derive a program which is an infinite list. The standard technique of using a well-founded ordering to prove termination of functions <ref> [5, 11] </ref> is inapplicable for recursively defined data-structures. Another technique would be needed in unfold/fold to verify the correctness of the following transformation.
Reference: [6] <author> Y. Futamura and K. Nogi. </author> <title> Generalized partial computation. </title> <editor> In D. Bjorner, A. P. Ershov, and N. D. Jones, editors, </editor> <booktitle> Partial Evaluation and Mixed Computation, </booktitle> <pages> pages 133-151. </pages> <publisher> North-Holland, </publisher> <year> 1988. </year>
Reference-contexts: With these we get the power of Generalized Partial Computation <ref> [6, 21] </ref>.
Reference: [7] <author> C. A. Gunter and D. S. Scott. </author> <title> Semantic domains. </title> <editor> In J. van Leeuwen, editor, </editor> <booktitle> Handbook of Theoretical Computer Science, </booktitle> <volume> Volume B, </volume> <pages> pages 633-674. </pages> <publisher> North-Holland, </publisher> <address> Amsterdam, </address> <year> 1990. </year>
Reference-contexts: If we did so we would have this rule C [f.D [f]] = g.E [g] if C [D [f]] = E [C [f]], C [] strict which is valid, it is simply a free theorem [22] of . This theorem is found in numerous places <ref> [1, 7, 20, 13] </ref>; we take its name, Fix-Point Fusion, from Meijer et al [13] where the power of the theorem is exploited considerably: most of their transformations are instances of this one general theorem.
Reference: [8] <author> P. Hudak, S. P. Jones, and P. Wadler. </author> <title> Report on the programming language Haskell. </title> <journal> SIGPLAN Notices, </journal> <volume> 27(5), </volume> <month> May </month> <year> 1992. </year>
Reference-contexts: For exam-ple, the well-known unfold/fold approach is not safe: terminating programs can be transformed into diverging ones. In an attempt to bridge the gap between the theory and practice of program transformation, we are developing PATH (Programmer Assistant for Transforming Haskell), a program transformation system for the language Haskell <ref> [8] </ref>. A key design step in PATH was to recognize the need for a well designed "intermediate meta-language". But what is an intermediate meta-language? In order to answer this question, we distinguish different aspects of the PATH system: object-language.
Reference: [9] <author> Gerard Huet and Bernard Lang. </author> <title> Proving and applying program transformations expressed with second order patterns. </title> <journal> Acta Informatica, </journal> <volume> 11 </volume> <pages> 31-55, </pages> <year> 1978. </year>
Reference-contexts: The language which is being transformed, a subset of Haskell in our case (though we hope to eventually support full Haskell). transformation rules. Semantics preserving transformation rules for the object-language; they are in the form of transformation templates <ref> [9] </ref>, "P 1 = P 2 if C", where P 1 and P 2 are program schemes and C is an applicability condition. meta-language. The language that describes the application of a transformation rule at a point in a program.
Reference: [10] <editor> L. Kott. Unfold/fold transformations. In M. Nivat and J. Reynolds, editors, </editor> <booktitle> Algebraic Methods in Semantics, chapter 12, </booktitle> <pages> pages 412-433. CUP, </pages> <year> 1985. </year> <month> 14 </month>
Reference-contexts: Although this example is overly simple, similar situations can arise in more subtle contexts, and thus non-termination can be introduced inadvertently. Several approaches have been proposed to solve this problem of partial correctness. One is to suitably constrain the use of fold, for example as proposed by Kott <ref> [10] </ref>. Another is to provide a separate proof of termination. Yet another is the "tick algebra" of Sands, which guarantees incremental improvement in performance to all transformations [17].
Reference: [11] <author> Zohar Manna and Richard Waldinger. </author> <title> Synthesis: Dreams ! programs. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 5(4) </volume> <pages> 294-328, </pages> <month> July </month> <year> 1979. </year>
Reference-contexts: Although each of these examples is by necessity short, each demonstrates a transformation which is problematic with other approaches. 6.1 Transforming an Infinite List Here we derive a program which is an infinite list. The standard technique of using a well-founded ordering to prove termination of functions <ref> [5, 11] </ref> is inapplicable for recursively defined data-structures. Another technique would be needed in unfold/fold to verify the correctness of the following transformation.
Reference: [12] <author> L. Meertens. </author> <title> Algorithmics towards programming as a mathematical activity. </title> <editor> In J. W. de Bakker, E. M. Hazewinkel, and J. K. Lenstra, editors, </editor> <booktitle> Proceedings of the CWI Symposium on Mathematics and Computer Science, </booktitle> <pages> pages 289-334. </pages> <publisher> North-Holland, </publisher> <year> 1986. </year> <journal> CWI Monographs, </journal> <volume> volume 1. </volume>
Reference-contexts: The Bird-Meertens Formalism (or Squiggol) <ref> [2, 12, 13] </ref> is an example of the former. Unfold/fold and expression procedures are examples of the latter.
Reference: [13] <author> Erik Meijer, Maarten Fokkinga, and Ross Paterson. </author> <title> Functional programming with bananas, lenses, envelopes and barbed wire. </title> <editor> In John Hughes, editor, </editor> <booktitle> Functional Programming Languages and Computer Architecture, </booktitle> <pages> pages 124-144. </pages> <publisher> Springer Verlag, </publisher> <month> June </month> <year> 1991. </year> <note> LNCS 523. </note>
Reference-contexts: If we did so we would have this rule C [f.D [f]] = g.E [g] if C [D [f]] = E [C [f]], C [] strict which is valid, it is simply a free theorem [22] of . This theorem is found in numerous places <ref> [1, 7, 20, 13] </ref>; we take its name, Fix-Point Fusion, from Meijer et al [13] where the power of the theorem is exploited considerably: most of their transformations are instances of this one general theorem. <p> This theorem is found in numerous places [1, 7, 20, 13]; we take its name, Fix-Point Fusion, from Meijer et al <ref> [13] </ref> where the power of the theorem is exploited considerably: most of their transformations are instances of this one general theorem. So, we have accomplished our goal: we can do expression procedure transformations with one reversible rule using the Fix-point Fusion theorem. <p> The Bird-Meertens Formalism (or Squiggol) <ref> [2, 12, 13] </ref> is an example of the former. Unfold/fold and expression procedures are examples of the latter.
Reference: [14] <author> H. Partsch and R. Steinbrueggen. </author> <title> Program transformation systems. </title> <journal> ACM Computing Surveys, </journal> <volume> 15 </volume> <pages> 199-236, </pages> <year> 1983. </year>
Reference-contexts: expression procedures the derivations can be much more unstructured, although seldom are (it remains to be seen if this lack of structure could ever be advantageous). 6 By showing how to do expression procedure transformations with a single transformation rule we have integrated two different approaches to doing program transformation <ref> [14] </ref>: (1) the schematic, or catalog, approach which is based on using a large catalog of rules, each performing a significant transformation and (2) the generative set approach, which is based on a small set of simple rules which in combination are very expressive.
Reference: [15] <author> C. Runciman, M. Firth, and N. Jagger. </author> <title> Transformation in a non-strict language: An approach to instantiation. </title> <editor> In K. Davis and R. J. M. Hughes, editors, </editor> <booktitle> Functional Programming: Proceedings of the 1989 Glasgow Workshop, </booktitle> <month> 21-23 August </month> <year> 1989, </year> <pages> pages 133-141, </pages> <address> London, UK, 1990. </address> <publisher> Springer-Verlag. British Computer Society Workshops in Computing Series. </publisher>
Reference-contexts: It corresponds to the instantiation rule in unfold/fold (which only goes in one direction). The context C [] must be strict: as Sands [16] has noted, this corresponds to the conditions described by Runciman et al <ref> [15] </ref> for safe instantiation in a non-strict language.
Reference: [16] <author> D. Sands. </author> <title> Higher-order expression procedures. </title> <booktitle> In Proceedings of the ACM SIGPLAN Symposium on Partial Evaluation and Semantics-Based Program Manipulation (PEPM). </booktitle> <publisher> ACM Press, </publisher> <year> 1995. </year>
Reference-contexts: This history is needed because a previous definition of a function is used to give folding its power. 2.2 Expression Procedures Motivated by the problems with unfold/fold, Scherlis invented expression procedures [18, 19]. (More recently Sands <ref> [16] </ref> extended this work to a higher-order non-strict language.) Scherlis's key innovation was to add a new procedure definition mechanism to his language: expression procedures. The left hand side of an expression procedure definition can be an arbitrary expression. <p> An example of a program derivation using expression procedures (adapted from <ref> [16] </ref>) follows. <p> Instantiation. The Instantiation rule lets us move strict contexts into case expressions (and in the reverse direction, out). It corresponds to the instantiation rule in unfold/fold (which only goes in one direction). The context C [] must be strict: as Sands <ref> [16] </ref> has noted, this corresponds to the conditions described by Runciman et al [15] for safe instantiation in a non-strict language.
Reference: [17] <author> D. Sands. </author> <title> Total correctness by local improvement in program transformation. </title> <booktitle> In Proceedings of the 22nd Annual ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages (POPL), </booktitle> <pages> pages 221-232. </pages> <publisher> ACM Press, </publisher> <year> 1995. </year>
Reference-contexts: One is to suitably constrain the use of fold, for example as proposed by Kott [10]. Another is to provide a separate proof of termination. Yet another is the "tick algebra" of Sands, which guarantees incremental improvement in performance to all transformations <ref> [17] </ref>. Besides the problem with correctness, unfold/fold has a significant inconvenience in practice: a history must be kept of all versions of the program as it is being transformed (or the user must specify which versions to keep or throw away).
Reference: [18] <author> W.L. Scherlis. </author> <title> Expression Procedures and Program Derivation. </title> <type> PhD thesis, </type> <institution> Stanford University, California, </institution> <month> August </month> <year> 1980. </year> <institution> Stanford Computer Science Report STAN-CS-80-818. </institution>
Reference-contexts: This history is needed because a previous definition of a function is used to give folding its power. 2.2 Expression Procedures Motivated by the problems with unfold/fold, Scherlis invented expression procedures <ref> [18, 19] </ref>. (More recently Sands [16] extended this work to a higher-order non-strict language.) Scherlis's key innovation was to add a new procedure definition mechanism to his language: expression procedures. The left hand side of an expression procedure definition can be an arbitrary expression. <p> We want to support the reuse of program derivations better than the simple method of "apply the old derivation to the new program and hope it works." * We plan to increase the expressiveness of our meta-language by adding "qualified expression procedures," which Scherlis used in his thesis <ref> [18] </ref>, to increase the information used to specialize programs. With these we get the power of Generalized Partial Computation [6, 21].
Reference: [19] <author> W.L. Scherlis. </author> <title> Program improvement by internal specialization. </title> <booktitle> In Eighth ACM Symposium on Principles of Programming Languages, </booktitle> <address> Williamsburg, Virginia, </address> <month> January </month> <year> 1981, </year> <pages> pages 41-49. </pages> <publisher> ACM, </publisher> <year> 1981. </year>
Reference-contexts: This history is needed because a previous definition of a function is used to give folding its power. 2.2 Expression Procedures Motivated by the problems with unfold/fold, Scherlis invented expression procedures <ref> [18, 19] </ref>. (More recently Sands [16] extended this work to a higher-order non-strict language.) Scherlis's key innovation was to add a new procedure definition mechanism to his language: expression procedures. The left hand side of an expression procedure definition can be an arbitrary expression.
Reference: [20] <author> Joseph E. Stoy. </author> <title> Denotational Semantics: The Scott-Strachey Approach to Programming Language Theory. </title> <publisher> MIT Press, </publisher> <year> 1977. </year>
Reference-contexts: If we did so we would have this rule C [f.D [f]] = g.E [g] if C [D [f]] = E [C [f]], C [] strict which is valid, it is simply a free theorem [22] of . This theorem is found in numerous places <ref> [1, 7, 20, 13] </ref>; we take its name, Fix-Point Fusion, from Meijer et al [13] where the power of the theorem is exploited considerably: most of their transformations are instances of this one general theorem.
Reference: [21] <author> A. Takano. </author> <title> Generalized partial computation for a lazy functional language. </title> <journal> ACM SIGPLAN Notices, </journal> <volume> 26(9) </volume> <pages> 1-11, </pages> <year> 1991. </year> <booktitle> Proceedings of Conference on Partial Evaluation and Semantics-Based Program Manipulation, </booktitle> <address> New Haven, CT. </address>
Reference-contexts: With these we get the power of Generalized Partial Computation <ref> [6, 21] </ref>.
Reference: [22] <author> P. L. Wadler. </author> <title> Theorems for free. </title> <booktitle> In Proceedings of the 1989 ACM Conference on Lisp and Functional Programming, </booktitle> <pages> pages 347-359, </pages> <year> 1989. </year> <month> 15 </month>
Reference-contexts: If we did so we would have this rule C [f.D [f]] = g.E [g] if C [D [f]] = E [C [f]], C [] strict which is valid, it is simply a free theorem <ref> [22] </ref> of . This theorem is found in numerous places [1, 7, 20, 13]; we take its name, Fix-Point Fusion, from Meijer et al [13] where the power of the theorem is exploited considerably: most of their transformations are instances of this one general theorem.
References-found: 22

