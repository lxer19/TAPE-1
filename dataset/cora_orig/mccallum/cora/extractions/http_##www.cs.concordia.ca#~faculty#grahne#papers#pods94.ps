URL: http://www.cs.concordia.ca/~faculty/grahne/papers/pods94.ps
Refering-URL: http://www.cs.concordia.ca/~faculty/grahne/papers/index.html
Root-URL: http://www.aic.nrl.navy.mil/~aha/people.html
Email: fgrahne,mnykanen,ukkoneng@cs.helsinki.fi  
Title: Reasoning about Strings in Databases  
Author: Gosta Grahne, Matti Nykanen and Esko Ukkonen 
Address: P.O. Box 26, FIN-00014 University of Helsinki, Finland  
Affiliation: Department of Computer Science  
Abstract: In order to enable the database programmer to reason about relations over strings of arbitrary length we introduce alignment logic, a modal extension of relational calculus. In addition to relations, a state in the model consists of a two-dimensional array where the strings are aligned on top of each other. The basic modality in the language (a transpose, or "slide") allows for a rearrangment of the alignment, and more complex formulas can be formed using a syntax reminiscent of regular expressions, in addition to the usual connectives and quantifiers. It turns out that the computational counterpart of the string-based portion of the logic is the class of multitape two-way finite state automata, which are devices particularly well suited for the implementation of string matching. A computational counterpart of the full logic is obtained from relational algebra by extending the selection operator into filters based on these multitape machines. Safety of formulas in alignment logic implies that new strings generated from old ones have to be of bounded length. While an undecidable property in general, this boundedness is decidable for an important subclass of formulas. As far as expressive power is concerned, alignment logic includes previous proposals for querying string databases, and gives full Turing computability. The language can be restricted to define exactly regular sets and sets in the polynomial hierarchy. 
Abstract-found: 1
Intro-found: 1
Reference: [CoV91] <author> J. Collado-Vides. </author> <title> The search for a grammatical theory of gene regulation is formally justified by showing the inadequacy of context-free grammars. </title> <booktitle> Computer Applications in the Biosciences 7 (1991), </booktitle> <pages> 321-326. </pages>
Reference-contexts: For instance, the theory of gene regulation explores the combinatorial or grammatical structure inherent in genetic data, as opposed to its statistical properties. This grammatical structure can be quite involved, since gene regulation involves non-context-free dependencies between different parts of a string <ref> [CoV91] </ref>. Such dependencies should be explicitly expressible, as they constitute knowledge about the family of strings that the current database represents. For serving as a framework for databases containing stringological information we extend the relational model to include strings over some finite alphabet . <p> This type of problem occurs e.g. in <ref> [CoV91] </ref>. ([x; y] l x = y) fl :([y] l y ? ) ^ :([y:z] l y ? ^ z ? ) The formula states that x is of the form yz where z is the translation of y. 3 Alignment Logic and Computation Since the queries are expressed in alignment
Reference: [GaS83] <author> Z. Galil and J. Seiferas. </author> <title> Time-space optimal string matching. </title> <booktitle> JCSS 26 (1983), </booktitle> <pages> 280-294. </pages>
Reference-contexts: The components of our logic that the aforementioned acceptors are a counterpart of are called string formulas. The string formulas as such have the same expressive power as the multitape two-way automata. This alone is enough e.g. for string matching <ref> [GaS83] </ref>. The string formulas together with one projection operator yield the power of full Turing computability. 2 Alignment Logic In the world of strings we distinguish as state an alignment of the strings.
Reference: [GaJ79] <author> M. R. Garey and D. S. Johnson. </author> <title> Computers and Intractability: A Guide to the Theory of NP-Completeness. </title> <publisher> Freeman Press 1979. </publisher>
Reference: [GiS65] <author> S. Ginsburg and H. Spanier. </author> <title> Mappings of languages by two-tape devices. </title> <editor> J. </editor> <booktitle> ACM 12 (1965), </booktitle> <pages> 423-434. </pages>
Reference-contexts: Theorem 5.4 Every set definable in sequence logic is definable in alignment logic. We note that the programming paradigms underlying sequence logic and alignment logic are different. The basic stringological construct in sequence logic is the transducer mapping. Since regular sets are closed under transducer mappings <ref> [GiS65] </ref>, computational power is achieved by resorting to "extra-stringological" features, such as first order logic. In alignment logic, on the other hand, full Turing computability is available 311 already when using unquantified string formulas on three variables and a projection operator (cf. Theorem 5.2).
Reference: [GiW92] <author> S. Ginsburg and X. Wang. </author> <title> Pattern matching by rs-operations: towards a unified approach to querying sequenced data. </title> <booktitle> PODS '92, </booktitle> <pages> pp. 293-300 </pages>
Reference-contexts: This partially solves the data extraction problem but 303 does not support restructuring operations very well. On the other hand, one can add a restructuring operator, such as the transducer mappings of Ginsburg and Wang <ref> [GiW92] </ref>. This gives good data restructuring abilities, but only rather implicit data extraction features, because (finite-state) transducers generate the regular sets only. Then there is the avenue of a declarative approach. The idea is to design a language for expressing properties of strings. <p> list above, e.g. along x 1 ; : : :; x k since = df: ([x 1 ; : : : ; x k ] r ) fl ([x 1 ; : : : ; x k ] r ): As far as the sequence logic of Ginsburg and Wang <ref> [GiW92] </ref> is concerned, it turns out that it is included in alignment logic. Theorem 5.4 Every set definable in sequence logic is definable in alignment logic. We note that the programming paradigms underlying sequence logic and alignment logic are different. <p> In alignment logic, on the other hand, full Turing computability is available 311 already when using unquantified string formulas on three variables and a projection operator (cf. Theorem 5.2). As pointed out by Ginsburg and Wang <ref> [GiW92] </ref>, it is of course always possible to increase the expressive power of sequence logic by strengthening the language used to specify the transducers. However, in alignment logic it not necessary to go beyond regular expressions in the syntax of the string formulas.
Reference: [HeS93] <author> C. Helgesen and P. R. Sibbald. </author> <title> PALM - A pattern language for molecular biology. </title> <booktitle> In: Proc. First Int. Conf. on Intelligent Systems for Molecular Biology (ISMB-93), </booktitle> <publisher> AAAI Press 1993, </publisher> <pages> pp. 172-180. </pages>
Reference-contexts: How should one go about when building a database language having such features? From the literature we find the following types of proposals. On one hand, like in <ref> [PiT86, HeS93] </ref> one can add, say to relational algebra, a selection predicate for testing membership in a set specified by for instance a regular expression. This partially solves the data extraction problem but 303 does not support restructuring operations very well.
Reference: [PiT86] <author> P. Pistor and R. Traunmueller. </author> <title> A database language for sets, lists and tables. </title> <booktitle> Information Systems 11 (1986), </booktitle> <pages> 323-336. </pages>
Reference-contexts: How should one go about when building a database language having such features? From the literature we find the following types of proposals. On one hand, like in <ref> [PiT86, HeS93] </ref> one can add, say to relational algebra, a selection predicate for testing membership in a set specified by for instance a regular expression. This partially solves the data extraction problem but 303 does not support restructuring operations very well.
Reference: [RBS87] <author> R. Ramakrishnan, F. Bancilhon and A. Silberschatz. </author> <title> Safety of recursive Horn clauses with infinite relations. </title> <booktitle> PODS '87, </booktitle> <pages> pp. 328-339. </pages>
Reference-contexts: We are thus interested in inferring the finiteness constraints : fx 1 ; : : : ; x k g ; fy 1 ; : : : ; y m g proposed by Ramakrishnan et al <ref> [RBS87] </ref>. Theorem 4.1 The limitation problem is undecidable when k 1 and m 3. The proof is based on the fact that we can encode the behaviour of an arbitrary 2-counter machine as a string formula on variables x 1 ; y 1 ; y 2 ; y 3 .
Reference: [Ric92] <author> J. Richardson. </author> <title> Supporting lists in a data model (a timely approach). </title> <type> IBM research report RJ 8853, </type> <month> June </month> <year> 1992. </year>
Reference-contexts: This gives good data restructuring abilities, but only rather implicit data extraction features, because (finite-state) transducers generate the regular sets only. Then there is the avenue of a declarative approach. The idea is to design a language for expressing properties of strings. One such proposal can be found in <ref> [Ric92] </ref>, which essentially suggests using the modalities of temporal logic for this purpose. Each successive position in a string is seen to be the timewise "next" instance of that string. The temporal modalities lend themselves naturally to reasoning about strings.
Reference: [SaK83] <author> D. Sankoff and J. B. Kruskal (eds.) </author> <title> Time Warps, String Edits and Macromolecules: The Theory and Practice of Sequence Comparison. </title> <publisher> Addison-Wesley 1983. </publisher>
Reference-contexts: Each step can consist of replacing one symbol by another, or of inserting or deleting a symbol, see e.g. <ref> [SaK83] </ref>. 307 a string y. Likewise, each occurrence of the character b must match a position in a string z.
Reference: [Sto77] <author> L. J. Stockmeyer. </author> <title> The polynomial-time hierarchy. </title> <booktitle> Theoretical Computer Science 3 (1977), </booktitle> <pages> 1-22. </pages>
Reference-contexts: However, in alignment logic it not necessary to go beyond regular expressions in the syntax of the string formulas. We have also been able to obtain a correspondence between alignment formulas and the polynomial hierarchy <ref> [Sto77] </ref>. For this correspondence we need the class of quantifier limited formulas.
Reference: [Ull88] <author> J. D. Ullman. </author> <title> Principles of Database and Knowledge-base Systems. </title> <publisher> Computer Science Press 1988. </publisher>
Reference-contexts: An important question is whether semantic safety can be syntactically determined. It is well known that safety is undecidable for purely relational formulas <ref> [Ull88] </ref>. Thus there is no hope that safety would be decidable for alignment formulas. We shall however first look into the possibility of determining safety for string formulas alone. It turns out that there is a source of undecidability in the string formulas too.
Reference: [Var82] <author> M. Vardi. </author> <title> The complexity of relational query languages. </title> <booktitle> STOC '82, </booktitle> <pages> pp. 137-145. </pages>
Reference-contexts: Furthermore, we assume that there is only one free variable and w.l.o.g. that all quantifiers are at front. Given such an "unrelational" formula we say that defines the set f A 0 (x) : A 0 j= g: By the (data) complexity <ref> [Var82] </ref> of a set defined by a formula we mean the complexity of the decision problem "w 2 f A 0 (x) : A 0 j= g?," measured as a function of the length of the string w.
Reference: [Wol83] <author> P. Wolper. </author> <title> Temporal logic can be more expressive. </title> <booktitle> Information and Control 56 (1983), </booktitle> <pages> 72-93. </pages>
Reference-contexts: Each successive position in a string is seen to be the timewise "next" instance of that string. The temporal modalities lend themselves naturally to reasoning about strings. But as shown by Wolper <ref> [Wol83] </ref>, using only the modalities next and until, to say that a property holds in every even position of the string is not within the power of the language. Using Wolper's extended temporal logic would be a step in the right direction.
References-found: 14

