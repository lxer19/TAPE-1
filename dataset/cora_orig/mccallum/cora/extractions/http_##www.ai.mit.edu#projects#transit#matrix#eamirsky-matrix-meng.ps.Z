URL: http://www.ai.mit.edu/projects/transit/matrix/eamirsky-matrix-meng.ps.Z
Refering-URL: http://www.ai.mit.edu/projects/transit/matrix_documents.html
Root-URL: 
Title: Coarse-Grain Reconfigurable Computing  
Author: by Ethan A. Mirsky Thomas F. Knight 
Degree: Submitted to the Department of Electrical Engineering and Computer Science in partial fulfillment of the requirements for the degrees of Master of Engineering in Computer Science and Electrical Engineering and Bachelor of Science in Computer Science and Engineering at the  All rights reserved. Author  Certified by  Senior Research Scientist Thesis Supervisor Accepted by F. R. Morgenthaler Chairman, Departmental Committee on Graduate Students  
Date: June 1996  May 24, 1996  
Affiliation: MASSACHUSETTS INSTITUTE OF TECHNOLOGY  c Massachusetts Institute of Technology 1996.  Department of Electrical Engineering and Computer Science  
Abstract-found: 0
Intro-found: 0
Reference: [1] <author> Michael Bolotski, Thomas Simon, Carlin Vieri, Rajeevan Amirtharajah, and Thomas F. Knight Jr. </author> <title> Abacus: A 1024 processor 8ns simd array. </title> <booktitle> In Advanced Research in VLSI 1995, </booktitle> <year> 1995. </year>
Reference-contexts: Datapaths are assembled by composing BFUs through carry-chains. We saw an application-specific example of this processing style in Chapter 8. A number of other architectures have been proposed or built which can also adjust 71 to different datapath granularity. Typically, this is accomplished through segmentable datapaths (e.g. [19] <ref> [1] </ref>). These generally exhibit SIMD instruction control for the datapath, but can be reconfigured to treat the n bit datapath as k, n k -bit words, for certain, restricted, values of k. <p> -2'd3,2'd3,2'd3,2'd3,2'd3,2'd3,2'd3, 2'd3,2'd3,2'd3,2'd3,2'd3,2'd3,2'd3, CRsel_1 = 4'd0; CRsel_2 = 4'd0; CRsel_3 = 4'd0; CRsel_4 = 4'd0; CtrlBitsel = 1'b0; CRIIsel = 1'b0; end if (Gctx === 2'd2) 96 begin TempReg = Ctx2 [0]; MSB = TempReg [7]; LSB = TempReg [6]; RightSource = TempReg [5:3]; LeftSource = TempReg [2:0]; TempReg = Ctx2 <ref> [1] </ref>; MAdd2source = TempReg [3]; MAdd1source = TempReg [2]; TS_Enable = TempReg [1]; CarryPipeline = TempReg [0]; TempReg = Ctx2 [6]; Fa_a = -TempReg [0],Ctx2 [2]-; Fa_b = -TempReg [1], Ctx2 [3]-; Fm_a = -TempReg [2], Ctx2 [4]-; Fm_b = -TempReg [3], Ctx2 [5]-; TempReg = Ctx2 [11]; A_a = -TempReg <p> = 4'd0; CtrlBitsel = 1'b0; CRIIsel = 1'b0; end if (Gctx === 2'd2) 96 begin TempReg = Ctx2 [0]; MSB = TempReg [7]; LSB = TempReg [6]; RightSource = TempReg [5:3]; LeftSource = TempReg [2:0]; TempReg = Ctx2 <ref> [1] </ref>; MAdd2source = TempReg [3]; MAdd1source = TempReg [2]; TS_Enable = TempReg [1]; CarryPipeline = TempReg [0]; TempReg = Ctx2 [6]; Fa_a = -TempReg [0],Ctx2 [2]-; Fa_b = -TempReg [1], Ctx2 [3]-; Fm_a = -TempReg [2], Ctx2 [4]-; Fm_b = -TempReg [3], Ctx2 [5]-; TempReg = Ctx2 [11]; A_a = -TempReg [1:0], Ctx2 [7]-; A_b = -TempReg [3:2], Ctx2 [8]-; B_a = -TempReg <p> Ctx2 [0]; MSB = TempReg [7]; LSB = TempReg [6]; RightSource = TempReg [5:3]; LeftSource = TempReg [2:0]; TempReg = Ctx2 <ref> [1] </ref>; MAdd2source = TempReg [3]; MAdd1source = TempReg [2]; TS_Enable = TempReg [1]; CarryPipeline = TempReg [0]; TempReg = Ctx2 [6]; Fa_a = -TempReg [0],Ctx2 [2]-; Fa_b = -TempReg [1], Ctx2 [3]-; Fm_a = -TempReg [2], Ctx2 [4]-; Fm_b = -TempReg [3], Ctx2 [5]-; TempReg = Ctx2 [11]; A_a = -TempReg [1:0], Ctx2 [7]-; A_b = -TempReg [3:2], Ctx2 [8]-; B_a = -TempReg [5:4], Ctx2 [9]-; B_b = -TempReg [7:6], Ctx2 [10]-; TempReg = Ctx2 [16]; N1_a = -TempReg [1:0], <p> [5:4], Ctx2 [9]-; B_b = -TempReg [7:6], Ctx2 [10]-; TempReg = Ctx2 [16]; N1_a = -TempReg [1:0], Ctx2 [12]-; N1_b = -TempReg [3:2], Ctx2 [13]-; N2_a = -TempReg [5:4], Ctx2 [14]-; N2_b = -TempReg [7:6], Ctx2 [15]-; TempReg = Ctx2 [21]; FP1_a = -TempReg [0], Ctx2 [17]-; FP1_b = -TempReg <ref> [1] </ref>, Ctx2 [18]-; FP2_a = -TempReg [2], Ctx2 [19]-; FP2_b = -TempReg [3], Ctx2 [20]-; TempReg = Ctx2 [22]; L1_Enable = TempReg [3:0]; TempReg = Ctx2 [23]; L2_1 = TempReg [1:0]; L2_2 = TempReg [3:2]; TempReg = Ctx2 [24]; L2_1_Enable = TempReg [1:0]; L2_2_Enable = TempReg [3:2]; TempReg = Ctx2 [25]; <p> [42]; CRII = -TempReg [1:0], Ctx2 [41], Ctx2 [40], Ctx2 [39], Ctx2 [38], Ctx2 [37]-; TempReg = Ctx2 [43]; CRsel_1 = TempReg [3:0]; CRsel_2 = TempReg [7:4]; TempReg = Ctx2 [44]; CRsel_3 = TempReg [3:0]; CRsel_4 = TempReg [7:4]; TempReg = Ctx2 [45]; CtrlBitsel = TempReg [0]; CRIIsel = TempReg <ref> [1] </ref>; end if (Gctx === 2'd3) begin TempReg = Ctx3 [0]; MSB = TempReg [7]; LSB = TempReg [6]; RightSource = TempReg [5:3]; LeftSource = TempReg [2:0]; 98 TempReg = Ctx3 [1]; MAdd2source = TempReg [3]; MAdd1source = TempReg [2]; TS_Enable = TempReg [1]; CarryPipeline = TempReg [0]; TempReg = Ctx3 <p> CRsel_3 = TempReg [3:0]; CRsel_4 = TempReg [7:4]; TempReg = Ctx2 [45]; CtrlBitsel = TempReg [0]; CRIIsel = TempReg <ref> [1] </ref>; end if (Gctx === 2'd3) begin TempReg = Ctx3 [0]; MSB = TempReg [7]; LSB = TempReg [6]; RightSource = TempReg [5:3]; LeftSource = TempReg [2:0]; 98 TempReg = Ctx3 [1]; MAdd2source = TempReg [3]; MAdd1source = TempReg [2]; TS_Enable = TempReg [1]; CarryPipeline = TempReg [0]; TempReg = Ctx3 [6]; Fa_a = -TempReg [0],Ctx3 [2]-; Fa_b = -TempReg [1], Ctx3 [3]-; Fm_a = -TempReg [2], Ctx3 [4]-; Fm_b = -TempReg [3], Ctx3 [5]-; TempReg = Ctx3 [11]; A_a = -TempReg <p> CtrlBitsel = TempReg [0]; CRIIsel = TempReg <ref> [1] </ref>; end if (Gctx === 2'd3) begin TempReg = Ctx3 [0]; MSB = TempReg [7]; LSB = TempReg [6]; RightSource = TempReg [5:3]; LeftSource = TempReg [2:0]; 98 TempReg = Ctx3 [1]; MAdd2source = TempReg [3]; MAdd1source = TempReg [2]; TS_Enable = TempReg [1]; CarryPipeline = TempReg [0]; TempReg = Ctx3 [6]; Fa_a = -TempReg [0],Ctx3 [2]-; Fa_b = -TempReg [1], Ctx3 [3]-; Fm_a = -TempReg [2], Ctx3 [4]-; Fm_b = -TempReg [3], Ctx3 [5]-; TempReg = Ctx3 [11]; A_a = -TempReg [1:0], Ctx3 [7]-; A_b = -TempReg [3:2], Ctx3 [8]-; B_a = -TempReg <p> [0]; MSB = TempReg [7]; LSB = TempReg [6]; RightSource = TempReg [5:3]; LeftSource = TempReg [2:0]; 98 TempReg = Ctx3 <ref> [1] </ref>; MAdd2source = TempReg [3]; MAdd1source = TempReg [2]; TS_Enable = TempReg [1]; CarryPipeline = TempReg [0]; TempReg = Ctx3 [6]; Fa_a = -TempReg [0],Ctx3 [2]-; Fa_b = -TempReg [1], Ctx3 [3]-; Fm_a = -TempReg [2], Ctx3 [4]-; Fm_b = -TempReg [3], Ctx3 [5]-; TempReg = Ctx3 [11]; A_a = -TempReg [1:0], Ctx3 [7]-; A_b = -TempReg [3:2], Ctx3 [8]-; B_a = -TempReg [5:4], Ctx3 [9]-; B_b = -TempReg [7:6], Ctx3 [10]-; TempReg = Ctx3 [16]; N1_a = -TempReg [1:0], <p> [5:4], Ctx3 [9]-; B_b = -TempReg [7:6], Ctx3 [10]-; TempReg = Ctx3 [16]; N1_a = -TempReg [1:0], Ctx3 [12]-; N1_b = -TempReg [3:2], Ctx3 [13]-; N2_a = -TempReg [5:4], Ctx3 [14]-; N2_b = -TempReg [7:6], Ctx3 [15]-; TempReg = Ctx3 [21]; FP1_a = -TempReg [0], Ctx3 [17]-; FP1_b = -TempReg <ref> [1] </ref>, Ctx3 [18]-; FP2_a = -TempReg [2], Ctx3 [19]-; FP2_b = -TempReg [3], Ctx3 [20]-; TempReg = Ctx3 [22]; L1_Enable = TempReg [3:0]; TempReg = Ctx3 [23]; L2_1 = TempReg [1:0]; L2_2 = TempReg [3:2]; TempReg = Ctx3 [24]; L2_1_Enable = TempReg [1:0]; L2_2_Enable = TempReg [3:2]; TempReg = Ctx3 [25]; <p> [42]; CRII = -TempReg [1:0], Ctx3 [41], Ctx3 [40], Ctx3 [39], Ctx3 [38], Ctx3 [37]-; TempReg = Ctx3 [43]; CRsel_1 = TempReg [3:0]; CRsel_2 = TempReg [7:4]; TempReg = Ctx3 [44]; CRsel_3 = TempReg [3:0]; CRsel_4 = TempReg [7:4]; TempReg = Ctx3 [45]; CtrlBitsel = TempReg [0]; CRIIsel = TempReg <ref> [1] </ref>; end end /* Context Changes */ /********************************/ /* Number to CRconfig Converter */ /********************************/ function [5:0] Num2CR; input [2:0] Value; reg [1:0] Out [2:0]; integer i; begin for (i=0;i&lt;3;i=i+1) begin if (Value [i] == 1'b0) 100 Out [i]=2'b01; else Out [i]=2'b10; Num2CR = -Out [2],Out [1],Out [0]-; endfunction endmodule 101 <p> 1'b1)) begin OR_Config = ReadMem [ProgAdd [5:0]]; end /* Program ReadMem */ /*******************/ always @(posedge (CLK) && (PWE === 1'b1)) begin if (ProgAdd [6] === 1'b1) begin ReadMem [ProgAdd [5:0]] = ProgData; /********************/ /* Setup the ORMem */ /********************/ ORMem [0] = -ReadMem [4],ReadMem [3],ReadMem [2], ReadMem <ref> [1] </ref>,ReadMem [0]-; ORMem [1] = -ReadMem [9],ReadMem [8],ReadMem [7], ReadMem [6],ReadMem [5]-; ORMem [2] = -ReadMem [14],ReadMem [13],ReadMem [12], ReadMem [11],ReadMem [10]-; ORMem [3] = -ReadMem [19],ReadMem [18],ReadMem [17], ReadMem [16],ReadMem [15]-; ORMem [4] = -ReadMem [24],ReadMem [23],ReadMem [22], ReadMem [21],ReadMem [20]-; ORMem [5] = -ReadMem [29],ReadMem [28],ReadMem [27], 106 ReadMem [26],ReadMem [25]-; ORMem <p> wire [7:0] FinalData; /* The final, selected and registered data */ 117 reg [7:0] pipeline; /* The optional register */ /*************/ /* Selectors */ /*************/ Sel2 #(8) Sel_A (N1out, N2out, data_A, DRsel [0], start); Sel2 #(8) Sel_B (FP1out, FP2out, data_B, DRsel [0], start); Sel2 #(8) Sel_Data (data_A, data_B, SelData, DRsel <ref> [1] </ref>, start); Sel2 #(8) Sel_Final (SelData, pipeline, FinalData, Enable [0], start); /**********************************/ /* Maintain the Pipeline Register */ /**********************************/ always @(posedge (CLK) or start) begin pipeline = SelData; end /* The Actual Driver */ /*********************/ always @(Enable or start) begin if (Enable [1]===1'b1) assign Out = FinalData; else assign Out = <p> Wires */ /********************************/ wire [7:0] data_A, data_B; /* Intermediate selector data */ wire [7:0] SelData; /* The selected data */ /*************/ /* Selectors */ /*************/ Sel2 #(8) Sel_A (N1out, N2out, data_A, DRsel [0], start); Sel2 #(8) Sel_B (FP1out, FP2out, data_B, DRsel [0], start); Sel2 #(8) Sel_Data (data_A, data_B, SelData, DRsel <ref> [1] </ref>, start); /*******************/ /* Tristate Driver */ /*******************/ Trireg #(8) Driver (SelData, Enable, CLK, start, Out); endmodule 123 /*****************************/ /* Specifications for MAdd.v */ /*****************************/ /* MAdd is the decoder for the Multiplier-Add inputs to a BFU. See TN130 for complete description of this part of MATRIX. <p> Ain_sel, Bin_sel, Data_sel, WEconf, REconf; reg Mode, Ain_sel, Bin_sel, Data_sel, WEconf, REconf; /******************/ /* Begin Decoding */ /******************/ /* Assign the inputs appropriately */ initial begin assign Mode = Fin [5]; assign Ain_sel = Fin [4]; assign Bin_sel = Fin [3]; assign Data_sel = Fin [2]; assign WEconf = Fin <ref> [1] </ref>; assign REconf = Fin [0]; end /* Decoding */ endmodule 141 /*********************************/ /* Specifications for WEdecode.v */ /*********************************/ /* WEdecode decodes the Write Enable for the BFU memory. Its inputs are: WE_Fa, WE_Fm : Write Enables from the ALU and Memory function ports.
Reference: [2] <author> Timothy Bridges. </author> <title> The gpa machine: A generally partitionable msimd architecture. </title> <booktitle> In Proceedings of the Third Symposium on The Frontiers for Massively Parallel Computations, </booktitle> <pages> pages 196-202. </pages> <publisher> IEEE, </publisher> <year> 1990. </year>
Reference-contexts: In order to efficiently deal with these cases a number of architectures, including MSIMD (e.g. <ref> [2] </ref>, [15]) have been developed. These devices allocate control units among a set of processing units. Like MATRIX, these devices can deploy control 74 units as applications require. Unlike MATRIX, the control and processing units are not the same, nor do data and control travel over the same network. <p> CRsel_3 = 4'd0; CRsel_4 = 4'd0; CtrlBitsel = 1'b0; CRIIsel = 1'b0; end if (Gctx === 2'd2) 96 begin TempReg = Ctx2 [0]; MSB = TempReg [7]; LSB = TempReg [6]; RightSource = TempReg [5:3]; LeftSource = TempReg [2:0]; TempReg = Ctx2 [1]; MAdd2source = TempReg [3]; MAdd1source = TempReg <ref> [2] </ref>; TS_Enable = TempReg [1]; CarryPipeline = TempReg [0]; TempReg = Ctx2 [6]; Fa_a = -TempReg [0],Ctx2 [2]-; Fa_b = -TempReg [1], Ctx2 [3]-; Fm_a = -TempReg [2], Ctx2 [4]-; Fm_b = -TempReg [3], Ctx2 [5]-; TempReg = Ctx2 [11]; A_a = -TempReg [1:0], Ctx2 [7]-; A_b = -TempReg [3:2], Ctx2 <p> 96 begin TempReg = Ctx2 [0]; MSB = TempReg [7]; LSB = TempReg [6]; RightSource = TempReg [5:3]; LeftSource = TempReg [2:0]; TempReg = Ctx2 [1]; MAdd2source = TempReg [3]; MAdd1source = TempReg <ref> [2] </ref>; TS_Enable = TempReg [1]; CarryPipeline = TempReg [0]; TempReg = Ctx2 [6]; Fa_a = -TempReg [0],Ctx2 [2]-; Fa_b = -TempReg [1], Ctx2 [3]-; Fm_a = -TempReg [2], Ctx2 [4]-; Fm_b = -TempReg [3], Ctx2 [5]-; TempReg = Ctx2 [11]; A_a = -TempReg [1:0], Ctx2 [7]-; A_b = -TempReg [3:2], Ctx2 [8]-; B_a = -TempReg [5:4], Ctx2 [9]-; B_b = -TempReg [7:6], Ctx2 [10]-; TempReg = Ctx2 [16]; <p> LSB = TempReg [6]; RightSource = TempReg [5:3]; LeftSource = TempReg [2:0]; TempReg = Ctx2 [1]; MAdd2source = TempReg [3]; MAdd1source = TempReg <ref> [2] </ref>; TS_Enable = TempReg [1]; CarryPipeline = TempReg [0]; TempReg = Ctx2 [6]; Fa_a = -TempReg [0],Ctx2 [2]-; Fa_b = -TempReg [1], Ctx2 [3]-; Fm_a = -TempReg [2], Ctx2 [4]-; Fm_b = -TempReg [3], Ctx2 [5]-; TempReg = Ctx2 [11]; A_a = -TempReg [1:0], Ctx2 [7]-; A_b = -TempReg [3:2], Ctx2 [8]-; B_a = -TempReg [5:4], Ctx2 [9]-; B_b = -TempReg [7:6], Ctx2 [10]-; TempReg = Ctx2 [16]; N1_a = -TempReg [1:0], Ctx2 [12]-; N1_b = -TempReg [3:2], <p> [7:6], Ctx2 [10]-; TempReg = Ctx2 [16]; N1_a = -TempReg [1:0], Ctx2 [12]-; N1_b = -TempReg [3:2], Ctx2 [13]-; N2_a = -TempReg [5:4], Ctx2 [14]-; N2_b = -TempReg [7:6], Ctx2 [15]-; TempReg = Ctx2 [21]; FP1_a = -TempReg [0], Ctx2 [17]-; FP1_b = -TempReg [1], Ctx2 [18]-; FP2_a = -TempReg <ref> [2] </ref>, Ctx2 [19]-; FP2_b = -TempReg [3], Ctx2 [20]-; TempReg = Ctx2 [22]; L1_Enable = TempReg [3:0]; TempReg = Ctx2 [23]; L2_1 = TempReg [1:0]; L2_2 = TempReg [3:2]; TempReg = Ctx2 [24]; L2_1_Enable = TempReg [1:0]; L2_2_Enable = TempReg [3:2]; TempReg = Ctx2 [25]; L3_V1 = TempReg [1:0]; L3_V2 = <p> TempReg = Ctx2 [45]; CtrlBitsel = TempReg [0]; CRIIsel = TempReg [1]; end if (Gctx === 2'd3) begin TempReg = Ctx3 [0]; MSB = TempReg [7]; LSB = TempReg [6]; RightSource = TempReg [5:3]; LeftSource = TempReg [2:0]; 98 TempReg = Ctx3 [1]; MAdd2source = TempReg [3]; MAdd1source = TempReg <ref> [2] </ref>; TS_Enable = TempReg [1]; CarryPipeline = TempReg [0]; TempReg = Ctx3 [6]; Fa_a = -TempReg [0],Ctx3 [2]-; Fa_b = -TempReg [1], Ctx3 [3]-; Fm_a = -TempReg [2], Ctx3 [4]-; Fm_b = -TempReg [3], Ctx3 [5]-; TempReg = Ctx3 [11]; A_a = -TempReg [1:0], Ctx3 [7]-; A_b = -TempReg [3:2], Ctx3 <p> begin TempReg = Ctx3 [0]; MSB = TempReg [7]; LSB = TempReg [6]; RightSource = TempReg [5:3]; LeftSource = TempReg [2:0]; 98 TempReg = Ctx3 [1]; MAdd2source = TempReg [3]; MAdd1source = TempReg <ref> [2] </ref>; TS_Enable = TempReg [1]; CarryPipeline = TempReg [0]; TempReg = Ctx3 [6]; Fa_a = -TempReg [0],Ctx3 [2]-; Fa_b = -TempReg [1], Ctx3 [3]-; Fm_a = -TempReg [2], Ctx3 [4]-; Fm_b = -TempReg [3], Ctx3 [5]-; TempReg = Ctx3 [11]; A_a = -TempReg [1:0], Ctx3 [7]-; A_b = -TempReg [3:2], Ctx3 [8]-; B_a = -TempReg [5:4], Ctx3 [9]-; B_b = -TempReg [7:6], Ctx3 [10]-; TempReg = Ctx3 [16]; <p> = TempReg [6]; RightSource = TempReg [5:3]; LeftSource = TempReg [2:0]; 98 TempReg = Ctx3 [1]; MAdd2source = TempReg [3]; MAdd1source = TempReg <ref> [2] </ref>; TS_Enable = TempReg [1]; CarryPipeline = TempReg [0]; TempReg = Ctx3 [6]; Fa_a = -TempReg [0],Ctx3 [2]-; Fa_b = -TempReg [1], Ctx3 [3]-; Fm_a = -TempReg [2], Ctx3 [4]-; Fm_b = -TempReg [3], Ctx3 [5]-; TempReg = Ctx3 [11]; A_a = -TempReg [1:0], Ctx3 [7]-; A_b = -TempReg [3:2], Ctx3 [8]-; B_a = -TempReg [5:4], Ctx3 [9]-; B_b = -TempReg [7:6], Ctx3 [10]-; TempReg = Ctx3 [16]; N1_a = -TempReg [1:0], Ctx3 [12]-; N1_b = -TempReg [3:2], <p> [7:6], Ctx3 [10]-; TempReg = Ctx3 [16]; N1_a = -TempReg [1:0], Ctx3 [12]-; N1_b = -TempReg [3:2], Ctx3 [13]-; N2_a = -TempReg [5:4], Ctx3 [14]-; N2_b = -TempReg [7:6], Ctx3 [15]-; TempReg = Ctx3 [21]; FP1_a = -TempReg [0], Ctx3 [17]-; FP1_b = -TempReg [1], Ctx3 [18]-; FP2_a = -TempReg <ref> [2] </ref>, Ctx3 [19]-; FP2_b = -TempReg [3], Ctx3 [20]-; TempReg = Ctx3 [22]; L1_Enable = TempReg [3:0]; TempReg = Ctx3 [23]; L2_1 = TempReg [1:0]; L2_2 = TempReg [3:2]; TempReg = Ctx3 [24]; L2_1_Enable = TempReg [1:0]; L2_2_Enable = TempReg [3:2]; TempReg = Ctx3 [25]; L3_V1 = TempReg [1:0]; L3_V2 = <p> @(posedge (CLK) && (PRE === 1'b1)) begin OR_Config = ReadMem [ProgAdd [5:0]]; end /* Program ReadMem */ /*******************/ always @(posedge (CLK) && (PWE === 1'b1)) begin if (ProgAdd [6] === 1'b1) begin ReadMem [ProgAdd [5:0]] = ProgData; /********************/ /* Setup the ORMem */ /********************/ ORMem [0] = -ReadMem [4],ReadMem [3],ReadMem <ref> [2] </ref>, ReadMem [1],ReadMem [0]-; ORMem [1] = -ReadMem [9],ReadMem [8],ReadMem [7], ReadMem [6],ReadMem [5]-; ORMem [2] = -ReadMem [14],ReadMem [13],ReadMem [12], ReadMem [11],ReadMem [10]-; ORMem [3] = -ReadMem [19],ReadMem [18],ReadMem [17], ReadMem [16],ReadMem [15]-; ORMem [4] = -ReadMem [24],ReadMem [23],ReadMem [22], ReadMem [21],ReadMem [20]-; ORMem [5] = -ReadMem [29],ReadMem [28],ReadMem [27], <p> ReadMem */ /*******************/ always @(posedge (CLK) && (PWE === 1'b1)) begin if (ProgAdd [6] === 1'b1) begin ReadMem [ProgAdd [5:0]] = ProgData; /********************/ /* Setup the ORMem */ /********************/ ORMem [0] = -ReadMem [4],ReadMem [3],ReadMem <ref> [2] </ref>, ReadMem [1],ReadMem [0]-; ORMem [1] = -ReadMem [9],ReadMem [8],ReadMem [7], ReadMem [6],ReadMem [5]-; ORMem [2] = -ReadMem [14],ReadMem [13],ReadMem [12], ReadMem [11],ReadMem [10]-; ORMem [3] = -ReadMem [19],ReadMem [18],ReadMem [17], ReadMem [16],ReadMem [15]-; ORMem [4] = -ReadMem [24],ReadMem [23],ReadMem [22], ReadMem [21],ReadMem [20]-; ORMem [5] = -ReadMem [29],ReadMem [28],ReadMem [27], 106 ReadMem [26],ReadMem [25]-; ORMem [6] = -ReadMem [34],ReadMem [33],ReadMem [32], ReadMem [31],ReadMem [30]-; ORMem <p> */ /***********************/ initial begin $async$or$array (ORMem, -~Data [19],Data [19],~Data [18],Data [18], ~Data [17],Data [17],~Data [16],Data [16], ~Data [15],Data [15],~Data [14],Data [14], ~Data [13],Data [13],~Data [12],Data [12], ~Data [11],Data [11],~Data [10],Data [10], ~Data [9],Data [9],~Data [8],Data [8], ~Data [7],Data [7],~Data [6],Data [6], ~Data [5],Data [5],~Data [4],Data [4], ~Data [3],Data [3],~Data <ref> [2] </ref>,Data [2], ~Data [1],Data [1],~Data [0],Data [0]-, -OR_out [8],OR_out [7],OR_out [6],OR_out [5], OR_out [0]-); /*******************/ /* Output Selector */ /*******************/ Sel2 #(9) OutSel (9'b0,OR_out,Out,Gctx [1],start); endmodule 107 /* The following is necessary because this file may be read from many inlcude statements and should be ignored on all but the first */ <p> input [7:0] Fin; output Mode, Ain_sel, Bin_sel, Data_sel, WEconf, REconf; reg Mode, Ain_sel, Bin_sel, Data_sel, WEconf, REconf; /******************/ /* Begin Decoding */ /******************/ /* Assign the inputs appropriately */ initial begin assign Mode = Fin [5]; assign Ain_sel = Fin [4]; assign Bin_sel = Fin [3]; assign Data_sel = Fin <ref> [2] </ref>; assign WEconf = Fin [1]; assign REconf = Fin [0]; end /* Decoding */ endmodule 141 /*********************************/ /* Specifications for WEdecode.v */ /*********************************/ /* WEdecode decodes the Write Enable for the BFU memory. Its inputs are: WE_Fa, WE_Fm : Write Enables from the ALU and Memory function ports.
Reference: [3] <author> Dev C. Chen and Jan M. Rabaey. </author> <title> A reconfigurable multiprocessor ic for rapid prototyping of algorithmic-specific high-speed dsp data paths. </title> <journal> IEEE Journal of Solid-State Circuits, </journal> <volume> 27(12) </volume> <pages> 1895-1904, </pages> <month> December </month> <year> 1992. </year>
Reference-contexts: Instruction Memory per Stream Datapath Granularity Architecture/Examples 0 0 n/a Hardwired Functional Unit 0 1 FPGA, Programmable Cellular Automata n 1 w reconfigurable ALUs Programmable Systolic Datapath Arrays n 1 bitwise SIMD 1 c w Traditional Processors n w Vector Processors 1 c 1 DPGA [20] n 8 16 PADDI <ref> [3] </ref> c w VLIW m 1 c n m w MSIMD c 1 VEGA [11] n 1 8 16 PADDI-2 [22] c w MIMD (traditional) Where: n is the number of processors w is the width of a single processor m is the number of program counters (PCs) c is the <p> A single program counter (PC) controls three separate instruction streams. As discussed in Chapter 2, these designs generally provide more processing power per unit area than MIMD machines, but do not have the same control flexibility. Various architectures, such as PADDI <ref> [3] </ref> choose a granularity (16 for PADDI), 1 VEGA actually has multiple program counters and therefore functions as a MIMD machine. 73 and a instruction memory size (8 for PADDI). <p> 4'd0; CRsel_2 = 4'd0; CRsel_3 = 4'd0; CRsel_4 = 4'd0; CtrlBitsel = 1'b0; CRIIsel = 1'b0; end if (Gctx === 2'd2) 96 begin TempReg = Ctx2 [0]; MSB = TempReg [7]; LSB = TempReg [6]; RightSource = TempReg [5:3]; LeftSource = TempReg [2:0]; TempReg = Ctx2 [1]; MAdd2source = TempReg <ref> [3] </ref>; MAdd1source = TempReg [2]; TS_Enable = TempReg [1]; CarryPipeline = TempReg [0]; TempReg = Ctx2 [6]; Fa_a = -TempReg [0],Ctx2 [2]-; Fa_b = -TempReg [1], Ctx2 [3]-; Fm_a = -TempReg [2], Ctx2 [4]-; Fm_b = -TempReg [3], Ctx2 [5]-; TempReg = Ctx2 [11]; A_a = -TempReg [1:0], Ctx2 [7]-; A_b <p> MSB = TempReg [7]; LSB = TempReg [6]; RightSource = TempReg [5:3]; LeftSource = TempReg [2:0]; TempReg = Ctx2 [1]; MAdd2source = TempReg <ref> [3] </ref>; MAdd1source = TempReg [2]; TS_Enable = TempReg [1]; CarryPipeline = TempReg [0]; TempReg = Ctx2 [6]; Fa_a = -TempReg [0],Ctx2 [2]-; Fa_b = -TempReg [1], Ctx2 [3]-; Fm_a = -TempReg [2], Ctx2 [4]-; Fm_b = -TempReg [3], Ctx2 [5]-; TempReg = Ctx2 [11]; A_a = -TempReg [1:0], Ctx2 [7]-; A_b = -TempReg [3:2], Ctx2 [8]-; B_a = -TempReg [5:4], Ctx2 [9]-; B_b = -TempReg [7:6], Ctx2 [10]-; TempReg = Ctx2 [16]; N1_a = -TempReg [1:0], Ctx2 [12]-; <p> TempReg [5:3]; LeftSource = TempReg [2:0]; TempReg = Ctx2 [1]; MAdd2source = TempReg <ref> [3] </ref>; MAdd1source = TempReg [2]; TS_Enable = TempReg [1]; CarryPipeline = TempReg [0]; TempReg = Ctx2 [6]; Fa_a = -TempReg [0],Ctx2 [2]-; Fa_b = -TempReg [1], Ctx2 [3]-; Fm_a = -TempReg [2], Ctx2 [4]-; Fm_b = -TempReg [3], Ctx2 [5]-; TempReg = Ctx2 [11]; A_a = -TempReg [1:0], Ctx2 [7]-; A_b = -TempReg [3:2], Ctx2 [8]-; B_a = -TempReg [5:4], Ctx2 [9]-; B_b = -TempReg [7:6], Ctx2 [10]-; TempReg = Ctx2 [16]; N1_a = -TempReg [1:0], Ctx2 [12]-; N1_b = -TempReg [3:2], Ctx2 [13]-; N2_a = -TempReg [5:4], <p> [16]; N1_a = -TempReg [1:0], Ctx2 [12]-; N1_b = -TempReg [3:2], Ctx2 [13]-; N2_a = -TempReg [5:4], Ctx2 [14]-; N2_b = -TempReg [7:6], Ctx2 [15]-; TempReg = Ctx2 [21]; FP1_a = -TempReg [0], Ctx2 [17]-; FP1_b = -TempReg [1], Ctx2 [18]-; FP2_a = -TempReg [2], Ctx2 [19]-; FP2_b = -TempReg <ref> [3] </ref>, Ctx2 [20]-; TempReg = Ctx2 [22]; L1_Enable = TempReg [3:0]; TempReg = Ctx2 [23]; L2_1 = TempReg [1:0]; L2_2 = TempReg [3:2]; TempReg = Ctx2 [24]; L2_1_Enable = TempReg [1:0]; L2_2_Enable = TempReg [3:2]; TempReg = Ctx2 [25]; L3_V1 = TempReg [1:0]; L3_V2 = TempReg [3:2]; L3_V3 = TempReg [5:4]; <p> CRsel_4 = TempReg [7:4]; TempReg = Ctx2 [45]; CtrlBitsel = TempReg [0]; CRIIsel = TempReg [1]; end if (Gctx === 2'd3) begin TempReg = Ctx3 [0]; MSB = TempReg [7]; LSB = TempReg [6]; RightSource = TempReg [5:3]; LeftSource = TempReg [2:0]; 98 TempReg = Ctx3 [1]; MAdd2source = TempReg <ref> [3] </ref>; MAdd1source = TempReg [2]; TS_Enable = TempReg [1]; CarryPipeline = TempReg [0]; TempReg = Ctx3 [6]; Fa_a = -TempReg [0],Ctx3 [2]-; Fa_b = -TempReg [1], Ctx3 [3]-; Fm_a = -TempReg [2], Ctx3 [4]-; Fm_b = -TempReg [3], Ctx3 [5]-; TempReg = Ctx3 [11]; A_a = -TempReg [1:0], Ctx3 [7]-; A_b <p> = TempReg [7]; LSB = TempReg [6]; RightSource = TempReg [5:3]; LeftSource = TempReg [2:0]; 98 TempReg = Ctx3 [1]; MAdd2source = TempReg <ref> [3] </ref>; MAdd1source = TempReg [2]; TS_Enable = TempReg [1]; CarryPipeline = TempReg [0]; TempReg = Ctx3 [6]; Fa_a = -TempReg [0],Ctx3 [2]-; Fa_b = -TempReg [1], Ctx3 [3]-; Fm_a = -TempReg [2], Ctx3 [4]-; Fm_b = -TempReg [3], Ctx3 [5]-; TempReg = Ctx3 [11]; A_a = -TempReg [1:0], Ctx3 [7]-; A_b = -TempReg [3:2], Ctx3 [8]-; B_a = -TempReg [5:4], Ctx3 [9]-; B_b = -TempReg [7:6], Ctx3 [10]-; TempReg = Ctx3 [16]; N1_a = -TempReg [1:0], Ctx3 [12]-; <p> [5:3]; LeftSource = TempReg [2:0]; 98 TempReg = Ctx3 [1]; MAdd2source = TempReg <ref> [3] </ref>; MAdd1source = TempReg [2]; TS_Enable = TempReg [1]; CarryPipeline = TempReg [0]; TempReg = Ctx3 [6]; Fa_a = -TempReg [0],Ctx3 [2]-; Fa_b = -TempReg [1], Ctx3 [3]-; Fm_a = -TempReg [2], Ctx3 [4]-; Fm_b = -TempReg [3], Ctx3 [5]-; TempReg = Ctx3 [11]; A_a = -TempReg [1:0], Ctx3 [7]-; A_b = -TempReg [3:2], Ctx3 [8]-; B_a = -TempReg [5:4], Ctx3 [9]-; B_b = -TempReg [7:6], Ctx3 [10]-; TempReg = Ctx3 [16]; N1_a = -TempReg [1:0], Ctx3 [12]-; N1_b = -TempReg [3:2], Ctx3 [13]-; N2_a = -TempReg [5:4], <p> [16]; N1_a = -TempReg [1:0], Ctx3 [12]-; N1_b = -TempReg [3:2], Ctx3 [13]-; N2_a = -TempReg [5:4], Ctx3 [14]-; N2_b = -TempReg [7:6], Ctx3 [15]-; TempReg = Ctx3 [21]; FP1_a = -TempReg [0], Ctx3 [17]-; FP1_b = -TempReg [1], Ctx3 [18]-; FP2_a = -TempReg [2], Ctx3 [19]-; FP2_b = -TempReg <ref> [3] </ref>, Ctx3 [20]-; TempReg = Ctx3 [22]; L1_Enable = TempReg [3:0]; TempReg = Ctx3 [23]; L2_1 = TempReg [1:0]; L2_2 = TempReg [3:2]; TempReg = Ctx3 [24]; L2_1_Enable = TempReg [1:0]; L2_2_Enable = TempReg [3:2]; TempReg = Ctx3 [25]; L3_V1 = TempReg [1:0]; L3_V2 = TempReg [3:2]; L3_V3 = TempReg [5:4]; <p> begin if (ProgAdd [6] === 1'b1) begin ReadMem [ProgAdd [5:0]] = ProgData; /********************/ /* Setup the ORMem */ /********************/ ORMem [0] = -ReadMem [4],ReadMem <ref> [3] </ref>,ReadMem [2], ReadMem [1],ReadMem [0]-; ORMem [1] = -ReadMem [9],ReadMem [8],ReadMem [7], ReadMem [6],ReadMem [5]-; ORMem [2] = -ReadMem [14],ReadMem [13],ReadMem [12], ReadMem [11],ReadMem [10]-; ORMem [3] = -ReadMem [19],ReadMem [18],ReadMem [17], ReadMem [16],ReadMem [15]-; ORMem [4] = -ReadMem [24],ReadMem [23],ReadMem [22], ReadMem [21],ReadMem [20]-; ORMem [5] = -ReadMem [29],ReadMem [28],ReadMem [27], 106 ReadMem [26],ReadMem [25]-; ORMem [6] = -ReadMem [34],ReadMem [33],ReadMem [32], ReadMem [31],ReadMem [30]-; ORMem [7] = -ReadMem [39],ReadMem [38],ReadMem [37], ReadMem [36],ReadMem [35]-; ORMem <p> Ain_sel, Bin_sel, Data_sel, WEconf, REconf); input [7:0] Fin; output Mode, Ain_sel, Bin_sel, Data_sel, WEconf, REconf; reg Mode, Ain_sel, Bin_sel, Data_sel, WEconf, REconf; /******************/ /* Begin Decoding */ /******************/ /* Assign the inputs appropriately */ initial begin assign Mode = Fin [5]; assign Ain_sel = Fin [4]; assign Bin_sel = Fin <ref> [3] </ref>; assign Data_sel = Fin [2]; assign WEconf = Fin [1]; assign REconf = Fin [0]; end /* Decoding */ endmodule 141 /*********************************/ /* Specifications for WEdecode.v */ /*********************************/ /* WEdecode decodes the Write Enable for the BFU memory.
Reference: [4] <author> Chi-Jui Chou, Satish Mohanakrishnan, and Joseph B. Evans. </author> <title> Fpga implementation of digital filters. </title> <booktitle> In International Conference on Signal Processing Applications and Technology, </booktitle> <year> 1993. </year>
Reference-contexts: This design would be a hybrid between the systolic implementation and the microcoded example in Section 8.3. 59 Device MATRIX FPGA (XC4K) Reference ICSPAT93 <ref> [4] </ref> App. <p> Note [8] 64 CLBs, 184 ns/16-TAPs y 1.0 ICSPAT93 <ref> [4] </ref> 400 CLBs, 100ns/4-TAPs 0.080 PADDI2 ISSCC95 [22] 5 EXUs, 20ns/TAP 0.93 Full Custom JSSC89 [16] 45ns/64-TAPs z 6.1 JSSC90 [7] 33ns/16-TAPs 3.5 y symmetric filter; z - 24-bit accum. <p> TempReg [6]; RightSource = TempReg [5:3]; LeftSource = TempReg [2:0]; TempReg = Ctx2 [1]; MAdd2source = TempReg [3]; MAdd1source = TempReg [2]; TS_Enable = TempReg [1]; CarryPipeline = TempReg [0]; TempReg = Ctx2 [6]; Fa_a = -TempReg [0],Ctx2 [2]-; Fa_b = -TempReg [1], Ctx2 [3]-; Fm_a = -TempReg [2], Ctx2 <ref> [4] </ref>-; Fm_b = -TempReg [3], Ctx2 [5]-; TempReg = Ctx2 [11]; A_a = -TempReg [1:0], Ctx2 [7]-; A_b = -TempReg [3:2], Ctx2 [8]-; B_a = -TempReg [5:4], Ctx2 [9]-; B_b = -TempReg [7:6], Ctx2 [10]-; TempReg = Ctx2 [16]; N1_a = -TempReg [1:0], Ctx2 [12]-; N1_b = -TempReg [3:2], Ctx2 [13]-; <p> [6]; RightSource = TempReg [5:3]; LeftSource = TempReg [2:0]; 98 TempReg = Ctx3 [1]; MAdd2source = TempReg [3]; MAdd1source = TempReg [2]; TS_Enable = TempReg [1]; CarryPipeline = TempReg [0]; TempReg = Ctx3 [6]; Fa_a = -TempReg [0],Ctx3 [2]-; Fa_b = -TempReg [1], Ctx3 [3]-; Fm_a = -TempReg [2], Ctx3 <ref> [4] </ref>-; Fm_b = -TempReg [3], Ctx3 [5]-; TempReg = Ctx3 [11]; A_a = -TempReg [1:0], Ctx3 [7]-; A_b = -TempReg [3:2], Ctx3 [8]-; B_a = -TempReg [5:4], Ctx3 [9]-; B_b = -TempReg [7:6], Ctx3 [10]-; TempReg = Ctx3 [16]; N1_a = -TempReg [1:0], Ctx3 [12]-; N1_b = -TempReg [3:2], Ctx3 [13]-; <p> = ProgData; /********************/ /* Setup the ORMem */ /********************/ ORMem [0] = -ReadMem <ref> [4] </ref>,ReadMem [3],ReadMem [2], ReadMem [1],ReadMem [0]-; ORMem [1] = -ReadMem [9],ReadMem [8],ReadMem [7], ReadMem [6],ReadMem [5]-; ORMem [2] = -ReadMem [14],ReadMem [13],ReadMem [12], ReadMem [11],ReadMem [10]-; ORMem [3] = -ReadMem [19],ReadMem [18],ReadMem [17], ReadMem [16],ReadMem [15]-; ORMem [4] = -ReadMem [24],ReadMem [23],ReadMem [22], ReadMem [21],ReadMem [20]-; ORMem [5] = -ReadMem [29],ReadMem [28],ReadMem [27], 106 ReadMem [26],ReadMem [25]-; ORMem [6] = -ReadMem [34],ReadMem [33],ReadMem [32], ReadMem [31],ReadMem [30]-; ORMem [7] = -ReadMem [39],ReadMem [38],ReadMem [37], ReadMem [36],ReadMem [35]-; ORMem [8] = -ReadMem [44],ReadMem [43],ReadMem [42], ReadMem [41],ReadMem [40]-; end <p> /* Define the OR Plane */ /***********************/ initial begin $async$or$array (ORMem, -~Data [19],Data [19],~Data [18],Data [18], ~Data [17],Data [17],~Data [16],Data [16], ~Data [15],Data [15],~Data [14],Data [14], ~Data [13],Data [13],~Data [12],Data [12], ~Data [11],Data [11],~Data [10],Data [10], ~Data [9],Data [9],~Data [8],Data [8], ~Data [7],Data [7],~Data [6],Data [6], ~Data [5],Data [5],~Data <ref> [4] </ref>,Data [4], ~Data [3],Data [3],~Data [2],Data [2], ~Data [1],Data [1],~Data [0],Data [0]-, -OR_out [8],OR_out [7],OR_out [6],OR_out [5], OR_out [0]-); /*******************/ /* Output Selector */ /*******************/ Sel2 #(9) OutSel (9'b0,OR_out,Out,Gctx [1],start); endmodule 107 /* The following is necessary because this file may be read from many inlcude statements and should be ignored on <p> ShiftAL = 1'b0; 134 ShiftBR = 1'b0; ShiftBL = 1'b0; ADD = 1'b0; MULT = 1'b0; MULTA = 1'b0; MULTAA = 1'b0; MULTcont = 1'b0; assign CinALU = 1'b0; /* Default Cin */ /* Decode the function */ case (Fin [3:0]) 4'd0: begin MULT = 1'b1; assign InvertA = Fin <ref> [4] </ref>; assign InvertB = Fin [5]; end begin MULTA = 1'b1; assign InvertA = Fin [4]; assign InvertB = Fin [5]; end begin MULTAA = 1'b1; assign InvertA = Fin [4]; assign InvertB = Fin [5]; end begin MULTcont = 1'b1; assign InvertA = Fin [4]; assign InvertB = Fin [5]; <p> 1'b0; MULTA = 1'b0; MULTAA = 1'b0; MULTcont = 1'b0; assign CinALU = 1'b0; /* Default Cin */ /* Decode the function */ case (Fin [3:0]) 4'd0: begin MULT = 1'b1; assign InvertA = Fin <ref> [4] </ref>; assign InvertB = Fin [5]; end begin MULTA = 1'b1; assign InvertA = Fin [4]; assign InvertB = Fin [5]; end begin MULTAA = 1'b1; assign InvertA = Fin [4]; assign InvertB = Fin [5]; end begin MULTcont = 1'b1; assign InvertA = Fin [4]; assign InvertB = Fin [5]; end 4'd4: /* Shift with Force-Carry */ begin assign InvertA = 1'b0; assign InvertB = <p> Default Cin */ /* Decode the function */ case (Fin [3:0]) 4'd0: begin MULT = 1'b1; assign InvertA = Fin <ref> [4] </ref>; assign InvertB = Fin [5]; end begin MULTA = 1'b1; assign InvertA = Fin [4]; assign InvertB = Fin [5]; end begin MULTAA = 1'b1; assign InvertA = Fin [4]; assign InvertB = Fin [5]; end begin MULTcont = 1'b1; assign InvertA = Fin [4]; assign InvertB = Fin [5]; end 4'd4: /* Shift with Force-Carry */ begin assign InvertA = 1'b0; assign InvertB = 1'b0; case (Fin [5:4]) 2'b00: begin ShiftAR = 1'b1; assign CinALU = CinL; end begin <p> 1'b1; assign InvertA = Fin <ref> [4] </ref>; assign InvertB = Fin [5]; end begin MULTA = 1'b1; assign InvertA = Fin [4]; assign InvertB = Fin [5]; end begin MULTAA = 1'b1; assign InvertA = Fin [4]; assign InvertB = Fin [5]; end begin MULTcont = 1'b1; assign InvertA = Fin [4]; assign InvertB = Fin [5]; end 4'd4: /* Shift with Force-Carry */ begin assign InvertA = 1'b0; assign InvertB = 1'b0; case (Fin [5:4]) 2'b00: begin ShiftAR = 1'b1; assign CinALU = CinL; end begin ShiftBR = 1'b1; assign CinALU = CinL; end begin 135 ShiftAL = 1'b1; assign CinALU <p> = 1'b1; assign CinALU = ((MSB && 1'b1) || (~MSB && CinL)); end begin ShiftAL = 1'b1; assign CinALU = ((LSB && 1'b1) || (~LSB && CinR)); end begin ShiftBL = 1'b1; assign CinALU = ((LSB && 1'b1) || (~LSB && CinR)); end endcase end begin assign InvertA = Fin <ref> [4] </ref>; assign InvertB = Fin [5]; ADD = 1'b1; assign CinALU = CinR; end begin assign InvertA = Fin [4]; assign InvertB = Fin [5]; ADD = 1'b1; assign CinALU = ((LSB && 1'b0) || (~LSB && CinR)); end begin 137 assign InvertA = Fin [4]; assign InvertB = Fin [5]; <p> = ((LSB && 1'b1) || (~LSB && CinR)); end begin ShiftBL = 1'b1; assign CinALU = ((LSB && 1'b1) || (~LSB && CinR)); end endcase end begin assign InvertA = Fin <ref> [4] </ref>; assign InvertB = Fin [5]; ADD = 1'b1; assign CinALU = CinR; end begin assign InvertA = Fin [4]; assign InvertB = Fin [5]; ADD = 1'b1; assign CinALU = ((LSB && 1'b0) || (~LSB && CinR)); end begin 137 assign InvertA = Fin [4]; assign InvertB = Fin [5]; ADD = 1'b1; assign CinALU = ((LSB && 1'b1) || (~LSB && CinR)); end 4'd11: /* Unusued Opcode Treat <p> begin assign InvertA = Fin <ref> [4] </ref>; assign InvertB = Fin [5]; ADD = 1'b1; assign CinALU = CinR; end begin assign InvertA = Fin [4]; assign InvertB = Fin [5]; ADD = 1'b1; assign CinALU = ((LSB && 1'b0) || (~LSB && CinR)); end begin 137 assign InvertA = Fin [4]; assign InvertB = Fin [5]; ADD = 1'b1; assign CinALU = ((LSB && 1'b1) || (~LSB && CinR)); end 4'd11: /* Unusued Opcode Treat as an Add-1 */ begin assign InvertA = Fin [4]; assign InvertB = Fin [5]; ADD = 1'b1; assign CinALU = ((LSB && 1'b1) || (~LSB <p> CinALU = ((LSB && 1'b0) || (~LSB && CinR)); end begin 137 assign InvertA = Fin <ref> [4] </ref>; assign InvertB = Fin [5]; ADD = 1'b1; assign CinALU = ((LSB && 1'b1) || (~LSB && CinR)); end 4'd11: /* Unusued Opcode Treat as an Add-1 */ begin assign InvertA = Fin [4]; assign InvertB = Fin [5]; ADD = 1'b1; assign CinALU = ((LSB && 1'b1) || (~LSB && CinR)); end 4'd12: /* Pass */ begin if (Fin [5]==1'b1) begin B_Pass = 1'b1; assign InvertA = 1'b0; assign InvertB = Fin [4]; end else begin A_Pass = 1'b1; assign InvertA = Fin <p> Treat as an Add-1 */ begin assign InvertA = Fin <ref> [4] </ref>; assign InvertB = Fin [5]; ADD = 1'b1; assign CinALU = ((LSB && 1'b1) || (~LSB && CinR)); end 4'd12: /* Pass */ begin if (Fin [5]==1'b1) begin B_Pass = 1'b1; assign InvertA = 1'b0; assign InvertB = Fin [4]; end else begin A_Pass = 1'b1; assign InvertA = Fin [4]; assign InvertB = 1'b0; end 4'd13: begin NAND = 1'b1; assign InvertA = Fin [4]; assign InvertB = Fin [5]; end begin NOR = 1'b1; assign InvertA = Fin [4]; assign InvertB = Fin [5]; end begin XOR = <p> assign InvertB = Fin [5]; ADD = 1'b1; assign CinALU = ((LSB && 1'b1) || (~LSB && CinR)); end 4'd12: /* Pass */ begin if (Fin [5]==1'b1) begin B_Pass = 1'b1; assign InvertA = 1'b0; assign InvertB = Fin <ref> [4] </ref>; end else begin A_Pass = 1'b1; assign InvertA = Fin [4]; assign InvertB = 1'b0; end 4'd13: begin NAND = 1'b1; assign InvertA = Fin [4]; assign InvertB = Fin [5]; end begin NOR = 1'b1; assign InvertA = Fin [4]; assign InvertB = Fin [5]; end begin XOR = 1'b1; assign InvertA = Fin [4]; assign InvertB = Fin [5]; <p> (~LSB && CinR)); end 4'd12: /* Pass */ begin if (Fin [5]==1'b1) begin B_Pass = 1'b1; assign InvertA = 1'b0; assign InvertB = Fin <ref> [4] </ref>; end else begin A_Pass = 1'b1; assign InvertA = Fin [4]; assign InvertB = 1'b0; end 4'd13: begin NAND = 1'b1; assign InvertA = Fin [4]; assign InvertB = Fin [5]; end begin NOR = 1'b1; assign InvertA = Fin [4]; assign InvertB = Fin [5]; end begin XOR = 1'b1; assign InvertA = Fin [4]; assign InvertB = Fin [5]; end endcase end /* Decode */ endmodule 138 /*************************/ /* Specifications: MEM.v */ /*************************/ /* <p> 1'b1; assign InvertA = 1'b0; assign InvertB = Fin <ref> [4] </ref>; end else begin A_Pass = 1'b1; assign InvertA = Fin [4]; assign InvertB = 1'b0; end 4'd13: begin NAND = 1'b1; assign InvertA = Fin [4]; assign InvertB = Fin [5]; end begin NOR = 1'b1; assign InvertA = Fin [4]; assign InvertB = Fin [5]; end begin XOR = 1'b1; assign InvertA = Fin [4]; assign InvertB = Fin [5]; end endcase end /* Decode */ endmodule 138 /*************************/ /* Specifications: MEM.v */ /*************************/ /* This module emuates the 256x8 memory block which the main MATRIX BFU memory. <p> 1'b1; assign InvertA = Fin <ref> [4] </ref>; assign InvertB = 1'b0; end 4'd13: begin NAND = 1'b1; assign InvertA = Fin [4]; assign InvertB = Fin [5]; end begin NOR = 1'b1; assign InvertA = Fin [4]; assign InvertB = Fin [5]; end begin XOR = 1'b1; assign InvertA = Fin [4]; assign InvertB = Fin [5]; end endcase end /* Decode */ endmodule 138 /*************************/ /* Specifications: MEM.v */ /*************************/ /* This module emuates the 256x8 memory block which the main MATRIX BFU memory. Reads happen during the first half of the clock cycle. <p> module MEMdecode (Fin [7:0], Mode, Ain_sel, Bin_sel, Data_sel, WEconf, REconf); input [7:0] Fin; output Mode, Ain_sel, Bin_sel, Data_sel, WEconf, REconf; reg Mode, Ain_sel, Bin_sel, Data_sel, WEconf, REconf; /******************/ /* Begin Decoding */ /******************/ /* Assign the inputs appropriately */ initial begin assign Mode = Fin [5]; assign Ain_sel = Fin <ref> [4] </ref>; assign Bin_sel = Fin [3]; assign Data_sel = Fin [2]; assign WEconf = Fin [1]; assign REconf = Fin [0]; end /* Decoding */ endmodule 141 /*********************************/ /* Specifications for WEdecode.v */ /*********************************/ /* WEdecode decodes the Write Enable for the BFU memory.
Reference: [5] <author> Andre DeHon. </author> <title> Reconfigurable Architectures for General-Purpose Computing. </title> <type> PhD dissertation, </type> <institution> Massachusetts Institute of Technology, Department of Electrical Engineering and Computer Science, </institution> <year> 1996. </year> <note> Draft version expected completion: </note> <month> July, </month> <year> 1996. </year>
Reference-contexts: The background material presented in this chapter has been summarized from Andre DeHon's soon to be released PhD thesis <ref> [5] </ref>. 14 * Systems built with GPCDs are post-fabrication adaptable. <p> Thus different applications require different amounts of the architectural resources discussed above. The closer the match between the application's require 1 This table was taken from <ref> [5] </ref>. 20 Control Threads (PCs) Instruction Streams per Control Thread Instruction Memory per Stream Datapath Granularity Architecture/Examples 0 0 n/a Hardwired Functional Unit 0 1 FPGA, Programmable Cellular Automata n 1 w reconfigurable ALUs Programmable Systolic Datapath Arrays n 1 bitwise SIMD 1 c w Traditional Processors n w Vector Processors <p> number of processors w is the width of a single processor m is the number of program counters (PCs) c is the size of the instruction memories Table 2.1: Instruction/Control Architecture Taxonomy 21 ment and the device's resource allocation, the more efficient that device will be at running that application. <ref> [5] </ref> discusses this in more detail. All modern general-purpose computing devices fix their resource allocation decisions when they are fabricated. <p> These examples are based on 8-bit sample data (x i ) and a 16-bit accumulate (y i ). 8.1 Comparison Benchmark In order to compare the efficiency and performance of MATRIX designs with more conventional architectures, we will employ the metric of functional density, similar to the one used in <ref> [5] </ref>. Functional density measures the capacity per unit area of I am indebted to Andre DeHon for working through the details of these examples. This material first appeared in [13]. 57 a device. <p> LeftSource = TempReg [2:0]; TempReg = Ctx2 [1]; MAdd2source = TempReg [3]; MAdd1source = TempReg [2]; TS_Enable = TempReg [1]; CarryPipeline = TempReg [0]; TempReg = Ctx2 [6]; Fa_a = -TempReg [0],Ctx2 [2]-; Fa_b = -TempReg [1], Ctx2 [3]-; Fm_a = -TempReg [2], Ctx2 [4]-; Fm_b = -TempReg [3], Ctx2 <ref> [5] </ref>-; TempReg = Ctx2 [11]; A_a = -TempReg [1:0], Ctx2 [7]-; A_b = -TempReg [3:2], Ctx2 [8]-; B_a = -TempReg [5:4], Ctx2 [9]-; B_b = -TempReg [7:6], Ctx2 [10]-; TempReg = Ctx2 [16]; N1_a = -TempReg [1:0], Ctx2 [12]-; N1_b = -TempReg [3:2], Ctx2 [13]-; N2_a = -TempReg [5:4], Ctx2 [14]-; <p> = TempReg [2:0]; 98 TempReg = Ctx3 [1]; MAdd2source = TempReg [3]; MAdd1source = TempReg [2]; TS_Enable = TempReg [1]; CarryPipeline = TempReg [0]; TempReg = Ctx3 [6]; Fa_a = -TempReg [0],Ctx3 [2]-; Fa_b = -TempReg [1], Ctx3 [3]-; Fm_a = -TempReg [2], Ctx3 [4]-; Fm_b = -TempReg [3], Ctx3 <ref> [5] </ref>-; TempReg = Ctx3 [11]; A_a = -TempReg [1:0], Ctx3 [7]-; A_b = -TempReg [3:2], Ctx3 [8]-; B_a = -TempReg [5:4], Ctx3 [9]-; B_b = -TempReg [7:6], Ctx3 [10]-; TempReg = Ctx3 [16]; N1_a = -TempReg [1:0], Ctx3 [12]-; N1_b = -TempReg [3:2], Ctx3 [13]-; N2_a = -TempReg [5:4], Ctx3 [14]-; <p> /* Program ReadMem */ /*******************/ always @(posedge (CLK) && (PWE === 1'b1)) begin if (ProgAdd [6] === 1'b1) begin ReadMem [ProgAdd [5:0]] = ProgData; /********************/ /* Setup the ORMem */ /********************/ ORMem [0] = -ReadMem [4],ReadMem [3],ReadMem [2], ReadMem [1],ReadMem [0]-; ORMem [1] = -ReadMem [9],ReadMem [8],ReadMem [7], ReadMem [6],ReadMem <ref> [5] </ref>-; ORMem [2] = -ReadMem [14],ReadMem [13],ReadMem [12], ReadMem [11],ReadMem [10]-; ORMem [3] = -ReadMem [19],ReadMem [18],ReadMem [17], ReadMem [16],ReadMem [15]-; ORMem [4] = -ReadMem [24],ReadMem [23],ReadMem [22], ReadMem [21],ReadMem [20]-; ORMem [5] = -ReadMem [29],ReadMem [28],ReadMem [27], 106 ReadMem [26],ReadMem [25]-; ORMem [6] = -ReadMem [34],ReadMem [33],ReadMem [32], ReadMem [31],ReadMem <p> [0] = -ReadMem [4],ReadMem [3],ReadMem [2], ReadMem [1],ReadMem [0]-; ORMem [1] = -ReadMem [9],ReadMem [8],ReadMem [7], ReadMem [6],ReadMem <ref> [5] </ref>-; ORMem [2] = -ReadMem [14],ReadMem [13],ReadMem [12], ReadMem [11],ReadMem [10]-; ORMem [3] = -ReadMem [19],ReadMem [18],ReadMem [17], ReadMem [16],ReadMem [15]-; ORMem [4] = -ReadMem [24],ReadMem [23],ReadMem [22], ReadMem [21],ReadMem [20]-; ORMem [5] = -ReadMem [29],ReadMem [28],ReadMem [27], 106 ReadMem [26],ReadMem [25]-; ORMem [6] = -ReadMem [34],ReadMem [33],ReadMem [32], ReadMem [31],ReadMem [30]-; ORMem [7] = -ReadMem [39],ReadMem [38],ReadMem [37], ReadMem [36],ReadMem [35]-; ORMem [8] = -ReadMem [44],ReadMem [43],ReadMem [42], ReadMem [41],ReadMem [40]-; end /***********************/ /* Define the OR Plane */ /***********************/ initial begin <p> [18], ~Data [17],Data [17],~Data [16],Data [16], ~Data [15],Data [15],~Data [14],Data [14], ~Data [13],Data [13],~Data [12],Data [12], ~Data [11],Data [11],~Data [10],Data [10], ~Data [9],Data [9],~Data [8],Data [8], ~Data [7],Data [7],~Data [6],Data [6], ~Data <ref> [5] </ref>,Data [5],~Data [4],Data [4], ~Data [3],Data [3],~Data [2],Data [2], ~Data [1],Data [1],~Data [0],Data [0]-, -OR_out [8],OR_out [7],OR_out [6],OR_out [5], OR_out [0]-); /*******************/ /* Output Selector */ /*******************/ Sel2 #(9) OutSel (9'b0,OR_out,Out,Gctx [1],start); endmodule 107 /* The following is necessary because this file may be read from many inlcude statements and should be ignored on all but the first */ `define CompReduce_defined /***********************************/ /* Specifications for CompReduce.v */ /***********************************/ /* <p> = 1'b0; ShiftBL = 1'b0; ADD = 1'b0; MULT = 1'b0; MULTA = 1'b0; MULTAA = 1'b0; MULTcont = 1'b0; assign CinALU = 1'b0; /* Default Cin */ /* Decode the function */ case (Fin [3:0]) 4'd0: begin MULT = 1'b1; assign InvertA = Fin [4]; assign InvertB = Fin <ref> [5] </ref>; end begin MULTA = 1'b1; assign InvertA = Fin [4]; assign InvertB = Fin [5]; end begin MULTAA = 1'b1; assign InvertA = Fin [4]; assign InvertB = Fin [5]; end begin MULTcont = 1'b1; assign InvertA = Fin [4]; assign InvertB = Fin [5]; end 4'd4: /* Shift with <p> = 1'b0; MULTcont = 1'b0; assign CinALU = 1'b0; /* Default Cin */ /* Decode the function */ case (Fin [3:0]) 4'd0: begin MULT = 1'b1; assign InvertA = Fin [4]; assign InvertB = Fin <ref> [5] </ref>; end begin MULTA = 1'b1; assign InvertA = Fin [4]; assign InvertB = Fin [5]; end begin MULTAA = 1'b1; assign InvertA = Fin [4]; assign InvertB = Fin [5]; end begin MULTcont = 1'b1; assign InvertA = Fin [4]; assign InvertB = Fin [5]; end 4'd4: /* Shift with Force-Carry */ begin assign InvertA = 1'b0; assign InvertB = 1'b0; case (Fin [5:4]) 2'b00: <p> the function */ case (Fin [3:0]) 4'd0: begin MULT = 1'b1; assign InvertA = Fin [4]; assign InvertB = Fin <ref> [5] </ref>; end begin MULTA = 1'b1; assign InvertA = Fin [4]; assign InvertB = Fin [5]; end begin MULTAA = 1'b1; assign InvertA = Fin [4]; assign InvertB = Fin [5]; end begin MULTcont = 1'b1; assign InvertA = Fin [4]; assign InvertB = Fin [5]; end 4'd4: /* Shift with Force-Carry */ begin assign InvertA = 1'b0; assign InvertB = 1'b0; case (Fin [5:4]) 2'b00: begin ShiftAR = 1'b1; assign CinALU = CinL; end begin ShiftBR = 1'b1; assign CinALU <p> [4]; assign InvertB = Fin <ref> [5] </ref>; end begin MULTA = 1'b1; assign InvertA = Fin [4]; assign InvertB = Fin [5]; end begin MULTAA = 1'b1; assign InvertA = Fin [4]; assign InvertB = Fin [5]; end begin MULTcont = 1'b1; assign InvertA = Fin [4]; assign InvertB = Fin [5]; end 4'd4: /* Shift with Force-Carry */ begin assign InvertA = 1'b0; assign InvertB = 1'b0; case (Fin [5:4]) 2'b00: begin ShiftAR = 1'b1; assign CinALU = CinL; end begin ShiftBR = 1'b1; assign CinALU = CinL; end begin 135 ShiftAL = 1'b1; assign CinALU = CinR; end begin ShiftBL <p> ((MSB && 1'b1) || (~MSB && CinL)); end begin ShiftAL = 1'b1; assign CinALU = ((LSB && 1'b1) || (~LSB && CinR)); end begin ShiftBL = 1'b1; assign CinALU = ((LSB && 1'b1) || (~LSB && CinR)); end endcase end begin assign InvertA = Fin [4]; assign InvertB = Fin <ref> [5] </ref>; ADD = 1'b1; assign CinALU = CinR; end begin assign InvertA = Fin [4]; assign InvertB = Fin [5]; ADD = 1'b1; assign CinALU = ((LSB && 1'b0) || (~LSB && CinR)); end begin 137 assign InvertA = Fin [4]; assign InvertB = Fin [5]; ADD = 1'b1; assign CinALU <p> (~LSB && CinR)); end begin ShiftBL = 1'b1; assign CinALU = ((LSB && 1'b1) || (~LSB && CinR)); end endcase end begin assign InvertA = Fin [4]; assign InvertB = Fin <ref> [5] </ref>; ADD = 1'b1; assign CinALU = CinR; end begin assign InvertA = Fin [4]; assign InvertB = Fin [5]; ADD = 1'b1; assign CinALU = ((LSB && 1'b0) || (~LSB && CinR)); end begin 137 assign InvertA = Fin [4]; assign InvertB = Fin [5]; ADD = 1'b1; assign CinALU = ((LSB && 1'b1) || (~LSB && CinR)); end 4'd11: /* Unusued Opcode Treat as an Add-1 */ begin <p> [4]; assign InvertB = Fin <ref> [5] </ref>; ADD = 1'b1; assign CinALU = CinR; end begin assign InvertA = Fin [4]; assign InvertB = Fin [5]; ADD = 1'b1; assign CinALU = ((LSB && 1'b0) || (~LSB && CinR)); end begin 137 assign InvertA = Fin [4]; assign InvertB = Fin [5]; ADD = 1'b1; assign CinALU = ((LSB && 1'b1) || (~LSB && CinR)); end 4'd11: /* Unusued Opcode Treat as an Add-1 */ begin assign InvertA = Fin [4]; assign InvertB = Fin [5]; ADD = 1'b1; assign CinALU = ((LSB && 1'b1) || (~LSB && CinR)); end 4'd12: /* <p> || (~LSB && CinR)); end begin 137 assign InvertA = Fin [4]; assign InvertB = Fin <ref> [5] </ref>; ADD = 1'b1; assign CinALU = ((LSB && 1'b1) || (~LSB && CinR)); end 4'd11: /* Unusued Opcode Treat as an Add-1 */ begin assign InvertA = Fin [4]; assign InvertB = Fin [5]; ADD = 1'b1; assign CinALU = ((LSB && 1'b1) || (~LSB && CinR)); end 4'd12: /* Pass */ begin if (Fin [5]==1'b1) begin B_Pass = 1'b1; assign InvertA = 1'b0; assign InvertB = Fin [4]; end else begin A_Pass = 1'b1; assign InvertA = Fin [4]; assign InvertB = 1'b0; <p> /* Pass */ begin if (Fin <ref> [5] </ref>==1'b1) begin B_Pass = 1'b1; assign InvertA = 1'b0; assign InvertB = Fin [4]; end else begin A_Pass = 1'b1; assign InvertA = Fin [4]; assign InvertB = 1'b0; end 4'd13: begin NAND = 1'b1; assign InvertA = Fin [4]; assign InvertB = Fin [5]; end begin NOR = 1'b1; assign InvertA = Fin [4]; assign InvertB = Fin [5]; end begin XOR = 1'b1; assign InvertA = Fin [4]; assign InvertB = Fin [5]; end endcase end /* Decode */ endmodule 138 /*************************/ /* Specifications: MEM.v */ /*************************/ /* This module emuates the 256x8 <p> assign InvertB = Fin [4]; end else begin A_Pass = 1'b1; assign InvertA = Fin [4]; assign InvertB = 1'b0; end 4'd13: begin NAND = 1'b1; assign InvertA = Fin [4]; assign InvertB = Fin <ref> [5] </ref>; end begin NOR = 1'b1; assign InvertA = Fin [4]; assign InvertB = Fin [5]; end begin XOR = 1'b1; assign InvertA = Fin [4]; assign InvertB = Fin [5]; end endcase end /* Decode */ endmodule 138 /*************************/ /* Specifications: MEM.v */ /*************************/ /* This module emuates the 256x8 memory block which the main MATRIX BFU memory. <p> [4]; assign InvertB = 1'b0; end 4'd13: begin NAND = 1'b1; assign InvertA = Fin [4]; assign InvertB = Fin <ref> [5] </ref>; end begin NOR = 1'b1; assign InvertA = Fin [4]; assign InvertB = Fin [5]; end begin XOR = 1'b1; assign InvertA = Fin [4]; assign InvertB = Fin [5]; end endcase end /* Decode */ endmodule 138 /*************************/ /* Specifications: MEM.v */ /*************************/ /* This module emuates the 256x8 memory block which the main MATRIX BFU memory. Reads happen during the first half of the clock cycle. <p> /* MEMdecode module */ /********************/ module MEMdecode (Fin [7:0], Mode, Ain_sel, Bin_sel, Data_sel, WEconf, REconf); input [7:0] Fin; output Mode, Ain_sel, Bin_sel, Data_sel, WEconf, REconf; reg Mode, Ain_sel, Bin_sel, Data_sel, WEconf, REconf; /******************/ /* Begin Decoding */ /******************/ /* Assign the inputs appropriately */ initial begin assign Mode = Fin <ref> [5] </ref>; assign Ain_sel = Fin [4]; assign Bin_sel = Fin [3]; assign Data_sel = Fin [2]; assign WEconf = Fin [1]; assign REconf = Fin [0]; end /* Decoding */ endmodule 141 /*********************************/ /* Specifications for WEdecode.v */ /*********************************/ /* WEdecode decodes the Write Enable for the BFU memory.
Reference: [6] <author> Dave Epstein. </author> <title> Chromatic raises the multimedia bar. </title> <type> Microprocessor Report, </type> <institution> 9(14):23 ff., </institution> <month> October 23 </month> <year> 1995. </year>
Reference-contexts: Typically, this is accomplished through segmentable datapaths (e.g. [19] [1]). These generally exhibit SIMD instruction control for the datapath, but can be reconfigured to treat the n bit datapath as k, n k -bit words, for certain, restricted, values of k. Modern multimedia processors (e.g. [18] <ref> [6] </ref>) allow the datapath to be treated as a collection of 8, 16, 32, or 64 bit words. All of these architectures give users the ability to choose an appropriate granularity for their computation. However, they all control these datapaths in a SIMD manner. <p> CRI_a, CRI_b; reg [41:0] CRII; output [3:0] CRsel_1, CRsel_2, CRsel_3, CRsel_4; output CRIIsel, CtrlBitsel; reg [3:0] CRsel_1, CRsel_2, CRsel_3, CRsel_4; reg CRIIsel, CtrlBitsel; /*************************************/ /* Define the Configuration Memories */ /*************************************/ reg [7:0] Ctx3 [45:0]; /* Handle Programming */ /**********************/ always @(posedge (CLK) && (PWE === 1'b1)) begin if (ProgAdd <ref> [6] </ref> === 1'b0) begin if (ProgAdd [7] === 1'b0) Ctx2 [ProgAdd [5:0]] = ProgData; else Ctx3 [ProgAdd [5:0]] = ProgData; end /******************/ /* Handle Reading */ /******************/ always @(posedge (CLK) && (PRE === 1'b1)) begin if (ProgAdd [7] === 1'b0) DataOut = Ctx2 [ProgAdd [5:0]]; else DataOut = Ctx3 [ProgAdd [5:0]]; <p> 4'd0; TS_MAdd1 = 4'd0; TS_MAdd2 = 4'd0; CRI_a = -2'd0,2'd0,2'd0,2'd0,2'd0,2'd0,2'd0,2'd0,2'd0-; CRII = -2'd3,2'd3,2'd3,2'd3,2'd3,2'd3,2'd3, 2'd3,2'd3,2'd3,2'd3,2'd3,2'd3,2'd3, CRsel_1 = 4'd0; CRsel_2 = 4'd0; CRsel_3 = 4'd0; CRsel_4 = 4'd0; CtrlBitsel = 1'b0; CRIIsel = 1'b0; end if (Gctx === 2'd2) 96 begin TempReg = Ctx2 [0]; MSB = TempReg [7]; LSB = TempReg <ref> [6] </ref>; RightSource = TempReg [5:3]; LeftSource = TempReg [2:0]; TempReg = Ctx2 [1]; MAdd2source = TempReg [3]; MAdd1source = TempReg [2]; TS_Enable = TempReg [1]; CarryPipeline = TempReg [0]; TempReg = Ctx2 [6]; Fa_a = -TempReg [0],Ctx2 [2]-; Fa_b = -TempReg [1], Ctx2 [3]-; Fm_a = -TempReg [2], Ctx2 [4]-; Fm_b <p> end if (Gctx === 2'd2) 96 begin TempReg = Ctx2 [0]; MSB = TempReg [7]; LSB = TempReg <ref> [6] </ref>; RightSource = TempReg [5:3]; LeftSource = TempReg [2:0]; TempReg = Ctx2 [1]; MAdd2source = TempReg [3]; MAdd1source = TempReg [2]; TS_Enable = TempReg [1]; CarryPipeline = TempReg [0]; TempReg = Ctx2 [6]; Fa_a = -TempReg [0],Ctx2 [2]-; Fa_b = -TempReg [1], Ctx2 [3]-; Fm_a = -TempReg [2], Ctx2 [4]-; Fm_b = -TempReg [3], Ctx2 [5]-; TempReg = Ctx2 [11]; A_a = -TempReg [1:0], Ctx2 [7]-; A_b = -TempReg [3:2], Ctx2 [8]-; B_a = -TempReg [5:4], Ctx2 [9]-; B_b = -TempReg [7:6], Ctx2 <p> [43]; CRsel_1 = TempReg [3:0]; CRsel_2 = TempReg [7:4]; TempReg = Ctx2 [44]; CRsel_3 = TempReg [3:0]; CRsel_4 = TempReg [7:4]; TempReg = Ctx2 [45]; CtrlBitsel = TempReg [0]; CRIIsel = TempReg [1]; end if (Gctx === 2'd3) begin TempReg = Ctx3 [0]; MSB = TempReg [7]; LSB = TempReg <ref> [6] </ref>; RightSource = TempReg [5:3]; LeftSource = TempReg [2:0]; 98 TempReg = Ctx3 [1]; MAdd2source = TempReg [3]; MAdd1source = TempReg [2]; TS_Enable = TempReg [1]; CarryPipeline = TempReg [0]; TempReg = Ctx3 [6]; Fa_a = -TempReg [0],Ctx3 [2]-; Fa_b = -TempReg [1], Ctx3 [3]-; Fm_a = -TempReg [2], Ctx3 [4]-; <p> end if (Gctx === 2'd3) begin TempReg = Ctx3 [0]; MSB = TempReg [7]; LSB = TempReg <ref> [6] </ref>; RightSource = TempReg [5:3]; LeftSource = TempReg [2:0]; 98 TempReg = Ctx3 [1]; MAdd2source = TempReg [3]; MAdd1source = TempReg [2]; TS_Enable = TempReg [1]; CarryPipeline = TempReg [0]; TempReg = Ctx3 [6]; Fa_a = -TempReg [0],Ctx3 [2]-; Fa_b = -TempReg [1], Ctx3 [3]-; Fm_a = -TempReg [2], Ctx3 [4]-; Fm_b = -TempReg [3], Ctx3 [5]-; TempReg = Ctx3 [11]; A_a = -TempReg [1:0], Ctx3 [7]-; A_b = -TempReg [3:2], Ctx3 [8]-; B_a = -TempReg [5:4], Ctx3 [9]-; B_b = -TempReg [7:6], Ctx3 <p> data */ reg [39:0] ORMem [8:0]; /* This is basis for the OR array */ /****************/ /* Handle Reads */ /****************/ always @(posedge (CLK) && (PRE === 1'b1)) begin OR_Config = ReadMem [ProgAdd [5:0]]; end /* Program ReadMem */ /*******************/ always @(posedge (CLK) && (PWE === 1'b1)) begin if (ProgAdd <ref> [6] </ref> === 1'b1) begin ReadMem [ProgAdd [5:0]] = ProgData; /********************/ /* Setup the ORMem */ /********************/ ORMem [0] = -ReadMem [4],ReadMem [3],ReadMem [2], ReadMem [1],ReadMem [0]-; ORMem [1] = -ReadMem [9],ReadMem [8],ReadMem [7], ReadMem [6],ReadMem [5]-; ORMem [2] = -ReadMem [14],ReadMem [13],ReadMem [12], ReadMem [11],ReadMem [10]-; ORMem [3] = -ReadMem [19],ReadMem <p> = -ReadMem [9],ReadMem [8],ReadMem [7], ReadMem <ref> [6] </ref>,ReadMem [5]-; ORMem [2] = -ReadMem [14],ReadMem [13],ReadMem [12], ReadMem [11],ReadMem [10]-; ORMem [3] = -ReadMem [19],ReadMem [18],ReadMem [17], ReadMem [16],ReadMem [15]-; ORMem [4] = -ReadMem [24],ReadMem [23],ReadMem [22], ReadMem [21],ReadMem [20]-; ORMem [5] = -ReadMem [29],ReadMem [28],ReadMem [27], 106 ReadMem [26],ReadMem [25]-; ORMem [6] = -ReadMem [34],ReadMem [33],ReadMem [32], ReadMem [31],ReadMem [30]-; ORMem [7] = -ReadMem [39],ReadMem [38],ReadMem [37], ReadMem [36],ReadMem [35]-; ORMem [8] = -ReadMem [44],ReadMem [43],ReadMem [42], ReadMem [41],ReadMem [40]-; end /***********************/ /* Define the OR Plane */ /***********************/ initial begin $async$or$array (ORMem, -~Data [19],Data [19],~Data [18],Data [18], ~Data [17],Data [17],~Data [16],Data <p> ReadMem [41],ReadMem [40]-; end /***********************/ /* Define the OR Plane */ /***********************/ initial begin $async$or$array (ORMem, -~Data [19],Data [19],~Data [18],Data [18], ~Data [17],Data [17],~Data [16],Data [16], ~Data [15],Data [15],~Data [14],Data [14], ~Data [13],Data [13],~Data [12],Data [12], ~Data [11],Data [11],~Data [10],Data [10], ~Data [9],Data [9],~Data [8],Data [8], ~Data [7],Data [7],~Data <ref> [6] </ref>,Data [6], ~Data [5],Data [5],~Data [4],Data [4], ~Data [3],Data [3],~Data [2],Data [2], ~Data [1],Data [1],~Data [0],Data [0]-, -OR_out [8],OR_out [7],OR_out [6],OR_out [5], OR_out [0]-); /*******************/ /* Output Selector */ /*******************/ Sel2 #(9) OutSel (9'b0,OR_out,Out,Gctx [1],start); endmodule 107 /* The following is necessary because this file may be read from many inlcude statements <p> MULT, MULTA, MULTAA, MULTcont; /* Additional Control signals */ output InvertA, InvertB; reg InvertA, InvertB; /* Control Context Select */ output CCS; reg CCS; /* Memory Write Enable */ output WE; reg WE; /* Decode Logic */ /****************/ /* Assign the fixed bits */ initial begin assign CCS = Fin <ref> [6] </ref>; assign WE = Fin [7]; end always @(Fin [5:0] or start) begin /* Start by clearing value of the one-hot outputs. */ A_Pass = 1'b0; B_Pass = 1'b0; NAND = 1'b0; NOR = 1'b0; ShiftAR = 1'b0; ShiftAL = 1'b0; 134 ShiftBR = 1'b0; ShiftBL = 1'b0; ADD = 1'b0;
Reference: [7] <author> Carla Golla, Fulvio Nava, Franco Cavallotti, Alessandro Cremonesi, and Giulio Casagrande. </author> <title> 30-msamples/s programmable filter processor. </title> <journal> IEEE Journal of Solid-State Circuits, </journal> <volume> 25(6) </volume> <pages> 1502-1509, </pages> <month> December </month> <year> 1990. </year> <month> 159 </month>
Reference-contexts: Note [8] 64 CLBs, 184 ns/16-TAPs y 1.0 ICSPAT93 [4] 400 CLBs, 100ns/4-TAPs 0.080 PADDI2 ISSCC95 [22] 5 EXUs, 20ns/TAP 0.93 Full Custom JSSC89 [16] 45ns/64-TAPs z 6.1 JSSC90 <ref> [7] </ref> 33ns/16-TAPs 3.5 y symmetric filter; z - 24-bit accum. Table 8.6: FIR Survey - 8fi8 multiply, 16-bit Accumulate 68 Chapter 9 Relationship to Conventional Computing Devices As we have seen, MATRIX is capable of changing its architectural structure in order to match application needs. <p> [3:0] CRsel_1, CRsel_2, CRsel_3, CRsel_4; output CRIIsel, CtrlBitsel; reg [3:0] CRsel_1, CRsel_2, CRsel_3, CRsel_4; reg CRIIsel, CtrlBitsel; /*************************************/ /* Define the Configuration Memories */ /*************************************/ reg [7:0] Ctx3 [45:0]; /* Handle Programming */ /**********************/ always @(posedge (CLK) && (PWE === 1'b1)) begin if (ProgAdd [6] === 1'b0) begin if (ProgAdd <ref> [7] </ref> === 1'b0) Ctx2 [ProgAdd [5:0]] = ProgData; else Ctx3 [ProgAdd [5:0]] = ProgData; end /******************/ /* Handle Reading */ /******************/ always @(posedge (CLK) && (PRE === 1'b1)) begin if (ProgAdd [7] === 1'b0) DataOut = Ctx2 [ProgAdd [5:0]]; else DataOut = Ctx3 [ProgAdd [5:0]]; end /* Temporary Register */ /**********************/ <p> Programming */ /**********************/ always @(posedge (CLK) && (PWE === 1'b1)) begin if (ProgAdd [6] === 1'b0) begin if (ProgAdd <ref> [7] </ref> === 1'b0) Ctx2 [ProgAdd [5:0]] = ProgData; else Ctx3 [ProgAdd [5:0]] = ProgData; end /******************/ /* Handle Reading */ /******************/ always @(posedge (CLK) && (PRE === 1'b1)) begin if (ProgAdd [7] === 1'b0) DataOut = Ctx2 [ProgAdd [5:0]]; else DataOut = Ctx3 [ProgAdd [5:0]]; end /* Temporary Register */ /**********************/ /* Note that this are required because verilog does not support bit-selects of memory elements */ 93 reg [7:0] TempReg; /**************************/ /* Handle Context Changes */ /**************************/ always @(start or Gctx <p> = 4'd0; TS_CR = 4'd0; TS_MAdd1 = 4'd0; TS_MAdd2 = 4'd0; CRI_a = -2'd0,2'd0,2'd0,2'd0,2'd0,2'd0,2'd0,2'd0,2'd0-; CRII = -2'd3,2'd3,2'd3,2'd3,2'd3,2'd3,2'd3, 2'd3,2'd3,2'd3,2'd3,2'd3,2'd3,2'd3, CRsel_1 = 4'd0; CRsel_2 = 4'd0; CRsel_3 = 4'd0; CRsel_4 = 4'd0; CtrlBitsel = 1'b0; CRIIsel = 1'b0; end if (Gctx === 2'd2) 96 begin TempReg = Ctx2 [0]; MSB = TempReg <ref> [7] </ref>; LSB = TempReg [6]; RightSource = TempReg [5:3]; LeftSource = TempReg [2:0]; TempReg = Ctx2 [1]; MAdd2source = TempReg [3]; MAdd1source = TempReg [2]; TS_Enable = TempReg [1]; CarryPipeline = TempReg [0]; TempReg = Ctx2 [6]; Fa_a = -TempReg [0],Ctx2 [2]-; Fa_b = -TempReg [1], Ctx2 [3]-; Fm_a = -TempReg <p> TempReg [3]; MAdd1source = TempReg [2]; TS_Enable = TempReg [1]; CarryPipeline = TempReg [0]; TempReg = Ctx2 [6]; Fa_a = -TempReg [0],Ctx2 [2]-; Fa_b = -TempReg [1], Ctx2 [3]-; Fm_a = -TempReg [2], Ctx2 [4]-; Fm_b = -TempReg [3], Ctx2 [5]-; TempReg = Ctx2 [11]; A_a = -TempReg [1:0], Ctx2 <ref> [7] </ref>-; A_b = -TempReg [3:2], Ctx2 [8]-; B_a = -TempReg [5:4], Ctx2 [9]-; B_b = -TempReg [7:6], Ctx2 [10]-; TempReg = Ctx2 [16]; N1_a = -TempReg [1:0], Ctx2 [12]-; N1_b = -TempReg [3:2], Ctx2 [13]-; N2_a = -TempReg [5:4], Ctx2 [14]-; N2_b = -TempReg [7:6], Ctx2 [15]-; TempReg = Ctx2 [21]; <p> [37]-; TempReg = Ctx2 [43]; CRsel_1 = TempReg [3:0]; CRsel_2 = TempReg [7:4]; TempReg = Ctx2 [44]; CRsel_3 = TempReg [3:0]; CRsel_4 = TempReg [7:4]; TempReg = Ctx2 [45]; CtrlBitsel = TempReg [0]; CRIIsel = TempReg [1]; end if (Gctx === 2'd3) begin TempReg = Ctx3 [0]; MSB = TempReg <ref> [7] </ref>; LSB = TempReg [6]; RightSource = TempReg [5:3]; LeftSource = TempReg [2:0]; 98 TempReg = Ctx3 [1]; MAdd2source = TempReg [3]; MAdd1source = TempReg [2]; TS_Enable = TempReg [1]; CarryPipeline = TempReg [0]; TempReg = Ctx3 [6]; Fa_a = -TempReg [0],Ctx3 [2]-; Fa_b = -TempReg [1], Ctx3 [3]-; Fm_a = <p> TempReg [3]; MAdd1source = TempReg [2]; TS_Enable = TempReg [1]; CarryPipeline = TempReg [0]; TempReg = Ctx3 [6]; Fa_a = -TempReg [0],Ctx3 [2]-; Fa_b = -TempReg [1], Ctx3 [3]-; Fm_a = -TempReg [2], Ctx3 [4]-; Fm_b = -TempReg [3], Ctx3 [5]-; TempReg = Ctx3 [11]; A_a = -TempReg [1:0], Ctx3 <ref> [7] </ref>-; A_b = -TempReg [3:2], Ctx3 [8]-; B_a = -TempReg [5:4], Ctx3 [9]-; B_b = -TempReg [7:6], Ctx3 [10]-; TempReg = Ctx3 [16]; N1_a = -TempReg [1:0], Ctx3 [12]-; N1_b = -TempReg [3:2], Ctx3 [13]-; N2_a = -TempReg [5:4], Ctx3 [14]-; N2_b = -TempReg [7:6], Ctx3 [15]-; TempReg = Ctx3 [21]; <p> [ProgAdd [5:0]]; end /* Program ReadMem */ /*******************/ always @(posedge (CLK) && (PWE === 1'b1)) begin if (ProgAdd [6] === 1'b1) begin ReadMem [ProgAdd [5:0]] = ProgData; /********************/ /* Setup the ORMem */ /********************/ ORMem [0] = -ReadMem [4],ReadMem [3],ReadMem [2], ReadMem [1],ReadMem [0]-; ORMem [1] = -ReadMem [9],ReadMem [8],ReadMem <ref> [7] </ref>, ReadMem [6],ReadMem [5]-; ORMem [2] = -ReadMem [14],ReadMem [13],ReadMem [12], ReadMem [11],ReadMem [10]-; ORMem [3] = -ReadMem [19],ReadMem [18],ReadMem [17], ReadMem [16],ReadMem [15]-; ORMem [4] = -ReadMem [24],ReadMem [23],ReadMem [22], ReadMem [21],ReadMem [20]-; ORMem [5] = -ReadMem [29],ReadMem [28],ReadMem [27], 106 ReadMem [26],ReadMem [25]-; ORMem [6] = -ReadMem [34],ReadMem [33],ReadMem <p> = -ReadMem [14],ReadMem [13],ReadMem [12], ReadMem [11],ReadMem [10]-; ORMem [3] = -ReadMem [19],ReadMem [18],ReadMem [17], ReadMem [16],ReadMem [15]-; ORMem [4] = -ReadMem [24],ReadMem [23],ReadMem [22], ReadMem [21],ReadMem [20]-; ORMem [5] = -ReadMem [29],ReadMem [28],ReadMem [27], 106 ReadMem [26],ReadMem [25]-; ORMem [6] = -ReadMem [34],ReadMem [33],ReadMem [32], ReadMem [31],ReadMem [30]-; ORMem <ref> [7] </ref> = -ReadMem [39],ReadMem [38],ReadMem [37], ReadMem [36],ReadMem [35]-; ORMem [8] = -ReadMem [44],ReadMem [43],ReadMem [42], ReadMem [41],ReadMem [40]-; end /***********************/ /* Define the OR Plane */ /***********************/ initial begin $async$or$array (ORMem, -~Data [19],Data [19],~Data [18],Data [18], ~Data [17],Data [17],~Data [16],Data [16], ~Data [15],Data [15],~Data [14],Data [14], ~Data [13],Data [13],~Data [12],Data <p> ADDresult [7:0]; assign Cout = ADDresult [8]; end if (ShiftAR) begin assign TempShift = (A [7:0] &gt;> 1); assign Out = -Cin, TempShift [6:0]-; assign Cout = A [0]; end if (ShiftAL) begin assign TempShift = (A [7:0] &lt;< 1); assign Out = -TempShift [7:1], Cin-; assign Cout = A <ref> [7] </ref>; end if (ShiftBR) begin assign TempShift = (B [7:0] &gt;> 1); assign Out = -Cin, TempShift [6:0]-; assign Cout = B [0]; end if (ShiftBL) begin assign TempShift = (B [7:0] &lt;< 1); assign Out = -TempShift [7:1], Cin-; assign Cout = B [7]; end if (MULT) begin assign MULTresult <p> [7:1], Cin-; assign Cout = A <ref> [7] </ref>; end if (ShiftBR) begin assign TempShift = (B [7:0] &gt;> 1); assign Out = -Cin, TempShift [6:0]-; assign Cout = B [0]; end if (ShiftBL) begin assign TempShift = (B [7:0] &lt;< 1); assign Out = -TempShift [7:1], Cin-; assign Cout = B [7]; end if (MULT) begin assign MULTresult = (A [7:0] * B [7:0]); assign Out = MULTresult [7:0]; 131 assign Cout = 1'b0; end if (MULTA) begin assign MULTresult = (A [7:0] * B [7:0]) + Madd1 [7:0]; assign Out = MULTresult [7:0]; assign Cout = 1'b0; end if (MULTAA) begin <p> Additional Control signals */ output InvertA, InvertB; reg InvertA, InvertB; /* Control Context Select */ output CCS; reg CCS; /* Memory Write Enable */ output WE; reg WE; /* Decode Logic */ /****************/ /* Assign the fixed bits */ initial begin assign CCS = Fin [6]; assign WE = Fin <ref> [7] </ref>; end always @(Fin [5:0] or start) begin /* Start by clearing value of the one-hot outputs. */ A_Pass = 1'b0; B_Pass = 1'b0; NAND = 1'b0; NOR = 1'b0; ShiftAR = 1'b0; ShiftAL = 1'b0; 134 ShiftBR = 1'b0; ShiftBL = 1'b0; ADD = 1'b0; MULT = 1'b0; MULTA = <p> begin 135 ShiftAL = 1'b1; assign CinALU = CinR; end begin ShiftBL = 1'b1; assign CinALU = CinR; end endcase end 4'd5: /* Shift with Skip-Bit */ begin assign InvertA = 1'b0; assign InvertB = 1'b0; case (Fin [5:4]) 2'b00: begin ShiftAR = 1'b1; assign CinALU = ((MSB && ALU_A <ref> [7] </ref>) || (~MSB && CinL)); end begin ShiftBR = 1'b1; assign CinALU = ((MSB && ALU_B [7]) || (~MSB && CinL)); end begin ShiftAL = 1'b1; assign CinALU = ((LSB && ALU_A [0]) || (~LSB && CinR)); end begin ShiftBL = 1'b1; assign CinALU = ((LSB && ALU_B [0]) || (~LSB <p> = CinR; end endcase end 4'd5: /* Shift with Skip-Bit */ begin assign InvertA = 1'b0; assign InvertB = 1'b0; case (Fin [5:4]) 2'b00: begin ShiftAR = 1'b1; assign CinALU = ((MSB && ALU_A <ref> [7] </ref>) || (~MSB && CinL)); end begin ShiftBR = 1'b1; assign CinALU = ((MSB && ALU_B [7]) || (~MSB && CinL)); end begin ShiftAL = 1'b1; assign CinALU = ((LSB && ALU_A [0]) || (~LSB && CinR)); end begin ShiftBL = 1'b1; assign CinALU = ((LSB && ALU_B [0]) || (~LSB && CinR)); end endcase end 4'd6: /* Shift with Insert 0 */ begin assign InvertA =
Reference: [8] <author> Greg Goslin and Bruce Newgard. 16-TAP, </author> <title> 8-Bit FIR Filter Applications Guide. </title> <publisher> Xilinx, Inc., </publisher> <address> 2100 Logic Drive, San Jose, CA 95124, </address> <month> November </month> <year> 1994. </year> <note> http: //www.xilinx.com/appnote/fir_filt.pdf. </note>
Reference-contexts: This design would be a hybrid between the systolic implementation and the microcoded example in Section 8.3. 59 Device MATRIX FPGA (XC4K) Reference ICSPAT93 [4] App. Note <ref> [8] </ref> Size 2 BFUs/TAP 100 CLBs/TAP 67 CLBs/16-TAPs 29M 2 /BFU 1.25M 2 /CLB Speed 20 ns cycle 100 ns cycle 184 ns cycle Density 0.87/ 2 s 0.08/ 2 s 1.0/ 2 s T AP s= 2 s (symmetric) Table 8.1: Systolic FIR Performance Density Comparison Thus, the k-weight filter <p> Note <ref> [8] </ref> 64 CLBs, 184 ns/16-TAPs y 1.0 ICSPAT93 [4] 400 CLBs, 100ns/4-TAPs 0.080 PADDI2 ISSCC95 [22] 5 EXUs, 20ns/TAP 0.93 Full Custom JSSC89 [16] 45ns/64-TAPs z 6.1 JSSC90 [7] 33ns/16-TAPs 3.5 y symmetric filter; z - 24-bit accum. <p> TS_Enable = TempReg [1]; CarryPipeline = TempReg [0]; TempReg = Ctx2 [6]; Fa_a = -TempReg [0],Ctx2 [2]-; Fa_b = -TempReg [1], Ctx2 [3]-; Fm_a = -TempReg [2], Ctx2 [4]-; Fm_b = -TempReg [3], Ctx2 [5]-; TempReg = Ctx2 [11]; A_a = -TempReg [1:0], Ctx2 [7]-; A_b = -TempReg [3:2], Ctx2 <ref> [8] </ref>-; B_a = -TempReg [5:4], Ctx2 [9]-; B_b = -TempReg [7:6], Ctx2 [10]-; TempReg = Ctx2 [16]; N1_a = -TempReg [1:0], Ctx2 [12]-; N1_b = -TempReg [3:2], Ctx2 [13]-; N2_a = -TempReg [5:4], Ctx2 [14]-; N2_b = -TempReg [7:6], Ctx2 [15]-; TempReg = Ctx2 [21]; FP1_a = -TempReg [0], Ctx2 [17]-; <p> TS_Enable = TempReg [1]; CarryPipeline = TempReg [0]; TempReg = Ctx3 [6]; Fa_a = -TempReg [0],Ctx3 [2]-; Fa_b = -TempReg [1], Ctx3 [3]-; Fm_a = -TempReg [2], Ctx3 [4]-; Fm_b = -TempReg [3], Ctx3 [5]-; TempReg = Ctx3 [11]; A_a = -TempReg [1:0], Ctx3 [7]-; A_b = -TempReg [3:2], Ctx3 <ref> [8] </ref>-; B_a = -TempReg [5:4], Ctx3 [9]-; B_b = -TempReg [7:6], Ctx3 [10]-; TempReg = Ctx3 [16]; N1_a = -TempReg [1:0], Ctx3 [12]-; N1_b = -TempReg [3:2], Ctx3 [13]-; N2_a = -TempReg [5:4], Ctx3 [14]-; N2_b = -TempReg [7:6], Ctx3 [15]-; TempReg = Ctx3 [21]; FP1_a = -TempReg [0], Ctx3 [17]-; <p> = -ReadMem [19],ReadMem [18],ReadMem [17], ReadMem [16],ReadMem [15]-; ORMem [4] = -ReadMem [24],ReadMem [23],ReadMem [22], ReadMem [21],ReadMem [20]-; ORMem [5] = -ReadMem [29],ReadMem [28],ReadMem [27], 106 ReadMem [26],ReadMem [25]-; ORMem [6] = -ReadMem [34],ReadMem [33],ReadMem [32], ReadMem [31],ReadMem [30]-; ORMem [7] = -ReadMem [39],ReadMem [38],ReadMem [37], ReadMem [36],ReadMem [35]-; ORMem <ref> [8] </ref> = -ReadMem [44],ReadMem [43],ReadMem [42], ReadMem [41],ReadMem [40]-; end /***********************/ /* Define the OR Plane */ /***********************/ initial begin $async$or$array (ORMem, -~Data [19],Data [19],~Data [18],Data [18], ~Data [17],Data [17],~Data [16],Data [16], ~Data [15],Data [15],~Data [14],Data [14], ~Data [13],Data [13],~Data [12],Data [12], ~Data [11],Data [11],~Data [10],Data [10], ~Data [9],Data [9],~Data [8],Data <p> = -ReadMem [44],ReadMem [43],ReadMem [42], ReadMem [41],ReadMem [40]-; end /***********************/ /* Define the OR Plane */ /***********************/ initial begin $async$or$array (ORMem, -~Data [19],Data [19],~Data [18],Data [18], ~Data [17],Data [17],~Data [16],Data [16], ~Data [15],Data [15],~Data [14],Data [14], ~Data [13],Data [13],~Data [12],Data [12], ~Data [11],Data [11],~Data [10],Data [10], ~Data [9],Data [9],~Data <ref> [8] </ref>,Data [8], ~Data [7],Data [7],~Data [6],Data [6], ~Data [5],Data [5],~Data [4],Data [4], ~Data [3],Data [3],~Data [2],Data [2], ~Data [1],Data [1],~Data [0],Data [0]-, -OR_out [8],OR_out [7],OR_out [6],OR_out [5], OR_out [0]-); /*******************/ /* Output Selector */ /*******************/ Sel2 #(9) OutSel (9'b0,OR_out,Out,Gctx [1],start); endmodule 107 /* The following is necessary because this file may be <p> /* Internal Wires */ /******************/ wire [8:0] Config; /* Final configuration word */ /******************************/ /* Delacare the major modules */ /******************************/ NetSwitch switch (Local, L1_N1, L1_N2, L1_NE, L1_E1, L1_E2, L1_SE, L1_S1, L1_S2, L1_SW, L1_W1, L1_W2, L1_NW, L3_V1, L3_V2, L3_V3, L3_V4, L3_H1, L3_H2, L3_H3, L3_H4, CByte, Config [4:0], Config [7:0], Config <ref> [8] </ref>, Out, start); Sel2 #(9) Ctx_Sel (Config_a, Config_b, Config, Ctrl, start); endmodule 112 /*******************************/ /* Specifications for NAport.v */ /*******************************/ /* An NAport is the switch used to feed data to the BFU L2 and L3 network drivers and address ports. <p> SourceSel; /* Final Source Selector */ wire [9:0] Config; /* Final configuration word */ /******************************/ /* Delacare the major modules */ /******************************/ NetSwitch switch (Local, L1_N1, L1_N2, L1_NE, L1_E1, L1_E2, L1_SE, L1_S1, L1_S2, L1_SW, L1_W1, L1_W2, L1_NW, L3_V1, L3_V2, L3_V3, L3_V4, L3_H1, L3_H2, L3_H3, L3_H4, CByte, SourceSel, Config [7:0], Config <ref> [8] </ref>, Out, start); Sel2 #(10) Ctx_sel (Config_a, Config_b, Config, Ctrl, start); Sel2 #(5) source_sel (Config [4:0], FPout [4:0], SourceSel, ~Config [9], start); endmodule 114 /**********************************/ /* Specifications for L1drivers.v */ /**********************************/ /* L1drivers represent the drivers that enable the BFU's output Level 1 lines. <p> 1'b0; end begin assign Out = ~(A [7:0] | B [7:0]); assign Cout = 1'b0; end begin assign Out = (A [7:0] ^ B [7:0]); assign Cout = 1'b0; end begin assign ADDresult = (A [7:0] + B [7:0] + Cin); assign Out = ADDresult [7:0]; assign Cout = ADDresult <ref> [8] </ref>; end if (ShiftAR) begin assign TempShift = (A [7:0] &gt;> 1); assign Out = -Cin, TempShift [6:0]-; assign Cout = A [0]; end if (ShiftAL) begin assign TempShift = (A [7:0] &lt;< 1); assign Out = -TempShift [7:1], Cin-; assign Cout = A [7]; end if (ShiftBR) begin assign TempShift
Reference: [9] <author> Paul Gronowski, Peter Bannon, Michael Bertone, Randel Blake-Campos, Gre-gory Bouchard, William Bowhill, David Carlson, Ruben Castelino, Dale Donchin, Richard Fromm, Mary Gowan, Anil Jain, Bruce Loughlin, Shekhar Mehta, Jeanne Meyer, Robert Mueller, Andy Olesin, Tung Pham, Ronald Preston, and Paul Robinfeld. </author> <title> A 433mhz 64b quad-issue risc microprocessor. </title> <booktitle> In 1996 IEEE International Solid-State Circuits Conference, Digst of Technical Papers, </booktitle> <pages> pages 222-223. </pages> <publisher> IEEE, </publisher> <month> February </month> <year> 1996. </year>
Reference-contexts: Larger FIRs could be supported using additional BFUs to store the extra sample and coefficient values. 62 Device MATRIX MIPS-X NEC VSP8 1996 Alpha mstep 32b mpy 64b mpy Reference ISSCC87 [10] [14] ISSCC96 <ref> [9] </ref> Size 8 BFUs 1 die 1 die 1 die Area 29M 2 /BFU 68M 2 1.2G 2 6.8G 2 Clock Rate 10 ns cycle 50 ns cycle 10 ns cycle 2.3 ns cycle Throughput 8 cycles/TAP 10+ cycles/TAP 4 cycles/TAP 1 cycle/TAP Density 0.054/ 2 s 0.029/ 2 s 0.022/ <p> robust performance density across a wide range of applications. 67 Architecture Reference Area and Time Filter TAPs 2 s 16b DSP ISSCC86 [21] 125 ns/TAP 0.090 CICC92 [17] 50 ns/TAP 0.072 32b RISC mstep MIPS-X [10] 50+ ns/TAP 0.029 32b RISC/DSP VSP8 [14] 40 ns/TAP 0.022 64b RISC 1996 Alpha <ref> [9] </ref> 2.3 ns/TAP 0.064 systolic 2 BFUs, 20ns/TAP 0.87 MATRIX microcode 8 BFUs, 80ns/TAP 0.054 VLIW 11 BFUs, 20ns/TAP 0.16 XC4K App. <p> TempReg [0]; TempReg = Ctx2 [6]; Fa_a = -TempReg [0],Ctx2 [2]-; Fa_b = -TempReg [1], Ctx2 [3]-; Fm_a = -TempReg [2], Ctx2 [4]-; Fm_b = -TempReg [3], Ctx2 [5]-; TempReg = Ctx2 [11]; A_a = -TempReg [1:0], Ctx2 [7]-; A_b = -TempReg [3:2], Ctx2 [8]-; B_a = -TempReg [5:4], Ctx2 <ref> [9] </ref>-; B_b = -TempReg [7:6], Ctx2 [10]-; TempReg = Ctx2 [16]; N1_a = -TempReg [1:0], Ctx2 [12]-; N1_b = -TempReg [3:2], Ctx2 [13]-; N2_a = -TempReg [5:4], Ctx2 [14]-; N2_b = -TempReg [7:6], Ctx2 [15]-; TempReg = Ctx2 [21]; FP1_a = -TempReg [0], Ctx2 [17]-; FP1_b = -TempReg [1], Ctx2 [18]-; <p> TempReg [0]; TempReg = Ctx3 [6]; Fa_a = -TempReg [0],Ctx3 [2]-; Fa_b = -TempReg [1], Ctx3 [3]-; Fm_a = -TempReg [2], Ctx3 [4]-; Fm_b = -TempReg [3], Ctx3 [5]-; TempReg = Ctx3 [11]; A_a = -TempReg [1:0], Ctx3 [7]-; A_b = -TempReg [3:2], Ctx3 [8]-; B_a = -TempReg [5:4], Ctx3 <ref> [9] </ref>-; B_b = -TempReg [7:6], Ctx3 [10]-; TempReg = Ctx3 [16]; N1_a = -TempReg [1:0], Ctx3 [12]-; N1_b = -TempReg [3:2], Ctx3 [13]-; N2_a = -TempReg [5:4], Ctx3 [14]-; N2_b = -TempReg [7:6], Ctx3 [15]-; TempReg = Ctx3 [21]; FP1_a = -TempReg [0], Ctx3 [17]-; FP1_b = -TempReg [1], Ctx3 [18]-; <p> */ /******************************/ NetSwitch switch (Local, L1_N1, L1_N2, L1_NE, L1_E1, L1_E2, L1_SE, L1_S1, L1_S2, L1_SW, L1_W1, L1_W2, L1_NW, L3_V1, L3_V2, L3_V3, L3_V4, L3_H1, L3_H2, L3_H3, L3_H4, CByte, SourceSel, Config [7:0], Config [8], Out, start); Sel2 #(10) Ctx_sel (Config_a, Config_b, Config, Ctrl, start); Sel2 #(5) source_sel (Config [4:0], FPout [4:0], SourceSel, ~Config <ref> [9] </ref>, start); endmodule 114 /**********************************/ /* Specifications for L1drivers.v */ /**********************************/ /* L1drivers represent the drivers that enable the BFU's output Level 1 lines. When enabled, the drive the BFU output along the appropriate wires. When disabled, they drive the lines to ground.
Reference: [10] <author> Mark Horowitz, John Hennessy, Paul Chow, Glenn Gulak, John Acken, Anant Agarwal, Chorng-Yeung Chu, Scott McFarling, Steven Przybylski, Steven Richardson, Arturo Salz, Richard Simoni, Don Stark, Peter Steenkiste, Steven Tjiang, and Malcom Wing. </author> <title> A 32b microprocessor with on-chip 2k byte instruction cache. </title> <booktitle> In 1987 IEEE International Solid-State Circuits Conference, Digst of Technical Papers, </booktitle> <pages> pages 30-31. </pages> <publisher> IEEE, </publisher> <month> February </month> <year> 1987. </year>
Reference-contexts: In this example, k 61 because of the limited space in the ALU's register file memory. Larger FIRs could be supported using additional BFUs to store the extra sample and coefficient values. 62 Device MATRIX MIPS-X NEC VSP8 1996 Alpha mstep 32b mpy 64b mpy Reference ISSCC87 <ref> [10] </ref> [14] ISSCC96 [9] Size 8 BFUs 1 die 1 die 1 die Area 29M 2 /BFU 68M 2 1.2G 2 6.8G 2 Clock Rate 10 ns cycle 50 ns cycle 10 ns cycle 2.3 ns cycle Throughput 8 cycles/TAP 10+ cycles/TAP 4 cycles/TAP 1 cycle/TAP Density 0.054/ 2 s 0.029/ <p> the ability to change its design to match application requirements and flexibility, giving it a robust performance density across a wide range of applications. 67 Architecture Reference Area and Time Filter TAPs 2 s 16b DSP ISSCC86 [21] 125 ns/TAP 0.090 CICC92 [17] 50 ns/TAP 0.072 32b RISC mstep MIPS-X <ref> [10] </ref> 50+ ns/TAP 0.029 32b RISC/DSP VSP8 [14] 40 ns/TAP 0.022 64b RISC 1996 Alpha [9] 2.3 ns/TAP 0.064 systolic 2 BFUs, 20ns/TAP 0.87 MATRIX microcode 8 BFUs, 80ns/TAP 0.054 VLIW 11 BFUs, 20ns/TAP 0.16 XC4K App. <p> Fa_a = -TempReg [0],Ctx2 [2]-; Fa_b = -TempReg [1], Ctx2 [3]-; Fm_a = -TempReg [2], Ctx2 [4]-; Fm_b = -TempReg [3], Ctx2 [5]-; TempReg = Ctx2 [11]; A_a = -TempReg [1:0], Ctx2 [7]-; A_b = -TempReg [3:2], Ctx2 [8]-; B_a = -TempReg [5:4], Ctx2 [9]-; B_b = -TempReg [7:6], Ctx2 <ref> [10] </ref>-; TempReg = Ctx2 [16]; N1_a = -TempReg [1:0], Ctx2 [12]-; N1_b = -TempReg [3:2], Ctx2 [13]-; N2_a = -TempReg [5:4], Ctx2 [14]-; N2_b = -TempReg [7:6], Ctx2 [15]-; TempReg = Ctx2 [21]; FP1_a = -TempReg [0], Ctx2 [17]-; FP1_b = -TempReg [1], Ctx2 [18]-; FP2_a = -TempReg [2], Ctx2 [19]-; <p> Fa_a = -TempReg [0],Ctx3 [2]-; Fa_b = -TempReg [1], Ctx3 [3]-; Fm_a = -TempReg [2], Ctx3 [4]-; Fm_b = -TempReg [3], Ctx3 [5]-; TempReg = Ctx3 [11]; A_a = -TempReg [1:0], Ctx3 [7]-; A_b = -TempReg [3:2], Ctx3 [8]-; B_a = -TempReg [5:4], Ctx3 [9]-; B_b = -TempReg [7:6], Ctx3 <ref> [10] </ref>-; TempReg = Ctx3 [16]; N1_a = -TempReg [1:0], Ctx3 [12]-; N1_b = -TempReg [3:2], Ctx3 [13]-; N2_a = -TempReg [5:4], Ctx3 [14]-; N2_b = -TempReg [7:6], Ctx3 [15]-; TempReg = Ctx3 [21]; FP1_a = -TempReg [0], Ctx3 [17]-; FP1_b = -TempReg [1], Ctx3 [18]-; FP2_a = -TempReg [2], Ctx3 [19]-; <p> === 1'b1)) begin if (ProgAdd [6] === 1'b1) begin ReadMem [ProgAdd [5:0]] = ProgData; /********************/ /* Setup the ORMem */ /********************/ ORMem [0] = -ReadMem [4],ReadMem [3],ReadMem [2], ReadMem [1],ReadMem [0]-; ORMem [1] = -ReadMem [9],ReadMem [8],ReadMem [7], ReadMem [6],ReadMem [5]-; ORMem [2] = -ReadMem [14],ReadMem [13],ReadMem [12], ReadMem [11],ReadMem <ref> [10] </ref>-; ORMem [3] = -ReadMem [19],ReadMem [18],ReadMem [17], ReadMem [16],ReadMem [15]-; ORMem [4] = -ReadMem [24],ReadMem [23],ReadMem [22], ReadMem [21],ReadMem [20]-; ORMem [5] = -ReadMem [29],ReadMem [28],ReadMem [27], 106 ReadMem [26],ReadMem [25]-; ORMem [6] = -ReadMem [34],ReadMem [33],ReadMem [32], ReadMem [31],ReadMem [30]-; ORMem [7] = -ReadMem [39],ReadMem [38],ReadMem [37], ReadMem [36],ReadMem <p> ReadMem [36],ReadMem [35]-; ORMem [8] = -ReadMem [44],ReadMem [43],ReadMem [42], ReadMem [41],ReadMem [40]-; end /***********************/ /* Define the OR Plane */ /***********************/ initial begin $async$or$array (ORMem, -~Data [19],Data [19],~Data [18],Data [18], ~Data [17],Data [17],~Data [16],Data [16], ~Data [15],Data [15],~Data [14],Data [14], ~Data [13],Data [13],~Data [12],Data [12], ~Data [11],Data [11],~Data <ref> [10] </ref>,Data [10], ~Data [9],Data [9],~Data [8],Data [8], ~Data [7],Data [7],~Data [6],Data [6], ~Data [5],Data [5],~Data [4],Data [4], ~Data [3],Data [3],~Data [2],Data [2], ~Data [1],Data [1],~Data [0],Data [0]-, -OR_out [8],OR_out [7],OR_out [6],OR_out [5], OR_out [0]-); /*******************/ /* Output Selector */ /*******************/ Sel2 #(9) OutSel (9'b0,OR_out,Out,Gctx [1],start); endmodule 107 /* The following is necessary
Reference: [11] <author> David Jones and David Lewis. </author> <title> A time-multiplexed fpga architecture for logic emulation. </title> <booktitle> In Proceedings of the IEEE 1995 Custom Integrated Circuits Conference, </booktitle> <pages> pages 495-498. </pages> <publisher> IEEE, </publisher> <month> May </month> <year> 1995. </year>
Reference-contexts: 1 FPGA, Programmable Cellular Automata n 1 w reconfigurable ALUs Programmable Systolic Datapath Arrays n 1 bitwise SIMD 1 c w Traditional Processors n w Vector Processors 1 c 1 DPGA [20] n 8 16 PADDI [3] c w VLIW m 1 c n m w MSIMD c 1 VEGA <ref> [11] </ref> n 1 8 16 PADDI-2 [22] c w MIMD (traditional) Where: n is the number of processors w is the width of a single processor m is the number of program counters (PCs) c is the size of the instruction memories Table 2.1: Instruction/Control Architecture Taxonomy 21 ment and the <p> Several designs have been proposed including: the DPGA [20] which provides a small number of instructions per basic look-up table (4 in the current prototype), and VEGA <ref> [11] </ref> which provides 2048 instructions. 1 These devices all fix the number instructions on-chip at fabrication time, making it hard select the "correct" size of the instruction memories. <p> TempReg = Ctx2 [1]; MAdd2source = TempReg [3]; MAdd1source = TempReg [2]; TS_Enable = TempReg [1]; CarryPipeline = TempReg [0]; TempReg = Ctx2 [6]; Fa_a = -TempReg [0],Ctx2 [2]-; Fa_b = -TempReg [1], Ctx2 [3]-; Fm_a = -TempReg [2], Ctx2 [4]-; Fm_b = -TempReg [3], Ctx2 [5]-; TempReg = Ctx2 <ref> [11] </ref>; A_a = -TempReg [1:0], Ctx2 [7]-; A_b = -TempReg [3:2], Ctx2 [8]-; B_a = -TempReg [5:4], Ctx2 [9]-; B_b = -TempReg [7:6], Ctx2 [10]-; TempReg = Ctx2 [16]; N1_a = -TempReg [1:0], Ctx2 [12]-; N1_b = -TempReg [3:2], Ctx2 [13]-; N2_a = -TempReg [5:4], Ctx2 [14]-; N2_b = -TempReg [7:6], <p> TempReg = Ctx3 [1]; MAdd2source = TempReg [3]; MAdd1source = TempReg [2]; TS_Enable = TempReg [1]; CarryPipeline = TempReg [0]; TempReg = Ctx3 [6]; Fa_a = -TempReg [0],Ctx3 [2]-; Fa_b = -TempReg [1], Ctx3 [3]-; Fm_a = -TempReg [2], Ctx3 [4]-; Fm_b = -TempReg [3], Ctx3 [5]-; TempReg = Ctx3 <ref> [11] </ref>; A_a = -TempReg [1:0], Ctx3 [7]-; A_b = -TempReg [3:2], Ctx3 [8]-; B_a = -TempReg [5:4], Ctx3 [9]-; B_b = -TempReg [7:6], Ctx3 [10]-; TempReg = Ctx3 [16]; N1_a = -TempReg [1:0], Ctx3 [12]-; N1_b = -TempReg [3:2], Ctx3 [13]-; N2_a = -TempReg [5:4], Ctx3 [14]-; N2_b = -TempReg [7:6],
Reference: [12] <author> Ethan Mirsky. </author> <title> Matrix micro-architecture. </title> <type> Transit Note 130, </type> <institution> MIT Artificial Intelligence Laboratory, </institution> <month> November </month> <year> 1995. </year>
Reference-contexts: [3]-; Fm_a = -TempReg [2], Ctx2 [4]-; Fm_b = -TempReg [3], Ctx2 [5]-; TempReg = Ctx2 [11]; A_a = -TempReg [1:0], Ctx2 [7]-; A_b = -TempReg [3:2], Ctx2 [8]-; B_a = -TempReg [5:4], Ctx2 [9]-; B_b = -TempReg [7:6], Ctx2 [10]-; TempReg = Ctx2 [16]; N1_a = -TempReg [1:0], Ctx2 <ref> [12] </ref>-; N1_b = -TempReg [3:2], Ctx2 [13]-; N2_a = -TempReg [5:4], Ctx2 [14]-; N2_b = -TempReg [7:6], Ctx2 [15]-; TempReg = Ctx2 [21]; FP1_a = -TempReg [0], Ctx2 [17]-; FP1_b = -TempReg [1], Ctx2 [18]-; FP2_a = -TempReg [2], Ctx2 [19]-; FP2_b = -TempReg [3], Ctx2 [20]-; TempReg = Ctx2 [22]; <p> [3]-; Fm_a = -TempReg [2], Ctx3 [4]-; Fm_b = -TempReg [3], Ctx3 [5]-; TempReg = Ctx3 [11]; A_a = -TempReg [1:0], Ctx3 [7]-; A_b = -TempReg [3:2], Ctx3 [8]-; B_a = -TempReg [5:4], Ctx3 [9]-; B_b = -TempReg [7:6], Ctx3 [10]-; TempReg = Ctx3 [16]; N1_a = -TempReg [1:0], Ctx3 <ref> [12] </ref>-; N1_b = -TempReg [3:2], Ctx3 [13]-; N2_a = -TempReg [5:4], Ctx3 [14]-; N2_b = -TempReg [7:6], Ctx3 [15]-; TempReg = Ctx3 [21]; FP1_a = -TempReg [0], Ctx3 [17]-; FP1_b = -TempReg [1], Ctx3 [18]-; FP2_a = -TempReg [2], Ctx3 [19]-; FP2_b = -TempReg [3], Ctx3 [20]-; TempReg = Ctx3 [22]; <p> (CLK) && (PWE === 1'b1)) begin if (ProgAdd [6] === 1'b1) begin ReadMem [ProgAdd [5:0]] = ProgData; /********************/ /* Setup the ORMem */ /********************/ ORMem [0] = -ReadMem [4],ReadMem [3],ReadMem [2], ReadMem [1],ReadMem [0]-; ORMem [1] = -ReadMem [9],ReadMem [8],ReadMem [7], ReadMem [6],ReadMem [5]-; ORMem [2] = -ReadMem [14],ReadMem [13],ReadMem <ref> [12] </ref>, ReadMem [11],ReadMem [10]-; ORMem [3] = -ReadMem [19],ReadMem [18],ReadMem [17], ReadMem [16],ReadMem [15]-; ORMem [4] = -ReadMem [24],ReadMem [23],ReadMem [22], ReadMem [21],ReadMem [20]-; ORMem [5] = -ReadMem [29],ReadMem [28],ReadMem [27], 106 ReadMem [26],ReadMem [25]-; ORMem [6] = -ReadMem [34],ReadMem [33],ReadMem [32], ReadMem [31],ReadMem [30]-; ORMem [7] = -ReadMem [39],ReadMem [38],ReadMem <p> = -ReadMem [39],ReadMem [38],ReadMem [37], ReadMem [36],ReadMem [35]-; ORMem [8] = -ReadMem [44],ReadMem [43],ReadMem [42], ReadMem [41],ReadMem [40]-; end /***********************/ /* Define the OR Plane */ /***********************/ initial begin $async$or$array (ORMem, -~Data [19],Data [19],~Data [18],Data [18], ~Data [17],Data [17],~Data [16],Data [16], ~Data [15],Data [15],~Data [14],Data [14], ~Data [13],Data [13],~Data <ref> [12] </ref>,Data [12], ~Data [11],Data [11],~Data [10],Data [10], ~Data [9],Data [9],~Data [8],Data [8], ~Data [7],Data [7],~Data [6],Data [6], ~Data [5],Data [5],~Data [4],Data [4], ~Data [3],Data [3],~Data [2],Data [2], ~Data [1],Data [1],~Data [0],Data [0]-, -OR_out [8],OR_out [7],OR_out [6],OR_out [5], OR_out [0]-); /*******************/ /* Output Selector */ /*******************/ Sel2 #(9) OutSel (9'b0,OR_out,Out,Gctx [1],start); endmodule 107
Reference: [13] <author> Ethan Mirsky and Andre DeHon. </author> <title> Matrix: A reconfigurable computing architecture with configurable instruction distribution and deployable resources. </title> <booktitle> In Proceedings of the IEEE Workshop on FPGAs for Custom Computing Machines, </booktitle> <month> April </month> <year> 1996. </year>
Reference-contexts: Functional density measures the capacity per unit area of I am indebted to Andre DeHon for working through the details of these examples. This material first appeared in <ref> [13] </ref>. 57 a device. The capacity of a device is roughly the number of unit operations it can perform in a unit of time. In this case, we will measure the number of filter TAPs per unit area. We will use the second (s) as the unit of time. <p> [4]-; Fm_b = -TempReg [3], Ctx2 [5]-; TempReg = Ctx2 [11]; A_a = -TempReg [1:0], Ctx2 [7]-; A_b = -TempReg [3:2], Ctx2 [8]-; B_a = -TempReg [5:4], Ctx2 [9]-; B_b = -TempReg [7:6], Ctx2 [10]-; TempReg = Ctx2 [16]; N1_a = -TempReg [1:0], Ctx2 [12]-; N1_b = -TempReg [3:2], Ctx2 <ref> [13] </ref>-; N2_a = -TempReg [5:4], Ctx2 [14]-; N2_b = -TempReg [7:6], Ctx2 [15]-; TempReg = Ctx2 [21]; FP1_a = -TempReg [0], Ctx2 [17]-; FP1_b = -TempReg [1], Ctx2 [18]-; FP2_a = -TempReg [2], Ctx2 [19]-; FP2_b = -TempReg [3], Ctx2 [20]-; TempReg = Ctx2 [22]; L1_Enable = TempReg [3:0]; TempReg = <p> [4]-; Fm_b = -TempReg [3], Ctx3 [5]-; TempReg = Ctx3 [11]; A_a = -TempReg [1:0], Ctx3 [7]-; A_b = -TempReg [3:2], Ctx3 [8]-; B_a = -TempReg [5:4], Ctx3 [9]-; B_b = -TempReg [7:6], Ctx3 [10]-; TempReg = Ctx3 [16]; N1_a = -TempReg [1:0], Ctx3 [12]-; N1_b = -TempReg [3:2], Ctx3 <ref> [13] </ref>-; N2_a = -TempReg [5:4], Ctx3 [14]-; N2_b = -TempReg [7:6], Ctx3 [15]-; TempReg = Ctx3 [21]; FP1_a = -TempReg [0], Ctx3 [17]-; FP1_b = -TempReg [1], Ctx3 [18]-; FP2_a = -TempReg [2], Ctx3 [19]-; FP2_b = -TempReg [3], Ctx3 [20]-; TempReg = Ctx3 [22]; L1_Enable = TempReg [3:0]; TempReg =
Reference: [14] <author> Kouhei Nadehara, Miwako Hayashida, and Ichiro Kuroda. </author> <title> A Low-Power, 32-bit RISC Processor with Signal Processing Capability and its Multiply-Adder, </title> <booktitle> volume VIII of VLSI Signal Processing, </booktitle> <pages> pages 51-60. </pages> <publisher> IEEE, </publisher> <year> 1995. </year> <month> 160 </month>
Reference-contexts: In this example, k 61 because of the limited space in the ALU's register file memory. Larger FIRs could be supported using additional BFUs to store the extra sample and coefficient values. 62 Device MATRIX MIPS-X NEC VSP8 1996 Alpha mstep 32b mpy 64b mpy Reference ISSCC87 [10] <ref> [14] </ref> ISSCC96 [9] Size 8 BFUs 1 die 1 die 1 die Area 29M 2 /BFU 68M 2 1.2G 2 6.8G 2 Clock Rate 10 ns cycle 50 ns cycle 10 ns cycle 2.3 ns cycle Throughput 8 cycles/TAP 10+ cycles/TAP 4 cycles/TAP 1 cycle/TAP Density 0.054/ 2 s 0.029/ 2 <p> match application requirements and flexibility, giving it a robust performance density across a wide range of applications. 67 Architecture Reference Area and Time Filter TAPs 2 s 16b DSP ISSCC86 [21] 125 ns/TAP 0.090 CICC92 [17] 50 ns/TAP 0.072 32b RISC mstep MIPS-X [10] 50+ ns/TAP 0.029 32b RISC/DSP VSP8 <ref> [14] </ref> 40 ns/TAP 0.022 64b RISC 1996 Alpha [9] 2.3 ns/TAP 0.064 systolic 2 BFUs, 20ns/TAP 0.87 MATRIX microcode 8 BFUs, 80ns/TAP 0.054 VLIW 11 BFUs, 20ns/TAP 0.16 XC4K App. <p> [5]-; TempReg = Ctx2 [11]; A_a = -TempReg [1:0], Ctx2 [7]-; A_b = -TempReg [3:2], Ctx2 [8]-; B_a = -TempReg [5:4], Ctx2 [9]-; B_b = -TempReg [7:6], Ctx2 [10]-; TempReg = Ctx2 [16]; N1_a = -TempReg [1:0], Ctx2 [12]-; N1_b = -TempReg [3:2], Ctx2 [13]-; N2_a = -TempReg [5:4], Ctx2 <ref> [14] </ref>-; N2_b = -TempReg [7:6], Ctx2 [15]-; TempReg = Ctx2 [21]; FP1_a = -TempReg [0], Ctx2 [17]-; FP1_b = -TempReg [1], Ctx2 [18]-; FP2_a = -TempReg [2], Ctx2 [19]-; FP2_b = -TempReg [3], Ctx2 [20]-; TempReg = Ctx2 [22]; L1_Enable = TempReg [3:0]; TempReg = Ctx2 [23]; L2_1 = TempReg [1:0]; <p> [5]-; TempReg = Ctx3 [11]; A_a = -TempReg [1:0], Ctx3 [7]-; A_b = -TempReg [3:2], Ctx3 [8]-; B_a = -TempReg [5:4], Ctx3 [9]-; B_b = -TempReg [7:6], Ctx3 [10]-; TempReg = Ctx3 [16]; N1_a = -TempReg [1:0], Ctx3 [12]-; N1_b = -TempReg [3:2], Ctx3 [13]-; N2_a = -TempReg [5:4], Ctx3 <ref> [14] </ref>-; N2_b = -TempReg [7:6], Ctx3 [15]-; TempReg = Ctx3 [21]; FP1_a = -TempReg [0], Ctx3 [17]-; FP1_b = -TempReg [1], Ctx3 [18]-; FP2_a = -TempReg [2], Ctx3 [19]-; FP2_b = -TempReg [3], Ctx3 [20]-; TempReg = Ctx3 [22]; L1_Enable = TempReg [3:0]; TempReg = Ctx3 [23]; L2_1 = TempReg [1:0]; <p> ReadMem [31],ReadMem [30]-; ORMem [7] = -ReadMem [39],ReadMem [38],ReadMem [37], ReadMem [36],ReadMem [35]-; ORMem [8] = -ReadMem [44],ReadMem [43],ReadMem [42], ReadMem [41],ReadMem [40]-; end /***********************/ /* Define the OR Plane */ /***********************/ initial begin $async$or$array (ORMem, -~Data [19],Data [19],~Data [18],Data [18], ~Data [17],Data [17],~Data [16],Data [16], ~Data [15],Data [15],~Data <ref> [14] </ref>,Data [14], ~Data [13],Data [13],~Data [12],Data [12], ~Data [11],Data [11],~Data [10],Data [10], ~Data [9],Data [9],~Data [8],Data [8], ~Data [7],Data [7],~Data [6],Data [6], ~Data [5],Data [5],~Data [4],Data [4], ~Data [3],Data [3],~Data [2],Data [2], ~Data [1],Data [1],~Data [0],Data [0]-, -OR_out [8],OR_out [7],OR_out [6],OR_out [5], OR_out [0]-); /*******************/ /* Output Selector */ /*******************/ Sel2 #(9)
Reference: [15] <author> Gary J. Nutt. </author> <title> Microprocessor implementation of a parallel processor. </title> <booktitle> In Proceed--ings of the Fourth Annual International Symposium on Computer Architecture, </booktitle> <pages> pages 147-152. </pages> <publisher> ACM, </publisher> <year> 1977. </year>
Reference-contexts: In order to efficiently deal with these cases a number of architectures, including MSIMD (e.g. [2], <ref> [15] </ref>) have been developed. These devices allocate control units among a set of processing units. Like MATRIX, these devices can deploy control 74 units as applications require. Unlike MATRIX, the control and processing units are not the same, nor do data and control travel over the same network. <p> = -TempReg [1:0], Ctx2 [7]-; A_b = -TempReg [3:2], Ctx2 [8]-; B_a = -TempReg [5:4], Ctx2 [9]-; B_b = -TempReg [7:6], Ctx2 [10]-; TempReg = Ctx2 [16]; N1_a = -TempReg [1:0], Ctx2 [12]-; N1_b = -TempReg [3:2], Ctx2 [13]-; N2_a = -TempReg [5:4], Ctx2 [14]-; N2_b = -TempReg [7:6], Ctx2 <ref> [15] </ref>-; TempReg = Ctx2 [21]; FP1_a = -TempReg [0], Ctx2 [17]-; FP1_b = -TempReg [1], Ctx2 [18]-; FP2_a = -TempReg [2], Ctx2 [19]-; FP2_b = -TempReg [3], Ctx2 [20]-; TempReg = Ctx2 [22]; L1_Enable = TempReg [3:0]; TempReg = Ctx2 [23]; L2_1 = TempReg [1:0]; L2_2 = TempReg [3:2]; TempReg = <p> = -TempReg [1:0], Ctx3 [7]-; A_b = -TempReg [3:2], Ctx3 [8]-; B_a = -TempReg [5:4], Ctx3 [9]-; B_b = -TempReg [7:6], Ctx3 [10]-; TempReg = Ctx3 [16]; N1_a = -TempReg [1:0], Ctx3 [12]-; N1_b = -TempReg [3:2], Ctx3 [13]-; N2_a = -TempReg [5:4], Ctx3 [14]-; N2_b = -TempReg [7:6], Ctx3 <ref> [15] </ref>-; TempReg = Ctx3 [21]; FP1_a = -TempReg [0], Ctx3 [17]-; FP1_b = -TempReg [1], Ctx3 [18]-; FP2_a = -TempReg [2], Ctx3 [19]-; FP2_b = -TempReg [3], Ctx3 [20]-; TempReg = Ctx3 [22]; L1_Enable = TempReg [3:0]; TempReg = Ctx3 [23]; L2_1 = TempReg [1:0]; L2_2 = TempReg [3:2]; TempReg = <p> [ProgAdd [5:0]] = ProgData; /********************/ /* Setup the ORMem */ /********************/ ORMem [0] = -ReadMem [4],ReadMem [3],ReadMem [2], ReadMem [1],ReadMem [0]-; ORMem [1] = -ReadMem [9],ReadMem [8],ReadMem [7], ReadMem [6],ReadMem [5]-; ORMem [2] = -ReadMem [14],ReadMem [13],ReadMem [12], ReadMem [11],ReadMem [10]-; ORMem [3] = -ReadMem [19],ReadMem [18],ReadMem [17], ReadMem [16],ReadMem <ref> [15] </ref>-; ORMem [4] = -ReadMem [24],ReadMem [23],ReadMem [22], ReadMem [21],ReadMem [20]-; ORMem [5] = -ReadMem [29],ReadMem [28],ReadMem [27], 106 ReadMem [26],ReadMem [25]-; ORMem [6] = -ReadMem [34],ReadMem [33],ReadMem [32], ReadMem [31],ReadMem [30]-; ORMem [7] = -ReadMem [39],ReadMem [38],ReadMem [37], ReadMem [36],ReadMem [35]-; ORMem [8] = -ReadMem [44],ReadMem [43],ReadMem [42], ReadMem [41],ReadMem
Reference: [16] <author> Peter Ruetz. </author> <title> The architectures and design of a 20-mhz real-time dsp chip set. </title> <journal> IEEE Journal of Solid-State Circuits, </journal> <volume> 24(2) </volume> <pages> 338-348, </pages> <month> April </month> <year> 1989. </year>
Reference-contexts: Note [8] 64 CLBs, 184 ns/16-TAPs y 1.0 ICSPAT93 [4] 400 CLBs, 100ns/4-TAPs 0.080 PADDI2 ISSCC95 [22] 5 EXUs, 20ns/TAP 0.93 Full Custom JSSC89 <ref> [16] </ref> 45ns/64-TAPs z 6.1 JSSC90 [7] 33ns/16-TAPs 3.5 y symmetric filter; z - 24-bit accum. Table 8.6: FIR Survey - 8fi8 multiply, 16-bit Accumulate 68 Chapter 9 Relationship to Conventional Computing Devices As we have seen, MATRIX is capable of changing its architectural structure in order to match application needs. <p> [2]-; Fa_b = -TempReg [1], Ctx2 [3]-; Fm_a = -TempReg [2], Ctx2 [4]-; Fm_b = -TempReg [3], Ctx2 [5]-; TempReg = Ctx2 [11]; A_a = -TempReg [1:0], Ctx2 [7]-; A_b = -TempReg [3:2], Ctx2 [8]-; B_a = -TempReg [5:4], Ctx2 [9]-; B_b = -TempReg [7:6], Ctx2 [10]-; TempReg = Ctx2 <ref> [16] </ref>; N1_a = -TempReg [1:0], Ctx2 [12]-; N1_b = -TempReg [3:2], Ctx2 [13]-; N2_a = -TempReg [5:4], Ctx2 [14]-; N2_b = -TempReg [7:6], Ctx2 [15]-; TempReg = Ctx2 [21]; FP1_a = -TempReg [0], Ctx2 [17]-; FP1_b = -TempReg [1], Ctx2 [18]-; FP2_a = -TempReg [2], Ctx2 [19]-; FP2_b = -TempReg [3], <p> [2]-; Fa_b = -TempReg [1], Ctx3 [3]-; Fm_a = -TempReg [2], Ctx3 [4]-; Fm_b = -TempReg [3], Ctx3 [5]-; TempReg = Ctx3 [11]; A_a = -TempReg [1:0], Ctx3 [7]-; A_b = -TempReg [3:2], Ctx3 [8]-; B_a = -TempReg [5:4], Ctx3 [9]-; B_b = -TempReg [7:6], Ctx3 [10]-; TempReg = Ctx3 <ref> [16] </ref>; N1_a = -TempReg [1:0], Ctx3 [12]-; N1_b = -TempReg [3:2], Ctx3 [13]-; N2_a = -TempReg [5:4], Ctx3 [14]-; N2_b = -TempReg [7:6], Ctx3 [15]-; TempReg = Ctx3 [21]; FP1_a = -TempReg [0], Ctx3 [17]-; FP1_b = -TempReg [1], Ctx3 [18]-; FP2_a = -TempReg [2], Ctx3 [19]-; FP2_b = -TempReg [3], <p> = -ReadMem [34],ReadMem [33],ReadMem [32], ReadMem [31],ReadMem [30]-; ORMem [7] = -ReadMem [39],ReadMem [38],ReadMem [37], ReadMem [36],ReadMem [35]-; ORMem [8] = -ReadMem [44],ReadMem [43],ReadMem [42], ReadMem [41],ReadMem [40]-; end /***********************/ /* Define the OR Plane */ /***********************/ initial begin $async$or$array (ORMem, -~Data [19],Data [19],~Data [18],Data [18], ~Data [17],Data [17],~Data <ref> [16] </ref>,Data [16], ~Data [15],Data [15],~Data [14],Data [14], ~Data [13],Data [13],~Data [12],Data [12], ~Data [11],Data [11],~Data [10],Data [10], ~Data [9],Data [9],~Data [8],Data [8], ~Data [7],Data [7],~Data [6],Data [6], ~Data [5],Data [5],~Data [4],Data [4], ~Data [3],Data [3],~Data [2],Data [2], ~Data [1],Data [1],~Data [0],Data [0]-, -OR_out [8],OR_out [7],OR_out [6],OR_out [5], OR_out [0]-); /*******************/ /* Output
Reference: [17] <author> M. Shiraishi, M. Koizumi, A. Yamaguchi, and H. Hoike. </author> <title> User programmable 16bit 50ns dsp. </title> <booktitle> In Proceedings of the IEEE 1992 Custom Integrated Circuits Conference, pages 6.4.1-6.4.4. IEEE, </booktitle> <month> May </month> <year> 1992. </year>
Reference-contexts: While DSPs have tailored their datapath to performing signal processing operations, they include many more hardwired functional units, most of which are not needed for a given application. 65 Design MATRIX Toshiba 16b DSP Reference CICC92 <ref> [17] </ref> Size 11 BFUs 1 die Area 29M 2 /BFU 275M 2 Clock Rate 10 ns cycle 50 ns cycle Throughput 2 cycles/TAP 1 cycle/TAP Density 0.16/ 2 s 0.072/ 2 s T AP s= 2 s Table 8.5: VLIW FIR Performance Density Comparison 8.4.3 Conclusions This example demonstrates the advantages <p> In addition, as we have seen, MATRIX has the ability to change its design to match application requirements and flexibility, giving it a robust performance density across a wide range of applications. 67 Architecture Reference Area and Time Filter TAPs 2 s 16b DSP ISSCC86 [21] 125 ns/TAP 0.090 CICC92 <ref> [17] </ref> 50 ns/TAP 0.072 32b RISC mstep MIPS-X [10] 50+ ns/TAP 0.029 32b RISC/DSP VSP8 [14] 40 ns/TAP 0.022 64b RISC 1996 Alpha [9] 2.3 ns/TAP 0.064 systolic 2 BFUs, 20ns/TAP 0.87 MATRIX microcode 8 BFUs, 80ns/TAP 0.054 VLIW 11 BFUs, 20ns/TAP 0.16 XC4K App. <p> [8]-; B_a = -TempReg [5:4], Ctx2 [9]-; B_b = -TempReg [7:6], Ctx2 [10]-; TempReg = Ctx2 [16]; N1_a = -TempReg [1:0], Ctx2 [12]-; N1_b = -TempReg [3:2], Ctx2 [13]-; N2_a = -TempReg [5:4], Ctx2 [14]-; N2_b = -TempReg [7:6], Ctx2 [15]-; TempReg = Ctx2 [21]; FP1_a = -TempReg [0], Ctx2 <ref> [17] </ref>-; FP1_b = -TempReg [1], Ctx2 [18]-; FP2_a = -TempReg [2], Ctx2 [19]-; FP2_b = -TempReg [3], Ctx2 [20]-; TempReg = Ctx2 [22]; L1_Enable = TempReg [3:0]; TempReg = Ctx2 [23]; L2_1 = TempReg [1:0]; L2_2 = TempReg [3:2]; TempReg = Ctx2 [24]; L2_1_Enable = TempReg [1:0]; L2_2_Enable = TempReg [3:2]; <p> [8]-; B_a = -TempReg [5:4], Ctx3 [9]-; B_b = -TempReg [7:6], Ctx3 [10]-; TempReg = Ctx3 [16]; N1_a = -TempReg [1:0], Ctx3 [12]-; N1_b = -TempReg [3:2], Ctx3 [13]-; N2_a = -TempReg [5:4], Ctx3 [14]-; N2_b = -TempReg [7:6], Ctx3 [15]-; TempReg = Ctx3 [21]; FP1_a = -TempReg [0], Ctx3 <ref> [17] </ref>-; FP1_b = -TempReg [1], Ctx3 [18]-; FP2_a = -TempReg [2], Ctx3 [19]-; FP2_b = -TempReg [3], Ctx3 [20]-; TempReg = Ctx3 [22]; L1_Enable = TempReg [3:0]; TempReg = Ctx3 [23]; L2_1 = TempReg [1:0]; L2_2 = TempReg [3:2]; TempReg = Ctx3 [24]; L2_1_Enable = TempReg [1:0]; L2_2_Enable = TempReg [3:2]; <p> 1'b1) begin ReadMem [ProgAdd [5:0]] = ProgData; /********************/ /* Setup the ORMem */ /********************/ ORMem [0] = -ReadMem [4],ReadMem [3],ReadMem [2], ReadMem [1],ReadMem [0]-; ORMem [1] = -ReadMem [9],ReadMem [8],ReadMem [7], ReadMem [6],ReadMem [5]-; ORMem [2] = -ReadMem [14],ReadMem [13],ReadMem [12], ReadMem [11],ReadMem [10]-; ORMem [3] = -ReadMem [19],ReadMem [18],ReadMem <ref> [17] </ref>, ReadMem [16],ReadMem [15]-; ORMem [4] = -ReadMem [24],ReadMem [23],ReadMem [22], ReadMem [21],ReadMem [20]-; ORMem [5] = -ReadMem [29],ReadMem [28],ReadMem [27], 106 ReadMem [26],ReadMem [25]-; ORMem [6] = -ReadMem [34],ReadMem [33],ReadMem [32], ReadMem [31],ReadMem [30]-; ORMem [7] = -ReadMem [39],ReadMem [38],ReadMem [37], ReadMem [36],ReadMem [35]-; ORMem [8] = -ReadMem [44],ReadMem [43],ReadMem
Reference: [18] <author> Michael Slater. </author> <note> Microunity lifts veil on mediaprocessor. Microprocessor Report, 9(14):11 ff., </note> <month> October 23 </month> <year> 1995. </year>
Reference-contexts: Typically, this is accomplished through segmentable datapaths (e.g. [19] [1]). These generally exhibit SIMD instruction control for the datapath, but can be reconfigured to treat the n bit datapath as k, n k -bit words, for certain, restricted, values of k. Modern multimedia processors (e.g. <ref> [18] </ref> [6]) allow the datapath to be treated as a collection of 8, 16, 32, or 64 bit words. All of these architectures give users the ability to choose an appropriate granularity for their computation. However, they all control these datapaths in a SIMD manner. <p> [9]-; B_b = -TempReg [7:6], Ctx2 [10]-; TempReg = Ctx2 [16]; N1_a = -TempReg [1:0], Ctx2 [12]-; N1_b = -TempReg [3:2], Ctx2 [13]-; N2_a = -TempReg [5:4], Ctx2 [14]-; N2_b = -TempReg [7:6], Ctx2 [15]-; TempReg = Ctx2 [21]; FP1_a = -TempReg [0], Ctx2 [17]-; FP1_b = -TempReg [1], Ctx2 <ref> [18] </ref>-; FP2_a = -TempReg [2], Ctx2 [19]-; FP2_b = -TempReg [3], Ctx2 [20]-; TempReg = Ctx2 [22]; L1_Enable = TempReg [3:0]; TempReg = Ctx2 [23]; L2_1 = TempReg [1:0]; L2_2 = TempReg [3:2]; TempReg = Ctx2 [24]; L2_1_Enable = TempReg [1:0]; L2_2_Enable = TempReg [3:2]; TempReg = Ctx2 [25]; L3_V1 = <p> [9]-; B_b = -TempReg [7:6], Ctx3 [10]-; TempReg = Ctx3 [16]; N1_a = -TempReg [1:0], Ctx3 [12]-; N1_b = -TempReg [3:2], Ctx3 [13]-; N2_a = -TempReg [5:4], Ctx3 [14]-; N2_b = -TempReg [7:6], Ctx3 [15]-; TempReg = Ctx3 [21]; FP1_a = -TempReg [0], Ctx3 [17]-; FP1_b = -TempReg [1], Ctx3 <ref> [18] </ref>-; FP2_a = -TempReg [2], Ctx3 [19]-; FP2_b = -TempReg [3], Ctx3 [20]-; TempReg = Ctx3 [22]; L1_Enable = TempReg [3:0]; TempReg = Ctx3 [23]; L2_1 = TempReg [1:0]; L2_2 = TempReg [3:2]; TempReg = Ctx3 [24]; L2_1_Enable = TempReg [1:0]; L2_2_Enable = TempReg [3:2]; TempReg = Ctx3 [25]; L3_V1 = <p> ReadMem [26],ReadMem [25]-; ORMem [6] = -ReadMem [34],ReadMem [33],ReadMem [32], ReadMem [31],ReadMem [30]-; ORMem [7] = -ReadMem [39],ReadMem [38],ReadMem [37], ReadMem [36],ReadMem [35]-; ORMem [8] = -ReadMem [44],ReadMem [43],ReadMem [42], ReadMem [41],ReadMem [40]-; end /***********************/ /* Define the OR Plane */ /***********************/ initial begin $async$or$array (ORMem, -~Data [19],Data [19],~Data <ref> [18] </ref>,Data [18], ~Data [17],Data [17],~Data [16],Data [16], ~Data [15],Data [15],~Data [14],Data [14], ~Data [13],Data [13],~Data [12],Data [12], ~Data [11],Data [11],~Data [10],Data [10], ~Data [9],Data [9],~Data [8],Data [8], ~Data [7],Data [7],~Data [6],Data [6], ~Data [5],Data [5],~Data [4],Data [4], ~Data [3],Data [3],~Data [2],Data [2], ~Data [1],Data [1],~Data [0],Data [0]-, -OR_out [8],OR_out [7],OR_out [6],OR_out [5],
Reference: [19] <author> Lawrence Snyder. </author> <title> An inquiry into the benefits of multigauge parallel computation. </title> <booktitle> In Proceedings of the 1985 International Conference on Parallel Processing, </booktitle> <pages> pages 488-492. </pages> <publisher> IEEE, </publisher> <month> August </month> <year> 1985. </year>
Reference-contexts: Datapaths are assembled by composing BFUs through carry-chains. We saw an application-specific example of this processing style in Chapter 8. A number of other architectures have been proposed or built which can also adjust 71 to different datapath granularity. Typically, this is accomplished through segmentable datapaths (e.g. <ref> [19] </ref> [1]). These generally exhibit SIMD instruction control for the datapath, but can be reconfigured to treat the n bit datapath as k, n k -bit words, for certain, restricted, values of k. <p> [10]-; TempReg = Ctx2 [16]; N1_a = -TempReg [1:0], Ctx2 [12]-; N1_b = -TempReg [3:2], Ctx2 [13]-; N2_a = -TempReg [5:4], Ctx2 [14]-; N2_b = -TempReg [7:6], Ctx2 [15]-; TempReg = Ctx2 [21]; FP1_a = -TempReg [0], Ctx2 [17]-; FP1_b = -TempReg [1], Ctx2 [18]-; FP2_a = -TempReg [2], Ctx2 <ref> [19] </ref>-; FP2_b = -TempReg [3], Ctx2 [20]-; TempReg = Ctx2 [22]; L1_Enable = TempReg [3:0]; TempReg = Ctx2 [23]; L2_1 = TempReg [1:0]; L2_2 = TempReg [3:2]; TempReg = Ctx2 [24]; L2_1_Enable = TempReg [1:0]; L2_2_Enable = TempReg [3:2]; TempReg = Ctx2 [25]; L3_V1 = TempReg [1:0]; L3_V2 = TempReg [3:2]; <p> [10]-; TempReg = Ctx3 [16]; N1_a = -TempReg [1:0], Ctx3 [12]-; N1_b = -TempReg [3:2], Ctx3 [13]-; N2_a = -TempReg [5:4], Ctx3 [14]-; N2_b = -TempReg [7:6], Ctx3 [15]-; TempReg = Ctx3 [21]; FP1_a = -TempReg [0], Ctx3 [17]-; FP1_b = -TempReg [1], Ctx3 [18]-; FP2_a = -TempReg [2], Ctx3 <ref> [19] </ref>-; FP2_b = -TempReg [3], Ctx3 [20]-; TempReg = Ctx3 [22]; L1_Enable = TempReg [3:0]; TempReg = Ctx3 [23]; L2_1 = TempReg [1:0]; L2_2 = TempReg [3:2]; TempReg = Ctx3 [24]; L2_1_Enable = TempReg [1:0]; L2_2_Enable = TempReg [3:2]; TempReg = Ctx3 [25]; L3_V1 = TempReg [1:0]; L3_V2 = TempReg [3:2];
Reference: [20] <author> Edward Tau, Ian Eslick, Derrick Chen, Jeremy Brown, and Andre DeHon. </author> <title> A first generation dpga implementation. </title> <booktitle> In Proceedings of the Third Canadian Workshop on Field-Programmable Devices, </booktitle> <pages> pages 138-143, </pages> <month> May </month> <year> 1995. </year>
Reference-contexts: As a result, FPGA are not efficient for performing dynamically changing computations new operations require a long time to configure. Its important to note that this limit of one in FPGAs is not inherent to CCDs. Experimental devices, such as <ref> [20] </ref>, have put more than one configuration on a CCD, allowing a limited amount of cycle-by-cycle flexibility. 2.2.3 Number of Instruction Streams The number of instruction streams on a general-purpose computing device refers to the number of operations that can be performed in parallel. <p> Instruction Streams per Control Thread Instruction Memory per Stream Datapath Granularity Architecture/Examples 0 0 n/a Hardwired Functional Unit 0 1 FPGA, Programmable Cellular Automata n 1 w reconfigurable ALUs Programmable Systolic Datapath Arrays n 1 bitwise SIMD 1 c w Traditional Processors n w Vector Processors 1 c 1 DPGA <ref> [20] </ref> n 8 16 PADDI [3] c w VLIW m 1 c n m w MSIMD c 1 VEGA [11] n 1 8 16 PADDI-2 [22] c w MIMD (traditional) Where: n is the number of processors w is the width of a single processor m is the number of program <p> These devices are categorized by having multiple instruction stream operating under a single thread of control. 72 Multi-context gate arrays are FPGA-like devices which store multiple instruction (configurations) on-chip. Several designs have been proposed including: the DPGA <ref> [20] </ref> which provides a small number of instructions per basic look-up table (4 in the current prototype), and VEGA [11] which provides 2048 instructions. 1 These devices all fix the number instructions on-chip at fabrication time, making it hard select the "correct" size of the instruction memories. <p> = -TempReg [1:0], Ctx2 [12]-; N1_b = -TempReg [3:2], Ctx2 [13]-; N2_a = -TempReg [5:4], Ctx2 [14]-; N2_b = -TempReg [7:6], Ctx2 [15]-; TempReg = Ctx2 [21]; FP1_a = -TempReg [0], Ctx2 [17]-; FP1_b = -TempReg [1], Ctx2 [18]-; FP2_a = -TempReg [2], Ctx2 [19]-; FP2_b = -TempReg [3], Ctx2 <ref> [20] </ref>-; TempReg = Ctx2 [22]; L1_Enable = TempReg [3:0]; TempReg = Ctx2 [23]; L2_1 = TempReg [1:0]; L2_2 = TempReg [3:2]; TempReg = Ctx2 [24]; L2_1_Enable = TempReg [1:0]; L2_2_Enable = TempReg [3:2]; TempReg = Ctx2 [25]; L3_V1 = TempReg [1:0]; L3_V2 = TempReg [3:2]; L3_V3 = TempReg [5:4]; L3_V4 = <p> = -TempReg [1:0], Ctx3 [12]-; N1_b = -TempReg [3:2], Ctx3 [13]-; N2_a = -TempReg [5:4], Ctx3 [14]-; N2_b = -TempReg [7:6], Ctx3 [15]-; TempReg = Ctx3 [21]; FP1_a = -TempReg [0], Ctx3 [17]-; FP1_b = -TempReg [1], Ctx3 [18]-; FP2_a = -TempReg [2], Ctx3 [19]-; FP2_b = -TempReg [3], Ctx3 <ref> [20] </ref>-; TempReg = Ctx3 [22]; L1_Enable = TempReg [3:0]; TempReg = Ctx3 [23]; L2_1 = TempReg [1:0]; L2_2 = TempReg [3:2]; TempReg = Ctx3 [24]; L2_1_Enable = TempReg [1:0]; L2_2_Enable = TempReg [3:2]; TempReg = Ctx3 [25]; L3_V1 = TempReg [1:0]; L3_V2 = TempReg [3:2]; L3_V3 = TempReg [5:4]; L3_V4 = <p> /********************/ ORMem [0] = -ReadMem [4],ReadMem [3],ReadMem [2], ReadMem [1],ReadMem [0]-; ORMem [1] = -ReadMem [9],ReadMem [8],ReadMem [7], ReadMem [6],ReadMem [5]-; ORMem [2] = -ReadMem [14],ReadMem [13],ReadMem [12], ReadMem [11],ReadMem [10]-; ORMem [3] = -ReadMem [19],ReadMem [18],ReadMem [17], ReadMem [16],ReadMem [15]-; ORMem [4] = -ReadMem [24],ReadMem [23],ReadMem [22], ReadMem [21],ReadMem <ref> [20] </ref>-; ORMem [5] = -ReadMem [29],ReadMem [28],ReadMem [27], 106 ReadMem [26],ReadMem [25]-; ORMem [6] = -ReadMem [34],ReadMem [33],ReadMem [32], ReadMem [31],ReadMem [30]-; ORMem [7] = -ReadMem [39],ReadMem [38],ReadMem [37], ReadMem [36],ReadMem [35]-; ORMem [8] = -ReadMem [44],ReadMem [43],ReadMem [42], ReadMem [41],ReadMem [40]-; end /***********************/ /* Define the OR Plane */ /***********************/
Reference: [21] <author> Jef van Meerbergen, Frank Welten, Frans van Wijk, Jan Stoter, Jos Huisken, Antoine Delaruelle, and Karel Van Eerdewijk. </author> <title> An 8 mips cmos digital signal processor. </title> <booktitle> In 1985 IEEE International Solid-State Circuits Conference, Digst of Technical Papers, </booktitle> <pages> pages 84-85. </pages> <publisher> IEEE, </publisher> <month> February </month> <year> 1986. </year>
Reference-contexts: In addition, as we have seen, MATRIX has the ability to change its design to match application requirements and flexibility, giving it a robust performance density across a wide range of applications. 67 Architecture Reference Area and Time Filter TAPs 2 s 16b DSP ISSCC86 <ref> [21] </ref> 125 ns/TAP 0.090 CICC92 [17] 50 ns/TAP 0.072 32b RISC mstep MIPS-X [10] 50+ ns/TAP 0.029 32b RISC/DSP VSP8 [14] 40 ns/TAP 0.022 64b RISC 1996 Alpha [9] 2.3 ns/TAP 0.064 systolic 2 BFUs, 20ns/TAP 0.87 MATRIX microcode 8 BFUs, 80ns/TAP 0.054 VLIW 11 BFUs, 20ns/TAP 0.16 XC4K App. <p> [7]-; A_b = -TempReg [3:2], Ctx2 [8]-; B_a = -TempReg [5:4], Ctx2 [9]-; B_b = -TempReg [7:6], Ctx2 [10]-; TempReg = Ctx2 [16]; N1_a = -TempReg [1:0], Ctx2 [12]-; N1_b = -TempReg [3:2], Ctx2 [13]-; N2_a = -TempReg [5:4], Ctx2 [14]-; N2_b = -TempReg [7:6], Ctx2 [15]-; TempReg = Ctx2 <ref> [21] </ref>; FP1_a = -TempReg [0], Ctx2 [17]-; FP1_b = -TempReg [1], Ctx2 [18]-; FP2_a = -TempReg [2], Ctx2 [19]-; FP2_b = -TempReg [3], Ctx2 [20]-; TempReg = Ctx2 [22]; L1_Enable = TempReg [3:0]; TempReg = Ctx2 [23]; L2_1 = TempReg [1:0]; L2_2 = TempReg [3:2]; TempReg = Ctx2 [24]; L2_1_Enable = <p> [7]-; A_b = -TempReg [3:2], Ctx3 [8]-; B_a = -TempReg [5:4], Ctx3 [9]-; B_b = -TempReg [7:6], Ctx3 [10]-; TempReg = Ctx3 [16]; N1_a = -TempReg [1:0], Ctx3 [12]-; N1_b = -TempReg [3:2], Ctx3 [13]-; N2_a = -TempReg [5:4], Ctx3 [14]-; N2_b = -TempReg [7:6], Ctx3 [15]-; TempReg = Ctx3 <ref> [21] </ref>; FP1_a = -TempReg [0], Ctx3 [17]-; FP1_b = -TempReg [1], Ctx3 [18]-; FP2_a = -TempReg [2], Ctx3 [19]-; FP2_b = -TempReg [3], Ctx3 [20]-; TempReg = Ctx3 [22]; L1_Enable = TempReg [3:0]; TempReg = Ctx3 [23]; L2_1 = TempReg [1:0]; L2_2 = TempReg [3:2]; TempReg = Ctx3 [24]; L2_1_Enable =
Reference: [22] <author> Alfred K. Yeung and Jan M. Rabaey. </author> <title> A 2.4 gops data-drivern reconfigurable multiprocessor ic for dsp. </title> <booktitle> In Proceedings of the 1995 IEEE International Solid-State Circuits Conference, </booktitle> <pages> pages 108-109. </pages> <publisher> IEEE, </publisher> <month> February </month> <year> 1995. </year> <month> 161 </month>
Reference-contexts: 1 w reconfigurable ALUs Programmable Systolic Datapath Arrays n 1 bitwise SIMD 1 c w Traditional Processors n w Vector Processors 1 c 1 DPGA [20] n 8 16 PADDI [3] c w VLIW m 1 c n m w MSIMD c 1 VEGA [11] n 1 8 16 PADDI-2 <ref> [22] </ref> c w MIMD (traditional) Where: n is the number of processors w is the width of a single processor m is the number of program counters (PCs) c is the size of the instruction memories Table 2.1: Instruction/Control Architecture Taxonomy 21 ment and the device's resource allocation, the more efficient <p> Note [8] 64 CLBs, 184 ns/16-TAPs y 1.0 ICSPAT93 [4] 400 CLBs, 100ns/4-TAPs 0.080 PADDI2 ISSCC95 <ref> [22] </ref> 5 EXUs, 20ns/TAP 0.93 Full Custom JSSC89 [16] 45ns/64-TAPs z 6.1 JSSC90 [7] 33ns/16-TAPs 3.5 y symmetric filter; z - 24-bit accum. <p> Figure 9-5 shows an generic 2-PC, 32-bit MIMD machine implemented on MATRIX. Just as in the VLIW case, a variety of devices, such as PADDI-2 <ref> [22] </ref>, have chosen a specific data point, while MATRIX gives a designer the option of changing those choices. 9.5 Hybrid Architectures Certainly not all applications fall into one of the traditional computing realms discussed above. <p> [12]-; N1_b = -TempReg [3:2], Ctx2 [13]-; N2_a = -TempReg [5:4], Ctx2 [14]-; N2_b = -TempReg [7:6], Ctx2 [15]-; TempReg = Ctx2 [21]; FP1_a = -TempReg [0], Ctx2 [17]-; FP1_b = -TempReg [1], Ctx2 [18]-; FP2_a = -TempReg [2], Ctx2 [19]-; FP2_b = -TempReg [3], Ctx2 [20]-; TempReg = Ctx2 <ref> [22] </ref>; L1_Enable = TempReg [3:0]; TempReg = Ctx2 [23]; L2_1 = TempReg [1:0]; L2_2 = TempReg [3:2]; TempReg = Ctx2 [24]; L2_1_Enable = TempReg [1:0]; L2_2_Enable = TempReg [3:2]; TempReg = Ctx2 [25]; L3_V1 = TempReg [1:0]; L3_V2 = TempReg [3:2]; L3_V3 = TempReg [5:4]; L3_V4 = TempReg [7:6]; 97 TempReg <p> [12]-; N1_b = -TempReg [3:2], Ctx3 [13]-; N2_a = -TempReg [5:4], Ctx3 [14]-; N2_b = -TempReg [7:6], Ctx3 [15]-; TempReg = Ctx3 [21]; FP1_a = -TempReg [0], Ctx3 [17]-; FP1_b = -TempReg [1], Ctx3 [18]-; FP2_a = -TempReg [2], Ctx3 [19]-; FP2_b = -TempReg [3], Ctx3 [20]-; TempReg = Ctx3 <ref> [22] </ref>; L1_Enable = TempReg [3:0]; TempReg = Ctx3 [23]; L2_1 = TempReg [1:0]; L2_2 = TempReg [3:2]; TempReg = Ctx3 [24]; L2_1_Enable = TempReg [1:0]; L2_2_Enable = TempReg [3:2]; TempReg = Ctx3 [25]; L3_V1 = TempReg [1:0]; L3_V2 = TempReg [3:2]; L3_V3 = TempReg [5:4]; L3_V4 = TempReg [7:6]; TempReg = <p> the ORMem */ /********************/ ORMem [0] = -ReadMem [4],ReadMem [3],ReadMem [2], ReadMem [1],ReadMem [0]-; ORMem [1] = -ReadMem [9],ReadMem [8],ReadMem [7], ReadMem [6],ReadMem [5]-; ORMem [2] = -ReadMem [14],ReadMem [13],ReadMem [12], ReadMem [11],ReadMem [10]-; ORMem [3] = -ReadMem [19],ReadMem [18],ReadMem [17], ReadMem [16],ReadMem [15]-; ORMem [4] = -ReadMem [24],ReadMem [23],ReadMem <ref> [22] </ref>, ReadMem [21],ReadMem [20]-; ORMem [5] = -ReadMem [29],ReadMem [28],ReadMem [27], 106 ReadMem [26],ReadMem [25]-; ORMem [6] = -ReadMem [34],ReadMem [33],ReadMem [32], ReadMem [31],ReadMem [30]-; ORMem [7] = -ReadMem [39],ReadMem [38],ReadMem [37], ReadMem [36],ReadMem [35]-; ORMem [8] = -ReadMem [44],ReadMem [43],ReadMem [42], ReadMem [41],ReadMem [40]-; end /***********************/ /* Define the OR
References-found: 22

