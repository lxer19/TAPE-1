URL: http://http.cs.berkeley.edu/~halw/pentium.ps
Refering-URL: http://http.cs.berkeley.edu/~halw/
Root-URL: 
Title: Reflections on the Pentium Division Bug  
Author: Manuel Blum and Hal Wasserman 
Note: DRAFT  
Date: October 9, 1997  
Abstract-found: 0
Intro-found: 0
Reference: [1] <author> S. Ar, M. Blum, B. Codenotti, and P. </author> <title> Gemmell, "Checking approximate computations over the reals," </title> <booktitle> Proc. 25th Symp. Theory of Computing, </booktitle> <pages> pp. 786-795, </pages> <year> 1993. </year>
Reference-contexts: What if the matrix-components are real numbers, so that a correct matrix-product may include small round-off errors? <ref> [1] </ref> extends the Freivald checker to this case. Note the applicability of such techniques to pragmatic run-time checking of software. For we have here checked a complicated, O (n &gt;2 )-time program with a simple, O (n 2 )-time program.
Reference: [2] <author> M. Blum, </author> <title> "Designing programs to check their work," </title> <institution> Int'l Computer Science Institute Tech. Report TR-88-009, </institution> <month> Dec. </month> <year> 1988. </year>
Reference: [3] <author> M. Blum and S. Kannan, </author> <title> "Designing programs that check their work," </title> <booktitle> Proc. 21st Symp. Theory of Computing, </booktitle> <pages> pp. 86-97, </pages> <year> 1989. </year>
Reference: [4] <author> M. Blum, M. Luby, and R. Rubinfeld, </author> <title> "Self-testing/correcting with applications to numerical problems," </title> <journal> J. Computer and System Sciences, </journal> <volume> vol. 47, </volume> <pages> pp. 549-95, </pages> <month> Dec. </month> <year> 1993. </year> <note> October 9, 1997 DRAFT 24 </note>
Reference-contexts: We might also have available a straightforward, October 9, 1997 DRAFT 10 O (n 3 )-time matrix-multiplication program. Such a program would be easy to code, and, while slow, would hopefully be needed only rarely. Complex correcting <ref> [4] </ref> is a more rigorous methodology for correcting certain clean mathematical functions. Complex correcting is based on the fact that, for many functions f , we can efficiently compute f (x) if we know the value of f at several random-looking inputs other than x. <p> Since it is easy to determine, via a simple stage of random testing, that such a program is correct on most inputs, a self-corrector of this sort will then suffice to patch over the remaining, occasional errors, making the program effectively perfect. As an example of a complex corrector <ref> [4] </ref>, let us return to the problem from Section I-B of multiplying matrices A = 0 @ 0 3 3 1 A , B = B 0 -1 0 3 0 1 C A . Say that a program has calculated this product incorrectly, necessitating a self-correction. <p> B. A Corrector for Multiplication When our simple checker detects a multiplication error, the microprocessor might then circumvent this error by means of a complex corrector. We employ a standard method <ref> [4] </ref>, one closely related to the matrix-multiplication corrector from Section I-F; however, we must here attend to details of legal input range in a context of limited-accuracy real numbers. We assume that the essential task to be corrected is the multiplication of n-bit normalized significands A, B.
Reference: [5] <author> M. Blum, W. Evans, P. Gemmell, S. Kannan, and M. Naor, </author> <title> "Checking the correctness of memories," </title> <journal> Algo-rithmica, </journal> <volume> vol. 12, </volume> <pages> pp. 225-244, </pages> <address> Aug.-Sept. </address> <year> 1994. </year>
Reference: [6] <author> M. Blum and H. Wasserman, </author> <title> "Software reliability via run-time result-checking," </title> <note> http://http.cs.berkeley.edu/- ~blum/. Submitted to Journal of the ACM. Preliminary version: </note> <author> "Program result-checking: </author> <title> a theory of testing meets a test of theory," </title> <booktitle> Proc. 35th Symp. Foundations of Computer Science, </booktitle> <pages> pp. 382-392, </pages> <year> 1994. </year>
Reference-contexts: 1 Portions of Section I parallel <ref> [6, Section 1] </ref>. October 9, 1997 DRAFT 4 B B @ 0 3 3 1 C C B B @ 2 2 2 1 C C = B B @ 15 6 9 1 C C Fig. 1.
Reference: [7] <author> C. Boettcher and D. J. Mellema, </author> <title> "Program checkers: practical applications to real-time software," </title> <booktitle> Test Facility Working Group Conf., </booktitle> <year> 1995. </year>
Reference-contexts: This direction has been sporadically anticipated: indeed, simple run-time checks|e.g., checks that variables are in legal range|are sometimes employed in modern software development. But checking has never been given a full and sufficient trial. In our ongoing research ([6], <ref> [7] </ref>), we are taking first steps toward such a trial. Checking simple hardware functionalities is, arguably, more immediately practicable.
Reference: [8] <author> R. Butler and G. Finelli, </author> <title> "The infeasibility of quantifying the reliability of life-critical real-time software," </title> <journal> IEEE Trans. Software Engineering, </journal> <volume> vol. 19, </volume> <pages> pp. 3-12, </pages> <month> Jan. </month> <year> 1993. </year>
Reference-contexts: Finally, the two versions of a redundant program, unlike a program and its checker, are not substantially different from each other. Thus, it has been found that redundant programs often turn out to be quite similar and so suffer from correlated bugs <ref> [8] </ref>. DRAFT October 9, 1997 9 Let us also consider whether it does any good for a program to know when its behavior is buggy: for it could be argued that the user would notice buggy behavior in any case.
Reference: [9] <author> R. Freivald, </author> <title> "Fast probabilistic algorithms," </title> <booktitle> Springer Verlag Lecture Notes in Computer Science #74: Mathematical Foundations of Computer Science, </booktitle> <pages> pp. 57-69, </pages> <year> 1979. </year>
Reference-contexts: Checking the matrix multiplication from Fig. 1. As an example, we will consider Freivald's simple checker for matrix multiplication <ref> [9] </ref>. First recall that computing the product of two n fi n matrices by the most straightforward method|i.e., the top left component of the product in Fig. 1 is calculated to be (1 0) + (2 2) + (1 3) = 1|takes time O (n 3 ).
Reference: [10] <author> R. Freivald, </author> <title> "Fast probabilistic verification of number multiplication," </title> <journal> Automatic Control and Computer Sciences, </journal> <volume> vol. 13, no. 1, </volume> <pages> pp. 37-39, </pages> <year> 1979. </year>
Reference-contexts: If we then have only the high-order half of the product available for our check, we face the more difficult problem of checking approximate multiplication rather than exact multiplication. As far as we know, this problem remains open. 10 This is an application of a standard result-checking trick <ref> [10] </ref>. Moreover, it is a modern version of "casting out nines," a traditional check for arithmetic computations. DRAFT October 9, 1997 15 mod 73+ +mod 73 # #mod 73 72 932646904 Fig. 4. Checking multiplication, by a comparison of residues mod 73.
Reference: [11] <author> P. Gemmell, R. Lipton, R. Rubinfeld, M. Sudan, and A. Wigderson, </author> <title> "Self-testing/correcting for polynomials and for approximate functions," </title> <booktitle> Proc. 23rd Symp. Theory of Computing, </booktitle> <pages> pp. 32-42, </pages> <year> 1991. </year>
Reference: [12] <author> R. Rubinfeld, </author> <title> "On the robustness of functional equations," </title> <booktitle> Proc. 35th Symp. Foundations of Computer Science, </booktitle> <pages> pp. 288-299, </pages> <year> 1994. </year>
Reference-contexts: In particular, it is often possible to check a computational resource by making use of only more primitive resources. This leads to a productive methodology of hierarchical checking. For example, trigonometric functions may be corrected by reference to multiplication (see <ref> [12] </ref>, [13]), which may in turn be corrected by reference to addition (see Section II-B). (2). Even if both checker and program are buggy, we note that the checker is often substantially different from the program. <p> This argument can be made rigorous. October 9, 1997 DRAFT 12 Such complex correctors are possible for a broad variety of mathematical functions. Ru-binfeld <ref> [12] </ref> has shown that many naturally occurring functions satisfy robust functional equations which allow for correcting. Vainstein [13] has shown that a large class of functions satisfy polynomial functional equations, and has suggested that this may allow for correcting. We conclude our discussion of correcting with a note of caution.

References-found: 12

