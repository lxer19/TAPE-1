URL: http://www.cis.ohio-state.edu/~harrold/webpapers/coherent.ps
Refering-URL: http://www.cis.ohio-state.edu/~harrold/allpapers.html
Root-URL: 
Email: fharrold,grotherg@cis.ohio-state.edu  
Title: A Coherent Family of Analyzable Graph Representations for Object-Oriented Software  
Author: Mary Jean Harrold and Gregg Rothermel 
Address: 395 Dreese Lab, Columbus OH, 43210  
Affiliation: Department of Computer and Information Science Ohio State University  
Abstract: Many software engineering tools and techniques rely on graphical representations of software, such as control flow graphs, program dependence graphs, or system dependence graphs. To apply these tools and techniques to object-oriented software, we cannot necessarily use existing graphical representations of procedural software. Representations of object-oriented software, like those for procedural software, must depict individual procedures (methods) and entire programs; however, they must also depict classes and their interactions, and account for the effects of inheritance, polymorphism, and aggregation. These representations should facilitate the use of existing program analysis tools and techniques, rather than requiring us to create new techniques. A system for constructing and managing these representations should take advantage of the code reuse inherent in object-oriented software, by reusing representational components. In this paper, we describe a coherent family of graphical representations of object-oriented software that meets the foregoing requirements, and we outline the architecture of an efficient, extensible system for constructing and managing those representations. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> A. V. Aho, R. Sethi, and J. D. Ullman. </author> <booktitle> Compilers, Principles, Techniques, and Tools. </booktitle> <publisher> Addison-Wesley Publishing Company, </publisher> <year> 1986. </year>
Reference-contexts: We can also use control flow graphs to represent individual class methods. A control flow graph <ref> [1] </ref> for method M contains a node for each statement in M ; edges between nodes represent flow of control between statements. Labeled edges leaving nodes associated with conditional statements represent control paths taken when the condition evaluates to the value of the edge label.
Reference: [2] <author> S. R. Chidamber and C. F. Kemerer. </author> <title> A metrics suite for object-oriented design. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 20(6) </volume> <pages> 476-493, </pages> <month> June </month> <year> 1994. </year>
Reference-contexts: This technique can use the class hierarchy graph to determine which tests for a base class can be reused to test a derived class. The class hierarchy graph also provides information that can be useful for computing metrics for object-oriented software <ref> [2, 16] </ref>, such as numbers of data attributes, numbers of methods, visibility information, numbers of base classes, and depth and width of inheritance hierarchies. 2.2 Class Call Graphs A call graph represents static calling relationships among procedures. Nodes in a call graph represent procedures.
Reference: [3] <author> C. Ghezzi, M. Jazayeri, and D. Mandrioli. </author> <title> Fundamentals of Software Engineering. </title> <publisher> Prentice Hall, </publisher> <year> 1991. </year> <month> 20 </month>
Reference-contexts: An interclass call graph (ICCG) is composed of class call 9 For example, a component set may simply contain integer identifiers for (or pointers to) other nodes, edges, or component sets. 10 More precisely, the figure displays an is-composed-of relation <ref> [3] </ref> over the universe of graphs and component sets that are required for our representations. 15 graphs and an additional set of (interclass) call edges. 11 The figure depicts an incremental data organization, and shows the extent to which that data organization supports reuse of representational components.
Reference: [4] <author> M. J. Harrold, J. D. McGregor, and K. J. Fitzpatrick. </author> <title> Incremental testing of object-oriented class structures. </title> <booktitle> Proceedings of the 14th International Conference on Software Enginering, </booktitle> <pages> pages 68-80, </pages> <month> May </month> <year> 1992. </year>
Reference-contexts: Methods retrn, vend, and check are inherited from Coinbox and thus, connected to Changebox's class header node by inherited membership edges. Class hierarchy graphs are not defined at the interclass level. A class hierarchy graph has various uses. For example, one class testing technique <ref> [4] </ref> exploits the hierarchical nature of the inheritance relation to test a group of related classes. This technique can use the class hierarchy graph to determine which tests for a base class can be reused to test a derived class.
Reference: [5] <author> M. J. Harrold and G. Rothermel. </author> <title> Performing dataflow testing on classes. </title> <booktitle> Second ACM SIGSOFT Symposium on the Foundations of Software Engineering, </booktitle> <pages> pages 154-163, </pages> <month> December </month> <year> 1994. </year>
Reference-contexts: of objects, or calls to methods defined in other classes, we connect the class control flow graphs of the individual classes to form an interclass control flow graph. 4 In this sense, our graphs resemble the interprocedural control flow graphs defined originally by Landi and Ryder [12]. 5 In Reference <ref> [5] </ref>, we defined class control flow graphs to include a frame, which we discuss in Section 2.5 of this paper. <p> graph for the frame to the class control flow graph by connecting each call M node to the method entry node in the class control flow graph for M , and connecting M 's exit node to the appropriate frame return node. 8 We initially presented the frame in Reference <ref> [5] </ref>. That version of the frame contained five vertices; constructors and destructors were called within the frame loop. <p> We construct a framed interclass control flow graph using a technique that is similar to the one described above, except that for these graphs we use interclass control flow graphs. Framed class control flow graphs support direct use of flow-sensitive data flow and alias analysis techniques <ref> [5, 12] </ref>. The graphs thus facilitate data flow testing of classes [5]. Framed Class Dependence Graph To perform analyses that require dependence information about the class, we expand the program dependence graph for the frame, and add this expanded program dependence graph to the class dependence graph. <p> Framed class control flow graphs support direct use of flow-sensitive data flow and alias analysis techniques [5, 12]. The graphs thus facilitate data flow testing of classes <ref> [5] </ref>. Framed Class Dependence Graph To perform analyses that require dependence information about the class, we expand the program dependence graph for the frame, and add this expanded program dependence graph to the class dependence graph. The 13 portions of the graph. result is a framed class dependence graph.
Reference: [6] <author> M. J. Harrold and M. L. Soffa. </author> <title> Selecting data for integration testing. </title> <journal> IEEE Software, </journal> <pages> pages 58-65, </pages> <month> March </month> <year> 1991. </year>
Reference-contexts: Similar return edges connect the method exit nodes to the polymorphic return nodes. Class control flow graphs directly support the use of flow-sensitive data flow and alias algorithms [12]. The graphs thus facilitate data flow testing of interacting methods <ref> [6] </ref>. Class control flow graphs can also be used to gather metrics about the methods and interacting methods in the class. 8 2.4 Class Dependence Graphs Class dependence graphs are based on the system dependence graphs initially defined by Horwitz, Reps, and Binkley [7].
Reference: [7] <author> S. Horwitz, T. Reps, and D. Binkley. </author> <title> Interprocedural slicing using dependence graphs. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 12(1) </volume> <pages> 26-60, </pages> <month> January </month> <year> 1990. </year>
Reference-contexts: Class control flow graphs can also be used to gather metrics about the methods and interacting methods in the class. 8 2.4 Class Dependence Graphs Class dependence graphs are based on the system dependence graphs initially defined by Horwitz, Reps, and Binkley <ref> [7] </ref>. A system dependence graph represents control dependencies and data dependencies for an entire program by connecting program dependence graphs for each procedure in the program. <p> However, we also add formal-in and formal-out parameter nodes that match the actual-in and actual-out parameter nodes at the method entry node of the called method. Class dependence graphs directly support the use of forward and backward slicing techniques, originally 10 graph. defined by Horwitz, Reps, and Binkley <ref> [7] </ref>, that can be applied to the interacting methods in the class. Also, the regression testing technique of Reference [15] uses a similar graphical representation. 2.5 Framed Graphs In the previous subsections, we described various representations for classes and interacting classes. <p> Framed class dependence graphs support direct use of interprocedural forward and backward slicing techniques [13], originally defined by Horwitz, Reps, and Binkley <ref> [7] </ref>. 3 A system architecture For the family of graphical representations described in the previous section to be useful in practice, we must be able to construct and manage the representations efficiently.
Reference: [8] <author> D. Kung, J. Gao, P. Hsia, Y. Toyoshima, and C. Chen. </author> <title> Design recovery for software testing of object-oriented programs. </title> <booktitle> In Working Conference on Reverse Engineering, </booktitle> <pages> pages 202-211, </pages> <month> May </month> <year> 1993. </year>
Reference: [9] <author> D. Kung, J. Gao, P. Hsia, F. Wen, Y. Toyoshima, and C. Chen. </author> <title> Change impact identification in object-oriented software maintenance. </title> <booktitle> In International Conference on Software Maintenance '94, </booktitle> <pages> pages 202-211, </pages> <month> September </month> <year> 1994. </year>
Reference: [10] <author> D. Kung, J. Gao, P. Hsia, F. Wen, Y. Toyoshima, and C. Chen. </author> <title> Firewall regression testing and software maintenance of object-oriented systems. </title> <journal> Journal of Object-Oriented Programming, </journal> <year> 1994. </year>
Reference: [11] <author> D. Kung, N. Suchak, J. Gao, P. Hsia, Y. Toyoshima, and C. Chen. </author> <title> On object state testing. </title> <booktitle> In COMSAC 94, </booktitle> <year> 1994. </year>
Reference: [12] <author> W. Landi and B. Ryder. </author> <title> A safe approximate algorithm for interprocedural pointer aliasing. </title> <booktitle> In Proceedings of the ACM SIGPLAN '92 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 235-248, </pages> <month> June </month> <year> 1992. </year>
Reference-contexts: interact due to declarations of objects, or calls to methods defined in other classes, we connect the class control flow graphs of the individual classes to form an interclass control flow graph. 4 In this sense, our graphs resemble the interprocedural control flow graphs defined originally by Landi and Ryder <ref> [12] </ref>. 5 In Reference [5], we defined class control flow graphs to include a frame, which we discuss in Section 2.5 of this paper. <p> Call edges connect the two polymorphic call nodes to method header nodes for Coinbox::insert and Changebox::insert, respectively. Similar return edges connect the method exit nodes to the polymorphic return nodes. Class control flow graphs directly support the use of flow-sensitive data flow and alias algorithms <ref> [12] </ref>. The graphs thus facilitate data flow testing of interacting methods [6]. <p> We construct a framed interclass control flow graph using a technique that is similar to the one described above, except that for these graphs we use interclass control flow graphs. Framed class control flow graphs support direct use of flow-sensitive data flow and alias analysis techniques <ref> [5, 12] </ref>. The graphs thus facilitate data flow testing of classes [5]. Framed Class Dependence Graph To perform analyses that require dependence information about the class, we expand the program dependence graph for the frame, and add this expanded program dependence graph to the class dependence graph.
Reference: [13] <author> L. Larsen and M. J. Harrold. </author> <title> Slicing object-oriented software. </title> <booktitle> 18th International Conference on Software Engineering, </booktitle> <pages> pages 495-505, </pages> <month> March </month> <year> 1996. </year>
Reference-contexts: We construct a framed interclass control dependence graph using a technique that is similar to the one described above except that for these graphs we use interclass control dependence graphs. Framed class dependence graphs support direct use of interprocedural forward and backward slicing techniques <ref> [13] </ref>, originally defined by Horwitz, Reps, and Binkley [7]. 3 A system architecture For the family of graphical representations described in the previous section to be useful in practice, we must be able to construct and manage the representations efficiently.
Reference: [14] <author> B. A. Malloy, J. D. McGregor, A. Krishnaswamy, and M. Medikonda. </author> <title> An extensible program representation for object-oriented software. </title> <journal> ACM Sigplan Notices, </journal> <volume> 29(12) </volume> <pages> 38-47, </pages> <month> December </month> <year> 1994. </year>
Reference: [15] <author> G. Rothermel and M. J. Harrold. </author> <title> Selecting regression tests for object-oriented software. </title> <booktitle> Proceedings of Conference on Software Maintenance-1994, </booktitle> <pages> pages 14-25, </pages> <month> September </month> <year> 1994. </year>
Reference-contexts: Class dependence graphs directly support the use of forward and backward slicing techniques, originally 10 graph. defined by Horwitz, Reps, and Binkley [7], that can be applied to the interacting methods in the class. Also, the regression testing technique of Reference <ref> [15] </ref> uses a similar graphical representation. 2.5 Framed Graphs In the previous subsections, we described various representations for classes and interacting classes. Many of the analysis techniques that we want to perform on these classes function only on complete program representations. <p> This data organization supports system extensibility. For example, if we wish to add the class control dependence graphs required by the regression test selection algorithm of Reference <ref> [15] </ref> to our family of representations, we can easily build these graphs from component sets already defined for our family of representations.
Reference: [16] <author> M. Singh. </author> <title> A system for representing object-oriented software. </title> <type> Master's thesis, </type> <institution> Clemson University, </institution> <year> 1995. </year>
Reference-contexts: This technique can use the class hierarchy graph to determine which tests for a base class can be reused to test a derived class. The class hierarchy graph also provides information that can be useful for computing metrics for object-oriented software <ref> [2, 16] </ref>, such as numbers of data attributes, numbers of methods, visibility information, numbers of base classes, and depth and width of inheritance hierarchies. 2.2 Class Call Graphs A call graph represents static calling relationships among procedures. Nodes in a call graph represent procedures. <p> Thus far, our implementation creates control flow graphs and program dependence graphs for individual methods, and class hierarchy graphs and class call graphs. We have used our implementation to gather metrics for C++ classes <ref> [16] </ref>. In this paper, we have focused on analyzable representations for classes; however, a system for representing object-oriented software should also represent applications programs that use classes. Our family of representations is easily extended to provide the necessary graphs. <p> Acknowledgements This work was partially supported by grants from Microsoft, Inc. and Data General Corp., and by NSF under Grant CCR-9357811 to Clemson University and Ohio State University. Manvinder Singh implemented portions of our analysis system <ref> [16] </ref>.
References-found: 16

