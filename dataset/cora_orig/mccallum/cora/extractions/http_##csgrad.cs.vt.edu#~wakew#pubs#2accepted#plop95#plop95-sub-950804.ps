URL: http://csgrad.cs.vt.edu/~wakew/pubs/2accepted/plop95/plop95-sub-950804.ps
Refering-URL: http://csgrad.cs.vt.edu/~wakew/pubs/2accepted/plop95/
Root-URL: http://www.cs.vt.edu
Title: Improving Responsiveness in Interactive Applications Using Queues  
Author: William C. Wake B. Douglas Wake and Edward A. Fox 
Abstract: This paper presents a set of patterns for use in designing the low-level interaction structure of an interactive application. 
Abstract-found: 1
Intro-found: 1
Reference: [Ambriola & Notkin 1988] <author> Vincenzo Ambriola and David Notkin. </author> <title> Reasoning About Interactive Systems, </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 14(2), </volume> <month> February, </month> <year> 1988, </year> <pages> pp. 272-276. </pages>
Reference-contexts: In an interactive, or responsive, application, the program presents output in response to input, and the user reaction to that output can affect future input to the program <ref> [Ambriola & Notkin 1988] </ref>. 4 An interactive program must react to the user's actions as quickly as possible. In graphical applications in particular, timely reaction to user actions is critical to achieving an adequate interactive feel. <p> Generate Artificial Events 4. Decouple Execution and Output 1 Department of Computer Science, Virginia Tech. 2 Representing himself. 3 Department of Computer Science and the Computing Center, Virginia Tech 4 I'd appreciate a reference to the 3-way split of batch vs. real-time vs. reactive - it's not in <ref> [Ambriola & Notkin 1988] </ref>, but I believe it is from an article in either IEEE Computer or IEEE Software within the last five years. PLOP '95 submission: August 4, 1995 1 1.
Reference: [Apple 1985] <author> Apple Computer, Inc. </author> <title> Inside Macintosh, Volume I, </title> <publisher> Addison-Wesley, </publisher> <address> Reading, MA, </address> <year> 1985. </year> <note> QA76.8 M3 R67 1985. </note>
Reference-contexts: Examples Simulations. Simulations have long used an event queue structure for overall organization [Pooch & Wall 1993]. Programming for a graphical user interface. Programs on the Apple Macintosh uses an event-queue-based design for their basic structure <ref> [Apple 1985] </ref>. Microsoft Windows uses a similar structure [Petzold 1990]. However, many user interface frameworks such as PowerPlant [Metrowerks 1995] hide the event queue by using the Chain of Responsibility pattern [Gamma et al. 1995, p. 223]. <p> Examples Lisp systems may schedule garbage collection while the system is waiting for user input [Teitelman & Masinter 1981]. An editor can use idle time to write a file logging the current state (for use in crash and error recovery). The Macintosh <ref> [Apple 1985] </ref> supports null events to let the program do work while no user input is pending. PLOP '95 submission: August 4, 1995 7 4. <p> For example, dragging a window on the Macintosh causes an outline of the window to be dragged rather than its full contents. This lets display keep up with mouse motion, and makes the interaction feel smoother (especially on slower machines). Examples The Macintosh <ref> [Apple 1985] </ref> uses a dirty region event (on the input event queue, however) to tell an application it must update its windows. [Finseth 1991] describes Emacs output as a pair of processes, one creating the text, the other trying to keep up with displaying it.
Reference: [Finseth 1991] <author> Finseth, Craig A. </author> <title> The Craft of Text Editing: Emacs for the Modern World, </title> <publisher> Springer-Verlag, </publisher> <address> New York, NY, </address> <year> 1991. </year> <note> QA76.76 T49 F56 1991. PLOP '95 submission: August 4, 1995 9 </note>
Reference-contexts: This lets display keep up with mouse motion, and makes the interaction feel smoother (especially on slower machines). Examples The Macintosh [Apple 1985] uses a dirty region event (on the input event queue, however) to tell an application it must update its windows. <ref> [Finseth 1991] </ref> describes Emacs output as a pair of processes, one creating the text, the other trying to keep up with displaying it. The WM CPU decouples input and output queues for better performance ([Wulf 1988]). <p> These patterns are not applicable only to systems with graphical interfaces - even strictly keyboard-based interfaces can make use of them. The final pattern (Decouple Execution and Output (4)) represents an old idea that's coming back around. The Emacs editor has long decoupled the display from command execution <ref> [Finseth 1991] </ref>. The idea is achieving prominence again due to the requirements of virtual reality systems. Acknowledgements This paper has benefitted from discussions with and criticisms from Steve Wake (STL, Blacksburg, VA) and the conference reviewer. The first and third authors were partially supported by NSF grant IRI-9116991.
Reference: [Gamma et al. 1995] <author> Erich Gamma, Richard Helm, Ralph Johnson, and John Vlissides. </author> <title> Design Patterns: Elements of Reusable Object-Oriented Software, </title> <publisher> Addison-Wesley, </publisher> <address> Reading, MA, </address> <year> 1995. </year> <month> QA76.64 D47 </month> <year> 1994. </year>
Reference-contexts: Programs on the Apple Macintosh uses an event-queue-based design for their basic structure [Apple 1985]. Microsoft Windows uses a similar structure [Petzold 1990]. However, many user interface frameworks such as PowerPlant [Metrowerks 1995] hide the event queue by using the Chain of Responsibility pattern <ref> [Gamma et al. 1995, p. 223] </ref>. Related Patterns There is usually only one event queue per application; it might be an instance of the Singleton pattern [Gamma et al. 1995, p. 127]. Events are a low-level structure. <p> However, many user interface frameworks such as PowerPlant [Metrowerks 1995] hide the event queue by using the Chain of Responsibility pattern [Gamma et al. 1995, p. 223]. Related Patterns There is usually only one event queue per application; it might be an instance of the Singleton pattern <ref> [Gamma et al. 1995, p. 127] </ref>. Events are a low-level structure. You should consider using the Command and/or Chain of Responsibility patterns from [Gamma et al. 1995, pp. 233 and 223 respectively]. <p> Related Patterns There is usually only one event queue per application; it might be an instance of the Singleton pattern [Gamma et al. 1995, p. 127]. Events are a low-level structure. You should consider using the Command and/or Chain of Responsibility patterns from <ref> [Gamma et al. 1995, pp. 233 and 223 respectively] </ref>. Command can encapsulate an event into an object; Chain of Responsibility can dispatch the event to the object that should handle it. <p> Related Patterns The Merge Compatible Events (2) and Generate Artificial Events (3) patterns can be applied to the output queue as well. This is a variation on the Observer pattern of <ref> [Gamma et al. 1995, p. 293] </ref>. In the classical Model-View-Controller architecture, views update synchronously after changes in the model. This pattern splits view updating from the model changes. <p> When nothing is happening, Generate Artificial Events (3) generates null events, which cause new action to occur. Many user interface frameworks hide the event queue. Instead, they construct a layer above the queue, and make it seem that messages are sent to interaction objects (using Chain of Responsibility from <ref> [Gamma et al. 1995] </ref>). These patterns aren't meant to preclude hiding the events - but rather to suggest ways to change event dispatching to improve responsiveness. Applications that are not using a framework may be able to apply the patterns directly.
Reference: [Metrowerks 1995] <author> Metrowerks, Inc. </author> <title> Inside CodeWarrior 6, Metrowerks, </title> <address> Mooers, NY, </address> <year> 1995. </year>
Reference-contexts: Programming for a graphical user interface. Programs on the Apple Macintosh uses an event-queue-based design for their basic structure [Apple 1985]. Microsoft Windows uses a similar structure [Petzold 1990]. However, many user interface frameworks such as PowerPlant <ref> [Metrowerks 1995] </ref> hide the event queue by using the Chain of Responsibility pattern [Gamma et al. 1995, p. 223]. Related Patterns There is usually only one event queue per application; it might be an instance of the Singleton pattern [Gamma et al. 1995, p. 127]. Events are a low-level structure.
Reference: [Petzold 1990] <author> Charles Petzold. </author> <title> Programming Windows: The Microsoft Guide to writing applications for Windows 3, </title> <publisher> Microsoft Press, </publisher> <address> Redmond, WA, </address> <year> 1990. </year> <note> QA76.8 I2594 P474 1990. </note>
Reference-contexts: Examples Simulations. Simulations have long used an event queue structure for overall organization [Pooch & Wall 1993]. Programming for a graphical user interface. Programs on the Apple Macintosh uses an event-queue-based design for their basic structure [Apple 1985]. Microsoft Windows uses a similar structure <ref> [Petzold 1990] </ref>. However, many user interface frameworks such as PowerPlant [Metrowerks 1995] hide the event queue by using the Chain of Responsibility pattern [Gamma et al. 1995, p. 223]. <p> Microsoft Windows has a repeat count field in the event record, to indicate that a string of several identical keystrokes was combined into one event. (However, <ref> [Petzold 1990, p. 92] </ref> indicates that many programs ignore the count.) PLOP '95 submission: August 4, 1995 5 3.
Reference: [Pooch & Wall 1993] <author> Udo W. Pooch and James A. Wall. </author> <title> Discrete Event Simulation: A Practical Approach, </title> <publisher> CRC Press, </publisher> <address> Boca Raton, FL, </address> <year> 1993. </year> <note> QA76.9 C55 P66 1993. </note>
Reference-contexts: input as events, such as mouse movement or keystrokes Problem The program must systematically deal with a mix of several event types Solution To accommodate low-level interaction as used in GUI programs, we can adopt one of the classical architectures used by simulation programs: an event queue. (For example, see <ref> [Pooch & Wall 1993] </ref>.) For each event in the queue, information about the type of the event (e.g., keystroke) is augmented with a timestamp and data specific to that type of event (e.g., shift-A). Events in the queue are ordered by time. <p> Event-driven applications often strive to minimize the number of modes. Such applications must be prepared to deal with many types of events in various program contexts. Examples Simulations. Simulations have long used an event queue structure for overall organization <ref> [Pooch & Wall 1993] </ref>. Programming for a graphical user interface. Programs on the Apple Macintosh uses an event-queue-based design for their basic structure [Apple 1985]. Microsoft Windows uses a similar structure [Petzold 1990].
Reference: [Sha & Goodenough 1990] <author> Liu Sha and John B. Goodenough. </author> <title> Real-Time Scheduling Theory and Ada, </title> <journal> IEEE Computer, </journal> <volume> 23(4), </volume> <month> April, </month> <year> 1990, </year> <pages> pp. 53-62. </pages>
Reference-contexts: In a batch application, output is not synchronized with input. (The input data is determined before the program is run.) In a real-time application, the program reacts to the passage of time (and the correctness of a computation depends upon when the result of that computation is delivered, see e.g., <ref> [Sha & Goodenough 1990] </ref>). In an interactive, or responsive, application, the program presents output in response to input, and the user reaction to that output can affect future input to the program [Ambriola & Notkin 1988]. 4 An interactive program must react to the user's actions as quickly as possible.
Reference: [Teitelman & Masinter 1981] <author> Warren Teitelman and Larry Masinter. </author> <title> The Interlisp Programming Environment, </title> <journal> IEEE Computer, </journal> <volume> 14(4), </volume> <month> April, </month> <year> 1981, </year> <pages> pp. 25-34. </pages> <note> Reprinted in Barstow, </note> <editor> Shrobe, and Sandewall (editors), </editor> <title> Interactive Programming Environments, </title> <publisher> McGraw-Hill, </publisher> <year> 1984. </year> <month> QA76.6 I525 </month> <year> 1984. </year>
Reference-contexts: Unfortunately, many operating systems make this less feasible, as they don't provide for thread-safe interaction with the operating system. Examples Lisp systems may schedule garbage collection while the system is waiting for user input <ref> [Teitelman & Masinter 1981] </ref>. An editor can use idle time to write a file logging the current state (for use in crash and error recovery). The Macintosh [Apple 1985] supports null events to let the program do work while no user input is pending.
Reference: [UVa UIG 1995] <author> UVa User Interface Group, Alice: </author> <title> Rapid Prototyping for Virtual Reality, </title> <journal> IEEE Computer Graphics and Applications, </journal> <volume> 15(3), </volume> <month> May, </month> <year> 1995, </year> <pages> pp. 8-11. </pages>
Reference-contexts: The WM CPU decouples input and output queues for better performance ([Wulf 1988]). Virtual reality systems can use this decoupling to allow regular updates of the display at a rate independent of the speed at which the world is updated (e.g., <ref> [UVa UIG 1995] </ref>). Related Patterns The Merge Compatible Events (2) and Generate Artificial Events (3) patterns can be applied to the output queue as well. This is a variation on the Observer pattern of [Gamma et al. 1995, p. 293].
Reference: [Wulf 1988] <author> Wm. A. Wulf. </author> <title> The WM Computer Architecture, </title> <journal> ACM Computer Architecture News, </journal> <volume> 16(1), </volume> <year> 1988, </year> <pages> pp. 70-84. </pages> <address> PLOP '95 submission: </address> <month> August 4, </month> <year> 1995 </year> <month> 10 </month>
References-found: 11

