URL: ftp://ftp.cs.utexas.edu/pub/predator/icse-15.ps
Refering-URL: http://www.cs.utexas.edu/users/schwartz/pub.htm
Root-URL: 
Email: singhal-@cs.utexas.edu  
Title: Software Components in a Data Structure Precompiler  
Author: Marty Sirkin, Don Batory, Vivek Singhal -marty, batory, 
Note: 1: Introduction  
Address: Austin, Texas 78712  
Affiliation: Department of Computer Sciences The University of Texas at Austin  
Abstract: PREDATOR is a data structure precompiler that generates efficient code for maintaining and querying complex data structures. It embodies a novel component reuse technology that transcends traditional generic data types. In this paper, we explain the concepts of our work and our prototype system. We show how complex data structures can be specified as compositions of software building blocks, and present performance results that compare PREDATOR output to hand-optimized programs. Designing, writing, and debugging programs is a time-intensive task. Of the different aspects of writing programs of moderate to large complexity, implementing data structures often consumes a disproportionally large fraction of a programmer's time. A data structure compiler is a suite of tools that reduces the burden of programming data structures. There have been several attempts to produce such compilers. Three examples are [10, 19, 25]. In general, however, data structure compilers have not achieved a broad level of acceptance. The reasons include inadequate performance, unnecessary complexity, host language restrictions, and limited scope. Eliminating the drudgery of programming data structures is clearly an important problem. We believe the solution rests on a software component technology that is defined by a combination of concepts from databases, compilers, transformation systems, and domain modelling. While none of these concepts are new, we are presenting a unique combination that yields a technology for assembling complex data structures from plug-compatible components. Two goals of a data structure compiler should be: 1. To generate efficient code, i.e. within 10% of highly 
Abstract-found: 1
Intro-found: 1
Reference: [1] <editor> ACM. </editor> <title> Next Generation Database Systems. </title> <journal> Communications of the ACM, </journal> <month> October </month> <year> 1991. </year>
Reference-contexts: Databases are classical examples of systems that have successfully exploited plug-compatible implementations of containers [4]. Our container interface largely reects work on embedded relational languages and persistent languages. Iterations over subsets of objects in a container are accomplished through the use of iterators or cursors <ref> [13, 14, 1, 6] </ref>. Cursors provide SQL-like select capabilities where programmers declaratively specify via predicates the records (or objects) of a container that they want to retrieve [11]. Table 1 lists some of the operations of our container interface. In PREDATOR, cursors and containers are first-class objects.
Reference: [2] <author> A. V. Aho, J. E. Hopcroft, and J. D. Ullman. </author> <title> Data Structures and Algorithms, </title> <publisher> Addison-Wesley, </publisher> <year> 1983. </year>
Reference-contexts: Modifying and debugging BSD quicksort is nontrivial. Initially we intended to extract the data structure generic algorithm implemented by the BSD code, but discovered that it was too tightly coupled to the array data structure for this to be possible. Instead, we implemented the quicksort algorithm in <ref> [2] </ref> with a pivot selection and base case handling similar to the BSD version. This was important, as it assured the asymptotic complexity of both algorithms would be similar, thereby permitting a fair comparison to be made. <p> The actual experiments involved sorting randomized sets of unique records. Randomization is important because the two algorithms use slightly different pivot selection methods. Uniqueness is significant because the PREDATOR <ref> [2] </ref> algorithm improves greatly when there exist duplicates and we did not want that to bias the results. Also, we ran each sample size many times to arrive at an accurate mean time. The following graph shows the average sorting time for sample sizes ranging from 1000 to 110,000 records.
Reference: [3] <author> D. S. Batory. </author> <title> Concepts for a DBMS Synthesizer. </title> <booktitle> Symposium on Princ. of Database Sys., </booktitle> <year> 1988. </year>
Reference-contexts: In addition to PREDATOR, another prototype implementation of these ideas is the Genesis extensible database management system. Genesis can produce a customized DBMS of 70K lines by assembling prefabricated components <ref> [3, 4] </ref>. 3.4: Conceptual Limitation: Type Transformations Recall that there are type transformations which do not add fields and operations to data types. <p> When PREDATOR composes multiple NPTs, it performs compiler optimizations such as common sub expression elimination and partial evaluation. 2. PREDATOR expands inline code, thus removing runtime functional call overhead [12]. 3. PREDATOR optimizes queries to determine the most efficient way to traverse a container <ref> [14, 3] </ref>. In the following sections, we report the results of three experiments using PREDATOR. We specifically examine the performance of generated code, the potential gains in software productivity, and the advantages of using plug-compatible data structures.
Reference: [4] <author> D. S. Batory. </author> <title> The Genesis Database System Compiler: User Manual, </title> <institution> University of Texas TR-90-27. </institution>
Reference-contexts: Note that typical database systems offer multiple container implementations which can be either selected by users or chosen at runtime by query optimizers. Databases are classical examples of systems that have successfully exploited plug-compatible implementations of containers <ref> [4] </ref>. Our container interface largely reects work on embedded relational languages and persistent languages. Iterations over subsets of objects in a container are accomplished through the use of iterators or cursors [13, 14, 1, 6]. <p> In addition to PREDATOR, another prototype implementation of these ideas is the Genesis extensible database management system. Genesis can produce a customized DBMS of 70K lines by assembling prefabricated components <ref> [3, 4] </ref>. 3.4: Conceptual Limitation: Type Transformations Recall that there are type transformations which do not add fields and operations to data types.
Reference: [5] <author> T. Biggerstaff and A. Perlis. </author> <title> Software Reusability, </title> <publisher> ACM Press, </publisher> <year> 1989. </year>
Reference-contexts: For example, Figure 1 depicts a linked list TPT that has been instantiated with a binary tree TPT, where each node of the list is the root of a distinct binary tree. trees There is no consensus on how software reuse can be achieved <ref> [5] </ref>. In our opinion, there are three requirements for successful software reuse. First, software components must be designed to be plug-compatible and interchangeable. Second, programming languages should provide appropriate features for implementing such designs. And third, these designs and programming language features should not incur exorbitant performance penalties.
Reference: [6] <author> G. Booch. </author> <title> Software Components with ADA, </title> <publisher> Benjamin/ Cummings Publishing, </publisher> <year> 1987. </year>
Reference-contexts: A common event is for a customer to leave the middle of a queue when he realizes he needs another item. Head of list Specialization is the process of modifying a type to provide a customized interface for an application. Specialization of TPTs poses some difficult problems <ref> [6, 9, 20, 24] </ref>: Attempting to provide an exhaustive TPT interface actually discourages reuse. Programmers are intimidated by complex interfaces and would rather design their own. Given TPT source code, a programmer could attempt to integrate his own changes. <p> Even with the addition of object-oriented inheritance, these prob lems remain. 2. Complex compositions (conceptual limitation). It is widely believed that TPTs are the appropriate abstraction for encapsulating primitive data structures <ref> [6, 17, 18] </ref>. More complex structures, such as the one depicted in Figure 1, are created through TPT compositions. Software component libraries are unlikely to provide implementations for many data structures used in practice; rather, the idea is to form complex structures through composition of available TPTs. <p> Other languages such as SELF [8] provide more sophisticated inheritance mechanisms, but still suffer from generality (lack of knowledge about the data structures domain) and hence are not particularly efficient in creating merged, efficient components. Mapping TPTs <ref> [6] </ref> can be used to simulate (but not match identically) the structure of Figure 2, but glue code still needs to be written. Moreover, the resulting composite TPT incurs an additional performance penalty because mapping TPTs introduce extra pointer indirections. <p> This can be accomplished by carefully designing standardized interfaces for TPTs. Poorly designed TPTs or TPTs with incompatible interfaces make the task of a data structure compiler difficult, if not impossible. In practice, we note that existing component libraries <ref> [6, 7, 16] </ref> tend not to provide the same interface for all components. 6. Code efficiency (implementation limitation). A standard technique of implementing TPTs is to compile the code for each TPT component separately, where references and manipulations of generic objects are performed via pointers [13]. <p> Databases are classical examples of systems that have successfully exploited plug-compatible implementations of containers [4]. Our container interface largely reects work on embedded relational languages and persistent languages. Iterations over subsets of objects in a container are accomplished through the use of iterators or cursors <ref> [13, 14, 1, 6] </ref>. Cursors provide SQL-like select capabilities where programmers declaratively specify via predicates the records (or objects) of a container that they want to retrieve [11]. Table 1 lists some of the operations of our container interface. In PREDATOR, cursors and containers are first-class objects.
Reference: [7] <author> G. Booch and M. Vilot. </author> <title> The Design of the C++ Booch Components. </title> <booktitle> OOPSLA ECOOP 90, </booktitle> <publisher> ACM Press, </publisher> <year> 1990. </year>
Reference-contexts: This can be accomplished by carefully designing standardized interfaces for TPTs. Poorly designed TPTs or TPTs with incompatible interfaces make the task of a data structure compiler difficult, if not impossible. In practice, we note that existing component libraries <ref> [6, 7, 16] </ref> tend not to provide the same interface for all components. 6. Code efficiency (implementation limitation). A standard technique of implementing TPTs is to compile the code for each TPT component separately, where references and manipulations of generic objects are performed via pointers [13].
Reference: [8] <author> C. Chambers, D. Unger, and E. Lee. </author> <title> An Efficient Implementation of SELF, a Dynamically-Typed Object-Oriented Language Based on Prototypes. </title> <booktitle> OOPSLA 89, </booktitle> <publisher> ACM Press, </publisher> <year> 1989. </year>
Reference-contexts: The structure of Figure 2 can be created using approaches such as composing TPTs via multiple inheritance. However, application programmers must write additional glue code to achieve the correct semantics in the resulting composite TPT. Other languages such as SELF <ref> [8] </ref> provide more sophisticated inheritance mechanisms, but still suffer from generality (lack of knowledge about the data structures domain) and hence are not particularly efficient in creating merged, efficient components.
Reference: [9] <author> S. Cohen. </author> <title> Ada 9X Project Report, </title> <year> 1990. </year>
Reference-contexts: A common event is for a customer to leave the middle of a queue when he realizes he needs another item. Head of list Specialization is the process of modifying a type to provide a customized interface for an application. Specialization of TPTs poses some difficult problems <ref> [6, 9, 20, 24] </ref>: Attempting to provide an exhaustive TPT interface actually discourages reuse. Programmers are intimidated by complex interfaces and would rather design their own. Given TPT source code, a programmer could attempt to integrate his own changes.
Reference: [10] <author> D. Cohen. </author> <title> AP5 Manual, </title> <institution> USC Information Sciences Institute, </institution> <year> 1991. </year>
Reference-contexts: A data structure compiler is a suite of tools that reduces the burden of programming data structures. There have been several attempts to produce such compilers. Three examples are <ref> [10, 19, 25] </ref>. In general, however, data structure compilers have not achieved a broad level of acceptance. The reasons include inadequate performance, unnecessary complexity, host language restrictions, and limited scope. Eliminating the drudgery of programming data structures is clearly an important problem.
Reference: [11] <author> C. J. Date. </author> <title> An Introduction to Database Systems, </title> <publisher> Addison-Wesley, </publisher> <year> 1983. </year>
Reference-contexts: Iterations over subsets of objects in a container are accomplished through the use of iterators or cursors [13, 14, 1, 6]. Cursors provide SQL-like select capabilities where programmers declaratively specify via predicates the records (or objects) of a container that they want to retrieve <ref> [11] </ref>. Table 1 lists some of the operations of our container interface. In PREDATOR, cursors and containers are first-class objects.
Reference: [12] <author> J. Davidson. </author> <title> Subprogram Inlining: A Study of its Effects on Program Execution Time. </title> <journal> IEEE Trans. on Soft. </journal> <volume> Engr., </volume> <month> February </month> <year> 1992. </year>
Reference-contexts: Our work utilizes a precompiler optimizer to produce efficient code. There are several advantages to this approach: 1. When PREDATOR composes multiple NPTs, it performs compiler optimizations such as common sub expression elimination and partial evaluation. 2. PREDATOR expands inline code, thus removing runtime functional call overhead <ref> [12] </ref>. 3. PREDATOR optimizes queries to determine the most efficient way to traverse a container [14, 3]. In the following sections, we report the results of three experiments using PREDATOR.
Reference: [13] <author> C. Ghezzi and M. Jazayeri. </author> <title> Programming Language Concepts, </title> <publisher> John Wiley & Sons, </publisher> <year> 1987. </year>
Reference-contexts: We then discuss the required abstractions and how they overcome the limitations that we identify. 2: Traditional Parameterized Types Existing data structure compilers accomplish software reuse through traditional parameterized types (TPTs), e.g., C++ templates [24] and ADA generics <ref> [13] </ref>. A TPT is a generic type whose parametric instantiations define a family of related types. The classic example is the array, which can be instantiated to produce arrays of integers, arrays of 1. <p> Code efficiency (implementation limitation). A standard technique of implementing TPTs is to compile the code for each TPT component separately, where references and manipulations of generic objects are performed via pointers <ref> [13] </ref>. This introduces unnecessary runtime overhead. Another technique of TPT implementation is macro expansion [24]. Macro expansion by itself is not always sufficient to provide efficient code, because context information is not considered when optimizing the code which results from expanding TPT compositions. <p> Databases are classical examples of systems that have successfully exploited plug-compatible implementations of containers [4]. Our container interface largely reects work on embedded relational languages and persistent languages. Iterations over subsets of objects in a container are accomplished through the use of iterators or cursors <ref> [13, 14, 1, 6] </ref>. Cursors provide SQL-like select capabilities where programmers declaratively specify via predicates the records (or objects) of a container that they want to retrieve [11]. Table 1 lists some of the operations of our container interface. In PREDATOR, cursors and containers are first-class objects.
Reference: [14] <author> H.F. Korth and A. Silberschatz. </author> <title> Database System Concepts, </title> <publisher> McGraw-Hill, </publisher> <year> 1991. </year>
Reference-contexts: The choice of container implementation is often made for performance reasons. There are many possible interfaces to containers; most expose the containers implementation. However, research on relational databases and persistent object stores have identified interfaces that do not expose a containers implementation <ref> [14, 15] </ref>. Such interfaces are ideal for use in data structure compilers because they promote interchangeable data structure components. 3 To simplify the design of our data structure compiler, we have carefully selected an interface that is sufficiently simple that could be shared by all data structures. <p> Databases are classical examples of systems that have successfully exploited plug-compatible implementations of containers [4]. Our container interface largely reects work on embedded relational languages and persistent languages. Iterations over subsets of objects in a container are accomplished through the use of iterators or cursors <ref> [13, 14, 1, 6] </ref>. Cursors provide SQL-like select capabilities where programmers declaratively specify via predicates the records (or objects) of a container that they want to retrieve [11]. Table 1 lists some of the operations of our container interface. In PREDATOR, cursors and containers are first-class objects. <p> This interface reects the operations that can be performed on all data structures. Moreover, the generality and practicality of this interface has been substantiated by twenty five years of research in databases, because our container interface is virtually identical to the programming language interface for relations in relational databases <ref> [14] </ref>. We stated in Section 2 that TPT authors cannot envision all specializations. Yet, the interface that we have chosen has historically shown to be general enough to permit the definition of any other container interface. <p> When PREDATOR composes multiple NPTs, it performs compiler optimizations such as common sub expression elimination and partial evaluation. 2. PREDATOR expands inline code, thus removing runtime functional call overhead [12]. 3. PREDATOR optimizes queries to determine the most efficient way to traverse a container <ref> [14, 3] </ref>. In the following sections, we report the results of three experiments using PREDATOR. We specifically examine the performance of generated code, the potential gains in software productivity, and the advantages of using plug-compatible data structures.
Reference: [15] <author> C. Lamb, G. Landis, J. Orenstein, and D. Weinreb. </author> <title> The ObjectStore Database System. </title> <journal> Communications of the ACM, </journal> <month> October </month> <year> 1991. </year>
Reference-contexts: The choice of container implementation is often made for performance reasons. There are many possible interfaces to containers; most expose the containers implementation. However, research on relational databases and persistent object stores have identified interfaces that do not expose a containers implementation <ref> [14, 15] </ref>. Such interfaces are ideal for use in data structure compilers because they promote interchangeable data structure components. 3 To simplify the design of our data structure compiler, we have carefully selected an interface that is sufficiently simple that could be shared by all data structures.
Reference: [16] <author> D. Lea. libg++, </author> <title> The GNU C++ Library. </title> <booktitle> C++ Conference USENIX Association, </booktitle> <address> Denver, CO 1988. </address>
Reference-contexts: This can be accomplished by carefully designing standardized interfaces for TPTs. Poorly designed TPTs or TPTs with incompatible interfaces make the task of a data structure compiler difficult, if not impossible. In practice, we note that existing component libraries <ref> [6, 7, 16] </ref> tend not to provide the same interface for all components. 6. Code efficiency (implementation limitation). A standard technique of implementing TPTs is to compile the code for each TPT component separately, where references and manipulations of generic objects are performed via pointers [13].
Reference: [17] <author> D. G. McNicoll, C. Palmer, et al. </author> <title> Common Ada Missle Packages (CAMP) Volume I: Overview and Commonality Study Results, </title> <address> AFATL-TR-85-93, </address> <month> May </month> <year> 1986. </year>
Reference-contexts: Even with the addition of object-oriented inheritance, these prob lems remain. 2. Complex compositions (conceptual limitation). It is widely believed that TPTs are the appropriate abstraction for encapsulating primitive data structures <ref> [6, 17, 18] </ref>. More complex structures, such as the one depicted in Figure 1, are created through TPT compositions. Software component libraries are unlikely to provide implementations for many data structures used in practice; rather, the idea is to form complex structures through composition of available TPTs.
Reference: [18] <author> D. G. McNicoll, C. Palmer, et al. </author> <title> Common Ada Missile Packages (CAMP) Volume II: Software Parts Composition Study Results, </title> <address> AFATL-TR-85-93, </address> <month> May </month> <year> 1986. </year>
Reference-contexts: Even with the addition of object-oriented inheritance, these prob lems remain. 2. Complex compositions (conceptual limitation). It is widely believed that TPTs are the appropriate abstraction for encapsulating primitive data structures <ref> [6, 17, 18] </ref>. More complex structures, such as the one depicted in Figure 1, are created through TPT compositions. Software component libraries are unlikely to provide implementations for many data structures used in practice; rather, the idea is to form complex structures through composition of available TPTs.
Reference: [19] <author> G. Novak. </author> <title> Software Reuse by Compilation through View Clusters. </title> <note> Submitted for publication in IEEE Trans. on Soft. Engr., </note> <year> 1992. </year>
Reference-contexts: A data structure compiler is a suite of tools that reduces the burden of programming data structures. There have been several attempts to produce such compilers. Three examples are <ref> [10, 19, 25] </ref>. In general, however, data structure compilers have not achieved a broad level of acceptance. The reasons include inadequate performance, unnecessary complexity, host language restrictions, and limited scope. Eliminating the drudgery of programming data structures is clearly an important problem.
Reference: [20] <author> C. Palmer and S. Cohen. </author> <title> Engineering and Applications of Reusable Software Resources. Aerospace Software Engineering: A Collection of Concepts, </title> <editor> ed. C. Anderson and M. Dorfman. </editor> <volume> Vol. 136, </volume> <booktitle> Progress in Astronautics and Aeronautics, </booktitle> <year> 1990. </year>
Reference-contexts: A common event is for a customer to leave the middle of a queue when he realizes he needs another item. Head of list Specialization is the process of modifying a type to provide a customized interface for an application. Specialization of TPTs poses some difficult problems <ref> [6, 9, 20, 24] </ref>: Attempting to provide an exhaustive TPT interface actually discourages reuse. Programmers are intimidated by complex interfaces and would rather design their own. Given TPT source code, a programmer could attempt to integrate his own changes.
Reference: [21] <author> R. Prieto-Diaz and G. Arango. </author> <title> Domain Analysis and Software Systems Modeling, </title> <publisher> IEEE Computer Society Press, </publisher> <year> 1991. </year>
Reference-contexts: In PREDATOR, cursors and containers are first-class objects. They may be saved in variables, passed to functions, and stored in containers. 3.2: Conceptual Limitation: Difficulty of Specialization The interface described in Table 1 was the result of a domain modelling <ref> [21] </ref> effort. This interface reects the operations that can be performed on all data structures.
Reference: [22] <author> J. Schmidt. </author> <title> Some High Level Language Constructs for Data of Type Relation, </title> <journal> ACM Trans. on Database Sys., </journal> <year> 1977. </year>
Reference-contexts: We stated in Section 2 that TPT authors cannot envision all specializations. Yet, the interface that we have chosen has historically shown to be general enough to permit the definition of any other container interface. The programming language Pascal/R <ref> [22] </ref>, for example, allowed users to customize the interface to relations by letting them place their own abstract data type (ADT) interfaces on top of relations and to implement ADT operations as calls to relational operators.
Reference: [23] <author> R. Snodgrass. </author> <title> The Interface Description Language, </title> <publisher> Computer Science Press, </publisher> <year> 1989. </year>
Reference-contexts: Occasionally, a programmer is forced to implement new components, thus mixing the two phases. Our research aims to simplify component creation and reduce the necessity of implementing new components. This division of specification and tools from application programming is not unique <ref> [26, 23] </ref>. Our research concentrates more on programmer productivity and code efficiency than on program evolution and maintenance. Our project is called PREDATOR, which is a (misspelled) acronym for PREcompiler for DAta sTRuctures.
Reference: [24] <author> B. Stroustrup. </author> <title> The C++ Programming Language, 2nd edition, </title> <publisher> Addison-Wesley, </publisher> <year> 1991. </year>
Reference-contexts: We then discuss the required abstractions and how they overcome the limitations that we identify. 2: Traditional Parameterized Types Existing data structure compilers accomplish software reuse through traditional parameterized types (TPTs), e.g., C++ templates <ref> [24] </ref> and ADA generics [13]. A TPT is a generic type whose parametric instantiations define a family of related types. The classic example is the array, which can be instantiated to produce arrays of integers, arrays of 1. <p> A common event is for a customer to leave the middle of a queue when he realizes he needs another item. Head of list Specialization is the process of modifying a type to provide a customized interface for an application. Specialization of TPTs poses some difficult problems <ref> [6, 9, 20, 24] </ref>: Attempting to provide an exhaustive TPT interface actually discourages reuse. Programmers are intimidated by complex interfaces and would rather design their own. Given TPT source code, a programmer could attempt to integrate his own changes. <p> Code efficiency (implementation limitation). A standard technique of implementing TPTs is to compile the code for each TPT component separately, where references and manipulations of generic objects are performed via pointers [13]. This introduces unnecessary runtime overhead. Another technique of TPT implementation is macro expansion <ref> [24] </ref>. Macro expansion by itself is not always sufficient to provide efficient code, because context information is not considered when optimizing the code which results from expanding TPT compositions. In current data structure compilers, TPTs provide a useful framework for describing reusable software components.
Reference: [25] <author> D. Volpano and R. Kieburtz. </author> <title> Software Templates, </title> <booktitle> Proc. Eighth Intl. Conf. on Soft. </booktitle> <address> Eng., </address> <publisher> IEEE Computer Society, </publisher> <year> 1985. </year>
Reference-contexts: A data structure compiler is a suite of tools that reduces the burden of programming data structures. There have been several attempts to produce such compilers. Three examples are <ref> [10, 19, 25] </ref>. In general, however, data structure compilers have not achieved a broad level of acceptance. The reasons include inadequate performance, unnecessary complexity, host language restrictions, and limited scope. Eliminating the drudgery of programming data structures is clearly an important problem.
Reference: [26] <author> D. Weiss. </author> <title> Synthesis Operational Scenarios, </title> <institution> Software Productivity Consortium, Inc, </institution> <year> 1990. </year>
Reference-contexts: Occasionally, a programmer is forced to implement new components, thus mixing the two phases. Our research aims to simplify component creation and reduce the necessity of implementing new components. This division of specification and tools from application programming is not unique <ref> [26, 23] </ref>. Our research concentrates more on programmer productivity and code efficiency than on program evolution and maintenance. Our project is called PREDATOR, which is a (misspelled) acronym for PREcompiler for DAta sTRuctures.
References-found: 26

