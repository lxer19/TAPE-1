URL: ftp://ftp.cs.utah.edu/pub/pisa.ps.Z
Refering-URL: http://www.cs.utah.edu/~gary/MSO-publications.html
Root-URL: 
Title: Persistent Immutable Shared Abstractions  
Author: Benny Yih, Mark Swanson, and Robert Kessler 
Address: Salt Lake City, UT 84112  
Affiliation: Center for Software Science, Department of Computer Science, University of Utah,  
Abstract: A write-once, read-many persistent store has been developed for Concurrent Scheme, a distributed-memory parallel Lisp for the Mayfly multicomputer. The prototype implementation 2 supports the explicit store and implicit retrieval of instances of the Scheme data types. Items are stored into per node repositories, using a modified form of the original Concurrent Scheme "message" format. Potential access concur-rency and transaction atomicity of the store are discussed. The efficacy of the prototype is demonstrated via its utilization within a parallel ray tracer, on a network implementation of Concurrent Scheme.
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> Jim Blinn. </author> <title> What, </title> <journal> teapots again ? IEEE Computer Graphics and Applications, </journal> <volume> 7(9) </volume> <pages> 61-63, </pages> <month> September </month> <year> 1987. </year>
Reference-contexts: At some future date, tdbm may replaced by a more elaborate backend, such as the EXODUS storage system [3]. 5 Current Status The PISA prototype currently works well enough to support the Rayshade application, allowing the rendering of some simple images such as the Utah teapot <ref> [7, 1] </ref> (about 4 K polygons versus a maximum around 1.5 K polygons in CUS). Table 1. Timings of Basic Scheme Operations (secs). Operation PISA/CUS (identity 1) 1.8 (cons 1 '()) 2.5 (make-vector 100 0) 112.8 (+ 1.0 1.0) 15.6 Table 2. Timings of Basic Concurrent Scheme Operations (secs).
Reference: 2. <author> Barry Brachman and Gerald Neufeld. TDBM: </author> <title> a DBM library with atomic transactions. </title> <booktitle> In Proceedings of the Summer 1992 USENIX Conference, </booktitle> <pages> pages 63-80, </pages> <address> San Antonio, TX, June 8-12, 1992. </address> <publisher> Usenix Association. </publisher>
Reference-contexts: The actual object, when created at the original domain, is captured in a closure. Support for clustering of unique objects [as with other closures] is not presently envisioned. 4.5 PISA Storage Management At the file system interface, tdbm <ref> [2] </ref> routines are currently used to manipulate the persistent heaps. Each is stored as a value keyed on its global PISA index, in the database for items registered at that node.
Reference: 3. <author> Michael J. Carey, David J. DeWitt, Joel E. Richardson, and Eugene J. Shekita. </author> <title> Storage management for objects in EXODUS. </title> <editor> In Won Kim and Frederick H. Lochovsky, editors, </editor> <booktitle> Object-Oriented Concepts, Databases, and Applications, </booktitle> <pages> pages 341-369. </pages> <publisher> Addison-Wesley, </publisher> <year> 1989. </year>
Reference-contexts: The [distributed] garbage collection of unreachable items within the store is not currently performed. At some future date, tdbm may replaced by a more elaborate backend, such as the EXODUS storage system <ref> [3] </ref>. 5 Current Status The PISA prototype currently works well enough to support the Rayshade application, allowing the rendering of some simple images such as the Utah teapot [7, 1] (about 4 K polygons versus a maximum around 1.5 K polygons in CUS). Table 1.
Reference: 4. <author> Harold Carr. </author> <title> Utah Scheme version 1.0 users guide. </title> <type> Technical Report CSS Opnote 89-02, </type> <institution> Center for Software Sciences, Department of Computer Science, University of Utah, </institution> <address> Salt Lake City, Utah 84112, </address> <year> 1989. </year>
Reference-contexts: This scheme is sufficient for a simple store, but with more users and more objects saved in the store, a more elaborate hierarchical naming scheme may be required. 4 Continuations are not currently supported in either the Utah Scheme or the Con current Utah Scheme implementations <ref> [4] </ref>. 5 A more elaborate scheme, with perhaps better scalability, might employ conditional local naming and asynchronous abort messages, in case of clashes. 3.3 Persistent Store Management Each PISA database is implemented as a distributed store, utilizing the file system at every CS node to maximize concurrency and I/O bandwidth.
Reference: 5. <author> H-T. Chou, David J. DeWitt, Randy H. Katz, and Anthony C. Klug. </author> <title> Design and implementation of the Wisconsin storage system. </title> <journal> Software-Practice and Experience, </journal> <volume> 15(10) </volume> <pages> 943-962, </pages> <month> October </month> <year> 1983. </year>
Reference-contexts: This technique allows simple object trees of closely associated items to be registered, and retrieved, as a single entry. Use of more specific hints (such as Mneme [19, 20] segments, or Wisconsin Storage System <ref> [5] </ref> pages) to cluster certain named items near each other is not planned. Shallow copying (i.e., pass by reference) of instances across domains is supported via the specification of unique object classes. These are implemented via proxy instances which forward each slot or method request to the actual object.
Reference: 6. <author> W.P. Cockshot. </author> <title> Persistent programming and secure data storage. </title> <journal> Information and Storage Technology, </journal> <volume> 29(5) </volume> <pages> 249-256, </pages> <month> June </month> <year> 1987. </year>
Reference-contexts: The typical approach has been for individual applications to incorporate ad hoc solutions, such as custom translators to some disk file format, or translators to some backend database system. The mismatch between the application and traditional databases can be significant <ref> [32, 6] </ref>. Persistent languages o*oad this burden from the application, by offering a standard mechanism for retaining data. This standard mechanism can introduce additional benefits, such as data sharing between applications and access to a store larger than the available virtual address space.
Reference: 7. <author> Frank Crow. </author> <title> The origins of the teapot. </title> <journal> IEEE Computer Graphics and Applications, </journal> <volume> 7(1) </volume> <pages> 8-19, </pages> <month> January </month> <year> 1987. </year>
Reference-contexts: At some future date, tdbm may replaced by a more elaborate backend, such as the EXODUS storage system [3]. 5 Current Status The PISA prototype currently works well enough to support the Rayshade application, allowing the rendering of some simple images such as the Utah teapot <ref> [7, 1] </ref> (about 4 K polygons versus a maximum around 1.5 K polygons in CUS). Table 1. Timings of Basic Scheme Operations (secs). Operation PISA/CUS (identity 1) 1.8 (cons 1 '()) 2.5 (make-vector 100 0) 112.8 (+ 1.0 1.0) 15.6 Table 2. Timings of Basic Concurrent Scheme Operations (secs).
Reference: 8. <author> Partha Dasgupta, R. Ananthanarayanan, Sathis Menon, Ajay Mohindra, and Ray-mond Chen. </author> <title> Distributed programming with objects and threads in the Clouds system. </title> <journal> Computing Systems, </journal> <volume> 4(3) </volume> <pages> 243-275, </pages> <month> Summer </month> <year> 1991. </year>
Reference-contexts: No concurrency control is presently specified. 2.4 CLiDE CLOUDS Lisp Distributed Environments [24], CLiDE, offer very large-grained persistent objects, as part of CLOUDS object-oriented operating system project. Each object emulates a traditional single-user Lisp environment, and can communicate with other CLOUDS system <ref> [25, 34, 9, 8] </ref> objects developed in CC++ or C-Eiffel. Objects are referenced via a sysname registered with CLOUDS. Each CC++ object contains conventional C++ objects, and C-Eiffel objects contain Eiffel objects. Both CC++ and C-Eiffel objects can contain multiple threads.
Reference: 9. <author> Partha Dasgupta, R. Ananthanarayanan, Sathis Menon, Ajay Mohindra, Mark Pearson, Raymond Chen, and Christoper Wilkenloh. </author> <title> Language and operating system support for distributed programming in Clouds. </title> <booktitle> In Proceedings of the Symposium on Experiences with Distributed and Multiprocesor Systems (SEDMS II), </booktitle> <pages> pages 321-340, </pages> <address> Atlanta, GA, March 21-22, 1990. </address> <publisher> Usenix Association. </publisher>
Reference-contexts: No concurrency control is presently specified. 2.4 CLiDE CLOUDS Lisp Distributed Environments [24], CLiDE, offer very large-grained persistent objects, as part of CLOUDS object-oriented operating system project. Each object emulates a traditional single-user Lisp environment, and can communicate with other CLOUDS system <ref> [25, 34, 9, 8] </ref> objects developed in CC++ or C-Eiffel. Objects are referenced via a sysname registered with CLOUDS. Each CC++ object contains conventional C++ objects, and C-Eiffel objects contain Eiffel objects. Both CC++ and C-Eiffel objects can contain multiple threads.
Reference: 10. <author> Keith E. Gorlen, Sanford M. Orlow, and Perry S. Plexico. </author> <title> Data Abstraction and Object-Oriented Programming in C++. </title> <publisher> John Wiley & Sons, </publisher> <year> 1990. </year>
Reference-contexts: Instances of these are registered as local PISAs within the same message as the enclosing Lisp item, possibly violating any object level sharing of these instances with another entry in the store. This convention is similar to the deep versus shallow copying scheme, present in some other systems <ref> [10] </ref>. This technique allows simple object trees of closely associated items to be registered, and retrieved, as a single entry. Use of more specific hints (such as Mneme [19, 20] segments, or Wisconsin Storage System [5] pages) to cluster certain named items near each other is not planned.
Reference: 11. <author> Theo Haerder and Andreas Reuter. </author> <title> Principles of transaction-oriented database recovery. </title> <journal> ACM Computing Surveys, </journal> <volume> 15(4) </volume> <pages> 287-317, </pages> <month> December </month> <year> 1983. </year>
Reference-contexts: Large items are stored within a number of contiguous indirect pages, and referenced from the direct page for that key's hash value. Each top-level commit creates an intention file with actions that will update the database, using after-image physical logging <ref> [11] </ref>. This file contains the shadow pages which will replace pages in the database. Though transaction semantics are employed within the PISA system, the additional support at the CS layer for explicit user level transactions is not planned.
Reference: 12. <author> R.H. Halstead Jr. </author> <title> Multilisp: A language for concurrent symbolic computation. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 7(4) </volume> <pages> 501-538, </pages> <month> Octo-ber </month> <year> 1985. </year>
Reference-contexts: Automatic locking and recovery features are provided with cp-threads. Normal Unix executables are post-processed into a text segment and multiple data segments under programmer control. Each cp-thread applies read and write locks to the segments it uses. A form of the future <ref> [12] </ref> construct for concurrent evaluations is provided in CLiDE, by a group of functions dealing with future set structures. These allow for the asynchronous remote evaluation of series of expressions by other objects (passed in the form of a string), and return of their values.
Reference: 13. <author> R. Kessler, H. Carr, L. Stoller, and M. Swanson. </author> <title> Implementiong Concurrent Scheme for the Mayfly distributed parallel processing system. LISP AND SYMBOLIC COMPUTATION: </title> <journal> An International Journal, </journal> 5(1/2):73-93, May 1992. 
Reference-contexts: This standard mechanism can introduce additional benefits, such as data sharing between applications and access to a store larger than the available virtual address space. This access to large stores was one impetus for adding a backing store to Concurrent Scheme <ref> [13, 31, 14] </ref> (CS). The CS port of a public domain ray tracing program, Rayshade, is currently restricted to rendering simple scenes due to limited heap size.
Reference: 14. <author> R. R. Kessler and M. R. Swanson. </author> <title> Concurrent Scheme. </title> <editor> In T. Ito and R. H. Hal-stead, editors, </editor> <booktitle> Parallel Lisp: Languages and Systems, </booktitle> <pages> pages 200-234. </pages> <publisher> Springer-Verlag, </publisher> <year> 1990. </year>
Reference-contexts: This standard mechanism can introduce additional benefits, such as data sharing between applications and access to a store larger than the available virtual address space. This access to large stores was one impetus for adding a backing store to Concurrent Scheme <ref> [13, 31, 14] </ref> (CS). The CS port of a public domain ray tracing program, Rayshade, is currently restricted to rendering simple scenes due to limited heap size.
Reference: 15. <author> Gregor Kiczales, Jim des Rivieres, and Daniel G. Bobrow. </author> <title> The Art of the Metaob-ject Protocol. </title> <publisher> MIT Press, </publisher> <year> 1991. </year>
Reference-contexts: Per class methods are stored in binary form, and class hierarchy information is stored in OBJFADS system catalogs. 2.2 PCLOS PCLOS [21, 22] utilizes a virtual database interface, and implements persistence via the CLOS Meta-Object Protocol <ref> [15] </ref> (MOP). Protocol adapters map requests from the virtual, relational interface to any of the three specific databases currently supported. A pclos-class metaclass is used to include the extra mechanism for persistence. Object slots may be declared transient when the class is defined.
Reference: 16. <author> Gary Lindstrom and Robert Kessler. </author> <title> Mach shared objects. </title> <booktitle> In Proceedings of the DARPA Software Technology Conference 1992, </booktitle> <pages> pages 279-280, </pages> <address> Los Angeles, CA, </address> <month> April </month> <year> 1992, 1992. </year> <pages> DARPA. </pages>
Reference-contexts: Its use has been demonstrated by incorporation into a distributed ray tracing program. In particular, its ability to persist code fragments is of wide interest, and is being used in the Mach Shared Objects <ref> [16] </ref> project, a distributed client/server style object manager on top of the Mach operating system supporting bilingual programming in Lisp and C++. PISAs provide the mechanism to persist objects and their associated methods.
Reference: 17. <author> J. S. Miller. MultiScheme, </author> <title> A Parallel Processing System Based on MIT Scheme. </title> <type> PhD thesis, </type> <institution> Department of Electrical Engineering and Computer Science, MIT, </institution> <month> August </month> <year> 1987. </year>
Reference-contexts: On the other hand, local closures (i.e., non-exported) will be restored in the target domain, allowing the possibility of multiple copies when the PISA's value is required at different domains. 4.2 The PISA Type and Lazy Retrieval The implementation of lazy retrieval was modeled on the placeholder type <ref> [17] </ref>, and a new PISA data type was specified. The type has been designed such that strict operations encountering a PISA cause an import of the referenced item into the current domain heap.
Reference: 18. <author> David A. Moon. </author> <title> The Common Lisp object-oriented programmin language stan-dard. </title> <editor> In Won Kim and Frederick H. Lochovsky, editors, </editor> <booktitle> Object-Oriented Concepts, Databases, and Applications, </booktitle> <pages> pages 49-78. </pages> <publisher> Addison-Wesley, </publisher> <year> 1989. </year>
Reference-contexts: The references on immutability help to demonstrate some of the nuances in constructing immutable systems. 2.1 OBJFADS The OBJFADS [27] system, was designed on top of the Postgres [30, 29] relational database. This is based on the Common Lisp Object System <ref> [28, 18] </ref> (CLOS), and intended for multimedia applications. Instances are created as classes derived from a DBClass metaclass. Common Lisp datatypes are mapped to native Postgres types, or to a string which is evaluated.
Reference: 19. <author> J. Eliot B. Moss. </author> <title> Design of the Mneme persistent object store. </title> <journal> ACM Transactions on Information Systems, </journal> <volume> 8(2) </volume> <pages> 103-139, </pages> <month> April </month> <year> 1990. </year>
Reference-contexts: This convention is similar to the deep versus shallow copying scheme, present in some other systems [10]. This technique allows simple object trees of closely associated items to be registered, and retrieved, as a single entry. Use of more specific hints (such as Mneme <ref> [19, 20] </ref> segments, or Wisconsin Storage System [5] pages) to cluster certain named items near each other is not planned. Shallow copying (i.e., pass by reference) of instances across domains is supported via the specification of unique object classes.
Reference: 20. <author> J. Eliot B. Moss and Tony Hosking. </author> <title> Managing persistent data with Mneme: User's guide to the client interface. </title> <type> Technical report, </type> <institution> Object Oriented Systems Laboratory, Department of Computer and Information Science, University of Mas-sachusetts, </institution> <address> Amherst, MA 01003, </address> <month> March </month> <year> 1989. </year>
Reference-contexts: This convention is similar to the deep versus shallow copying scheme, present in some other systems [10]. This technique allows simple object trees of closely associated items to be registered, and retrieved, as a single entry. Use of more specific hints (such as Mneme <ref> [19, 20] </ref> segments, or Wisconsin Storage System [5] pages) to cluster certain named items near each other is not planned. Shallow copying (i.e., pass by reference) of instances across domains is supported via the specification of unique object classes.
Reference: 21. <author> Andreas Paepcke. PCLOS: </author> <title> a critical review. </title> <journal> ACM SIGPLAN Notices, </journal> <volume> 24(10) </volume> <pages> 221-237, </pages> <month> October </month> <year> 1989. </year>
Reference-contexts: The cached object is invalidated by a database alerter, when changed by another application. Per class methods are stored in binary form, and class hierarchy information is stored in OBJFADS system catalogs. 2.2 PCLOS PCLOS <ref> [21, 22] </ref> utilizes a virtual database interface, and implements persistence via the CLOS Meta-Object Protocol [15] (MOP). Protocol adapters map requests from the virtual, relational interface to any of the three specific databases currently supported. A pclos-class metaclass is used to include the extra mechanism for persistence.
Reference: 22. <author> Andreas Paepcke. PCLOS: </author> <title> stress testing CLOS. </title> <journal> ACM SIGPLAN Notices, </journal> <volume> 25(10) </volume> <pages> 221-237, </pages> <month> October </month> <year> 1990. </year>
Reference-contexts: The cached object is invalidated by a database alerter, when changed by another application. Per class methods are stored in binary form, and class hierarchy information is stored in OBJFADS system catalogs. 2.2 PCLOS PCLOS <ref> [21, 22] </ref> utilizes a virtual database interface, and implements persistence via the CLOS Meta-Object Protocol [15] (MOP). Protocol adapters map requests from the virtual, relational interface to any of the three specific databases currently supported. A pclos-class metaclass is used to include the extra mechanism for persistence.
Reference: 23. <author> Girish Pathak, John Joseph, and Steve Ford. </author> <title> Object eXchange service for an object-oriented database system. </title> <booktitle> In IEEE 5th International Conference on Data Engineering, </booktitle> <pages> pages 27-34, </pages> <year> 1989. </year>
Reference-contexts: Data structure sharing between slots is lost when written to the database, or if transactions are rolled back. In-place modifications of cached data must explicitly notify PCLOS by rebinding the slot, or only be used inside transactions. 2.3 OXS The Object eXchange Service <ref> [23] </ref>, OXS, also provides a Common Lisp persistent store, as part of the Zeitgeist project. This store is targeted toward the computer aided design environment. Persistent items are internally referenced by a 64 bit identifier, with a number of global items, such as nil, predefined.
Reference: 24. <author> Mark P. Pearson and Partha Dasgupta. CLiDE: </author> <title> a distributed, symbolic programming system based on large-grained persistent objects. </title> <type> Technical report, </type> <institution> Distributed Systems Laboratory, College of Computing, Georgia Institute of Technology, </institution> <address> Atlanta, GA, </address> <year> 1991. </year>
Reference-contexts: Due to the likelihood of sharing, Lisp symbols are considered separate items. Within Lisp, items are represented by a surrogate which faults in the actual item if accessed. No concurrency control is presently specified. 2.4 CLiDE CLOUDS Lisp Distributed Environments <ref> [24] </ref>, CLiDE, offer very large-grained persistent objects, as part of CLOUDS object-oriented operating system project. Each object emulates a traditional single-user Lisp environment, and can communicate with other CLOUDS system [25, 34, 9, 8] objects developed in CC++ or C-Eiffel. Objects are referenced via a sysname registered with CLOUDS.
Reference: 25. <author> Umakishore Ramachandran and M. Yousef A. Khalidi. </author> <title> An implementation of distributed shared memory. </title> <booktitle> In Proceedings of the First USENIX/SERC Workshop on Experiences with Distributed and Multiprocesor Systems, </booktitle> <pages> pages 21-38, </pages> <address> Fort Laud-erdale, FL, </address> <month> October 5-6, </month> <year> 1989. </year> <institution> Usenix Association. </institution>
Reference-contexts: No concurrency control is presently specified. 2.4 CLiDE CLOUDS Lisp Distributed Environments [24], CLiDE, offer very large-grained persistent objects, as part of CLOUDS object-oriented operating system project. Each object emulates a traditional single-user Lisp environment, and can communicate with other CLOUDS system <ref> [25, 34, 9, 8] </ref> objects developed in CC++ or C-Eiffel. Objects are referenced via a sysname registered with CLOUDS. Each CC++ object contains conventional C++ objects, and C-Eiffel objects contain Eiffel objects. Both CC++ and C-Eiffel objects can contain multiple threads.
Reference: 26. <editor> J. Rees and W. Clinger. </editor> <title> Revised 3 Report on the Algorithmic Language Scheme. </title> <journal> SIGPLAN Notices, </journal> <volume> 21(12) </volume> <pages> 37-79, </pages> <month> December </month> <year> 1986. </year>
Reference-contexts: Though the traditional sequential Scheme <ref> [26] </ref> data types 4 are well supported, only a small amount of context is preserved for the types introduced by CS (i.e., placeholders, domains, threads, ports, and delay queues).
Reference: 27. <author> Lawrence A. Rowe. </author> <title> A shared object hierarchy. </title> <editor> In Michael Stonebraker and Lawrence A. Rowe, editors, </editor> <booktitle> The Postgres Papers, number UCB/ERL M86/85, </booktitle> <pages> pages 91-117. </pages> <institution> Electronics Research Laboratory, University of California, Berke-ley, </institution> <month> June </month> <year> 1987. </year>
Reference-contexts: As we shall see, PISAs take the more general approach, 3 although a primitive object system is supported. The references on immutability help to demonstrate some of the nuances in constructing immutable systems. 2.1 OBJFADS The OBJFADS <ref> [27] </ref> system, was designed on top of the Postgres [30, 29] relational database. This is based on the Common Lisp Object System [28, 18] (CLOS), and intended for multimedia applications. Instances are created as classes derived from a DBClass metaclass.
Reference: 28. <author> Guy L. Steele Jr. </author> <title> Common Lisp: The Language. </title> <note> Digital Press, second edition, </note> <year> 1990. </year>
Reference-contexts: The references on immutability help to demonstrate some of the nuances in constructing immutable systems. 2.1 OBJFADS The OBJFADS [27] system, was designed on top of the Postgres [30, 29] relational database. This is based on the Common Lisp Object System <ref> [28, 18] </ref> (CLOS), and intended for multimedia applications. Instances are created as classes derived from a DBClass metaclass. Common Lisp datatypes are mapped to native Postgres types, or to a string which is evaluated.
Reference: 29. <author> Michael Stonebraker. </author> <title> The design of the Postgres storage system. </title> <editor> In Michael Stone-braker and Lawrence A. Rowe, editors, </editor> <booktitle> The Postgres Papers, number UCB/ERL M86/85, </booktitle> <pages> pages 69-90. </pages> <institution> Electronics Research Laboratory, University of California, Berkeley, </institution> <month> June </month> <year> 1987. </year>
Reference-contexts: As we shall see, PISAs take the more general approach, 3 although a primitive object system is supported. The references on immutability help to demonstrate some of the nuances in constructing immutable systems. 2.1 OBJFADS The OBJFADS [27] system, was designed on top of the Postgres <ref> [30, 29] </ref> relational database. This is based on the Common Lisp Object System [28, 18] (CLOS), and intended for multimedia applications. Instances are created as classes derived from a DBClass metaclass. Common Lisp datatypes are mapped to native Postgres types, or to a string which is evaluated.
Reference: 30. <author> Michael Stonebraker and Greg Kemnitz. </author> <title> The POSTGRES next-generation database management system. </title> <journal> Communications of the ACM, </journal> <volume> 34(10) </volume> <pages> 78-92, </pages> <month> Oc-tober </month> <year> 1991. </year>
Reference-contexts: As we shall see, PISAs take the more general approach, 3 although a primitive object system is supported. The references on immutability help to demonstrate some of the nuances in constructing immutable systems. 2.1 OBJFADS The OBJFADS [27] system, was designed on top of the Postgres <ref> [30, 29] </ref> relational database. This is based on the Common Lisp Object System [28, 18] (CLOS), and intended for multimedia applications. Instances are created as classes derived from a DBClass metaclass. Common Lisp datatypes are mapped to native Postgres types, or to a string which is evaluated.
Reference: 31. <author> M. R. Swanson. </author> <title> DOMAINS-A Mechanism for Specifying Mutual Exclusion and Disciplined Data Sharing in Concurrent Symbolic Programs. </title> <type> PhD thesis, </type> <institution> Department of Computer Science, University of Utah, </institution> <month> June </month> <year> 1991. </year>
Reference-contexts: This standard mechanism can introduce additional benefits, such as data sharing between applications and access to a store larger than the available virtual address space. This access to large stores was one impetus for adding a backing store to Concurrent Scheme <ref> [13, 31, 14] </ref> (CS). The CS port of a public domain ray tracing program, Rayshade, is currently restricted to rendering simple scenes due to limited heap size.
Reference: 32. <author> D.C. Tsichritzis and O.M. Nierstrasz. </author> <title> Fitting round objects into square databases. </title> <editor> In S. Gjessing and K. Nygaard, editors, </editor> <booktitle> ECOOP '88: European Conference on Object-Oriented Programming, volume 322 of Lecture Notes in Computer Science, </booktitle> <pages> pages 283-299, </pages> <address> Oslo, Norway, </address> <month> August 15-17, </month> <title> 1988. </title> <publisher> Springer-Verlag. </publisher>
Reference-contexts: The typical approach has been for individual applications to incorporate ad hoc solutions, such as custom translators to some disk file format, or translators to some backend database system. The mismatch between the application and traditional databases can be significant <ref> [32, 6] </ref>. Persistent languages o*oad this burden from the application, by offering a standard mechanism for retaining data. This standard mechanism can introduce additional benefits, such as data sharing between applications and access to a store larger than the available virtual address space.
Reference: 33. <author> Douglas Wiebe. </author> <title> A distributed repository for immutable persistent objects. </title> <journal> ACM SIGPLAN Notices, </journal> <volume> 21(11) </volume> <pages> 453-465, </pages> <month> November </month> <year> 1986. </year>
Reference-contexts: For object integrity, Lisp symbols within the CLiDE environment have access control lists, governing local and remote evaluations. 2.5 Jasmine Immutable versions are used in the Jasmine <ref> [33] </ref> software description model. User authentication and per database access control lists are employed for object protection. Objects are saved through a five phase protocol to support the atomic creation of replicas.
Reference: 34. <author> C. J. Wilkenloh, U. Ramachandran, S. Menon, R. J. LeBlanc, M. Y. A. Khalidi, P. W. Hutto, P. Dasgupta, R. C. Chen, J. M. Bernabeu, W. F. Appelbe, and M. Ahamad. </author> <title> The Clouds experience: Building an object-based distributed operat-ing system. </title> <booktitle> In Proceedings of the First USENIX/SERC Workshop on Experiences with Distributed and Multiprocesor Systems, </booktitle> <pages> pages 333-347, </pages> <address> Fort Lauderdale, FL, </address> <month> October 5-6, </month> <year> 1989. </year> <institution> Usenix Association. </institution>
Reference-contexts: No concurrency control is presently specified. 2.4 CLiDE CLOUDS Lisp Distributed Environments [24], CLiDE, offer very large-grained persistent objects, as part of CLOUDS object-oriented operating system project. Each object emulates a traditional single-user Lisp environment, and can communicate with other CLOUDS system <ref> [25, 34, 9, 8] </ref> objects developed in CC++ or C-Eiffel. Objects are referenced via a sysname registered with CLOUDS. Each CC++ object contains conventional C++ objects, and C-Eiffel objects contain Eiffel objects. Both CC++ and C-Eiffel objects can contain multiple threads.
Reference: 35. <author> Benny Yih. </author> <title> Ray tracing in Concurrent Scheme. </title> <type> Technical Report CSS Opnote 91-02, </type> <institution> Center for Software Sciences, Department of Computer Science, University of Utah, </institution> <address> Salt Lake City, Utah 84112, </address> <year> 1991. </year>
Reference-contexts: This offset is used to return the proper function start address back to Lisp, as the fasl is reloaded. 4.4 PISA Object System As a special case, instances of a rudimentary structure-based object system <ref> [35] </ref> include explicit CS and PISA support. These highly stylized structures inherit from a "special" structure type, and are treated differently when registered with the PISA store. They are abstracted into a local annotation within the message, which contains the class name and slot values, but not the class methods.
Reference: 36. <author> Benny Yih, Mark R. Swanson, and Robert R. Kessler. </author> <title> Persistent immutable shared abstractions. </title> <editor> In Robert H. Halstead Jr. and Takayasu Ito, editors, </editor> <booktitle> Parallel Symbolic Computing: Languages, Systems, and Applications (US/Japan Workshop Proceedings), volume 748 of Lecture Notes in Computer Science, </booktitle> <pages> pages 300-317, </pages> <address> Berlin, </address> <month> November </month> <year> 1993. </year> <title> Springer-Verlag. This article was processed using the L a T E X macro package with LLNCS style </title>
Reference-contexts: N00014-91-J-4046. 2 An earlier version of this paper was presented at the 1992 US/Japan Workshop on Parallel Symbolic Computing <ref> [36] </ref>. Rayshade and many similar applications do not require the ability to change the shared graphic primitives after their creation. Thus, we chose a simplified write-once form of persistent store.
References-found: 36

