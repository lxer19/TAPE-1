URL: http://www.pmg.lcs.mit.edu/papers/thor-interface.ps.gz
Refering-URL: http://www.pmg.lcs.mit.edu/areas/type-safe.html
Root-URL: 
Title: The Language-Independent Interface of the Thor Persistent Object System  
Author: Barbara Liskov Mark Day Sanjay Ghemawat Robert Gruber Umesh Maheshwari Andrew C. Myers Liuba Shrira 
Date: February 24, 1993  
Abstract: Thor is a new object-oriented database system being developed at MIT. It allows applications written in different programming languages, and possibly running on heterogeneous machines and operating systems, to share objects conveniently. Our goal is to provide safe sharing of objects with higher-level semantics than is typical for today's file systems and databases, while still providing good performance. This paper describes the interface of Thor and also discusses some of the implementation techniques we are using to achieve our performance goal.
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Atul Adya. </author> <title> A distributed commit protocol for optimistic concurrency control. </title> <type> Master's thesis, </type> <institution> Massachusetts Institute of Technology, </institution> <year> 1993. </year> <month> Forthcoming. </month>
Reference-contexts: in which ORs that own objects used in the transaction attempt to validate the transaction (i.e., check whether the versions used are still the current versions). (A faster commit is used if only that OR is involved in the transaction.) More information about our commit technique can be found in <ref> [1] </ref>. If the commit fails, the FE is given the xrefs of all the objects for which validation failed. It discards these objects (turning them into surrogates) and undoes all modifications made by the aborted transaction.
Reference: [2] <author> Paul Butterworth, Allen Otis, and Jacob Stein. </author> <title> The gemstone object database management system. </title> <journal> Communications of the ACM, </journal> <volume> 34(10) </volume> <pages> 64-77, </pages> <month> October </month> <year> 1991. </year>
Reference-contexts: Most existing object oriented databases, such as ObjectStore [15], Statice [28], Iris [9], and Orion [14] are specific to a single language. Of the systems that support multiple languages, the approach in GemStone <ref> [2] </ref> is the closest to ours; programs written in different languages access persistant objects through a method-based interface. However, Gemstone violates object encapsulation to enhance query performance. The approach in O 2 [7] is very different; different languages can access O 2 objects and implement methods. <p> By contrast, many client languages (e.g., C) are unsafe and allow program errors (e.g., dangling references) that could damage or destroy persistent objects if we allowed programs written in them to run inside of Thor. Our approach is similar to that of GemStone <ref> [2] </ref>, with its GemStone DDL/DML; however, while that language is an adaptation of Smalltalk, ours is a new object-oriented language, influenced by CLU [19] and Modula-3 [3].
Reference: [3] <author> Luca Cardelli, James Donahue, Lucille Glassman, Mick Jordan, Bill Kalsow, and Greg Nelson. </author> <title> Language definition. </title> <editor> In Greg Nelson, editor, </editor> <booktitle> Systems Programming in Modula-3, chapter 2. </booktitle> <publisher> Prentice-Hall, </publisher> <year> 1991. </year>
Reference-contexts: Our approach is similar to that of GemStone [2], with its GemStone DDL/DML; however, while that language is an adaptation of Smalltalk, ours is a new object-oriented language, influenced by CLU [19] and Modula-3 <ref> [3] </ref>. Programmers can ignore our programming language if they just use existing types and implementations but not if they want to define new types or implementations.
Reference: [4] <author> Luca Cardelli and Peter Wegner. </author> <title> On understanding types, data abstraction, </title> <journal> and polymor phism. ACM Computing Surveys, </journal> <volume> 17(4) </volume> <pages> 471-522, </pages> <month> December </month> <year> 1985. </year>
Reference-contexts: A type can have zero or more supertypes. A subtype must provide the methods of each of its supertype with compatible signatures <ref> [4] </ref>; in addition, it should simulate the behavior of its supertypes as discussed in [23, 22]. We allow a subtype to rename the supertype's methods, so that if the supertype has a method named "bar", in the subtype we can choose to name the method "foo" instead.
Reference: [5] <author> Mark Day. </author> <title> Managing a Cache of Swizzled Objects and Surrogates. </title> <type> PhD thesis, </type> <institution> Mas sachusetts Institute of Technology, </institution> <year> 1993. </year> <month> Forthcoming. 18 </month>
Reference-contexts: We plan to experiment with this and other schemes later, perhaps including schemes where the application can control prefetching. We are also exploring schemes for managing the FE buffer <ref> [5] </ref>. An FE cache contains both copies of persistent objects and newly-created objects that have not yet become persistent. Newly-created objects are not persistent when first created and might never become persistent, in which case they will never be sent to ORs.
Reference: [6] <author> Mark Day, Barbara Liskov, Umesh Maheshwari, and Andrew C. Myers. </author> <title> Naming and locating objects in thor. </title> <note> Submitted for publication, </note> <year> 1993. </year>
Reference-contexts: Therefore, the only disk read needed is to get the segment. In fact even that read is usually not needed because objects are clustered in segments and the OR maintains recently used segments in its cache. Our scheme for object naming is discussed in more detail in <ref> [6] </ref>. 3.2.4 Objects and Surrogates When an object is copied to an FE, it is desirable to change its pointers to other objects to direct memory pointers at the FE, i.e., to virtual memory addresses.
Reference: [7] <editor> O. Deux and et al. </editor> <title> The o@-(2) system. </title> <journal> Communications of the ACM, </journal> <volume> 34(10) </volume> <pages> 34-48, </pages> <month> October </month> <year> 1991. </year>
Reference-contexts: Of the systems that support multiple languages, the approach in GemStone [2] is the closest to ours; programs written in different languages access persistant objects through a method-based interface. However, Gemstone violates object encapsulation to enhance query performance. The approach in O 2 <ref> [7] </ref> is very different; different languages can access O 2 objects and implement methods. However, even though such a language keeps its syntactic appearance, it is reimplemented to include the O 2 data model, in effect resulting in a semantically different language.
Reference: [8] <author> David J. DeWitt, David Maier, Philippe Futtersack, and Fernando Velez. </author> <title> A study of three alternative workstation-server architectures for object oriented database systems. </title> <booktitle> In Proceedings of the 16th VLDB Conference, </booktitle> <pages> pages 107-121, </pages> <year> 1990. </year>
Reference: [9] <author> D.H. Fishman and et al. </author> <title> An object-oriented database management system. </title> <journal> ACM Trans actions on Office Information Systems, </journal> <volume> 5(1) </volume> <pages> 48-69, </pages> <month> January </month> <year> 1987. </year>
Reference-contexts: Also, it is awkward or impossible for objects to contain references to one another, and object deletion must be explicit, since any kind of garbage collection is impossible if references cannot be distingushed from data. Most existing object oriented databases, such as ObjectStore [15], Statice [28], Iris <ref> [9] </ref>, and Orion [14] are specific to a single language. Of the systems that support multiple languages, the approach in GemStone [2] is the closest to ours; programs written in different languages access persistant objects through a method-based interface. However, Gemstone violates object encapsulation to enhance query performance.
Reference: [10] <author> Cary G. Gray and David R. Cheriton. Leases: </author> <title> An efficient fault-tolerant mechanism for distributed file cache consistency. </title> <booktitle> In Proceedings of the Twelfth ACM Symposium on Operating System Principles, </booktitle> <pages> pages 202-210, </pages> <year> 1989. </year>
Reference-contexts: When the client closes its session with the FE, the FE closes its OR-sessions. Thor guarantees that all objects accessible to a client (via a path from a handle) will not be deleted by garbage collection. This guarantee is provided by leases <ref> [10] </ref>. An OR guarantees to maintain a OR-session with an FE for a limited time: until the lease expires. Normally, the FE renews the lease before it expires by sending ping messages in the background.
Reference: [11] <author> Maurice Herlihy and Barbara Liskov. </author> <title> A value transmission method for abstract data types. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 4(4) </volume> <pages> 527-551, </pages> <month> October </month> <year> 1982. </year>
Reference-contexts: Method calls return additional handles, and also values, such as integers or characters. Values show up on the Thor interface in an external representation defined by their type; the client program can then map the value into some internal form that makes sense in the client programming language <ref> [11] </ref>. Clients can also invoke stand-alone procedures. Such procedures are used to create new objects, and also to do computations that operate on objects rather than belong to objects (e.g., a sort routine). 2.2 Transactions Every interaction with Thor implicitly takes place within an atomic transaction. <p> A veneer is defined just once for a particular client language, probably in the form of a preprocessor for the compiler of the client language. These techniques used in veneers are similar to those used in heterogeneous distributed systems (e.g., <ref> [11, ?, 18] </ref>). To support method calls, the veneer must provide client-side handles and also a way of getting values.
Reference: [12] <author> Deborah J. Hwang and Barbara Liskov. </author> <title> A new indexing scheme for object sets. </title> <note> Submitted to VLDB, </note> <year> 1993. </year>
Reference-contexts: They provide methods for querying over their members (e.g., a select based on a predicate). The efficient implementation of these methods requires attention (see <ref> [12] </ref> for details), but queries do not have a special place in the interface. 2.6 Operations This section summarizes the preceding discussion by describing the operations of the language-independent interface.
Reference: [13] <author> T. Kaehler and G. Krasner. </author> <title> LOOM | Large Object-Oriented Memory for Smalltalk-80 Systems, pages 298|307. </title> <publisher> Morgan Kaufmann Publishers, Inc., </publisher> <address> San Mateo, CA, </address> <year> 1990. </year>
Reference-contexts: We use the latter scheme; we call the non-residents surrogates. A surrogate contains its object's xref. It is like a forwarder in Mneme [26] or a leaf in LOOM <ref> [13] </ref>. Here is what happens when a group of objects arrives at an FE: 1. The objects are entered into the swizzle table. The swizzle table contains entries for every object at the FE, mapping between xref of the object and its current virtual memory address. 2.
Reference: [14] <author> Won Kim and et al. </author> <title> Architecture of the orion next-generation database system. </title> <journal> IEEE Transactions on Knowledge and Data Engineering, </journal> <volume> 2(1) </volume> <pages> 109-124, </pages> <month> March </month> <year> 1990. </year>
Reference-contexts: Most existing object oriented databases, such as ObjectStore [15], Statice [28], Iris [9], and Orion <ref> [14] </ref> are specific to a single language. Of the systems that support multiple languages, the approach in GemStone [2] is the closest to ours; programs written in different languages access persistant objects through a method-based interface. However, Gemstone violates object encapsulation to enhance query performance.
Reference: [15] <author> Charles Lamb, Gordon Landis, Jack Orenstein, and Dan Weinreb. </author> <title> The objectstore database system. </title> <journal> Communications of the ACM, </journal> <volume> 34(10) </volume> <pages> 50-63, </pages> <month> October </month> <year> 1991. </year>
Reference-contexts: Also, it is awkward or impossible for objects to contain references to one another, and object deletion must be explicit, since any kind of garbage collection is impossible if references cannot be distingushed from data. Most existing object oriented databases, such as ObjectStore <ref> [15] </ref>, Statice [28], Iris [9], and Orion [14] are specific to a single language. Of the systems that support multiple languages, the approach in GemStone [2] is the closest to ours; programs written in different languages access persistant objects through a method-based interface.
Reference: [16] <author> B. Lewis and D. Laliberte. </author> <title> Gnu emacs lisp reference manual, </title> <booktitle> 1990. Free Software Foun dation, </booktitle> <address> Cambridge, MA. </address>
Reference-contexts: TH is implemented in Argus [17]. It is a distributed system in which clients run at different nodes from ORs, and there are several ORs. We have built a veneer for Emacs Lisp <ref> [16] </ref> and Argus, and have written a toy hypertext application on top of Emacs and TH. We have implemented the swizzling and filling techniques described, and local garbage 16 collection built on top of the Argus garbage collector.
Reference: [17] <author> B. Liskov. </author> <title> Distributed programming in argus. </title> <journal> Comm. of the ACM, </journal> <volume> 31(3) </volume> <pages> 300-312, </pages> <month> March </month> <year> 1988. </year>
Reference-contexts: The creation of new objects is not undone (it is difficult to understand what a variable referring to such an "uncreated object" should mean), but any changes to that object are undone so that it returns to its state as first created. (This is the same semantics as in Argus <ref> [17] </ref>.) 2.6.4 Retain-handles and Discard-handles These operations inform Thor about handles no longer needed by the client. Retain-handles lists handles still in use by the client; discard-handles lists handles that will not be used subsequently. <p> TH is implemented in Argus <ref> [17] </ref>. It is a distributed system in which clients run at different nodes from ORs, and there are several ORs. We have built a veneer for Emacs Lisp [16] and Argus, and have written a toy hypertext application on top of Emacs and TH.
Reference: [18] <author> B. Liskov, T. Bloom, D. Gifford, R. Scheifler, and W. Weihl. </author> <title> Communication in the mercury system. </title> <booktitle> In Proc. of the 21st Annual Hawaii Conference on System Sciences, </booktitle> <pages> pages 178-187. </pages> <publisher> IEEE, </publisher> <month> January </month> <year> 1988. </year>
Reference-contexts: A veneer is defined just once for a particular client language, probably in the form of a preprocessor for the compiler of the client language. These techniques used in veneers are similar to those used in heterogeneous distributed systems (e.g., <ref> [11, ?, 18] </ref>). To support method calls, the veneer must provide client-side handles and also a way of getting values. <p> When calls to Thor appear in client programs the veneer compiler (or preprocessor) generates code to make the call to Thor, i.e., it implements the procedures of the client-side type. This is very much like a stub compiler in distributed systems <ref> [18, ?] </ref>. The client program usually runs in a separate address space to ensure safety; for some safe languages we may allow the client and the FE to share a single address space. <p> Since inter-process calls are usually fairly expensive, it would be good to avoid them by bundling several calls together. We are investigating ways of making such "combined operations"[?]; our approach is based partly on the promises of Mercury <ref> [18] </ref>, and partly on the work of Stamos [?]. 8 3.2 Implementation of the Interface Thor is a distributed system consisting of front ends (FEs) and object repositories (ORs). The ORs run on reliable server machines and provide persistent storage and concurrency control.
Reference: [19] <author> B. Liskov and et al. </author> <title> CLU Reference Manual. </title> <publisher> Springer-Verlag, </publisher> <year> 1984. </year>
Reference-contexts: Our approach is similar to that of GemStone [2], with its GemStone DDL/DML; however, while that language is an adaptation of Smalltalk, ours is a new object-oriented language, influenced by CLU <ref> [19] </ref> and Modula-3 [3]. Programmers can ignore our programming language if they just use existing types and implementations but not if they want to define new types or implementations.
Reference: [20] <author> B. Liskov, S. Ghemawat, R. Gruber, P. Johnson, L. Shrira, and M. Williams. </author> <title> Replication in the harp file system. </title> <booktitle> In Proc. of the Thirteenth ACM Symposium on Operating Systems Principles, </booktitle> <month> October </month> <year> 1991. </year>
Reference-contexts: ORs are replicated for high availability and performance using the same technology as the Harp file system <ref> [20] </ref>. FEs are responsible for running client calls, communicating with ORs as neeeded. To make calls run fast, FEs make use of three techniques: caching, prefetching, and swizzling.
Reference: [21] <author> Barbara Liskov, Mark Day, and Liuba Shrira. </author> <title> Distributed object management in thor. </title> <editor> In Tamer Ozsu, Umesh Dayal, and Patrick Valduriez, editors, </editor> <booktitle> Distributed Object Management, </booktitle> <publisher> pages ??-?? Morgan Kaufmann, </publisher> <year> 1993. </year>
Reference-contexts: The remainder of this section focusses on the FE implementation. Details of the OR implementation can be found in <ref> [21] </ref>. 9 3.2.1 OR-Sessions When an FE first contacts an OR, say to fetch an object, it opens an OR-session with the OR. during the session, the FE and the OR maintain information about each other.
Reference: [22] <author> Barbara Liskov and Jeannette Wing. </author> <title> Family values: A semantic notion of subtyping. </title> <type> Tech nical Report MIT/LCS/TR-526, </type> <institution> M.I.T. Laboratory for Computer Science, </institution> <address> Cambridge, MA, </address> <month> January </month> <year> 1993. </year>
Reference-contexts: A type can have zero or more supertypes. A subtype must provide the methods of each of its supertype with compatible signatures [4]; in addition, it should simulate the behavior of its supertypes as discussed in <ref> [23, 22] </ref>. We allow a subtype to rename the supertype's methods, so that if the supertype has a method named "bar", in the subtype we can choose to name the method "foo" instead.
Reference: [23] <author> Barbara Liskov and Jeannette Wing. </author> <title> Using extension maps to define subtypes. </title> <note> Submitted for publication, </note> <year> 1993. </year>
Reference-contexts: A type can have zero or more supertypes. A subtype must provide the methods of each of its supertype with compatible signatures [4]; in addition, it should simulate the behavior of its supertypes as discussed in <ref> [23, 22] </ref>. We allow a subtype to rename the supertype's methods, so that if the supertype has a method named "bar", in the subtype we can choose to name the method "foo" instead.
Reference: [24] <author> Umesh Maheshwari. </author> <title> Distributed garbage collection in a client-server, transactional, per sistent object system. </title> <type> Master's thesis, </type> <institution> Massachusetts Institute of Technology, </institution> <year> 1993. </year>
Reference-contexts: More information can be found in <ref> [24] </ref>. It allows client sessions to survive failovers at ORs and avoids the need to maintain session information on stable storage at ORs. 3.2.2 Buffer Management Unlike other systems, Thor manages its buffers in terms of objects.
Reference: [25] <author> J. E. B. Moss. </author> <title> Working with persistent objects: To swizzle or not to swizzle. </title> <type> Technical Report 90-38, COINS, </type> <institution> University of Massachusetts - Amherst, </institution> <year> 1990. </year>
Reference-contexts: This lazy swizzling avoids the filled surrogate indirection. Also, eager swizzling would spend time swizzling many objects that are prefetched but never used <ref> [25] </ref>; lazy swizzling avoids this overhead. We are working on schemes that allow dispatching to be replaced by direct calls in the presence of swizzling [27]. 3.2.6 Transactions The calls that make up a transaction run using objects at the FE, and fetching additional objects if necessary.
Reference: [26] <author> J.E.B. Moss. </author> <title> Design of the mneme persistent object store. </title> <journal> ACM Transactions on Office Information Systems, </journal> <volume> 8(2) </volume> <pages> 103-139, </pages> <month> March </month> <year> 1990. </year>
Reference-contexts: We use the latter scheme; we call the non-residents surrogates. A surrogate contains its object's xref. It is like a forwarder in Mneme <ref> [26] </ref> or a leaf in LOOM [13]. Here is what happens when a group of objects arrives at an FE: 1. The objects are entered into the swizzle table.
Reference: [27] <author> Andrew C. Myers. </author> <title> Optimizing method dispatch in a heterogeneous object repository. </title> <type> Master's thesis, </type> <institution> Massachusetts Institute of Technology, </institution> <year> 1993. </year> <month> Forthcoming. </month>
Reference-contexts: This lazy swizzling avoids the filled surrogate indirection. Also, eager swizzling would spend time swizzling many objects that are prefetched but never used [25]; lazy swizzling avoids this overhead. We are working on schemes that allow dispatching to be replaced by direct calls in the presence of swizzling <ref> [27] </ref>. 3.2.6 Transactions The calls that make up a transaction run using objects at the FE, and fetching additional objects if necessary.
Reference: [28] <author> D. Weinreb, D. Gerson, and C. Lamb. </author> <title> An object oriented system to support an integrated programming environment. </title> <journal> IEEE Transactions on Data Engineering, </journal> <volume> 11(2) </volume> <pages> 33-43, </pages> <year> 1988. </year> <month> 20 </month>
Reference-contexts: Also, it is awkward or impossible for objects to contain references to one another, and object deletion must be explicit, since any kind of garbage collection is impossible if references cannot be distingushed from data. Most existing object oriented databases, such as ObjectStore [15], Statice <ref> [28] </ref>, Iris [9], and Orion [14] are specific to a single language. Of the systems that support multiple languages, the approach in GemStone [2] is the closest to ours; programs written in different languages access persistant objects through a method-based interface. However, Gemstone violates object encapsulation to enhance query performance.
References-found: 28

