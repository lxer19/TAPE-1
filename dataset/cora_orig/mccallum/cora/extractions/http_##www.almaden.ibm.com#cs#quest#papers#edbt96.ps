URL: http://www.almaden.ibm.com/cs/quest/papers/edbt96.ps
Refering-URL: http://www.almaden.ibm.com/cs/quest/publications.html
Root-URL: http://www.aic.nrl.navy.mil/~aha/people.html
Email: fsrikant, ragrawalg@almaden.ibm.com  
Title: Mining Sequential Patterns: Generalizations and Performance Improvements  
Author: Ramakrishnan Srikant and Rakesh Agrawal 
Address: 650 Harry Road, San Jose, CA 95120  
Affiliation: IBM Almaden Research Center  
Abstract: The problem of mining sequential patterns was recently introduced in [3]. We are given a database of sequences, where each sequence is a list of transactions ordered by transaction-time, and each transaction is a set of items. The problem is to discover all sequential patterns with a user-specified minimum support, where the support of a pattern is the number of data-sequences that contain the pattern. An example of a sequential pattern is "5% of customers bought `Foundation' and `Ringworld' in one transaction, followed by `Second Foundation' in a later transaction". We generalize the problem as follows. First, we add time constraints that specify a minimum and/or maximum time period between adjacent elements in a pattern. Second, we relax the restriction that the items in an element of a sequential pattern must come from the same transaction, instead allowing the items to be present in a set of transactions whose transaction-times are within a user-specified time window. Third, given a user-defined taxonomy (is-a hierarchy) on items, we allow sequential patterns to include items across all levels of the taxonomy. We present GSP, a new algorithm that discovers these generalized sequential patterns. Empirical evaluation using synthetic and real-life data indicates that GSP is much faster than the AprioriAll algorithm presented in [3]. GSP scales linearly with the number of data-sequences, and has very good scale-up properties with respect to the average data sequence size.
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> R. Agrawal, T. Imielinski, and A. Swami. </author> <title> Mining association rules between sets of items in large databases. </title> <booktitle> In Proc. of the ACM SIGMOD Conference on Management of Data, </booktitle> <pages> pages 207-216, </pages> <address> Washington, D.C., </address> <month> May </month> <year> 1993. </year>
Reference-contexts: For the cases that the extended AprioriAll can handle, our empirical evaluation shows that GSP is upto 20 times faster. Somewhat related to our work is the problem of mining association rules <ref> [1] </ref>. Association rules are rules about what items are bought together within a transaction, and are thus intra-transaction patterns, unlike inter-transaction sequential patterns. The problem of finding association rules when there is a user-defined taxonomy on items has been addressed in [6] [4].
Reference: 2. <author> R. Agrawal and R. Srikant. </author> <title> Fast Algorithms for Mining Association Rules. </title> <booktitle> In Proc. of the 20th Int'l Conference on Very Large Databases, </booktitle> <address> Santiago, Chile, </address> <month> September </month> <year> 1994. </year>
Reference-contexts: If there is no max-gap constraint, we also delete candidate sequences that have any subsequence without minimum support. The above procedure is reminiscent of the candidate generation procedure for finding association rules <ref> [2] </ref>; however details are quite different. A proof of correctness of this procedure is given in [7]. Example Figure 3 shows L 3 , and C 4 after the join and prune phases. <p> We transform the representation of the data-sequence d so that we can effi ciently find whether a specific candidate is a subsequence of d. 3.2.1 Reducing the number of candidates that need to be checked We adapt the hash-tree data structure of <ref> [2] </ref> for this purpose. A node of the hash-tree either contains a list of sequences (a leaf node) or a hash table (an interior node). In an interior node, each non-empty bucket of the hash table points to another node.
Reference: 3. <author> R. Agrawal and R. Srikant. </author> <title> Mining Sequential Patterns. </title> <booktitle> In Proc. of the 11th Int'l Conference on Data Engineering, </booktitle> <address> Taipei, Taiwan, </address> <month> March </month> <year> 1995. </year>
Reference-contexts: 1 Introduction Data mining, also known as knowledge discovery in databases, has been recognized as a promising new area for database research. This area can be defined as efficiently discovering interesting rules from large databases. A new data mining problem, discovering sequential patterns, was introduced in <ref> [3] </ref>. The input data is a set of sequences, called data-sequences. Each data-sequence is a list of transactions, where each transaction is a sets of literals, called items. Typically there is a transaction-time associated with each transaction. A sequential pattern also consists of a list of sets of items. <p> The patterns discovered using this data could be used in disease research to help identify symptoms/diseases that precede certain diseases. However, the above problem definition as introduced in <ref> [3] </ref> has the following limitations: 1. Absence of time constraints. Users often want to specify maximum and/or minimum time gaps between adjacent elements of the sequential pattern. <p> With this taxonomy, a customer who bought "Foundation" followed by "Perfect Spy" would support the patterns " `Foundation' followed by `Perfect Spy' ", " `Asimov' followed by `Perfect Spy' ", " `Science Fiction' followed by `Le Carre' ", etc. In this paper, we generalize the problem definition given in <ref> [3] </ref> to incorporate time constraints, sliding time windows, and taxonomies in sequential patterns. We present GSP (Generalized Sequential Patterns), a new algorithm that discovers all such sequential patterns. <p> Empirical evaluation shows that GSP scales linearly with the number of data-sequences, and has very good scale-up properties with respect to the number of transactions per data-sequence and number of items per transaction. 1.1 Related Work In addition to introducing the problem of sequential patterns, <ref> [3] </ref> presented three algorithms for solving this problem, but these algorithms do not handle time constraints, sliding windows, or taxonomies. Two of these algorithms were designed to find only maximal sequential patterns; however, many applications require all patterns and their supports. <p> In Section 3, we describe GSP, an algorithm for finding such patterns. We empirically compared the performance of GSP with the AprioriAll algorithm <ref> [3] </ref>, studied the scale-up properties of GSP, and examined the performance impact of time constraints and sliding windows. Due to space limitations, we could not include the details of these experiments which are reported in [7]. However, we include the gist of the main results in Section 4. <p> of total data-sequences that "contain" this sequence. (Although the word "contains" is not strictly accurate once we incorporate taxonomies, it captures the spirt of when a data-sequence contributes to the support of a sequential pattern.) We now define when a data-sequence contains a sequence, starting with the definition as in <ref> [3] </ref>, and then adding taxonomies, sliding windows, and time constraints : * as in [3]: In the absence of taxonomies, sliding windows and time constraints, a data-sequence contains a sequence s if s is a subsequence of the data-sequence. * plus taxonomies: We say that a transaction T contains an item <p> accurate once we incorporate taxonomies, it captures the spirt of when a data-sequence contributes to the support of a sequential pattern.) We now define when a data-sequence contains a sequence, starting with the definition as in <ref> [3] </ref>, and then adding taxonomies, sliding windows, and time constraints : * as in [3]: In the absence of taxonomies, sliding windows and time constraints, a data-sequence contains a sequence s if s is a subsequence of the data-sequence. * plus taxonomies: We say that a transaction T contains an item x 2 I if x is in T or x is an ancestor of <p> Note that if there is no taxonomy, min-gap = 0, max-gap = 1 and window-size = 0 we get the notion of sequential patterns as introduced in <ref> [3] </ref>, where there are no time constraints and items in an element come from a single transaction. 2.1 Problem Definition Given a database D of data-sequences, a taxonomy T , user-specified min-gap and max-gap time constraints, and a user-specified sliding-window size, the problem of mining sequential patterns is to find all <p> For simplicity, we have assumed that the transaction-times are integers; they could represent, for instance, the number of days after January 1, 1995. We have used an abbreviated version of the taxonomy given in Figure 1. Assume that the minimum support has been set to 2 data-sequences. With the <ref> [3] </ref> problem definition, the only 2-element sequential patterns is: h (Ringworld) (Ringworld Engineers) i Database D Sequence-Id Transaction Items Time C1 1 Ringworld C1 2 Foundation C1 15 Ringworld Engineers, Second Foundation C2 1 Foundation, Ringworld C2 20 Foundation and Empire C2 50 Ringworld Engineers Taxonomy T Fig. 2. <p> idea is that given a user-specified interest-level I, we display patterns that have no ancestors, or patterns whose actual support is at least I times their expected support (based on the support of their ancestors). 4 Performance Evaluation We compared the performance of GSP to the AprioriAll algorithm given in <ref> [3] </ref>, using both synthetic and real-life datasets. Due to lack of space, we only summarize the main results in this section. Details of the experiments, including performance graphs and detailed explanations of the results, can be found in [7]. Comparison of GSP and AprioriAll. <p> The problem of mining sequential patterns introduced in <ref> [3] </ref> is to discover all sequential patterns with a user-specified minimum support, where the support of a pattern is the number of data-sequences that contain the pattern. We addressed some critical limitations of the earlier work in order to make sequential patterns useful for real applications. <p> We presented GSP, a new algorithm that discovers these generalized sequential patterns. It is a complete algorithm in that it guarantees finding all rules that have a user-specified minimum support. Empirical evaluation using synthetic and real-life data indicates that GSP is much faster than the AprioriAll algorithm presented in <ref> [3] </ref>. GSP scales linearly with the number of data-sequences, and has very good scale-up properties with respect to the average data-sequence size. The GSP algorithm has been implemented as part of the Quest data mining prototype at IBM Research, and is incorporated in the IBM data mining product.
Reference: 4. <author> J. Han and Y. Fu. </author> <title> Discovery of multiple-level association rules from large databases. </title> <booktitle> In Proc. of the 21st Int'l Conference on Very Large Databases, </booktitle> <address> Zurich, Switzerland, </address> <month> September </month> <year> 1995. </year>
Reference-contexts: Association rules are rules about what items are bought together within a transaction, and are thus intra-transaction patterns, unlike inter-transaction sequential patterns. The problem of finding association rules when there is a user-defined taxonomy on items has been addressed in [6] <ref> [4] </ref>. The problem of discovering similarities in a database of genetic sequences, presented in [8], is relevant. However, the patterns they wish to discover are subsequences made up of consecutive characters separated by a variable number of noise characters.
Reference: 5. <author> H. Mannila, H. Toivonen, and A. I. Verkamo. </author> <title> Discovering frequent episodes in sequences. </title> <booktitle> In Proc. of the Int'l Conference on Knowledge Discovery in Databases and Data Mining (KDD-95), </booktitle> <address> Montreal, Canada, </address> <month> August </month> <year> 1995. </year>
Reference-contexts: In addition, we are interested in finding all sequences with minimum support rather than some frequent patterns. A problem of discovering frequent episodes in a sequence of events was presented in <ref> [5] </ref>. Their patterns are arbitrary DAG (directed acyclic graphs), where each vertex corresponds to a single event (or item) and an edge from event A to event B denotes that A occurred before B.
Reference: 6. <author> R. Srikant and R. Agrawal. </author> <title> Mining Generalized Association Rules. </title> <booktitle> In Proc. of the 21st Int'l Conference on Very Large Databases, </booktitle> <address> Zurich, Switzerland, </address> <month> September </month> <year> 1995. </year>
Reference-contexts: Association rules are rules about what items are bought together within a transaction, and are thus intra-transaction patterns, unlike inter-transaction sequential patterns. The problem of finding association rules when there is a user-defined taxonomy on items has been addressed in <ref> [6] </ref> [4]. The problem of discovering similarities in a database of genetic sequences, presented in [8], is relevant. However, the patterns they wish to discover are subsequences made up of consecutive characters separated by a variable number of noise characters. <p> We now find item 2 at time 90, while item 6 remains at time 95. Since the time gap between 90 and 95 is less than the window size, we are done. 3.3 Taxonomies The ideas presented in <ref> [6] </ref> for discovering association rules with taxonomies carry over to the current problem. <p> Given this information, we would "expect" the support of the pattern h (Foundation) (Ringworld) i to be 7.5%, since half the "Asimov"s are "Foundation"s. If the actual support of h (Foundation) (Ringworld) i is close to 7.5%, the pattern can be considered "redundant". The interest measure introduced in <ref> [6] </ref> also carries over and can be used to prune such redundant patterns.
Reference: 7. <author> R. Srikant and R. Agrawal. </author> <title> Mining Sequential Patterns: Generalizations and Performance Improvements. </title> <type> Research Report RJ 9994, </type> <institution> IBM Almaden Research Center, </institution> <address> San Jose, California, </address> <month> December </month> <year> 1995. </year>
Reference-contexts: We empirically compared the performance of GSP with the AprioriAll algorithm [3], studied the scale-up properties of GSP, and examined the performance impact of time constraints and sliding windows. Due to space limitations, we could not include the details of these experiments which are reported in <ref> [7] </ref>. However, we include the gist of the main results in Section 4. We conclude with a summary in Section 5. 2 Problem Statement Definitions Let I = fi 1 ; i 2 ; : : : ; i m g be a set of literals, called items. <p> Frequent sequences resulting from these candidates are written to disk, while those candidates without minimum support are deleted. This procedure is repeated until all the candidates have been counted. Further details about memory management can be found in <ref> [7] </ref>. 3.1 Candidate Generation We refer to a sequence with k items as a k-sequence. (If an item occurs multiple times in different elements of a sequence, each occurrence contributes to the value of k.) Let L k denote the set of all frequent k-sequences, and C k the set of <p> The sequences h (2) (3, 4) (5) i, h (1, 2) (3) (5) (6) i and h (3) (5) i are some of the contiguous subsequences of s. However, h (1, 2) (3, 4) (6) i and h (1) (5) (6) i are not. We show in <ref> [7] </ref> that any data-sequence that contains a sequence s will also contain any contiguous subsequence of s. <p> If there is no max-gap constraint, we also delete candidate sequences that have any subsequence without minimum support. The above procedure is reminiscent of the candidate generation procedure for finding association rules [2]; however details are quite different. A proof of correctness of this procedure is given in <ref> [7] </ref>. Example Figure 3 shows L 3 , and C 4 after the join and prune phases. <p> Due to lack of space, we only summarize the main results in this section. Details of the experiments, including performance graphs and detailed explanations of the results, can be found in <ref> [7] </ref>. Comparison of GSP and AprioriAll. On the synthetic datasets, GSP was between 30% to 5 times faster than AprioriAll, with the performance gap often increasing at low levels of minimum support.
Reference: 8. <author> J. T.-L. Wang, G.-W. Chirn, T. G. Marr, B. Shapiro, D. Shasha, and K. Zhang. </author> <title> Combinatorial pattern discovery for scientific data: Some preliminary results. </title> <booktitle> In Proc. of the ACM SIGMOD Conference on Management of Data, </booktitle> <address> Minneapolis, </address> <month> May </month> <year> 1994. </year>
Reference-contexts: The problem of finding association rules when there is a user-defined taxonomy on items has been addressed in [6] [4]. The problem of discovering similarities in a database of genetic sequences, presented in <ref> [8] </ref>, is relevant. However, the patterns they wish to discover are subsequences made up of consecutive characters separated by a variable number of noise characters. A sequence in our problem consists of list of sets of characters (items), rather than being simply a list of characters.
References-found: 8

