URL: http://www.cs.toronto.edu/~csc2532h/lin-ijcai97.ps.Z
Refering-URL: http://www.cs.toronto.edu/~csc2532h/
Root-URL: http://www.cs.toronto.edu
Email: (flin@cs.ust.hk)  
Title: Applications of the Situation Calculus To Formalizing Control and Strategic Information: The Prolog Cut Operator  
Author: Fangzhen Lin 
Address: Hong Kong  
Affiliation: Department of Computer Science The Hong Kong University of Science and Technology Clear Water Bay, Kowloon,  
Abstract: We argue that the situation calculus is a natural formalism for representing and reasoning about control and strategic information. As a case study, in this paper we provide a situation calculus semantics for the Prolog cut operator, the central search control operator in Prolog. We show that our semantics is well-behaved when the programs are properly stratified. We also show that according to this semantics, the conventional implementation of the negation-as-failure operator using cut is provably correct with respect to the stable model semantics. 
Abstract-found: 1
Intro-found: 1
Reference: [ 1 ] <author> J. Andrews. </author> <title> A paralogical semantics for the prolog cut. </title> <booktitle> In Proc. of Int. Logic Programming Symposium, </booktitle> <pages> pages 591-605, </pages> <year> 1995. </year>
Reference-contexts: Regarding our situation calculus semantics for the cut operator, there are many directions for future work. First of all, there is a need to compare our semantics with recent work of <ref> [ 1; 9 ] </ref> . More importantly, we should use this semantics to clarify the proper roles of cut in logic programming, to study the possibility of a better control mechanism, and to do verifications and syntheses of logic programs with cut.
Reference: [ 2 ] <author> M. Gelfond and V. Lifschitz. </author> <title> The stable model semantics for logic programming. </title> <booktitle> In Proc. Fifth International Conference and Symposium on Logic Programming, </booktitle> <pages> pages 1070-1080, </pages> <year> 1988. </year>
Reference-contexts: We also show that according to this semantics, the conventional implementation of the negation-as-failure operator using cut is provably correct with respect to the stable model semantics of Gelfond and Lifschitz <ref> [ 2 ] </ref> . To the best of our knowledge, this is the first time a connection has been shown between a declarative semantics of negation and that of cut. This paper is organized as follows. Section 2 briefly reviews the basic concepts in the situation calculus and logic programming. <p> As noted in (Lin and Reiter [ 6 ] ), the semantics given there for logic programs with negation yields the same results as that given in (Wallace [ 10 ] ), and the latter has been shown to be equivalent to the stable model semantics of (Gelfond and Lifschitz <ref> [ 2 ] </ref> ) when only Herbrand models are considered.
Reference: [ 3 ] <author> C. C. Green. </author> <title> Application of theorem proving to problem solving. </title> <booktitle> In Proceedings of the International Joint Conference on Artificial Intelligence (IJCAI-69), </booktitle> <pages> pages 219-239, </pages> <year> 1969. </year>
Reference-contexts: A situation term S is called a plan for a goal G iff D j= H (G; S). Therefore query answering in logic programs literally becomes planning in the style of (Green <ref> [ 3 ] </ref> ) in the situation calculus. This semantics has some nice properties. It is closely related to a recent proposal by Wallace [ 10 ] , and generalizes the Clark completion semantics. Furthermore, in the propositional case, it is equivalent to Gelfond and Lifschitz's stable model semantics.
Reference: [ 4 ] <author> F. Lin. </author> <title> An ordering on subgoals for planning. </title> <journal> Annals of Mathematics and Artificial Intelligence. </journal> <note> Special issue in honor of Professor Michael Gelfond, To appear. http://www.cs.ust.hk/~flin. </note>
Reference-contexts: For example, in AI planning, a plan is a sequence of actions, thus isomorphic to situations. So control knowledge in planning, which often are constraints on desirable plans, becomes constraints on situations (Lin <ref> [ 4 ] </ref> ). Similarly, when we talk about control information in logic programming, we are referring to constraints on derivations, i.e. sequences of actions according to (Lin and Reiter [ 6 ] ). <p> As we mentioned in Section 1, in AI planning, a plan is a sequence of actions, thus isomorphic to situations. So control knowledge in planning, which often are constraints on desirable plans, becomes constraints on situations. Based on this idea, in (Lin <ref> [ 4 ] </ref> ), we formulate precisely a subgoal ordering in planning in the situation calculus, and show how information about this subgoal ordering can be deduced from a background action theory.
Reference: [ 5 ] <author> F. Lin and R. Reiter. </author> <title> State constraints revisited. </title> <journal> Journal of Logic and Computation, Special Issue on Actions and Processes, </journal> <volume> 4(5) </volume> <pages> 655-678, </pages> <year> 1994. </year>
Reference-contexts: The third axiom is second order induction. 2 Except for the one about &lt;, these axioms are taken from (Lin and Reiter <ref> [ 5 ] </ref> ), which also proves some useful properties about them. It amounts to the domain closure axiom that every situation has to be obtained from the initial one by repeatly applying the function do.
Reference: [ 6 ] <author> F. Lin and R. Reiter. </author> <title> Rules as actions: A situation calculus semantics for logic programs. </title> <journal> J. of Logic Programming, </journal> <note> To appear. http://www.cs.toronto.edu/~cogrobo/. </note>
Reference-contexts: So control knowledge in planning, which often are constraints on desirable plans, becomes constraints on situations (Lin [ 4 ] ). Similarly, when we talk about control information in logic programming, we are referring to constraints on derivations, i.e. sequences of actions according to (Lin and Reiter <ref> [ 6 ] </ref> ). Although our long term goal is to develop a general framework for representing and reasoning about control knowledge in problem solving using the situation calculus, our focus in this paper is the Prolog cut operator, the central search control operator in Prolog. <p> This paper is organized as follows. Section 2 briefly reviews the basic concepts in the situation calculus and logic programming. Section 3 reviews the situation cal culus semantics of (Lin and Reiter <ref> [ 6 ] </ref> ) for cut-free logic programs. For the purpose of this paper, the key property of this semantics is that derivations in logic programming are identified with situations. Section 4 extends this semantics to logic programs with cut. <p> First, we consider the "pure logical" semantics of the programs when cut is taken to be a goal that succeeds immediately. For this purpose, we shall use the situation calculus semantics for logic programs without cut proposed by Lin and Reiter ( <ref> [ 6 ] </ref> ). For our purpose here, the key of this semantics is that program clauses are identified with the effects of actions in the situation calculus, so a branch in a search tree becomes a sequence of actions, thus isomorphically, a situation. <p> The rest of this section is basically a review of <ref> [ 6 ] </ref> with a minor notational difference: while we reify fluents and use the special predicate H, Lin and Reiter [ 6 ] treat flu-ents as predicate symbols. For example, H (broken; s) would be written as broken (s) in [ 6 ] . According to [ 6 ] , <p> The rest of this section is basically a review of <ref> [ 6 ] </ref> with a minor notational difference: while we reify fluents and use the special predicate H, Lin and Reiter [ 6 ] treat flu-ents as predicate symbols. For example, H (broken; s) would be written as broken (s) in [ 6 ] . According to [ 6 ] , clauses are treated as rules, so that the application of such a rule in the process of answering a query is <p> rest of this section is basically a review of <ref> [ 6 ] </ref> with a minor notational difference: while we reify fluents and use the special predicate H, Lin and Reiter [ 6 ] treat flu-ents as predicate symbols. For example, H (broken; s) would be written as broken (s) in [ 6 ] . According to [ 6 ] , clauses are treated as rules, so that the application of such a rule in the process of answering a query is like performing an action. <p> a review of <ref> [ 6 ] </ref> with a minor notational difference: while we reify fluents and use the special predicate H, Lin and Reiter [ 6 ] treat flu-ents as predicate symbols. For example, H (broken; s) would be written as broken (s) in [ 6 ] . According to [ 6 ] , clauses are treated as rules, so that the application of such a rule in the process of answering a query is like performing an action. <p> to <ref> [ 6 ] </ref> , clauses are treated as rules, so that the application of such a rule in the process of answering a query is like performing an action. Formally, given a clause of the form F (x 1 ; :::; x n ) :- G Lin and Reiter [ 6 ] introduce a unique action A of the arity object n ! action to name this clause. <p> This semantics has some nice properties. It is closely related to a recent proposal by Wallace [ 10 ] , and generalizes the Clark completion semantics. Furthermore, in the propositional case, it is equivalent to Gelfond and Lifschitz's stable model semantics. For details, see (Lin and Reiter <ref> [ 6 ] </ref> ). <p> A 0 Suppose that for each fluent F , the action A F is ordered before the action A 0 F . Theorem 2 Let E be the extended action theory of P 0 , and D the action theory for P as defined in (Lin and Reiter <ref> [ 6 ] </ref> ). For fluent F in P , and any tuple ~ t of terms of sort object, we have D j= (9s)H (F ( ~ t); s) iff E j= (9s):Acc (s) ^ H (F ( ~ t); s). <p> From this theorem, we conclude that the usual implementation of negation using cut is correct with respect to the semantics given in (Lin and Reiter <ref> [ 6 ] </ref> ). As noted in (Lin and Reiter [ 6 ] ), the semantics given there for logic programs with negation yields the same results as that given in (Wallace [ 10 ] ), and the latter has been shown to be equivalent to the stable model semantics of <p> From this theorem, we conclude that the usual implementation of negation using cut is correct with respect to the semantics given in (Lin and Reiter <ref> [ 6 ] </ref> ). As noted in (Lin and Reiter [ 6 ] ), the semantics given there for logic programs with negation yields the same results as that given in (Wallace [ 10 ] ), and the latter has been shown to be equivalent to the stable model semantics of (Gelfond and Lifschitz [ 2 ] ) when only Herbrand
Reference: [ 7 ] <author> J. McCarthy and P. Hayes. </author> <title> Some philosophical problems from the standpoint of artificial intelligence. </title> <editor> In B. Meltzer and D. Michie, editors, </editor> <booktitle> Machine Intelligence 4, </booktitle> <pages> pages 463-502. </pages> <publisher> Edinburgh University Press, </publisher> <address> Edin-burgh, </address> <year> 1969. </year>
Reference-contexts: 1 Introduction The situation calculus (McCarthy and Hayes <ref> [ 7 ] </ref> ) is a formalism for representing and reasoning about actions in dynamic domains. It is a many-sorted predicate calculus with some reserved predicate and function symbols.
Reference: [ 8 ] <author> R. Reiter. </author> <title> The frame problem in the situation calculus: a simple solution (sometimes) and a completeness result for goal regression. </title> <editor> In V. Lifschitz, editor, </editor> <booktitle> Artificial Intelligence and Mathematical Theory of Computation: Papers in Honor of John McCarthy, </booktitle> <pages> pages 418-420. </pages> <publisher> Academic Press, </publisher> <address> San Diego, CA, </address> <year> 1991. </year>
Reference-contexts: We then generate the following successor state axiom (Reiter <ref> [ 8 ] </ref> ) for F : H (F (~x); do (a; s)) j fa = A 1 (~x) ^ (9 ~y 1 )H (G 1 ; s) _ _ Intuitively, this axiom says that F is true in a successor situation iff either it is true initially or the action
Reference: [ 9 ] <author> K. Stroetmann and T. Glab. </author> <title> A declarative semantics for the prolog cut operator. </title> <booktitle> In Proc. of 5th Int. Workshop on Extensions of Logic Programming, </booktitle> <pages> pages 255-271, </pages> <year> 1996. </year>
Reference-contexts: Regarding our situation calculus semantics for the cut operator, there are many directions for future work. First of all, there is a need to compare our semantics with recent work of <ref> [ 1; 9 ] </ref> . More importantly, we should use this semantics to clarify the proper roles of cut in logic programming, to study the possibility of a better control mechanism, and to do verifications and syntheses of logic programs with cut.
Reference: [ 10 ] <author> M. G. Wallace. </author> <title> Tight, consistent, and computable completions for unrestricted logic programs. </title> <journal> Journal of Logic Programming, </journal> <volume> 15 </volume> <pages> 243-273, </pages> <year> 1993. </year>
Reference-contexts: Therefore query answering in logic programs literally becomes planning in the style of (Green [ 3 ] ) in the situation calculus. This semantics has some nice properties. It is closely related to a recent proposal by Wallace <ref> [ 10 ] </ref> , and generalizes the Clark completion semantics. Furthermore, in the propositional case, it is equivalent to Gelfond and Lifschitz's stable model semantics. For details, see (Lin and Reiter [ 6 ] ). <p> As noted in (Lin and Reiter [ 6 ] ), the semantics given there for logic programs with negation yields the same results as that given in (Wallace <ref> [ 10 ] </ref> ), and the latter has been shown to be equivalent to the stable model semantics of (Gelfond and Lifschitz [ 2 ] ) when only Herbrand models are considered.
References-found: 10

