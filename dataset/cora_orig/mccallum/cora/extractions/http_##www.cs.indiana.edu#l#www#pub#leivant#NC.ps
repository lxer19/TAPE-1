URL: http://www.cs.indiana.edu/l/www/pub/leivant/NC.ps
Refering-URL: http://www.cs.indiana.edu/l/www/pub/leivant/
Root-URL: http://www.cs.indiana.edu
Email: leivant@cs.indiana.edu.  
Title: A Characterization of NC by Tree Recurrence  
Author: Daniel Leivant 
Affiliation: Computer Science Department, Indiana University  
Abstract: We show that a boolean valued function is in NC iff it is defined by ramified schematic recurrence over trees. This machine-independent characterization uses no initial functions other than basic tree operations, and no bounding conditions on the recurrence. Aside from its technical interest, our result evidences the foundational nature of NC, thereby illustrating the merits of implicit (i.e. machine independent) computational complexity theory. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> S. Bellantoni. </author> <title> Predicative recursion and the polytime hierarchy. </title> <editor> In Peter Clote and Jef-fery Remmel, editors, </editor> <booktitle> Feasible Mathematics II, Perspectives in Computer Science, </booktitle> <pages> pages 15-29. </pages> <publisher> Birkhauser, </publisher> <year> 1994. </year>
Reference-contexts: Indeed, the phrase "recursion" is used in computer science for a broader notion, whereas "recurrence" has been used precisely for this and closely related schemas. log time [18]), linear space [13, 11, 15], NP, the poly--time hierarchy <ref> [1] </ref>, poly-space [21, 22] and (Kalmar-) elementary time [17]. 2 Most of the characterizations above refer to recurrence over free algebras of words or trees, rather than over the set N of natural numbers. <p> If T is a single configuration K, there are three cases, depending on the state q in K: (a) q is an action state, then the valued returned is ?; (b) q is rejecting [respectively, accepting], then the value returned is 0 <ref> [respectively, 1] </ref>; (c) q is c; j-reading, then return 1 or 0 according to whether the n'th bit of that input tape is c, where n is the numeric value (in inverse binary) of the j-th work-stack (if n exceeds the length of the input then the n'th bit is posited
Reference: [2] <author> S. Bellantoni. </author> <title> Characterizing parallel time by type 2 recursions with polynomial output lenght. </title> <editor> In D. Leivant, editor, </editor> <booktitle> Logic and Computational Complexity, </booktitle> <volume> LNCS 960, </volume> <pages> pages 253-268. </pages> <publisher> Springer-Verlag, </publisher> <year> 1995. </year>
Reference-contexts: The observation above was used in <ref> [21, 2, 23, 22] </ref> to obtain characterizations of PSpace, alternating log time, and alternating poly-log time. 1.4 Main result and comparison with previous works In this paper we establish a characterization by ramified recurrence of computation in NC. <p> Ramified recurrence over trees was introduced in [13, 15], as part of a generic notion of ramified recurrence over free algebras. The first characterization result that uses explicitly ramified recurrence over trees seems to be in <ref> [2] </ref>, where Steve Bellantoni outlines a proof for a characterization of the alternating poly-log functions.
Reference: [3] <author> S. Bellantoni and S. Cook. </author> <title> A new recursion-theoretic characterization of the poly-time functions. </title> <journal> Computational Complexity, </journal> <volume> 2 </volume> <pages> 97-110, </pages> <year> 1992. </year>
Reference-contexts: More recently it has been shown that recurrence can reflect different uses of data in computing, leading to a better understanding of the relation between applicative programs and computational complexity. This was pointed out independently for recurrence <ref> [3] </ref>, functional recurrence [28], lambda representability [12], and second order provability [14]. Notably, Bellantoni and Cook [3] formalized this distinction and obtained a functional characterization of poly-time that does away with the bounding condition of [7]. <p> This was pointed out independently for recurrence <ref> [3] </ref>, functional recurrence [28], lambda representability [12], and second order provability [14]. Notably, Bellantoni and Cook [3] formalized this distinction and obtained a functional characterization of poly-time that does away with the bounding condition of [7]. In [13] we outlined a predicative-finitistic critique of recurrence that leads to a generalization and streamlining of the result and proof of [3], using a general form of ramified data and <p> Notably, Bellantoni and Cook <ref> [3] </ref> formalized this distinction and obtained a functional characterization of poly-time that does away with the bounding condition of [7]. In [13] we outlined a predicative-finitistic critique of recurrence that leads to a generalization and streamlining of the result and proof of [3], using a general form of ramified data and ramified recurrence. Variants of this method have been used to characterize, among others, alternating fl Research partially supported by NSF grants CCR-9309824 and DMS-980320. <p> However, some of these references are indirect, with the underlying free algebras embedded in N : word recurrence is then conveyed as "recursion on notations" over N <ref> [7, 3] </ref>, and tree recurrence as "divide-and-conquer recursion" [10, 4]. <p> Functions with all inputs and output in T 0 will be called flat. For easier readability, we use a notational convention similar to that of <ref> [3] </ref>, and write f (~u; ~v), with a semicolon separating two lists of arguments, to indicate that the arguments ~u are in T 1 , and ~v in T 0 .
Reference: [4] <author> S. Bloch. </author> <title> Function-algebraic characterizations of log and polylog parallel time. </title> <journal> Computational Complexity, </journal> <volume> 4(2) </volume> <pages> 175-205, </pages> <year> 1994. </year>
Reference-contexts: However, some of these references are indirect, with the underlying free algebras embedded in N : word recurrence is then conveyed as "recursion on notations" over N [7, 3], and tree recurrence as "divide-and-conquer recursion" <ref> [10, 4] </ref>. <p> However, these use ad hoc initial functions also, bounding of recurrence is essentially an explicit restriction of computational resources, so such characterizations do not link computational complexity to a conceptually-based machine-independent definition. In <ref> [4] </ref> Steve Bloch characterized alternating log time using a ramified variant of recurrence. Improved result and proof, using tree recurrence similar to the one considered here, are in [18]. Ramified recurrence over trees was introduced in [13, 15], as part of a generic notion of ramified recurrence over free algebras. <p> One approach has been to concentrate on computation in linear time, giving rise to various characterizations of alternating log time such as <ref> [10, 4, 18] </ref>. Another approach extends the ramification to a third tier T 2 , allowing the generation of polynomial "clocks" in tier T 1 ; such clocks can then be used to drive a single computation cycle, thereby avoiding the problem of nested recurrence.
Reference: [5] <author> A. Chandra, D. Kozen, and L. Stockmeyer. </author> <title> Alternation. </title> <journal> Journal of the ACM, </journal> <volume> 28 </volume> <pages> 114-133, </pages> <year> 1981. </year> <title> 11 This can be seen by a construction analogous to Theorem 2.4 in [15]. 12 Note that the inputs in T 0 may be of poly-logarithmic height, whence super-polynomial size. </title>
Reference-contexts: nest recurrences an arbitrary number of times, resulting in functions essentially as fast growing as with no restriction at all. 8 Here log is the base-2 logarithm rounded to the next larger integer. 2.4 Precise statement of the main result We refer to the alternating random access Turing machines of <ref> [5, 26] </ref>, ARM for short. Let us recap the essentials of the definition. An ARM M has read-only input tapes as well as work-stacks. 9 No output device is provided, since the output is a single bit, determined by the machine's control.
Reference: [6] <author> P. Clote. </author> <title> Computation models and function al-gebras. </title> <editor> In E. Griffor, editor, </editor> <booktitle> Handbook of Recursion Theory. </booktitle> <publisher> North Holland, </publisher> <year> 1997. </year>
Reference-contexts: Machine independent characterizations of alternating log time have been known for some time. The earliest one seems to be the descriptive (finite model theoretic) characterization in [10]. Various characterizations of NC and related classes, based on schemas of bounded recursion on notations, are surveyed in <ref> [6] </ref>. However, these use ad hoc initial functions also, bounding of recurrence is essentially an explicit restriction of computational resources, so such characterizations do not link computational complexity to a conceptually-based machine-independent definition. In [4] Steve Bloch characterized alternating log time using a ramified variant of recurrence.
Reference: [7] <author> A. Cobham. </author> <title> The intrinsic computational difficulty of functions. </title> <editor> In Y. Bar-Hillel, editor, </editor> <booktitle> Proceedings of the International Conference on Logic, Methodology, and Philosophy of Science, </booktitle> <pages> pages 24-30. </pages> <publisher> North-Holland, </publisher> <address> Amsterdam, </address> <year> 1962. </year>
Reference-contexts: a streamlined incorporation of computational complexity into areas such as formal methods in software development, programming language theory, and database theory. 1.2 Ramified recurrence and computational complexity Several natural classes of computable numeric functions can be defined or characterized by variants of recurrence (i.e. primitive recursion). 1 Ritchie and Cobham <ref> [24, 7] </ref> gave the first characterizations by recurrence of computational complexity classes of interest in computer science. More recently it has been shown that recurrence can reflect different uses of data in computing, leading to a better understanding of the relation between applicative programs and computational complexity. <p> This was pointed out independently for recurrence [3], functional recurrence [28], lambda representability [12], and second order provability [14]. Notably, Bellantoni and Cook [3] formalized this distinction and obtained a functional characterization of poly-time that does away with the bounding condition of <ref> [7] </ref>. In [13] we outlined a predicative-finitistic critique of recurrence that leads to a generalization and streamlining of the result and proof of [3], using a general form of ramified data and ramified recurrence. <p> However, some of these references are indirect, with the underlying free algebras embedded in N : word recurrence is then conveyed as "recursion on notations" over N <ref> [7, 3] </ref>, and tree recurrence as "divide-and-conquer recursion" [10, 4].
Reference: [8] <author> E. Cohors-Fresenborg. Subrekursive Funktionen-klassen uber binaren Baumen. </author> <type> PhD thesis, </type> <institution> Uni-versitat Munster, </institution> <year> 1971. </year>
Reference-contexts: The study of computability over free algebras in general and trees in particular goes back at least to the early 1970's; in fact, recurrence over trees was considered explicitly already in 1971 (see <ref> [8, 9] </ref>). 1.3 Parallelism and recurrence The simulation of deterministic computation by recurrence goes back to [27]. It is based on iterating a transition function between machine configurations (suitably coded in the underlying data type, a slightly messy task if the latter is the natural numbers).
Reference: [9] <editor> E. Cohors-Fresenborg. Elementare und subele-mentare funktionenklassen uber binaren baumen. GI-Fachtg. Automathenth. Form Sprach, </editor> <volume> 1 </volume> <pages> 220-229, </pages> <year> 1973. </year>
Reference-contexts: The study of computability over free algebras in general and trees in particular goes back at least to the early 1970's; in fact, recurrence over trees was considered explicitly already in 1971 (see <ref> [8, 9] </ref>). 1.3 Parallelism and recurrence The simulation of deterministic computation by recurrence goes back to [27]. It is based on iterating a transition function between machine configurations (suitably coded in the underlying data type, a slightly messy task if the latter is the natural numbers).
Reference: [10] <author> K. Compton and C. Laflamme. </author> <title> An algebra and a logic for NC 1 . Information and Computation, </title> <booktitle> 87 </booktitle> <pages> 241-263, </pages> <year> 1990. </year>
Reference-contexts: However, some of these references are indirect, with the underlying free algebras embedded in N : word recurrence is then conveyed as "recursion on notations" over N [7, 3], and tree recurrence as "divide-and-conquer recursion" <ref> [10, 4] </ref>. <p> Machine independent characterizations of alternating log time have been known for some time. The earliest one seems to be the descriptive (finite model theoretic) characterization in <ref> [10] </ref>. Various characterizations of NC and related classes, based on schemas of bounded recursion on notations, are surveyed in [6]. <p> One approach has been to concentrate on computation in linear time, giving rise to various characterizations of alternating log time such as <ref> [10, 4, 18] </ref>. Another approach extends the ramification to a third tier T 2 , allowing the generation of polynomial "clocks" in tier T 1 ; such clocks can then be used to drive a single computation cycle, thereby avoiding the problem of nested recurrence.
Reference: [11] <author> W.G. Handley. </author> <title> Bellantoni and Cook's characterization of polynomial time functions. </title> <address> Typescript, </address> <month> August </month> <year> 1992. </year>
Reference-contexts: Indeed, the phrase "recursion" is used in computer science for a broader notion, whereas "recurrence" has been used precisely for this and closely related schemas. log time [18]), linear space <ref> [13, 11, 15] </ref>, NP, the poly--time hierarchy [1], poly-space [21, 22] and (Kalmar-) elementary time [17]. 2 Most of the characterizations above refer to recurrence over free algebras of words or trees, rather than over the set N of natural numbers.
Reference: [12] <author> D. Leivant. </author> <title> Subrecursion and lambda representation over free algebras. </title> <editor> In Samuel Buss and Philip Scott, editors, </editor> <booktitle> Feasible Mathematics, Perspectives in Computer Science, </booktitle> <pages> pages 281-291. </pages> <address> Birkhauser-Boston, New York, </address> <year> 1990. </year>
Reference-contexts: More recently it has been shown that recurrence can reflect different uses of data in computing, leading to a better understanding of the relation between applicative programs and computational complexity. This was pointed out independently for recurrence [3], functional recurrence [28], lambda representability <ref> [12] </ref>, and second order provability [14]. Notably, Bellantoni and Cook [3] formalized this distinction and obtained a functional characterization of poly-time that does away with the bounding condition of [7].
Reference: [13] <author> D. Leivant. </author> <title> Stratified functional programs and computational complexity. </title> <booktitle> In Conference Record of the Twentieth Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 325-333, </pages> <address> New York, 1993. </address> <publisher> ACM. </publisher>
Reference-contexts: This was pointed out independently for recurrence [3], functional recurrence [28], lambda representability [12], and second order provability [14]. Notably, Bellantoni and Cook [3] formalized this distinction and obtained a functional characterization of poly-time that does away with the bounding condition of [7]. In <ref> [13] </ref> we outlined a predicative-finitistic critique of recurrence that leads to a generalization and streamlining of the result and proof of [3], using a general form of ramified data and ramified recurrence. <p> Indeed, the phrase "recursion" is used in computer science for a broader notion, whereas "recurrence" has been used precisely for this and closely related schemas. log time [18]), linear space <ref> [13, 11, 15] </ref>, NP, the poly--time hierarchy [1], poly-space [21, 22] and (Kalmar-) elementary time [17]. 2 Most of the characterizations above refer to recurrence over free algebras of words or trees, rather than over the set N of natural numbers. <p> In [4] Steve Bloch characterized alternating log time using a ramified variant of recurrence. Improved result and proof, using tree recurrence similar to the one considered here, are in [18]. Ramified recurrence over trees was introduced in <ref> [13, 15] </ref>, as part of a generic notion of ramified recurrence over free algebras. The first characterization result that uses explicitly ramified recurrence over trees seems to be in [2], where Steve Bellantoni outlines a proof for a characterization of the alternating poly-log functions.
Reference: [14] <author> D. Leivant. </author> <note> A foundational delineation of poly-time. Information and Computation, 1994. (Special issue of selected papers from LICS'91, edited by G. Kahn). </note>
Reference-contexts: More recently it has been shown that recurrence can reflect different uses of data in computing, leading to a better understanding of the relation between applicative programs and computational complexity. This was pointed out independently for recurrence [3], functional recurrence [28], lambda representability [12], and second order provability <ref> [14] </ref>. Notably, Bellantoni and Cook [3] formalized this distinction and obtained a functional characterization of poly-time that does away with the bounding condition of [7]. <p> He also gives results for subclasses, showing, roughly, that his class 2T + k;1 contains ATimeSpace (O (log d n); 2 O (log d n) ) (Theorem 12 2 Data ramification underlies also the characterizations of poly-time by set-existence principles <ref> [14] </ref>, by typed -calculi [19], and by a proof theoretic ramification [16]. there), and is contained in uniform parallel time O (log n) (Theorem 15) (for all k 1).
Reference: [15] <author> D. Leivant. </author> <title> Ramified recurrence and computational complexity I: Word recurrence and poly-time. </title> <editor> In Peter Clote and Jeffrey Remmel, editors, </editor> <booktitle> Feasible Mathematics II, </booktitle> <pages> pages 320-343. </pages> <address> Birkhauser-Boston, New York, </address> <year> 1994. </year>
Reference-contexts: Indeed, the phrase "recursion" is used in computer science for a broader notion, whereas "recurrence" has been used precisely for this and closely related schemas. log time [18]), linear space <ref> [13, 11, 15] </ref>, NP, the poly--time hierarchy [1], poly-space [21, 22] and (Kalmar-) elementary time [17]. 2 Most of the characterizations above refer to recurrence over free algebras of words or trees, rather than over the set N of natural numbers. <p> In [4] Steve Bloch characterized alternating log time using a ramified variant of recurrence. Improved result and proof, using tree recurrence similar to the one considered here, are in [18]. Ramified recurrence over trees was introduced in <ref> [13, 15] </ref>, as part of a generic notion of ramified recurrence over free algebras. The first characterization result that uses explicitly ramified recurrence over trees seems to be in [2], where Steve Bellantoni outlines a proof for a characterization of the alternating poly-log functions. <p> In particular, for ramified schematic tree recurrence one gets alternating log time when using a linearly restricted form of 2 tier recurrence [18], and alternating poly-log time when using 3 or more tiers <ref> [15] </ref>. In this paper we identify the definitional power of ramified schematic tree recurrence with two tiers, but without the linearity condition. Indeed, this work has been driven by the wish to calibrate that definitional power, rather than finding a machine independent characterization of NC. <p> (tr ) = log jj. 3 Simulation of NC by RSR 3.1 Main issues and a new technique When dealing with deterministic computing one can simulate by recurrence a computation in time n 2 , say, by iterating n times the functions that simulates computation in time n (see e.g. <ref> [15] </ref>). This method no longer works, even with schematic recurrence, for computations that bifurcate, such as nondeterministic or alternating ones. <p> These computation snapshots are of manageable size due to the space restriction, and they can be used as parameters of the schematic recurrence. Moreover, the alternating computation of the ARM can then be captured as a deterministic process of updating TC's, enabling us to use the technique of <ref> [15] </ref> for capturing by ramified recurrence a polynomial number of deterministic computation steps. 3.2 Representing computation snapshots in T We wish to code configurations by words, so that each configuration may be represented, modulo inessential coding detail, as an address of a leaf of a TC.
Reference: [16] <author> D. Leivant. </author> <title> Intrinsic theories and computational complexity. </title> <editor> In D. Leivant, editor, </editor> <booktitle> Logic and Coputational Complexity, volume 960 of LNCS, </booktitle> <pages> pages 177-194. </pages> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1995. </year>
Reference-contexts: also gives results for subclasses, showing, roughly, that his class 2T + k;1 contains ATimeSpace (O (log d n); 2 O (log d n) ) (Theorem 12 2 Data ramification underlies also the characterizations of poly-time by set-existence principles [14], by typed -calculi [19], and by a proof theoretic ramification <ref> [16] </ref>. there), and is contained in uniform parallel time O (log n) (Theorem 15) (for all k 1).
Reference: [17] <author> D. Leivant. </author> <title> Ramified recurrence and computational complexity III: Higher type recurrence and elementary complexity. </title> <journal> Annals of Pure and Applied Logic, </journal> <note> 1998. Special issue in honor of Ro-hit Parikh's 60th Birthday; editors: </note> <author> M. Fitting, R. Ramanujam and K. </author> <month> Georgatos. </month>
Reference-contexts: Indeed, the phrase "recursion" is used in computer science for a broader notion, whereas "recurrence" has been used precisely for this and closely related schemas. log time [18]), linear space [13, 11, 15], NP, the poly--time hierarchy [1], poly-space [21, 22] and (Kalmar-) elementary time <ref> [17] </ref>. 2 Most of the characterizations above refer to recurrence over free algebras of words or trees, rather than over the set N of natural numbers.
Reference: [18] <author> D. Leivant and J.-Y. Marion. </author> <title> Ramified recurrence and computational complexity V: linear tree recurrence and alternating log-time. </title> <note> Theoretical Computer Science. Special issue for CAAP'98, </note> <editor> editor: M. </editor> <address> Duachet. </address> <note> To appear. </note>
Reference-contexts: Indeed, the phrase "recursion" is used in computer science for a broader notion, whereas "recurrence" has been used precisely for this and closely related schemas. log time <ref> [18] </ref>), linear space [13, 11, 15], NP, the poly--time hierarchy [1], poly-space [21, 22] and (Kalmar-) elementary time [17]. 2 Most of the characterizations above refer to recurrence over free algebras of words or trees, rather than over the set N of natural numbers. <p> In [4] Steve Bloch characterized alternating log time using a ramified variant of recurrence. Improved result and proof, using tree recurrence similar to the one considered here, are in <ref> [18] </ref>. Ramified recurrence over trees was introduced in [13, 15], as part of a generic notion of ramified recurrence over free algebras. <p> An alternative approach is to avoid the issue altogether by considering only a number of iterations linear in the height of the input. In particular, for ramified schematic tree recurrence one gets alternating log time when using a linearly restricted form of 2 tier recurrence <ref> [18] </ref>, and alternating poly-log time when using 3 or more tiers [15]. In this paper we identify the definitional power of ramified schematic tree recurrence with two tiers, but without the linearity condition. <p> In contrast, it is trivial to define by rsr a coercion function : T 1 ! T 0 . A useful property of skewed recurrence is given in the following lemma, proved in <ref> [18] </ref>. Lemma 2.3 (Multiplicity Lemma) Suppose that f : T 1 fi T 0 ! T 0 is defined by skewed rsr. <p> Thus, we have for boolean valued functions RSR m NC m RSR m+2 , for all m 2. This is all we know at this time, except for the following additional result at the bottom of the hierarchy: the main result of <ref> [18] </ref> implies that RSR 1 = ALogT ime for boolean functions. 2.5 Lists as addresses In addition to the coding tr of words in f0; 1; ?g fl by balanced trees, we shall use the coding ls of words by lists, i.e. skewed binary trees, determined by ls (fl) = ? <p> One approach has been to concentrate on computation in linear time, giving rise to various characterizations of alternating log time such as <ref> [10, 4, 18] </ref>. Another approach extends the ramification to a third tier T 2 , allowing the generation of polynomial "clocks" in tier T 1 ; such clocks can then be used to drive a single computation cycle, thereby avoiding the problem of nested recurrence.
Reference: [19] <author> D. Leivant and J.-Y. Marion. </author> <title> Lambda-calculus characterizations of poly-time. </title> <journal> Fundamenta In-formaticae, </journal> <volume> 19 </volume> <pages> 167-184, </pages> <year> 1993. </year> <title> Special Issue: Lambda Calculus and Type Theory (editor: </title> <journal> J. Tiuryn). </journal>
Reference-contexts: He also gives results for subclasses, showing, roughly, that his class 2T + k;1 contains ATimeSpace (O (log d n); 2 O (log d n) ) (Theorem 12 2 Data ramification underlies also the characterizations of poly-time by set-existence principles [14], by typed -calculi <ref> [19] </ref>, and by a proof theoretic ramification [16]. there), and is contained in uniform parallel time O (log n) (Theorem 15) (for all k 1).
Reference: [20] <author> D. Leivant and J.-Y. Marion. </author> <title> Application characterizations of poly-space. Extended Abstract, </title> <year> 1994. </year>
Reference-contexts: The computation's output is then obtained as U (f (t; c 0 )), where c 0 is the initial configuration, t the computation time, and U a function that extracts the output from the final configuration. In <ref> [20, 21] </ref> we observed that schematic recurrence (also known as "recursion with parameter substitutions") yields a backward simulation of transitions. <p> Bellan-toni refers to the schema of ramified recurrence over functionals of predicative ramified type, introduced in <ref> [20] </ref>; that schema is more liberal than (first order) ramified schematic recurrence, introduced in [21] (over words rather than trees) to characterize alter nating poly-time, i.e. poly-space. 3 All attempts to capture alternating computing by variants of schematic recurrence face a difficulty with polynomial iterations: n computation steps of an alternating <p> In the context of sub-elementary complexity classes it is appropriate and fruitful to consider this schema in its own right. 2.2 Ramified tree recurrence Feasible variants of recurrence are obtained by ramifying the underlying data algebra, as mentioned 3 The characterization by ramified recurrence for predicative functionals outlined in <ref> [20] </ref> is spelled out in [22]. 4 We use sans serif for fixed formal object and function identifiers, underlined roman for metamathematical functions, and the usual italics for variables and parameters. 5 Note that we do not allow here t and t 0 as arguments of the recurrence functions g i
Reference: [21] <author> D. Leivant and J.-Y. Marion. </author> <title> Ramified recurrence and computational complexity II: </title> <editor> substitution and poly-space. In L. Pacholski and J. Tiuryn, editors, </editor> <booktitle> Proceedings of CSL 94, </booktitle> <pages> pages 486-500. </pages> <publisher> LNCS 933, Springer Verlag, </publisher> <year> 1995. </year>
Reference-contexts: Indeed, the phrase "recursion" is used in computer science for a broader notion, whereas "recurrence" has been used precisely for this and closely related schemas. log time [18]), linear space [13, 11, 15], NP, the poly--time hierarchy [1], poly-space <ref> [21, 22] </ref> and (Kalmar-) elementary time [17]. 2 Most of the characterizations above refer to recurrence over free algebras of words or trees, rather than over the set N of natural numbers. <p> The computation's output is then obtained as U (f (t; c 0 )), where c 0 is the initial configuration, t the computation time, and U a function that extracts the output from the final configuration. In <ref> [20, 21] </ref> we observed that schematic recurrence (also known as "recursion with parameter substitutions") yields a backward simulation of transitions. <p> The observation above was used in <ref> [21, 2, 23, 22] </ref> to obtain characterizations of PSpace, alternating log time, and alternating poly-log time. 1.4 Main result and comparison with previous works In this paper we establish a characterization by ramified recurrence of computation in NC. <p> At first blush one might expect that the use of trees to represent data also matches the tree-like nature of alternating computing; however, we see no such correspondence at work, and branching control is captured by parameter substitution, as we showed in <ref> [21] </ref> (where data is represented by words, not trees). Machine independent characterizations of alternating log time have been known for some time. The earliest one seems to be the descriptive (finite model theoretic) characterization in [10]. <p> Bellan-toni refers to the schema of ramified recurrence over functionals of predicative ramified type, introduced in [20]; that schema is more liberal than (first order) ramified schematic recurrence, introduced in <ref> [21] </ref> (over words rather than trees) to characterize alter nating poly-time, i.e. poly-space. 3 All attempts to capture alternating computing by variants of schematic recurrence face a difficulty with polynomial iterations: n computation steps of an alternating machine spawn O (2 n ) configurations.
Reference: [22] <author> D. Leivant and J.-Y. Marion. </author> <title> Predicative functional recurrence and poly-space. </title> <editor> In M. Bidoit and M. Dauchet, editors, </editor> <booktitle> TAPSOFT'97 CAAP, </booktitle> <pages> pages 369-380. </pages> <publisher> LNCS 1214, Springer-Verlag, </publisher> <month> April </month> <year> 1997. </year>
Reference-contexts: Indeed, the phrase "recursion" is used in computer science for a broader notion, whereas "recurrence" has been used precisely for this and closely related schemas. log time [18]), linear space [13, 11, 15], NP, the poly--time hierarchy [1], poly-space <ref> [21, 22] </ref> and (Kalmar-) elementary time [17]. 2 Most of the characterizations above refer to recurrence over free algebras of words or trees, rather than over the set N of natural numbers. <p> The observation above was used in <ref> [21, 2, 23, 22] </ref> to obtain characterizations of PSpace, alternating log time, and alternating poly-log time. 1.4 Main result and comparison with previous works In this paper we establish a characterization by ramified recurrence of computation in NC. <p> sub-elementary complexity classes it is appropriate and fruitful to consider this schema in its own right. 2.2 Ramified tree recurrence Feasible variants of recurrence are obtained by ramifying the underlying data algebra, as mentioned 3 The characterization by ramified recurrence for predicative functionals outlined in [20] is spelled out in <ref> [22] </ref>. 4 We use sans serif for fixed formal object and function identifiers, underlined roman for metamathematical functions, and the usual italics for variables and parameters. 5 Note that we do not allow here t and t 0 as arguments of the recurrence functions g i .
Reference: [23] <author> D. Leivant and J.-Y. Marion. </author> <title> Ramified recurrence and computational complexity IV: Pred-icative functionals and poly-space. </title> <booktitle> Information and Computation, </booktitle> <year> 1999. </year>
Reference-contexts: The observation above was used in <ref> [21, 2, 23, 22] </ref> to obtain characterizations of PSpace, alternating log time, and alternating poly-log time. 1.4 Main result and comparison with previous works In this paper we establish a characterization by ramified recurrence of computation in NC.
Reference: [24] <author> R.W. Ritchie. </author> <title> Classes of predictably computable functions. </title> <journal> Trans. A.M.S., </journal> <volume> 106 </volume> <pages> 139-173, </pages> <year> 1963. </year>
Reference-contexts: a streamlined incorporation of computational complexity into areas such as formal methods in software development, programming language theory, and database theory. 1.2 Ramified recurrence and computational complexity Several natural classes of computable numeric functions can be defined or characterized by variants of recurrence (i.e. primitive recursion). 1 Ritchie and Cobham <ref> [24, 7] </ref> gave the first characterizations by recurrence of computational complexity classes of interest in computer science. More recently it has been shown that recurrence can reflect different uses of data in computing, leading to a better understanding of the relation between applicative programs and computational complexity.
Reference: [25] <author> H.E. Rose. </author> <title> Subrecursion. </title> <publisher> Clarendon Press (Oxford University Press), Oxford, </publisher> <year> 1984. </year>
Reference-contexts: It is well known that schematic recurrence is reducible to recurrence, but the standard reduction uses sequence-coding by Kalmar-elementary func tions <ref> [25] </ref>. <p> Thus, we focus on the form of recursion knows as iteration with parameters or monotonic recurrence. 6 Schematic recurrence is known for numeric functions as "recursion with parameter substitution", see e.g. <ref> [25] </ref>. in the introduction. We refer to a two sorted algebra, with the sorts interpreted as two copies T 0 ; T 1 of the algebra T, each with its own constructors. Functions with all inputs and output in T 0 will be called flat.
Reference: [26] <author> W. Ruzzo. </author> <title> On uniform circuit complexity. </title> <journal> Journal of Computer System Sciences, </journal> <volume> 22 </volume> <pages> 365-383, </pages> <year> 1981. </year>
Reference-contexts: nest recurrences an arbitrary number of times, resulting in functions essentially as fast growing as with no restriction at all. 8 Here log is the base-2 logarithm rounded to the next larger integer. 2.4 Precise statement of the main result We refer to the alternating random access Turing machines of <ref> [5, 26] </ref>, ARM for short. Let us recap the essentials of the definition. An ARM M has read-only input tapes as well as work-stacks. 9 No output device is provided, since the output is a single bit, determined by the machine's control. <p> Every boolean valued function in NC m is representable in RSR m . Proof. Suppose that a function f : W ! f0; 1g is in NC. By <ref> [26] </ref> f is computable by some ARM M that operates in time A log m (n) + A and space A log n, for some A, where n is the length of the input.
Reference: [27] <author> S.C.Kleene. </author> <title> Introduction to Metamathematics. </title> <address> Wolters-Noordhof, Groningen, </address> <year> 1952. </year>
Reference-contexts: The study of computability over free algebras in general and trees in particular goes back at least to the early 1970's; in fact, recurrence over trees was considered explicitly already in 1971 (see [8, 9]). 1.3 Parallelism and recurrence The simulation of deterministic computation by recurrence goes back to <ref> [27] </ref>. It is based on iterating a transition function between machine configurations (suitably coded in the underlying data type, a slightly messy task if the latter is the natural numbers).
Reference: [28] <author> H. Simmons. </author> <title> The realm of primitive recursion. </title> <journal> Archive for Mathematical Logic, </journal> <volume> 27 </volume> <pages> 177-188, </pages> <year> 1988. </year>
Reference-contexts: More recently it has been shown that recurrence can reflect different uses of data in computing, leading to a better understanding of the relation between applicative programs and computational complexity. This was pointed out independently for recurrence [3], functional recurrence <ref> [28] </ref>, lambda representability [12], and second order provability [14]. Notably, Bellantoni and Cook [3] formalized this distinction and obtained a functional characterization of poly-time that does away with the bounding condition of [7].
References-found: 28

