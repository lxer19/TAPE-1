URL: http://www.cs.iastate.edu/tech-reports/TR91-20.ps
Refering-URL: http://www.cs.iastate.edu/tech-reports/catalog.html
Root-URL: 
Title: A Taxonomy of Automatic Differentiation Tools  
Author: by David W. Juedes 
Date: January 31, 1992  
Pubnum: TR91-20  
Abstract-found: 0
Intro-found: 1
Reference: [Adam69] <author> D. S. Adamsom and C. W. Winant, </author> <title> A SLANG Simulation of an Initially Strong Shock Wave Downstream of an Infinite Area Change, </title> <booktitle> Proceedings to the Confernce on Applications of Continuous-System Simulation Languages, </booktitle> <month> June </month> <year> 1969, </year> <pages> pp. 231-240. </pages>
Reference-contexts: They are characterized by source languages that directly provide automatic differentiation. Several of the earliest AD tools belong to the integral class. The best examples of these are SLANG <ref> [Adam69, McCu69, Tham69] </ref> and PROSE [Tham75, PROS77, Tham82, Krin84, Pfei87]. More recent examples of integral AD tools are the modeling language AMPL [Four90], and the FM/FAD [Mazo91] package. J J b b b Computer Algebra SystemsElemental Extensional Integral Operational Symbolic Fig. 1.
Reference: [Berz87] <author> M. Berz, </author> <title> The Differential Algebra FORTRAN precompiler DAFOR, </title> <institution> Los Alamos National Laboratory Technical Report AT-3: </institution> <month> TN-87-32 </month> <year> (1987). </year>
Reference-contexts: Extensional tools subdivided by differentiation approach ATOMFT propagates the Taylor series values strictly in the forward mode. The length of the generated Taylor series is arbitrary and is controlled by user-specified parameters. (5) The FORTRAN precompiler DAFOR <ref> [Berz87, Berz89, Berz90a] </ref> transforms existing FORTRAN code into FORTRAN code that also evaluates derivatives. Partial derivatives can be calculated to an arbitrary-order and with respect to an arbitrary number of independent variables. The transformation creates calls to a library of subroutines for the elementary operations.
Reference: [Berz89] <author> M. Berz, </author> <title> Differential Algebraic Description of Beam Dynamics to Very High Order, </title> <booktitle> Particle Accelerators 24 (1989), </booktitle> <pages> pp. 109 </pages>
Reference-contexts: Extensional tools subdivided by differentiation approach ATOMFT propagates the Taylor series values strictly in the forward mode. The length of the generated Taylor series is arbitrary and is controlled by user-specified parameters. (5) The FORTRAN precompiler DAFOR <ref> [Berz87, Berz89, Berz90a] </ref> transforms existing FORTRAN code into FORTRAN code that also evaluates derivatives. Partial derivatives can be calculated to an arbitrary-order and with respect to an arbitrary number of independent variables. The transformation creates calls to a library of subroutines for the elementary operations.
Reference: [Berz90a] <author> M. Berz, </author> <title> Differential Algebra Precompiler Version 3 Reference Manual, </title> <institution> Michigan State University Technical Report MSUCL-755 (1990). </institution>
Reference-contexts: Extensional tools subdivided by differentiation approach ATOMFT propagates the Taylor series values strictly in the forward mode. The length of the generated Taylor series is arbitrary and is controlled by user-specified parameters. (5) The FORTRAN precompiler DAFOR <ref> [Berz87, Berz89, Berz90a] </ref> transforms existing FORTRAN code into FORTRAN code that also evaluates derivatives. Partial derivatives can be calculated to an arbitrary-order and with respect to an arbitrary number of independent variables. The transformation creates calls to a library of subroutines for the elementary operations.
Reference: [Berz90b] <author> M. Berz, </author> <title> COSY INFINITY Version 3 Reference Manual, </title> <institution> Michigan State University Technical Report MSUCL-751 (1990). </institution>
Reference-contexts: The problem solving aspect of the FM/FAD package uses the DIFALG interpreter directly to calculate function values and their gradients evaluated at a point. The DIFALG interpreter calculates the gradient of the function via the reverse mode. The FM/FAD package only generates first order partial derivatives. (24) FOXY <ref> [Berz90b, Berz90c, Berz90d] </ref> is an object-oriented programming language that is similar to PASCAL. FOXY has built in facilities for automatically differentiating functions written in that language. Arbitrary-order partial derivatives with respect to arbitrarily many variables can be calculated. These derivatives are calculated in the forward mode. 4.5. The Symbolic Tools.
Reference: [Berz90c] <author> M. Berz, </author> <title> Computational Aspects of Design and Simulation: COSY INFINITY, Nuclear Instruments and Methods A298, </title> <month> 473 </month> <year> (1990). </year>
Reference-contexts: The problem solving aspect of the FM/FAD package uses the DIFALG interpreter directly to calculate function values and their gradients evaluated at a point. The DIFALG interpreter calculates the gradient of the function via the reverse mode. The FM/FAD package only generates first order partial derivatives. (24) FOXY <ref> [Berz90b, Berz90c, Berz90d] </ref> is an object-oriented programming language that is similar to PASCAL. FOXY has built in facilities for automatically differentiating functions written in that language. Arbitrary-order partial derivatives with respect to arbitrarily many variables can be calculated. These derivatives are calculated in the forward mode. 4.5. The Symbolic Tools.
Reference: [Berz90d] <author> M. Berz, </author> <title> COSY INFINITY, an arbitrary order general purpose optics code, Computer Codes and the Linear Accelerator Community Los Alamos LA-11857-C, </title> <month> 137 </month> <year> (1990). </year>
Reference-contexts: The problem solving aspect of the FM/FAD package uses the DIFALG interpreter directly to calculate function values and their gradients evaluated at a point. The DIFALG interpreter calculates the gradient of the function via the reverse mode. The FM/FAD package only generates first order partial derivatives. (24) FOXY <ref> [Berz90b, Berz90c, Berz90d] </ref> is an object-oriented programming language that is similar to PASCAL. FOXY has built in facilities for automatically differentiating functions written in that language. Arbitrary-order partial derivatives with respect to arbitrarily many variables can be calculated. These derivatives are calculated in the forward mode. 4.5. The Symbolic Tools.
Reference: [Chan82] <author> Y. F. Chang and G. F. Corliss, </author> <title> Solving ordinary differential equations using Taylor series, </title> <journal> ACM Trans. Math. Softw., </journal> <volume> 8/2 (1982), </volume> <pages> pp. 114 - 144. </pages>
Reference-contexts: This class consists primarily of precompilers. Of the tools in this class, four produce derivatives strictly in the forward mode, one produces derivatives only in the reverse mode, and four use both modes. Figure 2 illustrates this fact. (4) The general purpose ordinary differential equation (ODE) solver ATOMFT <ref> [Chan82] </ref> is an AD tool in the sense that it provides the automatic generation of code to evaluate Taylor series; however, automatic differentiation is not its primary focus. ATOMFT is a FORTRAN preprocessor that generates FORTRAN source code to solve systems of ODEs.
Reference: [Chri90] <author> B. Christianson, </author> <title> Automatic Hessians by reverse accumulation, </title> <institution> TR228, Numerical Opti-misation Centre, Hatfield Polytechnic, </institution> <address> Herts England Europe (1990). </address>
Reference-contexts: In ADOL-C, arbitrarily nested or recursive functions can be differentiated. Also, the trace of a function is stored sequentially in main memory and is automatically paged to disk when necessary. (14) The BC1 <ref> [Chri90] </ref> package uses operator overloading in ADA to provide a new data type that aids in the calculation of derivatives. When functions using this new type are executed, the computational graph of that execution is created.
Reference: [Corl83] <author> G. F. Corliss and L. B. Rall, </author> <title> Automatic generation of Taylor series in PASCAL-SC: Basic operations and applications to ordinary differential equations, </title> <institution> Univ. of Wisc. </institution> <note> Mathematics Research Center Technical Report #2497, 1983. Modified version appeared in Transactions of the First Army Conference on Applied Mathematics and Computing, </note> <year> 1984. </year>
Reference-contexts: GC1 was designed to be used in an interval ODE solver. It takes special care of applications (like ODEs) in which the Taylor series terms must be completed one term at a time. User-defined functions and procedures involving variables of Taylor type are supported. (16) The GC2 <ref> [Corl83] </ref> package is written in PASCAL-SC and is used to compute point and interval valued Taylor series operators. GC2 declares the Taylor series data types Real Taylor Type and Interval Taylor Type, and overloads all of the PASCAL-SC elementary functions for them.
Reference: [Corl87] <author> G. F. Corliss and L. B. Rall, </author> <title> Adaptive, self-validating quadrature, </title> <journal> SIAM J. Sci. Stat. Comput., </journal> <volume> 8/5 (1987), </volume> <pages> pp. 831-847. </pages>
Reference-contexts: These Reduce expressions calculate the gradient of the function in the reverse mode. This array of Reduce expressions can be converted to FORTRAN by the Reduce system. Currently the NR1 package is purely a research AD tool. (29) The suite of FORTRAN programs SVALAQ (Self-Validating Adaptive Quadrature) <ref> [Corl87] </ref> contain elements that allow it to be classified as a symbolic AD tool. This suite of programs produces guaranteed bounds on the values of certain definite integrals by using automatic differentiation. SVALAQ takes as input a single FORTRAN expression (no longer than 80 characters) for the integrand.
Reference: [Corl91a] <author> G. F. Corliss and L. B. Rall, </author> <title> Computing the Range of Derivatives, </title> <note> to appear in IMACS Annals on Computing and Applied Mathematics. </note>
Reference-contexts: This computational graph, which is stored in a linearized form, is used by other routines to propagate derivatives in the reverse mode. The BC1 package can be used to generate first- and second-order partial derivatives (i.e., gradients and Hessians). (15) GC1 <ref> [Corl91a, Corl91b] </ref> is an ADA package for operations on interval valued Taylor series. To generate Taylor series, a user of GC1 writes a program that declares the appropriate variables to be of the Taylor type and uses the overloaded operations provided by GC1.
Reference: [Corl91b] <author> G. F. Corliss, </author> <title> Overloading Point and Interval Taylor Operators, submitted to Proceedings of SIAM Workshop on Automatic Differentiation, </title> <publisher> (Breckenridge, CO, </publisher> <year> 1991). </year>
Reference-contexts: This computational graph, which is stored in a linearized form, is used by other routines to propagate derivatives in the reverse mode. The BC1 package can be used to generate first- and second-order partial derivatives (i.e., gradients and Hessians). (15) GC1 <ref> [Corl91a, Corl91b] </ref> is an ADA package for operations on interval valued Taylor series. To generate Taylor series, a user of GC1 writes a program that declares the appropriate variables to be of the Taylor type and uses the overloaded operations provided by GC1.
Reference: [Flan91] <author> H. Flanders, </author> <title> Response to electronic mail survey (1991). </title>
Reference-contexts: These derivatives are calculated in the forward mode. 4.5. The Symbolic Tools. The class of symbolic AD tools contains five members. Of the members of this class, four use the forward mode of automatic differen tiation, while only one uses the reverse mode. (25) The AD <ref> [Flan91] </ref> program is a PC-based menu driven program for producing numeric function and derivative values. The AD program allows a function to be entered symbolically. Once entered, the symbolic representation of the function is parsed and a tree representing the function is built internally.
Reference: [Four90] <author> R. Fourer, D .M. Gay, and B. W. Kernighan, </author> <title> A Modeling Language for Mathematical Programming, </title> <booktitle> Management Science Vol. </booktitle> <volume> 36 no. 5 (1990), </volume> <pages> pp. 519-554. </pages>
Reference-contexts: Several AD tools have been created with the help of language development tools like Lex and Yacc. The most notable of these AD tools are the FORTRAN precompilers JAKE [Spee80] and PADRE2 [Kubo90], and the modeling language AMPL <ref> [Four90] </ref>. During the SIAM Workshop on Automatic Differentiation, it became clear that the forces driving AD technology had caused a variety of different tools to be created. Of these various tools, many of them had similar characteristics. <p> Several of the earliest AD tools belong to the integral class. The best examples of these are SLANG [Adam69, McCu69, Tham69] and PROSE [Tham75, PROS77, Tham82, Krin84, Pfei87]. More recent examples of integral AD tools are the modeling language AMPL <ref> [Four90] </ref>, and the FM/FAD [Mazo91] package. J J b b b Computer Algebra SystemsElemental Extensional Integral Operational Symbolic Fig. 1. The relationship among the various classes of AD tools The operational tools have their origins in the ideas embodied by both the elemental and extensional tools. <p> The translation process can produce code that calculates partial derivatives in either the forward or reverse mode. The partial derivatives can be calculated to aribritary order and with respect to arbritrarily many independent variables. ADDS also provides facilities for estimating rounding errors. (22) The modeling language AMPL <ref> [Four90, Gay91] </ref> is a declarative language that was designed for expressing mathematical programming problems. Mathematical programming problems are described in AMPL by a sequence of nonlinear expressions. The AMPL translator emits a representation of the DAG for each nonlinear expression given.
Reference: [Gay91] <author> D. M. Gay, </author> <title> Response to electronic mail survey (1991). </title>
Reference-contexts: The translation process can produce code that calculates partial derivatives in either the forward or reverse mode. The partial derivatives can be calculated to aribritary order and with respect to arbritrarily many independent variables. ADDS also provides facilities for estimating rounding errors. (22) The modeling language AMPL <ref> [Four90, Gay91] </ref> is a declarative language that was designed for expressing mathematical programming problems. Mathematical programming problems are described in AMPL by a sequence of nonlinear expressions. The AMPL translator emits a representation of the DAG for each nonlinear expression given.
Reference: [Garc91] <author> O. Garcia, </author> <title> A System for the Automatic Differentiation of FORTRAN programs, presented at the SIAM Workshop on Automatic Differentiation, </title> <publisher> (Breckenridge, CO, </publisher> <year> 1991). </year>
Reference-contexts: The preprocessor puts some restrictions on the subset of FORTRAN used to define the subroutine (see [Step91]). For example, EQUIVALENCE statements are not allowed. This package was designed to interface smoothly with the NAG library of mathematical software, but it is not NAG specific. (7) GRAD <ref> [Garc91] </ref> is a FORTRAN preprocessor. GRAD takes as input a FORTRAN subroutine that computes a function and produces a FORTRAN subroutine that computes the function and its first-order partial derivatives with respect to specified independent variables.
Reference: [Grie89] <author> A. Griewank, </author> <title> On automatic differentiation, in Mathematical Programming: Recent Developments and Applications, </title> <editor> ed. M. Iri and K. Tanabe, </editor> <publisher> KTK Scientific/Kluwer Academic Publishers, </publisher> <year> 1989. </year>
Reference-contexts: In the forward mode, derivative values propagate from the independent variables to the dependent variables. For more in-depth descriptions of these automatic differentiation techniques, see <ref> [Rall81, Iri87, Grie89, etc.] </ref>. As noted by Griewank [Grie89], neither the forward mode nor the reverse mode is optimal in all cases. <p> In the forward mode, derivative values propagate from the independent variables to the dependent variables. For more in-depth descriptions of these automatic differentiation techniques, see [Rall81, Iri87, Grie89, etc.]. As noted by Griewank <ref> [Grie89] </ref>, neither the forward mode nor the reverse mode is optimal in all cases. The forward mode can be used to produce the partial derivatives of all dependent variables with respect to a single independent variable in time pro 2 portional to the evaluation of F .
Reference: [Grie90] <author> A. Griewank, D. Juedes, and J. Srinivasan, ADOL-C: </author> <title> A package for the automatic differentiation of algorithms written in C/C++, </title> <type> Preprint (1990), </type> <institution> Mathematics and Computer Science Division, Argonne National Laboratory, </institution> <address> Argonne,IL 60439. </address>
Reference-contexts: Some languages, such as C++, also provide constructors and destructors for variables as they enter and leave their scope of existence. These facilities allow AD tools to transparently allocate and deallocate memory when necessary, as well as perform other maintenance procedures. The operational tools ADOL-C <ref> [Grie90] </ref> and MXYZPTLK [Mich90] make use of these facilities in C++. The final class of AD tools is the class of symbolic tools. <p> The languages ADA, C++, and PASCAL-SC were used to implement these packages. Two of the packages were implemented using ADA, four using C++, and two using PASCAL-SC. This fact is illustrated in Figure 3. (13) The ADOL-C <ref> [Grie90, Jued90] </ref> package consists of a definition of a class of active variables called adouble, and a library of supporting routines. ADOL-C was written using C++, and can be used to differentiate algorithms written in C or C++.
Reference: [Hill85] <author> K. E. Hillstrom, </author> <note> Users Guide for JAKEF, Technical Memorandum ANL/MCS-TM-16 (1985), </note> <institution> Mathematics and Computer Science Division, Argonne National Laboratory, </institution> <address> Argonne,IL 60439. </address>
Reference-contexts: They usually automate the process of decomposing complicated right-hand-sides of equations into sequences of elementary operations. Typically, automatic differentia-tors in this class use precompilers to perform the transformation from the extensions to the original language. For example, the FORTRAN precompilers JAKEF <ref> [Hill85] </ref>, GRESS [Horw88] and PADRE2 [Kubo90] transform their variants of FORTRAN into standard FORTRAN 77. For this reason, we classify them as extensional AD tools. The integral tools push the ideas embodied by the extensional tools one step further. <p> The subroutines propagate the values of variables and their partial derivatives using the forward mode. These subroutines can calculate first- and second-order partial derivatives with respect to an arbitrary number of independent variables. (10) JAKEF <ref> [Hill85] </ref> is another FORTRAN precompiler. JAKEF is a version of JAKE [Spee80] that was developed at Argonne National Laboratory and written using FORTRAN 77.
Reference: [Horw88] <author> J. E. Horwedel, B. A. Worley, E. M. Oblow, and F. G. Pin, </author> <note> GRESS Version 0.0 Users Manual, ORNL/TM 10835 (1988), </note> <institution> Oak Ridge National Laboratory, Oak Ridge Tennessee, </institution> <address> 37830, U.S.A. </address>
Reference-contexts: AD tools aid in the transformation from the source language to a form which may easily be used to generate derivative values. This transformation may be either explicit or implicit. For example, the FORTRAN precompiler in the GRESS <ref> [Horw88] </ref> package does an explicit transformation from its source language (a minor extension of FORTRAN) to standard FORTRAN. The taxonomy presented in this paper classifies automatic differentiators based on how, where, and when this transformation is performed. The most basic class is composed of the elemental AD tools. <p> They usually automate the process of decomposing complicated right-hand-sides of equations into sequences of elementary operations. Typically, automatic differentia-tors in this class use precompilers to perform the transformation from the extensions to the original language. For example, the FORTRAN precompilers JAKEF [Hill85], GRESS <ref> [Horw88] </ref> and PADRE2 [Kubo90] transform their variants of FORTRAN into standard FORTRAN 77. For this reason, we classify them as extensional AD tools. The integral tools push the ideas embodied by the extensional tools one step further. <p> The partial derivatives are calculated directly and are placed in specially named variables. The code generated by GRAD propagates derivatives in the forward mode. (8) The GRESS (GRadient Enhanced Software System) <ref> [Horw88] </ref> package is a system for adding the ability to calculate normalized sensitivities and first-order partial derivatives to existing FORTRAN programs. The GRESS package consists of a FORTRAN precompiler and a library of supporting routines. The GRESS precompiler produces code that propagates derivatives using either the forward or reverse mode.
Reference: [Horw89] <author> J. E. Horwedel, R. J. Raridon, and R. Q. Wright, </author> <title> Sensitivity Analysis of AIRDOS-EPA Using ADGEN with Matrix Reduction Algorithms, </title> <booktitle> ORNL/TM 11373 (1989), </booktitle> <institution> Oak Ridge National Laboratory, Oak Ridge Tennessee, </institution> <address> 37830, U.S.A. </address>
Reference-contexts: The GRESS "Adgen" option produces code that propagates derivatives using the reverse mode. GRESS has been used successfully on a variety of problems. Examples of the application of GRESS can be found in <ref> [Horw89, Horw90, etc.] </ref>. (9) FORTRAN CALCULUS [Tham89, Tham91] (denoted here by FC) is a commercially available package for mathematical modeling. FC is an extension of FORTRAN 77 that provides macro statements for differentiation, optimization and integration, dynamic arrays, and vector and matrix operations.
Reference: [Horw90] <author> J. E. Horwedel, R. Q. Wright, and R. E. Maerker, </author> <title> Sensitivity Analysis of EQ3, </title> <booktitle> ORNL/TM 11407 (1990), </booktitle> <institution> Oak Ridge National Laboratory, Oak Ridge Tennessee, </institution> <address> 37830, U.S.A. </address>
Reference-contexts: The GRESS "Adgen" option produces code that propagates derivatives using the reverse mode. GRESS has been used successfully on a variety of problems. Examples of the application of GRESS can be found in <ref> [Horw89, Horw90, etc.] </ref>. (9) FORTRAN CALCULUS [Tham89, Tham91] (denoted here by FC) is a commercially available package for mathematical modeling. FC is an extension of FORTRAN 77 that provides macro statements for differentiation, optimization and integration, dynamic arrays, and vector and matrix operations.
Reference: [Iri87] <author> M. Iri, and K. Kubota, </author> <title> Methods of Fast Automatic Differentiation and Applications, </title> <note> Research memorandum RMI 87-0 (1987), </note> <institution> Department of Mathematical Engineering and Instrumentation Physics, Faculty of Engineering, University of Tokyo. </institution> <month> 17 </month>
Reference-contexts: In the forward mode, derivative values propagate from the independent variables to the dependent variables. For more in-depth descriptions of these automatic differentiation techniques, see <ref> [Rall81, Iri87, Grie89, etc.] </ref>. As noted by Griewank [Grie89], neither the forward mode nor the reverse mode is optimal in all cases. <p> The trace is stored in a linearized form in auxiliary integer and real arrays. There is no facility in JAKEF for using auxiliary storage on large traces, although Speelpenning mentions in his unpublished thesis [Spee80] how such a technique could be implemented. (11) PADRE2 <ref> [Iri87, Kubo90] </ref> is also a FORTRAN precompiler. PADRE2 is an extended version of PADRE, which was developed by N. Iwata [Iwat84]. PADRE2 processes a FORTRAN function or subroutine that evaluates a scalar or vector function and then produces a modified subroutine.
Reference: [Iwat84] <author> N. Iwata, </author> <title> Automatization of the Computation of Partial Derivatives, </title> <type> Master's Thesis (1984), </type> <institution> Information Engineering, Graduate School, University of Tokyo. </institution>
Reference-contexts: PADRE2 is an extended version of PADRE, which was developed by N. Iwata <ref> [Iwat84] </ref>. PADRE2 processes a FORTRAN function or subroutine that evaluates a scalar or vector function and then produces a modified subroutine. This subroutine calculates the original function, its partial derivatives, and an estimate of the rounding error generated.
Reference: [Jerr89a] <author> M. Jerrell, </author> <title> Automatic Differentiation Using Almost Any Language, </title> <journal> ACM SIGNUM Newsletter, </journal> <month> Jan., </month> <year> 1989. </year> <pages> pp. 2-9. </pages>
Reference-contexts: For example, the statement a = x + y + z is written as follows using the WCOMP package. call SWSUM (N,Y,Z,Q) // Q=Y+Z call SWSUM (N,Q,X,A) // A=X+Q Both packages support single and double precision arithmetic. (2) The MJ1 <ref> [Jerr89a] </ref> package contains the definition of an object for automatic differentiation and its associated operations. The MJ1 package uses Turbo Pascal v5.5 to define an Ad object. Each Ad object contains a scalar value, gradient vector, and Hessian matrix.
Reference: [Jerr89b] <author> M. Jerrell, </author> <title> Function Minimization and Automatic Differentiation in C++, </title> <booktitle> ACM OOP-SLA'89 Conference Proceedings, </booktitle> <address> Oct 1989, New Orleans. </address> <pages> pp. 169-173. </pages>
Reference-contexts: The user of GC2 writes a program using either Real Taylor Type or Interval Taylor Type variables. During the execution of the program, the Taylor series of the desired lengths 10 are calculated in the forward mode. User-defined functions and procedures are supported. (17) The MJ2 <ref> [Jerr89b, Jerr90] </ref> package is very similar to the MJ1 package described in x4.1. MJ2 is written using Turbo C++ v1.0.
Reference: [Jerr90] <author> M. Jerrell, </author> <title> Automatic Differentiation Using C++, Journal of Object Oriented Programming, </title> <booktitle> May/Jun, (1990) pp. </booktitle> <pages> 17-24. </pages>
Reference-contexts: The user of GC2 writes a program using either Real Taylor Type or Interval Taylor Type variables. During the execution of the program, the Taylor series of the desired lengths 10 are calculated in the forward mode. User-defined functions and procedures are supported. (17) The MJ2 <ref> [Jerr89b, Jerr90] </ref> package is very similar to the MJ1 package described in x4.1. MJ2 is written using Turbo C++ v1.0.
Reference: [Jued90] <author> D. Juedes and A. Griewank, </author> <title> Implementing Automatic Differentiation Efficiently, </title> <note> Technical Memorandum ANL/MCS-TM-140 (1990), </note> <institution> Mathematics and Computer Science Division, Argonne National Laboratory, </institution> <address> Argonne,IL 60439. </address>
Reference-contexts: The languages ADA, C++, and PASCAL-SC were used to implement these packages. Two of the packages were implemented using ADA, four using C++, and two using PASCAL-SC. This fact is illustrated in Figure 3. (13) The ADOL-C <ref> [Grie90, Jued90] </ref> package consists of a definition of a class of active variables called adouble, and a library of supporting routines. ADOL-C was written using C++, and can be used to differentiate algorithms written in C or C++.
Reference: [Krin84] <author> B. Krinsky and J. M. Thames, </author> <title> The Structure of Synthetic Calculus, </title> <booktitle> Proceedings of the International Workshop on High Level Computer Architecture, </booktitle> <address> Los Angeles, </address> <year> 1984. </year>
Reference-contexts: They are characterized by source languages that directly provide automatic differentiation. Several of the earliest AD tools belong to the integral class. The best examples of these are SLANG [Adam69, McCu69, Tham69] and PROSE <ref> [Tham75, PROS77, Tham82, Krin84, Pfei87] </ref>. More recent examples of integral AD tools are the modeling language AMPL [Four90], and the FM/FAD [Mazo91] package. J J b b b Computer Algebra SystemsElemental Extensional Integral Operational Symbolic Fig. 1. <p> The FC package consists of a FORTRAN precompiler and a run-time library of supporting routines. FC's extension to FORTRAN is based on a paradigm referred to as synthetic calculus in <ref> [Tham82, Krin84, Tham89, Tham91] </ref>. The basic unit within this paradigm is a model. Models are subprograms that contain sets of formulas. Differentiation, optimization and integration are performed on specified models. Models may include macro statements for optimization and integration. This allows for the nesting of models.
Reference: [Kubo90] <author> K. Kubota, and M. Iri, PADRE2, </author> <note> version 1 - User's Manual, Research memorandum RMI 90-01 (1990), </note> <institution> Department of Mathematical Engineering and Instrumentation Physics, Faculty of Engineering, University of Tokyo. </institution>
Reference-contexts: Several AD tools have been created with the help of language development tools like Lex and Yacc. The most notable of these AD tools are the FORTRAN precompilers JAKE [Spee80] and PADRE2 <ref> [Kubo90] </ref>, and the modeling language AMPL [Four90]. During the SIAM Workshop on Automatic Differentiation, it became clear that the forces driving AD technology had caused a variety of different tools to be created. Of these various tools, many of them had similar characteristics. <p> They usually automate the process of decomposing complicated right-hand-sides of equations into sequences of elementary operations. Typically, automatic differentia-tors in this class use precompilers to perform the transformation from the extensions to the original language. For example, the FORTRAN precompilers JAKEF [Hill85], GRESS [Horw88] and PADRE2 <ref> [Kubo90] </ref> transform their variants of FORTRAN into standard FORTRAN 77. For this reason, we classify them as extensional AD tools. The integral tools push the ideas embodied by the extensional tools one step further. Integral tools have the ability to automatically differentiate functions integrated within their environment or language. <p> The trace is stored in a linearized form in auxiliary integer and real arrays. There is no facility in JAKEF for using auxiliary storage on large traces, although Speelpenning mentions in his unpublished thesis [Spee80] how such a technique could be implemented. (11) PADRE2 <ref> [Iri87, Kubo90] </ref> is also a FORTRAN precompiler. PADRE2 is an extended version of PADRE, which was developed by N. Iwata [Iwat84]. PADRE2 processes a FORTRAN function or subroutine that evaluates a scalar or vector function and then produces a modified subroutine.
Reference: [Laws71] <author> C. L. Lawson, </author> <title> Computing Derivatives using W-Arithmetic and U-Arithmetic, </title> <institution> Jet Propulsion Laboratory Internal Computing Technical Memorandum, </institution> <month> 286, September, </month> <year> 1971. </year>
Reference-contexts: Each procedure takes as input the values of an operation's arguments and its derivatives, and returns the result and its derivatives. The transformation from the source language is performed manually by decomposing a function into a sequence of procedure calls for the elementary operations. Lawson's WCOMP and UCOMP packages <ref> [Laws71] </ref> are examples of elemental AD tools. Based on the concepts pioneered by the elemental tools, the class of extensional tools provide extensions to standard programming languages for automatic differentiation. They usually automate the process of decomposing complicated right-hand-sides of equations into sequences of elementary operations. <p> Tools that could be cross-classified were placed in the class whose characteristics best described them. 4.1. The Elemental Tools. Of the tools surveyed, three of them are elemental tools. All three of these tools produce derivatives in the forward mode. (1) The WCOMP and UCOMP <ref> [Laws71, Math89] </ref> packages consist of FORTRAN 77 subroutines for executing operations that propagate derivatives in the forward mode. The WCOMP package contains subroutines that perform operations using real-valued arrays of length N + 1. <p> In the FEED implementation, derivatives are propagated in the forward mode as operations are performed. This implementation is similar to the UCOMP package <ref> [Laws71, Math89] </ref>. 4.2. The Extensional Tools. The class of extensional tools contains the largest number (nine) of the surveyed tools. This class consists primarily of precompilers.
Reference: [Liep90] <author> M. Liepelt and K. Schittkowski, PCOMP: </author> <title> A FORTRAN code for automatic differentiation Report No.254 (1990), </title> <institution> DFG Schwerpunktprogramm Anwendungsbezogene Op-timierung und Optimale Steuerung, Mathematisches Institut, Universitat Bayreuth, D-8580 Bayreuth, Germany. </institution>
Reference-contexts: The computational graph produced by a PADRE2 generated subroutine is stored exclusively in main memory. (12) The PCOMP <ref> [Liep90] </ref> package consists of three independent parts. The first part (a) processes the description of function written in a subset of an extension to FORTRAN, and compiles it into an intermediate code.
Reference: [Lind91] <author> R. Lindell, </author> <title> Response to electronic mail survey (1991). </title>
Reference-contexts: When variables from the two classes are used, derivative values are propagated in the forward mode. MXYZPTLK can be used to calculate aribritrary-order partial derivatives with respect to arbitrarily many independent variables. (19) RL1 <ref> [Lind91] </ref> is another operational AD tool written in C++. The RL1 package is used to generate derivatives for scalar or vector functions of a single real variable (time).
Reference: [Math89] <author> MATH77, </author> <title> Release 3.0, A Library of Mathematical Subprograms for Fortran 77, Jet Propulsion Laboratory Internal Document, </title> <editor> D-1341, Rev. B., </editor> <month> May </month> <year> 1989. </year>
Reference-contexts: Tools that could be cross-classified were placed in the class whose characteristics best described them. 4.1. The Elemental Tools. Of the tools surveyed, three of them are elemental tools. All three of these tools produce derivatives in the forward mode. (1) The WCOMP and UCOMP <ref> [Laws71, Math89] </ref> packages consist of FORTRAN 77 subroutines for executing operations that propagate derivatives in the forward mode. The WCOMP package contains subroutines that perform operations using real-valued arrays of length N + 1. <p> In the FEED implementation, derivatives are propagated in the forward mode as operations are performed. This implementation is similar to the UCOMP package <ref> [Laws71, Math89] </ref>. 4.2. The Extensional Tools. The class of extensional tools contains the largest number (nine) of the surveyed tools. This class consists primarily of precompilers.
Reference: [Mazo91] <author> V. Mazourik, </author> <title> Integration of Automatic Differentiation into Application Programs for PC's, submitted to Proceedings of SIAM Workshop on Automatic Differentiation, </title> <publisher> (Breckenridge, CO, </publisher> <year> 1991). </year>
Reference-contexts: Several of the earliest AD tools belong to the integral class. The best examples of these are SLANG [Adam69, McCu69, Tham69] and PROSE [Tham75, PROS77, Tham82, Krin84, Pfei87]. More recent examples of integral AD tools are the modeling language AMPL [Four90], and the FM/FAD <ref> [Mazo91] </ref> package. J J b b b Computer Algebra SystemsElemental Extensional Integral Operational Symbolic Fig. 1. The relationship among the various classes of AD tools The operational tools have their origins in the ideas embodied by both the elemental and extensional tools. <p> The DAG of an expression can also be used to produce FORTRAN or C routines for calculating the expression and its gradient at a point. (23) The FM/FAD <ref> [Mazo91] </ref> package is a PC-based set of tools for problem management. Problems (i.e., functions) are defined in FM/FAD using DIFALG, an ALGOL-60 like programming language. Function definitions are compiled by the DIFALG compiler and the compiled version is used by the DIFALG interpreter.
Reference: [McCu69] <author> J. D. McCully, </author> <title> The Q Approach to Problem Solving, </title> <booktitle> Proceedings, FJCC 69, AFIPS 1969, </booktitle> <pages> pp. 691-699. </pages>
Reference-contexts: They are characterized by source languages that directly provide automatic differentiation. Several of the earliest AD tools belong to the integral class. The best examples of these are SLANG <ref> [Adam69, McCu69, Tham69] </ref> and PROSE [Tham75, PROS77, Tham82, Krin84, Pfei87]. More recent examples of integral AD tools are the modeling language AMPL [Four90], and the FM/FAD [Mazo91] package. J J b b b Computer Algebra SystemsElemental Extensional Integral Operational Symbolic Fig. 1.
Reference: [Mich90] <author> L. Michelotti, MXYZPTLK: </author> <title> A Practical, User-Friendly C++ Implementation of Differential Algebra: User's Guide, </title> <note> Technical Memorandum FN-535 (1990), </note> <institution> Fermi National Accelerator Laboratory, Batavia, </institution> <address> IL 60510. </address>
Reference-contexts: Some languages, such as C++, also provide constructors and destructors for variables as they enter and leave their scope of existence. These facilities allow AD tools to transparently allocate and deallocate memory when necessary, as well as perform other maintenance procedures. The operational tools ADOL-C [Grie90] and MXYZPTLK <ref> [Mich90] </ref> make use of these facilities in C++. The final class of AD tools is the class of symbolic tools. <p> MJ2 is written using Turbo C++ v1.0. MJ2 uses operator overloading, and therefore the example code segment f = x + cos (z fl y) from x4.1 does not need to be modified. (18) The MXYZPTLK <ref> [Mich90] </ref> package is an operational AD tool written in C++. The MXYZPTLK package defines two classes, DA and DAVector, and provides a library of supporting routines. A number of binary and unary operations are overloaded for these classes (e.g. +, *, sin, cos, etc.).
Reference: [Mona91] <author> M. Monagan, </author> <title> Response to electronic mail survey (1991). </title>
Reference-contexts: The character string is parsed internally by the GRAD function, which then uses the forward mode to evaluate the gradient. The GRAD function can be called by C programs. (27) The newest version (5.1) of MAPLE <ref> [Mona91] </ref> can perform automatic differentiation. In Maple, functions are expressed as Maple procedures. The Maple D routine produces Maple procedures that evaluate single derivative values for functions described by other Maple procedures. The Maple optimize routine can then be used to optimize these procedures.
Reference: [Neid91] <author> R. D. Neidinger, </author> <title> An efficient method for the numerical evaluation of partial derivatives of arbitrary order, </title> <note> Preprint (1991). </note>
Reference-contexts: The standard operations are overloaded for this class. When operations are executed on members of this class, the derivative values are propagated along with the function values in the forward mode. Derivatives up to the third order can be calculated. (20) The RN1 <ref> [Neid91] </ref> package is an operational AD tool written in PASCAL-SC. RN1 defines a new data type for which the standard operations are overloaded. When operations using this new type are executed, derivatives are propagated in the forward mode.
Reference: [Pfei87] <author> F. Pfeiffer, </author> <title> Automatic Differentiation in PROSE, </title> <journal> ACM SIGNUM Newsletter, Nov. </journal> <volume> 22, </volume> <year> 1987. </year>
Reference-contexts: They are characterized by source languages that directly provide automatic differentiation. Several of the earliest AD tools belong to the integral class. The best examples of these are SLANG [Adam69, McCu69, Tham69] and PROSE <ref> [Tham75, PROS77, Tham82, Krin84, Pfei87] </ref>. More recent examples of integral AD tools are the modeling language AMPL [Four90], and the FM/FAD [Mazo91] package. J J b b b Computer Algebra SystemsElemental Extensional Integral Operational Symbolic Fig. 1.
Reference: [PROS77] <institution> PROSE A General Purpose Higher Level Language, </institution> <note> Procedure Manual (Pub. No. 84003000 Rev. B), Calculus Operations Manual (Pub. No. 84003200 Rev. A), Calculus Applications Guide (Pub. No. 84000170 Rev. A), </note> <institution> Control Data Corporation, </institution> <month> Jan. </month> <year> 1977. </year>
Reference-contexts: They are characterized by source languages that directly provide automatic differentiation. Several of the earliest AD tools belong to the integral class. The best examples of these are SLANG [Adam69, McCu69, Tham69] and PROSE <ref> [Tham75, PROS77, Tham82, Krin84, Pfei87] </ref>. More recent examples of integral AD tools are the modeling language AMPL [Four90], and the FM/FAD [Mazo91] package. J J b b b Computer Algebra SystemsElemental Extensional Integral Operational Symbolic Fig. 1.
Reference: [Rall81] <author> L. B. Rall, </author> <title> Automatic Differentiation: Techniques and Applications, </title> <booktitle> Lecture Notes in Computer Science No. </booktitle> <volume> 120, </volume> <publisher> Springer, </publisher> <year> 1981. </year>
Reference-contexts: In the forward mode, derivative values propagate from the independent variables to the dependent variables. For more in-depth descriptions of these automatic differentiation techniques, see <ref> [Rall81, Iri87, Grie89, etc.] </ref>. As noted by Griewank [Grie89], neither the forward mode nor the reverse mode is optimal in all cases.
Reference: [Rich91] <author> L. C. Rich and D. R. Hill, </author> <title> Automatic Differentiation in MATLAB, </title> <note> in preparation (1991). </note>
Reference-contexts: The function and its derivatives (up to the 20th order) can then be evaluated at a point. The evaluation process propagates derivatives in the forward mode. Currently the AD package is only a demonstrational tool. (26) The GRAD <ref> [Rich91] </ref> function within the MATLAB library of mathematical software can calculate gradients interactively. The parameters to the GRAD function are a character string containing the symbolic description of a function of n variables and a point in n-space (i.e., an array containing n real values).
Reference: [Rost91] <author> N. Rostaing and M. Gaetano, </author> <title> Response to electronic mail survey (1991). </title>
Reference-contexts: Procedures for derivative values of arbitrary order and with respect to arbitrary independent variables can be generated. These procedures calculate derivatives in the forward mode. Maple procedures can be converted into FORTRAN or C subroutines. (28) The NR1 package <ref> [Rost91] </ref> is a symbolic AD tool. NR1 is implemented in LISP within the Reduce Computer Algebra system. NR1 processes a Reduce 12 procedure that satifies certain restrictions and produces an array of Reduce expressions. These Reduce expressions calculate the gradient of the function in the reverse mode.
Reference: [Step91] <author> B. R. Stephens and J. D. Pryce, DAPRE: </author> <title> a Differentiation Arithmetic System for Fortran, </title> <type> Technical Report ACM-91-3 (1991), </type> <institution> Royal Military College of Science, Shrivenham, UK. </institution>
Reference-contexts: Partial derivatives can be calculated to an arbitrary-order and with respect to an arbitrary number of independent variables. The transformation creates calls to a library of subroutines for the elementary operations. These subroutines propagate derivative values in the forward mode. (6) DAPRE <ref> [Step91] </ref> is a FORTRAN preprocessor. It takes as input a FORTRAN subroutine and produces a new FORTRAN subroutine in which all of the arithmetic operations are converted to calls to subroutines from a supporting run-time library. <p> The preprocessor puts some restrictions on the subset of FORTRAN used to define the subroutine (see <ref> [Step91] </ref>). For example, EQUIVALENCE statements are not allowed. This package was designed to interface smoothly with the NAG library of mathematical software, but it is not NAG specific. (7) GRAD [Garc91] is a FORTRAN preprocessor.
Reference: [Spee80] <author> B. Speelpenning, </author> <title> Compiling fast Partial Derivatives of Functions given by Algorithms, </title> <type> Ph.D. </type> <institution> Dissertation (1980), Department of Computer Science, University of Illinois at Urbana Champaign, Urbana, </institution> <address> IL 61801. </address>
Reference-contexts: Several AD tools have been created with the help of language development tools like Lex and Yacc. The most notable of these AD tools are the FORTRAN precompilers JAKE <ref> [Spee80] </ref> and PADRE2 [Kubo90], and the modeling language AMPL [Four90]. During the SIAM Workshop on Automatic Differentiation, it became clear that the forces driving AD technology had caused a variety of different tools to be created. Of these various tools, many of them had similar characteristics. <p> The subroutines propagate the values of variables and their partial derivatives using the forward mode. These subroutines can calculate first- and second-order partial derivatives with respect to an arbitrary number of independent variables. (10) JAKEF [Hill85] is another FORTRAN precompiler. JAKEF is a version of JAKE <ref> [Spee80] </ref> that was developed at Argonne National Laboratory and written using FORTRAN 77. JAKEF takes as input a FORTRAN subroutine defining a scalar or vector function, and generates a FORTRAN subroutine for computing the gradient or Jacobian of the function, respectively. <p> The trace is stored in a linearized form in auxiliary integer and real arrays. There is no facility in JAKEF for using auxiliary storage on large traces, although Speelpenning mentions in his unpublished thesis <ref> [Spee80] </ref> how such a technique could be implemented. (11) PADRE2 [Iri87, Kubo90] is also a FORTRAN precompiler. PADRE2 is an extended version of PADRE, which was developed by N. Iwata [Iwat84].
Reference: [Tesf91] <author> L. Tesfatsion, </author> <title> Automatic Evaluation of Higher-Order Partial Derivatives for Nonlocal Sensitivity Analysis, submitted to Proceedings of SIAM Workshop on Automatic Differentiation, </title> <publisher> (Breckenridge, CO, </publisher> <year> 1991). </year>
Reference-contexts: the elementary operations t1 = z fl y, t1 = cos (t1), and f = x + t1, is written as follows using MJ1. t1.AdMultiply (z,y) ; t1.AdCos (t1) ; f.AdAdd (x,t1) ; (3) The implementation of the FEED (the fast efficient evaluation of derivatives) algorithm by Tesfatsion et al. <ref> [Tesf91] </ref> consists of a suite of FORTRAN subroutines that evaluate a function value and its first-, second- and third-order partial derivatives with respect to N independent variables. In the FEED implementation, derivatives are propagated in the forward mode as operations are performed.
Reference: [Tham69] <author> J. M. Thames, SLANG, </author> <title> A Problem-Solving Language for Continuous-Model Simulation and Optimization, </title> <booktitle> Proceedings to the ACM 24th National Conference, </booktitle> <month> December </month> <year> 1969. </year>
Reference-contexts: They are characterized by source languages that directly provide automatic differentiation. Several of the earliest AD tools belong to the integral class. The best examples of these are SLANG <ref> [Adam69, McCu69, Tham69] </ref> and PROSE [Tham75, PROS77, Tham82, Krin84, Pfei87]. More recent examples of integral AD tools are the modeling language AMPL [Four90], and the FM/FAD [Mazo91] package. J J b b b Computer Algebra SystemsElemental Extensional Integral Operational Symbolic Fig. 1.
Reference: [Tham75] <author> J. M. Thames, </author> <title> Computing in Calculus, </title> <address> Research/Development, </address> <month> May </month> <year> 1975, </year> <pages> pp. 24-30. </pages>
Reference-contexts: They are characterized by source languages that directly provide automatic differentiation. Several of the earliest AD tools belong to the integral class. The best examples of these are SLANG [Adam69, McCu69, Tham69] and PROSE <ref> [Tham75, PROS77, Tham82, Krin84, Pfei87] </ref>. More recent examples of integral AD tools are the modeling language AMPL [Four90], and the FM/FAD [Mazo91] package. J J b b b Computer Algebra SystemsElemental Extensional Integral Operational Symbolic Fig. 1.
Reference: [Tham82] <author> J. M. Thames, </author> <title> The Evolution of Synthetic Calculus: A Mathematical Technology for Advanced Architecture, </title> <booktitle> Proceedings of the International Workshop on High Level Com 18 puter Architecture, </booktitle> <address> Fort Lauderdale, FL, </address> <month> December </month> <year> 1982. </year>
Reference-contexts: They are characterized by source languages that directly provide automatic differentiation. Several of the earliest AD tools belong to the integral class. The best examples of these are SLANG [Adam69, McCu69, Tham69] and PROSE <ref> [Tham75, PROS77, Tham82, Krin84, Pfei87] </ref>. More recent examples of integral AD tools are the modeling language AMPL [Four90], and the FM/FAD [Mazo91] package. J J b b b Computer Algebra SystemsElemental Extensional Integral Operational Symbolic Fig. 1. <p> The FC package consists of a FORTRAN precompiler and a run-time library of supporting routines. FC's extension to FORTRAN is based on a paradigm referred to as synthetic calculus in <ref> [Tham82, Krin84, Tham89, Tham91] </ref>. The basic unit within this paradigm is a model. Models are subprograms that contain sets of formulas. Differentiation, optimization and integration are performed on specified models. Models may include macro statements for optimization and integration. This allows for the nesting of models.
Reference: [Tham89] <author> J. M. Thames, </author> <title> FORTRAN CALCULUS: A new implementation of synthetic calculus, Digital Calculus Corporation, </title> <month> August </month> <year> 1989. </year>
Reference-contexts: The GRESS "Adgen" option produces code that propagates derivatives using the reverse mode. GRESS has been used successfully on a variety of problems. Examples of the application of GRESS can be found in [Horw89, Horw90, etc.]. (9) FORTRAN CALCULUS <ref> [Tham89, Tham91] </ref> (denoted here by FC) is a commercially available package for mathematical modeling. FC is an extension of FORTRAN 77 that provides macro statements for differentiation, optimization and integration, dynamic arrays, and vector and matrix operations. <p> The FC package consists of a FORTRAN precompiler and a run-time library of supporting routines. FC's extension to FORTRAN is based on a paradigm referred to as synthetic calculus in <ref> [Tham82, Krin84, Tham89, Tham91] </ref>. The basic unit within this paradigm is a model. Models are subprograms that contain sets of formulas. Differentiation, optimization and integration are performed on specified models. Models may include macro statements for optimization and integration. This allows for the nesting of models.
Reference: [Tham91] <author> J. M. Thames, </author> <title> Synthetic Calculus A Paradigm of Mathematical Program Synthesis submitted to Proceedings of SIAM Workshop on Automatic Differentiation, </title> <publisher> (Breckenridge, CO, </publisher> <year> 1991). </year>
Reference-contexts: The GRESS "Adgen" option produces code that propagates derivatives using the reverse mode. GRESS has been used successfully on a variety of problems. Examples of the application of GRESS can be found in [Horw89, Horw90, etc.]. (9) FORTRAN CALCULUS <ref> [Tham89, Tham91] </ref> (denoted here by FC) is a commercially available package for mathematical modeling. FC is an extension of FORTRAN 77 that provides macro statements for differentiation, optimization and integration, dynamic arrays, and vector and matrix operations. <p> The FC package consists of a FORTRAN precompiler and a run-time library of supporting routines. FC's extension to FORTRAN is based on a paradigm referred to as synthetic calculus in <ref> [Tham82, Krin84, Tham89, Tham91] </ref>. The basic unit within this paradigm is a model. Models are subprograms that contain sets of formulas. Differentiation, optimization and integration are performed on specified models. Models may include macro statements for optimization and integration. This allows for the nesting of models.
Reference: [Yosh89] <author> T. Yoshida, </author> <title> Automatic derivative derivation system, </title> <journal> Transactions of Information Processing Society of Japan, </journal> <volume> Vol. 30, No. </volume> <pages> 7 (1989) , pp. 799-806. </pages> <note> (in Japanese.) 19 </note>
Reference-contexts: The Integral Tools. Of the tools surveyed, four are integral tools. Of these, one uses the forward mode of automatic differentiation, one uses the reverse mode, and two use both modes. (21) The ADDS (Automatic Derivative Derivation System) <ref> [Yosh89] </ref> package is an AD tool that defines a new language. The ADDS package provides a language for describing scalar, vector, and matrix expressions, and their partial derivatives. Expressions defined in the ADDS language are translated into FORTRAN.
References-found: 54

