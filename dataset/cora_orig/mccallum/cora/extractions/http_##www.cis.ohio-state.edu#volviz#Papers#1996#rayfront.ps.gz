URL: http://www.cis.ohio-state.edu/volviz/Papers/1996/rayfront.ps.gz
Refering-URL: http://www.cis.ohio-state.edu/volviz/papers_subject.html
Root-URL: 
Email: Email: -law, yagel-@cis.ohio-state.edu  
Phone: Phone: 614-292-0060 Fax: 614-292-2911  
Title: Multi-Frame Thrashless Ray Casting with Advancing Ray-Front  
Author: Asish Law and Roni Yagel 
Keyword: parallel rendering, volume visualization, ray casting.  
Address: 2036 Neil Avenue Columbus, Ohio  
Affiliation: Department of Computer and Information Science The Ohio State University  
Abstract: Coherency (data locality) is one of the most important factors that inuences the performance of distributed ray tracing systems, especially when object dataow approach is employed. The enormous cost associated with remote fetches must be reduced to improve the efficiency of the parallel renderer. Objects once fetched should be maximally utilized before replacing them with other objects. In this paper, we describe a parallel volume ray caster that eliminates thrashing by efficiently advancing a ray-front in a front-to-back manner. The method adopts an image-order approach, but capitalizes on the advantages of object-order algorithms as well to almost eliminate the communication overheads. Unlike previous algorithms, we have successfully preserved the thrashless property across a number of incrementally changing screen positions also. The use of efficient data structures and object ordering scheme has enabled complete latency hiding of non-local objects. The sum total of all these result in a scalable parallel volume renderer with the most coherent screen traversal. Comparison with other existing screen traversal schemes delineates the advantages of our approach. 
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> M.B. Amin, A. Grama, V. Singh. </author> <title> Fast Volume Render- ing Using an Efficient, Scalable Parallel Formulation of the Shear-Warp Algorithm, </title> <booktitle> Proceedings of Parallel Rendering Symposium, </booktitle> <address> Atlanta, </address> <month> October </month> <year> 1995, </year> <pages> pp. 7-14. </pages>
Reference-contexts: Limited memory and processing power of uniprocessor machines make volume rendering a good candidate for parallelization, the algorithms presented in <ref> [1] </ref> and [8] being considered as the most efficient parallel vol <br>- Proceedings of Graphics Interfaces 1996, Toronto, Canada, May 1996, pp. 70-77.. ume renderers. Parallel volume rendering can be classi-fied into two categories: object-dataow, and image- dataow, depending on the type of data transferred between the processors.
Reference: 2. <author> J. Arvo. </author> <title> Space-Filling Curves and a Measure of Coher <br>- ence. Graphics Gems II, </title> <booktitle> Chapter 1.8, </booktitle> <pages> pp. 26-30. </pages>
Reference-contexts: For example, for rendering using compression caches, 35000 cells will undergo decompression in the case of 1 frame/phase as opposed to 4000 cells in the case of 30 frames/phase. 4.2 Comparison algorithm with three of the most common screen-traversal algorithms: scan-line, spiral, and Hilbert <ref> [2] </ref>. In each of these, the screen regions were distributed to the processors in exactly the same manner as in our algorithm. The only difference was the way in which the respective regions were traversed by each algorithm.
Reference: 3. <author> D. Badouel, K. Bouatouch, T. Priol. </author> <title> Ray Tracing on Dis- tributed Memory Parallel Computers: Strategies for Dis- tributing Computations and Data, SIGGRAPH 90, Parallel Algorithms and Architecture for 3D Image Gen <br>- eration, </title> <booktitle> Course Notes. </booktitle> <pages> pp. 185-198. </pages>
Reference-contexts: The local memory is partitioned into two segments: the first segment is used to store the home cells, while the other segment is used as a cache <ref> [3] </ref>. The size of the home memory in number of cells equals the total number of cells in the volume divided by the number of processors. The home region of the memory is static as cells residing in this region (home cells) are never replaced.
Reference: 4. <author> J. Challinger. </author> <title> Parallel Volume Rendering on a Shared- Memory Multiprocessor, </title> <institution> Department of Computer and Information Sciences, UC Santa Cruz, </institution> <note> Technical Report UCSC-CRL-91-23, revised March 1992. </note>
Reference: 5. <author> B. Corrie, P. Mackerras. </author> <title> Parallel Volume Rendering and Data Coherence, </title> <booktitle> Proceedings of Parallel Rendering Symposium, </booktitle> <address> San Jose, California, </address> <month> October </month> <year> 1993, </year> <pages> pp. </pages> <address> 23 <br>- 26. </address>
Reference-contexts: If the cache is large enough, then the system can even take advantage of frame-to-frame coherency [7]. If the cache is not large enough, then it starts to thrash. Thrashing is manifested as the repeated transfer of the same data to the same processing node <ref> [5] </ref>. If a processors cache cannot hold the number of blocks that it needs to render a single ray, then a cyclic refill of the cache will occur for each ray. As the size of the database increases, the effect of thrashing becomes more visible.
Reference: 6. <author> T. von Eicken, D.E. Culler, S.C. Goldstein, K.E. Schauser. </author> <title> Active Messages: a Mechanism for Integrated Communication and Computation, </title> <journal> ACM Transactions 1992, </journal> <pages> pp. 256-266. </pages>
Reference-contexts: This is done by sending requests for the next few cells in the FTBL, while working on the currently active cell. After advancing each ray through a cell, the buffers are polled for messages with a non-blocking probe. A software handler is provided for each kind of message <ref> [6] </ref>. Depending on the type of message a corresponding action is taken. For example, if the message contains cell information, it is read from the buffers and directly put in a proper place in memory (cache).
Reference: 7. <author> S. Green, D. Paddon. </author> <title> Exploiting Coherence for Multi- processor Ray Tracing, </title> <journal> IEEE Computer Graphics and Applications 9, </journal> <volume> (6), </volume> <pages> pp. 12-26, </pages> <month> November </month> <year> 1989. </year>
Reference-contexts: With a coherent screen traversal, these objects are likely to be used again for subsequent rays in the current frame. If the cache is large enough, then the system can even take advantage of frame-to-frame coherency <ref> [7] </ref>. If the cache is not large enough, then it starts to thrash. Thrashing is manifested as the repeated transfer of the same data to the same processing node [5].
Reference: 8. <author> P. Lacroute. </author> <title> Real Time Volume Rendering on Shared Memory Multiprocessors Using the Shear-Warp Factor- ization. </title> <booktitle> Proceedings of Parallel Rendering Symposium, </booktitle> <address> Atlanta, </address> <month> October </month> <year> 1995, </year> <pages> pp. 15-22. </pages>
Reference-contexts: Limited memory and processing power of uniprocessor machines make volume rendering a good candidate for parallelization, the algorithms presented in [1] and <ref> [8] </ref> being considered as the most efficient parallel vol <br>- Proceedings of Graphics Interfaces 1996, Toronto, Canada, May 1996, pp. 70-77.. ume renderers. Parallel volume rendering can be classi-fied into two categories: object-dataow, and image- dataow, depending on the type of data transferred between the processors.
Reference: 9. <author> A. Law, R. Yagel. CellFlow: </author> <title> A Parallel Rendering Scheme for Distributed Memory Architectures, </title> <booktitle> Pro- ceedings of the International Conference on Parallel and Distributed Techniques and Applications, </booktitle> <address> Atlanta, </address> <month> November, </month> <year> 1995, </year> <pages> pp. 1-10. </pages>
Reference: 10. <author> M. Levoy. </author> <title> Display of Surfaces from Volume Data, </title> <journal> IEEE Computer Graphics and Applications, </journal> <volume> Vol. 8, No. 5, </volume> <month> May </month> <year> 1988, </year> <pages> pp. 29-37. </pages>
Reference-contexts: Such volume data may be, for example, scanned by MRI (Magnetic Resonance Imaging) or CT (Computed Tomography), or simulated by CFD (Computational Fluid Dynamics) programs. Two of the most popular approaches used in volume rendering are based on image-order <ref> [10] </ref> and object-order [15] traversals. In image-order traversal, a ray is shot from the eye point and through each screen pixel. This method is also referred to as forward-projection or ray- casting. The volume is sampled at regular intervals along the ray.
Reference: 11. <author> K.L. Ma, J.S. Painter, C.D. Hansen, M.F. Krough. </author> <title> A Data Distributed, Parallel Algorithm for Ray-Traced Vol- ume Rendering, </title> <booktitle> Proceedings of Parallel Rendering Symposium, </booktitle> <address> San Jose, California, </address> <month> October </month> <year> 1993, </year> <pages> pp. </pages> <address> 15 <br>- 22. </address>
Reference-contexts: Also, it is more difficult to generate high quality images (e.g., anti- aliased images), especially when viewed in perspective. On the other hand, as each voxel in the volume has to be projected, parallel object-order techniques are inherently load-balanced in the projection stage, and in the compositing stage <ref> [11] </ref>. Moreover, object-order methods do not suffer from thrashing within a single frame generation. Voxels once brought in and processed are not needed again for the generation of the current frame.
Reference: 12. <author> R. Machiraju, R.Yagel. </author> <title> Efficient Feed-Forward Volume Rendering Techniques for Vector and Parallel Proces- sors, </title> <booktitle> Proceedings of Supercomputing 93, </booktitle> <address> Portland, OR, </address> <pages> pp. 699-708. </pages>
Reference-contexts: The object-order rendering approach is more data coherent, as voxels in the volume are traversed in a regular manner, making this approach more amenable to par- allelization or vectorization <ref> [12] </ref>. Each voxel is projected onto the screen, and its color and opacity are composited to the appropriate pixels. The major disadvantage of this approach is that it cannot easily take advantage of acceleration techniques as in the case of image-order approaches.
Reference: 13. <author> I.E. Sutherland, R.F. Sproull, R.A. Schumacker. </author> <title> A Char- acterization of Ten Hidden-Surface Algorithms, </title> <journal> Com <br>- puting Surveys, </journal> <volume> Vol. 6, No. 1, </volume> <month> March </month> <year> 1974, </year> <pages> pp. 1-55. </pages>
Reference-contexts: The results of our implementation on the Cray T3D, including comparisons with existing screen traversal methods, are shown in Section 4. The advantages, disadvantages, and some of our future goals are summarized in Section 5. 2. Exploiting Coherency for Efficient Rendering In their classic paper, Sutherland et al., <ref> [13] </ref> have described coherency as the extent to which the environment, or the picture of it, is locally constant.
Reference: 14. <author> R. Westermann, S. </author> <title> Augustin. </title> <booktitle> Parallel Volume Render- ing, Proceedings of International Parallel Processing Symposium, </booktitle> <year> 1995, </year> <pages> pp. 693-699. </pages>
Reference-contexts: This can be asserted by verifying that the improvement gained by efficient caching of cells is not offset by the traversal of the data structures employed by our algorithm. Our method is advantageous over other similar implementations <ref> [14] </ref>, as we have achieved thrash-free property across a number of frames also. Our efficient data structures optimizes the complexity of the ray search, and the cell ordering scheme we employ facilitates effective latency hiding making the algorithm scalable.
Reference: 15. <author> L. Westover. </author> <title> Footprint Evaluation for Volume Render- ing., </title> <journal> Computer Graphics (SIGGRAPH 90 Proceed <br>- ings), </journal> <volume> Vol. 24, </volume> <year> 1990, </year> <pages> pp. 367-376. </pages>
Reference-contexts: Such volume data may be, for example, scanned by MRI (Magnetic Resonance Imaging) or CT (Computed Tomography), or simulated by CFD (Computational Fluid Dynamics) programs. Two of the most popular approaches used in volume rendering are based on image-order [10] and object-order <ref> [15] </ref> traversals. In image-order traversal, a ray is shot from the eye point and through each screen pixel. This method is also referred to as forward-projection or ray- casting. The volume is sampled at regular intervals along the ray.
Reference: 16. <author> R. Yagel, Z. Shi. </author> <title> Accelerating Volume Animation by Space-Leaping, </title> <booktitle> Proceedings of Visualization93, </booktitle> <address> San Jose, California, </address> <month> October </month> <year> 1993, </year> <pages> pp. 62-69. </pages>
Reference-contexts: For example, rays can be made to terminate as soon as the accumulated opacity exceeds a pre-specified threshold value. This is known as early ray termination or opacity clipping. The sampling of the volume along the ray can also be adapted to rapidly traverse empty spaces <ref> [16] </ref>, leading to significant savings in computation. The disadvantage of the image order approach, however, is that the data access is highly irregular, leading to low object-space coherency.
Reference: 17. <author> H. Zhang, S. Liu. </author> <title> Order of Pixel Traversal and Parallel Volume Ray Tracing on the Distributed Volume Buffer. </title> <booktitle> Presented at the Eurographics Workshop on Volume Visualization, </booktitle> <year> 1995. </year>
Reference-contexts: The only difference was the way in which the respective regions were traversed by each algorithm. Out of these, the Hilbert is believed to be the most coherent screen-traversal scheme <ref> [17] </ref>. It is evident from is graph that the screen traversal used for the ray-front algorithm outclasses the others at all cache sizes for parallel projection ray casting. The performance gain at lower cache sizes is particularly noteworthy. The primary advantage FIGURE 8.
References-found: 17

