URL: http://www-cad.eecs.berkeley.edu/~sriramr/ag.ps
Refering-URL: http://www-cad.eecs.berkeley.edu/~sriramr/research.html
Root-URL: 
Email: Email: ftah, shaz, sriramrg@ic.eecs.berkeley.edu  
Author: Thomas A. Henzinger Shaz Qadeer Sriram K. Rajamani 
Address: Berkeley, CA 94720-1770, U.S.A.  
Affiliation: EECS Department, University of California at  
Abstract: You Assume, We Guarantee: Methodology and Case Studies Abstract. Assume-guarantee reasoning has long been advertised as the method for decomposing proof obligations in system verification. Refinement mappings (homomorphisms) have long been advertised as the method for solving the language-inclusion problem in practice. When confronted with large verification problems, we therefore attempted to make use of both techniques. We soon found that rather than offering instant solutions, the success of assume-guarantee reasoning depends critically on the construction of suitable abstraction modules, and the success of refinement checking depends critically on the construction of suitable witness modules. Moreover, as abstractions need to be witnessed, and witnesses abstracted, the process must be iterated. We present here the main lessons we learned from our experiments, in form of a systematic and structured discipline for compositional verification of fair reactive modules. This discipline has succeeded in several major case studies, of which we discuss in detail the verification of a sliding-window protocol and of Tomasulo's algorithm. An infrastructure to support this discipline, and automate parts of the verification, has been implemented in the tool Mocha. 
Abstract-found: 1
Intro-found: 1
Reference: [AH96] <author> R. Alur and T.A. Henzinger. </author> <title> Reactive Modules. </title> <booktitle> In Proceedings of the 11th Annual Symposium on Logic in Computer Science, </booktitle> <pages> pages 207-218. </pages> <publisher> IEEE Computer Society Press, </publisher> <year> 1996. </year>
Reference-contexts: We believe that this compositional approach is more scalable. In this paper, we present the results and experiences in implementing a system for compositional refinement. Our tool is called Mocha, and our system description language is called Reactive Modules <ref> [AH96] </ref>. We started out by trying to verify a few large examples compositionally. In the process, we discovered a systematic methodology to carry out such proofs. This methodology, implemented in Mocha [AHM + 98], is described in detail here. <p> Our methodology generalizes easily to fair refinement checks. We illustrate our methodology using non-trivial examples | a sliding window communication protocol and a hardware circuit implementing the Tomasulo algorithm. Related Work. The use of assume-guarantee proof rules to decompose a refinement check has appeared before in <ref> [Sta85, Kur87, Kur94, AL95, AH96, McM97] </ref>. The proof rule used in this paper is a generalization of the one in [AH96]. The use of witness modules to deal with the exponential in the specification state space, has appeared in various guises and forms in [Lam83, LT87, AL91, AL95, Lyn96, McM97]. <p> Related Work. The use of assume-guarantee proof rules to decompose a refinement check has appeared before in [Sta85, Kur87, Kur94, AL95, AH96, McM97]. The proof rule used in this paper is a generalization of the one in <ref> [AH96] </ref>. The use of witness modules to deal with the exponential in the specification state space, has appeared in various guises and forms in [Lam83, LT87, AL91, AL95, Lyn96, McM97]. <p> Though our work draws inspiration from [McM97], methodological issues like iterating witness and abstraction modules, generalization to handle fairness, and results of larger case studies have not been presented before. 2 Reactive Modules A formal definition of reactive modules can be found in <ref> [AH96] </ref>; here we give only a brief introduction. <p> The assume guarantee rule, stated below is a generalization of the rule proved in <ref> [AH96] </ref>. Proposition 3.2 Let P = P 1 kP 2 k:::kP n and Q = Q 1 kQ 2 k:::kQ m be two reactive modules. Let i be some legal parallel composition of arbitrary modules from P and Q with the exception of Q i . <p> A fair module is a pair hP; i, where is a linear temporal logic formula (called fairness condition) over the variables of P , such that the set of !-trajectories of P satisfying (called fair !-trajectories of P ) is receptive <ref> [AH96] </ref>. Roughly, this means that in order to extend a finite trajectory to a fair !-trajectory, the module does not need cooperation of the environment. An !-trace is fair if it is witnessed by a fair !-trajectory. <p> The circularity in the fairness assumptions need to be broken. A slightly weaker rule, stated below, has been established in <ref> [AH96] </ref>: hP 1 ; 1 ikhQ 2 ; truei F hQ 1 ; 1 i hQ 1 ; 1 ikhP 2 ; 2 i F hQ 2 ; 2 i hP 1 ; 1 ikhP 2 ; 2 i F hQ 1 ; 1 ikhQ 2 ; 2 i The correctness
Reference: [AHM + 98] <author> R. Alur, T. A. Henzinger, F. Y. C. Mang, S. Qadeer, S. K. Rajamani, and S. Tapcsran. </author> <title> Mocha : Modularity in Model Checking. </title> <booktitle> Submitted to the 10th International Conference on Computer-Aided Verification, </booktitle> <year> 1998. </year>
Reference-contexts: Our tool is called Mocha, and our system description language is called Reactive Modules [AH96]. We started out by trying to verify a few large examples compositionally. In the process, we discovered a systematic methodology to carry out such proofs. This methodology, implemented in Mocha <ref> [AHM + 98] </ref>, is described in detail here. To illustrate the main aspects of our methodology that deal with explosion of the implementation state space, consider the refinement check P 1 kP 2 Q, where k denotes parallel composition operation and denotes the refinement relation on modules.
Reference: [AL91] <author> M. Abadi and L. Lamport. </author> <title> The Existence of Refinement Mappings. </title> <journal> Theoretical Computer Science, </journal> <volume> 82(2) </volume> <pages> 253-284, </pages> <year> 1991. </year>
Reference-contexts: The proof rule used in this paper is a generalization of the one in [AH96]. The use of witness modules to deal with the exponential in the specification state space, has appeared in various guises and forms in <ref> [Lam83, LT87, AL91, AL95, Lyn96, McM97] </ref>. <p> Suppose P is comparable with Q, but not projection comparable. We need to compose P with a witness module to make it projection comparable with Q. The idea of providing witness modules is related to homomorphisms [Kur94], refinement mappings <ref> [AL91] </ref> and simulation relations [Lyn96]. Whenever there is hidden state in the specification, a witness for the hidden state has to be provided in the implementation. Consider, for example, the communication protocol example from Figure 1. We wish to prove that TwoWayHandShake ComSpec.
Reference: [AL95] <author> M. Abadi and L. Lamport. </author> <title> Conjoining Specifications. </title> <booktitle> In ACM Transactions on Programming Languages and Systems, </booktitle> <pages> pages 507-534, </pages> <month> May </month> <year> 1995. </year>
Reference-contexts: Our methodology generalizes easily to fair refinement checks. We illustrate our methodology using non-trivial examples | a sliding window communication protocol and a hardware circuit implementing the Tomasulo algorithm. Related Work. The use of assume-guarantee proof rules to decompose a refinement check has appeared before in <ref> [Sta85, Kur87, Kur94, AL95, AH96, McM97] </ref>. The proof rule used in this paper is a generalization of the one in [AH96]. The use of witness modules to deal with the exponential in the specification state space, has appeared in various guises and forms in [Lam83, LT87, AL91, AL95, Lyn96, McM97]. <p> The proof rule used in this paper is a generalization of the one in [AH96]. The use of witness modules to deal with the exponential in the specification state space, has appeared in various guises and forms in <ref> [Lam83, LT87, AL91, AL95, Lyn96, McM97] </ref>.
Reference: [BHSV + 96] <author> R.K. Brayton, G.D. Hachtel, A. Sangiovanni-Vincentelli, F. Somenzi, A. Aziz, S.-T. Cheng, S. Ed-wards, S. Khatri, Y. Kukimoto, A. Pardo, S. Qadeer, R.K. Ranjan, S. Sarwary, T.R. Shiple, G. Swamy, and T. Villa. </author> <title> VIS: A System for Verification and Synthesis. </title> <booktitle> In Proc. of the 8th International Conference on Computer-Aided Verification, volume 1102 of Lecture Notes in Computer Science, </booktitle> <pages> pages 428-432. </pages> <publisher> Springer-Verlag, </publisher> <year> 1996. </year>
Reference-contexts: Not surprisingly, algorithms for refinement checking are exponential in the size of the implementation description and double exponential in the size of the specification description. Existing techniques to combat this state space explosion problem are based on heuristics that target specific application domains, e.g., symbolic methods <ref> [McM93, HHK96, BHSV + 96] </ref> based on binary decision diagrams [Bry86] for hardware designs, and partial-order reduction [HP96] and symmetry reduction [Dil96] for protocols.
Reference: [Bry86] <author> R. Bryant. </author> <title> Graph-based Algorithms for Boolean Function Manipulation. </title> <journal> IEEE Transactions on Computers, </journal> <volume> C-35:677-691, </volume> <month> August </month> <year> 1986. </year>
Reference-contexts: Existing techniques to combat this state space explosion problem are based on heuristics that target specific application domains, e.g., symbolic methods [McM93, HHK96, BHSV + 96] based on binary decision diagrams <ref> [Bry86] </ref> for hardware designs, and partial-order reduction [HP96] and symmetry reduction [Dil96] for protocols. We take an orthogonal approach to the problem, in which the refinement proof is decomposed into smaller lemmas each of which can be discharged by any of the aforementioned techniques.
Reference: [Dil96] <author> David L. Dill. </author> <title> The Mur Verification System. </title> <booktitle> In Proc. of the 8th International Conference on Computer-Aided Verification, volume 1102 of Lecture Notes in Computer Science, </booktitle> <pages> pages 390-393. </pages> <publisher> Springer-Verlag, </publisher> <year> 1996. </year>
Reference-contexts: Existing techniques to combat this state space explosion problem are based on heuristics that target specific application domains, e.g., symbolic methods [McM93, HHK96, BHSV + 96] based on binary decision diagrams [Bry86] for hardware designs, and partial-order reduction [HP96] and symmetry reduction <ref> [Dil96] </ref> for protocols. We take an orthogonal approach to the problem, in which the refinement proof is decomposed into smaller lemmas each of which can be discharged by any of the aforementioned techniques. We believe that this compositional approach is more scalable.
Reference: [DP97] <author> W. Damm and A. Pnueli. </author> <title> Verifying Out-of-Order Executions. </title> <booktitle> In Proc. of the IFIP Conference on Correct Hardware Design, </booktitle> <address> CHARME, </address> <year> 1997. </year>
Reference-contexts: Out of order execution of an instruction is allowed, if operands are available. The specification module is the simple Instruction Set Architecture (ISA) module that we saw in Figure 2. Recently, there have been a few efforts to verify this algorithm <ref> [DP97, McM95] </ref>. We present below our use of witness and abstraction modules to verify the algorithm in an assume-guarantee fashion. The implementation module TOMASULO has five main components: Implementation registers, reservation stations, bus, schedulers and a stall generator. Each register in the implementation has three fields: valid, value and tag.
Reference: [HHK96] <author> R. H. Hardin, Z. Har'El, and R. P. </author> <title> Kurshan. </title> <booktitle> COSPAN. In Proc. of the 8th International Conference on Computer-Aided Verification, volume 1102 of Lecture Notes in Computer Science, </booktitle> <pages> pages 423-427. </pages> <publisher> Springer-Verlag, </publisher> <year> 1996. </year>
Reference-contexts: Not surprisingly, algorithms for refinement checking are exponential in the size of the implementation description and double exponential in the size of the specification description. Existing techniques to combat this state space explosion problem are based on heuristics that target specific application domains, e.g., symbolic methods <ref> [McM93, HHK96, BHSV + 96] </ref> based on binary decision diagrams [Bry86] for hardware designs, and partial-order reduction [HP96] and symmetry reduction [Dil96] for protocols.
Reference: [HP96] <author> G.J. Holzmann and D.A. Peled. </author> <title> The State of SPIN. </title> <booktitle> In Proc. of the 8th International Conference on Computer-Aided Verification, volume 1102 of Lecture Notes in Computer Science, </booktitle> <pages> pages 385-389. </pages> <publisher> Springer-Verlag, </publisher> <year> 1996. </year>
Reference-contexts: Existing techniques to combat this state space explosion problem are based on heuristics that target specific application domains, e.g., symbolic methods [McM93, HHK96, BHSV + 96] based on binary decision diagrams [Bry86] for hardware designs, and partial-order reduction <ref> [HP96] </ref> and symmetry reduction [Dil96] for protocols. We take an orthogonal approach to the problem, in which the refinement proof is decomposed into smaller lemmas each of which can be discharged by any of the aforementioned techniques. We believe that this compositional approach is more scalable.
Reference: [Kur87] <author> R. P. Kurshan. </author> <title> Reducibility in Analysis of Coordination. In Discrete Event Systems: Models and Applications, </title> <booktitle> volume 103 of LNCIS, </booktitle> <pages> pages 19-39. </pages> <publisher> Springer-Verlag, </publisher> <year> 1987. </year>
Reference-contexts: Our methodology generalizes easily to fair refinement checks. We illustrate our methodology using non-trivial examples | a sliding window communication protocol and a hardware circuit implementing the Tomasulo algorithm. Related Work. The use of assume-guarantee proof rules to decompose a refinement check has appeared before in <ref> [Sta85, Kur87, Kur94, AL95, AH96, McM97] </ref>. The proof rule used in this paper is a generalization of the one in [AH96]. The use of witness modules to deal with the exponential in the specification state space, has appeared in various guises and forms in [Lam83, LT87, AL91, AL95, Lyn96, McM97].
Reference: [Kur94] <author> R. P. Kurshan. </author> <title> Automata-Theoretic Verification of Coordinating Processes. </title> <publisher> Princeton University Press, </publisher> <year> 1994. </year>
Reference-contexts: Our methodology generalizes easily to fair refinement checks. We illustrate our methodology using non-trivial examples | a sliding window communication protocol and a hardware circuit implementing the Tomasulo algorithm. Related Work. The use of assume-guarantee proof rules to decompose a refinement check has appeared before in <ref> [Sta85, Kur87, Kur94, AL95, AH96, McM97] </ref>. The proof rule used in this paper is a generalization of the one in [AH96]. The use of witness modules to deal with the exponential in the specification state space, has appeared in various guises and forms in [Lam83, LT87, AL91, AL95, Lyn96, McM97]. <p> Suppose P is comparable with Q, but not projection comparable. We need to compose P with a witness module to make it projection comparable with Q. The idea of providing witness modules is related to homomorphisms <ref> [Kur94] </ref>, refinement mappings [AL91] and simulation relations [Lyn96]. Whenever there is hidden state in the specification, a witness for the hidden state has to be provided in the implementation. Consider, for example, the communication protocol example from Figure 1. We wish to prove that TwoWayHandShake ComSpec.
Reference: [Lam83] <author> L. Lamport. </author> <title> Specifying Concurrent Program Modules. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 5(2) </volume> <pages> 190-222, </pages> <year> 1983. </year>
Reference-contexts: The proof rule used in this paper is a generalization of the one in [AH96]. The use of witness modules to deal with the exponential in the specification state space, has appeared in various guises and forms in <ref> [Lam83, LT87, AL91, AL95, Lyn96, McM97] </ref>.
Reference: [LT87] <author> N.A. Lynch and M.R. Tuttle. </author> <title> Hierarchical Correctness Proofs for Distributed Algorithms. </title> <booktitle> In Proceedings of the Sixth Annual Symposium on Principles of Distributed Computing, </booktitle> <pages> pages 137-151. </pages> <publisher> ACM Press, </publisher> <year> 1987. </year>
Reference-contexts: The proof rule used in this paper is a generalization of the one in [AH96]. The use of witness modules to deal with the exponential in the specification state space, has appeared in various guises and forms in <ref> [Lam83, LT87, AL91, AL95, Lyn96, McM97] </ref>.
Reference: [Lyn96] <author> N. A. Lynch. </author> <title> Distributed Algorithms. </title> <address> Morgan-Kaufman, </address> <year> 1996. </year>
Reference-contexts: The proof rule used in this paper is a generalization of the one in [AH96]. The use of witness modules to deal with the exponential in the specification state space, has appeared in various guises and forms in <ref> [Lam83, LT87, AL91, AL95, Lyn96, McM97] </ref>. <p> Suppose P is comparable with Q, but not projection comparable. We need to compose P with a witness module to make it projection comparable with Q. The idea of providing witness modules is related to homomorphisms [Kur94], refinement mappings [AL91] and simulation relations <ref> [Lyn96] </ref>. Whenever there is hidden state in the specification, a witness for the hidden state has to be provided in the implementation. Consider, for example, the communication protocol example from Figure 1. We wish to prove that TwoWayHandShake ComSpec. The private variable pc in ComSpec varies without any constraints.
Reference: [McM93] <author> Kenneth L. McMillan. </author> <title> Symbolic Model Checking. </title> <publisher> Kluwer Academic Publishers, </publisher> <year> 1993. </year>
Reference-contexts: Not surprisingly, algorithms for refinement checking are exponential in the size of the implementation description and double exponential in the size of the specification description. Existing techniques to combat this state space explosion problem are based on heuristics that target specific application domains, e.g., symbolic methods <ref> [McM93, HHK96, BHSV + 96] </ref> based on binary decision diagrams [Bry86] for hardware designs, and partial-order reduction [HP96] and symmetry reduction [Dil96] for protocols.
Reference: [McM95] <author> K. L. </author> <type> McMillan. </type> <institution> Cadence Berkeley Labs, Berkeley, CA. </institution> <type> Personal communication, </type> <year> 1995. </year>
Reference-contexts: Out of order execution of an instruction is allowed, if operands are available. The specification module is the simple Instruction Set Architecture (ISA) module that we saw in Figure 2. Recently, there have been a few efforts to verify this algorithm <ref> [DP97, McM95] </ref>. We present below our use of witness and abstraction modules to verify the algorithm in an assume-guarantee fashion. The implementation module TOMASULO has five main components: Implementation registers, reservation stations, bus, schedulers and a stall generator. Each register in the implementation has three fields: valid, value and tag.
Reference: [McM97] <author> K. L. McMillan. </author> <title> A Compositional Rule for Hardware Design Refinement. </title> <booktitle> In Proc. of the 9th International Conference on Computer-Aided Verification, Lecture Notes in Computer Science, </booktitle> <pages> pages 24-35. </pages> <publisher> Springer-Verlag, </publisher> <year> 1997. </year>
Reference-contexts: Our methodology generalizes easily to fair refinement checks. We illustrate our methodology using non-trivial examples | a sliding window communication protocol and a hardware circuit implementing the Tomasulo algorithm. Related Work. The use of assume-guarantee proof rules to decompose a refinement check has appeared before in <ref> [Sta85, Kur87, Kur94, AL95, AH96, McM97] </ref>. The proof rule used in this paper is a generalization of the one in [AH96]. The use of witness modules to deal with the exponential in the specification state space, has appeared in various guises and forms in [Lam83, LT87, AL91, AL95, Lyn96, McM97]. <p> The proof rule used in this paper is a generalization of the one in [AH96]. The use of witness modules to deal with the exponential in the specification state space, has appeared in various guises and forms in <ref> [Lam83, LT87, AL91, AL95, Lyn96, McM97] </ref>. <p> The use of witness modules to deal with the exponential in the specification state space, has appeared in various guises and forms in [Lam83, LT87, AL91, AL95, Lyn96, McM97]. Though our work draws inspiration from <ref> [McM97] </ref>, methodological issues like iterating witness and abstraction modules, generalization to handle fairness, and results of larger case studies have not been presented before. 2 Reactive Modules A formal definition of reactive modules can be found in [AH96]; here we give only a brief introduction.
Reference: [Raj] <author> Sriram K. Rajamani. </author> <note> http://www-cad.eecs.berkeley.edu/~sriramr/research. </note>
Reference-contexts: Writing good abstraction modules is crucial for decomposing a large verification task into smaller tasks. To illustrate abstraction modules, let us consider the modules ISA, described before and PIPELINE , a three-stage pipeline implementation. A detailed description of PIPELINE module can be found in <ref> [Raj] </ref>. Here we give a brief overview. The PIPELINE module is a parallel composition of seven modules: RegFile, Pipe1 , Opr1 , Opr2 , Pipe2 , PipeOut and Stall . <p> Note that messages are consumed in the same order in which they are produced. We verified that a particular implementation of the sliding window protocol satisfies this specification. The reactive modules description of the implementation can be found in <ref> [Raj] </ref>. It consists of four components producer, sender, receiver and consumer. The sender and receiver communicate over an unreliable channel that can loose messages sent by the sender and the acknowledgments sent by the receiver. If an acknowledgment is not received within a certain time, the sender retransmits the messages.
Reference: [Sta85] <author> E. W. Stark. </author> <title> A Proof Technique for Rely/Guarantee Properties. </title> <booktitle> In Foundations of Software Technology and Theoretical Computer Science, volume 206 of Lecture Notes in Computer Science, </booktitle> <pages> pages 369-391, </pages> <year> 1985. </year>
Reference-contexts: Our methodology generalizes easily to fair refinement checks. We illustrate our methodology using non-trivial examples | a sliding window communication protocol and a hardware circuit implementing the Tomasulo algorithm. Related Work. The use of assume-guarantee proof rules to decompose a refinement check has appeared before in <ref> [Sta85, Kur87, Kur94, AL95, AH96, McM97] </ref>. The proof rule used in this paper is a generalization of the one in [AH96]. The use of witness modules to deal with the exponential in the specification state space, has appeared in various guises and forms in [Lam83, LT87, AL91, AL95, Lyn96, McM97].
Reference: [Tan92] <author> Andrew S. Tanenbaum. </author> <title> Computer Networks. </title> <publisher> Prentice-Hall Inc., </publisher> <year> 1992. </year> <month> 16 </month>
Reference-contexts: The receiver can then assemble the message sequence correctly by looking at the sequence number. For the protocol to work correctly, at least 2 fl WINSIZE sequence numbers are needed <ref> [Tan92] </ref>. The sender module has two arrays | msgBufferS of messages and busy of boolean values, each of size WINSIZE . A variables windowS contains the size of the current window of unacknowledged messages. A new message can be produced only when windowS is less than WINSIZE .
References-found: 21

