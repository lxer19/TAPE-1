URL: ftp://ftp.cs.man.ac.uk/pub/TR/UMCS-98-6-1-robertson.ps.Z
Refering-URL: ftp://ftp.cs.man.ac.uk/pub/TR/UMCS-98-6-1.html
Root-URL: http://www.cs.man.ac.uk
Email: Email: dr@aisb.ed.ac.uk Email: agusti@iiia.csic.es  
Title: Pragmatics in the Synthesis of Logic Programs  
Author: Dave Robertson Jaume Agusti 
Address: Edinburgh, Campus UAB, 08193 Bellaterra, 80 South Bridge, Edinburgh Barcelona,  
Affiliation: yDept. of Artificial Intelligence, zIIIA (CSIC), University of  
Abstract: Many of the systems which we, and those who have worked with us, have built were intended to make it easier for people with particular backgrounds to construct and understand logic programs. A major issue when designing this sort of system is pragmatics: from the many logically equivalent ways of describing a program we must identify styles of description which make particular tasks easier to support. This paper describes three ways in which we have attempted to understand the pragmatics of particular domains using well known methods from computational logic. These are: design using parameterisable components; synthesis by incremental addition of program slices; and meta-interpretation. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> A. W. Bowles, D. Robertson, W. W. Vasconcelos, M. Vargas-Vera, and D. Bental. </author> <title> Applying Prolog Programming Techniques. </title> <journal> International Journal of Human-Computer Studies, </journal> <volume> 41(3) </volume> <pages> 329-350, </pages> <month> September </month> <year> 1994. </year> <note> Also as Research Paper 641, </note> <institution> Dept of Artificial Intelligence, University of Edinburgh. </institution>
Reference-contexts: In some cases it can be desirable to make such decisions explicit. For example: * In our use of techniques editing in supporting novice Prolog programmers <ref> [1] </ref> we worked at a fine level of detail but limited the diversity of the library used by novices so that the range of decisions they had to make was still small.
Reference: [2] <author> V. Brilhante. </author> <title> A system for representing uncertainty of evidence in ecological models. </title> <type> Technical report, </type> <institution> Department of Artificial Intelligence, University of Edinburgh, </institution> <year> 1995. </year> <note> MSc Thesis. </note>
Reference-contexts: Each of these parameters (and the equations connecting them to the 14 state variables) were obtained from different combinations of field data, physiological measurement and literature survey. Hence the context of the model is highly heterogeneous. Brilhante <ref> [2] </ref> reconstructed the BIONTE Carbon and Nitrogen sub-models using meta-interpretation to reproduce the equation solving strategy for simulation and confirmed that it produced results which closely matched the original model 2 .
Reference: [3] <author> T.S. Gegg-Harrison. </author> <title> Basic prolog schemata. </title> <type> Technical Report CS-1989-20, </type> <institution> Department of Computer Science, Duke University, </institution> <month> September </month> <year> 1989. </year>
Reference-contexts: We have been most strongly influenced by the style of development called "techniques editing", first explained in [6] and later elaborated by others (for example <ref> [3] </ref>). Our method of designing these systems is as follows: * We identify the basic flows of control (often called "skeletons") which our target group of engineers will want to use. Each of these is defined by a set of clauses which define a predicate P of arity, n.
Reference: [4] <author> J. Goguen. </author> <booktitle> Principles of Parameterised Programming, </booktitle> <pages> pages 159-225. </pages> <publisher> Addison Wesley, </publisher> <year> 1989. </year>
Reference-contexts: Although generic notions of parameterisability exist within logic programming (e.g. [10]) and functional programming (e.g. <ref> [4] </ref>) we use more specific forms of parameterisation adequate for our applications. Our method of designing such systems is as follows: * We identify basic features of the domain which engineers use in order to select and instantiate standard patterns.
Reference: [5] <author> J. Hesketh, D. Robertson, N. Fuchs, and A. Bundy. </author> <title> Lightweight formalisation in support of requirements engineering. </title> <journal> Journal of Automated Software Engineering, </journal> <volume> 5(2) </volume> <pages> 183-210, </pages> <year> 1998. </year>
Reference-contexts: The specification is converted automatically to HTML via the Pillow translator (currently available from http://www.clip.dia.fi.upm.es). * A prototype system for connecting safety shutdown logic to segments of codes of design practice is described in <ref> [5] </ref>. In this case, the problem description, , is a set of formal descriptions of parts of the codes of practice. Each component (N; C; D; P ) defines a standard segment of the specification of the shutdown logic, where C relates D to .
Reference: [6] <author> M. Kirschenbaum, A. Lakhotia, and L.S. Sterling. </author> <title> Skeletons and techniques for prolog programming. </title> <type> Tr 89-170, </type> <institution> Case Western Reserve University, </institution> <year> 1989. </year>
Reference-contexts: We have been most strongly influenced by the style of development called "techniques editing", first explained in <ref> [6] </ref> and later elaborated by others (for example [3]). Our method of designing these systems is as follows: * We identify the basic flows of control (often called "skeletons") which our target group of engineers will want to use.
Reference: [7] <author> D. Robertson. </author> <title> Distributed specification. </title> <booktitle> In Proceedings of the 12th European Conference on Artificial Intelligence, </booktitle> <address> Budapest, Hungary, </address> <month> August </month> <year> 1996. </year>
Reference-contexts: The products of either of these two methods could be augmented by meta-interpretation of the sort described in Section 4. We are a long way from fully utilising this form of synergy but an example of what we can do with existing tools is given in <ref> [7] </ref>.
Reference: [8] <author> D. Robertson. </author> <title> An empirical study of the lss specification toolkit in use. </title> <booktitle> In Proceedings of the 8th International Conference on Software Engineering and Knowledge Engineering, </booktitle> <address> Nevada, USA. </address> <institution> Knowledge Systems Institute, Illinois, </institution> <year> 1996. </year> <note> ISBN 0-9641699-3-2. </note>
Reference-contexts: We have used this for more sizeable designs the largest being a reconstruction of the tool itself <ref> [8] </ref>. However, this sort of system can only be used by engineers who are trained in the use of logic programming techniques because the questions which one must answer in satisfying s and t can be sophisticated (such as the precise form of term deconstruction).
Reference: [9] <author> D. Robertson, A. Bundy, R. Muetzelfeldt, M. Haggith, and M Uschold. Eco-Logic: </author> <title> Logic-Based Approaches to Ecological Modelling. </title> <publisher> MIT Press (Logic Programming Series), </publisher> <year> 1991. </year> <note> ISBN 0-262-18143-6. </note>
Reference-contexts: ) ^ 8G:G 2 C ! ` G)g; (C; D; P n )) ^ parameterise (P r [ P n ; ; D r ) Our earliest use of this form of design was in constructing animal population models from problem descriptions couched in the terminology used by ecologists (see <ref> [9] </ref>). An example of a component (simplified from [9]) is determining whether two animals (A and B) are considered to be in proximity to each other at time point T . <p> (C; D; P n )) ^ parameterise (P r [ P n ; ; D r ) Our earliest use of this form of design was in constructing animal population models from problem descriptions couched in the terminology used by ecologists (see <ref> [9] </ref>). An example of a component (simplified from [9]) is determining whether two animals (A and B) are considered to be in proximity to each other at time point T .
Reference: [10] <author> D.T. Sannella and L.A. Wallen. </author> <title> A calculus for the construction of modular prolog programs. </title> <journal> Journal of Logic Programming, </journal> <volume> 12 </volume> <pages> 147-177, </pages> <year> 1992. </year>
Reference-contexts: Although generic notions of parameterisability exist within logic programming (e.g. <ref> [10] </ref>) and functional programming (e.g. [4]) we use more specific forms of parameterisation adequate for our applications. Our method of designing such systems is as follows: * We identify basic features of the domain which engineers use in order to select and instantiate standard patterns.
Reference: [11] <author> L.U. Yalcinalp and L.S. Sterling. </author> <title> Uncertainty reasoning in prolog with layered meta-interpreters. </title> <type> Technical Report TR 90-110, </type> <institution> Center for Automation and Intelligent Systems Research, Case Western Reserve University, Ohio, USA, </institution> <year> 1990. </year> <month> 8 </month>
Reference-contexts: A natural way of doing this in a logic programming style is through meta-interpretation. Different variants of this method of design exist but we have been most influenced by the ideas of layered meta-interpretation given in <ref> [11] </ref>. This type of meta-interpreter tends to be problem-specific so the method is best explained by a simplified example.
References-found: 11

