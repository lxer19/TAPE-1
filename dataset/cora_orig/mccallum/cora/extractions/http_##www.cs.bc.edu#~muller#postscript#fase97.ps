URL: http://www.cs.bc.edu/~muller/postscript/fase97.ps
Refering-URL: http://www.cs.bc.edu/~muller/papers.html
Root-URL: http://www.cs.bc.edu
Phone: 2  
Title: A Typed Intermediate Language for Flow-Directed Compilation  
Author: J. B. Wells ? Allyn Dimock Robert Muller and Franklyn Turbak 
Address: Boston MA 02215, USA  Cambridge MA 02138, USA 3 Boston College, Chestnut Hill MA 02167, USA 4 Wellesley College, Wellesley MA 02181, USA  
Affiliation: 1 Boston University,  Harvard University,  
Abstract: We present a typed intermediate language CIL for optimizing compilers for function-oriented and polymorphically typed programming languages (e.g., ML). The language CIL is a typed lambda calculus with product, sum, intersection, and union types as well as function types annotated with flow labels. A novel formulation of intersection and union types supports encoding flow information in the typed program representation. This flow information can direct optimization. 
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> A. S. Aiken and E. L. Wimmers. </author> <title> Type inclusion constraints and type inference. </title> <booktitle> In FPCA '93, Conf. Funct. Program. </booktitle> <publisher> Lang. Comput. Arch., </publisher> <pages> pp. 31-41. </pages> <publisher> ACM, </publisher> <year> 1993. </year>
Reference-contexts: General research into intersection types that has influenced our thinking includes the work of Van Bakel [4] and Jim [13]. Research on both intersection and union types that we have consulted includes the work by Pierce [20], Aiken, Wimmers, and Lakshman <ref> [1, 2] </ref>, Barbanera and Dezani-Ciancaglini [6], and Tri-fonov and Smith [29]. Of the above, only Pierce considers intersection and union types in an explicitly typed language.
Reference: 2. <author> A. S. Aiken, E. L. Wimmers, and T. K. Lakshman. </author> <title> Soft typing with conditional types. </title> <booktitle> In POPL '94 [22], </booktitle> <pages> pp. 163-173. </pages>
Reference-contexts: General research into intersection types that has influenced our thinking includes the work of Van Bakel [4] and Jim [13]. Research on both intersection and union types that we have consulted includes the work by Pierce [20], Aiken, Wimmers, and Lakshman <ref> [1, 2] </ref>, Barbanera and Dezani-Ciancaglini [6], and Tri-fonov and Smith [29]. Of the above, only Pierce considers intersection and union types in an explicitly typed language.
Reference: 3. <author> A. W. Appel. </author> <title> Compiling with Continuations. </title> <publisher> Cambridge University Press, </publisher> <year> 1992. </year>
Reference-contexts: Most typed intermediate languages for polymorphic programming languages can be seen as variants of the Girard/Reynolds -calculus, System F [9, 24]. Recent versions of the Standard ML of New Jersey (SML/NJ) compiler <ref> [3, 27] </ref> use a variant of system F as the representation in the front-end of the compiler. In SML/NJ, type inference annotates polymorphic functions with universally quan-tified types and annotates function applications with the simple types to which the polymorphic types are instantiated.
Reference: 4. <author> S. van Bakel. </author> <title> Intersection Type Disciplines in Lambda Calculus and Applicative Term Rewriting Systems. </title> <type> PhD thesis, </type> <institution> University of Nijmegen, </institution> <year> 1993. </year>
Reference-contexts: While it is clearly possible to compute, record, and use the flow and type information separately, we believe that a single representation is more natural for compilation. General research into intersection types that has influenced our thinking includes the work of Van Bakel <ref> [4] </ref> and Jim [13]. Research on both intersection and union types that we have consulted includes the work by Pierce [20], Aiken, Wimmers, and Lakshman [1, 2], Barbanera and Dezani-Ciancaglini [6], and Tri-fonov and Smith [29].
Reference: 5. <author> A. Banerjee. </author> <title> A modular, polyvariant, and type-based closure analysis. </title> <type> Manuscript, </type> <month> Nov. </month> <year> 1996. </year>
Reference-contexts: This paper introduces a typed intermediate language for optimizing compilers for higher-order polymorphic programming languages. Our intermediate language 1 CIL is an explicitly typed -calculus with product, sum, intersection, union as well as function types annotated with flow labels in the style of Heintze and Banerjee <ref> [12, 5] </ref>. The flow annotations on function types are sets of term labels that can encode control and data flow information as it would be computed by one of several typed flow analyses in the literature [12, 5]. <p> as function types annotated with flow labels in the style of Heintze and Banerjee <ref> [12, 5] </ref>. The flow annotations on function types are sets of term labels that can encode control and data flow information as it would be computed by one of several typed flow analyses in the literature [12, 5]. <p> Our flow labels encode information about the operational behavior of the program that cannot be obtained from types without flow labels. At the same time, intersection and union types support a natural encoding of polyvariant flow information <ref> [5] </ref>. While it is clearly possible to compute, record, and use the flow and type information separately, we believe that a single representation is more natural for compilation. General research into intersection types that has influenced our thinking includes the work of Van Bakel [4] and Jim [13].
Reference: 6. <author> F. Barbanera and M. Dezani-Ciancaglini. </author> <title> Intersection and union types: Syntax and semantics. </title> <journal> Information and Computation, </journal> <volume> 119 </volume> <pages> 202-230, </pages> <year> 1995. </year>
Reference-contexts: General research into intersection types that has influenced our thinking includes the work of Van Bakel [4] and Jim [13]. Research on both intersection and union types that we have consulted includes the work by Pierce [20], Aiken, Wimmers, and Lakshman [1, 2], Barbanera and Dezani-Ciancaglini <ref> [6] </ref>, and Tri-fonov and Smith [29]. Of the above, only Pierce considers intersection and union types in an explicitly typed language.
Reference: 7. <author> N. S. </author> <title> Bjorner. Minimal typing derivations. </title> <booktitle> In ACM SIGPLAN Workshop on ML and its Applications, </booktitle> <pages> pp. 120-126, </pages> <year> 1994. </year>
Reference-contexts: Typically the specialization approach is limited to non-escaping polymorphic functions where the required specializations of the definition are determined by its uses within the confines of a binding construct such as let <ref> [26, 7] </ref>. In CIL , the required specializations can be determined by the flow analysis. Escaping polymorphic functions can be specialized for their uses in textually remote parts of the program. <p> The compiler uses the type information to select efficient data representations and to minimize boxing coercions [16]. The SML/NJ compiler also uses minimal typing derivations <ref> [7] </ref> to reduce boxing coercions for let-polymorphic definitions. The compiler uses a simply typed representation in later stages of the compiler. The Glasgow Haskell Compiler (GHC) [15] also uses a variant of System F.
Reference: 8. <author> A. Dimock, R. Muller, F. Turbak, and J. B. Wells. </author> <title> Strongly typed flow-directed representation transformations (extended abstract). </title> <note> Submitted. See http://www.cs.bu.edu/groups/church, Nov. </note> <year> 1996. </year>
Reference-contexts: The sets OE and are sets of potential flow sources and sinks. The formulation of CIL allows flow information to be separated in a well typed manner to expose precise correspondences between sources and sinks of flow <ref> [8] </ref>. A -abstraction flowing to m application sites can be assigned an intersection type with m conjuncts. This is represented in CIL by m virtual copies of the term. In a dual manner, an application to which n abstractions might flow can be assigned a union type with n disjuncts. <p> It is also easier in CIL to provide multiple representations of a function for different types and for particular inputs. Inlining of functions can be performed even when multiple functions can flow to a call site. It can also be performed on open functions. This is further discussed in <ref> [8] </ref>. 2 Flow-Directed Program Transformation We informally illustrate the features of CIL in the context of closure conversion, a key program transformation in optimizing compilers for function-oriented and object-oriented languages [30, 17, 10]. Closure conversion transforms programs that may contain open functions into equivalent programs that contain only closed functions. <p> Every change from ^ to fi or _ to + may lead to a cascade of changes necesary to preserve well typedness and meaning. Our calculus aids in automatically handling these changes. Space does not permit us to specify the closure conversion transformations here; for details, see <ref> [8] </ref>. 3 Design Issues This section discusses some of the goals that guided the design of our language CIL and some of the technical challenges that had to be overcome. <p> The intermediate language is designed to facilitate verifiable flow-directed compiling. Based on CIL , we have developed a framework for typed-directed flow-based representation transformations, and have illustrated this framework in a closure conversion application that supports multiple function representations, including the inlining of open functions <ref> [8] </ref>. This application (informally sketched in section 2) is an example of how CIL supplies the compiler writer both important information and great flexibility in making optimization decisions. Below, we outline some of the work ahead.
Reference: 9. <institution> J.-Y. Girard. Interpretation Fonctionnelle et Elimination des Coupures de l'Arithmetique d'Ordre Superieur. These d'Etat, Universite de Paris VII, </institution> <year> 1972. </year>
Reference-contexts: Most typed intermediate languages for polymorphic programming languages can be seen as variants of the Girard/Reynolds -calculus, System F <ref> [9, 24] </ref>. Recent versions of the Standard ML of New Jersey (SML/NJ) compiler [3, 27] use a variant of system F as the representation in the front-end of the compiler.
Reference: 10. <author> J. Hannan. </author> <title> Type systems for closure conversion. </title> <booktitle> In Workshop on Types for Program Analysis, </booktitle> <pages> pp. 48-62, </pages> <year> 1995. </year> <note> DAIMI PB-493. </note>
Reference-contexts: It can also be performed on open functions. This is further discussed in [8]. 2 Flow-Directed Program Transformation We informally illustrate the features of CIL in the context of closure conversion, a key program transformation in optimizing compilers for function-oriented and object-oriented languages <ref> [30, 17, 10] </ref>. Closure conversion transforms programs that may contain open functions into equivalent programs that contain only closed functions.
Reference: 11. <author> R. Harper and G. Morrisett. </author> <title> Compiling polymorphism using intensional type analysis. </title> <booktitle> In Conf. Rec. 22nd Ann. ACM Symp. Principles of Programming Languages, </booktitle> <year> 1995. </year>
Reference-contexts: System F can also be seen as the basis of the typed intermediate language ML i of the TIL compiler for Standard ML [18, 17]. The calculus ML i is a pred-icative variant of System F extended with intensional polymorphism <ref> [11] </ref>. The key feature is the support for dynamic type dispatch at run-time. This aids in efficient compilation of polymorphism without sacrificing separate compilation. A use of a polymorphic function can dispatch on a type argument to yield a monomorphic routine suitable for the type.
Reference: 12. <author> N. Heintze. </author> <title> Control-flow analysis and type systems. </title> <booktitle> In Proc. 2nd Int'l Static Analysis Symp., </booktitle> <pages> pp. 189-206, </pages> <year> 1995. </year>
Reference-contexts: This paper introduces a typed intermediate language for optimizing compilers for higher-order polymorphic programming languages. Our intermediate language 1 CIL is an explicitly typed -calculus with product, sum, intersection, union as well as function types annotated with flow labels in the style of Heintze and Banerjee <ref> [12, 5] </ref>. The flow annotations on function types are sets of term labels that can encode control and data flow information as it would be computed by one of several typed flow analyses in the literature [12, 5]. <p> as function types annotated with flow labels in the style of Heintze and Banerjee <ref> [12, 5] </ref>. The flow annotations on function types are sets of term labels that can encode control and data flow information as it would be computed by one of several typed flow analyses in the literature [12, 5].
Reference: 13. <author> T. Jim. </author> <title> What are principal typings and what are they good for? In POPL '96 [23]. </title>
Reference-contexts: Our intermediate language CIL was inspired by the earlier work on rank-2 intersection types of Jim <ref> [13] </ref>. As we have shown in this paper, intersection types naturally lead to a flow-directed approach to compilation. Our flow labels encode information about the operational behavior of the program that cannot be obtained from types without flow labels. <p> While it is clearly possible to compute, record, and use the flow and type information separately, we believe that a single representation is more natural for compilation. General research into intersection types that has influenced our thinking includes the work of Van Bakel [4] and Jim <ref> [13] </ref>. Research on both intersection and union types that we have consulted includes the work by Pierce [20], Aiken, Wimmers, and Lakshman [1, 2], Barbanera and Dezani-Ciancaglini [6], and Tri-fonov and Smith [29]. Of the above, only Pierce considers intersection and union types in an explicitly typed language.
Reference: 14. <author> M. P. Jones. </author> <title> Dictionary-free overloading by partial evaluation. </title> <booktitle> In ACM SIGPLAN Workshop on Partial Eval. & Semantics-Based Prog. Manipulation, </booktitle> <year> 1994. </year>
Reference-contexts: Specialization not only avoids the overhead of boxing but more importantly enables subsequent optimizations such as inlining and common subexpression elimination. Empirical evidence suggests that the optimizations enabled by specialization can actually lead to smaller object programs than alternative approaches <ref> [14] </ref>. Typically the specialization approach is limited to non-escaping polymorphic functions where the required specializations of the definition are determined by its uses within the confines of a binding construct such as let [26, 7]. In CIL , the required specializations can be determined by the flow analysis.
Reference: 15. <author> S. L. P. Jones. </author> <title> Compiling Haskell by program transformation: a report from the trenches. </title> <booktitle> In Proc. European Symp. on Programming, </booktitle> <year> 1996. </year>
Reference-contexts: This invariant can be observed if the input program is well typed and each compiler transformation changes the intermediate representation and its typing in a consistent way. This approach requires using one or more typed intermediate languages. Explicitly typed intermediate languages offer several benefits to the compiler writer <ref> [15, 18, 26, 19] </ref>. First, type information can guide program analyses and transformations. Second, some applications need accurate type information at run-time thereby requiring the compiler to preserve it. Finally, typed intermediate languages are useful as a debugging aid in the compiler development process. <p> The SML/NJ compiler also uses minimal typing derivations [7] to reduce boxing coercions for let-polymorphic definitions. The compiler uses a simply typed representation in later stages of the compiler. The Glasgow Haskell Compiler (GHC) <ref> [15] </ref> also uses a variant of System F. In GHC, type inference annotates polymorphic functions with type abstractions and uses of polymorphic functions with type arguments. This allows the compiler to preserve the well-typedness of the intermediate representation across program transformations.
Reference: 16. <author> X. Leroy. </author> <title> Unboxed objects and polymorphic typing. </title> <booktitle> In Conf. Rec. 19th Ann. ACM Symp. Principles of Programming Languages, </booktitle> <pages> pp. 177-188, </pages> <year> 1992. </year>
Reference-contexts: In SML/NJ, type inference annotates polymorphic functions with universally quan-tified types and annotates function applications with the simple types to which the polymorphic types are instantiated. The compiler uses the type information to select efficient data representations and to minimize boxing coercions <ref> [16] </ref>. The SML/NJ compiler also uses minimal typing derivations [7] to reduce boxing coercions for let-polymorphic definitions. The compiler uses a simply typed representation in later stages of the compiler. The Glasgow Haskell Compiler (GHC) [15] also uses a variant of System F.
Reference: 17. <author> Y. Minamide, G. Morrisett, and R. Harper. </author> <title> Typed closure conversion. </title> <note> In POPL '96 [23]. </note>
Reference-contexts: It can also be performed on open functions. This is further discussed in [8]. 2 Flow-Directed Program Transformation We informally illustrate the features of CIL in the context of closure conversion, a key program transformation in optimizing compilers for function-oriented and object-oriented languages <ref> [30, 17, 10] </ref>. Closure conversion transforms programs that may contain open functions into equivalent programs that contain only closed functions. <p> The type information is used in the later stages of the compiler to improve code generation. System F can also be seen as the basis of the typed intermediate language ML i of the TIL compiler for Standard ML <ref> [18, 17] </ref>. The calculus ML i is a pred-icative variant of System F extended with intensional polymorphism [11]. The key feature is the support for dynamic type dispatch at run-time. This aids in efficient compilation of polymorphism without sacrificing separate compilation.
Reference: 18. <author> G. Morrisett. </author> <title> Compiling with Types. </title> <type> PhD thesis, </type> <institution> Carnegie Mellon University, </institution> <year> 1995. </year>
Reference-contexts: This invariant can be observed if the input program is well typed and each compiler transformation changes the intermediate representation and its typing in a consistent way. This approach requires using one or more typed intermediate languages. Explicitly typed intermediate languages offer several benefits to the compiler writer <ref> [15, 18, 26, 19] </ref>. First, type information can guide program analyses and transformations. Second, some applications need accurate type information at run-time thereby requiring the compiler to preserve it. Finally, typed intermediate languages are useful as a debugging aid in the compiler development process. <p> The type information is used in the later stages of the compiler to improve code generation. System F can also be seen as the basis of the typed intermediate language ML i of the TIL compiler for Standard ML <ref> [18, 17] </ref>. The calculus ML i is a pred-icative variant of System F extended with intensional polymorphism [11]. The key feature is the support for dynamic type dispatch at run-time. This aids in efficient compilation of polymorphism without sacrificing separate compilation.
Reference: 19. <author> S. Peyton Jones and E. Meijer. Henk: </author> <title> A typed intermediate language. </title> <note> Submitted, </note> <month> Jan. </month> <year> 1997. </year>
Reference-contexts: This invariant can be observed if the input program is well typed and each compiler transformation changes the intermediate representation and its typing in a consistent way. This approach requires using one or more typed intermediate languages. Explicitly typed intermediate languages offer several benefits to the compiler writer <ref> [15, 18, 26, 19] </ref>. First, type information can guide program analyses and transformations. Second, some applications need accurate type information at run-time thereby requiring the compiler to preserve it. Finally, typed intermediate languages are useful as a debugging aid in the compiler development process.
Reference: 20. <author> B. C. Pierce. </author> <title> Programming with intersection types, union types, and polymorphism. </title> <type> Technical Report CMU-CS-91-106, </type> <institution> Carnegie Mellon University, </institution> <month> Feb. </month> <year> 1991. </year>
Reference-contexts: Unfortunately, this method is not sufficient to represent dependencies between the types of nested variable bindings. Pierce gives a more general approach using a special term-level construct to bind a type variable to some set of types <ref> [20] </ref>. For example, using this method the term (x:y:x) could be annotated as (for ff 2 foe; o g:x: ff:y: ff:x) to have the type (oe ! oe ! oe) ^ (o ! o ! o ). <p> General research into intersection types that has influenced our thinking includes the work of Van Bakel [4] and Jim [13]. Research on both intersection and union types that we have consulted includes the work by Pierce <ref> [20] </ref>, Aiken, Wimmers, and Lakshman [1, 2], Barbanera and Dezani-Ciancaglini [6], and Tri-fonov and Smith [29]. Of the above, only Pierce considers intersection and union types in an explicitly typed language.
Reference: 21. <editor> Proc. </editor> <booktitle> ACM SIGPLAN '95 Conf. Prog. Language Design & Implementation, </booktitle> <year> 1995. </year>
Reference: 22. <editor> Conf. </editor> <booktitle> Rec. 21st Ann. ACM Symp. Principles of Programming Languages, </booktitle> <year> 1994. </year>
Reference: 23. <editor> Conf. </editor> <booktitle> Rec. POPL '96: 23rd ACM Symp. Principles of Prog. Languages, </booktitle> <year> 1996. </year>
Reference: 24. <author> J. C. Reynolds. </author> <title> Towards a theory of type structure. </title> <booktitle> In Colloque sur la Programmation, vol. 19 of LNCS, </booktitle> <pages> pp. 408-425, </pages> <address> Paris, France, 1974. </address> <publisher> Springer-Verlag. </publisher>
Reference-contexts: Most typed intermediate languages for polymorphic programming languages can be seen as variants of the Girard/Reynolds -calculus, System F <ref> [9, 24] </ref>. Recent versions of the Standard ML of New Jersey (SML/NJ) compiler [3, 27] use a variant of system F as the representation in the front-end of the compiler.
Reference: 25. <author> J. C. Reynolds. </author> <title> Design of the programming language Forsythe. </title> <editor> In P. O'Hearn and R. D. Tennent, eds., </editor> <booktitle> Algol-like Languages. </booktitle> <publisher> Birkhauser, </publisher> <year> 1996. </year>
Reference-contexts: M 1 : oe; A ` M 2 : o ; M 1 and M 2 are "the same modulo type annotations"; M 3 is the "combination" of M 1 and M 2 A ` M 3 : oe ^ o The approach used by Reynolds in the language Forsythe <ref> [25] </ref> annotates the binding of an abstraction (x:M ) with a list of types as in (x: oe 1 j joe n :M ), requires the body M of the abstraction to be typable with the same type o for each possible type oe i of the bound variable x, and
Reference: 26. <author> Z. Shao. </author> <title> Compiling Standard ML for Efficient Execution on Modern Machines. </title> <type> PhD thesis, </type> <institution> Princeton University, </institution> <year> 1994. </year>
Reference-contexts: This invariant can be observed if the input program is well typed and each compiler transformation changes the intermediate representation and its typing in a consistent way. This approach requires using one or more typed intermediate languages. Explicitly typed intermediate languages offer several benefits to the compiler writer <ref> [15, 18, 26, 19] </ref>. First, type information can guide program analyses and transformations. Second, some applications need accurate type information at run-time thereby requiring the compiler to preserve it. Finally, typed intermediate languages are useful as a debugging aid in the compiler development process. <p> Typically the specialization approach is limited to non-escaping polymorphic functions where the required specializations of the definition are determined by its uses within the confines of a binding construct such as let <ref> [26, 7] </ref>. In CIL , the required specializations can be determined by the flow analysis. Escaping polymorphic functions can be specialized for their uses in textually remote parts of the program.
Reference: 27. <author> Z. Shao and A. Appel. </author> <title> A type-based compiler for Standard ML. </title> <note> In PLDI '95 [21]. </note>
Reference-contexts: Most typed intermediate languages for polymorphic programming languages can be seen as variants of the Girard/Reynolds -calculus, System F [9, 24]. Recent versions of the Standard ML of New Jersey (SML/NJ) compiler <ref> [3, 27] </ref> use a variant of system F as the representation in the front-end of the compiler. In SML/NJ, type inference annotates polymorphic functions with universally quan-tified types and annotates function applications with the simple types to which the polymorphic types are instantiated.
Reference: 28. <author> D. Tarditi, G. Morrisett, P. Cheng, C. Stone, R. Harper, and P. Lee. </author> <title> TIL: A type-directed optimizing compiler for ML. </title> <note> In PLDI '95 [21]. </note>
Reference-contexts: This aids in efficient compilation of polymorphism without sacrificing separate compilation. A use of a polymorphic function can dispatch on a type argument to yield a monomorphic routine suitable for the type. This approach to compiling poly-morphism yields excellent results <ref> [28] </ref> since many type dispatch redexes can be eliminated at compile-time and the compiler can then gain the resulting benefits of type specialization including in-lining and common subexpression elimination. Our intermediate language CIL was inspired by the earlier work on rank-2 intersection types of Jim [13].
Reference: 29. <author> V. Trifonov and S. Smith. </author> <title> Subtyping constrained types. </title> <note> Revised Draft, </note> <month> May </month> <year> 1996. </year>
Reference-contexts: Research on both intersection and union types that we have consulted includes the work by Pierce [20], Aiken, Wimmers, and Lakshman [1, 2], Barbanera and Dezani-Ciancaglini [6], and Tri-fonov and Smith <ref> [29] </ref>. Of the above, only Pierce considers intersection and union types in an explicitly typed language.
Reference: 30. <author> M. Wand and P. Steckler. </author> <title> Selective and lightweight closure conversion. </title> <booktitle> In POPL '94 [22], </booktitle> <pages> pp. 435-445. </pages>
Reference-contexts: It can also be performed on open functions. This is further discussed in [8]. 2 Flow-Directed Program Transformation We informally illustrate the features of CIL in the context of closure conversion, a key program transformation in optimizing compilers for function-oriented and object-oriented languages <ref> [30, 17, 10] </ref>. Closure conversion transforms programs that may contain open functions into equivalent programs that contain only closed functions. <p> The function 1 f3;4g is already closed, so it is desirable to represent it as a function (not a closure) and to keep @ f1g 3 as a regular function application (not a closure application). This optimization is called selective closure conversion <ref> [30] </ref>. However, since 1 f3;4g also flows to @ f1;2g 4 along with the open function 2 f4g , something must be done to ensure that the protocols at the call sites are consistent with the function representations that flow to them.
Reference: 31. <author> J. B. Wells. </author> <title> Intersection types revisited in the Church style. </title> <type> Manuscript, </type> <month> June </month> <year> 1996. </year> <title> This article was processed using the L A T E X macro package with LLNCS style </title>
Reference-contexts: A difficulty this introduces is that reduction must essentially work on typing derivations, which is non-trivial to formulate. Wells <ref> [31] </ref> has developed an alternative formulation where typed and untyped terms have essentially the same tree structure, but the reduction rules are quite complex. Difficulties with Union Types: It is difficult to formulate an implicitly typed calculus with union types which has the subject-reduction property. <p> Our current language duplicates terms when it duplicates types. While this language is conceptually convenient for specification, for implementation purposes a considerable size savings can be obtained by using a typed calculus with intersection and union types in the style of <ref> [31] </ref>.
References-found: 31

