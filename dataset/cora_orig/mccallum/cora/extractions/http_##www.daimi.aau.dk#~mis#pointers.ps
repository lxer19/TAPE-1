URL: http://www.daimi.aau.dk/~mis/pointers.ps
Refering-URL: http://www.daimi.aau.dk/~mis/papers.html
Root-URL: http://www.daimi.aau.dk
Title: Automatic Verification of Pointer Programs using Monadic Second-Order Logic  
Author: Jakob L. Jensen Michael E. Jorgensen Nils Klarlund Michael I. Schwartzbach 
Address: New Jersey  
Affiliation: BRICS, University of Aarhus AT&T Research,  
Abstract: We present a technique for automatic verification of pointer programs based on a decision procedure for the monadic second-order logic on finite strings. We are concerned with a while-fragment of Pascal, which includes recursively-defined pointer structures but excludes pointer arithmetic. We define a logic of stores with interesting basic predicates such as pointer equality, tests for nil pointers, and garbage cells, as well as reachability along pointers. We present a complete decision procedure for Hoare triples based on this logic over loop-free code. Combined with explicit loop invariants, the decision procedure allows us to answer surprisingly detailed questions about small but non-trivial programs. If a program fails to satisfy a certain property, then we can automatically supply an initial store that provides a counterexample. Our technique has been fully and efficiently implemented for linear linked lists, and it extends in principle to tree structures. The resulting system can be used to verify extensive properties of smaller pointer programs and could be particularly useful in a teaching environment. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Randal E. Bryant. </author> <title> Graph-based algorithms for Boolean function manipulation. </title> <journal> IEEE Transactions on Computers, </journal> <month> August </month> <year> 1986. </year>
Reference-contexts: Mona is an engine that reduces an M2L formula to an equivalent finite state automaton. Fido is a high-level specification notation that generates primitive Mona formulas. The implementation of Mona is feasible because of a special representation of automata, where transition functions are encoded as binary decision diagrams <ref> [1] </ref> (BDDs). Corresponding to this representation, specialized algorithms for the basic automata operations have been developed. As a result, Mona may efficiently reduce automata with very large alphabets, such as those we encounter in our application.
Reference: [2] <author> Michael Burke, Paul Carini, Jong-Deok Choi, and Michael Hind. </author> <title> Flow-insensitive interprocedural alias analysis in the presence of pointers. </title> <booktitle> In of the 7th International on Languages and Compilers for Parallel Computing, number 892 in Lecture Notes in Computer Science, </booktitle> <month> August </month> <year> 1994. </year>
Reference-contexts: A more abstract contribution is to identify and exploit an important niche of finite state regularity in programming language semantics. Related Work Our work does not follow the established tradition of conventional heap-based pointer analysis <ref> [8, 9, 20, 4, 5, 19, 16, 22, 2] </ref>, which develops specialized algorithms for answering specific questions about preexisting programs without annotations.
Reference: [3] <author> David L. Detlefs. </author> <title> An overview of the Extended Static Checking system. </title> <booktitle> In Proceedings of The First Workshop on Formal Methods in Software Practice. ACM SIGSOFT, </booktitle> <month> January </month> <year> 1996. </year> <month> 8 </month>
Reference-contexts: Also, the use of Hoare triples allows a modular analysis of programs. However, we are less general in requiring programs to be explicitly annotated with formulas and invariants; also, the present implementation handles only list structures. Most similar in spirit is the ESC system <ref> [3] </ref>, which also uses a restricted specification logic, requires explicit annotation with formulas and invariants, and generates counterexamples. A principal difference is in the questions that can be phrased.
Reference: [4] <author> Alain Deutsch. </author> <title> Interprocedural may-alias analysis for pointers: Beyond k-limiting. </title> <booktitle> In of the ACM SIGPLAN '94 on Programming Language Design and Implementation, </booktitle> <month> June </month> <year> 1994. </year>
Reference-contexts: A more abstract contribution is to identify and exploit an important niche of finite state regularity in programming language semantics. Related Work Our work does not follow the established tradition of conventional heap-based pointer analysis <ref> [8, 9, 20, 4, 5, 19, 16, 22, 2] </ref>, which develops specialized algorithms for answering specific questions about preexisting programs without annotations.
Reference: [5] <author> Alain Deutsch. </author> <title> Semantic models and abstract interpretation techniques for inductive data structures and pointers. </title> <booktitle> In of the ACM SIGPLAN on Partial Evaluation and Semantics-Based Program Manipulation (PEPM), </booktitle> <month> June </month> <year> 1995. </year>
Reference-contexts: A more abstract contribution is to identify and exploit an important niche of finite state regularity in programming language semantics. Related Work Our work does not follow the established tradition of conventional heap-based pointer analysis <ref> [8, 9, 20, 4, 5, 19, 16, 22, 2] </ref>, which develops specialized algorithms for answering specific questions about preexisting programs without annotations.
Reference: [6] <author> David Evans, John Guttag, Jim Horning, and Yang Meng Tan. LCLint: </author> <title> A tool for using specifications to check code. </title> <booktitle> In Proceedings of Symposium on the Foundations of Software Engineering. ACM SIG-SOFT, </booktitle> <month> December </month> <year> 1994. </year>
Reference-contexts: In contrast, we annotate Pascal programs with assertions in a formal logic, very similar to what is taught in elementary programming classes at college level. In [18] algorithms are provided that sometimes will infer when pointers are parts of list and trees. The system LCLint <ref> [6] </ref> uses simple annotations and a fast, incomplete decision procedure to detect certain dynamic memory errors in C programs. In comparison, our technique is more detailed but restricted to a simpler store model. The present work is also related to reasoning about program equivalence.
Reference: [7] <author> Pascal Fradet and Daniel Le Metayer. </author> <title> Shape types. </title> <booktitle> In Proc. 24th Symp. on Princ. of Prog. Lang., </booktitle> <pages> pages 27-37. </pages> <publisher> ACM, </publisher> <year> 1997. </year>
Reference-contexts: The two approaches are incomparable in their ambitions. For loop-free code we provide a complete, model-theoretic BDD-based decision procedure, whereas ESC relies on an incomplete theorem prover. Another recent, similar approach describes data structures by shape types, which are graph grammar expressions <ref> [7] </ref>. Shape types can be embedded in an imperative programming language, and values of shape types can be updated by rather elementary operations such that it can be verified that shape invariance holds automatically under certain restrictions.
Reference: [8] <author> Rakesh Ghiya and Laurie J. Hendren. </author> <title> Is it a Tree, a DAG, or a Cyclic Graph? A shape analysis for heap-directed pointers in C. </title> <booktitle> In the 23rd ACM SIGPLAN-SIGACT on Principles of Programming Languages, </booktitle> <month> January </month> <year> 1996. </year>
Reference-contexts: A more abstract contribution is to identify and exploit an important niche of finite state regularity in programming language semantics. Related Work Our work does not follow the established tradition of conventional heap-based pointer analysis <ref> [8, 9, 20, 4, 5, 19, 16, 22, 2] </ref>, which develops specialized algorithms for answering specific questions about preexisting programs without annotations.
Reference: [9] <author> Laurie J. Hendren and Alexandru Nicolau. </author> <title> Parallelizing programs with recursive data structures. </title> <journal> IEEE TPDS, </journal> <volume> 1(1) </volume> <pages> 35-47, </pages> <month> January </month> <year> 1990. </year>
Reference-contexts: A more abstract contribution is to identify and exploit an important niche of finite state regularity in programming language semantics. Related Work Our work does not follow the established tradition of conventional heap-based pointer analysis <ref> [8, 9, 20, 4, 5, 19, 16, 22, 2] </ref>, which develops specialized algorithms for answering specific questions about preexisting programs without annotations.
Reference: [10] <author> Jesper Gulmann Henriksen, Michael Jorgensen, Jakob Jensen, Nils Klarlund, Bob Paige, Theis Rauhe, and Anders Sandholm. Mona: </author> <title> Monadic second-order logic in practice. </title> <booktitle> In Proceedings TACAS'95, LNCS 1019, </booktitle> <month> May </month> <year> 1995. </year>
Reference-contexts: The net effect is to produce a (possibly huge) M2L formula whose validity coincides with validity of the given triple. 7 Using Fido and Mona The M2L approach is fruitful because of the Fido and Mona tools that implement this logic for finite strings and trees <ref> [10, 15] </ref>. Mona is an engine that reduces an M2L formula to an equivalent finite state automaton. Fido is a high-level specification notation that generates primitive Mona formulas.
Reference: [11] <author> Jakob Jensen and Michael Jorgensen. M.sc. </author> <type> thesis. </type> <year> 1996. </year>
Reference-contexts: With another BDD-package developed at the University of Aarhus and a more modern machine, the running times would likely be ten times faster [12]. Also, the calculations of the weakest preconditions can be sped up, sometimes several hundred times, on the examples considered here <ref> [11] </ref>. 7 Conclusions We have demonstrated that small programs in our Pascal subset can be verified with great accuracy. Our decision procedure exploits a new approach to pointer analysis by modeling stores as strings and reducing the problem to validity of formulas in monadic second-order logic.
Reference: [12] <author> N Klarlund and T. Rauhe. </author> <title> Bdd algorithms and cache misses. </title> <type> Technical report, BRICS Report Series RS-96-5, </type> <institution> Department of Computer Science, University of Aarhus, </institution> <year> 1996. </year>
Reference-contexts: The times reported here are for an implementation of Mona in ML running on a Sparc 1000. With another BDD-package developed at the University of Aarhus and a more modern machine, the running times would likely be ten times faster <ref> [12] </ref>. Also, the calculations of the weakest preconditions can be sped up, sometimes several hundred times, on the examples considered here [11]. 7 Conclusions We have demonstrated that small programs in our Pascal subset can be verified with great accuracy.
Reference: [13] <author> Nils Klarlund and Michael I. Schwartzbach. </author> <title> Graph types. </title> <booktitle> In the Twentieth Annual ACM SIGPLAN-SIGACT on Principles of Programming Languages, </booktitle> <month> January </month> <year> 1993. </year> <note> Available through http://www.brics.dk/klarlund/MonaFido/papers. </note>
Reference-contexts: . . . cell term variables A formula is built from basic predicates and the usual con nectives: ::= C 1 = C 2 cell equality C 1 &lt;R&gt; C 2 routing relation ~ negation 1 & 2 conjunction ex ff: existential quantification over cells A routing relation (introduced in <ref> [13] </ref>) is a binary relation on cells: R ::= n traverse an n-pointer (T:v)? test for type and variant nil? test for the nil cell garb? test for a garbage cell R 1 . <p> Thus it is an open question whether our analysis can be made to work for trees in practice. Can we go beyond trees? Some extensions are possible, specifically along the lines of graph types <ref> [13] </ref>, which include doubly-linked and cyclic structures. However, this extension requires an invasive modification of the Pascal syntax. Also, there are clear limitations; for example, on grid structures the store logic is no longer decidable.
Reference: [14] <author> Nils Klarlund and Michael I. Schwartzbach. </author> <title> Graphs and decidable transductions based on edge constraints. </title> <booktitle> In Proc. CAAP' 94 (TAPSOFT), </booktitle> <year> 1994. </year>
Reference-contexts: The present work is also related to reasoning about program equivalence. For example, [17] provides a sound and complete proof system for a simple lisp-like language that manipulates memory cells. Our previous work on decidable graph transductions <ref> [14] </ref> describes the theoretical foundations for our current approach and for several generalizations. 2 The Pascal Subset We consider a subset of the Pascal language, which has been restricted for reasons of both presentation and necessity. First, we have chosen Pascal rather than e.g. <p> There are of course subtle details to this approach that are not explained here; however, the formal foundations for the general case of trees are presented in <ref> [14] </ref>. Encoding Stores To encode a single store as a string, we need a suitable alphabet, called the store alphabet. A single alphabet symbol will consist of both a label and a bitmap.
Reference: [15] <author> Nils Klarlund and Michael I. Schwartzbach. </author> <title> Regularity = Logic + Recursive Data Types. </title> <type> BRICS, </type> <institution> University of Aarhus, </institution> <month> October </month> <year> 1996. </year>
Reference-contexts: The net effect is to produce a (possibly huge) M2L formula whose validity coincides with validity of the given triple. 7 Using Fido and Mona The M2L approach is fruitful because of the Fido and Mona tools that implement this logic for finite strings and trees <ref> [10, 15] </ref>. Mona is an engine that reduces an M2L formula to an equivalent finite state automaton. Fido is a high-level specification notation that generates primitive Mona formulas.
Reference: [16] <author> William Landi and Barbara G. Ryder. </author> <title> A safe approximate algorithm for interprocedural pointer aliasing. </title> <booktitle> In of the ACM SIGPLAN '92 on Programming Language Design and Implementation, </booktitle> <month> June </month> <year> 1992. </year>
Reference-contexts: A more abstract contribution is to identify and exploit an important niche of finite state regularity in programming language semantics. Related Work Our work does not follow the established tradition of conventional heap-based pointer analysis <ref> [8, 9, 20, 4, 5, 19, 16, 22, 2] </ref>, which develops specialized algorithms for answering specific questions about preexisting programs without annotations.
Reference: [17] <author> Ian Mason and Carolyn Talcott. </author> <title> Inferring the equivalence of functional programs that mutate data. </title> <journal> Theoretical Computer Science, </journal> <volume> 105 </volume> <pages> 167-215, </pages> <year> 1992. </year>
Reference-contexts: The system LCLint [6] uses simple annotations and a fast, incomplete decision procedure to detect certain dynamic memory errors in C programs. In comparison, our technique is more detailed but restricted to a simpler store model. The present work is also related to reasoning about program equivalence. For example, <ref> [17] </ref> provides a sound and complete proof system for a simple lisp-like language that manipulates memory cells.
Reference: [18] <author> Aki Matsumoto, D.S. Han, and Takao Tsuda. </author> <title> Alias analysis of pointers in Pascal and Fortran 90: dependence analysis between pointer references. </title> <journal> Acta Infor-matica, </journal> <volume> 33 </volume> <pages> 99-130, </pages> <year> 1996. </year>
Reference-contexts: In contrast, we annotate Pascal programs with assertions in a formal logic, very similar to what is taught in elementary programming classes at college level. In <ref> [18] </ref> algorithms are provided that sometimes will infer when pointers are parts of list and trees. The system LCLint [6] uses simple annotations and a fast, incomplete decision procedure to detect certain dynamic memory errors in C programs.
Reference: [19] <author> John Plevyak, Andrew A. Chien, and Vijay Karam-cheti. </author> <title> Analysis of dynamic structures for efficient parallel execution. </title> <booktitle> In of the 6th International on Languages and Compilers for Parallel Computing, number 768 in Lecture Notes in Computer Science, </booktitle> <month> August </month> <year> 1993. </year>
Reference-contexts: A more abstract contribution is to identify and exploit an important niche of finite state regularity in programming language semantics. Related Work Our work does not follow the established tradition of conventional heap-based pointer analysis <ref> [8, 9, 20, 4, 5, 19, 16, 22, 2] </ref>, which develops specialized algorithms for answering specific questions about preexisting programs without annotations.
Reference: [20] <author> Mooly Sagiv, Thomas Reps, and Reinhard Wilhelm. </author> <title> Solving shape-analysis problems in languages with destructive updating. </title> <booktitle> In the 23rd ACM SIGPLAN-SIGACT on Principles of Programming Languages, </booktitle> <month> January </month> <year> 1996. </year>
Reference-contexts: A more abstract contribution is to identify and exploit an important niche of finite state regularity in programming language semantics. Related Work Our work does not follow the established tradition of conventional heap-based pointer analysis <ref> [8, 9, 20, 4, 5, 19, 16, 22, 2] </ref>, which develops specialized algorithms for answering specific questions about preexisting programs without annotations.
Reference: [21] <author> Wolfgang Thomas. </author> <title> Automata on infinite objects. </title> <editor> In J. van Leeuwen, editor, </editor> <booktitle> Handbook of Theoretical Computer Science, </booktitle> <volume> volume B, </volume> <pages> pages 133-191. </pages> <publisher> MIT Press/Elsevier, </publisher> <year> 1990. </year>
Reference-contexts: We have a unifying framework for expressing all these tasks. Using Monadic Second-Order Logic Our implementation is based on the monadic second-order logic on finite strings (M2L), which is an inordinately succinct notation for specifying regular sets <ref> [21] </ref>. It uses formulas similar to but more general than those of our store logic. It turns out to be a straightforward task to inductively translate formulas of our store logic into equivalent formulas of M2L. The regular set is then represented by an M2L formula.
Reference: [22] <author> Robert P. Wilson and Monica S. Lam. </author> <title> Efficient context-sensitive pointer analysis for C programs. </title> <booktitle> In of the ACM SIGPLAN '95 on Programming Language Design and Implementation, </booktitle> <month> June </month> <year> 1995. </year> <month> 9 </month>
Reference-contexts: A more abstract contribution is to identify and exploit an important niche of finite state regularity in programming language semantics. Related Work Our work does not follow the established tradition of conventional heap-based pointer analysis <ref> [8, 9, 20, 4, 5, 19, 16, 22, 2] </ref>, which develops specialized algorithms for answering specific questions about preexisting programs without annotations.
References-found: 22

