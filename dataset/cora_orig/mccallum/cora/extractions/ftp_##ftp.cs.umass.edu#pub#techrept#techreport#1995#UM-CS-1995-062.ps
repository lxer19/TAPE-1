URL: ftp://ftp.cs.umass.edu/pub/techrept/techreport/1995/UM-CS-1995-062.ps
Refering-URL: http://laser.cs.umass.edu/abstracts/95-062.html
Root-URL: 
Title: Data Flow Analysis Frameworks for Concurrent Programs  
Author: Matthew B. Dwyer 
Note: 1fl This work was supported by the Advanced Research Projects Agency under Grant F30602-94-C-0137.  
Address: Amherst  
Affiliation: Department of Computer Science University of Massachusetts,  
Abstract: Data flow analysis is a well studied family of static program analyses. A rich theoretical basis for data flow analysis has been developed. Central to this theory is the concept of data flow framework. These frameworks are a semantically well-founded formalism for specifying a data flow analysis. A variety of solution algorithms for problems specified as data flow frameworks have been developed. The bulk of the research on data flow analysis has been done in the context of analysis of sequential programs. Unfortunately, a number of important assumptions of this work are violated when we apply data flow analysis results to concurrent programs. In this paper, we extend data flow frameworks for sequential program analysis to accommodate concurrent programs. We present solution algorithms for these extended frameworks and reason about their convergence and complexity. 
Abstract-found: 1
Intro-found: 1
Reference: [ASU85] <author> Alfred V. Aho, Ravi Sethi, and Jeffrey D. Ullman. </author> <booktitle> Compilers, Principles, Techniques, and Tools. </booktitle> <publisher> Addison-Wesley, </publisher> <year> 1985. </year> <month> 18 </month>
Reference-contexts: For such graphs, the MOP is no longer the best possible solution; in fact, it can be quite imprecise. Consider a classic any-path forward-flow data flow analysis problem such as reaching definitions <ref> [ASU85] </ref>. A definition of variable v at node d is said to reach a use at node u if there exists a path from d to u on which d is not killed, i.e., v is not re-defined.
Reference: [CC77] <author> P. Cousot and R. Cousot. </author> <title> Abstract interpretation: A unified lattice model for static analysis of programs by construction or approximation of fixpoints. </title> <booktitle> In Conference Record of the Fourth Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 238-252, </pages> <year> 1977. </year>
Reference-contexts: The bulk of this work has been for sequential programs. The development of data flow frameworks by Kildall [Kil73] marked the beginning of a new era in compiler optimization. Setting data flow analysis on a sound formal foundation spurred a wealth of research into both generalizing, e.g., <ref> [KU77, CC77, GW76, Tar81] </ref> and specializing Kildall's result, e.g., [KU76, WZ91, Tar81]. This resulted in formalisms for specifying and classifying data flow analysis problems, and the development of algorithms for solving any problem in a given class.
Reference: [CK93] <author> S.C. Cheung and J. Kramer. </author> <title> Tractable flow analysis for anomaly detection in distributed programs. </title> <booktitle> In Proceedings of the European Software Engineering Conference, </booktitle> <year> 1993. </year>
Reference-contexts: Note that, for this problem, &gt; = N and ? = ;. An instance of this framework is defined as (G; M ) where M (n) = f n . For concurrent programs we are also interested in gathering statement precedence information <ref> [CKS90, CK93, DS91, GS93, Mas93] </ref>. Unfortunately, using Dom information often yields an overly pessimistic safe approximation. Recall the example concurrent flow graph in Figure 1.
Reference: [CKS90] <author> David Callahan, Ken Kennedy, and Jaspal Subhlok. </author> <title> Analysis of event synchronization in a parallel programming tool. </title> <booktitle> In Proceedings of the Second Symposion on Principles and Practice of Parallel Programming. ACM, </booktitle> <year> 1990. </year>
Reference-contexts: Unfortunately, the problem of computing that information is NP-complete [Tay83]. As a consequence of this second implication, researchers have developed flow graphs that do not explicitly represent statement interleavings; these include the SCG <ref> [CKS90] </ref>, PFG [GS93], MIG [Due91], and sync hypergraph [MR93]. There are also flow graphs that can be viewed with or without explicit interleavings, such as the TFG [DC94]. Figure 1 depicts flow graphs for a sequential and a concurrent program. The sequential flow graph is standard. <p> Note that, for this problem, &gt; = N and ? = ;. An instance of this framework is defined as (G; M ) where M (n) = f n . For concurrent programs we are also interested in gathering statement precedence information <ref> [CKS90, CK93, DS91, GS93, Mas93] </ref>. Unfortunately, using Dom information often yields an overly pessimistic safe approximation. Recall the example concurrent flow graph in Figure 1. <p> Since the lattice is the powerset of the set of flow graph nodes its height is jN j. Thus, applying Algorithm 2 gives an O (jN j 3 ) solution procedure for the problem. The bound of this algorithm is equal to the bound of algorithms developed by Callahan <ref> [CKS90] </ref> and Grunwald [GS93] for the statement precedence problem. 6 Conclusions We have extended the theoretical foundations of data flow analysis to accommodate a number of natural analysis problems for concurrent programs. The formulation of complete-lattice frameworks is compatible with previous semi-lattice frameworks.
Reference: [DC94] <author> Matthew B. Dwyer and Lori A. Clarke. </author> <title> Data flow analysis for verifying properties of concurrent programs. </title> <journal> Software Engineering Notes, </journal> <volume> 19(5) </volume> <pages> 62-75, </pages> <month> December </month> <year> 1994. </year> <booktitle> Proceedings of the ACM SIGSOFT Symposium on the Foundations of Software Engineering. </booktitle>
Reference-contexts: There are also flow graphs that can be viewed with or without explicit interleavings, such as the TFG <ref> [DC94] </ref>. Figure 1 depicts flow graphs for a sequential and a concurrent program. The sequential flow graph is standard. The concurrent flow graph can be viewed as a collection of sequential control flow graphs, one for each process in the program (enclosed in a dashed box), consisting of (circular) nodes.
Reference: [DP90] <author> B.A. Davey and H.A. Priestley. </author> <title> Introduction to Lattices and Order. </title> <publisher> Cambridge University Press, </publisher> <year> 1990. </year>
Reference-contexts: of a complete-lattice data flow analysis framework, D, is a quadruple consisting of a flow graph G, subsets of the flow graph nodes N u and N t , and a function map M jN ! F , where: 3 This is the standard lattice-theoretic definition of a complete lattice <ref> [DP90] </ref>. 7 n 0 62 N u N u " N t = ; The set N u contains the flow graph nodes for which u is used to merge predecessor values. The set N t contains the flow graph nodes for which t is used to merge predecessor values.
Reference: [DS91] <author> E. Duesterwald and M.L. Soffa. </author> <title> Concurrency analysis in the presence of procedures using a data flow framework. </title> <booktitle> In Proceedings of the ACM SIGSOFT Symposium on Testing, Analysis and Verification (TAV4), </booktitle> <month> October </month> <year> 1991. </year>
Reference-contexts: Note that, for this problem, &gt; = N and ? = ;. An instance of this framework is defined as (G; M ) where M (n) = f n . For concurrent programs we are also interested in gathering statement precedence information <ref> [CKS90, CK93, DS91, GS93, Mas93] </ref>. Unfortunately, using Dom information often yields an overly pessimistic safe approximation. Recall the example concurrent flow graph in Figure 1.
Reference: [Due91] <author> Evelyn Duesterwald. </author> <title> Static concurrency analysis in the presence of procedures. </title> <institution> Department of Computer Science 91-6, University of Pittsburgh, </institution> <address> Pittsburgh, Pens-sylvania 15260, </address> <month> March </month> <year> 1991. </year>
Reference-contexts: Unfortunately, the problem of computing that information is NP-complete [Tay83]. As a consequence of this second implication, researchers have developed flow graphs that do not explicitly represent statement interleavings; these include the SCG [CKS90], PFG [GS93], MIG <ref> [Due91] </ref>, and sync hypergraph [MR93]. There are also flow graphs that can be viewed with or without explicit interleavings, such as the TFG [DC94]. Figure 1 depicts flow graphs for a sequential and a concurrent program. The sequential flow graph is standard.
Reference: [GS93] <author> Dirk Grunwald and Harini Srinivasan. </author> <title> Efficient computation of precedence information in parallel programs. </title> <booktitle> In Proceedings of the Sixth Annual Workshop on Languages and Compilers for Parallel Computing, </booktitle> <address> Portland, OR, </address> <month> August </month> <year> 1993. </year>
Reference-contexts: More recently, data flow analyses and optimizations for explicitly concurrent and parallel programs have been investigated, e.g., <ref> [SHW93, GS93] </ref>. Unfortunately, the theory of data flow frameworks has not been updated to accommodate the new program representations and analyses that concurrency and parallelism have brought. In this the next section, we present a review of data flow frameworks. <p> Unfortunately, the problem of computing that information is NP-complete [Tay83]. As a consequence of this second implication, researchers have developed flow graphs that do not explicitly represent statement interleavings; these include the SCG [CKS90], PFG <ref> [GS93] </ref>, MIG [Due91], and sync hypergraph [MR93]. There are also flow graphs that can be viewed with or without explicit interleavings, such as the TFG [DC94]. Figure 1 depicts flow graphs for a sequential and a concurrent program. The sequential flow graph is standard. <p> Note that, for this problem, &gt; = N and ? = ;. An instance of this framework is defined as (G; M ) where M (n) = f n . For concurrent programs we are also interested in gathering statement precedence information <ref> [CKS90, CK93, DS91, GS93, Mas93] </ref>. Unfortunately, using Dom information often yields an overly pessimistic safe approximation. Recall the example concurrent flow graph in Figure 1. <p> Thus, applying Algorithm 2 gives an O (jN j 3 ) solution procedure for the problem. The bound of this algorithm is equal to the bound of algorithms developed by Callahan [CKS90] and Grunwald <ref> [GS93] </ref> for the statement precedence problem. 6 Conclusions We have extended the theoretical foundations of data flow analysis to accommodate a number of natural analysis problems for concurrent programs. The formulation of complete-lattice frameworks is compatible with previous semi-lattice frameworks.
Reference: [GW76] <author> S.L. Graham and M. Wegman. </author> <title> A fast and usually linear algorithm for global data flow analysis. </title> <journal> Journal of the ACM, </journal> <volume> 23(1) </volume> <pages> 172-202, </pages> <year> 1976. </year>
Reference-contexts: The bulk of this work has been for sequential programs. The development of data flow frameworks by Kildall [Kil73] marked the beginning of a new era in compiler optimization. Setting data flow analysis on a sound formal foundation spurred a wealth of research into both generalizing, e.g., <ref> [KU77, CC77, GW76, Tar81] </ref> and specializing Kildall's result, e.g., [KU76, WZ91, Tar81]. This resulted in formalisms for specifying and classifying data flow analysis problems, and the development of algorithms for solving any problem in a given class.
Reference: [Hec77] <author> Matthew S. Hecht. </author> <title> Flow Analysis of Computer Programs. The Computer Science Library Programming Language Series. </title> <publisher> Elsevier North-Holland, </publisher> <year> 1977. </year>
Reference-contexts: Section 6 mentions future directions and concludes. 2 Background We begin with some definitions and terminology. In this section, we present results about data flow analyses formulated as data flow frameworks, using the terminology and definitions in Hecht <ref> [Hec77] </ref>. Every data flow analysis problem computes a different kind of problem information. This information captures facts about executable program behavior that the analysis is designed 1 to gather; this information is inherently approximate. <p> We describe one such implementation here. It is an adaptation of Hecht's iterative worklist algorithm <ref> [Hec77] </ref>. Algorithm 2 (Iterative Worklist Solver) Input: An instance I = (G; N u ; N t ; M ) of D = (L; F ), a monotone complete-lattice framework. Output: A lattice value for each node, 8n 2 N : A [n] 2 V . <p> This is a safe approximation to statement precedence information in the sense that Dom (m) = n implies that statement n precedes statement m on all program executions in which both occur. Hecht presents a formulation of it as a distributive semi-lattice data flow analysis framework <ref> [Hec77] </ref>: L = (P (N ); ; ") F = ff ident (S) = S : S P (N )g [ ff n (S) = S [ n : n 2 N ^ S P (N )g [ ff misc (X) = Y : X; Y P (N )g Where the
Reference: [Kil73] <author> Gary A. Kildall. </author> <title> A unified approach to global program optimization. </title> <booktitle> In Conference Record of the ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 194-206, </pages> <address> Boston, Massachusetts, </address> <month> October </month> <year> 1973. </year>
Reference-contexts: The constant desire for faster programs has spurred tremendous theoretical and practical advances in program analysis and optimization techniques. The bulk of this work has been for sequential programs. The development of data flow frameworks by Kildall <ref> [Kil73] </ref> marked the beginning of a new era in compiler optimization. Setting data flow analysis on a sound formal foundation spurred a wealth of research into both generalizing, e.g., [KU77, CC77, GW76, Tar81] and specializing Kildall's result, e.g., [KU76, WZ91, Tar81].
Reference: [KU76] <author> John B. Kam and Jeffrey D. Ullman. </author> <title> Global data flow analysis and iterative algorithms. </title> <journal> Journal of the ACM, </journal> <volume> 23 </volume> <pages> 158-171, </pages> <year> 1976. </year> <month> 19 </month>
Reference-contexts: The development of data flow frameworks by Kildall [Kil73] marked the beginning of a new era in compiler optimization. Setting data flow analysis on a sound formal foundation spurred a wealth of research into both generalizing, e.g., [KU77, CC77, GW76, Tar81] and specializing Kildall's result, e.g., <ref> [KU76, WZ91, Tar81] </ref>. This resulted in formalisms for specifying and classifying data flow analysis problems, and the development of algorithms for solving any problem in a given class. This meant that compiler developers no longer had to hand-craft a system of equations and a solver for an analysis problem.
Reference: [KU77] <author> John B. Kam and Jeffrey D. Ullman. </author> <title> Monotone data flow analysis frameworks. </title> <journal> Acta Informatica, </journal> <volume> 7 </volume> <pages> 305-317, </pages> <year> 1977. </year>
Reference-contexts: The bulk of this work has been for sequential programs. The development of data flow frameworks by Kildall [Kil73] marked the beginning of a new era in compiler optimization. Setting data flow analysis on a sound formal foundation spurred a wealth of research into both generalizing, e.g., <ref> [KU77, CC77, GW76, Tar81] </ref> and specializing Kildall's result, e.g., [KU76, WZ91, Tar81]. This resulted in formalisms for specifying and classifying data flow analysis problems, and the development of algorithms for solving any problem in a given class. <p> In this the next section, we present a review of data flow frameworks. Section 3 follows with a discussion of the limitations of those frameworks. In Section 4 we present a generalization of Kam and Ullman's monotone data flow analysis framework <ref> [KU77] </ref>; this generalization, called a complete-lattice monotone data flow analysis framework, supports the formulation of data flow analyses over flow graphs for concurrent programs. We present solution algorithms for data flow analysis problems formulated as complete-lattice frameworks and prove results related to their correctness and complexity. <p> A data flow analysis problem is solved by computing a fixed point of the equation system, as described above. Solving Complete-Lattice Data Flow Problems We generalize existing results for monotone semi-lattice frameworks to monotone complete-lattice frameworks by mirroring Kam and Ullman's generalization of Kildall's distributive semi-lattice frameworks <ref> [KU77] </ref>. In the following, we assume the existence of &gt;.
Reference: [Mas93] <author> S.P. Masticola. </author> <title> Static Detection of Deadlocks in Polynomial Time. </title> <type> PhD thesis, </type> <institution> Rutgers University, </institution> <month> May </month> <year> 1993. </year>
Reference-contexts: Note that, for this problem, &gt; = N and ? = ;. An instance of this framework is defined as (G; M ) where M (n) = f n . For concurrent programs we are also interested in gathering statement precedence information <ref> [CKS90, CK93, DS91, GS93, Mas93] </ref>. Unfortunately, using Dom information often yields an overly pessimistic safe approximation. Recall the example concurrent flow graph in Figure 1.
Reference: [MR90] <author> T.J. Marlowe and B.G. Ryder. </author> <title> Properties of data flow frameworks. </title> <journal> Acta Infor-matica, </journal> <volume> 28 </volume> <pages> 121-163, </pages> <year> 1990. </year>
Reference-contexts: Given this we can write the MOP solution as: A [n] = u p2P aths (n) f p (?) 3 Limitations of Semi-lattice Frameworks Placing data flow analysis on a sound formal foundation has brought many advantages to developers of new analyses. The ability to characterize an analysis framework <ref> [MR90] </ref>, as rapid, continuous, distributive, monotone, or k-bounded for example, allows one to apply existing theoretical results to reason about convergence, bounds on running time, and the precision of analyses. In addition, a wide variety of general and specialized algorithms have been developed for classes of frameworks. <p> We have illustrated, by way of example, the ease with which analysis problems for concurrent programs can be formulated as a complete-lattice framework. On the theoretical front we intend to look at the extent to which distributivity, continuity and rapidity <ref> [MR90] </ref> can be exploited in complete-lattice frameworks. We intend to investigate a wide variety of standard and special purpose data flow analysis problems to understand the extent to which they are accommodated in the new theory.
Reference: [MR93] <author> S.P. Masticola and B.G. Ryder. </author> <title> Non-concurrency analysis. </title> <booktitle> In Proceedings of the 4th ACM SIGPLAN Symposium on Principles and Practice of Parallel Programming, </booktitle> <month> May </month> <year> 1993. </year>
Reference-contexts: Unfortunately, the problem of computing that information is NP-complete [Tay83]. As a consequence of this second implication, researchers have developed flow graphs that do not explicitly represent statement interleavings; these include the SCG [CKS90], PFG [GS93], MIG [Due91], and sync hypergraph <ref> [MR93] </ref>. There are also flow graphs that can be viewed with or without explicit interleavings, such as the TFG [DC94]. Figure 1 depicts flow graphs for a sequential and a concurrent program. The sequential flow graph is standard.
Reference: [SHW93] <author> Harini Srinivasan, James Hook, and Michael Wolfe. </author> <title> Static single assignment for explicitly parallel programs. </title> <booktitle> In Conference Record of the Twentieth Annual ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages, </booktitle> <pages> pages 260-272, </pages> <address> Charleston, South Carolina, </address> <month> January </month> <year> 1993. </year>
Reference-contexts: More recently, data flow analyses and optimizations for explicitly concurrent and parallel programs have been investigated, e.g., <ref> [SHW93, GS93] </ref>. Unfortunately, the theory of data flow frameworks has not been updated to accommodate the new program representations and analyses that concurrency and parallelism have brought. In this the next section, we present a review of data flow frameworks. <p> In meet semi-lattice data flow frameworks this combining operation is the meet operation. For the concurrent flow graphs described above, it appears that being limited to a single combining operation can lead to significant imprecision in analysis results. Srinivasan <ref> [SHW93] </ref> has also identified the necessity of multiple combining operations, represented as and nodes, in defining an SSA form for explicitly parallel programs. 4 Complete-lattice Frameworks In this section, we generalize semi-lattice frameworks to allow formulation of data flow problems over a complete-lattice.
Reference: [Tar81] <author> Robert Endre Tarjan. </author> <title> Fast algorithms for solving path problems. </title> <journal> Journal of the ACM, </journal> <volume> 28(3) </volume> <pages> 594-614, </pages> <month> jul </month> <year> 1981. </year>
Reference-contexts: The bulk of this work has been for sequential programs. The development of data flow frameworks by Kildall [Kil73] marked the beginning of a new era in compiler optimization. Setting data flow analysis on a sound formal foundation spurred a wealth of research into both generalizing, e.g., <ref> [KU77, CC77, GW76, Tar81] </ref> and specializing Kildall's result, e.g., [KU76, WZ91, Tar81]. This resulted in formalisms for specifying and classifying data flow analysis problems, and the development of algorithms for solving any problem in a given class. <p> The development of data flow frameworks by Kildall [Kil73] marked the beginning of a new era in compiler optimization. Setting data flow analysis on a sound formal foundation spurred a wealth of research into both generalizing, e.g., [KU77, CC77, GW76, Tar81] and specializing Kildall's result, e.g., <ref> [KU76, WZ91, Tar81] </ref>. This resulted in formalisms for specifying and classifying data flow analysis problems, and the development of algorithms for solving any problem in a given class. This meant that compiler developers no longer had to hand-craft a system of equations and a solver for an analysis problem.
Reference: [Tay83] <author> Richard N. Taylor. </author> <title> Complexity of analyzing the synchronization structure of concurrent programs. </title> <journal> Acta Informatica, </journal> <volume> 19 </volume> <pages> 57-84, </pages> <year> 1983. </year>
Reference-contexts: Even with exact information about the statements that can execute concurrently, the flow graph would still be very dense, i.e., jEj will approach jN j 2 . Unfortunately, the problem of computing that information is NP-complete <ref> [Tay83] </ref>. As a consequence of this second implication, researchers have developed flow graphs that do not explicitly represent statement interleavings; these include the SCG [CKS90], PFG [GS93], MIG [Due91], and sync hypergraph [MR93].
Reference: [WZ91] <author> Mark N. Wegman and F. Kenneth Zadeck. </author> <title> Constant propagation with conditional branches. </title> <journal> Transactions on Programming Languages and Systems, </journal> <volume> 13(2) </volume> <pages> 181-210, </pages> <month> apr </month> <year> 1991. </year>
Reference-contexts: The development of data flow frameworks by Kildall [Kil73] marked the beginning of a new era in compiler optimization. Setting data flow analysis on a sound formal foundation spurred a wealth of research into both generalizing, e.g., [KU77, CC77, GW76, Tar81] and specializing Kildall's result, e.g., <ref> [KU76, WZ91, Tar81] </ref>. This resulted in formalisms for specifying and classifying data flow analysis problems, and the development of algorithms for solving any problem in a given class. This meant that compiler developers no longer had to hand-craft a system of equations and a solver for an analysis problem.
Reference: [ZC91] <author> Hans Zima and Barbara Chapman. </author> <title> Supercompilers for Parallel and Vector Computers. </title> <publisher> ACM Press, </publisher> <year> 1991. </year> <month> 20 </month>
Reference-contexts: Compiler optimization research has adapted to the emergence of concurrent and parallel computing into the programming mainstream A large body of work has been developed for using data flow analyses to aid in parallelizing of sequential programs, e.g., <ref> [ZC91] </ref>. More recently, data flow analyses and optimizations for explicitly concurrent and parallel programs have been investigated, e.g., [SHW93, GS93]. Unfortunately, the theory of data flow frameworks has not been updated to accommodate the new program representations and analyses that concurrency and parallelism have brought.
References-found: 22

