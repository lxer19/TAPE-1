URL: http://www.cs.utah.edu/~banavar/cms.ps.Z
Refering-URL: http://www.cs.utah.edu/~banavar/research.html
Root-URL: 
Title: Compositionally Modular Scheme  
Author: Guruduth Banavar Gary Lindstrom 
Keyword: module systems, object-oriented programming, inheritance, Scheme.  
Address: Salt Lake City, UT 84112  
Affiliation: Department of Computer Science University of Utah,  
Abstract: We present a new module system for Scheme that supports a high degree of implementation reuse via module composition. The module system encourages breaking down a program into the smallest possible individually meaningful modules, and recomposing them using a powerful set of adaptation and combination mechanisms. Even hierarchical nesting is achieved via a composition operation. This module system is shown to support a stronger and more flexible notion of compositionality and reuse than traditional class-based inheritance in object-oriented programming. Finally, this module system is itself implemented by reusing a language independent OO framework. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Guruduth Banavar. </author> <title> An Application Framework for Compositional Modularity. </title> <type> PhD thesis, </type> <institution> University of Utah, </institution> <address> Salt Lake City, Utah, </address> <year> 1995. </year>
Reference-contexts: For example, two such structures can be combined by appropriately composing their s parameters, or one such structure can be embedded into another by supplying the e parameter of the former with the s parameter of the latter. The reader is referred to <ref> [1, 2] </ref> for a development of the formalism. This ability to manipulate the namespace enables a high degree of compositionality and reuse. The design of CMS is based upon the above semantic notion of modules that goes back to record calculi [11, 5]. <p> The implementation of CMS is interesting in its own right; please see <ref> [1] </ref> for details. Some important areas of future work remain. Static typing is desirable and possible within our model, although it would introduce several restrictions to the programming style presented here.
Reference: [2] <author> Gilad Bracha and Gary Lindstrom. </author> <title> Modularity meets inheritance. </title> <booktitle> In Proc. International Conference on Computer Languages, </booktitle> <pages> pages 282-290, </pages> <address> San Francisco, CA, </address> <month> April 20-23, </month> <year> 1992. </year> <journal> IEEE Computer Society. </journal> <note> Also available as Technical Report UUCS-91-017. </note>
Reference-contexts: For example, two such structures can be combined by appropriately composing their s parameters, or one such structure can be embedded into another by supplying the e parameter of the former with the s parameter of the latter. The reader is referred to <ref> [1, 2] </ref> for a development of the formalism. This ability to manipulate the namespace enables a high degree of compositionality and reuse. The design of CMS is based upon the above semantic notion of modules that goes back to record calculi [11, 5]. <p> The design of CMS is based upon the above semantic notion of modules that goes back to record calculi [11, 5]. Classes were modeled as record generators by Cook [7], who also first introduced some of the operators used here. Based on this, Bracha and Lindstrom in <ref> [2] </ref> developed a suite of operators to support sharing, encapsulation, and static binding. In this paper, we further augment the above model with the notion of compositional nesting, enabled by the e parameter of the previous paragraph.
Reference: [3] <author> Rod Burstall and Butler Lampson. </author> <title> A kernel language for abstract data types and modules. </title> <editor> In Giles Kahn, David MacQueen, and Gordon Plotkin, editors, </editor> <booktitle> Proceedings, International Symposium on the Semantics of Data Types, volume 173 of Lecture Notes in Computer Science, </booktitle> <pages> pages 1-50. </pages> <publisher> Springer, </publisher> <year> 1984. </year>
Reference-contexts: In the context of Scheme, it is natural to support modules as first-class values. The uniformity and expressive power obtained by using first-class modules was recognized in the early language Pebble <ref> [3] </ref>. More recently, many other languages such as FX [19] and Rascal [12] also support first-class modules. Some Scheme implementations support first-class environments, which can be dynamically created and extended, and expressions evaluated within them.
Reference: [4] <author> P. Canning, W. Cook, W. Hill, and W. Olthoff. </author> <title> Interfaces for strongly-typed object-oriented programming. </title> <editor> In Norman Meyrowitz, editor, </editor> <booktitle> Proceedings of the ACM Conference on Object-Oriented Programming, Systems, Languages, and Applications, </booktitle> <pages> pages 457-467, </pages> <year> 1989. </year>
Reference-contexts: As a result, functions expecting an instance of a particular module may not necessarily operate correctly on an instance of the module subjected to a hide operation. This represents the widely accepted notion of separating inheritance from subtyping <ref> [4] </ref>. Combination. The module capacity-module given in Figure 1 (c) exports two symbols: capacity, that represents the fuel capacity of a vehicle in gallons, and greater-capacity?, bound to a procedure that determines if the current instance has greater fuel capacity than the incoming argument.
Reference: [5] <author> Luca Cardelli and John C. Mitchell. </author> <title> Operations on records. </title> <type> Technical Report 48, </type> <institution> DEC SRC, </institution> <month> August </month> <year> 1989. </year>
Reference-contexts: The reader is referred to [1, 2] for a development of the formalism. This ability to manipulate the namespace enables a high degree of compositionality and reuse. The design of CMS is based upon the above semantic notion of modules that goes back to record calculi <ref> [11, 5] </ref>. Classes were modeled as record generators by Cook [7], who also first introduced some of the operators used here. Based on this, Bracha and Lindstrom in [2] developed a suite of operators to support sharing, encapsulation, and static binding.
Reference: [6] <author> William Clinger and Jonathan Rees. </author> <title> Revised 4 report on the algorithmic language Scheme. </title> <journal> ACM Lisp Pointers, </journal> <volume> 4(3), </volume> <year> 1991. </year>
Reference-contexts: We present the above module system within the context of a programming language named Compositionally Modular Scheme, or CMS for short. CMS is an extension of vanilla Scheme <ref> [6] </ref>. In the spirit of Scheme, CMS supports modules as first-class entities, and it is dynamic and interactive. Also, the notion of modules and their instances have a clear denotational semantics based upon record generators, described below. <p> completely consistent with Scheme's original design philosophy that "... a very small number of rules for forming expressions, with no restrictions on how they are composed, suffice to form a practical and efficient programming language that is flexible enough to support most of the major programming paradigms in use today." <ref> [6] </ref> Acknowledgements. We gratefully acknowledge support and several useful comments on this work from Jay Lepreau, Bjorn Freeman-Benson, Gilad Bracha, Bryan Ford, Doug Orr, Robert Mecklenburg, and Nevenka Dimitrova.
Reference: [7] <author> William Cook and Jen Palsberg. </author> <title> A denotational semantics of inheritance and its correctness. </title> <booktitle> In Proc. ACM Conf. on Object-Oriented Programming: Systems, Languages and Applications, </booktitle> <pages> pages 433-444, </pages> <year> 1989. </year>
Reference-contexts: This ability to manipulate the namespace enables a high degree of compositionality and reuse. The design of CMS is based upon the above semantic notion of modules that goes back to record calculi [11, 5]. Classes were modeled as record generators by Cook <ref> [7] </ref>, who also first introduced some of the operators used here. Based on this, Bracha and Lindstrom in [2] developed a suite of operators to support sharing, encapsulation, and static binding.
Reference: [8] <author> Pavel Curtis and James Rauen. </author> <title> A module system for Scheme. </title> <booktitle> In Conference Record of the ACM Lisp and Functional Programming. ACM, </booktitle> <year> 1990. </year>
Reference-contexts: Several module systems have been proposed for Scheme <ref> [8, 20, 18] </ref>. CMS is different from these systems in its explicit goal of supporting reuse via module composition. <p> In CMS, interconnection of modules is not done via import/export declarations, but rather by explicitly combining the modules involved, possibly after adaptation. (One simple notion of adaptation by renaming was supported in [20].) Some previous systems (e.g. <ref> [8, 18] </ref>) support explicit interfaces. Although the CMS language presented here does not support this, interfaces can be built up dynamically by specifying a module's public interface attributes and providing error stubs for methods.
Reference: [9] <author> R. Ducournau, M. Habib, M. Huchard, and M. L. Mugnier. </author> <title> Proposal for a monotonic multiple inheritance linearization. </title> <booktitle> In Proceedings of OOPSLA, </booktitle> <pages> pages pages 164 - 175, </pages> <month> October </month> <year> 1994. </year>
Reference-contexts: It has been argued that currently used linearizations do not ensure that "the inheritance mechanism behaves "naturally" relative to the incremental design of the inheritance hierarchy" <ref> [9] </ref>.
Reference: [10] <author> Erick Gallesio. </author> <note> STk reference manual. Available with STk release, version 2.1, 1993/94. 14 </note>
Reference-contexts: This set of classes, also known as an OO framework [13], can be subclassed and instantiated to implement processors for particular languages. We have implemented an interpreter for CMS by extending an existing Scheme interpreter implementation (available as part of the STk package <ref> [10] </ref>) with classes derived from the reusable OO framework mentioned above.
Reference: [11] <author> Robert Harper and Benjamin Pierce. </author> <title> A record calculus based on symmetric concatenation. </title> <booktitle> In POPL, </booktitle> <pages> pages 131-142, </pages> <month> January </month> <year> 1991. </year>
Reference-contexts: The reader is referred to [1, 2] for a development of the formalism. This ability to manipulate the namespace enables a high degree of compositionality and reuse. The design of CMS is based upon the above semantic notion of modules that goes back to record calculi <ref> [11, 5] </ref>. Classes were modeled as record generators by Cook [7], who also first introduced some of the operators used here. Based on this, Bracha and Lindstrom in [2] developed a suite of operators to support sharing, encapsulation, and static binding.
Reference: [12] <author> Suresh Jagannathan. </author> <title> Metalevel building blocks for modular systems. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 16(3) </volume> <pages> 456-492, </pages> <month> May </month> <year> 1994. </year>
Reference-contexts: In the context of Scheme, it is natural to support modules as first-class values. The uniformity and expressive power obtained by using first-class modules was recognized in the early language Pebble [3]. More recently, many other languages such as FX [19] and Rascal <ref> [12] </ref> also support first-class modules. Some Scheme implementations support first-class environments, which can be dynamically created and extended, and expressions evaluated within them. The environment can also be captured at any point by using a special primitive, such as the-environment. <p> However, such simple notions of environments are not very powerful | the only useful operation defined on them is eval. A more powerful notion of first-class environments with reflective operations has been proposed in the language Rascal <ref> [12] </ref>. While CMS and Rascal are similar in that they support operations on first-class abstractions, the approaches used are entirely different. Rascal uses the approach of reflection, adaptation, and reification of first-class environments. CMS uses the approach of module combination and adaptation with the specific goal of reuse.
Reference: [13] <author> Ralph E. Johnson and Vincent F. Russo. </author> <title> Reusing object-oriented designs. </title> <type> Technical Report UIUCDCS-R-1991-1696, </type> <institution> Department of Computer Science, University of Illinois at Urbana-Champaign, Urbana, Illinois, </institution> <year> 1991. </year>
Reference-contexts: In fact, we have designed and implemented a generic reusable set of C++ classes that embody the language independent aspects of the model. This set of classes, also known as an OO framework <ref> [13] </ref>, can be subclassed and instantiated to implement processors for particular languages. We have implemented an interpreter for CMS by extending an existing Scheme interpreter implementation (available as part of the STk package [10]) with classes derived from the reusable OO framework mentioned above.
Reference: [14] <author> Gregor Kiczales, Jim des Rivieres, and Daniel G. Bobrow. </author> <title> The Art of the Metaobject Protocol. </title> <publisher> The MIT Press, </publisher> <address> Cambridge, MA, </address> <year> 1991. </year>
Reference-contexts: From one perspective, the operations provided by CMS can be viewed as "meta-level" primitives to achieve various goals of module composition. In some respects, e.g. inheritance (and method dispatch to some extent), CMS provides the programmer flexibility akin to that provided by meta 3 object protocols (MOPs) <ref> [14] </ref>, without actually exposing the meta-architecture implementation to direct user programming. However, a full-blown MOP gives the user much more control over various other aspects of a language implementation as well, such as object layout.
Reference: [15] <author> Bent Bruun Kristensen, Ole Lehrmann Madsen, Birger Moller-Pedersen, and Kristen Nygaard. </author> <title> The BETA programming language. </title> <booktitle> In Research Directions in Object-Oriented Programming, </booktitle> <pages> pages pages 7 - 48. </pages> <publisher> MIT Press, </publisher> <year> 1987. </year>
Reference-contexts: Similarly, the self-references within a module and the module of an instance can also be queried for. Prefixing. The programming language Beta <ref> [15] </ref> supports a form of single inheritance called prefixing which is quite different from the single inheritance presented earlier. In prefixing, a superclass method that expects to be re-bound by a subclass definition uses a construct called inner somewhere in its body.
Reference: [16] <author> Ole Lehrmann Madsen. </author> <title> Block structure and object-oriented languages. </title> <booktitle> In Research Directions in Object-Oriented Programming, </booktitle> <pages> pages pages 113 - 128. </pages> <publisher> MIT Press, </publisher> <year> 1987. </year>
Reference-contexts: A module can serve as a shared data repository for nested modules, and could perhaps serve as a "factory" that produces initialized instances of nested modules. Furthermore, nesting can nicely solve some real-world modeling problems such as the prototype abstraction relation problem (<ref> [16] </ref>, page 123). Madsen [16] has also shown that nested classes can be used to emulate the functionality of meta-classes.
Reference: [17] <author> Harold Ossher and William Harrison. </author> <title> Combination of inheritance hierarchies. </title> <booktitle> In OOPSLA Proceedings, </booktitle> <pages> pages 25-40, </pages> <month> October </month> <year> 1992. </year>
Reference-contexts: The outer module can be thought of as containing an inheritance hierarchy of modules. Such modules can themselves be manipulated in several ways to realize a useful application known as inheritance hierarchy combination <ref> [17] </ref>. Lexical Nesting. In CMS, modules follow static scoping rules just like the rest of Scheme. The methods of modules can refer to bindings in their surrounding environments using primitives such as (env-ref hattribute-namei harg-expr* i), analogous to the self-reference primitives given earlier.
Reference: [18] <author> Jonathan Rees. </author> <title> Another module system for Scheme. Included in the Scheme 48 distribution, </title> <year> 1993. </year>
Reference-contexts: Several module systems have been proposed for Scheme <ref> [8, 20, 18] </ref>. CMS is different from these systems in its explicit goal of supporting reuse via module composition. <p> In CMS, interconnection of modules is not done via import/export declarations, but rather by explicitly combining the modules involved, possibly after adaptation. (One simple notion of adaptation by renaming was supported in [20].) Some previous systems (e.g. <ref> [8, 18] </ref>) support explicit interfaces. Although the CMS language presented here does not support this, interfaces can be built up dynamically by specifying a module's public interface attributes and providing error stubs for methods.
Reference: [19] <author> Mark A. Sheldon. </author> <title> Static dependent types for first class modules. </title> <booktitle> In ACM Conference on Lisp and Functional Programming, </booktitle> <month> June </month> <year> 1990. </year>
Reference-contexts: In the context of Scheme, it is natural to support modules as first-class values. The uniformity and expressive power obtained by using first-class modules was recognized in the early language Pebble [3]. More recently, many other languages such as FX <ref> [19] </ref> and Rascal [12] also support first-class modules. Some Scheme implementations support first-class environments, which can be dynamically created and extended, and expressions evaluated within them. The environment can also be captured at any point by using a special primitive, such as the-environment.
Reference: [20] <author> Sho-Huan Simon Tung. </author> <title> Interactive modular programming in Scheme. </title> <booktitle> In Proceedings of the ACM Lisp and Functional Programming Conference, </booktitle> <pages> pages pages 86 - 95. </pages> <publisher> ACM, </publisher> <year> 1992. </year> <title> Last modified: </title> <month> October 26, </month> <year> 1995 </year> <month> 15 </month>
Reference-contexts: Several module systems have been proposed for Scheme <ref> [8, 20, 18] </ref>. CMS is different from these systems in its explicit goal of supporting reuse via module composition. <p> CMS is different from these systems in its explicit goal of supporting reuse via module composition. In CMS, interconnection of modules is not done via import/export declarations, but rather by explicitly combining the modules involved, possibly after adaptation. (One simple notion of adaptation by renaming was supported in <ref> [20] </ref>.) Some previous systems (e.g. [8, 18]) support explicit interfaces. Although the CMS language presented here does not support this, interfaces can be built up dynamically by specifying a module's public interface attributes and providing error stubs for methods.
References-found: 20

