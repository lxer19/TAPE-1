URL: http://polaris.cs.uiuc.edu/reports/1469.ps.gz
Refering-URL: http://polaris.cs.uiuc.edu/tech_reports.html
Root-URL: http://www.cs.uiuc.edu
Title: Low Perturbation Address Trace Collection for Operating System, Multiprogrammed, and Parallel Workloads in Multiprocessors 1  
Author: Russell Daigle Chun Xia, and Josep Torrellas 
Keyword: Address tracing, hardware performance monitor, operating system, shared-memory multiprocessor, cache misses.  
Address: IL 61801  
Affiliation: Center for Supercomputing Research and Development and Computer Science Department University of Illinois at Urbana-Champaign,  
Abstract: While address trace analysis is a popular method to evaluate the memory system of computers, getting accurate traces of operating system, multiprogrammed, and parallel workloads in multiprocessors is hard. This is because the true behavior of these real-time loads can be easily altered by the tracing activity. To minimize perturbation, it is usually necessary to use trace-gathering hardware devices. Unfortunately, these devices usually gather limited information. For example, they often only capture physical addresses, can only collect references that miss in on-chip caches, and can only monitor a very small time window. In this paper, we improve the capability of such devices. We present a methodology to instrument operating system and applications to transfer a wide variety of information to the trace-gathering hardware with very little perturbation. For instance, the information transferred includes the virtual to physical address mapping or the sequence of basic blocks executed. Each piece of information is transferred as cheaply and non-intrusively as one or more machine instructions and one or more cache misses. With this approach, instrumenting every basic block in the operating system and application code causes only a 1.5-2.8 execution slowdown. This is in contrast to a 10-times slowdown for software-based instrumentation in uniprocessors. Furthermore, the behavior of the operating system is largely unaffected. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> A. Agarwal, R. L. Sites, and M. Horowitz. ATUM: </author> <title> A New Technique for Capturing Address Traces Using Microcode. </title> <booktitle> In Proc. 13th Annual International Symposium on Computer Architecture, </booktitle> <pages> pages 119-127, </pages> <month> June </month> <year> 1986. </year>
Reference-contexts: The other two systems [26, 27] are the ones described in this paper. They can generate continuous traces without perturbing the system much. They are described in the next section. Other trace-collecting hardware devices have been used in uniprocessors. One example is ATUM <ref> [1] </ref>, the uniprocessor predecessor of ATUM-2. Other examples are various schemes involving data acquisition systems, for example the one described by Alexander et al [2]. This system uses a logic analyzer to gather address traces from a NS32016 microprocessor.
Reference: [2] <author> C. Alexander, W. Keshlear, F. Cooper, and F. Briggs. </author> <title> Cache Memory Performance in a UNIX Environment. </title> <booktitle> In Computer Architecture News, </booktitle> <pages> pages 41-70, </pages> <month> June </month> <year> 1986. </year>
Reference-contexts: They are described in the next section. Other trace-collecting hardware devices have been used in uniprocessors. One example is ATUM [1], the uniprocessor predecessor of ATUM-2. Other examples are various schemes involving data acquisition systems, for example the one described by Alexander et al <ref> [2] </ref>. This system uses a logic analyzer to gather address traces from a NS32016 microprocessor. This system can gather complete address traces because the processor monitored does not have on-chip caches. In general, all these systems tend to work with samples because they have a limited trace storage capacity.
Reference: [3] <institution> Alliant Computer Systems Corporation. FX/Series Product Summary. Littleton, </institution> <address> MA, </address> <year> 1986. </year>
Reference-contexts: In practice, any memory access can be made uncachable by setting its four most significant bits to a certain value bits that are otherwise not used to address memory. 3.2 The Alliant System This trace generation system [27] uses a 4-processor Alliant FX/8 <ref> [3] </ref> bus-based multiprocessor. In this machine, each processor has a 16-Kbyte on-board direct-mapped instruction cache. In addition, all processors share one 512-Kbyte 4-way interleaved cache. The line size of the cache is 32 bytes. This cache receives all data accesses plus the instruction accesses that miss in the primary caches. <p> For this experiment, we add one instruction at the beginning of each basic block. The instruction is add ea,an, which adds the source operand (specified as an effective address, ea), to the contents of the address register an, and stores the result in the address register an <ref> [3, 19] </ref>. We chose this instruction because it has low overhead (very close to that of a load instruction) and does not modify any condition codes.
Reference: [4] <editor> J. B. </editor> <address> Andrews. </address>
Reference-contexts: The line size of the cache is 32 bytes. This cache receives all data accesses plus the instruction accesses that miss in the primary caches. The machine has 32 Mbytes of main memory. Between the primary caches and the shared one, we connected a hardware performance monitor <ref> [4] </ref> that can gather the address of all references that reach the cache. The monitor has 4 trace buffers connected to the four processors. Each trace buffer gathers the physical addresses of the memory locations referenced by the loads and stores from one processor.
References-found: 4

