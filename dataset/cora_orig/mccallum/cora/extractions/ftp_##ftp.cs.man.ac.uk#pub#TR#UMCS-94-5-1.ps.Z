URL: ftp://ftp.cs.man.ac.uk/pub/TR/UMCS-94-5-1.ps.Z
Refering-URL: http://www.cs.man.ac.uk/cstechrep/Abstracts/UMCS-94-5-1.html
Root-URL: http://www.cs.man.ac.uk
Email: -js,cck,andersos-@cs.man.ac.uk  
Title: Page 1 The Uflow Computational Model and Intermediate Format  
Author: John Sargeant, Chris Kirkham, Steve Anderson 
Address: Manchester M13 9PL, England  
Affiliation: Dept. of Computer Science, University of Manchester,  
Pubnum: UMCS Technical Report 94-5-1 1  
Abstract: This report motivates and defines a general-purpose, architecture independent, parallel computational model, which captures the intuitions which underlie the design of the United Functions and Objects programming language. The model has two aspects, which turn out to be a traditional dataflow model and an actor-like model, with a very simple interface between the two. Certain aspects of the model, particularly strictness, maximum parallelism, and lack of suspension are stressed. The implications of introducing stateful objects are carefully spelled out. The model has several purposes, although we largely describe it as it would be used for visualising the execution of programs. The model is embodied in a textual intermediate format, and in a set of UFO data structures. This report also serves as a definition of the intermediate format, and gives a brief overview of the data structures. 
Abstract-found: 1
Intro-found: 1
Reference: [Agha86] <author> G. Agha: </author> <title> Actors: A Model of Concurrent Computation in Distributed Systems, </title> <publisher> MIT Press series in artificial intelligence, </publisher> <year> 1986. </year>
Reference-contexts: UFO has integrated functional arrays and loop structures, in the style of SISAL [McGr85], but significantly generalised. UFO has stateful objects, with updateable instance variables, which are accessed by a queuing mechanism like actors <ref> [Agha86] </ref>. A single-update scheme provides internal coherence; again this is similar to some actor systems. Again like some actor languages, UFO provides conditional message acceptance. An object may accept certain messages only when particular conditions (defined in terms of the values of the instance variables) are met.
Reference: [ArTh81] <author> Arvind, R.E. Thomas: I-structures: </author> <title> An Efficient Data Type for Functional Languages, </title> <institution> M.I.T./LCS/TM-178, Computer Science Laboratory, M.I.T., </institution> <address> Cambridge, MA, </address> <month> Oct </month> <year> 1981. </year>
Reference-contexts: Page 13 A simple implementation of non-strictness is enough to explain the model and highlight the issues, however. The following class implements a straightforward I-Structure location. An I structure <ref> [ArTh81] </ref> is one each of whose elements is written exactly once; an attempt may be made to read an element before it has been written, in which case the read is deferred until the write has been made.
Reference: [Booc94] <author> G. Booch: </author> <title> Object-Oriented Analysis and Design with Applications, </title> <note> second edition, Benjamin/Cummings 1994. </note>
Reference: [Cann92] <author> D. C. Cann: </author> <title> Retire Fortran? A Debate Rekindled, </title> <journal> Communications of the ACM 35(8), </journal> <month> August </month> <year> 1992, </year> <pages> pp 81-89. </pages>
Reference: [HaBo92] <author> M. Haines and A.P.W. Bhm: </author> <title> Towards a Distributed Memory Implementation of SISAL, </title> <booktitle> Scalable High Performance Computing Conference, </booktitle> <month> April </month> <year> 1992. </year>
Reference: [HoAg92] <author> C. Houck, G. Agha: Hal: </author> <title> A High-level Actor Language and its Distributed Implementation, </title> <booktitle> proc. 21st International Conference on Parallel Processing, </booktitle> <month> August </month> <year> 1992. </year>
Reference-contexts: An object may accept certain messages only when particular conditions (defined in terms of the values of the instance variables) are met. Amongst other things, this allows non-strict or lazy data structures to be programmed if required. Unlike most actor languages, e.g. ABCL [Yone90], HAL <ref> [HoAg92] </ref>, UFO has a static type system which provides type safety but with considerable flexibility. Overloading, subtyping via inheritance, and genericity are all supported. In addition, the type system provides important static protection from some of the problems associated with the transition from a pure functional environment.
Reference: [Hoot94] <author> S. Hooton: </author> <title> Efficient Implementation of Stateful Objects, M.Sc. </title> <type> thesis, </type> <institution> Department of Computer Science, University of Manchester 1994. </institution> <note> In preparation. </note>
Reference-contexts: The type system provides a certain amount of useful information in this regard. An M.Sc. project is currently investigating this <ref> [Hoot94] </ref>. Of course there are many other issues to address, for instance load balancing and data distribution. <p> To produce a visualisation and debugging tool which will animate computations as suggested above. 2. For sharing and array build/update in place analysis, similar to that employed in the SISAL project using IF1. 3. For analysis to optimise the implementation of stateful objects <ref> [Hoot94] </ref>, as described earlier. The uflow format will also be used in the compiler for the initial parallel implementation of UFO, on the KSR machine at Manchester, and hopefully for implementations on other parallel machines also.
Reference: [Meye93] <author> B. Meyer: </author> <title> Systematic Concurrent Object-oriented Programming, </title> <journal> Communications of the ACM 36:9, </journal> <month> September </month> <year> 1993, </year> <pages> pp 56-79. </pages>
Reference-contexts: The precondition, on the other hand, seems more naturally a property of the method: it decides whether things are in the right state when it gets there. We would therefore argue against merging acceptance conditions and preconditions, as proposed in <ref> [Meye93] </ref>. Representation of the methods is straightforward. In particular, the body of procedure write can look exactly like the body of a loop with loop values val and present. The single assignment updates mean that parallelism can be exploited within the body of a procedure just like anywhere else.
Reference: [McGr85] <author> J. R. McGraw, S. K. Skedzielewski, S. J. Allan, R. R.Oldehoeft, J. Glauert, C. C. Kirkham, W. Noyce, and R. Thomas: </author> <title> SISAL:Streams and Iteration in a Single Assignment Language, Reference Manual 1.2, Manual M-146, </title> <type> Rev. 1, </type> <institution> Lawrence Livermore National Laboratory, </institution> <year> 1985. </year>
Reference-contexts: Selection by pattern matching, as used in most functional languages, is restricted to simple cases, for software engineering reasons, and OO-style selection via dynamic binding is used instead. UFO has integrated functional arrays and loop structures, in the style of SISAL <ref> [McGr85] </ref>, but significantly generalised. UFO has stateful objects, with updateable instance variables, which are accessed by a queuing mechanism like actors [Agha86]. A single-update scheme provides internal coherence; again this is similar to some actor systems. Again like some actor languages, UFO provides conditional message acceptance.
Reference: [Mohr90] <author> E. Mohr, D.A. Kranz & R.H. Halsted: </author> <title> Lazy Task Creation: A Technique for Increasing the Granularity of Parallel Programs, </title> <booktitle> Proceedings of the ACM Conference on Lisp and Functional Programming. </booktitle> <year> 1990. </year>
Reference-contexts: If thread sizes are statically determined, poor performance results for irregular programs; on the other hand the use of techniques such as dynamic granularity and lazy task creation <ref> [Mohr90] </ref> makes the dynamic behaviour very complex. For instance [SaWa91] shows how the behaviour of a very simple program under such a model can vary dramatically with subtle changes in the exact details of how threads are spawned.
Reference: [RuSa87] <author> C.A. Ruggiero & J. Sargeant: </author> <title> Control of Parallelism in the Manchester Dataflow Machine, </title> <booktitle> in Proc. 1987 Conference on Functional Programming Languages and Computer Architecture, </booktitle> <address> Portland, Oregon, </address> <year> 1987. </year>
Reference-contexts: However, this is inefficient in space, which is particularly problematic for visualisation purposes, and can be a problem in a real implementation, exascerbating the problem of parallelism control or throttling <ref> [RuSa87] </ref>. We prefer a copying model where a method call happens at an identifiable moment in time, after all the inputs are available, at which point the graph is expanded, and input tokens are placed on the appropriate arcs.
Reference: [Saka89] <author> S. Sakai, Y. Yamaguchi, K. Hiraki, Y. Kodoma, T. Yuba: </author> <title> Architecture of a Dataflow Single Chip Processor, </title> <booktitle> proc 16th Annual Symposium on Computer Architecture, </booktitle> <address> pp46-53, </address> <note> 1989 Page 35 </note>
Reference-contexts: For instance, the graph expansion on firing a node is equivalent to allocating an operand segment in the EM4 machine <ref> [Saka89] </ref>. 1 For more conventional architectures, the code must be transformed to a threads-based model. A suitable model, incorporating variable granularity, lazy task creation, and load balancing via active messages is described in [Wats94].
Reference: [Sarg91] <author> J. Sargeant: </author> <title> Improving Compilation of Implicit Parallel Programs by Using Runtime Information, </title> <booktitle> Proc. Workshop on Compilation of Symbolic Languages for Parallel Computers, </booktitle> <address> San Diego, </address> <year> 1991, </year> <institution> Argonne National Laboratory tech. </institution> <note> report ANL-91/34, pp129-148. </note>
Reference: [Sarg93a] <author> J. Sargeant: </author> <title> United Functions and Objects: An Overview Technical report UMCS-93-1-4, </title> <institution> Department of Computer Science, University of Manchester, </institution> <year> 1993. </year> <note> (Available by anonymous ftp from ftp.cs.man.ac.uk. /pub/TR/UMCS-93-1-4.ps.Z) </note>
Reference-contexts: note similarity to loops. proc write ( v: T ): Void is pre not present do new present = true od end ** ILoc The use of an array of such objects to implement a wavefront algorithm, and generalisation to more powerful non-strict structures such as futures, are described in <ref> [Sarg93a] </ref>. The implementation relies on conditional message acceptance: reads are only accepted after the value is written. In a high performance implementation, this would be a built-in library class, implemented as efficiently as possible, with hardware support if available.
Reference: [Sarg93b] <author> J. Sargeant: </author> <title> Implicit Parallelism: The United Functions and Objects Approach PARLE 93, </title> <address> Munich, </address> <month> June </month> <year> 1993. </year> <note> LNCS 694, pp120-132. </note>
Reference: [Sarg93c] <author> J. Sargeant: </author> <title> Uniting Functional and Object-Oriented Programming Invited Paper, </title> <booktitle> International Sympoisum on Object Technologies for Advanced Software, </booktitle> <address> Kanazawa, Japan, </address> <month> November </month> <year> 1993 </year> <month> LNCS 742, </month> <pages> pp 1-26. </pages>
Reference: [SaWa91] <author> J. Sargeant, I. Watson: </author> <title> Some experiments in controlling the dynamic behaviour of parallel functional programs, </title> <booktitle> Proc. Workshop on the Parallel Implementation of Functional Languages, </booktitle> <address> Southampton, </address> <month> June </month> <year> 1991, </year> <institution> Southampton University tech. </institution> <type> report CSTR 91-07, </type> <pages> pp 103-121. </pages>
Reference-contexts: If thread sizes are statically determined, poor performance results for irregular programs; on the other hand the use of techniques such as dynamic granularity and lazy task creation [Mohr90] makes the dynamic behaviour very complex. For instance <ref> [SaWa91] </ref> shows how the behaviour of a very simple program under such a model can vary dramatically with subtle changes in the exact details of how threads are spawned.
Reference: [SkWe85] <author> S. K. Skedzielewski and M. L. </author> <title> Welcome: Dataflow Graph Optimization in IF1 in J-P. </title> <editor> Jouannaud (editor), </editor> <booktitle> Functional Programming Languages and Computer Architecture, </booktitle> <address> pp17-34, </address> <publisher> Springer-Verlag, </publisher> <address> NY, </address> <year> 1985. </year>
Reference-contexts: The latter is a straightforward representation of (possibly stateful) objects, and it is mostly the computational view which is of interest here. 1 The computational view turns out to be a remarkably conventional dataflow model, with strong similarities to IF1 <ref> [SkWe85] </ref>. Arcs carry values which are primitive data values, references to objects, or references to methods. A node consists of a number of slots, each of which either has an input arc or holds a constant. The first two slots are distinguished. <p> No suspended computation. Nodes become enabled, fire, and always terminate. They never suspend or block. 1 5 Compound nodes The next problem is how to represent other control structures such as conditionals and loops. Our approach here owes a great deal to IF1 <ref> [SkWe85] </ref>. Such structures are represented as special compound nodes, which perform some special-purpose action when fired. The problem with this is that the semantics of compound nodes becomes tied to that of a particular language: SISAL in the case of IF1.
Reference: [Vali90] <author> L. G. Valiant. </author> <booktitle> A Bridging Model for Parallel Computation Communications of the ACM 33(8), </booktitle> <pages> pp 103-111, </pages> <year> 1990. </year>
Reference-contexts: For more general computations (lazy or stateful), graph rewriting provides a very general representation, but the graph transformations are low-level and difficult to visualise and, in the case of laziness, the execution order is even more so. 1.2.3 BSP models Bulk Synchronous Parallel models (e.g. PRAMS <ref> [Vali90] </ref>), are not really computational models in the sense we are considering. There are clearly many sorts of parallel computation for which such models are not the appropriate way to visualise them. The biggest problem, though, is with principle 3.
Reference: [WaSa88] <author> I. Watson, J. Sargeant, P. Watson, J.V. Woods, </author> <booktitle> The Flagship Parallel Machine, </booktitle> <address> Proc.CONPAR 88, Manchester, England, </address> <publisher> Cambridge University Press 1988. </publisher>
Reference: [Wats94] <author> I. Watson: </author> <title> SLAM: Lazy Task Creation and Dynamic Load Balancing Using Active Messages, </title> <type> Internal report, </type> <institution> Department of Computer Science University of Manchester 1994. </institution> <note> In preparation. </note>
Reference-contexts: A suitable model, incorporating variable granularity, lazy task creation, and load balancing via active messages is described in <ref> [Wats94] </ref>. The main problem with such models is making the threads large enough, as conventional machines tend to have very long (relative to our requirements, at least) context switching times.
Reference: [Yone90] <editor> A. Yonezawa (ed.): </editor> <title> ABCL, an Object-oriented Concurrent System, </title> <publisher> MIT press Computer Systems Series, </publisher> <year> 1990. </year>
Reference-contexts: An object may accept certain messages only when particular conditions (defined in terms of the values of the instance variables) are met. Amongst other things, this allows non-strict or lazy data structures to be programmed if required. Unlike most actor languages, e.g. ABCL <ref> [Yone90] </ref>, HAL [HoAg92], UFO has a static type system which provides type safety but with considerable flexibility. Overloading, subtyping via inheritance, and genericity are all supported. In addition, the type system provides important static protection from some of the problems associated with the transition from a pure functional environment.
References-found: 22

