URL: http://www.cs.utexas.edu/users/diz/code.ps
Refering-URL: http://www.cs.utexas.edu/users/diz/pubs.html
Root-URL: 
Title: Asymptotically Good Codes Correcting Insertions, Deletions, and Transpositions (Preliminary Version)  
Author: Leonard J. Schulman David Zuckerman 
Abstract: We present simple, polynomial-time encodable and de-codable codes which are asymptotically good for channels allowing insertions, deletions and transpositions. As a corollary, they achieve exponential error probability in a stochastic model of insertion-deletion. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> A. Albanese, J. Blomer, J. Edmonds, M. Luby, and M. Sudan, </author> <title> "Priority Encoding Transmission," </title> <booktitle> 35th Annual Symposium on Foundations of Computer Science, </booktitle> <year> 1994, </year> <pages> pp. 604-612. </pages>
Reference-contexts: Currently, coding for these two stages is handled separately (and the first stage is usually not coded at all, but interest in such coding appears to be growing, especially for real-time applications <ref> [1, 2] </ref>); the channel as a whole, however, is of the type considered in this paper, and it may be possible to improve transmission rates by coding for the entire process. <p> Along different lines, there are also essentially-optimal codes for lossy packet-based channels such as the internet <ref> [1, 2] </ref>. Those codes handle only deletion of complete packets. Gallager discussed a stochastic model of insertion and deletion errors [4].
Reference: [2] <author> N. Alon, J. Edmonds, and M. Luby, </author> <title> "Linear Time Erasure Codes with Nearly Optimal Recovery," </title> <booktitle> 36th Annual Symposium on Foundations of Computer Science, </booktitle> <year> 1995, </year> <pages> pp. 512-519. </pages>
Reference-contexts: Currently, coding for these two stages is handled separately (and the first stage is usually not coded at all, but interest in such coding appears to be growing, especially for real-time applications <ref> [1, 2] </ref>); the channel as a whole, however, is of the type considered in this paper, and it may be possible to improve transmission rates by coding for the entire process. <p> Along different lines, there are also essentially-optimal codes for lossy packet-based channels such as the internet <ref> [1, 2] </ref>. Those codes handle only deletion of complete packets. Gallager discussed a stochastic model of insertion and deletion errors [4].
Reference: [3] <author> P. A. H. Bours, </author> <title> "Construction of Fixed-Length Insertion/Deletion Correcting Runlength-Limited Code", </title> <journal> IEEE Trans. Inform. Theory, </journal> <month> November </month> <year> 1994, </year> <pages> 40(6) 1841-1856. </pages>
Reference-contexts: E-mail: diz@cs.utexas.edu. Sup ported in part by NSF NYI Grant No. CCR-9457799. * Insertion and deletion errors occur in reading magnetic and optical media (in addition to the more familiar character-alteration errors). This was the motivation for considering insertions and deletions in <ref> [9, 3] </ref>. * If the error correcting code employed in a digital communication system is designed for a synchronous model (i.e. one without insertions or deletions) then occasional synchronization pulses must be transmitted over the channel. <p> If the original codeword has a small enough constant fraction of errors, then a small enough constant fraction of the ff i are modified, so the Justesen code can be used to recover the original word. Bours <ref> [3] </ref>, following on Roth and Siegel [9], improved the constants above by constructing fixed-length (d; k)-constrained codes using the more appropriate Lee metric.
Reference: [4] <author> R. G. Gallager, </author> <title> "Sequential Decoding for Binary Channels with Noise and Synchronization Errors," </title> <institution> Lincoln Laboratory Group Report 2502 September 1966; unclassified document AD266879, Armed Services Technical Information Agency, Arlington Hall Station, Arlington Virginia. </institution>
Reference-contexts: It is likely that the best rate for such a channel is instead achieved by allowing for timing uncertainties in the statistics of the channel, directly into the design of the code. This was the motivation for considering insertions and deletions in <ref> [4] </ref>. * In a medium with only occasional transmissions (e.g. radio) it may not be apparent whether a noise burst has obscured transmissions. * Genetic material undergoes just such transformations between generations. <p> Along different lines, there are also essentially-optimal codes for lossy packet-based channels such as the internet [1, 2]. Those codes handle only deletion of complete packets. Gallager discussed a stochastic model of insertion and deletion errors <ref> [4] </ref>.
Reference: [5] <author> J. Justesen, </author> <title> "A Class of Constructive, Asymptotically Good Algebraic Codes," </title> <journal> IEEE Trans. Inform. Theory, </journal> <month> September </month> <year> 1972, </year> <pages> 18 652-656. </pages>
Reference-contexts: To our knowledge it is the first constructive code of this type. The code can be encoded and decoded in polynomial time up to its designed distance. This is a generalization of the constructive, asymptotically good codes for the Hamming distance given by Justesen <ref> [5] </ref>. Those codes could correct only alterations of characters, whereas here we allow more general errors. Channels with insertions and deletions occur in various situations, for example: fl College of Computing, Georgia Inst. Technology, Atlanta GA 30332-0280. <p> We emphasize that our codes allow arbitrary insertions, deletions and transpositions, subject only to numerical limits; the errors do not have to be of restricted types, or distributed randomly, as in the preceding literature. 2 The Code Our code, like Justesen codes <ref> [5] </ref>, is a two-level code. The outer level can be given by polynomial evaluation (and decoded using the Welch-Berlekamp algorithm [11]); or by any asymptotically good, efficiently encod-able and decodable code. The inner level is given by a code which we find by brute force (e.g. by a "greedy" construction).
Reference: [6] <author> T. Klove, </author> <title> "Codes correcting a single insertion/deletion of a zero or a single peak-shift", </title> <journal> IEEE Trans. Inform. Theory, </journal> <month> January </month> <year> 1995, </year> <pages> 41(1) 279-283. </pages>
Reference-contexts: Somewhat less relevant to our point of view, Klove <ref> [6] </ref> provided perfect codes correcting a single error which may be either a transposition of adjacent characters or an insertion or deletion of a 0. Along different lines, there are also essentially-optimal codes for lossy packet-based channels such as the internet [1, 2].
Reference: [7] <author> V. I. Levenshtein, </author> <title> "Binary Codes Capable of Correcting Deletions, </title> <journal> Insertions, and Reversals". Soviet Physics - Doklady, </journal> <volume> Vol. 10 No. </volume> <pages> 8 pp. 707-710, </pages> <month> February </month> <year> 1966. </year> <journal> Translated from Doklady Akademii Nauk SSSR, </journal> <volume> Vol. 163 No. </volume> <pages> 4 pp. 845-848, </pages> <month> August </month> <year> 1965. </year>
Reference-contexts: The ability to handle transpositions is essential in this example, since the order of 1 transmission of the packets is lost due to their separate routing. Codes for insertion and deletion errors were first considered in 1965 by Levenshtein <ref> [7] </ref>. He obtained bounds on the number of codewords possible for correcting any constant number (not fraction) of errors in a block, and suggested the use of buffers between code-words in an extended transmission. <p> the minimum number of insertions or deletions (i.e. type A errors) required to transform one string into another. (For strings of the same length this is equivalent to the minimum total number of deletions, or the minimum total number of insertions, to convert the two strings into a common string <ref> [7] </ref>.) We will use two slightly different greedily constructed codes S 1 (used in the buffered codes) and S 2 (used in the unbuffered codes). S 1 is a function from f0; 1g t=2 ! f0; 1g 2t (where t will be fi (lg n)).
Reference: [8] <author> B. Reiffen, </author> <title> "Sequential Encoding and Decoding for the Discrete Memoryless Channel," </title> <institution> Res. Lab. of Electronics, M.I.T. </institution> <type> Technical Report, vol. 374, </type> <year> 1960. </year>
Reference-contexts: Along different lines, there are also essentially-optimal codes for lossy packet-based channels such as the internet [1, 2]. Those codes handle only deletion of complete packets. Gallager discussed a stochastic model of insertion and deletion errors [4]. He showed how the random convolutional coding method of Wozencaft and Reiffen <ref> [12, 8] </ref> could be adapted to this situation. (Note that this method is not a code but a probability distribution over codes; successful transmission requires that the transmitter and receiver share a random seed identifying the code to be used.) We will describe a different stochastic model in section 4. <p> This work was conducted before the first constructions of asymptotically good codes; however Gallager showed that, if transmitter and receiver have a shared random sequence, the random convolutional coding method of Wozencraft and Reiffen <ref> [12, 8] </ref> can be employed to yield computationally efficient sequential decoding for rates below a cut-off rate R comp . 5 Discussion We can modify our code to also account for reversals, i.e. the modification of ABC into AB r C, where B r is the reverse of B.
Reference: [9] <author> R. M. Roth and P. H. Siegel, </author> <title> "Lee-metric BCH codes and their application to constrained and partial-response channels", </title> <journal> IEEE Trans. Inform. Theory, </journal> <month> July </month> <year> 1994, </year> <pages> 40(4) 1083-1096. </pages>
Reference-contexts: E-mail: diz@cs.utexas.edu. Sup ported in part by NSF NYI Grant No. CCR-9457799. * Insertion and deletion errors occur in reading magnetic and optical media (in addition to the more familiar character-alteration errors). This was the motivation for considering insertions and deletions in <ref> [9, 3] </ref>. * If the error correcting code employed in a digital communication system is designed for a synchronous model (i.e. one without insertions or deletions) then occasional synchronization pulses must be transmitted over the channel. <p> If the original codeword has a small enough constant fraction of errors, then a small enough constant fraction of the ff i are modified, so the Justesen code can be used to recover the original word. Bours [3], following on Roth and Siegel <ref> [9] </ref>, improved the constants above by constructing fixed-length (d; k)-constrained codes using the more appropriate Lee metric.
Reference: [10] <author> D. Spielman, </author> <title> "Linear-Time Encodable and Decodable Error-Correcting Codes," </title> <booktitle> 27th Annual ACM Symposium on the Theory of Computing, </booktitle> <year> 1995, </year> <pages> pp. 388-397. </pages>
Reference-contexts: It follows that the code T defined above satisfies the required decoding property with c 0 = 3. 2.1.2 Linear-Time Codes We can improve the running time of our decoder, at the expense of worse rate constants, by using Spielman's linear-time codes <ref> [10] </ref>. In fact, we can base this on any asymptotically good and computationally efficient code C : f0; 1g n ! f0; 1g c 0 n .
Reference: [11] <author> L. Welch and E. R. Berlekamp, </author> <title> Error correction of algebraic block codes, </title> <type> US Patent Number 4,633,470, </type> <month> December </month> <year> 1986. </year>
Reference-contexts: The outer level can be given by polynomial evaluation (and decoded using the Welch-Berlekamp algorithm <ref> [11] </ref>); or by any asymptotically good, efficiently encod-able and decodable code. The inner level is given by a code which we find by brute force (e.g. by a "greedy" construction). <p> Set T (x; i) = i ffi g (i) (here ffi denotes 2 concatenation), for 1 i 3n= lg n. To see how to decode this, we use the following lemma, which is the essence of the Welch-Berlekamp decoder <ref> [11] </ref>: Lemma 2.1. Let F be a field with efficiently implementable arithmetic operations, and assume t, d, and k are non-negative integers such that 2t + d &lt; k.
Reference: [12] <author> J. M. Wozencraft, </author> <title> "Sequential Decoding for Reliable Communications," </title> <institution> Res. Lab. of Electronics, M.I.T. </institution> <type> Technical Report, </type> <note> vol. 325, 1957. 6 </note>
Reference-contexts: Along different lines, there are also essentially-optimal codes for lossy packet-based channels such as the internet [1, 2]. Those codes handle only deletion of complete packets. Gallager discussed a stochastic model of insertion and deletion errors [4]. He showed how the random convolutional coding method of Wozencaft and Reiffen <ref> [12, 8] </ref> could be adapted to this situation. (Note that this method is not a code but a probability distribution over codes; successful transmission requires that the transmitter and receiver share a random seed identifying the code to be used.) We will describe a different stochastic model in section 4. <p> This work was conducted before the first constructions of asymptotically good codes; however Gallager showed that, if transmitter and receiver have a shared random sequence, the random convolutional coding method of Wozencraft and Reiffen <ref> [12, 8] </ref> can be employed to yield computationally efficient sequential decoding for rates below a cut-off rate R comp . 5 Discussion We can modify our code to also account for reversals, i.e. the modification of ABC into AB r C, where B r is the reverse of B.
References-found: 12

