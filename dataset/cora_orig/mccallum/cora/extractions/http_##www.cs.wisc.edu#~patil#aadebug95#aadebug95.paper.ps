URL: http://www.cs.wisc.edu/~patil/aadebug95/aadebug95.paper.ps
Refering-URL: http://www.cs.wisc.edu/~patil/aadebug95/aadebug95.html
Root-URL: http://www.cs.wisc.edu
Title: Efficient Run-time Monitoring Using Shadow Processing  
Author: Harish Patil and Charles Fischer 
Address: Wisconsin Madison  
Affiliation: University of  
Note: Presented at AADEBUG95  
Abstract: General purpose multiprocessors are becoming increasingly common. We propose using pairs of processors, one running an ordinary application program and the other monitoring the applications execution. We call the processor doing the monitoring a shadow processor, as it shadows the main processor s execution. We have developed a prototype shadow processing system which supports fullsize programs written in C. Our system instruments an executable user program in C to obtain a main process and a shadow process. The main process performs computations from the original program, occasionally communicating a few key values to the shadow process. The shadow process follows the main process, checking pointer and array accesses and detecting memory leaks. The overhead to the main process is very low almost always less than 10%. Further , since the shadow process avoids repeating some of the computations from the input program, it runs much faster than a single process performing both the computation and monitoring. Sometimes the shadow process can even run ahead of the main process catching errors before they actually occur. Our system has found a number of errors (15 so far) in widely-used Unix utilities and SPEC92 benchmarks. It also detected many subtle memory leaks in various test cases. We believe our approach shows great potential in improving the quality and reliability of application programs at a very modest cost.
Abstract-found: 1
Intro-found: 1
Reference: [ABS94] <author> Todd Austin, Scott Breach, and Gurindar Sohi. </author> <title> Efficient detection of all pointer and array access errors. </title> <booktitle> In Proceedings of the ACM SIGPLAN94 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 290301, </pages> <year> 1994. </year>
Reference-contexts: Sometimes the shadow process can even run ahead of the main process, catching errors before they actually occur. 3. Handling of real programs: Shadow guarding has been implemented to handle real C programs. It provides complete <ref> [ABS94] </ref> error coverage for array and pointer access errors. It has been used to detect previously unreported errors in a number of SPEC benchmarks and Unix utilities. The rest of this report is organized as follows. Section 2 presents details of shadow guarding. <p> Finally, Section 7 summarizes our results. 2 Guards Each pointer p in the main process has a guard G_p in the shadow. The guard for a pointer stores spatial and temporal attributes for the pointers referent. The idea is similar to safe pointers used in <ref> [ABS94] </ref>. We will use the term pointer to include array references as well because when an array identifier appears in an 4 Presented at AADEBUG95 expression, the type of the identifier is converted from array of T to pointer to T [HS91]. <p> It has 56Mbyte of real memory and it runs SunOS Release 5.3 [UNIX system V release 4]. Suns multi-threading library was used to create main and shadow threads. The test programs included integer benchmarks from the SPEC92 test suite, one program, yacr, from the SafeC <ref> [ABS94] </ref> test suite and many commonly used utilities from SunOS 4.1.3. A utility called fuzz [MLS90] was used to generate random input for the SunOS utilities. <p> If a pointers intended referent is freed and the memory is reallocated, dereferencing the pointer should lead to a temporal access error; however Purify is also unable to detect that error. Austin et al <ref> [ABS94] </ref> have proposed translation of C programs to SafeC programs to handle array and pointer access errors. Their technique provides complete error detection under certain conditions. They have reported execution time overhead in the range of 130% to 540% for 6 (optimized) test programs. <p> An input C program, annotated with macros, results in a C++ program which combined with some run-time support performs pointer access checking. Shadow guarding shares the completeness of error detection with SafeC. Unlike the system described in <ref> [ABS94] </ref>, shadow guarding is completely automated. Temporal access errors in SafeC are caught using a capability attribute which is an essentially unique value per object, much like the lock in shadow guards. However, checking temporal validity of a pointer access involves an expensive associative search in a capability database.
Reference: [AG88] <author> Ziya Aral and Ilya Gertner. </author> <title> High-level debugging in Parasight. </title> <booktitle> In ACM Workshop on Parallel and Distributed Debugging, </booktitle> <pages> pages 151162, </pages> <month> May </month> <year> 1988. </year>
Reference-contexts: In contrast shadow processing is a run-time technique that removes expensive tracing from the critical execution path of a program and shifts the cost to another processor. Parasight <ref> [AG88] </ref> is a parallel programming environment for shared-memory multiprocessors. The system allows creation of observer programs (parasites) that run concurrently with a target program and monitor its behavior.
Reference: [Chr84] <author> Thomas W. Christopher. </author> <title> Reference count garbage collection. </title> <journal> Software - Practice and Experience, </journal> <volume> 14(6):503507, </volume> <month> June </month> <year> 1984. </year>
Reference-contexts: dangling references); - /* Using G_p.shptr recursively decrement refcounts of referents of embedded pointers */ /* if p is a multilevel pointer or a pointer to a struct, G_p.shptr needs to be freed as well */ if (G_p.shptr) free (G_p.shptr); /*Reset fields of G_p*/ 8 Presented at AADEBUG95 reference counting <ref> [Chr84] </ref> or by moving to a mark and sweep or a copying garbage collection scheme [Wil] will require cooperation from the main process. We currently ignore memory leaks due to circular data structures. There may be unions overlaying pointers in a C program.
Reference: [Det90] <author> David L. Detlefs. </author> <title> Concurrent garbage collection for C++. </title> <type> CMU-CS-90-119, </type> <institution> School of Computer Science, Carnegie Mellon University, </institution> <address> Pittsburgh, PA 15213, </address> <month> May </month> <year> 1990. </year>
Reference-contexts: Garbage collection [Wil] is a well-known technique for preventing memory leaks by reclaiming unusable memory blocks. Garbage collectors are routinely used for languages such as ML and LISP. Garbage collection in C is complicated by features such as pointer arithmetic, casting, and unions <ref> [Det90] </ref>. We have modified our shadow guarding system to detect memory leaks in C programs. We use the shadow process to perform concurrent garbage detection. Our approach is based on reference counting garbage collection [Wil].
Reference: [EGH94] <author> Marayam Emami, Rakesh Ghiya, and Laurie Hendren. </author> <title> Context-sensitive interprocedural points-to analysis in the presence of function pointers. </title> <booktitle> In Proceedings of the ACM SIGPLAN94 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 242256, </pages> <year> 1994. </year>
Reference-contexts: Both the sequential approach and the shadow guarding approach can equally benefit from these optimizations. We are currently exploring an optimization to reduce the overhead of temporal checks. We want to statically determine the life-time of the referent of pointers. The approach based on <ref> [EGH94] </ref> classifies pointers into the following categories: i. Points_to_NULL: These are uninitialized pointers whose dereference is reported at compile time. ii. Points_to_global iii. Points_to_local_of_current_function iv. Points_to_local_of_exited_function: Dereferencing these pointers is illegal and can be reported at compile time. v. Points_to_heap.
Reference: [Feu73] <author> E. A. Feustal. </author> <title> On the advantages of tagged architectures. </title> <journal> IEEE Transactions on Computers, </journal> <volume> C-22(7):12411258, </volume> <month> July </month> <year> 1973. </year>
Reference-contexts: Shadow Processing 3 Presented at AADEBUG95 program variables and it does not change the result of valid computations. Hence run-time checking can be overlapped with normal computation. One approach to concurrent run-time checking is to use specialized hardware. Tagged hardware <ref> [Feu73] </ref> can be used for type-checking at run-time. Watchdog processors [MJ88] are used to provide control ow checking. Unfortunately, specialized architectures are not widely available and they may not be able to support the full range of desirable checks (e.g., pointer validity checking).
Reference: [GGPY89] <author> Patrick Gelsinger, Paolo Gargini, Gerhard Parker, and Albert Y. C. Yu. </author> <title> Microprocessors circa 2000. </title> <journal> IEEE Spectrum, </journal> <pages> pages 4347, </pages> <month> October </month> <year> 1989. </year>
Reference-contexts: Vendors such as Sun and SGI offer multiprocessor workstations. Dual processor PCs have started appearing in the market. With rapid advances in microprocessor technology, high-performance microprocessors should soon routinely incorporate as many as four general-purpose central processing units on a single chip <ref> [GGPY89] </ref>. The goal, of course, is to use extra processors in a multi processor workstation to solve problems beyond the scope of a single processor. The reality is that such a workstation often operates like a single-user time-sharing system. Our department has more than 60 dual processor workstations.
Reference: [Gup93] <author> Rajiv Gupta. </author> <title> Optimizing array bound checks using flow analysis. </title> <journal> ACM Letters on Programming Languages and Systems, </journal> <volume> 2:135150, </volume> <month> March-December </month> <year> 1993. </year>
Reference-contexts: To reduce slowdown due to pointer checking, a variety of range checking optimizations such as <ref> [Gup93] </ref> can be applied to reduce the number of checks done at run-time. Both the sequential approach and the shadow guarding approach can equally benefit from these optimizations. We are currently exploring an optimization to reduce the overhead of temporal checks.
Reference: [HJ92] <author> Reed Hastings and Bob Joyce. Purify: </author> <title> Fast detection of memory leaks and access errors. </title> <booktitle> In Proceedings of the Winter USENIX Conference, </booktitle> <pages> pages 125136, </pages> <year> 1992. </year>
Reference-contexts: Extensive run-time checking provided by diagnostic compilers incurs significant run-time costs. In [Ste92], run-time checks were added to a C compiler. The code generated ran 10 times slower than the original code. Similar slowdowns are reported for commercially available run-time error checking systems such as Purify <ref> [HJ92] </ref>. The high cost of run-time checks restricts their use to the program development phase. When programs are fully developed and tested, they are assumed to be correct and run-time checks are disabled. This is dangerous because errors in heavily-used programs can be extremely destructive. <p> It detects approximately 70 run-time violations involving illegal array and pointer accesses, improper function arguments, type mismatches etc. Interpretation of the intermediate code for supporting these checks is very expensive though; the evaluator executes C code approximately 200 times slower than the compiled object code. Purify <ref> [HJ92] </ref> is a commercially available system that modifies object files to, in essence, implement a byte-level tagged architecture in software. It maintains a bit table at run-time to hold a two-bit state code for each byte in the memory.
Reference: [HS91] <author> Samual P. Harbison and Guy L. Steele Jr. </author> <title> C - A Reference Manual. </title> <publisher> Prentice Hall, 3rd edition, </publisher> <year> 1991. </year>
Reference-contexts: We will use the term pointer to include array references as well because when an array identifier appears in an 4 Presented at AADEBUG95 expression, the type of the identifier is converted from array of T to pointer to T <ref> [HS91] </ref>. Operations on pointers in the main process lead to operations on guards in the shadow. Structures and unions containing pointers have shadow objects containing guards. Valid pointers in C contain addresses of data objects (including pointers) or functions. <p> In Figure 3, the intended referent of p is another pointer q, G_p.shptr points to the guard of q viz. G_q. Thus the 2-level dereference **p leads to checking of two guards G_p and *(G_p.shptr) (which is G_q). In C, invalid pointers <ref> [HS91] </ref> can be created by casting arbitrary integer values to pointer types, by deallocating the storage for the referent of the pointer, or by using pointer arithmetic to produce a pointer pointing outside its intended referent. <p> If p is a multi-level pointer, var must be a pointer with its own guard G_var. In this case the statement G_p.shptr = &G_var is needed. Otherwise a NULL value is assigned to G_p.shptr. setjmp and longjmp functions in C implement a primitive form of nonlocal jumps <ref> [HS91] </ref>. setjmp (env) records its callers environment in the jump buffer env, an implementation-defined array. The function longjmp takes as its argument a jump buffer previously filled by a calling setjmp and restores the environment stored in that buffer. <p> In the example above, a garbage report for pu will lead to an appropriate recursive garbage detection involving the guard for its active pointer field. The run-time type tag is also useful in detecting the misuse <ref> [HS91] </ref> of the value of one field of a union as another field. 4 Implementation An overview of our prototype shadow processing system is shown in Figure 4. Analyzing and tracking expressions involving pointers in C can be a formidable task. These expressions may involve side-effects and multiple dereferences.
Reference: [HS92] <author> Laurie J. Hendren and Bhama Sridharan. </author> <title> The SIMPLE AST - McCAT compiler. ACAPS design note 36, </title> <institution> School of Computer Science, McGill University, Montreal, Canada, </institution> <year> 1992. </year>
Reference-contexts: Further, they can occur as loop conditions, array indices, actual parameters etc. A simplification phase was introduced to restrict the case analysis required for shadow guarding. Our simplifier is a C-to-C translator whose output is a subset of C similar to the intermediate representation called SIMPLE from McGill university <ref> [HS92] </ref>. Simplification greatly reduces the number of cases to be analyzed by the translator phase - there are only 15 types of basic statements in any simplified program. However a large number of temporary variables are introduced. These variables increase the demand on register allocation.
Reference: [KLP88] <author> Stephan Kaufer, Russel Lopez, and Sesha Pratap. </author> <title> Saber-C an interpreter-based programming environment for the C language. </title> <booktitle> In Proceedings of the Summer USENIX Conference, </booktitle> <pages> pages 161171, </pages> <year> 1988. </year>
Reference-contexts: Like shadow processing, the ANNA to ADA transformer uses the idea of executing checking code concurrently with the underlying program. However, it generates numerous tasks per annotation, which may lead to excessive overhead. Executing user defined assertions seems like a good application for shadow processing. CodeCenter <ref> [KLP88] </ref> is a programming environment that supports an interpreter-based development scheme for the C language. The evaluator in CodeCenter provides a wide range of run-time checks. It detects approximately 70 run-time violations involving illegal array and pointer accesses, improper function arguments, type mismatches etc.
Reference: [Lar90] <author> James Larus. </author> <title> Abstract execution: A technique for efficiently tracing programs. </title> <journal> Software - Practice and Experience, </journal> <volume> 20(12):12411258, </volume> <month> December </month> <year> 1990. </year>
Reference-contexts: Hence a separate storage class attribute, as in safe pointers, to catch freeing of global objects is not necessary. Shadow processing was motivated, in part, by a tool called AE that supports abstract execution 13 Presented at AADEBUG95 <ref> [Lar90] </ref>. AE is used for efficient generation of detailed program traces. A source program, in C, is instrumented to record a small set of key events during execution.
Reference: [LLM88] <author> Michael J. Litzkow, Miron Livny, and Matt W. </author> <title> Mutka. Condor - A hunter of idle workstations. </title> <booktitle> In Proceedings of the 8th International Conference on Distributed Computing Systems, </booktitle> <pages> pages 104111, </pages> <year> 1988. </year>
Reference-contexts: The reality is that such a workstation often operates like a single-user time-sharing system. Our department has more than 60 dual processor workstations. We monitored 18 of those machines over a period of 24 hours using condor <ref> [LLM88] </ref>. We found that 83% of the dual processor workstations that were active had a load average less than one. This implies that most of the time a dual processor workstation was busy, one processor was running an application while the other processor was idle.
Reference: [MJ88] <author> A. Mahmood and McCluskey E. J. </author> <title> Concurrent error detection using watchdog processor - a survey. </title> <journal> IEEE Transactions on Computers, </journal> <volume> C-37(2):160174, </volume> <month> February </month> <year> 1988. </year>
Reference-contexts: Hence run-time checking can be overlapped with normal computation. One approach to concurrent run-time checking is to use specialized hardware. Tagged hardware [Feu73] can be used for type-checking at run-time. Watchdog processors <ref> [MJ88] </ref> are used to provide control ow checking. Unfortunately, specialized architectures are not widely available and they may not be able to support the full range of desirable checks (e.g., pointer validity checking). We propose to use general purpose multi-processors for concurrent run-time checking.
Reference: [MLS90] <author> Barton P. Miller, Fredriksen Lars, and Brian So. </author> <title> An empirical study of the reliability of Unix utilities. </title> <journal> Communications of the ACM, </journal> <volume> 33(12):3244, </volume> <month> December </month> <year> 1990. </year>
Reference-contexts: Even if an erroneous program crashes, it may be difficult to repeat the error inside a debugger. Further, debugging long running programs can be very time consuming. Undiscovered errors in heavily-used programs may not be rare; a study <ref> [MLS90] </ref> has shown that as many as a quarter of the most commonly used Unix utilities crash or hang when presented with unexpected inputs. Thus there is a strong case for running programs with checks routinely enabled. Naturally, these checks should be as inexpensive as possible. <p> Suns multi-threading library was used to create main and shadow threads. The test programs included integer benchmarks from the SPEC92 test suite, one program, yacr, from the SafeC [ABS94] test suite and many commonly used utilities from SunOS 4.1.3. A utility called fuzz <ref> [MLS90] </ref> was used to generate random input for the SunOS utilities. SPEC benchmarks were tested with their reference inputs. 5.1 Errors uncovered Run-time errors which do not crash programs can go unnoticed for a long time. Shadow guarding reports such errors as they occur. <p> These programs (with the number of errors in parentheses) were decompress (1) and sc (2) from SPEC92 and cb (1), ptx (4), and ul (1) from SunOS. Four SunOS utilities col, deroff, uniq, and units crashed with random inputs. These were already reported to be buggy <ref> [MLS90] </ref> in earlier versions of SunOS. However, we found new errors in these utilities as well. In all, we uncovered 15 errors in nine programs. A complete report on the errors in the programs tested so far can be found in [PF94].
Reference: [PF94] <author> Harish Patil and Charles Fischer. </author> <title> Shadow Guarding: Run-time checking you can afford. </title> <type> TR 1254, </type> <institution> Computer Sciences department, University of Wisconsin, Madison, Wisconsin, </institution> <month> November </month> <year> 1994. </year> <note> Available by anonymous ftp from ftp.cs.wisc.edu. </note>
Reference-contexts: These were already reported to be buggy [MLS90] in earlier versions of SunOS. However, we found new errors in these utilities as well. In all, we uncovered 15 errors in nine programs. A complete report on the errors in the programs tested so far can be found in <ref> [PF94] </ref>. We expect further testing will reveal errors in other widely-used programs. 5.2 Overhead to the user program Table 1 compares (real) execution time of the main process with that of the original program. <p> However, all the errors we discovered were reported by the shadow before the main process had finished. Our frontend for shadow guarding has been functional for 8 months. Shadow guarding has been successful in detecting bugs in many real programs. A technical report describing shadow guarding is now available <ref> [PF94] </ref>. We have since then modified our prototype to detect memory leaks as outlined in Section 3. Table 2 presents the cost of memory leak detection. Test cases compress, decompress, and alvinn do not need memory leak detection because they do not allocate memory dynamically.
Reference: [Rep89] <author> Thomas Reps. </author> <title> Demonstration of a prototype tool for program integration. </title> <type> TR 819, </type> <institution> Computer Sciences department, University of Wisconsin, Madison, Wisconsin, </institution> <month> January </month> <year> 1989. </year>
Reference-contexts: We modified the shadow program for alvinn to delete statements not necessary for guarding. The resulting shadow process ran 21% faster than the sequential checking process. We are currently interfacing our translator with a slicing backend that is an offshoot of the Wisconsin Program-Integration System <ref> [Rep89] </ref>. Slicing should help shadow guarding in two ways. First since the shadow may not need all the input values and return values of all the unsafe calls, the number of communication calls in the main will be reduced.
Reference: [SM93] <author> Sriram Sankar and Manas Mandal. </author> <title> Concurrent runtime monitoring of formally specified programs. </title> <booktitle> Computer, </booktitle> <address> 26(3):3241, </address> <month> March </month> <year> 1993. </year>
Reference-contexts: An ANNA to ADA transformer that allows either sequential or concurrent execution of the checking code is described in <ref> [SM93] </ref>. Concurrent run-time monitoring is achieved by defining an ADA task containing a checking function for each annotation. Calls to the checking function are automatically inserted at places where inconsistency with respect to the annotation can arise.
Reference: [Ste92] <author> Joseph L. Steffen. </author> <title> Adding run-time checking to the portable C compiler. </title> <journal> Software Practice and Experience, </journal> <volume> 22(4):825834, </volume> <month> April </month> <year> 1992. </year>
Reference-contexts: These slices can be combined to form the shadow program. 1.1 Shadow run-time checking Run-time checks can detect errors that cannot be detected at compile-time, including array bound violations, invalid pointer accesses, and use of uninitialized variables. Extensive run-time checking provided by diagnostic compilers incurs significant run-time costs. In <ref> [Ste92] </ref>, run-time checks were added to a C compiler. The code generated ran 10 times slower than the original code. Similar slowdowns are reported for commercially available run-time error checking systems such as Purify [HJ92]. The high cost of run-time checks restricts their use to the program development phase.
Reference: [Tip94] <author> Frank Tip. </author> <title> A survey of program slicing techniques. </title> <type> Report CS-R9438, </type> <institution> Centrum voor Wiskunde en Informatica (CWI), </institution> <address> Amsterdam, </address> <year> 1994. </year>
Reference-contexts: The shadow program in this case is obtained from the main program by extracting all those statements which affect the analysis being performed. This can be achieved by taking a program slice <ref> [Tip94] </ref> with the slicing criteria involving the variables required for the analysis. These slices can be combined to form the shadow program. 1.1 Shadow run-time checking Run-time checks can detect errors that cannot be detected at compile-time, including array bound violations, invalid pointer accesses, and use of uninitialized variables.
Reference: [Wil] <author> Paul R. Wilson. </author> <title> Uniprocessor garbage collection techniques. </title> <journal> ACM Computing Surveys. </journal> <note> To appear. </note>
Reference-contexts: Memory leaks in long-running programs add up and may ultimately exhaust the available memory. Garbage collection <ref> [Wil] </ref> is a well-known technique for preventing memory leaks by reclaiming unusable memory blocks. Garbage collectors are routinely used for languages such as ML and LISP. Garbage collection in C is complicated by features such as pointer arithmetic, casting, and unions [Det90]. <p> Garbage collection in C is complicated by features such as pointer arithmetic, casting, and unions [Det90]. We have modified our shadow guarding system to detect memory leaks in C programs. We use the shadow process to perform concurrent garbage detection. Our approach is based on reference counting garbage collection <ref> [Wil] </ref>. The shadow process maintains a count of references to each heap object allocated in the main process. These reference counts are maintained in a data structure very similar to the shadow heap. <p> Hence after a call free (p) the reference counts for all the heap objects being pointed to from within the referent of p are decremented as shown below. A well known problem with reference counting garbage collection is its inability to reclaim circular data structures which have become garbage <ref> [Wil] </ref>. <p> /* if p is a multilevel pointer or a pointer to a struct, G_p.shptr needs to be freed as well */ if (G_p.shptr) free (G_p.shptr); /*Reset fields of G_p*/ 8 Presented at AADEBUG95 reference counting [Chr84] or by moving to a mark and sweep or a copying garbage collection scheme <ref> [Wil] </ref> will require cooperation from the main process. We currently ignore memory leaks due to circular data structures. There may be unions overlaying pointers in a C program. For example: Suppose pu is a pointer to the union described above.
References-found: 22

