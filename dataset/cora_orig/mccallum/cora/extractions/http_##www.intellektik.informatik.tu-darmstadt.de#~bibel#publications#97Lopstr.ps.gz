URL: http://www.intellektik.informatik.tu-darmstadt.de/~bibel/publications/97Lopstr.ps.gz
Refering-URL: http://www.intellektik.informatik.tu-darmstadt.de/~bibel/
Root-URL: http://www.aic.nrl.navy.mil/~aha/people.html
Phone: 2  
Title: A Multi-Level Approach to Program Synthesis  
Author: W. Bibel D. Korn C. Kreitz F. Kurucz J. Otten S. Schmitt G. Stolpmann 
Address: Alexanderstr. 10, 64283 Darmstadt, Germany  Ithaca, NY 14853, USA  
Affiliation: 1 Fachgebiet Intellektik, Fachbereich Informatik, Darmstadt University of Technology  Department of Computer Science, Cornell University,  
Abstract: We present an approach to a coherent program synthesis system which integrates a variety of interactively controlled and automated techniques from theorem proving and algorithm design at different levels of abstraction. Besides providing an overall view we summarize the individual research results achieved in the course of this development. 
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> D. Basin & T. Walsh. </author> <title> A calculus for and termination of rippling. </title> <journal> Journal of Automated Reasoning, </journal> <pages> 16(1-2), pp. 147-180, </pages> <year> 1996. </year>
Reference-contexts: For deriving recursive programs induction techniques are needed during the proof process. In [23] we have developed an induction prover for "simple" induction problems which is based on rippling <ref> [9, 1] </ref>. <p> To perform rewriting in a goal oriented way, a special technique called rippling was introduced by Bundy [9]. A more refined and formalized version has later been developed by Basin and Walsh <ref> [1] </ref> from which we take the central ideas for our presentation. Rippling uses annotations on subterms to mark the differences between the conclusion and the hypothesis. It first identifies additional function symbols in the conclusion, called wave fronts, which will be annotated by surrounding boxes. <p> Backtracking is required to find a sequence of rules which ripples all wave fronts into sink positions. A sink heuristic, defined in <ref> [1] </ref>, makes sure that rippling-in always ripples a wave front towards sink positions. <p> From the measure MD we have developed a new reduction ordering dist which can be computed more efficiently than the ordering comp , the compound reduction ordering for rippling-in presented in <ref> [1] </ref>. This advantage becomes remarkable if multi-wave holes are used where wave fronts may contain more then one wave hole.
Reference: 2. <author> J. L. Bates & R. L. Constable. </author> <title> Proofs as programs. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 7(1) </volume> <pages> 113-136, </pages> <year> 1985. </year>
Reference-contexts: Since it is based on the proofs-as-programs paradigm to program synthesis <ref> [2] </ref> it allows to treat algorithm design strategies as proof procedures and to integrate a great variety of reasoning techniques on all levels of abstraction. Finally it supports interaction with a human expert (programmer) whenever the automated strategies turn out to be too weak. <p> However, whenever a piece of code shall be extracted from the proof, it is necessary to convert the proofs generated by a search procedure back into a constructive sequent proof which, according to the proofs-as-program paradigm <ref> [2] </ref>, can be turned into a program. In [36, 22] we have developed an embedding of connection based proof methods into NuPRL based on such conversions.
Reference: 3. <editor> J. Van Benthem Correspondence Theory In D. Gabbay & F. Guenther, eds., </editor> <booktitle> Handbook of Philosophical Logic, II, </booktitle> <pages> pp. 167-247, </pages> <publisher> Reidel, </publisher> <year> 1984. </year>
Reference-contexts: For the sake of completeness axioms encoding the properties of the accessibility relation R will be added which then must imply the translated formula. This technique is known as the relational translation <ref> [26, 27, 3] </ref>. A major difficulty of this approach is the potential undecidability of the resulting classical formula. On the other hand, any intuitionistic non-theorem has a finite countermodel.
Reference: 4. <author> W. Bibel. </author> <title> On matrices with connections. </title> <journal> Journal of the ACM, </journal> <pages> 28(633-645), </pages> <year> 1981. </year>
Reference-contexts: This procedure will be embedded as trusted refiner which creates a sequent proof on demand. Matrix methods for constructive first-order logic use a non-clausal extension of the connection method <ref> [4, 30] </ref>. They have been combined with an algorithm for translating matrix proofs into sequent proofs [36] and integrated into NuPRL as a proof tactic [22]. Inductive proofs will be generated by proof planners involving rippling [9] and rewrite techniques. <p> It is based on a matrix characterization of logical validity: A formula F is (classically) valid iff the matrix of F is (classically) complementary <ref> [4, 5] </ref>. In propositional classical logic the matrix of a formula F is complementary if there is a spanning set C of connections for F .
Reference: 5. <author> W. Bibel. </author> <title> Automated Theorem Proving. </title> <publisher> Vieweg Verlag, </publisher> <year> 1987. </year>
Reference-contexts: It is based on a matrix characterization of logical validity: A formula F is (classically) valid iff the matrix of F is (classically) complementary <ref> [4, 5] </ref>. In propositional classical logic the matrix of a formula F is complementary if there is a spanning set C of connections for F . <p> More precisely, the history of matrix proofs will be integrated into the conversion process rather than using only the spanning matings. This makes our procedure depend on a particular proof search strategy, i.e. an extension procedure <ref> [5, 32] </ref>. But a compact encoding of this proof knowledge into the conversion process (which can be done in polynomial time in the size of the matrix proof) allows us to derive the reconstruction knowledge in terms of a few elegant conditions.
Reference: 6. <author> W. Bibel. </author> <title> Toward predicative programming. </title> <editor> In M. R. Lowry & R. McCartney, eds., </editor> <booktitle> Automating Software Design, </booktitle> <pages> pp. 405-424, </pages> <publisher> AAAI Press / The MIT Press, </publisher> <year> 1991. </year>
Reference-contexts: This tech nique heavily relies on verified domain knowledge [42] but is very effective. The MAPS enterprise may be seen as a milestone in the long tradition of program synthesis efforts of our group which started as early as 1974 eventually leading to the program system LOPS (see <ref> [6] </ref> for a detailed exposition of this development). In lack of powerful proof systems at that time the emphasis then was laid on high-level strategies guiding the synthesis (or search for a proof) while in MAPS it is laid more on the proof obligations resulting in the synthesis task.
Reference: 7. <author> W. Bibel, S. Bruning, U. Egly, T. Rath. Komet. </author> <booktitle> In 12 th Conference on Automated Deduction, LNAI 814, </booktitle> <pages> pp. 783-787. </pages> <publisher> Springer Verlag, </publisher> <year> 1994. </year>
Reference-contexts: a variety of propositional formulas with a performance competitive to any intuitionistic decision mechanism known to us. 6 2.2 Proof Construction in Intuitionistic First-Order Logic The connection method is a well-known proof procedure for classical first-order logic and has successfully been realized in theorem provers like Setheo [24] or KoMeT <ref> [7] </ref>. It is based on a matrix characterization of logical validity: A formula F is (classically) valid iff the matrix of F is (classically) complementary [4, 5].
Reference: 8. <author> W. Bibel, D. Korn, C. Kreitz, S. Schmitt. </author> <title> Problem-oriented applications of automated theorem proving. </title> <editor> In J. Calmet & C. Limongelli, eds., </editor> <booktitle> Design and Implementation of Symbolic Computation Systems, </booktitle> <publisher> LNCS 1126, Springer Verlag, </publisher> <pages> pp. 1-21, </pages> <year> 1996. </year>
Reference-contexts: The present paper considerably extends the preliminary outline of the concepts underlying MAPS given in <ref> [8] </ref> and presents the results achieved in the meantime. In the following we shall describe our proof methods and their integration into the NuPRL program development system.
Reference: 9. <author> A. Bundy, F. van Harmelen, A. Ireland, A. Smaill. Rippling: </author> <title> a heuristic for guiding inductive proofs. </title> <journal> Artificial Intelligence, </journal> <year> 1992. </year>
Reference-contexts: They have been combined with an algorithm for translating matrix proofs into sequent proofs [36] and integrated into NuPRL as a proof tactic [22]. Inductive proofs will be generated by proof planners involving rippling <ref> [9] </ref> and rewrite techniques. Sequences of rewrite steps will be transformed into applications of cut- and substitution rules while other techniques will deter mine the parameters of the general induction rule [25, 23]. High-level synthesis strategies will be integrated by verifying formal theorems about schematic program construction [18, 19]. <p> For deriving recursive programs induction techniques are needed during the proof process. In [23] we have developed an induction prover for "simple" induction problems which is based on rippling <ref> [9, 1] </ref>. <p> To perform rewriting in a goal oriented way, a special technique called rippling was introduced by Bundy <ref> [9] </ref>. A more refined and formalized version has later been developed by Basin and Walsh [1] from which we take the central ideas for our presentation. Rippling uses annotations on subterms to mark the differences between the conclusion and the hypothesis.
Reference: 10. <author> R. L. Constable, et. al. </author> <title> Implementing Mathematics with the NuPRL proof development system. </title> <publisher> Prentice Hall, </publisher> <year> 1986. </year>
Reference-contexts: If none of the available proof procedures suits the proof task to be solved the program development system will have to rely on user interaction (right hand side). As common platform for our work we have chosen the NuPRL proof development system <ref> [10] </ref> since its underlying logical calculus can deal with a rich variety of problems from mathematics and programming and allows to formalize even high-level strategies in a natural way.
Reference: 11. <author> M. Davis & H. Putnam. </author> <title> A computing procedure for quantification theory. </title> <journal> Journal of the ACM, </journal> <volume> 7 </volume> <pages> 201-215, </pages> <year> 1960. </year>
Reference-contexts: For any further details cf. [17]. To sum up we have achieved a morphism from intuitionistic to classical logic that maps propositional input formulas to propositional output formulas (note that no quantifiers or uninstantiated terms occur in the output formula). 5 A non-clausal Davis-Putnam proof procedure. The Davis-Putnam pro-cedure <ref> [11, 12] </ref> is one of the most successful proof procedures for classical propositional logic.
Reference: 12. <author> M. Davis, G. Logemann, D. Loveland. </author> <title> A machine program for theorem-proving. </title> <journal> Communications of the ACM, </journal> <volume> 5 </volume> <pages> 394-397, </pages> <year> 1962. </year>
Reference-contexts: For any further details cf. [17]. To sum up we have achieved a morphism from intuitionistic to classical logic that maps propositional input formulas to propositional output formulas (note that no quantifiers or uninstantiated terms occur in the output formula). 5 A non-clausal Davis-Putnam proof procedure. The Davis-Putnam pro-cedure <ref> [11, 12] </ref> is one of the most successful proof procedures for classical propositional logic.
Reference: 13. <author> M. C. </author> <title> Fitting. First-Order Logic and Automated Theorem Proving. </title> <publisher> Springer Verlag, </publisher> <year> 1990. </year>
Reference-contexts: We only have to change the notion of complementarity (i.e. the prefix unification) while leaving the path checking algorithm unchanged. Path checking can also be performed by using a semantic tableau <ref> [13] </ref>. The prover ileanTAP [28] is based on free-variable semantic tableaux extended by the above-mentioned prefix unification.
Reference: 14. <author> G. </author> <title> Gentzen. Untersuchungen uber das logische Schlieen. </title> <journal> Mathematische Zeitschrift, </journal> <volume> 39 </volume> <pages> 176-210, 405-431, </pages> <year> 1935. </year>
Reference-contexts: Certain rules in the intuitionistic sequent calculus LJ differ from the classical LK <ref> [14] </ref>. The arising non-permutabilities between these rules need a special treatment. In the matrix characterization for intuitionistic logic [44] this is done by an additional intuitionistic substitution J . This substitution has to make the prefixes of each connection identical and therewith complementary. <p> Its integration into NuPRL basically consists of a transformation from LJ mc -proofs into sequent proofs in Gentzen's LJ <ref> [14] </ref>, the first-order 8 fragment of NuPRL's calculus. To allow a structure preserving transformation the cut -rule had to be used in a restricted and regular manner. For the sake of clarity we have hidden its application within an extended sequent calculus LJ ? .
Reference: 15. <author> P. Jackson. </author> <title> NuPRL's Metalanguage ML. Reference Manual and User's Guide, </title> <institution> Cornell Univer--sity, </institution> <year> 1994. </year>
Reference-contexts: The prover is implemented in NuPRL-ML <ref> [15] </ref> and called during a NuPRL proof session via a tactic Ripple. This tactic prepares the proof goal for the prover by applying an appropriate induction scheme and extracting the induction step.
Reference: 16. <author> P. Jackson. </author> <title> The NuPRL Proof Development System, Version 4.1. Reference Manual and User's Guide, </title> <institution> Cornell University, </institution> <year> 1994. </year>
Reference-contexts: Then the goal is forced to fail and the extracted type information will be used for the original proof. The last improvement allows premises of the current proof goal to be used as wave rules if they are in NuPRL's universal formula format <ref> [16] </ref>. So second order proofs over universally quantified functions can be established by using the recursive definitions of these functions in the premises as wave rules. Many additional improvements have been made for adapting the basic translation approach to the rippling-distance strategy.
Reference: 17. <author> D. Korn & C. </author> <title> Kreitz. Deciding intuitionistic propositional logic via translation into classical logic. </title> <editor> In W. McCune, ed., </editor> <booktitle> 14 th Conference on Automated Deduction, LNAI 1249, </booktitle> <pages> pp. 131-145, </pages> <publisher> Springer Verlag, </publisher> <year> 1997. </year>
Reference-contexts: All our automated proof procedures were originally developed independently from the common platform and we had to provide techniques for integrating them into the top-down sequent proof style of NuPRL. 2 Formulas from propositional intuitionistic logic will be decided by translating them into classical logic <ref> [17] </ref> and applying a non-normal form Davis-Putnam procedure [28]. This procedure will be embedded as trusted refiner which creates a sequent proof on demand. Matrix methods for constructive first-order logic use a non-clausal extension of the connection method [4, 30]. <p> One can easily show that for any world w and any propositional formula F there always is an accessible F -maximal world max F (w) (cf. <ref> [17] </ref>). Once we have (potentially) added w 1 to our countermodel as shown above we know that there must also be an F -maximal max F (w 1 ) accessible from w 1 , where F is the input formula of our translation. <p> However, instead of positive occurrences of universal quantifications over accessible worlds we use an appropriate such term as a representative for an arbitrary accessible world. Negatively occuring quantifications are replaced by finite conjunctions over all such terms denoting an accessible world. For any further details cf. <ref> [17] </ref>. To sum up we have achieved a morphism from intuitionistic to classical logic that maps propositional input formulas to propositional output formulas (note that no quantifiers or uninstantiated terms occur in the output formula). 5 A non-clausal Davis-Putnam proof procedure.
Reference: 18. <author> C. </author> <title> Kreitz. METASYNTHESIS: Deriving Programs that Develop Programs. </title> <type> Thesis for Habilitation, </type> <institution> TH Darmstadt, </institution> <year> 1992. </year> <note> Forschungsbericht AIDA-93-03. </note>
Reference-contexts: Sequences of rewrite steps will be transformed into applications of cut- and substitution rules while other techniques will deter mine the parameters of the general induction rule [25, 23]. High-level synthesis strategies will be integrated by verifying formal theorems about schematic program construction <ref> [18, 19] </ref>. For each strategy a theorem describing the axioms for the correctness of a particular class of algorithms will serve as derived inference rule. It will be accompanied by specialized tactics for determining and validating values for its parameters [43]. <p> A careful analysis in [39] (later refined and formalized in <ref> [18, 19] </ref>) has shown that the common structure of global search algorithms can be expressed by a pair of abstract programs which is presented in Fig. 6. <p> All solutions must be contained in the initial search space (3) and be extractable after splitting finitely many times (4). Subspaces containing solutions must pass the filter (5) and filtered splitting, the combined enumeration/elimination process, must eventually terminate (6). In [39] (refined in <ref> [18, 19] </ref>) the following theorem has been proved. Theorem 1. <p> In a similar way, we can avoid having to prove the sixth axiom explicitly. For each enumeration structure there are only a few standard methods to ensure termination through an elimination process. In <ref> [18, 19] </ref> it has been shown that these methods can be stored in the form of filters for a GS-theory G which are proved to satisfy axiom 6. Such filters will be called well-founded wrt. G and this property will be preserved during specialization as well. <p> This allows us to formulate simple programs and to prove their properties. Next, in order to reason about programs as such, we had to implement concepts like program, specification and related notions which were formalized in <ref> [18, chapter 2] </ref>. The conditions for specialization and filtering reside on a similar level. They are used in the axioms of the GS-theories which had to be implemented on the basis of the specific data structure containing the different components.
Reference: 19. <author> C. </author> <title> Kreitz. Formal mathematics for verifiably correct program synthesis. </title> <journal> Journal of the IGPL, </journal> <volume> 4(1) </volume> <pages> 75-94, </pages> <year> 1996. </year>
Reference-contexts: Sequences of rewrite steps will be transformed into applications of cut- and substitution rules while other techniques will deter mine the parameters of the general induction rule [25, 23]. High-level synthesis strategies will be integrated by verifying formal theorems about schematic program construction <ref> [18, 19] </ref>. For each strategy a theorem describing the axioms for the correctness of a particular class of algorithms will serve as derived inference rule. It will be accompanied by specialized tactics for determining and validating values for its parameters [43]. <p> It has been demonstrated [41] that algorithm schemata do not only lead to a very efficient synthesis process but can also produce competitive algorithms if properly guided. Formally verified theorems stating the requirements for the correctness of an abstract program scheme <ref> [19] </ref> are the key for an integration of these strategies into the general framework. Such theorems can be applied like high-level inference rules which decompose the synthesis task into the task of proving instances of the given axioms. <p> Often we use only the left side to denote specifications in a more readable way. All the above concepts, including an ML-like mathematical notation for computable functions, can be straightforwardly formalized in the logical language of NuPRL (see <ref> [19, section 2] </ref>) and are the formal foundation for the automated derivation of global search algorithms within the integrated synthesis system. <p> A careful analysis in [39] (later refined and formalized in <ref> [18, 19] </ref>) has shown that the common structure of global search algorithms can be expressed by a pair of abstract programs which is presented in Fig. 6. <p> All solutions must be contained in the initial search space (3) and be extractable after splitting finitely many times (4). Subspaces containing solutions must pass the filter (5) and filtered splitting, the combined enumeration/elimination process, must eventually terminate (6). In [39] (refined in <ref> [18, 19] </ref>) the following theorem has been proved. Theorem 1. <p> In a similar way, we can avoid having to prove the sixth axiom explicitly. For each enumeration structure there are only a few standard methods to ensure termination through an elimination process. In <ref> [18, 19] </ref> it has been shown that these methods can be stored in the form of filters for a GS-theory G which are proved to satisfy axiom 6. Such filters will be called well-founded wrt. G and this property will be preserved during specialization as well. <p> Only the specialization condition and the necessity of the specialized filter conditions whose proofs are much easier than those of axioms 4 and 6 need to be checked explicitly. These insights led to the following strategy for synthesizing global search algorithms from formal specifications (see <ref> [19, Section 4.4] </ref> for an application example). Strategy 3. Given the specification FUNCTION f (x: D): Set (R) WHERE I (x) RETURNS fz j O (x; z)g 1. <p> In the following we will explain the techniques by which these two requirements could be achieved. The application of formally verified theorems is one of the most important principles which make program synthesis within a formal proof system like NuPRL feasible (see <ref> [19, Section 3] </ref> for a detailed exposition). In such systems all derivations must eventually be based on primitive inference rules. Formal theorems, however, can serve as derived inference rules on a much higher level of abstraction.
Reference: 20. <author> C. </author> <title> Kreitz. Formal reasoning about communication systems I: Embedding ML into type theory. </title> <type> Technical Report TR 97-1637, </type> <institution> Cornell University, </institution> <year> 1997. </year>
Reference-contexts: We will also work on supporting several existing functional, logical, and imperative programming languages as a target language of our derivations. Recent work on embedding the Objective Caml programming language into NuPRL's formal language <ref> [20] </ref> has shown that the practical usefulness of systems for program synthesis and transformation can be drastically increased by such efforts.
Reference: 21. <editor> C. Kreitz, H. Mantel, J. Otten, S. Schmitt. </editor> <title> Connection-Based Proof Construction in Linear Logic. </title> <editor> In W. McCune, ed., </editor> <booktitle> 14 th Conference on Automated Deduction, LNAI 1249, </booktitle> <pages> pp. 207-221, </pages> <publisher> Springer Verlag, </publisher> <year> 1997. </year>
Reference-contexts: This enabled us to develop a much simpler algorithm computing a minimal set of most general unifiers. Our general proof procedure also allows a uniform treatment of other nonclassical logics like various modal logics [32] or linear logic <ref> [21] </ref>. We only have to change the notion of complementarity (i.e. the prefix unification) while leaving the path checking algorithm unchanged. Path checking can also be performed by using a semantic tableau [13]. The prover ileanTAP [28] is based on free-variable semantic tableaux extended by the above-mentioned prefix unification. <p> This guarantees that no decisions on selecting proof-relevant subrelations have to be made and hence, additional search wrt. these decisions will be avoided. Our approach for reconstructing LJ mc -proofs from MJ -proofs has been uniformly extended to various non-classical logics <ref> [37, 21] </ref> for which matrix characterizations exist.
Reference: 22. <editor> C. Kreitz, J. Otten, S. Schmitt. </editor> <title> Guiding Program Development Systems by a Connection Based Proof Strategy. </title> <editor> In M. Proietti, ed., </editor> <booktitle> 5 th International Workshop on Logic Program Synthesis and Transformation, </booktitle> <volume> LNCS 1048, </volume> <pages> pp. 137-151. </pages> <publisher> Springer Verlag, </publisher> <year> 1996. </year>
Reference-contexts: Matrix methods for constructive first-order logic use a non-clausal extension of the connection method [4, 30]. They have been combined with an algorithm for translating matrix proofs into sequent proofs [36] and integrated into NuPRL as a proof tactic <ref> [22] </ref>. Inductive proofs will be generated by proof planners involving rippling [9] and rewrite techniques. Sequences of rewrite steps will be transformed into applications of cut- and substitution rules while other techniques will deter mine the parameters of the general induction rule [25, 23]. <p> However, whenever a piece of code shall be extracted from the proof, it is necessary to convert the proofs generated by a search procedure back into a constructive sequent proof which, according to the proofs-as-program paradigm [2], can be turned into a program. In <ref> [36, 22] </ref> we have developed an embedding of connection based proof methods into NuPRL based on such conversions. <p> In [36, 22] we have developed an embedding of connection based proof methods into NuPRL based on such conversions. The proof method described in <ref> [22] </ref> constructs a matrix proof closely related to a cut-free sequent proof in LJ mc , the multiply-conclusioned sequent calculus on which the matrix characterization for J is based [44].
Reference: 23. <editor> F. Kurucz. Realisierung verschiedender Induktionsstrategien basierend auf dem Rippling-Kalkul. Diplomarbeit, TH Darmstadt, </editor> <year> 1997. </year>
Reference-contexts: Inductive proofs will be generated by proof planners involving rippling [9] and rewrite techniques. Sequences of rewrite steps will be transformed into applications of cut- and substitution rules while other techniques will deter mine the parameters of the general induction rule <ref> [25, 23] </ref>. High-level synthesis strategies will be integrated by verifying formal theorems about schematic program construction [18, 19]. For each strategy a theorem describing the axioms for the correctness of a particular class of algorithms will serve as derived inference rule. <p> For deriving recursive programs induction techniques are needed during the proof process. In <ref> [23] </ref> we have developed an induction prover for "simple" induction problems which is based on rippling [9, 1]. <p> In order to obtain an efficient induction strategy we have generalized rippling-out and rippling-in to a new uniform strategy, called rippling-distance <ref> [23] </ref>. The arrows `"` and `#` were removed from the wave fronts and each wave front is assigned to one goal sink . To guarantee termination a distance measure MD has been introduced which describes the distance between a wave front and its assigned goal sink in the term tree. <p> Then an independent proof search for each class reduces the complexity to about m! d steps for m = n, and to (m 0 ) (n+m 0 d) steps for m &gt; n, where m 0 = m (n 1) (see <ref> [23] </ref> for details). In order to uniformly integrate rippling-out into the rippling-distance strategy the definition of sinks has been generalized to arbitrary term positions. <p> This means that the annotations of wave rules are determined at runtime from a set of rewrite rules which do not have annotations. Since there are no direction marks '"', '#' at the wave fronts the number of possible annotations is decreased and the annotations are easier to compute <ref> [23] </ref>. The admissibility of annotated wave rules has to be tested using a well founded reduction ordering x in order to avoid cyclic sequences of wave rules. <p> This advantage becomes remarkable if multi-wave holes are used where wave fronts may contain more then one wave hole. Furthermore, dist has been extended with an additional weight-function, which allows the use of additional associativity and commutativity wave rules. 3.3 Integrating the Rippling-Distance Strategy into NuPRL In <ref> [23] </ref> we have described the integration of an external rippling prover into the NuPRL system which uses rippling-distance with dynamic rule annotations for guiding a proof search. The prover is implemented in NuPRL-ML [15] and called during a NuPRL proof session via a tactic Ripple. <p> In [25] a translation for rippling-out proofs was developed, which can be used for arbitrary sequences of rewrite rules. It is implemented as meta-tactic and uses the basic refinement rules cut , substitution and lemma. We have extended this approach with the following concepts <ref> [23] </ref>: 1. The (universally quantified) induction hypothesis can be instantiated. 2. Polymorphic types for integration of rewrite steps can be reconstructed. 3. Premises in a NuPRL-sequent can be used as rewrite rules. The first improvement is necessary for completing rippling-in proofs.
Reference: 24. <author> R. Letz, J. Schumann, S. Bayerl, W. Bibel. </author> <title> Setheo: A high-performance theorem prover. </title> <journal> Journal of Automated Reasoning, </journal> <volume> 8 </volume> <pages> 183-212, </pages> <year> 1992. </year>
Reference-contexts: intuitionistic validity of a variety of propositional formulas with a performance competitive to any intuitionistic decision mechanism known to us. 6 2.2 Proof Construction in Intuitionistic First-Order Logic The connection method is a well-known proof procedure for classical first-order logic and has successfully been realized in theorem provers like Setheo <ref> [24] </ref> or KoMeT [7]. It is based on a matrix characterization of logical validity: A formula F is (classically) valid iff the matrix of F is (classically) complementary [4, 5].
Reference: 25. <author> T. van thanh Liem. </author> <title> Induktion im NuPRL System. </title> <institution> Diplomarbeit, TH Darmstadt, </institution> <year> 1996. </year>
Reference-contexts: Inductive proofs will be generated by proof planners involving rippling [9] and rewrite techniques. Sequences of rewrite steps will be transformed into applications of cut- and substitution rules while other techniques will deter mine the parameters of the general induction rule <ref> [25, 23] </ref>. High-level synthesis strategies will be integrated by verifying formal theorems about schematic program construction [18, 19]. For each strategy a theorem describing the axioms for the correctness of a particular class of algorithms will serve as derived inference rule. <p> This integration concept has been realized with tactics and extends an earlier approach presented in <ref> [25] </ref>. 3.1 Introduction to Rippling In order to prove a goal by induction an induction scheme of the form A (base) ^ (8x:A (x) ) A (step (x))) ) 8x:A (x) has to be applied to the goal which results in the following two subgoals: a base case A (base), which <p> Before applying an induction scheme the induction variable is moved in front of other universally quantified variables in order to maximize the number of sink variables. After the step case is proved the translation back into a sequent proof has to be done. In <ref> [25] </ref> a translation for rippling-out proofs was developed, which can be used for arbitrary sequences of rewrite rules. It is implemented as meta-tactic and uses the basic refinement rules cut , substitution and lemma. We have extended this approach with the following concepts [23]: 1.
Reference: 26. <author> R. C. Moore. </author> <title> Reasoning about Knowledge and Action IJCAI-77 , pp 223-227, </title> <year> 1977. </year>
Reference-contexts: For the sake of completeness axioms encoding the properties of the accessibility relation R will be added which then must imply the translated formula. This technique is known as the relational translation <ref> [26, 27, 3] </ref>. A major difficulty of this approach is the potential undecidability of the resulting classical formula. On the other hand, any intuitionistic non-theorem has a finite countermodel.
Reference: 27. <author> H. J. Ohlbach. </author> <title> Semantics-Based Translation Methods for Modal Logics Journal of Logic and Computation, </title> <booktitle> 1(6), </booktitle> <pages> pp 691-746, </pages> <year> 1991. </year>
Reference-contexts: For the sake of completeness axioms encoding the properties of the accessibility relation R will be added which then must imply the translated formula. This technique is known as the relational translation <ref> [26, 27, 3] </ref>. A major difficulty of this approach is the potential undecidability of the resulting classical formula. On the other hand, any intuitionistic non-theorem has a finite countermodel.
Reference: 28. <author> J. Otten. ileanTAP: </author> <title> An intuitionistic theorem prover. </title> <editor> In Didier Galmiche, ed., </editor> <booktitle> International Conference TABLEAUX '97 . LNAI 1227, </booktitle> <pages> pp. 307-312, </pages> <publisher> Springer Verlag, </publisher> <year> 1997. </year>
Reference-contexts: proof procedures were originally developed independently from the common platform and we had to provide techniques for integrating them into the top-down sequent proof style of NuPRL. 2 Formulas from propositional intuitionistic logic will be decided by translating them into classical logic [17] and applying a non-normal form Davis-Putnam procedure <ref> [28] </ref>. This procedure will be embedded as trusted refiner which creates a sequent proof on demand. Matrix methods for constructive first-order logic use a non-clausal extension of the connection method [4, 30]. <p> We only have to change the notion of complementarity (i.e. the prefix unification) while leaving the path checking algorithm unchanged. Path checking can also be performed by using a semantic tableau [13]. The prover ileanTAP <ref> [28] </ref> is based on free-variable semantic tableaux extended by the above-mentioned prefix unification. <p> Converting matrix proofs into sequent proofs. Improving the efficiency of proof search in the above procedures resulted in strategies which do not support a parallel construction of matrix proofs in MJ and LJ mc -proofs anymore. Proof strategies such as an extension procedure [32] or a tableaux prover <ref> [28] </ref> (see also section 2.2) make it necessary to transform matrix proofs into sequent proofs after the proof search has been finished. Hence, the above mapping LJ mc 7! LJ ? has to be extended by an additional mapping MJ 7! LJ mc .
Reference: 29. <author> J. Otten. </author> <title> On the advantage of a non-clausal Davis-Putnam procedure. </title> <institution> Forschungsbericht AIDA-97-01, TH Darmstadt, </institution> <year> 1997. </year>
Reference-contexts: Experimental results have shown that a translation to clausal form often yields formulas which are too large to obtain a proof, in particular if applying the standard translation techniques. To avoid any translation steps to clausal form we have developed a non-clausal proof procedure <ref> [29] </ref>. It is a generalization of the original clausal Davis-Putnam procedure and operates directly on arbitrary propositional formulas. To this end we represent formulas by nested matrices. A matrix is a very compact representation of a formula and the corresponding search space (see also section 2.2).
Reference: 30. <author> J. Otten & C. </author> <title> Kreitz. A connection based proof method for intuitionistic logic. </title> <editor> In P. Baumgartner, R. Hahnle, J. Posegga, eds., </editor> <title> 4 th Workshop on Theorem Proving with Analytic Tableaux and Related Methods, </title> <publisher> LNAI 918, </publisher> <pages> pp. 122-137, </pages> <publisher> Springer Verlag, </publisher> <year> 1995. </year>
Reference-contexts: This procedure will be embedded as trusted refiner which creates a sequent proof on demand. Matrix methods for constructive first-order logic use a non-clausal extension of the connection method <ref> [4, 30] </ref>. They have been combined with an algorithm for translating matrix proofs into sequent proofs [36] and integrated into NuPRL as a proof tactic [22]. Inductive proofs will be generated by proof planners involving rippling [9] and rewrite techniques. <p> Proof search is done by a general path checking algorithm which is driven by connections instead of logical connectives <ref> [30, 32] </ref>. Once a complementary connection has been identified all paths containing this connection are deleted. This is similar to Bibel's connection method for classical logic but without necessity for transforming the given formula to normal form.
Reference: 31. <author> J. Otten & C. </author> <title> Kreitz. T-String-Unification: Unifying Prefixes in Non-Classical Proof Methods. </title> <editor> In U. Moscato, ed., </editor> <title> 5 th Workshop on Theorem Proving with Analytic Tableaux and Related Methods, </title> <publisher> LNAI 1071, </publisher> <pages> pp. 244-260, </pages> <publisher> Springer Verlag, </publisher> <year> 1996. </year>
Reference-contexts: While the first-order substitution Q can be computed by well-known term-unification algorithms we had to develop a specialized prefix -unification procedure for computing J . This is done by a specialized algorithm for string-unification <ref> [31] </ref>.
Reference: 32. <author> J. Otten & C. </author> <title> Kreitz. A Uniform Proof Procedure for Classical and Non-classical Logics. </title> <editor> In G. Gorz & S. Holldobler, eds., KI-96: </editor> <booktitle> Advances in Artificial Intelligence, LNAI 1137, </booktitle> <pages> pp. 307-319. </pages> <publisher> Springer Verlag, </publisher> <year> 1996. </year>
Reference-contexts: Proof search is done by a general path checking algorithm which is driven by connections instead of logical connectives <ref> [30, 32] </ref>. Once a complementary connection has been identified all paths containing this connection are deleted. This is similar to Bibel's connection method for classical logic but without necessity for transforming the given formula to normal form. <p> This enabled us to develop a much simpler algorithm computing a minimal set of most general unifiers. Our general proof procedure also allows a uniform treatment of other nonclassical logics like various modal logics <ref> [32] </ref> or linear logic [21]. We only have to change the notion of complementarity (i.e. the prefix unification) while leaving the path checking algorithm unchanged. Path checking can also be performed by using a semantic tableau [13]. <p> Converting matrix proofs into sequent proofs. Improving the efficiency of proof search in the above procedures resulted in strategies which do not support a parallel construction of matrix proofs in MJ and LJ mc -proofs anymore. Proof strategies such as an extension procedure <ref> [32] </ref> or a tableaux prover [28] (see also section 2.2) make it necessary to transform matrix proofs into sequent proofs after the proof search has been finished. Hence, the above mapping LJ mc 7! LJ ? has to be extended by an additional mapping MJ 7! LJ mc . <p> More precisely, the history of matrix proofs will be integrated into the conversion process rather than using only the spanning matings. This makes our procedure depend on a particular proof search strategy, i.e. an extension procedure <ref> [5, 32] </ref>. But a compact encoding of this proof knowledge into the conversion process (which can be done in polynomial time in the size of the matrix proof) allows us to derive the reconstruction knowledge in terms of a few elegant conditions.
Reference: 33. <author> D. Plaisted & S. Greenbaum. </author> <title> A structure-preserving clause form translation. </title> <journal> Journal of Symbolic Computation, </journal> <volume> 2 </volume> <pages> 293-304, </pages> <year> 1986. </year>
Reference-contexts: The usual translation of a given formula into this form is based on the application of distributivity laws. In the worst case this will lead to an exponential increase of the resulting formula. The application of the so-called definitional translation <ref> [33] </ref> yields (at most) a quadratic increase of the resulting formula's size at the expense of introducing new propositional variables. The translation of intuitionistic into classical propositional formulas described above leads to formulas which are strongly in non-normal form.
Reference: 34. <author> S. Schmitt. </author> <title> Avoiding redundancy in proof reconstruction 1 st International Workshop on Proof Transformation and Presentation, </title> <publisher> Schlo Dagstuhl, </publisher> <address> Germany, </address> <year> 1997. </year>
Reference-contexts: If only the spanning mating is given, backtracking may be required over this selection (i.e. converting irrelevant subrelations) in order to retain completeness. For this purpose we have developed a concept of redundancy elimination from a reduction ordering during proof reconstruction <ref> [34, 35] </ref>. The concept is based on the specification of additional proof knowledge from the search process in order to extract reconstruction knowledge for the conversion procedure. More precisely, the history of matrix proofs will be integrated into the conversion process rather than using only the spanning matings.
Reference: 35. <author> S. Schmitt. </author> <title> Building Efficient Conversion Procedures using Proof Knowledge. </title> <type> Technical Report, </type> <institution> TH Darmstadt, </institution> <year> 1997. </year>
Reference-contexts: If only the spanning mating is given, backtracking may be required over this selection (i.e. converting irrelevant subrelations) in order to retain completeness. For this purpose we have developed a concept of redundancy elimination from a reduction ordering during proof reconstruction <ref> [34, 35] </ref>. The concept is based on the specification of additional proof knowledge from the search process in order to extract reconstruction knowledge for the conversion procedure. More precisely, the history of matrix proofs will be integrated into the conversion process rather than using only the spanning matings. <p> Furthermore, a technique for efficient redundancy elimination after splitting at fi-positions has been developed for all of these logics <ref> [35] </ref>. The result can be seen as a general framework for building efficient and complete conversion procedures for non-classical logics when the basic proof search method is known.
Reference: 36. <author> S. Schmitt & C. </author> <title> Kreitz. On transforming intuitionistic matrix proofs into standard-sequent proofs. </title> <editor> In P. Baumgartner, R. Hahnle, J. Posegga, eds., </editor> <title> 4 th Workshop on Theorem Proving with Analytic Tableaux and Related Methods, </title> <publisher> LNAI 918, </publisher> <pages> pp. 106-121. </pages> <publisher> Springer Verlag, </publisher> <year> 1995. </year>
Reference-contexts: This procedure will be embedded as trusted refiner which creates a sequent proof on demand. Matrix methods for constructive first-order logic use a non-clausal extension of the connection method [4, 30]. They have been combined with an algorithm for translating matrix proofs into sequent proofs <ref> [36] </ref> and integrated into NuPRL as a proof tactic [22]. Inductive proofs will be generated by proof planners involving rippling [9] and rewrite techniques. <p> However, whenever a piece of code shall be extracted from the proof, it is necessary to convert the proofs generated by a search procedure back into a constructive sequent proof which, according to the proofs-as-program paradigm [2], can be turned into a program. In <ref> [36, 22] </ref> we have developed an embedding of connection based proof methods into NuPRL based on such conversions. <p> Hence, the above mapping LJ mc 7! LJ ? has to be extended by an additional mapping MJ 7! LJ mc . This two-step conversion from intuitionistic matrix proofs into LJ ? -sequent proofs has first been presented in <ref> [36] </ref>. The first step MJ 7! LJ mc turns out to be non-trivial since the compact representation of MJ -proofs, called reduction ordering / ? , does not completely encode the non-permutabilities of sequent rules in an LJ mc -proof.
Reference: 37. <author> S. Schmitt & C. </author> <title> Kreitz. Converting non-classical matrix proofs into sequent-style systems. </title> <editor> In M. McRobbie & J. Slaney, eds., </editor> <booktitle> 13 th Conference on Automated Deduction, LNAI 1104, </booktitle> <pages> pp. 418-432. </pages> <publisher> Springer Verlag, </publisher> <year> 1996. </year>
Reference-contexts: After reducing the fi-position fi 1 the reduction ordering is split into two suborderings / ? 1 ; / ? 2 and the conversion continues separately on each of the suborderings. For this we have developed an operation split (/ ? ; fi 1 ) <ref> [37] </ref> which first splits the reduction ordering / ? . Secondly non-normal form reductions are applied to each of the / ? i in order to delete redundancies from / ? i which are no longer relevant for the corresponding branch of the sequent proof. <p> Adding two wait-labels dynamically to ff 6 and ff 5 completes / ? and avoids this deadlock during traversal. For a more detailed presentation of this approach as well as for an algorithmic realization we refer to <ref> [37] </ref>. Building efficient conversion procedures. The basic problem for proof reconstruction in constructive logics lies in the deletion of redundancies after splitting at fi-positions. <p> Consequently, the wait-label could be removed from ff 6 since ff 5 does not exist any longer. If the purity reduction were not applied, both wait-labels would remain in / ? 1 which would then be totally blocked for further reconstruction steps. 10 In <ref> [37, 38] </ref> we have shown that complete redundancy deletion after splitting at fi-positions cannot be performed efficiently when only the spanning mating is given from the matrix proof. Efficiency means that the selection of proof-relevant subrelations from the / ? i should avoid any additional search. <p> This guarantees that no decisions on selecting proof-relevant subrelations have to be made and hence, additional search wrt. these decisions will be avoided. Our approach for reconstructing LJ mc -proofs from MJ -proofs has been uniformly extended to various non-classical logics <ref> [37, 21] </ref> for which matrix characterizations exist.
Reference: 38. <author> S. Schmitt & C. </author> <title> Kreitz. A uniform procedure for converting non-classical matrix proofs into sequent-style systems. </title> <type> Technical Report AIDA-96-01, </type> <institution> TH Darmstadt 1996. </institution>
Reference-contexts: Consequently, the wait-label could be removed from ff 6 since ff 5 does not exist any longer. If the purity reduction were not applied, both wait-labels would remain in / ? 1 which would then be totally blocked for further reconstruction steps. 10 In <ref> [37, 38] </ref> we have shown that complete redundancy deletion after splitting at fi-positions cannot be performed efficiently when only the spanning mating is given from the matrix proof. Efficiency means that the selection of proof-relevant subrelations from the / ? i should avoid any additional search.
Reference: 39. <author> D. R. Smith. </author> <title> Structure and design of global search algorithms. </title> <type> Technical Report KES.U.87.12, </type> <institution> Kestrel Institute, </institution> <year> 1987. </year>
Reference-contexts: In this section we shall illustrate how this methodology is used for integrating a strategy for the design of global search algorithms <ref> [39] </ref> into the uniform proof system. 4.1 Formalizing the Design of Global Search Algorithms Solving a problem by enumerating candidate solutions is a well-known concept in computer science. <p> All the above concepts, including an ML-like mathematical notation for computable functions, can be straightforwardly formalized in the logical language of NuPRL (see [19, section 2]) and are the formal foundation for the automated derivation of global search algorithms within the integrated synthesis system. A careful analysis in <ref> [39] </ref> (later refined and formalized in [18, 19]) has shown that the common structure of global search algorithms can be expressed by a pair of abstract programs which is presented in Fig. 6. <p> All solutions must be contained in the initial search space (3) and be extractable after splitting finitely many times (4). Subspaces containing solutions must pass the filter (5) and filtered splitting, the combined enumeration/elimination process, must eventually terminate (6). In <ref> [39] </ref> (refined in [18, 19]) the following theorem has been proved. Theorem 1. <p> Axioms of Global Search algorithm will use a special case of such a technique. Therefore it makes sense to store information about generic enumeration processes in a knowledge base and to develop techniques for adapting them to a particular programming problem. The investigations in <ref> [39] </ref> have shown that standard enumeration structures for some range type R can be stored in a knowledge base as objects of the form G = ((D G ; R; I G ; O G ); S; J; s 0 ; sat; split; ext) which are proved to satisfy axioms 1
Reference: 40. <author> D. R. Smith & M. R. Lowry. </author> <title> Algorithm theories and design tactics. </title> <booktitle> Science of Computer Programming, </booktitle> <address> 14(2-3):305-321, </address> <year> 1990. </year>
Reference-contexts: The corresponding proof techniques have to operate on a higher level of abstraction and must be based on comprehensible formalizations of application domains and programming concepts rather than on low-level inferences of the logical calculus. Algorithm design strategies based on schematic solutions for certain classes of algorithms <ref> [40] </ref> have proved to be suited best for this purpose since they can be formulated almost entirely in programmer's terminology. It has been demonstrated [41] that algorithm schemata do not only lead to a very efficient synthesis process but can also produce competitive algorithms if properly guided. <p> A program is correct if it computes the complete set of output values for each acceptable input (8x:D. I (x) ) body (x) = fz:R j O (x,z)g). A specification is satisfiable if it can be extended into a correct program. As in <ref> [40] </ref> we use a formal notation for programs which emphasizes that we are interested in computing the set of all solutions of a given problem (assuming that there are finitely many): FUNCTION f (x: D): Set (R) WHERE I (x) RETURNS fz j O (x; z)g body (x).
Reference: 41. <author> D. R. Smith & E. A. </author> <title> Parra. Transformational approach to transportation scheduling. </title> <booktitle> 8 th Knowledge-Based Software Engineering Conference, </booktitle> <pages> pp. 60-68, </pages> <year> 1993. </year>
Reference-contexts: Algorithm design strategies based on schematic solutions for certain classes of algorithms [40] have proved to be suited best for this purpose since they can be formulated almost entirely in programmer's terminology. It has been demonstrated <ref> [41] </ref> that algorithm schemata do not only lead to a very efficient synthesis process but can also produce competitive algorithms if properly guided.
Reference: 42. <author> G. Stolpmann. </author> <title> Datentypen und Programmsynthese. </title> <type> Studienarbeit, </type> <institution> TH Darmstadt, </institution> <year> 1996. </year>
Reference-contexts: For each strategy a theorem describing the axioms for the correctness of a particular class of algorithms will serve as derived inference rule. It will be accompanied by specialized tactics for determining and validating values for its parameters [43]. This tech nique heavily relies on verified domain knowledge <ref> [42] </ref> but is very effective. The MAPS enterprise may be seen as a milestone in the long tradition of program synthesis efforts of our group which started as early as 1974 eventually leading to the program system LOPS (see [6] for a detailed exposition of this development).
Reference: 43. <author> G. Stolpmann. Schematische Konstruktion von Globalsuchalgorithmen. Diplomarbeit, TH Darmstadt, </author> <year> 1997. </year>
Reference-contexts: For each strategy a theorem describing the axioms for the correctness of a particular class of algorithms will serve as derived inference rule. It will be accompanied by specialized tactics for determining and validating values for its parameters <ref> [43] </ref>. This tech nique heavily relies on verified domain knowledge [42] but is very effective.
Reference: 44. <author> L. Wallen. </author> <title> Automated deduction in nonclassical logic. </title> <publisher> MIT Press, </publisher> <year> 1990. </year> <month> 25 </month>
Reference-contexts: Certain rules in the intuitionistic sequent calculus LJ differ from the classical LK [14]. The arising non-permutabilities between these rules need a special treatment. In the matrix characterization for intuitionistic logic <ref> [44] </ref> this is done by an additional intuitionistic substitution J . This substitution has to make the prefixes of each connection identical and therewith complementary. <p> The proof method described in [22] constructs a matrix proof closely related to a cut-free sequent proof in LJ mc , the multiply-conclusioned sequent calculus on which the matrix characterization for J is based <ref> [44] </ref>. Its integration into NuPRL basically consists of a transformation from LJ mc -proofs into sequent proofs in Gentzen's LJ [14], the first-order 8 fragment of NuPRL's calculus. To allow a structure preserving transformation the cut -rule had to be used in a restricted and regular manner.
References-found: 44

