URL: http://www.eecs.umich.edu/~pychang/papers/micro27.ps
Refering-URL: http://www.eecs.umich.edu/~pychang/
Root-URL: http://www.cs.umich.edu
Title: Branch Classification: a New Mechanism for Improving Branch Predictor Performance  
Author: Po-Yung Chang Eric Hao Tse-Yu Yeh Yale Patt 
Keyword: branch classification, branch predictor, speculative execution, processor performance, superscalar.  
Address: Ann Arbor, Michigan 48109-2122  Santa Clara, CA 95051  
Affiliation: Department of Electrical Engineering and Computer Science The University of Michigan  Intel Corporation  
Abstract: There is wide agreement that one of the most important impediments to the performance of current and future pipelined superscalar processors is the presence of conditional branches in the instruction stream. Speculative execution seems to be one solution of choice to the branch problem, but speculative work is discarded if a branch is mispredicted. Therefore, we need a very accurate branch predictor; 95% accuracy is not good enough. This paper proposes branch classification to help improve the accuracy of branch predictors. Branch classification allows an individual branch instruction to be associated with the branch predictor best suited to predict its direction. Using this approach, a hybrid branch predictor can be constructed such that each component branch predictor predicts those branches for which it is best suited. This paper suggests one classification scheme, analyzes several branch predictors, and proposes a hybrid branch predictor that achieves higher prediction accuracy than any branch predictor previously reported in the literature. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> P. Chow and M. Horowitz, </author> <title> "Architecture tradeoffs in the design of MIPS-X," </title> <booktitle> Proceedings of the 14th Annual International Symposium on Computer Architecture, </booktitle> <month> June </month> <year> 1987. </year>
Reference-contexts: The simplest kind of branch prediction is to predict that all conditional branches are always taken (as in Stan-ford MIPS-X <ref> [1] </ref>), or always not-taken (as in Motorola MC88000 [8]). Predicting all branches to be taken achieves about 65% accuracy whereas predicting not-taken achieves about 35% [3, 5, 9].
Reference: [2] <author> J.A. DeRosa and H. M. Levy, </author> <title> "An Evaluation of Branch Architectures," </title> <booktitle> Proceedings of the 14th International Symposium on Computer Architecture, </booktitle> <month> May </month> <year> 1989. </year>
Reference-contexts: Predicting all branches to be taken achieves about 65% accuracy whereas predicting not-taken achieves about 35% [3, 5, 9]. Dynamic branch prediction algorithms use hardware to record branch execution history at run-time, and predict future branch directions by studying their previous behavior. Many dynamic prediction methods have been studied <ref> [2, 7, 9, 10, 11] </ref>. One important class, branch target buffers, uses fast hardware logic to detect branches at an early stage of the instruction pipeline, and predict the branch direction and target address [9].
Reference: [3] <author> J. Emer and D. Clark, </author> <title> "A Characterization of Processor Performance in the VAX-11/780," </title> <booktitle> Proceedings of the 11th Annual Symposium on Computer Architecture, </booktitle> <month> June </month> <year> 1984. </year>
Reference-contexts: The simplest kind of branch prediction is to predict that all conditional branches are always taken (as in Stan-ford MIPS-X [1]), or always not-taken (as in Motorola MC88000 [8]). Predicting all branches to be taken achieves about 65% accuracy whereas predicting not-taken achieves about 35% <ref> [3, 5, 9] </ref>. Dynamic branch prediction algorithms use hardware to record branch execution history at run-time, and predict future branch directions by studying their previous behavior. Many dynamic prediction methods have been studied [2, 7, 9, 10, 11].
Reference: [4] <author> P.M. Kogge, </author> <title> The Architecture of Pipelined Computers, </title> <publisher> pp.237-243, McGraw-Hill, </publisher> <year> 1981. </year>
Reference-contexts: 1 Introduction Branches can significantly reduce the performance of pipelined processors if they interrupt the steady supply of instructions to the instruction pipeline <ref> [4] </ref>. A branch 0 predictor minimizes the number of pipeline stalls by predicting the direction of the branch and fetching the instructions from that path.
Reference: [5] <author> J.K.F. Lee and A.J. Smith, </author> <title> "Branch Prediction Strategies and Branch Target Buffer Design," </title> <journal> IEEE Computer, </journal> <volume> pp.6-22, </volume> <month> January </month> <year> 1984. </year>
Reference-contexts: The simplest kind of branch prediction is to predict that all conditional branches are always taken (as in Stan-ford MIPS-X [1]), or always not-taken (as in Motorola MC88000 [8]). Predicting all branches to be taken achieves about 65% accuracy whereas predicting not-taken achieves about 35% <ref> [3, 5, 9] </ref>. Dynamic branch prediction algorithms use hardware to record branch execution history at run-time, and predict future branch directions by studying their previous behavior. Many dynamic prediction methods have been studied [2, 7, 9, 10, 11].
Reference: [6] <author> S. McFarling, </author> <title> "Combining Branch Predictors", </title> <note> WRL Technical Note TN-36, </note> <institution> Digital Equipment Corporation, </institution> <month> June </month> <year> 1993. </year>
Reference-contexts: High branch prediction accuracies, about 85%-90%, have been reported for simple history bit and counter-based schemes [9]. By keeping more history information, an even higher level of branch prediction accuracy, about 90%-95%, can be attained <ref> [6, 10, 11, 12] </ref>. To further improve prediction accuracy, McFarling [6] proposed a new technique that combines two branch predictors. <p> High branch prediction accuracies, about 85%-90%, have been reported for simple history bit and counter-based schemes [9]. By keeping more history information, an even higher level of branch prediction accuracy, about 90%-95%, can be attained [6, 10, 11, 12]. To further improve prediction accuracy, McFarling <ref> [6] </ref> proposed a new technique that combines two branch predictors. His technique uses 2-bit up-down counters to keep track of which predictor is currently more accurate for each branch; the hybrid predictor then uses the more accurate predictor for making its prediction. <p> Three different implementations of the Two-Level Branch Predictor are studied. They are the Per-address Two-Level Branch Predictor using a set of pattern history tables (PAs), the Global Two-Level Branch Predictor using a set of pattern history tables (GAs), and a modified GAg scheme (gshare <ref> [6] </ref>) that exclusive-ORs the global history with the branch address to select the appropriate pattern history table entry. 3.4.1 Advantages of Branch Classification In our study, static branches with similar dynamic taken-rates are grouped together. <p> To better identify each branch, the gshare scheme <ref> [6] </ref> uses both the global history and the branch address. As in the gshare scheme, GAs.mhl exclusive-ORs the global history with the branch address to select the appropriate PHT entry. This is done to hash the frequent global history patterns to different PHT entries. <p> new hybrid predictor design that uses both dynamic and static predictor selection to further improve prediction accuracy. * Hybrid Predictor with Dynamic Predictor Selection One method of dynamically selecting the optimal predictor is to use 2-bit saturating up-down counters (i.e. 2bC) to keep track of which predictor is doing better <ref> [6] </ref>. Specifically, let BD denote the Static Branch Classification mostly not-taken branches mixed-direction branches actual branch direction, P1 denote predicted direction from predictor 1, and P2 denote the predicted direction from predictor 2. The counters can be incremented or decremented based on the rule shown in Table 3.
Reference: [7] <author> S. McFarling and J.L. Hennessey, </author> <title> "Reducing the cost of branches," </title> <booktitle> Proceedings of the 13th International Symposium on Computer Architecture, </booktitle> <address> pp.396-404, </address> <month> June </month> <year> 1986. </year>
Reference-contexts: Predicting all branches to be taken achieves about 65% accuracy whereas predicting not-taken achieves about 35% [3, 5, 9]. Dynamic branch prediction algorithms use hardware to record branch execution history at run-time, and predict future branch directions by studying their previous behavior. Many dynamic prediction methods have been studied <ref> [2, 7, 9, 10, 11] </ref>. One important class, branch target buffers, uses fast hardware logic to detect branches at an early stage of the instruction pipeline, and predict the branch direction and target address [9]. <p> Another method of combining branch predictors is to select the optimal predictor dynamically <ref> [7] </ref>. In this section, we first compare the performance of both types of hybrid branch predictor. <p> For the SPEC92 benchmark gcc, which contains many branches, PG+PAs/gshare achieves prediction accuracy of 96.91%, as compared to 96.47% for the best pre viously known predictor (PAs/gshare) <ref> [7] </ref>. 3.4.2.3 Summary of Hybrid Branch Predictors We examined many different hybrid branch prediction schemes. In this report, we present the most success both dynamic and static selection ful ones (see Table 4).
Reference: [8] <author> C. Melear, </author> <title> "The design of the 88000 RISC family," </title> <journal> IEEE MICRO, </journal> <volume> pp.26-38, </volume> <month> April </month> <year> 1989. </year> <title> [9] , J.E. Smith, "A Study of Branch Prediction Strategies," </title> <booktitle> Proceedings of the 8th International Symposium on Computer Architecture, </booktitle> <address> pp.135-148, </address> <month> June </month> <year> 1981. </year>
Reference-contexts: The simplest kind of branch prediction is to predict that all conditional branches are always taken (as in Stan-ford MIPS-X [1]), or always not-taken (as in Motorola MC88000 <ref> [8] </ref>). Predicting all branches to be taken achieves about 65% accuracy whereas predicting not-taken achieves about 35% [3, 5, 9]. Dynamic branch prediction algorithms use hardware to record branch execution history at run-time, and predict future branch directions by studying their previous behavior.
Reference: [10] <author> T.-Y. Yeh and Y.N. Patt, </author> <title> "Alternative Implementations of Two-level Adaptive Branch Prediction," </title> <booktitle> Proceedings of the 19th Annual International Symposium on Computer Architecture, </booktitle> <address> pp.124-135, </address> <month> May </month> <year> 1992. </year>
Reference-contexts: Predicting all branches to be taken achieves about 65% accuracy whereas predicting not-taken achieves about 35% [3, 5, 9]. Dynamic branch prediction algorithms use hardware to record branch execution history at run-time, and predict future branch directions by studying their previous behavior. Many dynamic prediction methods have been studied <ref> [2, 7, 9, 10, 11] </ref>. One important class, branch target buffers, uses fast hardware logic to detect branches at an early stage of the instruction pipeline, and predict the branch direction and target address [9]. <p> High branch prediction accuracies, about 85%-90%, have been reported for simple history bit and counter-based schemes [9]. By keeping more history information, an even higher level of branch prediction accuracy, about 90%-95%, can be attained <ref> [6, 10, 11, 12] </ref>. To further improve prediction accuracy, McFarling [6] proposed a new technique that combines two branch predictors.
Reference: [11] <author> T.-Y. Yeh and Y.N. Patt, </author> <title> "Two-level Adaptive Branch Prediction," </title> <booktitle> Proceedings of the 24th ACM/IEEE International Symposium on Microarchi-tecture, </booktitle> <address> pp.51-61, </address> <month> November </month> <year> 1991. </year>
Reference-contexts: Predicting all branches to be taken achieves about 65% accuracy whereas predicting not-taken achieves about 35% [3, 5, 9]. Dynamic branch prediction algorithms use hardware to record branch execution history at run-time, and predict future branch directions by studying their previous behavior. Many dynamic prediction methods have been studied <ref> [2, 7, 9, 10, 11] </ref>. One important class, branch target buffers, uses fast hardware logic to detect branches at an early stage of the instruction pipeline, and predict the branch direction and target address [9]. <p> High branch prediction accuracies, about 85%-90%, have been reported for simple history bit and counter-based schemes [9]. By keeping more history information, an even higher level of branch prediction accuracy, about 90%-95%, can be attained <ref> [6, 10, 11, 12] </ref>. To further improve prediction accuracy, McFarling [6] proposed a new technique that combines two branch predictors.
Reference: [12] <author> T.-Y. Yeh and Y.N. Patt, </author> <title> "A Comparison of Dynamic Branch Predictors that use Two Levels of Branch History", </title> <booktitle> Proceedings of the 20th Annual International Symposium on Computer Architecture, </booktitle> <address> pp.257-266, </address> <month> May </month> <year> 1993. </year>
Reference-contexts: High branch prediction accuracies, about 85%-90%, have been reported for simple history bit and counter-based schemes [9]. By keeping more history information, an even higher level of branch prediction accuracy, about 90%-95%, can be attained <ref> [6, 10, 11, 12] </ref>. To further improve prediction accuracy, McFarling [6] proposed a new technique that combines two branch predictors. <p> Each curve in the graphs indicates the performance of a branch predictor at a fixed hardware cost. The hardware cost of a predictor is estimated using the following equations <ref> [12] </ref>: GAs (k; p) = k + (p fi 2 k fi 2) (bits) PAs (k; p) = (b fi k) + (p fi 2 k fi 2) (bits) gshare (k; t) = k + (2 t fi 2) (bits) where k is the history register length, p is the number <p> For example, the highest curve in Figure 9 shows the performance of a 32K-byte size GAs. The left-most point of this curve shows the prediction accuracy of GAs (1; 2 16 ). The right-most point shows the prediction accuracy of GAs (17; 1). Our results match those presented in <ref> [12] </ref>. Let PA (x) denote the prediction accuracy of the branch prediction scheme x. With a fixed branch history length, the prediction accuracy increases as the number of PHTs increases, e.g.
References-found: 11

