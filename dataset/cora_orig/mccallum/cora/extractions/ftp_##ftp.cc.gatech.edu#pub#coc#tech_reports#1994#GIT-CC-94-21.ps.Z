URL: ftp://ftp.cc.gatech.edu/pub/coc/tech_reports/1994/GIT-CC-94-21.ps.Z
Refering-URL: http://www.cs.gatech.edu/tech_reports/index.94.html
Root-URL: 
Title: Falcon: On-line Monitoring and Steering of Large-Scale Parallel Programs 1  
Author: Weiming Gu, Greg Eisenhauer, Eileen Kraemer, Karsten Schwan John Stasko, and Jeffrey Vetter 
Affiliation: College of Computing Georgia Institute of Technology  
Abstract: Atlanta, GA 30332 Technical Report GIT-CC-94-21 Abstract Falcon is a system for on-line monitoring and steering of large-scale parallel programs. The purpose of such interactive steering is to improve its performance or to affect its execution behavior. The Falcon system is composed of an application-specific on-line monitoring system, an interactive steering mechanism, and a graphical display system. In this paper, we present a framework of the Falcon system, its implementation, and evaluation of the system performance. A complex sample application a molecular dynamics simulation program (MD) is used to motivate the research as well as to evaluate the performance of the Falcon system. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Thomas E. Anderson and Edward D. Lazowska. Quartz: </author> <title> A tool for tuning parallel program performance. </title> <booktitle> In Proc. of the 1990 SIGMETRICS Conference on Measurement and Modeling of Computer Systems, </booktitle> <pages> pages 115-125, </pages> <address> Boston, </address> <month> May </month> <year> 1990. </year>
Reference-contexts: These performance monitoring systems (e.g. Miller's IPS [34] and IPS-2 [33], Reed's Pablo [41]) provides programmers with execution information about their parallel codes, and leads their attention to those program components on which most execution time is spent. A variety of performance metrics, such as normalized processor time <ref> [1] </ref>, execution time on the critical execution path [33], etc., are employed to describe the program's runtime performance. One limitation of these performance metrics is the difficulty to relate measured performance numbers to specific program details. Instead, most such research measures program execution times at the procedure level.
Reference: [2] <author> Peter Bates. </author> <title> Debugging heterogeneous distributed systems using event-based models of behavior. </title> <booktitle> In Proceedings of the Workshop on Parallel and Distributed Debugging, </booktitle> <pages> pages 11-22, </pages> <address> Madison, Wisconsin, </address> <month> May </month> <year> 1988. </year>
Reference-contexts: Unfortunately, this lock is a point of contention between the server and the application 21 and, as such, the performance of the server is somewhat degraded. From these measurements and in accordance with earlier results presented in this paper and in <ref> [2] </ref> addressing the time required for analyzing monitoring output, it should be apparent that the steering component of Falcon is sufficiently fast to (1) keep up with fairly high rates of monitoring and (2) steer programs at rates and with overheads enabling medium grain on-line program configuration [5] and application steering.
Reference: [3] <author> Adam Beguelin, Jack Dongarra, Al Geist, and Vaidy Sunderam. </author> <title> Visualization and debugging in a heterogeneous environment. </title> <journal> Computer, </journal> <volume> 26(6) </volume> <pages> 88-95, </pages> <month> June </month> <year> 1993. </year>
Reference-contexts: These events violate the "happened-before" relationship described in [27] and [10]. Post-mortem display systems such as ParaGraph [17] and SIEVE [42] may sort the trace files by timestamp. Instant Replay [28], Makbilan [52], TraceViewer [19], the Animation Choreographer [25], and Xab <ref> [3] </ref> have all used a causality graph as on ordering tool for the post-mortem display of the execution of parallel programs. These methods are not effective for run-time performance display because they rely on fully available trace files that may be sorted prior to their display. In contrast, Xab [3], a <p> Xab <ref> [3] </ref> have all used a causality graph as on ordering tool for the post-mortem display of the execution of parallel programs. These methods are not effective for run-time performance display because they rely on fully available trace files that may be sorted prior to their display. In contrast, Xab [3], a tool for monitoring PVM programs, uses a timestamp adjustment approach. Each processor calculates time as the sum of its local clock and an "offset" value. This offset value is adjusted whenever a process a message with a a later timestamp than the receiving process's current time.
Reference: [4] <author> Adam Beguelin and Erik Seligman. </author> <title> Causality-preserving timestamps in distributed programs. </title> <type> Technical Report CMU-CS-93-167, </type> <institution> Carnegie Mellon University, </institution> <address> Pittsburgh, PA, </address> <month> June </month> <year> 1993. </year>
Reference-contexts: The on-line nature of the Falcon monitoring system precludes using such a solution, and sorting by timestamp order does not entirely eliminate the problem of out-of-order events <ref> [4] </ref>. In addition, coarse clock granularities and poor clock synchronization among different processors may lead to event timestamps that do not accurately reflect the actual order of program execution.
Reference: [5] <author> Thomas E. Bihari and Karsten Schwan. </author> <title> Dynamic adaptation of real-time software. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 9(2) </volume> <pages> 143-174, </pages> <month> May </month> <year> 1991. </year>
Reference-contexts: Examples include the automatic configuration of small program fragments for maintaining real-time response in uniprocessor systems [32], the on-line adaptation of functional program components for realizing reliability versus performance tradeoffs in parallel and real-time applications <ref> [5, 14, 12] </ref>, and the load balancing or program configuration for enhanced reliability in distributed systems [26, 43, 31]. The MD simulation offers opportunities for performance improvement through on-line interactions with end users and with algorithms, including: * Decomposition geometries can be changed to respond to changes in physical systems. <p> can be made steerable only by requiring end users to write them accordingly, by requiring substantial compiler support [46], or by requiring that the programming language offer stronger mechanisms of abstraction than those existing in parallel Fortran or in the Cthreads library used in our work (e.g., the object model <ref> [5, 11, 26, 14] </ref>). We are currently designing higher level language primitives for definition of steering actions and for inclusion of such actions with application code. At this time, however, Falcon relies on user-directed inclusion of actuators with the application code. <p> Such actuators may also execute additional functions to ensure that modifications of program state do not violate program correctness criteria <ref> [5] </ref>. The performance of steering is assessed in Section 4.5 below. 4 System Evaluation To understand the performance of the Falcon monitoring system, we evaluate its implementation on a Kendall Square Research KSR-2 parallel machine 2 . This machine has 64 processors interconnected by two rings. <p> paper and in [2] addressing the time required for analyzing monitoring output, it should be apparent that the steering component of Falcon is sufficiently fast to (1) keep up with fairly high rates of monitoring and (2) steer programs at rates and with overheads enabling medium grain on-line program configuration <ref> [5] </ref> and application steering. 5 The On-line Presentation of Monitoring Information The process of on-line user interaction with a target application includes (1) obtaining application-specific information through monitoring mechanisms, (2) displaying this information to the user, and (3) controlling program execution based on (2). <p> The VASE system [21] offers tools that create and manage collections of steerable Fortran codes. The idea of steering has also been used in parallel and distributed programming to dynamically change program states or execution environment for improving program performance or reliability <ref> [5, 35, 8] </ref>. Early work in this research area focusses on the dynamic tuning of parallel applications in order to adapt them to different execution environments [44, 45].
Reference: [6] <author> Gretchen P. Brown, Richard T. Carling, Christopher F. Herot, David A. Kramlich, and Paul Souza. </author> <title> Program visualization: Graphical support for software development. </title> <journal> IEEE Computer, </journal> <volume> 18(8) </volume> <pages> 27-35, </pages> <month> August </month> <year> 1985. </year>
Reference-contexts: Interactive program steering does not involve simply the on-line or postmortem exploration of program trace or output data, as being investigated by researchers in program debugging [28, 18] or in computer graphics <ref> [6] </ref>.
Reference: [7] <author> Bernd Bruegge. </author> <title> A portable platform for distributed event environments. </title> <booktitle> In Proceedings of the ACM/ONR Workshop on Parallel and Distributed Debugging, </booktitle> <pages> pages 184-193, </pages> <address> Santa Cruz, California, </address> <month> May 20-21 </month> <year> 1991. </year> <journal> ACM Press. ACM SIGPLAN NOTICES 26(12), </journal> <month> December </month> <year> 1991. </year>
Reference-contexts: In either case, program steering is based on the on-line capture of information about current program and configuration state <ref> [7, 31, 46, 40] </ref>, and it assumes that human users and/or algorithms inspect, analyze, and manipulate such information when making and enacting steering decisions. 1 This research was supported in part by NASA grant No.
Reference: [8] <author> Greg Eisenhauer, Weiming Gu, Karsten Schwan, and Niru Mallavarupu. </author> <title> Falcon toward interactive parallel programs: The on-line steering of a molecular dynamics application. </title> <booktitle> In Proceedings of The Third International Symposium on High-Performance Distributed Computing (HPDC-3), </booktitle> <pages> pages 26-34, </pages> <address> San Francisco, CA, </address> <month> August </month> <year> 1994. </year> <journal> IEEE, IEEE Computer Society. </journal>
Reference-contexts: this section briefly describes a particular parallel code, its potential for utilizing program steering, and the required support for on-line monitoring. 2.1 The MD Application MD is an interactive molecular dynamics simulation developed at Georgia Tech in cooperation with a group of physicists exploring the statistical mechanics of complex liquids <ref> [51, 8] </ref>. In this paper, the physical MD system being simulated contains 4800 particles representing an alkane film and 2700 particles in a crystalline base on which the film is layered. <p> The VASE system [21] offers tools that create and manage collections of steerable Fortran codes. The idea of steering has also been used in parallel and distributed programming to dynamically change program states or execution environment for improving program performance or reliability <ref> [5, 35, 8] </ref>. Early work in this research area focusses on the dynamic tuning of parallel applications in order to adapt them to different execution environments [44, 45]. <p> Early work in this research area focusses on the dynamic tuning of parallel applications in order to adapt them to different execution environments [44, 45]. Recent experiments demonstrate that changes to specific program states or program components, such as locks [35] and problem partition boundaries <ref> [8] </ref>, can significantly improve overall performance. Our research interests are to provide a mechanism for programmers easily take advantage of this dynamic tuning capability as well as supporting the on-line capture of program and performance information necessary for efficient program steering.
Reference: [9] <author> Greg Eisenhauer and Karsten Schwan. </author> <title> Md a flexible framework for high-speed parallel molecular dynamics. </title> <editor> In Adrian Tentner, editor, </editor> <booktitle> High Performance Computing - 1994, </booktitle> <pages> pages 70-75, </pages> <address> P.O. Box 17900, San Diego, CA 92177, </address> <month> April </month> <year> 1994. </year> <title> Society for Computer Simulation, </title> <booktitle> Society for Computer Simulation. Proceedings of the 1994 SCS Simulation Multiconference. </booktitle> <pages> 33 </pages>
Reference-contexts: Measurements in this section are taken on a 64-node Kendall Square Research KSR-1 machine. The specific MD simulation used in these measurements uses a cylindrical domain decomposition; MD performance and speedups with different decompositions are evaluated in detail elsewhere <ref> [9] </ref>. Table 4 depicts the results of four different sets of MD runs, normed against a run of MD without monitoring.
Reference: [10] <author> Colin Fidge. </author> <title> Logical time in distributed computing systems. </title> <journal> Computer, </journal> <volume> 24(8) </volume> <pages> 28-33, </pages> <month> August </month> <year> 1991. </year>
Reference-contexts: All such techniques may be applied to Falcon's monitoring data, as well. A number of systems have addressed the problem of "out-of-order" events, events that violate causality. These events violate the "happened-before" relationship described in [27] and <ref> [10] </ref>. Post-mortem display systems such as ParaGraph [17] and SIEVE [42] may sort the trace files by timestamp.
Reference: [11] <author> Ahmed Gheith, Bodhi Mukherjee, Dilma Silva, and Karsten Schwan. Ktk: </author> <title> Kernel support for configurable objects and invocations. </title> <booktitle> In Proceedings of the Second International Workshop on Configurable Distributed Systems, </booktitle> <pages> pages 92-103, </pages> <address> Pittsburgh, Pennsylvania, March 1994. </address> <publisher> The IEEE Computer Society Press. </publisher>
Reference-contexts: can be made steerable only by requiring end users to write them accordingly, by requiring substantial compiler support [46], or by requiring that the programming language offer stronger mechanisms of abstraction than those existing in parallel Fortran or in the Cthreads library used in our work (e.g., the object model <ref> [5, 11, 26, 14] </ref>). We are currently designing higher level language primitives for definition of steering actions and for inclusion of such actions with application code. At this time, however, Falcon relies on user-directed inclusion of actuators with the application code.
Reference: [12] <author> Ahmed Gheith and Karsten Schwan. </author> <title> Chaos-arc kernel support for multi-weight objects, invocations, and atomicity in real-time applications. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 11(1) </volume> <pages> 33-72, </pages> <month> April </month> <year> 1993. </year>
Reference-contexts: Examples include the automatic configuration of small program fragments for maintaining real-time response in uniprocessor systems [32], the on-line adaptation of functional program components for realizing reliability versus performance tradeoffs in parallel and real-time applications <ref> [5, 14, 12] </ref>, and the load balancing or program configuration for enhanced reliability in distributed systems [26, 43, 31]. The MD simulation offers opportunities for performance improvement through on-line interactions with end users and with algorithms, including: * Decomposition geometries can be changed to respond to changes in physical systems.
Reference: [13] <author> Kaushik Ghosh, Kiran Panesar, Richard M. Fujimoto, and Karsten Schwan. </author> <title> PORTS: A parallel, optimistic, real-time simulator. </title> <booktitle> In Proceedings of the 8th Workshop on Parallel and Distributed Simulation, </booktitle> <address> Edinburgh, </address> <month> July </month> <year> 1994. </year> <institution> College of Computing, Georgia Institute of Technology. </institution> <note> to appear. </note>
Reference-contexts: Toward this end, our group is now experimenting with interactive parallel programs in several domains, including (1) the interactive simulation of complex systems used in conjunction with some physical system, for on-line diagnosis of problems or for trying out certain fault containment strategies <ref> [13] </ref> (e.g., telecommunication systems), and (2) the on-line experimentation with scientific or engineering applications.
Reference: [14] <author> Prabha Gopinath and Karsten Schwan. </author> <title> Chaos: Why one cannot have only an operating system for real-time applications. </title> <journal> SIGOPS Notices, </journal> <pages> pages 106-125, </pages> <month> July </month> <year> 1989. </year> <note> Also available as Philips Technical Note TN-89-006. </note>
Reference-contexts: Examples include the automatic configuration of small program fragments for maintaining real-time response in uniprocessor systems [32], the on-line adaptation of functional program components for realizing reliability versus performance tradeoffs in parallel and real-time applications <ref> [5, 14, 12] </ref>, and the load balancing or program configuration for enhanced reliability in distributed systems [26, 43, 31]. The MD simulation offers opportunities for performance improvement through on-line interactions with end users and with algorithms, including: * Decomposition geometries can be changed to respond to changes in physical systems. <p> can be made steerable only by requiring end users to write them accordingly, by requiring substantial compiler support [46], or by requiring that the programming language offer stronger mechanisms of abstraction than those existing in parallel Fortran or in the Cthreads library used in our work (e.g., the object model <ref> [5, 11, 26, 14] </ref>). We are currently designing higher level language primitives for definition of steering actions and for inclusion of such actions with application code. At this time, however, Falcon relies on user-directed inclusion of actuators with the application code.
Reference: [15] <author> Weiming Gu, Greg Eisenhauer, Eileen Kraemer, Karsten Schwan, John Stasko, Jeffrey Vetter, and Nirupama Mallavarupu. </author> <title> Falcon: On-line monitoring and steering of large-scale parallel programs. </title> <booktitle> In Proceedings of FRONTIERS'95, </booktitle> <month> February </month> <year> 1995. </year> <note> To appear. Also available as Technical Report GIT-CC-94-21, </note> <institution> College of Computing, Georgia Institute of Technology. </institution>
Reference-contexts: In comparison, with Gprof, the execution time of MD is increased by approximately 180%. Similar advantages of Falcon to other profiling tools are demonstrated when using Prof. Experimental results not reported in detail here show that Prof's overhead is approximately 130% <ref> [15] </ref>. The results described above are not surprising, since profiling tools typically maintain large amounts of compiler-derived information about a parallel program's attributes. In comparison, Falcon only maintains the specific information required for taking certain program measurements.
Reference: [16] <author> Weiming Gu, Jeffrey Vetter, and Karsten Schwan. </author> <title> An annotated bibliography of interactive program steering. </title> <journal> ACM SIGPLAN Notices, </journal> <volume> 29(9) </volume> <pages> 140-148, </pages> <month> September </month> <year> 1994. </year>
Reference-contexts: While we can base some of our work on past research on the monitoring of parallel and distributed programs for correctness and/or performance debugging, on-line and dynamic monitoring are relatively new topics [40]. We refer the reader to <ref> [16] </ref> for a brief survey of current research on interactive steering and on-line monitoring. 30 Program monitoring. Past work in monitoring of parallel and distributed programs focuses on perfor-mance understanding and debugging. These performance monitoring systems (e.g.
Reference: [17] <author> Michael T. Heath and Jennifer A. Etheridge. </author> <title> Visualizing the performance of parallel programs. </title> <journal> IEEE Software, </journal> <volume> 8(5) </volume> <pages> 29-39, </pages> <month> September </month> <year> 1991. </year>
Reference-contexts: This section presents Falcon's methods for presenting monitoring information to end users. 5.1 Falcon's On-line Display System: An Overview Graphical displays have been shown useful in presenting data structures [39], algorithms [48], runtime program behaviors [29], and performance information <ref> [17, 41] </ref> to human users. However, most current work deals primarily with off-line graphical and animated presentations of program and performance information. <p> On-line event reordering. The diagnosis and correction of out-of-order events is a common problem in parallel and distributed monitoring systems. Existing systems (e.g., ParaGraph <ref> [17] </ref> and SIEVE [42]) rely on a sort by timestamp value to impose a total order on all events stored in event files. <p> All such techniques may be applied to Falcon's monitoring data, as well. A number of systems have addressed the problem of "out-of-order" events, events that violate causality. These events violate the "happened-before" relationship described in [27] and [10]. Post-mortem display systems such as ParaGraph <ref> [17] </ref> and SIEVE [42] may sort the trace files by timestamp. Instant Replay [28], Makbilan [52], TraceViewer [19], the Animation Choreographer [25], and Xab [3] have all used a causality graph as on ordering tool for the post-mortem display of the execution of parallel programs.
Reference: [18] <author> David P. Helmbold, Charles E. McDowell, and Jian-Zhong Wang. </author> <title> Determining possible event orders by analyzing sequential traces. </title> <journal> IEEE Transactions on Parallel and Distributed Systems, </journal> <volume> 4(7) </volume> <pages> 827-840, </pages> <month> July </month> <year> 1993. </year>
Reference-contexts: Interactive program steering does not involve simply the on-line or postmortem exploration of program trace or output data, as being investigated by researchers in program debugging <ref> [28, 18] </ref> or in computer graphics [6].
Reference: [19] <author> David P. Helmbold, Charlie E. McDowell, and Jian-ZhongWang. Traceviewer: </author> <title> A graphical browser for trace analysis. </title> <type> Technical Report UCSC-CRL-90-59, </type> <institution> Univ. of California at Santa Cruz, </institution> <address> Santa Cruz, CA, </address> <month> October </month> <year> 1990. </year>
Reference-contexts: A number of systems have addressed the problem of "out-of-order" events, events that violate causality. These events violate the "happened-before" relationship described in [27] and [10]. Post-mortem display systems such as ParaGraph [17] and SIEVE [42] may sort the trace files by timestamp. Instant Replay [28], Makbilan [52], TraceViewer <ref> [19] </ref>, the Animation Choreographer [25], and Xab [3] have all used a causality graph as on ordering tool for the post-mortem display of the execution of parallel programs.
Reference: [20] <author> Jeffrey K. Hollingsworth and Barton P. Miller. </author> <title> Dynamic control of performance monitoring on large scale parallel systems. </title> <booktitle> In Proceedings of the 7th ACM International Conference on Supercomputing, </booktitle> <pages> pages 185-194, </pages> <address> Tokyo, Japan, </address> <month> July </month> <year> 1993. </year>
Reference-contexts: Some recent work has addressed application-specific program monitoring [47, 40]. In these systems, users can explicitly specify what variables or program states to monitor using specification languages [40, 23], some of which are based on the Entity-Relational model [47]. The W 3 search model described in <ref> [20] </ref> addresses this problem in a different fashion: performance data is collected using hooks either inserted by the compiler or by programmers; based on this data, potential performance bottlenecks are identified and resources causing these bottlenecks are found and then, corrected by application programmers. Data and perturbation analysis.
Reference: [21] <author> David Jablonowski, John Bruner, Brian Bliss, and Robert Haber. VASE: </author> <title> The visualization and application steering environment. </title> <booktitle> In Proceedings of Supercomputing'93, </booktitle> <pages> pages 560-569, </pages> <month> November </month> <year> 1993. </year>
Reference-contexts: The concept of steering can be found in many interactive scientific visualization and animation applications which allow users to directly manipulate the objects to be visualized or animated <ref> [22, 21] </ref>. For example, in a wind tunnel simulation, users can interactively change shapes and boundaries of objects in the wind tunnel in order to see the effects on the air flow. <p> Research has also addressed the provision of programming models and environments to support the interactive steering of scientific visualization. In [22], DYNA3D and AVS (Application Visualization System from AVS Inc.) are combined with customized interactive steering code to produce a time-accurate, unsteady finite-element simulation. The VASE system <ref> [21] </ref> offers tools that create and manage collections of steerable Fortran codes. The idea of steering has also been used in parallel and distributed programming to dynamically change program states or execution environment for improving program performance or reliability [5, 35, 8].
Reference: [22] <author> David Kerlick and Elisabeth Kirby. </author> <title> Towards interactive steering, visualization and animation of unsteady finite element simulations. </title> <booktitle> In Proceedings of Visualization'93, </booktitle> <year> 1993. </year>
Reference-contexts: The concept of steering can be found in many interactive scientific visualization and animation applications which allow users to directly manipulate the objects to be visualized or animated <ref> [22, 21] </ref>. For example, in a wind tunnel simulation, users can interactively change shapes and boundaries of objects in the wind tunnel in order to see the effects on the air flow. <p> Research has also addressed the provision of programming models and environments to support the interactive steering of scientific visualization. In <ref> [22] </ref>, DYNA3D and AVS (Application Visualization System from AVS Inc.) are combined with customized interactive steering code to produce a time-accurate, unsteady finite-element simulation. The VASE system [21] offers tools that create and manage collections of steerable Fortran codes.
Reference: [23] <author> Carol Kilpatrick, Karsten Schwan, and David Ogle. </author> <title> Using languages for describing capture, analysis, and display of performance information for parallel and distributed applications. </title> <booktitle> In International Conference on Computer Languages `90, </booktitle> <address> New Orleans, </address> <pages> pages 180-189. </pages> <publisher> IEEE, </publisher> <month> March </month> <year> 1990. </year>
Reference-contexts: Some recent work has addressed application-specific program monitoring [47, 40]. In these systems, users can explicitly specify what variables or program states to monitor using specification languages <ref> [40, 23] </ref>, some of which are based on the Entity-Relational model [47].
Reference: [24] <author> Carol E. Kilpatrick and Karsten Schwan. </author> <title> ChaosMON - application-specific monitoring and display of performance information for parallel and distributed systems. </title> <booktitle> In Proceedings of the ACM/ONR Workshop on Parallel and Distributed Debugging, </booktitle> <pages> pages 57-67, </pages> <address> Santa Cruz, California, </address> <month> May 20-21 </month> <year> 1991. </year> <journal> ACM Press. ACM SIGPLAN NOTICES 26(12), </journal> <month> December </month> <year> 1991. </year>
Reference-contexts: We are now generalizing the notion of sensors to permit programmers to specify higher level `views' of monitoring data like those described in <ref> [24, 40, 47] </ref>. Such views will be implemented with library support resident in both local and central monitors.
Reference: [25] <author> Eileen Kraemer and John T. Stasko. </author> <title> Toward flexible control of the temporal mapping from concurrent program events to animations. </title> <booktitle> In Proceedings Eighth International Parallel Processing Symposium, </booktitle> <pages> pages 902-908, </pages> <year> 1994. </year> <month> 34 </month>
Reference-contexts: These events violate the "happened-before" relationship described in [27] and [10]. Post-mortem display systems such as ParaGraph [17] and SIEVE [42] may sort the trace files by timestamp. Instant Replay [28], Makbilan [52], TraceViewer [19], the Animation Choreographer <ref> [25] </ref>, and Xab [3] have all used a causality graph as on ordering tool for the post-mortem display of the execution of parallel programs. These methods are not effective for run-time performance display because they rely on fully available trace files that may be sorted prior to their display.
Reference: [26] <author> Jeff Kramer and Jeff Magee. </author> <title> Dynamic configuration for distributed systems. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> SE-11(4):424-436, </volume> <month> April </month> <year> 1985. </year>
Reference-contexts: include the automatic configuration of small program fragments for maintaining real-time response in uniprocessor systems [32], the on-line adaptation of functional program components for realizing reliability versus performance tradeoffs in parallel and real-time applications [5, 14, 12], and the load balancing or program configuration for enhanced reliability in distributed systems <ref> [26, 43, 31] </ref>. The MD simulation offers opportunities for performance improvement through on-line interactions with end users and with algorithms, including: * Decomposition geometries can be changed to respond to changes in physical systems. <p> can be made steerable only by requiring end users to write them accordingly, by requiring substantial compiler support [46], or by requiring that the programming language offer stronger mechanisms of abstraction than those existing in parallel Fortran or in the Cthreads library used in our work (e.g., the object model <ref> [5, 11, 26, 14] </ref>). We are currently designing higher level language primitives for definition of steering actions and for inclusion of such actions with application code. At this time, however, Falcon relies on user-directed inclusion of actuators with the application code.
Reference: [27] <author> Leslie Lamport. </author> <title> Time, clocks and the ordering of events in a distributed system. </title> <journal> Communication of the Association for Computing Machinery, </journal> <volume> 21(7) </volume> <pages> 558-565, </pages> <month> July </month> <year> 1978. </year>
Reference-contexts: All such techniques may be applied to Falcon's monitoring data, as well. A number of systems have addressed the problem of "out-of-order" events, events that violate causality. These events violate the "happened-before" relationship described in <ref> [27] </ref> and [10]. Post-mortem display systems such as ParaGraph [17] and SIEVE [42] may sort the trace files by timestamp.
Reference: [28] <author> Thomas J. LeBlanc and John M. Mellor-Crummey. </author> <title> Debugging parallel programs with instant replay. </title> <journal> IEEE Transactions on Computers, </journal> <volume> C-36(4):471-481, </volume> <month> April </month> <year> 1987. </year>
Reference-contexts: Interactive program steering does not involve simply the on-line or postmortem exploration of program trace or output data, as being investigated by researchers in program debugging <ref> [28, 18] </ref> or in computer graphics [6]. <p> monitoring has focussed on helping programmers understand the correctness or performance of their parallel codes [33, 41], on minimizing or correcting for program perturbation due to monitoring [30], on reducing the amounts of monitoring or trace information captured for parallel or distributed program debugging [40], and on the effective replay <ref> [28] </ref> or long-term storage [47] of monitoring information. Falcon has three important attributes. <p> A number of systems have addressed the problem of "out-of-order" events, events that violate causality. These events violate the "happened-before" relationship described in [27] and [10]. Post-mortem display systems such as ParaGraph [17] and SIEVE [42] may sort the trace files by timestamp. Instant Replay <ref> [28] </ref>, Makbilan [52], TraceViewer [19], the Animation Choreographer [25], and Xab [3] have all used a causality graph as on ordering tool for the post-mortem display of the execution of parallel programs.
Reference: [29] <author> Allen D. Malony, David H. Hammerslag, and David J. Jablonowski. </author> <title> Traceview: A trace visualization. </title> <journal> IEEE Software, </journal> <pages> pages 19-28, </pages> <month> September </month> <year> 1991. </year>
Reference-contexts: Steps (1) and (3) have been discussed in the previous sections. This section presents Falcon's methods for presenting monitoring information to end users. 5.1 Falcon's On-line Display System: An Overview Graphical displays have been shown useful in presenting data structures [39], algorithms [48], runtime program behaviors <ref> [29] </ref>, and performance information [17, 41] to human users. However, most current work deals primarily with off-line graphical and animated presentations of program and performance information.
Reference: [30] <author> Allen D. Malony, Daniel A. Reed, and Harry A. G. Wijshoff. </author> <title> Performance measurement intrusion and perturbation analysis. </title> <journal> IEEE Transactions on Parallel and Distributed Systems, </journal> <volume> 3(4) </volume> <pages> 433-450, </pages> <month> July </month> <year> 1992. </year>
Reference-contexts: interfaces to program animation and graphical data rendering tools. 3 The Design and Implementation of Falcon 3.1 Design Goals Past work in program monitoring has focussed on helping programmers understand the correctness or performance of their parallel codes [33, 41], on minimizing or correcting for program perturbation due to monitoring <ref> [30] </ref>, on reducing the amounts of monitoring or trace information captured for parallel or distributed program debugging [40], and on the effective replay [28] or long-term storage [47] of monitoring information. Falcon has three important attributes. <p> Such perturbation is generally predictable (results on the KSR-2 are presented in Section 4), and its effects on the correctness of timing information can be eliminated using straightforward techniques for perturbation analysis <ref> [30] </ref>. Falcon's runtime system itself may be configured (steered) in several ways, including disabling or enabling sets of sensors, varying activation rates, etc. <p> Given these costs, total perturbation of a parallel program can be derived as the cumulative cost of generating all of the sensor records in the program's critical path. A more complex perturbation model is required when considering side effects of such direct program perturbation <ref> [30] </ref>. The dominant factor in sensor execution is the cost of accessing the buffer shared between application and monitoring threads. <p> From this example, it should be evident that perturbation events help users understand the monitoring system's contribution to total thread execution and wait times. Our current work is generalizing this straightforward notion of perturbation events to apply more sophisticated sequential perturbation analyses (e.g., see <ref> [30] </ref>). Another type of monitoring perturbation, causing misordered event streams, is discussed next. 5.4 On-line Event Reordering Event orderings and program animation. Displays like the thread life-time view of Figure 13 can provide users with insights into program progress and correctness. <p> Monitoring information may be refined with trace data analysis techniques, such as the Critical Path Analysis and Phase Behavior Analysis described in [33], often in an off-line manner. More sophisticated analysis techniques may be used to reduce and correct perturbation to the measured program performance due to monitoring <ref> [30] </ref>. In addition, performance data may be subjected to various statistical filtering techniques prior to its display to users. All such techniques may be applied to Falcon's monitoring data, as well. A number of systems have addressed the problem of "out-of-order" events, events that violate causality.
Reference: [31] <author> Keith Marzullo and Mark Wood. </author> <title> Making real-time reactive systems reliable. </title> <journal> ACM Operating Systems Review, </journal> <volume> 25(1) </volume> <pages> 45-48, </pages> <month> January </month> <year> 1991. </year>
Reference-contexts: In either case, program steering is based on the on-line capture of information about current program and configuration state <ref> [7, 31, 46, 40] </ref>, and it assumes that human users and/or algorithms inspect, analyze, and manipulate such information when making and enacting steering decisions. 1 This research was supported in part by NASA grant No. <p> include the automatic configuration of small program fragments for maintaining real-time response in uniprocessor systems [32], the on-line adaptation of functional program components for realizing reliability versus performance tradeoffs in parallel and real-time applications [5, 14, 12], and the load balancing or program configuration for enhanced reliability in distributed systems <ref> [26, 43, 31] </ref>. The MD simulation offers opportunities for performance improvement through on-line interactions with end users and with algorithms, including: * Decomposition geometries can be changed to respond to changes in physical systems.
Reference: [32] <author> Henry Massalin and Calton Pu. </author> <title> Threads and input/output in the synthesis kernel. </title> <booktitle> In Proceedings of the 12th Symposium on Operating Systems Principles, </booktitle> <pages> pages 191-201. </pages> <publisher> SIGOPS, Assoc. Comput. Mach., </publisher> <month> December </month> <year> 1989. </year>
Reference-contexts: Examples include the automatic configuration of small program fragments for maintaining real-time response in uniprocessor systems <ref> [32] </ref>, the on-line adaptation of functional program components for realizing reliability versus performance tradeoffs in parallel and real-time applications [5, 14, 12], and the load balancing or program configuration for enhanced reliability in distributed systems [26, 43, 31].
Reference: [33] <author> Barton P. Miller, Morgan Clark, Jeff Hollingsworth, Steven Kierstead, Sek-See Lim, and Timothy Torzewski. IPS-2: </author> <title> The second generation of a parallel program measurement system. </title> <journal> IEEE Transactions on Parallel and Distributed Systems, </journal> <volume> 1(2) </volume> <pages> 206-217, </pages> <month> April </month> <year> 1990. </year>
Reference-contexts: demonstrate the usability of Falcon, we also briefly describe and evaluate Falcon's interfaces to program animation and graphical data rendering tools. 3 The Design and Implementation of Falcon 3.1 Design Goals Past work in program monitoring has focussed on helping programmers understand the correctness or performance of their parallel codes <ref> [33, 41] </ref>, on minimizing or correcting for program perturbation due to monitoring [30], on reducing the amounts of monitoring or trace information captured for parallel or distributed program debugging [40], and on the effective replay [28] or long-term storage [47] of monitoring information. Falcon has three important attributes. <p> We refer the reader to [16] for a brief survey of current research on interactive steering and on-line monitoring. 30 Program monitoring. Past work in monitoring of parallel and distributed programs focuses on perfor-mance understanding and debugging. These performance monitoring systems (e.g. Miller's IPS [34] and IPS-2 <ref> [33] </ref>, Reed's Pablo [41]) provides programmers with execution information about their parallel codes, and leads their attention to those program components on which most execution time is spent. A variety of performance metrics, such as normalized processor time [1], execution time on the critical execution path [33], etc., are employed to <p> IPS [34] and IPS-2 <ref> [33] </ref>, Reed's Pablo [41]) provides programmers with execution information about their parallel codes, and leads their attention to those program components on which most execution time is spent. A variety of performance metrics, such as normalized processor time [1], execution time on the critical execution path [33], etc., are employed to describe the program's runtime performance. One limitation of these performance metrics is the difficulty to relate measured performance numbers to specific program details. Instead, most such research measures program execution times at the procedure level. <p> Data and perturbation analysis. Monitoring information may be refined with trace data analysis techniques, such as the Critical Path Analysis and Phase Behavior Analysis described in <ref> [33] </ref>, often in an off-line manner. More sophisticated analysis techniques may be used to reduce and correct perturbation to the measured program performance due to monitoring [30]. In addition, performance data may be subjected to various statistical filtering techniques prior to its display to users.
Reference: [34] <author> Barton P. Miller and Cui-Qing Yang. IPS: </author> <title> An interactive and automatic performance measurement tool for parallel and distributed programs. </title> <booktitle> In Proceedings of the 7th International Conference on Distributed Computing Systems, </booktitle> <pages> pages 482-489, </pages> <address> Berlin, West Germany, </address> <month> September </month> <year> 1987. </year> <note> IEEE. </note>
Reference-contexts: We refer the reader to [16] for a brief survey of current research on interactive steering and on-line monitoring. 30 Program monitoring. Past work in monitoring of parallel and distributed programs focuses on perfor-mance understanding and debugging. These performance monitoring systems (e.g. Miller's IPS <ref> [34] </ref> and IPS-2 [33], Reed's Pablo [41]) provides programmers with execution information about their parallel codes, and leads their attention to those program components on which most execution time is spent.
Reference: [35] <author> Bodhi Mukherjee and Karsten Schwan. </author> <title> Experiments with a configurable lock for multiprocessors. </title> <booktitle> In Proceedings of the International Conference on Parallel Processing, </booktitle> <publisher> Michigan, </publisher> <pages> pages 205-208. </pages> <publisher> IEEE, </publisher> <month> Aug. </month> <year> 1993. </year>
Reference-contexts: Instead, program steering targets the parallel code itself, and it can range from rapid changes made by on-line algorithms to the implementation of single program abstractions (e.g., a mu-tex lock <ref> [35] </ref>) to the user-directed improvement of or experimentation with high-level attributes of parallel codes (e.g., load balancing in a large-scale scientific code see Section 2.2). <p> Examples of such information used by on-line steering algorithms include lock contention values, which are used by on-line configuration algorithms to adjust individual mutex locks (see <ref> [35] </ref>) based on changes in a program's locking pattern. A third requirement of on-line steering is that steering is effective only if it can be performed at a rate higher than the rate of program change. <p> However, when steering is used to dynamically adjust lock waiting strategies, changes in locking patterns must be detected and reacted upon in every few milliseconds <ref> [35] </ref>. <p> Actions are defined methods able to operate on the attributes of these objects. A complete object-oriented framework for defining and operating on program attributes is defined in [38]. The definition and dynamic adjustment of operating system level attributes is described in <ref> [35] </ref>. For purposes of this paper, the reader should assume that such attributes correspond to specific program variables (ie., to specific locations in the program's data). <p> However, it is not possible to use Falcon's current mechanisms to perform steering of program abstractions accessed with high frequencies, like the adaptable locks described in <ref> [35] </ref>. Such high-rate and low-latency steering must be performed by local monitors themselves, possibly using custom implementations of sampling sensors. <p> The VASE system [21] offers tools that create and manage collections of steerable Fortran codes. The idea of steering has also been used in parallel and distributed programming to dynamically change program states or execution environment for improving program performance or reliability <ref> [5, 35, 8] </ref>. Early work in this research area focusses on the dynamic tuning of parallel applications in order to adapt them to different execution environments [44, 45]. <p> Early work in this research area focusses on the dynamic tuning of parallel applications in order to adapt them to different execution environments [44, 45]. Recent experiments demonstrate that changes to specific program states or program components, such as locks <ref> [35] </ref> and problem partition boundaries [8], can significantly improve overall performance. Our research interests are to provide a mechanism for programmers easily take advantage of this dynamic tuning capability as well as supporting the on-line capture of program and performance information necessary for efficient program steering. <p> In other publications, we also also demonstrate some limitations on applying Falcon's functionality, notably when using it for the steering of individual operating system abstractions used by parallel programs (e.g., mutex locks <ref> [35] </ref>). To support the monitoring and steering rates required for such fine grain program control, monitoring mechanisms must be customized. Our future work will address how such customized mechanisms may be used in conjunction with the remainder of the Falcon system.
Reference: [36] <author> Bodhisattwa Mukherjee. </author> <title> A portable and reconfigurable threads package. </title> <booktitle> In Proceedings of Sun User Group Technical Conference, </booktitle> <pages> pages 101-112, </pages> <month> June </month> <year> 1991. </year>
Reference-contexts: required for on-line data visualization and to take advantage of other performance display tools, Falcon also interfaces to custom displays and to systems for the creation of high-quality 3D visualizations of program output data, like the SGI Explorer tools. 3.3 System Implementation Falcon's implementation relies on a Mach-compatible Cthreads library <ref> [36] </ref> available on several hardware platforms, including the Kendall Square Research KSR-1 and KSR-2 supercomputer, the GP1000 BBN Butterfly multiprocessor, the Sequent multiprocessor, and uni- and multi-processor SGI and SUN SPARC workstations. Figure 5 depicts the system's implementation.
Reference: [37] <author> Bodhisattwa Mukherjee and Karsten Schwan. </author> <title> Improving performance by use of adaptive objects: Experimentation with a configurable multiprocessor thread package. </title> <booktitle> In Proc. of Second International Symposium on High Performance Distributed Computing (HPDC-2), </booktitle> <pages> pages 59-66, </pages> <month> July </month> <year> 1993. </year> <note> Also TR# GIT-CC-93/17. </note>
Reference-contexts: Low latency implies that steering algorithms can rapidly react to changes in a user program's current state <ref> [37] </ref>. Monitoring latency includes the cost of writing a sensor record to a monitoring buffer, the waiting time in the buffer, and the cost of reading the sensor record from the monitoring buffer.
Reference: [38] <author> Bodhisattwa Mukherjee, Dilma Silva, Karsten Schwan, and Ahmed Gheith. Ktk: </author> <title> kernel support for configurable objects and invocations. </title> <journal> Distributed Systems Engineering Journal. </journal> <note> Expected to be out early 95. </note>
Reference-contexts: Also, actions are stored in the database with each event type. Actions are defined methods able to operate on the attributes of these objects. A complete object-oriented framework for defining and operating on program attributes is defined in <ref> [38] </ref>. The definition and dynamic adjustment of operating system level attributes is described in [35]. For purposes of this paper, the reader should assume that such attributes correspond to specific program variables (ie., to specific locations in the program's data). <p> Our future work will address how such customized mechanisms may be used in conjunction with the remainder of the Falcon system. In addition, future work is addressing the monitoring of object-oriented, parallel programs, including the provision of default monitoring views and performance displays <ref> [38] </ref>. The MD and atmospheric modeling codes as well as the Falcon system are implemented and evaluated on a 64-node KSR shared memory supercomputer. However, the Falcon system is available on several shared memory platforms, including SGI and SUN Sparc parallel workstations.
Reference: [39] <author> Brad A. Myers. INCENSE: </author> <title> A system for displaying data structures. </title> <journal> Computer Graphics, </journal> <volume> 17(3):113, </volume> <month> July </month> <year> 1983. </year>
Reference-contexts: Steps (1) and (3) have been discussed in the previous sections. This section presents Falcon's methods for presenting monitoring information to end users. 5.1 Falcon's On-line Display System: An Overview Graphical displays have been shown useful in presenting data structures <ref> [39] </ref>, algorithms [48], runtime program behaviors [29], and performance information [17, 41] to human users. However, most current work deals primarily with off-line graphical and animated presentations of program and performance information.
Reference: [40] <author> D.M. Ogle, K. Schwan, and R. Snodgrass. </author> <title> Application-dependent dynamic monitoring of distributed and parallel systems. </title> <journal> IEEE Transactions on Parallel and Distributed Systems, </journal> <volume> 4(7) </volume> <pages> 762-778, </pages> <month> July </month> <year> 1993. </year>
Reference-contexts: In either case, program steering is based on the on-line capture of information about current program and configuration state <ref> [7, 31, 46, 40] </ref>, and it assumes that human users and/or algorithms inspect, analyze, and manipulate such information when making and enacting steering decisions. 1 This research was supported in part by NASA grant No. <p> Analyses may employ statistical methods, boolean operators like those described in <ref> [40] </ref>, or simply reorder the events being received, as described in Section 5.4. Graphical views may be displayed with multiple media or systems, currently including X windows, Motif, and the SGI Explorer environment. In addition, Falcon offers default on-line graphical animations of the performance of threads-based parallel programs. <p> Design Goals Past work in program monitoring has focussed on helping programmers understand the correctness or performance of their parallel codes [33, 41], on minimizing or correcting for program perturbation due to monitoring [30], on reducing the amounts of monitoring or trace information captured for parallel or distributed program debugging <ref> [40] </ref>, and on the effective replay [28] or long-term storage [47] of monitoring information. Falcon has three important attributes. <p> While we can base some of our work on past research on the monitoring of parallel and distributed programs for correctness and/or performance debugging, on-line and dynamic monitoring are relatively new topics <ref> [40] </ref>. We refer the reader to [16] for a brief survey of current research on interactive steering and on-line monitoring. 30 Program monitoring. Past work in monitoring of parallel and distributed programs focuses on perfor-mance understanding and debugging. These performance monitoring systems (e.g. <p> However, program steering can depend on program information derived from specific program variables or statements, such as the analyses of the workloads of each domain when steering the MD application. Some recent work has addressed application-specific program monitoring <ref> [47, 40] </ref>. In these systems, users can explicitly specify what variables or program states to monitor using specification languages [40, 23], some of which are based on the Entity-Relational model [47]. <p> Some recent work has addressed application-specific program monitoring [47, 40]. In these systems, users can explicitly specify what variables or program states to monitor using specification languages <ref> [40, 23] </ref>, some of which are based on the Entity-Relational model [47]. <p> We are now generalizing the notion of sensors to permit programmers to specify higher level `views' of monitoring data like those described in <ref> [24, 40, 47] </ref>. Such views will be implemented with library support resident in both local and central monitors.
Reference: [41] <author> Daniel A. Reed, Ruth A. Aydt, Roger J. Noe, Keith A. Shields, and Bradley W. Schwartz. </author> <title> An Overview of the Pablo Performance Analysis Environment. </title> <institution> Department of Computer Science, University of Illinois, </institution> <address> 1304 West Springfield Avenue, Urbana, Illinois 61801, </address> <month> November </month> <year> 1992. </year>
Reference-contexts: demonstrate the usability of Falcon, we also briefly describe and evaluate Falcon's interfaces to program animation and graphical data rendering tools. 3 The Design and Implementation of Falcon 3.1 Design Goals Past work in program monitoring has focussed on helping programmers understand the correctness or performance of their parallel codes <ref> [33, 41] </ref>, on minimizing or correcting for program perturbation due to monitoring [30], on reducing the amounts of monitoring or trace information captured for parallel or distributed program debugging [40], and on the effective replay [28] or long-term storage [47] of monitoring information. Falcon has three important attributes. <p> This section presents Falcon's methods for presenting monitoring information to end users. 5.1 Falcon's On-line Display System: An Overview Graphical displays have been shown useful in presenting data structures [39], algorithms [48], runtime program behaviors [29], and performance information <ref> [17, 41] </ref> to human users. However, most current work deals primarily with off-line graphical and animated presentations of program and performance information. <p> Figure 12 demonstrates the use of three alternative display methods for a sample event stream. The first method, built on the X window system and the Athena and Pablo <ref> [41] </ref> widget sets, uses the work load events for the display of the application's load balance information. The second method applies statistical methods to analyze events from the application and then presents the resulting summary information to end users in a textual format. <p> Past work in monitoring of parallel and distributed programs focuses on perfor-mance understanding and debugging. These performance monitoring systems (e.g. Miller's IPS [34] and IPS-2 [33], Reed's Pablo <ref> [41] </ref>) provides programmers with execution information about their parallel codes, and leads their attention to those program components on which most execution time is spent.
Reference: [42] <author> Sekhar R. Sarukkai and Dennis Gannon. </author> <title> Parallel program visualization using SIEVE.1. </title> <booktitle> In International Conference on Supercomputing. ACM, </booktitle> <month> July </month> <year> 1992. </year> <month> 35 </month>
Reference-contexts: On-line event reordering. The diagnosis and correction of out-of-order events is a common problem in parallel and distributed monitoring systems. Existing systems (e.g., ParaGraph [17] and SIEVE <ref> [42] </ref>) rely on a sort by timestamp value to impose a total order on all events stored in event files. The on-line nature of the Falcon monitoring system precludes using such a solution, and sorting by timestamp order does not entirely eliminate the problem of out-of-order events [4]. <p> All such techniques may be applied to Falcon's monitoring data, as well. A number of systems have addressed the problem of "out-of-order" events, events that violate causality. These events violate the "happened-before" relationship described in [27] and [10]. Post-mortem display systems such as ParaGraph [17] and SIEVE <ref> [42] </ref> may sort the trace files by timestamp. Instant Replay [28], Makbilan [52], TraceViewer [19], the Animation Choreographer [25], and Xab [3] have all used a causality graph as on ordering tool for the post-mortem display of the execution of parallel programs.
Reference: [43] <author> Karsten Schwan, Prabha Gopinath, </author> <title> and Win Bo. CHAOS kernel support for objects in the real-time domain. </title> <journal> IEEE Transactions on Computers, </journal> <volume> C-36(8):904-916, </volume> <month> July </month> <year> 1987. </year>
Reference-contexts: include the automatic configuration of small program fragments for maintaining real-time response in uniprocessor systems [32], the on-line adaptation of functional program components for realizing reliability versus performance tradeoffs in parallel and real-time applications [5, 14, 12], and the load balancing or program configuration for enhanced reliability in distributed systems <ref> [26, 43, 31] </ref>. The MD simulation offers opportunities for performance improvement through on-line interactions with end users and with algorithms, including: * Decomposition geometries can be changed to respond to changes in physical systems.
Reference: [44] <author> Karsten Schwan and Anita K. Jones. </author> <title> Flexible software development for multiple computer systems. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> SE-12(3):385-401, </volume> <month> March </month> <year> 1986. </year>
Reference-contexts: Early work in this research area focusses on the dynamic tuning of parallel applications in order to adapt them to different execution environments <ref> [44, 45] </ref>. Recent experiments demonstrate that changes to specific program states or program components, such as locks [35] and problem partition boundaries [8], can significantly improve overall performance.
Reference: [45] <author> Karsten Schwan, Rajiv Ramnath, Sridhar Vasudevan, and Dave Ogle. </author> <title> A system for parallel programming. </title> <booktitle> In 9th International Conference on Software Engineering, </booktitle> <address> Monterey, CA, </address> <pages> pages 270-282. </pages> <publisher> IEEE, ACM, </publisher> <month> March </month> <year> 1987. </year> <note> Awarded best paper. </note>
Reference-contexts: Early work in this research area focusses on the dynamic tuning of parallel applications in order to adapt them to different execution environments <ref> [44, 45] </ref>. Recent experiments demonstrate that changes to specific program states or program components, such as locks [35] and problem partition boundaries [8], can significantly improve overall performance.
Reference: [46] <author> Karsten Schwan, Rajiv Ramnath, Sridhar Vasudevan, and David Ogle. </author> <title> A language and system for the construction and timing of parallel programs. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 14(4) </volume> <pages> 455-471, </pages> <month> April </month> <year> 1988. </year>
Reference-contexts: In either case, program steering is based on the on-line capture of information about current program and configuration state <ref> [7, 31, 46, 40] </ref>, and it assumes that human users and/or algorithms inspect, analyze, and manipulate such information when making and enacting steering decisions. 1 This research was supported in part by NASA grant No. <p> In general, however, programs can be made steerable only by requiring end users to write them accordingly, by requiring substantial compiler support <ref> [46] </ref>, or by requiring that the programming language offer stronger mechanisms of abstraction than those existing in parallel Fortran or in the Cthreads library used in our work (e.g., the object model [5, 11, 26, 14]).
Reference: [47] <author> Richard Snodgrass. </author> <title> A relational approach to monitoring complex systems. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 6(2) </volume> <pages> 157-196, </pages> <month> May </month> <year> 1988. </year>
Reference-contexts: helping programmers understand the correctness or performance of their parallel codes [33, 41], on minimizing or correcting for program perturbation due to monitoring [30], on reducing the amounts of monitoring or trace information captured for parallel or distributed program debugging [40], and on the effective replay [28] or long-term storage <ref> [47] </ref> of monitoring information. Falcon has three important attributes. First, Falcon supports the application-specific monitoring/steering, analysis, and display of program information, so that users can capture, process, and understand and steer exactly the program attributes relevant to steering or to the specific performance problems being diagnosed or investigated. <p> Monitoring overheads may be controlled during each program run by direct interaction of user programs and/or Falcon's user interface and/or analysis/steering algorithms with the monitor's runtime system. First, sensors can be turned on or off during the application's execution <ref> [47] </ref>. Second, sensors can dynamically adjust their own behavior to continously control overall monitoring overhead and latency. <p> However, program steering can depend on program information derived from specific program variables or statements, such as the analyses of the workloads of each domain when steering the MD application. Some recent work has addressed application-specific program monitoring <ref> [47, 40] </ref>. In these systems, users can explicitly specify what variables or program states to monitor using specification languages [40, 23], some of which are based on the Entity-Relational model [47]. <p> Some recent work has addressed application-specific program monitoring [47, 40]. In these systems, users can explicitly specify what variables or program states to monitor using specification languages [40, 23], some of which are based on the Entity-Relational model <ref> [47] </ref>. <p> We are now generalizing the notion of sensors to permit programmers to specify higher level `views' of monitoring data like those described in <ref> [24, 40, 47] </ref>. Such views will be implemented with library support resident in both local and central monitors.
Reference: [48] <author> John T. Stasko. </author> <title> TANGO: A framework and system for algorithm animation. </title> <journal> IEEE Computer, </journal> <volume> 23(9) </volume> <pages> 27-39, </pages> <month> September </month> <year> 1990. </year>
Reference-contexts: Steps (1) and (3) have been discussed in the previous sections. This section presents Falcon's methods for presenting monitoring information to end users. 5.1 Falcon's On-line Display System: An Overview Graphical displays have been shown useful in presenting data structures [39], algorithms <ref> [48] </ref>, runtime program behaviors [29], and performance information [17, 41] to human users. However, most current work deals primarily with off-line graphical and animated presentations of program and performance information.
Reference: [49] <author> John T. Stasko and Eileen Kraemer. </author> <title> A methodology for building application-specific visualizations of parallel programs. </title> <journal> Journal of Parallel and Distributed Computing, </journal> <volume> 18(2) </volume> <pages> 258-264, </pages> <month> June </month> <year> 1993. </year>
Reference-contexts: In addition, Falcon offers default on-line graphical animations of the performance of threads-based parallel programs. For such Motif-based displays, the Polka system for program animation provides users with easy-to-use tools for creating application-specific 2D animations of arbitrary program attributes <ref> [49] </ref>. * Extension to multiple heterogeneous computing platforms an extension of Falcon addresses both single parallel computing platforms running threads programs as well as distributed computational engines using PVM as a software basis. <p> In contrast, the central monitoring and steering controller is typically located on 8 a front end workstation or on a processor providing user interface functionality. Falcon uses the Polka system for the construction and use of graphical displays of program information <ref> [49] </ref>. Several performance or functional views (e.g., the aforementioned bargraphs and thread visualizations) have been built with this tool. <p> Available with Cthreads programs running on SGI and SPARC workstations and on KSR machines, this view uses the default sensors embedded in Cthreads. The view is implemented with the Polka animation library <ref> [49] </ref>. Since Polka provides a variety of graphical objects, animation primitives, and user interface facilities, the program defining the thread 23 life-time view only consists of roughly 200 lines of application-level Polka code. <p> Polka runtime libraries pro-vide a flexible animation scheduling policy, permit different temporal mappings of program events to their animations, and therefore facilitates the construction of on-line displays. Polka is described and evaluated in detail in <ref> [49] </ref>. The thread life-time view shows the different states of threads over time. The state information depicted in the view includes thread execution time, blocking time, waiting time in ready queues, the identifiers of conditions or mutex locks on which threads are blocked, and thread identifiers. <p> A version of Falcon currently being completed also works with PVM across networked execution platforms. Similar portability is attained for the graphical displays used with Falcon. Notably, the Polka animation library can be executed on any Unix platform on which Motif is available <ref> [49] </ref>. The Falcon system has been in routine use at the Georgia Institute of Technology by non-Computer Science end users. Its low-level mechanisms are available via the Internet since early Summer 1994. A version of Falcon offering on-line user interfaces for monitoring and monitor control will be released in 1995.
Reference: [50] <author> V. S. Sunderam. </author> <title> PVM: A framework for parallel distributed computing. </title> <journal> Concurrency: Practice and Experience, </journal> <volume> 2(4) </volume> <pages> 315-339, </pages> <year> 1990. </year>
Reference-contexts: On-line program steering utilizes current and past efforts concerning the efficient linkage of multiple supercomputer engines, which is being addressed by several Gigabit testbeds efforts in the United States. Systems like PVM <ref> [50] </ref> and Express offer software support for constructing large-scale distributed and parallel codes. 7 Conclusions and Future Work The Falcon monitoring system enables programmers to capture and view precisely the program attributes of interest to them.
Reference: [51] <author> T. K. Xia, Jian Ouyang, M. W. Ribarsky, and Uzi Landman. </author> <title> Interfacial alkane films. </title> <journal> Physical Review Letters, </journal> <volume> 69(13) </volume> <pages> 1967-1970, </pages> <month> 28 September </month> <year> 1992. </year>
Reference-contexts: this section briefly describes a particular parallel code, its potential for utilizing program steering, and the required support for on-line monitoring. 2.1 The MD Application MD is an interactive molecular dynamics simulation developed at Georgia Tech in cooperation with a group of physicists exploring the statistical mechanics of complex liquids <ref> [51, 8] </ref>. In this paper, the physical MD system being simulated contains 4800 particles representing an alkane film and 2700 particles in a crystalline base on which the film is layered.
Reference: [52] <author> Dror Zernik and Larry Rudolph. </author> <title> Animating work and time for debugging parallel programs foundation and experience. </title> <booktitle> In Proceedings of the ACM/ONR Workshop on Parallel and Distributed Debugging, </booktitle> <pages> pages 46-56, </pages> <address> Santa Cruz, California, </address> <month> May 20-21 </month> <year> 1991. </year> <journal> ACM Press. ACM SIGPLAN NOTICES 26(12), </journal> <month> December </month> <year> 1991. </year> <month> 36 </month>
Reference-contexts: A number of systems have addressed the problem of "out-of-order" events, events that violate causality. These events violate the "happened-before" relationship described in [27] and [10]. Post-mortem display systems such as ParaGraph [17] and SIEVE [42] may sort the trace files by timestamp. Instant Replay [28], Makbilan <ref> [52] </ref>, TraceViewer [19], the Animation Choreographer [25], and Xab [3] have all used a causality graph as on ordering tool for the post-mortem display of the execution of parallel programs.
References-found: 52

