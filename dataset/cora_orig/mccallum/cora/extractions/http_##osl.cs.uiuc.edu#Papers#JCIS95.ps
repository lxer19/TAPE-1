URL: http://osl.cs.uiuc.edu/Papers/JCIS95.ps
Refering-URL: http://osl.cs.uiuc.edu/Papers/Vis.html
Root-URL: http://www.cs.uiuc.edu
Email: Email: fastley j aghag@cs.uiuc.edu  
Phone: Phone: (217) 244-3087 Fax: (217) 333-3501  
Title: A Visualization Model for Concurrent Systems  
Author: Mark Astley and Gul A. Agha 
Keyword: Actors, Distributed Systems, Program Visualization  
Date: 21, 1995  
Note: December  
Address: 1304 W. Springfield Avenue  Urbana, IL 61801, USA  
Affiliation: Open Systems Laboratory Department of Computer Science  University of Illinois at Urbana-Champaign  
Abstract: Concurrent systems maintain a distributed state and thus require coordination and synchronization between components to ensure consistency. To provide a coherent design approach to concurrent systems, recent work has employed an object-based methodology which emphasizes interactions through well-defined interfaces. The Actor model has provided formal reasoning about distributed object systems. Nonetheless, due to the complex interactions among components and the high volume of observable information produced, understanding and reasoning about concurrent algorithms in terms of simple interactions is a difficult task. Coordination patterns, which abstract over simple interactions, are not biased by low-level event orderings and are the appropriate mechanism for reasoning about concurrent algorithms. We outline a methodology for visualizing coordination patterns in concurrent algorithms which emphasizes observable interactions and causal connections between objects. We introduce visualizers as a linguistic mechanism for mapping coordination patterns to visualization. Visualizers are specified separately from algorithm code and thus respect code integrity. Moreover, visualizers may be implemented strictly in terms of object interfaces and thus preserve object encapsulation. fl Author for contact.
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> G. Agha. </author> <title> Actors: A Model of Concurrent Computation. </title> <publisher> MIT Press, </publisher> <year> 1986. </year>
Reference-contexts: Large performance overhead affects message passing and A Visualization Model for Concurrent Systems 4 may mask race conditions. The causal interaction model naturally separates visualization design objectives from the system under analysis by allowing transparent implementation. We model distributed systems as systems of Actors <ref> [1] </ref>. Actors provide a general and flexible object-based model of concurrency. In particular, common concurrent abstractions can be constructed using a system of actors. Actors may coordinate by exchanging messages and updating local behavior according to specific protocols. <p> Thus, to capture the most general and flexible notion of concurrency, we base our model of program visualization on Actors <ref> [1] </ref>. Actors are encapsulated, interactive, autonomous components of a computing system that communicate by asynchronous message passing. Conceptually, an actor consists of a unique name, a mail buffer to receive messages, and a behavior which determines an actor's response to each message.
Reference: [2] <author> G. Agha, S. Frtlund, W. Kim, R. Panwar, A. Patterson, and D. Sturman. </author> <title> Abstraction and modularity mechanisms for concurrent computing. </title> <booktitle> IEEE Parallel and Distributed Technology, </booktitle> <month> May </month> <year> 1993. </year>
Reference-contexts: Internal concurrency may be mimicked by creating a new actor to asynchronously process the remainder of the current computation while the original actor begins processing a new message. Actors provide a model of concurrent computation upon which a wide variety of concurrent abstractions can be developed <ref> [2] </ref>. In particular, actors can be used to model systems of objects communicating through well-defined interfaces. <p> This suggests an implementation in which components and their observers are indistinguishable entities. The transparent implementation of protocols for guaranteeing fault-tolerance requires similar constructs [19]. In particular, reflective language attributes have been used to modify communication behavior <ref> [2] </ref>. Recall that preserving the causal order of actor interactions is necessary in order to create visualization which can be used to reason about global behavior.
Reference: [3] <author> G. Agha, I. Mason, S. Smith, and C. Talcott. </author> <title> Towards a theory of actor computation. </title> <booktitle> In The Third International Conference on Concurrency Theory (CONCUR '92), </booktitle> <pages> pages 565-579, </pages> <address> Stony Brook, NY, </address> <month> August </month> <year> 1992. </year> <title> Springer Verlag. </title> <booktitle> Lecture Notes in Computer Science No. </booktitle> <pages> 630. </pages>
Reference-contexts: We then define the causal interaction model by augmenting the actor event model with mechanisms for detecting patterns of actor events in a manner which preserves consistency. Note that we only develop the linguistic constructs and implementation techniques that are 1 Formally, actor events are only receive events <ref> [3] </ref>. However, for the sake of clarity we abuse terminology here.
Reference: [4] <author> O. Babaoglu and K. Marzullo. </author> <title> Consistent global states of distributed systems: Fundamental concepts and mechanisms. </title> <editor> In S. Mullender, editor, </editor> <booktitle> Distributed Systems, chapter 4, </booktitle> <pages> pages 55-96. </pages> <publisher> ACM Press, </publisher> <address> New York, NY, </address> <year> 1994. </year>
Reference-contexts: Thus, when used to visualize concurrent execution, the state-transition model requires a global snapshot of algorithm state. Unfortunately, in distributed environments global snapshots are costly due to distributed state and asynchrony, and may not correspond to any state entered by the underlying execution <ref> [4] </ref>. Moreover, semantically equivalent execution behavior A Visualization Model for Concurrent Systems 3 may yield different state transitions. As a result, the state-transition model is costly to implement and does not effectively abstract over the relevant behavior in distributed systems. <p> Thus, we require implementation mechanisms which maintain a representation of the causal order of events and ensure that invoked visualization actions are A Visualization Model for Concurrent Systems 12 causally delivered. Causal delivery can be guaranteed by implementing a vector clock protocol <ref> [4] </ref>. In particular, we wish to guarantee that invocations of visualization actions are causally delivered to the visualization monitor and hence executed in causal order. Note that because observers are installed on each actor, they are the natural choice for transparently implementing a vector clock protocol.
Reference: [5] <author> M.H. Brown. </author> <title> Exploring algorithms using balsa-ii. </title> <booktitle> IEEE Computer, </booktitle> <month> May </month> <year> 1988. </year>
Reference-contexts: Program visualization, the animated display of various aspects of algorithm execution, has been utilized in an attempt to cope with this complexity [7, 17]. In particular, program visualization has been applied to such diverse applications as computer science instruction <ref> [5] </ref>, visual debugging [12], program verification and reasoning [7], and educational software [8]. Typical visual environments use pictorial abstractions to represent program components and their interactions, showing the various stages of a program in execution. <p> As a result, most recent efforts have concentrated on visualizing sequential program execution. Nonetheless, it is still useful to contrast and compare the causal interaction model with sequential systems in order to reveal differences in expressiveness and specification techniques. Representative sequential environments include BALSA <ref> [5] </ref> and its descendent ZEUS [6], and TANGO [16]. Technically, these environments are not restricted to visualizing sequential programs. However, none of the named systems includes explicit mechanisms for dealing with concurrency.
Reference: [6] <author> M.H. Brown. Zeus: </author> <title> A system for algorithm animation and multiview editing. </title> <booktitle> In Proceedings of the IEEE Workshop on Visual Languages, </booktitle> <pages> pages 4-9, </pages> <year> 1991. </year>
Reference-contexts: As a result, most recent efforts have concentrated on visualizing sequential program execution. Nonetheless, it is still useful to contrast and compare the causal interaction model with sequential systems in order to reveal differences in expressiveness and specification techniques. Representative sequential environments include BALSA [5] and its descendent ZEUS <ref> [6] </ref>, and TANGO [16]. Technically, these environments are not restricted to visualizing sequential programs. However, none of the named systems includes explicit mechanisms for dealing with concurrency.
Reference: [7] <author> G.-C. Roman et. al. Pavane: </author> <title> A system for declarative visualization of concurrent computations. </title> <journal> Journal of Visual Languages and Computing, </journal> <volume> 3(2) </volume> <pages> 161-193, </pages> <month> June </month> <year> 1992. </year>
Reference-contexts: Program visualization, the animated display of various aspects of algorithm execution, has been utilized in an attempt to cope with this complexity <ref> [7, 17] </ref>. In particular, program visualization has been applied to such diverse applications as computer science instruction [5], visual debugging [12], program verification and reasoning [7], and educational software [8]. <p> Program visualization, the animated display of various aspects of algorithm execution, has been utilized in an attempt to cope with this complexity [7, 17]. In particular, program visualization has been applied to such diverse applications as computer science instruction [5], visual debugging [12], program verification and reasoning <ref> [7] </ref>, and educational software [8]. Typical visual environments use pictorial abstractions to represent program components and their interactions, showing the various stages of a program in execution. Program visualization is particularly important for understanding concurrent applications where the semantic behavior of an algorithm corresponds to many different low-level event orderings.
Reference: [8] <author> K. Kahn. </author> <title> Toontalk TM an animated programming environment for children. </title> <booktitle> In Proceedings of the National Educational Computing Conference (NECC'95), </booktitle> <year> 1995. </year>
Reference-contexts: In particular, program visualization has been applied to such diverse applications as computer science instruction [5], visual debugging [12], program verification and reasoning [7], and educational software <ref> [8] </ref>. Typical visual environments use pictorial abstractions to represent program components and their interactions, showing the various stages of a program in execution. Program visualization is particularly important for understanding concurrent applications where the semantic behavior of an algorithm corresponds to many different low-level event orderings.
Reference: [9] <author> L. Lamport. </author> <title> Time, clocks, and the ordering of events in a distributed system. </title> <journal> Communications of the ACM, </journal> <volume> 21(7) </volume> <pages> 558-565, </pages> <month> July </month> <year> 1978. </year>
Reference-contexts: In particular, reasoning about coordination behavior requires preserving the causal relationships among interacting components. Causal order can be determined succinctly in terms of the partial order of events in a distributed system <ref> [9] </ref>. Thus, the causal interaction model guarantees consistency by requiring that visualization observe the same partial order of events as that of the algorithm execution.
Reference: [10] <author> C. Manning. Traveler: </author> <title> the actor observatory. </title> <booktitle> In Proceedings of European Conference on Object-Oriented Programming, </booktitle> <month> January </month> <year> 1987. </year> <note> Also appeared in LNCS (276). </note>
Reference-contexts: From a somewhat different tradition than program visualization, event diagrams have been a prevalent mechanism for visualizing actor computation. Augmented Event Diagrams were used by Manning in the Traveler observatory to support the debugging of actor programs <ref> [10] </ref>. In a related fashion, predicate transition nets have been used to visualize actor computation [11]. However, both approaches suffer from two key weaknesses: there are no coordination abstraction mechanisms; and, representations rather than models are generated.
Reference: [11] <author> S. Miriyala, G. Agha, and Y. Sami. </author> <title> Visualizing actor programs using predicate transition nets. </title> <journal> Journal of Visual Languages and Computation, </journal> <volume> 3(2) </volume> <pages> 195-220, </pages> <month> June </month> <year> 1992. </year>
Reference-contexts: Augmented Event Diagrams were used by Manning in the Traveler observatory to support the debugging of actor programs [10]. In a related fashion, predicate transition nets have been used to visualize actor computation <ref> [11] </ref>. However, both approaches suffer from two key weaknesses: there are no coordination abstraction mechanisms; and, representations rather than models are generated. Event diagrams do not abstract over low-level execution details and tend to be unnecessarily complex.
Reference: [12] <author> S. Mukherjea and J.T. Stasko. </author> <title> Toward visual debugging: Integrating algorithm animation capabilities within a source level debugger. </title> <journal> ACM Transactions on Computer-Human Interaction, </journal> <year> 1993. </year>
Reference-contexts: Program visualization, the animated display of various aspects of algorithm execution, has been utilized in an attempt to cope with this complexity [7, 17]. In particular, program visualization has been applied to such diverse applications as computer science instruction [5], visual debugging <ref> [12] </ref>, program verification and reasoning [7], and educational software [8]. Typical visual environments use pictorial abstractions to represent program components and their interactions, showing the various stages of a program in execution.
Reference: [13] <author> M. Raynal, A. Schiper, and S. Toueg. </author> <title> The causal ordering abstraction and a simple way to implement it. </title> <journal> Information Processing Letters, </journal> <volume> 36(6) </volume> <pages> 343-350, </pages> <year> 1991. </year>
Reference-contexts: Note that requiring that causal connection information be maintained entails both performance and storage overhead. Vector clocks are only one implementation and may not always be the most suitable. A variety of different techniques exist for guaranteeing causal delivery in various contexts <ref> [13] </ref>. However, as long as the number of actors remains modest, vector clocks provide suitable functionality to demonstrate the implementation. 5.2 Linguistic Support for Specifying Visualization Visualization groups represent the key abstraction for specifying visualization over a group of actors. We define visualization groups linguistically in terms of visualizers.
Reference: [14] <author> G.-C. Roman and K.C. Cox. </author> <title> A taxonomy of program visualization systems. </title> <booktitle> IEEE Computer, </booktitle> <month> December </month> <year> 1993. </year>
Reference-contexts: Similarly, unlike most contemporary environments, we demonstrate that the causal interaction model allows a transparent implementation separating visualization design concerns from algorithm code. Current visualization environments adopt the view that program visualization represents a mapping from computational state to visual representation <ref> [14] </ref>. Constructing this map involves the following three tasks: first, identifying interesting program states; second, defining visual representations corresponding to these states; and finally, defining a mapping mechanism which links program state to visual representation. We call this the state-transition approach. <p> Moreover, annotated code biases the resulting visualization to a particular execution history. By emphasizing patterns as a basis for visualization events, visualizers avoid bias and provide an abstraction mechanism for viewing interactions. Of the few environments which do exist for visualizing concurrency, POLKA [17] and PAVANE <ref> [14] </ref> are the most relevant. POLKA is a descendent of TANGO intended for animations of programs executing on parallel architectures.
Reference: [15] <author> J.T. Stasko. </author> <title> The path-transition paradigm: A practical methodology for adding animation to program interfaces. </title> <journal> Journal of Visual Languages and Computing, </journal> <volume> 1(3) </volume> <pages> 213-236, </pages> <month> September </month> <year> 1990. </year>
Reference-contexts: BALSA and ZEUS provide perhaps the most complete mechanisms in terms of specifying arbitrary visual layouts. TANGO, on the other hand, contributes a natural and flexible animation facility using the notion of path transitions <ref> [15] </ref>. The sequential systems named above all use code annotation to identify visualization events (in BALSA these are called interesting events). In effect, visualization state and computational state are intermingled. As a result, visualization is produced as a side effect of algorithm execution.
Reference: [16] <author> J.T. Stasko. </author> <title> Tango: A framework and system for algorithm animation. </title> <journal> Computer, </journal> <volume> 23(9) </volume> <pages> 27-39, </pages> <month> Septem-ber </month> <year> 1990. </year>
Reference-contexts: Nonetheless, it is still useful to contrast and compare the causal interaction model with sequential systems in order to reveal differences in expressiveness and specification techniques. Representative sequential environments include BALSA [5] and its descendent ZEUS [6], and TANGO <ref> [16] </ref>. Technically, these environments are not restricted to visualizing sequential programs. However, none of the named systems includes explicit mechanisms for dealing with concurrency. The strength of these systems tends to lie not in their visualization event detection mechanisms, but rather in their expressiveness in terms of visualization actions.
Reference: [17] <author> J.T. Stasko and E. Kraemer. </author> <title> A methodology for building application-specific visualizations of parallel programs. </title> <journal> Journal of Parallel and Distributed Computing, </journal> <volume> 18 </volume> <pages> 258-264, </pages> <year> 1993. </year>
Reference-contexts: Program visualization, the animated display of various aspects of algorithm execution, has been utilized in an attempt to cope with this complexity <ref> [7, 17] </ref>. In particular, program visualization has been applied to such diverse applications as computer science instruction [5], visual debugging [12], program verification and reasoning [7], and educational software [8]. <p> Moreover, annotated code biases the resulting visualization to a particular execution history. By emphasizing patterns as a basis for visualization events, visualizers avoid bias and provide an abstraction mechanism for viewing interactions. Of the few environments which do exist for visualizing concurrency, POLKA <ref> [17] </ref> and PAVANE [14] are the most relevant. POLKA is a descendent of TANGO intended for animations of programs executing on parallel architectures.
Reference: [18] <author> D.C. Sturman. </author> <title> Fault-adaptation for systems in unpredictable environments. </title> <type> Master's thesis, </type> <institution> University of Illinois at Urbana-Champaign, </institution> <month> January </month> <year> 1994. </year>
Reference-contexts: Visualizers are specification transparent in that they need only refer to the interfaces of member actors and hence may be specified completely separately from algorithm code. Currently, we are in the process of implementing our model atop Broadway, a proto-type environment for developing actor systems <ref> [18] </ref>. We have concentrated on specifying visualization event detection mechanisms rather than specifying explicit graphics modeling features. A more complete specification of a visualization model would include mechanisms for defining visualization actions as well. We leave this topic for future work.

References-found: 18

