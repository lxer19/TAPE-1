URL: http://www-swiss.ai.mit.edu/ftpdir/users/dae/related-papers/liang1.ps.Z
Refering-URL: http://www-swiss.ai.mit.edu/ftpdir/users/dae/home.html
Root-URL: 
Email: fliang,hudak,jones-markg@cs.yale.edu  
Title: Monad Transformers and Modular Interpreters  
Author: Sheng Liang Paul Hudak Mark Jones 
Address: New Haven, CT 06520-8285  
Affiliation: Yale University Department of Computer Science  
Abstract: We show how a set of building blocks can be used to construct programming language interpreters, and present implementations of such building blocks capable of supporting many commonly known features, including simple expressions, three different function call mechanisms (call-by-name, call-by-value and lazy evaluation), references and assignment, nondeterminism, first-class continuations, and program tracing. The underlying mechanism of our system is monad transformers, a simple form of abstraction for introducing a wide range of computational behaviors, such as state, I/O, continuations, and exceptions. Our work is significant in the following respects. First, we have succeeded in designing a fully modular interpreter based on monad transformers that includes features missing from Steele's, Espinosa's, and Wadler's earlier efforts. Second, we have found new ways to lift monad operations through monad transformers, in particular difficult cases not achieved in Moggi's original work. Third, we have demonstrated that interactions between features are reflected in liftings and that semantics can be changed by reordering monad transformers. Finally, we have implemented our interpreter in Gofer, whose constructor classes provide just the added power over Haskell's type classes to allow precise and convenient expression of our ideas. This implementation includes a method for constructing extensible unions and a form of subtyping that is interesting in its own right. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Andrew W. Appel and Trevor Jim. </author> <title> Continuation-passing, closure-passing style. </title> <booktitle> In ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 193-302, </pages> <month> Jan-uary </month> <year> 1989. </year>
Reference-contexts: The lack of separability of traditional denotational semantics [19] has long been recognized. Algebraic approaches such as Mosses' action semantics [16], and related efforts by Lee [13], Wand [23], Appel & Jim <ref> [1] </ref>, Kelsey & Hudak [11], and others, attempt to solve parts of this problem, but fall short in several crucial ways. 1 A ground-breaking attempt to better solve the overall problem began with Moggi's [15] proposal to use monads to structure denotational semantics.
Reference: [2] <author> Adrienne Bloss, Paul Hudak, and Jonathan Young. </author> <title> Code optimization for lazy evaluation. </title> <journal> Lisp and Symbolic Computation, </journal> <volume> 1(1) </volume> <pages> 147-164, </pages> <year> 1988. </year>
Reference-contexts: We assume a type Env of environments that associates variable names with computations (corresponding to the closure mode of evaluation <ref> [2] </ref>), and that has two operations: lookupEnv :: Name ! Env ! Maybe (InterpM Value) extendEnv :: (Name; InterpM Value) ! Env ! Env type Name = String In addition, we will define later two monadic operations, rdEnv and inEnv, that return the current environment and perform a computation in a
Reference: [3] <author> Robert Cartwright and Matthias Felleisen. </author> <title> Extensible denotational semantics. </title> <booktitle> In Proceedings of Symposium on Theoretical Aspects of Computer Software, </booktitle> <pages> pages 244-272, </pages> <year> 1994. </year>
Reference-contexts: We begin by realizing the limitations of Moggi's framework and Espinosa's implementation, in particular the difficulty in dealing with complicated operations such as callcc, and investigate how common programming language fea 1 Very recently, Cartwright and Felleisen <ref> [3] </ref> have independently proposed a modular semantics emphasizing a direct semantics approach, which seems somewhat more complex than ours; the precise relationship between the approaches is, however, not yet clear. type Term = OR TermA arithmetic ( OR TermF functions ( OR TermR assignment ( OR TermL lazy evaluation ( OR
Reference: [4] <author> David Espinosa. </author> <title> Modular denotational semantics. </title> <type> Unpublished manuscript, </type> <month> December </month> <year> 1993. </year>
Reference-contexts: In fact, pseudomonads are really just a special kind of monad transformer, first suggested by Moggi [15] as a potential way to leave a hole in a monad for further extension. Returning to Moggi's original ideas, Espinosa <ref> [4] </ref> nicely formulated in Scheme a system called Semantic Lego the first modular interpreter based on monad transformers and laid out the issues in lifting.
Reference: [5] <author> David Espinosa. </author> <title> Building interpreters by transforming stratified monads. </title> <type> Unpublished manuscript, </type> <note> ftp from altdorf.ai.mit.edu:pub/dae, </note> <month> June </month> <year> 1994. </year>
Reference-contexts: Our work also shares results with Jones and Duponcheel's [10] work on composing monads. Independently, Espinosa <ref> [5] </ref> has continued working on monad transformers, and has also recognized the limitations of earlier approaches and proposed a solution quite different from ours.
Reference: [6] <author> Andrzej Filinski. </author> <title> Representing monads. </title> <booktitle> In Conference Record of POPL '94: 21st ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages, Portland, Oregon, </booktitle> <pages> pages 446-457, </pages> <address> New York, </address> <month> January </month> <year> 1994. </year> <note> ACM Press. </note>
Reference-contexts: This is consistent with Filinski's observations <ref> [6] </ref>, and, in practice, provides us an opportunity to fine tune the resulting semantics. In lifting callcc through StateT s, we have a choice of passing either the current state s 1 or the captured state s 0 .
Reference: [7] <editor> Paul Hudak, Simon Peyton Jones, and Philip Wadler. </editor> <title> Report on the programming language Haskell: a non-strict, purely functional language, version 1.2. </title> <type> Technical Report YALEU/DCS/RR-777, </type> <institution> Yale University Department of Computer Science, </institution> <month> March </month> <year> 1992. </year> <journal> Also in ACM SIGPLAN Notices, </journal> <volume> Vol. 27(5), </volume> <month> May </month> <year> 1992. </year>
Reference-contexts: More recently, Steele [18] proposed pseudomonads as a way to compose monads and thus build up an interpreter from smaller parts, but he failed to properly incorporate important features such as an environment and store, and struggled with restrictions in the Haskell <ref> [7] </ref> type system when trying to implement his ideas. In fact, pseudomonads are really just a special kind of monad transformer, first suggested by Moggi [15] as a potential way to leave a hole in a monad for further extension.
Reference: [8] <author> Mark P. Jones. </author> <note> Introduction to gofer 2.20. Ftp from nebula.cs.yale.edu in the directory pub/haskell/gofer, </note> <month> September </month> <year> 1991. </year>
Reference-contexts: His new approach relies on a notion of higher-order monads (called situated monads) to relate different layers of monad transformers, and he has investigated the semantic implications of the order of monad transformer composition. It is not yet clear how his new approach relates to ours. We use Gofer <ref> [8] </ref> syntax, which is very similar to Haskell's, throughout the paper.
Reference: [9] <author> Mark P. Jones. </author> <title> A system of constructor classes: Overloading and implicit higher-order polymorphism. </title> <booktitle> In FPCA '93: Conference on Functional Programming Languages and Computer Architecture, Copenhagen, Denmark, </booktitle> <pages> pages 52-61, </pages> <address> New York, June 1993. </address> <publisher> ACM Press. </publisher>
Reference-contexts: and we choose a functional language over mathematical syntax for three reasons: (1) it is just about as concise as mathematical syntax, 2 (2) it emphasizes the fact that our ideas are implementable (and thus have been debugged!), and (3) it shows how the relatively new idea of constructor classes <ref> [9] </ref> can be used to represent some rather complex typing relationships. Of course, monads can be expressed in a variety of other (higher-order) programming languages, in particular SML [14], whose type system is equally capable of expressing some of our ideas. <p> Then with monad transformers we can put the individual features together, piece-by-piece in different orders, to create full-featured interpreters. 3 The Constructor Class System For readers not familiar with the Gofer type system (in particular, constructor classes <ref> [9] </ref>), this section provides a motivating example. Constructor classes support abstraction of common features among type constructors. <p> For example: write msg = update (n sofar ! sofar ++ msg) `bind` n ! unit () 7 Monad Transformers To get an intuitive feel for monad transformers, consider the merging of a state monad with an arbitrary monad, an example adapted from Jones's constructor class paper <ref> [9] </ref>: type StateT s m a = s ! m (s; a) Note that the type variable m above stands for a type constructor, a fact automatically determined by the Gofer kind inference system. <p> Some of these (StateT, ContT, and ErrorT) appear in an abstract form in Moggi's note [15]. The environment monad is similar to the state reader by Wadler [22]. The state and environment monad transformers are related to ideas found in Jones and Duponcheel's <ref> [9] </ref> [10] work. 7.1 State Monad Transformer Recall the definition of state monad transformer StateT: type StateT s m a = s ! m (s; a) Using instance declarations, we now wish to declare both that StateT s m is a monad (given m is a monad), and that StateT s
Reference: [10] <author> Mark P. Jones and Luc Duponcheel. </author> <note> Composing mon-ads. Research Report YALEU/DCS/RR-1004, </note> <institution> Yale University Department of Computer Science, </institution> <address> New Haven, Connecticut, </address> <month> December </month> <year> 1993. </year>
Reference-contexts: In so doing we are able to express more modularity and more language features than in previous work, solving several open problems that arose not only in Moggi's work, but in Steele's and Espinosa's as well. Our work also shares results with Jones and Duponcheel's <ref> [10] </ref> work on composing monads. Independently, Espinosa [5] has continued working on monad transformers, and has also recognized the limitations of earlier approaches and proposed a solution quite different from ours. <p> Some of these (StateT, ContT, and ErrorT) appear in an abstract form in Moggi's note [15]. The environment monad is similar to the state reader by Wadler [22]. The state and environment monad transformers are related to ideas found in Jones and Duponcheel's [9] <ref> [10] </ref> work. 7.1 State Monad Transformer Recall the definition of state monad transformer StateT: type StateT s m a = s ! m (s; a) Using instance declarations, we now wish to declare both that StateT s m is a monad (given m is a monad), and that StateT s is <p> = bind class Monad m ) ContMonad m where callcc :: ((a ! m b) ! m a) ! m a instance Monad m ) ContMonad (ContT ans m) where callcc f = nk ! f (na ! n ! k a) k 7.5 The List Monad Jones and Duponcheel <ref> [10] </ref> have shown that lists compose with special kinds of monads called commutative monads. It is not clear, however, if lists compose with arbitrary monads.
Reference: [11] <author> Richard Kelsey and Paul Hudak. </author> <title> Realistic compilation by program transformation. </title> <booktitle> In ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 181-192, </pages> <month> January </month> <year> 1989. </year>
Reference-contexts: The lack of separability of traditional denotational semantics [19] has long been recognized. Algebraic approaches such as Mosses' action semantics [16], and related efforts by Lee [13], Wand [23], Appel & Jim [1], Kelsey & Hudak <ref> [11] </ref>, and others, attempt to solve parts of this problem, but fall short in several crucial ways. 1 A ground-breaking attempt to better solve the overall problem began with Moggi's [15] proposal to use monads to structure denotational semantics.
Reference: [12] <author> Amir Kishon, Paul Hudak, and Charles Consel. </author> <title> Monitoring semantics: A formal framework for specifying, implementing and reasoning about execution monitors. </title> <booktitle> In Proceedings of the ACM SIGPLAN '91 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 338-352, </pages> <month> June </month> <year> 1991. </year>
Reference-contexts: InterpC TermT where interp (Trace l t) = write ("enter " ++ l) `bind` n ! interp t `bind` nv ! write ("leave " ++ l ++ " with:" ++ show v) `bind` n ! unit v Here we see that some of the features in Kishon et al.'s system <ref> [12] </ref> are easily incorporated into our interpreter. 5.6 The Continuation Building Block First-class continuations can be included in our language with: data TermC = CallCC Using the callcc semantic function (to be defined later): callcc :: ((a ! InterpM b) ! InterpM a) ! InterpM a we can give an interpretation
Reference: [13] <author> Peter Lee. </author> <title> Realistic Compiler Generation. </title> <booktitle> Foundations of Computing. </booktitle> <publisher> MIT Press, </publisher> <year> 1989. </year>
Reference-contexts: The lack of separability of traditional denotational semantics [19] has long been recognized. Algebraic approaches such as Mosses' action semantics [16], and related efforts by Lee <ref> [13] </ref>, Wand [23], Appel & Jim [1], Kelsey & Hudak [11], and others, attempt to solve parts of this problem, but fall short in several crucial ways. 1 A ground-breaking attempt to better solve the overall problem began with Moggi's [15] proposal to use monads to structure denotational semantics.
Reference: [14] <author> Robin Milner, Mads Tofte, and Robert Harper. </author> <title> The Definition of Standard ML. </title> <publisher> MIT Press, </publisher> <year> 1990. </year>
Reference-contexts: Of course, monads can be expressed in a variety of other (higher-order) programming languages, in particular SML <ref> [14] </ref>, whose type system is equally capable of expressing some of our ideas. The system could also be expressed in Scheme, but of course we would then lose the benefits of strong static type-checking. Our Gofer source code is available via anonymous ftp from nebula.cs.yale.edu in the directory pub/yale-fp/modular-interpreter.
Reference: [15] <author> Eugenio Moggi. </author> <title> An abstract view of programming languages. </title> <type> Technical Report ECS-LFCS-90-113, </type> <institution> Laboratory for Foundations of Computer Science, University of Edinburgh, Edinburgh, </institution> <address> Scotland, </address> <year> 1990. </year>
Reference-contexts: as Mosses' action semantics [16], and related efforts by Lee [13], Wand [23], Appel & Jim [1], Kelsey & Hudak [11], and others, attempt to solve parts of this problem, but fall short in several crucial ways. 1 A ground-breaking attempt to better solve the overall problem began with Moggi's <ref> [15] </ref> proposal to use monads to structure denotational semantics. <p> In fact, pseudomonads are really just a special kind of monad transformer, first suggested by Moggi <ref> [15] </ref> as a potential way to leave a hole in a monad for further extension. Returning to Moggi's original ideas, Espinosa [4] nicely formulated in Scheme a system called Semantic Lego the first modular interpreter based on monad transformers and laid out the issues in lifting. <p> Specific monad transformers are described in the remainder of this section. Some of these (StateT, ContT, and ErrorT) appear in an abstract form in Moggi's note <ref> [15] </ref>. The environment monad is similar to the state reader by Wadler [22]. <p> types) j m t (monad types) de t is the mapping of types across the monad transformer t: dAe t = A dt 1 ! t 2 e t = dt 1 e t ! dt 2 e t dm t e t = t m dt e t Moggi <ref> [15] </ref> studied the problem of lifting under a categorical context. The objective was to identify liftable operations from their type signatures. Unfortunately, many useful operations such as merge, inEnv and callcc failed to meet Moggi's criteria, and were left unsolved. We individually consider how to lift these difficult cases.
Reference: [16] <author> Peter D. Mosses. </author> <title> A basic abstract semantic algebra. </title> <editor> In Gilles Kahn, David B. MacQueen, and Gor-don D. Plotkin, editors, </editor> <booktitle> Semantics of Data Types: International Symposium, Sophia-Antipolis, France, </booktitle> <pages> pages 87-107. </pages> <publisher> Springer-Verlag, </publisher> <month> June </month> <year> 1984. </year> <note> Lecture Notes in Computer Science 173. </note>
Reference-contexts: The lack of separability of traditional denotational semantics [19] has long been recognized. Algebraic approaches such as Mosses' action semantics <ref> [16] </ref>, and related efforts by Lee [13], Wand [23], Appel & Jim [1], Kelsey & Hudak [11], and others, attempt to solve parts of this problem, but fall short in several crucial ways. 1 A ground-breaking attempt to better solve the overall problem began with Moggi's [15] proposal to use monads
Reference: [17] <editor> Simon Peyton Jones and Philip Wadler. </editor> <title> Imperative functional programming. </title> <booktitle> In Proceedings 20th Symposium on Principles of Programming Languages, </booktitle> <pages> pages 71-84. </pages> <publisher> ACM, </publisher> <month> January </month> <year> 1993. </year>
Reference-contexts: Wadler [21] popularized Moggi's ideas in the functional programming community by showing that many type constructors (such as List) were monads and how monads could be used in a variety of settings, many with an imperative feel (such as in Peyton Jones & Wadler <ref> [17] </ref>). Wadler's interpreter design, however, treats the interpreter monad as a monolithic structure which has to be reconstructed every time a new feature is added.
Reference: [18] <author> Guy L. Steele Jr. </author> <title> Building interpreters by composing monads. </title> <booktitle> In Conference Record of POPL '94: 21st ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages, Portland, Oregon, </booktitle> <pages> pages 472-492, </pages> <address> New York, </address> <month> January </month> <year> 1994. </year> <note> ACM Press. </note>
Reference-contexts: Wadler's interpreter design, however, treats the interpreter monad as a monolithic structure which has to be reconstructed every time a new feature is added. More recently, Steele <ref> [18] </ref> proposed pseudomonads as a way to compose monads and thus build up an interpreter from smaller parts, but he failed to properly incorporate important features such as an environment and store, and struggled with restrictions in the Haskell [7] type system when trying to implement his ideas.
Reference: [19] <author> Joseph Stoy. </author> <title> Denotational Semantics: The Scott-Strachey Approach to Programming Language Theory. </title> <publisher> MIT Press, </publisher> <year> 1977. </year>
Reference-contexts: The motivation for building modular interpreters is to isolate the semantics of individual programming language features for the purpose of better understanding, simplifying, and implementing the features and their interactions. The lack of separability of traditional denotational semantics <ref> [19] </ref> has long been recognized. <p> Our approach also helps to clarify the interactions between various programming language features. This paper realized Moggi's idea of a modular presentation of denotational semantics for complicated languages, and is much cleaner than the traditional approach <ref> [19] </ref>. On the practical side, our results provide new insights into designing and implementing programming languages, in particular, extensible languages, which allow the programmer to specify new features on top of existing ones. Acknowledgements We thank Dan Rabin, Zhong Shao, Rajiv Mirani and anonymous referees for helpful suggestions.
Reference: [20] <author> Andrew P. Tolmach and Andrew W. Appel. </author> <title> Debugging standard ML without reverse engineering. </title> <booktitle> In Proceedings of the 1990 ACM Conference on Lisp and Functional Programming, </booktitle> <address> Nice, France, </address> <month> June </month> <year> 1990. </year>
Reference-contexts: In lifting callcc through StateT s, we have a choice of passing either the current state s 1 or the captured state s 0 . The former is the usual semantics for callcc, and the latter is useful in Tolmach and Appel's approach to debugging <ref> [20] </ref>. instance (MonadT (StateT s) m; ContMonad m) ) ContMonad (StateT s m) where - callcc :: ((a ! s ! m (s; b)) ! s ! m (s; a)) ! s ! m (s; a) callcc f = ns 0 ! callcc (nk ! f (na ! ns 1 !
Reference: [21] <editor> Philip Wadler. </editor> <booktitle> The essence of functional programming. In Conference Record of the Nineteenth Annual ACM Symposium on Principles of Programming Languages, </booktitle> <address> Albuquerque, New Mexico, </address> <pages> pages 1-14, </pages> <month> January </month> <year> 1992. </year> <month> 10 </month>
Reference-contexts: Wadler <ref> [21] </ref> popularized Moggi's ideas in the functional programming community by showing that many type constructors (such as List) were monads and how monads could be used in a variety of settings, many with an imperative feel (such as in Peyton Jones & Wadler [17]). <p> For example, if we substitute the identity monad: type Id a = a for m in the above monad transformer, we arrive at: StateT s Id a = s ! Id (s; a) = s ! (s; a) which is the standard state monad found, for example, in Wadler's work <ref> [21] </ref>. The power of monad transformers is two-fold. First, they add operations (i.e. introduce new features) to a monad. The StateT monad transformer above, for example, adds state s to the monad it is applied to, and the resulting monad accepts update as a legitimate operation on it. <p> To be a monad, bind and unit must satisfy the well-known Monad Laws <ref> [21] </ref>: Left unit: (unit a) `bind` k = k a Right unit: m `bind` unit = m Associativity: m `bind` na ! (k a `bind` h) = (m `bind` k) `bind` h We define a monad transformer as any type constructor t such that if m is a monad (based on
Reference: [22] <author> Philip L. Wadler. </author> <title> Comprehending monads. </title> <booktitle> In Proceed--ings of the 1990 ACM Conference on Lisp and Functional Programming, </booktitle> <year> 1990. </year>
Reference-contexts: Specific monad transformers are described in the remainder of this section. Some of these (StateT, ContT, and ErrorT) appear in an abstract form in Moggi's note [15]. The environment monad is similar to the state reader by Wadler <ref> [22] </ref>.
Reference: [23] <author> Mitchell Wand. </author> <title> A semantic prototyping system. </title> <booktitle> SIG-PLAN Notices, ACM Symposium on Compiler Construction, </booktitle> <volume> 19(6) </volume> <pages> 213-221, </pages> <year> 1984. </year>
Reference-contexts: The lack of separability of traditional denotational semantics [19] has long been recognized. Algebraic approaches such as Mosses' action semantics [16], and related efforts by Lee [13], Wand <ref> [23] </ref>, Appel & Jim [1], Kelsey & Hudak [11], and others, attempt to solve parts of this problem, but fall short in several crucial ways. 1 A ground-breaking attempt to better solve the overall problem began with Moggi's [15] proposal to use monads to structure denotational semantics.
References-found: 23

