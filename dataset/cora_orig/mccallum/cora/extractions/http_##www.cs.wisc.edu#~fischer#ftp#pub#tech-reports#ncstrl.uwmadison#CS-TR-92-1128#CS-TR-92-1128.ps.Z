URL: http://www.cs.wisc.edu/~fischer/ftp/pub/tech-reports/ncstrl.uwmadison/CS-TR-92-1128/CS-TR-92-1128.ps.Z
Refering-URL: http://www.cs.wisc.edu/~fischer/ftp/pub/tech-reports/ncstrl.uwmadison/CS-TR-92-1128/
Root-URL: http://www.cs.wisc.edu
Email: tom@cs.wisc.edu horwitz@cs.wisc.edu  
Title: Slicing Programs with Arbitrary Control Flow  
Author: THOMAS BALL SUSAN HORWITZ 
Date: December 21, 1992  
Address: 1210 West Dayton Street Madison, Wisconsin 53706 USA  
Affiliation: Computer Sciences Department University of Wisconsin Madison  
Abstract: Program slicing is a program transformation that is useful in program debugging, program maintenance, and other applications that involve understanding program behavior. Given a program point p and a set of variables V, the goal of slicing is to create a projection of the program (by eliminating some statements), such that the projection and the original program compute the same values for all variables in V at point p. This paper addresses the problem of slicing programs with arbitrary control flow. Previous slicing algorithms do not always form semantically correct program projections when applied to such programs. We present an algorithm for slicing programs with complex control flow and a proof of its correctness. Our algo rithm works for programs with completely arbitrary control flow, including irreducible control flow.
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> A. Aho, R. Sethi, and J. Ullman, </author> <booktitle> Compilers: Principles, Techniques and Tools, </booktitle> <publisher> Addison-Wesley, </publisher> <address> Reading, MA (1986). </address>
Reference-contexts: Our algorithm works for programs with completely arbitrary control flow, including irreducible graphs <ref> [1] </ref>. (As given here, our algorithm has a slight restriction: A program is sliced with respect to a point p and the set of variables used or defined at p rather than an arbitrary set of variables.
Reference: 2. <author> B. Baker, </author> <title> An Algorithm for Structuring Flow Graphs, </title> <editor> J. </editor> <booktitle> ACM 24(1) pp. </booktitle> <address> 98-120 New York, NY, </address> <month> (January </month> <year> 1977). </year>
Reference-contexts: For example, given a program P with standard CFG G, one could construct the minimal flow/path-projection of G with respect to some vertex and then synthesize a program from that CFG using a structuring algorithm such as Baker's <ref> [2] </ref>. However, in a language with unstructured control flow, there can be many programs with the same CFG.
Reference: 3. <author> J. D. Choi and J. Ferrante, </author> <title> What is in a slice, </title> <type> Unpublished draft, </type> <institution> IBM T.J. Watson Research Center (December 1992). </institution>
Reference-contexts: However, we believe it is possible to extend slicing with reordering even in the presence of complex control flow. Choi and Ferrante independently discovered the same problem of slicing programs with complex control flow <ref> [3] </ref>. They proposed two solutions to the problem, both based on the program dependence graph. The first uses the idea of an augmented control flow graph, much the same as ours. The second solution uses the PDG of the program's standard control flow graph to decide which statements to eliminate.
Reference: 4. <author> J. Ferrante, K. Ottenstein, and J. Warren, </author> <title> The program dependence graph and its use in optimization, </title> <journal> ACM Transactions on Programming Languages and Systems 9(5) pp. </journal> <month> 319-349 (July </month> <year> 1987). </year>
Reference-contexts: Both algorithms make use of a program's control flow graph; Weiser's algorithm operates directly on the control flow graph, and the Ottensteins' algorithm operates on the program dependence graph <ref> [4] </ref>, which includes edges that are defined in terms of relationships between vertices in the control flow graph. Both algorithms have two steps. In Weiser's algorithm, the output of Step 1 is a subset S of the vertices of the control flow graph. <p> preserve the values of all variables, but only to preserve the values of the variables used or defined at the point with respect to which the slice is taken. 4 In addition to control and flow dependences, program dependence graphs usually include either def-order dependences [5] or output and anti-dependences <ref> [4] </ref>. These additional edges are not needed for program slicing, and so are omitted from the definition given here. We also do not need to distinguish between loop-independent and loop-carried dependences (which are ill-defined for irreducible control flow anyway). - 8 - DEFINITION (control dependence).
Reference: 5. <author> S. Horwitz, J. Prins, and T. Reps, </author> <title> On the adequacy of program dependence graphs for representing programs, pp. </title> <booktitle> 146-157 in Conference Record of the 15th ACM Symposium on Principles of Programming Languages, </booktitle> <address> (San Diego, CA, </address> <month> January 13-15, </month> <year> 1988), </year> <booktitle> ACM, </booktitle> <address> New York (1988). </address>
Reference-contexts: of slicing is not to preserve the values of all variables, but only to preserve the values of the variables used or defined at the point with respect to which the slice is taken. 4 In addition to control and flow dependences, program dependence graphs usually include either def-order dependences <ref> [5] </ref> or output and anti-dependences [4]. These additional edges are not needed for program slicing, and so are omitted from the definition given here. We also do not need to distinguish between loop-independent and loop-carried dependences (which are ill-defined for irreducible control flow anyway). - 8 - DEFINITION (control dependence).
Reference: 6. <author> S. Horwitz, J. Prins, and T. Reps, </author> <title> Integrating non-interfering versions of programs, </title> <journal> ACM Trans. Program. Lang. Syst. </journal> <pages> 11(3) pp. </pages> <month> 345-387 (July </month> <year> 1989). </year>
Reference-contexts: 1. INTRODUCTION Program slicing, a program transformation originally defined by Mark Weiser [13], is useful in program debugging [9], program maintenance <ref> [6] </ref>, and other applications that involve understanding program behavior [7].
Reference: 7. <author> S. Horwitz, </author> <title> Identifying the semantic and textual differences between two versions of a program, </title> <booktitle> Proceedings of the ACM SIGPLAN '90 Conference on Programming Language Design and Implementation (published as SIGPLAN Notices) 25(6) pp. 234-245 ACM, </booktitle> <month> (June 20-22, </month> <year> 1990). </year>
Reference-contexts: 1. INTRODUCTION Program slicing, a program transformation originally defined by Mark Weiser [13], is useful in program debugging [9], program maintenance [6], and other applications that involve understanding program behavior <ref> [7] </ref>. Given a program point p and a set of variables V, the goal of slicing is to create a projection of the program (by eliminating some statements), such that the projection and the original program compute the same values for all variables in V at point p. Example.
Reference: 8. <author> S. Horwitz, T. Reps, and D. Binkley, </author> <title> Interprocedural slicing using dependence graphs, </title> <journal> ACM Transactions on Programming Languages and Systems 12(1) pp. </journal> <month> 26-60 (January </month> <year> 1990). </year>
Reference-contexts: For any value of N, the example program and the program projection compute the same value for variable prod in the output statement. ` This paper addresses a problem that has not been discussed in the literature on program slicing <ref> [8, 10, 12, 13] </ref>. The problem is how to slice programs with unstructured control flow, i.e., programs that include constructs such as break and goto. Previous algorithms do not slice such programs correctly.
Reference: 9. <author> B. Korel, </author> <title> PELASProgram Error-Locating Assistant System, </title> <journal> IEEE Transactions on Software Engineering SE-14(9) pp. </journal> <month> 1253-1260 (September </month> <year> 1988). </year>
Reference-contexts: 1. INTRODUCTION Program slicing, a program transformation originally defined by Mark Weiser [13], is useful in program debugging <ref> [9] </ref>, program maintenance [6], and other applications that involve understanding program behavior [7].
Reference: 10. <author> K.J. Ottenstein and L.M. Ottenstein, </author> <title> The program dependence graph in a software development environment, </title> <booktitle> Proceedings of the ACM SIGSOFT/SIGPLAN Software Engineering Symposium on Practical Software Development Environments, </booktitle> <address> (Pittsburgh, PA, </address> <month> April 23-25, </month> <year> 1984), </year> <journal> ACM SIGPLAN Notices 19(5) pp. </journal> <month> 177-184 (May, </month> <year> 1984). </year>
Reference-contexts: For any value of N, the example program and the program projection compute the same value for variable prod in the output statement. ` This paper addresses a problem that has not been discussed in the literature on program slicing <ref> [8, 10, 12, 13] </ref>. The problem is how to slice programs with unstructured control flow, i.e., programs that include constructs such as break and goto. Previous algorithms do not slice such programs correctly. <p> c c c slice to be taken with respect to an arbitrary set of variables V at point p is straightforward: Add artificial uses of all variables in V at point p.) Algorithms for slicing programs with structured control flow have been defined by Weiser [13] and by the Otten-steins <ref> [10] </ref>. Let us consider the problems that arise if one tries to apply either of those algorithms to programs with unstructured control flow. <p> RELATED WORK As mentioned previously, Weiser defined the first program slicing algorithm [13]. The Ottensteins defined a more efficient program slicing algorithm using the program dependence graph <ref> [10] </ref>. Neither algorithm handles unstructured control flow correctly. Reps and Yang gave the first formal proof that the program slices formed by using the program dependence graph have the desired semantic property [12].
Reference: 11. <author> T. Reps and T. Teitelbaum, </author> <title> The Synthesizer Generator: A system for constructing language-based editors, </title> <publisher> Springer-Verlag, </publisher> <address> New York, NY (1988). </address>
Reference-contexts: Example. Figure 2 (b) shows the CFG of the program in Figure 2 (a). ` translation from a program to its control flow graph. The grammar is given in the style used in <ref> [11] </ref>, in which the underlying context free grammar defines a program's abstract (rather than concrete) syntax. Operator names are used to identify productions uniquely.
Reference: 12. <author> T. Reps and W. Yang, </author> <title> The semantics of program slicing and program integration, </title> <booktitle> in Proceedings of the Colloquium on Current Issues in Programming Languages, </booktitle> <address> (Barcelona, Spain, March 13-17, </address> <year> 1989), </year> <booktitle> Lecture Notes in Computer Science, </booktitle> <publisher> Springer-Verlag, </publisher> <address> New York, NY (March 1989). </address>
Reference-contexts: For any value of N, the example program and the program projection compute the same value for variable prod in the output statement. ` This paper addresses a problem that has not been discussed in the literature on program slicing <ref> [8, 10, 12, 13] </ref>. The problem is how to slice programs with unstructured control flow, i.e., programs that include constructs such as break and goto. Previous algorithms do not slice such programs correctly. <p> In fact, we prove a stronger result (as done by Reps and Yang for structured programs <ref> [12] </ref>): the original program and the projection compute the same values at every shared component. <p> The Ottensteins defined a more efficient program slicing algorithm using the program dependence graph [10]. Neither algorithm handles unstructured control flow correctly. Reps and Yang gave the first formal proof that the program slices formed by using the program dependence graph have the desired semantic property <ref> [12] </ref>. Furthermore, they showed that slicing using the program dependence graph guarantees equivalent behavior at every point in the slice (not just at the slicing vertex). However, they proved this only for programs with structured control flow.
Reference: 13. <author> M. Weiser, </author> <title> Program slicing, </title> <journal> IEEE Transactions on Software Engineering SE-10(4) pp. </journal> <month> 352-357 (July, </month> <year> 1984). </year>
Reference-contexts: 1. INTRODUCTION Program slicing, a program transformation originally defined by Mark Weiser <ref> [13] </ref>, is useful in program debugging [9], program maintenance [6], and other applications that involve understanding program behavior [7]. <p> For any value of N, the example program and the program projection compute the same value for variable prod in the output statement. ` This paper addresses a problem that has not been discussed in the literature on program slicing <ref> [8, 10, 12, 13] </ref>. The problem is how to slice programs with unstructured control flow, i.e., programs that include constructs such as break and goto. Previous algorithms do not slice such programs correctly. <p> c c c c c c c c slice to be taken with respect to an arbitrary set of variables V at point p is straightforward: Add artificial uses of all variables in V at point p.) Algorithms for slicing programs with structured control flow have been defined by Weiser <ref> [13] </ref> and by the Otten-steins [10]. Let us consider the problems that arise if one tries to apply either of those algorithms to programs with unstructured control flow. <p> The program that results from such an approach may not be a projection of the original program, even though it meets the semantic goal (because its CFG is a flow/path-projection of the original program's CFG). 6. RELATED WORK As mentioned previously, Weiser defined the first program slicing algorithm <ref> [13] </ref>. The Ottensteins defined a more efficient program slicing algorithm using the program dependence graph [10]. Neither algorithm handles unstructured control flow correctly. Reps and Yang gave the first formal proof that the program slices formed by using the program dependence graph have the desired semantic property [12].
References-found: 13

