URL: file://ftp.cs.wisc.edu/coral/doc/ordsearch.ps
Refering-URL: http://www.cs.wisc.edu/coral/coral.papers.html
Root-URL: 
Email: fraghu,divesh,sudarshang@cs.wisc.edu  
Title: Controlling the Search in Bottom- Up Evaluation  
Author: Raghu Ramakrishnan Divesh Srivastava S. Sudarshan 
Address: Madison, WI 53706, U.S.A.  
Affiliation: Computer Sciences Department University of Wisconsin-Madison  
Abstract: Bottom-up evaluation of queries on deductive databases has many advantages over an evaluation scheme such as Prolog. It is sound and complete with respect to the declarative semantics of least Herbrand models for positive Horn clause programs. In particular, it is able to avoid infinite loops by detecting repeated (possibly cyclic) subgoals. Further, in many database applications, it is more efficient than Prolog due to its set-orientedness. However, the completely set-oriented, breadth-first search strategy of bottom-up evaluation has certain disadvantages. For example, to evaluate several classes of programs with negation (or aggregation), it is necessary to order the inferences; in essence, we must evaluate all answers to a negative subgoal before making an inference that depends upon the negative subgoal. A completely breadth-first search strategy ([14]) would have to maintain a lot of redundant subgoal dependency information to achieve this. We present a technique to order the use of generated subgoals, that is a hybrid between pure breadth-first and pure depth-first search. The technique, called Ordered Search, is able to maintain subgoal dependency information efficiently, while being able to detect repeated subgoals, and avoid infinite loops. Also, the technique avoids repeated computation and is complete for DATALOG. We demonstrate the power of Ordered Search through two applications. First, we show that it can be used to evaluate programs with left-to-right modularly stratified negation and aggregation more efficiently than with any previously known bottom-up technique. Second, we illustrate its use for optimizing single-answer queries for linear programs. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> I. Balbin and K. Ramamohanarao. </author> <title> A generalization of the differential approach to recursive query evaluation. </title> <journal> Journal of Logic Programming, </journal> <volume> 4(3), </volume> <month> September </month> <year> 1987. </year>
Reference-contexts: fg Context m path (1; 4) fl ; m path (3; 4); m path (2; 4) 2 path fpath (2; 4; [2; 4])g Context fm path (1; 4) fl ; m path (2; 4) fl g; m path (3; 4) 3 path fpath (2; 4; [2; 4]); path (1; 4; <ref> [1; 2; 4] </ref>)g Context fm path (1; 4) fl ; m path (2; 4) fl gm path (3; 4) Table 1: Ordered Search evaluation of hP mg path ; Q mg path i Example 3.2 (Modular negation) Consider the left-to-right modularly stratified program P even from Example 1.1, and the query
Reference: [2] <author> N. Bidoit and P. Legay. </author> <title> WELL! An evaluation procedure for all logic programs. </title> <booktitle> In Proceedings of the International Conference on Database Theory, </booktitle> <pages> pages 335-348, </pages> <address> Paris, France, </address> <month> December </month> <year> 1990. </year>
Reference-contexts: a result, in iteration 2, several nodes in Context have been collapsed together. 2 Iter Facts in Ordered Search 0 path fg Context m path (1; 4) 1 path fg Context m path (1; 4) fl ; m path (3; 4); m path (2; 4) 2 path fpath (2; 4; <ref> [2; 4] </ref>)g Context fm path (1; 4) fl ; m path (2; 4) fl g; m path (3; 4) 3 path fpath (2; 4; [2; 4]); path (1; 4; [1; 2; 4])g Context fm path (1; 4) fl ; m path (2; 4) fl gm path (3; 4) Table 1: Ordered <p> path (1; 4) 1 path fg Context m path (1; 4) fl ; m path (3; 4); m path (2; 4) 2 path fpath (2; 4; <ref> [2; 4] </ref>)g Context fm path (1; 4) fl ; m path (2; 4) fl g; m path (3; 4) 3 path fpath (2; 4; [2; 4]); path (1; 4; [1; 2; 4])g Context fm path (1; 4) fl ; m path (2; 4) fl gm path (3; 4) Table 1: Ordered Search evaluation of hP mg path ; Q mg path i Example 3.2 (Modular negation) Consider the left-to-right modularly stratified program P even from <p> fg Context m path (1; 4) fl ; m path (3; 4); m path (2; 4) 2 path fpath (2; 4; [2; 4])g Context fm path (1; 4) fl ; m path (2; 4) fl g; m path (3; 4) 3 path fpath (2; 4; [2; 4]); path (1; 4; <ref> [1; 2; 4] </ref>)g Context fm path (1; 4) fl ; m path (2; 4) fl gm path (3; 4) Table 1: Ordered Search evaluation of hP mg path ; Q mg path i Example 3.2 (Modular negation) Consider the left-to-right modularly stratified program P even from Example 1.1, and the query <p> There is no analogue to this step in the technique of [8]. Techniques for computing the well-founded model: There are several query evaluation techniques in the literature that compute answers under the well-founded model. For example, WELL! <ref> [2] </ref> is based on global SLS-resolution; XOLDTNF [4] is an extension of OLDT resolution; GUUS [9] is based on the alternating fixpoint semantics; and the technique of Kemp et al. [7] is based on alternating fixpoint semantics and magic sets.
Reference: [3] <author> F. Bry. </author> <title> Query evaluation in recursive databases: Bottom-up and top-down reconciled. </title> <journal> IEEE Transactions on Knowledge and Data Engineering, </journal> <volume> 5 </volume> <pages> 289-312, </pages> <year> 1990. </year>
Reference: [4] <author> W. Chen and D. S. Warren. </author> <title> A practical approach to computing the well founded semantics. </title> <booktitle> In Proceedings of the Joint International Conference and Symposium on Logic Programming, </booktitle> <year> 1992. </year>
Reference-contexts: a result, in iteration 2, several nodes in Context have been collapsed together. 2 Iter Facts in Ordered Search 0 path fg Context m path (1; 4) 1 path fg Context m path (1; 4) fl ; m path (3; 4); m path (2; 4) 2 path fpath (2; 4; <ref> [2; 4] </ref>)g Context fm path (1; 4) fl ; m path (2; 4) fl g; m path (3; 4) 3 path fpath (2; 4; [2; 4]); path (1; 4; [1; 2; 4])g Context fm path (1; 4) fl ; m path (2; 4) fl gm path (3; 4) Table 1: Ordered <p> path (1; 4) 1 path fg Context m path (1; 4) fl ; m path (3; 4); m path (2; 4) 2 path fpath (2; 4; <ref> [2; 4] </ref>)g Context fm path (1; 4) fl ; m path (2; 4) fl g; m path (3; 4) 3 path fpath (2; 4; [2; 4]); path (1; 4; [1; 2; 4])g Context fm path (1; 4) fl ; m path (2; 4) fl gm path (3; 4) Table 1: Ordered Search evaluation of hP mg path ; Q mg path i Example 3.2 (Modular negation) Consider the left-to-right modularly stratified program P even from <p> fg Context m path (1; 4) fl ; m path (3; 4); m path (2; 4) 2 path fpath (2; 4; [2; 4])g Context fm path (1; 4) fl ; m path (2; 4) fl g; m path (3; 4) 3 path fpath (2; 4; [2; 4]); path (1; 4; <ref> [1; 2; 4] </ref>)g Context fm path (1; 4) fl ; m path (2; 4) fl gm path (3; 4) Table 1: Ordered Search evaluation of hP mg path ; Q mg path i Example 3.2 (Modular negation) Consider the left-to-right modularly stratified program P even from Example 1.1, and the query <p> There is no analogue to this step in the technique of [8]. Techniques for computing the well-founded model: There are several query evaluation techniques in the literature that compute answers under the well-founded model. For example, WELL! [2] is based on global SLS-resolution; XOLDTNF <ref> [4] </ref> is an extension of OLDT resolution; GUUS [9] is based on the alternating fixpoint semantics; and the technique of Kemp et al. [7] is based on alternating fixpoint semantics and magic sets.
Reference: [5] <author> S. W. Dietrich. </author> <title> Extension tables: Memo relations in logic programming. </title> <booktitle> In Proceedings of the Symposium on Logic Programming, </booktitle> <pages> pages 264-272, </pages> <year> 1987. </year>
Reference-contexts: QSQR/QoSaQ and Extension Tables: Extension Tables <ref> [5] </ref> is similar to Prolog, except that it memos facts and subgoals and can detect loops. 1 Of course, a meta-interpreter can be written using Prolog to evaluate such programs. QSQR/QoSaQ [19, 20] is a top-down, memoing, set-oriented strategy that is closely related to bottom-up evaluation with Supplementary Magic rewriting.
Reference: [6] <author> S. Ganguly, S. Greco, and C. Zaniolo. </author> <title> Minimum and maximum predicates in logic programming. </title> <booktitle> In Proceedings of the ACM Symposium on Principles of Database Systems, </booktitle> <year> 1991. </year>
Reference-contexts: There are other proposed techniques that control the order of inferences in a bottom-up evaluation in some way. Sloppy Delta Iteration [15] provides a way to "hide" facts until they are to be used. Techniques for hiding facts are used in <ref> [6, 16] </ref> to evaluate programs with aggregate operations efficiently.
Reference: [7] <author> D. Kemp, D. Srivastava, and P. Stuckey. </author> <title> Magic sets and bottom-up evaluation of well-founded models. </title> <booktitle> In Proceedings of the International Logic Programming Symposium, </booktitle> <pages> pages 337-351, </pages> <address> San Diego, CA, U.S.A., </address> <month> Oct. </month> <year> 1991. </year>
Reference-contexts: As an example, the doubled program technique of Kemp et al. <ref> [7] </ref> would also use O (m) space and make O (m) derivations on this example. However, if rule r1 were removed from P even , the doubled program approach would make O (m 2 ) derivations, though it would still use only O (m) space. <p> For example, WELL! [2] is based on global SLS-resolution; XOLDTNF [4] is an extension of OLDT resolution; GUUS [9] is based on the alternating fixpoint semantics; and the technique of Kemp et al. <ref> [7] </ref> is based on alternating fixpoint semantics and magic sets. The class of programs handled by these techniques is larger than that handled by Ordered Search, but each of these techniques can repeat computation even for left-to-right modularly stratified programs. This can result in a loss of efficiency of evaluation.
Reference: [8] <author> A. Lefebvre. </author> <title> Towards an efficient evaluation of recursive aggregates in deductive databases. </title> <booktitle> In Proceedings of the International Conference on Fifth Generation Computer Systems, </booktitle> <month> June </month> <year> 1992. </year>
Reference-contexts: In this case as well, dependencies between subgoals are maintained transitively, and our previous comparisons also apply to this case. Subquery Completion: A variant of QSQR, subquery completion, was described in <ref> [8] </ref> to deal with recursively defined aggregates. It uses the dependencies between subgoals maintained by QSQR to handle a class of acyclic programs with aggregation. <p> Ordered Search allows positive cycles in the subgoal dependency graph, and deals with them by collapsing nodes in the Context, and declaring all the facts in a collapsed node to be completely evaluated once a fixpoint is reached. There is no analogue to this step in the technique of <ref> [8] </ref>. Techniques for computing the well-founded model: There are several query evaluation techniques in the literature that compute answers under the well-founded model.
Reference: [9] <author> N. Leone and P. Rullo. </author> <title> Safe computation of the well-founded semantics of Datalog queries. </title> <journal> Information Systems, </journal> <volume> 17(1) </volume> <pages> 17-31, </pages> <year> 1992. </year>
Reference-contexts: Techniques for computing the well-founded model: There are several query evaluation techniques in the literature that compute answers under the well-founded model. For example, WELL! [2] is based on global SLS-resolution; XOLDTNF [4] is an extension of OLDT resolution; GUUS <ref> [9] </ref> is based on the alternating fixpoint semantics; and the technique of Kemp et al. [7] is based on alternating fixpoint semantics and magic sets.
Reference: [10] <author> J. W. Lloyd. </author> <title> Foundations of Logic Programming. </title> <publisher> Springer-Verlag, </publisher> <year> 1984. </year>
Reference-contexts: Related work is described in Section 5, and directions for future research are indicated in Section 6. 2 Preliminaries We assume familiarity with logic programming terminology (see <ref> [10] </ref>) and the issues involved in the bottom-up evaluation of logic programs. In particular, we assume the reader is familiar with Magic Templates rewriting ([11]), and with semi-naive bottom-up evaluation ([1]). For the purposes of this paper, a program is a set of normal rules.
Reference: [11] <author> R. Ramakrishnan. </author> <title> Magic Templates: A spellbinding approach to logic programs. </title> <booktitle> In Proceedings of the International Conference on Logic Programming, </booktitle> <pages> pages 140-159, </pages> <address> Seattle, Washington, </address> <month> August </month> <year> 1988. </year>
Reference: [12] <author> R. Ramakrishnan, D. Srivastava, and S. Sudarshan. </author> <title> CORAL: Control, Relations and Logic. </title> <booktitle> In Proceedings of the International Conference on Very Large Databases, </booktitle> <year> 1992. </year>
Reference-contexts: We believe that Ordered Search is a versatile and very useful tool in the evaluation of queries on deductive databases. Ordered Search has been implemented in the CORAL system <ref> [12] </ref>, and performance numbers will be presented in the full version of the paper. An important direction of future research is to explore the possibility of increasing the set-orientedness of Ordered Search, thereby increasing efficiency of evaluation, while retaining its desirable properties for evaluating left-to-right modularly stratified programs.
Reference: [13] <author> R. Ramakrishnan and S. Sudarshan. </author> <title> Top-Down vs. Bottom-Up Revisited. </title> <booktitle> In Proceedings of the International Logic Programming Symposium, </booktitle> <year> 1991. </year>
Reference-contexts: Unification of ground facts can be done in constant time using hash-consing for ground terms; indexing and insertion of ground facts in relations can also be done in constant time using hash based indexing (see <ref> [13] </ref>). Hence, the cost of each derivation depends on the operations on Context, and several of these operations are operations on sets: finding the node corresponding to a fact, taking the union of facts associated with nodes on Context, and deleting entire sets of facts associated with a ContextN ode.
Reference: [14] <author> K. Ross. </author> <title> Modular Stratification and Magic Sets for Datalog programs with negation. </title> <booktitle> (A shorter version appeared in the Proceedings of the ACM Symposium on the Principles of Database Systems, </booktitle> <year> 1990), 1991. </year>
Reference-contexts: This technique generates subgoals and answers to subgoals asynchronously, as in bottom-up evaluation, while ordering the use of generated subgoals in a manner reminiscent of top-down evaluation. As a consequence, Ordered Search is able to efficiently evaluate left-to-right modularly stratified programs <ref> [14] </ref> (see Sections 4.1 and 4.2), and restrict the search space in many cases when we want a single answer to the query (see Section 4.3). 1.1 Motivating Examples Example 1.1 (Modular negation) The class of programs with modular negation [14] naturally extends the class of programs with stratified and locally <p> Search is able to efficiently evaluate left-to-right modularly stratified programs <ref> [14] </ref> (see Sections 4.1 and 4.2), and restrict the search space in many cases when we want a single answer to the query (see Section 4.3). 1.1 Motivating Examples Example 1.1 (Modular negation) The class of programs with modular negation [14] naturally extends the class of programs with stratified and locally stratified negation while retaining a two-valued model. <p> r1 : even (X) : succ (X; Y 1); succ (Y 1; Y ); even (Y ): r2 : even (X) : succ (X; Y ); :even (Y ): r3 : even (0): succ (1; 0): succ (2; 1): : : : succ (n; n 1): Query: ?-:even (m): Ross <ref> [14] </ref> proposed a supplementary magic sets rewriting of hP even ; Q even i in conjunction with a bottom-up method for evaluating the rewritten program. This method explicitly stores all the subgoal dependency information for negative subgoals. <p> Given a subgoal on the head of a rule, there are directed arcs in the subgoal-dependency graph to each subgoal set up during the evaluation of the body of that rule. We formalize this using SLP-trees and negation trees (see <ref> [14] </ref>) in the full version of the paper. We assume the reader is familiar with the definition of (left-to-right) modularly stratified programs and the meaning of such programs (see [14]). <p> We formalize this using SLP-trees and negation trees (see <ref> [14] </ref>) in the full version of the paper. We assume the reader is familiar with the definition of (left-to-right) modularly stratified programs and the meaning of such programs (see [14]). Intuitively, a program is modularly stratified iff its mutually recursive components are locally stratified once all instantiated rules with a false subgoal that is defined in a "lower" component are removed. In the subgoal-dependency graph for left-to-right modularly stratified programs there is no cyclic dependency involving a negated subgoal. <p> In the subgoal-dependency graph for left-to-right modularly stratified programs there is no cyclic dependency involving a negated subgoal. Ross' <ref> [14] </ref> technique as well as our technique makes essential use of this property in evaluating programs with left-to-right modularly stratified negation. 2.1 Modified Magic Templates Rewriting Intuitively, the Magic Templates rewriting of a program defines a new predicate m p (the magic predicate) for each predicate p in the original program <p> The evaluation of the supplementary magic program using Ordered Search computes and stores only information about direct dependencies as a linear ordering of the magic and supplementary facts on Context; hence, the evaluation uses linear space and makes a linear number of derivations. The technique described in <ref> [14] </ref> computes and stores the transitive depen dencies in addition to the direct dependencies on this example; consequently, it would use quadratic space and make a quadratic number of derivations (of facts and dependencies). <p> For instance, in Example 1.1, Ross' algorithm uses O (m 2 ) space, whereas Ordered Search uses O (m) space. Our technique for evaluating left-to-right modularly stratified programs is strictly better than the algorithm in <ref> [14] </ref>, in terms of the asymptotic space complexity. We now compare the asymptotic time complexity of Ordered Search with other bottom-up evaluation strategies.
Reference: [15] <author> H. Schmidt, W. Kiessling, U. Guntzer, and R. Bayer. </author> <title> Compiling exploratory and goal-directed deduction into sloppy delta iteration. </title> <booktitle> In IEEE International Symposium on Logic Programming, </booktitle> <pages> pages 234-243, </pages> <year> 1987. </year>
Reference-contexts: This can result in a loss of efficiency of evaluation. There are other proposed techniques that control the order of inferences in a bottom-up evaluation in some way. Sloppy Delta Iteration <ref> [15] </ref> provides a way to "hide" facts until they are to be used. Techniques for hiding facts are used in [6, 16] to evaluate programs with aggregate operations efficiently.
Reference: [16] <author> S. Sudarshan and R. Ramakrishnan. </author> <title> Aggregation and relevance in deductive databases. </title> <booktitle> In Proceedings of the Seventeenth International Conference on Very Large Databases, </booktitle> <month> Sept. </month> <year> 1991. </year>
Reference-contexts: There are other proposed techniques that control the order of inferences in a bottom-up evaluation in some way. Sloppy Delta Iteration [15] provides a way to "hide" facts until they are to be used. Techniques for hiding facts are used in <ref> [6, 16] </ref> to evaluate programs with aggregate operations efficiently.
Reference: [17] <author> R. E. Tarjan. </author> <title> Data Structures and Network Algorithms. </title> <institution> Society for Industrial and Applied Mathematics, </institution> <year> 1983. </year>
Reference-contexts: These operations can be efficiently implemented using the union-find technique <ref> [17] </ref>, with an amortized cost of O (ff (N )) per operation, where N is the total number of these operations on Context, and ff (N ) is the inverse Ackermann function. Consequently, we have: Theorem 4.4 Let hP; Qi be a program-query pair. 1.
Reference: [18] <author> J. D. Ullman. </author> <title> Bottom-up beats top-down for Datalog. </title> <booktitle> In Proceedings of the Eighth ACM Symposium on Principles of Database Systems, </booktitle> <pages> pages 140-149, </pages> <address> Philadelphia, Pennsylvania, </address> <month> March </month> <year> 1989. </year>
Reference: [19] <author> L. Vieille. </author> <title> Recursive axioms in deductive databases: The query-subquery approach. </title> <booktitle> In Proceedings of the First International Conference on Expert Database Systems, </booktitle> <pages> pages 179-193, </pages> <address> Charleston, South Carolina, </address> <year> 1986. </year>
Reference-contexts: QSQR/QoSaQ and Extension Tables: Extension Tables [5] is similar to Prolog, except that it memos facts and subgoals and can detect loops. 1 Of course, a meta-interpreter can be written using Prolog to evaluate such programs. QSQR/QoSaQ <ref> [19, 20] </ref> is a top-down, memoing, set-oriented strategy that is closely related to bottom-up evaluation with Supplementary Magic rewriting. Like Prolog, these techniques cannot deal with left-to-right modularly stratified negation/aggregation.
Reference: [20] <author> L. Vieille. </author> <title> From QSQ towards QoSaQ: Global optimizations of recursive queries. </title> <booktitle> In Proc. 2nd International Conference on Expert Database Systems, </booktitle> <month> Apr. </month> <year> 1988. </year>
Reference-contexts: QSQR/QoSaQ and Extension Tables: Extension Tables [5] is similar to Prolog, except that it memos facts and subgoals and can detect loops. 1 Of course, a meta-interpreter can be written using Prolog to evaluate such programs. QSQR/QoSaQ <ref> [19, 20] </ref> is a top-down, memoing, set-oriented strategy that is closely related to bottom-up evaluation with Supplementary Magic rewriting. Like Prolog, these techniques cannot deal with left-to-right modularly stratified negation/aggregation.
References-found: 20

