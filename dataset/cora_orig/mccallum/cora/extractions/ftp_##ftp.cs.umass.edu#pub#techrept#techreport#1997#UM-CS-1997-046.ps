URL: ftp://ftp.cs.umass.edu/pub/techrept/techreport/1997/UM-CS-1997-046.ps
Refering-URL: http://laser.cs.umass.edu/abstracts/97-046.html
Root-URL: 
Email: tarr@watson.ibm.com clarke@cs.umass.edu  
Title: Consistency Management for Complex Applications  
Author: Peri Tarr Lori A. Clarke 
Keyword: Consistency management, inconsistency management, object management, software engineering environments  
Address: 30 Saw Mill River Road  NY 10532 Amherst, MA 01003  
Affiliation: IBM T.J. Watson Research Center Department of Computer Science  University of Massachusetts Hawthorne,  
Abstract: Consistency management is an important requirement in many complex applications, but current programming languages and database systems provide inadequate support for it. To address this limitation, we have defined a consistency management model and incorporated it into the Pleiades object management system. This paper presents a motivating example that illustrates some typical consistency management requirements and discusses the requirements in terms of both functionality and cross-cutting concerns that affect how this functionality is provided. It then describes the model and some design and implementation issues that arose in instantiating it. Finally, we discuss feedback we have received from users and future research plans. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> T. Andrews and C. Harris. </author> <booktitle> Combining Language and Database Advances in an Object-Oriented Development Environment, </booktitle> <pages> pages 186-196. </pages> <booktitle> Readings in Object-Oriented Database Systems. </booktitle> <year> 1990. </year>
Reference-contexts: Many database programming languages and object-oriented databases support only a limited, predefined set of consistency definitions, such as referential integrity (e.g., [23]) or programming language kinds of consistency definitions (e.g., <ref> [37, 1] </ref>), or they support consistency definitions over only a subset of types (typically collection types; e.g., [33, 9]). Active database systems (e.g., [8, 20, 6]) include reactive control primitives, typically in the form of event-condition-action (ECA) rules, that can facilitate consistency management.
Reference: [2] <author> M. P. Atkinson and O. P. Buneman. </author> <title> Types and persistence in database programming languages. </title> <journal> ACM Computing Surveys, </journal> <volume> 19(2) </volume> <pages> 105-190, </pages> <month> Jun </month> <year> 1987. </year>
Reference-contexts: A well-known example of the container problem is the dangling reference problem. For example, an application might destroy a node 3 A programming language enhanced with capabilities like consistency management, persistence and concurrency control is typically referred to as a database programming language <ref> [2] </ref>. in an AST without realizing that other nodes refer to it. The destroyed node affects the consistency of those that refer to it, according to a referential integrity constraint, but it can be destroyed without the knowledge of the referring nodes.
Reference: [3] <author> R. Balzer. </author> <title> Tolerating inconsistency. </title> <booktitle> In Proc. 13th Int'l. Conf. on Software Engineering, </booktitle> <pages> pages 158-165, </pages> <year> 1991. </year>
Reference-contexts: Thus, when consistency violations cannot be repaired immediately, it may be necessary to tolerate the inconsistency for some period of time <ref> [3, 31, 33] </ref> and to ensure the meaningful manipulation of inconsistent objects appropriately. This simple example illustrates some of the kinds of functionality needed to facilitate the definition and management of object consistency.
Reference: [4] <author> S. Bandinelli and A. Fuggetta. </author> <title> Computational reflection in software process modeling: the SLANG approach. </title> <booktitle> In Proc. 15th Int'l. Conf. on Software Engineering, </booktitle> <year> 1993. </year>
Reference-contexts: Much research has been done in consistency management for software process languages [27]. Some of these languages rely on consistency management support from an associated object management system (e.g., SLANG <ref> [4, 5] </ref>). Many software process languages incorporate conditions on product state as process control conditions, rather than as product consistency conditions, which assumes that process correctness ensures product consistency.
Reference: [5] <author> S. Bandinelli, A. Fuggetta, and S. Grigolli. </author> <title> Process modeling in-the-large with SLANG. </title> <booktitle> In Proc. 2nd Int'l. Conf. on the Software Process, </booktitle> <pages> pages 75-83, </pages> <year> 1993. </year>
Reference-contexts: Much research has been done in consistency management for software process languages [27]. Some of these languages rely on consistency management support from an associated object management system (e.g., SLANG <ref> [4, 5] </ref>). Many software process languages incorporate conditions on product state as process control conditions, rather than as product consistency conditions, which assumes that process correctness ensures product consistency.
Reference: [6] <author> N. Barghouti and G. Kaiser. </author> <title> Modeling concurrency in rule-based development. </title> <journal> IEEE Expert, </journal> <volume> 5(6), </volume> <year> 1990. </year>
Reference-contexts: Active database systems (e.g., <ref> [8, 20, 6] </ref>) include reactive control primitives, typically in the form of event-condition-action (ECA) rules, that can facilitate consistency management. ECA rules are general-purpose mechanisms for detecting the occurrence of some event and responding to it by some action.
Reference: [7] <author> N. Barghouti and G. Kaiser. </author> <title> Concurrency control in advance database applications. </title> <journal> ACM Computing Surveys, </journal> <pages> pages 269-317, </pages> <month> Sep </month> <year> 1991. </year>
Reference-contexts: Information about the set of consistency conditions that are currently enforced on an object and about an object's consistency status are examples of the kinds of meta-data that may be required. Generality/heterogeneity: Previous research (e.g., <ref> [7, 31, 17] </ref>) demonstrated that different kinds of applications require different programming paradigms and models. Generality means that a consistency management system must provide a set of primitive capabilities that facilitate the implementation of alternative consistency management paradigms.
Reference: [8] <author> A. Buchmann, R. Carrera, and M. Vazquez-Galindo. </author> <title> A generalized constraint and exception handler for an object-oriented CAD-DBMS. </title> <booktitle> In Proc. Int'l. Workshop on Object-Oriented Database Systems, </booktitle> <pages> pages 38-49, </pages> <month> Sep </month> <year> 1986. </year>
Reference-contexts: Active database systems (e.g., <ref> [8, 20, 6] </ref>) include reactive control primitives, typically in the form of event-condition-action (ECA) rules, that can facilitate consistency management. ECA rules are general-purpose mechanisms for detecting the occurrence of some event and responding to it by some action.
Reference: [9] <author> D. Cohen. </author> <title> AP5 Manual. </title> <institution> University of Southern Cali-fornia, Information Sciences Institute, </institution> <year> 1988. </year>
Reference-contexts: Many database programming languages and object-oriented databases support only a limited, predefined set of consistency definitions, such as referential integrity (e.g., [23]) or programming language kinds of consistency definitions (e.g., [37, 1]), or they support consistency definitions over only a subset of types (typically collection types; e.g., <ref> [33, 9] </ref>). Active database systems (e.g., [8, 20, 6]) include reactive control primitives, typically in the form of event-condition-action (ECA) rules, that can facilitate consistency management. ECA rules are general-purpose mechanisms for detecting the occurrence of some event and responding to it by some action. <p> In fact, the underlying capabilities required to implement consistency management and ECA rules are very similar, and some researchers have used ECA rules to imple ment consistency management capabilities. As noted by <ref> [33, 18, 9, 16] </ref>, however, the semantics of consistency management and reactive control are fairly different. Consistency management activities are a required part of any computation in which constraints are enforced| failure to satisfy constraints may invalidate an activity. <p> On the other hand, failure to satisfy well-formedness constraints on the design artifacts impacts the design process and artifacts. For this reason, many process languages with reactive control draw a distinction between consistency management and automation rules (e.g., <ref> [9, 18, 16, 33] </ref>). In these languages, all consistency maintenance activities associated with a process step must be carried out before the step can complete; failure to satisfy constraints typically results in aborting the associated step. <p> For example, EPOS [11] uses guards and postconditions to affect flow of process control; Grapple [15] and Interact [28] model conditions as goals; Melmac [14] and SLANG use conditional branching; and Marvel [18], AP5 <ref> [9] </ref>, and Merlin [16] use conditions as a basis for inferencing. All of these process languages provide a more restrictive consistency model than the one we have proposed.
Reference: [10] <author> R. Conradi, C. Fernstrom, and A. Fuggetta. </author> <title> Con--cepts for evolving software processes. </title> <editor> In A. Finkelstein, J. Kramer, and B. Nuseibeh, editors, </editor> <booktitle> Software Process Modeling and Technology, </booktitle> <pages> pages 9-31. </pages> <year> 1994. </year>
Reference-contexts: Completeness: Computational completeness supports the definition of arbitrarily complex algorithms, both for determining whether or not objects satisfy consistency conditions and for specifying enforcement semantics. Type completeness provides the ability to associate consistency conditions and enforcement mechanisms with any type of object. Meta-data: To make decisions dynamically (e.g., reflection <ref> [10] </ref>), applications require information about their run-time state or environment, which is commonly referred to as meta-data. Information about the set of consistency conditions that are currently enforced on an object and about an object's consistency status are examples of the kinds of meta-data that may be required.
Reference: [11] <author> R. Conradi, et. al. EPOS: </author> <title> Object-oriented cooperative process modeling. </title> <editor> In A. Finkelstein, J. Kramer, and B. Nuseibeh, editors, </editor> <booktitle> Software Process Modeling and Technology, </booktitle> <pages> pages 33-70. </pages> <year> 1994. </year>
Reference-contexts: Some of these languages rely on consistency management support from an associated object management system (e.g., SLANG [4, 5]). Many software process languages incorporate conditions on product state as process control conditions, rather than as product consistency conditions, which assumes that process correctness ensures product consistency. For example, EPOS <ref> [11] </ref> uses guards and postconditions to affect flow of process control; Grapple [15] and Interact [28] model conditions as goals; Melmac [14] and SLANG use conditional branching; and Marvel [18], AP5 [9], and Merlin [16] use conditions as a basis for inferencing.
Reference: [12] <author> M. Dwyer and L. Clarke. </author> <title> Data flow analysis for verifying properties of concurrent programs. </title> <booktitle> In Proc. 2nd Symp. on Foundations of Software Engineering, </booktitle> <pages> pages 62-75, </pages> <month> Dec </month> <year> 1994. </year>
Reference-contexts: The client applications about which we obtained information were a reusable components library, the Arcadia language processing tool set, TAOS (Testing with Analysis and Oracle Support) [29], the Booch Object-Oriented Design process program (BOOD) [34], FLAVERS (Flow Analysis and VERification System) <ref> [12] </ref>, an agenda management system, and an avionics validation and verification system [21]. The process we used to perform the evaluation was as follows. We constructed a questionnaire that included approximately fifty questions.
Reference: [13] <author> S. Easterbrook, A. Finkelstein, J. Kramer, and B. Nu-seibeh. </author> <title> Coordinating distributed viewpoints: The anatomy of a consistency check. </title> <journal> Int'l. Journal on Concurrent Engineering: Research and Applications, </journal> <volume> 2(3) </volume> <pages> 209-222, </pages> <year> 1994. </year>
Reference-contexts: Optimistic concurrency control assumes that conflicts are rare, so it permits them and resolves them by aborting conflicting transactions. ViewPoints permits conflicts between viewpoints and provides mechanisms for their collaborative resolution. Optimistic approaches tacitly assume that loss of work due to conflicts is acceptable. Also, as noted in <ref> [13] </ref>, ViewPoints is limited in its ability to handle "global" consistency conditions, since there is no concept of global or shared state. Pessimistic concurrency control assumes that state may be shared but provides mechanisms that can be used to avoid conflicts. <p> We hope to explore the integration of optimistic mechanisms, such as that described in <ref> [26, 13] </ref>, into our model. Finally, we hope to generalize from the experiences we, and other developers, have had in using Pleiades and feed those experiences back into the consistency management model.
Reference: [14] <author> V. Gruhn and R. Jegelka. </author> <title> An evaluation of FUNSOFT nets. </title> <booktitle> In Proc. 2nd European Workshop on Software Process Technology, </booktitle> <month> Sep </month> <year> 1992. </year>
Reference-contexts: For example, EPOS [11] uses guards and postconditions to affect flow of process control; Grapple [15] and Interact [28] model conditions as goals; Melmac <ref> [14] </ref> and SLANG use conditional branching; and Marvel [18], AP5 [9], and Merlin [16] use conditions as a basis for inferencing. All of these process languages provide a more restrictive consistency model than the one we have proposed.
Reference: [15] <author> K. E. Huff and V. Lesser. </author> <title> A plan-based intelligent assistant that supports the software development process. </title> <booktitle> In ACM Symp. on Practical Software Development Environments, </booktitle> <pages> pages 97-106, </pages> <year> 1988. </year>
Reference-contexts: Many software process languages incorporate conditions on product state as process control conditions, rather than as product consistency conditions, which assumes that process correctness ensures product consistency. For example, EPOS [11] uses guards and postconditions to affect flow of process control; Grapple <ref> [15] </ref> and Interact [28] model conditions as goals; Melmac [14] and SLANG use conditional branching; and Marvel [18], AP5 [9], and Merlin [16] use conditions as a basis for inferencing. All of these process languages provide a more restrictive consistency model than the one we have proposed.
Reference: [16] <author> G. Junkermann, B. Peuschel, W. Schafer, and S. Wolf. MERLIN: </author> <title> Supporting coooperation in software development through a knowledge-based environment. </title> <editor> In A. Finkelstein, J. Kramer, and B. Nuseibeh, editors, </editor> <booktitle> Software Process Modeling and Technology, </booktitle> <pages> pages 103-129. </pages> <year> 1994. </year>
Reference-contexts: In fact, the underlying capabilities required to implement consistency management and ECA rules are very similar, and some researchers have used ECA rules to imple ment consistency management capabilities. As noted by <ref> [33, 18, 9, 16] </ref>, however, the semantics of consistency management and reactive control are fairly different. Consistency management activities are a required part of any computation in which constraints are enforced| failure to satisfy constraints may invalidate an activity. <p> On the other hand, failure to satisfy well-formedness constraints on the design artifacts impacts the design process and artifacts. For this reason, many process languages with reactive control draw a distinction between consistency management and automation rules (e.g., <ref> [9, 18, 16, 33] </ref>). In these languages, all consistency maintenance activities associated with a process step must be carried out before the step can complete; failure to satisfy constraints typically results in aborting the associated step. <p> For example, EPOS [11] uses guards and postconditions to affect flow of process control; Grapple [15] and Interact [28] model conditions as goals; Melmac [14] and SLANG use conditional branching; and Marvel [18], AP5 [9], and Merlin <ref> [16] </ref> use conditions as a basis for inferencing. All of these process languages provide a more restrictive consistency model than the one we have proposed.
Reference: [17] <author> R. Kadia. </author> <title> Issues encountered in building a flexible software development environment. </title> <booktitle> In Proc. 5th ACM SIG-SOFT Symp. on Software Development Environments, </booktitle> <pages> pages 169-180, </pages> <month> Dec </month> <year> 1992. </year>
Reference-contexts: Section 6 examines related research. Finally, Section 7 discusses ongoing and future work. 2 Motivating Example and Requirements To illustrate some typical consistency management needs in complex applications, we use an example from the Arcadia SEE project <ref> [17] </ref>. This example includes three types of objects: source code, abstract syntax trees (ASTs), and control flow graphs (CFGs), along with some consistency definitions. <p> Information about the set of consistency conditions that are currently enforced on an object and about an object's consistency status are examples of the kinds of meta-data that may be required. Generality/heterogeneity: Previous research (e.g., <ref> [7, 31, 17] </ref>) demonstrated that different kinds of applications require different programming paradigms and models. Generality means that a consistency management system must provide a set of primitive capabilities that facilitate the implementation of alternative consistency management paradigms.
Reference: [18] <author> G. E. Kaiser, P. H. Feiler, and S. S. Popovich. </author> <title> Intelligent assistance for software development and maintenance. </title> <journal> IEEE Software, </journal> <volume> 5(3) </volume> <pages> 40-49, </pages> <month> May </month> <year> 1988. </year>
Reference-contexts: In fact, the underlying capabilities required to implement consistency management and ECA rules are very similar, and some researchers have used ECA rules to imple ment consistency management capabilities. As noted by <ref> [33, 18, 9, 16] </ref>, however, the semantics of consistency management and reactive control are fairly different. Consistency management activities are a required part of any computation in which constraints are enforced| failure to satisfy constraints may invalidate an activity. <p> On the other hand, failure to satisfy well-formedness constraints on the design artifacts impacts the design process and artifacts. For this reason, many process languages with reactive control draw a distinction between consistency management and automation rules (e.g., <ref> [9, 18, 16, 33] </ref>). In these languages, all consistency maintenance activities associated with a process step must be carried out before the step can complete; failure to satisfy constraints typically results in aborting the associated step. <p> For example, EPOS [11] uses guards and postconditions to affect flow of process control; Grapple [15] and Interact [28] model conditions as goals; Melmac [14] and SLANG use conditional branching; and Marvel <ref> [18] </ref>, AP5 [9], and Merlin [16] use conditions as a basis for inferencing. All of these process languages provide a more restrictive consistency model than the one we have proposed.
Reference: [19] <editor> B. Liskov, et. al. </editor> <booktitle> Lecture Notes in Computer Science, volume 114, chapter CLU Reference Manual. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1981. </year>
Reference-contexts: Assertion (e.g., [30, 22, 25]) and exception handling mechanisms (e.g., Ada, CLU <ref> [19] </ref>, and Java) are specialized consistency management mechanisms provided by some languages. Assertions describe invariant conditions of a running program and specify actions to be taken upon detecting violations of invariants.
Reference: [20] <author> G. Lohman, B. Lindsay, H. Pirahesh, and K. B. Schiefer. </author> <title> Extensions to starburst: Objects, types, functions, and rules. </title> <journal> Communications of the ACM, </journal> <volume> 34(10) </volume> <pages> 95-109, </pages> <month> Oct </month> <year> 1991. </year>
Reference-contexts: Active database systems (e.g., <ref> [8, 20, 6] </ref>) include reactive control primitives, typically in the form of event-condition-action (ECA) rules, that can facilitate consistency management. ECA rules are general-purpose mechanisms for detecting the occurrence of some event and responding to it by some action.
Reference: [21] <author> J. P. Loyall, S. A. Mathisen, P. J. Hurley, J. S. Williamson, and L. A. Clarke. </author> <title> An advanced system for the verification and validation of real-time avionics software. </title> <booktitle> In Proc. 11th Digital Avionics Systems Conf., </booktitle> <month> Oct </month> <year> 1992. </year>
Reference-contexts: about which we obtained information were a reusable components library, the Arcadia language processing tool set, TAOS (Testing with Analysis and Oracle Support) [29], the Booch Object-Oriented Design process program (BOOD) [34], FLAVERS (Flow Analysis and VERification System) [12], an agenda management system, and an avionics validation and verification system <ref> [21] </ref>. The process we used to perform the evaluation was as follows. We constructed a questionnaire that included approximately fifty questions.
Reference: [22] <author> D. Luckham and F. vonHenke. </author> <title> An overview of ANNA, a specification language for ada. </title> <journal> IEEE Software, </journal> <volume> 2(2) </volume> <pages> 9-24, </pages> <month> Mar </month> <year> 1985. </year>
Reference-contexts: Assertion (e.g., <ref> [30, 22, 25] </ref>) and exception handling mechanisms (e.g., Ada, CLU [19], and Java) are specialized consistency management mechanisms provided by some languages. Assertions describe invariant conditions of a running program and specify actions to be taken upon detecting violations of invariants.
Reference: [23] <author> D. Maier and J. Stein. </author> <title> Development and implementation of an object-oriented dbms. </title> <editor> In S. Zdonik and D. Maier, editors, </editor> <booktitle> Readings in Object-Oriented Database Systems, </booktitle> <pages> pages 167-185. </pages> <publisher> Morgan Kaufman, </publisher> <year> 1990. </year>
Reference-contexts: Relational databases support only roll-back semantics|if constraints are not satisfied at the end of a transaction, the effects of the transaction are undone. Many database programming languages and object-oriented databases support only a limited, predefined set of consistency definitions, such as referential integrity (e.g., <ref> [23] </ref>) or programming language kinds of consistency definitions (e.g., [37, 1]), or they support consistency definitions over only a subset of types (typically collection types; e.g., [33, 9]).
Reference: [24] <author> D. McCarthy and U. Dayal. </author> <title> The architecture of an active database management system. </title> <booktitle> In Proc. ACM SIGMOD Int'l. Conf. on Management of Data, </booktitle> <pages> pages 214-224, </pages> <year> 1989. </year>
Reference-contexts: This approach would incorporate analysis techniques to help guide the selection of appropriate strategies as well as a specification mechanism that allows developers to state properties of objects that are useful in choosing the best enforcement strategies. Third, we are examining the application of coupling modes <ref> [24] </ref> to consistency management. The presence of coupling modes would permit the decoupling of consistency checking from any associated actions. These modes may be useful, for example, in cases where a reaction to a consistency violation should be deferred to some later time.
Reference: [25] <author> B. Meyer. </author> <title> Object-oriented Software Construction. </title> <publisher> Prentice-Hall, </publisher> <year> 1988. </year>
Reference-contexts: Assertion (e.g., <ref> [30, 22, 25] </ref>) and exception handling mechanisms (e.g., Ada, CLU [19], and Java) are specialized consistency management mechanisms provided by some languages. Assertions describe invariant conditions of a running program and specify actions to be taken upon detecting violations of invariants.
Reference: [26] <author> B. Nuseibeh, J. Kramer, and A. Finkelstein. </author> <title> A framework for expressing the relationships between multiple views in requirements specifications. </title> <journal> Trans. on Software Engineering, </journal> 20(10) 760-773, Oct 1994. 
Reference-contexts: Further, some kinds of consistency definitions apply within an object, some apply across objects, and some apply globally <ref> [26] </ref>. Another factor that makes consistency management difficult is that the set of consistency definitions and enforcement semantics that apply to any given object may change during the lifetime of the object. <p> Some process languages also include support for tolerating inconsistency, but, as noted, these capabilities tend to be somewhat limited. Consistency management has also been a focus of research in the area of viewpoint management. The ViewPoints system <ref> [26] </ref>, for example, facilitates multi-agent, concurrent requirements engineering by associating a viewpoint with each developer. Each viewpoint represents that developer's own perspective on the requirements under development and the process by which they are being developed. <p> We hope to explore the integration of optimistic mechanisms, such as that described in <ref> [26, 13] </ref>, into our model. Finally, we hope to generalize from the experiences we, and other developers, have had in using Pleiades and feed those experiences back into the consistency management model.
Reference: [27] <author> L. J. Osterweil. </author> <title> Software processes are software too. </title> <booktitle> In Proc. 9th Int'l. Conf. on Software Engineering, </booktitle> <pages> pages 2-13, </pages> <month> Mar </month> <year> 1987. </year>
Reference-contexts: The model of consistency management we proposed helps to address the scalability problem by localizing constraints to the objects and applications to which they pertain. Much research has been done in consistency management for software process languages <ref> [27] </ref>. Some of these languages rely on consistency management support from an associated object management system (e.g., SLANG [4, 5]). Many software process languages incorporate conditions on product state as process control conditions, rather than as product consistency conditions, which assumes that process correctness ensures product consistency.
Reference: [28] <author> D. E. Perry. </author> <title> Policy-directed coordination and cooperation. </title> <booktitle> In Proc. 7th Int'l. Software Process Workshop, </booktitle> <year> 1991. </year>
Reference-contexts: Many software process languages incorporate conditions on product state as process control conditions, rather than as product consistency conditions, which assumes that process correctness ensures product consistency. For example, EPOS [11] uses guards and postconditions to affect flow of process control; Grapple [15] and Interact <ref> [28] </ref> model conditions as goals; Melmac [14] and SLANG use conditional branching; and Marvel [18], AP5 [9], and Merlin [16] use conditions as a basis for inferencing. All of these process languages provide a more restrictive consistency model than the one we have proposed.
Reference: [29] <author> D. J. Richardson. TAOS: </author> <title> Testing with analysis and oracle support. </title> <booktitle> In Proc. 1994 Int'l. Symp. on Software Testing and Analysis, </booktitle> <month> Aug </month> <year> 1994. </year>
Reference-contexts: The evaluation we performed was based on information obtained directly from several Pleiades users. The client applications about which we obtained information were a reusable components library, the Arcadia language processing tool set, TAOS (Testing with Analysis and Oracle Support) <ref> [29] </ref>, the Booch Object-Oriented Design process program (BOOD) [34], FLAVERS (Flow Analysis and VERification System) [12], an agenda management system, and an avionics validation and verification system [21]. The process we used to perform the evaluation was as follows. We constructed a questionnaire that included approximately fifty questions.
Reference: [30] <author> D. Rosenblum. </author> <title> Towards a method of programming with assertions. </title> <booktitle> In Proc. 14th Int'l. Conf. on Software Engineering, </booktitle> <month> May </month> <year> 1992. </year>
Reference-contexts: Assertion (e.g., <ref> [30, 22, 25] </ref>) and exception handling mechanisms (e.g., Ada, CLU [19], and Java) are specialized consistency management mechanisms provided by some languages. Assertions describe invariant conditions of a running program and specify actions to be taken upon detecting violations of invariants.
Reference: [31] <author> S. M. Sutton, Jr. </author> <title> A flexible consistency model for persistent data in software-process programming languages. </title> <editor> In A. Dearle, G. M. Shaw, and S. B. Zdonik, editors, </editor> <booktitle> Implementing Persistent Object Bases|Principles and Practice, </booktitle> <pages> pages 305-318, </pages> <year> 1991. </year>
Reference-contexts: Thus, when consistency violations cannot be repaired immediately, it may be necessary to tolerate the inconsistency for some period of time <ref> [3, 31, 33] </ref> and to ensure the meaningful manipulation of inconsistent objects appropriately. This simple example illustrates some of the kinds of functionality needed to facilitate the definition and management of object consistency. <p> Information about the set of consistency conditions that are currently enforced on an object and about an object's consistency status are examples of the kinds of meta-data that may be required. Generality/heterogeneity: Previous research (e.g., <ref> [7, 31, 17] </ref>) demonstrated that different kinds of applications require different programming paradigms and models. Generality means that a consistency management system must provide a set of primitive capabilities that facilitate the implementation of alternative consistency management paradigms.
Reference: [32] <author> S. M. Sutton, Jr. </author> <title> Preconditions, postconditions, and provisional execution in software processes. </title> <type> Technical Report CMPSCI TR 95-77, </type> <institution> Computer Science Department, University of Massachusetts at Amherst, </institution> <month> Aug </month> <year> 1995. </year>
Reference-contexts: Partial means that some, but not all, parts of a condition evaluate to consistent. This facilitates the use of decomposition relationships among conditions (e.g., to enable incremental condition satisfaction). Unknown means that not enough information is available to evaluate the status of one or more objects <ref> [32] </ref>.
Reference: [33] <author> S. M. Sutton, Jr., D. Heimbigner, and L. J. Oster-weil. APPL/A: </author> <title> A language for software-process programming. </title> <journal> ACM Trans. on Software Engineering and Methodology, </journal> <volume> 4(3) </volume> <pages> 221-286, </pages> <month> Jul </month> <year> 1995. </year>
Reference-contexts: Thus, when consistency violations cannot be repaired immediately, it may be necessary to tolerate the inconsistency for some period of time <ref> [3, 31, 33] </ref> and to ensure the meaningful manipulation of inconsistent objects appropriately. This simple example illustrates some of the kinds of functionality needed to facilitate the definition and management of object consistency. <p> Many database programming languages and object-oriented databases support only a limited, predefined set of consistency definitions, such as referential integrity (e.g., [23]) or programming language kinds of consistency definitions (e.g., [37, 1]), or they support consistency definitions over only a subset of types (typically collection types; e.g., <ref> [33, 9] </ref>). Active database systems (e.g., [8, 20, 6]) include reactive control primitives, typically in the form of event-condition-action (ECA) rules, that can facilitate consistency management. ECA rules are general-purpose mechanisms for detecting the occurrence of some event and responding to it by some action. <p> In fact, the underlying capabilities required to implement consistency management and ECA rules are very similar, and some researchers have used ECA rules to imple ment consistency management capabilities. As noted by <ref> [33, 18, 9, 16] </ref>, however, the semantics of consistency management and reactive control are fairly different. Consistency management activities are a required part of any computation in which constraints are enforced| failure to satisfy constraints may invalidate an activity. <p> On the other hand, failure to satisfy well-formedness constraints on the design artifacts impacts the design process and artifacts. For this reason, many process languages with reactive control draw a distinction between consistency management and automation rules (e.g., <ref> [9, 18, 16, 33] </ref>). In these languages, all consistency maintenance activities associated with a process step must be carried out before the step can complete; failure to satisfy constraints typically results in aborting the associated step.
Reference: [34] <author> S. M. Sutton, Jr. and L. J. Osterweil. </author> <title> The design of a next-generation process language. </title> <booktitle> In Proc. 5th Symp. on the Foundations of Software Engineering, </booktitle> <month> Sep </month> <year> 1997. </year> <note> (To appear.). </note>
Reference-contexts: The evaluation we performed was based on information obtained directly from several Pleiades users. The client applications about which we obtained information were a reusable components library, the Arcadia language processing tool set, TAOS (Testing with Analysis and Oracle Support) [29], the Booch Object-Oriented Design process program (BOOD) <ref> [34] </ref>, FLAVERS (Flow Analysis and VERification System) [12], an agenda management system, and an avionics validation and verification system [21]. The process we used to perform the evaluation was as follows. We constructed a questionnaire that included approximately fifty questions.
Reference: [35] <author> P. L. Tarr. </author> <title> Object Management Support for the Construction of Complex Applications. </title> <type> PhD thesis, </type> <institution> University of Massachusetts at Amherst, </institution> <year> 1996. </year>
Reference-contexts: Identity facilitates sharing, which makes it easier, for example, to share enforcement semantics among constraints. 3 Model of Consistency Management Based on the requirements described earlier, we have defined a model of consistency management. A formal specification of this model is given in <ref> [35] </ref>. We have incorporated much of the model into the Pleiades object management system [35, 36] to evaluate the model and to explore implementation considerations. This section describes the consistency management model. To facilitate the description of this model, we assume an abstract data type (ADT) programming model. <p> A formal specification of this model is given in [35]. We have incorporated much of the model into the Pleiades object management system <ref> [35, 36] </ref> to evaluate the model and to explore implementation considerations. This section describes the consistency management model. To facilitate the description of this model, we assume an abstract data type (ADT) programming model. <p> While some issues are specific to an Ada instantiation, many are general issues for any instantia-tion. This section describes some of these issues and discusses justifications for, and the implications of, some of the decisions we made in implementing Pleiades. <ref> [35] </ref> includes a more detailed discussion. General Issues: The purpose of imposing the crosscutting requirements was to ensure the definition of a consistency model that is powerful and flexible enough to facilitate the description of many different consistency management semantics. With this flexibility comes a number of tradeoffs, however. <p> As noted earlier, first-class status and identity of objects provides the ability to model relationships among, and constraints on, any kinds of objects. The identity requirement, however, can lead to a fairly serious consistency management system implementation problem. The problem, which we call the container problem <ref> [35] </ref>, arises when the consistency status of an object, o, depends on the states of other objects whose states can change independently of o's. A well-known example of the container problem is the dangling reference problem. <p> We then evaluated each user's experiences, based on the information provided. Once this evaluation was written, it was sent to the user for correction and feedback. A complete description of the evaluation appears in <ref> [35] </ref>. The results of the evaluation suggest that, in general, the consistency management requirements and model we proposed are sound. Clients liked and made use of most of the capabilities associated with the functional requirements, and they made use of all the capabilities associated with the cross-cutting requirements.
Reference: [36] <author> P. L. Tarr and L. A. Clarke. PLEIADES: </author> <title> An object management system for software engineering environments. </title> <booktitle> In ACM SIGSOFT '93 Symp. on Foundations of Software Engineering, </booktitle> <pages> pages 56-70, </pages> <month> Dec </month> <year> 1993. </year>
Reference-contexts: Section 3 describes a model of consistency management that satisfies these requirements. We have implemented much of this model in the Pleiades object management system <ref> [36] </ref>. Section 4 discusses various design and implementation tradeoffs involved in instantiating the model for Pleiades. Pleiades has been used in the implementation of several applications. Section 5 describes some of these uses and, based on client feedback, evaluates our proposed requirements on, and model of, consistency management. <p> Towards satisfying this goal, we have further constrained the set of functionalities discussed above with a set of cross-cutting requirements <ref> [36] </ref> that describe more specifically how these capabilities should be provided to produce a flexible, broad-spectrum consistency management system. Completeness: Computational completeness supports the definition of arbitrarily complex algorithms, both for determining whether or not objects satisfy consistency conditions and for specifying enforcement semantics. <p> A formal specification of this model is given in [35]. We have incorporated much of the model into the Pleiades object management system <ref> [35, 36] </ref> to evaluate the model and to explore implementation considerations. This section describes the consistency management model. To facilitate the description of this model, we assume an abstract data type (ADT) programming model.
Reference: [37] <author> S. L. Vandenberg and D. J. DeWitt. </author> <title> Algebraic support for complex objects with arrays, identity, and inheritance. </title> <booktitle> In Proc. SIGMOD Int'l. Conf. on Management of Data, </booktitle> <pages> pages 158-167, </pages> <month> May </month> <year> 1991. </year>
Reference-contexts: Many database programming languages and object-oriented databases support only a limited, predefined set of consistency definitions, such as referential integrity (e.g., [23]) or programming language kinds of consistency definitions (e.g., <ref> [37, 1] </ref>), or they support consistency definitions over only a subset of types (typically collection types; e.g., [33, 9]). Active database systems (e.g., [8, 20, 6]) include reactive control primitives, typically in the form of event-condition-action (ECA) rules, that can facilitate consistency management.
References-found: 37

