URL: ftp.cse.unsw.edu.au/pub/users/disy/papers/Heiser_EVRL_98.ps.gz
Refering-URL: 
Root-URL: 
Email: E-mail: fgernot,kevine,jerry,smrg@cse.unsw.edu.au  E-mail: jochen@us.ibm.com  
Phone: Phone: +61-2-9385-5156 Fax: +61-2-9385-5995  
Title: The Mungi Single-Address-Space Operating System  
Author: Gernot Heiser, Kevin Elphinstone, Jerry Vochteloo, Stephen Russell Jochen Liedtke 
Date: 18(9), 25 July 1998  
Note: Appeared in Software: Practice Experience,  
Web: WWW: http://www.cse.unsw.edu.au/ disy  
Address: Sydney 2052, Australia  30 Saw Mill River Road, Hawthorne, NY 10532, USA  
Affiliation: Department of Computer Systems School of Computer Science and Engineering The University of New South Wales,  IBM T. J. Watson Research Center  
Abstract-found: 0
Intro-found: 0
Reference: [1] <author> W. Cockshot, M. Atkinson, K. Chisholm, P. Bailey, and R. Morrison. </author> <title> Persistent object management systems. </title> <journal> Software: Practice and Experience, </journal> <volume> 14 </volume> <pages> 49-71, </pages> <year> 1984. </year>
Reference-contexts: This process is called flattening, and must generally be done by the programmer. The alternative is to store pointers in a portable form, then translate them automatically when they are used, a process called pointer swizzling <ref> [1, 2] </ref>. Pointer swizzling is only 3 possible if the system is able to detect all pointers. This imposes significant re-strictions on pointer use, which are generally incompatible with languages like C. Careful use of shared memory also offers a partial solution.
Reference: [2] <author> P. R. Wilson. </author> <title> Pointer swizzling at page fault time: Efficiently supporting huge address spaces on standard hardware. </title> <journal> Computer Architecture News, </journal> <volume> 19(4) </volume> <pages> 6-13, </pages> <month> June </month> <year> 1991. </year>
Reference-contexts: This process is called flattening, and must generally be done by the programmer. The alternative is to store pointers in a portable form, then translate them automatically when they are used, a process called pointer swizzling <ref> [1, 2] </ref>. Pointer swizzling is only 3 possible if the system is able to detect all pointers. This imposes significant re-strictions on pointer use, which are generally incompatible with languages like C. Careful use of shared memory also offers a partial solution.
Reference: [3] <author> M. Atkinson, P. Bailey, K. Chisholm, P. Cockshott, and R. Morrison. </author> <title> An approach to persistent programming. </title> <journal> The Computer Journal, </journal> <volume> 26 </volume> <pages> 360-365, </pages> <year> 1983. </year>
Reference-contexts: These problems could be avoided if all data were put into the same address space. It has been pointed out long ago <ref> [3] </ref> that there are significant benefits to be gained by a uniform treatment of all data, no matter how long its lifetime. This is generally referred to as orthogonal persistence.
Reference: [4] <author> M. E. Houdek, F. G. Soltis, and R. L. Hoffman. </author> <title> IBM System/38 support for capability-based addressing. </title> <booktitle> In Proceedings of the 8th Symposium on Computer Architecture, </booktitle> <pages> pages 341-348. </pages> <address> ACM/IEEE, </address> <month> May </month> <year> 1981. </year>
Reference-contexts: This is generally referred to as orthogonal persistence. Large address spaces An address space that is able to accommodate all persistent objects and to allow easy sharing must be large, much larger than the 32-bit addresses available until recently. This was recognised in IBM's System/38 <ref> [4] </ref> (now AS/400) and Mon-ads [5], which implemented a large shared virtual address space. These systems offered attractive features such as a single-level store, object-based protection, and, in Monads' case, transparent distribution.
Reference: [5] <author> J. Rosenberg and D. Abramson. </author> <title> MONADS-PC|a capability-based workstation to support software engineering. </title> <booktitle> In Proceedings of the 18th Hawaii International Conference on System Sciences, </booktitle> <volume> volume 1, </volume> <pages> pages 222-31. </pages> <publisher> IEEE, </publisher> <year> 1985. </year>
Reference-contexts: Large address spaces An address space that is able to accommodate all persistent objects and to allow easy sharing must be large, much larger than the 32-bit addresses available until recently. This was recognised in IBM's System/38 [4] (now AS/400) and Mon-ads <ref> [5] </ref>, which implemented a large shared virtual address space. These systems offered attractive features such as a single-level store, object-based protection, and, in Monads' case, transparent distribution. <p> On a miss in this software cache, the mapping 16 is obtained from a guarded page table (GPT) [36, 37]. The GPT is an efficient data structure well suited for large, sparse address spaces. The main advantage GPTs have over alternative data structures, such as inverted page tables (IPTs) <ref> [5, 38] </ref>, is that they efficiently support sharing of large areas of the address space. In our implementation we use this for quickly mapping kernel data structures into the client's view of the address space for the duration of a system call.
Reference: [6] <author> T. Wilkinson, T. Stiemerling, P. E. Osmon, A. Saulsbury, and P. Kelly. Angel: </author> <title> A proposed multiprocessor operating system kernel. </title> <booktitle> In European Workshop on Parallel Computing, </booktitle> <pages> pages 316-319, </pages> <address> Barcelona, Spain, </address> <year> 1992. </year>
Reference-contexts: Recent work In recent years there have been several projects investigating the design and benefits of SASOS. They have in common a 64-bit distributed persistent memory, which is implemented without the use of specialised hardware. The systems differ, however, in interesting ways. The Angel <ref> [6, 10] </ref> project was the first of these systems. The designers of Angel have studied fault tolerance issues [11] and have shown that, by making the distributed single address space fault tolerant, this reliability is automatically inherited by other software structures built on top.
Reference: [7] <author> J. S. Chase, H. M. Levy, E. D. Lazowska, and M. Baker-Harvey. </author> <title> Lightweight shared objects in a 64-bit operating system. </title> <booktitle> In Conference on Object-Oriented Programming Systems, Languages, and Applications, </booktitle> <year> 1992. </year>
Reference: [8] <author> S. Russell, A. Skea, K. Elphinstone, G. Heiser, K. Burston, I. Gorton, and G. Hellestrand. </author> <title> Distribution + persistence = global virtual memory. </title> <booktitle> In Proceedings of the 2nd International Workshop on Object Orientation in Operating Systems, </booktitle> <pages> pages 96-99, </pages> <address> Dourdan, France, </address> <month> September </month> <year> 1992. </year> <note> IEEE. </note>
Reference: [9] <author> F. G. Soltis. </author> <title> Inside the AS/400. </title> <publisher> Duke Press, Loveland, CO, </publisher> <address> USA, </address> <year> 1996. </year>
Reference-contexts: Eliminating the need for a file system does more than just simplify data storage and application programs. Redundant data movements inherent in file system are avoided, as data read from disk is deposited directly where it is to be 4 accessed by user code. Soltis <ref> [9] </ref> also points out that the process independence of virtual-to-physical address mappings in a single address space plays a significant role in keeping context switching costs low.
Reference: [10] <author> T. Wilkinson and K. Murray. </author> <title> Evaluation of a distributed single address space operating system. </title> <booktitle> In Proceedings of the 16th International Conference on Distributed Computing Systems, </booktitle> <pages> pages 494-501, </pages> <address> Hong Kong, </address> <month> May </month> <year> 1996. </year> <journal> IEEE. </journal> <volume> 30 </volume>
Reference-contexts: Soltis [9] also points out that the process independence of virtual-to-physical address mappings in a single address space plays a significant role in keeping context switching costs low. It has furthermore been noted <ref> [10] </ref> that the simplified model significantly reduces the complexity of the operating system, and leads to improved performance (small is beautiful!) In a distributed system, the single address space incorporating all nodes makes process migration easier to implement: Once a process' context is migrated, data accessed by the process will move <p> Recent work In recent years there have been several projects investigating the design and benefits of SASOS. They have in common a 64-bit distributed persistent memory, which is implemented without the use of specialised hardware. The systems differ, however, in interesting ways. The Angel <ref> [6, 10] </ref> project was the first of these systems. The designers of Angel have studied fault tolerance issues [11] and have shown that, by making the distributed single address space fault tolerant, this reliability is automatically inherited by other software structures built on top.
Reference: [11] <author> T. Wilkinson. </author> <title> Implementing Fault Tolerance in a 64-Bit Distributed Op--erating System. </title> <type> PhD thesis, </type> <institution> Systems Architecture Research Centre, City University, </institution> <address> London, UK, </address> <month> July </month> <year> 1993. </year>
Reference-contexts: They have in common a 64-bit distributed persistent memory, which is implemented without the use of specialised hardware. The systems differ, however, in interesting ways. The Angel [6, 10] project was the first of these systems. The designers of Angel have studied fault tolerance issues <ref> [11] </ref> and have shown that, by making the distributed single address space fault tolerant, this reliability is automatically inherited by other software structures built on top. They have furthermore demonstrated that full POSIX support, including the difficult fork () operation, is possible in a SASOS [12].
Reference: [12] <author> T. Wilkinson, K. Murray, A. Saulsbury, and T. Stiemerling. </author> <title> Compiling for a 64-bit single address space architecture. </title> <type> Technical report TCU/SARC/1993/1, </type> <institution> Systems Architecture Research Centre, City University, </institution> <address> London, UK, </address> <month> March </month> <year> 1993. </year>
Reference-contexts: They have furthermore demonstrated that full POSIX support, including the difficult fork () operation, is possible in a SASOS <ref> [12] </ref>. Angel has no explicit protection system. Instead, it relies on the ability of an object to be accessed or a service to be named in order to protect it|protection is effectively left in the hands of servers. <p> Hence, it is possible on a fork () to create and initialise the child's data segment in a different portion of the address space, provided that the POSIX application is compiled to use suitable indirect addressing <ref> [12] </ref>. As we shall show later this introduces very little overhead, and this overhead only incurred for applications which actually use fork (). It is worth mentioning that even UNIX applications rarely rely on the full fork () semantics. <p> To evaluate this cost quantitatively we modified gcc, the GNU C compiler, as done by Wilkinson et al. <ref> [12] </ref>. Table 4 shows the result of benchmark runs which were compiled in three different ways: "normal" compilation (i.e., without support for fork ()) using SGI's C compiler, normal compilation using gcc, and compilation using gcc with support for fork (). All versions were compiled for 64-bit with full optimisation.
Reference: [13] <author> S. J. Mullender and A. S. Tanenbaum. </author> <title> The design of a capability-based distributed operating system. </title> <journal> The Computer Journal, </journal> <volume> 29 </volume> <pages> 289-299, </pages> <year> 1986. </year>
Reference-contexts: Angel has no explicit protection system. Instead, it relies on the ability of an object to be accessed or a service to be named in order to protect it|protection is effectively left in the hands of servers. This approach is similar to that taken in the Amoeba distributed system <ref> [13] </ref>, where servers use sparse capabilities for naming and protecting objects. While the design is aimed at 64-bit architectures, the Angel prototype was implemented on i486 hardware. It therefore has not considered issues resulting from a huge, sparsely used address space. <p> In Mungi no directory services are provided by the system itself. To assist users in managing their storage, we instead use a different, and more flexible scheme, derived from the rent model used in Monash University's Password Capability System [15] and the bank accounts used in Amoeba <ref> [13] </ref>. Whenever an object is created, a bank account must be supplied, and the bank account reference is recorded in the object's OT entry. A rent collector periodically charges the account for the disk storage used by the object. A paymaster periodically deposits funds into each account.
Reference: [14] <author> J. S. Chase, H. M. Levy, M. J. Feeley, and E. D. Lazowska. </author> <title> Sharing and protection in a single-address-space operating system. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 12 </volume> <pages> 271-307, </pages> <month> November </month> <year> 1994. </year>
Reference-contexts: While the design is aimed at 64-bit architectures, the Angel prototype was implemented on i486 hardware. It therefore has not considered issues resulting from a huge, sparsely used address space. Opal <ref> [14] </ref> in contrast uses password capabilities [15] to name and protect memory segments, threads, protection domains, portals (protected procedure entry points) and resource groups (used for accounting). Access to these objects generally requires that the correct capabilities be presented explicitly. <p> As there are no such address space boundaries in a SASOS, this seems, at first glance, to weaken protection. In fact, memory protection in SASOS is by no means weaker than in traditional systems <ref> [14] </ref>. As far as protection is concerned, the concept of an address space is replaced by a protection domain, which is the set of objects a process is allowed to access. <p> All the Mungi, Irix and Linux figures were obtained on an 100MHz R4600 based SGI Indy workstation with 64Mb of RAM. Comparisons with Opal are based on published data <ref> [14] </ref>. These timings had been obtained on a DEC 3000/400 AXP (133.3 MHz Alpha CPU).
Reference: [15] <author> M. Anderson, R. Pose, and C. S. Wallace. </author> <title> A password-capability system. </title> <journal> The Computer Journal, </journal> <volume> 29 </volume> <pages> 1-8, </pages> <year> 1986. </year>
Reference-contexts: While the design is aimed at 64-bit architectures, the Angel prototype was implemented on i486 hardware. It therefore has not considered issues resulting from a huge, sparsely used address space. Opal [14] in contrast uses password capabilities <ref> [15] </ref> to name and protect memory segments, threads, protection domains, portals (protected procedure entry points) and resource groups (used for accounting). Access to these objects generally requires that the correct capabilities be presented explicitly. A protected procedure call mechanism is supported which has the caller enter the callee's protection domain. <p> In Mungi no directory services are provided by the system itself. To assist users in managing their storage, we instead use a different, and more flexible scheme, derived from the rent model used in Monash University's Password Capability System <ref> [15] </ref> and the bank accounts used in Amoeba [13]. Whenever an object is created, a bank account must be supplied, and the bank account reference is recorded in the object's OT entry. A rent collector periodically charges the account for the disk storage used by the object.
Reference: [16] <author> I. Leslie, D. McAuley, R. Black, T. Roscoe, P. Barham, D. Evers, R. Fair-bairns, and E. Hyden. </author> <title> The design and implementation of an operating system to support distributed multimedia applications. </title> <journal> IEEE Journal on Selected Areas in Communications, </journal> <volume> 14 </volume> <pages> 1280-1297, </pages> <year> 1996. </year>
Reference-contexts: The prototype implements Opal on top of Mach, and uses the Mach UNIX server for support. This approach has a impact on performance, as discussed below. For this reason, the Opal prototype has not fully demonstrated the inherent performance advantages of a SASOS. Nemesis <ref> [16] </ref> is another recent SASOS designed for efficient support of multimedia applications. Its address space is not distributed, and persistence is handled at the user level. Objects in Nemesis export multiple interfaces, which are combined with closures to provide compile-time type checking. Grasshopper [17] is a related system.
Reference: [17] <author> J. Rosenberg, A. Dearle, D. Hulse, A. Lindstrom, and S. Norris. </author> <title> Operating system support for persistent and recoverable computations. </title> <journal> Communications of the ACM, </journal> <volume> 39(9) </volume> <pages> 62-69, </pages> <month> September </month> <year> 1996. </year>
Reference-contexts: Nemesis [16] is another recent SASOS designed for efficient support of multimedia applications. Its address space is not distributed, and persistence is handled at the user level. Objects in Nemesis export multiple interfaces, which are combined with closures to provide compile-time type checking. Grasshopper <ref> [17] </ref> is a related system. Its basic storage abstraction is called a 5 container, which essentially constitutes an address space. Containers, or parts thereof, can be mapped into other containers.
Reference: [18] <author> A. Lindstrom, J. Rosenberg, and A. Dearle. </author> <title> The grand unified theory of address spaces. </title> <booktitle> In Proceedings of the 5th Workshop on Hot Topics in Operating Systems (HotOS), </booktitle> <pages> pages 66-71, </pages> <address> Orcas Island, WA, USA, </address> <month> May </month> <year> 1995. </year> <note> IEEE. </note>
Reference-contexts: Its basic storage abstraction is called a 5 container, which essentially constitutes an address space. Containers, or parts thereof, can be mapped into other containers. Grasshopper presents a gener-alised model of address spaces, which can emulate a traditional model, such as UNIX, as well as the SASOS model <ref> [18] </ref>. However, as the single-address-space view is not enforced by the system, Grasshopper cannot provide the SASOS guarantee that a specific data item always appears at the same virtual address for the duration of its life time, and thus cannot ensure that data containing embedded pointers can always be shared.
Reference: [19] <author> J. Vochteloo, S. Russell, and G. Heiser. </author> <title> Capability-based protection in the Mungi operating system. </title> <booktitle> In Proceedings of the 3rd International Workshop on Object Orientation in Operating Systems, </booktitle> <pages> pages 108-15, </pages> <address> Asheville, NC, USA, </address> <month> December </month> <year> 1993. </year> <note> IEEE. </note>
Reference-contexts: Threads are the basic execution abstraction. A task is a set of threads which share a protection domain. A protection domain consists of a set of capabilities. Capabilities are presented implicitly by storing them in a special data-structure known to the system <ref> [19] </ref>. This reduces the need for most applications to deal with capabilities and thus makes protection transparent. Mungi is a pure SASOS in that it provides no inter-process communication facility other than shared memory (plus semaphores for synchronisation). Furthermore, there are no explicit system calls to support I/O in Mungi.
Reference: [20] <author> J. B. Carter, J. K. Bennett, and W. Zwaenepoel. </author> <title> Techniques for reducing consistency-related communication in distributed shared memory systems. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 13 </volume> <pages> 205-243, </pages> <year> 1995. </year>
Reference-contexts: The answer is that in a distributed system these instructions are unusable for synchronisation unless strict memory coherence is enforced. Strict coherence has been shown to be expensive, and unnecessary for many distributed applications <ref> [20] </ref>. In order to maintain sufficient flexibility until we have gathered enough experience with distribution in Mungi, we decided to support synchro-nisation in the OS. In a later version this can be moved to a library should that turn out to be sufficient.
Reference: [21] <author> G. Heiser, J. Vochteloo, K. Elphinstone, and S. Russell. </author> <title> The Mungi kernel API/Release 1.0. </title> <type> Technical Report UNSW-CSE-TR-9701, </type> <institution> School of Computer Science and Engineering, University of NSW, </institution> <address> Sydney 2052, Australia, </address> <month> March </month> <year> 1997. </year> <note> Latest version available from http://www.cse.unsw.edu.au/ ~ disy/. </note>
Reference-contexts: In a later version this can be moved to a library should that turn out to be sufficient. The remainder of this section describes in more detail the basic Mungi abstractions. A full description of the API is given in <ref> [21] </ref>. 1 Capabilities While SASOS make sharing of data easy, this must not happen at the expense of security.
Reference: [22] <author> C. S. Wallace. </author> <title> Physically random generator. </title> <journal> Computer Systems Science & Engineering, </journal> <volume> 5 </volume> <pages> 82-88, </pages> <year> 1990. </year> <month> 31 </month>
Reference-contexts: The password is chosen by the owner when the capability is registered; it is normally obtained from a library routine. Presently, we use a DES-based encryption scheme for creating "random" passwords. However, in the future we plan to use a hardware device producing truly random bitstrings <ref> [22] </ref>. The list of valid capabilities for each object is maintained by the system in a distributed system-wide directory, the object table (OT). As capabilities are user objects, it is not possible to determine the tasks and users who have access to a particular object.
Reference: [23] <author> D. Kotz and P. Crow. </author> <title> The expected lifetime of single-address-space oper-ating systems. </title> <journal> Computing Systems, </journal> <volume> 9 </volume> <pages> 155-178, </pages> <year> 1996. </year>
Reference-contexts: Hence dangling pointers and capabilities do not present a security problem, although they have other problems similar to those of dangling symbolic links in UNIX. Address space reuse is important as otherwise even a 64-bit address space could conceivably be exhausted <ref> [23] </ref>. With reuse, address space consumption is essentially limited by the amount of backing store available, which ensures that a 64-bit address space will suffice until it becomes feasible to connect billions of gigabytes of disk to a single system.
Reference: [24] <author> G. Heiser, F. Lam, and S. Russell. </author> <title> Resource management in the Mungi single-address-space operating system. </title> <booktitle> In Proceedings of the 21st Aus-tralasian Computer Science Conference, </booktitle> <pages> pages 417-428, </pages> <address> Perth, Australia, </address> <month> February </month> <year> 1998. </year> <note> Springer-Verlag. Also available as UNSW-CSE-TR-9705 from http://www.cse.unsw.edu.au/school/research/tr.html. </note>
Reference-contexts: Storage management While the kill list helps to reduce the amount of garbage objects, this is not enough to prevent all secondary storage eventually filling up with unused objects. Automatic garbage collection does not provide a solution <ref> [24] </ref>. As in a traditional file system, persistent objects are normally entered into a directory, which associates human-readable names with 64-bit object addresses. As long as the directory continues to contain a reference to an object, it cannot be automatically removed as garbage. <p> Such a graceful degradation of service cannot be achieved with a quota system. Details can be found in <ref> [24] </ref>. It should be pointed out that Mungi's support for bank accounts is limited to requiring the presentation of a valid bank account capability at object creation time. The details of the accounting model are implemented at user-level.
Reference: [25] <author> J. Vochteloo. </author> <title> Design, Implementation and Performance of Protection in Mungi. </title> <type> Phd thesis, </type> <institution> School of Computer Science and Engineering, University of NSW, </institution> <address> Sydney 2052, Australia, </address> <month> July </month> <year> 1998. </year> <note> Submitted. </note>
Reference-contexts: This provides a mechanism to control propagation of capabilities: A task can be executed in an APD which does not allow access to the capabilities themselves. By providing in addition the possibility to lock the APD, preventing further changes, we are able to confine an untrusted program <ref> [25] </ref>. Protected procedure calls In a SASOS, threads normally communicate via shared memory. However, in many cases a more controlled access to data by clients is required|essentially we want a mechanism to support object encapsulation. <p> If an object needs to grow it can be moved to a different location in the address space. 3 The POSIX protection model can be emulated in Mungi by appropriate organisation of one's Clists <ref> [25] </ref>. Operations like chmod () are possible in this emulation. The biggest problem with POSIX compatibility is the fork () system call, which explicitly duplicates the process' address space. This is impossible to do in a SASOS, as there is only one address space.
Reference: [26] <author> H. M. Levy. </author> <title> Capability-Based Computer Systems. </title> <publisher> Digital Press, </publisher> <year> 1984. </year>
Reference-contexts: Tying protection domains to procedures, and performing an automatic change of the protection domain during invocation of such a procedure, is a natural idea in a capability system. It has been used since the 1970s in such systems as the Plessey 250 (see <ref> [26] </ref>) and the Cambridge CAP computer [27].
Reference: [27] <author> R. Needham and R. Walker. </author> <title> The Cambridge CAP computer and its protection system. </title> <booktitle> In Proceedings of the 6th ACM Symposium on OS Principles, </booktitle> <pages> pages 1-10. </pages> <publisher> ACM, </publisher> <month> November </month> <year> 1977. </year>
Reference-contexts: Tying protection domains to procedures, and performing an automatic change of the protection domain during invocation of such a procedure, is a natural idea in a capability system. It has been used since the 1970s in such systems as the Plessey 250 (see [26]) and the Cambridge CAP computer <ref> [27] </ref>. Hydra, one of the pioneers of what 11 Registered for PDX Object Protection Domain of Task Protection Domain During PDX Call Selected Subset of Task's PD Protection Domain is now called microkernels and the first object-based OS, made protected procedures the basis of secure object invocation.
Reference: [28] <author> V. Berstis. </author> <title> Security and protection in the IBM System/38. </title> <booktitle> In Proceedings of the 7th Symposium on Computer Architecture, </booktitle> <pages> pages 245-250. </pages> <address> ACM/IEEE, </address> <month> May </month> <year> 1980. </year>
Reference-contexts: The need to initialise a new protection domain on each procedure call, and to manipulate it again to enable sharing, made protected procedure calls expensive in Hydra. Our mechanism, called protection domain extension (PDX), is similar to the profile adoption mechanism of the IBM System/38 <ref> [28] </ref>. It allows the caller of a PDX procedure to extend its protection domain, for the duration of the call, by the protection domain of the callee [29].
Reference: [29] <author> J. Vochteloo, K. Elphinstone, S. Russell, and G. Heiser. </author> <title> Protection domain extensions in Mungi. </title> <booktitle> In Proceedings of the 5th International Workshop on Object Orientation in Operating Systems, </booktitle> <pages> pages 161-165, </pages> <address> Seattle, WA, USA, </address> <month> October </month> <year> 1996. </year> <note> IEEE. </note>
Reference-contexts: Our mechanism, called protection domain extension (PDX), is similar to the profile adoption mechanism of the IBM System/38 [28]. It allows the caller of a PDX procedure to extend its protection domain, for the duration of the call, by the protection domain of the callee <ref> [29] </ref>. Hence, sharing can be achieved without the need to pass capabilities to the procedure via parameters, and changes to the protection domain are minimised. Unlike System/38, our PDX mechanism does not require special hardware, yet allows for efficient implementation (as explained later).
Reference: [30] <author> K. Elphinstone, S. Russell, G. Heiser, and J. Liedtke. </author> <title> Supporting persistent object systems in a single address space. </title> <booktitle> In Proceedings of the 7th International Workshop on Persistent Object Systems, </booktitle> <pages> pages 111-119, </pages> <address> Cape May, NJ, USA, May 1996. </address> <publisher> Morgan Kaufmann. </publisher>
Reference-contexts: As there is no I/O model in the system, a pager cannot use I/O operations to handle a residency fault. Instead, the pager uses another virtual memory object to page to. To support such forwarding of page faults, Mungi provides mapping operations between different regions of virtual memory <ref> [30] </ref>. Pages belonging to an object O 1 may be mapped to another object O 2 , which causes O 2 's pager to be 13 invoked when necessary. <p> The addition of virtual memory mapping operations has made it possible to incorporate into the single-address-space model user-level pagers and I/O, and leave, for example, the implementation of stability and fault tolerance to the user level <ref> [30] </ref>. This allowed us to build a "pure" SASOS, where virtual memory is the only communication medium between processes.
Reference: [31] <author> C. Chao, M. Mackey, and B. Sears. </author> <title> Mach on a virtually addressed cache architecture. </title> <booktitle> In USENIX Mach Workshop, </booktitle> <pages> pages 31-51, </pages> <year> 1990. </year>
Reference-contexts: Implications of aliasing The default pager supports copy-on-write. While this introduces aliasing on read-only objects (and is thus harmless <ref> [31] </ref>), other mappings potentially introduce the same aliasing problems as in multi-address-space systems. This seems to defeat some of the advantages of a SASOS. Remember, however, that a mapping can vanish at any time, as soon as the source page of a mapping becomes non-resident.
Reference: [32] <author> Portable Operating System Interface (POSIX)|Part 1: </author> <title> System Application Program Interface (API) [C Language], </title> <booktitle> 1990. IEEE Std 1003.1-1990, </booktitle> <address> ISO/IEC 9945-1:1990. </address>
Reference-contexts: In particular they must provide user environments similar to established systems. In the context of a SASOS this means that it must be possible to support applications written for multi-address-space systems like POSIX <ref> [32] </ref>. Most of the POSIX interface presents no particular problems for emulation under Mungi. A file system, for example, while not necessary in Mungi, can easily be implemented on top of it | it simply provides a file interface to Mungi objects.
Reference: [33] <author> D. Presotto, R. Pike, K. Thompson, and H. Trickey. </author> <title> Plan 9, a distributed system. </title> <booktitle> In EurOpen Conference, </booktitle> <pages> pages 43-50, </pages> <address> Tromso, Norway, </address> <month> May </month> <year> 1991. </year>
Reference-contexts: Mungi does not support a system-wide naming facility other than virtual memory addresses; it is left to the user environment to supply a text-based object name space. We presently use an adaptation of the Plan 9 naming system <ref> [33] </ref>, as its concept of user-tailorable naming fits the Mungi model well. However, other views of the object space could be used, including the familiar UNIX naming hierarchy.
Reference: [34] <editor> J. Liedtke. </editor> <booktitle> On -kernel construction. In Proceedings of the 15th ACM Symposium on OS Principles, </booktitle> <pages> pages 237-250, </pages> <address> Copper Mountain, CO, USA, </address> <month> December </month> <year> 1995. </year>
Reference-contexts: The details of the implementation are given below, while performance figures are presented in the next section. We decided to build Mungi on top of the L4 microkernel <ref> [34] </ref>. The main reason for this approach was that, by basing our system on a well-designed and optimised microkernel, we would find it easier to produce an implementation which can demonstrate that the SASOS approach can lead to very efficient operating systems. <p> While the L4 interface is hardware independent (except for details like the number of registers used for by-value IPC parameters), the actual implementation is not. It is mostly written in assembler, and inherently unportable <ref> [34] </ref>. Furthermore, there were no 64-bit implementations of L4 available at the time. This meant that we had to implement L4 from scratch. In the following, we highlight those features of our L4 implementation that impact on Mungi.
Reference: [35] <author> J. Liedtke, K. Elphinstone, S. Schonberg, H. Hartig, G. Heiser, N. Islam, and T. Jaeger. </author> <title> Achieved IPC performance (still the foundation for efficiency). </title> <booktitle> In Proceedings of the 6th Workshop on Hot Topics in Operating Systems (HotOS), </booktitle> <pages> pages 28-31, </pages> <address> Cape Cod, MA, USA, </address> <month> May </month> <year> 1997. </year> <journal> IEEE. </journal> <volume> 32 </volume>
Reference-contexts: However, the performance of our prototype shows that the benefit would be small. The microkernel The main features of L4 which made it suitable for our use are its small size, its very efficient process management and IPC <ref> [35] </ref>, and the flexible address space model it provides. While the L4 interface is hardware independent (except for details like the number of registers used for by-value IPC parameters), the actual implementation is not. It is mostly written in assembler, and inherently unportable [34].
Reference: [36] <author> J. Liedtke. </author> <title> A basis for huge fine-grained address spaces and user level mapping. </title> <booktitle> In Proceedings of the 7th European Conference on Object Oriented Programming (ECOOP) Workshop on Granularity of Objects in Distributed Systems (GODS'93), </booktitle> <address> Kaiserslautern, Germany, </address> <month> July </month> <year> 1993. </year>
Reference-contexts: We maintain in software a two-way associative TLB cache for fast handling of hardware TLB misses. On a miss in this software cache, the mapping 16 is obtained from a guarded page table (GPT) <ref> [36, 37] </ref>. The GPT is an efficient data structure well suited for large, sparse address spaces. The main advantage GPTs have over alternative data structures, such as inverted page tables (IPTs) [5, 38], is that they efficiently support sharing of large areas of the address space.
Reference: [37] <author> J. Liedtke. </author> <title> On the Realization Of Huge Sparsely-Occupied and Fine-Grained Address Spaces. </title> <publisher> Oldenbourg, </publisher> <address> Munich, Germany, </address> <year> 1996. </year>
Reference-contexts: We maintain in software a two-way associative TLB cache for fast handling of hardware TLB misses. On a miss in this software cache, the mapping 16 is obtained from a guarded page table (GPT) <ref> [36, 37] </ref>. The GPT is an efficient data structure well suited for large, sparse address spaces. The main advantage GPTs have over alternative data structures, such as inverted page tables (IPTs) [5, 38], is that they efficiently support sharing of large areas of the address space.
Reference: [38] <author> A. Chang and M. F. Mergen. </author> <title> 801 Storage: Architecture and programming. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 6 </volume> <pages> 28-50, </pages> <year> 1988. </year>
Reference-contexts: On a miss in this software cache, the mapping 16 is obtained from a guarded page table (GPT) [36, 37]. The GPT is an efficient data structure well suited for large, sparse address spaces. The main advantage GPTs have over alternative data structures, such as inverted page tables (IPTs) <ref> [5, 38] </ref>, is that they efficiently support sharing of large areas of the address space. In our implementation we use this for quickly mapping kernel data structures into the client's view of the address space for the duration of a system call.
Reference: [39] <author> M. Talluri, M. D. Hill, and Y. A. Khalid. </author> <title> A new page table for 64-bit address spaces. </title> <booktitle> In Proceedings of the 15th ACM Symposium on OS Principles, </booktitle> <pages> pages 184-200, </pages> <address> Copper Mountain Resort, Co, USA, </address> <month> December </month> <year> 1995. </year> <note> ACM. </note>
Reference-contexts: In our implementation we use this for quickly mapping kernel data structures into the client's view of the address space for the duration of a system call. Using clustered page tables <ref> [39] </ref> would have been an alternative. However, we doubt that clustered page tables can handle very sparse address spaces, with many single-page objects, as efficiently as GPTs. We are still investigating this topic.
Reference: [40] <author> H. Hartig, M. Hohmuth, J. Liedtke, S. Schonberg, and J. Wolter. </author> <title> The performance of -kernel-based systems. </title> <booktitle> In Proceedings of the 16th ACM Symposium on OS Principles, </booktitle> <pages> pages 66-77, </pages> <address> St. Malo, France, </address> <month> October </month> <year> 1997. </year> <note> ACM. </note>
Reference-contexts: This is consistent with the findings of Hartig et al. <ref> [40] </ref>, who showed that Linux can be converted to run as a server under L4 at little run-time cost. <p> Making direct comparisons between these systems is difficult, as Mungi's superior performance is a result of the use of a fast microkernel as well as the inherent advantages of the SASOS model. However, it has recently been shown <ref> [40] </ref> that Linux can be run as a server on L4 with essentially unchanged performance. We conclude that whether Linux runs native or as a server on L4 makes little difference in performance. We also compare Mungi with Opal where possible.
Reference: [41] <editor> J. Liedtke. Clans & chiefs. </editor> <booktitle> In 12. GI/ITG-Fachtagung Architektur von Rechensystemen, </booktitle> <pages> pages 294-305, </pages> <address> Kiel, 1992. </address> <publisher> Springer Verlag. </publisher>
Reference-contexts: The only problem that occurs is that it prevents confinement, as we cannot control IPC between user tasks. Ideally, all IPC should go through the Mungi server. L4 actually provides appropriate mechanisms to control IPC <ref> [41] </ref>, but at the cost of doubling the number of IPCs required to implement Mungi system calls, an overhead which is estimated to be up to ten percent on the faster system calls.
Reference: [42] <author> M. J. Feeley, J. S. Chase, and E. D. Lazowska. </author> <title> User-level threads and in-terprocess communication. </title> <type> Technical report 93-02-03, </type> <institution> Department of Computer Science & Engineering, University of Washington, </institution> <address> Seattle, WA 98195, USA, </address> <year> 1993. </year>
Reference-contexts: In a context where threads are created and deleted frequently (and where consequently this cost is most important) this should mostly be the case. Thread deletion is the 22 same cost as thread creation with recycling, i.e., 48 s. Thread times for Opal were published in <ref> [42] </ref> for an R3000-based DECstation (create 140s, delete 230s). However, as no clock speed or SPEC ratings were quoted for that platform, it is hard to compare these figures.
Reference: [43] <author> G. Gonnet and R. Baeza-Yates. </author> <title> Handbook of Algorithms and Data Structures. </title> <publisher> Addison-Wesley, </publisher> <address> 2 nd edition, </address> <year> 1990. </year>
Reference-contexts: Objects Object creation (which, by itself, does not allocate any backing store) costs 60 s in Mungi. Less than one microsecond of that is for the OT update (on a 4-level B + -tree, which is sufficient to hold at least 32 million object descriptors <ref> [43] </ref>). Segment creation in Opal using a recycled inode costs 315 s. Object deletion in Mungi takes 150 s, compared to 900 s in Opal. Only the combination of creation, access and deletion could easily be measured in the UNIX systems.
Reference: [44] <author> R. G. G. Cattell and J. Skeen. </author> <title> Object operations benchmark. </title> <journal> ACM Transactions on Database Systems, </journal> <volume> 17 </volume> <pages> 1-31, </pages> <year> 1992. </year> <month> 33 </month>
Reference-contexts: A typical application would therefore see an even greater difference in performance. OO1 As an approximation to a "real-life" application we implemented the Object Operations ("OO1") benchmark <ref> [44] </ref>. OO1 simulates typical operations in a simple object-oriented database system, which is an example of the class of applications which we believe to benefit most from the SASOS model. Client code invokes a database system to perform lookup, traverse and insert operations on a database. <p> The project was supported by grant no A49330285 under the Australian Research Council's Large Grants scheme. OO1 Implementation Details For our benchmarks we used the "small" database (20,000 parts) defined in <ref> [44] </ref>. The lookup operation consists of searching 1000 random parts in the database; the database server is invoked once for each part. The insert operation creates 100 new parts in the database and connects each to 3 random parts.
References-found: 44

