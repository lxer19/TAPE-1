URL: http://HTTP.CS.Berkeley.EDU/~nweaver/generators.ps
Refering-URL: 
Root-URL: 
Title: Object Oriented Circuit-Generators in Java  
Author: Michael Chu Nicholas Weaver Kolja Sulimma Andre DeHon John Wawrzynek 
Abstract: Generators, parameterized code which produces a digital design, have long been a staple of the VLSI community. In recent years, several Field Programmable Gate Array (FPGA) design tools have adopted generators, as it is a convenient way to specify reusable designs in a familiar programming environment. We have built a generator framework in Java as a basis for programming reconfigurable devices and as a tool to be embedded in larger development systems. In addition to the conventional benefits of generators, this powerful framework allows for partial evaluation, simulation, specialization, and easy inclusion of other automatic services. In order to verify the utility of this system, we have implemented several applications using this framework and compared them with implementations using schematic capture and HDL synthesis. Our system runs significantly faster and produces comparable or superior results when mapped to a target FPGA. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Jonathan Babb, Matthew Frank, Victor Lee, El-liot Waingold, Rajeev Barua, Michael Taylor, Jang Kim, Sirkrishna Devabhaktuni, and Anant Agarwal. </author> <title> The RAW Benchmark Suite: Computation Structures for General Purpose Computing. </title> <booktitle> In IEEE Symposium on Field-Programmable Custom Computing Machines, </booktitle> <address> Napa Valley, CA, </address> <month> April </month> <year> 1997. </year>
Reference-contexts: The current run-time performance is decent but not excellent, requiring 30 seconds to generate an XNF netlist for a 25 cell example, running under JDK1.1.4 on an UltraSPARC2 200. 9 Application #2, portions of the RAW benchmarks The Raw benchmarks <ref> [1] </ref> are a series of micro-benchmarks designed to test reconfigurable devices and development tools. Each benchmark consists of verilog for a single computational cell, verilog for a set of control logic, and a small C program 9 which tiles a specified number of cells together.
Reference: [2] <author> Patrice Bertin and Herve Touati. </author> <title> "PAM Programming Environments: Practice and Experience". </title> <booktitle> In IEEE Workshop on FPGAs for Custom Computing Machines, </booktitle> <address> Napa Valley, CA, </address> <month> April </month> <year> 1994. </year>
Reference-contexts: As an additional benefit, the programmer may use the full expressive power of the language to express and encapsulate his choices. These benefits are well understood and have been the rationale behind several systems including Digital's PamDC [4], its predecessor <ref> [2] </ref>, the PAM-Blox system [7] and National Semiconductor's D4 language [8]. Other development systems, such as the Cadence tool-suite, encourage developers to create ad-hoc generators such as short scripts which tile small components to form a large array.
Reference: [3] <author> James Gosling, Bill Joy, and Guy Steele. </author> <title> The Java Language Specification. </title> <publisher> Addison Wesley, </publisher> <year> 1996. </year>
Reference-contexts: This object must also contain a method for connecting a components inputs and outputs to the subcomponents which make up the design. Finally, it may contain routines to override the default behavior of any automatic service in our system. 2 Generators in Java Java <ref> [3] </ref> is an object oriented programming language designed by Sun Microsystems.
Reference: [4] <author> Tauati Herve and Mark Shand, "PamDC: </author> <title> a C++ Library for the Simulation and Generation of Xilinx FPGA Designs". </title> <address> March 30, </address> <year> 1997. </year> <note> http://www.research.digital.com/SRC/pamette/PamDC.pdf. </note>
Reference-contexts: As an additional benefit, the programmer may use the full expressive power of the language to express and encapsulate his choices. These benefits are well understood and have been the rationale behind several systems including Digital's PamDC <ref> [4] </ref>, its predecessor [2], the PAM-Blox system [7] and National Semiconductor's D4 language [8]. Other development systems, such as the Cadence tool-suite, encourage developers to create ad-hoc generators such as short scripts which tile small components to form a large array.
Reference: [5] <author> Dzung Hoang, </author> <title> "Searching Genetic Databases on Splash 2", </title> <booktitle> in Proceedings of the IEEE Workshop on FPGAs for Custom Computing Machines, </booktitle> <month> April </month> <year> 1993. </year>
Reference-contexts: This problem was one of the primary applications on the Splash systolic array <ref> [5] </ref>. DNA sequence matching is usually implemented as a dynamic programming algorithm designed to calculate edit-distance, with a systolic implementation requiring O (m) space and O (n) time, with m and n being the length of the strings being compared.
Reference: [6] <author> Tom Kean, Bernie New, and Bob Slous, </author> <title> "A Fast Constant Coefficient Multiplier for the XC6200". In Field Programmable Logic 96. </title>
Reference-contexts: For example, it may be comparatively difficult to specify a specialized multiply-by-constant such as the one described in <ref> [6] </ref>, where the multiplier consists of table lookups which are based on the desired constant. Our system makes it comparatively easy to specify such designs, because the program can instantiate arbitrary components based on its program.
Reference: [7] <author> O Mencer, M Morf, and M Flynn, "PAM-Blox: </author> <title> High performance FPGA Design for Adaptive Computing", </title> <booktitle> in Proceedings of the IEEE Symposium on Field Programmable Custom Computing Machine, </booktitle> <month> April </month> <year> 1998. </year>
Reference-contexts: As an additional benefit, the programmer may use the full expressive power of the language to express and encapsulate his choices. These benefits are well understood and have been the rationale behind several systems including Digital's PamDC [4], its predecessor [2], the PAM-Blox system <ref> [7] </ref> and National Semiconductor's D4 language [8]. Other development systems, such as the Cadence tool-suite, encourage developers to create ad-hoc generators such as short scripts which tile small components to form a large array. Even more, such as the Xilinx LogicBlox [9] use generators which are hidden from the user.
Reference: [8] <author> Charle Rupp, </author> <note> D4 User's Guide. </note>
Reference-contexts: These benefits are well understood and have been the rationale behind several systems including Digital's PamDC [4], its predecessor [2], the PAM-Blox system [7] and National Semiconductor's D4 language <ref> [8] </ref>. Other development systems, such as the Cadence tool-suite, encourage developers to create ad-hoc generators such as short scripts which tile small components to form a large array. Even more, such as the Xilinx LogicBlox [9] use generators which are hidden from the user.
Reference: [9] <author> Xilinx Corporation, </author> <title> The Programmable Logic Data Book. </title>
Reference-contexts: Other development systems, such as the Cadence tool-suite, encourage developers to create ad-hoc generators such as short scripts which tile small components to form a large array. Even more, such as the Xilinx LogicBlox <ref> [9] </ref> use generators which are hidden from the user. All these existing systems share a common philosophy, where the programmer describes the computation as a series of small logic units and connections, essentially building up netlists out of primitive components. <p> This is because the generic forms in our base library will instantiate array-specific subcom-ponents when possible. Thus, the generic counter will instantiate and benefit from array specific adders. Currently, the generator framework has been used to construct a library for the Xilinx 4000E series <ref> [9] </ref> of Field Programmable Gate Arrays. This library provides several high-level components, including adders, counters, flip-flops, and multipliers. These components are all parameterized, allowing them to implement functional blocks of arbitrary bit-width. A sample of the available library components is listed in Table 1.
References-found: 9

