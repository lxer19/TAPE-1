URL: http://www.cs.indiana.edu/~dyb/papers/popl99.ps.gz
Refering-URL: http://www.cs.indiana.edu/hyplan/dyb.html
Root-URL: http://www.cs.indiana.edu
Email: owaddell@ittc.ukans.edu  dyb@cs.indiana.edu  
Title: Extending the Scope of Syntactic Abstraction  
Author: Oscar Waddell R. Kent Dybvig 
Affiliation: University of Kansas  Indiana University  
Abstract: The benefits of module systems and lexically scoped syntactic abstraction (macro) facilities are well-established in the literature. This paper presents a system that seamlessly integrates modules and lexically scoped macros. The system is fully static, permits mutually recursive modules, and supports separate compilation. We show that more dynamic module facilities are easily implemented at the source level in the extended language supported by the system. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> William Clinger and Jonathan Rees. </author> <title> Macros that work. </title> <booktitle> In Conference Record of the Seventeenth Annaual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 155-162, </pages> <month> January </month> <year> 1991. </year>
Reference-contexts: Queinnec and Padget describe a module language for controlling the visibility of sets of named locations [13, 14]. They describe a high-level macro expansion protocol intended to support various macro system implementations such as expansion-passing style [5] or hygienic systems based on syntactic closures <ref> [1] </ref>. Because their system is not tightly integrated with the macro expander they do not permit nested modules, nor do they permit macros to expand into module constructs. The Dylan programming language [17] supports both modules and lexically scoped macros.
Reference: [2] <author> Pavel Curtis and James Rauen. </author> <title> A module system for Scheme. </title> <booktitle> In Proceedings of the 1990 ACM Conference on LISP and Functional Programming, </booktitle> <pages> pages 13-19, </pages> <month> June </month> <year> 1990. </year>
Reference-contexts: 1 Introduction The benefits of module systems and lexically scoped syntactic abstraction (macro) facilities are well-established [1, 2, 3, 6, 7, 8, 12, 10, 11, 15, 16, 18]. Over the past several years there has been increasing interest in combining lexically scoped macros and modules <ref> [2, 16, 17] </ref>. Building on this work we present here the first fully implemented system that allows arbitrary composition of module and macro facilities, supports separate compilation, and supports fully general macro transformations while maintaining lexical scoping for all macros. <p> To match, the set of marks associated with the fail token must match the set of marks on the identifier. 6 Related Work Our system is similar in some respects to systems described by Curtis and Rauen <ref> [2] </ref> and Rees [16]. Our system is based on simpler core module constructs, however, and derives its expressive power largely via syntactic abstraction.
Reference: [3] <author> Harley Davis, Pierre Parquier, and Nitsan Seniak. </author> <title> Talking about modules and delivery. </title> <booktitle> In Proceedings of the 1994 ACM Conference on LISP and Functional Programming, </booktitle> <pages> pages 113-120, </pages> <year> 1994. </year>
Reference: [4] <author> R. Kent Dybvig. </author> <title> The Scheme Programming Language. </title> <booktitle> Prentice-Hall, second edition, </booktitle> <year> 1996. </year>
Reference-contexts: Our system extends the small core language and powerful syntactic abstraction mechanisms of the syntax-case system <ref> [4, 6] </ref> with support for modules. A module is a named scope that encapsulates a set of identifier bindings. Importing from a module makes these identifier bindings visible in the importing context. <p> [( n defs) (with-implicit (n a b) #'(module n (a b) . defs))] [( (expand-exports i-name mac)) 1 with-implicit, used here to ensure that the introduced export identifiers are visible in the same scope as the name of the module in the define-module form, is implemented in terms of datum-&gt;syntax-object <ref> [4, 6] </ref>. The reader syntax #'hformi expands into (syntax hformi). 4 (with-implicit (i-name a b) #'(mac i-name a b))]))) The second clause of this macro provides a simple mechanism for reflecting on the interface. <p> Even conservative analysis is impossible if transformers are able to synthesize new identifiers from existing identifiers, e.g., using datum-&gt;syntax-object <ref> [4, 6] </ref>. <p> Second, our mechanism for intentional capture, datum-&gt;syntax-object, is sufficiently powerful that all identifiers are potential implicit exports, as demonstrated in Section 5.2. While Dylan provides a limited form of intentional capture via the macro template modifier ?=, this is insufficient to express macros such as include <ref> [4] </ref>. Flatt and Felleisen propose a system for dynamically linking separately compiled program units [7, 8]. While it does not permit the export of macros, the unit facility is interesting as representative of systems providing both higher-order modules and programmatic control over linking.
Reference: [5] <author> R. Kent Dybvig, Daniel P. Friedman, and Christo-pher T. Haynes. </author> <title> Expansion-passing style: A general macro mechanism. </title> <journal> Lisp and Symbolic Computation, </journal> <volume> 1(1) </volume> <pages> 53-75, </pages> <year> 1988. </year>
Reference-contexts: Queinnec and Padget describe a module language for controlling the visibility of sets of named locations [13, 14]. They describe a high-level macro expansion protocol intended to support various macro system implementations such as expansion-passing style <ref> [5] </ref> or hygienic systems based on syntactic closures [1]. Because their system is not tightly integrated with the macro expander they do not permit nested modules, nor do they permit macros to expand into module constructs. The Dylan programming language [17] supports both modules and lexically scoped macros.
Reference: [6] <author> R. Kent Dybvig, Robert Hieb, and Carl Bruggeman. </author> <title> Syntactic abstraction in Scheme. </title> <journal> Lisp and Symbolic Computation, </journal> <volume> 5(4) </volume> <pages> 295-326, </pages> <year> 1993. </year>
Reference-contexts: Our system extends the small core language and powerful syntactic abstraction mechanisms of the syntax-case system <ref> [4, 6] </ref> with support for modules. A module is a named scope that encapsulates a set of identifier bindings. Importing from a module makes these identifier bindings visible in the importing context. <p> [( n defs) (with-implicit (n a b) #'(module n (a b) . defs))] [( (expand-exports i-name mac)) 1 with-implicit, used here to ensure that the introduced export identifiers are visible in the same scope as the name of the module in the define-module form, is implemented in terms of datum-&gt;syntax-object <ref> [4, 6] </ref>. The reader syntax #'hformi expands into (syntax hformi). 4 (with-implicit (i-name a b) #'(mac i-name a b))]))) The second clause of this macro provides a simple mechanism for reflecting on the interface. <p> Subject to this restriction, the implementations may be separately compiled. The compiled interface of an abstract module must be loaded before attempting to use its compiled implementation. 4 Implementation The module system is implemented by extending the syntax-case macro system <ref> [6] </ref>. Section 4.1 describes the existing macro system, and Section 4.2 shows how the macro system is extended to support modules. 4.1 The syntax-case system As described in Section 2.3, a source program is translated into the core language before it is compiled. <p> Even conservative analysis is impossible if transformers are able to synthesize new identifiers from existing identifiers, e.g., using datum-&gt;syntax-object <ref> [4, 6] </ref>.
Reference: [7] <author> Robert Bruce Findler and Matthew Flatt. </author> <title> Modular object-oriented programming with units and mixins. </title> <booktitle> In Proceedings of the 1998 ACM SIGPLAN International Conference on Functional Programming, </booktitle> <pages> pages 94-104, </pages> <month> September </month> <year> 1998. </year>
Reference-contexts: While Dylan provides a limited form of intentional capture via the macro template modifier ?=, this is insufficient to express macros such as include [4]. Flatt and Felleisen propose a system for dynamically linking separately compiled program units <ref> [7, 8] </ref>. While it does not permit the export of macros, the unit facility is interesting as representative of systems providing both higher-order modules and programmatic control over linking. They argue against module linkage via static import and instead propose a mechanism that provides programmatic control over module linkage.
Reference: [8] <author> Matthew Flatt and Matthias Felleisen. </author> <title> Units: Cool modules for HOT languages. </title> <booktitle> In Proceedings of the ACM SIGPLAN '98 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 236-248, </pages> <month> June </month> <year> 1998. </year>
Reference-contexts: While Dylan provides a limited form of intentional capture via the macro template modifier ?=, this is insufficient to express macros such as include [4]. Flatt and Felleisen propose a system for dynamically linking separately compiled program units <ref> [7, 8] </ref>. While it does not permit the export of macros, the unit facility is interesting as representative of systems providing both higher-order modules and programmatic control over linking. They argue against module linkage via static import and instead propose a mechanism that provides programmatic control over module linkage.
Reference: [9] <editor> Richard Kelsey, William Clinger, and Jonathan A. Rees (Editors). </editor> <title> Revised 5 report on the algorithmic language Scheme. </title> <journal> SIGPLAN Notices, </journal> <volume> 33(9) </volume> <pages> 26-76, </pages> <year> 1998. </year>
Reference-contexts: Section 6 discusses related work, and Section 7 presents our conclusions. 2 Language 2.1 Syntax The core language of the syntax-case system is the core language of the Revised 5 Report on Scheme <ref> [9] </ref>.
Reference: [10] <author> Eugene Kohlbecker, Daniel P. Friedman, Matthias Felleisen, and Bruce Duba. </author> <title> Hygienic macro expansion. </title> <booktitle> In Proceedings of the 1986 ACM Conference on LISP and Functional Programming, </booktitle> <pages> pages 151-161, </pages> <year> 1986. </year>
Reference: [11] <author> Eugene E. Kohlbecker. </author> <title> Syntactic Extensions in the Programming Language Lisp. </title> <type> PhD thesis, </type> <institution> Indiana University, Bloomington, Indiana, </institution> <year> 1986. </year>
Reference: [12] <author> David MacQueen. </author> <title> Modules for standard ML. </title> <booktitle> In Conference Record of the 1984 ACM Symposium on LISP and Functional Programming, </booktitle> <pages> pages 198-207, </pages> <year> 1984. </year>
Reference: [13] <author> Christian Queinnec and Julian Padget. </author> <title> A deterministic model for modules and macros. </title> <type> Bath Computing Group Technical Report 90-36, </type> <institution> University of Bath, Bath (UK), </institution> <year> 1990. </year>
Reference-contexts: This is a useful feature that our system currently lacks, although nothing in our system precludes support for such a feature. Queinnec and Padget describe a module language for controlling the visibility of sets of named locations <ref> [13, 14] </ref>. They describe a high-level macro expansion protocol intended to support various macro system implementations such as expansion-passing style [5] or hygienic systems based on syntactic closures [1].
Reference: [14] <author> Christian Queinnec and Julian Padget. </author> <title> Modules, macros and Lisp. </title> <booktitle> In Eleventh International Conference of the Chilean Computer Science Society, </booktitle> <pages> pages 111-123, </pages> <address> Santiago (Chile), October 1991. </address> <publisher> Plenum Publishing Corporation, </publisher> <address> New York NY (USA). </address>
Reference-contexts: This is a useful feature that our system currently lacks, although nothing in our system precludes support for such a feature. Queinnec and Padget describe a module language for controlling the visibility of sets of named locations <ref> [13, 14] </ref>. They describe a high-level macro expansion protocol intended to support various macro system implementations such as expansion-passing style [5] or hygienic systems based on syntactic closures [1].
Reference: [15] <author> Jonathan Rees. </author> <title> Modular macros. </title> <type> Master's thesis, </type> <institution> Mas-sachusetts Institute of Technology, </institution> <month> May </month> <year> 1989. </year>
Reference: [16] <author> Jonathan Rees. </author> <title> Another Module System for Scheme. </title> <institution> Massachusetts Institute of Technology, </institution> <year> 1994. </year> <title> Scheme 48 documentation. </title>
Reference-contexts: 1 Introduction The benefits of module systems and lexically scoped syntactic abstraction (macro) facilities are well-established [1, 2, 3, 6, 7, 8, 12, 10, 11, 15, 16, 18]. Over the past several years there has been increasing interest in combining lexically scoped macros and modules <ref> [2, 16, 17] </ref>. Building on this work we present here the first fully implemented system that allows arbitrary composition of module and macro facilities, supports separate compilation, and supports fully general macro transformations while maintaining lexical scoping for all macros. <p> To match, the set of marks associated with the fail token must match the set of marks on the identifier. 6 Related Work Our system is similar in some respects to systems described by Curtis and Rauen [2] and Rees <ref> [16] </ref>. Our system is based on simpler core module constructs, however, and derives its expressive power largely via syntactic abstraction. While the other systems build in support for separation of interface from implementation, for example, our system allows multiple interface separation mechanisms to be created via syntactic abstraction.
Reference: [17] <author> Andrew Shalit. </author> <title> The Dylan Reference Manual. </title> <publisher> Addison Wesley Longman, </publisher> <year> 1996. </year>
Reference-contexts: 1 Introduction The benefits of module systems and lexically scoped syntactic abstraction (macro) facilities are well-established [1, 2, 3, 6, 7, 8, 12, 10, 11, 15, 16, 18]. Over the past several years there has been increasing interest in combining lexically scoped macros and modules <ref> [2, 16, 17] </ref>. Building on this work we present here the first fully implemented system that allows arbitrary composition of module and macro facilities, supports separate compilation, and supports fully general macro transformations while maintaining lexical scoping for all macros. <p> Because their system is not tightly integrated with the macro expander they do not permit nested modules, nor do they permit macros to expand into module constructs. The Dylan programming language <ref> [17] </ref> supports both modules and lexically scoped macros. Their macro system is more restrictive in its treatment of symbols and identifiers. Macro and module definitions can appear only at the top level of a compilation unit (library), and import is tied to the module syntax, limiting expressiveness.
Reference: [18] <author> Sho-Huan Simon Tung and R. Kent Dybvig. </author> <title> Reliable interactive programming with modules. </title> <journal> Lisp and Symbolic Computation, </journal> <volume> 9(4) </volume> <pages> 343-358, </pages> <year> 1996. </year> <month> 11 </month>
References-found: 18

