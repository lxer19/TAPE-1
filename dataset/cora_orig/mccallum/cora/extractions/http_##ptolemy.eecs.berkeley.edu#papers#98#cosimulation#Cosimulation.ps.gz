URL: http://ptolemy.eecs.berkeley.edu/papers/98/cosimulation/Cosimulation.ps.gz
Refering-URL: http://ptolemy.eecs.berkeley.edu/papers/98/cosimulation/
Root-URL: 
Date: 15-18 March 1998 1  
Address: CODES/CASHE98, Seattle, Washington [USA],  
Note: 6th International Workshop on Hardware/Software Co-Design,  
Abstract: Timing analysis for checking satisfaction of constraints is a crucial problem in real-time system design. In some current approaches, the delay of software modules is precalcu-lated by a software performance estimation method, which is not accurate enough for hard real-time systems and complicated designs. In this paper, we present an approach to integrate a clock-cycle-accurate instruction set simulator (ISS) with a fast event-based system simulator. By using the ISS, the delay of events can be measured instead of estimated. An interprocess communication architecture and a simple protocol are designed to meet the requirement of robustness and exibility. A cached refinement scheme is presented to improve the performance at the expense of accuracy. The scheme is especially effective for applications in which the delay of basic blocks is approximately data-independent. We also discuss the implementation issues by using the Ptolemy simulation environment and the ST20 simulator as an example. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> F. Balarin, M. Chiodo, </author> <title> etc. Hardware-Software Co-design of Embedded Systems, </title> <publisher> Kluwer Academic Publishers, </publisher> <year> 1997 </year>
Reference-contexts: So it is essential for the simulator to use timing information for each module, especially software modules, which is as close to reality as possible. An incorrect delay may cause the simulation result to differ from the behavior of the implemented system. Polis <ref> [1] </ref> is a hardware/software codesign environment for control dominated embedded systems. Polis is based on a formal model of computation called codesign finite state machine (CFSM). In Polis, systems are modeled as a group of communicating CFSMs, each of which is originally described in a formal language. e.g. <p> Our approach is close to [4], but we determine which basic blocks are used at run-time by using a delay caching technique. Our approach is to leverage on an existing approach to time-approximate cosimulation <ref> [1] </ref> , based on source-code estimation of execution time, and refine its precision by using an ISS. In particular, we do not require the designer to change the system specification.
Reference: [2] <institution> Ptolemy Home Page, </institution> <note> http://ptolemy.eecs.berkeley.edu </note>
Reference-contexts: In Polis, systems are modeled as a group of communicating CFSMs, each of which is originally described in a formal language. e.g. Esterel [3] . In the simulations phase, both hardware and software modules are simulated in the Ptolemy environment. Ptolemy <ref> [2] </ref> is a complete design environment for simulation and synthesis of mixed hardware-software embedded systems. In Ptolemy jargon, each functional block (a software or a hardware module) is called a star. Each star has one or more input and output ports.
Reference: [3] <institution> Esterel Home Page, </institution> <note> http://www.inria.tr/meije/esterel </note>
Reference-contexts: Polis is based on a formal model of computation called codesign finite state machine (CFSM). In Polis, systems are modeled as a group of communicating CFSMs, each of which is originally described in a formal language. e.g. Esterel <ref> [3] </ref> . In the simulations phase, both hardware and software modules are simulated in the Ptolemy environment. Ptolemy [2] is a complete design environment for simulation and synthesis of mixed hardware-software embedded systems. In Ptolemy jargon, each functional block (a software or a hardware module) is called a star.
Reference: [4] <author> R. Ernst, W. Ye, </author> <title> Embedded Program Timing Analysis Based on Path Clustering and architecture classification, </title> <journal> Proceedings of ICCAD, Nov. </journal> <volume> 97, </volume> <pages> PP 598-60 </pages>
Reference-contexts: As the co-verification progresses, larger amounts of memory access can be optimized gradually, further speeding up the software execution. The link with an ISS is not only applicable to hardware software cosimulation, but also useful for the general problem of embedded program timing analysis. For example, in <ref> [4] </ref> an approach which combines simulation with formal techniques is presented. They address the timing analysis problem by trying to approach each step in the analysis with the best methods currently known. <p> The ISS is run only once on all basic blocks in the program and then the information collected is used with a formal analysis to determine the worst case execution time of the program. Our approach is close to <ref> [4] </ref>, but we determine which basic blocks are used at run-time by using a delay caching technique. Our approach is to leverage on an existing approach to time-approximate cosimulation [1] , based on source-code estimation of execution time, and refine its precision by using an ISS.
Reference: [5] <author> K. ten Hagen, H. Meyr, </author> <title> Timed and Untimed Hardware Software Cosimulation: Application and Efficient Implementation, </title> <booktitle> Proc. of Int. Workshop on Hardware-Software Codesign, </booktitle> <month> Oct. </month> <year> 1993 </year>
Reference-contexts: This requires the use of handshaking protocols, which may impose an undue burden on the implementation. This may happen, for example, because hardware and software would not need such handshaking since the hardware part runs in reality much faster than in simulation. In <ref> [5] </ref> a method, which keeps track of time in software and hardware independently and synchronizes them periodically, is described. In [7] an optimistic and non-IPC approach for improving the performance of single-processor timed cosimulation are presented.
Reference: [6] <author> E. A. Lee and A. Sangiovanni-Vincentelli, </author> <title> A Denotational Framework for Comparing Models of Computation, </title> <institution> ERL Memorandum UCB/ERL M97/11, University of California, Berkeley, </institution> <address> CA 94720, </address> <month> January 30, </month> <year> 1997. </year>
Reference-contexts: Although this approximation reduces the accuracy, the simulation execution time can be dramatically improved. 4.2. The Ptolemy Discrete Event Domain The semantics of Ptolemy DE domain <ref> [6] </ref> is that all signals (events) have two fields, a tag and a value. The tag is the timestamp, which is totally ordered among all the events. A star simply receives events from its the input ports and generates events to its output ports.
Reference: [7] <author> S. Leef, </author> <title> Hardware and Software Co-Verification Key to Co-Design, </title> <booktitle> Electronic Design, </booktitle> <month> September 15, </month> <year> 1997, </year> <pages> PP 67-71 </pages>
Reference-contexts: This may happen, for example, because hardware and software would not need such handshaking since the hardware part runs in reality much faster than in simulation. In [5] a method, which keeps track of time in software and hardware independently and synchronizes them periodically, is described. In <ref> [7] </ref> an optimistic and non-IPC approach for improving the performance of single-processor timed cosimulation are presented. The biggest problem with all the current strategies is how to optimize the communication overhead required to synchronize the execution of the ISS and hardware simulator.
Reference: [8] <author> C. Passerone, L.Lavagno, </author> <title> etc. Trade-off Evaluation in Embedded System Design via Co-simulation. </title> <booktitle> Proceedings of ASP-DAC, </booktitle> <year> 1997, </year> <pages> PP 291-297. </pages>
Reference-contexts: The software performance issue (clock cycles needed for a software module to execute) is involved in step 5 above. Software performance has to be estimated in hardware/ software codesign tools [4][5][10] . The advantages are small simulation overhead, ease of integration, and exibility of porting to multiple microprocessors <ref> [8] </ref> . The disadvantage is the poor accuracy. For hard real-time embedded system, it is crucial to provide accurate timing information during the simulation phase. Instruction Set Simulators (ISS) are software environments which can read microprocessor instructions and simulate their execution.
Reference: [9] <editor> J. Rowson, Hardware/Software Co-simulation, </editor> <booktitle> Proceedings of DAC, </booktitle> <year> 1994, </year> <pages> PP 439-440. </pages>
Reference-contexts: Related Approaches Although the idea of performing a hardware/software cosimulation by combining RTL hardware simulation with cycle accurate instruction set simulators (ISS) is not new, a seamless integration of the two environments with high accuracy and good performance is still an unsolved problem. In <ref> [9] </ref> a method which loosely links a hardware simulator with a software process is proposed. Synchronization is achieved by using the standard interprocess communication (IPC) mechanisms offered by the host operating system.
Reference: [10] <author> K. Suzuki and A. Sangiovanni-Vincentelli, </author> <title> Efficient Software Performance Estimation Methods for Hardware/Software Codesign, </title> <booktitle> Proceedings of DAC, </booktitle> <year> 1996, </year> <month> PP605-610. </month>
Reference-contexts: Implementation A prototype of this scheme has been implemented by using the Ptolemy and the ST20 Toolset [11] . Two parameters are added for each star to allow users to choose the delay calculation method--that of <ref> [10] </ref>, cached refinement, and uncached refinement. A hash table is used to record and retrieve the path delay. <p> estimation and the ISS are shown in Table 2 and Table 3 respectively, where dctA is the ag of detecting an input A; A stands for the value of input A; output is the termination point with 0 for END; estimated is the clock cycles obtained from the method of <ref> [10] </ref>; and measured is that from the ISS. COMPARE is a module without function calls, where the compiler optimization make the delay of an entire path to be less than the delay of the sum of each node. <p> The experiments are done on a SPARC20 workstation. For a simulation of 100 firings of COMPARE or ADDER, despite the time of starting the ISS (approximately 3 Sec.), the cached timing analysis is about 10 times slower than that of <ref> [10] </ref>, but 1000 times faster than the non-cached exact timing analysis. 6. Conclusion In this paper, an ISS-based timing refinement scheme is studied in the context of the Polis codesign approach. By using the ISS, some intrinsic problems of software performance estimation are solved.
Reference: [11] <author> ST20 Osprey Toolset: </author> <title> User Manual, </title> <publisher> SGS-THOMSON Electronics, </publisher> <month> March </month> <year> 1997 </year>
Reference-contexts: Both activities outlined are still at a very preliminary stage, but the results seem quite promising. 5. Implementation A prototype of this scheme has been implemented by using the Ptolemy and the ST20 Toolset <ref> [11] </ref> . Two parameters are added for each star to allow users to choose the delay calculation method--that of [10], cached refinement, and uncached refinement. A hash table is used to record and retrieve the path delay.
Reference: [12] <author> S. Yoo, K. Choi, </author> <title> Synchronization Overhead Reduction in Timed Cosimulation, </title> <booktitle> Proc. of Int. High Level Design Validation. </booktitle> <volume> Table 2: COMPARE MODULE state dctA dctB output estimated measured 0 - 57 51 1 0 1 0 77 59 1 1 1 1 106 56 2 - 0 0 67 49 2 - 1 2 98 58 3 1 - 1 100 61 Table 3: ADDER MODULE state dctA A B output estimated measured 0 - 0.1 0 120 114 1 1 0 0 1 887 392 1 1 2.3e12 5.3e8 1 887 790 </volume>
Reference-contexts: The other typical drawback of this approach is that the system has to be recompiled and resynthesized when the partition is changed. The commercial tool Mentor-Seamless CVE <ref> [12] </ref> can offer a certain number of optimization techniques such as an instruction-fetch optimization that can directly fetch operations to the memory-image server, thus eliminating these cycles from the logic simulator workload.
References-found: 12

