URL: http://osl.cs.uiuc.edu/Papers/hal-icpp-language.ps
Refering-URL: http://osl.cs.uiuc.edu/Papers/Language.html
Root-URL: http://www.cs.uiuc.edu
Email: Email: fhouck j aghag@cs.uiuc.edu  
Title: HAL: A High-level Actor Language and Its Distributed Implementation  
Author: Chris Houck and Gul Agha 
Address: Urbana, IL 61801, USA  
Affiliation: Department of Computer Science University of Illinois at Urbana-Champaign  
Abstract: We describe Hal, a high-level, actor-based language which has served as a test-bed for experimenting with powerful linguistic constructs for par allel and distributed programming. Hal is an architecture independent, concurrent object-oriented language which supports inheritance, synchronization constraints, continuation capture, synchronous and asynchronous message passing, and reflection. The Hal compiler has been used to execute actor programs on a number of shared and distributed memory machines. Hal allows powerful abstractions to be defined and reused. Furthermore, Hal supports the use of synchronization constraints at a fine-grained level and the use of software pipelining. In this paper, we describe the design of Hal, using specific examples to illustrate its features. We then discuss some of the implementation issues in the run-time system. Keywords: Actors, Concurrency, Object-Oriented Languages, Distributed Execution. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> G. Agha. </author> <title> Actors: A Model of Concurrent Computation in Distributed Systems. </title> <publisher> MIT Press, </publisher> <year> 1986. </year>
Reference-contexts: 1 Introduction The actor model is a flexible model of concurrent computation in distributed systems <ref> [1] </ref>. Specifically, actors can be thought of as an abstract representation for multicomputer architectures. <p> Section 6 discusses our compiler and run-time system implementation. Conclusions and future directions are outlined in Section 7. 2 The Actor Model Actors are self-contained, interacting, independent components of a computing system that communicate by asynchronous message passing <ref> [1] </ref>. Each actor has a mail address and a behavior. The acquaintances of a given actor are the actors whose mail addresses are known by the actor. The mail addresses of actors may be contained in messages, leading to a dynamic actor interconnection topology. <p> The update statement can be used to specify less dramatic changes in an actor's state. The expression (update A B) binds the variable A to B for the next message (actor state changes only go into effect for the next message that they process <ref> [1] </ref>). The canonical example of actor behavior is a simulation of a bank account. A bank account may change its state as money is deposited or withdrawn . In addition, a bank account may be shared between one or more actors. <p> Can tor, POOL and Emerald can be run in a limited num ber of distributed environments. CHARM is one of the few languages that is reasonably architecture independent. This fact was the primary motivation for basing the Hal run-time system on CHARM. 4 Language Features The basic actor model <ref> [1] </ref> is a fairly low-level model, without predefined abstraction mechanisms and linguistic features necessary for non-trivial programming. We have therefore introduced a number of syntactic constructions to make programming easier. High level descriptions of these features will be discussed in the rest of this section. <p> The reliance on CHARM implies that a number of aspects of the actor model are sacrificed, the most serious being internal concurrency. The actor model allows the expressions that make up a single method to be executed concurrently <ref> [1] </ref>. It is obvious that simply building an actor compiler is insufficient for distributed execution of actor programs; a run-time system must also be provided. For example, it is necessary to provide facilities for address lookup and resource management problems among others.
Reference: [2] <author> G. Agha, S. Frtlund, R. Panwar, and D. Sturman. </author> <title> A linguistic framework for dynamic composition of fault-tolerance protocols. </title> <type> Technical Report UIUC DCS-R-92-1730, </type> <institution> University of Illinois at Urbana-Champaign, </institution> <month> April </month> <year> 1992. </year>
Reference-contexts: A message to an actor is received by its (reified) mailq. Once the mailq actor processes the message, it forwards the message to the original recipient. The current reflective architec ture is sufficient to implement a number of significant examples including a meta-architecture for fault-tolerance <ref> [2] </ref>. 5 Examples 5.1 Software Pipelining The actor model provides for a means of increasing program efficiency by supporting a high degree of software pipelining. In [3], implementations of a Cholesky Decomposition of a symmetric positive definite matrix were explored in order to demonstrate the benefits of pipelining. <p> Our implementation of Dispatcher makes no refernce to its base actor; therefore, many actors could share the same meta-dispatcher providing a limited form of groupwide reflection [21]. Hal has also been used to experiment with implementing dependability protocols at the meta level thus providing a separation of design concerns <ref> [2] </ref>. One of the design motivations for Hal was to create a platform to test out theoretical ideas.
Reference: [3] <author> G. Agha, C. Houck, and R. Panwar. </author> <title> Distributed execution of actor systems. </title> <booktitle> In Proceedings of Fourth Workshop on Languages and Compilers for Parallel Computing, </booktitle> <address> Santa Clara, </address> <year> 1991. </year>
Reference-contexts: A proposed optimization would create dependency lists between the actor's state variables and the constraints to reduce the number of constraint expressions which need to be retested. The (constrain...) construct may be used to order messages of a certain type. This ability is useful in many numeric computations <ref> [3] </ref> where multiple iterations of an algorithm may be active concurrently but execution ordering must be maintained. This style of constraint specification makes code more reusable as will be seen in Section 4.4. However, it only offers a hold/deliver decision procedure. <p> The current reflective architec ture is sufficient to implement a number of significant examples including a meta-architecture for fault-tolerance [2]. 5 Examples 5.1 Software Pipelining The actor model provides for a means of increasing program efficiency by supporting a high degree of software pipelining. In <ref> [3] </ref>, implementations of a Cholesky Decomposition of a symmetric positive definite matrix were explored in order to demonstrate the benefits of pipelining. Using an actor based programming style can lead to programs that monotonically improve in performance.
Reference: [4] <author> P. </author> <title> America. Issues in the design of a parallel object-oriented language. </title> <journal> Formal Aspects of Computing, </journal> <volume> 1(4) </volume> <pages> 366-411, </pages> <year> 1989. </year>
Reference-contexts: CHARM and Cantor allow only asynchronous message passing while, in Emerald, all invocations are synchronous. The POOL languages vary in their support for message passing styles. It appears as though some dialects (POOL2) allow only asynchronous message passing <ref> [4] </ref>, while others (POOL-I) allow only synchronous messages [5]. Perhaps the most surprising aspect of these concurrent languages is that many of them are not portable. For example, ACBL/1, Rosette and Acore are run on uniprocessor virtual machines (though ABCL/1 is currently being ported to the EM-4 platform).
Reference: [5] <author> P. America and F. van der Linden. </author> <title> A parallel object-oriented language with inheritance and subtyping. </title> <booktitle> In OOPSLA '90, </booktitle> <pages> pages 161-168, </pages> <month> October </month> <year> 1990. </year>
Reference-contexts: In Rosette [18], these constraints take the form of enabled-sets which are specified inline. This mixing of code and enabledness conditions greatly reduces the reusability of inherited code. ABCL/1 also places synchronization issues within the scope of method definitions. In POOL <ref> [5] </ref>, the body of an object is responsible for maintaining object consistency. However, object bodies are not inheritable; therefore, synchronization constraints must be repeatedly specified. Another important aspect of a language's programmability is the types of message passing styles supported. <p> CHARM and Cantor allow only asynchronous message passing while, in Emerald, all invocations are synchronous. The POOL languages vary in their support for message passing styles. It appears as though some dialects (POOL2) allow only asynchronous message passing [4], while others (POOL-I) allow only synchronous messages <ref> [5] </ref>. Perhaps the most surprising aspect of these concurrent languages is that many of them are not portable. For example, ACBL/1, Rosette and Acore are run on uniprocessor virtual machines (though ABCL/1 is currently being ported to the EM-4 platform).
Reference: [6] <author> W. Athas and C. Seitz. </author> <title> Cantor user report version 2.0. </title> <type> Technical Report 5232:TR:86, </type> <institution> California Insti-ture of Technology, Pasadena, </institution> <address> CA, </address> <month> January </month> <year> 1987. </year>
Reference-contexts: Although such simulations are a useful tool for some purposes, a number of issues such as load balancing and distributed garbage collection are harder to realistically emulate. On the other hand, a number of other concurrent languages available on distributed memory machines are generally not portable <ref> [6, 12] </ref>, thus limiting the their utility. This paper describes an architecture independent actor system called Hal. Hal programs have been run on shared memory, distributed memory and uniprocessor architectures. We focus on issues of compilation and the necessary run-time support needed to execute actor based programs. <p> (define-Actor Bank-Account (slots balance) (method (deposit amount) (update balance (+ balance amount)) (print "Deposited %d"n" amount)) (method (withdraw amount) (let* [[newBal (- balance amount)]] (update balance newBal) (print "Withdrew %d"n" amount) (print "Balance %d"n" newBal))) (method (get-balance) (print "Balance %d"n" balance)) concurrent programming languages, (e.g., CHARM [15], Acore [17], Cantor <ref> [6] </ref>, Emerald [12] and ABCL/1 [23]) do not incorporate inheritance. In our view, it is important to study the use of inheritance in concurrent systems. In particular, synchronization constraints (described below) can interfere with inheritance in concurrent systems.
Reference: [7] <author> A. Chien. </author> <title> Concurrent Aggregates: An Object-Oriented Language for Fine-Grained Message-Passing Machines. </title> <type> PhD thesis, </type> <institution> MIT, </institution> <month> July </month> <year> 1990. </year>
Reference-contexts: Automatic forwarding may be used to provide a global service while only requiring clients to know the addresses of the local representative. In this way, we have been able to build primitive forms of Concurrent Aggregates (CA) <ref> [7] </ref>. A CA is a multi-object struc ture: when a message arrives at an object in a CA the object forwards the message to the members of the aggregate responsible for processing that particular message.
Reference: [8] <author> W. Fenton, B. Ramkumar, V.A. Saletore, A.B. Sinha, and L.V.Kale. </author> <title> Supporting machine independent programming on diverse parallel architectures. </title> <booktitle> In Proceedings of the International Conference on Parallel Processing, </booktitle> <pages> pages 193-201, </pages> <month> August, </month> <year> 1991. </year>
Reference-contexts: We focus on issues of compilation and the necessary run-time support needed to execute actor based programs. Architecture independence has been achieved by compiling Hal source code down to an existing architecture independent parallel processing environment called CHARM <ref> [8] </ref>. Hal has served as a test-bed for experimenting with new language constructs and dependability methods. This paper discusses some of the more interesting linguistic extensions that have been made to the basic actor model. We have found that these extensions greatly increase the flexibility and reusability of Hal programs. <p> A CHARM source program only needs to be recompiled to be transferred between many existing shared memory and distributed memory architectures <ref> [8] </ref>. The reliance on CHARM implies that a number of aspects of the actor model are sacrificed, the most serious being internal concurrency. The actor model allows the expressions that make up a single method to be executed concurrently [1]. <p> The user can just write code in terms of rpc-sends . 7 Results and Future Research The Hal system is based on CHARM which has been implemented on both shared and nonshared memory machines including Sequent Balance and Symmetry, Encore Multimax, Alliant FX/8, Intel iPSC/2, iPSC/i860 and NCUBE/2 <ref> [8] </ref>. As a result, Hal programs are expected to run on all such machines. Hal programs have been tested on uniprocessor, Encore Multimax and Intel iPSC/2 architectures.
Reference: [9] <author> N. Francez. </author> <title> Fairness. Texts and Monographs in Computer Science. </title> <publisher> Springer-Verlag, </publisher> <year> 1986. </year>
Reference-contexts: If &lt;expr&gt; is FALSE , the mail message is added to a local Pending queue and reevaluated later. Currently, whenever the state of an actor changes the constraints of all of the messages on Pending queue are checked, providing strong fairness <ref> [9] </ref>. A proposed optimization would create dependency lists between the actor's state variables and the constraints to reduce the number of constraint expressions which need to be retested. The (constrain...) construct may be used to order messages of a certain type.
Reference: [10] <author> S. Frtlund. </author> <title> Inheritance of synchronization constraints in concurrent object-oriented programming languages. </title> <note> To appear at ECOOP 1992. </note>
Reference-contexts: Going back to the bank account example, this may occur if a withdraw message arrives when the account balance is zero. Some form of synchronization constraint must be placed on the bank account actor to specify when withdraw messages are "serviceable" <ref> [10] </ref>. The following syntax is used to specify acceptance constraints as a function of the actor's state and the contents of the message: (constrain &lt;msg-expr&gt; &lt;expr&gt;) where &lt;msg-expr&gt; specifies a message name and bindings of message values, so that they may be used in testing the constraints. <p> However, while the code of one's ancestor may be overwritten in the style of Smalltalk [16], we have adopted the view that an ancestor's synchronization constraints may never be over-written; they are always in effect <ref> [10] </ref>. In this sense, inheritance is viewed as a means of specialization. An example of how inheritance and synchronization constraints interact will be seen in Section 5.2. 4.5 Reflection One of the fundamental aspects of open systems is that they are extensible.
Reference: [11] <author> C. Houck. </author> <title> Run-time system support for distributed actor programs. </title> <type> Master's thesis, </type> <institution> University of Illinois at Urbana-Champaign, </institution> <month> May </month> <year> 1992. </year>
Reference-contexts: Hal is an object-oriented language with a lisp-like syntax which is compiled to C code and executed using the CHARM programming system [15]. The full syntax of Hal can be found in <ref> [11] </ref>. Hal is loosely based on the previous actor languages Rosette [18], Acore [17] and ABCL/1 [23]. In Hal, there are two primitives to modify an actor's state. A change in an actor's behavior definition is specified through the become command.
Reference: [12] <author> N. Hutchinson, R. Raj, A. Black, H. Levy, and E. </author> <month> Jul. </month> <title> The emerald programming language REPORT. </title> <type> Technical Report 87-10-07, </type> <institution> University of Washington, </institution> <month> Oc-tober </month> <year> 1987. </year>
Reference-contexts: Although such simulations are a useful tool for some purposes, a number of issues such as load balancing and distributed garbage collection are harder to realistically emulate. On the other hand, a number of other concurrent languages available on distributed memory machines are generally not portable <ref> [6, 12] </ref>, thus limiting the their utility. This paper describes an architecture independent actor system called Hal. Hal programs have been run on shared memory, distributed memory and uniprocessor architectures. We focus on issues of compilation and the necessary run-time support needed to execute actor based programs. <p> (slots balance) (method (deposit amount) (update balance (+ balance amount)) (print "Deposited %d"n" amount)) (method (withdraw amount) (let* [[newBal (- balance amount)]] (update balance newBal) (print "Withdrew %d"n" amount) (print "Balance %d"n" newBal))) (method (get-balance) (print "Balance %d"n" balance)) concurrent programming languages, (e.g., CHARM [15], Acore [17], Cantor [6], Emerald <ref> [12] </ref> and ABCL/1 [23]) do not incorporate inheritance. In our view, it is important to study the use of inheritance in concurrent systems. In particular, synchronization constraints (described below) can interfere with inheritance in concurrent systems.
Reference: [13] <editor> S. Peyton Jones. </editor> <booktitle> The Implementation of Functional Programming Languages. </booktitle> <publisher> Prentice-Hall, </publisher> <year> 1987. </year>
Reference-contexts: Because only explicit message passing is allowed in CHARM [15], we automatically lift synchronous messages and their continuations out of user code in a manner akin to lambda lifting <ref> [13] </ref>. A more detailed description of this problem and our implementation is contained in Section 6.3. 4.4 Inheritance Hal allows for inheritance of both code and synchronization constraints.
Reference: [14] <author> D. Kafura, D. Washabaugh, and J. Nelson. </author> <title> Garbage collecton of actors. </title> <booktitle> In OOPSLA '90, </booktitle> <pages> pages 126-134, </pages> <month> October </month> <year> 1990. </year>
Reference-contexts: The actor model abstracts away from details of memory management; the task is thus left to the run-time system. Actor languages present a unique difficulty for resource management in that it is necessary to determine both the "reachability" and "state" (active or blocked) of an actor <ref> [14] </ref>.
Reference: [15] <author> L. Kale. </author> <title> The CHARM(3.0) Programming Language Manual. </title> <institution> University of Illinois, </institution> <month> October </month> <year> 1991. </year>
Reference-contexts: In order to experiment with distributed implementations of actor programs, we have developed a high-level actor language Hal. Hal is an object-oriented language with a lisp-like syntax which is compiled to C code and executed using the CHARM programming system <ref> [15] </ref>. The full syntax of Hal can be found in [11]. Hal is loosely based on the previous actor languages Rosette [18], Acore [17] and ABCL/1 [23]. In Hal, there are two primitives to modify an actor's state. <p> Unfortunately, many (define-Actor Bank-Account (slots balance) (method (deposit amount) (update balance (+ balance amount)) (print "Deposited %d"n" amount)) (method (withdraw amount) (let* [[newBal (- balance amount)]] (update balance newBal) (print "Withdrew %d"n" amount) (print "Balance %d"n" newBal))) (method (get-balance) (print "Balance %d"n" balance)) concurrent programming languages, (e.g., CHARM <ref> [15] </ref>, Acore [17], Cantor [6], Emerald [12] and ABCL/1 [23]) do not incorporate inheritance. In our view, it is important to study the use of inheritance in concurrent systems. In particular, synchronization constraints (described below) can interfere with inheritance in concurrent systems. <p> Hal extends the basic actor semantics by supporting synchronous communication. In synchronous method invocations, the calling program implicitly blocks and waits for a value to be returned from the actor whose method was invoked. Because only explicit message passing is allowed in CHARM <ref> [15] </ref>, we automatically lift synchronous messages and their continuations out of user code in a manner akin to lambda lifting [13]. A more detailed description of this problem and our implementation is contained in Section 6.3. 4.4 Inheritance Hal allows for inheritance of both code and synchronization constraints. <p> In this case, it has been clearly shown that using reflection to implement fault-tolerance is possible and, from a code complexity standpoint, desirable. 6 An Actor Run-Time System In order to make the compiler and run-time system machine independent, the CHARM system <ref> [15] </ref> is used as the compilation target. A CHARM source program only needs to be recompiled to be transferred between many existing shared memory and distributed memory architectures [8].
Reference: [16] <author> W. LaLonde and J. Pugh. </author> <title> Inside Smalltalk, volume 1. </title> <publisher> Prentice Hall, </publisher> <year> 1990. </year>
Reference-contexts: A more detailed description of this problem and our implementation is contained in Section 6.3. 4.4 Inheritance Hal allows for inheritance of both code and synchronization constraints. However, while the code of one's ancestor may be overwritten in the style of Smalltalk <ref> [16] </ref>, we have adopted the view that an ancestor's synchronization constraints may never be over-written; they are always in effect [10]. In this sense, inheritance is viewed as a means of specialization.
Reference: [17] <author> Carl Manning. Acore: </author> <title> The design of a core actor language and its compiler. </title> <type> Master's thesis, </type> <institution> MIT, Artificial Intelligence Laboratory, </institution> <month> August </month> <year> 1987. </year>
Reference-contexts: Actors are dynamically reconfigurable and extensible and thus suitable for modeling open systems. A number of actor languages have been implemented; these implementations have generally used a simulation of distributed execution on a single proces sor <ref> [17, 18, 23] </ref>. Although such simulations are a useful tool for some purposes, a number of issues such as load balancing and distributed garbage collection are harder to realistically emulate. <p> Hal is an object-oriented language with a lisp-like syntax which is compiled to C code and executed using the CHARM programming system [15]. The full syntax of Hal can be found in [11]. Hal is loosely based on the previous actor languages Rosette [18], Acore <ref> [17] </ref> and ABCL/1 [23]. In Hal, there are two primitives to modify an actor's state. A change in an actor's behavior definition is specified through the become command. <p> Unfortunately, many (define-Actor Bank-Account (slots balance) (method (deposit amount) (update balance (+ balance amount)) (print "Deposited %d"n" amount)) (method (withdraw amount) (let* [[newBal (- balance amount)]] (update balance newBal) (print "Withdrew %d"n" amount) (print "Balance %d"n" newBal))) (method (get-balance) (print "Balance %d"n" balance)) concurrent programming languages, (e.g., CHARM [15], Acore <ref> [17] </ref>, Cantor [6], Emerald [12] and ABCL/1 [23]) do not incorporate inheritance. In our view, it is important to study the use of inheritance in concurrent systems. In particular, synchronization constraints (described below) can interfere with inheritance in concurrent systems. <p> The first is a message order preserving send, or sequenced send. The second is a remote procedure call mechanism similar to Acore's ask primitive <ref> [17] </ref>. Sequenced Sends. As noted above, the (constrain...) expression may be used to order messages of a certain type. This construct is specified in the receiver and is primarily concerned with types of messages.
Reference: [18] <author> C. Tomlinson, W. Kim, M. Schevel, V. Singh, B. Will, and G. Agha. Rosette: </author> <title> An object oriented concurrent system architecture. </title> <journal> Sigplan Notices, </journal> <volume> 24(4) </volume> <pages> 91-93, </pages> <year> 1989. </year>
Reference-contexts: Actors are dynamically reconfigurable and extensible and thus suitable for modeling open systems. A number of actor languages have been implemented; these implementations have generally used a simulation of distributed execution on a single proces sor <ref> [17, 18, 23] </ref>. Although such simulations are a useful tool for some purposes, a number of issues such as load balancing and distributed garbage collection are harder to realistically emulate. <p> Hal is an object-oriented language with a lisp-like syntax which is compiled to C code and executed using the CHARM programming system [15]. The full syntax of Hal can be found in [11]. Hal is loosely based on the previous actor languages Rosette <ref> [18] </ref>, Acore [17] and ABCL/1 [23]. In Hal, there are two primitives to modify an actor's state. A change in an actor's behavior definition is specified through the become command. <p> In our view, it is important to study the use of inheritance in concurrent systems. In particular, synchronization constraints (described below) can interfere with inheritance in concurrent systems. It is often desirable to place some form of synchronization constraint on objects to maintain their internal consistency. In Rosette <ref> [18] </ref>, these constraints take the form of enabled-sets which are specified inline. This mixing of code and enabledness conditions greatly reduces the reusability of inherited code. ABCL/1 also places synchronization issues within the scope of method definitions. <p> All the additional functionality we support could be simulated in terms of the basic actor primitives, but this would exact a great cost in terms of readability and modularity. A conscious effort has been made to make Hal more of a class-based language than Rosette <ref> [18] </ref>. As a result, Hal satisfies all of Wegner's qualifications to be classified as object-oriented [22]. For example, the define-Actor construct defines a class of actors; every actor belongs to a class. However, new (instance creation) and suicide (instance destruction) are the only class methods.
Reference: [19] <author> C. Tomlinson and V. Singh. </author> <title> Inheritance and synchronization with enabled-sets. </title> <booktitle> In OOPSLA, </booktitle> <year> 1989. </year>
Reference-contexts: in Rosette, would require reimplementing both get and put as constraints are specified through enabled-sets and the superclass get and put operations would (define-Actor Dispatcher (method (default) (print "Sent type %d"n" msg-type) (send msg-type msg-dst))) (define-Actor Me (method (initialize) (dispatcher (new Dispatcher)) (method (...))) tion. never enable the get2 method <ref> [19] </ref>. In Hal, we can simply declare the new method and the relevant syn chronization constraints.
Reference: [20] <author> T. Watanabe and A. Yonezawa. </author> <title> ABCL An Object-Oriened Concurrent System, </title> <booktitle> chapter Reflection in an Object-Oriented Concurrent Language, </booktitle> <pages> pages 45-70. </pages> <publisher> MIT Press, </publisher> <address> Cambridge, Mass, </address> <year> 1990. </year>
Reference-contexts: An example of how inheritance and synchronization constraints interact will be seen in Section 5.2. 4.5 Reflection One of the fundamental aspects of open systems is that they are extensible. One aspect of extensibility is the ability to dynamically change the underlying system executing a program through reflection <ref> [20] </ref>. Full reflection, which would allow modification of every aspect of the system down to the arithmetic interpreter, is not currently supported.
Reference: [21] <author> T. Watanabe and A. Yonezawa. </author> <title> A actor-based metalevel architecture for group-wide reflection. </title> <editor> In J. W. deBakker, W. P. deRoever, and G. Rozenberg, editors, </editor> <booktitle> Foundations of Object-Oriented Languages, </booktitle> <pages> pages 405-425. </pages> <publisher> Springer-Verlag, </publisher> <year> 1990. </year> <note> LNCS 489. </note>
Reference-contexts: An actor of class Me will replace its dispatcher with an actor that will print diagnostic information to the console. Our implementation of Dispatcher makes no refernce to its base actor; therefore, many actors could share the same meta-dispatcher providing a limited form of groupwide reflection <ref> [21] </ref>. Hal has also been used to experiment with implementing dependability protocols at the meta level thus providing a separation of design concerns [2]. One of the design motivations for Hal was to create a platform to test out theoretical ideas.
Reference: [22] <author> P. Wegner. </author> <title> Dimensions of object-based language design. </title> <type> Technical Report CS-87-14, </type> <institution> Brown University, </institution> <month> July </month> <year> 1987. </year>
Reference-contexts: A conscious effort has been made to make Hal more of a class-based language than Rosette [18]. As a result, Hal satisfies all of Wegner's qualifications to be classified as object-oriented <ref> [22] </ref>. For example, the define-Actor construct defines a class of actors; every actor belongs to a class. However, new (instance creation) and suicide (instance destruction) are the only class methods.
Reference: [23] <author> A. Yonezawa, </author> <title> editor. ABCL An Object-Oriented Concurrent System. </title> <publisher> MIT Press, </publisher> <address> Cambridge, Mass., </address> <year> 1990. </year>
Reference-contexts: Actors are dynamically reconfigurable and extensible and thus suitable for modeling open systems. A number of actor languages have been implemented; these implementations have generally used a simulation of distributed execution on a single proces sor <ref> [17, 18, 23] </ref>. Although such simulations are a useful tool for some purposes, a number of issues such as load balancing and distributed garbage collection are harder to realistically emulate. <p> Hal is an object-oriented language with a lisp-like syntax which is compiled to C code and executed using the CHARM programming system [15]. The full syntax of Hal can be found in [11]. Hal is loosely based on the previous actor languages Rosette [18], Acore [17] and ABCL/1 <ref> [23] </ref>. In Hal, there are two primitives to modify an actor's state. A change in an actor's behavior definition is specified through the become command. For example, changing a Bank Account actor to a Pizzeria actor or changing the number of local variables an actor knows requires the become statement. <p> (deposit amount) (update balance (+ balance amount)) (print "Deposited %d"n" amount)) (method (withdraw amount) (let* [[newBal (- balance amount)]] (update balance newBal) (print "Withdrew %d"n" amount) (print "Balance %d"n" newBal))) (method (get-balance) (print "Balance %d"n" balance)) concurrent programming languages, (e.g., CHARM [15], Acore [17], Cantor [6], Emerald [12] and ABCL/1 <ref> [23] </ref>) do not incorporate inheritance. In our view, it is important to study the use of inheritance in concurrent systems. In particular, synchronization constraints (described below) can interfere with inheritance in concurrent systems.
References-found: 23

