URL: http://www.ri.cmu.edu/afs/cs/user/fp/www/courses/linear/handouts/erm97.ps
Refering-URL: http://www.ri.cmu.edu/afs/cs/user/fp/www/courses/linear/handouts.html
Root-URL: 
Email: E-mail: filianojfpg@cs.cmu.edu  E-mail: hodas@cs.hmc.edu  
Phone: 2  
Title: Efficient Resource Management  for Linear Logic Proof Search  
Author: Iliano Cervesato Joshua S. Hodas and Frank Pfenning 
Date: August 29, 1997  
Address: Pittsburgh, PA 15213-3891, USA  Claremont, CA 91711, USA  
Affiliation: 1 Department of Computer Science, Carnegie Mellon University  Computer Science Department, Harvey Mudd College  
Note: Submitted to Theoretical Computer Science. Comments are welcome!  
Abstract: The design of linear logic programming languages and theorem provers opens a number of new implementation challenges not present in more traditional logic languages such as Horn clauses (Prolog) and hereditary Harrop formulas (Prolog and Elf ). Among these, the problem of efficiently managing the linear context when solving a goal is of crucial importance for the use of these systems in non-trivial applications. This paper studies this problem in the case of Lolli [HM94], though its results have application to other systems. We first give a proof-theoretic presentation of the operational semantics of this language as a resolution calculus. We then present a series of resource management systems designed to eliminate the non-determinism in the distribution of linear formulas that undermines the efficiency of a direct implementation of this system.
Abstract-found: 1
Intro-found: 1
Reference: [AP91] <author> Jean-Marc Andreoli and Remo Pareschi. </author> <title> Linear objects: Logical processes with built-in inheritance. </title> <journal> New Generation Computing, </journal> <volume> 9 </volume> <pages> 445-473, </pages> <year> 1991. </year>
Reference-contexts: In particular, many problems centered around the notion of a state that evolves as a computation proceeds fall into this category. Consequently, several logic programming languages based on linear logic have been designed in recent years <ref> [AP91, HP91, HM94, Mil96] </ref>. Others are the subject of extensive research. Each proposal is accompanied by interesting theoretical results that show its computational relevance, and by numerous examples that prove its practical significance. <p> provable sequent of L can be transformed into an equivalent proof that consults the program only when the goal formula is atomic (thus proofs are goal-directed [MNPS91]), and at that point selects and operates upon a single program formula in order to proceed with the derivation (thus proofs are focused <ref> [AP91] </ref>). Proofs with both properties are called uniform.
Reference: [CHMP] <author> Iliano Cervesato, Joshua S. Hodas, Dale Miller, and Frank Pfenning. </author> <title> Some implementations of the linear logic programming language Lolli. Available on the World Wide Web at address ftp://ftp.cs.cmu.edu/user/iliano/misc/lolli.tar.gz. </title>
Reference-contexts: Similarly, we do not consider orthogonal issues in linear proof search, such as the permutability of inference rules, which have been treated exhaustively elsewhere [GP94, Min93, Tam94]. We will focus our attention on the language Lolli [Hod94, HM94], that we used to test the techniques described below <ref> [CHMP] </ref>. However, our results have already been applied to prototype implementations [HP96, LP97] of a programming language based on Miller's specification logic Forum [Mil96]. <p> Each element can be either a linear program formula, an intuitionistic program formula (marked with the tag "!"), or the special constant del. This is very close to their original Prolog implementation of LHHF <ref> [CHMP] </ref>. Here, I and O are instead sets of labelled formulas and the intuitionistic part of the context has been separated out. This is consistent with the resolution judgment presented in Section 2, and permits easier proofs of soundness and completeness. <p> This causes the failure of the original query. Clearly, it would be preferable for the attempt to solve b to fail as soon as c is accessed, so that the message is never printed. Even in a Prolog-based implementation [HM94] (one is included in <ref> [CHMP] </ref>), where the constraint on the output contexts is enforced by unification rather than by an after-the-fact check, the same problem occurs if we replace the body of the rule for b with `c, write "Some Output", true'. <p> The techniques presented in this section have been applied into an enhanced version of the ML interpreter for Lolli. A series of implementations realizing each of the ideas discussed in this paper is available by anonymous ftp (see <ref> [CHMP] </ref> for details). The declarative nature of the rules makes these same ideas applicable to implementations based on other programming paradigms. In particular, the original Prolog prototype (also available in [CHMP]) for Lolli [HM94] can be easily adapted to take advantage of these observations. 7 Conclusions and Related Work The issue <p> A series of implementations realizing each of the ideas discussed in this paper is available by anonymous ftp (see <ref> [CHMP] </ref> for details). The declarative nature of the rules makes these same ideas applicable to implementations based on other programming paradigms. In particular, the original Prolog prototype (also available in [CHMP]) for Lolli [HM94] can be easily adapted to take advantage of these observations. 7 Conclusions and Related Work The issue of efficient context management has proved to be crucial for the use of linear logic programming languages in non-trivial applications. <p> In this paper, we have presented a general technique that not only eliminates sources of non-determinism deriving from naive context management, but also permits early recognition of certain failure situations. We have implemented these ideas in the interpreter for a new release of the language Lolli <ref> [CHMP] </ref>. Tests showed a general improvement in performance and, in some examples, arbitrary speed-ups. We also achieved convergence for some previously non-terminating programs. <p> We are currently investigating a related method as a way to achieve a practical implementation of linear higher-order unification [CP97]. Our analysis was motivated primarily by the goal of building an efficient interpreter <ref> [CHMP] </ref>, but should also be applicable to the design of compilers which will ultimately be necessary for the execution of large programs. We expect that compilation techniques developed for Prolog [LO87] and Prolog [Kwo94, NJK95] may be combined with our methods.
Reference: [CP96] <author> Iliano Cervesato and Frank Pfenning. </author> <title> A linear logical framework. </title> <editor> In E. Clarke, editor, </editor> <booktitle> Proceedings of the Eleventh Annual Symposium on Logic in Computer Science | LICS'96, </booktitle> <pages> pages 264-275, </pages> <address> New Brunswick, New Jersey, </address> <month> 27-30 July </month> <year> 1996. </year> <note> IEEE Computer Society Press. This work also appeared as Preprint 1834 of the Department of Mathematics of Technical University of Darmstadt, Germany. </note>
Reference-contexts: They should apply equally well to implementations of other linear logic programming languages such as Lygon [HP91] and to a concrete realization of the linear logical framework LLF <ref> [CP96] </ref>. It is also possible to adapt our techniques to the development of theorem provers for linear logic, but our main goal has been to remove non-determinism in order to obtain a satisfactory and predictable operational semantics for logic programming.
Reference: [CP97] <author> Iliano Cervesato and Frank Pfenning. </author> <title> Linear higher-order pre-unification. </title> <editor> In G. Winskel, editor, </editor> <booktitle> Twelfth Annual Symposium on Logic in Computer Science | LICS'97, </booktitle> <pages> pages 422-433, </pages> <address> Warsaw, Poland, 29 June - 2 July 1997. </address> <publisher> IEEE Computer Society Press. </publisher>
Reference-contexts: They recently proposed a new and promising approach to context management based on the idea of maintaining boolean constraints in order to specify how linear resources should be distributed [HP97]. We are currently investigating a related method as a way to achieve a practical implementation of linear higher-order unification <ref> [CP97] </ref>. Our analysis was motivated primarily by the goal of building an efficient interpreter [CHMP], but should also be applicable to the design of compilers which will ultimately be necessary for the execution of large programs.
Reference: [Gir87] <author> Jean-Yves Girard. </author> <title> Linear logic. </title> <journal> Theoretical Computer Science, </journal> <volume> 50 </volume> <pages> 1-102, </pages> <year> 1987. </year>
Reference-contexts: 1 Introduction Linear logic <ref> [Gir87] </ref> views logical assumptions as consumable resources. This allows elegant and concise formalizations of a number of problems which are difficult to represent in traditional logics. In particular, many problems centered around the notion of a state that evolves as a computation proceeds fall into this category.
Reference: [GP94] <author> Didier Galmiche and Guy Perrier. </author> <title> Foundations of proof search strategies design in linear logic. </title> <booktitle> In Symposium on Logical Foundations of Computer Science, </booktitle> <pages> pages 101-113, </pages> <address> St. Petersburg, Russia, </address> <year> 1994. </year> <note> Springer-Verlag LNCS 813. Also available as Technical Report CRIN 94-R-112 from the Centre di Recherche en Informatique de Nancy. </note>
Reference-contexts: Similarly, we do not consider orthogonal issues in linear proof search, such as the permutability of inference rules, which have been treated exhaustively elsewhere <ref> [GP94, Min93, Tam94] </ref>. We will focus our attention on the language Lolli [Hod94, HM94], that we used to test the techniques described below [CHMP]. However, our results have already been applied to prototype implementations [HP96, LP97] of a programming language based on Miller's specification logic Forum [Mil96].
Reference: [HM94] <author> Joshua S. Hodas and Dale Miller. </author> <title> Logic programming in a fragment of intuitionistic linear logic. </title> <journal> Information and Computation, </journal> <volume> 110(2) </volume> <pages> 327-365, </pages> <year> 1994. </year> <booktitle> Extended abstract in the Proceedings of the Sixth Annual Symposium on Logic in Computer Science, </booktitle> <address> Amsterdam, </address> <month> July 15-18, </month> <year> 1991. </year>
Reference-contexts: In particular, many problems centered around the notion of a state that evolves as a computation proceeds fall into this category. Consequently, several logic programming languages based on linear logic have been designed in recent years <ref> [AP91, HP91, HM94, Mil96] </ref>. Others are the subject of extensive research. Each proposal is accompanied by interesting theoretical results that show its computational relevance, and by numerous examples that prove its practical significance. <p> Others are the subject of extensive research. Each proposal is accompanied by interesting theoretical results that show its computational relevance, and by numerous examples that prove its practical significance. However, to our knowledge, usable implementations have thus far been released only for Lolli <ref> [HM94] </ref> and Lygon [HP91]. Linear logic programming languages offer the implementor new challenges not present in more traditional logic languages such as Prolog or Prolog. <p> In this paper, we begin by reiterating the deterministic solution to this problem presented in the original work on Lolli <ref> [Hod94, HM94] </ref>. We will then concentrate on less apparent issues in context management involving the additive connectives and constants. <p> Similarly, we do not consider orthogonal issues in linear proof search, such as the permutability of inference rules, which have been treated exhaustively elsewhere [GP94, Min93, Tam94]. We will focus our attention on the language Lolli <ref> [Hod94, HM94] </ref>, that we used to test the techniques described below [CHMP]. However, our results have already been applied to prototype implementations [HP96, LP97] of a programming language based on Miller's specification logic Forum [Mil96]. <p> We discuss further steps towards an efficient implementation of Lolli in Section 6. Finally, we summarize our work and compare it with other proposals in the literature in Section 7. 2 2 Resolution for Linear Hereditary Harrop Formulas The programming language Lolli <ref> [Hod94, HM94] </ref> is based on the fragment of linear logic freely generated by the operators &gt;, &, ffi, and 8. The connective is called intuitionistic implication and is defined as A B !A ffi B. <p> Hodas and Miller discuss a proof system, L, for LHHF based on sequents of this form <ref> [HM94] </ref>. They also prove the soundness and completeness of L with respect to the usual rules for linear logic restricted to the language of LHHF . Most importantly, they prove that LHHF possesses the necessary computational properties to be considered an abstract logic programming language [MNPS91]. <p> The rules in the bottom section of Figure 1 describe how to reduce non-atomic goal formulas. They stem from the right introduction rules of linear logic, and are essentially identical to the right rules for L 0 <ref> [HM94] </ref>. R differs from L 0 in the treatment of atomic goal formulas. In order to handle these goals, Hodas and Miller rely on the function k k, which converts a formula in the program to a (possibly infinite) set of clauses, each defining a single ground atom. <p> Assume that contains n formulas. Then there are 2 n possible splits. In the worst case, finding a workable split (or determining that none exists) will require trying them all. This problem was given a deterministic solution by Hodas and Miller in <ref> [HM94] </ref> in what they called the I/O model of execution for Lolli. We will instead use the name resource management system and refer to our presentation of this deduction system as RM 1 . <p> In their original paper, Hodas and Miller write this judgment IfGgO, with G being the goal formula, and I and O being the input and the output contexts respectively <ref> [HM94] </ref>. The main difference with respect to our judgment is that in their presentation I and O are lists. Each element can be either a linear program formula, an intuitionistic program formula (marked with the tag "!"), or the special constant del. <p> System RM 1 does not address this hidden source of context management non-determinism. Hodas and Miller initially underestimated the importance of this issue <ref> [HM94] </ref>. However the subsequent development of sample applications to accompany the first public release of Lolli showed this problem to be critical in practice. The solution we describe is adapted from Hodas' dissertation [Hod94, Section 7.4], and was incorporated into that implementation. <p> This causes the failure of the original query. Clearly, it would be preferable for the attempt to solve b to fail as soon as c is accessed, so that the message is never printed. Even in a Prolog-based implementation <ref> [HM94] </ref> (one is included in [CHMP]), where the constraint on the output contexts is enforced by unification rather than by an after-the-fact check, the same problem occurs if we replace the body of the rule for b with `c, write "Some Output", true'. <p> The declarative nature of the rules makes these same ideas applicable to implementations based on other programming paradigms. In particular, the original Prolog prototype (also available in [CHMP]) for Lolli <ref> [HM94] </ref> can be easily adapted to take advantage of these observations. 7 Conclusions and Related Work The issue of efficient context management has proved to be crucial for the use of linear logic programming languages in non-trivial applications.
Reference: [Hod94] <author> Joshua S. Hodas. </author> <title> Logic Programming in Intuitionistic Linear Logic: Theory, Design and Implementation. </title> <type> PhD thesis, </type> <institution> University of Pennsylvania, Department of Computer and Information Science, </institution> <year> 1994. </year>
Reference-contexts: In this paper, we begin by reiterating the deterministic solution to this problem presented in the original work on Lolli <ref> [Hod94, HM94] </ref>. We will then concentrate on less apparent issues in context management involving the additive connectives and constants. <p> Similarly, we do not consider orthogonal issues in linear proof search, such as the permutability of inference rules, which have been treated exhaustively elsewhere [GP94, Min93, Tam94]. We will focus our attention on the language Lolli <ref> [Hod94, HM94] </ref>, that we used to test the techniques described below [CHMP]. However, our results have already been applied to prototype implementations [HP96, LP97] of a programming language based on Miller's specification logic Forum [Mil96]. <p> We discuss further steps towards an efficient implementation of Lolli in Section 6. Finally, we summarize our work and compare it with other proposals in the literature in Section 7. 2 2 Resolution for Linear Hereditary Harrop Formulas The programming language Lolli <ref> [Hod94, HM94] </ref> is based on the fragment of linear logic freely generated by the operators &gt;, &, ffi, and 8. The connective is called intuitionistic implication and is defined as A B !A ffi B. <p> We also make use of the residuation judgment in place of the special predicate pickr which they appeal to. Details of the correctness proofs following Hodas and Miller's formulation can be found in <ref> [Hod94, Section 7.1] </ref>. 6 When considering the judgment ; I n O =) G, we adopt a computational point of view in which the schematic variables , I and G are given as input to the rules, while O is returned as an output value from the resolution of the goal. <p> Hodas and Miller initially underestimated the importance of this issue [HM94]. However the subsequent development of sample applications to accompany the first public release of Lolli showed this problem to be critical in practice. The solution we describe is adapted from Hodas' dissertation <ref> [Hod94, Section 7.4] </ref>, and was incorporated into that implementation.
Reference: [HP91] <author> James Harland and David Pym. </author> <title> The uniform proof-theoretic foundation of linear logic programming. </title> <editor> In V. Saraswat and K. Ueda, editors, </editor> <booktitle> Proceedings of the International Logic Programming Symposium, </booktitle> <pages> pages 304-318, </pages> <address> San Diego, California, </address> <month> October </month> <year> 1991. </year>
Reference-contexts: In particular, many problems centered around the notion of a state that evolves as a computation proceeds fall into this category. Consequently, several logic programming languages based on linear logic have been designed in recent years <ref> [AP91, HP91, HM94, Mil96] </ref>. Others are the subject of extensive research. Each proposal is accompanied by interesting theoretical results that show its computational relevance, and by numerous examples that prove its practical significance. <p> Others are the subject of extensive research. Each proposal is accompanied by interesting theoretical results that show its computational relevance, and by numerous examples that prove its practical significance. However, to our knowledge, usable implementations have thus far been released only for Lolli [HM94] and Lygon <ref> [HP91] </ref>. Linear logic programming languages offer the implementor new challenges not present in more traditional logic languages such as Prolog or Prolog. Among these, the efficient management of the linear formulas contained in the context is of crucial importance for the use of these languages in non-trivial applications. <p> However, our results have already been applied to prototype implementations [HP96, LP97] of a programming language based on Miller's specification logic Forum [Mil96]. They should apply equally well to implementations of other linear logic programming languages such as Lygon <ref> [HP91] </ref> and to a concrete realization of the linear logical framework LLF [CP96]. <p> Lopez and Pimentel have designed another implementation of Forum on a system similar to RM 3 but currently without a slack indicator [LP97]. These techniques should extend just as easily to implementations of 24 Lygon <ref> [HP91, HW94] </ref> and other linear languages. Acknowledgments We would like to thank Vladimir Alexiev, James Harland, Dale Miller, Jeffrey Polakow and Roberto Virga, as well as the anonymous reviewers of the 1996 International Workshop on Extensions of Logic Programming (ELP'96), for their valuable comments on early versions of this paper.
Reference: [HP96] <author> Joshua S. Hodas and Jeffrey Polakow. </author> <title> Forum as a logic programming language: Preliminary results and observations. </title> <editor> In M. Okada, editor, </editor> <booktitle> Proceedings of the Linear Logic '96 Meeting, </booktitle> <address> Tokyo, Japan, </address> <year> 1996. </year> <booktitle> Elsevier Electronic Notes in Theoretical Computer Science, </booktitle> <volume> volume 3. </volume> <pages> 25 </pages>
Reference-contexts: We will focus our attention on the language Lolli [Hod94, HM94], that we used to test the techniques described below [CHMP]. However, our results have already been applied to prototype implementations <ref> [HP96, LP97] </ref> of a programming language based on Miller's specification logic Forum [Mil96]. They should apply equally well to implementations of other linear logic programming languages such as Lygon [HP91] and to a concrete realization of the linear logical framework LLF [CP96]. <p> The results described in the paper can be applied to other programming languages based on linear logic. Hodas and Polakow have extended the system RM 3 to Miller's specification logic Forum [Mil96] and have based a prototype implementation on it <ref> [HP96] </ref>. Lopez and Pimentel have designed another implementation of Forum on a system similar to RM 3 but currently without a slack indicator [LP97]. These techniques should extend just as easily to implementations of 24 Lygon [HP91, HW94] and other linear languages.
Reference: [HP97] <author> James Harland and David Pym. </author> <title> Resource distribution via boolean constraints. </title> <editor> In W. McCune, editor, </editor> <booktitle> Proceedings of the Fourteenth International Conference on Automated Deduction | CADE-14, Townsville, </booktitle> <address> Australia, </address> <month> July </month> <year> 1997. </year> <note> To appear. </note>
Reference-contexts: It is also possible to adapt our techniques to the development of theorem provers for linear logic, but our main goal has been to remove non-determinism in order to obtain a satisfactory and predictable operational semantics for logic programming. In related work, Harland and Pym <ref> [HP97] </ref> present a less committed framework for resource management strategies in general linear logic proof search which relies on Boolean constraints. As far as we can see, their framework does not have an immediate operational interpretation or efficient implementation and thus does not directly address our problem. <p> They recently proposed a new and promising approach to context management based on the idea of maintaining boolean constraints in order to specify how linear resources should be distributed <ref> [HP97] </ref>. We are currently investigating a related method as a way to achieve a practical implementation of linear higher-order unification [CP97].
Reference: [HW94] <author> James Harland and Michael Winikoff. </author> <title> Deterministic resource management for the linear logic programming language Lygon. </title> <type> Technical Report TR 94/23, </type> <institution> Melbourne University, Department of Computer Science, </institution> <year> 1994. </year>
Reference-contexts: To our knowledge, the only other authors who have been concerned with the issue of efficiency in context management for linear logic programming languages are the designers of Lygon. In their first publication on this subject <ref> [HW94] </ref>, they build on the work of Hodas and Miller and independently develop a system with the characteristics of Hodas' efficient handling of &gt;. <p> Lopez and Pimentel have designed another implementation of Forum on a system similar to RM 3 but currently without a slack indicator [LP97]. These techniques should extend just as easily to implementations of 24 Lygon <ref> [HP91, HW94] </ref> and other linear languages. Acknowledgments We would like to thank Vladimir Alexiev, James Harland, Dale Miller, Jeffrey Polakow and Roberto Virga, as well as the anonymous reviewers of the 1996 International Workshop on Extensions of Logic Programming (ELP'96), for their valuable comments on early versions of this paper.
Reference: [Kwo94] <author> Keehang Kwon. </author> <title> Towards a Verified Abstract Machine for a Logic Programming Language with a Notion of Scope. </title> <type> PhD thesis, </type> <institution> Department of Computer Science, Duke University, </institution> <month> December </month> <year> 1994. </year> <note> Available as Technical Report CS-1994-36. </note>
Reference-contexts: Our analysis was motivated primarily by the goal of building an efficient interpreter [CHMP], but should also be applicable to the design of compilers which will ultimately be necessary for the execution of large programs. We expect that compilation techniques developed for Prolog [LO87] and Prolog <ref> [Kwo94, NJK95] </ref> may be combined with our methods. The results described in the paper can be applied to other programming languages based on linear logic. Hodas and Polakow have extended the system RM 3 to Miller's specification logic Forum [Mil96] and have based a prototype implementation on it [HP96].
Reference: [KY93] <author> Naoki Kobayashi and Akinori Yonezawa. </author> <title> ACL | A concurrent linear logic programming paradigm. </title> <editor> In D. Miller, editor, </editor> <booktitle> Proceedings of the 1993 International Logic Programming Symposium, </booktitle> <pages> pages 279-294, </pages> <address> Vancouver, Canada, October 1993. </address> <publisher> MIT Press. </publisher>
Reference-contexts: We do not treat other sources of non-determinism, which can be handled according to standard techniques in a logic programming framework [Pfe92], or that we might want to keep open in a theorem prover and in the implementation of a concurrent linear logic programming language such as ACL <ref> [KY93] </ref>. Similarly, we do not consider orthogonal issues in linear proof search, such as the permutability of inference rules, which have been treated exhaustively elsewhere [GP94, Min93, Tam94]. We will focus our attention on the language Lolli [Hod94, HM94], that we used to test the techniques described below [CHMP].
Reference: [LO87] <author> Timothy G. Lindholm and Richard A. O'Keefe. </author> <title> Efficient implementation of a defensible semantics for dynamic Prolog code. </title> <editor> In J.L. Lassez, editor, </editor> <booktitle> Proceedings of the Fourth International Conference on Logic Programming | ICLP'87, </booktitle> <pages> pages 21-39, </pages> <address> Melbourne, Australia, 1987. </address> <publisher> MIT Press. </publisher>
Reference-contexts: Managing the clauses of a program is particularly simple in Prolog: The only predicates that can modify the program are the extra-logicals assert and retract, which have global effect <ref> [LO87] </ref>. In languages admitting implications in goals, Prolog [Mil91] and Elf [Pfe94] for example, the use of scoped assumptions causes the program to grow and contract, but in a simple stack-like fashion. <p> Our analysis was motivated primarily by the goal of building an efficient interpreter [CHMP], but should also be applicable to the design of compilers which will ultimately be necessary for the execution of large programs. We expect that compilation techniques developed for Prolog <ref> [LO87] </ref> and Prolog [Kwo94, NJK95] may be combined with our methods. The results described in the paper can be applied to other programming languages based on linear logic.
Reference: [LP97] <author> Pablo Lopez and Ernesto Pimentel. </author> <title> A lazy splitting system for Forum. </title> <editor> In M. Falaschi, M. Navarro, and A. Policriti, editors, </editor> <booktitle> Proceedings of the Joint Conference on Declarative Programming | APPIA-GULP-PRODE'97, </booktitle> <pages> pages 247-258, </pages> <address> Grado, Italy, </address> <year> 1997. </year>
Reference-contexts: We will focus our attention on the language Lolli [Hod94, HM94], that we used to test the techniques described below [CHMP]. However, our results have already been applied to prototype implementations <ref> [HP96, LP97] </ref> of a programming language based on Miller's specification logic Forum [Mil96]. They should apply equally well to implementations of other linear logic programming languages such as Lygon [HP91] and to a concrete realization of the linear logical framework LLF [CP96]. <p> Hodas and Polakow have extended the system RM 3 to Miller's specification logic Forum [Mil96] and have based a prototype implementation on it [HP96]. Lopez and Pimentel have designed another implementation of Forum on a system similar to RM 3 but currently without a slack indicator <ref> [LP97] </ref>. These techniques should extend just as easily to implementations of 24 Lygon [HP91, HW94] and other linear languages.
Reference: [Mil91] <author> Dale Miller. </author> <title> A logic programming language with lambda-abstraction, function variables, and simple unification. </title> <journal> Journal of Logic and Computation, </journal> <volume> 1(4) </volume> <pages> 497-536, </pages> <year> 1991. </year>
Reference-contexts: Managing the clauses of a program is particularly simple in Prolog: The only predicates that can modify the program are the extra-logicals assert and retract, which have global effect [LO87]. In languages admitting implications in goals, Prolog <ref> [Mil91] </ref> and Elf [Pfe94] for example, the use of scoped assumptions causes the program to grow and contract, but in a simple stack-like fashion. The matter is more complicated in the case of linear logic due to the strict rules placed on the use and reuse of assumptions.
Reference: [Mil96] <author> Dale Miller. </author> <title> A multiple-conclusion specification logic. </title> <journal> Theoretical Computer Science, </journal> <volume> 165(1) </volume> <pages> 201-232, </pages> <year> 1996. </year>
Reference-contexts: In particular, many problems centered around the notion of a state that evolves as a computation proceeds fall into this category. Consequently, several logic programming languages based on linear logic have been designed in recent years <ref> [AP91, HP91, HM94, Mil96] </ref>. Others are the subject of extensive research. Each proposal is accompanied by interesting theoretical results that show its computational relevance, and by numerous examples that prove its practical significance. <p> We will focus our attention on the language Lolli [Hod94, HM94], that we used to test the techniques described below [CHMP]. However, our results have already been applied to prototype implementations [HP96, LP97] of a programming language based on Miller's specification logic Forum <ref> [Mil96] </ref>. They should apply equally well to implementations of other linear logic programming languages such as Lygon [HP91] and to a concrete realization of the linear logical framework LLF [CP96]. <p> The results described in the paper can be applied to other programming languages based on linear logic. Hodas and Polakow have extended the system RM 3 to Miller's specification logic Forum <ref> [Mil96] </ref> and have based a prototype implementation on it [HP96]. Lopez and Pimentel have designed another implementation of Forum on a system similar to RM 3 but currently without a slack indicator [LP97].
Reference: [Min93] <author> Grigori Mints. </author> <title> Resolution calculus for the first order linear logic. </title> <journal> Journal of Logic, Language and Information, </journal> <volume> 2(1) </volume> <pages> 59-83, </pages> <year> 1993. </year>
Reference-contexts: Similarly, we do not consider orthogonal issues in linear proof search, such as the permutability of inference rules, which have been treated exhaustively elsewhere <ref> [GP94, Min93, Tam94] </ref>. We will focus our attention on the language Lolli [Hod94, HM94], that we used to test the techniques described below [CHMP]. However, our results have already been applied to prototype implementations [HP96, LP97] of a programming language based on Miller's specification logic Forum [Mil96].
Reference: [MNPS91] <author> Dale Miller, Gopalan Nadathur, Frank Pfenning, and Andre Scedrov. </author> <title> Uniform proofs as a foundation for logic programming. </title> <journal> Annals of Pure and Applied Logic, </journal> <volume> 51 </volume> <pages> 125-157, </pages> <year> 1991. </year>
Reference-contexts: They also prove the soundness and completeness of L with respect to the usual rules for linear logic restricted to the language of LHHF . Most importantly, they prove that LHHF possesses the necessary computational properties to be considered an abstract logic programming language <ref> [MNPS91] </ref>. In particular, every provable sequent of L can be transformed into an equivalent proof that consults the program only when the goal formula is atomic (thus proofs are goal-directed [MNPS91]), and at that point selects and operates upon a single program formula in order to proceed with the derivation (thus <p> Most importantly, they prove that LHHF possesses the necessary computational properties to be considered an abstract logic programming language <ref> [MNPS91] </ref>. In particular, every provable sequent of L can be transformed into an equivalent proof that consults the program only when the goal formula is atomic (thus proofs are goal-directed [MNPS91]), and at that point selects and operates upon a single program formula in order to proceed with the derivation (thus proofs are focused [AP91]). Proofs with both properties are called uniform.
Reference: [NJK95] <author> Gopalan Nadathur, Bharat Jayaraman, and Keehang Kwon. </author> <title> Scoping constructs in logic programming: Implementation problems and their solution. </title> <journal> Journal of Logic Programming, </journal> <volume> 25(2) </volume> <pages> 119-161, </pages> <year> 1995. </year>
Reference-contexts: Our analysis was motivated primarily by the goal of building an efficient interpreter [CHMP], but should also be applicable to the design of compilers which will ultimately be necessary for the execution of large programs. We expect that compilation techniques developed for Prolog [LO87] and Prolog <ref> [Kwo94, NJK95] </ref> may be combined with our methods. The results described in the paper can be applied to other programming languages based on linear logic. Hodas and Polakow have extended the system RM 3 to Miller's specification logic Forum [Mil96] and have based a prototype implementation on it [HP96].
Reference: [Pfe92] <author> Frank Pfenning. </author> <title> Computation and deduction. </title> <booktitle> Unpublished lecture notes, </booktitle> <pages> 277 pp. </pages> <month> Revised May </month> <year> 1994, </year> <month> April </month> <year> 1996, </year> <month> May </month> <year> 1992. </year>
Reference-contexts: We will then concentrate on less apparent issues in context management involving the additive connectives and constants. We do not treat other sources of non-determinism, which can be handled according to standard techniques in a logic programming framework <ref> [Pfe92] </ref>, or that we might want to keep open in a theorem prover and in the implementation of a concurrent linear logic programming language such as ACL [KY93].
Reference: [Pfe94] <author> Frank Pfenning. </author> <title> Elf: A meta-language for deductive systems. </title> <editor> In A. Bundy, editor, </editor> <booktitle> Proceedings of the 12th International Conference on Automated Deduction, </booktitle> <pages> pages 811-815, </pages> <address> Nancy, France, </address> <month> June </month> <year> 1994. </year> <note> Springer-Verlag LNAI 814. System abstract. </note>
Reference-contexts: Managing the clauses of a program is particularly simple in Prolog: The only predicates that can modify the program are the extra-logicals assert and retract, which have global effect [LO87]. In languages admitting implications in goals, Prolog [Mil91] and Elf <ref> [Pfe94] </ref> for example, the use of scoped assumptions causes the program to grow and contract, but in a simple stack-like fashion. The matter is more complicated in the case of linear logic due to the strict rules placed on the use and reuse of assumptions.
Reference: [Tam94] <author> T. Tammet. </author> <title> Proof strategies in linear logic. </title> <journal> Journal of Automated Reasoning, </journal> <volume> 12 </volume> <pages> 273-304, </pages> <year> 1994. </year> <note> Also available as Programming Methodology Group Report 70, </note> <institution> Chalmers University, </institution> <year> 1993. </year> <month> 26 </month>
Reference-contexts: Similarly, we do not consider orthogonal issues in linear proof search, such as the permutability of inference rules, which have been treated exhaustively elsewhere <ref> [GP94, Min93, Tam94] </ref>. We will focus our attention on the language Lolli [Hod94, HM94], that we used to test the techniques described below [CHMP]. However, our results have already been applied to prototype implementations [HP96, LP97] of a programming language based on Miller's specification logic Forum [Mil96].
References-found: 24

