URL: http://www.it.kth.se/docs/Reports/se/comb-oo-lp.ps.Z
Refering-URL: http://www.it.kth.se/docs/Reports/se/
Root-URL: http://www.it.kth.se
Title: Combination of Object-Oriented and Logic Paradigms  
Author: Tarmo Uustalu 
Degree: A Thesis submitted to the Tallinn Technical University in partial fulfillment of the requirements for the degree of Master of Engineering Written at the  
Note: Supervisors: Prof. Reidar Conradi and Prof. Jan Komorowski  
Date: Apr Aug 1991  
Address: (NTH), Trondheim,  
Affiliation: Dept. of Computer Systems and Telematics, The Norwegian Institute of Technology  
Pubnum: TALLINN TECHNICAL UNIVERSITY  
Abstract-found: 0
Intro-found: 1
Reference: [AM86] <author> M. Abadi and Z. Manna. </author> <title> Modal theorem proving. </title> <editor> In J. H. Siekmann, editor, </editor> <booktitle> 8th Int'l Conf. on Automated Deduction: Proc., </booktitle> <address> Oxford, UK, </address> <month> 27 July - 1 Aug </month> <year> 1986, </year> <pages> pages 172-89. </pages> <publisher> Springer, </publisher> <address> Berlin-Verlag, </address> <year> 1986. </year> <note> (LNCS, 230). </note>
Reference-contexts: The so-called Lemmon notation for these most known normal modal logics consists in indicating the axioms' code-names. We can talk about logics KD, KT, KT4 (S4), KTB4 (=KT5, S5), KD45 etc. There are many papers discussing how resolution systems for modal logics must look like, see e.g. <ref> [AM86, Cha87, Ohl88] </ref>.
Reference: [AN86] <author> H. Ait-Kaci and R. Nasr. </author> <title> LOGIN: A logic programming language with built-in inheritance. </title> <journal> Journal of Logic Programming, </journal> <volume> 3(3) </volume> <pages> 185-215, </pages> <year> 1986. </year>
Reference-contexts: Since ALF itself has been implemented in Alltalk, ALF also provides persistence for its specific objects, i.e. for rules, facts and queries. ALF draws heavily on LOGIN <ref> [AN86] </ref>, a logic programming language with built-in inheritance. LOGIN generalizes unification, putting it to take into account the lattice relationship among types which closely corresponds to the OO class hierarchy. However, LOGIN is more complicated than ALF, which, due to its origin in Smalltalk, only has single inheritance. <p> Towards a New Solution: Kernel Ideas and Logical Basis isa relation. The reason for such separating of taxonomic knowledge is that we want to obtain better computational efficiency by letting unification instead of resolution to infer property bindings. The same approach has been taken in both LOGIN <ref> [AN86] </ref> and EPOS [HV87], and is particularly emphasized in the latter. 4.4 Tasks of the Layers In order to determine the tasks of each layer, we return to the four principles of OO that we reviewed in Subsection 2.2.1.
Reference: [BGHS91] <author> G. Blair, J. Gallagher, D. Hutchison, and D. Shepherd, </author> <title> editors. Object-Oriented Languages, Systems and Applications. </title> <publisher> Pitman, </publisher> <address> London, </address> <year> 1991. </year> <pages> 375 pp. </pages>
Reference-contexts: This especially important with fastly evolving areas. Several attempts have been made to unify the views on OO, e.g. in <ref> [Str88, KM90, BGHS91] </ref>. <p> This also is finds reflection in a rather widely accepted sliding scale towards object-orientation: object-based: objects (communicating, hopefully), class-based: object-based plus classes, object-oriented: class-based plus inheritance. In contrast to that, a broader view is considered in <ref> [BGHS91] </ref>. Chapters 1,2,4,5 of that book present a uniform and rather philosophical basis which is further supplemented by detailed studies on languages, databases, distributed systems and user interfaces, and also on the applicability of OO to the design phase of software lifecycle. <p> In [KM90], a different unifying OO paradigm is suggested, where the principles and basic concepts of OO, and the problems of lifecycle model and tools are considered in parallel. 2.2. What Is Object-Orientation? 7 2.2.1 General Principles and Framework In <ref> [BGHS91] </ref> four principles are suggested as measures of the "rate of object-orientedness". These are: * data abstraction, * behaviour sharing, * evolution, * correctness. Data abstraction encompasses two aspects: modularization and information hiding. <p> Evolution in OO involves two levels. Requirements evolution means stepwise (top-down) refinement of the specification. Solution by evolution is the inverse: a synthesizing activity, building up a solution (bottom-up) in an incremental manner. The OO philosophy is to provide a uniform approach for the whole software lifecycle [HE90]. In <ref> [BGHS91] </ref>, it is even claimed that the evolutionary approach is unique to OO computing. Though the latter statement is disputable|stepwise prototyping, for instance, is thinkable also within other paradigms|the evolutionary feature of OO still provides powerful support to exploratory programming. <p> Correctness is in no way opposite to flexibility. Though evolution allows different levels of "precision" in different stages, it is possible (and even desirable) to maintain correctness with respect to a given level at each of these stages. Besides the above principles, the so-called "framework" is formulated in <ref> [BGHS91] </ref> to systematize the techniques of OO. Encapsulation is a generic term for techniques realizing data abstraction, so it is in an one-to-one correspondence to the data abstraction principle. 8 Chapter 2. <p> the framework classification of techniques are of auxiliary value, helping to see which principle a particular concept or technique is utilized to realize. 2.2.2 Basic Concepts and Techniques In this subsection, we briefly summarize the essence of the basic concepts and techniques of OO, mainly basing on the approach of <ref> [BGHS91] </ref>. Objects Objects are the fundamental building blocks in OO. At the conceptual level, an object is any perceived entity of the system being developed. In the first approximation, objects represent real world entities. Actually, objects may also represent abstractions without direct counterparts in the real world.
Reference: [BK82] <author> K. Bowen and R. Kowalski. </author> <title> Amalgamating language and metalanguage in logic programming. </title> <editor> In K. L. Clark and S.- A. Tarnlund, editors, </editor> <booktitle> Logic Programming, </booktitle> <pages> pages 153-72. </pages> <publisher> Academic Press, </publisher> <address> London, </address> <year> 1982. </year>
Reference-contexts: The functions of this manager instance include modifying the axioms stored in the unit world and creating and destruction of instances of the unit world (cf. the notion of metaclass). The classic predicate demo of metaprogramming in Prolog <ref> [BK82] </ref> has been generalized into simulate for the purpose of Mandala, being its concurrent version. Message passing in Mandala is expressed through streams. <p> While the main task of metaclasses in traditional object-oriented systems is to serve as templates for classes, the role of metaprogramming in logic programming languages is more general <ref> [BK82] </ref>. Many information hiding and sharing disciplines can be more easily and flexibly implemented using metaprogramming. Each Prolog-unit represents a chunk of knowledge about a particular domain. It is conceptually an autonomous world able to solve queries asked of by user.
Reference: [BMS90] <author> M. v. Biema, G. Q. Maguire, and S. Stolfo. </author> <title> The constraint-based paradigm: Integrating object-oriented and rule-based programming. </title> <booktitle> In Proc. 23rd Annual Hawaii Int'l Conf. on Syst. Sci., </booktitle> <address> Kailua-Kona, HI, USA, </address> <month> 2-5 Jan </month> <year> 1990, </year> <booktitle> volume 2, </booktitle> <pages> pages 358-66. </pages> <publisher> IEEE Comp. Soc. Press, Los Alamitos, </publisher> <address> CA, </address> <year> 1990. </year>
Reference-contexts: Significantly, authors of different solutions point out very overlapping pros and cons of each paradigm, though having set forth completely different purposes in their merging efforts <ref> [BMS90, FH86, FY88, IC90, KE88] </ref>. Modularity, encapsulation and sharing (both classed sharing, i.e. inheritance, and flexible one, i.e. polymorphism etc.) constitute the advantages of the OO paradigm. Declarative framework with pattern matching, unification and backtracking are the main beneficial characteristics of the logic approach. <p> The second is rather to bring them together into a synergistic unification under a new subsuming paradigm, which may require both original paradigms to undergo major transformation (hybrid mergers). The second approach has been underlined in <ref> [BMS90] </ref>, though it is disputable whether it actually is followed there. In [GM87], concern is expressed about the dangers of integration for the sake of integration, 13 14 Chapter 3. <p> In order to acquire facts about the mother-child relation, a method for querying mothers about their children is defined. askMother |m x| foreach_unify (name (?x)) do:[:x| m &lt;- x mother. appendKB (mother (x,m))]. 3.2.2 CBL = Constraint-Based Language The language CBL <ref> [BMS90] </ref> has been designed at Columbia University, NY, USA. It is based on CLOS (Common Lisp Object Specification System). It pretends to be the first instance of a new, constraint-based paradigm (different from what is called constraint-based in [BS86]!), a synthesis of the OO and rule-based paradigms.
Reference: [BS86] <author> D. G. Bobrow and M. J. Stefik. </author> <booktitle> Perspectives on artificial intelligence programming. Science, </booktitle> <volume> 231 </volume> <pages> 951-7, </pages> <year> 1986. </year>
Reference-contexts: That might lead to the functional paradigm. Even others concentrate on relations between data items, thus appreciating the logic paradigm. And fourth could view program execution as communication between relatively autonomous entities named "objects", exploiting the OO paradigm. An elementary comparison of different paradigms has been presented in <ref> [BS86] </ref>. Note that a paradigm need not be (and hardly ever is) universal to fit all sorts of application areas. Each paradigm specifically suits for some areas, but may be completely inadequate with respect to others. The logic paradigm, for instance, supports tasks involving deductive retrieval but disencourages numeric computations. <p> It is based on CLOS (Common Lisp Object Specification System). It pretends to be the first instance of a new, constraint-based paradigm (different from what is called constraint-based in <ref> [BS86] </ref>!), a synthesis of the OO and rule-based paradigms. Though the approach can be worth the label, CBL strongly relies on CLOS. Constraints in CBL are formulated through predicates. <p> This slightly corresponds to message sending. The solver can only explicate a variable from an equation, if the values of all the other variables in that equation have become known. The solver cannot solve equation systems in the strong sense. The idea of equation solving is close to constraint-orientation <ref> [BS86] </ref>. The specification is translated into formulae, and so is the query. The planner has to derive the query formula from the specification ones. The example rectangle: (a,b,s,p,d:numeric s=a*b d=sqrt (a^2+b^2)) square:rectangle a=b thissquare:square s=25 will yield the following formulae: 40 Chapter 3.
Reference: [Cat88] <author> L. Catach. </author> <title> Normal multimodal logics. </title> <booktitle> In AAAI-88: Proc. 7th Nat'l Conf. on Artif. Intelligence, </booktitle> <address> St. Paul, MI, USA, </address> <month> 21-26 Aug </month> <year> 1988, </year> <booktitle> volume 2, </booktitle> <pages> pages 491-5. </pages> <year> 1988. </year>
Reference-contexts: The writing haiA is a shorthand for :[a]:A. The theory of normal multimodal logics has been developed in <ref> [Cat88] </ref>. A Hilbert-type axiomatization of a normal multimodal logic consists of the axiomatizations of a number of normal unimodal logics plus of several (maybe none) axioms of the form G ff;fi;fl;ffi : hffi [fi]A ! [fl]hffiiA (ff; fi; fl; ffi-incestuality axiom); where ff; fi; fl; ffi are abstract parameters.
Reference: [Cha87] <author> M. Chan. </author> <title> The recursive resolution method for modal logic. New. </title> <journal> Gener. Computing, </journal> <volume> 5(1) </volume> <pages> 155-183, </pages> <year> 1987. </year>
Reference-contexts: The so-called Lemmon notation for these most known normal modal logics consists in indicating the axioms' code-names. We can talk about logics KD, KT, KT4 (S4), KTB4 (=KT5, S5), KD45 etc. There are many papers discussing how resolution systems for modal logics must look like, see e.g. <ref> [AM86, Cha87, Ohl88] </ref>.
Reference: [Che80] <author> B. F. Chellas. </author> <title> Modal Logic: An Introduction. </title> <publisher> University Press, </publisher> <address> Cambridge, UK, </address> <year> 1980. </year> <pages> 295 pp. </pages>
Reference-contexts: Letters p, q, r usually stand for atomic formulae, whereas A, B, C denote arbitrary formulae. As regards to modal logic, the terms and notation of the textbook by B. F. Chellas <ref> [Che80] </ref> are followed mostly. Proof trees are written with the root (the theorem) in the bottom. 4 Chapter 1. Introduction Chapter 2 Ob ject-Oriented Paradigm During the recent years, OO has become increasingly popular. As B. <p> The considered axiomatizations of 15 normal modal logics are complete w.r.t. the corre-ponding Kripke semantics in the propositional case. In the predicate case, some of them turn out incomplete. A classic introduction into modal logic is the book by B. F. Chellas <ref> [Che80] </ref>. If there is more than one modal operator in the language of a given modal logic, it is called multimodal.
Reference: [Che87] <author> W. Chen. </author> <title> A theory of modules based on second-order logic. </title> <booktitle> In Proc. 1987 Symp. on Logic Programming, </booktitle> <address> San Fransisco, CA, USA, </address> <month> 31 Aug - 4 Sep </month> <year> 1987, </year> <pages> pages 24-33. </pages> <publisher> IEEE Comp. Soc. Press, </publisher> <address> Washington, DC, </address> <year> 1987. </year>
Reference-contexts: Note that in OO, such a distinction between structuring directions would not work, since the OO objects and classes are a hybrid of programs and data (data-drivenness). As examples of works in the direction of modularization, we mention [Mil86], <ref> [Che87] </ref>, and [Day89]. A number of studies has also been carried out where modules are viewed as worlds, with more or less explicit parallels drawn to the possible-worlds' semantics of modal logics. From among the solutions reviewed in Chapter 3, Prolog/KR, Mandala, and CPU take this approach.
Reference: [Chi84] <author> T. Chikayama. </author> <title> Unique features of ESP. </title> <booktitle> In Proc. 1984 Int'l Conf. on Fifth Gener. </booktitle> <institution> Comput. Syst., </institution> <address> Tokyo, Japan, </address> <month> 6-9 Nov </month> <year> 1984, </year> <pages> pages 292-8. </pages> <publisher> North-Holland, </publisher> <address> Amsterdam, </address> <year> 1984. </year>
Reference-contexts: Introducing OO Features Into Logic Languages 21 (The ? postfix in Concurrent Prolog is read-only annotation.) Mandala also provides a kind of rule-orientation. Weights can be associated with rules, and certainty factors of deduction results can be estimated on their basis. 3.4.4 ESP ESP <ref> [Chi84] </ref> was developed as the system description language of SIMPOS, which is the programming and operating system of (the Fifth Generation Computers' project Personal Sequential Inference Machine). ESP has been implemented on top of KL0, a Prolog-like high-level machine language.
Reference: [Con88] <author> J. S. Conery. </author> <title> Logical objects. </title> <booktitle> In Logic Programming: Proc. 5th Int'l Conf. and Symp., </booktitle> <address> Seattle, WA, USA, </address> <month> 15-19 Aug </month> <year> 1988, </year> <pages> pages 420-34. </pages> <publisher> The MIT Press, </publisher> <address> Cambridge, MA, </address> <year> 1988. </year>
Reference-contexts: Consider how a stack can be implemented as an intension. isempty (IStack) :- IStack::[]. top (IStack,El) :- IStack::[El|Rest]. push (IStack,El) ::= IStack::Curr, IStack:=[El|Curr]. pop (IStack,El) ::= IStack::[El|Rest], IStack:=Rest. The proposal has a clear semantics in intensional logic. 3.4.14 Object Clauses The proposal <ref> [Con88] </ref> by J. S. Conery of Oregon University, OR, USA, in many respects resembles that of the previous section. Its main objective is to cope with dynamic states. The base language is Prolog.
Reference: [CW88] <author> W. Chen and D. S. Warren. </author> <title> Objects as intensions. </title> <booktitle> In Logic Programming: Proc. 5th Int'l Conf. and Symp., </booktitle> <address> Seattle, WA, USA, </address> <month> 15-19 Aug </month> <year> 1988, </year> <pages> pages 404-19. </pages> <publisher> The MIT Press, </publisher> <address> Cambridge, MA, </address> <year> 1988. </year> <note> 109 110 BIBLIOGRAPHY </note>
Reference-contexts: LOCO has an automatic versioning feature (former revisions of objects get a numeric suffix). Also, to objects clauses can be attached that execute at updates (triggering, cf. access-orientation). 3.4.13 Objects as Intensions W. Chen and D. S. Warren made their proposal <ref> [CW88] </ref>, searching for a neat and adequate semantics for dynamic objects. There is no implementation behind their model. It basically deals with objects having dynamic states. Methods, classes, and inheritance are not considered.
Reference: [Day89] <author> G. Dayantis. </author> <title> Types, modularization and abstraction in logic programming. </title> <editor> In J. Grabowski, P. Lescanne, and W. Wechler, editors, </editor> <booktitle> Algebraic and Logic Programming: Int'l Workshop: Proc., </booktitle> <address> Gaussig, GDR, </address> <month> 14-18 Nov </month> <year> 1988, </year> <pages> pages 127-36. </pages> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1989. </year> <note> (LNCS, 343). </note>
Reference-contexts: Note that in OO, such a distinction between structuring directions would not work, since the OO objects and classes are a hybrid of programs and data (data-drivenness). As examples of works in the direction of modularization, we mention [Mil86], [Che87], and <ref> [Day89] </ref>. A number of studies has also been carried out where modules are viewed as worlds, with more or less explicit parallels drawn to the possible-worlds' semantics of modal logics. From among the solutions reviewed in Chapter 3, Prolog/KR, Mandala, and CPU take this approach.
Reference: [DH91] <author> R. Ducornau and M. Habib. </author> <title> Masking and conflicts, or to inherit is not to own. </title> <editor> In M. Lenzerini, D. Nardi, and M. Simi, editors, </editor> <booktitle> Inheritance Hierarchies in Knowledge Representation and Programming Languages, </booktitle> <pages> pages 223-44. </pages> <editor> J. </editor> <publisher> Wi-ley & Sons, </publisher> <address> Chichester, UK, </address> <year> 1991. </year>
Reference-contexts: In the present thesis, the class who possesses this definition, will be often called its owner (following the terminology of <ref> [DH91] </ref>), in contrast to its inheriting classes. Association of a method name to a definition (implementation) is called method binding. Method binding can be performed either statically, during compile time, or dynamically, at run-time.
Reference: [Far86] <author> L. Fari~nas del Cerro. MOLOG: </author> <title> A system that extends Prolog with modal logic. </title> <journal> New Gener. Computing, </journal> <volume> 4(1) </volume> <pages> 35-50, </pages> <year> 1986. </year>
Reference-contexts: From among the solutions reviewed in Chapter 3, Prolog/KR, Mandala, and CPU take this approach. From among proper modal enhancements of Prolog we mention two. An interesting MULTILOG proposal [KG86] has not been directly related to OO by its authors, but its possible connections are obvious. The MOLOG proposal <ref> [Far86] </ref> does not pretend to offer modularization, but instead allows a very wide understanding of modal operators. In the OO applications of the "modal logic paradigm", the accessibility relation 4.2. Trends of Structuring within the Logic Paradigm 51 52 Chapter 4.
Reference: [FH86] <author> K. Fukunaga and S. Hirose. </author> <title> An experience with a Prolog-based object-oriented language. </title> <editor> In N. Meyrowitz, editor, OOPSLA'86: </editor> <booktitle> Object-Oriented Programming Systems, Languages and Applications: Conf. Proc., </booktitle> <address> Portland, OR, USA, </address> <month> 29 Sep - 2 Oct </month> <year> 1986, </year> <pages> pages 224-31. </pages> <year> 1986. </year> <journal> (SIGPLAN Notices, </journal> <volume> 21(11)). </volume>
Reference-contexts: Significantly, authors of different solutions point out very overlapping pros and cons of each paradigm, though having set forth completely different purposes in their merging efforts <ref> [BMS90, FH86, FY88, IC90, KE88] </ref>. Modularity, encapsulation and sharing (both classed sharing, i.e. inheritance, and flexible one, i.e. polymorphism etc.) constitute the advantages of the OO paradigm. Declarative framework with pattern matching, unification and backtracking are the main beneficial characteristics of the logic approach. <p> a concrete application|the LOOKS/Glaucoma medical expert system|there are three worlds: the object-world, which is formalized as described above, the decision-world, containing heuristic knowledge in a rule-oriented language, and the patient-world, being defined by simply making assertions. world-demo is exploited to dispatch interaction of the worlds. 3.4.6 SPOOL The language SPOOL <ref> [FH86] </ref> was designed at IBM Japan Science Institute. It has been implemented on top of VM/Programming in Logic (an IBM implementation in Prolog). A class in SPOOL, similarly to LOOKS (see Subsection 3.4.5), has five properties: su-perclasses, metaclasses, instance attributes, class attributes, and methods.
Reference: [FTK + 84] <author> K. Furukawa, A. Takeuchi, S. Kunifuji, H. Yasukawa, M. Ohki, and K. Ueda. Mandala: </author> <title> A logic based knowledge programming system. </title> <booktitle> In Proc. 1984 Int'l Conf. on Fifth Gener. </booktitle> <institution> Comput. Syst., </institution> <address> Tokyo, Japan, </address> <month> 6-9 Nov </month> <year> 1984, </year> <pages> pages 613-22. </pages> <publisher> North-Holland, </publisher> <address> Amsterdam, </address> <year> 1984. </year>
Reference-contexts: Since there Prolog/KR is classless, its inheritance is similar to delegation. An advantage of Prolog/KR is its reliance on a very simple idea of worlds with a neat semantics, that allows natural expansion towards several more complicated concepts. 3.4.3 Mandala Mandala <ref> [FTK + 84] </ref> was designed at ICOT Resarch Center, Tokyo. It has been implemented on top of KL1. The latter is a logic programming language with stream-AND-parallelism like Concurrent Prolog, and was developed for the Fifth Generation Computers' project Parallel Inference Machine (PIM).
Reference: [FY88] <author> Chen Fu-an and Zhu Yi-fen. POKRS: </author> <title> A Prolog-based object-oriented knowledge representation system. </title> <booktitle> In Proc. 1988 Int'l Conf. on Syst., Man and Cy-bern., </booktitle> <institution> Beijing and Shenyang, China, </institution> <month> 8-12 Aug </month> <year> 1988, </year> <booktitle> volume 1, </booktitle> <pages> pages 285-8. </pages> <institution> Int'l Acad. Publ., Beijing, </institution> <year> 1988. </year>
Reference-contexts: Significantly, authors of different solutions point out very overlapping pros and cons of each paradigm, though having set forth completely different purposes in their merging efforts <ref> [BMS90, FH86, FY88, IC90, KE88] </ref>. Modularity, encapsulation and sharing (both classed sharing, i.e. inheritance, and flexible one, i.e. polymorphism etc.) constitute the advantages of the OO paradigm. Declarative framework with pattern matching, unification and backtracking are the main beneficial characteristics of the logic approach. <p> end. class manager has super-class employee; methods give-me-approval (Subject,approved) :- unimportant (Subject); give-me-approval (Subject,rejected) :- unreasonable (Subject); give-me-approval (pending); unimportant (domestic-trip); unreasonable (double-salary); end. employee &lt;< new (snoopy, -his-manager: charlie-). manager &lt;< new (charlie, -his-manager: X-). snoopy &lt;< request (domestic-trip). 3.4.7 POKRS = Prolog-Based Object-Oriented Knowledge Representa tion System POKRS <ref> [FY88] </ref> was designed at Hefei Polytecnic, P.R.C., to serve as an environment for large knowledge systems. POKRS has been implemented on top of the Prolog-KABA language, and is meant to run on microcomputers.
Reference: [Gal86] <author> H. Gallaire. </author> <title> Merging objects and logic programming: Relational semantics. </title> <booktitle> In AAAI-86: Proc. 5th Nat'l Conf. on AI, </booktitle> <address> Philadelfia, PA, USA, </address> <month> 11-15 Aug </month> <year> 1986, </year> <booktitle> volume 2, </booktitle> <pages> pages 754-8. </pages> <publisher> Morgan Kaufmann, </publisher> <address> Los Altos, CA, </address> <year> 1986. </year>
Reference-contexts: Method-sets are meant to incorporate more procedural, and local-KB's to incorporate more declarative knowledge, though both are expressed in Prolog syntax. POKRS offers metaclasses and multiple inheritance. Message sending is realized through the predicate send (receiver,selector,parameters). 3.4.8 POL The POL <ref> [Gal86] </ref> proposal seems to have no implementation, and is mostly theoretic. The main principles,set forth while designing POL, were the following. POL is to be a superset of Prolog. A relational framework has to be used to appropriately refine OO concepts such as inheritance and method evaluation 1 . <p> In the context of logic this means that if its given invocation failed when it was attempted to resolve the call goal with the definition clauses owned by a class (object), no definition clauses from above are searched for or tried. This kind of inheritance is called call/return in <ref> [Gal86] </ref>. Most solutions adapt this approach to inheritance. In procedural OO languages, concatenation of method definitions might not make sense. It would yield a new method with its invocation equivalent to serial invocation of the original ones. <p> Thus it may turn out reasonable to let method definitions cumulate down the hierarchy. This is what is called the success/failure understanding of inheritance in <ref> [Gal86] </ref>. The ultimate purpose of a method invocation according to it is not to get the invocation result somehow, but to get it result successfully, if possible. 3.6. Comparison 47 In Prolog/KR, ESP, and POL, cumulation is the default inheritance mode.
Reference: [GM87] <author> J. A. Goguen and J. Meseguer. </author> <title> Unifying functional, object-oriented and relational programming with logical semantics. </title> <editor> In B. Shriver and P. Wegner, editors, </editor> <booktitle> Research Directions in Object-Oriented Programming, </booktitle> <pages> pages 417-77. </pages> <publisher> The MIT Press, </publisher> <address> Cambridge, MA, </address> <year> 1987. </year>
Reference-contexts: The second is rather to bring them together into a synergistic unification under a new subsuming paradigm, which may require both original paradigms to undergo major transformation (hybrid mergers). The second approach has been underlined in [BMS90], though it is disputable whether it actually is followed there. In <ref> [GM87] </ref>, concern is expressed about the dangers of integration for the sake of integration, 13 14 Chapter 3. Reported Mergers stating that "experience (with languages like PL/I) has shown that patching together features from different paradigms in an ad hoc way results in a complex language without intellectual coherence". <p> If square.a-&gt;square.s queried, no numerical solution is possible, and the analytic solution s=a^2 will be synthesized. NUT is an advanced, more object-oriented version of PRIZ. 3.5.3 FOOPlog The FOOPlog proposal <ref> [GM87] </ref>, similarly to PRIZ and NUT, takes a non-traditional standpoint about logic. Usually, functionality, logic, and OO are viewed as (the) three orthogonal paradigms. The authors of FOOPlog claim, on the contrary, that actually, only two orthogonal paradigms|logical and OO|exist. <p> Errors are therefore handled as normal data of error supersorts, and this in a sense legalizes error situations. An analogous technique is also utilized with classes, where error superclasses are associated with user-defined classes. In <ref> [GM87] </ref> FOOPS is discussed thoroughly, mainly from the perspective of the ideas on ADT's and abstract machines, and also on reflection.
Reference: [HE90] <author> B. Henderson-Sellers and J. M. Edwards. </author> <title> Object-oriented systems life cycle. </title> <journal> Comm. ACM, </journal> <volume> 33(9) </volume> <pages> 142-59, </pages> <year> 1990. </year>
Reference-contexts: The idea of logic might support requirements specification but prove ineffecient later. Functional programming fits many kinds of problems but produces poorly readable programs (deep nestings!), being difficult to maintain. The OO paradigm claims to be universal in this respect <ref> [KM90, HE90] </ref>. We return to this point later. Different paradigms need different languages and tools|compilers, software engineering environments|to support software development "in accordance with them". These must encourage, not merely enable to work within both the facilities and discipline (purposely introduced limitations) foreseen by the paradigm [Str88]. <p> Evolution in OO involves two levels. Requirements evolution means stepwise (top-down) refinement of the specification. Solution by evolution is the inverse: a synthesizing activity, building up a solution (bottom-up) in an incremental manner. The OO philosophy is to provide a uniform approach for the whole software lifecycle <ref> [HE90] </ref>. In [BGHS91], it is even claimed that the evolutionary approach is unique to OO computing. Though the latter statement is disputable|stepwise prototyping, for instance, is thinkable also within other paradigms|the evolutionary feature of OO still provides powerful support to exploratory programming. <p> OO is often claimed to be equally suitable for all the phases of the software lifecycle. The evolutionary principle of OO is in correspondence with the very idea of systematic development. The arguments on the benefits of this circumstance from <ref> [HE90, KM90] </ref>, plus some of ours, can be briefly summarized as follows: * As OO applies to all lifecycle phases, no "translation" from the output documentation of one phase into an input document of the next phase is needed. <p> Moreover, such output can possibly even serve as an initial layer for the next phase. * The above-mentioned diffusion of phases makes their boundaries blurring. * The lack of distinct boundaries and the iterative nature of OO development (the "fountain model" of software lifecycle <ref> [HE90] </ref>) amplify each other. One one hand, due to the diffusion, reiteration in the software development process is not as painful as it is in more traditional paradigms.
Reference: [HV87] <author> M. Huber and I. Varsek. </author> <title> Extended Prolog for order-sorted resolution. </title> <booktitle> In Proc. 1987 Symp. on Logic Programming, </booktitle> <address> San Fransisco, CA, USA, </address> <month> 31 Aug - 4 Sep </month> <year> 1987, </year> <pages> pages 34-43. </pages> <publisher> IEEE Comp. Soc. Press, </publisher> <address> Washington, DC, </address> <year> 1987. </year>
Reference-contexts: To provide such a counterpart, order-sorted logics have been developed [Wal89, Obe89, Sch89]. In order-sorted logics, a partial ordering is defined between sorts which basically is a subsort/supersort relation. A good example of an order-sorted logic based language is EPOS (Extended Prolog for Order-Sorted Resolution) <ref> [HV87] </ref>. The LOGIN Prolog extension, which laid the basis for ALF, can be also viewed as relying on a variant of order-sorted logic. Its main peculiarity is that since there are no sorts in LOGIN, it is individuals that are ordered there. <p> The reason for such separating of taxonomic knowledge is that we want to obtain better computational efficiency by letting unification instead of resolution to infer property bindings. The same approach has been taken in both LOGIN [AN86] and EPOS <ref> [HV87] </ref>, and is particularly emphasized in the latter. 4.4 Tasks of the Layers In order to determine the tasks of each layer, we return to the four principles of OO that we reviewed in Subsection 2.2.1.
Reference: [IC90] <author> M. H. Ibrahim and F. A. Cummins. KSL/Logic: </author> <title> Integration of logic with objects. </title> <booktitle> In Proc. 1990 Int'l Conf. on Comp. Languages, </booktitle> <address> New Orleans, LA, USA, </address> <month> 12-15 Mar </month> <year> 1990, </year> <pages> pages 228-35. </pages> <publisher> IEEE Comp. Soc. Press, Los Alamitos, </publisher> <address> CA, </address> <year> 1990. </year>
Reference-contexts: Significantly, authors of different solutions point out very overlapping pros and cons of each paradigm, though having set forth completely different purposes in their merging efforts <ref> [BMS90, FH86, FY88, IC90, KE88] </ref>. Modularity, encapsulation and sharing (both classed sharing, i.e. inheritance, and flexible one, i.e. polymorphism etc.) constitute the advantages of the OO paradigm. Declarative framework with pattern matching, unification and backtracking are the main beneficial characteristics of the logic approach. <p> There is also a relation to constraint logic programming (for a survey on the perspectives of the latter, see [JL88]). A careful study on this connection might be worthwhile. 3.2.3 KSL/Logic The language KSL/Logic <ref> [IC90] </ref> is a product from Detroit R&D, MI, USA, and is an extension to KSL. The latter is a "pure" object-oriented language where "everything is object" (variables, methods, main programs etc. incl.). All objects in KSL belong to classes, and all activities are initiated by message-passing.
Reference: [IT86] <author> Y. Ishikawa and M. Tokoro. </author> <title> Concurrent object-oriented knowledge representation language Orient84/K: Its features and implementation. </title> <editor> In N. Meyrowitz, editor, OOPSLA'86: </editor> <booktitle> Object-Oriented Programming Systems, Languages and Applications: Conf. Proc., </booktitle> <address> Portland, OR, USA, </address> <month> 29 Sep - 2 Oct </month> <year> 1986, </year> <pages> pages 232-41. </pages> <year> 1986. </year> <journal> (SIGPLAN Notices, </journal> <volume> 21(11)). </volume>
Reference-contexts: One paradigm has remained ruling and provided the basis language, while features from the other one have been adjusted to suit that context. In one case, a "language interface" was reported. Hybrid mergers are of special interest. 3.2 Introducing Logical Features Into OO Languages 3.2.1 Orient84/K The language Orient84/K <ref> [TI84, IT86] </ref>, designed at Keyo University, Japan, relies on the so-called distributed knowledge object modelling (the authors' method for OO knowledge systems). The syntax and semantics of Orient84/K owe much to, and are extended from Smalltalk80. It has the metaclass/class/instance distinction, and allows multiple inheritance.
Reference: [JL88] <author> J. Jaffar and J.-L. Lassez. </author> <title> From unification to constraints. </title> <editor> In K. Furukawa, H. Tanaka, and T. Fujisaki, editors, </editor> <booktitle> Logic Programming '87: Proc. 6th Conf., </booktitle> <address> Tokyo, Japan, 22-24 June 1987. </address> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1988. </year> <note> (LNCS, 315). BIBLIOGRAPHY 111 </note>
Reference-contexts: There is also a relation to constraint logic programming (for a survey on the perspectives of the latter, see <ref> [JL88] </ref>). A careful study on this connection might be worthwhile. 3.2.3 KSL/Logic The language KSL/Logic [IC90] is a product from Detroit R&D, MI, USA, and is an extension to KSL. The latter is a "pure" object-oriented language where "everything is object" (variables, methods, main programs etc. incl.).
Reference: [KE88] <author> T. Koschmann and M. W. Evens. </author> <title> Bridging the gap between object-oriented and logic programming. </title> <journal> IEEE Software, </journal> <volume> 5(5) </volume> <pages> 36-42, </pages> <year> 1988. </year>
Reference-contexts: Significantly, authors of different solutions point out very overlapping pros and cons of each paradigm, though having set forth completely different purposes in their merging efforts <ref> [BMS90, FH86, FY88, IC90, KE88] </ref>. Modularity, encapsulation and sharing (both classed sharing, i.e. inheritance, and flexible one, i.e. polymorphism etc.) constitute the advantages of the OO paradigm. Declarative framework with pattern matching, unification and backtracking are the main beneficial characteristics of the logic approach. <p> For each of these resolutions, the KSL Print message will access the value bound to the %QualifiedPerson. 3.3. Interfacing Languages of Different Paradigms 17 3.3 Interfacing Languages of Different Paradigms 3.3.1 Prolog/Loops The article <ref> [KE88] </ref> reports on a language interface designed at Xerox AI Systems, IL, USA. It is ambitiously titled "Bridging the gap between object-oriented and logic programming". Unfortunately, the solution is more like "filling in", rather than elegantly bridging the gap.
Reference: [KG86] <author> H. Kauffmann and A. Grumbach. MULTILOG: </author> <booktitle> MULtiple worlds in LOGic programming. In ECAI'86: 7th Europ. Conf. on Artif. Intelligence: Proc., </booktitle> <address> Brighton, UK, </address> <month> 21-25 July </month> <year> 1986, </year> <booktitle> volume 1, </booktitle> <pages> pages 291-305. </pages> <year> 1986. </year>
Reference-contexts: From among the solutions reviewed in Chapter 3, Prolog/KR, Mandala, and CPU take this approach. From among proper modal enhancements of Prolog we mention two. An interesting MULTILOG proposal <ref> [KG86] </ref> has not been directly related to OO by its authors, but its possible connections are obvious. The MOLOG proposal [Far86] does not pretend to offer modularization, but instead allows a very wide understanding of modal operators. In the OO applications of the "modal logic paradigm", the accessibility relation 4.2. <p> It is obvious that the two formulations which we herewith made in our terminology, are reformulations of each other. The fact that inheritance along revisions provides a solution to the frame problem, was first explicitly pointed out in the MULTILOG proposal <ref> [KG86] </ref>. Property definitions (value assignments) will be represented by clauses annotated with their owners. Inter-unit taxonomic knowledge (i.e. the isa relations), on the contrary, will be not represented in "normal" clauses.
Reference: [KLW90] <author> M. Kifer, G. Lausen, and J. Wu. </author> <title> Logical foundations of object-oriented and frame-based languages. </title> <type> Technical Report 90/14, </type> <institution> SUNY at Stony Brook, Dept. of Comput. Sci., </institution> <month> August </month> <year> 1990. </year> <pages> 84 pp. </pages>
Reference-contexts: At the present stage, the designed logics allow only objects be dynamic, while the isa links between them must be static. Only when the present thesis was in the stage of completion, the author got to know about the work by M. Kifer et al. <ref> [KLW90] </ref>. Even basing on superficial acquaintance with the mentioned work, it is evident that a major breaktrough has been made there. The connection between the formalisms of the present thesis and that work deserves studying.
Reference: [KM90] <author> T. Korson and J. D. McGregor. </author> <title> Understanding object-oriented: A unifying paradigm. </title> <journal> Comm. ACM, </journal> <volume> 33(9) </volume> <pages> 40-60, </pages> <year> 1990. </year>
Reference-contexts: This especially important with fastly evolving areas. Several attempts have been made to unify the views on OO, e.g. in <ref> [Str88, KM90, BGHS91] </ref>. <p> The idea of logic might support requirements specification but prove ineffecient later. Functional programming fits many kinds of problems but produces poorly readable programs (deep nestings!), being difficult to maintain. The OO paradigm claims to be universal in this respect <ref> [KM90, HE90] </ref>. We return to this point later. Different paradigms need different languages and tools|compilers, software engineering environments|to support software development "in accordance with them". These must encourage, not merely enable to work within both the facilities and discipline (purposely introduced limitations) foreseen by the paradigm [Str88]. <p> Unfortunately, the carefully and systematically introduced terminology of the first chapters is not always adhered to in these further studies, e.g. with regards to polymorphism, and distinctive features of set, class and type. In <ref> [KM90] </ref>, a different unifying OO paradigm is suggested, where the principles and basic concepts of OO, and the problems of lifecycle model and tools are considered in parallel. 2.2. <p> The interface of a module (the discipline enforced) is called its behavior. Sometimes, behavior is also referred to as specification to emphasize its difference from implementation (the hidden part of the module). Another pair of principles is used <ref> [KM90] </ref> to express approximately the same ideas. Strong cohesion and weak coupling are guidelines for modularization. A module should be sufficiently self-contained and independent on other modules. Coupling of modules is further weakened through information hiding. Behavior sharing deals with interfaces. <p> OO is often claimed to be equally suitable for all the phases of the software lifecycle. The evolutionary principle of OO is in correspondence with the very idea of systematic development. The arguments on the benefits of this circumstance from <ref> [HE90, KM90] </ref>, plus some of ours, can be briefly summarized as follows: * As OO applies to all lifecycle phases, no "translation" from the output documentation of one phase into an input document of the next phase is needed.
Reference: [KTMB87] <author> K. Kahn, E. D. Tribble, M. S. Miller, and D. G. Bobrow. Vulcan: </author> <title> Logical concurrent objects. </title> <editor> In B. Shriver and P. Wegner, editors, </editor> <booktitle> Research Directions in Object-Oriented Programming, </booktitle> <pages> pages 75-112. </pages> <publisher> The MIT Press, </publisher> <address> Cambridge, MA, </address> <year> 1987. </year>
Reference-contexts: To facilitate communication between instances, special queue units are used to serve as communication channels. By that, senders and receivers of messages are subordinated to auxiliary request sender metaunits and request server metaunits. 3.4.10 Vulcan The language Vulcan <ref> [KTMB87] </ref> was designed at Xerox PARC, CA, USA. It is a higher level language, translating into Concurrent Prolog.
Reference: [LM88] <author> L. Leonardi and P. Mello. </author> <title> Combining logic- and object-oriented programming language paradigms. </title> <editor> In B. D. Shriver, editor, </editor> <booktitle> Proc. 21st Annual Hawaii Int'l Conf. on Syst. Sci., </booktitle> <volume> volume 2, </volume> <pages> pages 376-85. </pages> <publisher> IEEE Comp. Soc. Press, </publisher> <address> Wash-ington, DC, </address> <year> 1988. </year>
Reference-contexts: In those languages, the user-end representation of an object is a logical variable. In some of the solutions where objects are represented by atoms, anonymous (intensional) messages are allowed. In writing such messages, the receiver object is left open by indicating an uninstantiated logical variable as its ID. In <ref> [LM88] </ref>, it is pointed out that Zaniolo's proposal essentially supports a variant of intensionality. In that language, a receiver can be a partially specified object of a given class, represented by a literal with containing uninstantiated variables in its argument terms. <p> Attributes in those languages are represented by ("illogical") variables similar to those used in procedural languages. Among more logical approaches to tretaing state changes, two are the most wide-spread. In <ref> [LM88] </ref> they are called procedural states and declarative states, respectively. * Predominantly, states are revised using the assert and retract built-in predicates. 44 Chapter 3. Reported Mergers Language Base language Obj. repr. Class repr. Instance creation Inst./Class rel. Cl./Supercl. hier. Metacl. repr. Cl./Mtcl. hier. Other hier's decl. kind decl. decl.
Reference: [LV91] <author> E. Laenens and D. Vermeir. </author> <title> A logical basis for object-oriented programming. </title> <booktitle> In Logics in AI: European Workshop JELIA'90: Proc., </booktitle> <address> Amsterdam, NL, </address> <month> 10-14 Sep </month> <year> 1990, </year> <pages> pages 317-32. </pages> <publisher> Springer-Verlag, </publisher> <address> Berlin, 1991. </address> <publisher> (LNAI, </publisher> <pages> 478). </pages>
Reference-contexts: If negation by failure (the not predicate) is supported, a complicated non-monotonicity emerges in LOCO. There exist programs for which there is no unique minimal model etc. The logical theory behind LOCO, the so-called ordered logic, has been thoroughly studied in <ref> [LV91] </ref>. LOCO has an automatic versioning feature (former revisions of objects get a numeric suffix). Also, to objects clauses can be attached that execute at updates (triggering, cf. access-orientation). 3.4.13 Objects as Intensions W. Chen and D. S.
Reference: [LVV89] <author> E. Laenens, D. Vermeir, and B. Verdonk. LOCO, </author> <title> a logic-based language for complex objects. </title> <booktitle> In ESPRIT'89: Proc. 6th Annual ESPRIT Conf., </booktitle> <address> Brussels, Belgium, </address> <month> 27 Nov - 1 Dec </month> <year> 1989, </year> <pages> pages 604-16. </pages> <publisher> Kluwer Acad. Publ., </publisher> <address> Dordrecht et al., </address> <year> 1989. </year>
Reference-contexts: In order to protect locality, the asserta, assertz and retract predicates are forbidden as goals of a remote calls. 30 Chapter 3. Reported Mergers SCOOP also facilitates concurrency, and has a discrete simulation capability. 3.4.12 LOCO = LOgic for Complex Objects The design philosophy of the LOCO <ref> [LVV89] </ref> language is very different from that admitted in most merging attempts basing on Prolog. The language syntax closely resembles Prolog, but the treatment of the concept of predicate is rather unusual.
Reference: [Mel88] <author> F. Mellender. </author> <title> An integration of logic and object-oriented programming. </title> <journal> SIG-PLAN Notices, </journal> <volume> 23(10) </volume> <pages> 181-5, </pages> <year> 1988. </year>
Reference-contexts: These approaches usually rely on advanced generalizations of some characteristics of the "source" paradigms. A selection of them is reviewed below. 3.5.1 ALF = Alltalk Logic Facility ALF <ref> [Mel88] </ref> has been developed to offer a Prolog-like model for logic programming to the users of Alltalk, a system which provides persistence to Smalltalk objects without adding new language syntax.
Reference: [Mel91] <author> P. Mello. </author> <title> Inheritance as combination of Horn clause theories. </title> <editor> In M. Lenz-erini, D. Nardi, and M. Simi, editors, </editor> <booktitle> Inheritance Hierarchies in Knowledge Representation and Programming Languages, </booktitle> <pages> pages 275-89. </pages> <editor> J. </editor> <publisher> Wiley & Sons, </publisher> <address> Chichester, UK, </address> <year> 1991. </year>
Reference-contexts: applied to some object does not suppress further search for solutions for other objects, and|similarly|withdefault can apply to some object, although solutions for some other objects might have been found already). 3.4.9 CPU = Communicating Prolog Units The keyword of the solution originally proposed in [MN87], and further elaborated in <ref> [Mel91] </ref>, is metaprogramming (similarly to Mandala, Subsection 3.4.3). While the main task of metaclasses in traditional object-oriented systems is to serve as templates for classes, the role of metaprogramming in logic programming languages is more general [BK82].
Reference: [Mes90] <author> J. Meseguer. </author> <title> A logical theory of concurrent objects. </title> <editor> In N. Meyrowitz, editor, </editor> <booktitle> OOPSLA ECOOP '90 Proc.: Conf. on Object-Oriented Programming: Systems, Languages and Applications, Europ. Conf. on Object-Oriented Programming, </booktitle> <address> Ottawa, Canada, </address> <month> 21-25 Oct </month> <year> 1990, </year> <pages> pages 101-15. </pages> <year> 1990. </year> <journal> (SIGPLAN Notices, </journal> <month> 20(10)). </month>
Reference-contexts: The concrete details of FOOPlog (which would be our main interest), the interaction of OO and relations in this language, are not considered in that paper, unfortunately. 3.5.4 Maude The language Maude <ref> [Mes90] </ref> is a further development on the line of OBJ, FOOPS, and FOOPlog.
Reference: [Mil86] <author> D. Miller. </author> <title> A theory of modules for logic programming. </title> <booktitle> In Proc. 1986 Symp. on Logic Programming, </booktitle> <address> Salt Lake City, UT, USA, </address> <month> 22-25 Sep </month> <year> 1986, </year> <pages> pages 106-14. </pages> <publisher> IEEE Comp. Soc. Press, </publisher> <address> Washington, DC, </address> <year> 1986. </year>
Reference-contexts: Note that in OO, such a distinction between structuring directions would not work, since the OO objects and classes are a hybrid of programs and data (data-drivenness). As examples of works in the direction of modularization, we mention <ref> [Mil86] </ref>, [Che87], and [Day89]. A number of studies has also been carried out where modules are viewed as worlds, with more or less explicit parallels drawn to the possible-worlds' semantics of modal logics. From among the solutions reviewed in Chapter 3, Prolog/KR, Mandala, and CPU take this approach.
Reference: [MLV89] <author> J. Malenfant, G. Lapalme, and J. Vaucher. ObjVProlog: </author> <title> Metaclasses in logic. </title> <editor> In S. Cook, editor, ECOOP'89: </editor> <booktitle> Proc. 1989 Europ. Conf. on Object-Oriented Programming, </booktitle> <address> Nottingham, UK, </address> <month> 10-14 July </month> <year> 1989, </year> <pages> pages 257-69. </pages> <publisher> Univ. Press, </publisher> <address> Cambridge, UK, </address> <year> 1989. </year> <note> 112 BIBLIOGRAPHY </note>
Reference-contexts: In this, turnbacks in time are involved, and so time is reversible in a sense!! 3.4.15 ObjVProlog The design of the ObjVProlog <ref> [MLV89] </ref> language has been guided by the example of Ob-jVLisp model, which provides metaclasses and handles metaclass/class/instance concepts in a systematic and reflexive way. It was proposed by the same research group that earlier worked out SCOOP (see Subsection 3.4.11).
Reference: [MN86] <author> P. Mello and A. Natali. </author> <title> Programs as collections of communicating Prolog units. </title> <editor> In B. Robinet and R. Wilhelm, editors, </editor> <booktitle> ESOP 86: Europ. Symp. on Programming: Proc., Saarbrucken, </booktitle> <address> Germany, </address> <month> 17-19 Mar </month> <year> 1986, </year> <pages> pages 274-88. </pages> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1986. </year> <note> (LNCS, 213). </note>
Reference-contexts: We will also use modal logic. Since for the logic paradigm, modules specifically are lists of clauses ("chunks of knowledge"), we decide to underline this specificity by calling them units within this paradigm in the rest of this thesis. This is in harmony with the terminology of <ref> [MN86] </ref>. 4.3 Units. Two dimensions of evolution In the previous section, we decided that in the design of the internal layer, we will proceed from the modularization direction of Prolog structuring. In this section, we determine what will the main building blocks, i.e. units be.
Reference: [MN87] <author> P. Mello and A. Natali. </author> <title> Objects as communicating Prolog units. </title> <editor> In J. Bezivin, J.-M. Hullot, P. Cointe, and H. Lieberman, editors, ECOOP'87: </editor> <booktitle> Europ. Conf. on Object-Oriented Programming: Proc., </booktitle> <address> Paris, France, </address> <month> 15-17 June </month> <year> 1987, </year> <pages> pages 181-92. </pages> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1987. </year> <note> (LNCS, 276). </note>
Reference-contexts: of relevant classes (i.e. withdeterministic applied to some object does not suppress further search for solutions for other objects, and|similarly|withdefault can apply to some object, although solutions for some other objects might have been found already). 3.4.9 CPU = Communicating Prolog Units The keyword of the solution originally proposed in <ref> [MN87] </ref>, and further elaborated in [Mel91], is metaprogramming (similarly to Mandala, Subsection 3.4.3). While the main task of metaclasses in traditional object-oriented systems is to serve as templates for classes, the role of metaprogramming in logic programming languages is more general [BK82].
Reference: [MOK84] <author> F. Misoguchi, H. Owhada, and Y. Katayama. </author> <title> LOOKS: Knowledge representation system for designing expert systems in logic programming framework. </title> <booktitle> In Proc. 1984 Int'l Conf. on Fifth Gener. </booktitle> <institution> Comput. Syst., </institution> <address> Tokyo, Japan, </address> <month> 6-9 Nov </month> <year> 1984, </year> <pages> pages 606-12. </pages> <publisher> North-Holland, </publisher> <address> Amsterdam, </address> <year> 1984. </year>
Reference-contexts: ESP also exploits metaprogramming, but only for defining macros (to simplify writing of arithmetical computations etc.). 3.4.5 LOOKS = Logic-Oriented Organized Knowledge System LOOKS <ref> [MOK84] </ref>, like Mandala and ESP (see Subsections 3.4.3 and 3.4.4, resp.), owes its birth to the Fifth Generation Computers' project. It has been implemented in DEC-10 Prolog. A LOOKS class has five properties: superclasses, metaclasses, instance attributes, class attributes, and methods.
Reference: [Mos90] <author> C. Moss. </author> <title> An introduction to Prolog++. </title> <type> Research Report DOC 90/10, </type> <institution> Imperial College, </institution> <address> London, </address> <month> June </month> <year> 1990. </year>
Reference-contexts: P2::display. :: is used as message sending operator here. First, a class point as a subclass of object, and then an instance P2 of point are created. Finally, P2 is displayed. 3.4.16 Prolog++ Prolog++ <ref> [Mos90] </ref> was developed by Phil Vasey at LPA, and is a layer on top of Prolog. Prolog++ is a classless language, and what it terms as inheritance, is like delegation (cf. LOCO, Subsection 3.4.12). <p> Towards a New Solution: Kernel Ideas and Logical Basis 4.11.1 Family Relationships Example In this example, taken from <ref> [Mos90] </ref>, the father of a family is stored only in the object for the eldest of children. For each person, his next older and next younger siblings are stored in his/her object. Data about the father for non-eldest children other siblings can be derived.
Reference: [MP90] <author> L. Monteiro and A. Porto. </author> <title> Semantic and syntactic inheritance in logic programming. </title> <type> Draft report, </type> <institution> Departamento de Informatica, Universidade Nova de Lisboa, </institution> <month> December </month> <year> 1990. </year> <pages> 12 pp. </pages>
Reference-contexts: Subsection 4.6.5 comments on the full (predicate) MU U . In Subsec tion 4.6.6 explains some principal obstacles to straightforward improvements of MU U . 4.6.1 Motivation L. Monteiro and A. Porto <ref> [MP90] </ref> distinguish between two orthogonal dimensions in modes of inheritance. Along the first dimension, inheritance can be cumulative (they call it extension mode) or overriding. This distinction is not new (cf. Section 3.6). Along the second, novel dimension, inheritance can be semantic or syntactic. Suppose that u isa v. <p> Altogether, the two dimensions yield four modes: Extension Overriding Predicate PE PO Clause CE CO The following example from <ref> [MP90] </ref> demonstrates that all the four modes really differ. <p> This is an example of a case where it is not possible to annotate pairs hunit, predicatei, and goals must be annotated instead <ref> [MP90] </ref>. Annotating at goals, the "traditional" writing for this clause would be: v : p q; self : r: Besides coping with inheritance, i.e. with implicit access by unit to other units, MU U also will allow explicit access which in OO is termed as message sending.
Reference: [MT90] <author> G. E. Mints and E. H. Tyugu. </author> <title> Propositional logic programming and the PRIZ system. </title> <journal> Journal of Logic Programming, </journal> <volume> 9(3) </volume> <pages> 179-93, </pages> <year> 1990. </year>
Reference-contexts: Instances of the class AlfProgram have instance attributes ruleDictionary, author, date, comment, and name. The class attribute pgmDictionary of AlfProgram registers all Alf-Programs in the system, keyed by name. 3.5.2 PRIZ and NUT The programming environments PRIZ and NUT, developed at the Institute of Cybernetics, Estonian Academy of Sciences <ref> [MT90] </ref>, differ greatly from all solutions considered above. Both the treatment of logic and OO are non-traditional. Logic programming is understood in a broad sense as the use of constructive proofs for building correct programs, and not merely as predicate Horn clause programming.
Reference: [Nak84] <author> H. Nakashima. </author> <title> Knowledge representation in Prolog/KR. </title> <booktitle> In 1984 Int'l Symp. on Logic Programming, </booktitle> <address> Atlantic City, NJ, USA, </address> <month> 6-9 Feb </month> <year> 1984: </year> <booktitle> Conf. Proc., </booktitle> <pages> pages 126-30. </pages> <publisher> IEEE Comp. Soc. Press, </publisher> <address> Silver Spring, MD, </address> <year> 1984. </year>
Reference-contexts: They are static, and serve also as identifiers to objects|an object is essentially referred to by indicating its class and the values of its attributes. A method declared in a subclass overrides the method with the same name of the superclass. Multiple inheritance is allowed. 3.4.2 Prolog/KR Prolog/KR <ref> [Nak84] </ref> is an extension to Prolog, but was implemented originally in versions of Lisp. Its design aim was to provide Prolog with modularization in order to cope with knowledge representation tasks. Prolog/KR differs from other solutions considered in this paper, as it follows OO ideas only vaguely.
Reference: [Obe89] <author> A. </author> <title> Oberschelp. Order sorted predicate logic. </title> <editor> In K. H. Blasius, U. Hedstuck, and C.-R. Rollinger, editors, </editor> <booktitle> Sorts and Types in Artif. Intelligence: Workshop Proc., </booktitle> <address> Eringerfeld, FRG, </address> <month> 24-26 Apr </month> <year> 1989, </year> <pages> pages 8-17. </pages> <publisher> Springer-Verlag, </publisher> <address> Berlin, 1989. </address> <publisher> (LNAI, </publisher> <pages> 418). </pages>
Reference-contexts: Thus, sorts closely correspond to types. Plain many-sorted logic offers no relations between sorts. Hence, the subtype/supertype relation has no counterpart there. To provide such a counterpart, order-sorted logics have been developed <ref> [Wal89, Obe89, Sch89] </ref>. In order-sorted logics, a partial ordering is defined between sorts which basically is a subsort/supersort relation. A good example of an order-sorted logic based language is EPOS (Extended Prolog for Order-Sorted Resolution) [HV87].
Reference: [Ohl88] <author> H. J. Ohlbach. </author> <title> A resolution calculus for modal logics. </title> <editor> In E. Lusk and R. Over-beek, editors, </editor> <booktitle> 9th Int'l Conf. on Automated Deduction: Proc., </booktitle> <address> Argonne, IL, USA, </address> <month> 23-26 May </month> <year> 1988, </year> <pages> pages 500-16. </pages> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1988. </year> <note> (LNCS, 310). </note>
Reference-contexts: The so-called Lemmon notation for these most known normal modal logics consists in indicating the axioms' code-names. We can talk about logics KD, KT, KT4 (S4), KTB4 (=KT5, S5), KD45 etc. There are many papers discussing how resolution systems for modal logics must look like, see e.g. <ref> [AM86, Cha87, Ohl88] </ref>.
Reference: [Ohl90] <author> H. J. Ohlbach. </author> <title> New ways for developing proof theories for first-order multimodal logics. </title> <editor> In E. Borger, H. Kleine Buning, and M. M. Richter, editors, CSL'89: </editor> <booktitle> 3rd Workshop on Comp. Sci. Logic: Proc., </booktitle> <address> Kaiserslautern, FRG, </address> <month> 2-6 Oct </month> <year> 1989, </year> <pages> pages 271-308. </pages> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1990. </year> <note> (LNCS, 440). </note>
Reference-contexts: Towards a New Solution: Kernel Ideas and Logical Basis restrictions on individual accessibility relations enforced by the corresponding unimodal logics, plus by additional restrictions on the whole family of accessibility relations, that result from the incestuality axioms. Resolution systems for multimodal logics are thoroughly discussed in <ref> [Ohl90] </ref>. The MOLOG and MULTILOG Prolog developments that we referred to in Section 4.2 already, are also both multimodal. The next four sections (Sections 4.6-4.9) work out and study the concrete modal logics for the internal layer.
Reference: [Sch89] <author> P. H. Schmidt. </author> <title> Tableau calculus for order sorted logic. </title> <editor> In K. H. Blasius, U. Hedstuck, and C.-R. Rollinger, editors, </editor> <booktitle> Sorts and Types in Artif. Intelligence: Workshop Proc., </booktitle> <address> Eringerfeld, FRG, </address> <month> 24-26 Apr </month> <year> 1989, </year> <pages> pages 49-60. </pages> <publisher> Springer-Verlag, </publisher> <address> Berlin, 1989. </address> <publisher> (LNAI, </publisher> <pages> 418). </pages>
Reference-contexts: Thus, sorts closely correspond to types. Plain many-sorted logic offers no relations between sorts. Hence, the subtype/supertype relation has no counterpart there. To provide such a counterpart, order-sorted logics have been developed <ref> [Wal89, Obe89, Sch89] </ref>. In order-sorted logics, a partial ordering is defined between sorts which basically is a subsort/supersort relation. A good example of an order-sorted logic based language is EPOS (Extended Prolog for Order-Sorted Resolution) [HV87].
Reference: [Sho88] <author> Y. Shoham. </author> <title> Reasoning about Change: Time and Causation from the Standpoint of Artificial Intelligence. </title> <publisher> The MIT Press, </publisher> <address> Cambridge, MA, </address> <year> 1988. </year> <pages> 201 pp. </pages>
Reference-contexts: Object revisions would not have allowed restoration of object universe revisions, because the succession of revising different objects would not have been recorded. In his major work on time in AI <ref> [Sho88, p 19] </ref>, Y. Shoham argues that two problems connected to time|the persistence problem and the frame problem|essentially coincide. The persistence problem lies in predicting that a piece of knowledge, valid at the present time instant, will remain valid troughout a lengthy future interval.
Reference: [ST83] <author> E. Shapiro and A. Takeuchi. </author> <title> Object oriented programming in Concurrent Prolog. </title> <journal> New Gener. Computing, </journal> <volume> 1(1) </volume> <pages> 25-48, </pages> <year> 1983. </year>
Reference-contexts: It is a higher level language, translating into Concurrent Prolog. It draws heavily from the approach by Shapiro and Takeuchi <ref> [ST83] </ref> to OO in Concurrent Prolog, thus basically being a syntactic sugaring to remedy some syntactic awkwardness and verbosity of OO programming in the "bare" Concurrent Prolog. The key ideas behind Vulcan are similar to those of Mandala, but there is no meta-interpretative processing at run-time in Vulcan.
Reference: [Ste87] <author> L. A. Stein. </author> <title> Delegation is inheritance. </title> <editor> In N. Meyrowitz, editor, OOPSLA'87: </editor> <booktitle> Object-Oriented Programming Systems, Languages and Applications: Conf. BIBLIOGRAPHY 113 Proc., </booktitle> <address> Orlando, FL, USA, </address> <month> 4-8 Oct </month> <year> 1987, </year> <pages> pages 138-46. </pages> <year> 1987. </year> <journal> (SIGPLAN Notices, </journal> <volume> 22(12)). </volume>
Reference-contexts: If an object delegates some properties| attributes or method|to another object (its prototype), then they will be stored only in the prototype. Any changes to those properties will affect both the object and the prototype. In this way, the object and the prototype mutually depend on each other. In <ref> [Ste87] </ref>, it has been proven formally that inheritance and delegation can model each other to a certain extent. The proof that inheritance can model delegation, is based on the observation that strict inheritance is "delegation on the class-level". <p> The LOCO understanding of predicate enables expression of default and delegation mechanisms. The authors of LOCO claim that, in their approach to the concept of object, inheritance becomes a special case of delegation. This is even stronger a claim than that by Stein <ref> [Ste87] </ref> discussed above. As an example of the LOCO delegation, consider: gonzales = -name ("Gonzales"). profession ("hotelkeeper"). owns-nautilus-. owns-neptuno-. ...-; (gonzales) pedro = -name ("Pedro"). owns (perdoInn).-; pedro inherits everything thats true about gonzales, except for the latter's name which is overruled.
Reference: [Str88] <author> B. Stroustrup. </author> <title> What is object-oriented programming? IEEE Software, </title> <booktitle> 5(3) </booktitle> <pages> 10-20, </pages> <year> 1988. </year>
Reference-contexts: This especially important with fastly evolving areas. Several attempts have been made to unify the views on OO, e.g. in <ref> [Str88, KM90, BGHS91] </ref>. <p> We return to this point later. Different paradigms need different languages and tools|compilers, software engineering environments|to support software development "in accordance with them". These must encourage, not merely enable to work within both the facilities and discipline (purposely introduced limitations) foreseen by the paradigm <ref> [Str88] </ref>. A software development paradigm can be compared to a world-view. It is relatively easy to work fluently with a couple of languages, but to reorient oneself onto a new paradigm is hard. And even if one succeeds, quick switches back and forth remain still difficult.
Reference: [TI84] <author> M. Tokoro and Y. Ishikawa. </author> <title> An object-oriented approach to knowledge systems. </title> <booktitle> In Proc. 1984 Int'l Conf. on Fifth Gener. </booktitle> <institution> Comput. Syst., </institution> <address> Tokyo, Japan, </address> <month> 6-9 Nov </month> <year> 1984, </year> <pages> pages 623-31. </pages> <publisher> North-Holland, </publisher> <address> Amsterdam, </address> <year> 1984. </year>
Reference-contexts: One paradigm has remained ruling and provided the basis language, while features from the other one have been adjusted to suit that context. In one case, a "language interface" was reported. Hybrid mergers are of special interest. 3.2 Introducing Logical Features Into OO Languages 3.2.1 Orient84/K The language Orient84/K <ref> [TI84, IT86] </ref>, designed at Keyo University, Japan, relies on the so-called distributed knowledge object modelling (the authors' method for OO knowledge systems). The syntax and semantics of Orient84/K owe much to, and are extended from Smalltalk80. It has the metaclass/class/instance distinction, and allows multiple inheritance.
Reference: [VLM88] <author> J. Vaucher, G. Lapalme, and J. Malenfant. SCOOP: </author> <title> Structured concurrent object-oriented Prolog. </title> <editor> In S. Gjessing and K. Nygaard, editors, ECOOP'88: </editor> <booktitle> Europ. Conf. on Object-Oriented Programming: Proc., </booktitle> <address> Oslo, Norway, </address> <month> 15-17 Aug </month> <year> 1988, </year> <pages> pages 191-211. </pages> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1988. </year> <note> (LNCS, 322). </note>
Reference-contexts: Terms appear effective in modelling immutable (static) objects: if attribute variables do not change, there is no need to store the message stream within an object to distinguish between its revisions. 3.4.11 SCOOP = Structured Concurrent Object-Oriented Prolog The language SCOOP <ref> [VLM88] </ref> was developed at University of Montreal as an experimental extension of Prolog. Both classes and objects are modelled through Horn clause databases. All objects of a particular class have a common set of predicates. Each predicate is either static or dynamic.
Reference: [Wal88] <author> L. A. Wallen. </author> <title> Automated theorem proving in non-classical logics. </title> <editor> In T. Danielsen, editor, </editor> <booktitle> Scand. Conf. on Artif. Intelligence: Proc. </booktitle> <address> SCAI'88, Tromso, Norway, </address> <month> 9-11 Mar </month> <year> 1988, </year> <pages> pages 1-12. </pages> <publisher> IOS, </publisher> <address> Amsterdam, </address> <year> 1988. </year>
Reference-contexts: Thus, these distinctions will appear necessary only in the front-end layer. 4.5 An Introduction to Modal Logic The word `logic' has two meanings: a framework for analysis, and a tool for representation and reasoning <ref> [Wal88] </ref>. The first meaning implies that logic is a branch of science; the second implies that logics (multiple!) are triples hlanguage, deduction mechanism, semanticsi being studied in this branch of science. The phrase `modal logic' likewise has two meanings.
Reference: [Wal89] <author> C. Walther. </author> <title> Many-sorted inferences in automated theorem proving. </title> <editor> In K. H. Blasius, U. Hedstuck, and C.-R. Rollinger, editors, </editor> <booktitle> Sorts and Types in Artif. Intelligence: Workshop Proc., </booktitle> <address> Eringerfeld, FRG, </address> <month> 24-26 Apr </month> <year> 1989, </year> <pages> pages 19-48. </pages> <publisher> Springer-Verlag, </publisher> <address> Berlin, 1989. </address> <publisher> (LNAI, </publisher> <pages> 418). </pages>
Reference-contexts: Thus, sorts closely correspond to types. Plain many-sorted logic offers no relations between sorts. Hence, the subtype/supertype relation has no counterpart there. To provide such a counterpart, order-sorted logics have been developed <ref> [Wal89, Obe89, Sch89] </ref>. In order-sorted logics, a partial ordering is defined between sorts which basically is a subsort/supersort relation. A good example of an order-sorted logic based language is EPOS (Extended Prolog for Order-Sorted Resolution) [HV87].
Reference: [Weg87] <author> P. Wegner. </author> <title> The object-oriented classification paradigm. </title> <editor> In B. Shriver and P. Wegner, editors, </editor> <booktitle> Research Directions in Object-Oriented Programming, </booktitle> <pages> pages 479-560. </pages> <publisher> The MIT Press, </publisher> <address> Cambridge, MA, </address> <year> 1987. </year>
Reference-contexts: Subtyping in ADT's is defined through the conformance rules. Polymorphism Polymorphism provides flexible typing disciplines. It is defined as an ability for an entity to act as of more than one type. According to a classic taxonomy by Cardelli and Wegner <ref> [Weg87] </ref>, techniques of polymorphism can be divided into ad hoc and universal. Ad hoc techniques are older and work only on a specific number of types in an unprincipled way. The best known of these techniques are coercion and overloading.
Reference: [WWE89] <author> S. N. Woodfield, J. M. Weston, and D. W. Embley. </author> <title> Combining three conceptual models: Abstract data types, logic programming, and databases. </title> <booktitle> In 8th Annual Int'l Phoenix Conf. on Computers and Comm's: 1989 Conf. Proc., </booktitle> <address> Scottsdale, AZ, USA, </address> <month> 22-24 Mar </month> <year> 1989, </year> <pages> pages 322-6. </pages> <publisher> IEEE Comp. Soc. Press, </publisher> <address> Washington, DC, </address> <year> 1989. </year>
Reference-contexts: Most of modifications that might give them a logical blend, bring along increased complexity. Despite this, for the sake of uniformity, these modifications sometimes still are used. Such ideals are seldom fully appreciated by practical people. The authors of a combination of ADT's, logic programming, and databases <ref> [WWE89] </ref>, for instance, write, ". . . Also, it would be better if operations that change the state of the system were made first class (read: 49 50 Chapter 4.
Reference: [Zan84] <author> C. Zaniolo. </author> <title> Object-oriented programming in Prolog. </title> <booktitle> In Proc. 1984 Int'l Symp. on Logic. Programming, </booktitle> <address> Atlantic City, NJ, USA, </address> <month> 6-9 Feb </month> <year> 1984, </year> <pages> pages 265-70. </pages> <publisher> IEEE Comp. Soc. Press, </publisher> <address> Silver Spring, MD, </address> <year> 1984. </year>
Reference-contexts: Generally, disturbing overhead is often the case when integration is achieved through introduction of the features of one paradigm into a language of another. 3.4 Introducing OO Features Into Logic Languages 3.4.1 Extension to Prolog by Zaniolo The extension to Prolog suggested by C. Zaniolo, Bell Laboratories, NJ, USA <ref> [Zan84] </ref>, is an early attempt to introduce OO features into a logic language. Three xfx operators isa, with and : have been implemented on top of UNSW Prolog.
References-found: 61

