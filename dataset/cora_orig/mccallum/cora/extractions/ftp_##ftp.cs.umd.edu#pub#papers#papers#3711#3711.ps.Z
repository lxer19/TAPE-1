URL: ftp://ftp.cs.umd.edu/pub/papers/papers/3711/3711.ps.Z
Refering-URL: http://www.cs.umd.edu/TRs/authors/Anurag_Acharya-no-abs.html
Root-URL: 
Email: facha,saltzg@cs.umd.edu  
Title: Compiler-directed Dynamic Linking for Mobile Programs  
Author: Anurag Acharya Joel Saltz 
Address: College Park 20742  
Affiliation: UMIACS and Department of Computer Science University of Maryland,  
Abstract: In this paper, we present a compiler-directed technique for safe dynamic linking for mobile programs. Our technique guarantees that linking failures can occur only when a program arrives at a new execution site and that this failure can be delivered to the program as an error code or an exception. We use interprocedural analysis to identify the set of names that must be linked at the different sites the program executes on. We use a combination of runtime and compile-time techniques to identify the calling context and to link only the names needed in that context. Our technique is able to handle recursive programs as well as separately compiled code that may itself be able to move. We discuss language constructs for controlling the behavior of dynamic linking and the implication of some of these constructs for application structure.
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> G. Agrawal, A. Acharya, and J. Saltz. </author> <title> An interprocedural framework for placement of asynchronous I/O operations. </title> <booktitle> In Proceedings of the 1996 International Conference on Supercomputing, </booktitle> <pages> pages 358-65, </pages> <month> May </month> <year> 1996. </year>
Reference-contexts: Extending our analysis to programs that use higher-order functions or to programs that can move without an explicit operation is beyond the scope of this paper. We use a modified version of the full-program representation (FPR) introduced by Agrawal et al <ref> [1, 2] </ref>. In our version, a program is represented by a directed multigraph; nodes correspond to program points and edges correspond to a control-flow path or paths between program points.
Reference: [2] <author> G. Agrawal, J. Saltz, and R. Das. </author> <title> Interprocedural partial redundancy elimination and its application to distributed memory compilation. </title> <booktitle> In Proceedings of the ACM SIGPLAN'95 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 258-69, </pages> <month> Jun </month> <year> 1995. </year>
Reference-contexts: Extending our analysis to programs that use higher-order functions or to programs that can move without an explicit operation is beyond the scope of this paper. We use a modified version of the full-program representation (FPR) introduced by Agrawal et al <ref> [1, 2] </ref>. In our version, a program is represented by a directed multigraph; nodes correspond to program points and edges correspond to a control-flow path or paths between program points.
Reference: [3] <author> A. Birrell, G. Nelson, S. Owicki, and E. Wobber. </author> <title> Network objects. </title> <booktitle> In Proceedings of the 14th ACM Symposium on Operating System Principles, </booktitle> <pages> pages 217-30, </pages> <month> Dec </month> <year> 1993. </year>
Reference-contexts: An example of this would be the net import () primitive provided by Obliq [4] (as well the NetObj.Import primitive provided by Network Objects <ref> [3] </ref> that has been used to implement it). <p> At the simplest level, the eval (env,expr) primitive that has long been available allows the user to control the bindings for the free variables in the expression expr. Obliq [4] and Network Objects <ref> [3] </ref> allow the programmer to query a name-server and obtain a reference which can then be bound to a name in the program. The fragmented-objects model [17, 18] proposed by Shapiro includes a detailed interface for binding and unbinding references 10 in a distributed system.
Reference: [4] <author> L. Cardelli. </author> <title> A language with distributed scope. </title> <booktitle> In Proceedings of the 22nd ACM Symposium on Principles of Programming Languages, </booktitle> <month> Jan. </month> <year> 1995. </year>
Reference-contexts: Third, sticky links cannot be rebound, user-specified linking can rebind names. * user-specified linking: in this case, the user explicitly specifies which names are to be bound to which operations on which sites. An example of this would be the net import () primitive provided by Obliq <ref> [4] </ref> (as well the NetObj.Import primitive provided by Network Objects [3] that has been used to implement it). <p> At the simplest level, the eval (env,expr) primitive that has long been available allows the user to control the bindings for the free variables in the expression expr. Obliq <ref> [4] </ref> and Network Objects [3] allow the programmer to query a name-server and obtain a reference which can then be bound to a name in the program. The fragmented-objects model [17, 18] proposed by Shapiro includes a detailed interface for binding and unbinding references 10 in a distributed system. <p> They do not address the issue of determining what needs to be linked. Dynamic linking issues for mobile programs, in particular the need to be able to name procedures that access resources local to an execution site, have been previously considered by Cardelli <ref> [4] </ref> and Knabe [7]. The Obliq language presented in [4] handles this problem by packaging the execution environment available at a site as an object and using its methods to access the procedures available at that site. <p> Dynamic linking issues for mobile programs, in particular the need to be able to name procedures that access resources local to an execution site, have been previously considered by Cardelli <ref> [4] </ref> and Knabe [7]. The Obliq language presented in [4] handles this problem by packaging the execution environment available at a site as an object and using its methods to access the procedures available at that site. The responsibility of determining whether the environment available on a host provides all names needed by the program resides with the user.
Reference: [5] <author> L. Cardelli. </author> <title> Mobile computation. </title> <note> Position Paper, 1995. http://www.research.digital.com/SRC/personal /Luca Cardelli/Papers/MobileComputationPosition.ps. 11 </note>
Reference-contexts: At migration points, the execution stack and the heap of the program are transferred from original host to the target host; execution continues at the target host. Mobile programs have been proposed as a suitable model of computation for the Internet <ref> [5, 16, 21] </ref>. To access local resources or to use site-specific operations available at individual hosts, they need to be able to name them. The mapping between program names and local procedures/operations has to be established dynamically. There are three reasons for this.
Reference: [6] <author> C. Cowan, T. Autrey, C. Krasic, C. Pu, and J. Walpole. </author> <title> Fast concurrent dynamic linking for an adaptive operating system. </title> <booktitle> In Proceedings of the Third International Conference on Configurable Distributed Systems, </booktitle> <pages> pages 108-15, </pages> <month> May </month> <year> 1996. </year>
Reference-contexts: These schemes provide varying degrees of flexibility and convenience but all of them require the user to explicit manage the linking. There has also been considerable work on efficient (and safe) implementation of dynamic linking, particularly in the context of shared libraries and kernel extensions <ref> [6, 10, 13, 14, 19] </ref>. These schemes focus on the linking procedure and the performance of the linked code. They do not address the issue of determining what needs to be linked.
Reference: [7] <author> F.C.Knabe. </author> <title> Language and compiler support for mobile agents. </title> <type> PhD Thesis, </type> <institution> Carnegie Mellon University, </institution> <month> Nov. </month> <year> 1995. </year>
Reference-contexts: They do not address the issue of determining what needs to be linked. Dynamic linking issues for mobile programs, in particular the need to be able to name procedures that access resources local to an execution site, have been previously considered by Cardelli [4] and Knabe <ref> [7] </ref>. The Obliq language presented in [4] handles this problem by packaging the execution environment available at a site as an object and using its methods to access the procedures available at that site. <p> The responsibility of determining whether the environment available on a host provides all names needed by the program resides with the user. Knabe <ref> [7] </ref> proposes that certain functions be specified to be ubiquitous that is, they are available on all sites and that all remaining code should be carried by the mobile program.
Reference: [8] <author> D. Gelernter and S. Jagannathan. </author> <title> Environments as first class objects. </title> <booktitle> In Proceedings of the 14th Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 98-110, </pages> <month> Jan </month> <year> 1987. </year>
Reference-contexts: The fragmented-objects model [17, 18] proposed by Shapiro includes a detailed interface for binding and unbinding references 10 in a distributed system. First-class environments <ref> [8] </ref> can also be used for various scenarios in whch user--specified linking might be useful. Miller&Rozas [12] propose to use first-class environments to remove the need for a distinguished top-level interaction environment for Scheme.
Reference: [9] <author> J. Gosling and H. McGilton. </author> <title> The Java language environment white paper, </title> <year> 1995. </year>
Reference-contexts: There are two approaches for dealing with this problem. The first is to make sure that the execution environment on every host is exactly identical. This restriction is stronger than requiring that every host provide a well-known interface (for example, the Java T M <ref> [9] </ref> API). Instead it requires that every environment provide nothing else. This would eliminate an important reason for program mobility.
Reference: [10] <author> E. Ho, C. Wei-Chau, and L. Leung. </author> <title> Optimizing the performance of dynamically-linked programs. </title> <booktitle> In Proceedings of the 1995 USENIX Technical Conference, </booktitle> <pages> pages 225-33, </pages> <month> Jan </month> <year> 1995. </year>
Reference-contexts: These schemes provide varying degrees of flexibility and convenience but all of them require the user to explicit manage the linking. There has also been considerable work on efficient (and safe) implementation of dynamic linking, particularly in the context of shared libraries and kernel extensions <ref> [6, 10, 13, 14, 19] </ref>. These schemes focus on the linking procedure and the performance of the linked code. They do not address the issue of determining what needs to be linked.
Reference: [11] <author> S. Jagannathan. </author> <title> Dynamic modules in higher-order languages. </title> <booktitle> In Proceedings of the 1994 International Conference on Computer Languages, </booktitle> <pages> pages 74-87, </pages> <month> May </month> <year> 1994. </year>
Reference-contexts: First-class environments [8] can also be used for various scenarios in whch user--specified linking might be useful. Miller&Rozas [12] propose to use first-class environments to remove the need for a distinguished top-level interaction environment for Scheme. Jagannathan <ref> [11] </ref> proposes a reification operator that returns the current environment as a first-class object and a reflection operator that merges a set of bindings from a named environment into the current environment. Queinnec&DeRoure [15] propose a chain-environment function which can compose environments.
Reference: [12] <author> J. Miller and G. Rozas. </author> <title> Free variables and first-class environments. </title> <journal> Lisp and Symbolic Computation, </journal> <volume> 4(2) </volume> <pages> 107-41, </pages> <month> Apr </month> <year> 1991. </year>
Reference-contexts: The fragmented-objects model [17, 18] proposed by Shapiro includes a detailed interface for binding and unbinding references 10 in a distributed system. First-class environments [8] can also be used for various scenarios in whch user--specified linking might be useful. Miller&Rozas <ref> [12] </ref> propose to use first-class environments to remove the need for a distinguished top-level interaction environment for Scheme.
Reference: [13] <author> M. Nelson and G. Hamilton. </author> <title> High performance dynamic linking through caching. </title> <booktitle> In Proceedings of the Summer 1993 USENIX Conference, </booktitle> <pages> pages 253-65, </pages> <year> 1993. </year>
Reference-contexts: These schemes provide varying degrees of flexibility and convenience but all of them require the user to explicit manage the linking. There has also been considerable work on efficient (and safe) implementation of dynamic linking, particularly in the context of shared libraries and kernel extensions <ref> [6, 10, 13, 14, 19] </ref>. These schemes focus on the linking procedure and the performance of the linked code. They do not address the issue of determining what needs to be linked.
Reference: [14] <author> D. Orr, J. Bonn, J. Lepreau, and R. Mecklenburg. </author> <title> Fast and flexible shared libraries. </title> <booktitle> In Proceedings of the Summer 1993 USENIX Conference, </booktitle> <pages> pages 237-51, </pages> <year> 1993. </year>
Reference-contexts: These schemes provide varying degrees of flexibility and convenience but all of them require the user to explicit manage the linking. There has also been considerable work on efficient (and safe) implementation of dynamic linking, particularly in the context of shared libraries and kernel extensions <ref> [6, 10, 13, 14, 19] </ref>. These schemes focus on the linking procedure and the performance of the linked code. They do not address the issue of determining what needs to be linked.
Reference: [15] <author> C. Queinnec and D. D. Roure. </author> <title> Sharing code through first-class environments. </title> <booktitle> In Proceedings of the 1996 International Conference on Functional Programming, </booktitle> <month> May </month> <year> 1996. </year>
Reference-contexts: Jagannathan [11] proposes a reification operator that returns the current environment as a first-class object and a reflection operator that merges a set of bindings from a named environment into the current environment. Queinnec&DeRoure <ref> [15] </ref> propose a chain-environment function which can compose environments. This can be used to share common enviornments between different programs/users. These schemes provide varying degrees of flexibility and convenience but all of them require the user to explicit manage the linking.
Reference: [16] <author> M. Ranganathan, A. Acharya, S. Sharma, and J. Saltz. </author> <title> Network-aware mobile programs. </title> <booktitle> In Proceedings of the 1997 USENIX Annual Technical Conference, </booktitle> <month> Jan </month> <year> 1997. </year> <note> To appear. </note>
Reference-contexts: At migration points, the execution stack and the heap of the program are transferred from original host to the target host; execution continues at the target host. Mobile programs have been proposed as a suitable model of computation for the Internet <ref> [5, 16, 21] </ref>. To access local resources or to use site-specific operations available at individual hosts, they need to be able to name them. The mapping between program names and local procedures/operations has to be established dynamically. There are three reasons for this.
Reference: [17] <author> M. Shapiro. </author> <title> Flexible bindings for fine-grain distributed objects. </title> <type> Technical Report 2007, </type> <institution> Institut National de Recherche et en Automatique, </institution> <month> August </month> <year> 1993. </year>
Reference-contexts: Obliq [4] and Network Objects [3] allow the programmer to query a name-server and obtain a reference which can then be bound to a name in the program. The fragmented-objects model <ref> [17, 18] </ref> proposed by Shapiro includes a detailed interface for binding and unbinding references 10 in a distributed system. First-class environments [8] can also be used for various scenarios in whch user--specified linking might be useful.
Reference: [18] <author> M. Shapiro. </author> <title> A binding protocol for distributed shared objects. </title> <booktitle> In Proceedings of the 14th International Conference on Distributed Systems, </booktitle> <month> Jun </month> <year> 1994. </year>
Reference-contexts: Obliq [4] and Network Objects [3] allow the programmer to query a name-server and obtain a reference which can then be bound to a name in the program. The fragmented-objects model <ref> [17, 18] </ref> proposed by Shapiro includes a detailed interface for binding and unbinding references 10 in a distributed system. First-class environments [8] can also be used for various scenarios in whch user--specified linking might be useful.
Reference: [19] <author> E. Sirer, M. Fiucynski, P. Pardyak, and B. Bershad. </author> <title> Safe dynamic linking in an extensible operating system. </title> <booktitle> In The First Workshop on Compiler Support for System Software, </booktitle> <month> Feb </month> <year> 1996. </year>
Reference-contexts: These schemes provide varying degrees of flexibility and convenience but all of them require the user to explicit manage the linking. There has also been considerable work on efficient (and safe) implementation of dynamic linking, particularly in the context of shared libraries and kernel extensions <ref> [6, 10, 13, 14, 19] </ref>. These schemes focus on the linking procedure and the performance of the linked code. They do not address the issue of determining what needs to be linked.
Reference: [20] <author> J. White. </author> <title> Talk at the DAGS'96 Workshop on Transportable Agents, </title> <month> Sep </month> <year> 1996. </year>
Reference-contexts: That is, all the code that is to be linked in dynamically does not contain a call to go. We then relax this constraint and show how separately compiled mobile code can be dealt with. This also allows our technique to deal with library sites <ref> [20] </ref>. Library sites are an intriguing idea these are sites that provide pre-compiled mobile code that can be picked up by mobile programs for execution on other sites.
Reference: [21] <author> J. White. </author> <title> Telescript Technology: </title> <booktitle> Mobile Agents, </booktitle> <year> 1996. </year> <note> http://www.genmagic.com/Telescript/Whitepapers. </note>
Reference-contexts: At migration points, the execution stack and the heap of the program are transferred from original host to the target host; execution continues at the target host. Mobile programs have been proposed as a suitable model of computation for the Internet <ref> [5, 16, 21] </ref>. To access local resources or to use site-specific operations available at individual hosts, they need to be able to name them. The mapping between program names and local procedures/operations has to be established dynamically. There are three reasons for this.
Reference: [22] <author> M. Wolfe. </author> <title> High Performance Compilers for Parallel Computing. </title> <publisher> Addison-Wesley, </publisher> <year> 1995. </year> <month> 12 </month>
Reference-contexts: point B is visible from program point A iff there exists at least one path from A to B in the control-flow graph that has no call to go; calls to go are said to hide the code that they 2 dominate (in the sense of dominators in control-flow graphs <ref> [22] </ref>). We refer to the set of gos visible from a particular go as its departure-set. If the program arrives at a host by this go and it does not terminate on this host, it will depart from the host via one of the calls in the departure-set.
References-found: 22

