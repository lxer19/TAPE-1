URL: ftp://ftp.cs.utexas.edu/pub/predator/das-thesis.ps
Refering-URL: http://www.cs.utexas.edu/users/schwartz/pub.htm
Root-URL: http://www.cs.utexas.edu
Title: by  
Author: Dinesh Das 
Date: 1995  
Note: Copyright  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> M. M. Astrahan et al. </author> <title> System R: Relational approach to database management. </title> <journal> ACM Transactions on Database Systems, </journal> <volume> 1(2) </volume> <pages> 97-137, </pages> <month> June </month> <year> 1976. </year>
Reference-contexts: Below, we briefly review some related work on optimizers. 4 1.2 Related Work 1.2.1 Traditional Query Optimizers The System R optimizer [46] was one of the earliest query optimizers proposed and implemented. It was built for the System R database system <ref> [1] </ref>. System R is a centralized, relational DBMS where users specify their queries in SQL. The System R optimizer is still the de facto industry standard; it was the first to show the practical viability of query optimization in a commercial setting. <p> algorithm argument:al arg ! required [0] ! tuple order = needed phy prop ! tuple order ; 5. ret value ! algorithm argument:al arg ! cost = ret value ! algorithm argument:al arg ! desc [0] ! log prop ! cardinality fl ret value ! algorithm argument:al arg ! desc <ref> [1] </ref> ! log prop ! cardinality ; g Support function derive Nested loops phy prop f == book-keeping statements 6. algorithm argument ! phy prop ! tuple order = input phy prop [0] ! tuple order ; g (b) P2V-generated impl rule and support functions corresponding to the I-rule in (a).
Reference: [2] <author> Don Batory. </author> <title> Modeling the storage architectures of commercial database systems. </title> <journal> ACM Transactions on Database Systems, </journal> <volume> 10(4) </volume> <pages> 463-528, </pages> <month> December </month> <year> 1985. </year>
Reference-contexts: Database management systems (DBMSs) are large-scale software systems that can also benefit from a component-based approach. The first system to demonstrate the feasibil 76 ity of this idea was Genesis <ref> [2, 3, 5, 6, 12] </ref>. A DBI created a customized DBMS by composing several pre-defined components with standard interfaces. The result was a DBMS that was tailored to the needs of a particular application.
Reference: [3] <author> Don Batory. </author> <title> Extensible cost models and query optimization in GENESIS. </title> <journal> Database Engineering, </journal> <volume> 9(4) </volume> <pages> 30-36, </pages> <month> December </month> <year> 1986. </year>
Reference-contexts: Database management systems (DBMSs) are large-scale software systems that can also benefit from a component-based approach. The first system to demonstrate the feasibil 76 ity of this idea was Genesis <ref> [2, 3, 5, 6, 12] </ref>. A DBI created a customized DBMS by composing several pre-defined components with standard interfaces. The result was a DBMS that was tailored to the needs of a particular application.
Reference: [4] <author> Don Batory. </author> <title> Building blocks of database management systems. </title> <type> Technical Report TR 87-23, </type> <institution> The University of Texas at Austin, </institution> <month> February </month> <year> 1988. </year>
Reference-contexts: The need to have extensible database systems, and in turn extensible optimizers, has long been recognized in systems like EXODUS [17], Starburst [43], Genesis <ref> [4] </ref>, and Post-gres [49]. Rule-based query optimizers [25, 28, 30, 31, 33, 36] are among the major conceptual advances that have been proposed to deal with query optimizer extensibility. <p> This means that layers can have multiple parameters, each of which can be instantiated by a layer. For example, a retrieval layer implementing an abstract RET operator with the index scan algorithm may require an additional parameter to define the implementation of the index. Experience with Genesis <ref> [4] </ref> has shown that such parameterized layers can capture the semantics of many widely used optimization algorithms. Extending Prairie to allow such compositions will necessi tate a modification of P2V's layer compaction algorithm. * Extensible search strategies is another important area of future work.
Reference: [5] <author> Don Batory. </author> <title> On the reusability of query optimization algorithms. </title> <journal> Information Systems, </journal> <volume> 49(1/3), </volume> <year> 1989. </year>
Reference-contexts: Database management systems (DBMSs) are large-scale software systems that can also benefit from a component-based approach. The first system to demonstrate the feasibil 76 ity of this idea was Genesis <ref> [2, 3, 5, 6, 12] </ref>. A DBI created a customized DBMS by composing several pre-defined components with standard interfaces. The result was a DBMS that was tailored to the needs of a particular application.
Reference: [6] <author> Don Batory. </author> <title> The Genesis database system compiler: User manual. </title> <type> Technical Report TR 90-27, </type> <institution> The University of Texas at Austin, </institution> <month> August </month> <year> 1990. </year>
Reference-contexts: Database management systems (DBMSs) are large-scale software systems that can also benefit from a component-based approach. The first system to demonstrate the feasibil 76 ity of this idea was Genesis <ref> [2, 3, 5, 6, 12] </ref>. A DBI created a customized DBMS by composing several pre-defined components with standard interfaces. The result was a DBMS that was tailored to the needs of a particular application.
Reference: [7] <author> Don Batory, Lou Coglianese, Mark Goodwin, and Steve Shafer. </author> <title> Creating reference architectures: An example from avionics. </title> <booktitle> In Proceedings Symposium on Software Reusability, </booktitle> <address> Seattle, </address> <month> April </month> <year> 1995. </year>
Reference: [8] <author> Don Batory and Bart Geraci. </author> <title> Validating component compositions in software system generators. </title> <type> Technical Report TR 95-03, </type> <institution> The University of Texas at Austin, </institution> <year> 1995. </year> <month> 113 </month>
Reference-contexts: Symmetric layers can, thus, be composed in arbitrary ways; this provides DBIs many ways to construct optimizers using the same layers. However, not all the compositions are necessarily meaningful or correct. Batory and Geraci <ref> [8] </ref> describe methods for validating the correctness of component compositions. We will assume that compositions of our layers are always correct. We will not address the problem of validating layer compositions; we are aware these problems are present. <p> It is formed by composing the SE-4 The layer ordering of Figure 6.5 is actually an example of a composition error, in that the SEQUENTIAL layer should lie above all join layers for it to be useful. Errors like this can be detected using Batory and Geraci's algorithms <ref> [8] </ref>. 87 SEQUENTIAL JOIN (S 1 ; S 2 ) =)! JOIN (S 2 ; S 1 ) JOIN (JOIN (S 1 ; S 2 ); S 3 ) =) JOIN (S 1 ; JOIN (S 2 ; S 3 )) JOIN (S 1 ; S 2 ) =) JOIN CONC <p> This affords a much greater flexibility in layer composition. However, not all legal compositions are necessarily valid or meaningful. This implies a need for some validation techniques that can detect invalid compositions. Batory and Geraci <ref> [8] </ref> describe a useful method for design rule checking in layered systems that validates layer compositions. A future goal is to integrate this validation into the P2V preprocessor. * Multi-phase query optimizers are being investigated as a means of limiting the enormous size of the search spaces in most optimizers.
Reference: [9] <author> Don Batory and Sean O'Malley. </author> <title> The design and implementation of hierarchical soft-ware systems with reusable components. </title> <journal> ACM Transactions on Software Engineering and Methodology, </journal> <volume> 1(4) </volume> <pages> 355-398, </pages> <month> October </month> <year> 1992. </year>
Reference-contexts: The extensions described here were made easier by the clean design and abstractions embodied in Prairie. 6.1 Overview Large-scale software development is an expensive undertaking. An approach that has been proposed is that of using software components <ref> [9, 11, 26, 27] </ref>. These components, typically used as building-blocks to construct larger systems, have well-defined and standardized imported (input) and exported (output) interfaces. A system is developed by fitting together components whose interfaces match one another. <p> The term concrete refers to the fact that they are obtained by transforming abstract operators through the use of rules; concrete operators of a layer can also be viewed as calls to abstract operators of lower layers. Layers in Prairie follow the GenVoca paradigm <ref> [9] </ref>. <p> Layers in Prairie are usually symmetric; that is, they have export interfaces that are the same as their import interfaces <ref> [9] </ref>. Typically, these interfaces are comprised of all the abstract operators in the particular database schema at hand. Symmetric layers can, thus, be composed in arbitrary ways; this provides DBIs many ways to construct optimizers using the same layers. However, not all the compositions are necessarily meaningful or correct. <p> First, rules can now be declared as belonging to a specific layer (a layer declaration demarcates rule definitions). Second, the optimizer can be defined as a composition of layers. This composition is defined as a type expression <ref> [9] </ref> 79 expressed as a linear sequence of layers. This is described in more detail in the next section. An example layer is shown in Figure 6.1 (b).
Reference: [10] <author> Don Batory, Vivek Singhal, Marty Sirkin, and Jeff Thomas. </author> <title> Scalable software libraries. </title> <booktitle> In Proceedings 1993 ACM SIGSOFT Conference, </booktitle> <pages> pages 191-199, </pages> <address> Los An-geles, </address> <month> December </month> <year> 1993. </year>
Reference-contexts: The ideas incorporated in Genesis are not unique to databases; in fact, the GenVoca paradigm [7-9, 11] has shown that the same component-based approach also applies to networks, avionics, file systems, and data structures. The P2 generator <ref> [10, 11] </ref>, in particular, has demonstrated that very efficient container data structures can be generated from a small family of plug-compatible components. Query optimizers are integral to most DBMSs. They also tend to be a significant and complex part of a DBMS. <p> We discuss the model, together with a few simple examples, and show how the P2V preprocessor, described in Chapter 4, can be used to quickly generate 77 efficient rule sets from component-based specifications. Currently, the P2 generator <ref> [10, 11] </ref> does not have a framework for quickly generating efficient full-fledged optimizers. The ultimate goal of the research described in this chapter is to integrate the Prairie specification language into P2 to enable automatic generation of rule-based optimizers. <p> Our primary goal in this chapter was to quickly design and implement a practical framework for specifying layered optimizers. Future work can add more generality to this approach. An important goal is to use Prairie to automatically generate efficient optimizers in P2 <ref> [10, 11] </ref>. 98 Chapter 7 Conclusion This dissertation described Prairie, an algebraic framework for rule-specification in query optimizers.
Reference: [11] <author> Don Batory, Vivek Singhal, Jeff Thomas, Sankar Dasari, Bart Geraci, and Marty Sirkin. </author> <title> The GenVoca model of software-system generators. </title> <journal> IEEE Software, </journal> <volume> 11(5) </volume> <pages> 89-94, </pages> <month> September </month> <year> 1994. </year>
Reference-contexts: The extensions described here were made easier by the clean design and abstractions embodied in Prairie. 6.1 Overview Large-scale software development is an expensive undertaking. An approach that has been proposed is that of using software components <ref> [9, 11, 26, 27] </ref>. These components, typically used as building-blocks to construct larger systems, have well-defined and standardized imported (input) and exported (output) interfaces. A system is developed by fitting together components whose interfaces match one another. <p> A DBI created a customized DBMS by composing several pre-defined components with standard interfaces. The result was a DBMS that was tailored to the needs of a particular application. The ideas incorporated in Genesis are not unique to databases; in fact, the GenVoca paradigm <ref> [7-9, 11] </ref> has shown that the same component-based approach also applies to networks, avionics, file systems, and data structures. The P2 generator [10, 11], in particular, has demonstrated that very efficient container data structures can be generated from a small family of plug-compatible components. <p> The ideas incorporated in Genesis are not unique to databases; in fact, the GenVoca paradigm [7-9, 11] has shown that the same component-based approach also applies to networks, avionics, file systems, and data structures. The P2 generator <ref> [10, 11] </ref>, in particular, has demonstrated that very efficient container data structures can be generated from a small family of plug-compatible components. Query optimizers are integral to most DBMSs. They also tend to be a significant and complex part of a DBMS. <p> We discuss the model, together with a few simple examples, and show how the P2V preprocessor, described in Chapter 4, can be used to quickly generate 77 efficient rule sets from component-based specifications. Currently, the P2 generator <ref> [10, 11] </ref> does not have a framework for quickly generating efficient full-fledged optimizers. The ultimate goal of the research described in this chapter is to integrate the Prairie specification language into P2 to enable automatic generation of rule-based optimizers. <p> Our primary goal in this chapter was to quickly design and implement a practical framework for specifying layered optimizers. Future work can add more generality to this approach. An important goal is to use Prairie to automatically generate efficient optimizers in P2 <ref> [10, 11] </ref>. 98 Chapter 7 Conclusion This dissertation described Prairie, an algebraic framework for rule-specification in query optimizers.
Reference: [12] <author> Don Batory and Devang Vasavada. </author> <title> Software components for object-oriented database systems. </title> <journal> International Journal of Software Engineering and Knowledge Engineering, </journal> <volume> 3(2) </volume> <pages> 165-192, </pages> <year> 1993. </year>
Reference-contexts: Database management systems (DBMSs) are large-scale software systems that can also benefit from a component-based approach. The first system to demonstrate the feasibil 76 ity of this idea was Genesis <ref> [2, 3, 5, 6, 12] </ref>. A DBI created a customized DBMS by composing several pre-defined components with standard interfaces. The result was a DBMS that was tailored to the needs of a particular application.
Reference: [13] <author> Dina Bitton, David J. DeWitt, and Carolyn Turbyfill. </author> <title> Benchmarking database systems: A systematic approach. </title> <booktitle> In Proceedings 9th International Conference on Very Large Data Bases, </booktitle> <pages> pages 8-19, </pages> <address> Florence, </address> <month> November </month> <year> 1983. </year>
Reference-contexts: The problem of developing a set of representative benchmark queries to test a query processing system is a well-researched topic <ref> [13, 14, 32, 42] </ref>. However, standard benchmark queries were not very useful in our case for various reasons. <p> The problem of developing a set of representative benchmark queries to test a query processing system is a well-researched topic [13, 14, 32, 42]. However, standard benchmark queries were not very useful in our case for various reasons. For example, the Wisconsin benchmark <ref> [13] </ref> consists of no queries with more than 3 joins; moreover, this benchmark was designed to test the performance of query processors on queries consisting of the entire set of relational operators (select, project, retrieve, join, update, insert, delete, aggregation) and with a variety of algorithms implementing the various operators.
Reference: [14] <author> Dina Bitton and Carolyn Turbyfill. </author> <title> A retrospective on the wisconsin benchmark. </title> <editor> In Michael Stonebraker, editor, </editor> <booktitle> Readings in Database Systems. </booktitle> <publisher> Morgan Kaufmann, </publisher> <address> San Mateo, </address> <note> second edition, </note> <year> 1994. </year>
Reference-contexts: The problem of developing a set of representative benchmark queries to test a query processing system is a well-researched topic <ref> [13, 14, 32, 42] </ref>. However, standard benchmark queries were not very useful in our case for various reasons.
Reference: [15] <author> Jos e A. Blakeley, William J. McKenna, and Goetz Graefe. </author> <title> Experiences building the Open OODB query optimizer. </title> <booktitle> In Proceedings 1993 ACM SIGMOD International Conference on Management of Data, </booktitle> <pages> pages 287-296, </pages> <address> Washington, </address> <month> May </month> <year> 1993. </year>
Reference-contexts: A query expressed in this high-level format is parsed and transformed into an operator tree suitable for optimization. From this operator tree, the query optimizer generates an optimal access plan, which is then transformed into a C++ program ready for execution. The query optimizer in Open OODB <ref> [15] </ref> is generated using Volcano.
Reference: [16] <author> M. W. Blasgen and K. P. Eswaran. </author> <title> Storage and access in relational data bases. </title> <journal> IBM Systems Journal, </journal> <volume> 16(4) </volume> <pages> 363-377, </pages> <year> 1977. </year>
Reference-contexts: Some of the salient features it embodied are listed below: * It employed a bottom-up strategy. That is, children of nodes in an operator tree are optimized before the node itself is optimized. * It used two join algorithms, nested loops and merge join (first introduced in <ref> [16] </ref>), and two relation retrieval algorithms, segment scan and variations of index scan. * The concept of interesting orders was introduced to generate only those access plans in the search space that were likely to be part of other access plans.
Reference: [17] <author> Michael J. Carey, David J. DeWitt, Daniel Frank, Goetz Graefe, M. Muralikrishna, Joel E. Richardson, and Eugene J. Shekita. </author> <title> The architecture of the EXODUS exten 114 sible DBMS. </title> <booktitle> In Proceedings International Workshop on Object-Oriented Database Systems, </booktitle> <pages> pages 52-65, </pages> <address> Asilomar, </address> <month> September </month> <year> 1986. </year>
Reference-contexts: The need to have extensible database systems, and in turn extensible optimizers, has long been recognized in systems like EXODUS <ref> [17] </ref>, Starburst [43], Genesis [4], and Post-gres [49]. Rule-based query optimizers [25, 28, 30, 31, 33, 36] are among the major conceptual advances that have been proposed to deal with query optimizer extensibility. <p> Expressions are evaluated each time they are encountered. In addition, as in the rewrite phase of Starburst, he doesn't consider the cost transformations inherent in any query transformation; rules are 7 syntactic transformation rules. The EXODUS project <ref> [17] </ref> has similar goals as those of Starburst, to provide a framework in which DBMSs can be easily implemented as extensions of existing DBMSs, or to design completely new DBMSs.
Reference: [18] <author> Chin-Liang Chang and Richard Char-Tung Lee. </author> <title> Symbolic Logic and Mechanical Theorem Proving. </title> <publisher> Academic Press, </publisher> <year> 1973. </year>
Reference-contexts: First, the arity (i.e., the number of inputs) of the opera 5 This process is called unification because it is similar to the technique used in automatic theorem proving by resolution in first-order logic (see, e.g., <ref> [18] </ref>). 58 tors on each side of the rule must be the same. Second, the test for the T-rule must be TRUE (i.e., the rule must be unconditionally applicable).
Reference: [19] <author> Thomas Cormen, Charles Leiserson, and Ronald Rivest. </author> <title> Introduction to Algorithms. </title> <publisher> MIT Press, </publisher> <address> Cambridge, </address> <year> 1990. </year>
Reference-contexts: The System R optimizer only generates left-deep operator trees. That is, the inner input of a join operator is the retrieval of a stored file. It is easy to see that, under this assumption, the total number of distinct expressions is n!. However, System R uses dynamic programming <ref> [19] </ref> to substantially reduce this complexity. Below, we derive the complexity of the System R optimizer using dynamic programming. The optimizer constructs optimal plans for each possible join of j relations, for j = 0; : : : ; n.
Reference: [20] <author> Dean Daniels, Pat Selinger, Laura Haas, Bruce Lindsay, C. Mohan, Adrian Walker, and Paul Wilms. </author> <booktitle> An introduction to distributed query compilation in R fl . In Proceedings 2nd International Conference on Distributed Databases, </booktitle> <pages> pages 291-309, </pages> <address> Berlin, </address> <month> September </month> <year> 1982. </year>
Reference-contexts: R fl is a distributed relative of System R. The stored relations are located at distributed sites. R fl 's query processor <ref> [20, 37, 45] </ref> works in essentially the same way as that of System R, except for some subtle complications introduced by the distribution of relations. These complications arise mostly in authentication and catalog sharing between remote sites. Con ceptually, however, the R fl optimizer builds upon the System R optimizer. <p> The Ship algorithm here is assumed to be a block transfer of streams (as in R fl <ref> [20, 37, 45] </ref>); other transfer strategies (e.g., tuple-at-a-time) could be defined in this or other layers encapsulating distribution transformations. The REPLICATION layer models replicated databases. Its imported interface is a RET operator that simulates a centralized, non-replicated database.
Reference: [21] <author> Dinesh Das and Don Batory. Prairie: </author> <title> An algebraic framework for rule specification in query optimizers. In Proceedings of the Workshop on Database Query Optimizer Generators and Rule-Based Optimizers, </title> <address> pages 139-154, Dallas, </address> <month> September </month> <year> 1993. </year>
Reference-contexts: functions made rule programming much easier. 5.2.2 Generating Benchmark Queries Our experiments using the centralized optimizer consisted of optimizing randomly generated queries using the two optimizers generated, respectively, using the Prairie and the hand-written Volcano specifications. (In the remainder of this chapter, we will use Prairie 2 As reported in <ref> [21] </ref>, the savings are even greater if the Volcano rule engine is modified slightly to remove calls to support functions that are grounded by the P2V preprocessor. 63 R 1 R 2 JOIN : : : RET JOIN (a) N -way join benchmark query (b) Query optimization time (c) Number of
Reference: [22] <author> Dinesh Das and Don Batory. Prairie: </author> <title> A rule specification framework for query opti-mizers. </title> <type> Technical Report TR 94-16, </type> <institution> The University of Texas at Austin, </institution> <month> May </month> <year> 1994. </year>
Reference: [23] <author> Dinesh Das and Don Batory. Prairie: </author> <title> A rule specification framework for query op-timizers. </title> <booktitle> In Proceedings 11th International Conference on Data Engineering, </booktitle> <pages> pages 201-210, </pages> <address> Taipei, </address> <month> March </month> <year> 1995. </year>
Reference: [24] <author> Leonidas Fegaras, David Maier, and Tim Sheard. </author> <title> Specifying rule-based query opti-mizers in a reflective framework. </title> <booktitle> In Proceedings Third International Conference on Deductive and Object-Oriented Databases, </booktitle> <pages> pages 146-168, </pages> <address> Phoenix, </address> <month> December </month> <year> 1993. </year>
Reference-contexts: We will discuss the Volcano optimizer generator in greater detail in Chapter 2. Fegaras, Maier, and Sheard <ref> [24] </ref> describe a declarative optimizer generator framework for specifying query optimizers. The premise in their work is that much of the specification in current optimizers consists of procedurally defined actions; making these actions declarative results in a cleaner specification language.
Reference: [25] <author> Johann Christoph Freytag. </author> <title> A rule-based view of query optimization. </title> <booktitle> In Proceedings 1987 ACM SIGMOD International Conference on Management of Data, </booktitle> <pages> pages 173-180, </pages> <address> San Francisco, </address> <month> May </month> <year> 1987. </year> <month> 115 </month>
Reference-contexts: The need to have extensible database systems, and in turn extensible optimizers, has long been recognized in systems like EXODUS [17], Starburst [43], Genesis [4], and Post-gres [49]. Rule-based query optimizers <ref> [25, 28, 30, 31, 33, 36] </ref> are among the major conceptual advances that have been proposed to deal with query optimizer extensibility. A primary advantage of rule-based optimizers over traditional ones is the ability to introduce new functionality in a query algebra without changing the optimization algorithm. <p> In other words, the rewrite rules of Starburst are purely syntactic transformations of one query representation into another. Thus, all operator trees are subjected to all applicable rules before costs are computed and the search space can be pruned. Freytag <ref> [25] </ref> describes a rule-based query optimizer similar to Starburst. The rules are based on LISP-like representations of access plans. The rules themselves are recursively defined on smaller expressions (operator trees). Although several expressions can contain a common sub-expression, Freytag doesn't consider the possibility of sharing.
Reference: [26] <author> E. Gamma, R. Helm, R. Johnson, and J. Vlissides. </author> <title> Design Patterns: Micro--Architectures for Reusable Object-Oriented Design. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, </address> <year> 1994. </year>
Reference-contexts: The extensions described here were made easier by the clean design and abstractions embodied in Prairie. 6.1 Overview Large-scale software development is an expensive undertaking. An approach that has been proposed is that of using software components <ref> [9, 11, 26, 27] </ref>. These components, typically used as building-blocks to construct larger systems, have well-defined and standardized imported (input) and exported (output) interfaces. A system is developed by fitting together components whose interfaces match one another.
Reference: [27] <author> D. Garlan and M. Shaw. </author> <title> An introduction to software architecture. </title> <editor> In V. Ambriloa and G. Tortora, editors, </editor> <booktitle> Advances in Software Engineering and Knowledge Engineering, </booktitle> <volume> volume 1. </volume> <publisher> World Scientific Publishing Company, </publisher> <year> 1993. </year>
Reference-contexts: The extensions described here were made easier by the clean design and abstractions embodied in Prairie. 6.1 Overview Large-scale software development is an expensive undertaking. An approach that has been proposed is that of using software components <ref> [9, 11, 26, 27] </ref>. These components, typically used as building-blocks to construct larger systems, have well-defined and standardized imported (input) and exported (output) interfaces. A system is developed by fitting together components whose interfaces match one another.
Reference: [28] <author> Goetz Graefe. </author> <title> Rule-Based Query Optimization in Extensible Database Systems. </title> <type> PhD thesis, </type> <institution> University of Wisconsin-Madison, </institution> <year> 1987. </year>
Reference-contexts: The need to have extensible database systems, and in turn extensible optimizers, has long been recognized in systems like EXODUS [17], Starburst [43], Genesis [4], and Post-gres [49]. Rule-based query optimizers <ref> [25, 28, 30, 31, 33, 36] </ref> are among the major conceptual advances that have been proposed to deal with query optimizer extensibility. A primary advantage of rule-based optimizers over traditional ones is the ability to introduce new functionality in a query algebra without changing the optimization algorithm. <p> The EXODUS project [17] has similar goals as those of Starburst, to provide a framework in which DBMSs can be easily implemented as extensions of existing DBMSs, or to design completely new DBMSs. The query optimizer in EXODUS <ref> [28, 30] </ref> is, in fact, an optimizer generator which accepts the specification of the data model and operators in a description file. The optimizer generator compiles these rules, together with pre-defined rules, to generate an optimizer for the particular data model and set of operators.
Reference: [29] <author> Goetz Graefe. </author> <title> Query evaluation techniques for large databases. </title> <journal> ACM Computing Surveys, </journal> <volume> 25(2) </volume> <pages> 73-170, </pages> <month> June </month> <year> 1993. </year>
Reference-contexts: A query optimizer then transforms this operator tree into an access plan. Finally, the execution module executes the access plan to return the results of the SQL query. As shown in Figure 1.1, query optimization <ref> [29, 34, 35, 51] </ref> is an important step in query processing. It is the process of generating an efficient access plan for a database query.
Reference: [30] <author> Goetz Graefe and David J. DeWitt. </author> <title> The EXODUS optimizer generator. </title> <booktitle> In Proceedings 1987 ACM SIGMOD International Conference on Management of Data, </booktitle> <pages> pages 387-394, </pages> <address> San Francisco, </address> <month> May </month> <year> 1987. </year>
Reference-contexts: The need to have extensible database systems, and in turn extensible optimizers, has long been recognized in systems like EXODUS [17], Starburst [43], Genesis [4], and Post-gres [49]. Rule-based query optimizers <ref> [25, 28, 30, 31, 33, 36] </ref> are among the major conceptual advances that have been proposed to deal with query optimizer extensibility. A primary advantage of rule-based optimizers over traditional ones is the ability to introduce new functionality in a query algebra without changing the optimization algorithm. <p> The EXODUS project [17] has similar goals as those of Starburst, to provide a framework in which DBMSs can be easily implemented as extensions of existing DBMSs, or to design completely new DBMSs. The query optimizer in EXODUS <ref> [28, 30] </ref> is, in fact, an optimizer generator which accepts the specification of the data model and operators in a description file. The optimizer generator compiles these rules, together with pre-defined rules, to generate an optimizer for the particular data model and set of operators.
Reference: [31] <author> Goetz Graefe and William McKenna. </author> <title> The Volcano optimizer generator: Extensibility and efficient search. </title> <booktitle> In Proceedings 9th International Conference on Data Engineering, </booktitle> <pages> pages 209-218, </pages> <address> Vienna, </address> <month> April </month> <year> 1993. </year>
Reference-contexts: The need to have extensible database systems, and in turn extensible optimizers, has long been recognized in systems like EXODUS [17], Starburst [43], Genesis [4], and Post-gres [49]. Rule-based query optimizers <ref> [25, 28, 30, 31, 33, 36] </ref> are among the major conceptual advances that have been proposed to deal with query optimizer extensibility. A primary advantage of rule-based optimizers over traditional ones is the ability to introduce new functionality in a query algebra without changing the optimization algorithm. <p> In this dissertation, we propose a well-defined, algebraic framework, called Prairie, for specifying rules in a query optimizer that meets all of the four goals listed above. The algebra that we propose is similar to the rule specification languages in Starburst [36] and Volcano <ref> [31] </ref>, but provides a cleaner abstraction of the actions of an optimizer; as such, it is much easier to write and read rules in our proposed model. The algebra allows a database implementor (DBI) to specify transformations of a query using rewrite rules that may have conditions. <p> The EXODUS optimizer uses the cost factor with an exhaustive search strategy to guide the exploration of access plans. The Volcano optimizer generator project <ref> [31] </ref> evolved from the EXODUS project. It is different from all the above optimizers in one significant way: it is a top-down optimizer compared with the bottom-up strategy of the others. Operator trees are optimized starting from the root while sub-trees are not yet optimized. <p> Finally, we end with some conclusions and future work in Chapter 7. 9 Chapter 2 The Volcano Optimizer Generator This chapter describes the Volcano optimizer generator. The features that are relevant to this dissertation are presented, but more details can be found in <ref> [31, 38] </ref>. 2.1 Overview Volcano is a rule-based query optimizer generator that is designed to be flexible and extensible to specific database architectures. (Henceforth, when we talk of Volcano, we are referring to the Volcano optimizer generator.) It implements a top-down query optimizer in the sense that parents of nodes in
Reference: [32] <author> Jim Gray. </author> <title> The Benchmark Handbook for Database and Transaction Processing Systems. </title> <publisher> Morgan Kaufman, </publisher> <address> San Mateo, </address> <note> second edition, </note> <year> 1993. </year>
Reference-contexts: The problem of developing a set of representative benchmark queries to test a query processing system is a well-researched topic <ref> [13, 14, 32, 42] </ref>. However, standard benchmark queries were not very useful in our case for various reasons.
Reference: [33] <author> L. M. Haas, J. C. Freytag, G. M. Lohman, and H. Pirahesh. </author> <title> Extensible query processing in Starburst. </title> <type> Research Report RJ 6610, </type> <institution> IBM Almaden Research Center, </institution> <month> December </month> <year> 1988. </year>
Reference-contexts: The need to have extensible database systems, and in turn extensible optimizers, has long been recognized in systems like EXODUS [17], Starburst [43], Genesis [4], and Post-gres [49]. Rule-based query optimizers <ref> [25, 28, 30, 31, 33, 36] </ref> are among the major conceptual advances that have been proposed to deal with query optimizer extensibility. A primary advantage of rule-based optimizers over traditional ones is the ability to introduce new functionality in a query algebra without changing the optimization algorithm. <p> The primary advantage of rule-based query optimizers is the ability to add new operators and algorithms without a costly rewrite of the entire optimizer. Below, we review a few of the more well-known rule-based optimizers. The Starburst query optimizer <ref> [33, 36, 43] </ref> uses rules for all decisions that need to be taken by the query optimizer. The rules are functional in nature and transform a given operator tree into another. The rules are commonly those that reflect relational calculus transformations.
Reference: [34] <author> Matthias Jarke and J urgen Koch. </author> <title> Query optimization in database systems. </title> <journal> ACM Computing Surveys, </journal> <volume> 16(2) </volume> <pages> 111-152, </pages> <month> June </month> <year> 1984. </year>
Reference-contexts: A query optimizer then transforms this operator tree into an access plan. Finally, the execution module executes the access plan to return the results of the SQL query. As shown in Figure 1.1, query optimization <ref> [29, 34, 35, 51] </ref> is an important step in query processing. It is the process of generating an efficient access plan for a database query.
Reference: [35] <author> Won Kim, David S. Reiner, and Don S. Batory, </author> <title> editors. Query Processing in Database Systems. </title> <publisher> Springer-Verlag, </publisher> <year> 1985. </year> <month> 116 </month>
Reference-contexts: A query optimizer then transforms this operator tree into an access plan. Finally, the execution module executes the access plan to return the results of the SQL query. As shown in Figure 1.1, query optimization <ref> [29, 34, 35, 51] </ref> is an important step in query processing. It is the process of generating an efficient access plan for a database query.
Reference: [36] <author> Guy M. Lohman. </author> <title> Grammar-like functional rules for representing query optimization alternatives. </title> <booktitle> In Proceedings 1988 ACM SIGMOD International Conference on Management of Data, </booktitle> <pages> pages 18-27, </pages> <address> Chicago, </address> <month> June </month> <year> 1988. </year>
Reference-contexts: The need to have extensible database systems, and in turn extensible optimizers, has long been recognized in systems like EXODUS [17], Starburst [43], Genesis [4], and Post-gres [49]. Rule-based query optimizers <ref> [25, 28, 30, 31, 33, 36] </ref> are among the major conceptual advances that have been proposed to deal with query optimizer extensibility. A primary advantage of rule-based optimizers over traditional ones is the ability to introduce new functionality in a query algebra without changing the optimization algorithm. <p> In this dissertation, we propose a well-defined, algebraic framework, called Prairie, for specifying rules in a query optimizer that meets all of the four goals listed above. The algebra that we propose is similar to the rule specification languages in Starburst <ref> [36] </ref> and Volcano [31], but provides a cleaner abstraction of the actions of an optimizer; as such, it is much easier to write and read rules in our proposed model. The algebra allows a database implementor (DBI) to specify transformations of a query using rewrite rules that may have conditions. <p> The primary advantage of rule-based query optimizers is the ability to add new operators and algorithms without a costly rewrite of the entire optimizer. Below, we review a few of the more well-known rule-based optimizers. The Starburst query optimizer <ref> [33, 36, 43] </ref> uses rules for all decisions that need to be taken by the query optimizer. The rules are functional in nature and transform a given operator tree into another. The rules are commonly those that reflect relational calculus transformations. <p> Also, the rewrite phase uses heuristics to prune the search space before the optimiza tion phase; this can lead to a sub-optimal plan. Lohman describes rules for the optimization phase of Starburst <ref> [36] </ref>. These rules represent alternative access paths, join algorithms, and site choices in a distributed DBMS. However, even though these rules transform an operator tree into a valid access plan, the cost computation is not done until all rules are applied.
Reference: [37] <author> Guy M. Lohman, C. Mohan, Laura M. Haas, Bruce G. Lindsay, Patricia G. Selinger, Paul F. Wilms, and Dean Daniels. </author> <title> Query processing in R fl . Research Report RJ 4272, </title> <institution> IBM Research Laboratory, </institution> <address> San Jose, </address> <month> April </month> <year> 1984. </year>
Reference-contexts: R fl is a distributed relative of System R. The stored relations are located at distributed sites. R fl 's query processor <ref> [20, 37, 45] </ref> works in essentially the same way as that of System R, except for some subtle complications introduced by the distribution of relations. These complications arise mostly in authentication and catalog sharing between remote sites. Con ceptually, however, the R fl optimizer builds upon the System R optimizer. <p> The Ship algorithm here is assumed to be a block transfer of streams (as in R fl <ref> [20, 37, 45] </ref>); other transfer strategies (e.g., tuple-at-a-time) could be defined in this or other layers encapsulating distribution transformations. The REPLICATION layer models replicated databases. Its imported interface is a RET operator that simulates a centralized, non-replicated database.
Reference: [38] <author> William McKenna. </author> <title> Efficient Search in Extensible Database Query Optimization: The Volcano Optimizer Generator. </title> <type> PhD thesis, </type> <institution> University of Colorado at Boulder, </institution> <year> 1993. </year>
Reference-contexts: Finally, we end with some conclusions and future work in Chapter 7. 9 Chapter 2 The Volcano Optimizer Generator This chapter describes the Volcano optimizer generator. The features that are relevant to this dissertation are presented, but more details can be found in <ref> [31, 38] </ref>. 2.1 Overview Volcano is a rule-based query optimizer generator that is designed to be flexible and extensible to specific database architectures. (Henceforth, when we talk of Volcano, we are referring to the Volcano optimizer generator.) It implements a top-down query optimizer in the sense that parents of nodes in
Reference: [39] <author> Gail Mitchell, Umeshwar Dayal, and Stanley B. Zdonik. </author> <title> Control of an extensible query optimizer: A planning-based approach. </title> <booktitle> In Proceedings 19th International Conference on Very Large Data Bases, </booktitle> <pages> pages 517-528, </pages> <address> Dublin, </address> <month> August </month> <year> 1993. </year>
Reference-contexts: Also, it is not evident whether the general nature of the framework makes it hard and unwieldy to use. If so, then it defeats the purpose of an extensible optimizer generator paradigm. Mitchell, Dayal, and Zdonik <ref> [39, 40] </ref> propose a framework called Epoq in which op-timizers are constructed using extensible regions. A region is defined by a stated goal (e.g., lower cost, join reorder, etc.). Each region defines a control strategy that transforms a query into alternative forms based on its internal transformation rules. <p> Thus, the need for a global search strategy disappears, and each layer implements its own search strategy (in addition to its own search space and cost model). This is similar to the frameworks proposed in <ref> [39, 40, 44] </ref>.
Reference: [40] <author> Gail Mitchell, Stanley B. Zdonik, and Umeshwar Dayal. </author> <title> An architecture for query processing in persistent object stores. </title> <booktitle> In Proceedings of the Hawaii International Conference on System Sciences, </booktitle> <volume> volume II, </volume> <pages> pages 787-798, </pages> <month> January </month> <year> 1992. </year>
Reference-contexts: Also, it is not evident whether the general nature of the framework makes it hard and unwieldy to use. If so, then it defeats the purpose of an extensible optimizer generator paradigm. Mitchell, Dayal, and Zdonik <ref> [39, 40] </ref> propose a framework called Epoq in which op-timizers are constructed using extensible regions. A region is defined by a stated goal (e.g., lower cost, join reorder, etc.). Each region defines a control strategy that transforms a query into alternative forms based on its internal transformation rules. <p> Thus, the need for a global search strategy disappears, and each layer implements its own search strategy (in addition to its own search space and cost model). This is similar to the frameworks proposed in <ref> [39, 40, 44] </ref>.
Reference: [41] <author> Patrick O'Neil. </author> <title> Database: Principles, Programming, and Performance. </title> <publisher> Morgan Kaufmann, </publisher> <address> San Mateo, </address> <year> 1994. </year>
Reference-contexts: Apart from the familiar relational operators and algorithms we have already encountered, Figure 4.12 introduces some new operators. An outer join <ref> [41] </ref> is a generalization of the traditional join operator (or natural join). It produces a stream that contains tuples whose join attributes are unmatched according to the join predicate. The outer join operation has two special cases depending on whether the outer or inner streams contribute unmatched tuples.
Reference: [42] <author> W. B. Rubenstein, M. S. Kubicar, and R. G. G. Cattell. </author> <title> Benchmarking simple database operations. </title> <booktitle> In Proceedings 1987 ACM SIGMOD International Conference on Management of Data, </booktitle> <pages> pages 387-394, </pages> <address> San Francisco, </address> <month> May </month> <year> 1987. </year>
Reference-contexts: The problem of developing a set of representative benchmark queries to test a query processing system is a well-researched topic <ref> [13, 14, 32, 42] </ref>. However, standard benchmark queries were not very useful in our case for various reasons.
Reference: [43] <author> P. Schwarz, W. Chang, J. C. Freytag, G. Lohman, J. McPherson, C. Mohan, and H. Pi-rahesh. </author> <title> Extensibility in the Starburst database system. </title> <booktitle> In Proceedings International Workshop on Object-Oriented Database Systems, </booktitle> <pages> pages 85-92, </pages> <address> Asilomar, </address> <month> September </month> <year> 1986. </year>
Reference-contexts: The need to have extensible database systems, and in turn extensible optimizers, has long been recognized in systems like EXODUS [17], Starburst <ref> [43] </ref>, Genesis [4], and Post-gres [49]. Rule-based query optimizers [25, 28, 30, 31, 33, 36] are among the major conceptual advances that have been proposed to deal with query optimizer extensibility. <p> The primary advantage of rule-based query optimizers is the ability to add new operators and algorithms without a costly rewrite of the entire optimizer. Below, we review a few of the more well-known rule-based optimizers. The Starburst query optimizer <ref> [33, 36, 43] </ref> uses rules for all decisions that need to be taken by the query optimizer. The rules are functional in nature and transform a given operator tree into another. The rules are commonly those that reflect relational calculus transformations.
Reference: [44] <author> Edward Sciore and John Sieg, Jr. </author> <title> A modular query optimizer generator. </title> <booktitle> In Proceedings 6th International Conference on Data Engineering, </booktitle> <pages> pages 146-153, </pages> <address> Los Angeles, </address> <month> February </month> <year> 1990. </year> <month> 117 </month>
Reference-contexts: Moreover, as we have seen in Chapter 4, it is important to have a compiler that can generate efficient, compact optimizers from a specification constructed using components. None of the proposals discussed in this section describe how that is done, or even if it is possible. Sciore and Sieg <ref> [44] </ref> describe an optimizer generator model that allows a DBI to construct a rule-based optimizer using modules. Each module consists of term rewrite rules, where rewrite rules transform terms in a relational algebra. These rules can have conditions associated with them. <p> Thus, the need for a global search strategy disappears, and each layer implements its own search strategy (in addition to its own search space and cost model). This is similar to the frameworks proposed in <ref> [39, 40, 44] </ref>.
Reference: [45] <author> P. G. Selinger and M. Adiba. </author> <title> Access path selection in distributed data base manage-ment systems. </title> <editor> In Deen and Hammersly, editors, </editor> <booktitle> Proceedings International Conference on Databases, </booktitle> <pages> pages 204-215, </pages> <institution> University of Aberdeen, </institution> <month> July </month> <year> 1980. </year>
Reference-contexts: R fl is a distributed relative of System R. The stored relations are located at distributed sites. R fl 's query processor <ref> [20, 37, 45] </ref> works in essentially the same way as that of System R, except for some subtle complications introduced by the distribution of relations. These complications arise mostly in authentication and catalog sharing between remote sites. Con ceptually, however, the R fl optimizer builds upon the System R optimizer. <p> Generally speaking, if the property value of each node in an operator tree can be 1 In many real-world query optimizers (e.g., System R [46] and R fl <ref> [45] </ref>), the cost of a node is a function of the costs of its inputs. Thus, in Volcano's terminology, cost should really be a physical property. <p> The Ship algorithm here is assumed to be a block transfer of streams (as in R fl <ref> [20, 37, 45] </ref>); other transfer strategies (e.g., tuple-at-a-time) could be defined in this or other layers encapsulating distribution transformations. The REPLICATION layer models replicated databases. Its imported interface is a RET operator that simulates a centralized, non-replicated database.
Reference: [46] <author> P. G. Selinger, M. M. Astrahan, D. D. Chamberlin, R. A. Lorie, and T. G. Price. </author> <title> Access path selection in a relational database management system. </title> <booktitle> In Proceedings 1979 ACM SIGMOD International Conference on Management of Data, </booktitle> <pages> pages 23-34, </pages> <address> Boston, </address> <month> May </month> <year> 1979. </year>
Reference-contexts: Below, we briefly review some related work on optimizers. 4 1.2 Related Work 1.2.1 Traditional Query Optimizers The System R optimizer <ref> [46] </ref> was one of the earliest query optimizers proposed and implemented. It was built for the System R database system [1]. System R is a centralized, relational DBMS where users specify their queries in SQL. <p> Dynamic programming is used to prune the search space as much as possible. Since this process of pruning is similar to the one in System R <ref> [46] </ref>, we will not describe it further. The rule specification language is the part of Volcano that allows a DBI to specify how operator trees are transformed to generate access plans. The optimizer is specified as a set of operators, algorithms, and rules with associated actions. <p> Generally speaking, if the property value of each node in an operator tree can be 1 In many real-world query optimizers (e.g., System R <ref> [46] </ref> and R fl [45]), the cost of a node is a function of the costs of its inputs. Thus, in Volcano's terminology, cost should really be a physical property. <p> Query optimizers are integral to most DBMSs. They also tend to be a significant and complex part of a DBMS. The earliest query optimizer proposed, System R <ref> [46] </ref>, was monolithic in nature. That is, the three features of a query optimizer, namely, search space, cost model, and search strategy, were all hard-wired into a single module that represented the optimizer. Many contemporary optimizers still follow this model. <p> This dissertation is a step in that direction. 105 Appendix A Complexity of the System R Optimizer In this appendix, we sketch a proof for the asymptotic complexity of the System R optimizer <ref> [46] </ref> for joining n relations. This complexity holds when the query graph is fully connected or the heuristic of delaying cross-products is dropped. This is the worst-case scenario. The System R optimizer only generates left-deep operator trees.
Reference: [47] <author> Michael Stonebraker, Paul M. Aoki, Robert Devine, Witold Litwin, and Michael Ol-son. Mariposa: </author> <title> A new architecture for distributed data. </title> <booktitle> In Proceedings 10th International Conference on Data Engineering, </booktitle> <pages> pages 54-65, </pages> <address> Houston, </address> <month> February </month> <year> 1994. </year>
Reference-contexts: In this approach, the optimizer is implemented as a composition of separate phases, each phase optimizing the output of another. Systems like XPRS [48] and Mariposa <ref> [47] </ref> are some examples of this approach. The Mariposa distributed DBMS, for instance, implements a three-phase optimizer; these phases are compilation, parallelization, and distribution. <p> The compilation phase optimizes an operator tree assuming a centralized DBMS, the paral-lelization phase introduces intra-operator parallelism, and the distribution phase selects sites for the execution of the various algorithms. As Stonebraker et al point out 103 in <ref> [47] </ref>, partitioning the optimization process into multiple phases can result in sub-optimal plans. However, careful design and implementation of each phase can significantly reduce the search space of the optimizer (and, consequently, the optimization time), while still generating a good access plan.
Reference: [48] <author> Michael Stonebraker, Randy Katz, David Patterson, and John Ousterhout. </author> <booktitle> The design of XPRS. In Proceedings 14th International Conference on Very Large Data Bases, </booktitle> <pages> pages 318-330, </pages> <address> Los Angeles, </address> <year> 1988. </year>
Reference-contexts: In this approach, the optimizer is implemented as a composition of separate phases, each phase optimizing the output of another. Systems like XPRS <ref> [48] </ref> and Mariposa [47] are some examples of this approach. The Mariposa distributed DBMS, for instance, implements a three-phase optimizer; these phases are compilation, parallelization, and distribution.
Reference: [49] <author> Michael Stonebraker and Lawrence A. Rowe. </author> <title> The design of Postgres. </title> <booktitle> In Proceedings 1986 ACM SIGMOD International Conference on Management of Data, </booktitle> <pages> pages 340-355, </pages> <address> Washington, </address> <month> May </month> <year> 1986. </year>
Reference-contexts: The need to have extensible database systems, and in turn extensible optimizers, has long been recognized in systems like EXODUS [17], Starburst [43], Genesis [4], and Post-gres <ref> [49] </ref>. Rule-based query optimizers [25, 28, 30, 31, 33, 36] are among the major conceptual advances that have been proposed to deal with query optimizer extensibility.
Reference: [50] <author> David L. Wells, Jos e A. Blakeley, and Craig W. Thompson. </author> <title> Architecture of an open object-oriented database management system. </title> <journal> IEEE Computer, </journal> <volume> 25(10) </volume> <pages> 74-82, </pages> <month> Octo-ber </month> <year> 1992. </year>
Reference-contexts: next section. 3 To reduce measurement errors, the same query was optimized 10 times (in a loop) and the total time was divided by 10 to obtain the optimization time for any query. 65 5.3 The Texas Instruments Open OODB Query Optimizer The Texas Instruments Open Object-Oriented Database Management System <ref> [50] </ref> is an open, extensible, object-oriented database system which provides users an architectural framework that is configurable in an incremental manner.
Reference: [51] <author> C. T. Yu and C. C. Chang. </author> <title> Distributed query processing. </title> <journal> ACM Computing Surveys, </journal> <volume> 16(4) </volume> <pages> 399-433, </pages> <month> December </month> <year> 1984. </year> <month> 118 </month>
Reference-contexts: A query optimizer then transforms this operator tree into an access plan. Finally, the execution module executes the access plan to return the results of the SQL query. As shown in Figure 1.1, query optimization <ref> [29, 34, 35, 51] </ref> is an important step in query processing. It is the process of generating an efficient access plan for a database query.
References-found: 51

