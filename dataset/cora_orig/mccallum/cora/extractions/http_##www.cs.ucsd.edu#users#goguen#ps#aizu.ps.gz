URL: http://www.cs.ucsd.edu/users/goguen/ps/aizu.ps.gz
Refering-URL: http://www.cs.ucsd.edu/users/goguen/new.html
Root-URL: http://www.cs.ucsd.edu
Title: Hidden Algebraic Engineering  
Author: Joseph A. Goguen 
Date: 24-26 March 1997).  December 1997  
Address: Japan,  San Diego, La Jolla CA 92093-0114 USA  
Affiliation: pher Nehaniv (University of Aizu, Aizu-Wakamatsu,  Department of Computer Science Engineering University of California at  
Note: To appear in Proceedings, Conference on Semigroups and Algebraic Engineering, edited by Chrysto-  
Pubnum: Report CS97-569,  
Abstract: This paper outlines a research programme in algebraic engineering. It starts with a review of classical algebraic specification for abstract data types, such as integers, vectors, booleans, and lists. Software engineering also needs abstract machines, recently called "objects," that can communicate concurrently with other objects, and that have local states with visible "attributes" that are changed by inputs. Hidden algebra is a new development in algebraic semantics for such systems; its most important results are powerful hidden coinduction principles for proving behavioral properties, especially behavioral refinement. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Jan Bergstra and John Tucker. </author> <title> Characterization of computable data types by means of a finite equational specification method. </title> <editor> In J.W. de Bakker and Jan van Leeuwen, editors, </editor> <booktitle> Automata, Languages and Programming, Seventh Colloquium, </booktitle> <pages> pages 76-90. </pages> <publisher> Springer, </publisher> <year> 1980. </year> <booktitle> Lecture Notes in Computer Science, </booktitle> <volume> Volume 81. </volume>
Reference-contexts: Another fact suggesting we are on the right track is that any computable abstract data type has an equational specification; moreover, this specification tends to be reasonably simple and intuitive in practice. The following result from [46] somewhat generalizes the original version due to Bergstra and Tucker <ref> [1] </ref> (M is reachable iff the unique -homomorphism T ! M is surjective): Theorem 2.10 (Adequacy of Initiality) Given any computable reachable -algebra M with finite, there is a finite specification P = ( 0 ; A 0 ) such that 0 , such that 0 has the same sorts as <p> More on initiality can be found in [33] and [46]; the latter especially develops connections with induction and computability. Results on the adequacy of initiality were first given by Bergstra and Tucker <ref> [1] </ref>.
Reference: [2] <author> Garrett Birkhoff. </author> <title> On the structure of abstract algebras. </title> <booktitle> Proceedings of the Cambridge Philosophical Society, </booktitle> <volume> 31 </volume> <pages> 433-454, </pages> <year> 1935. </year> <month> 13 </month>
Reference-contexts: I build software tools to help deal with these huge algebras. 4. I build new kinds of algebra, to get better results in building software. All this is within the general framework of universal (also called "general") algebra, as pioneered by Birkhoff <ref> [2] </ref> and Tarski (among others). Although I'm not the only one doing such things, this survey focuses on the work with which I am most familiar, from my research groups at Oxford and UCSD, and the CafeOBJ project.
Reference: [3] <author> Barry Boehm. </author> <title> Software Engineering Economics. </title> <publisher> Prentice-Hall, </publisher> <year> 1981. </year>
Reference-contexts: Most of the literature addresses code verification, but this is very difficult in practice, and empirical studies have shown that little of the cost of software arises from errors in coding: most comes from errors in design and requirements <ref> [3] </ref>. <p> However, this is an area where mathematics can make a contribution. It is well known that most of the effort in programming goes into debugging and maintenance (i.e., into improving and updating programs) <ref> [3] </ref>. Therefore anything that can be done to ease these processes has enormous economic potential. <p> However, we contend that this isolation is actually an advantage, since only about 5% of the difficulty of software development lies in the code itself <ref> [3] </ref>, with much more of the difficulty in specification and design; our approach addresses these directly, without assuming the heavy burden of a messy programming language semantics. But of course we can use algebraic semantics to verify code if we wish, as extensively illustrated in [25].
Reference: [4] <author> Adel Bouhoula. </author> <title> Automated theorem proving by test set induction. </title> <journal> Journal of Symbolic Computation, </journal> <volume> 23(1) </volume> <pages> 47-77, </pages> <year> 1997. </year>
Reference-contexts: There is also exciting new work in term rewriting [11] (which is the basis for implementing systems like OBJ3, Maude and CafeOBJ), for example in France around Prof. Jean-Pierre Jouannoud, on induction and termination proofs [5], including the spike <ref> [4] </ref> and CiME systems. The issues discussed in this paper seem to be of increasing importance for computer science, and I think we can look forward to continuing progress.
Reference: [5] <author> Adel Bouhoula and Jean-Pierre Jouannaud. </author> <title> Automata-driven automated induction. </title> <booktitle> In Proceedings, 12th Symposium on Logic in Computer Science, </booktitle> <pages> pages 14-25. </pages> <publisher> IEEE, </publisher> <year> 1997. </year>
Reference-contexts: There is also exciting new work in term rewriting [11] (which is the basis for implementing systems like OBJ3, Maude and CafeOBJ), for example in France around Prof. Jean-Pierre Jouannoud, on induction and termination proofs <ref> [5] </ref>, including the spike [4] and CiME systems. The issues discussed in this paper seem to be of increasing importance for computer science, and I think we can look forward to continuing progress.
Reference: [6] <author> Rod Burstall and Razvan Diaconescu. </author> <title> Hiding and behaviour: an institutional approach. </title> <editor> In A. William Roscoe, editor, </editor> <title> A Classical Mind: </title> <booktitle> Essays in Honour of C.A.R. Hoare, </booktitle> <pages> pages 75-92. </pages> <publisher> Prentice Hall, </publisher> <year> 1994. </year> <note> Also Technical Report ECS-LFCS-8892-253, </note> <institution> Laboratory for Foundations of Computer Science, University of Edinburgh, </institution> <year> 1992. </year>
Reference-contexts: Many much more complex examples have been done, including correctness proofs for an optimizing compiler and for a novel communication protocol [35]. Hidden algebra first appeared in [20], and was subsequently elaborated in several papers, including <ref> [22, 41, 6] </ref>; an important precursor was work by Goguen and Meseguer on what they called "abstract machines" [27]. The rapidly growing literature on hidden algebra includes [12, 26, 40, 8, 14].
Reference: [7] <author> Graham Button and Wes Sharrock. </author> <title> Occasioned practises in the work of implementing development methodologies. </title> <editor> In Marina Jirotka and Joseph Goguen, editors, </editor> <booktitle> Requirements Engineering: Social and Technical Issues, </booktitle> <pages> pages 217-240. </pages> <publisher> Academic, </publisher> <year> 1994. </year>
Reference-contexts: Behavioral refinement is much more general than ordinary refinement, and many of the enormous variety of clever implementation techniques that so often occur in practice require this extra generality. 2 Empirical studies show that real software development projects involve many false starts, redesigns, prototypes, patches, etc. <ref> [7] </ref>.
Reference: [8] <author> Corina C^rstea. </author> <title> A semantical study of the object paradigm. </title> <type> Transfer thesis, </type> <institution> Oxford University Computing Laboratory, </institution> <year> 1996. </year>
Reference-contexts: Hidden algebra first appeared in [20], and was subsequently elaborated in several papers, including [22, 41, 6]; an important precursor was work by Goguen and Meseguer on what they called "abstract machines" [27]. The rapidly growing literature on hidden algebra includes <ref> [12, 26, 40, 8, 14] </ref>. Coinduction seems to give proofs that are about as simple as possible, but more experience is needed before this can be said with complete certainty.
Reference: [9] <author> Manuel Clavel, Steven Eker, Patrick Lincoln, and Jose Meseguer. </author> <title> Principles of Maude. </title> <editor> In Jose Meseguer, editor, </editor> <booktitle> Proceedings, First International Workshop on Rewriting Logic and its Applications. Elsevier Science, 1996. Volume 4 of Electronic Notes in Theoretical Computer Science. </booktitle>
Reference-contexts: logic [42, 43], a weakening of equational logic providing an operational semantics that is ideal for rapid implementation of many algorithms, e.g., in term rewriting [10], as well as for describing and comparing the many kinds of concurrency [44]; rewriting logic has been very efficiently implemented in the Maude system <ref> [45, 9] </ref>.
Reference: [10] <author> Manuel Clavel, Steven Eker, and Jose Meseguer. </author> <title> Current design and implementation of the Cafe prover and Knuth-Bendix tools, </title> <booktitle> 1997. Presented at CafeOBJ Workshop, </booktitle> <address> Kanazawa, </address> <month> October </month> <year> 1997. </year>
Reference-contexts: We have discussed hidden algebra and its cousin coalgebra. One important new development is rewriting logic [42, 43], a weakening of equational logic providing an operational semantics that is ideal for rapid implementation of many algorithms, e.g., in term rewriting <ref> [10] </ref>, as well as for describing and comparing the many kinds of concurrency [44]; rewriting logic has been very efficiently implemented in the Maude system [45, 9].
Reference: [11] <author> Nachum Dershowitz and Jean-Pierre Jouannaud. </author> <title> Rewriting systems. </title> <booktitle> In Handbook of Theoretical Computer Science, </booktitle> <volume> Volume B, </volume> <pages> pages 243-309. </pages> <publisher> North-Holland, </publisher> <year> 1990. </year>
Reference-contexts: There is also exciting new work in term rewriting <ref> [11] </ref> (which is the basis for implementing systems like OBJ3, Maude and CafeOBJ), for example in France around Prof. Jean-Pierre Jouannoud, on induction and termination proofs [5], including the spike [4] and CiME systems.
Reference: [12] <author> Razvan Diaconescu. </author> <title> Foundations of behavioural specification in rewriting logic. </title> <booktitle> In Proceedings, First International Workshop on Rewriting Logic and its Applications. Asilomar, </booktitle> <address> California, </address> <month> September </month> <year> 1996, </year> <title> ETCS. </title> <publisher> North-Holland, </publisher> <year> 1996. </year>
Reference-contexts: Hidden algebra first appeared in [20], and was subsequently elaborated in several papers, including [22, 41, 6]; an important precursor was work by Goguen and Meseguer on what they called "abstract machines" [27]. The rapidly growing literature on hidden algebra includes <ref> [12, 26, 40, 8, 14] </ref>. Coinduction seems to give proofs that are about as simple as possible, but more experience is needed before this can be said with complete certainty.
Reference: [13] <author> Razvan Diaconescu and Kokichi Futatsugi. </author> <title> Logical semantics for CafeOBJ, </title> <note> 1996. Submitted for publication. </note>
Reference-contexts: The CafeOBJ system should also be mentioned [16, 15]; it provides industrial strength implementions of rewriting logic, as well as of ordinary order sorted equational logic, hidden sorted equational logic, and all their combinations <ref> [13] </ref>! The designs for both Maude and CafeOBJ are heavily indebted to that of OBJ3 and its predecessors, and indeed, can be considered extensions of OBJ3.
Reference: [14] <author> Razvan Diaconescu and Kokichi Futatsugi. </author> <title> Logical semantics for CafeOBJ. </title> <type> Technical Report IS-RR-96-0024S, </type> <institution> Japan Advanced Institute of Science and Technology, </institution> <year> 1996. </year>
Reference-contexts: Hidden algebra first appeared in [20], and was subsequently elaborated in several papers, including [22, 41, 6]; an important precursor was work by Goguen and Meseguer on what they called "abstract machines" [27]. The rapidly growing literature on hidden algebra includes <ref> [12, 26, 40, 8, 14] </ref>. Coinduction seems to give proofs that are about as simple as possible, but more experience is needed before this can be said with complete certainty.
Reference: [15] <author> Kokichi Futatsugi and Razvan Diaconescu. </author> <type> CafeOBJ report. Technical report, </type> <institution> JAIST, </institution> <year> 1997. </year> <note> In preparation. </note>
Reference-contexts: The CafeOBJ system should also be mentioned <ref> [16, 15] </ref>; it provides industrial strength implementions of rewriting logic, as well as of ordinary order sorted equational logic, hidden sorted equational logic, and all their combinations [13]! The designs for both Maude and CafeOBJ are heavily indebted to that of OBJ3 and its predecessors, and indeed, can be considered extensions
Reference: [16] <author> Kokichi Futatsugi and Ataru Nakagawa. </author> <title> An overview of Cafe specification environment. </title> <booktitle> In Proceedings, </booktitle> <institution> ICFEM'97. University of Hiroshima, 1997. Hiroshima, </institution> <month> November </month> <year> 1997. </year>
Reference-contexts: The CafeOBJ system should also be mentioned <ref> [16, 15] </ref>; it provides industrial strength implementions of rewriting logic, as well as of ordinary order sorted equational logic, hidden sorted equational logic, and all their combinations [13]! The designs for both Maude and CafeOBJ are heavily indebted to that of OBJ3 and its predecessors, and indeed, can be considered extensions
Reference: [17] <author> Joseph Goguen. </author> <title> Semantics of computation. </title> <editor> In Ernest Manes, editor, </editor> <booktitle> Proceedings, First International Symposium on Category Theory Applied to Computation and Control, </booktitle> <pages> pages 151-163. </pages> <publisher> Springer, </publisher> <address> 1975. San Fransisco, </address> <month> February </month> <year> 1974. </year> <booktitle> Lecture Notes in Computer Science, </booktitle> <volume> Volume 25. </volume> <pages> 14 </pages>
Reference-contexts: The term "initial algebra se-mantics" and its first applications (including Knuthian attribute semantics) appear in <ref> [17] </ref>, while its first application to abstract data types is in [32]; a more complete and rigorous exposition is given in [31]. More on initiality can be found in [33] and [46]; the latter especially develops connections with induction and computability.
Reference: [18] <author> Joseph Goguen. </author> <title> Memories of ADJ. </title> <journal> Bulletin of the European Association for Theoretical Com--puter Science, </journal> <volume> 36 </volume> <pages> 96-102, </pages> <month> October </month> <year> 1989. </year> <title> Guest column in the `Algebraic Specification Column.' </title> <booktitle> Also in Current Trends in Theoretical Computer Science: Essays and Tutorials, World Scientific, </booktitle> <year> 1993, </year> <pages> pages 76-81. </pages>
Reference-contexts: More on initiality can be found in [33] and [46]; the latter especially develops connections with induction and computability. Results on the adequacy of initiality were first given by Bergstra and Tucker [1]. See <ref> [18] </ref> for more historical information about this early period, and [25, 21] for more recent results, examples and references. 2.3 OBJ Notation OBJ gives a notation for expressing both initial and loose specifications, and this notation has been implemented in a way that permits proving things about such specifications [34, 25, <p> John Reynolds has written an excellent book in a more traditional style [50]. Some early history of initial algebra semantics for abstract data types was given at the end of Section 2.2; see also <ref> [18] </ref>. It seems to me that the area of algebraic specification may now be entering a golden age, in which new techniques are bringing old goals to fruition in unexpected ways, and are also opening new horizons from which exciting new goals seem reachable.
Reference: [19] <author> Joseph Goguen. </author> <title> Proving and rewriting. </title> <editor> In Helene Kirchner and Wolfgang Wechler, editors, </editor> <booktitle> Proceedings, Second International Conference on Algebraic and Logic Programming, </booktitle> <pages> pages 1-24. </pages> <publisher> Springer, </publisher> <year> 1990. </year> <booktitle> Lecture Notes in Computer Science, </booktitle> <volume> Volume 463. </volume>
Reference-contexts: a way to organize and document verification efforts, often retrospectively. 2 1.2 Overview of this Paper Section 2 gives a brief overview of classical algebraic specification theory for abstract data types, which may be thought of realms of unchanging Platonic values, such as integers, booleans, and lists; this exposition follows <ref> [19] </ref> and [21]. Following [26], Section 3 explains why software engineering also needs abstract machines, recently called "objects," and why their behavioral properties are important. It then gives a brief overview of the hidden algebra approach to behavioral specification, including its most significant proof technique, which is called coinduction.
Reference: [20] <author> Joseph Goguen. </author> <title> Types as theories. </title> <editor> In George Michael Reed, Andrew William Roscoe, and Ralph F. Wachter, editors, </editor> <booktitle> Topology and Category Theory in Computer Science, </booktitle> <pages> pages 357-390. </pages> <address> Oxford, </address> <year> 1991. </year> <booktitle> Proceedings of a Conference held at Oxford, </booktitle> <month> June </month> <year> 1989. </year>
Reference-contexts: Many much more complex examples have been done, including correctness proofs for an optimizing compiler and for a novel communication protocol [35]. Hidden algebra first appeared in <ref> [20] </ref>, and was subsequently elaborated in several papers, including [22, 41, 6]; an important precursor was work by Goguen and Meseguer on what they called "abstract machines" [27]. The rapidly growing literature on hidden algebra includes [12, 26, 40, 8, 14].
Reference: [21] <author> Joseph Goguen. </author> <title> Theorem Proving and Algebra. MIT, </title> <note> to appear. </note>
Reference-contexts: to organize and document verification efforts, often retrospectively. 2 1.2 Overview of this Paper Section 2 gives a brief overview of classical algebraic specification theory for abstract data types, which may be thought of realms of unchanging Platonic values, such as integers, booleans, and lists; this exposition follows [19] and <ref> [21] </ref>. Following [26], Section 3 explains why software engineering also needs abstract machines, recently called "objects," and why their behavioral properties are important. It then gives a brief overview of the hidden algebra approach to behavioral specification, including its most significant proof technique, which is called coinduction. <p> More on initiality can be found in [33] and [46]; the latter especially develops connections with induction and computability. Results on the adequacy of initiality were first given by Bergstra and Tucker [1]. See [18] for more historical information about this early period, and <ref> [25, 21] </ref> for more recent results, examples and references. 2.3 OBJ Notation OBJ gives a notation for expressing both initial and loose specifications, and this notation has been implemented in a way that permits proving things about such specifications [34, 25, 21]. <p> See [18] for more historical information about this early period, and [25, 21] for more recent results, examples and references. 2.3 OBJ Notation OBJ gives a notation for expressing both initial and loose specifications, and this notation has been implemented in a way that permits proving things about such specifications <ref> [34, 25, 21] </ref>. OBJ modules that are to be interpreted loosely begin with the keyword theory (or th) and close with the keyword endth. Between these two keywords come declarations for sorts and operations, plus (as discussed later) variables and equations. <p> Principles of induction can be justified from the fact that an initial algebra has no proper subalgebras <ref> [21, 46] </ref>; final (terminal) algebras play an analogous role in justifying reasoning about behavioral properties with hidden coinduction. Before describing the final algebra, I want to note that its use is not precisely dual to that of the initial algebra for abstract data types.
Reference: [22] <author> Joseph Goguen and Razvan Diaconescu. </author> <title> Towards an algebraic semantics for the object paradigm. </title> <editor> In Hartmut Ehrig and Fernando Orejas, editors, </editor> <booktitle> Proceedings, Tenth Workshop on Abstract Data Types, </booktitle> <pages> pages 1-29. </pages> <publisher> Springer, </publisher> <year> 1994. </year> <booktitle> Lecture Notes in Computer Science, </booktitle> <volume> Volume 785. </volume>
Reference-contexts: This paradigm has become dominant in many important application areas. We have already seen how to handle most of it with hidden algebra. Aspects of concurrency and inheritance are treated in <ref> [22, 26] </ref>. <p> Many much more complex examples have been done, including correctness proofs for an optimizing compiler and for a novel communication protocol [35]. Hidden algebra first appeared in [20], and was subsequently elaborated in several papers, including <ref> [22, 41, 6] </ref>; an important precursor was work by Goguen and Meseguer on what they called "abstract machines" [27]. The rapidly growing literature on hidden algebra includes [12, 26, 40, 8, 14].
Reference: [23] <author> Joseph Goguen, Kai Lin, Akira Mori, Grigore Ro~su, and Akiyoshi Sato. </author> <title> Distributed cooperative formal methods tools. </title> <editor> In Michael Lowry, editor, </editor> <booktitle> Proceedings, Automated Software Engineering. NASA, 1997. </booktitle> <address> Lake Tahoe CA, </address> <month> 3-5 November </month> <year> 1997. </year>
Reference-contexts: The UCSD group is putting much related material on the web, including sample hidden algebraic proofs, with tutorial background information, remote proof execution, and Java applets to illustrate specifications, properties, and proof ideas; see http://lex.ucsd.edu/links and the papers <ref> [30, 23, 29] </ref>, which are available from http:// www.cs.ucsd.edu/users/goguen (along with many others). Some other related work is discussed briefly in Section 4. 1.1 Notes on the State of the Art Software development is very difficult.
Reference: [24] <author> Joseph Goguen and Grant Malcolm. </author> <title> Proof of correctness of object representation. </title> <editor> In A. William Roscoe, editor, </editor> <title> A Classical Mind: </title> <booktitle> Essays in Honour of C.A.R. Hoare, </booktitle> <pages> pages 119-142. </pages> <publisher> Prentice Hall, </publisher> <year> 1994. </year>
Reference-contexts: Theorem 3.8 implies that if a ' a 0 under some hidden congruence ', then a and a 0 are behaviorally equivalent. This justifies a variety of techniques for proving behavioral equivalence (see also <ref> [24, 41] </ref>). In this context, a relation may be called a candidate relation before it is proved to be a hidden congruence. Probably the most common case is = , but the generalization to smaller is useful, for example in verifying refinements.
Reference: [25] <author> Joseph Goguen and Grant Malcolm. </author> <title> Algebraic Semantics of Imperative Programs. </title> <publisher> MIT, </publisher> <year> 1996. </year>
Reference-contexts: It then gives a brief overview of the hidden algebra approach to behavioral specification, including its most significant proof technique, which is called coinduction. We use the notation of OBJ3 <ref> [25, 34] </ref> for some simple examples. Dedication After the Algebraic Engineering '97 conference, I learned that it would be dedicated to Prof. John Rhodes, in honor of his sixtieth birthday. <p> More on initiality can be found in [33] and [46]; the latter especially develops connections with induction and computability. Results on the adequacy of initiality were first given by Bergstra and Tucker [1]. See [18] for more historical information about this early period, and <ref> [25, 21] </ref> for more recent results, examples and references. 2.3 OBJ Notation OBJ gives a notation for expressing both initial and loose specifications, and this notation has been implemented in a way that permits proving things about such specifications [34, 25, 21]. <p> See [18] for more historical information about this early period, and [25, 21] for more recent results, examples and references. 2.3 OBJ Notation OBJ gives a notation for expressing both initial and loose specifications, and this notation has been implemented in a way that permits proving things about such specifications <ref> [34, 25, 21] </ref>. OBJ modules that are to be interpreted loosely begin with the keyword theory (or th) and close with the keyword endth. Between these two keywords come declarations for sorts and operations, plus (as discussed later) variables and equations. <p> But of course we can use algebraic semantics to verify code if we wish, as extensively illustrated in <ref> [25] </ref>. Thus we have achieved a significant separation of concerns. 12 4 Summary and Related Work This paper has presented hidden algebra as an extension of the classical initial algebra approach to abstract data types, and as a natural next step in the evolution of algebraic specification. <p> Now there are many different schools, there are thousands of papers, and hundreds of books. Most of this is far from rigorous, which is sad considering the topic. Maybe the most recent really rigorous book is one that I wrote with Grant Malcolm <ref> [25] </ref>; it aims at making the best possible use of computers for proofs, and in fact is "executable" in that all its proofs run. John Reynolds has written an excellent book in a more traditional style [50].
Reference: [26] <author> Joseph Goguen and Grant Malcolm. </author> <title> A hidden agenda. </title> <type> Technical Report CS97-538, UCSD, </type> <institution> Dept. Computer Science & Engineering, </institution> <month> May </month> <year> 1997. </year> <note> Early version in Proceedings, Conference on Intelligent Systems: A Semiotic Perspective, Vol. I, </note> <editor> ed. James Albus, Alex Meystel and Richard Quintero, </editor> <booktitle> National Inst. </booktitle> <institution> Standards & Technology (Gaithersberg MD, </institution> <month> 20-23 October </month> <year> 1996), </year> <pages> pages 159-167. </pages>
Reference-contexts: Following <ref> [26] </ref>, Section 3 explains why software engineering also needs abstract machines, recently called "objects," and why their behavioral properties are important. It then gives a brief overview of the hidden algebra approach to behavioral specification, including its most significant proof technique, which is called coinduction. <p> Methods are interpreted similarly; see <ref> [26] </ref> for details. <p> is the following: Theorem 3.8 If is a hidden signature, is a hidden subsignature of , and A is a hidden -algebra, then behavioral -equivalence is the largest behavioral -congruence on A. 2 9 This result is not hard to prove (a simple but very abstract proof is given in <ref> [26] </ref>). The proof generalizes the well known construction of an abstract machine as a quotient of the term algebra by the behavioral equivalence relation (usually called the Nerode equivalence in that context) [46], and uses the existence of final algebras, which are proved to exist in [26]. <p> proof is given in <ref> [26] </ref>). The proof generalizes the well known construction of an abstract machine as a quotient of the term algebra by the behavioral equivalence relation (usually called the Nerode equivalence in that context) [46], and uses the existence of final algebras, which are proved to exist in [26]. Theorem 3.8 implies that if a ' a 0 under some hidden congruence ', then a and a 0 are behaviorally equivalent. This justifies a variety of techniques for proving behavioral equivalence (see also [24, 41]). <p> I think this proof is about as simple as could be hoped for 5 . 2 Much more can be said about doing coinductive proofs, just as there is a rich lore about doing inductive proofs; see <ref> [26] </ref> for more information. 5 Actually, the third reduction is unnecessary, but it is more trouble to justify its elimination than it is to ask OBJ to do it; see [26]. 3.2 Nondeterminism Since nondeterminism takes some extra effort for abstract data types, it is perhaps surprising that it is already <p> more can be said about doing coinductive proofs, just as there is a rich lore about doing inductive proofs; see <ref> [26] </ref> for more information. 5 Actually, the third reduction is unnecessary, but it is more trouble to justify its elimination than it is to ask OBJ to do it; see [26]. 3.2 Nondeterminism Since nondeterminism takes some extra effort for abstract data types, it is perhaps surprising that it is already an inherent facet of hidden algebra, as illustrated in the following very simple example: th C is pr DATA . op c : -&gt; Nat . endth Here c has <p> This simple and elegant situation holds for nondeterministic concurrent systems in general. (More information about nondeterminism and final models can be found in <ref> [26] </ref>.) The approach to nondeterminism in hidden algebra is quite different from that which is traditional in automaton theory: in hidden algebra, each possible behavior appears in a different possible world, whereas a nondeterministic automaton includes all choices in a single model. <p> The method is just to prove that each equation in E 0 is a behavioral consequence of E, i.e., a behavioral property of every model (implementation) of E. More details and some examples are given in <ref> [26] </ref>. 3.4 The Object Paradigm Objects have local states with visible local "attributes" and "methods" to change state. Objects also come in "classes," which can "inherit" from other classes, and objects can communicate concurrently with other objects in the same system. <p> This paradigm has become dominant in many important application areas. We have already seen how to handle most of it with hidden algebra. Aspects of concurrency and inheritance are treated in <ref> [22, 26] </ref>. <p> Hidden algebra first appeared in [20], and was subsequently elaborated in several papers, including [22, 41, 6]; an important precursor was work by Goguen and Meseguer on what they called "abstract machines" [27]. The rapidly growing literature on hidden algebra includes <ref> [12, 26, 40, 8, 14] </ref>. Coinduction seems to give proofs that are about as simple as possible, but more experience is needed before this can be said with complete certainty.
Reference: [27] <author> Joseph Goguen and Jose Meseguer. </author> <title> Universal realization, persistent interconnection and implementation of abstract modules. </title> <editor> In M. Nielsen and E.M. Schmidt, editors, </editor> <booktitle> Proceedings, 9th International Conference on Automata, Languages and Programming, </booktitle> <pages> pages 265-281. </pages> <publisher> Springer, </publisher> <year> 1982. </year> <booktitle> Lecture Notes in Computer Science, </booktitle> <volume> Volume 140. </volume>
Reference-contexts: Hidden algebra first appeared in [20], and was subsequently elaborated in several papers, including [22, 41, 6]; an important precursor was work by Goguen and Meseguer on what they called "abstract machines" <ref> [27] </ref>. The rapidly growing literature on hidden algebra includes [12, 26, 40, 8, 14]. Coinduction seems to give proofs that are about as simple as possible, but more experience is needed before this can be said with complete certainty.
Reference: [28] <author> Joseph Goguen and Jose Meseguer. </author> <title> Order-sorted algebra I: Equational deduction for multiple inheritance, overloading, exceptions and partial operations. </title> <journal> Theoretical Computer Science, </journal> <volume> 105(2) </volume> <pages> 217-273, </pages> <year> 1992. </year> <note> Drafts exists from as early as 1985. </note>
Reference-contexts: This paradigm has become dominant in many important application areas. We have already seen how to handle most of it with hidden algebra. Aspects of concurrency and inheritance are treated in [22, 26]. A full treatment of inheritance requires the use of order sorted algebra for subclasses <ref> [28] </ref>; this is another kind of algebra invented to help deal with software. 6 Some may object that this maneuver isolates us from the actual code used to define operations in A, preventing us from verifying that code.
Reference: [29] <author> Joseph Goguen, Akira Mori, and Kai Lin. </author> <title> Algebraic semiotics, ProofWebs and distributed cooperative proving. </title> <editor> In Yves Bartot, editor, </editor> <booktitle> Proceedings, User Interfaces for Theorem Provers, </booktitle> <pages> pages 25-34. </pages> <institution> INRIA, 1997. Sophia Antipolis, </institution> <month> 1-2 September </month> <year> 1997. </year>
Reference-contexts: The UCSD group is putting much related material on the web, including sample hidden algebraic proofs, with tutorial background information, remote proof execution, and Java applets to illustrate specifications, properties, and proof ideas; see http://lex.ucsd.edu/links and the papers <ref> [30, 23, 29] </ref>, which are available from http:// www.cs.ucsd.edu/users/goguen (along with many others). Some other related work is discussed briefly in Section 4. 1.1 Notes on the State of the Art Software development is very difficult.
Reference: [30] <author> Joseph Goguen, Akira Mori, Kai Lin, and Akiyoshi Sato. </author> <title> Formal tools for distributed cooperative engineering, </title> <note> 1998. Submitted for publication. 15 </note>
Reference-contexts: The UCSD group is putting much related material on the web, including sample hidden algebraic proofs, with tutorial background information, remote proof execution, and Java applets to illustrate specifications, properties, and proof ideas; see http://lex.ucsd.edu/links and the papers <ref> [30, 23, 29] </ref>, which are available from http:// www.cs.ucsd.edu/users/goguen (along with many others). Some other related work is discussed briefly in Section 4. 1.1 Notes on the State of the Art Software development is very difficult.
Reference: [31] <author> Joseph Goguen, James Thatcher, and Eric Wagner. </author> <title> An initial algebra approach to the specifica-tion, correctness and implementation of abstract data types. </title> <editor> In Raymond Yeh, editor, </editor> <booktitle> Current Trends in Programming Methodology, IV, </booktitle> <pages> pages 80-149. </pages> <publisher> Prentice Hall, </publisher> <year> 1978. </year>
Reference-contexts: What this result tells us is that all of the data types that are of interest in computer science can be defined using initiality, although sometimes it may be necessary to add some auxiliary functions. All of this motivates the following fundamental conceptualization, which goes back to 1975 <ref> [32, 31] </ref>: Definition 2.11 The abstract data type (abbreviated ADT) defined by a specification P is the class of all initial P -algebras. 2 5 The importance of initiality for computing developed gradually. <p> The term "initial algebra se-mantics" and its first applications (including Knuthian attribute semantics) appear in [17], while its first application to abstract data types is in [32]; a more complete and rigorous exposition is given in <ref> [31] </ref>. More on initiality can be found in [33] and [46]; the latter especially develops connections with induction and computability. Results on the adequacy of initiality were first given by Bergstra and Tucker [1]. <p> Moreover, in considering (for example) stacks of integers, the sorts for stacks and for integers must be treated differently, since the latter are still modeled initially as data. Although these issues have been successfully addressed in an initial framework (e.g., <ref> [31] </ref>), it is really better to take a different viewpoint. Hidden algebra explicitly distinguishes between "visible" sorts for data and "hidden" sorts for states.
Reference: [32] <author> Joseph Goguen, James Thatcher, Eric Wagner, and Jesse Wright. </author> <title> Abstract data types as initial algebras and the correctness of data representations. </title> <editor> In Alan Klinger, editor, </editor> <booktitle> Computer Graphics, Pattern Recognition and Data Structure, </booktitle> <pages> pages 89-93. </pages> <publisher> IEEE, </publisher> <year> 1975. </year>
Reference-contexts: What this result tells us is that all of the data types that are of interest in computer science can be defined using initiality, although sometimes it may be necessary to add some auxiliary functions. All of this motivates the following fundamental conceptualization, which goes back to 1975 <ref> [32, 31] </ref>: Definition 2.11 The abstract data type (abbreviated ADT) defined by a specification P is the class of all initial P -algebras. 2 5 The importance of initiality for computing developed gradually. <p> The term "initial algebra se-mantics" and its first applications (including Knuthian attribute semantics) appear in [17], while its first application to abstract data types is in <ref> [32] </ref>; a more complete and rigorous exposition is given in [31]. More on initiality can be found in [33] and [46]; the latter especially develops connections with induction and computability. Results on the adequacy of initiality were first given by Bergstra and Tucker [1].
Reference: [33] <author> Joseph Goguen, James Thatcher, Eric Wagner, and Jesse Wright. </author> <title> Initial algebra semantics and continuous algebras. </title> <journal> Journal of the Association for Computing Machinery, </journal> <volume> 24(1) </volume> <pages> 68-95, </pages> <month> January </month> <year> 1977. </year> <title> An early version is "Initial Algebra Semantics", by Joseph Goguen and James Thatcher, </title> <institution> IBM T.J. Watson Research Center, </institution> <type> Report RC 4865, </type> <month> May </month> <year> 1974. </year>
Reference-contexts: The term "initial algebra se-mantics" and its first applications (including Knuthian attribute semantics) appear in [17], while its first application to abstract data types is in [32]; a more complete and rigorous exposition is given in [31]. More on initiality can be found in <ref> [33] </ref> and [46]; the latter especially develops connections with induction and computability. Results on the adequacy of initiality were first given by Bergstra and Tucker [1].
Reference: [34] <author> Joseph Goguen, Timothy Winkler, Jose Meseguer, Kokichi Futatsugi, and Jean-Pierre Jouan-naud. Introducing OBJ. In Joseph Goguen and Grant Malcolm, </author> <title> editors, Algebraic Specification with OBJ: An Introduction with Case Studies. Academic, </title> <note> to appear. Also Technical Report SRI-CSL-88-9, August 1988, SRI International. </note>
Reference-contexts: It then gives a brief overview of the hidden algebra approach to behavioral specification, including its most significant proof technique, which is called coinduction. We use the notation of OBJ3 <ref> [25, 34] </ref> for some simple examples. Dedication After the Algebraic Engineering '97 conference, I learned that it would be dedicated to Prof. John Rhodes, in honor of his sixtieth birthday. <p> See [18] for more historical information about this early period, and [25, 21] for more recent results, examples and references. 2.3 OBJ Notation OBJ gives a notation for expressing both initial and loose specifications, and this notation has been implemented in a way that permits proving things about such specifications <ref> [34, 25, 21] </ref>. OBJ modules that are to be interpreted loosely begin with the keyword theory (or th) and close with the keyword endth. Between these two keywords come declarations for sorts and operations, plus (as discussed later) variables and equations.
Reference: [35] <author> Lutz Hamel. </author> <title> Behavioural Verification and Implementation of an Optimizing Compiler for OBJ3. </title> <type> PhD thesis, </type> <institution> Oxford University Computing Lab, </institution> <year> 1996. </year>
Reference-contexts: Of course, no one would invent a method like coinduction for examples as simple as our flag example; this was chosen for expository simplicity. Many much more complex examples have been done, including correctness proofs for an optimizing compiler and for a novel communication protocol <ref> [35] </ref>. Hidden algebra first appeared in [20], and was subsequently elaborated in several papers, including [22, 41, 6]; an important precursor was work by Goguen and Meseguer on what they called "abstract machines" [27]. The rapidly growing literature on hidden algebra includes [12, 26, 40, 8, 14].
Reference: [36] <author> Bart Jacobs. </author> <title> Objects and classes, </title> <editor> coalgebraically. In B. Freitag, Cliff Jones, C. Lengauer, and H.-J. Schek, editors, </editor> <booktitle> Object-Orientation with Parallelism and Persistence, </booktitle> <pages> pages 83-103. </pages> <publisher> Kluwer, </publisher> <year> 1996. </year>
Reference-contexts: Coinduction seems to give proofs that are about as simple as possible, but more experience is needed before this can be said with complete certainty. The closely related area of coalgebraic semantics also uses coinduction, and also has a rapidly growing literature, including <ref> [49, 36, 37, 38] </ref>. However, it seems that coalgebra has difficulty in treating builtin data types, nondeterminism, and concurrency. From the beginning of computer science almost sixty years ago, researchers have worked on program verification, starting with von Neumann and Turing.
Reference: [37] <author> Bart Jacobs. </author> <title> Invariants, bisimulations and the correctness of coalgebraic refinements. </title> <type> Technical Report CSI-R9704, </type> <institution> Computer Science Institute, Nijmegen, </institution> <year> 1997. </year>
Reference-contexts: Coinduction seems to give proofs that are about as simple as possible, but more experience is needed before this can be said with complete certainty. The closely related area of coalgebraic semantics also uses coinduction, and also has a rapidly growing literature, including <ref> [49, 36, 37, 38] </ref>. However, it seems that coalgebra has difficulty in treating builtin data types, nondeterminism, and concurrency. From the beginning of computer science almost sixty years ago, researchers have worked on program verification, starting with von Neumann and Turing.
Reference: [38] <author> Bart Jacobs and Jan Rutten. </author> <title> A tutorial on (co)algebras and (co)induction. </title> <journal> Bulletin of the European Association for Theoretical Computer Science, </journal> <volume> 62 </volume> <pages> 222-259, </pages> <month> June </month> <year> 1997. </year>
Reference-contexts: Coinduction seems to give proofs that are about as simple as possible, but more experience is needed before this can be said with complete certainty. The closely related area of coalgebraic semantics also uses coinduction, and also has a rapidly growing literature, including <ref> [49, 36, 37, 38] </ref>. However, it seems that coalgebra has difficulty in treating builtin data types, nondeterminism, and concurrency. From the beginning of computer science almost sixty years ago, researchers have worked on program verification, starting with von Neumann and Turing.
Reference: [39] <author> Saunders Mac Lane and Garrett Birkhoff. </author> <title> Algebra. </title> <publisher> Macmillan, </publisher> <year> 1967. </year>
Reference-contexts: e. 2 The word "abstract" in the phrase "abstract algebra" means "uniquely defined up to isomor-phism"; for example, an "abstract group" is an isomorphism class of groups, indicating that we are not interested in properties of any particular representation, but only in properties that hold for all representations; e.g., see <ref> [39] </ref>. Because Theorem 2.9 implies that all the initial models of a specification P = (; E) are abstractly the same in precisely this sense, the word "abstract" in "abstract data type" has exactly the same meaning. This is not a mere pun, but a significant fact about software engineering.
Reference: [40] <author> Grant Malcolm. </author> <title> Behavioural equivalence, bisimilarity, and minimal realisation. </title> <editor> In Magne Hav-eraaen, Olaf Owe, and Ole-Johan Dahl, editors, </editor> <title> Recent Trends in Data Type Specifications: </title> <booktitle> 11th Workshop on Specification of Abstract Data Types, </booktitle> <pages> pages 359-378. </pages> <booktitle> Springer Lecture Notes in Computer Science, </booktitle> <volume> Volume 1130, </volume> <year> 1996. </year> <institution> (Oslo Norway, </institution> <month> September </month> <year> 1995). </year>
Reference-contexts: Hidden algebra first appeared in [20], and was subsequently elaborated in several papers, including [22, 41, 6]; an important precursor was work by Goguen and Meseguer on what they called "abstract machines" [27]. The rapidly growing literature on hidden algebra includes <ref> [12, 26, 40, 8, 14] </ref>. Coinduction seems to give proofs that are about as simple as possible, but more experience is needed before this can be said with complete certainty.
Reference: [41] <author> Grant Malcolm and Joseph Goguen. </author> <title> Proving correctness of refinement and implementation. </title> <type> Technical Report Technical Monograph PRG-114, </type> <institution> Programming Research Group, University of Oxford, </institution> <year> 1994. </year> <note> Submitted for publication. </note>
Reference-contexts: Theorem 3.8 implies that if a ' a 0 under some hidden congruence ', then a and a 0 are behaviorally equivalent. This justifies a variety of techniques for proving behavioral equivalence (see also <ref> [24, 41] </ref>). In this context, a relation may be called a candidate relation before it is proved to be a hidden congruence. Probably the most common case is = , but the generalization to smaller is useful, for example in verifying refinements. <p> Many much more complex examples have been done, including correctness proofs for an optimizing compiler and for a novel communication protocol [35]. Hidden algebra first appeared in [20], and was subsequently elaborated in several papers, including <ref> [22, 41, 6] </ref>; an important precursor was work by Goguen and Meseguer on what they called "abstract machines" [27]. The rapidly growing literature on hidden algebra includes [12, 26, 40, 8, 14].
Reference: [42] <author> Jose Meseguer. </author> <title> Rewriting as a unified model of concurrency. </title> <booktitle> In Proceedings, Concur'90 Conference, Lecture Notes in Computer Science, </booktitle> <volume> Volume 458, </volume> <pages> pages 384-400, </pages> <address> Amsterdam, </address> <month> August </month> <year> 1990. </year> <pages> Springer. </pages>
Reference-contexts: We have discussed hidden algebra and its cousin coalgebra. One important new development is rewriting logic <ref> [42, 43] </ref>, a weakening of equational logic providing an operational semantics that is ideal for rapid implementation of many algorithms, e.g., in term rewriting [10], as well as for describing and comparing the many kinds of concurrency [44]; rewriting logic has been very efficiently implemented in the Maude system [45, 9].
Reference: [43] <author> Jose Meseguer. </author> <title> Conditional rewriting logic: Deduction, models and concurrency. </title> <editor> In Stephane Kaplan and Misuhiro Okada, editors, </editor> <booktitle> Conditional and Typed Rewriting Systems, </booktitle> <pages> pages 64-91. </pages> <publisher> Springer, </publisher> <year> 1991. </year> <booktitle> Lecture Notes in Computer Science, </booktitle> <volume> Volume 516. </volume>
Reference-contexts: We have discussed hidden algebra and its cousin coalgebra. One important new development is rewriting logic <ref> [42, 43] </ref>, a weakening of equational logic providing an operational semantics that is ideal for rapid implementation of many algorithms, e.g., in term rewriting [10], as well as for describing and comparing the many kinds of concurrency [44]; rewriting logic has been very efficiently implemented in the Maude system [45, 9].
Reference: [44] <author> Jose Meseguer. </author> <title> Conditional rewriting as a unified model of concurrency. </title> <journal> Theoretical Computer Science, </journal> <volume> 96(1) </volume> <pages> 73-155, </pages> <year> 1992. </year> <month> 16 </month>
Reference-contexts: One important new development is rewriting logic [42, 43], a weakening of equational logic providing an operational semantics that is ideal for rapid implementation of many algorithms, e.g., in term rewriting [10], as well as for describing and comparing the many kinds of concurrency <ref> [44] </ref>; rewriting logic has been very efficiently implemented in the Maude system [45, 9].
Reference: [45] <author> Jose Meseguer. </author> <title> A logical theory of concurrent objects and its realization in the Maude language. </title> <editor> In Gul Agha, Peter Wegner, and Aki Yonezawa, editors, </editor> <booktitle> Research Directions in Object-Based Concurrency. </booktitle> <publisher> MIT, </publisher> <year> 1993. </year> <note> Also Technical Report SRI-CSL-92-08, </note> <month> July </month> <year> 1992. </year>
Reference-contexts: logic [42, 43], a weakening of equational logic providing an operational semantics that is ideal for rapid implementation of many algorithms, e.g., in term rewriting [10], as well as for describing and comparing the many kinds of concurrency [44]; rewriting logic has been very efficiently implemented in the Maude system <ref> [45, 9] </ref>.
Reference: [46] <author> Jose Meseguer and Joseph Goguen. Initiality, </author> <title> induction and computability. </title> <editor> In Maurice Nivat and John Reynolds, editors, </editor> <booktitle> Algebraic Methods in Semantics, </booktitle> <pages> pages 459-541. </pages> <address> Cambridge, </address> <year> 1985. </year>
Reference-contexts: This is not a mere pun, but a significant fact about software engineering. Another fact suggesting we are on the right track is that any computable abstract data type has an equational specification; moreover, this specification tends to be reasonably simple and intuitive in practice. The following result from <ref> [46] </ref> somewhat generalizes the original version due to Bergstra and Tucker [1] (M is reachable iff the unique -homomorphism T ! M is surjective): Theorem 2.10 (Adequacy of Initiality) Given any computable reachable -algebra M with finite, there is a finite specification P = ( 0 ; A 0 ) such <p> sorts as , and such that M is -isomorphic to T P viewed as a -algebra. 2 We do not here define the concept of a "computable algebra", but it corresponds to what one would intuitively expect: all carrier sets are decidable and all operations are total computable functions; see <ref> [46] </ref>. What this result tells us is that all of the data types that are of interest in computer science can be defined using initiality, although sometimes it may be necessary to add some auxiliary functions. <p> The term "initial algebra se-mantics" and its first applications (including Knuthian attribute semantics) appear in [17], while its first application to abstract data types is in [32]; a more complete and rigorous exposition is given in [31]. More on initiality can be found in [33] and <ref> [46] </ref>; the latter especially develops connections with induction and computability. Results on the adequacy of initiality were first given by Bergstra and Tucker [1]. <p> Principles of induction can be justified from the fact that an initial algebra has no proper subalgebras <ref> [21, 46] </ref>; final (terminal) algebras play an analogous role in justifying reasoning about behavioral properties with hidden coinduction. Before describing the final algebra, I want to note that its use is not precisely dual to that of the initial algebra for abstract data types. <p> The proof generalizes the well known construction of an abstract machine as a quotient of the term algebra by the behavioral equivalence relation (usually called the Nerode equivalence in that context) <ref> [46] </ref>, and uses the existence of final algebras, which are proved to exist in [26]. Theorem 3.8 implies that if a ' a 0 under some hidden congruence ', then a and a 0 are behaviorally equivalent.
Reference: [47] <author> David Parnas. </author> <title> Information distribution aspects of design methodology. </title> <booktitle> Information Processing '72, </booktitle> <volume> 71 </volume> <pages> 339-344, </pages> <year> 1972. </year> <booktitle> Proceedings of 1972 IFIP Congress. </booktitle>
Reference-contexts: The crucial advance was to recognize that operations should be associated with data representations; this is exactly the same insight that advanced algebra from mere sets to algebras, which are sets with their associated operations. In software engineering this insight seems to have been due to David Parnas <ref> [47] </ref>, and in algebra to Emmy Noether. Parallel developments in software engineering and abstract algebra are a theme of this paper.
Reference: [48] <author> Horst Reichel. </author> <title> Behavioural validity of conditional equations in abstract data types. In Contributions to General Algebra 3. </title> <booktitle> Teubner, 1985. Proceedings of the Vienna Conference, </booktitle> <month> June 21-24, </month> <year> 1984. </year>
Reference-contexts: This motivates the following: Definition 3.4 Given a hidden signature (H; ), a hidden -algebra A is a (many sorted) - algebra A such that Aj = D. 2 We next define behavioral satisfaction of an equation, an idea introduced by Reichel <ref> [48] </ref>. Intuitively, the two terms of an equation `look the same' under every `experiment' consisting of some methods followed by an `observation,' i.e., an attribute.
Reference: [49] <author> Horst Reichel. </author> <title> An approach to object semantics based on terminal co-algebras. </title> <booktitle> Mathematical Structures in Computer Science, </booktitle> <volume> 5 </volume> <pages> 129-152, </pages> <year> 1995. </year>
Reference-contexts: Coinduction seems to give proofs that are about as simple as possible, but more experience is needed before this can be said with complete certainty. The closely related area of coalgebraic semantics also uses coinduction, and also has a rapidly growing literature, including <ref> [49, 36, 37, 38] </ref>. However, it seems that coalgebra has difficulty in treating builtin data types, nondeterminism, and concurrency. From the beginning of computer science almost sixty years ago, researchers have worked on program verification, starting with von Neumann and Turing.
Reference: [50] <author> John C. Reynolds. </author> <title> The Craft of Programming. </title> <publisher> Prentice Hall, </publisher> <year> 1981. </year>
Reference-contexts: John Reynolds has written an excellent book in a more traditional style <ref> [50] </ref>. Some early history of initial algebra semantics for abstract data types was given at the end of Section 2.2; see also [18].
References-found: 50

