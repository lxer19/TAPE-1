URL: http://www.cs.tu-berlin.de/~mki/report/part2.ps
Refering-URL: http://www.cs.tu-berlin.de/~mki/report/tr.html
Root-URL: http://www.aic.nrl.navy.mil/~aha/people.html
Title: Inductive Synthesis of Recursive Program Schemes  
Author: Stephan Bohm, Susanne Dobratz, Imre Szabo and Ute Schmid 
Keyword: sive program schemes.  
Abstract:  
Abstract-found: 1
Intro-found: 1
Reference: [ Wys83a ] <author> F. Wysotzki: </author> <title> Representation and induction of infinite concepts and recursive action sequences, </title> <booktitle> In Proceedings of the 8th IJCAI,Karlsruhe, </booktitle> <year> 1983 </year>
Reference-contexts: In this paper we only consider a method for inductive synthesis of functional programs. 2 Theoretical Background 2.1 General Idea Our basic approach is described in <ref> [ Wys83a ] </ref> . Given an initial tree, which represents an initial partial program for the solution of a finite set of example problems, we infer a generalized recursive function by interpreting the tree as element of a Kleene-sequence of an unknown recursive program scheme (RPS). <p> We cannot deal with functions in which more than one substitution rule occurs. Therefore, our algorithm cannot synthesize tree recursive functions, because there the structure of the recursion is completely different from the linear recursion one. For handling those functions it is necessary to generate sub-functions first, see <ref> [ Wys83a ] </ref> . All these restrictions of the algorithm are caused by the particular pattern matching idea, it is based on.
Reference: [ Wys83b ] <author> F. Wysotzki: </author> <title> Representation of recursive programs and action sequences, </title> <booktitle> In Proc.2 Workshop GDR/Italy, </booktitle> <address> Torino, </address> <year> 1983 </year>
Reference-contexts: The terms in (5) can be regarded as initial part of a Kleene-sequence of the RPS (2), which is the smallest fixpoint. 2.3 Formal Approach In this section we introduce a syntactical method to infer a RPS. Following <ref> [ Wys83b ] </ref> the induction principle is a generalization of the synthesis theorem of [ Sum77 ] . That is, by constructing a RPS we go into the opposite direction than mentioned in 2.2.
Reference: [ Sum77 ] <author> Ph. D. Summers: </author> <title> A methodology for LISP program construction from examples, </title> <journal> Journal ACM, 24/1,p. </journal> <volume> 162 - 175, </volume> <year> 1977 </year>
Reference-contexts: Following [ Wys83b ] the induction principle is a generalization of the synthesis theorem of <ref> [ Sum77 ] </ref> . That is, by constructing a RPS we go into the opposite direction than mentioned in 2.2.
Reference: [ MaWa80 ] <author> Z. Manna and R. Waldinger: </author> <title> A Deductive Approach to Program Synthesis, </title> <journal> In ACM Trans. on Programming Languages and Systems 2 (1),p.90 - 121, Association of Computing Machinery, </journal> <year> 1980 </year>
Reference-contexts: There are two methods of synthesizing programs. First, there is the deductive method, in which ones tries, to generate a program from a given specification by using transformation rules, f.e. [ DR93 ] , [ DaBur73 ] , or by theorem proving methods, f.e. <ref> [ MaWa80 ] </ref> . Therefore, it is necessary to have the appropriate knowledge about facts and rules of programming techniques as well as knowledge concerning the specified problem. Second, there is the inductive method.
Reference: [ DaBur73 ] <author> J. Darlington and R.M. Burstall: </author> <title> A System which automatically improves programes, </title> <note> In JCAI 3 , 1973,p.479 - 485 </note>
Reference-contexts: It is also called program synthesis. There are two methods of synthesizing programs. First, there is the deductive method, in which ones tries, to generate a program from a given specification by using transformation rules, f.e. [ DR93 ] , <ref> [ DaBur73 ] </ref> , or by theorem proving methods, f.e. [ MaWa80 ] . Therefore, it is necessary to have the appropriate knowledge about facts and rules of programming techniques as well as knowledge concerning the specified problem. Second, there is the inductive method.
Reference: [ DR93 ] <author> N. Dershowitz and U.S. Reddy: </author> <title> Deductive and inductive synthesis of equational programs, </title> <journal> In Journal of Symbolic Computation ,p.467 - 493, </journal> <year> 1993 </year>
Reference-contexts: It is also called program synthesis. There are two methods of synthesizing programs. First, there is the deductive method, in which ones tries, to generate a program from a given specification by using transformation rules, f.e. <ref> [ DR93 ] </ref> , [ DaBur73 ] , or by theorem proving methods, f.e. [ MaWa80 ] . Therefore, it is necessary to have the appropriate knowledge about facts and rules of programming techniques as well as knowledge concerning the specified problem. Second, there is the inductive method.
Reference: [ Bau79 ] <author> M.A. Bauer: </author> <title> Programming by Examples, </title> <booktitle> In AI 12, </booktitle> <year> 1979 </year>
Reference-contexts: Second, there is the inductive method. Here the intention is to extract a general solution, e.g. a general program scheme, from an initial computation tree, from traces of computation or from given examples of input-output-pairs, f.e. <ref> [ Bau79 ] </ref> . In this paper we only consider a method for inductive synthesis of functional programs. 2 Theoretical Background 2.1 General Idea Our basic approach is described in [ Wys83a ] .
Reference: [ JoKo ] <editor> J.P. Jouannaud and Y. Kodratoff: </editor> <title> Characterization of a class of functions synthesized from examples by a Summers like method using a `"B.M.W.`" matching technique, </title> <publisher> Pub.CRIN Univ. </publisher> <address> Nancy, </address> <year> (1979) </year>
Reference-contexts: All these restrictions of the algorithm are caused by the particular pattern matching idea, it is based on. In future work this pattern inferencer needs to be extended to a more generell one, like the Boyer-Moore-Algorithm, <ref> [ JoKo ] </ref> . 4 Conclusion and further work In this paper we showed a method for synthesizing LISP-functions from initial computation trees. Also our algorithm can only recognize simple tail-recursive functions yet.
Reference: [ FH88 ] <author> A.J. Field and P.G. Harrison: </author> <title> Functional Programming, </title> <publisher> Addison-Wesley, </publisher> <address> Reading, Mas., </address> <year> 1988 </year>
Reference-contexts: (empty (l); T; g (eq (head (l); 0); F; G (1) (tail (l))))) These partial solutions can be interpreted as starting elements of a Kleene-sequence with the RPS (2) as least fixpoint. 2.2 Basic Definitions Now, we want to describe some basic concepts of the semantics of functional programs, see <ref> [ FH88 ] </ref> . Term Algebras Let M (V,F) be a term algebra with V as set of variables and F as a set of primitive function symbols with arity. F may contain constant symbols as function symbols with arity zero.
Reference: [ BF82 ] <editor> A. Barr and E. Feigenbaum: </editor> <booktitle> The Handbook of Artificial Intelligence, Vol.2,p.297- 306, </booktitle> <publisher> W.Kaufmann Inc, </publisher> <address> Los Altos, California, </address> <year> 1982 </year>
Reference-contexts: Automatic programming may not only help experienced programmers in writing standard functions but also give help to inexperienced programmers. Another aspect of automatic programming is to guarantee the quality of software products in terms of meeting the specifications, see <ref> [ BF82 ] </ref> . The term 'automatic programming' describes the generation of computer programs from specifications or examples. It is also called program synthesis. There are two methods of synthesizing programs.
References-found: 10

