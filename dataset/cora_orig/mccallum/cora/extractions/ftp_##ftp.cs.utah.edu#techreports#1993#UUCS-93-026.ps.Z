URL: ftp://ftp.cs.utah.edu/techreports/1993/UUCS-93-026.ps.Z
Refering-URL: http://www.cs.utah.edu/~gary/MSO-EOYL94.html
Root-URL: 
Title: Modular Language Processors As Framework Completions  
Author: Guruduth Banavar Gary Lindstrom 
Date: October 21, 1993  
Address: Salt Lake City, UT 84112 USA  
Affiliation: Department of Computer Science University of Utah  
Pubnum: UUCS-93-026  
Abstract: The conceptual and specificational power of denotational semantics for programming language design has been amply demonstrated. We report here on a language implementation method that is similarly semantically motivated, but is based upon object-oriented design principles, and results in flexible and evolvable language processors. We apply this technique to the area of object-oriented (O-O) languages, in the form of a general metalevel architecture for objects and inheritance that facilitates the development of compilers and interpreters for O-O languages. This development strategy maintains architectural modularity by mapping conceptual language design decisions to isolatable parts of resulting language processors. Our architecture, which is presented as an O-O framework, is characterized by (i) support for a broad set of modularity features including encapsulation and strong typing, and (ii) an "unbundled" view of inheritance, semantic features of which are decomposed by means of a set of module combination operations (combinators). We describe an implementation of our framework in C++, and assess its utility by constructing a compiler for a simple O-O extension to the programming language C. We further argue the flexibility of the resulting processor by outlining the incorporation of several significant extensions to the basic module language. We claim that the use of such a framework for compiler construction has many advantages, including a systematic language development method, processor software reuse, language extensibility, and potential for interoperability among languages. 1 
Abstract-found: 1
Intro-found: 1
Reference: [AW82] <author> E. A. Ashcroft and W. W. Wadge. </author> <title> Prescription for semantics. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 4(2), </volume> <month> April, </month> <year> 1982. </year>
Reference-contexts: 1 Introduction The denotational approach to programming language design employs abstraction to specify properties that a language's implementation must satisfy. The conceptual and specificational power of this approach is widely acknowledged <ref> [AW82] </ref>. However, the direct realization of language processors embodying a denotational semantic specification in modular and evolvable form remains an elusive research goal [JS80]. One may ask whether alternative semantic formulations might more effectively bridge this gap between language design and implementation.
Reference: [BC90] <author> Gilad Bracha and William Cook. </author> <title> Mixin-based inheritance. </title> <booktitle> In Proc. OOPSLA Conference, </booktitle> <address> Ottawa, </address> <month> October </month> <year> 1990. </year> <note> ACM. </note>
Reference-contexts: Jigsaw is unusually powerful in accommodating differing senses of modules. Bracha and Lindstrom [BL92, Bra92] have given a rigorous formal semantics for Jigsaw's module abstraction, building on the work of Cardelli, Cook, Harper, Palsberg, Pierce, and others <ref> [HP91, CM89, Coo89, CP89, BC90] </ref>. For our purposes, an informal sketch of the semantics of Jigsaw will suffice. In Jigsaw, a module is simply a self-referential scope, associating labels (identifiers) with meanings.
Reference: [BCLO93] <author> Gilad Bracha, Charles F. Clark, Gary Lindstrom, and Douglas B. Orr. </author> <title> Module management as a system service. </title> <type> Unpublished paper, </type> <month> July </month> <year> 1993. </year>
Reference-contexts: The result is a greatly enlarged conception of object file (module) manipulation and management, cast as a pervasive system service, under which many value added features are deliverable, including portable shared libraries [OBLM93], function interposition <ref> [BCLO93] </ref>, and dynamic program monitoring and reorga nization [OMHL93]. * Concurrent O-O programming. It is increasingly evident that the relationships between sequential and concurrent conceptions of O-O programming are inadequately understood.
Reference: [BG93] <author> Gilad Bracha and David Griswold. Strongtalk: </author> <title> Typechecking Smalltalk in a production environment. </title> <booktitle> In Proc. OOPSLA Conference, </booktitle> <address> Washington D.C., </address> <month> September </month> <year> 1993. </year> <note> ACM. </note>
Reference-contexts: Other advantages include: * Language extensibility: the ability to layer object systems on legacy non-object languages; * Evolvability: the ability to easily model existing forms of inheritance, hence to re-engineer compilers for existing languages, thus facilitating further evolution, e.g. adaptation of new advances in type checking <ref> [BG93] </ref>, or combination of inheritance hierarchies [OH92]; and * Experimentation: the ability to refine and combine the framework abstractions in flexible ways to create new and interesting object models and to investigate the resulting feature interactions. <p> If it is necessary to design a name-based type system for a particular client language, this can be achieved by incorporating the concept of brands <ref> [Nel91, BG93] </ref> into a subclass brandedInterface of class Interface, and refining the corresponding constructor and equivalence methods. 7 Although instance types are generally regarded as distinct from module types (i.e. interfaces), they can be modeled as Interface objects. 8 Types that are not subtypes but share a similar recursive nature [CCHO89].
Reference: [BL92] <author> Gilad Bracha and Gary Lindstrom. </author> <title> Modularity meets inheritance. </title> <booktitle> In Proc. International Conference on Computer Languages, </booktitle> <pages> pages 282-290, </pages> <address> San Francisco, CA, </address> <month> April 20-23 </month> <year> 1992. </year> <journal> IEEE Computer Society. </journal> <note> Also available as Technical Report UUCS-91-017. 16 </note>
Reference-contexts: This realization motivates the formulation of our central abstraction, module, in such a way that it permits aspects of the class construct such as inheritance and visibility control to be "unbundled" as operations generically applicable to modules. We draw on previous work <ref> [BL92, Bra92] </ref>, which has succeeded in formulating the module notion and operations on modules as a set of operators in a module manipulation language called Jigsaw. Jigsaw is unusually powerful in accommodating differing senses of modules. Bracha and Lindstrom [BL92, Bra92] have given a rigorous formal semantics for Jigsaw's module abstraction, <p> We draw on previous work <ref> [BL92, Bra92] </ref>, which has succeeded in formulating the module notion and operations on modules as a set of operators in a module manipulation language called Jigsaw. Jigsaw is unusually powerful in accommodating differing senses of modules. Bracha and Lindstrom [BL92, Bra92] have given a rigorous formal semantics for Jigsaw's module abstraction, building on the work of Cardelli, Cook, Harper, Palsberg, Pierce, and others [HP91, CM89, Coo89, CP89, BC90]. For our purposes, an informal sketch of the semantics of Jigsaw will suffice. <p> For concreteness, an example of Jigsaw modules and module combination is given in Figure 1, in which a generic surface syntax is used. The modeling power of Jigsaw's module abstraction and module combination operators is fully investigated in <ref> [BL92] </ref>. 3 Jigsaw : A Modularity Framework For expository purposes, Jigsaw has been described thus far as a concrete language. The crucial point, however, is that one may view Jigsaw merely as an abstract module manipulation language.
Reference: [Bra92] <author> Gilad Bracha. </author> <title> The Programming Language Jigsaw: Mixins, Modularity and Multiple Inheritance. </title> <type> PhD thesis, </type> <institution> University of Utah, </institution> <month> March </month> <year> 1992. </year> <note> Technical report UUCS-92-007; 143 pp. </note>
Reference-contexts: One may ask whether alternative semantic formulations might more effectively bridge this gap between language design and implementation. Recently, concepts fundamental to object-oriented programming have been successfully specified in a formal semantic manner <ref> [Coo89, Bra92] </ref>. Moreover, object-oriented programming and design techniques have matured through extensive application in a variety of areas. <p> This realization motivates the formulation of our central abstraction, module, in such a way that it permits aspects of the class construct such as inheritance and visibility control to be "unbundled" as operations generically applicable to modules. We draw on previous work <ref> [BL92, Bra92] </ref>, which has succeeded in formulating the module notion and operations on modules as a set of operators in a module manipulation language called Jigsaw. Jigsaw is unusually powerful in accommodating differing senses of modules. Bracha and Lindstrom [BL92, Bra92] have given a rigorous formal semantics for Jigsaw's module abstraction, <p> We draw on previous work <ref> [BL92, Bra92] </ref>, which has succeeded in formulating the module notion and operations on modules as a set of operators in a module manipulation language called Jigsaw. Jigsaw is unusually powerful in accommodating differing senses of modules. Bracha and Lindstrom [BL92, Bra92] have given a rigorous formal semantics for Jigsaw's module abstraction, building on the work of Cardelli, Cook, Harper, Palsberg, Pierce, and others [HP91, CM89, Coo89, CP89, BC90]. For our purposes, an informal sketch of the semantics of Jigsaw will suffice. <p> When module objects are combined using module operators, their type compatibility is checked by comparing the interface objects corresponding to the modules with the help of methods in class Interface. The type checking rules incorporated into the Jigsaw framework are explained in detail in Bracha <ref> [Bra92] </ref>. As explained earlier, the framework provides a rather generic object model (via the module abstraction) and nothing more. As a result, the above abstractions are defined relative to the notions of value, type and even label in a client language, over which Jigsaw abstracts.
Reference: [Bra93] <author> Gilad Bracha. </author> <title> Private communication. Electronic mail, </title> <month> January 28, </month> <year> 1993. </year>
Reference-contexts: Secondly, there would be a need for type checking inherited types 8 | this can be done by subclassing class Interface and class Type. Language design issues such as these are discussed in detail in the literature <ref> [HC90, Bru93, Bra93] </ref> | the key point is that a wide range of type systems can be accommodated as refinements of the basic formulation of the Jigsaw framework.
Reference: [Bru92] <author> Kim B. Bruce. </author> <title> A paradigmatic object-oriented programming language: Design static typing and semantics. </title> <type> Technical Report CS-92-01, </type> <institution> Williams College, </institution> <month> January 31, </month> <year> 1992. </year>
Reference-contexts: Using our framework, the type of self, which is an instance type 7 , can be designed as a distinguished object of class Interface. Furthermore, if function parameters of self type are to be permitted in a client, as described extensively in recent literature <ref> [Bru93, Bru92] </ref>, two major refinements to the default type system would be required. Firstly, in the default formulation of Jigsaw, the hide operator permits removing an attribute from a module's public interface after the fact, i.e. module interfaces can evolve non-monotonically. <p> refining the corresponding constructor and equivalence methods. 7 Although instance types are generally regarded as distinct from module types (i.e. interfaces), they can be modeled as Interface objects. 8 Types that are not subtypes but share a similar recursive nature [CCHO89]. 9 This corresponds to the bound variable MyType in <ref> [Bru92] </ref> 13 * Bundled inheritance semantics. If a client requires retention of particular compound inher-itance semantics, such features can be modeled using Jigsaw operators.
Reference: [Bru93] <author> Kim B. Bruce. </author> <title> Safe type checking in a statically typed object-oriented programming language. </title> <editor> In Susan Graham, editor, </editor> <booktitle> Proc. Symposium on Principles of Programming Languages, </booktitle> <year> 1993. </year>
Reference-contexts: Using our framework, the type of self, which is an instance type 7 , can be designed as a distinguished object of class Interface. Furthermore, if function parameters of self type are to be permitted in a client, as described extensively in recent literature <ref> [Bru93, Bru92] </ref>, two major refinements to the default type system would be required. Firstly, in the default formulation of Jigsaw, the hide operator permits removing an attribute from a module's public interface after the fact, i.e. module interfaces can evolve non-monotonically. <p> Secondly, there would be a need for type checking inherited types 8 | this can be done by subclassing class Interface and class Type. Language design issues such as these are discussed in detail in the literature <ref> [HC90, Bru93, Bra93] </ref> | the key point is that a wide range of type systems can be accommodated as refinements of the basic formulation of the Jigsaw framework.
Reference: [CCHO89] <author> P. Canning, W. Cook, W. Hill, and W. Olthoff. </author> <title> Interfaces for strongly-typed object-oriented programming. </title> <editor> In Norman Meyrowitz, editor, </editor> <booktitle> Proceedings of the ACM Conference on Object-Oriented Programming, Systems, Languages, and Applications, </booktitle> <pages> pages 457-467, </pages> <year> 1989. </year>
Reference-contexts: [Nel91, BG93] into a subclass brandedInterface of class Interface, and refining the corresponding constructor and equivalence methods. 7 Although instance types are generally regarded as distinct from module types (i.e. interfaces), they can be modeled as Interface objects. 8 Types that are not subtypes but share a similar recursive nature <ref> [CCHO89] </ref>. 9 This corresponds to the bound variable MyType in [Bru92] 13 * Bundled inheritance semantics. If a client requires retention of particular compound inher-itance semantics, such features can be modeled using Jigsaw operators.
Reference: [CD88] <author> Eric C. Cooper and Richard P. Draves. </author> <title> C threads. </title> <type> Draft report, </type> <institution> Mach Project, Carnegie-Mellon Univ., </institution> <month> 6 March </month> <year> 1988. </year>
Reference-contexts: We conjecture that the Jigsaw framework, enhanced to support asynchronous message dispatch via synchronization condition predicates managed as rebind-able module attributes, will provide a more general and satisfying solution. We plan to test this conjecture by porting JigC to the pseudo concurrent environment provided by Cthreads <ref> [CD88] </ref>. * Nested Modules. Thorough incorporation of nested modules in a language opens up new semantic avenues, e.g. sharing, and several software engineering possibilities, e.g. combination of inheritance hierarchies.
Reference: [Cha89] <author> Craig Chambers. </author> <title> Customization: Optimizing compiler technology for self, a dynamically typed object-oriented programming language. </title> <booktitle> In SIGPLAN '89 Conference on Programming Language Design and Implementation, </booktitle> <volume> Jun 21 - 23, </volume> <year> 1989. </year>
Reference-contexts: A simple form of dispatch is built into the Jigsaw framework in the implementation of the methods select (Label) and self-refer (Label) of class Instance. Depending on client requirements, the default can be refined to incorporate alternate dispatch mechanisms <ref> [HC92, Cha89] </ref>. Interestingly, the Jigsaw module model requires a form of delayed binding occurring not at run-time (i.e. dynamically) but rather at module combination time. This is because module attributes are by default rebindable, but can be made non-rebindable at any point by applying the module operator freeze.
Reference: [CIJ + 91] <author> Roy H. Campbell, Nayeem Islam, Ralph Johnson, Panos Kougiouris, and Peter Madany. </author> <title> Choices, frameworks and refinement. </title> <booktitle> In Object Orientation in Operating Systems, </booktitle> <pages> pages 9-15, </pages> <address> Palo Alto, CA, </address> <month> October </month> <year> 1991. </year> <journal> IEEE Computer Society. </journal>
Reference-contexts: Frameworks thus promote design and code reuse through O-O concepts such as inheritance and polymorphism. Several 2 Connecting objects constructed from predefined concrete classes [JR91]. 4 frameworks have been developed, first for user interfaces, and subsequently for many other domains as well <ref> [Deu89, VL89, WGM88, CIJ + 91] </ref>.
Reference: [CM89] <author> Luca Cardelli and John C. Mitchell. </author> <title> Operations on records. </title> <type> Technical Report 48, </type> <institution> Digital Equipment Corporation Systems Research Center, </institution> <month> August </month> <year> 1989. </year>
Reference-contexts: Jigsaw is unusually powerful in accommodating differing senses of modules. Bracha and Lindstrom [BL92, Bra92] have given a rigorous formal semantics for Jigsaw's module abstraction, building on the work of Cardelli, Cook, Harper, Palsberg, Pierce, and others <ref> [HP91, CM89, Coo89, CP89, BC90] </ref>. For our purposes, an informal sketch of the semantics of Jigsaw will suffice. In Jigsaw, a module is simply a self-referential scope, associating labels (identifiers) with meanings.
Reference: [Coo89] <author> William Cook. </author> <title> A Denotational Semantics of Inheritance. </title> <type> PhD thesis, </type> <institution> Brown University, </institution> <year> 1989. </year>
Reference-contexts: One may ask whether alternative semantic formulations might more effectively bridge this gap between language design and implementation. Recently, concepts fundamental to object-oriented programming have been successfully specified in a formal semantic manner <ref> [Coo89, Bra92] </ref>. Moreover, object-oriented programming and design techniques have matured through extensive application in a variety of areas. <p> Jigsaw is unusually powerful in accommodating differing senses of modules. Bracha and Lindstrom [BL92, Bra92] have given a rigorous formal semantics for Jigsaw's module abstraction, building on the work of Cardelli, Cook, Harper, Palsberg, Pierce, and others <ref> [HP91, CM89, Coo89, CP89, BC90] </ref>. For our purposes, an informal sketch of the semantics of Jigsaw will suffice. In Jigsaw, a module is simply a self-referential scope, associating labels (identifiers) with meanings.
Reference: [CP89] <author> William Cook and Jen Palsberg. </author> <title> A denotational semantics of inheritance and its correctness. </title> <booktitle> In Proc. ACM Conf. on Object-Oriented Programming: Systems, Languages and Applications, </booktitle> <pages> pages 433-444, </pages> <year> 1989. </year>
Reference-contexts: Jigsaw is unusually powerful in accommodating differing senses of modules. Bracha and Lindstrom [BL92, Bra92] have given a rigorous formal semantics for Jigsaw's module abstraction, building on the work of Cardelli, Cook, Harper, Palsberg, Pierce, and others <ref> [HP91, CM89, Coo89, CP89, BC90] </ref>. For our purposes, an informal sketch of the semantics of Jigsaw will suffice. In Jigsaw, a module is simply a self-referential scope, associating labels (identifiers) with meanings.
Reference: [Deu89] <author> L. Peter Deutsch. </author> <title> Design reuse and frameworks in the Smalltalk-80 programming system. </title> <editor> In Ted J. Biggerstaff and Alan J. Perlis, editors, </editor> <booktitle> Software Reusability, </booktitle> <volume> volume 2, </volume> <pages> pages 55-71. </pages> <publisher> ACM Press, </publisher> <year> 1989. </year>
Reference-contexts: Frameworks thus promote design and code reuse through O-O concepts such as inheritance and polymorphism. Several 2 Connecting objects constructed from predefined concrete classes [JR91]. 4 frameworks have been developed, first for user interfaces, and subsequently for many other domains as well <ref> [Deu89, VL89, WGM88, CIJ + 91] </ref>.
Reference: [ES90] <author> Margaret A. Ellis and Bjarne Stroustrup. </author> <title> The Annotated C++ Reference Manual. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, MA, </address> <year> 1990. </year>
Reference-contexts: Jigsaw models object-level encapsulation 5 , as opposed to class-level encapsulation as found in languages such as CLU [LG86] and C++ <ref> [ES90] </ref>, where objects of a class have access to each other's internals. A module type system is built into the Jigsaw framework. This default type system is structural rather than name-based, the latter being found in most current O-O languages. <p> In our prototype implementation of the Jigsaw framework, we have chosen C++ <ref> [ES90] </ref> as our framework implementation language L f . In this section, we comment on a few aspects of this implementation.
Reference: [Gor79] <author> Michael J. C. Gordon. </author> <title> The Denotational Description of Programming Languages. </title> <publisher> Springer-Verlag, </publisher> <year> 1979. </year>
Reference-contexts: This exemplifies one virtue of the framework approach to language development | isolation and illumination of the options available to the language designer. The reader might have noted the correspondence between the above framework abstraction design and denotational models of programming languages <ref> [Gor79] </ref>. Denotational semantics applies functional programming to abstract over language functionality. Here, we apply a denotational description of modularity in O-O programming to abstract over language modularity.
Reference: [GR83] <author> Adele Goldberg and David Robson. </author> <title> Smalltalk-80: The Language and its Implementation. </title> <publisher> Addison-Wesley, </publisher> <year> 1983. </year>
Reference-contexts: The idea is to model notions fundamental to O-O programming, such as class, themselves as objects. This has been exploited in the design and construction of O-O languages and environments, such as Smalltalk <ref> [GR83] </ref> and the CLOS Meta Object Protocol [KdRB91]. However, such metalevel architectures are tightly coupled with their base languages within highly dynamic and reflective environments. While this coupling enhances application development flexibility, it causes the metalevel architecture to be too restrictive for full-fledged language and system development.
Reference: [Har87] <author> W. Harrison. </author> <title> RPDE 3 : A framework for integrating tool fragments. </title> <journal> IEEE Software, </journal> <volume> 4 </volume> <pages> 46-56, </pages> <month> November </month> <year> 1987. </year>
Reference-contexts: A further advantage of our approach that we are currently investigating is the potential for multi-lingual O-O 1 programming. We expect this to be the result of logical compatibility of objects across independent extensions of the framework, in the same sense that common calling sequences facilitate function-level inter-language linking <ref> [Har87] </ref>. Traditionally, abstraction and reuse in compiler construction have been fruitfully applied to implementation data structures, e.g. symbol tables, parse trees, etc. It seems natural to extend these advantages by abstracting concepts in the computational domain of the language being implemented.
Reference: [HC90] <author> Jin Ho Hur and Kilnam Chon. </author> <title> Self and selftype. </title> <journal> Information Processing Letters, </journal> <volume> 36 </volume> <pages> 225-230, </pages> <year> 1990. </year>
Reference-contexts: Secondly, there would be a need for type checking inherited types 8 | this can be done by subclassing class Interface and class Type. Language design issues such as these are discussed in detail in the literature <ref> [HC90, Bru93, Bra93] </ref> | the key point is that a wide range of type systems can be accommodated as refinements of the basic formulation of the Jigsaw framework.
Reference: [HC92] <author> Shih-Kun Huang and Deng-Jyi Chen. </author> <title> Efficient algorithms for method dispatch in object-oriented programming systems. </title> <journal> Journal of Object-Oriented Programming, </journal> <month> September </month> <year> 1992. </year>
Reference-contexts: A simple form of dispatch is built into the Jigsaw framework in the implementation of the methods select (Label) and self-refer (Label) of class Instance. Depending on client requirements, the default can be refined to incorporate alternate dispatch mechanisms <ref> [HC92, Cha89] </ref>. Interestingly, the Jigsaw module model requires a form of delayed binding occurring not at run-time (i.e. dynamically) but rather at module combination time. This is because module attributes are by default rebindable, but can be made non-rebindable at any point by applying the module operator freeze.
Reference: [HP91] <author> Robert Harper and Benjamin Pierce. </author> <title> A record calculus based on symmetric concatenation. </title> <booktitle> In Proc. of the ACM Symp. on Principles of Programming Languages, </booktitle> <pages> pages 131-142, </pages> <month> January </month> <year> 1991. </year> <month> 17 </month>
Reference-contexts: Jigsaw is unusually powerful in accommodating differing senses of modules. Bracha and Lindstrom [BL92, Bra92] have given a rigorous formal semantics for Jigsaw's module abstraction, building on the work of Cardelli, Cook, Harper, Palsberg, Pierce, and others <ref> [HP91, CM89, Coo89, CP89, BC90] </ref>. For our purposes, an informal sketch of the semantics of Jigsaw will suffice. In Jigsaw, a module is simply a self-referential scope, associating labels (identifiers) with meanings.
Reference: [JR91] <author> Ralph E. Johnson and Vincent F. Russo. </author> <title> Reusing object-oriented designs. </title> <type> Technical Report UIUCDCS 91-1696, </type> <institution> University of Illinois at Urbana-Champagne, </institution> <month> May </month> <year> 1991. </year>
Reference-contexts: We also seek to make our object model "open-ended", so that it can used in a variety of situations. This is achieved (i) conceptually by "unbundling" the class concept and inheritance semantics traditionally found in O-O languages, and (ii) implementationally by formulating our model as an O-O framework <ref> [JR91] </ref> that uses abstract classes, i.e. incompletely defined classes that are completed by the framework user. The framework user can either adopt the default semantics of the object system, or refine it to suit particular language requirements. <p> This formulation is facilitated by the use of O-O frameworks, where the concept of abstract classes is central. In this section, we present a framework for module manipulation encompassing the module manipulation language semantics presented above. We call this framework the Jigsaw framework. In essence, an O-O framework <ref> [JR91] </ref> expresses the design of a software system in terms of objects and interactions between them, typically represented using a general purpose O-O programming language. <p> Frameworks thus promote design and code reuse through O-O concepts such as inheritance and polymorphism. Several 2 Connecting objects constructed from predefined concrete classes <ref> [JR91] </ref>. 4 frameworks have been developed, first for user interfaces, and subsequently for many other domains as well [Deu89, VL89, WGM88, CIJ + 91].
Reference: [JS80] <author> N. D. Jones and D. A. Schmidt. </author> <title> Compiler generation from denotational semantics. </title> <editor> In N. D. Jones, editor, </editor> <booktitle> Semantics-Directed Compiler Generation, </booktitle> <pages> pages 70-93. </pages> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1980. </year> <booktitle> Lecture Notes In Computer Science Number 94. </booktitle>
Reference-contexts: The conceptual and specificational power of this approach is widely acknowledged [AW82]. However, the direct realization of language processors embodying a denotational semantic specification in modular and evolvable form remains an elusive research goal <ref> [JS80] </ref>. One may ask whether alternative semantic formulations might more effectively bridge this gap between language design and implementation. Recently, concepts fundamental to object-oriented programming have been successfully specified in a formal semantic manner [Coo89, Bra92].
Reference: [KdRB91] <author> Gregor Kiczales, Jim des Rivieres, and Daniel G. Bobrow. </author> <title> The Art of the Metaobject Protocol. </title> <publisher> The MIT Press, </publisher> <address> Cambridge, MA, </address> <year> 1991. </year>
Reference-contexts: The idea is to model notions fundamental to O-O programming, such as class, themselves as objects. This has been exploited in the design and construction of O-O languages and environments, such as Smalltalk [GR83] and the CLOS Meta Object Protocol <ref> [KdRB91] </ref>. However, such metalevel architectures are tightly coupled with their base languages within highly dynamic and reflective environments. While this coupling enhances application development flexibility, it causes the metalevel architecture to be too restrictive for full-fledged language and system development.
Reference: [KR88] <author> Brian W. Kernighan and Dennis M. Ritchie. </author> <title> The C Programming Language. </title> <publisher> Prentice-Hall, </publisher> <address> Englewood Cliffs, NJ, </address> <year> 1988. </year>
Reference-contexts: In this section, we outline the design and implementation of an upwardly compatible module extension of the programming language C <ref> [KR88] </ref>, called JigC, which is being developed to showcase and further evaluate the Jigsaw module model. In this experiment, we first retrofitted a module system onto an existing language, and implemented a processor for it using our framework.
Reference: [L 93] <author> Klaus-Peter Lohr. </author> <title> Concurrency annotations for reusable software. </title> <journal> Communications of the ACM, </journal> <volume> 36(9) </volume> <pages> 81-89, </pages> <month> September </month> <year> 1993. </year>
Reference-contexts: In particular, several researchers have reported that inheritance, as commonly understood for sequential O-O languages, gives rise to semantic anomalies and violations of encapsulation when applied to concurrent O-O languages. Various remedies have been proposed (e.g. <ref> [L 93, Mes93] </ref>), but none directly addresses the issue of migrating existing sequential O-O code to concurrent settings. We conjecture that the Jigsaw framework, enhanced to support asynchronous message dispatch via synchronization condition predicates managed as rebind-able module attributes, will provide a more general and satisfying solution.
Reference: [Lee92] <author> Arthur H. Lee. </author> <title> The Persistent Object System MetaStore: Persistence Via Metaprogramming. </title> <type> PhD thesis, </type> <institution> University of Utah, </institution> <month> June </month> <year> 1992. </year> <note> Technical report UUCS-92-027; 171 pp. </note>
Reference-contexts: However, the Jigsaw framework can be used for many purposes that the CLOS MOP has been put to use, notably persistent objects <ref> [Pae88, Lee92] </ref>. 6 Conclusions A framework-based approach to language processor design and implementation has been described. This approach, called Jigsaw, relies on an abstract conception of software modules, refineable in several dimensions to characterize a large space of specific module formulations.
Reference: [LG86] <author> Barbara Liskov and John Guttag. </author> <title> Abstraction and Specification in Program Development. </title> <publisher> The MIT Press, </publisher> <address> Cambridge, MA, </address> <year> 1986. </year>
Reference-contexts: Jigsaw models object-level encapsulation 5 , as opposed to class-level encapsulation as found in languages such as CLU <ref> [LG86] </ref> and C++ [ES90], where objects of a class have access to each other's internals. A module type system is built into the Jigsaw framework. This default type system is structural rather than name-based, the latter being found in most current O-O languages.
Reference: [Mes93] <author> Jose Meseguer. </author> <title> Solving the inheritance anomaly in concurrent object-oriented programming. </title> <booktitle> In Proceedings ECOOP '93, </booktitle> <publisher> LNCS, </publisher> <address> Kauserlautern, Germany, July 1993. </address> <publisher> Springer-Verlag. </publisher>
Reference-contexts: In particular, several researchers have reported that inheritance, as commonly understood for sequential O-O languages, gives rise to semantic anomalies and violations of encapsulation when applied to concurrent O-O languages. Various remedies have been proposed (e.g. <ref> [L 93, Mes93] </ref>), but none directly addresses the issue of migrating existing sequential O-O code to concurrent settings. We conjecture that the Jigsaw framework, enhanced to support asynchronous message dispatch via synchronization condition predicates managed as rebind-able module attributes, will provide a more general and satisfying solution.
Reference: [Nel91] <author> Ed. Greg Nelson. </author> <title> Systems Programming with Modula-3. </title> <publisher> Prentice Hall, </publisher> <address> Englewood Cliffs, NJ, </address> <year> 1991. </year>
Reference-contexts: If it is necessary to design a name-based type system for a particular client language, this can be achieved by incorporating the concept of brands <ref> [Nel91, BG93] </ref> into a subclass brandedInterface of class Interface, and refining the corresponding constructor and equivalence methods. 7 Although instance types are generally regarded as distinct from module types (i.e. interfaces), they can be modeled as Interface objects. 8 Types that are not subtypes but share a similar recursive nature [CCHO89].
Reference: [OBLM93] <author> Douglas Orr, John Bonn, Jay Lepreau, and Robert Mecklenburg. </author> <title> Fast and flexible shared libraries. </title> <booktitle> In Proc. USENIX Summer Conference, </booktitle> <pages> pages 237-251, </pages> <address> Cincinnati, </address> <month> June </month> <year> 1993. </year>
Reference-contexts: The result is a greatly enlarged conception of object file (module) manipulation and management, cast as a pervasive system service, under which many value added features are deliverable, including portable shared libraries <ref> [OBLM93] </ref>, function interposition [BCLO93], and dynamic program monitoring and reorga nization [OMHL93]. * Concurrent O-O programming. It is increasingly evident that the relationships between sequential and concurrent conceptions of O-O programming are inadequately understood.
Reference: [OH92] <author> Harold Ossher and William Harrison. </author> <title> Combination of inheritance hierarchies. </title> <booktitle> In OOPSLA Proceedings, </booktitle> <pages> pages 25-40, </pages> <month> October </month> <year> 1992. </year>
Reference-contexts: include: * Language extensibility: the ability to layer object systems on legacy non-object languages; * Evolvability: the ability to easily model existing forms of inheritance, hence to re-engineer compilers for existing languages, thus facilitating further evolution, e.g. adaptation of new advances in type checking [BG93], or combination of inheritance hierarchies <ref> [OH92] </ref>; and * Experimentation: the ability to refine and combine the framework abstractions in flexible ways to create new and interesting object models and to investigate the resulting feature interactions. <p> C++) for the same reasons that Jigsaw modules are advantageous, namely (i) it provides a uniform module model with unbundled inheritance operators, (ii) it supports a static structural (interface-based) module type system, and (iii) it supports nested modules, a powerful feature (e.g. enabling combination of inheritance hierarchies <ref> [OH92] </ref>). In addition, implementing the JigC compiler as a completion of the Jigsaw framework brings with it the important benefit of evolvability, which is the subject of Section 4.3. The interactions of the module system with the client language (C, in our case) are numerous, and sometimes subtle.
Reference: [OM92] <author> Douglas B. Orr and Robert W. Mecklenburg. </author> <title> OMOS | an object server for program execution. </title> <booktitle> In Proc. International Workshop on Object Oriented Operating Systems, </booktitle> <pages> pages 200-209, </pages> <address> Paris, </address> <month> September </month> <year> 1992. </year> <journal> IEEE Computer Society. </journal> <note> Also available as technical report UUCS-92-033. </note>
Reference-contexts: For example, object files produced by a compiler are composed by linking operations. Indeed, we have reused the same framework abstractions as a basis for a programmable linker/loader <ref> [OM92] </ref>. Private or shared system libraries constitute yet another example [See90]. Hence, we have found it advantageous to address this problem in its most general terms, by abstracting it to a language neutral plane. <p> A framework is meant to implement reusable abstractions. Although the design of the Jigsaw framework was motivated by purely semantic concerns, it is currently finding applications in a variety of situations, some of which were unanticipated, e.g. the programmable linker OMOS <ref> [OM92] </ref>. Indeed, this framework's asserted flexibility benefits are currently being demonstrated in a second generation of OMOS, in which we are incorporating type-safe linkage of object modules.
Reference: [OMHL93] <author> Douglas B. Orr, Robert W. Mecklenburg, Peter J. Hoogenboom, and Jay Lepreau. </author> <title> Dynamic program monitoring and transformation using the OMOS object server. </title> <booktitle> In Proceedings of the 26th Hawaii International Conference on System Sciences, </booktitle> <pages> pages 232-241, </pages> <month> January </month> <year> 1993. </year> <note> Also available as technical report UUCS-92-034. </note>
Reference-contexts: The result is a greatly enlarged conception of object file (module) manipulation and management, cast as a pervasive system service, under which many value added features are deliverable, including portable shared libraries [OBLM93], function interposition [BCLO93], and dynamic program monitoring and reorga nization <ref> [OMHL93] </ref>. * Concurrent O-O programming. It is increasingly evident that the relationships between sequential and concurrent conceptions of O-O programming are inadequately understood.
Reference: [Pae88] <author> Andreas Paepcke. PCLOS: </author> <title> A flexible implementation of CLOS persistence. </title> <editor> In S. Gjessing and K. Nygaard, editors, </editor> <booktitle> Proceedings of the European Conference on Object-Oriented Programming, Lecture Notes in Computer Science, </booktitle> <address> Berlin, 1988. </address> <publisher> Springer-Verlag. </publisher>
Reference-contexts: However, the Jigsaw framework can be used for many purposes that the CLOS MOP has been put to use, notably persistent objects <ref> [Pae88, Lee92] </ref>. 6 Conclusions A framework-based approach to language processor design and implementation has been described. This approach, called Jigsaw, relies on an abstract conception of software modules, refineable in several dimensions to characterize a large space of specific module formulations.
Reference: [See90] <author> Donn Seeley. </author> <title> Shared libraries as objects. </title> <booktitle> In Proc. USENIX Summer Conference, </booktitle> <address> Anaheim, CA, </address> <month> June </month> <year> 1990. </year>
Reference-contexts: For example, object files produced by a compiler are composed by linking operations. Indeed, we have reused the same framework abstractions as a basis for a programmable linker/loader [OM92]. Private or shared system libraries constitute yet another example <ref> [See90] </ref>. Hence, we have found it advantageous to address this problem in its most general terms, by abstracting it to a language neutral plane. It has been recognized in the past that object-oriented languages and systems are themselves perfectly suitable domains for object-oriented design.
Reference: [VL89] <author> John M. Vlissides and Mark A. Linton. Unidraw: </author> <title> a framework for building domain-specific graphical editors. </title> <booktitle> In Proceedings of the ACM User Interface Software and Technologies '89 Conference, </booktitle> <pages> pages 81-94, </pages> <month> November </month> <year> 1989. </year>
Reference-contexts: Frameworks thus promote design and code reuse through O-O concepts such as inheritance and polymorphism. Several 2 Connecting objects constructed from predefined concrete classes [JR91]. 4 frameworks have been developed, first for user interfaces, and subsequently for many other domains as well <ref> [Deu89, VL89, WGM88, CIJ + 91] </ref>.
Reference: [WGM88] <author> A. Weinand, E. Gamma, and R. Marty. ET++: </author> <title> an object-oriented application framework in C++. </title> <booktitle> In Proceedings of OOPSLA '88, </booktitle> <pages> pages 46-57. </pages> <publisher> ACM, </publisher> <month> November </month> <year> 1988. </year> <note> Last revised October 21, 1993 18 </note>
Reference-contexts: Frameworks thus promote design and code reuse through O-O concepts such as inheritance and polymorphism. Several 2 Connecting objects constructed from predefined concrete classes [JR91]. 4 frameworks have been developed, first for user interfaces, and subsequently for many other domains as well <ref> [Deu89, VL89, WGM88, CIJ + 91] </ref>.
References-found: 41

