URL: http://www.cs.man.ac.uk/~tessaris/DL/docs/CADE96/degiacomo.ps.Z
Refering-URL: http://www.cs.man.ac.uk/~tessaris/DL/papers.html
Root-URL: http://www.cs.man.ac.uk
Email: fdegiacomo,massaccig@dis.uniroma1.it  Fabio.Massacci@cl.cam.ac.uk  
Phone: 2  
Title: Tableaux and Algorithms for Propositional Dynamic Logic with Converse  
Author: Giuseppe De Giacomo and Fabio Massacci ; 
Address: Via Salaria 113, 00198 Roma, Italy,  Pembroke Street,Cambridge CB2 3QG, UK,  
Affiliation: 1 Dip. di Informatica e Sistemistica, Universita di Roma "La Sapienza"  Computer Laboratory, University of Cambridge,  
Abstract: This paper presents a prefixed tableaux calculus for Propositional Dynamic Logic with Converse based on a combination of different techniques such as prefixed tableaux for modal logics and model checkers for mu-calculus. We prove the correctness and completeness of the calculus and illustrate its features. We also discuss the transformation of the tableaux method (naively NEXPTIME) into an EXPTIME algorithm. 
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> P. Blackburn and E. Spaan. </author> <title> A modal perspective on computational complexity of attribute value grammar. </title> <journal> J. of Logic, Language and Information, </journal> <volume> 2 </volume> <pages> 129-169, </pages> <year> 1993. </year>
Reference-contexts: Over the years, propositional dynamic logics have been proved to be a valuable theoretical tool in Computer Science, Logic, Computational Linguistics, and Artificial Intelligence (e.g. <ref> [1, 6, 9, 10, 16, 18, 15] </ref>). Many inference procedures, decidability and complexity results, rely on research done within PDLs.
Reference: 2. <author> G. De Giacomo. </author> <title> Decidability of class-based knowledge representation formalisms. </title> <type> PhD thesis, </type> <institution> Universita di Roma "La Sapienza", </institution> <year> 1995. </year>
Reference-contexts: Thus, inference procedures for CP DL can be exploited as the reasoning core of very expressive description logics (and PDLs) by using polynomial reductions from the inference problem of such logics to the inference problem of CP DL <ref> [2, 3] </ref>. This was one of the main motivation that has led us to look into inference procedures for CP DL. CP DL shares many characteristics with the basic P DL, and many results for P DL extend to CP DL without difficulties. <p> Note that, since X i was new on the branch, the only way to introduce it for oe j+1 is to reduce completely oe j : haeiX i . By induction on the construction of ae (by using a techniques from <ref> [2] </ref>) it is possible to verify that hoe j ; oe j+1 i is in ae I and therefore the claim follows by definition of j=.
Reference: 3. <author> G. De Giacomo and M. Lenzerini. </author> <title> Boosting the correspondence between description logics and propositional dynamic logics. </title> <booktitle> In Proc. of AAAI-94, </booktitle> <pages> pages 205-212, </pages> <year> 1994. </year>
Reference-contexts: Thus, inference procedures for CP DL can be exploited as the reasoning core of very expressive description logics (and PDLs) by using polynomial reductions from the inference problem of such logics to the inference problem of CP DL <ref> [2, 3] </ref>. This was one of the main motivation that has led us to look into inference procedures for CP DL. CP DL shares many characteristics with the basic P DL, and many results for P DL extend to CP DL without difficulties.
Reference: 4. <author> N. J. Fisher and R. E. Ladner. </author> <title> Propositional dynamic logic of regular programs. </title> <journal> J. of Computer and System Sciences, </journal> <volume> 18 </volume> <pages> 194-211, </pages> <year> 1979. </year>
Reference-contexts: 1 Introduction Propositional Dynamic Logics (PDL) were used in <ref> [4] </ref> to describe the properties of states reached by programs during their execution, and to model the evolution of the computation process [10, 16]. <p> Many inference procedures, decidability and complexity results, rely on research done within PDLs. In this paper we present a tableaux calculus for the propositional dynamic logic Converse-P DL (CP DL) <ref> [4] </ref>, obtained from the basic logic P DL by adding the converse of a program whose running is obtained by "running the original program backwards". Typically, the converse is used for preconditions e.g. [ ]' can be interpreted as "before running program , property ' must hold". <p> CP DL shares many characteristics with the basic P DL, and many results for P DL extend to CP DL without difficulties. For instance the proofs of finite model property for P DL in <ref> [4] </ref> are easily extended to CP DL, as well as the proof of EXPTIME-completeness in [13]. <p> However, efficient in practical cases inference procedures have been successfully developed for P DL, but their extension to CP DL has proved to be a difficult task and unsuccessful till now (to the best of our knowledge). To be more precise, inference procedures based on models enumeration <ref> [4, 13] </ref> or on automata on infinite trees [19] have been extended to accommodate converse of programs. Yet, these procedures are better suited for proving theoretical results than for being used in applications. <p> Definition 1. A CP DL formula is satisfiable iff there is a model hS; Ii where () I is not empty. A formula is valid if for every model hS; Ii it is () I = S. The Fisher-Ladner closure of a formula <ref> [4, 10] </ref> is defined inductively as: - 2 CL (); if' 2 CL () then :' 2 CL (), provided ' does not start with :; if:','^ or haei' are in CL () then '; 2 CL (); if hae; Oi' 2 CL () then haeihOi' 2 CL (); if hae <p> The notion of Fisher-Ladner closure is closely related to the notion of set of subformulae in modal logics: to establish the truth value of a formula in a model it is sufficient to check the value of the formulae in CL () for every state of the model <ref> [4, 10] </ref>. <p> Such a definition implies that ae-steps are performed while :' is true, stopping as soon as ' becomes true. Indeed hae fl i' j h (:'?; ae) fl i' j hwhile :' do aei&gt; is valid in CP DL <ref> [4] </ref>. These constants are introduced to detect the presence of ae loops which never fulfill hae fl i', i.e. where ' never holds. In this way we can eliminate the ) (and its transitive closure) introduced by Pratt's tableaux [12], to relate pseudo models to actual models. Remark. <p> Consider now the state -(oe ! ) c the only difference with the original state -(oe ! ) is the incoming A-arc. But, as we have seen above, the two states see exactly the same formulae of CL () going back through A. By the filtration Lemma <ref> [4, 10] </ref>, these are the only formulae necessary for establishing the truth value of . Hence, by induction, we have that -(oe ! ) c satisfies hae fl i' in N R ae-steps in the new model (and indeed also in the old one). <p> This algorithm compute each time from scratch without keeping track of discarded branches, i.e. the naive implementation does not learn from failures. This makes sense for logics in PSPACE [9] but not for (C)P DL. In fact the algorithm works in NEXPTIME, while (C)P DL is EXPTIME complete <ref> [4, 13] </ref>. A smart algorithm can be developed with the techniques of [14]: use a suitable data structure where all possible subsets of the formulae that may appear in the tableau are listed. <p> Similarly if for oehAin : OE is present then oe : hAiOE is not reduced. 7 Discussion and Conclusion Known decision procedures for CP DL are based either on the enumeration of models <ref> [4, 13] </ref> or on automata on infinite trees [19]. However, these are often inherently exponential. So that the best procedures for P DL are the tableaux methods in [12, 14]. Yet they have not been extended till now.
Reference: 5. <author> M. </author> <title> Fitting. Proof Methods for Modal and Intuitionistic Logics. </title> <publisher> Reidel, </publisher> <year> 1983. </year>
Reference-contexts: In [12] Pratt says "We do not have a practical approach to this difficulty with converse, and our "practical" procedure therefore does not deal with converse". Our solution is to use labelled deduction [7] to develop modal prefixed tableaux <ref> [5, 8, 11] </ref> for CP DL. In particular we use Single Step Tableaux [11, 8] since they make it possible to reason locally both in "forward" and "backward" directions to accommodate the converse. <p> The definition of branch and tableau are similar (but the rules) to prefixed tableaux for modal logics <ref> [5, 8, 11] </ref>. A tableau is a rooted (binary) tree where nodes are labelled with formulae, and a branch is path from the root to a leaf. <p> Remark. It is easy to prove that cut can be eliminated if the initial formula contains either only the converse operator or only the iteration operator. 5 Soundness and Completeness The correctness proof of prefixed tableaux <ref> [5, 11] </ref> follows an established path: 1. devise an mapping between "names" (prefixes) and "things" (states) so that relations between states are preserved; 2. prove a safe extension lemma, i.e. that any tableau rule applied to a satis fiable formula preserve satisfiability with the above mentioned mapping; 3. prove a safe <p> A tableau is SAT if one branch is such for some model hS; Ii. Theorem 16. If T is a SAT tableau, then the tableau T 0 obtained by an application of a tableau rule is also SAT. Proof. By induction on the rules applied as in <ref> [5, Chapter 8] </ref> or [8, 11]. Now we prove that that ignorable branches can be safely discarded (the key point of the proof). The following preliminary result is useful: Lemma 17. <p> So that the best procedures for P DL are the tableaux methods in [12, 14]. Yet they have not been extended till now. One characterising feature of (C)P DL is the presence of fixpoint operators (the fl). In comparison with tableaux for modal logics <ref> [5, 8, 9, 11] </ref>, the tableaux for modal fixpoint logics are conceptually divided in two: (1) build a (pseudo) model expanding the modal part; (2) check this model for the satisfiability of fixpoint formulae.
Reference: 6. <author> N. Friedman and J. Halpern. </author> <title> On the complexity of conditional logics. </title> <booktitle> In Proc. of KR-94, </booktitle> <year> 1994. </year>
Reference-contexts: Over the years, propositional dynamic logics have been proved to be a valuable theoretical tool in Computer Science, Logic, Computational Linguistics, and Artificial Intelligence (e.g. <ref> [1, 6, 9, 10, 16, 18, 15] </ref>). Many inference procedures, decidability and complexity results, rely on research done within PDLs.
Reference: 7. <author> D. M. Gabbay. </author> <title> Labelled deductive systems. </title> <type> Tech. Rep. </type> <institution> MPI-I-94-223, Max Plank Inst. fur Informatik, Saarbruken, Germany, </institution> <year> 1994. </year>
Reference-contexts: In [12] Pratt says "We do not have a practical approach to this difficulty with converse, and our "practical" procedure therefore does not deal with converse". Our solution is to use labelled deduction <ref> [7] </ref> to develop modal prefixed tableaux [5, 8, 11] for CP DL. In particular we use Single Step Tableaux [11, 8] since they make it possible to reason locally both in "forward" and "backward" directions to accommodate the converse.
Reference: 8. <author> R. Gore. </author> <title> Tableaux method for modal and temporal logics. </title> <type> Tech. Rep. </type> <institution> TR-ARP-15-5, Australian National University, </institution> <year> 1995. </year>
Reference-contexts: In [12] Pratt says "We do not have a practical approach to this difficulty with converse, and our "practical" procedure therefore does not deal with converse". Our solution is to use labelled deduction [7] to develop modal prefixed tableaux <ref> [5, 8, 11] </ref> for CP DL. In particular we use Single Step Tableaux [11, 8] since they make it possible to reason locally both in "forward" and "backward" directions to accommodate the converse. <p> Our solution is to use labelled deduction [7] to develop modal prefixed tableaux [5, 8, 11] for CP DL. In particular we use Single Step Tableaux <ref> [11, 8] </ref> since they make it possible to reason locally both in "forward" and "backward" directions to accommodate the converse. The presence of the iteration operator imposes further constraints which lead to the notion of ignorable branches: branches which are modally consistent but where some iterated eventualities are never fulfilled. <p> The definition of branch and tableau are similar (but the rules) to prefixed tableaux for modal logics <ref> [5, 8, 11] </ref>. A tableau is a rooted (binary) tree where nodes are labelled with formulae, and a branch is path from the root to a leaf. <p> Theorem 16. If T is a SAT tableau, then the tableau T 0 obtained by an application of a tableau rule is also SAT. Proof. By induction on the rules applied as in [5, Chapter 8] or <ref> [8, 11] </ref>. Now we prove that that ignorable branches can be safely discarded (the key point of the proof). The following preliminary result is useful: Lemma 17. <p> So that the best procedures for P DL are the tableaux methods in [12, 14]. Yet they have not been extended till now. One characterising feature of (C)P DL is the presence of fixpoint operators (the fl). In comparison with tableaux for modal logics <ref> [5, 8, 9, 11] </ref>, the tableaux for modal fixpoint logics are conceptually divided in two: (1) build a (pseudo) model expanding the modal part; (2) check this model for the satisfiability of fixpoint formulae.
Reference: 9. <author> J. Halpern and Y. Moses. </author> <title> A guide to completeness and complexity for modal logics of knowledge and belief. </title> <journal> Artificial Intelligence, </journal> <volume> 54 </volume> <pages> 319-379, </pages> <year> 1992. </year>
Reference-contexts: Over the years, propositional dynamic logics have been proved to be a valuable theoretical tool in Computer Science, Logic, Computational Linguistics, and Artificial Intelligence (e.g. <ref> [1, 6, 9, 10, 16, 18, 15] </ref>). Many inference procedures, decidability and complexity results, rely on research done within PDLs. <p> This algorithm compute each time from scratch without keeping track of discarded branches, i.e. the naive implementation does not learn from failures. This makes sense for logics in PSPACE <ref> [9] </ref> but not for (C)P DL. In fact the algorithm works in NEXPTIME, while (C)P DL is EXPTIME complete [4, 13]. <p> So that the best procedures for P DL are the tableaux methods in [12, 14]. Yet they have not been extended till now. One characterising feature of (C)P DL is the presence of fixpoint operators (the fl). In comparison with tableaux for modal logics <ref> [5, 8, 9, 11] </ref>, the tableaux for modal fixpoint logics are conceptually divided in two: (1) build a (pseudo) model expanding the modal part; (2) check this model for the satisfiability of fixpoint formulae.
Reference: 10. <author> D. Kozen and J. Tiuryn. </author> <title> Logics of programs. </title> <booktitle> In Handbook of Theoretical Computer Science, </booktitle> <pages> pages 790-840. </pages> <publisher> Elsevier, </publisher> <year> 1990. </year>
Reference-contexts: 1 Introduction Propositional Dynamic Logics (PDL) were used in [4] to describe the properties of states reached by programs during their execution, and to model the evolution of the computation process <ref> [10, 16] </ref>. Over the years, propositional dynamic logics have been proved to be a valuable theoretical tool in Computer Science, Logic, Computational Linguistics, and Artificial Intelligence (e.g. [1, 6, 9, 10, 16, 18, 15]). Many inference procedures, decidability and complexity results, rely on research done within PDLs. <p> Over the years, propositional dynamic logics have been proved to be a valuable theoretical tool in Computer Science, Logic, Computational Linguistics, and Artificial Intelligence (e.g. <ref> [1, 6, 9, 10, 16, 18, 15] </ref>). Many inference procedures, decidability and complexity results, rely on research done within PDLs. <p> Examples are shown in Sect. 4, soundness and completeness are given in Sect. 5 and the transformation of NEXPTIME tableaux into EXPTIME algorithm is sketched in Sect. 6. Finally Sect. 7 concludes the paper. 2 Preliminaries We briefly present the basic notions on CP DL (see <ref> [10, 16] </ref> for surveys). <p> In the sequel P; Q are propositional variables and '; formulae whereas a; b; c atomic programs and ae; O programs. or are the formulae to be proved valid or satisfiable. CP DL semantics is based on transition systems (Kripke structures) <ref> [10] </ref>: a model is a pair hS; Ii where S is a non empty set of states and I an interpretation such that for every atomic program a 2 A it is a I S fi S and for every propositional letter P 2 P it is P I S. <p> Definition 1. A CP DL formula is satisfiable iff there is a model hS; Ii where () I is not empty. A formula is valid if for every model hS; Ii it is () I = S. The Fisher-Ladner closure of a formula <ref> [4, 10] </ref> is defined inductively as: - 2 CL (); if' 2 CL () then :' 2 CL (), provided ' does not start with :; if:','^ or haei' are in CL () then '; 2 CL (); if hae; Oi' 2 CL () then haeihOi' 2 CL (); if hae <p> The notion of Fisher-Ladner closure is closely related to the notion of set of subformulae in modal logics: to establish the truth value of a formula in a model it is sufficient to check the value of the formulae in CL () for every state of the model <ref> [4, 10] </ref>. <p> Consider now the state -(oe ! ) c the only difference with the original state -(oe ! ) is the incoming A-arc. But, as we have seen above, the two states see exactly the same formulae of CL () going back through A. By the filtration Lemma <ref> [4, 10] </ref>, these are the only formulae necessary for establishing the truth value of . Hence, by induction, we have that -(oe ! ) c satisfies hae fl i' in N R ae-steps in the new model (and indeed also in the old one).
Reference: 11. <author> F. Massacci. </author> <title> Strongly analytic tableaux for normal modal logics. </title> <booktitle> In Proc. of CADE-94, LNAI 814, </booktitle> <pages> pages 723-737. </pages> <publisher> Springer-Verlag, </publisher> <year> 1994. </year>
Reference-contexts: In [12] Pratt says "We do not have a practical approach to this difficulty with converse, and our "practical" procedure therefore does not deal with converse". Our solution is to use labelled deduction [7] to develop modal prefixed tableaux <ref> [5, 8, 11] </ref> for CP DL. In particular we use Single Step Tableaux [11, 8] since they make it possible to reason locally both in "forward" and "backward" directions to accommodate the converse. <p> Our solution is to use labelled deduction [7] to develop modal prefixed tableaux [5, 8, 11] for CP DL. In particular we use Single Step Tableaux <ref> [11, 8] </ref> since they make it possible to reason locally both in "forward" and "backward" directions to accommodate the converse. The presence of the iteration operator imposes further constraints which lead to the notion of ignorable branches: branches which are modally consistent but where some iterated eventualities are never fulfilled. <p> The definition of branch and tableau are similar (but the rules) to prefixed tableaux for modal logics <ref> [5, 8, 11] </ref>. A tableau is a rooted (binary) tree where nodes are labelled with formulae, and a branch is path from the root to a leaf. <p> Remark. It is easy to prove that cut can be eliminated if the initial formula contains either only the converse operator or only the iteration operator. 5 Soundness and Completeness The correctness proof of prefixed tableaux <ref> [5, 11] </ref> follows an established path: 1. devise an mapping between "names" (prefixes) and "things" (states) so that relations between states are preserved; 2. prove a safe extension lemma, i.e. that any tableau rule applied to a satis fiable formula preserve satisfiability with the above mentioned mapping; 3. prove a safe <p> Theorem 16. If T is a SAT tableau, then the tableau T 0 obtained by an application of a tableau rule is also SAT. Proof. By induction on the rules applied as in [5, Chapter 8] or <ref> [8, 11] </ref>. Now we prove that that ignorable branches can be safely discarded (the key point of the proof). The following preliminary result is useful: Lemma 17. <p> So that the best procedures for P DL are the tableaux methods in [12, 14]. Yet they have not been extended till now. One characterising feature of (C)P DL is the presence of fixpoint operators (the fl). In comparison with tableaux for modal logics <ref> [5, 8, 9, 11] </ref>, the tableaux for modal fixpoint logics are conceptually divided in two: (1) build a (pseudo) model expanding the modal part; (2) check this model for the satisfiability of fixpoint formulae.
Reference: 12. <author> V. R. Pratt. </author> <title> A practical decision method for propositional dynamic logic. </title> <booktitle> In Proc. of STOC-78, </booktitle> <pages> pages 326-337, </pages> <year> 1978. </year>
Reference-contexts: To be more precise, inference procedures based on models enumeration [4, 13] or on automata on infinite trees [19] have been extended to accommodate converse of programs. Yet, these procedures are better suited for proving theoretical results than for being used in applications. Tableau procedures for P DL <ref> [12, 14] </ref>, which are much more efficient in practice, have never been extended. The key point is that a tableau procedure for P DL can be organised so that, once the successors a state have been generated, no more reasoning involving this state is necessary. <p> In the case of a CP DL direct extensions of PDL procedures may require reasoning with the whole piece of model built so far. In <ref> [12] </ref> Pratt says "We do not have a practical approach to this difficulty with converse, and our "practical" procedure therefore does not deal with converse". Our solution is to use labelled deduction [7] to develop modal prefixed tableaux [5, 8, 11] for CP DL. <p> These constants are introduced to detect the presence of ae loops which never fulfill hae fl i', i.e. where ' never holds. In this way we can eliminate the ) (and its transitive closure) introduced by Pratt's tableaux <ref> [12] </ref>, to relate pseudo models to actual models. Remark. <p> These are the ideas behind the correctness theorem (model M bad ) and the completeness theorem (model M good ). In the tableaux for P DL by Pratt <ref> [12, 14] </ref> these two cases where called successful and unsuccessful loop. Question 12. <p> However, these are often inherently exponential. So that the best procedures for P DL are the tableaux methods in <ref> [12, 14] </ref>. Yet they have not been extended till now. One characterising feature of (C)P DL is the presence of fixpoint operators (the fl). <p> Such a merging requires to keeps track, during the expansions phase, of iterated eventualities and of their fulfillment. The necessity of (successful and unsuccessful) loop checking for eventualities has been pointed out in <ref> [12, 14] </ref> for P DL, and is even stronger for the modal mu-calculus [17]. For instance in [12] a model checker is run on the final pseudo-model whereas in [14] a new relation symbol ) is introduced and some properties of its transitive closure verified. <p> The necessity of (successful and unsuccessful) loop checking for eventualities has been pointed out in [12, 14] for P DL, and is even stronger for the modal mu-calculus [17]. For instance in <ref> [12] </ref> a model checker is run on the final pseudo-model whereas in [14] a new relation symbol ) is introduced and some properties of its transitive closure verified.
Reference: 13. <author> V. R. Pratt. </author> <title> Models of program logics. </title> <booktitle> In Proc. of FOCS-79, </booktitle> <pages> pages 115-122, </pages> <year> 1979. </year>
Reference-contexts: CP DL shares many characteristics with the basic P DL, and many results for P DL extend to CP DL without difficulties. For instance the proofs of finite model property for P DL in [4] are easily extended to CP DL, as well as the proof of EXPTIME-completeness in <ref> [13] </ref>. However, efficient in practical cases inference procedures have been successfully developed for P DL, but their extension to CP DL has proved to be a difficult task and unsuccessful till now (to the best of our knowledge). <p> However, efficient in practical cases inference procedures have been successfully developed for P DL, but their extension to CP DL has proved to be a difficult task and unsuccessful till now (to the best of our knowledge). To be more precise, inference procedures based on models enumeration <ref> [4, 13] </ref> or on automata on infinite trees [19] have been extended to accommodate converse of programs. Yet, these procedures are better suited for proving theoretical results than for being used in applications. <p> This algorithm compute each time from scratch without keeping track of discarded branches, i.e. the naive implementation does not learn from failures. This makes sense for logics in PSPACE [9] but not for (C)P DL. In fact the algorithm works in NEXPTIME, while (C)P DL is EXPTIME complete <ref> [4, 13] </ref>. A smart algorithm can be developed with the techniques of [14]: use a suitable data structure where all possible subsets of the formulae that may appear in the tableau are listed. <p> Similarly if for oehAin : OE is present then oe : hAiOE is not reduced. 7 Discussion and Conclusion Known decision procedures for CP DL are based either on the enumeration of models <ref> [4, 13] </ref> or on automata on infinite trees [19]. However, these are often inherently exponential. So that the best procedures for P DL are the tableaux methods in [12, 14]. Yet they have not been extended till now.
Reference: 14. <author> V. R. Pratt. </author> <title> A near-optimal method for reasoning about action. </title> <journal> J. of Computer and System Sciences, </journal> <volume> 20 </volume> <pages> 231-255, </pages> <year> 1980. </year>
Reference-contexts: To be more precise, inference procedures based on models enumeration [4, 13] or on automata on infinite trees [19] have been extended to accommodate converse of programs. Yet, these procedures are better suited for proving theoretical results than for being used in applications. Tableau procedures for P DL <ref> [12, 14] </ref>, which are much more efficient in practice, have never been extended. The key point is that a tableau procedure for P DL can be organised so that, once the successors a state have been generated, no more reasoning involving this state is necessary. <p> In case two X i ; X j are present in both prefix we assume them equal if they stand for the same iterated eventuality i.e. X i : : This definition of a copy is more restrictive than the corresponding definition one needs for simple P DL <ref> [14] </ref>. Intuitively a copy is "a different name for the same state" since they (i) have the same properties (dynamic formulae) and (ii) can be reached by the same program. This requirement is not necessary for P DL (one only looks forward) whereas in CP DL the past does matter. <p> These are the ideas behind the correctness theorem (model M bad ) and the completeness theorem (model M good ). In the tableaux for P DL by Pratt <ref> [12, 14] </ref> these two cases where called successful and unsuccessful loop. Question 12. <p> This makes sense for logics in PSPACE [9] but not for (C)P DL. In fact the algorithm works in NEXPTIME, while (C)P DL is EXPTIME complete [4, 13]. A smart algorithm can be developed with the techniques of <ref> [14] </ref>: use a suitable data structure where all possible subsets of the formulae that may appear in the tableau are listed. <p> This is the difference with <ref> [14] </ref>: for CP DL two sets must also be equal wrt the "arriving program" (Defn. 5 and Thm. 18). Last we start a marking algorithm which marks bad prefixes as in [14]. <p> This is the difference with <ref> [14] </ref>: for CP DL two sets must also be equal wrt the "arriving program" (Defn. 5 and Thm. 18). Last we start a marking algorithm which marks bad prefixes as in [14]. A key difference is that we discard at once all prefixes which contains a X i which makes the branch ignorable. This is more effective than [14] also for P DL since we do not compute the transitive closure of ) but just look for X i locally. <p> Last we start a marking algorithm which marks bad prefixes as in <ref> [14] </ref>. A key difference is that we discard at once all prefixes which contains a X i which makes the branch ignorable. This is more effective than [14] also for P DL since we do not compute the transitive closure of ) but just look for X i locally. <p> However, these are often inherently exponential. So that the best procedures for P DL are the tableaux methods in <ref> [12, 14] </ref>. Yet they have not been extended till now. One characterising feature of (C)P DL is the presence of fixpoint operators (the fl). <p> Such a merging requires to keeps track, during the expansions phase, of iterated eventualities and of their fulfillment. The necessity of (successful and unsuccessful) loop checking for eventualities has been pointed out in <ref> [12, 14] </ref> for P DL, and is even stronger for the modal mu-calculus [17]. For instance in [12] a model checker is run on the final pseudo-model whereas in [14] a new relation symbol ) is introduced and some properties of its transitive closure verified. <p> The necessity of (successful and unsuccessful) loop checking for eventualities has been pointed out in [12, 14] for P DL, and is even stronger for the modal mu-calculus [17]. For instance in [12] a model checker is run on the final pseudo-model whereas in <ref> [14] </ref> a new relation symbol ) is introduced and some properties of its transitive closure verified. We think that the use of constants for iterated eventualities, taken from model checking techniques in [17], improves efficiency and readability of the calculus.
Reference: 15. <author> K. Schild. </author> <title> A correspondence theory for terminological logics: Preliminary report. </title> <booktitle> In Proc. of IJCAI-91, </booktitle> <pages> pages 466-471, </pages> <year> 1991. </year>
Reference-contexts: Over the years, propositional dynamic logics have been proved to be a valuable theoretical tool in Computer Science, Logic, Computational Linguistics, and Artificial Intelligence (e.g. <ref> [1, 6, 9, 10, 16, 18, 15] </ref>). Many inference procedures, decidability and complexity results, rely on research done within PDLs. <p> There are several applications of PDLs where the ability of denoting converse programs is essential. For instance using PDLs as a core reasoning paradigm of Knowledge Representation Systems. Several recent papers (starting from <ref> [15] </ref>) point out a strong correspondence between PDLs and a family of class-based knowledge representation formalisms, Description Logics [20]. These logics represent the world in terms of objects grouped into classes, relations between classes and a number of constructs for properties of classes and relations.
Reference: 16. <author> C. Stirling. </author> <title> Modal and temporal logic. </title> <booktitle> In Handbook of Logic in Computer Science, </booktitle> <pages> pages 477-563. </pages> <publisher> Clarendon Press, </publisher> <year> 1992. </year>
Reference-contexts: 1 Introduction Propositional Dynamic Logics (PDL) were used in [4] to describe the properties of states reached by programs during their execution, and to model the evolution of the computation process <ref> [10, 16] </ref>. Over the years, propositional dynamic logics have been proved to be a valuable theoretical tool in Computer Science, Logic, Computational Linguistics, and Artificial Intelligence (e.g. [1, 6, 9, 10, 16, 18, 15]). Many inference procedures, decidability and complexity results, rely on research done within PDLs. <p> Over the years, propositional dynamic logics have been proved to be a valuable theoretical tool in Computer Science, Logic, Computational Linguistics, and Artificial Intelligence (e.g. <ref> [1, 6, 9, 10, 16, 18, 15] </ref>). Many inference procedures, decidability and complexity results, rely on research done within PDLs. <p> Examples are shown in Sect. 4, soundness and completeness are given in Sect. 5 and the transformation of NEXPTIME tableaux into EXPTIME algorithm is sketched in Sect. 6. Finally Sect. 7 concludes the paper. 2 Preliminaries We briefly present the basic notions on CP DL (see <ref> [10, 16] </ref> for surveys).
Reference: 17. <author> C. Stirling and D. Walker. </author> <title> Local model checking in modal mu-calculus. </title> <journal> Theoretical Computer Science, </journal> <volume> 89 </volume> <pages> 161-177, </pages> <year> 1991. </year>
Reference-contexts: Thus we use both forward and backward rules for necessity like subformula, as shown in Fig. 3 (where the subscript F stands for forward and B for backward). The rules for iteration combine prefixed tableaux with the techniques developed by <ref> [17] </ref> for model checking in modal mu-calculus, based on the intro (A) : oehAin : ' with oehAin new in the branch F (A) : oehAin : :' with oehAin already present in the branch B (A) : oehAin : :hA i' oe : :' with oe already present in the <p> Such a merging requires to keeps track, during the expansions phase, of iterated eventualities and of their fulfillment. The necessity of (successful and unsuccessful) loop checking for eventualities has been pointed out in [12, 14] for P DL, and is even stronger for the modal mu-calculus <ref> [17] </ref>. For instance in [12] a model checker is run on the final pseudo-model whereas in [14] a new relation symbol ) is introduced and some properties of its transitive closure verified. We think that the use of constants for iterated eventualities, taken from model checking techniques in [17], improves efficiency <p> modal mu-calculus <ref> [17] </ref>. For instance in [12] a model checker is run on the final pseudo-model whereas in [14] a new relation symbol ) is introduced and some properties of its transitive closure verified. We think that the use of constants for iterated eventualities, taken from model checking techniques in [17], improves efficiency and readability of the calculus. In this setting our tableaux calculus is a first step towards effective decision procedures for CP DL and the corresponding description logics.
Reference: 18. <editor> J. Van Benthem, J. Van Eijck, and V. Stebletsova. </editor> <title> Modal logic, transition systems and processes. </title> <journal> J. of Logic and Computation, </journal> <volume> 4(5) </volume> <pages> 811-855, </pages> <year> 1994. </year>
Reference-contexts: Over the years, propositional dynamic logics have been proved to be a valuable theoretical tool in Computer Science, Logic, Computational Linguistics, and Artificial Intelligence (e.g. <ref> [1, 6, 9, 10, 16, 18, 15] </ref>). Many inference procedures, decidability and complexity results, rely on research done within PDLs.
Reference: 19. <author> M. Y. Vardi and P. Wolper. </author> <title> Automata-theoretic techniques for modal logics of programs. </title> <journal> J. of Computer and System Sciences, </journal> <volume> 32 </volume> <pages> 183-221, </pages> <year> 1986. </year>
Reference-contexts: To be more precise, inference procedures based on models enumeration [4, 13] or on automata on infinite trees <ref> [19] </ref> have been extended to accommodate converse of programs. Yet, these procedures are better suited for proving theoretical results than for being used in applications. Tableau procedures for P DL [12, 14], which are much more efficient in practice, have never been extended. <p> Similarly if for oehAin : OE is present then oe : hAiOE is not reduced. 7 Discussion and Conclusion Known decision procedures for CP DL are based either on the enumeration of models [4, 13] or on automata on infinite trees <ref> [19] </ref>. However, these are often inherently exponential. So that the best procedures for P DL are the tableaux methods in [12, 14]. Yet they have not been extended till now. One characterising feature of (C)P DL is the presence of fixpoint operators (the fl).
Reference: 20. <author> W. A. Woods and J. G. Schmolze. </author> <title> The KL-ONE family. </title> <booktitle> In Semantic Networks in Artificial Intelligence, </booktitle> <pages> pages 133-178. </pages> <publisher> Pergamon Press, </publisher> <year> 1992. </year> <title> This article was processed using the L a T E X macro package with LLNCS style </title>
Reference-contexts: For instance using PDLs as a core reasoning paradigm of Knowledge Representation Systems. Several recent papers (starting from [15]) point out a strong correspondence between PDLs and a family of class-based knowledge representation formalisms, Description Logics <ref> [20] </ref>. These logics represent the world in terms of objects grouped into classes, relations between classes and a number of constructs for properties of classes and relations.
References-found: 20

