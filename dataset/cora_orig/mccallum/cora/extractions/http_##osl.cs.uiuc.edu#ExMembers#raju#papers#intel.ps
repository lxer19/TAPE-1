URL: http://osl.cs.uiuc.edu/ExMembers/raju/papers/intel.ps
Refering-URL: http://osl.cs.uiuc.edu/ExMembers/raju/
Root-URL: http://www.cs.uiuc.edu
Email: Email: f agha j houck j panwarg@cs.uiuc.edu  
Title: Distributed Execution of Actor Programs  
Author: Gul Agha, Chris Houck and Rajendra Panwar 
Note: DRAFT  
Address: 1304 W. Springfield Avenue  Urbana, IL 61801, USA  
Affiliation: Department of Computer Science  University of Illinois at Urbana-Champaign  
Abstract: A number of programming language models, including actors, provide inherent concur-rency. We are developing high-level language constructs using actors and studying their implementation on multiprocessor architectures. This report describes our experience with programming in actors by means of a specific example of scientific computation. We also discuss work in progress on compilation technology for efficient program exe cution on multiprocessors.
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> G. Agha. </author> <title> Actors: A Model of Concurrent Computation in Distributed Systems. </title> <publisher> MIT Press, </publisher> <year> 1986. </year>
Reference-contexts: This allows concurrent execution of actions specified within the body of the actor. The concept of actors was originally proposed by Hewitt [9]. The actor model has been formally characterized by means of power domain semantics [6], by a transition system <ref> [1] </ref>, and by Colored Petri Nets [12]. Complexity measures for actor programs have been defined [5]. The model has been proposed as a basis for multiparadigm programming [2] and has been used as a programming model for multicomputers [4] and [7].
Reference: [2] <author> G. Agha. </author> <title> Supporting multiparadigm programming on actor architectures. </title> <booktitle> In Pro--ceedings of Parallel Architectures and Languages Europe, Vol. II: Parallel Languages (PARLE '89), </booktitle> <pages> pages 1-19. </pages> <address> Espirit, </address> <publisher> Springer-Verlag, </publisher> <year> 1989. </year> <note> LNCS 366. </note>
Reference-contexts: The actor model has been formally characterized by means of power domain semantics [6], by a transition system [1], and by Colored Petri Nets [12]. Complexity measures for actor programs have been defined [5]. The model has been proposed as a basis for multiparadigm programming <ref> [2] </ref> and has been used as a programming model for multicomputers [4] and [7]. Rosette Our work uses Rosette, an actor language developed at MCC in collaboration with one of the authors [13]. The following code-fragment gives a flavor of the Rosette language.
Reference: [3] <author> G. Agha. </author> <title> Concurrent object-oriented programming. </title> <journal> Communications of the ACM, </journal> <volume> 33(9) </volume> <pages> 125-141, </pages> <month> September </month> <year> 1990. </year>
Reference-contexts: Replacement is a serialization mechanism which supports a trivial pipelining of the replacement actions: the aggregation of changes allows an easy determination of when we have finished computing the state of an actor and are ready to take the next action <ref> [3] </ref>. For example, as soon as the bank account actor has computed the new balance in the account, it is free to process the next request even if other actions implied by the withdrawal request are still being carried out.
Reference: [4] <author> W. Athas and C. Seitz. </author> <title> Multicomputers: Message-Passing Concurrent Computers. </title> <booktitle> IEEE Computer, </booktitle> <pages> pages 9-23, </pages> <month> August </month> <year> 1988. </year>
Reference-contexts: Complexity measures for actor programs have been defined [5]. The model has been proposed as a basis for multiparadigm programming [2] and has been used as a programming model for multicomputers <ref> [4] </ref> and [7]. Rosette Our work uses Rosette, an actor language developed at MCC in collaboration with one of the authors [13]. The following code-fragment gives a flavor of the Rosette language.
Reference: [5] <author> F. Baude and G. </author> <title> Vidal-Naquet. Actors as a parallel programming model. </title> <booktitle> In Proceedings of 8th Symposium on Theoretical Aspects of Computer Science, </booktitle> <year> 1991. </year> <note> LNCS 480. </note>
Reference-contexts: The concept of actors was originally proposed by Hewitt [9]. The actor model has been formally characterized by means of power domain semantics [6], by a transition system [1], and by Colored Petri Nets [12]. Complexity measures for actor programs have been defined <ref> [5] </ref>. The model has been proposed as a basis for multiparadigm programming [2] and has been used as a programming model for multicomputers [4] and [7]. Rosette Our work uses Rosette, an actor language developed at MCC in collaboration with one of the authors [13].
Reference: [6] <author> W. Clinger. </author> <title> Foundations of Actor Semantics. </title> <type> AI-TR- 633, </type> <institution> MIT Artificial Intelligence Laboratory, </institution> <month> May </month> <year> 1981. </year>
Reference-contexts: This allows concurrent execution of actions specified within the body of the actor. The concept of actors was originally proposed by Hewitt [9]. The actor model has been formally characterized by means of power domain semantics <ref> [6] </ref>, by a transition system [1], and by Colored Petri Nets [12]. Complexity measures for actor programs have been defined [5]. The model has been proposed as a basis for multiparadigm programming [2] and has been used as a programming model for multicomputers [4] and [7].
Reference: [7] <author> W. Dally. </author> <title> A VLSI Architecture for Concurrent Data Structures. </title> <publisher> Kluwer Academic Press, </publisher> <year> 1986. </year>
Reference-contexts: Complexity measures for actor programs have been defined [5]. The model has been proposed as a basis for multiparadigm programming [2] and has been used as a programming model for multicomputers [4] and <ref> [7] </ref>. Rosette Our work uses Rosette, an actor language developed at MCC in collaboration with one of the authors [13]. The following code-fragment gives a flavor of the Rosette language.
Reference: [8] <author> G. Golub and C. Van Loan. </author> <title> Matrix Computations. </title> <publisher> The Johns Hopkins University Press, </publisher> <year> 1983. </year>
Reference-contexts: Assume A is a symmetric positive definite matrix of size n fi n. The following algorithm computes a lower triangular matrix G, of size n fi n such that A = GG T <ref> [8] </ref>. Since A is a symmetric matrix, it can be stored as a lower triangular matrix. <p> We discuss ways of computing the CD of dense matrices in parallel. at hand. With a two dimensional mesh of n 2 processors <ref> [8] </ref>, the algorithm takes O (n 2 ) time if all the steps of one iteration are completed before starting the next one. Pipelining the execution of different iterations gives an O (n) time parallel implementation.
Reference: [9] <author> C. Hewitt. </author> <title> Viewing Control Structures as Patterns of Passing Messages. </title> <journal> Journal of Artificial Intelligence, </journal> <volume> 8(3) </volume> <pages> 323-364, </pages> <year> 1977. </year>
Reference-contexts: This allows concurrent execution of actions specified within the body of the actor. The concept of actors was originally proposed by Hewitt <ref> [9] </ref>. The actor model has been formally characterized by means of power domain semantics [6], by a transition system [1], and by Colored Petri Nets [12]. Complexity measures for actor programs have been defined [5].
Reference: [10] <author> P. Hudak. </author> <title> Para-functional programming. </title> <booktitle> IEEE Computer, </booktitle> <pages> pages 60-70, </pages> <month> August </month> <year> 1986. </year>
Reference-contexts: Furthermore, in some cases, the structure of a problem is crystalline and well-understood by the programmer. In these cases, the use of annotations for specifying processor locations for expression evaluation to guide the runtime system has been suggested (e.g. <ref> [10] </ref>). However, in the context of actors, explicit message passing primitives imply that a separate syntax to specify such annotations is superfluous. The organization of this paper is as follows. In Section 2 we give a brief overview of the actor model. Section 3 outlines multi-send constructs to increase concurrency.
Reference: [11] <author> Intel Corporation, </author> <title> Beaverton, Oregon. iPSC/2 C Programmers reference manual, </title> <booktitle> 1988. Order Number: </booktitle> <pages> 311017-002. </pages>
Reference-contexts: The intel iPSC also provides the ability to choose specific (tagged) messages out of the mail box <ref> [11] </ref>, thus allowing a user to handle arrival order non-determinism efficiently. However, programmers have to specify explicit processor addresses with every message that is sent across nodes.
Reference: [12] <author> Y. Sami and G. </author> <title> Vidal-Naquet. Formalisation of the behaviour of actors by colored petri nets and some applications. </title> <booktitle> In Proceedings of Parallel Architectures and Languages Europe, (PARLE '91), </booktitle> <year> 1991. </year>
Reference-contexts: This allows concurrent execution of actions specified within the body of the actor. The concept of actors was originally proposed by Hewitt [9]. The actor model has been formally characterized by means of power domain semantics [6], by a transition system [1], and by Colored Petri Nets <ref> [12] </ref>. Complexity measures for actor programs have been defined [5]. The model has been proposed as a basis for multiparadigm programming [2] and has been used as a programming model for multicomputers [4] and [7].
Reference: [13] <author> C. Tomlinson, W. Kim, M. Schevel, V. Singh, B. Will, and G. Agha. Rosette: </author> <title> An object oriented concurrent system architecture. </title> <journal> Sigplan Notices, </journal> <volume> 24(4) </volume> <pages> 91-93, </pages> <year> 1989. </year>
Reference-contexts: The model has been proposed as a basis for multiparadigm programming [2] and has been used as a programming model for multicomputers [4] and [7]. Rosette Our work uses Rosette, an actor language developed at MCC in collaboration with one of the authors <ref> [13] </ref>. The following code-fragment gives a flavor of the Rosette language. It defines a behavior template for actors, Add-Counter , which accept two kinds of messages and has an acquaintance (cf. local variable) called count , initially set to zero.
Reference: [14] <author> C. Tomlinson and V. Singh. </author> <title> Inheritance and Synchronization with Enabled-Sets. </title> <booktitle> In OOPSLA Proceedings, </booktitle> <year> 1989. </year>
Reference-contexts: We use a mechanism called enabled sets in Rosette for imposing order on the processing of messages <ref> [14] </ref>. The following code uses the block construct which packages a set of expressions which are evaluated concurrently. <p> While there are typically few behavior redefinitions in practice, this method can entail a significant performance loss if the network gets filled with messages getting forwarded from previous behaviors to new ones. Furthermore, it is not clear how to implement enabled-sets <ref> [14] </ref> and inheritance under such a scheme. Actors as Processes. The representation that we are implementing models actors as light-weight processes and requires the presence of a kernel run-time system on each node. Each actor that gets created is represented as a unique process.
Reference: [15] <author> P. Vaidya. </author> <title> Solving linear equations with symmetric diagonally dominant matrices by constructing good preconditioners. </title> <type> Technical report, </type> <institution> University of Illinois Department of Computer Science, </institution> <month> In Preparation. </month> <title> elements are read from and dotted elements are not involved with the current iteration. as a function of hypercube and matrix sizes. represent the more concurrent implementation. lines are function invocations </title>
Reference-contexts: Most of the problems involving large systems of equations have very few non-zero elements in the matrices and require methods for solving sparse linear systems. But some of the methods used for solving sparse systems of equations (e.g. <ref> [15] </ref>) require solution of a dense block of equations as an intermediate step. Depending on the size and structure of the original systems of equations, this dense block may be huge and sequential solution of such a block may reduce the overall performance significantly.
References-found: 15

