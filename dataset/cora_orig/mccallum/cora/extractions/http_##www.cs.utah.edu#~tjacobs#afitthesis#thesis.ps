URL: http://www.cs.utah.edu/~tjacobs/afitthesis/thesis.ps
Refering-URL: http://www.cs.utah.edu/~tjacobs/
Root-URL: 
Title: AN OBJECT-ORIENTED DATABASE IMPLEMENTATION OF THE MAGIC VLSI LAYOUT DESIGN SYSTEM  
Author: by Timothy Martin Jacobs 
Degree: A thesis submitted to the faculty of  in partial fulfillment of the requirements for the degree of Master of Science Department of Electrical and Computer Engineering  
Date: December 1991  
Affiliation: Institute of Technology  
Note: The Air Force  The Air Force Institute of Technology  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> Berre, Arne J. and T. Lougenia Anderson. </author> <title> "The HyperModel Benchmark for Evaluating Object-Oriented Databases." In Object-Oriented Databases with Applications to CASE, Networks, and VLSI CAD, </title> <booktitle> chapter 5, </booktitle> <pages> pages 75-91, </pages> <address> Englewood Cliffs, NJ: </address> <publisher> Prentice-Hall, Inc., </publisher> <year> 1991. </year>
Reference-contexts: He noted that none of the OODBMS implementations in research or production environments met his criteria when his paper was written in 1987. Berre and Anderson's HyperModel benchmark <ref> [1] </ref> presents a similar approach to performance measurement. In addition to the operations proposed by Cattel, the HyperModel benchmark includes: Sequential Scan. Visit each object in the database sequentially. Closure Operations. Perform operations on all objects reachable by a certain relation ship from a specified object. Open-and-Close.
Reference: [2] <author> Cattel, R.G.G. </author> <title> "Object-Oriented DBMS Performance Measurement." </title> <booktitle> In Proceedings of the 2nd Workshop on OODBS , pages 364-367, </booktitle> <year> 1988. </year>
Reference-contexts: Much of the literature on database performance evaluation addresses the results of standard benchmarks as applied to various DBMSs. While most of these benchmarks reflect typical applications for relational DBMSs, R.G.G. Cattel has developed an approach for measuring the performance of object-oriented database systems <ref> [2] </ref>. <p> Before discussing his approach, however, Cattel points out that "The most accurate measure of performance for engineering applications would be to run an actual application, representing the data in the manner best suited to each potential DBMS <ref> [2, 364] </ref>." Cattel proposes a database of parts on a circuit board with connections between them. He summarizes the three most important measures of performance in an object-oriented DBMS as: Lookup and Retrieval. Look up and retrieve an object given its identifier. Traversal. <p> R.G.G. Cattel suggests, however, that benchmark performance tests may not be an accurate measure of performance; rather "The most accurate measure of performance for engineering applications would be to run an actual application . . . . <ref> [2, 364] </ref>" When actually using Magic, the difference in performance was not readily apparent. For look up and retrieval, the difference in response time, while representing an increase of nearly 200 percent, was still only measured in fractions of a second | barely perceptible to a human user.
Reference: [3] <author> Gupta, Rajiv and others. </author> <title> "An Object-Oriented VLSI CAD Framework," </title> <note> Computer , 22 :28-37 (May 1989). </note>
Reference-contexts: Different implementations of an operation or data structure can be defined without affecting the interface of the object to other objects. Rajiv Gupta et al <ref> [3] </ref> point out similar advantages of an OODBMS. The object-oriented paradigm mimics real-world objects, encourages gradual evolution of a design, and encourages code reusability.
Reference: [4] <author> Heiler, Sandra and others. </author> <title> "An Object-Oriented Approach to Data Management: Why Design Databases Need It." </title> <booktitle> In 24th Design Automation Conference Proceedings, </booktitle> <pages> pages 335-340, </pages> <year> 1987. </year>
Reference-contexts: Inefficiencies and failure result when these DBMSs are used to support engineering design applications. [17] 10 Instead of conventional DBMSs, many database experts have proposed Object-Oriented Database Management Systems as more appropriate for engineering design systems. According to Sandra Heiler et al <ref> [4] </ref>, an object-oriented approach to data management supports engineering design requirements by allowing users to define relationships among engineering objects and by providing facilities for defining complex objects and version configurations. <p> The object-oriented paradigm provides a better model for mapping to the mental model of the users. System maintenance is simplified since "changes to the implementation of one object or object type will not require changes to others <ref> [4, 339] </ref>." Using the inheritance characteristic of object-oriented DBMSs, new objects can be added or old objects modified as requirements are refined. Different implementations of an operation or data structure can be defined without affecting the interface of the object to other objects. <p> Increased understanding is attained through abstraction, a concept in which the programmer's model of an object more closely approximates the user's conceptual model of the object <ref> [4] </ref>. A database management system also supports data encapsulation and abstraction by providing mechanisms for defining storage structures and manipulating information [8]. ObjectStore supports both object-oriented computing and database management.
Reference: [5] <author> Jacobs, Captain Timothy M. </author> <title> OSmagic Programmers' Manual . Air Force Institute of Technology, </title> <month> December </month> <year> 1991. </year>
Reference-contexts: This first phase of implementing Magic with ObjectStore requires the following changes. (A complete summary of all modifications to the Magic software is contained in the OSmagic Programmers' Manual <ref> [5] </ref>). * Where a database element such as those in Figure 3 has been allocated with the procedure MALLOC, remove the MALLOC and replace it with the ObjectStore Data Definition and Manipulation Language (DML) persistent new command. /* replace MALLOC with ObjectStore DML new * * MALLOC (CellDef *, cellDef, sizeof
Reference: [6] <author> Jhingran, Anant and Michael Stonebraker. </author> <title> "Alternatives in Complex Object Representation: A Performance Perspective." </title> <booktitle> In Proceedings of the Sixth International Conference on Data Engineering, </booktitle> <pages> pages 94-102, </pages> <month> February </month> <year> 1990. </year>
Reference-contexts: Open-and-Close. Time to open and close the database. 12 2.3.2 Design Issues Impacting Performance. One of the key design issues affecting OODBMS performance is whether or not to cluster subobjects and their referencing objects in physical storage. Jhingran and Stone-braker <ref> [6] </ref> address this issue and the effect of caching. They run a series of experiments using a relational DBMS and a hierarchical data structure in which the number of shared superobjects and subobjects is varied.
Reference: [7] <author> Kim, Won and others. </author> <title> "Indexing Techniques for Object-Oriented Databases." In Object-Oriented Concepts, Databases, </title> <journal> and Applications, </journal> <volume> chapter 15, </volume> <pages> pages 371-394, </pages> <address> New York: </address> <publisher> ACM Press, </publisher> <year> 1989. </year>
Reference-contexts: Caching, on the other hand, is generally viable except when a large number of updates is made. Another design issue affecting performance is the use of indexing. Kim et al <ref> [7] </ref> evaluate two different indexing techniques. The first of these is an index maintained on an attribute of a single class. Kim et al identify this as a single-class index. A class-hierarchy index is maintained on an attribute of all classes in a class hierarchy rooted at a particular class.
Reference: [8] <author> Korth, H.F. and A. Silberschatz. </author> <title> Database System Concepts. </title> <address> New York: </address> <publisher> McGraw-Hill Book Company, </publisher> <year> 1986. </year>
Reference-contexts: Increased understanding is attained through abstraction, a concept in which the programmer's model of an object more closely approximates the user's conceptual model of the object [4]. A database management system also supports data encapsulation and abstraction by providing mechanisms for defining storage structures and manipulating information <ref> [8] </ref>. ObjectStore supports both object-oriented computing and database management. With its persistent data structures and procedures for managing data, all input and output procedures can be eliminated from the program. This eliminates the complexity involved with transforming data from its flat file representation to the appropriate data structure in memory.
Reference: [9] <author> Lamb, Charles and others. </author> <title> "The ObjectStore Database System," </title> <note> Communications of the ACM , 34 :50-63 (October 1991). </note>
Reference-contexts: That the ObjectStore version of Magic performs best for hierarchy traversal demonstrates what Object Design considers to be the primary benefit of ObjectStore's architecture <ref> [9, 61] </ref>. Overall, the performance results obtained from implementing Magic with ObjectStore are inconclusive. Benchmark tests indicate that ObjectStore performance falls within the ten percent increase criteria for only three of six areas.
Reference: [10] <author> Mayo, Robert N. and others. </author> <note> 1990 DECWRL/Livermore Magic Release, </note> <year> 1990. </year>
Reference-contexts: Circuits can be created completely from scratch or through hierarchical inclusion of any number of sub-components. File extraction tools have also been included as part of Magic for compatibility with circuit testing and manufacturing systems. <ref> [10] </ref> To improve performance and simplify the designer's view of a circuit, Magic implements some unique features. The geometrical contents of a circuit are represented using a technique called corner stitching.
Reference: [11] <institution> Object Design, Inc., Burlington, Massachusetts. ObjectStore Administration and Development Tools, </institution> <month> March </month> <year> 1991. </year>
Reference-contexts: This Makefile compiles each program in the subdirectory and links the object files into a composite object file for the entire subdirectory. Each subdirectory object file is then linked together for the Magic executable. The description of ObjectStore Makefiles assumes all object and source code is in one directory <ref> [11] </ref>. The solution was simple | to only use the ObjectStore linker for the executable and not for each individual subdirectory | but many hours of analysis, trial and error, and consultation with the ObjectStore programmers were required before the problem was resolved.
Reference: [12] <institution> Object Design, Inc., Burlington, Massachusetts. </institution> <note> ObjectStore Reference Manual , March 1991. </note>
Reference-contexts: This was resolved by declaring them at file level in any directory and including an extern declaration in a header file. * When using versioning, the effects of configuration::forget are unclear. This command should remove the specified version from the current workspace <ref> [12] </ref>; however, this does not happen when the versioned object has just been created and exists in no other workspace. The configuration::destroy version command was used instead. To be able to destroy a version, however, the configuration must have been previously frozen in some workspace. <p> To be able to destroy a version, however, the configuration must have been previously frozen in some workspace. This is accomplished by first checking any new configuration into the global workspace before checking it back out to make modifications. * A discriminant function is required when using a union <ref> [12] </ref>. No explanation is given on what this function should do and when it should be called.
Reference: [13] <institution> Object Design, Inc., Burlington, Massachusetts. ObjectStore User Guide, </institution> <month> March </month> <year> 1991. </year>
Reference-contexts: ObjectStore also provides a versioning mechanism to support long transactions and multiple versions. To handle large 13 amounts of data, ObjectStore uses a memory mapping and page swapping mechanism which can be customized by the database designer. <ref> [13] </ref> ObjectStore does not support schema evolution. Any change to a schema makes data created with the old schema unreadable by the new program. [16] In addition to its uniquely object-oriented characteristics, ObjectStore also has traditional database management facilities. All access to the database must occur within a transaction. <p> Data integrity is also ensured through relations and inverse relations which synchronize related objects when one of them is modified. ObjectStore provides tools for managing collections (groups of homogeneous data) and supports query processing over these collections. <ref> [13] </ref> ObjectStore's Virtual Memory Mapping Architecture (VMMA) is key to its performance. This architecture allows persistent data stored in ObjectStore to be handled in the same way as non-persistent (transient) data. Large amounts of data can be retrieved and manipulated with minimal overhead through virtual memory management. <p> The overall effect of the memory mapping architecture is to provide the developer a single view of memory | basically expanding the program memory to the size of the database. <ref> [13] </ref> For an application to work with ObjectStore three auxiliary processes are required | the ObjectStore Server, the Directory Manager, and the Cache Manager. The Server handles all storage and retrieval of persistent data. The Directory Manager manages ObjectStore directories much as Unix manages its directories. <p> The Server handles all storage and retrieval of persistent data. The Directory Manager manages ObjectStore directories much as Unix manages its directories. The Cache Manager controls swapping of data between the cache memory associated with an application and the virtual database memory. <ref> [13] </ref> ObjectStore provides interfaces to both C and C++. It also has its own Data Definition and Manipulation Language (DML) which is a superset of C++.
Reference: [14] <author> Ousterhout, John K. </author> <title> Magic Tutorial #6: Design-Rule Checking. </title> <institution> University of 62 California, Berkeley, </institution> <address> CA, </address> <year> 1990. </year>
Reference-contexts: The design review checker applies rules from a file of over 500 lines to each tile in the cell. Hierarchical designs are checked by ensuring the cell alone is consistent, and that the combination of the cell and all of its subcells is consistent <ref> [14] </ref>. This may require traversing the cell hierarchy a number of times to complete the design rule checking; thus, small discrepancies in response time are multiplied into large differences such as those shown in Tables 4.1 and 4.2. <p> The design rule checker usually runs in the background because of the large amount of processing it requires <ref> [14] </ref>. It limits its checks to those cells which are currently in memory; other cells are checked the next time they are read into memory. This allows incremental application of design rules to the cell and eliminates the need to process the entire cell at once.
Reference: [15] <author> Ousterhout, John K. and others. </author> <title> "Magic: A VLSI Layout System." </title> <booktitle> In 21st Design Automation Conference Proceedings, </booktitle> <pages> pages 152-159, </pages> <year> 1984. </year>
Reference-contexts: The purpose of Magic is to increase the power and flexibility of previous layout editors so that designs can be entered quickly and modified easily. <ref> [15] </ref> To accomplish this goal, Magic provides basic commands for creating, copying, modifying, and deleting circuit components along with capabilities for automated circuit routing and continuous checking of design rules. Circuits can be created completely from scratch or through hierarchical inclusion of any number of sub-components. <p> Figure 2.1 demonstrates how three filled in tiles (enclosed with solid lines) would be stitched together with blank tiles (dashed lines) in a single plane. Corner stitching permits search operations to be performed more efficiently <ref> [15] </ref>; however, iterating through all tiles in a cell may require traversing a number of subcell hierarchies in the database. <p> Magic, however, abstracts these mask layers into a style referred to as logs. These logs are similar to a symbolic circuit layout which a designer uses to understand the electrical functionality of the circuit. The primary difference is that each component is seen in its actual size and location. <ref> [15] </ref> 2.6 Summary Based on the characteristics of engineering design systems and the key components of the object-oriented computing paradigm, object-oriented database management systems appear well suited for supporting these design systems.
Reference: [16] <author> Sawyer, Charlie and Steve Turner. </author> <title> Object Design, Inc. </title> <type> Technical Support, </type> <month> June - October </month> <year> 1991. </year> <title> Multiple telephone conversations. </title>
Reference-contexts: To handle large 13 amounts of data, ObjectStore uses a memory mapping and page swapping mechanism which can be customized by the database designer. [13] ObjectStore does not support schema evolution. Any change to a schema makes data created with the old schema unreadable by the new program. <ref> [16] </ref> In addition to its uniquely object-oriented characteristics, ObjectStore also has traditional database management facilities. All access to the database must occur within a transaction. All data manipulation which occurs within a transaction is not visible outside of the transaction until the transaction is complete. <p> Many difficulties were encountered due to peculiarities of the ObjectStore DML. Those which were hardest to resolve are listed below. * Inconsistency of schemas. If the database schema is modified, the old database is no longer valid for that application <ref> [16] </ref>. A procedure must be made for converting the old data to match the new schema, or the data is lost. * Incompatibility of persistent types with C. Persistent types have an extra level of indirection which must be accounted for if using them in a C program [16]. <p> that application <ref> [16] </ref>. A procedure must be made for converting the old data to match the new schema, or the data is lost. * Incompatibility of persistent types with C. Persistent types have an extra level of indirection which must be accounted for if using them in a C program [16]. ObjectStore also uses a persistent dereferencing type which is not compatible with the C compiler. This requires all C programs to access persistent data types through a C++ interface. * Databases and persistent database entry points must be declared at a global level. <p> These problems do not necessary reflect poorly on object-oriented databases, however, since proper transaction implementation would easily overcome the problems. In addition, newer releases of ObjectStore are projected to better handle such memory swapping problems <ref> [16] </ref>. When considering the performance of the ObjectStore version of Magic, one must realize that Magic was not designed using object-oriented programming techniques. Any optimization built into the Magic code is designed to improve efficiency of the Unix flat file storage system, not a database management system.
Reference: [17] <author> Sidle, Thomas W. </author> <title> "Weaknesses of Commercial Data Base Management Systems in Engineering Applications." </title> <booktitle> In 17th Design Automation Conference Proceedings, </booktitle> <pages> pages 57-61, </pages> <month> June </month> <year> 1980. </year>
Reference-contexts: Thomas Sidle identified Weaknesses of Commercial Data Base Management Systems in Engineering Applications <ref> [17] </ref> as early as 1980. These weaknesses include slow response, excessive discipline imposed on the software development activity, difficulty of satisfying engineering requirements, and organizational problems associated with database support. The primary reason for these inadequacies is the orientation of existing DBMSs toward business applications. <p> The record structures, operations, concurrency control techniques, and failure recovery methods of conventional DBMSs are designed to support these business databases. Inefficiencies and failure result when these DBMSs are used to support engineering design applications. <ref> [17] </ref> 10 Instead of conventional DBMSs, many database experts have proposed Object-Oriented Database Management Systems as more appropriate for engineering design systems.
Reference: [18] <author> Stroustrup, Bjarne. </author> <title> The C++ Programming Language. </title> <address> Reading, Massachusetts: </address> <publisher> Addison-Wesley Publishing Company, </publisher> <year> 1987. </year>
Reference-contexts: ObjectStore supports most of the object-oriented database characteristics listed in Table 1.1. The database design language is C++ which provides support for complex state, inheritance, and user defined data types <ref> [18] </ref>. Specific views for an object can be expressed in the C++ functions associated with that object. ObjectStore also provides a versioning mechanism to support long transactions and multiple versions. <p> Unfortunately, Magic is not such a program. The first difficulty is that Magic is written in C rather than C++. C++ was designed to be compatible with C <ref> [18] </ref>; however, this compatibility is not complete. ObjectStore has a C library interface, but this does not allow one to take full advantage of object-oriented programming techniques. Any program which contains ObjectStore DML must 25 be compiled with the DML compiler. This compiler is a slightly modified C++ compiler. <p> This prevents a circuit designer from backing out of cell modifications | once a cell is changed, the change is reflected permanently in the ObjectStore database. Another problem area stems from the incompatibility of C and C++. In theory, C++ is designed to be a superset of C <ref> [18] </ref>. While this may be true in a C program that is very well designed and coded, in reality C allows many structures that are not compatible with C++.
Reference: [19] <editor> Zdonik, Stanley B. and David Maier, editors. </editor> <booktitle> Readings in Object-Oriented Database Systems. </booktitle> <address> San Mateo, CA: </address> <publisher> Morgan Kaufmann Publishers, Inc., </publisher> <year> 1990. </year>
Reference-contexts: Object-oriented computing attempts to minimize the impact of changes through data encapsulation, in which the underlying data is accessible only through a well-defined interface <ref> [19] </ref>. Increased understanding is attained through abstraction, a concept in which the programmer's model of an object more closely approximates the user's conceptual model of the object [4]. A database management system also supports data encapsulation and abstraction by providing mechanisms for defining storage structures and manipulating information [8].
References-found: 19

