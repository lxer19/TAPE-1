URL: http://foxnet.cs.cmu.edu/people/cstone/papers/fool5.ps
Refering-URL: http://foxnet.cs.cmu.edu/people/cstone/
Root-URL: 
Email: riecke@bell-labs.com  cstone@cs.cmu.edu  
Title: Privacy via Subsumption  
Author: Jon G. Riecke Christopher A. Stone 
Address: 700 Mountain Avenue Murray Hill, NJ 07974 USA  5000 Forbes Avenue Pittsburgh, PA 15213 USA  
Affiliation: Bell Laboratories Lucent Technologies  School of Computer Science Carnegie Mellon University  
Abstract: We describe an object calculus that allows both extension of objects and full width subtyping (hiding arbitrary components). In contrast to other proposals, the types of our calculus do not mention missing methods. To avoid type unsoundness, the calculus mediates all interaction with objects via dictionaries that resemble the method dispatch tables in conventional implementations. Private fields and methods can be modeled and enforced by scoping restrictions: forgetting a field or method through subsumption makes it private. We prove that the type system is sound, give a variant which allows covariant self types, and give some examples of the expressiveness of the calculus. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> M. Abadi and L. Cardelli. </author> <title> A Theory of Objects. </title> <publisher> Springer-Verlag, </publisher> <year> 1996. </year>
Reference-contexts: In this paper we give an elementary account of private fields and methods in the presence of structural subtyping. We extend recent object calculi <ref> [1, 20] </ref> with operations for hiding and renaming methods, operations that can also be found in the class system of Eiffel [19]. <p> Because the semantics of object extension gives the new method a new internal name, the getx method remains unaffected. 2 A Language of First-Order Extensible Objects We begin with a first-order calculus (in the sense of <ref> [1] </ref>), i.e., the calculus without a notion of self type. <p> To keep the setting simple, all objects are immutable and objects have no fields; fields can be encoded as methods which ignore their self argument. 2.1 Syntax The language, whose syntax appears in Table 1, derives largely from the object calculi of Abadi and Cardelli <ref> [1] </ref>, Fisher, Honsell, and Mitchell [10], and Liquori [18]. The types of the language include base types, function types, and object types. Object types only mention the visible names of methods and their return types. We identify object expressions or types differing only in the order of their components. <p> This motivates a move to a second-order calculus in the par lance of <ref> [1] </ref>. Method types can now refer to the type of self which changes as the object is extended. Thus we define PT := Obj a:fjgetx : Int; move : Int!ajg where a represents the type of self, and is bound within the object type. <p> We would need more restrictive width subtyping to avoid unsoundness if the a were allowed to appear contravariantly (see <ref> [1] </ref> for examples).
Reference: [2] <author> V. Bono, M. Bugliesi, M. Dezani, and L. Liquori. </author> <title> Subtyping constraints for incomplete objects. </title> <booktitle> In CAAP, Lecture Notes in Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1997. </year>
Reference-contexts: The idea is related to an old idea: Jategaonkar and Mitchell [15] and Remy [22] use types that keep track of which methods must be absent from an object. Bono, Bugliesi, Dezani, and Liquori <ref> [4, 3, 2] </ref> take a different approach: object types contain a conservative approximation of which methods each method invokes via self. A collection of methods can be forgotten via sub-sumption if no remaining methods might invoke a member of this collection.
Reference: [3] <author> V. Bono, M. Bugliesi, and L. Liquori. </author> <title> A lambda calculus of incomplete objects. </title> <booktitle> In Proceedings, Mathematical Foundations of Computer Science, volume 1113 of Lecture Notes in Computer Science, </booktitle> <pages> pages 218229. </pages> <publisher> Springer-Verlag, </publisher> <year> 1996. </year>
Reference-contexts: The idea is related to an old idea: Jategaonkar and Mitchell [15] and Remy [22] use types that keep track of which methods must be absent from an object. Bono, Bugliesi, Dezani, and Liquori <ref> [4, 3, 2] </ref> take a different approach: object types contain a conservative approximation of which methods each method invokes via self. A collection of methods can be forgotten via sub-sumption if no remaining methods might invoke a member of this collection.
Reference: [4] <author> V. Bono and L. Liquori. </author> <title> A subtyping for the Fisher-Honsell-Mitchell calculus of objects. </title> <booktitle> In Proceedings, Computer Science Logic 1994, volume 933 of Lecture Notes in Computer Science, </booktitle> <pages> pages 1630. </pages> <publisher> Springer-Verlag, </publisher> <year> 1995. </year>
Reference-contexts: The idea is related to an old idea: Jategaonkar and Mitchell [15] and Remy [22] use types that keep track of which methods must be absent from an object. Bono, Bugliesi, Dezani, and Liquori <ref> [4, 3, 2] </ref> take a different approach: object types contain a conservative approximation of which methods each method invokes via self. A collection of methods can be forgotten via sub-sumption if no remaining methods might invoke a member of this collection.
Reference: [5] <author> G. Bracha and G. Lindstrom. </author> <title> Modularity meets inheritance. </title> <booktitle> In Proceedings of the IEEE Computer Society International Conference on Computer Languages, </booktitle> <pages> pages 282290, </pages> <address> Wash-ington, DC, April 1992. </address> <publisher> IEEE Computer Society. </publisher>
Reference-contexts: Eiffel [19] has operations for redefining and undefin-ing the methods of a class, much like our single renaming operation does in the first-order calculus. We are not aware, however, of any formal accounts that establish the soundness of the Eiffel type system. Bracha and Lindstrom <ref> [5] </ref> define a coercive operation for hiding components of objects; this appears to behave similarly to our subsumption operation, at least for first-order objects. They formalize this operation within an untyped l-calculus. More work has addressed the problems with object extension and subtyping.
Reference: [6] <author> K. B. Bruce, L. Cardelli, G. Castagna, The Hopkins Object Group, G. Leavens, and B. C. Pierce. </author> <title> On binary methods. Theory and Practice of Object Systems, </title> <address> 1(3):217238, </address> <year> 1995. </year>
Reference-contexts: We would need more restrictive width subtyping to avoid unsoundness if the a were allowed to appear contravariantly (see [1] for examples). As such, this system does not handle binary methods (see <ref> [6] </ref> for a thorough discussion). 3.2 Dynamic semantics The dynamic semantics for the second-order calculus uses evalua tion contexts of the form E ::= [] j (E e) j (v E) j E:l j E +l (s:a; d)=e 0 : t 0 j E v l (s:a; d)=e 0 The rules
Reference: [7] <author> L. Cardelli and P. Wegner. </author> <title> On understanding types, data abstraction and parametric polymorphism. </title> <journal> Computing Surveys, </journal> <volume> 17(4):471522, </volume> <year> 1985. </year>
Reference-contexts: An extension of the system with row variables [24] or bounded polymorphism <ref> [7] </ref> might allow preservation of methods in such cases. 3 Second-Order System In a calculus of immutable objects, it is natural to consider objects that can return updated copies of themselves.
Reference: [8] <author> M. Felleisen. </author> <title> The theory and practice of first-class prompts. </title> <booktitle> In Conference Record of the Fifteenth Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 180 190. </pages> <publisher> ACM, </publisher> <year> 1988. </year> <pages> 9 - 7 </pages>
Reference-contexts: An existing method can be replaced within an object by the operation e 0 l (s)=e. 2.2 Static and dynamic semantics To give dynamic semantics to the language, we use Felleisen's evaluation context formulation <ref> [8] </ref> of Plotkin's SOS [21].
Reference: [9] <author> K. Fisher. </author> <title> Type Systems for Object-Oriented Programming Languages. </title> <type> PhD thesis, </type> <institution> Department of Computer Science, Stanford University, </institution> <year> 1996. </year>
Reference-contexts: Variants of the calculus have been carefully studied before (e.g., <ref> [9, 10, 11, 12, 18] </ref>).
Reference: [10] <author> K. Fisher, F. Honsell, and J. C. Mitchell. </author> <title> A lambda calculus of objects and method specialization. </title> <journal> Nordic J. Computing (formerly BIT), </journal> <note> 1:337, 1994. Preliminary version appeared in Proc. IEEE Symp. on Logic in Computer Science, 1993, 2638. </note>
Reference-contexts: The type of p is fjx : Int; getx : Intjg. If p can also have the less precise type fjgetx : Intjg, there is be nothing to prevent us from adding a new method x returning the value True of type Bool. In the dynamic semantics of <ref> [10, 18] </ref> where an object can have at most one x component at a time, this would override the earlier x method and cause getx to thereafter return the value True; This is a type error as getx is statically typed as returning an integer. <p> To avoid such errors, the type systems of <ref> [10, 18] </ref> weaken the subtyping relation for extensible objects: either methods may not be hidden at all, or components can be made inaccessible (cannot be invoked) though still visible and overrid-able. <p> Variants of the calculus have been carefully studied before (e.g., <ref> [9, 10, 11, 12, 18] </ref>). <p> To keep the setting simple, all objects are immutable and objects have no fields; fields can be encoded as methods which ignore their self argument. 2.1 Syntax The language, whose syntax appears in Table 1, derives largely from the object calculi of Abadi and Cardelli [1], Fisher, Honsell, and Mitchell <ref> [10] </ref>, and Liquori [18]. The types of the language include base types, function types, and object types. Object types only mention the visible names of methods and their return types. We identify object expressions or types differing only in the order of their components.
Reference: [11] <author> K. Fisher and J. C. Mitchell. </author> <title> A delegation-based object calculus with subtyping. </title> <booktitle> In Fundamentals of Computation Theory (FCT'95), number 965 in Lecture Notes in Computer Science, </booktitle> <pages> pages 4261. </pages> <publisher> Springer-Verlag, </publisher> <year> 1995. </year>
Reference-contexts: Variants of the calculus have been carefully studied before (e.g., <ref> [9, 10, 11, 12, 18] </ref>).
Reference: [12] <author> K. Fisher and J. C. Mitchell. </author> <title> The development of type systems for object-oriented languages. Theory and Practice of Object Systems, </title> <address> 1:189220, </address> <year> 1996. </year> <note> Preliminary version appeared in Proc. Theoretical Aspects of Computer Software, Springer LNCS 789, 1994, 844885. </note>
Reference-contexts: Variants of the calculus have been carefully studied before (e.g., <ref> [9, 10, 11, 12, 18] </ref>). <p> Bracha and Lindstrom [5] define a coercive operation for hiding components of objects; this appears to behave similarly to our subsumption operation, at least for first-order objects. They formalize this operation within an untyped l-calculus. More work has addressed the problems with object extension and subtyping. Fisher and Mitchell <ref> [12] </ref>, for instance, discuss the unsoundness of width subtyping in the presence of object extension. Their solution is to distinguish the types of objects which either method override and object extension (but no subtyping) from those which support width and depth subtyping but not method override or object extension.
Reference: [13] <author> K. Fisher and J. C. Mitchell. </author> <title> On the relationship between classes, objects, and data abstraction. </title> <booktitle> In Proceedings of the International Summer School on Mathematics of Program Construction, Marktoberdorf, Germany, Lecture Notes in Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1997. </year> <note> To appear. Revised version to appear in Theory and Practice of Object Systems. </note>
Reference-contexts: Previous work has attempted to address these problems, and it is worth comparing these solutions to ours. In the context of modeling private components in objects, Fisher and Mitchell <ref> [13] </ref> give an account of private (as well as protected) methods and fields using abstract types. Abstract types can be used to hide the representations of objects from clients, even though the objects themselves have access to the internal representations.
Reference: [14] <author> J. Gosling, B. Joy, and G. Steele. </author> <title> The Java Language Specification. </title> <publisher> Addison-Wesley, </publisher> <year> 1996. </year>
Reference-contexts: 1 Introduction One of the most important principles of software engineering is information hiding: the ability to build and enforce data or procedural abstractions in order to make programs readable and maintainable. Most object-oriented programming languages provide direct support for information hiding. Class-based languages like C++ and Java <ref> [14] </ref>, for instance, have mechanisms for hiding methods and fields via private annotations; private methods and fields added to an object may be accessed only by other methods defined within the same class.
Reference: [15] <author> L. Jategaonkar and J. C. Mitchell. </author> <title> Type inference with extended pattern matching and subtypes. </title> <note> Fundamenta Informat-icae, 19:127166, 1993. Preliminary version appeared in the Proceedings of the ACM Symposium on Lisp and Functional Programming, </note> <year> 1988. </year>
Reference-contexts: The idea is related to an old idea: Jategaonkar and Mitchell <ref> [15] </ref> and Remy [22] use types that keep track of which methods must be absent from an object. Bono, Bugliesi, Dezani, and Liquori [4, 3, 2] take a different approach: object types contain a conservative approximation of which methods each method invokes via self.
Reference: [16] <author> J. Lakos. </author> <title> Large-Scale C++ Software Design. </title> <publisher> Addison-Wesley, </publisher> <year> 1996. </year>
Reference-contexts: Moreover, when we use these calculi as a basis for classes, additions or changes to the private methods of a base class may require subclasses to be re-typechecked and possibly recompiled (a problem familiar from C++ <ref> [16] </ref>). In the worst case, derived classes become ill-formed and large pieces of code must be rewritten. We approach this problem by allowing unrestricted hiding and compensating in the dynamic semantics.
Reference: [17] <author> L. Liquori. </author> <title> An extended theory of primitive objects: First and second order systems. </title> <type> Technical Report CS-23-96, </type> <institution> Diparti-mento di Informatica, Universita di Torino, </institution> <year> 1996. </year>
Reference-contexts: Later work has looked at other ways of combining width subtyping with object extension without losing soundness. Liquori <ref> [17, 18] </ref> gives first- and second-order systems in which the types of extensible objects list the names and types of (a superset of) methods hidden by subsumption; the types must match if the object is extended by a new method with the same name as a hidden method.
Reference: [18] <author> L. Liquori. </author> <title> An extended theory of primitive objects: First order system. </title> <editor> In M. Aksit and S. Matsuoka, editors, </editor> <booktitle> Proceedings of ECOOP-97, International European Conference on Object Oriented Programming, number 1241 in Lecture Notes in Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1997. </year>
Reference-contexts: The type of p is fjx : Int; getx : Intjg. If p can also have the less precise type fjgetx : Intjg, there is be nothing to prevent us from adding a new method x returning the value True of type Bool. In the dynamic semantics of <ref> [10, 18] </ref> where an object can have at most one x component at a time, this would override the earlier x method and cause getx to thereafter return the value True; This is a type error as getx is statically typed as returning an integer. <p> To avoid such errors, the type systems of <ref> [10, 18] </ref> weaken the subtyping relation for extensible objects: either methods may not be hidden at all, or components can be made inaccessible (cannot be invoked) though still visible and overrid-able. <p> Variants of the calculus have been carefully studied before (e.g., <ref> [9, 10, 11, 12, 18] </ref>). <p> setting simple, all objects are immutable and objects have no fields; fields can be encoded as methods which ignore their self argument. 2.1 Syntax The language, whose syntax appears in Table 1, derives largely from the object calculi of Abadi and Cardelli [1], Fisher, Honsell, and Mitchell [10], and Liquori <ref> [18] </ref>. The types of the language include base types, function types, and object types. Object types only mention the visible names of methods and their return types. We identify object expressions or types differing only in the order of their components. <p> Later work has looked at other ways of combining width subtyping with object extension without losing soundness. Liquori <ref> [17, 18] </ref> gives first- and second-order systems in which the types of extensible objects list the names and types of (a superset of) methods hidden by subsumption; the types must match if the object is extended by a new method with the same name as a hidden method.
Reference: [19] <author> B. Meyer. </author> <title> Eiffel: The Language. </title> <publisher> Prentice-Hall, </publisher> <year> 1992. </year>
Reference-contexts: In this paper we give an elementary account of private fields and methods in the presence of structural subtyping. We extend recent object calculi [1, 20] with operations for hiding and renaming methods, operations that can also be found in the class system of Eiffel <ref> [19] </ref>. The primitives of the calculus also include object extension, method override, and arbitrary width subtyping and sub-sumption (i.e., objects with more methods can always be used in contexts expecting fewer methods). We prove that the type systems prevent run-time type errors. <p> Remy and Vouil-lon [23] consider a more direct account of private data in classes, but only as inlined constant values. In addition to not matching a standard implementation, their approach does not extend well to mutable fields in the presence of object cloning or functional update of objects. Eiffel <ref> [19] </ref> has operations for redefining and undefin-ing the methods of a class, much like our single renaming operation does in the first-order calculus. We are not aware, however, of any formal accounts that establish the soundness of the Eiffel type system.
Reference: [20] <author> J. C. Mitchell. </author> <title> Toward a typed foundation for method specialization and inheritance. </title> <booktitle> In Conference Record of the Seventeenth Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 109124. </pages> <publisher> ACM, </publisher> <year> 1990. </year>
Reference-contexts: In this paper we give an elementary account of private fields and methods in the presence of structural subtyping. We extend recent object calculi <ref> [1, 20] </ref> with operations for hiding and renaming methods, operations that can also be found in the class system of Eiffel [19].
Reference: [21] <author> G. D. Plotkin. </author> <title> A structural approach to operational semantics. </title> <type> Technical Report DAIMI FN-19, </type> <institution> Aarhus Univ., Computer Science Dept., Denmark, </institution> <year> 1981. </year>
Reference-contexts: An existing method can be replaced within an object by the operation e 0 l (s)=e. 2.2 Static and dynamic semantics To give dynamic semantics to the language, we use Felleisen's evaluation context formulation [8] of Plotkin's SOS <ref> [21] </ref>.
Reference: [22] <author> D. Remy. </author> <title> Type inference for records in a natural extension of ML. </title> <editor> In C. A. Gunter and J. C. Mitchell, editors, </editor> <booktitle> Theoretical Aspects of Object-Oriented Programming, </booktitle> <pages> pages 6795. </pages> <publisher> MIT Press, </publisher> <year> 1994. </year> <note> An earlier version appeared in the Proceedings of the Sixteenth Annual ACM Symposium on Principles of Programming Languages, </note> <year> 1989. </year>
Reference-contexts: The idea is related to an old idea: Jategaonkar and Mitchell [15] and Remy <ref> [22] </ref> use types that keep track of which methods must be absent from an object. Bono, Bugliesi, Dezani, and Liquori [4, 3, 2] take a different approach: object types contain a conservative approximation of which methods each method invokes via self.
Reference: [23] <author> D. Remy and J. Vouillon. </author> <title> Objective ML: A simple object-oriented extension of ML. </title> <booktitle> In Proceedings of the 24th ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 4053. </pages> <publisher> ACM Press, </publisher> <year> 1997. </year>
Reference-contexts: Information about the names of private fields and methods, however, is still exposed. Their account is in some sense more fundamental than ours: our calculus directly supports hiding, and does not attempt to describe it in more basic concepts. Remy and Vouil-lon <ref> [23] </ref> consider a more direct account of private data in classes, but only as inlined constant values. In addition to not matching a standard implementation, their approach does not extend well to mutable fields in the presence of object cloning or functional update of objects.
Reference: [24] <author> M. Wand. </author> <title> Complete type inference for simple objects. </title> <booktitle> In Proceedings, Symposium on Logic in Computer Science, </booktitle> <pages> pages 3744. </pages> <publisher> IEEE, </publisher> <year> 1987. </year> <pages> 9 - 8 </pages>
Reference-contexts: An extension of the system with row variables <ref> [24] </ref> or bounded polymorphism [7] might allow preservation of methods in such cases. 3 Second-Order System In a calculus of immutable objects, it is natural to consider objects that can return updated copies of themselves.
References-found: 24

