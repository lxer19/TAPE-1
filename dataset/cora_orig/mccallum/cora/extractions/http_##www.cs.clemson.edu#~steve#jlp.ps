URL: http://www.cs.clemson.edu/~steve/jlp.ps
Refering-URL: http://www.cs.clemson.edu/~steve/eb.html
Root-URL: http://www.cs.clemson.edu
Title: W2C: A WAM TO C ASSEMBLER  
Author: D. E. STEVENSON 
Date: 1994:19, 20:1-679 1  
Note: J. LOGIC PROGRAMMING  
Abstract: We describe an assembler that accepts WAM commands as described in Ait-Kaci. The output of is a program in C. We describe how we make the backtracking model of the WAM work within the C paradigm. We also describe commands that are used to convert WAM tagged memory values to be compatible with more "vanilla" C. / 
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> Hassan Ait-Kaci. </author> <title> Warren's Abstract Machine. </title> <publisher> MIT Press. </publisher> <year> 1991. </year>
Reference-contexts: Three bits are currently reserved for tags. For portability sake, all tag/value operations are C macros. This constitutes the "microcode" and this microcode is available through the compiler. Even with the understanding produced in [3], the WAM described in <ref> [1] </ref> has some "magic" banks of registers. In particular the A, X, and Y banks took quite a few attempts to get correct. In our implementation, these three banks are special areas of the environment stack. <p> This means, however, that everything must be passed by reference. This in turn means that the procedure deref must be used everywhere. This leaves the optimization question of making deref into an inline procedure. Actually assignments to variables are accomplished by the various WAM instructions as outlined in <ref> [1] </ref>. 2.2. Atoms There has been some hesitancy on how to handle atoms, particularly given the functional bent of numerical evaluation. Using multiprecision integers, rationals, and floats considerably complicates storage considerations. The undefined length nature of character strings is also a complication. None of these concepts is addressed in [1]. <p> in <ref> [1] </ref>. 2.2. Atoms There has been some hesitancy on how to handle atoms, particularly given the functional bent of numerical evaluation. Using multiprecision integers, rationals, and floats considerably complicates storage considerations. The undefined length nature of character strings is also a complication. None of these concepts is addressed in [1]. In fact, a deficiency of the model is its handling of non primitive types. Our approach is straightforward: the lowest portion of memory is set aside as the atom area. These are registers that contain a pointer to the data. <p> WAM Commands and Ancillary Functions Implemented. 3. Individual Commands The individual commands are documented in <ref> [1] </ref>. Happily, the commands as documented were coded virtually verbatim. There were two major design innovations required: (i) the call-proceed versus retry mechanism and (ii) the calling of C functions directly. 3.1. Standard WAM Commands The commands implemented in the project are shown in Table 3.1. <p> There were two major design innovations required: (i) the call-proceed versus retry mechanism and (ii) the calling of C functions directly. 3.1. Standard WAM Commands The commands implemented in the project are shown in Table 3.1. These represent the commands defined in <ref> [1] </ref> except for the indexing commands. Since those commands are primarily for optimization it was decided to postpone implementation. It turns out that these commands are implemented virtually verbatim from [1]. The major changes involve the "microcode" available and some decisions to turn descriptions of common operations into subroutines. 3.2. <p> These represent the commands defined in <ref> [1] </ref> except for the indexing commands. Since those commands are primarily for optimization it was decided to postpone implementation. It turns out that these commands are implemented virtually verbatim from [1]. The major changes involve the "microcode" available and some decisions to turn descriptions of common operations into subroutines. 3.2. The Compiled Clauses A compiled clause is a C function. The clause expects two arguments: The dispatch state and a label number. <p> Qa2 := CLAUSE (Qa1 <ref> [1] </ref>) % The entry point trace % trace call if tracing on B0 := B % Set up neck cut Dispatch := initial_call % Set dispatcher to call longjmp (dispatch_longjmp,0) % Do long jump FIGURE 3.1. <p> The last standard WAM situation to consider is that of backtracking. backtrack can be called from any of a number of command. The routine described in <ref> [1] </ref> has been moved to the dispatcher, and the call to backtrack has been kept for uniformity and error checking. The processing is effectively that of [1]. 4. The Assembler The assembler is a simple yacc assembler with very few amenities since it is not meant for human use. <p> The routine described in <ref> [1] </ref> has been moved to the dispatcher, and the call to backtrack has been kept for uniformity and error checking. The processing is effectively that of [1]. 4. The Assembler The assembler is a simple yacc assembler with very few amenities since it is not meant for human use. The basic idea is to simplify the development of a system. A true compiler could generate code directly, but having the assembler allows for others to use. <p> An Example Program. The style of clause input is similar to that used in <ref> [1] </ref> and a sample program is shown in Figure 3.2. Each clause is to be the processing for the particular arity as defined in the clause statement. After the clause but before the start statement come the declarations. <p> This is a vector guaranteed to be out of the WAM's memory model. The W bank has special operations as outlined in Table 4.1. This extension is sufficient to gain access to C and Fortan routines. 5. Conclusion In retrospect, the development of this assembler was quite simple. Although <ref> [1] </ref> is very clear there are several subtle points that needed to be worked out.
Reference: 2. <author> Errett Bishop and Douglas Bridges. </author> <title> Constructive Analysis. </title> <publisher> Springer Verlag. </publisher> <year> 1985. </year>
Reference-contexts: Current practice, in this author's opinion, stands too far from the constructive roots of numerical analysis and pre-formalist mathematics. Even within that, there is much latitude. The author has chosen the "path less traveled" by attempting to work within the constructive framework of Errett Bishop <ref> [2] </ref>. To make such a program work, one must have a framework to build on. After some attempts at various ideas, the author has settled on a logic programming paradigm. For the most part, prologish ideas seem sufficient for now. However, some areas needed expansion.
Reference: 3. <author> K.L. Clark and S.-A. </author> <title> Tarnlund. Logic Programming. </title> <publisher> Academic Press. </publisher> <year> 1982. </year>
Reference-contexts: The Memory (High Address) Push Down Stack for Unification Environment/Choice Point Stack Heap Atomic Elements (Low Address) FIGURE 2.1. Standard Memory Layout. 3 As with any implementation, the layout of memory is crucial. Most of the real problems were solved in the 1980s <ref> [3] </ref>. The problems of structure sharing and unification without garbage collection leads one to have a word-oriented memory structure called registers as show in Figure 2.1. Our implementation uses a tagged memory system as one would expect. <p> This couples with another problem discussed in when describing atoms (See Section 2.2). Three bits are currently reserved for tags. For portability sake, all tag/value operations are C macros. This constitutes the "microcode" and this microcode is available through the compiler. Even with the understanding produced in <ref> [3] </ref>, the WAM described in [1] has some "magic" banks of registers. In particular the A, X, and Y banks took quite a few attempts to get correct. In our implementation, these three banks are special areas of the environment stack.
Reference: 4. <author> Wim H. Hesselink. </author> <title> Programs, Recursion and Unbounded Choice. </title> <booktitle> Cambridge Tracts in Theoretical Computer Science 27. </booktitle> <publisher> Cambridge University Press. </publisher> <year> 1992. </year>
Reference-contexts: These operations are being held in abeyance pending more detailed development of the numerical language. We are currently rewriting the assembler to remove the last vestiges of the i-machine. A higher-level language is being defined based on the use of guarded commands <ref> [4] </ref>. The guarded if and do introduced by Dijkstra fall naturally on top of the backtracking paradigm of the WAM. We have extended the assembler to support these two statements.
References-found: 4

