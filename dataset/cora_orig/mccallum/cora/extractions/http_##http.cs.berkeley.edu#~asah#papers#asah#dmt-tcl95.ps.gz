URL: http://http.cs.berkeley.edu/~asah/papers/asah/dmt-tcl95.ps.gz
Refering-URL: http://http.cs.berkeley.edu/~asah/papers/asah/
Root-URL: 
Email: asah@cs.Berkeley.EDU  
Title: Multiple Trace Composition and Its Uses  including a facility for writing persistent Tcl scripts. The prototype  
Author: Adam Sah 
Web: ftp://ginsberg.cs.berkeley.edu/pub/ asah/dmt/tcl-proto.tar.gz  
Note: The specifics of the prototype are presented,  requires Tcl7. with Tk3. or later and may be downloaded from  supported by a grant from the National Science Foundation #NSF-IRI9107455  
Date: May 23, 1995  
Address: Berkeley, CA 94720-1776  
Affiliation: Computer Science Division Electrical Engineering and Computer Sciences University of California  
Abstract: Traces are code attachments to variables that cause designated blocks of code to be executed on reads or writes to the given variable. Traces have numerous uses, including rules (on &lt;condition&gt; do &lt;action&gt; statements), autoloading and initialization based on data access, transparent remote data access, paging and swapping, and persistence. Traces are usually limited to ad-hoc, hard-coded composition, making it difficult to place multiple traces on the same variable. Multiple traces are useful for putting a rule on a persistent variable, or several rules on a variable. This paper presents a design for a low-level mechanism for reasoning about and configuring multiple traces on a single variable. Although the work is based on a prototype using a modified version of Tcl's trace command, this mechanism easily applies to any language or library capable of implementing traps. This includes systems such as data breakpoints[WLG93] in C and overloadable get() and set() methods in prototype-based object-oriented systems. 
Abstract-found: 1
Intro-found: 1
Reference: [AWH92] <author> Alexander Aiken, Jennifer Widom, and Joseph Hellerstein. </author> <title> Behavior of Database Production Rules: Termination, Confluence, and Observable Determinism Proc. </title> <booktitle> ACM SIGMOD'92 Conf. on Management of Data. </booktitle>
Reference-contexts: Language use encompasses a strict superset: for example, none of the DBMS papers consider rules that modify themselves, modify other rules or add extensions to the DBMS. Likewise, DBMS rule systems research is concerned with confluence and termination <ref> [AWH92] </ref> which are extremely hard to prove for even simple programs in general purpose languages (and, of course, impossible to prove in the general case). * Unlike AI systems, we are not trying to provide automatic reasoning about uncertain or complex situations.
Reference: [BS94] <author> Jon Blow and Adam Sah. </author> <title> Rule Semantics and Their Use in More Precise Aliasing UC Berkeley Technical Report #94/59. </title>
Reference: [Car94] <author> Michael Carey, et. al. </author> <title> Shoring Up Persistent Applications Proc. </title> <booktitle> ACM SIGMOD'94 Conf. on Management of Data. </booktitle>
Reference-contexts: It is expected that such a facility would be glued on top of a more complete object-oriented DBMS back-end, such as Exodus [Car86] or SHORE <ref> [Car94] </ref>. Relational databases would be harder to glue, since this model doesn't handle joins; the right way to model this might be to represent each desired join as a view in the RDBMS and attach the Tcl interface to that view.
Reference: [Car86] <editor> Michael Carey, et. al. </editor> <booktitle> The Architecture of the EXODUS Extensible DBMS 1986 Proc. Symp. on Very Large Database Systems. </booktitle> <address> (VLDB'86) </address>
Reference-contexts: Note that this doesn't perform the two phase commit needed for true atomicity in the previous example or deal with other issues typically handled by real DBMSs. It is expected that such a facility would be glued on top of a more complete object-oriented DBMS back-end, such as Exodus <ref> [Car86] </ref> or SHORE [Car94]. Relational databases would be harder to glue, since this model doesn't handle joins; the right way to model this might be to represent each desired join as a view in the RDBMS and attach the Tcl interface to that view.
Reference: [For81] <author> C.L. Forgy. </author> <title> OPS5 User's Manual Dept. </title> <institution> of Comp. Sci., Cargenie-Mellon Univ. </institution> <year> 1980. </year>
Reference-contexts: Language-based rules are meant to be programmed manually, where AI rule systems have typically investigated automatic resolution of rule conflicts <ref> [For81] </ref>. Some object-oriented systems allow prototypes, which are objects that differ (dynamically) from the templates used to create them (eg. Self has prototypes, ScriptX has singletons).
Reference: [Gud93] <author> David Gudeman. </author> <title> Representing Type Information in Dynamically Typed Languages Univ. </title> <type> of Arizona Technical Report #93-27. </type>
Reference-contexts: The Tcl [Ous94] trace command is typical of language support and will serve as the example throughout the paper, although memory access traps are commonplace in operating systems (ie. virtual memory fault handling). Traces are also described as hooked values in a survey paper by Gudeman <ref> [Gud93] </ref>. Few access trapping systems support the composition of multiple code attachments on a single traced variable; in other cases, programmers of the last trap must explicitly call any previously-defined trap handler as hard code.
Reference: [Han78] <author> Hanson, David R. </author> <title> Filters in SL5 The Computer Journal. </title> <address> v.21,No.2. pp.134-43. </address> <month> May </month> <year> 1978. </year>
Reference-contexts: The real limit is in how easy the facility is to use, which neither alternative maintains. 10 Related Work The SL5 language contains filters <ref> [Han78] </ref>, which are remarkably similar to the composable traces invented in this paper.
Reference: [HW93] <author> Eric Hanson and Jennifer Widom. </author> <title> An Overview of Production Rules in Database Systems Knowledge and Engineering Review. </title> <journal> vol.8, no.2, </journal> <volume> pp.121-143. </volume> <month> June </month> <year> 1993. </year>
Reference-contexts: From our standpoint, many of the semantic issues are similar, although the context is quite different. * Unlike DBMSs, languages are designed to be fully programmable and user extensible. DBMS rules are designed to enforce constraints <ref> [HW93] </ref>, to provide simple triggering mechanisms, or to provide different views of data [Sto90]. Language use encompasses a strict superset: for example, none of the DBMS papers consider rules that modify themselves, modify other rules or add extensions to the DBMS.
Reference: [Jon93] <editor> Michael B. Jones. </editor> <booktitle> Interposition Agents: Transparently Interposing User Code at the System Interface Proc. 14th Symp. on Operating System Principles (SOSP'93). </booktitle>
Reference-contexts: Compared with current SFI work, composable traces make traps a first-class language mechanism. Finally, there has been some recent work on composition of OS services. Examples include composable file systems such as Spring [KN93] and Interposition Agents <ref> [Jon93] </ref>. The chief difference in this work is its focus on memory accesses and their interaction with the target programming language. 11 Future Work Future work could take (at least) four directions. First, this work presents a low-level mechanism when higher level mechanisms are probably needed.
Reference: [KN93] <author> Yousef Khalidi and Michael Nelson. </author> <booktitle> Extensible File Systems in Spring Proc. 14th Symp. on Operating System Principles (SOSP'93). </booktitle>
Reference-contexts: Compared with current SFI work, composable traces make traps a first-class language mechanism. Finally, there has been some recent work on composition of OS services. Examples include composable file systems such as Spring <ref> [KN93] </ref> and Interposition Agents [Jon93]. The chief difference in this work is its focus on memory accesses and their interaction with the target programming language. 11 Future Work Future work could take (at least) four directions. First, this work presents a low-level mechanism when higher level mechanisms are probably needed.
Reference: [Ous94] <author> John Ousterhout. </author> <title> An Introduction to Tcl and Tk. </title> <publisher> Addison-Wesley. </publisher> <year> 1994. </year>
Reference-contexts: 1 Introduction Variable traces are code attachments to variables. When a program reads or writes a traced variable, the code is executed. The Tcl <ref> [Ous94] </ref> trace command is typical of language support and will serve as the example throughout the paper, although memory access traps are commonplace in operating systems (ie. virtual memory fault handling). Traces are also described as hooked values in a survey paper by Gudeman [Gud93].
Reference: [SBD94] <author> Adam Sah, Jon Blow and Brian Dennis. </author> <title> An Introduction to the Rush Language Proc. </title> <booktitle> Tcl'94 Workshop. </booktitle> <address> New Orleans, LA. </address> <month> June, </month> <year> 1994. </year>
Reference-contexts: This is because collection access and memory management semantics depend a lot on the target language, which would likely affect how traces are handled. This hunch was confirmed in the design of Rush, a language similar to Tcl. Among other differences, Rush supports references and first-class collections <ref> [SBD94] </ref>. Third, it would be interesting to explore whether constraints made from traps (rules) could be used to allow untrusted scripts to run safely (safe execution, a la Safe-Tcl). Finally, the demo is intentionally prototypical and still quite brittle.
Reference: [Sat93] <author> M. Satyanarayanan, et. al. </author> <title> Lightweight Recoverable Virtual Memory Proc. </title> <booktitle> 14th Symp. on Operating System Principles (SOSP'93). </booktitle>
Reference-contexts: Such persistence requires that agents periodically log their state to disk or to a remote host. Logging can be achieved by placing traps on persistent data variables <ref> [Sat93] </ref>, noting updates, and removing the traps after the first update. At the end of a transaction (a unit of atomic, persistent work), we could copy the state of all modified data items to a disk or remote host, restoring the original traps.
Reference: [Sto90] <author> Michael Stonebraker. </author> <title> On Rules, Procedures, Caching, </title> <booktitle> and Views in Database Systems Proc. ACM SIGMOD'90 Conf. on Management of Data. </booktitle>
Reference-contexts: From our standpoint, many of the semantic issues are similar, although the context is quite different. * Unlike DBMSs, languages are designed to be fully programmable and user extensible. DBMS rules are designed to enforce constraints [HW93], to provide simple triggering mechanisms, or to provide different views of data <ref> [Sto90] </ref>. Language use encompasses a strict superset: for example, none of the DBMS papers consider rules that modify themselves, modify other rules or add extensions to the DBMS.
Reference: [WLG93] <author> Robert Wahbe, Steven Lucco and Susan Graham. </author> <title> Practical Data Breakpoints: </title> <booktitle> Design and Implementation Proc. ACM SIGPLAN'93 Symp. on Programming Language Design and Implementation. </booktitle> <address> Albuquerque, NM. </address> <year> 1993. </year>
Reference: [WLAG93] <author> Robert Wahbe, Steven Lucco, Thomas E. Anderson and Susan Graham. </author> <title> Efficient Software-Based Fault Isolation Proc. </title> <booktitle> ACM SIGOPS'93 Symp. on Operating System Principles. </booktitle> <address> Asheville, NC. </address> <year> 1993. </year>
Reference-contexts: Overload-able getter/setters can still benefit inasmuch as this work presents a higher level interface for dynamically assigning a resend order between them. Compared with operating system virtual memory traps, traces are an instance of user-level virtual memory support (software fault isolation (SFI) <ref> [WLAG93] </ref>): when you touch a tainted piece of memory, your program jumps somewhere else and runs some code, then (possibly) returns to the caller. The primary differences are that language-level traps are orders of magnitude faster and offer facilities for composition and introspection.
Reference: [Whi94] <author> J.E. White. </author> <title> Telescript Technology: the foundation of the electronic marketplace White Paper. General Magic, </title> <publisher> Inc. </publisher> <year> 1994. </year>
Reference-contexts: This is one example where the -last option might be useful. 8 Logging and Persistent Com putation Telescript <ref> [Whi94] </ref> supports agents that can survive a host failure. Such persistence requires that agents periodically log their state to disk or to a remote host. Logging can be achieved by placing traps on persistent data variables [Sat93], noting updates, and removing the traps after the first update.
References-found: 17

