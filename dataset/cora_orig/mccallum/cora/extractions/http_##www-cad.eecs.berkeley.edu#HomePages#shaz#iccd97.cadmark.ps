URL: http://www-cad.eecs.berkeley.edu/HomePages/shaz/iccd97.cadmark.ps
Refering-URL: http://www-cad.eecs.berkeley.edu/HomePages/shaz/publications.html
Root-URL: http://www.cs.berkeley.edu
Email: email :fmehrotra,shaz,rajeev,randyg@eecs.berkeley.edu  
Title: Benchmarking and Analysis of Architectures for CAD Applications  
Author: Amit Mehrotra Shaz Qadeer Rajeev K. Ranjan Randy H. Katz 
Address: Berkeley, CA 94720  
Affiliation: Department of Electrical Engg. and Computer Science University of California at Berkeley  
Abstract: The SPEC benchmark system has traditionally been used for evaluating computer architectures. However, this system is too general and does not accurately reflect the performance of architectures on domain-specific applications. Moreover, the CPU95 benchmark suite used in the SPEC system is compute-intensive, while many important domains of applications have memory intensive algorithms. In this work, we present a benchmarking methodology for such an application domain CAD for VLSI design. We have created a benchmark suite consisting of CAD applications from each stage in a typical VLSI design flow. To exercise the memory organization, each application is run on a sequence of input designs of increasing size. We observed that increasing the input size causes non-monotonic variations in the performance of different machines. We simulate the caches of the benchmarked architectures to assess the effect of memory organization on performance. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <institution> The Standard Perfomance Evaluation Corporation, </institution> <year> 1996. </year> <note> http://www.specbench.org. </note>
Reference-contexts: However the presence of extremely diverse application domains of computers poses a major problem in the interpretation of benchmark numbers. SPEC (Standard Performance Evaluation Corporation) <ref> [1] </ref> attempts to come up with a range of "typical" applications for benchmarking purposes. Since its first release in 1989, SPEC benchmarks have come a long way by incorporating more applications, increasing the input size, and making the benchmarking methodology more rigorous.
Reference: [2] <author> Anonymous et al., </author> <title> "A Measure of Transaction Processing Power," </title> <journal> Datamation, </journal> <month> Apr. </month> <year> 1985. </year>
Reference-contexts: We try to identify features of the memory organization of the machines that lead to differing performance characteristics for different applications and input sizes. Other benchmarks have been designed for specific application areas, e.g., SFS benchmark to measure performance of file servers, DebitCredit for benchmarking transaction processing system <ref> [2] </ref>, self-scaling benchmark for I/O performance analysis [3], and PAS [4] and PERFECT [5] for scientific computing, to name a few. However, to the best of our knowledge there has been no work in benchmarks in the domain of CAD applications.
Reference: [3] <author> P. M. Chen and D. A. Patterson, </author> <title> "A New Approach to I/O Performance Evaluation - Self-scaling I/O Benchmarks, Predicted I/O Performance," </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 12:4, </volume> <month> Nov. </month> <year> 1994. </year>
Reference-contexts: Other benchmarks have been designed for specific application areas, e.g., SFS benchmark to measure performance of file servers, DebitCredit for benchmarking transaction processing system [2], self-scaling benchmark for I/O performance analysis <ref> [3] </ref>, and PAS [4] and PERFECT [5] for scientific computing, to name a few. However, to the best of our knowledge there has been no work in benchmarks in the domain of CAD applications.
Reference: [4] <author> D. Bailey, J. Barton, T. Lasinski, and H. Simon, </author> <title> "The NAS Parallel Benchmarks," </title> <type> Tech. Rep. </type> <institution> RNR-91-002, NASA Ames Research Center, </institution> <month> Aug. </month> <year> 1991. </year>
Reference-contexts: Other benchmarks have been designed for specific application areas, e.g., SFS benchmark to measure performance of file servers, DebitCredit for benchmarking transaction processing system [2], self-scaling benchmark for I/O performance analysis [3], and PAS <ref> [4] </ref> and PERFECT [5] for scientific computing, to name a few. However, to the best of our knowledge there has been no work in benchmarks in the domain of CAD applications.
Reference: [5] <author> M. Barry et al., </author> <title> "The PERFECT Club: Effective Performance Evaluation of Supercomputers," </title> <booktitle> in Intl. J. Supercomputing Appl., </booktitle> <month> Dec. </month> <year> 1989. </year>
Reference-contexts: Other benchmarks have been designed for specific application areas, e.g., SFS benchmark to measure performance of file servers, DebitCredit for benchmarking transaction processing system [2], self-scaling benchmark for I/O performance analysis [3], and PAS [4] and PERFECT <ref> [5] </ref> for scientific computing, to name a few. However, to the best of our knowledge there has been no work in benchmarks in the domain of CAD applications.
Reference: [6] <author> S.-T. Cheng, G. York, and R. K. Brayton, "VL2MV: </author> <note> A Compiler from Verilog to BLIF-MV," </note> <month> Oct. </month> <year> 1993. </year> <title> Supplied documentation. </title>
Reference-contexts: The transistor level design is further simulated for critical path analysis. And finally transistors are mapped into rectilinear blocks using place and route tools. Keeping in mind the state of the art in electronic design methodology, we chose the following 4 six tools. 1. Hardware Compiler: VL2MV <ref> [6] </ref> compiles a Verilog description into a gate level netlist of finite state machines (FSMs) which preserves the system behavior defined in terms of simulated results. After creating the parse tree representing the control and data flow, semantic checking is performed and the hardware gates are generated.
Reference: [7] <author> R. K. Brayton et al., </author> <title> "VIS: A System for Verification and Synthesis," </title> <booktitle> in Proc. of the 8th International Conference on Computer Aided Verification, vol. 1102 of Lecture Notes in Computer Science, </booktitle> <pages> pp. 428-432, </pages> <publisher> Springer-Verlag, </publisher> <year> 1996. </year>
Reference-contexts: After creating the parse tree representing the control and data flow, semantic checking is performed and the hardware gates are generated. The underlying computation is largely symbolic with local memory accesses. 2. Formal Verification Tool: VIS <ref> [7] </ref> is a unified environment for formal verification, synthesis, and simulation of finite state systems. We chose the problem of combinational verification by building the BDD [8] representation of two circuits and comparing them. The major underlying computation is memory intensive.
Reference: [8] <author> R. Bryant, </author> <title> "Graph-based Algorithms for Boolean Function Manipulation," </title> <journal> IEEE Trans. Computers, </journal> <volume> vol. C-35, </volume> <pages> pp. 677-691, </pages> <month> Aug. </month> <year> 1986. </year>
Reference-contexts: The underlying computation is largely symbolic with local memory accesses. 2. Formal Verification Tool: VIS [7] is a unified environment for formal verification, synthesis, and simulation of finite state systems. We chose the problem of combinational verification by building the BDD <ref> [8] </ref> representation of two circuits and comparing them. The major underlying computation is memory intensive. We have benchmarked machines for equivalence checking with two kinds of underlying BDD computations random memory access [9] and localized memory access [10]. 3.
Reference: [9] <author> D. E. </author> <title> Long, "BDD Manipulation Library." Public software. </title> <institution> Carnegie Mellon University, </institution> <address> Pitts-burgh, PA, </address> <month> June </month> <year> 1993. </year> <month> ftp://emc.cs.cmu.edu/pub/bdd/bddlib.tar.Z. </month>
Reference-contexts: We chose the problem of combinational verification by building the BDD [8] representation of two circuits and comparing them. The major underlying computation is memory intensive. We have benchmarked machines for equivalence checking with two kinds of underlying BDD computations random memory access <ref> [9] </ref> and localized memory access [10]. 3. Logic Synthesis Tool: SIS [11] is a logic synthesis system for combinational and sequential circuits. <p> As mentioned earlier, the underlying data structure (BDDs) can be manipulated with either random or local memory access behavior. We make use of two BDD packages - CMU <ref> [9] </ref> and CAL [10] which have random and local memory access patterns respectively, to get two sets of results. The inputs were taken from MCNC and ISCAS benchmark sets. The performance ratios are shown in Figure 1.
Reference: [10] <author> J. V. Sanghavi, R. K. Ranjan, R. K. Brayton, and A. L. Sangiovanni-Vincentelli, </author> <title> "High Performance BDD Package Based on Exploiting Memory Hierarchy," </title> <booktitle> in Proc. of the Design Automation Conf., </booktitle> <address> (Las Vegas, NV), </address> <month> June </month> <year> 1996. </year>
Reference-contexts: We chose the problem of combinational verification by building the BDD [8] representation of two circuits and comparing them. The major underlying computation is memory intensive. We have benchmarked machines for equivalence checking with two kinds of underlying BDD computations random memory access [9] and localized memory access <ref> [10] </ref>. 3. Logic Synthesis Tool: SIS [11] is a logic synthesis system for combinational and sequential circuits. <p> As mentioned earlier, the underlying data structure (BDDs) can be manipulated with either random or local memory access behavior. We make use of two BDD packages - CMU [9] and CAL <ref> [10] </ref> which have random and local memory access patterns respectively, to get two sets of results. The inputs were taken from MCNC and ISCAS benchmark sets. The performance ratios are shown in Figure 1.
Reference: [11] <author> E. M. Sentovich, K. J. Singh, L. Lavagno, C. Moon, R. Murgai, A. Saldanha, H. Savoj, P. R. Stephan, R. K. Brayton, and A. L. Sangiovanni-Vincentelli, </author> <title> "SIS: A System for Sequential Cir 18 cuit Synthesis," </title> <type> Tech. Rep. </type> <institution> UCB/ERL M92/41, Electronics Research Lab, Univ. of California, Berkeley, </institution> <address> CA 94720, </address> <month> May </month> <year> 1992. </year>
Reference-contexts: The major underlying computation is memory intensive. We have benchmarked machines for equivalence checking with two kinds of underlying BDD computations random memory access [9] and localized memory access [10]. 3. Logic Synthesis Tool: SIS <ref> [11] </ref> is a logic synthesis system for combinational and sequential circuits.
Reference: [12] <author> A. Salz and M. Horowitz, "IRSIM: </author> <title> An Incremental MOS Switch-Level Simulator," </title> <booktitle> in Proc. of the Design Automation Conf., </booktitle> <pages> pp. 173-178, </pages> <year> 1989. </year>
Reference-contexts: We use a script that tries to optimize for area. The underlying computation was mainly symbolic with largely local memory accesses. 4. Switch Level Circuit Simulator: IRSIM <ref> [12] </ref> models the transistor as a bi-directional switch with a finite ON resistance and capacitances and simulates the resulting RC network using an event driven simulator. The main computation is dynamic partitioning of circuits involving integer operations, and computation of delay times and node voltages using floating point operations.
Reference: [13] <author> L. Nagel, </author> <title> "A Computer Program to Simulate Semiconductor Circuits," </title> <type> Tech. Rep. </type> <institution> UCB/ERL M75/520, Electronics Research Lab, University of California, Berkeley, CA94720, </institution> <month> May </month> <year> 1975. </year>
Reference-contexts: The main computation is dynamic partitioning of circuits involving integer operations, and computation of delay times and node voltages using floating point operations. Since all the computation is performed in isolated stages of the circuit, the memory accesses are mostly local in nature. 5. Transistor Level Circuit Simulator: SPICE <ref> [13] </ref> is a transistor level simulator.
Reference: [14] <author> C. Sechen, "Chip-planning, </author> <title> Placement, and Global Routing of Macro-cell Integrated Circuits using Simulated Annealing," </title> <journal> International Journal of Computer Aided VLSI Design, </journal> <volume> vol. 2, </volume> <pages> pp. 1-10, </pages> <year> 1990. </year>
Reference-contexts: Layout Generator: TimberWolfMC <ref> [14] </ref> uses simulated annealing to solve the floor-planning and placement problem for macro-cells . The underlying algorithm proceeds in two stages. In the first stage, simulated annealing is used to place the cells approximately. This involves a lot of floating point computations.
Reference: [15] <author> R. Jain, </author> <title> The Art of Computer Systems Performance Analysis. </title> <publisher> John Wiley and Sons, </publisher> <year> 1991. </year>
Reference-contexts: The larger the sample, the higher is the confidence level. To estimate the mean performance of a system with an accuracy of r% and a confidence level of 100 (1 ff)%, the needed number of 7 observations n is given by <ref> [15] </ref> as n = 100z ff s 2 where z ff = normal variate of the desired confidence level x = observed mean s = observed standard deviation We take a few observations and find the required number of iterations from the calculated mean and standard deviation.
Reference: [16] <author> SHADE Cache Simulator, </author> <year> 1996. </year> <month> 19 </month>
Reference-contexts: that for CAD applications with inputs that fit in the main memory, performance is a complex function of clock speed and cache organization. 3.2 Cache Simulation Results and Analysis To gain further insight into the performance of machines for CAD applications, we made use of a commercial cache simulator Shade <ref> [16] </ref>.
References-found: 16

