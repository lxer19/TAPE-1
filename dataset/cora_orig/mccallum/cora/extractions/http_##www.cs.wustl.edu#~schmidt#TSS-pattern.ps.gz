URL: http://www.cs.wustl.edu/~schmidt/TSS-pattern.ps.gz
Refering-URL: http://www.cs.wustl.edu/~schmidt/OOPSLA-95/html/papers.html
Root-URL: 
Email: fschmidt, harrisong@cs.wustl.edu np2@scorch.doc.ic.ac.uk  
Title: Thread-Specific Storage for C/C++ An Object Behavioral Pattern for Accessing per-Thread State Efficiently theory, multi-threading
Author: Douglas C. Schmidt Nat Pryce Timothy H. Harrison 
Note: In  
Address: St. Louis 1 Imperial College 2 St. Louis, MO, USA London, UK  
Affiliation: Dept. of Computer Science Department of Computing Washington University,  
Abstract: This paper will appear at the 4 th annual Pattern Languages of Programming conference held in Allerton Park, Illinois, September, 1997. Permission is granted to make copies of this paper for the PLoP '97 conference proceedings. Abstract This paper describes the Thread-Specific Storage pattern, which alleviates several problems with multi-threading performance and programming complexity. The Thread-Specific Storage pattern improves performance and simplifies multi-threaded applications by allowing multiple threads to use one logically global access point to retrieve thread-specific data without incurring locking overhead for each access. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> J. Eykholt, S. Kleiman, S. Barton, R. Faulkner, A. Shivalin-giah, M. Smith, D. Stein, J. Voll, M. Weeks, and D. Williams, </author> <title> Beyond Multiprocessing... Multithreading the SunOS Kernel, </title> <booktitle> in Proceedings of the Summer USENIX Conference, </booktitle> <address> (San Antonio, Texas), </address> <month> June </month> <year> 1992. </year>
Reference-contexts: For instance, by placing errno into thread-specific storage, each thread can reliably set and test the completion status of methods within that thread without using complex synchronization protocols. This eliminates locking overhead for data shared within a thread, which is faster than acquiring and releasing a mutex <ref> [1] </ref>. <p> unchanged regardless of whether the thread-specific or non-thread-specific form of Logger is used. 10 Known Uses The following are known uses of the Thread-Specific Storage pattern: * The errno mechanism implemented on OS platforms that support the POSIX and Solaris threading APIs are widely-used examples of the Thread-Specific Storage pattern <ref> [1] </ref>. In addition, the C runtime library provided with Win32 supports thread-specific errno. The Win32 GetLastError/SetLastError functions also implement the Thread-Specific Storage pattern. * In the Win32 operating system, windows are owned by threads [8].
Reference: [2] <author> R. G. Lavender and D. C. Schmidt, </author> <title> Active Object: an Object Behavioral Pattern for Concurrent Programming, in Pattern Languages of Program Design (J. </title> <editor> O. Coplien, J. Vlissides, and N. Kerth, eds.), </editor> <address> Reading, MA: </address> <publisher> Addison-Wesley, </publisher> <year> 1996. </year>
Reference-contexts: These threads may log the number and type of services performed. This logging mechanism could be accessed as a global Logger object utilizing Thread-Specific Storage. A simpler approach, however, would represent each worker thread as an Active Object <ref> [2] </ref> with an instance of the Logger stored internally. In this case, no overhead is required to access the Logger, as long as it is passed as a parameter to all functions in the Active Object.
Reference: [3] <author> F. Mueller, </author> <title> A Library Implementation of POSIX Threads Under UNIX, </title> <booktitle> in Proceedings of the Winter USENIX Conference, </booktitle> <address> (San Diego, CA), </address> <pages> pp. 2942, </pages> <month> Jan. </month> <year> 1993. </year>
Reference-contexts: This example is adapted from a publically available implementation <ref> [3] </ref> of POSIX Pthreads [4]. The thread state structure shown below contains the state of a thread: struct thread_state - // The thread-specific error number. int errno_; // Thread-specific data values. void *key_ [_POSIX_THREAD_KEYS_MAX]; // ...
Reference: [4] <author> IEEE, </author> <title> Threads Extension for Portable Operating Systems (Draft 10), </title> <month> February </month> <year> 1996. </year>
Reference-contexts: This example is adapted from a publically available implementation [3] of POSIX Pthreads <ref> [4] </ref>. The thread state structure shown below contains the state of a thread: struct thread_state - // The thread-specific error number. int errno_; // Thread-specific data values. void *key_ [_POSIX_THREAD_KEYS_MAX]; // ...
Reference: [5] <author> D. C. Schmidt and T. Harrison, </author> <title> Double-Checked Locking An Object Behavioral Pattern for Initializing and Accessing Thread-safe Objects Efficiently, in Pattern Languages of Program Design (R. </title> <editor> Martin, F. Buschmann, and D. Riehle, eds.), </editor> <address> Reading, MA: </address> <publisher> Addison-Wesley, </publisher> <year> 1997. </year>
Reference-contexts: This makes it hard to write portable code among UNIX and Win32 platforms. * Hard to use: Even with error checking omitted, the locking operations shown by the func example in Section 8.2 are complex and non-intuitive. This code is a C implementation of the Double-Checked Locking pattern <ref> [5] </ref>. It's instructive to compare this C implementation to the C++ version in Section 9.2.1 to observe the greater simplicity, clarity, and type-safety resulting from the use of C++ wrappers. * Non-type-safe: The POSIX Pthreads, Solaris, and Win32 thread-specific storage interfaces store pointers to thread-specific objects as void *'s. <p> It combines the operator-&gt; method with other C++ features like templates, inlining, and overloading. It also utilizes patterns like Double-Checked Locking Optimization <ref> [5] </ref> and Proxy [6, 7]). The Double-Checked Locking Optimization pattern is used in operator-&gt; to test the once flag twice in the code. Although multiple threads could access the same instance of TSS simultaneously, only one thread can validly create a key (i.e., via pthread key create). <p> The TSS template class shown in Section 8 serves as a Proxy [7, 6] that shields the libraries, frameworks, and applications from the implementation of thread-specific storage provided by OS thread libraries. 11 The Double-Checked Locking Optimization pattern <ref> [5] </ref> is commonly used by applications that utilize the Thread-Specific Storage pattern to avoid constraining the order of initialization for thread-specific storage keys. 12 Concluding Remarks Multi-threading an existing application often adds significant complexity to the software due to the additional con-currency control protocols needed to prevent race conditions and deadlocks
Reference: [6] <author> F. Buschmann, R. Meunier, H. Rohnert, P. Sommerlad, and M. Stal, </author> <title> Pattern-Oriented Software Architecture A System of Patterns. </title> <publisher> Wiley and Sons, </publisher> <year> 1996. </year>
Reference-contexts: It combines the operator-&gt; method with other C++ features like templates, inlining, and overloading. It also utilizes patterns like Double-Checked Locking Optimization [5] and Proxy <ref> [6, 7] </ref>). The Double-Checked Locking Optimization pattern is used in operator-&gt; to test the once flag twice in the code. Although multiple threads could access the same instance of TSS simultaneously, only one thread can validly create a key (i.e., via pthread key create). <p> For instance, each Task object implement in ACE [10] stores a cleanup hook in thread-specific storage. The TSS template class shown in Section 8 serves as a Proxy <ref> [7, 6] </ref> that shields the libraries, frameworks, and applications from the implementation of thread-specific storage provided by OS thread libraries. 11 The Double-Checked Locking Optimization pattern [5] is commonly used by applications that utilize the Thread-Specific Storage pattern to avoid constraining the order of initialization for thread-specific storage keys. 12 Concluding
Reference: [7] <author> E. Gamma, R. Helm, R. Johnson, and J. Vlissides, </author> <title> Design Patterns: Elements of Reusable Object-Oriented Software. </title> <address> Reading, MA: </address> <publisher> Addison-Wesley, </publisher> <year> 1995. </year>
Reference-contexts: It combines the operator-&gt; method with other C++ features like templates, inlining, and overloading. It also utilizes patterns like Double-Checked Locking Optimization [5] and Proxy <ref> [6, 7] </ref>). The Double-Checked Locking Optimization pattern is used in operator-&gt; to test the once flag twice in the code. Although multiple threads could access the same instance of TSS simultaneously, only one thread can validly create a key (i.e., via pthread key create). <p> In addition, ACE implements the type-safe thread-specific storage template wrappers described in Section 9.2. 11 Related Patterns Objects implemented with thread-specific storage are often used as per-thread Singletons <ref> [7] </ref>, e.g., errno is a per-thread Singleton. Not all uses of thread-specific storage are Singletons, however, since a thread can have multiple instances of a type allocated from thread-specific storage. For instance, each Task object implement in ACE [10] stores a cleanup hook in thread-specific storage. <p> For instance, each Task object implement in ACE [10] stores a cleanup hook in thread-specific storage. The TSS template class shown in Section 8 serves as a Proxy <ref> [7, 6] </ref> that shields the libraries, frameworks, and applications from the implementation of thread-specific storage provided by OS thread libraries. 11 The Double-Checked Locking Optimization pattern [5] is commonly used by applications that utilize the Thread-Specific Storage pattern to avoid constraining the order of initialization for thread-specific storage keys. 12 Concluding
Reference: [8] <author> C. Petzold, </author> <title> Programming Windows 95. </title> <publisher> Microsoft Press, </publisher> <year> 1995. </year>
Reference-contexts: In addition, the C runtime library provided with Win32 supports thread-specific errno. The Win32 GetLastError/SetLastError functions also implement the Thread-Specific Storage pattern. * In the Win32 operating system, windows are owned by threads <ref> [8] </ref>. Each thread that owns a window has a private message queue where the OS enqueues user-interface events.
Reference: [9] <author> J. Neider, T. Davis, and M. Woo, </author> <title> OpenGL Programming Guide: The Official Guide to Learning OpenGL, Release 1. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, MA, </address> <year> 1993. </year>
Reference-contexts: Each thread that owns a window has a private message queue where the OS enqueues user-interface events. API calls that retrieve the next message waiting to be processed dequeue the next message on the calling thread's message queue, which resides in thread-specific storage. * OpenGL <ref> [9] </ref> is a C API for rendering three-dimensional graphics. The program renders graphics in terms of polygons that are described by making repeated calls to the glVertex function to pass each vertex of the polygon to the library.
Reference: [10] <author> D. C. Schmidt, </author> <title> ACE: an Object-Oriented Framework for Developing Distributed Applications, </title> <booktitle> in Proceedings of the 6 th USENIX C++ Technical Conference, </booktitle> <address> (Cambridge, Mas-sachusetts), </address> <publisher> USENIX Association, </publisher> <month> April </month> <year> 1994. </year>
Reference-contexts: On the Win32 platform, the OpenGL library maintains a unique set of state variables in thread-specific storage for each thread using the library. * Thread-specific storage is used within the ACE network programming toolkit <ref> [10] </ref> to implement its error handling scheme, which is similar to the Logger approach described in Section 9.2.3. <p> Not all uses of thread-specific storage are Singletons, however, since a thread can have multiple instances of a type allocated from thread-specific storage. For instance, each Task object implement in ACE <ref> [10] </ref> stores a cleanup hook in thread-specific storage.
Reference: [11] <author> J. Ousterhout, </author> <title> Why Threads Are A Bad Idea (for most purposes), </title> <booktitle> in USENIX Winter Technical Conference, </booktitle> <address> (San Diego, CA), </address> <publisher> USENIX, </publisher> <month> Jan. </month> <year> 1996. </year>
Reference-contexts: is commonly used by applications that utilize the Thread-Specific Storage pattern to avoid constraining the order of initialization for thread-specific storage keys. 12 Concluding Remarks Multi-threading an existing application often adds significant complexity to the software due to the additional con-currency control protocols needed to prevent race conditions and deadlocks <ref> [11] </ref>. The Thread-Specific Storage pattern alleviates some of synchronization overhead and programming complexity by allowing multiple threads to use one logically global access point to retrieve thread-specific data without incurring locking costs for each access. Application threads use TS Object Proxies to access TS Objects.
Reference: [12] <author> H. Mueller, </author> <title> Patterns for Handling Exception Handling Successfully, </title> <journal> C++ Report, </journal> <volume> vol. 8, </volume> <month> Jan. </month> <year> 1996. </year>
Reference: [13] <author> N. Pryce, </author> <title> Type-Safe Session: An Object-Structural Pattern, </title> <booktitle> in Submitted to the 2 nd European Pattern Languages of Programming Conference, </booktitle> <month> July </month> <year> 1997. </year>
Reference: [14] <author> J. Gosling and F. Yellin, </author> <title> The Java Application Programming Interface Volume 2: Window Toolkit and Applets. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, MA, </address> <year> 1996. </year>
References-found: 14

