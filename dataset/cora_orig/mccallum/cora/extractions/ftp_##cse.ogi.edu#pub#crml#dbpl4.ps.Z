URL: ftp://cse.ogi.edu/pub/crml/dbpl4.ps.Z
Refering-URL: http://karna.cs.umd.edu:3264/people/godfrey/cites.html
Root-URL: 
Email: fegaras@cse.ogi.edu  
Title: Efficient Optimization of Iterative Queries  
Author: Leonidas Fegaras 
Address: Portland, OR 97291-1000.  
Affiliation: Department of Computer Science and Engineering Oregon Graduate Institute of Science Technology  
Abstract: This paper presents a new query algebra based on fold iterations that facilitates database implementation. An algebraic normalization algorithm is introduced that reduces any program expressed in this algebra to a canonical form that generates no intermediate data structures and has no more nested iterations than the initial program. Given any inductive data type, our system can automatically synthesize the definition of the fold operator that traverses instances of this type, and, more importantly, it can produce the necessary transformations for optimizing expressions involving this fold operator. Database implementation in our framework is controlled by user-defined mappings from abstract types to physical structures. The optimizer uses this information to translate abstract programs and queries into concrete algorithms that conform to the type transformation. Database query optimization can be viewed as a search over the reduced space of all canonical forms which are equivalent to the query after type transformation and normalization. The optimization space can be expanded to capture semantic information expressed as integrity constraints attached to types. This information may include specifications of materialized views and of alternative access paths. The contribution of this paper is twofold. First, a new efficient algebraic optimization algorithm is introduced, based on loop fusion and partial evaluation, that normalizes a large class of queries over a wide spectrum of bulk data structures. Second, an effective query optimizer is described that searches the limited space of equivalent canonical forms for optimal programs, using additional semantic information to generate more alternatives.
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> C. Beeri and Y. Kornatzky. </author> <title> Algebraic Optimization of Object-Oriented Query Languages. </title> <booktitle> In International Conference on Database Theory, Paris, France, </booktitle> <pages> pp 72-88. </pages> <publisher> Springer-Verlag, </publisher> <month> December </month> <year> 1990. </year> <note> LNCS 470. </note>
Reference-contexts: For example, transforming a join predicate into disjunctive normal form may trigger new join transformations. The normalization algorithm can be used for algebraic optimization in both the abstract and physical layers. In fact, it generalizes many algebraic optimization algorithms found in the database literature <ref> [10, 1] </ref>. <p> This is desirable since we want all operations over any data type to be treated uniformly, in a context of a simple universal optimization algorithm. Our fold operator is similar to, but more expressive than, the pump operator <ref> [1] </ref> and the structural recursion operator [3]. The difference is that our system can derive the fold definition for most data types automatically by examining the type details.
Reference: [2] <author> S. Bellantoni and S. Cook. </author> <title> A new Recursion-Theoretic Characterization of the Polynomial Time. </title> <booktitle> In Proceedings of the 24th Annual ACM Symposium on Theory of Computing, </booktitle> <address> Victoria, B.C., </address> <pages> pp 283-293, </pages> <month> May </month> <year> 1992. </year>
Reference-contexts: Even though the restriction that the intermediate results of recursion (i.e. the values of accumulative result variables) are not allowed to be traversed limits the expressiveness of safe programs, there are many useful programs that are still expressible. In fact, in <ref> [2] </ref>, a language that poses a similar restriction was proved to capture all polynomial-time programs 3 . 3 Our language cannot be exactly PTIME since we have a decision algorithm for equalities (see Section 5) and it is well-known that function equality is undecidable for this class. 9 3.2 The Normalization
Reference: [3] <author> V. Breazu-Tannen, P. Buneman, and S. Naqvi. </author> <title> Structural Recursion as a Query Language. </title> <booktitle> In Proceedings of the Third International Workshop on Database Programming Languages: Bulk Types and Persistent Data, </booktitle> <address> Nafplion, Greece, </address> <pages> pp 9-19. </pages> <publisher> Morgan Kaufmann Publishers, </publisher> <month> August </month> <year> 1991. </year> <month> 25 </month>
Reference-contexts: This is desirable since we want all operations over any data type to be treated uniformly, in a context of a simple universal optimization algorithm. Our fold operator is similar to, but more expressive than, the pump operator [1] and the structural recursion operator <ref> [3] </ref>. The difference is that our system can derive the fold definition for most data types automatically by examining the type details. <p> An example call to this join retrieves all employees working in the CSE department (this is a semijoin): join (employees, departments, (emp,dept):(emp.dno=dept.dno and dept.name="CSE"), (emp,dept):emp) A sufficient condition for a set fold being order-independent is f s being both commutative and idempotent <ref> [3] </ref>: Definition 8 (Commutative-idempotent function) A function f is commutative-idempotent if: 8m 8n 8s : f (m; f (n; s)) = f (n; f (m; s)) (commutativity) 8n 8s : f (n; f (n; s)) = f (n; s) (idempotence) For example, Insert is commutative-idempotent, while Cons is not.
Reference: [4] <author> W. Chin. </author> <title> Safe Fusion of Functional Expressions. </title> <booktitle> Proceedings of the ACM Symposium on Lisp and Functional Programming, </booktitle> <address> San Francisco, </address> <publisher> Califor-nia, </publisher> <pages> pp 11-20, </pages> <month> June </month> <year> 1992. </year>
Reference-contexts: Fortunately, this type of program improvement can be done at any stage either before or after program normalization. We therefore choose to ignore it at this phase. The normalization algorithm is both a loop fusion method <ref> [16, 4] </ref> that merges two cascaded iterations 1 into one, and an online partial evaluator [5] that specializes programs with respect to their static input.
Reference: [5] <author> C. Consel and O. Danvy. </author> <title> Tutorial Notes on Partial Evaluation. </title> <booktitle> In Proceedings of the Twentieth ACM Symposium on Principles of Programming Languages, </booktitle> <address> Charleston, South Carolina, </address> <pages> pp 493-501, </pages> <month> January </month> <year> 1993. </year>
Reference-contexts: We therefore choose to ignore it at this phase. The normalization algorithm is both a loop fusion method [16, 4] that merges two cascaded iterations 1 into one, and an online partial evaluator <ref> [5] </ref> that specializes programs with respect to their static input. Based upon a generic promotion theorem, the algorithm is aided by the explicit inductive structure of folds rather than searching for implicit structure in an analysis phase, as is done in most program transformation systems [6]. <p> In the first equation, fold T accumulates all results from map T using the ^ (and) operator. For example, for the type T defined as: T = list (range <ref> [0; 5] </ref>) where (x) length (x) 10 IfT g x is: fold list (():true; (a; r):0 a and a 5 and r) x and length (x) 10 Type checking in the presence of type restrictions requires theorem proving capabilities.
Reference: [6] <author> J. Darlington and R. Burstall. </author> <title> A System which Automatically Improves Programs. </title> <journal> Acta Informatica, </journal> <volume> 6(1) </volume> <pages> 41-60, </pages> <year> 1976. </year>
Reference-contexts: Based upon a generic promotion theorem, the algorithm is aided by the explicit inductive structure of folds rather than searching for implicit structure in an analysis phase, as is done in most program transformation systems <ref> [6] </ref>. The normalization algorithm devotes the same effort to all traversals, independent of the data structures they traverse. In our model there are no primitive types, such as integers or booleans; all types are user-defined data structures.
Reference: [7] <author> L. Fegaras. </author> <title> A Transformational Approach to Database System Implementation. </title> <type> PhD thesis, </type> <institution> Department of Computer Science, University of Mas-sachusetts, Amherst, </institution> <month> February </month> <year> 1993. </year> <note> Also appeared as CMPSCI Technical Report 92-68. </note>
Reference-contexts: The reduced number of program schemes is achieved by requiring that all structure traversals be expressed in terms of a very small number of stereotyped generic recursion schemes. We have only one traversal mechanism in our algebra: the fold operation <ref> [14, 8, 7] </ref>. Given any inductive data type (e.g. tuple, set, list, tree, boolean, and integer) our system is capable of automatically synthesizing the definition of the fold operator that traverses instances of this type. <p> The compiler should be able to accumulate these pieces of information and use them to synthesize the functions c and r 0 from r. A convenient tool for performing this task is compile-time reflection <ref> [7] </ref>. 8 Decomposition into Concrete Primitives Suppose that a query is normalized into the following canonical form: fold list (():fold list (():Zero; (a; r):Succ (r)) y; (a; r):Succ (r)) x and there are the following abstractions in the physical layer: append (x; y) = fold list (():y; (a; r):Cons (a; r)) <p> The cost of a variable is derived from statistical information while the cost of a single construction is `unit', which is a user-supplied constant. (A complete framework for specifying database statistics and for assigning costs to all variables in a canonical program is proposed in <ref> [7] </ref>.) Estimating costs for canonical programs is easier than for non-canonical programs, since the former do not materialize intermediate results and, therefore, they do not require selectivity estimations.
Reference: [8] <author> L. Fegaras, T. Sheard, and D. Stemple. </author> <title> Uniform Traversal Combinators: Definition, Use and Properties. </title> <booktitle> In Proceedings of the 11th International Conference on Automated Deduction (CADE-11), </booktitle> <address> Saratoga Springs, New York, </address> <pages> pp 148-162. </pages> <publisher> Springer-Verlag, </publisher> <month> June </month> <year> 1992. </year> <note> LNCS 607. </note>
Reference-contexts: The reduced number of program schemes is achieved by requiring that all structure traversals be expressed in terms of a very small number of stereotyped generic recursion schemes. We have only one traversal mechanism in our algebra: the fold operation <ref> [14, 8, 7] </ref>. Given any inductive data type (e.g. tuple, set, list, tree, boolean, and integer) our system is capable of automatically synthesizing the definition of the fold operator that traverses instances of this type.
Reference: [9] <author> L. Fegaras and D. Stemple. </author> <title> Using Type Transformation in Database System Implementation. </title> <booktitle> In Proceedings of the Third International Workshop on Database Programming Languages: Bulk Types and Persistent Data, </booktitle> <address> Nafplion, Greece, </address> <pages> pp 337-353. </pages> <publisher> Morgan Kaufmann Publishers, </publisher> <month> August </month> <year> 1991. </year>
Reference-contexts: We have reduced the search space by eliminating suboptimal goals, but we have also expanded it by adding more alternatives that correspond to additional semantic information. One important component of our algebraic query optimizer is type transformation <ref> [9] </ref>. In this framework we specify how an abstract data type is mapped into a concrete type (a data structure in the physical layer) by providing an abstraction function. This function, expressed in canonical form, maps any structure of the concrete type into a value of the abstract type. <p> That way the model designer does not have to worry about program efficiency and space utilization, but only to be concerned with expressing correct specification. In addition, this separation may offer more opportunities for optimization. One effective mechanism for separating the model from implementation is type transformation <ref> [9] </ref>. In this framework each abstract data type in the abstract program is mapped into a storage structure by an abstraction function. Definition 9 (Abstraction Function) Let T be an abstract type and S the type of a concrete storage structure.
Reference: [10] <author> J. C. Freytag and N. Goodman. </author> <title> On the Translation of Relational Queries into Iterative Programs. </title> <journal> ACM Transactions on Database Systems, </journal> <volume> 14(1) </volume> <pages> 1-27, </pages> <month> March </month> <year> 1989. </year>
Reference-contexts: For example, transforming a join predicate into disjunctive normal form may trigger new join transformations. The normalization algorithm can be used for algebraic optimization in both the abstract and physical layers. In fact, it generalizes many algebraic optimization algorithms found in the database literature <ref> [10, 1] </ref>. <p> For example: bounded (ff)[low : ff; high : ff; f : (ff; ff) ! boolean] = ff where (x) f (low; x) and f (x; high) range [low : nat; high : nat] = bounded (nat)[low; high; ] range1 = range <ref> [10; 20] </ref> ordered list (ff)[f : (ff; ff) ! boolean] = list (ff) where (x) ordered (x; f ) keyed set (ff; fi)[f : (ff) ! fi] = set (ff) where (x) card (x) = card (image (f ) x) persons = keyed set (person; nat)[p:(p:ssn)] where ordered (x; f) is
Reference: [11] <author> G. Malcolm. </author> <title> Homomorphisms and Promotability. </title> <booktitle> In Mathematics of Program Construction, </booktitle> <pages> pp 335-347. </pages> <publisher> Springer-Verlag, </publisher> <month> June </month> <year> 1989. </year> <note> LNCS 375. </note>
Reference-contexts: The normalization algorithm will describe how these new accumulating functions can be calculated. The promotion theorem for folds has appeared in the literature using various notations <ref> [11, 12] </ref>: Theorem 1 (The Fold Promotion Theorem) 8i : i ffi E T i (g) = g ffi f i ) g ffi fold T (f ) = fold T () Proof: Let = gffifold T (f ) and C i a constructor of T .
Reference: [12] <author> E. Meijer, M. Fokkinga, and R. Paterson. </author> <title> Functional Programming with Bananas, Lenses, Envelopes and Barbed Wire. </title> <booktitle> In Proceedings of the 5th ACM Conference on Functional Programming Languages and Computer Architecture, </booktitle> <address> Cambridge, MA, </address> <pages> pp 124-144, </pages> <month> August </month> <year> 1991. </year> <note> LNCS 523. </note>
Reference-contexts: The normalization algorithm will describe how these new accumulating functions can be calculated. The promotion theorem for folds has appeared in the literature using various notations <ref> [11, 12] </ref>: Theorem 1 (The Fold Promotion Theorem) 8i : i ffi E T i (g) = g ffi f i ) g ffi fold T (f ) = fold T () Proof: Let = gffifold T (f ) and C i a constructor of T . <p> The following corollary says that there is a unique way of expressing a function as a fold <ref> [12] </ref>.
Reference: [13] <author> P. Selinger, M. Astrahan, D. Chamberlin, R. Lorie, and T. Price. </author> <title> Access Path Selection in a Relational Database Management System. </title> <booktitle> Proceedings of the ACM-SIGMOD International Conference on Management of Data, </booktitle> <address> Boston, Massachusetts, </address> <pages> pp 23-34, </pages> <month> May </month> <year> 1979. </year>
Reference-contexts: For example, queries in the relational model are expressed declaratively, without any concern about efficiency, relying on the query optimizer to select the best evaluation plan among a variety of available access plans and algorithms <ref> [13] </ref>. 1 Modern database applications require more advanced data structures and more expressive operations than those provided by the relational model. If complex storage structures are mapped into relational tables then semantic information is often lost.
Reference: [14] <author> T. Sheard and L. Fegaras. </author> <title> A Fold for All Seasons. </title> <booktitle> Sixth Conference on Functional Programming Languages and Computer Architecture, Copen-hagen, Denmark, </booktitle> <pages> pp 233-242, </pages> <month> June </month> <year> 1993. </year>
Reference-contexts: The reduced number of program schemes is achieved by requiring that all structure traversals be expressed in terms of a very small number of stereotyped generic recursion schemes. We have only one traversal mechanism in our algebra: the fold operation <ref> [14, 8, 7] </ref>. Given any inductive data type (e.g. tuple, set, list, tree, boolean, and integer) our system is capable of automatically synthesizing the definition of the fold operator that traverses instances of this type.
Reference: [15] <author> S. Shenoy and Z. Ozsoyoglu. </author> <title> Design and Implementation of a Semantic Query Optimizer. </title> <journal> ACM Transactions on Knowledge and Data Engineering, </journal> <volume> 1(3) </volume> <pages> 344-361, </pages> <month> September </month> <year> 1989. </year>
Reference-contexts: That way, the program optimizer can use semantic information directly to make intelligent decisions. Consequently, restrictions on data values, such as integrity constraints attached to the database state, should be provided explicitly as part of the schema, so that they may be used to generate alternatives during optimization <ref> [15] </ref>. There have been many proposals for query algebras that are more expressive than the relational algebra. Much research into these designs has been guided by the belief that the more the expressiveness (functionality) of a language the more difficult the program optimization task becomes.
Reference: [16] <author> P. Wadler. </author> <title> Deforestation: Transforming Programs to Eliminate Trees. </title> <booktitle> Proceedings of the 2nd European Symposium on Programming, Nancy, France, </booktitle> <pages> pp 344-358, </pages> <month> March </month> <year> 1988. </year> <note> LNCS 300. 26 </note>
Reference-contexts: Fortunately, this type of program improvement can be done at any stage either before or after program normalization. We therefore choose to ignore it at this phase. The normalization algorithm is both a loop fusion method <ref> [16, 4] </ref> that merges two cascaded iterations 1 into one, and an online partial evaluator [5] that specializes programs with respect to their static input.
References-found: 16

