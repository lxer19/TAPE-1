URL: ftp://enws318.eas.asu.edu/pub/rao/serial.ps
Refering-URL: http://enuxsa.eas.asu.edu:80/~ihrig/
Root-URL: 
Email: email: f rao biplav ihrig g@asu.edu  
Title: A Candidate Set based analysis of Subgoal Interactions in conjunctive goal planning  
Author: Subbarao Kambhampati Laurie Ihrig and Biplav Srivastava 
Web: WWW: http://rakaposhi.eas.asu.edu:8001/yochan.html  
Address: Tempe AZ 85287-5406  
Affiliation: Department of Computer Science and Engineering Arizona State University,  
Abstract: Subgoal interactions have received considerable attention in AI Planning. Earlier analyses by Korf [11] and Joslin and Roach [6] were done in terms of the topology of the space of world states. More recent analyses by Barrett and Weld [1] and Veloso and Blythe [14] were done in terms of the nature of the planner. In this paper, we will argue that subgoal interactions are best understood in terms of the candidate sets of the plans for the individual subgoals. We will describe a generalized representation for partial plans that applies to a large class of refinement planners, and discuss the notion of mergeability and serial extensibility of these partial plans. The concepts of independence and serializability of subgoals are derived by generalizing mergeability and serial extensibility over classes of partial plans. Unlike previous work, our analysis also applies to multi-method refinement planners such as UCP [7]. We will show that all existing characterizations of serializability differ only in terms of the specific class of partial plans that they implicitly address. Finally, we will use our interaction analysis to explore factors affecting the selection of a refinement planner for a given domain. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> A. Barrett and D. Weld. </author> <title> Partial Order Planning: Evaluating Possible Efficiency Gains. </title> <journal> Artificial Intelligence, </journal> <volume> Vol. 67, No. 1, </volume> <year> 1994. </year>
Reference-contexts: We Eric Jacopin and the AIPS reviewers for their critical comments. not readily generalize to planners that do not search in the space of states. Barrett and Weld <ref> [1] </ref> extended Korf's analysis by shifting the emphasis from the state space characterization to the nature of the planner that is used to solve the problems. They showed that a given set of subgoals may be serializable for a plan space planner while being non-serializable for a state space planner. <p> When there are multiple subgoals, the chance of picking the correct goal order is low and thus serializability does not imply improvements in planning cost. Following Barrett and Weld <ref> [1] </ref>, we thus further extend the notion of serializability to consider trivial and laborious serializability. Definition 5 (Serialization Order [1]) Given a set of n subgoals g 1 ; g 2 : : : g n , a permutation on these subgoals is considered a serialization order (modulo a class of <p> When there are multiple subgoals, the chance of picking the correct goal order is low and thus serializability does not imply improvements in planning cost. Following Barrett and Weld <ref> [1] </ref>, we thus further extend the notion of serializability to consider trivial and laborious serializability. Definition 5 (Serialization Order [1]) Given a set of n subgoals g 1 ; g 2 : : : g n , a permutation on these subgoals is considered a serialization order (modulo a class of plans P), if every plan for achieving [1] can be serially extended to [2] and any resulting plan can <p> Definition 5 (Serialization Order <ref> [1] </ref>) Given a set of n subgoals g 1 ; g 2 : : : g n , a permutation on these subgoals is considered a serialization order (modulo a class of plans P), if every plan for achieving [1] can be serially extended to [2] and any resulting plan can be serially extended [3] and so on. <p> t 1 , with the IPC P uton (B; C) On (B;C) t 1 is serially extensible with respect to On (B; C); although the plan t 0 fl P uton (B; C) t 1 , with the same IPC is not. 5.2 Barrett and Weld's Serializability Barett and Weld <ref> [1] </ref> extended Korf's [11] subgoal interaction analysis to plan space planners, and showed that problems like sussman anomaly are serializable for the partial order planner SNLP. <p> This is not useful in and of itself if there is no (domain-independent) refinement planner that can generate exactly that class of plans. Consider, for example, the artificial domain shown below (originally described as the D fl S 1 C 2 domain by Barrett and Weld <ref> [1] </ref>): D fl S 1 C 1 domain of Barrett and Weld Op Prec Add Del A 1 A 2 All problems have the initial state where all I i and G fl are true. <p> If we have to pick a plan for the first subgoal without knowing what the next subgoal is going to be, we are still better off in general picking a less constrained partial plan. The empirical results of Barrett and Weld <ref> [1] </ref> in domains that are laboriously serializable for all their planners, do support this view to some extent. Although less constrained plans are more likely to be serially extensible, more constrained plans do have their advantages. They are typically easier to ``handle'' in terms of consistency and terminations checks [10].
Reference: [2] <author> D. Chapman. </author> <title> Planning for conjunctive goals. </title> <journal> Artificial Intelligence, </journal> <volume> 32:333--377, </volume> <year> 1987. </year>
Reference-contexts: Point Truth Constraints: A point truth constraint (PTC) is specified as a 2-tuple: hp@ti. Syntactically, it demands that the condition p be necessarily true <ref> [2] </ref> in the situation before the step t. Semantically, it constrains all solutions of the partial plan to have p true in the state in which the operator corresponding to t is executed. <p> Definition 5 (Serialization Order [1]) Given a set of n subgoals g 1 ; g 2 : : : g n , a permutation on these subgoals is considered a serialization order (modulo a class of plans P), if every plan for achieving [1] can be serially extended to <ref> [2] </ref> and any resulting plan can be serially extended [3] and so on. The set of subgoals are considered trivially serializable if all the permutations correspond to serialization orders, and are considered laboriously serializable if a significant number of permutations ( &gt; 1 n ) correspond to non-serialization orderings. <p> fl P uton (B; C) fl P uton (A; B) t 1 (which happens to be a non-minimal solution). 5 We note that the protected plans made by a causal link planner such as SNLP are more constrained than the unprotected plans made by non-causal link planners such as TWEAK <ref> [2] </ref> and UA [13], or planners that use disjunctive 5 On the other hand, the one way rocket problem is not seri-alizable even without the protection restriction; the critical issue for this problem is the prefix plan requirement. <p> In particular, similar performance tradeoffs would be observed if the planners being compared were both state-space or both plan-space planners (e.g., one being TWEAK <ref> [2] </ref> and the other being SNLP), as long as one planner uses protections and the other doesn't. 6 Factors Influencing the Selection of a Refinement Planner One of the prime motivations for understanding subgoal interactions in refinement planning is to see if such an understanding would help us in selecting the
Reference: [3] <author> R. Fikes and N. Nilsson. </author> <title> STRIPS: A new approach to the application of theorem proving to problem solving. In Readings in Planning. </title> <publisher> Morgan Kaufmann, </publisher> <year> 1990. </year>
Reference-contexts: of n subgoals g 1 ; g 2 : : : g n , a permutation on these subgoals is considered a serialization order (modulo a class of plans P), if every plan for achieving [1] can be serially extended to [2] and any resulting plan can be serially extended <ref> [3] </ref> and so on. The set of subgoals are considered trivially serializable if all the permutations correspond to serialization orders, and are considered laboriously serializable if a significant number of permutations ( &gt; 1 n ) correspond to non-serialization orderings.
Reference: [4] <author> M. Ginsberg. </author> <title> Approximate Planning. </title> <journal> Artificial Intelligence, special issue on Planning and Scheduling. </journal> <volume> Vol. 76. </volume> <year> 1995. </year>
Reference-contexts: Three well known refinement operations are: Forward State Space Refinement (FSS), Backward State Space Refinement (BSS) and Plan 2 In <ref> [4] </ref>, Ginsberg argues for an elimination of this separation saying that a ``good'' plan will have a large candidate set most of which will be able to achieve the goals of the problem. Space Refinement (PS).
Reference: [5] <author> L. Ihrig and S. Kambhampati. </author> <title> On the Relative Utility of Plan-space vs. </title> <note> State-space planning in a case-based framework ASU CSE TR 94-006; Dec 1994. (Submitted for publication) </note>
Reference-contexts: more conducive to efficient planning is true in general however when 6 If we are considering case-based planning, rather than generative planning, then generating and storing partial plans with fewer constraints is more likely to be a win, as they can be reused and extended in more novel situations; see <ref> [5] </ref>. the domain contains a set of goals, not all of which are se-rializable with respect to any one subclass of plans. To see this, consider the domain below which is similar to the domain D fl S 1 C 2 except for the augmented delete lists of the actions.
Reference: [6] <author> D. Joslin and J. Roach. </author> <title> A Theoretical Analysis of Conjunctive Goal Problems. Research Note, </title> <journal> Artificial Intelligence, </journal> <volume> Vol. 41, </volume> <year> 1989/90. </year>
Reference-contexts: Proposition 1 (Korf's Serializability) Two subgoals g 1 and g 2 are Korf-Serializable, if they are serializable with respect to the class of protected prefix plans. 3 Joslin and Roach <ref> [6] </ref> give a similar analysis of subgoal interactions in terms of the state space graph. In particular, they consider the state transition graph of the domain, and identify each subgoal with a subgraph of the transition graph (where all the states in that subgraph satisfy that goal).
Reference: [7] <author> S. Kambhampati and B. Srivastava. </author> <title> Universal Classical Planner: An algorithm for unifying state space and plan space approaches. </title> <booktitle> In Current Trends in AI Planning: EWSP 95, </booktitle> <publisher> IOS Press, </publisher> <year> 1995. </year>
Reference-contexts: Given that there are a great variety of refinement planners (c.f. <ref> [10, 7] </ref>), characterization of subgoal interactions that depend on the details of the planners tie us to specific brand-name planners in terms of which the analysis is done, and make it hard to see the essential structure of the interactions. <p> Such an analysis has hitherto been impossible since the plan representations used by different types of planners have been incomparable. More recently, as part of our efforts to develop a common framework for refinement planning <ref> [10, 7] </ref>, we have developed a general representation for partial plans that is suitable for most classical refinement planners, including state-space, plan-space, goal protection oriented, and means-ends analysis planners. <p> It is easy to see that as long as a planner uses only refinement operators that are complete, it never has to backtrack over the application of a refinement operator. In <ref> [7] </ref>, we showed that state-space planning and plan-space planning 1 For a more formal development of the refinement search semantics of partial plans, see [8, 10] approaches can essentially be modeled as different varieties of refinement operators operating on the same partial plan representation. 2.1 Representation of partial plans In this <p> Optionally, an IPC t 4 s t 3 can also be added to the plan to protect this establishment with respect to further step additions. A more complete discussion of these three types of refinements and their many variations can be found in <ref> [7] </ref>. If a planner uses FSS or BSS refinement alone, it is called a pure state-space planner, and if it uses a PS refinement alone, it is called a pure plan-space planner. <p> This removes the strong distinctions between state-space and plan-space planners, and allows planners that use multiple refinements. In <ref> [7] </ref>, we describe a planner called UCP that allows arbitrary interleaving of refinements, and show that it leads to performance improvements over pure state-space and plan-space planners. 2.4 Classification of Partial Plans The plan representation discussed in this section is fairly general to allow many varieties of plans. <p> This distinction may seem artificial given that most traditional planners use the same refinement strategy to generate the first subplan as well as to extend it. However, the distinction becomes more useful when we consider planners which can use multiple refinements, such as UCP <ref> [7] </ref>. For example, we noted that the plan P 1 : t 0 P uton (B; C) t 1 for subgoal On (B; C) in the suss-man anomaly is serially extensible with respect to subgoal On (A; B). <p> and the other doesn't. 6 Factors Influencing the Selection of a Refinement Planner One of the prime motivations for understanding subgoal interactions in refinement planning is to see if such an understanding would help us in selecting the right type of refinement planner (including multi-method refinement planners such as UCP <ref> [7] </ref>) for a given domain. In this section, we will use our analysis of subgoal interactions to explore the various factors that affect this decision. <p> Because he and hf conditions are deleted by many steps, the subplans for individual top-level goals will have many interactions, even though the overall plans are all serially extensible. We tested this domain on several instantiations of UCP <ref> [7] </ref> that generate different subclasses of plans, including prefix plans (UCP-FSS), protected elastic plans (UCP-PSS) and blocked plans (UCP-BLK). The results are shown in the plot in Figure 3.
Reference: [8] <author> S. Kambhampati. </author> <title> Refinement search as a unifying framework for analyzing planning algorithms. </title> <booktitle> In Proc. </booktitle> <address> KR-94, </address> <month> May </month> <year> 1994. </year>
Reference-contexts: Refinement planners <ref> [10, 8] </ref> attempt to solve a planning problem by navigating the space of sets of potential solutions (ground operator sequences). The potential solution sets are represented and manipulated in the form of ``partial plans.'' 1 Syntactically, a partial plan P can be seen as a set of constraints. <p> In [7], we showed that state-space planning and plan-space planning 1 For a more formal development of the refinement search semantics of partial plans, see <ref> [8, 10] </ref> approaches can essentially be modeled as different varieties of refinement operators operating on the same partial plan representation. 2.1 Representation of partial plans In this section, we will develop a syntactic and semantic representation of partial plans that is adequate to support both state-space and plan-space refinements. <p> The semantic notion of the candidate set of the partial plan is tightly related to the syntactic notion of safe ground linearizations <ref> [10, 8] </ref>. Specifically, safe ground linearizations correspond to minimal length candidates (or simply ``minimal candidates'') of the partial plan [10]. If a partial plan has no safe ground linearizations, it has an empty candidate set.
Reference: [9] <author> S. Kambhampati. </author> <title> Multi-Contributor Causal Structures for Planning: A Formalization and Evaluation. </title> <journal> Artificial Intelligence, </journal> <volume> Vol. 69, </volume> <year> 1994. </year> <pages> pp. 235-278. </pages>
Reference-contexts: Since by Korf's original definition, both these problems are non-serializable, and thus indistinguishable, we note that by considering serializability in terms of classes of plans, we can make finer-grained distinctions among different problems. protections (e.g. multi-contributor causal links) such as MP and MP-I <ref> [9] </ref>. Thus, there may be domains with subgoals that are not serializable with respect to SNLP but are serializable with respect to these latter planners. ART-MD-RD, first described in [9], and shown below, is one such domain: ART-MD-RD domain from [9] Op Prec Add Del A i (i even) I i <p> classes of plans, we can make finer-grained distinctions among different problems. protections (e.g. multi-contributor causal links) such as MP and MP-I <ref> [9] </ref>. Thus, there may be domains with subgoals that are not serializable with respect to SNLP but are serializable with respect to these latter planners. ART-MD-RD, first described in [9], and shown below, is one such domain: ART-MD-RD domain from [9] Op Prec Add Del A i (i even) I i ; he G i ; hf fI j jj &lt; ig [ fheg A i (i odd) I i ; hf G i ; he fI j jj &lt; <p> protections (e.g. multi-contributor causal links) such as MP and MP-I <ref> [9] </ref>. Thus, there may be domains with subgoals that are not serializable with respect to SNLP but are serializable with respect to these latter planners. ART-MD-RD, first described in [9], and shown below, is one such domain: ART-MD-RD domain from [9] Op Prec Add Del A i (i even) I i ; he G i ; hf fI j jj &lt; ig [ fheg A i (i odd) I i ; hf G i ; he fI j jj &lt; ig [ fhf g To see this, consider a problem where
Reference: [10] <author> S. Kambhampati, C. Knoblock and Q. Yang. </author> <title> Planning as Refinement Search: A Unified framework for evaluating design tradeoffs in partial order planning. </title> <journal> Artificial Intelligence special issue on Planning and Scheduling. </journal> <volume> Vol. 76. </volume> <year> 1995. </year>
Reference-contexts: Given that there are a great variety of refinement planners (c.f. <ref> [10, 7] </ref>), characterization of subgoal interactions that depend on the details of the planners tie us to specific brand-name planners in terms of which the analysis is done, and make it hard to see the essential structure of the interactions. <p> Such an analysis has hitherto been impossible since the plan representations used by different types of planners have been incomparable. More recently, as part of our efforts to develop a common framework for refinement planning <ref> [10, 7] </ref>, we have developed a general representation for partial plans that is suitable for most classical refinement planners, including state-space, plan-space, goal protection oriented, and means-ends analysis planners. <p> Refinement planners <ref> [10, 8] </ref> attempt to solve a planning problem by navigating the space of sets of potential solutions (ground operator sequences). The potential solution sets are represented and manipulated in the form of ``partial plans.'' 1 Syntactically, a partial plan P can be seen as a set of constraints. <p> In [7], we showed that state-space planning and plan-space planning 1 For a more formal development of the refinement search semantics of partial plans, see <ref> [8, 10] </ref> approaches can essentially be modeled as different varieties of refinement operators operating on the same partial plan representation. 2.1 Representation of partial plans In this section, we will develop a syntactic and semantic representation of partial plans that is adequate to support both state-space and plan-space refinements. <p> (the former violates the contiguity constraint t 0 fl t 1 , and the latter violates the interval preservation constraint t 3 r 2.2 Goal Achievement A ground linearization is said to be a safe ground linearization if it syntactically satisfies all the contiguity constraints, and the interval preservation constraints <ref> [10] </ref>. The semantic notion of the candidate set of the partial plan is tightly related to the syntactic notion of safe ground linearizations [10, 8]. Specifically, safe ground linearizations correspond to minimal length candidates (or simply ``minimal candidates'') of the partial plan [10]. <p> The semantic notion of the candidate set of the partial plan is tightly related to the syntactic notion of safe ground linearizations <ref> [10, 8] </ref>. Specifically, safe ground linearizations correspond to minimal length candidates (or simply ``minimal candidates'') of the partial plan [10]. If a partial plan has no safe ground linearizations, it has an empty candidate set. <p> the contiguity constraints, and the interval preservation constraints <ref> [10] </ref>. The semantic notion of the candidate set of the partial plan is tightly related to the syntactic notion of safe ground linearizations [10, 8]. Specifically, safe ground linearizations correspond to minimal length candidates (or simply ``minimal candidates'') of the partial plan [10]. If a partial plan has no safe ground linearizations, it has an empty candidate set. <p> Although less constrained plans are more likely to be serially extensible, more constrained plans do have their advantages. They are typically easier to ``handle'' in terms of consistency and terminations checks <ref> [10] </ref>. Given a domain containing subgoals that are trivially serializable for two classes of plans P 1 and P 2 , it can be more efficient to do planning with the more constrained class of plans.
Reference: [11] <author> R. Korf. </author> <title> Planning as Search: A Quantitative Approach. </title> <journal> Artificial Intelligence, </journal> <volume> Vol. 33, </volume> <year> 1987. </year>
Reference-contexts: 1 Introduction One of the important ways of characterizing the complexity of planning in a domain involves analyzing the interrelation between the subgoals that arise in the problems in that domain. Korf's 1987 paper <ref> [11] </ref> characterized a set of subgoals as independent, serializable or non-serializable, and argued that the cost of planning increases as the subgoals go from independent to non-serializable. <p> This leads to the notion of optimal parallelizability. The optimality and efficiency restrictions on parallelizability can of course be combined. In fact, Korf's definition of subgoal independence <ref> [11] </ref>, implies optimal and trivial parallelizability of all subgoals. <p> In this section, we will explain how our characterization subsumes the existing work by identifying the specific classes of plans over which the existing characterizations of subgoal interactions are implicitly based. 5.1 Korf's Subgoal Interactions Korf <ref> [11] </ref> defines two subgoals to be serializable if there exists an ordering among the subgoals such that they can be planned for sequentially, such that once the first goal is achieved, the agent never passes through a state where the first goal is violated. 3 The Sussman anomaly has non-serializable subgoals <p> with the IPC P uton (B; C) On (B;C) t 1 is serially extensible with respect to On (B; C); although the plan t 0 fl P uton (B; C) t 1 , with the same IPC is not. 5.2 Barrett and Weld's Serializability Barett and Weld [1] extended Korf's <ref> [11] </ref> subgoal interaction analysis to plan space planners, and showed that problems like sussman anomaly are serializable for the partial order planner SNLP.
Reference: [12] <author> D. McAllester and D. Rosenblitt. </author> <title> Systematic Nonlinear Planning. </title> <booktitle> In Proc. 9th AAAI, </booktitle> <year> 1991. </year>
Reference: [13] <author> S. Minton, J. Bresina and M. Drummond. </author> <title> Total Order and Partial Order Planning: a comparative analysis. </title> <note> Journal of Artificial Intelligence Research 2 (1994) 227-262. </note>
Reference-contexts: (B; C) fl P uton (A; B) t 1 (which happens to be a non-minimal solution). 5 We note that the protected plans made by a causal link planner such as SNLP are more constrained than the unprotected plans made by non-causal link planners such as TWEAK [2] and UA <ref> [13] </ref>, or planners that use disjunctive 5 On the other hand, the one way rocket problem is not seri-alizable even without the protection restriction; the critical issue for this problem is the prefix plan requirement.
Reference: [14] <author> M. Veloso and J. Blythe. Linkability: </author> <title> Examining causal link commitments in partial-order planning. </title> <booktitle> Proceedings of AIPS-94, </booktitle> <year> 1994. </year>
Reference-contexts: They showed that a given set of subgoals may be serializable for a plan space planner while being non-serializable for a state space planner. Veloso and Blythe extend this planner based analysis of subgoal interactions by defining a complementary characterization of subgoal interactions they call ``linkability'' <ref> [14] </ref>, arguing that a given problem may be easily linkable for state space planners, while being laboriously linkable for plan space planners. <p> This difficulty goes away when we restrict our attention to the class of unprotected elastic plans. In <ref> [14] </ref>, Veloso and Blythe also provide a range of domains where protection commitments become the critical issues with respect to serializability.
Reference: [15] <author> Q. Yang, D. Nau and J. Hendler. </author> <title> Merging separately generated plans with restricted interactions. </title> <journal> Computational Intelligence, </journal> <volume> 8(2) </volume> <pages> 648-676, </pages> <month> February </month> <year> 1992 </year>
Reference-contexts: Simple mergeability essentially ensures that the plans can be merged without adding any new steps, or combining existing steps (thus bounding the amount of effort required in the merging phase). In contrast, the merging involving addition and combination of steps can be as costly as planning itself <ref> [15] </ref>. Even simple mergeability can lead to costly merging phases (as a possibly exponential number of combined linearizations of the two plans need to be considered). Trivial mergeability is the most restrictive as it requires that the merging operation only involve unioning the constraint sets of the two plans. <p> For parallelization to be a win, the cost of merging should be small. The cost depends upon the type of merging (trivial, simple or non-simple). While trivial mergeability takes constant time, and simple mergeability can be NP-hard <ref> [15] </ref>, merging involving the addition and deletion of tasks can be as costly as planning itself.
References-found: 15

