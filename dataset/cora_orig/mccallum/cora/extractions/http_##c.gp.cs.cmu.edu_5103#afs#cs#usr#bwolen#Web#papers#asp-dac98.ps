URL: http://c.gp.cs.cmu.edu:5103/afs/cs/usr/bwolen/Web/papers/asp-dac98.ps
Refering-URL: http://c.gp.cs.cmu.edu:5103/afs/cs.cmu.edu/user/bwolen/Web/publications.html
Root-URL: http://www.cs.cmu.edu
Title: Space- and Time-Efficient BDD Construction via Working Set Control  
Author: Bwolen Yang Yirng-An Chen Randal E. Bryant David R. O'Hallaron 
Address: Pittsburgh, PA 15213. USA  
Affiliation: Computer Science Department Carnegie Mellon University  
Abstract: Binary decision diagrams (BDDs) have been shown to be a powerful tool in formal verification. Efficient BDD construction techniques become more important as the complexity of protocol and circuit designs increases. This paper addresses this issue by introducing three techniques based on working set control. First, we introduce a novel BDD construction algorithm based on partial breadth-first expansion. This approach has the good memory locality of the breadth-first BDD construction while maintaining the low memory overhead of the depth-first approach. Second, we describe how memory management on a per-variable basis can improve spatial locality of BDD construction at all levels, including expansion, reduction, and rehashing. Finally, we introduce a memory compacting garbage collection algorithm to remove unreachable BDD nodes and minimize memory fragmentation. Experimental results show that when the applications fit in physical memory, our approach has speedups of up to 1.6 in comparison to both depth-first (CUDD) and breadth-first (CAL) packages. When the applications do not fit into physical memory, our approach outperforms both CUDD and CAL by up to an order of magnitude. Furthermore, the good memory locality and low memory overhead of this approach has enabled us to be the first to have successfully constructed the entire C6288 multiplication circuit from the ISCAS85 benchmark set using only conventional BDD representations. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> R. Ashar and M. Cheong. </author> <title> Efficient breadth-first manipulation of binary decision diagrams. </title> <booktitle> In Proceedings of the International Conference on Computer-Aided Design, </booktitle> <pages> pages 622627, </pages> <month> November </month> <year> 1994. </year>
Reference-contexts: This result demonstrates that our approach has very little memory overhead. As far as we know, this is the first time that the entire C6288 circuit has been built using conventional BDD representations. VI. RELATED WORK There are many research efforts based on breadth-first BDD construction <ref> [14, 15, 1, 10, 18] </ref>. However, none of these propose how to bound the memory overhead of the breadth-first construction. <p> Note that this hybrid is similar to the mixed depth-first and breadth-first approach that prunes unnecessary recursion branches for the quantification and relational product operations [18]. SMV [13]'s BDD package uses mark-and-sweep garbage collector without memory compaction. In <ref> [15, 1, 17] </ref>, memory compaction is used to avoid memory fragmentation. These three approaches are all based on reference counting. In [15], the compaction algorithm is stable (i.e., linear ordering of the nodes is maintained) and does not require additional memory. Our approach is quite similar to this. <p> These three approaches are all based on reference counting. In [15], the compaction algorithm is stable (i.e., linear ordering of the nodes is maintained) and does not require additional memory. Our approach is quite similar to this. In <ref> [1] </ref>, the garbage collection uses a free-list and when memory fragmentation becomes high, a separate memory compaction algorithm based on copying is used. In [17], garbage collection phase is also free-list based and memory compaction is performed after garbage collection only when memory fragmentation becomes high.
Reference: [2] <author> K. Brace, R. Rudell, and R. E. Bryant. </author> <title> Efficient implementation of a BDD package. </title> <booktitle> In Proceedings of the 27th ACM/IEEE Design Automation Conference, </booktitle> <pages> pages 4045, </pages> <month> June </month> <year> 1990. </year>
Reference: [3] <author> F. Brglez and H. Fujiwara. </author> <title> A neutral netlist of 10 combinational benchmark circuits and a target translator in Fortran. </title> <booktitle> In 1985 International Symposium on Circuits And Systems, </booktitle> <month> June </month> <year> 1985. </year> <editor> Partially described in F. Brglez, P. Pownall, R. Hum. </editor> <title> Accelearted ATPG and Fault Grading via Testability Analysis. </title> <booktitle> In 1985 International Symposium on circuits and Systems, </booktitle> <pages> pages 695-698, </pages> <month> June </month> <year> 1985. </year>
Reference-contexts: Dynamic variable reordering can counteract the clustering effects achieved by the per-variable memory managers [16]. The solutions proposed in [16] should be directly applicable to our approach. IV. PERFORMANCE EVALUATION In this section, we present a performance evaluation of our approach. The test cases are the ISCAS85 benchmarks <ref> [3] </ref>, a collection of ten circuits used in industry. The variable ordering we used is generated by order dfs in SIS [20]. To get more test cases, we generate difference size array multiplier circuits based on carry ripple adders [6].
Reference: [4] <author> R. E. Bryant. </author> <title> Graph-based algorithms for Boolean function manipulation. </title> <journal> IEEE Transactions on Computers, </journal> <volume> C-35(8):677 691, </volume> <month> August </month> <year> 1986. </year>
Reference: [5] <author> R. E. Bryant. </author> <title> On the complexity of VLSI implementations and graph representations of Boolean functions with application to integer multiplication. </title> <journal> IEEE Transactions on Computers, </journal> <volume> 40(2):205213, </volume> <month> Feburary </month> <year> 1991. </year>
Reference: [6] <author> R. E. Bryant and Y.-A. Chen. </author> <title> Verification of arithmetic circuits with binary moment diagrams. </title> <booktitle> In Proceedings of the 32nd ACM/IEEE Design Automation Conference, </booktitle> <pages> pages 535 541, </pages> <month> June </month> <year> 1995. </year>
Reference-contexts: The test cases are the ISCAS85 benchmarks [3], a collection of ten circuits used in industry. The variable ordering we used is generated by order dfs in SIS [20]. To get more test cases, we generate difference size array multiplier circuits based on carry ripple adders <ref> [6] </ref>. For the rest of this section, we shall refer to this multiplier circuit as MCRA (Multiplier based on Carry Ripple Adders).
Reference: [7] <author> Y.-A. Chen and R. E. Bryant. ACV: </author> <title> An arithmetic circuit verifier. </title> <booktitle> In Proceedings of the International Conference on Computer-Aided Design, </booktitle> <pages> pages 361365, </pages> <month> November </month> <year> 1996. </year>
Reference: [8] <author> Y.-A. Chen, B. Yang, and R. E. Bryant. </author> <title> Breadth-first with depth-first BDD construction: A hybrid approach. </title> <type> Technical Report CMU-CS-97-120, </type> <institution> School of Computer Science, Carnegie Mel-lon University, </institution> <year> 1997. </year>
Reference-contexts: However, none of these propose how to bound the memory overhead of the breadth-first construction. To address this issue, we introduced a hybrid algorithm which performs the breadth-first construction to exploit memory locality and switches to the depth-first construction when the memory overhead becomes too high <ref> [8] </ref>.
Reference: [9] <author> R. Drechsler, A. Sarabi, M. Theobald, B. Becker, and M. A. Perkowski. </author> <title> Efficient representation and manipulation of switching functions based on ordered kronecker functional decision diagrams. </title> <booktitle> In Proceedings of the 31st ACM/IEEE Design Automation Conference, </booktitle> <pages> pages 415419, </pages> <month> June </month> <year> 1994. </year>
Reference: [10] <author> A. Hett, R. Frechsler, and B. Becker. </author> <title> MORE: Alternative implementation of BDD-packages by multi-operand synthesis. </title> <booktitle> In Proceedings of the European Design Automation Conference, </booktitle> <pages> pages 1620, </pages> <month> September </month> <year> 1996. </year>
Reference-contexts: This result demonstrates that our approach has very little memory overhead. As far as we know, this is the first time that the entire C6288 circuit has been built using conventional BDD representations. VI. RELATED WORK There are many research efforts based on breadth-first BDD construction <ref> [14, 15, 1, 10, 18] </ref>. However, none of these propose how to bound the memory overhead of the breadth-first construction.
Reference: [11] <author> J. Jain, J. Bitner, J. A. Abraham, and D. S. Fussell. </author> <title> Functional partitioning for verification and related problems. </title> <booktitle> In Proceedings of the Brown/MIT VLSI Conference, </booktitle> <pages> pages 210226, </pages> <month> March </month> <year> 1992. </year>
Reference: [12] <author> S. Jha, Y. Lu, M. Minea, and E. M. Clarke. </author> <title> Equivalence checking using abstract BDDs. </title> <booktitle> In 1997 IEEE Proceedings of the International Conference on Computer Design, </booktitle> <pages> pages 332337, </pages> <month> October </month> <year> 1997. </year>
Reference: [13] <author> K. L. McMillan. </author> <title> Symbolic Model Checking. </title> <publisher> Kluwer Academic Publishers, </publisher> <year> 1993. </year>
Reference: [14] <author> H. Ochi, N. Ishiura, and S. Yajima. </author> <title> Breadth-first manipulation of SBDD of Boolean functions for vector processing. </title> <booktitle> In Proceedings of the 28th ACM/IEEE Design Automation Conference, </booktitle> <pages> pages 413416, </pages> <month> June </month> <year> 1991. </year>
Reference-contexts: This result demonstrates that our approach has very little memory overhead. As far as we know, this is the first time that the entire C6288 circuit has been built using conventional BDD representations. VI. RELATED WORK There are many research efforts based on breadth-first BDD construction <ref> [14, 15, 1, 10, 18] </ref>. However, none of these propose how to bound the memory overhead of the breadth-first construction.
Reference: [15] <author> H. Ochi, K. Yasuoka, and S. Yajima. </author> <title> Breadth-first manipulation of very large binary-decision diagrams. </title> <booktitle> In Proceedings of the International Conference on Computer-Aided Design, </booktitle> <pages> pages 48 55, </pages> <month> November </month> <year> 1993. </year>
Reference-contexts: This result demonstrates that our approach has very little memory overhead. As far as we know, this is the first time that the entire C6288 circuit has been built using conventional BDD representations. VI. RELATED WORK There are many research efforts based on breadth-first BDD construction <ref> [14, 15, 1, 10, 18] </ref>. However, none of these propose how to bound the memory overhead of the breadth-first construction. <p> Note that this hybrid is similar to the mixed depth-first and breadth-first approach that prunes unnecessary recursion branches for the quantification and relational product operations [18]. SMV [13]'s BDD package uses mark-and-sweep garbage collector without memory compaction. In <ref> [15, 1, 17] </ref>, memory compaction is used to avoid memory fragmentation. These three approaches are all based on reference counting. In [15], the compaction algorithm is stable (i.e., linear ordering of the nodes is maintained) and does not require additional memory. Our approach is quite similar to this. <p> SMV [13]'s BDD package uses mark-and-sweep garbage collector without memory compaction. In [15, 1, 17], memory compaction is used to avoid memory fragmentation. These three approaches are all based on reference counting. In <ref> [15] </ref>, the compaction algorithm is stable (i.e., linear ordering of the nodes is maintained) and does not require additional memory. Our approach is quite similar to this.
Reference: [16] <author> R. K. Ranjan, W. Gosti, R. K. Brayton, and A. Sangiovanni-Vincentelli. </author> <title> Dynamic reordering in a breadth-first manipulation based BDD package: Challenges and solutions. </title> <booktitle> In 1997 IEEE Proceedings of the International Conference on Computer Design, </booktitle> <pages> pages 344357, </pages> <month> October </month> <year> 1997. </year>
Reference-contexts: Since garbage collection is generally invoked right before variable reordering, we can compute reference counts during the mark-and-compact phase of garbage col lection (line 1 and line 7 of Fig.7). 2. Dynamic variable reordering can counteract the clustering effects achieved by the per-variable memory managers <ref> [16] </ref>. The solutions proposed in [16] should be directly applicable to our approach. IV. PERFORMANCE EVALUATION In this section, we present a performance evaluation of our approach. The test cases are the ISCAS85 benchmarks [3], a collection of ten circuits used in industry. <p> Dynamic variable reordering can counteract the clustering effects achieved by the per-variable memory managers <ref> [16] </ref>. The solutions proposed in [16] should be directly applicable to our approach. IV. PERFORMANCE EVALUATION In this section, we present a performance evaluation of our approach. The test cases are the ISCAS85 benchmarks [3], a collection of ten circuits used in industry.
Reference: [17] <author> R. K. Ranjan and J. Sanghavi. CAL-2.0: </author> <title> Breadth-first Manipulation Based BDD Library. Public software. </title> <institution> University of California, Berkeley, </institution> <address> CA, </address> <month> June </month> <year> 1997. </year> <note> http://www-cad.eecs.berkeley.edu/Research/cal bdd/. </note>
Reference-contexts: Note that this hybrid is similar to the mixed depth-first and breadth-first approach that prunes unnecessary recursion branches for the quantification and relational product operations [18]. SMV [13]'s BDD package uses mark-and-sweep garbage collector without memory compaction. In <ref> [15, 1, 17] </ref>, memory compaction is used to avoid memory fragmentation. These three approaches are all based on reference counting. In [15], the compaction algorithm is stable (i.e., linear ordering of the nodes is maintained) and does not require additional memory. Our approach is quite similar to this. <p> Our approach is quite similar to this. In [1], the garbage collection uses a free-list and when memory fragmentation becomes high, a separate memory compaction algorithm based on copying is used. In <ref> [17] </ref>, garbage collection phase is also free-list based and memory compaction is performed after garbage collection only when memory fragmentation becomes high.
Reference: [18] <author> R. K. Ranjan, J. V. Sanghavi, R. K. Brayton, and A. Sangiovanni-Vincentelli. </author> <title> High performance BDD package based on exploiting memory hierarchy. </title> <booktitle> In Proceedings of the 33rd ACM/IEEE Design Automation Conference, </booktitle> <pages> pages 635640, </pages> <month> June </month> <year> 1996. </year>
Reference-contexts: In this section, we use two leading BDD packages for com-parison. The first package is CAL version 2.0 from UC Berke-ley, which implements the breadth-first algorithm described in <ref> [18] </ref>. The second package is CUDD version 2.1.2 [21] from the University of Colorado at Boulder, which implements the depth-first algorithm for BDD construction. Both are the latest releases as of November, 1997. All packages are compiled with gcc using the optimization flag -O3. <p> First, we have not implemented dynamic variable reordering yet. Second, turning off the dynamic reordering features removes the performance impact due to different dynamic reordering algorithms. For the CAL package, the results we present are without its su-perscalarity and pipelining features <ref> [18] </ref> because of adverse performance impact. These features require decomposing all operations into a single operation type. <p> This result demonstrates that our approach has very little memory overhead. As far as we know, this is the first time that the entire C6288 circuit has been built using conventional BDD representations. VI. RELATED WORK There are many research efforts based on breadth-first BDD construction <ref> [14, 15, 1, 10, 18] </ref>. However, none of these propose how to bound the memory overhead of the breadth-first construction. <p> Note that this hybrid is similar to the mixed depth-first and breadth-first approach that prunes unnecessary recursion branches for the quantification and relational product operations <ref> [18] </ref>. SMV [13]'s BDD package uses mark-and-sweep garbage collector without memory compaction. In [15, 1, 17], memory compaction is used to avoid memory fragmentation. These three approaches are all based on reference counting.
Reference: [19] <author> R. Rudell. </author> <title> Dynamic variable ordering for ordered binary decision diagrams. </title> <booktitle> In Proceedings of the International Conference on Computer-Aided Design, </booktitle> <pages> pages 139144, </pages> <month> November </month> <year> 1993. </year>
Reference: [20] <author> E. M. Sentovich, K. J. Singh, L. Lavagno, C. Moon, R. Mur-gai, A. Saldanha, H. Savoj, P. R. Stephan, R. K. Brayton, and A. L. Sangiovanni-Vincentelli. </author> <title> SIS: A system for sequential circuit synthesis. </title> <type> Technical Report UCB/ERL M92/41, </type> <institution> Electronics Research Lab, University of California, </institution> <month> May </month> <year> 1992. </year>
Reference-contexts: IV. PERFORMANCE EVALUATION In this section, we present a performance evaluation of our approach. The test cases are the ISCAS85 benchmarks [3], a collection of ten circuits used in industry. The variable ordering we used is generated by order dfs in SIS <ref> [20] </ref>. To get more test cases, we generate difference size array multiplier circuits based on carry ripple adders [6]. For the rest of this section, we shall refer to this multiplier circuit as MCRA (Multiplier based on Carry Ripple Adders).
Reference: [21] <author> F. Somenzi. CUDD-2.1.2: </author> <title> CU Decision Diagram Package, </title> <month> April </month> <year> 1997. </year> <month> ftp://vlsi.colorado.edu/pub/cudd-2.1.2.tar.gz. </month>
Reference-contexts: In this section, we use two leading BDD packages for com-parison. The first package is CAL version 2.0 from UC Berke-ley, which implements the breadth-first algorithm described in [18]. The second package is CUDD version 2.1.2 <ref> [21] </ref> from the University of Colorado at Boulder, which implements the depth-first algorithm for BDD construction. Both are the latest releases as of November, 1997. All packages are compiled with gcc using the optimization flag -O3. In this section, we will refer to our package as PBF.
Reference: [22] <author> B. Yang and D. R. O'Hallaron. </author> <title> Parallel breadth-first BDD construction. </title> <booktitle> In Ninth ACM SIGPLAN Symposium on Principles and Practice of Parallel Programming, </booktitle> <pages> pages 145156, </pages> <month> June </month> <year> 1997. </year>
Reference-contexts: These results show that our techniques have successfully achieved better memory locality while reducing the memory overhead. Beyond the sequential world, another advantage of the partial breadth-first algorithm is that it can be parallelized by using each processor's context stack as a distributed work queue <ref> [22] </ref>. This approach achieves speedups of up to four on eight processors of a shared memory system. ACKNOWLEDGEMENT We thank Claudson F. Bornstein and Henry R. Rowley for numerous discussions on efficient BDD implementations. We also thank Rajeev K.
References-found: 22

