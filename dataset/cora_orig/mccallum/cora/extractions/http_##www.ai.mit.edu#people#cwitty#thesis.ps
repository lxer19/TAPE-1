URL: http://www.ai.mit.edu/people/cwitty/thesis.ps
Refering-URL: http://www.ai.mit.edu/people/cwitty/
Root-URL: 
Title: The Ontic Inference Language  
Author: Carl Roger Witty David A. McAllester, Associate Professor 
Degree: B.S., Computer Science Stanford University, 1991 Submitted to the Department of Electrical Engineering and Computer Science in Partial Fulfillment of the Requirements for the Degree of Master of Science in Electrical Engineering and Computer Science at the  All rights reserved. Signature of Author Certified by  Thesis Advisor Accepted by Frederic R. Morgenthaler, Chairman, Committee on Graduate  
Note: c fl1995  
Date: June 1995  
Affiliation: Massachusetts Institute of Technology  Massachusetts Institute of Technology.  MIT Artificial Intelligence Laboratory  Students  
Abstract: fl This material is based upon work supported under a National Science Foundation Graduate Fellowship. Any opinions, findings, conclusions or recommendations expressed in this publication are those of the author and do not necessarily reflect the views of the National Science Foundation. 
Abstract-found: 1
Intro-found: 1
Reference: [For81] <author> C. L. Forgy. </author> <title> OPS5 user's manual. </title> <type> Technical Report CMU-CS-81-135, </type> <institution> Computer Science Department, Carnegie-Mellon University, </institution> <month> July </month> <year> 1981. </year>
Reference-contexts: OPS5 <ref> [For81] </ref> is one of the best-known languages for writing production systems. It 6 is often used for writing expert systems. Except for its handling of equality, OIL is a particularly simple production system.
Reference: [For82] <author> C. L. Forgy. </author> <title> RETE: A fast algorithm for the many pattern/many object pattern matching problem. </title> <journal> Artificial Intelligence, </journal> <volume> 19 </volume> <pages> 17-37, </pages> <month> September </month> <year> 1982. </year>
Reference-contexts: As with other production systems, the match process (computing the conflict set) is the performance bottleneck in OIL. Much work has been done on discovering efficient match algorithms for production systems. One of the most popular match algorithms is RETE <ref> [For82] </ref>, which is used in many implementations of OPS5. Another match algorithm called TREAT [Mir90] was developed by Miranker.
Reference: [GM92] <author> Robert Givan and David McAllester. </author> <title> New results on local inference rela-tions. </title> <booktitle> In Principles of Knowledge Representation and Reasoning: Proceedings of the Third International Conference, </booktitle> <pages> pages 403-412. </pages> <publisher> Morgan Kaufman Press, </publisher> <month> October </month> <year> 1992. </year> <title> Internet file ftp.ai.mit.edu:/pub/dam/kr92.ps. </title>
Reference-contexts: Lemma 14 Any language of terms which can be computed in time polynomial in the size of the term (when represented as a DAG) can be represented as a syntactically local rule set (see <ref> [GM92] </ref>). Thus, the syntactically local rule sets form a syntactic characterization of the set P . 5 Complexity Results and Optimizations The results in this section assume that hash table operations take constant time.
Reference: [GST90] <author> Sumit Ganguly, Avi Silberschatz, and Shalom Tsur. </author> <title> A framework for the parallel processing of logic programs. </title> <editor> In Hector Garcia-Molina and H. V. Jagadish, editors, </editor> <booktitle> Proceedings of the 1990 ACM SIGMOD International Conference on Management of Data, </booktitle> <year> 1990. </year>
Reference-contexts: Essentially, the transformation gains efficiency by providing full memoing. OIL programs are typically written in a style similar to the results of the Magic Templates transformation; an implementation of OIL could be used as the back end of a system which used Magic Templates. In <ref> [GST90] </ref>, the authors present a method for splitting up parallelizing bottom-up logic programs for distributed memory computers. The method depends on splitting the program so that parts of it execute on different processors, with minimal communication between the processors.
Reference: [McA] <author> David McAllester. </author> <title> Ontic proof verification system. </title> <publisher> ftp://ftp.ai.mit.edu/ pub/ontic/ontic.tar.Z. </publisher>
Reference-contexts: In some cases, such as context-free parsing, very simple OIL programs can achieve an efficiency which requires a much more complicated algorithm in a traditional programming language. As the name suggests, OIL is designed for use in the Ontic proof verification system <ref> [McA] </ref>; it is a variant of the language in which Ontic's inference rules are currently written. The existing Ontic low-level inference language has a number of irregularities and special cases which make it difficult to understand and use.
Reference: [McA92] <author> David McAllester. </author> <title> Grammar rewriting. </title> <booktitle> In CADE-11, </booktitle> <pages> pages 124-138. </pages> <publisher> Springer-Verlag, </publisher> <month> June </month> <year> 1992. </year>
Reference-contexts: In <ref> [McA92] </ref>, McAllester presents an algorithm which will work, but here we'll take a different approach. <p> Let be a member of C 0 T (R)[R ; , and let be the corresponding member of C 0 R [R = ; then the unextended facts of C = () are exactly . Congruence Grammars The transformation is essentially a method for encoding congruence grammars <ref> [McA92] </ref> in rules. A congruence grammar is a very simple normal form for sets of facts which are closed under R = ; it can also be quite compact.
Reference: [McA93] <author> David McAllester. </author> <title> Inference rules. </title> <booktitle> Lecture Notes for 6.824, Artificial Intelligence, </booktitle> <year> 1993. </year>
Reference-contexts: such a data structure, the set of all cousins can be found with only a few thousand operations. 5.1 Complexity for OIL Without Equality or Negated An <p>- tecedents The results about binary rule sets and the binary rule transform for OIL without equality and without negated antecedents are from <ref> [McA93] </ref>. <p> Definition 46 (binary rule transform) Define B (R) (the "binary rule transform <ref> [McA93] </ref>") as the following transformation. Let r be a rule with more than two antecedents, r = A 1 ; A 2 ; : : : ; A n =C.
Reference: [Mir90] <author> Daniel P. Miranker. </author> <title> TREAT: A New and Efficient Match Algorithm for AI Production Systems. </title> <booktitle> Research Notes in Artificial Intelligence. </booktitle> <publisher> Morgan Kaufman Publishers, </publisher> <year> 1990. </year>
Reference-contexts: Much work has been done on discovering efficient match algorithms for production systems. One of the most popular match algorithms is RETE [For82], which is used in many implementations of OPS5. Another match algorithm called TREAT <ref> [Mir90] </ref> was developed by Miranker. <p> For every such rule, it does a match using the new contents of that alpha memory and the current contents of the other alpha memories for the rule. The TREAT algorithm doesn't specify how the match is to be done among these alpha memories, although Miranker <ref> [Mir90] </ref> mentions several possibilities. These include static ordering, where the match is done with a depth-first search in the order the antecedents appear in the rule, and seed ordering, where the antecedent with new WME's is ordered first. Another optimization is semijoin reduction. This is a two-pass method.
Reference: [New73] <author> Allen Newell. </author> <title> Production systems: Models of control structures. </title> <booktitle> chapter 10, </booktitle> <pages> pages 463-526. </pages> <publisher> Academic Press, </publisher> <year> 1973. </year>
Reference-contexts: OIL is also related to existing work in production systems and logic programming. Production systems are often used to create expert systems. Essentially, a production system <ref> [New73] </ref> consists of a set of rules (sometimes known as productions; hence the name) and a database encoding the current knowledge of the system (this database is known as the working memory, and the facts in the database are called working memory elements, or WME's).
Reference: [NR91] <author> Jeffrey F. Naughton and Raghu Ramakrishnan. </author> <title> Bottom-up evaluation of logic programs. </title> <editor> In Jean-Louis Lassez and Gordon Plotkin, editors, </editor> <booktitle> Computational Logic, chapter 20, </booktitle> <pages> pages 640-700. </pages> <publisher> MIT Press, </publisher> <year> 1991. </year> <month> 64 </month>
Reference-contexts: 1 Introduction Bottom-up logic programming has received considerable attention in recent years in the database literature because of its ability to concisely represent a wide variety of algorithms <ref> [NR91] </ref>. Algorithms well suited to such logic program representation include transitive closure, context free parsing, and shortest paths in graphs. Bottom- up interpreters for logic programs cache intermediate results. This makes them well suited for the representation of dynamic programming algorithms. <p> The existing Ontic low-level inference language has a number of irregularities and special cases which make it difficult to understand and use. Also, the implementation is old, and has grown complex by accretion over the years. OIL is more general and expressive. In <ref> [NR91] </ref>, Naughton and Ramakrishnan describe the Magic Templates transfor <p>- 5 mation, which transforms a pure Prolog program (intended to be evaluated top-down) into an equivalent program which can be evaluated efficiently with bottom-up fixpoint evaluation.
References-found: 10

