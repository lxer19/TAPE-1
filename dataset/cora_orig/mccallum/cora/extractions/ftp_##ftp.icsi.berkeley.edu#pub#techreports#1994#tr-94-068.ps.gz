URL: ftp://ftp.icsi.berkeley.edu/pub/techreports/1994/tr-94-068.ps.gz
Refering-URL: http://www.icsi.berkeley.edu/techreports/1994.html
Root-URL: http://www.icsi.berkeley.edu
Email: E-mail: eyalk@cs.technion.ac.il  E-mail: rafail@cs.berkeley.edu  E-mail: adiro@math.tau.ac.il.  
Title: LOG-Space Polynomial End-to-End Communication  
Author: Eyal Kushilevitz Rafail Ostrovsky Adi Rosen 
Note: Part of this research was done while visiting ICSI,  Part of this research was done while visiting ICSI, Berkeley.  
Address: 32000, Israel.  Berkeley, CA 94720.  Tel-Aviv 69978, Israel.  
Affiliation: Dept. of Computer Science, Technion, Haifa  Berkeley. Computer Science Division, University of California at Berkeley, and International Computer Science Institute,  Dept. of Computer Science, Tel-Aviv University,  
Date: December 1994  
Pubnum: TR-94-068  
Abstract-found: 0
Intro-found: 1
Reference: [AAF+90] <author> Y. Afek, H. Attiya, A. Fekete, M. J. Fischer, N. Lynch, Y. Mansour, D. Wang, L. D. Zuck. </author> <title> Reliable Communication Over Unreliable Channel. </title> <type> Manuscript. </type> <year> 1990. </year>
Reference-contexts: : O (nm log n + mD) linear : O (n + D) PRESENT WORK: polynomial : O (n 2 mD) logarithmic : O (log n + D) Our Techniques and Previous Work: The starting point of our investigation is the Slide protocol of [AGR92] and the Majority algorithm of <ref> [AGR92, AAF+90] </ref>. The Slide protocol requires keeping O (n) packets per incident edge, and decides on the recency of the received item only at the receiver node (using [AAF+90] technique.). <p> The Slide protocol requires keeping O (n) packets per incident edge, and decides on the recency of the received item only at the receiver node (using <ref> [AAF+90] </ref> technique.). If we wish to reduce space per edge, we can no longer afford keeping O (n) different packets, but must keep far fewer packets per edge, and we can no longer afford the Majority algorithm of [AAF+90], which collects a large number of packets arriving at the receiver and <p> the recency of the received item only at the receiver node (using <ref> [AAF+90] </ref> technique.). If we wish to reduce space per edge, we can no longer afford keeping O (n) different packets, but must keep far fewer packets per edge, and we can no longer afford the Majority algorithm of [AAF+90], which collects a large number of packets arriving at the receiver and then takes their majority. Thus, we must somehow "drop" all but several packets, and decide which to keep at each of the processors.
Reference: [AAG87] <author> Y. Afek, B. Awerbuch, and E. Gafni. </author> <title> Applying static network protocols to dynamic networks. </title> <booktitle> In Proc. of the 28th IEEE Ann. Symp. on Foundation of Computer Science, </booktitle> <pages> pages 358-370, </pages> <month> October </month> <year> 1987. </year>
Reference-contexts: That is, in case faults occur rarely, it is possible, upon a fault, to "reset" the network and compute a new path between the communicating nodes (e.g., <ref> [Fin79, AAG87, AS88, AAM89, AGH90] </ref>). <p> As mentioned, we deal with networks that frequently change their topology; In such dynamic networks, links may fail and recover many times (yet processors never fail) (see <ref> [AAG87] </ref>), and each failure or recovery of a network link is eventually reported at both its end-points by some underlying link protocol.
Reference: [AAM89] <author> Y. Afek, B. Awerbuch, and H. Moriel. </author> <title> A complexity preserving reset procedure. </title> <type> Technical Report MIT/LCS/TM-389, </type> <institution> MIT, </institution> <month> May </month> <year> 1989. </year>
Reference-contexts: That is, in case faults occur rarely, it is possible, upon a fault, to "reset" the network and compute a new path between the communicating nodes (e.g., <ref> [Fin79, AAG87, AS88, AAM89, AGH90] </ref>).
Reference: [AG88] <author> Y. Afek and E. Gafni. </author> <title> End-to-end communication in unreliable networks. </title> <booktitle> In Proc. of the 7th ACM Symp. on Principles of Distributed Computing, </booktitle> <pages> pages 131-148, </pages> <month> August </month> <year> 1988. </year>
Reference-contexts: Notice that both the reset and the self-stabilizing solutions work only if faults are not too frequent. communication during frequent faults: We consider a setting where faults occur very frequently. The so-called end-to-end communication problem <ref> [AG88, AMS89] </ref> is to deliver, in finite time, data-items from a sender node to a receiver node, where data-items are given in an on-line fashion to the sender, and must be output in the same order, without duplication or omission at the receiver node. <p> However, this solution has the drawback that the amount of communication needed per data-item grows unboundedly as the number of messages grows. Recently, the study of end-to-end protocols with bounded communication complexity received a lot of attention <ref> [AG88, AMS89, APV91, AG91, AGR92] </ref>. In this paper, we concentrate on bounded (in fact, polynomial) communication complexity protocols. space complexity: Another important complexity measure is the space complexity | the amount of space needed at the nodes, per incident link. <p> Protocols with smaller space complexity were only presented at the cost of (at least) exponential communication complexity: Afek and Gafni <ref> [AG88] </ref> give a protocol which uses logarithmic amount of space, but 1 See Section 2 for a formal description of the model. 1 has exponential communication complexity, and another protocol which uses constant amount of space but has unbounded communication complexity. <p> This is an exponential space complexity improvement over all known polynomial-communication protocols. We compare our result to the previous work in the table below: Paper reference Communication complexity (total number of bits) Space Complexity (bits per incident link) [Vis83, AE86] unbounded: 1 unbounded: 1 <ref> [AG88] </ref>, Alg. 1. unbounded: 1 constant : O (D) [AG88], Alg. 2. exponential: O (D exp (n)) logarithmic: O (log n + D) [AMS89] polynomial : O (n 9 + mD) polynomial : O (n 5 + D) [AGR92] polynomial : O (n 2 mD) linear : O (nD) [AG91] polynomial <p> We compare our result to the previous work in the table below: Paper reference Communication complexity (total number of bits) Space Complexity (bits per incident link) [Vis83, AE86] unbounded: 1 unbounded: 1 <ref> [AG88] </ref>, Alg. 1. unbounded: 1 constant : O (D) [AG88], Alg. 2. exponential: O (D exp (n)) logarithmic: O (log n + D) [AMS89] polynomial : O (n 9 + mD) polynomial : O (n 5 + D) [AGR92] polynomial : O (n 2 mD) linear : O (nD) [AG91] polynomial : O (nm log n + mD) linear : <p> In addition, we require that the local routing computation of the network be polynomial for each send/receive event at each node, (in fact, our protocol uses a constant number of computational steps per event). 2.4 Relations to other Models The model described above is called the "1-delay model" in <ref> [AG88] </ref>, and the "fail-stop model" in [AM88]. <p> The question 4 how, in addition to frequent faults of edges, one can allow bad initial state was addressed in the end-to-end setting by [APV91]. As pointed out in <ref> [AG88] </ref>, one can design protocols in the fail-stop model and convert them to the dynamic model. For this, a message to be forwarded on a link is stored in a buffer until the link recovers and the previously sent message has been delivered.
Reference: [AG91] <author> Y. Afek, , and E. Gafni. </author> <title> Bootstrap network resynchronization: An efficient technique for end-to-end communication. </title> <booktitle> In Proc. of the Tenth Ann. ACM Symp. on Principles of Distributed Computing (PODC), </booktitle> <month> August </month> <year> 1991. </year>
Reference-contexts: However, this solution has the drawback that the amount of communication needed per data-item grows unboundedly as the number of messages grows. Recently, the study of end-to-end protocols with bounded communication complexity received a lot of attention <ref> [AG88, AMS89, APV91, AG91, AGR92] </ref>. In this paper, we concentrate on bounded (in fact, polynomial) communication complexity protocols. space complexity: Another important complexity measure is the space complexity | the amount of space needed at the nodes, per incident link. <p> 1 [AG88], Alg. 1. unbounded: 1 constant : O (D) [AG88], Alg. 2. exponential: O (D exp (n)) logarithmic: O (log n + D) [AMS89] polynomial : O (n 9 + mD) polynomial : O (n 5 + D) [AGR92] polynomial : O (n 2 mD) linear : O (nD) <ref> [AG91] </ref> polynomial : O (nm log n + mD) linear : O (n + D) PRESENT WORK: polynomial : O (n 2 mD) logarithmic : O (log n + D) Our Techniques and Previous Work: The starting point of our investigation is the Slide protocol of [AGR92] and the Majority algorithm
Reference: [AGR92] <author> Y. Afek, E. Gafni, and A. Rosen. </author> <title> The slide mechanism with applications in dynamic networks. </title> <booktitle> In Proc. 11th ACM Symp. on Principles of Distributed Computing, </booktitle> <pages> pages 35-46, </pages> <month> August </month> <year> 1992. </year> <month> 10 </month>
Reference-contexts: However, this solution has the drawback that the amount of communication needed per data-item grows unboundedly as the number of messages grows. Recently, the study of end-to-end protocols with bounded communication complexity received a lot of attention <ref> [AG88, AMS89, APV91, AG91, AGR92] </ref>. In this paper, we concentrate on bounded (in fact, polynomial) communication complexity protocols. space complexity: Another important complexity measure is the space complexity | the amount of space needed at the nodes, per incident link. <p> Space Complexity (bits per incident link) [Vis83, AE86] unbounded: 1 unbounded: 1 [AG88], Alg. 1. unbounded: 1 constant : O (D) [AG88], Alg. 2. exponential: O (D exp (n)) logarithmic: O (log n + D) [AMS89] polynomial : O (n 9 + mD) polynomial : O (n 5 + D) <ref> [AGR92] </ref> polynomial : O (n 2 mD) linear : O (nD) [AG91] polynomial : O (nm log n + mD) linear : O (n + D) PRESENT WORK: polynomial : O (n 2 mD) logarithmic : O (log n + D) Our Techniques and Previous Work: The starting point of our <p> linear : O (nD) [AG91] polynomial : O (nm log n + mD) linear : O (n + D) PRESENT WORK: polynomial : O (n 2 mD) logarithmic : O (log n + D) Our Techniques and Previous Work: The starting point of our investigation is the Slide protocol of <ref> [AGR92] </ref> and the Majority algorithm of [AGR92, AAF+90]. The Slide protocol requires keeping O (n) packets per incident edge, and decides on the recency of the received item only at the receiver node (using [AAF+90] technique.). <p> : O (nm log n + mD) linear : O (n + D) PRESENT WORK: polynomial : O (n 2 mD) logarithmic : O (log n + D) Our Techniques and Previous Work: The starting point of our investigation is the Slide protocol of [AGR92] and the Majority algorithm of <ref> [AGR92, AAF+90] </ref>. The Slide protocol requires keeping O (n) packets per incident edge, and decides on the recency of the received item only at the receiver node (using [AAF+90] technique.). <p> We show that a careful combination of these two techniques yields the desired result. Hence, even in the frequent communication faults model, it is possible to achieve both polynomial communication 2 and logarithmic space. These techniques exponentially improve the space efficiency of all end-to--end polynomial-communication protocols; as in <ref> [AMS89, AGR92] </ref>, they have the additional benefit that they are totally local in nature. For example, the locality of Slide was used for establishing its self-stabilizing extension in [APV91], as well as for various multi-commodity flow problems in dynamic graphs [AL93, AL94]. <p> the only space used by the above transformation is for storing the buffers (i.e., per each link it is the capacity of the link, times the size of the longest message) 2 . 3 The Protocol 3.1 High-level Description Our starting point is a linear space, yet simple, solution of <ref> [AGR92] </ref>. This solution combines (as black-boxes) two components: the Slide protocol and the Majority algorithm. Before we explain our algorithm, we give a quick overview of the approach taken there. The slide is used to transfer tokens (data-items) in the network. <p> The Majority algorithm enables the receiver to decide, by collecting sufficiently large number of tokens (containing data-items) and taking the majority value, what is the sequence of data-items sent by the sender. It is proved in <ref> [AGR92] </ref> that the combination of these two components yields a polynomial-communication solution to the end-to-end problem. <p> Some of the proofs are similar to those of <ref> [AMS89, AGR92] </ref>. We first state the following technical lemmas (whose proofs appear in the Appendix). 1. At any time t and for any e = (u; v), message tokens [e] t v + nil tokens [e] t v + tokens t u!v n (Lemma 8).
Reference: [AKY90] <author> Y. Afek, S. Kutten, and M. Yung. </author> <title> Memory-efficient self-stabilization on general networks. </title> <booktitle> In Proc. 4th Workshop on Distributed Algorithms, </booktitle> <address> Italy, </address> <year> 1990. </year>
Reference-contexts: That is, in case faults occur rarely, it is possible, upon a fault, to "reset" the network and compute a new path between the communicating nodes (e.g., [Fin79, AAG87, AS88, AAM89, AGH90]). Alternatively, a reliable communication path can be computed in a "self-stabilizing" manner (e.g., <ref> [Dij74, AKY90, KP90, APV91, AV91, AKM+93, AO94, IL94] </ref>), which essentially means that after faults stop for a sufficiently long period of time, the protocol "stabilizes" to its correct behavior (i.e., establishes a new path).
Reference: [AG90] <author> A. Arora and M. Gouda. </author> <title> Distributed reset. </title> <booktitle> In Proc. 10th Conf. on Foundations of Software Technology and Theoretical Computer Science, </booktitle> <pages> pages 316-331. </pages> <publisher> Springer-Verlag (LNCS 472), </publisher> <year> 1990. </year>
Reference: [AE86] <author> B. Awerbuch and S. </author> <title> Even Reliable broadcast protocols in unreliable networks Networks 16(4) </title> <type> 381-396, </type> <year> 1986. </year>
Reference-contexts: to the problem are evaluated according to their Communication Complexity and Space Complexity. communication complexity: One possible solution to the above problem is to give messages "unbounded sequence numbers", implying that the message size increases unboundedly with the number of items sent, and to "flood" the network with each item <ref> [Vis83, AE86] </ref>. However, this solution has the drawback that the amount of communication needed per data-item grows unboundedly as the number of messages grows. Recently, the study of end-to-end protocols with bounded communication complexity received a lot of attention [AG88, AMS89, APV91, AG91, AGR92]. <p> This is an exponential space complexity improvement over all known polynomial-communication protocols. We compare our result to the previous work in the table below: Paper reference Communication complexity (total number of bits) Space Complexity (bits per incident link) <ref> [Vis83, AE86] </ref> unbounded: 1 unbounded: 1 [AG88], Alg. 1. unbounded: 1 constant : O (D) [AG88], Alg. 2. exponential: O (D exp (n)) logarithmic: O (log n + D) [AMS89] polynomial : O (n 9 + mD) polynomial : O (n 5 + D) [AGR92] polynomial : O (n 2 mD)
Reference: [AGH90] <author> B. Awerbuch, O. Goldreich, and A. Herzberg. </author> <title> A quantitative approach to dynamic networks. </title> <booktitle> In Proc. 9th ACM Symp. on Principles of Distributed Computing, </booktitle> <pages> pages 189-204, </pages> <month> August </month> <year> 1990. </year>
Reference-contexts: That is, in case faults occur rarely, it is possible, upon a fault, to "reset" the network and compute a new path between the communicating nodes (e.g., <ref> [Fin79, AAG87, AS88, AAM89, AGH90] </ref>).
Reference: [AL93] <author> B. Awerbuch and T. </author> <title> Leighton A simple local-control approximation algorithm for multi-commodity flow. </title> <publisher> FOCS-93. </publisher>
Reference-contexts: For example, the locality of Slide was used for establishing its self-stabilizing extension in [APV91], as well as for various multi-commodity flow problems in dynamic graphs <ref> [AL93, AL94] </ref>. Organization: Section 2 contains all the necessary background including formal definitions of the model and the problem.
Reference: [AL94] <author> B. Awerbuch and T. </author> <title> Leighton Improved Approximation Algorithms for the Multi-Commodity Flow Problem and Local Competitive Routing in Dynamic Networks. </title> <publisher> STOC-94. </publisher>
Reference-contexts: For example, the locality of Slide was used for establishing its self-stabilizing extension in [APV91], as well as for various multi-commodity flow problems in dynamic graphs <ref> [AL93, AL94] </ref>. Organization: Section 2 contains all the necessary background including formal definitions of the model and the problem.
Reference: [AM88] <author> B. Awerbuch and Y. Mansour. </author> <title> An efficient topology update protocol for dynamic networks. </title> <type> Unpublished manuscript, </type> <month> January </month> <year> 1988. </year>
Reference-contexts: the local routing computation of the network be polynomial for each send/receive event at each node, (in fact, our protocol uses a constant number of computational steps per event). 2.4 Relations to other Models The model described above is called the "1-delay model" in [AG88], and the "fail-stop model" in <ref> [AM88] </ref>. As mentioned, we deal with networks that frequently change their topology; In such dynamic networks, links may fail and recover many times (yet processors never fail) (see [AAG87]), and each failure or recovery of a network link is eventually reported at both its end-points by some underlying link protocol.
Reference: [AKM+93] <author> A. Awerbuch, S. Kutten, Y. Mansour, B. Patt-Shamir, G. </author> <title> Varghese Time Optimal Self-stabilizing Synchronization STOC-93. </title>
Reference-contexts: That is, in case faults occur rarely, it is possible, upon a fault, to "reset" the network and compute a new path between the communicating nodes (e.g., [Fin79, AAG87, AS88, AAM89, AGH90]). Alternatively, a reliable communication path can be computed in a "self-stabilizing" manner (e.g., <ref> [Dij74, AKY90, KP90, APV91, AV91, AKM+93, AO94, IL94] </ref>), which essentially means that after faults stop for a sufficiently long period of time, the protocol "stabilizes" to its correct behavior (i.e., establishes a new path).
Reference: [AMS89] <author> B. Awerbuch, Y. Mansour, and N. Shavit. </author> <title> Polynomial end to end communication. </title> <booktitle> In Proc. of the 30th IEEE Ann. Symp. on Foundation of Computer Science, </booktitle> <pages> pages 358-363, </pages> <month> October </month> <year> 1989. </year>
Reference-contexts: Notice that both the reset and the self-stabilizing solutions work only if faults are not too frequent. communication during frequent faults: We consider a setting where faults occur very frequently. The so-called end-to-end communication problem <ref> [AG88, AMS89] </ref> is to deliver, in finite time, data-items from a sender node to a receiver node, where data-items are given in an on-line fashion to the sender, and must be output in the same order, without duplication or omission at the receiver node. <p> However, this solution has the drawback that the amount of communication needed per data-item grows unboundedly as the number of messages grows. Recently, the study of end-to-end protocols with bounded communication complexity received a lot of attention <ref> [AG88, AMS89, APV91, AG91, AGR92] </ref>. In this paper, we concentrate on bounded (in fact, polynomial) communication complexity protocols. space complexity: Another important complexity measure is the space complexity | the amount of space needed at the nodes, per incident link. <p> the previous work in the table below: Paper reference Communication complexity (total number of bits) Space Complexity (bits per incident link) [Vis83, AE86] unbounded: 1 unbounded: 1 [AG88], Alg. 1. unbounded: 1 constant : O (D) [AG88], Alg. 2. exponential: O (D exp (n)) logarithmic: O (log n + D) <ref> [AMS89] </ref> polynomial : O (n 9 + mD) polynomial : O (n 5 + D) [AGR92] polynomial : O (n 2 mD) linear : O (nD) [AG91] polynomial : O (nm log n + mD) linear : O (n + D) PRESENT WORK: polynomial : O (n 2 mD) logarithmic : <p> We show that a careful combination of these two techniques yields the desired result. Hence, even in the frequent communication faults model, it is possible to achieve both polynomial communication 2 and logarithmic space. These techniques exponentially improve the space efficiency of all end-to--end polynomial-communication protocols; as in <ref> [AMS89, AGR92] </ref>, they have the additional benefit that they are totally local in nature. For example, the locality of Slide was used for establishing its self-stabilizing extension in [APV91], as well as for various multi-commodity flow problems in dynamic graphs [AL93, AL94]. <p> Some of the proofs are similar to those of <ref> [AMS89, AGR92] </ref>. We first state the following technical lemmas (whose proofs appear in the Appendix). 1. At any time t and for any e = (u; v), message tokens [e] t v + nil tokens [e] t v + tokens t u!v n (Lemma 8).
Reference: [APV91] <author> B. Awerbuch, B. Patt-Shamir, and G. Varghese. </author> <title> Self-stabilization by local checking and correction. </title> <booktitle> In Proc. of the 32nd IEEE Ann. Symp. on Foundation of Computer Science, </booktitle> <pages> pages 268-277, </pages> <month> October </month> <year> 1991. </year>
Reference-contexts: That is, in case faults occur rarely, it is possible, upon a fault, to "reset" the network and compute a new path between the communicating nodes (e.g., [Fin79, AAG87, AS88, AAM89, AGH90]). Alternatively, a reliable communication path can be computed in a "self-stabilizing" manner (e.g., <ref> [Dij74, AKY90, KP90, APV91, AV91, AKM+93, AO94, IL94] </ref>), which essentially means that after faults stop for a sufficiently long period of time, the protocol "stabilizes" to its correct behavior (i.e., establishes a new path). <p> However, this solution has the drawback that the amount of communication needed per data-item grows unboundedly as the number of messages grows. Recently, the study of end-to-end protocols with bounded communication complexity received a lot of attention <ref> [AG88, AMS89, APV91, AG91, AGR92] </ref>. In this paper, we concentrate on bounded (in fact, polynomial) communication complexity protocols. space complexity: Another important complexity measure is the space complexity | the amount of space needed at the nodes, per incident link. <p> These techniques exponentially improve the space efficiency of all end-to--end polynomial-communication protocols; as in [AMS89, AGR92], they have the additional benefit that they are totally local in nature. For example, the locality of Slide was used for establishing its self-stabilizing extension in <ref> [APV91] </ref>, as well as for various multi-commodity flow problems in dynamic graphs [AL93, AL94]. Organization: Section 2 contains all the necessary background including formal definitions of the model and the problem. <p> As was discussed in the introduction, this corresponds to infrequent faults, and is incomparable to the model of frequent faults addressed here. The question 4 how, in addition to frequent faults of edges, one can allow bad initial state was addressed in the end-to-end setting by <ref> [APV91] </ref>. As pointed out in [AG88], one can design protocols in the fail-stop model and convert them to the dynamic model. For this, a message to be forwarded on a link is stored in a buffer until the link recovers and the previously sent message has been delivered.
Reference: [AS88] <author> B. Awerbuch and M. Sipser. </author> <title> Dynamic networks are as fast as static networks. </title> <booktitle> In Proc. of the 29th IEEE Ann. Symp. on Foundation of Computer Science, </booktitle> <pages> pages 206-220, </pages> <month> October </month> <year> 1988. </year>
Reference-contexts: That is, in case faults occur rarely, it is possible, upon a fault, to "reset" the network and compute a new path between the communicating nodes (e.g., <ref> [Fin79, AAG87, AS88, AAM89, AGH90] </ref>).
Reference: [AO94] <author> B. Awerbuch, and R. </author> <title> Ostrovsky Memory-Efficient and Self-Stabilizing Network RESET, </title> <publisher> PODC-94 </publisher>
Reference-contexts: That is, in case faults occur rarely, it is possible, upon a fault, to "reset" the network and compute a new path between the communicating nodes (e.g., [Fin79, AAG87, AS88, AAM89, AGH90]). Alternatively, a reliable communication path can be computed in a "self-stabilizing" manner (e.g., <ref> [Dij74, AKY90, KP90, APV91, AV91, AKM+93, AO94, IL94] </ref>), which essentially means that after faults stop for a sufficiently long period of time, the protocol "stabilizes" to its correct behavior (i.e., establishes a new path). <p> Notice that the "unbounded sequence numbers" solution requires unbounded memory as well. The question of reducing memory requirements, while maintaining efficiency, received a lot of attention in the "self-stabilizing" setting (e.g., <ref> [MOOY92, AO94, IL94] </ref>), where it was shown that, in the setting on infrequent communication faults, small memory and communication efficiency are simultaneously attainable.
Reference: [AV91] <author> B. Awerbuch, and G. Varghese, </author> <title> Distributed program checking: a paradigm for building self-stabilizing distributed protocols, </title> <publisher> FOCS-91. </publisher>
Reference-contexts: That is, in case faults occur rarely, it is possible, upon a fault, to "reset" the network and compute a new path between the communicating nodes (e.g., [Fin79, AAG87, AS88, AAM89, AGH90]). Alternatively, a reliable communication path can be computed in a "self-stabilizing" manner (e.g., <ref> [Dij74, AKY90, KP90, APV91, AV91, AKM+93, AO94, IL94] </ref>), which essentially means that after faults stop for a sufficiently long period of time, the protocol "stabilizes" to its correct behavior (i.e., establishes a new path).
Reference: [BS88] <author> A. E. Baratz and A. Segall. </author> <title> Reliable link initialization procedures. </title> <journal> IEEE Transaction on Communication, </journal> <month> February </month> <year> 1988. </year> <title> Also in: IFIP 3rd Workshop on Protocol Specification, Testing and Verification, </title> <booktitle> III. </booktitle>
Reference-contexts: For this, a message to be forwarded on a link is stored in a buffer until the link recovers and the previously sent message has been delivered. A protocol similar to the data-link initialization protocol of <ref> [BS88] </ref> is used to guarantee that no message is lost or duplicated. Each link in the dynamic network that fails and never recovers for a long enough period to allow the delivery of a message is represented by a non-viable link.
Reference: [Dij74] <author> E. Dijkstra. </author> <title> Self stabilization in spite of distributed control. </title> <journal> Comm. of the ACM, </journal> <volume> 17 </volume> <pages> 643-644, </pages> <year> 1974. </year>
Reference-contexts: That is, in case faults occur rarely, it is possible, upon a fault, to "reset" the network and compute a new path between the communicating nodes (e.g., [Fin79, AAG87, AS88, AAM89, AGH90]). Alternatively, a reliable communication path can be computed in a "self-stabilizing" manner (e.g., <ref> [Dij74, AKY90, KP90, APV91, AV91, AKM+93, AO94, IL94] </ref>), which essentially means that after faults stop for a sufficiently long period of time, the protocol "stabilizes" to its correct behavior (i.e., establishes a new path). <p> This model should be contrasted with a self-stabilizing model (e.g. <ref> [Dij74] </ref>), where both processors and links can start in an inconsistent state, but it is assumed that they never fail after the computation begins. As was discussed in the introduction, this corresponds to infrequent faults, and is incomparable to the model of frequent faults addressed here.
Reference: [DF88] <author> E. W. Dijkstra and W. H. J. Feijin. </author> <title> A Method of Programming. </title> <publisher> Addison-Wesley, </publisher> <year> 1988. </year>
Reference: [Fin79] <author> S. Finn. </author> <title> Resynch procedures and a fail-safe network protocol. </title> <journal> IEEE Trans. on Commun., </journal> <volume> COM-27(6):840-845, </volume> <month> June </month> <year> 1979. </year>
Reference-contexts: That is, in case faults occur rarely, it is possible, upon a fault, to "reset" the network and compute a new path between the communicating nodes (e.g., <ref> [Fin79, AAG87, AS88, AAM89, AGH90] </ref>).
Reference: [KP90] <author> S. Katz and K. Perry. </author> <title> Self-stabilizing extensions for message-passing systems. </title> <publisher> PODC-90. </publisher>
Reference-contexts: That is, in case faults occur rarely, it is possible, upon a fault, to "reset" the network and compute a new path between the communicating nodes (e.g., [Fin79, AAG87, AS88, AAM89, AGH90]). Alternatively, a reliable communication path can be computed in a "self-stabilizing" manner (e.g., <ref> [Dij74, AKY90, KP90, APV91, AV91, AKM+93, AO94, IL94] </ref>), which essentially means that after faults stop for a sufficiently long period of time, the protocol "stabilizes" to its correct behavior (i.e., establishes a new path).
Reference: [IL94] <author> G. Itkis, L. Levin. </author> <title> Fast and Lean Self-Stabilizing Asynchronous Protocols FOCS-94. </title>
Reference-contexts: That is, in case faults occur rarely, it is possible, upon a fault, to "reset" the network and compute a new path between the communicating nodes (e.g., [Fin79, AAG87, AS88, AAM89, AGH90]). Alternatively, a reliable communication path can be computed in a "self-stabilizing" manner (e.g., <ref> [Dij74, AKY90, KP90, APV91, AV91, AKM+93, AO94, IL94] </ref>), which essentially means that after faults stop for a sufficiently long period of time, the protocol "stabilizes" to its correct behavior (i.e., establishes a new path). <p> Notice that the "unbounded sequence numbers" solution requires unbounded memory as well. The question of reducing memory requirements, while maintaining efficiency, received a lot of attention in the "self-stabilizing" setting (e.g., <ref> [MOOY92, AO94, IL94] </ref>), where it was shown that, in the setting on infrequent communication faults, small memory and communication efficiency are simultaneously attainable.
Reference: [MOOY92] <author> A. Mayer, Y. Ofek, R. Ostrovsky, and M. </author> <title> Yung Self-Stabilizing Symmetry Breaking in Constant-Space STOC-92. </title>
Reference-contexts: Notice that the "unbounded sequence numbers" solution requires unbounded memory as well. The question of reducing memory requirements, while maintaining efficiency, received a lot of attention in the "self-stabilizing" setting (e.g., <ref> [MOOY92, AO94, IL94] </ref>), where it was shown that, in the setting on infrequent communication faults, small memory and communication efficiency are simultaneously attainable.
Reference: [Vis83] <author> U. </author> <title> Vishkin A distributed orientation algorithm IEEE Info. </title> <booktitle> Theory, </booktitle> <month> June </month> <year> 1983. </year> <month> 11 </month>
Reference-contexts: to the problem are evaluated according to their Communication Complexity and Space Complexity. communication complexity: One possible solution to the above problem is to give messages "unbounded sequence numbers", implying that the message size increases unboundedly with the number of items sent, and to "flood" the network with each item <ref> [Vis83, AE86] </ref>. However, this solution has the drawback that the amount of communication needed per data-item grows unboundedly as the number of messages grows. Recently, the study of end-to-end protocols with bounded communication complexity received a lot of attention [AG88, AMS89, APV91, AG91, AGR92]. <p> This is an exponential space complexity improvement over all known polynomial-communication protocols. We compare our result to the previous work in the table below: Paper reference Communication complexity (total number of bits) Space Complexity (bits per incident link) <ref> [Vis83, AE86] </ref> unbounded: 1 unbounded: 1 [AG88], Alg. 1. unbounded: 1 constant : O (D) [AG88], Alg. 2. exponential: O (D exp (n)) logarithmic: O (log n + D) [AMS89] polynomial : O (n 9 + mD) polynomial : O (n 5 + D) [AGR92] polynomial : O (n 2 mD)
References-found: 27

