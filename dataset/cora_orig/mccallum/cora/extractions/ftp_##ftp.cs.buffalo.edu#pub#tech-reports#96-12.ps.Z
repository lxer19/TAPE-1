URL: ftp://ftp.cs.buffalo.edu/pub/tech-reports/96-12.ps.Z
Refering-URL: ftp://ftp.cs.buffalo.edu/pub/tech-reports/README.html
Root-URL: 
Email: E-mail: boxer@niagara.edu.  E-mail: miller@cs.buffalo.edu.  E-mail: arc@tuns.ca.  
Phone: 3  
Title: Some Scalable Parallel Algorithms for Geometric Problems  
Author: Laurence Boxer Russ Miller Andrew Rau-Chaplin 
Web: IRI9412415.  
Note: Research partially supported by a grant from the  Research partially supported by NSF grant  Research partially supported by Natural  
Address: NY 14109, USA.  New York 14260, USA.  Scotia, P.O. Box 1000, Halifax, Nova Scotia, Canada B3J 2X4.  
Affiliation: 1 Department of Computer and Information Sciences, Niagara University,  Niagara University Research Council. 2 Department of Computer Science, State University of New York at Buffalo, Buffalo,  School of Computer Science, Technical University of Nova  Sciences and Engineering Research Council of Canada.  
Abstract-found: 0
Intro-found: 1
Reference: [Agar90] <author> P.K. Agarwal, </author> <title> Partitioning arrangements of lines: II, </title> <booktitle> applications, Discrete and Computational Geometry 5 (1990), </booktitle> <pages> 533-573. </pages>
Reference-contexts: Since every matching has complexity k, the assertion follows. ffi The sequential time necessary to find the O (D 2 (n)) line segments of length b with endpoints in S is denoted by A 2 (n). We have the following. Proposition 8.4 <ref> [Agar90, Chaz91] </ref> For any fixed ffi &gt; 0, A 2 (n) = O (n 4 Theorem 8.5 [G&K92] The Point Set Pattern Matching Problem in R 2 can be solved sequentially in O (A 2 (n) + kD 2 (n) log n) time. ffi Theorem 8.6 The Point Set Pattern Matching
Reference: [Agar91] <author> P.K. Agarwal, </author> <title> Intersection and Decomposition Algorithms for Planar Arrangements, </title> <publisher> Cambridge University Press, </publisher> <address> Cambridge, </address> <year> 1991. </year>
Reference-contexts: We have the following. Theorem 5.3 The following results concerning the function (n; k) are known. * (n; 1) = n and (n; 2) = 2n 1 [D&S65]. * (n; 4) = fi (n 2 ff (n) ) <ref> [Agar91] </ref>. * For s &gt; 4; ( O (n 2 O ([ff (n)] (s2)=2 ) ) if s is even; O (n 2 O ([ff (n)] (s3)=2 log (ff (n))) ) if s is odd [AShSh89]. ffi In the following, we assume that k is a positive integer and that S
Reference: [AShSh89] <author> P.K. Agarwal, M. Sharir, and P. Shor, </author> <title> Sharp upper and lower bounds on the length of general Davenport-Schinzel sequences, </title> <journal> Journal of Combinatorial Theory Series A 52 (1989), </journal> <pages> 228-274. </pages>
Reference-contexts: 2) = 2n 1 [D&S65]. * (n; 4) = fi (n 2 ff (n) ) [Agar91]. * For s &gt; 4; ( O (n 2 O ([ff (n)] (s2)=2 ) ) if s is even; O (n 2 O ([ff (n)] (s3)=2 log (ff (n))) ) if s is odd <ref> [AShSh89] </ref>. ffi In the following, we assume that k is a positive integer and that S is a set of polynomial functions, each of degree at most k.
Reference: [A&L93] <author> S.G. Akl and K.A. Lyons, </author> <title> Parallel Computational Geometry, </title> <publisher> Prentice-Hall, </publisher> <address> New York, </address> <year> 1993. </year>
Reference-contexts: Most previous theoretical work in parallel computational geometry has assumed fine grained parallelism, i.e., n p = fi (1), for machine models including the PRAM, mesh, hypercube, and pyramid computer <ref> [A&L93, M&S96] </ref>. However, since most commercial parallel computers are coarse grained, it is desirable that parallel algorithms be scalable, i.e., implementable and efficient over a wide range of ratios of n p .
Reference: [Atal85a] <author> M.J. Atallah, </author> <title> Some dynamic computational geometry problems. </title> <booktitle> Computers and Mathematics with Applications 11 (1985), </booktitle> <pages> 1171-1181. </pages>
Reference-contexts: Suppose the members of S are all polynomial functions of degree at most k. Then the maximal number of pieces of LE (x) is denoted by (n; k). It was shown in <ref> [Atal85a] </ref> that (n; s) is the maximal length of a Davenport-Schinzel sequence [D&S65] defined by parameters n and s as follows. Definition 5.1 [Atal85a] Let n and s be positive integers. <p> Then the maximal number of pieces of LE (x) is denoted by (n; k). It was shown in <ref> [Atal85a] </ref> that (n; s) is the maximal length of a Davenport-Schinzel sequence [D&S65] defined by parameters n and s as follows. Definition 5.1 [Atal85a] Let n and s be positive integers. Let C n = fc 1 ; : : : ; c n g be an alphabet of n distinct symbols. <p> As was done in <ref> [Atal85a, B&M89a, B&M89b] </ref>, we also assume that for ff i ; f j g S, i 6= j, all solutions of the equation f i (x) = f j (x) may be determined in fi (1) serial time. We have the following, which generalizes an algorithm of [DFR93]. <p> In parallel, each processor P j computes sequentially LE (S j ). There are O (( n p ; k)) pieces of LE (S j ) stored in P j . This requires O (( n p ; k) log ( n p )) time <ref> [Atal85a] </ref>. 2. Globally sort the collection of pieces of [ p j=1 LE (S j ) by the left endpoints of their intervals. <p> This step requires T sort (p ( n p ; k); p) time, which, by Lemma 2.1, is O (T sort ((n; k); p)). 3. In parallel, each processor P j computes sequentially LE (V j ). Using the algorithm of <ref> [Atal85a] </ref>, this takes O ((( n p ; k); k) log (n=p)) time, and LE (V j ) has O ((( n p ; k); k)) pieces. <p> Hence, each processor now stores all of R 1 ; : : : ; R p . This step requires O (p) time [DFR93]. 5. In parallel, each processor describes LE (fR 1 ; : : : ; R p g) in O ((p; k) log p) time <ref> [Atal85a] </ref>. Ob serve O ((p; k) log p) is (since n p p) O (( n p )), which (by Lemma 5.2) is O ( (n;k) log n which is O (T sort ((n; k); p)). 6. <p> In the following, we discuss several corollaries of Theorem 5.4. We will use the following abbre viations. T env (n; k; p) = T sort (p (( n ; k); k); p); n ; k); k); p): Following <ref> [Atal85a] </ref>, we say the function f (t) has a jump discontinuity at u if both lim t!u + f (t) and lim t!u f (t) exist, and lim t!u + f (t) 6= lim t!u f (t); and the function f (t) has a transition at t 0 if f (t) <p> Then the intersection of the members of S may be described on a CGM env (n; k; p) in T env (n; k; p) time. ffi 5.4 Dynamic Computational Geometry Problems concerning geometric properties of moving point-objects were considered in <ref> [Atal85a, B&M89a, B&M89b] </ref>. Sequential algorithms are presented in [Atal85a], while fine-grained parallel algorithms are presented in [B&M89a, B&M89b]. We have obtained efficient scalable parallel algorithms for many of the problems discussed in the papers cited above. All have running times dominated by description of a lower envelope. <p> Then the intersection of the members of S may be described on a CGM env (n; k; p) in T env (n; k; p) time. ffi 5.4 Dynamic Computational Geometry Problems concerning geometric properties of moving point-objects were considered in [Atal85a, B&M89a, B&M89b]. Sequential algorithms are presented in <ref> [Atal85a] </ref>, while fine-grained parallel algorithms are presented in [B&M89a, B&M89b]. We have obtained efficient scalable parallel algorithms for many of the problems discussed in the papers cited above. All have running times dominated by description of a lower envelope. <p> In 30 this section, we develop a CGM algorithm for determining when a given point P i 2 S is an extreme point of hull (S), where S is a set of point objects in kmotion in R 2 . In doing so, we use some results of <ref> [Atal85a, B&M89a] </ref>. Let T ij (t) be the angle made by rotating the positively oriented horizontal ray with endpoint P i about P i until the ray contains the line segment from P i to P j at time t. By convention, &lt; T ij (t) . <p> Let q be the number of jump discontinuities of H and let r be the number of transitions of H. Then q + r k. ffi Define T = fT ij j j 6= i; 0 j &lt; ng: Lemma 5.22 <ref> [Atal85a, B&M89a] </ref> For a system of n point-objects in the Euclidean plane with k-motion, each of the functions a i ; b i ; c i , and d i has at most (n; 4k) pieces generated by T . ffi Lemma 5.23 [Atal85a] Given a set S of n point-objects <p> i; 0 j &lt; ng: Lemma 5.22 [Atal85a, B&M89a] For a system of n point-objects in the Euclidean plane with k-motion, each of the functions a i ; b i ; c i , and d i has at most (n; 4k) pieces generated by T . ffi Lemma 5.23 <ref> [Atal85a] </ref> Given a set S of n point-objects in the plane with kmotion, a point P i is an extreme point of hull (S) at time t if and only if 1. a i (t) d i (t) &gt; , or 3. a i (t) and b i (t) are undefined,
Reference: [A&C89] <author> M.J. Atallah and D.Z. Chen, </author> <title> An optimal parallel algorithm for the minimum circle-cover problem, </title> <booktitle> Information Processing Letters 32 (1989), </booktitle> <pages> 159-165. </pages>
Reference-contexts: An application of this problem is in finding the minimal number of watchmen that can guard the perimeter of a convex planar region, given the sector of the perimeter that each can watch. Serial and fine-grained parallel solutions to this problem have been given in several papers, including <ref> [L&L84, Bert88, S&S89, B&M89c, A&C89] </ref>.
Reference: [Bert88] <editor> A.A. Bertossi, </editor> <booktitle> Parallel circle-cover algorithms, Information Processing Letters 27 (1988), </booktitle> <pages> pp. 133-139. </pages>
Reference-contexts: An application of this problem is in finding the minimal number of watchmen that can guard the perimeter of a convex planar region, given the sector of the perimeter that each can watch. Serial and fine-grained parallel solutions to this problem have been given in several papers, including <ref> [L&L84, Bert88, S&S89, B&M89c, A&C89] </ref>.
Reference: [Boxe92] <author> L. Boxer, </author> <title> Finding congruent regions in parallel, </title> <booktitle> Parallel Computing 18 (1992), </booktitle> <pages> 807-810. </pages>
Reference-contexts: Serial and fine-grained parallel solutions to this 40 problem have been given in several papers, including <ref> [Boxe92, Boxe96, dR&L95, G&K92, L&L92, SL&Y90] </ref>.
Reference: [Boxe96] <author> L. Boxer, </author> <title> Point set pattern matching in 3-D, </title> <note> submitted. </note>
Reference-contexts: Serial and fine-grained parallel solutions to this 40 problem have been given in several papers, including <ref> [Boxe92, Boxe96, dR&L95, G&K92, L&L92, SL&Y90] </ref>. <p> We have the following, which is implicit in <ref> [Boxe96] </ref>. Proposition 8.8 The output of the Point Set Pattern Matching Problem in R 3 has complexity * O (kn 3=2 [ n ] 1=4 ), if P is a collinear set; * O (kn 5=2 [ n ] 1=4 ) in general. <p> Since there is a one-to-one correspondence between such rigid transformations of R 3 and matchings of P in S, it follows that the output in the general case has complexity O (kn 5=2 [ (n;6) Theorem 8.9 <ref> [Boxe96] </ref> The Point Set Pattern Matching Problem in R 3 can be solved on a serial computer in * O (n 2 + kn 3=2 [ n ] 1=4 log n) time, if P is a collinear set; * O (kn 5=2 [ n ] 1=4 log n) time in the
Reference: [B&M89a] <author> L. Boxer and R. Miller, </author> <title> Parallel dynamic computational geometry, </title> <journal> Journal of New Generation Computer Systems 2 (1989), </journal> <pages> 227-246. </pages>
Reference-contexts: The following is a generalization of Lemma 2.4 of <ref> [B&M89a] </ref>. Lemma 5.2 For all positive integers k; n; p, p (n=p; k) (n; k). Proof: The lemma is stated in the form in which it will be used later in the paper. <p> As was done in <ref> [Atal85a, B&M89a, B&M89b] </ref>, we also assume that for ff i ; f j g S, i 6= j, all solutions of the equation f i (x) = f j (x) may be determined in fi (1) serial time. We have the following, which generalizes an algorithm of [DFR93]. <p> The next result is a generalization of the complexity bound for lower envelope functions to functions with transitions and jump discontinuities. Lemma 5.5 <ref> [B&M89a] </ref> Let k be a positive integer. <p> Proof: The assertion may be proved by an argument that is virtually identical to that given for Theorem 5.4. ffi The next two lemmas will be useful when we combine piecewise defined functions. Lemma 5.7 <ref> [B&M89a] </ref> Let f (t) and g (t) be functions from R 1 to R 1 . Let m and n be positive integers. Suppose f (t) has m pieces and g (t) has n pieces. <p> Let m and n be positive integers. Suppose f (t) has m pieces and g (t) has n pieces. Then the intervals of pieces of f (t) have, altogether, at most m + n nondegenerate intersections with the intervals of pieces of g (t). ffi Lemma 5.8 <ref> [B&M89a] </ref> Let m and k be positive integers. Let f (t) and g (t) be functions from R 1 to R 1 . Suppose that for every piece of both f (t) and g (t), the function of the piece is a polynomial whose degree is at most k. <p> Then the intersection of the members of S may be described on a CGM env (n; k; p) in T env (n; k; p) time. ffi 5.4 Dynamic Computational Geometry Problems concerning geometric properties of moving point-objects were considered in <ref> [Atal85a, B&M89a, B&M89b] </ref>. Sequential algorithms are presented in [Atal85a], while fine-grained parallel algorithms are presented in [B&M89a, B&M89b]. We have obtained efficient scalable parallel algorithms for many of the problems discussed in the papers cited above. All have running times dominated by description of a lower envelope. <p> Sequential algorithms are presented in [Atal85a], while fine-grained parallel algorithms are presented in <ref> [B&M89a, B&M89b] </ref>. We have obtained efficient scalable parallel algorithms for many of the problems discussed in the papers cited above. All have running times dominated by description of a lower envelope. <p> We refer to such motion as kmotion <ref> [B&M89a] </ref>. 5.4.1 Nearest Neighbor We have the following. Theorem 5.18 Let d and k be fixed positive integers. Let S be a system of point-objects, each of which is in kmotion in R d . <p> In 30 this section, we develop a CGM algorithm for determining when a given point P i 2 S is an extreme point of hull (S), where S is a set of point objects in kmotion in R 2 . In doing so, we use some results of <ref> [Atal85a, B&M89a] </ref>. Let T ij (t) be the angle made by rotating the positively oriented horizontal ray with endpoint P i about P i until the ray contains the line segment from P i to P j at time t. By convention, &lt; T ij (t) . <p> Lemma 5.21 <ref> [B&M89a] </ref>, proof of Lemma 4.4: Let S be a set of n point-objects that are in kmotion, for some positive integer k, and let H : R 1 ! R 1 be any of the functions in fG ij ; H ij j 0 i &lt; n; 0 j &lt; n; <p> Let q be the number of jump discontinuities of H and let r be the number of transitions of H. Then q + r k. ffi Define T = fT ij j j 6= i; 0 j &lt; ng: Lemma 5.22 <ref> [Atal85a, B&M89a] </ref> For a system of n point-objects in the Euclidean plane with k-motion, each of the functions a i ; b i ; c i , and d i has at most (n; 4k) pieces generated by T . ffi Lemma 5.23 [Atal85a] Given a set S of n point-objects
Reference: [B&M89b] <author> L. Boxer and R. Miller, </author> <title> Dynamic computational geometry on meshes and hypercubes, </title> <booktitle> Journal of Supercomputing 3 (1989), </booktitle> <pages> 161-191. </pages>
Reference-contexts: As was done in <ref> [Atal85a, B&M89a, B&M89b] </ref>, we also assume that for ff i ; f j g S, i 6= j, all solutions of the equation f i (x) = f j (x) may be determined in fi (1) serial time. We have the following, which generalizes an algorithm of [DFR93]. <p> Then the intersection of the members of S may be described on a CGM env (n; k; p) in T env (n; k; p) time. ffi 5.4 Dynamic Computational Geometry Problems concerning geometric properties of moving point-objects were considered in <ref> [Atal85a, B&M89a, B&M89b] </ref>. Sequential algorithms are presented in [Atal85a], while fine-grained parallel algorithms are presented in [B&M89a, B&M89b]. We have obtained efficient scalable parallel algorithms for many of the problems discussed in the papers cited above. All have running times dominated by description of a lower envelope. <p> Sequential algorithms are presented in [Atal85a], while fine-grained parallel algorithms are presented in <ref> [B&M89a, B&M89b] </ref>. We have obtained efficient scalable parallel algorithms for many of the problems discussed in the papers cited above. All have running times dominated by description of a lower envelope.
Reference: [B&M89c] <author> L. Boxer and R. Miller, </author> <title> A parallel circle-cover minimization algorithm, </title> <booktitle> Information Processing Letters 32 (1989), </booktitle> <pages> 57-60. </pages>
Reference-contexts: An application of this problem is in finding the minimal number of watchmen that can guard the perimeter of a convex planar region, given the sector of the perimeter that each can watch. Serial and fine-grained parallel solutions to this problem have been given in several papers, including <ref> [L&L84, Bert88, S&S89, B&M89c, A&C89] </ref>.
Reference: [B&M90] <author> L. Boxer and R. Miller, </author> <title> Common intersections of polygons, </title> <note> Information Processing Letters 33 (1990), 249-254; Corrigenda in Information Processing Letters 35 (1990), 53. </note>
Reference-contexts: This requires O (p) time. * In parallel, all processors computes t 2 . This takes fi (1) time. Thus, our algorithm requires T sort (m + n; p) time. ffi 5.3 Common Intersections of Polygons In <ref> [Reic88, B&M90] </ref>, serial and fine-grained parallel algorithms are given to solve the Common Intersection Problem for vertically convex polygons (a polygon P is vertically convex if for every pair of points fx; yg 2 P , if x and y are on the same vertical line segment s, then s P
Reference: [B&M93] <author> L. Boxer and R. Miller, </author> <title> Parallel algorithms for all maximal equally-spaced collinear sets and all maximal regular coplanar lattices, </title> <journal> Pattern Recognition Letters 14 (1993), </journal> <pages> 17-22. </pages>
Reference-contexts: This problem was studied in <ref> [K&R91, B&M93] </ref>. The algorithm of [K&R91] runs in optimal fi (n 2 ) serial time. It seems to be an essentially sequential algorithm. A rather different algorithm that is efficient on a fine-grained PRAM and optimal on a fine-grained mesh is presented in [B&M93]. <p> This problem was studied in [K&R91, B&M93]. The algorithm of [K&R91] runs in optimal fi (n 2 ) serial time. It seems to be an essentially sequential algorithm. A rather different algorithm that is efficient on a fine-grained PRAM and optimal on a fine-grained mesh is presented in <ref> [B&M93] </ref>. We say S 0 S is collinear if jS 0 j &gt; 2 and there is a line in R d that contains all members of S 0 .
Reference: [Chaz91] <author> B. Chazelle, </author> <title> An optimal convex hull algorithm and new results on cuttings, </title> <booktitle> Proc. 32nd IEEE Symposium on Foundations of Computer Science (1991), </booktitle> <pages> 29-38. 56 </pages>
Reference-contexts: Since every matching has complexity k, the assertion follows. ffi The sequential time necessary to find the O (D 2 (n)) line segments of length b with endpoints in S is denoted by A 2 (n). We have the following. Proposition 8.4 <ref> [Agar90, Chaz91] </ref> For any fixed ffi &gt; 0, A 2 (n) = O (n 4 Theorem 8.5 [G&K92] The Point Set Pattern Matching Problem in R 2 can be solved sequentially in O (A 2 (n) + kD 2 (n) log n) time. ffi Theorem 8.6 The Point Set Pattern Matching
Reference: [CEGSW90] <author> Clarkson, K.L., H. Edelsbrunner, L.J. Guibas, M. Sharir, and E. Welzl, </author> <title> Combi--natorial complexity bounds for arrangements of curves and surfaces, </title> <booktitle> Discrete and Computational Geometry 5 (1990), </booktitle> <pages> 99-160. </pages>
Reference-contexts: In the following, the function is the same function used earlier to discuss the complexity of lower envelope functions. The following is used to construct an upper bound on the complexity of the output. Proposition 8.7 <ref> [CEGSW90] </ref> Let S R 3 with jSj = n.
Reference: [CKPSSSSE] <author> D. Culler, R. Karp, D. Patterson, A. Sahay, K.E. Schauser, E. Santos, R. Subramo-nian, and T. von Eicken, </author> <title> LogP: Towards a Realistic Model of Parallel Computation. </title> <booktitle> Proc. 4th ACM SIGPLAN Sym. on Principles of Parallel Programming, </booktitle> <year> 1993. </year>
Reference-contexts: Typically, commercial Coarse Grained Multicomputers like the IBM SP2, Cray T30, Intel Paragon, or TMC CM-5 have local memories 32M. For a more detailed description of the model and its associated operations, see [DFR93]. Recently, there has been a growing interest in coarse grained computational models <ref> [Vali90, CKPSSSSE, H&K93] </ref> and the design of coarse grained geometric algorithms [DFR93, FRU95, DDDFK95]. The work on computational models has tended to be motivated by the observation that "fast algorithms" for fine-grained models rarely translate to fast code running on coarse grained machines. <p> The BSP model, described by Valiant [Vali90], uses slackness in the number of processors and memory mapping via hash functions to hide communication latency and provide for the efficient execution of fine grained PRAM algorithms on coarse grained hardware. Culler et al. <ref> [CKPSSSSE] </ref> introduced the LogP model which, using Valient's BSP model as a starting point, focuses on the technological trend from fine grained parallel machines towards coarse grained systems and advocates portable parallel algorithm design. Other coarse grained models focus more on utilizing local computation and minimizing global operations.
Reference: [D&S65] <author> H. Davenport and A. </author> <title> Schinzel, A combinatorial problem connected with differential equations. </title> <journal> Amer. J. Math. </journal> <volume> 87 (1965), </volume> <pages> 684-694. </pages>
Reference-contexts: Suppose the members of S are all polynomial functions of degree at most k. Then the maximal number of pieces of LE (x) is denoted by (n; k). It was shown in [Atal85a] that (n; s) is the maximal length of a Davenport-Schinzel sequence <ref> [D&S65] </ref> defined by parameters n and s as follows. Definition 5.1 [Atal85a] Let n and s be positive integers. Let C n = fc 1 ; : : : ; c n g be an alphabet of n distinct symbols. <p> In the following, ff (n) is the extremely slowly growing inverse Ackermann function (c.f., [H&Sh86]). We have the following. Theorem 5.3 The following results concerning the function (n; k) are known. * (n; 1) = n and (n; 2) = 2n 1 <ref> [D&S65] </ref>. * (n; 4) = fi (n 2 ff (n) ) [Agar91]. * For s &gt; 4; ( O (n 2 O ([ff (n)] (s2)=2 ) ) if s is even; O (n 2 O ([ff (n)] (s3)=2 log (ff (n))) ) if s is odd [AShSh89]. ffi In the following,
Reference: [DFR93] <author> F. Dehne, A. Fabri, and A. Rau-Chaplin, </author> <title> Scalable parallel geometric algorithms for multicomputers, </title> <booktitle> Proc. 9th ACM Symp. on Computational Geometry, </booktitle> <year> (1993), </year> <pages> 298-307. </pages>
Reference-contexts: Recently, there has been growing interest in developing scalable parallel algorithms for solving geometric problems on coarse grained machines (see <ref> [DFR93, FRU95, DDDFK95] </ref>). This paper continues this effort by describing new scalable algorithms for a variety of problems in pattern recognition, a variety of lower envelope problems (including a nearly-optimal algorithm for determining the lower envelope of polynomials), and other problems in computational geometry. The paper is organized as follows. <p> Typically, commercial Coarse Grained Multicomputers like the IBM SP2, Cray T30, Intel Paragon, or TMC CM-5 have local memories 32M. For a more detailed description of the model and its associated operations, see <ref> [DFR93] </ref>. Recently, there has been a growing interest in coarse grained computational models [Vali90, CKPSSSSE, H&K93] and the design of coarse grained geometric algorithms [DFR93, FRU95, DDDFK95]. <p> For a more detailed description of the model and its associated operations, see [DFR93]. Recently, there has been a growing interest in coarse grained computational models [Vali90, CKPSSSSE, H&K93] and the design of coarse grained geometric algorithms <ref> [DFR93, FRU95, DDDFK95] </ref>. The work on computational models has tended to be motivated by the observation that "fast algorithms" for fine-grained models rarely translate to fast code running on coarse grained machines. <p> Other coarse grained models focus more on utilizing local computation and minimizing global operations. Such models include the C 3 model [H&K93] and the Coarse Grained Multicomputer (CGM) model used in this paper <ref> [DFR93] </ref>. The assumption n p p (equivalently, n p 2 ) implies, for example, that for a machine to process 2 100,000 data items over 100 processors, each processor must have a capacity of at least 1,000 data items. <p> Lemma 2.1 For positive integers k; n; p, we have k T sort (n; p) = O (T sort (kn; p)) on a CGM (kn; p): 4 Proof: This follows from the fact that the work in sorting is superlinear in the amount of data being sorted. ffi Proposition 2.2 <ref> [DFR93] </ref> Each of the following operations may be implemented in time T sort (n; p) on a CGM (n; p). * Segmented broadcast; * Multinode broadcast; * Total exchange. ffi Proposition 2.3 A permutation exchange operation may be implemented in time T sort (n; p) on a CGM (n; p). <p> We have the following, which generalizes an algorithm of <ref> [DFR93] </ref>. Theorem 5.4 Let k be a fixed positive integer and let S be a set of polynomial functions, each of degree at most k. Assume that, initially, descriptions of the members of S are stored O ( n p ) per processor. <p> Perform a multinode broadcast so that processor P j sends R j to all other processors. Hence, each processor now stores all of R 1 ; : : : ; R p . This step requires O (p) time <ref> [DFR93] </ref>. 5. In parallel, each processor describes LE (fR 1 ; : : : ; R p g) in O ((p; k) log p) time [Atal85a].
Reference: [DDDFK95] <author> F. Dehne, X. Deng, P. Dymond, A. Fabri, and A. Khokhar, </author> <title> A randomized parallel 3D convex hull algorithm for coarse grained multicomputers, </title> <booktitle> Proc. 7th ACM Symp. on Parallel Algorithms and Architectures, </booktitle> <year> (1995), </year> <pages> 27-33. </pages>
Reference-contexts: Recently, there has been growing interest in developing scalable parallel algorithms for solving geometric problems on coarse grained machines (see <ref> [DFR93, FRU95, DDDFK95] </ref>). This paper continues this effort by describing new scalable algorithms for a variety of problems in pattern recognition, a variety of lower envelope problems (including a nearly-optimal algorithm for determining the lower envelope of polynomials), and other problems in computational geometry. The paper is organized as follows. <p> For a more detailed description of the model and its associated operations, see [DFR93]. Recently, there has been a growing interest in coarse grained computational models [Vali90, CKPSSSSE, H&K93] and the design of coarse grained geometric algorithms <ref> [DFR93, FRU95, DDDFK95] </ref>. The work on computational models has tended to be motivated by the observation that "fast algorithms" for fine-grained models rarely translate to fast code running on coarse grained machines.
Reference: [dR&L95] <author> P.J. de Rezende and D.T. Lee, </author> <title> Point set pattern matching in ddimensions, </title> <booktitle> Algo-rithmica 13 (1995), </booktitle> <pages> 387-404. </pages>
Reference-contexts: Serial and fine-grained parallel solutions to this 40 problem have been given in several papers, including <ref> [Boxe92, Boxe96, dR&L95, G&K92, L&L92, SL&Y90] </ref>. <p> We also give algorithms for PSPM restricted to realization via rotation or translation in R 2 , and for approximate PSPM realized via rotation in R 2 . 8.1 PSPM in R 1 A serial algorithm for this case is given in <ref> [dR&L95] </ref>, in which it is shown that the worst case output complexity is fi (k (n k)). We have the following. Theorem 8.1 The Point Set Pattern Matching Problem in R 1 can be solved on a CGM (k (nk); p) in optimal T sort (k (n k); p) time.
Reference: [Erd46] <author> P. Erdos, </author> <title> On a set of distances of n points, </title> <journal> American Mathematical Monthly 53 (1946), </journal> <pages> 248-250. </pages>
Reference-contexts: The function D 2 (n) was introduced in <ref> [Erd46] </ref>. 42 Proposition 8.2 [SST84] D 2 (n) = O (n 4=3 ). ffi We have the following, which is implicit in [G&K92]. Proposition 8.3 The output of the Point Set Pattern Matching Problem in R 2 has complexity O (kD 2 (n)).
Reference: [FRU95] <author> A. Ferreira, A. Rau-Chaplin, and S. Ubeda, </author> <title> Scalable 2d convex hull and triangulation algorithms for coarse grained multicomputers, </title> <booktitle> Proc. 7th IEEE Symp. on Parallel and Distributed Processing, </booktitle> <year> 1995. </year>
Reference-contexts: Recently, there has been growing interest in developing scalable parallel algorithms for solving geometric problems on coarse grained machines (see <ref> [DFR93, FRU95, DDDFK95] </ref>). This paper continues this effort by describing new scalable algorithms for a variety of problems in pattern recognition, a variety of lower envelope problems (including a nearly-optimal algorithm for determining the lower envelope of polynomials), and other problems in computational geometry. The paper is organized as follows. <p> For a more detailed description of the model and its associated operations, see [DFR93]. Recently, there has been a growing interest in coarse grained computational models [Vali90, CKPSSSSE, H&K93] and the design of coarse grained geometric algorithms <ref> [DFR93, FRU95, DDDFK95] </ref>. The work on computational models has tended to be motivated by the observation that "fast algorithms" for fine-grained models rarely translate to fast code running on coarse grained machines.
Reference: [G&K92] <author> Goodrich, M.T., and D. Kravetz, </author> <title> Point set pattern matching, </title> <institution> Johns Hopkins University Department of Computer Science Technical Report JHU-92/11 (1992). </institution>
Reference-contexts: Serial and fine-grained parallel solutions to this 40 problem have been given in several papers, including <ref> [Boxe92, Boxe96, dR&L95, G&K92, L&L92, SL&Y90] </ref>. <p> The function D 2 (n) was introduced in [Erd46]. 42 Proposition 8.2 [SST84] D 2 (n) = O (n 4=3 ). ffi We have the following, which is implicit in <ref> [G&K92] </ref>. Proposition 8.3 The output of the Point Set Pattern Matching Problem in R 2 has complexity O (kD 2 (n)). Proof: Let b be the length of the line segment from a 0 to a 1 . <p> We have the following. Proposition 8.4 [Agar90, Chaz91] For any fixed ffi &gt; 0, A 2 (n) = O (n 4 Theorem 8.5 <ref> [G&K92] </ref> The Point Set Pattern Matching Problem in R 2 can be solved sequentially in O (A 2 (n) + kD 2 (n) log n) time. ffi Theorem 8.6 The Point Set Pattern Matching Problem in R 2 can be solved in pT sort (n; p) + A 2 (n) + <p> As above, we assume the pattern set P has cardinality k, the sampling set S has cardinality n, and that 0 &lt; k n. We have the following. Theorem 8.12 <ref> [G&K92] </ref> * Every rotation r of P about the origin such that r (P ) S may be found in O (kn + n log n) serial time. * Every translation T of P in R 2 such that T (P ) S may be found in O (kn + n <p> Since there may be infinitely many 52 such rotations r, we seek to describe them in a finite amount of data, e.g., approximate matches via rotation may be characterized via a finite number of rotation intervals. We have the following serial result. Theorem 8.14 <ref> [G&K92] </ref> Let P [ S R 2 , " &gt; 0. Then all rotations of P about the origin that yield an "approximate match of P in S may be described in serial O (kn log k + n log n) time. ffi We prove the following.
Reference: [H&K93] <author> S. Hambrusch, and A. Khokhar, C3: </author> <title> An Architecture-Independent Model For Coarse-Grained Parallel Machines, </title> <institution> Purdue University Computer Sciences Technical Report CSD-TR-93-080 (1993). </institution> <month> 57 </month>
Reference-contexts: Typically, commercial Coarse Grained Multicomputers like the IBM SP2, Cray T30, Intel Paragon, or TMC CM-5 have local memories 32M. For a more detailed description of the model and its associated operations, see [DFR93]. Recently, there has been a growing interest in coarse grained computational models <ref> [Vali90, CKPSSSSE, H&K93] </ref> and the design of coarse grained geometric algorithms [DFR93, FRU95, DDDFK95]. The work on computational models has tended to be motivated by the observation that "fast algorithms" for fine-grained models rarely translate to fast code running on coarse grained machines. <p> Other coarse grained models focus more on utilizing local computation and minimizing global operations. Such models include the C 3 model <ref> [H&K93] </ref> and the Coarse Grained Multicomputer (CGM) model used in this paper [DFR93].
Reference: [H&Sh86] <author> S. Hart and M. Sharir, </author> <title> Nonlinearity of Davenport-Schinzel sequences and of general-ized path compression schemes, </title> <booktitle> Combinatorica 6 (1986), </booktitle> <pages> 151-177. </pages>
Reference-contexts: This completes the proof. ffi The function (n; k) is, at worst, slightly more than linear in n. In the following, ff (n) is the extremely slowly growing inverse Ackermann function (c.f., <ref> [H&Sh86] </ref>). We have the following.
Reference: [K&R91] <author> A.B. Kahng and G. Robins, </author> <title> Optimal algorithms for extracting spatial regularity in images, </title> <journal> Pattern Recognition Letters 12 (1991), </journal> <pages> 757-764. </pages>
Reference-contexts: The optimality of our time requirement follows from the remark above that we wish to produce an ordered list whose worst case complexity is fi (n). ffi 7 Maximal collinear sets In this section, we give a scalable parallel algorithm to solve the All Maximal Equally Spaced Collinear Subsets (AMESCS <ref> [K&R91] </ref>) Problem: Given a set S of n points in a Euclidean space, find all maximal equally-spaced collinear subsets of S determined by segments of any length `. This problem was studied in [K&R91, B&M93]. The algorithm of [K&R91] runs in optimal fi (n 2 ) serial time. <p> This problem was studied in <ref> [K&R91, B&M93] </ref>. The algorithm of [K&R91] runs in optimal fi (n 2 ) serial time. It seems to be an essentially sequential algorithm. A rather different algorithm that is efficient on a fine-grained PRAM and optimal on a fine-grained mesh is presented in [B&M93]. <p> parallel algorithm to solve the All Maximal Equally Spaced Collinear Subsets (AMESCS <ref> [K&R91] </ref>) Problem: Given a set S of n points in a Euclidean space, find all maximal equally-spaced collinear subsets of S determined by segments of any length `. This problem was studied in [K&R91, B&M93]. The algorithm of [K&R91] runs in optimal fi (n 2 ) serial time. It seems to be an essentially sequential algorithm. A rather different algorithm that is efficient on a fine-grained PRAM and optimal on a fine-grained mesh is presented in [B&M93].
Reference: [L&L84] <author> C.C. Lee and D.T. Lee, </author> <title> On a cover-circle minimization problem, </title> <booktitle> Information Processing Letters 18 (1984), </booktitle> <pages> pp. 109-115. </pages>
Reference-contexts: An application of this problem is in finding the minimal number of watchmen that can guard the perimeter of a convex planar region, given the sector of the perimeter that each can watch. Serial and fine-grained parallel solutions to this problem have been given in several papers, including <ref> [L&L84, Bert88, S&S89, B&M89c, A&C89] </ref>. <p> Serial and fine-grained parallel solutions to this problem have been given in several papers, including [L&L84, Bert88, S&S89, B&M89c, A&C89]. It was shown in <ref> [L&L84] </ref> that a greedy algorithm based in part on finding for each arc a successor that "extends" the arc maximally, will yield a minimal-cardinality cover, if one exists, and that in the worst case, fi (n) members of the input set of n arcs form a cover of the circle.
Reference: [L&L92] <author> C-L Lei and H-T Liaw, </author> <title> A parallel algorithm for finding congruent regions, </title> <booktitle> Computers and Graphics 16 (1992), </booktitle> <pages> 289-294. </pages>
Reference-contexts: Serial and fine-grained parallel solutions to this 40 problem have been given in several papers, including <ref> [Boxe92, Boxe96, dR&L95, G&K92, L&L92, SL&Y90] </ref>.
Reference: [M&S96] <author> R. Miller and Q.F. Stout, </author> <title> Parallel Algorithms for Regular Architectures: Meshes and Pyramids, </title> <publisher> The MIT Press, </publisher> <address> Cambridge, Mass., </address> <year> 1996. </year>
Reference-contexts: Most previous theoretical work in parallel computational geometry has assumed fine grained parallelism, i.e., n p = fi (1), for machine models including the PRAM, mesh, hypercube, and pyramid computer <ref> [A&L93, M&S96] </ref>. However, since most commercial parallel computers are coarse grained, it is desirable that parallel algorithms be scalable, i.e., implementable and efficient over a wide range of ratios of n p .
Reference: [Nadl78] <author> S.B. Nadler, Jr., </author> <title> Hyperspaces of Sets, </title> <publisher> Marcel Dekker, Inc., </publisher> <address> New York, </address> <year> 1978. </year>
Reference-contexts: Assume that the intervals of the pieces of f (t) have m nondegenerate intersections with the intervals of the pieces of g (t). Then the function minff (t); g (t)g has at most m (k + 1) pieces. ffi 5.2 Minimization of Hausdorff Distance The Hausdorff distance <ref> [Nadl78] </ref> is a measure of how well two sets A and B resemble each other with respect to their positions; if A and B are nonempty finite subsets of a Euclidean space, regarded as statistical populations, this measure is an alternative to more common statistical measures of population similarity. <p> Proposition 5.9 Let A [ B R 1 , jAj = m, and jBj = n. Then H fl (A; B) = maxfH fl (fag; B) j a 2 Ag: ffi The Hausdorff metric H (A; B) is defined <ref> [Nadl78] </ref> by H (A; B) = maxfH fl (A; B); H fl (B; A)g: For A R 1 , t 2 R 1 , let In [Rote91], a serial algorithm is given to solve the following problem: Let A and B be finite subsets of the real line.
Reference: [P&Sh92] <author> J. Pach and M. Sharir, </author> <title> Repeated angles in the plane and related problems, </title> <journal> Journal of Combinatorial Theory 59 (1) (1992), </journal> <pages> 12-22. </pages>
Reference-contexts: Thus, the running time of the algorithm is T sort (n 2 log n; p). ffi Straightforward modifications to the algorithm of Theorem 3.2 yield the following (the output estimates are in <ref> [VK&D91, P&Sh92] </ref>): Problem Worst Case Output T par All Isonormal Rectangles fi (n 2 ) T sort (n 2 ; p) on CGM (n 2 ; p) All Squares fi (n 2 ) T sort (n 2 ; p) on CGM (n 2 ; p) All Isonormal Squares fi (n 3=2
Reference: [Reic88] <author> M. Reichling, </author> <title> On the detection of a common intersection of k convex objects in the plane, </title> <booktitle> Information Processing Letters 29 (1988), </booktitle> <pages> 25-29. </pages>
Reference-contexts: This requires O (p) time. * In parallel, all processors computes t 2 . This takes fi (1) time. Thus, our algorithm requires T sort (m + n; p) time. ffi 5.3 Common Intersections of Polygons In <ref> [Reic88, B&M90] </ref>, serial and fine-grained parallel algorithms are given to solve the Common Intersection Problem for vertically convex polygons (a polygon P is vertically convex if for every pair of points fx; yg 2 P , if x and y are on the same vertical line segment s, then s P
Reference: [Rote91] <author> G. </author> <title> Rote, Computing the minimum Hausdorff distance between two point sets on a line under translation, </title> <booktitle> Information Processing Letters 38 (1991), </booktitle> <pages> 123-127. </pages>
Reference-contexts: Then H fl (A; B) = maxfH fl (fag; B) j a 2 Ag: ffi The Hausdorff metric H (A; B) is defined [Nadl78] by H (A; B) = maxfH fl (A; B); H fl (B; A)g: For A R 1 , t 2 R 1 , let In <ref> [Rote91] </ref>, a serial algorithm is given to solve the following problem: Let A and B be finite subsets of the real line. Find a translation t of A so that the Hausdorff distance H (A + t; B) is minimized. The algorithm of [Rote91] is dominated by the description of the <p> t 2 R 1 , let In <ref> [Rote91] </ref>, a serial algorithm is given to solve the following problem: Let A and B be finite subsets of the real line. Find a translation t of A so that the Hausdorff distance H (A + t; B) is minimized. The algorithm of [Rote91] is dominated by the description of the function H (A + t; B), which is an upper envelope problem. <p> In order to prove Theorem 5.15, we use the following. Lemma 5.10 <ref> [Rote91] </ref> Let A [ B R 1 , jAj = m, and jBj = n. Suppose a 1 = b 1 . <p> for all t 2 R 1 , H (A + t; B) jtj. ffi For each a 2 A, let f a : R 1 ! R 1 be the function f a (t) = H fl (fa + tg; B): The assertions of the following Lemma are found in <ref> [Rote91] </ref>. We give a proof to clarify our methods. 20 Lemma 5.11 Let a 2 A. Then f a is a continuous, piecewise linear function for which the graph of each linear piece has slope in f1; 1g. <p> The following Proposition is essentially found in <ref> [Rote91] </ref>, where it is stated in somewhat lesser detail than is given below. Proposition 5.13 Let A [ B R 1 , jAj = m, and jBj = n. Suppose a 1 = b 1 .
Reference: [S&S89] <author> D. Sarkar and I. Stojmenovic, </author> <title> An optimal parallel circle-cover algorithm, </title> <booktitle> Information Processing Letters 32 (1989), </booktitle> <pages> 3-6. </pages>
Reference-contexts: An application of this problem is in finding the minimal number of watchmen that can guard the perimeter of a convex planar region, given the sector of the perimeter that each can watch. Serial and fine-grained parallel solutions to this problem have been given in several papers, including <ref> [L&L84, Bert88, S&S89, B&M89c, A&C89] </ref>.
Reference: [SL&Y90] <author> Z.C. Shih, R.C.T. Lee, and S.N. Yang, </author> <title> A parallel algorithm for finding congruent regions, </title> <booktitle> Parallel Computing 13 (1990), </booktitle> <pages> 135-142. </pages>
Reference-contexts: Serial and fine-grained parallel solutions to this 40 problem have been given in several papers, including <ref> [Boxe92, Boxe96, dR&L95, G&K92, L&L92, SL&Y90] </ref>.
Reference: [SST84] <author> J. Spencer, E. Szemeredi, and W.T. Trotter, Jr., </author> <title> Unit distances in the Euclidean plane, in Graph Theory and Combinatorics, </title> <publisher> Academic Press, </publisher> <address> London, </address> <year> 1984, </year> <pages> 293-303. </pages>
Reference-contexts: The function D 2 (n) was introduced in [Erd46]. 42 Proposition 8.2 <ref> [SST84] </ref> D 2 (n) = O (n 4=3 ). ffi We have the following, which is implicit in [G&K92]. Proposition 8.3 The output of the Point Set Pattern Matching Problem in R 2 has complexity O (kD 2 (n)).
Reference: [Vali90] <author> L.G. Valiant, </author> <title> A Bridging Model for Parallel Computation, </title> <booktitle> Communications of the ACM 33 (1990), </booktitle> <pages> 103-111. 58 </pages>
Reference-contexts: Typically, commercial Coarse Grained Multicomputers like the IBM SP2, Cray T30, Intel Paragon, or TMC CM-5 have local memories 32M. For a more detailed description of the model and its associated operations, see [DFR93]. Recently, there has been a growing interest in coarse grained computational models <ref> [Vali90, CKPSSSSE, H&K93] </ref> and the design of coarse grained geometric algorithms [DFR93, FRU95, DDDFK95]. The work on computational models has tended to be motivated by the observation that "fast algorithms" for fine-grained models rarely translate to fast code running on coarse grained machines. <p> The work on computational models has tended to be motivated by the observation that "fast algorithms" for fine-grained models rarely translate to fast code running on coarse grained machines. The BSP model, described by Valiant <ref> [Vali90] </ref>, uses slackness in the number of processors and memory mapping via hash functions to hide communication latency and provide for the efficient execution of fine grained PRAM algorithms on coarse grained hardware.
Reference: [VK&D91] <author> M.J. Van Kreveld and M.T. De Berg, </author> <title> Finding squares and rectangles in sets of points, </title> <booktitle> BIT 31 (1991), </booktitle> <pages> 202-219. 59 </pages>
Reference-contexts: We say a polygon P is from S R 2 if all vertices of P belong to S. The AR problem is to find all rectangles from S. A serial solution to this problem is given in <ref> [VK&D91] </ref>. Proposition 3.1 [VK&D91] Let S R 2 , jSj = n. Then a solution to the AR problem has fi (n 2 log n) output in the worst case. <p> We say a polygon P is from S R 2 if all vertices of P belong to S. The AR problem is to find all rectangles from S. A serial solution to this problem is given in <ref> [VK&D91] </ref>. Proposition 3.1 [VK&D91] Let S R 2 , jSj = n. Then a solution to the AR problem has fi (n 2 log n) output in the worst case. Therefore, (n 2 log n) time is required for any serial algo rithm that solves the AR problem. ffi We have the following. <p> Thus, the running time of the algorithm is T sort (n 2 log n; p). ffi Straightforward modifications to the algorithm of Theorem 3.2 yield the following (the output estimates are in <ref> [VK&D91, P&Sh92] </ref>): Problem Worst Case Output T par All Isonormal Rectangles fi (n 2 ) T sort (n 2 ; p) on CGM (n 2 ; p) All Squares fi (n 2 ) T sort (n 2 ; p) on CGM (n 2 ; p) All Isonormal Squares fi (n 3=2
References-found: 39

