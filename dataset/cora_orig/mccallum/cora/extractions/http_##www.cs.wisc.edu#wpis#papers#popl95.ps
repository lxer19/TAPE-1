URL: http://www.cs.wisc.edu/wpis/papers/popl95.ps
Refering-URL: http://www.cs.wisc.edu/~reps/
Root-URL: 
Abstract-found: 0
Intro-found: 1
Reference: 1. <author> Aho, A.V., Hopcroft, J.E., and Ullman, J.D., </author> <title> The Design and Analysis of Computer Algorithms, </title> <publisher> Addison-Wesley, </publisher> <address> Reading, MA (1974). </address>
Reference-contexts: with needed information only [10] or the minimal function-graph approach [18].) It is important to note the role of lines [26]-[28] of Figure 3, which are executed only when a new summary edge is discovered: hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh declare PathEdge, WorkList, SummaryEdge: global edge set algorithm Tabulate (G IP # ) begin <ref> [1] </ref> Let (N # , E # ) = G IP [2] PathEdge := - s main , 0 fi s main , 0 -[3] WorkList := - s main , 0 fi s main , 0 -[4] SummaryEdge := [5] ForwardTabulateSLRPs () [6] for each n N * do [7] <p> with a pure reachability problem, but with values obtained by applying functions along (realizable) paths. (The relationship between transformed IFDS problems and transformed IDE problems is similar to the relationship between ordinary graph-reachability problems and generalized problems that compute summaries over paths, such as shortest-path problems, closed-semiring path problems, etc. <ref> [1] </ref>.) The algorithm for solving IDE problems is a dynamic-programming algorithm similar to the Tabulation Algorithm. Appendix: The Running Time of the Tabulation Algorithm In this section, we present a derivation of the bound given in Table 5.2 for the cost of the Tabulation Algorithm on distributive problems.
Reference: 2. <author> Aho, A.V., Ganapathi, M., and Tjiang, S.W.K., </author> <title> Code generation using tree matching and dynamic programming, </title> <journal> ACM Trans. Program. Lang. Syst. </journal> <pages> 11(4) pp. </pages> <month> 491-516 (October </month> <year> 1989). </year>
Reference-contexts: The Tabulation Algorithm is a worklist algorithm that accumulates sets of path edges and summary edges. The initial set of path edges represents the 0-length same-level realizable path from s main , 0 to s main , 0 (see line <ref> [2] </ref>). On each iteration of the main loop in procedure ForwardTabu-lateSLRPs (lines [10]-[39]), the algorithm deduces the existence of additional path edges (and summary edges). The configurations that are used by the Tabulation Algorithm to deduce the existence of additional path edges are depicted in Figure 4. <p> It is important to note the role of lines [26]-[28] of Figure 3, which are executed only when a new summary edge is discovered: hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh declare PathEdge, WorkList, SummaryEdge: global edge set algorithm Tabulate (G IP # ) begin [1] Let (N # , E # ) = G IP <ref> [2] </ref> PathEdge := - s main , 0 fi s main , 0 -[3] WorkList := - s main , 0 fi s main , 0 -[4] SummaryEdge := [5] ForwardTabulateSLRPs () [6] for each n N * do [7] X n := - d 2 D | $ d 1 <p> analyzes a C program and generates the corresponding exploded super-graph for the possibly-uninitialized-variables problem. (The current implementation of the front end does not account for aliases due to pointers.) The study used four example C programs: struct-beauty, the beautification phase of the Unix struct program [3]; twig, a code-generator generator <ref> [2] </ref>; ratfor, a preprocessor that converts a structured Fortran dialect to standard Fortran [19]; and C-parser, a lex/yacc-generated parser for C. Tests were carried out on a Sun SPARCstation 10 Model 30 with 32 MB of RAM.
Reference: 3. <author> Baker, B., </author> <title> An algorithm for structuring flowgraphs, </title> <journal> J. ACM 24(1) pp. </journal> <month> 98-120 (January </month> <year> 1977). </year>
Reference-contexts: with a front end that analyzes a C program and generates the corresponding exploded super-graph for the possibly-uninitialized-variables problem. (The current implementation of the front end does not account for aliases due to pointers.) The study used four example C programs: struct-beauty, the beautification phase of the Unix struct program <ref> [3] </ref>; twig, a code-generator generator [2]; ratfor, a preprocessor that converts a structured Fortran dialect to standard Fortran [19]; and C-parser, a lex/yacc-generated parser for C. Tests were carried out on a Sun SPARCstation 10 Model 30 with 32 MB of RAM.
Reference: 4. <author> Cai, J. and Paige, R., </author> <title> Program derivation by fixed point computa tion, </title> <note> Science of Computer Programming 11 pp. 197-261 (1988/89). </note>
Reference-contexts: Nevertheless, these problems can be solved efficiently by the Tabulation Algorithm. Graph reachability can also be thought of as an implementation of the pointwise computation of fixed points, which has been studied by Cai and Paige <ref> [4] </ref> and Nielson and Nielson [26,25]. Theorem 3.3, the basis on which we convert dataflow-analysis problems to reachability problems, is similar to Lemma 14 of Cai and Paige; however, the relation that Cai and Paige define for representing distributive functions does not have the subsumption property.
Reference: 5. <author> Callahan, D., Cooper, K.D., Kennedy, K., and Torczon, L., </author> <title> Interpro cedural constant propagation, </title> <booktitle> Proceedings of the SIGPLAN 86 Symposium on Compiler Construction, </booktitle> <address> (Palo Alto, CA, </address> <month> June 25-27, </month> <year> 1986), </year> <journal> ACM SIGPLAN Notices 21(7) pp. </journal> <month> 152-161 (July </month> <year> 1986). </year>
Reference-contexts: global edge set algorithm Tabulate (G IP # ) begin [1] Let (N # , E # ) = G IP [2] PathEdge := - s main , 0 fi s main , 0 -[3] WorkList := - s main , 0 fi s main , 0 -[4] SummaryEdge := <ref> [5] </ref> ForwardTabulateSLRPs () [6] for each n N * do [7] X n := - d 2 D | $ d 1 (D - 0 -) such that s procOf (n) , d 1 fi n, d 2 PathEdge -[8] od end procedure Propagate (e) begin [9] if e / PathEdge
Reference: 6. <author> Callahan, D., </author> <title> The program summary graph and flow-sensitive inter procedural data flow analysis, </title> <booktitle> Proceedings of the ACM SIGPLAN 88 Conference on Programming Language Design and Implementation, </booktitle> <address> (Atlanta, GA, </address> <month> June 22-24, </month> <year> 1988), </year> <journal> ACM SIGPLAN Notices 23(7) pp. </journal> <month> 47-56 (July </month> <year> 1988). </year>
Reference-contexts: if it respects the fact that when a procedure finishes it returns to the site of the most recent call [31,15,6,24,21,29]see Section 2.) Relevant previous work on precise interprocedural dataflow analysis can be categorized as follows: g Polynomial-time algorithms for specific individual problems (e.g., constant propagation [5,14], flow-sensitive summary information <ref> [6] </ref>, and pointer analysis [24]). g A polynomial-time algorithm for a limited class of problems: the locally separable problems (the interpro-cedural versions of the classical bit-vector or gen-hhhhhhhhhhhhhhhhhhhhhhhhhhhhh Work performed while visiting the Datalogisk Institut, University of Copenhagen, Universitetsparken 1, DK-2100 Copenhagen East, Denmark. <p> However, in the preliminary experiments reported in Section 6, which involve examples where D is in the range 70-142, the penalty observed is at most a factor of 3.4. g Callahan has given algorithms for several interpro cedural flow-sensitive side-effect problems <ref> [6] </ref>. Although these problems are (from a certain technical standpoint) of a slightly different character from the IFDS dataflow-analysis problems, with small adaptations the algorithm from Section 4 can be applied to these problems and is asymptotically faster than the algorithm given by Callahan. <p> algorithm Tabulate (G IP # ) begin [1] Let (N # , E # ) = G IP [2] PathEdge := - s main , 0 fi s main , 0 -[3] WorkList := - s main , 0 fi s main , 0 -[4] SummaryEdge := [5] ForwardTabulateSLRPs () <ref> [6] </ref> for each n N * do [7] X n := - d 2 D | $ d 1 (D - 0 -) such that s procOf (n) , d 1 fi n, d 2 PathEdge -[8] od end procedure Propagate (e) begin [9] if e / PathEdge then Insert e <p> Because in the single-level-pointer problem the combining function for return-site nodes is not meet, the problem does not fit into the IFDS framework. Flow-Sensitive Side-Effect Analysis Callahan investigated two flow-sensitive side-effect problems: must-modify and may-use <ref> [6] </ref>. The must-modify problem is to identify, for each procedure p, which variables must be modified during a call on p; the may-use problem is to identify, for each procedure p, which variables may be used before being modified during a call on p.
Reference: 7. <author> Cooper, K.D. and Kennedy, K., </author> <title> Interprocedural side-effect analysis in linear time, </title> <booktitle> Proceedings of the ACM SIGPLAN 88 Conference on Programming Language Design and Implementation, </booktitle> <address> (Atlanta, GA, </address> <month> June 22-24, </month> <year> 1988), </year> <journal> ACM SIGPLAN Notices 23(7) pp. </journal> <month> 57-66 (July </month> <year> 1988). </year>
Reference-contexts: [1] Let (N # , E # ) = G IP [2] PathEdge := - s main , 0 fi s main , 0 -[3] WorkList := - s main , 0 fi s main , 0 -[4] SummaryEdge := [5] ForwardTabulateSLRPs () [6] for each n N * do <ref> [7] </ref> X n := - d 2 D | $ d 1 (D - 0 -) such that s procOf (n) , d 1 fi n, d 2 PathEdge -[8] od end procedure Propagate (e) begin [9] if e / PathEdge then Insert e into PathEdge; Insert e into WorkList fi <p> The final step of the Tabulation Algorithm (lines [6]-[8]) is to create values X n , for each n N * , by gathering up the set of nodes associated with n in G IP # that are targets of path edges discovered by procedure ForwardTabulateSLRPs: <ref> [7] </ref> X n := - d 2 D | $ d 1 (D - 0 -) such that s procOf (n) , d 1 fi n, d 2 PathEdge As mentioned above, the fact that edge s procOf (n) , d 1 fi n, d 2 is in PathEdge implies that
Reference: 8. <author> Cooper, K.D. and Kennedy, K., </author> <title> Fast interprocedural alias analysis, pp. </title> <booktitle> 49-59 in Conference Record of the Sixteenth ACM Symposium on Principles of Programming Languages, </booktitle> <address> (Austin, TX, </address> <month> Jan. </month> <pages> 11-13, </pages> <address> 1989), </address> <publisher> ACM, </publisher> <address> New York, NY (1989). </address>
Reference: 9. <author> Cousot, P. and Cousot, R., </author> <title> Abstract interpretation: A unified lattice model for static analysis of programs by construction or approximation of fixpoints, pp. </title> <booktitle> 238-252 in Conference Record of the Fourth ACM Symposium on Principles of Programming Languages, </booktitle> <address> (Los Angeles, CA, </address> <month> January 17-19, </month> <year> 1977), </year> <booktitle> ACM, </booktitle> <address> New York, NY (1977). </address>
Reference-contexts: 0 -[4] SummaryEdge := [5] ForwardTabulateSLRPs () [6] for each n N * do [7] X n := - d 2 D | $ d 1 (D - 0 -) such that s procOf (n) , d 1 fi n, d 2 PathEdge -[8] od end procedure Propagate (e) begin <ref> [9] </ref> if e / PathEdge then Insert e into PathEdge; Insert e into WorkList fi end procedure ForwardTabulateSLRPs () begin [10] while WorkList do [11] Select and remove an edge s p , d 1 fi n, d 2 from WorkList [12] switch n [13] case n Call p : [14]
Reference: 10. <author> Cousot, P. and Cousot, R., </author> <title> Static determination of dynamic proper ties of recursive procedures, pp. 237-277 in Formal Descriptions of Programming Concepts, </title> <booktitle> (IFIP WG 2.2, </booktitle> <address> St. Andrews, Canada, </address> <month> August </month> <year> 1977), </year> <editor> ed. E.J. Neuhold,North-Holland, </editor> <address> New York, NY (1978). </address>
Reference-contexts: from s main , 0 to s p , d. (The idea of inserting only relevant s p , d fi s p , d edges into WorkList is similar to the idea of avoiding unnecessary function applications during abstract interpretation, known variously as chaotic iteration with needed information only <ref> [10] </ref> or the minimal function-graph approach [18].) It is important to note the role of lines [26]-[28] of Figure 3, which are executed only when a new summary edge is discovered: hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh declare PathEdge, WorkList, SummaryEdge: global edge set algorithm Tabulate (G IP # ) begin [1] Let (N # , <p> 2 D | $ d 1 (D - 0 -) such that s procOf (n) , d 1 fi n, d 2 PathEdge -[8] od end procedure Propagate (e) begin [9] if e / PathEdge then Insert e into PathEdge; Insert e into WorkList fi end procedure ForwardTabulateSLRPs () begin <ref> [10] </ref> while WorkList do [11] Select and remove an edge s p , d 1 fi n, d 2 from WorkList [12] switch n [13] case n Call p : [14] for each d 3 such that n, d 2 fi s calledProc (n) , d 3 E # do [15] <p> different generalization to handle recursive procedures with local variables and parameters was proposed by Knoop and Steffen [21].) The IFDS problems can be solved by a number of previous algorithms, including the elimination, iterative, and call-strings algorithms given by Sharir and Pnueli [31] and the algorithm of Cousot and Cousot <ref> [10] </ref>. However, for general IFDS problems both the iterative and call-strings algorithms can take exponential time in the worst case. Knoop and Steffen give an algorithm similar to Sharir and Pnueli's elimination algorithm [21].
Reference: 11. <author> Duesterwald, E., Gupta, R., and Soffa, </author> <title> M.L., Demand-driven com putation of interprocedural data flow, </title> <booktitle> in Conference Record of the Twenty-Second ACM Symposium on Principles of Programming Languages, </booktitle> <address> (San Francisco, CA, </address> <month> Jan. </month> <pages> 23-25, </pages> <address> 1995), </address> <publisher> ACM, </publisher> <address> New York, NY (1995). </address> <note> (To appear.) </note>
Reference-contexts: d 1 (D - 0 -) such that s procOf (n) , d 1 fi n, d 2 PathEdge -[8] od end procedure Propagate (e) begin [9] if e / PathEdge then Insert e into PathEdge; Insert e into WorkList fi end procedure ForwardTabulateSLRPs () begin [10] while WorkList do <ref> [11] </ref> Select and remove an edge s p , d 1 fi n, d 2 from WorkList [12] switch n [13] case n Call p : [14] for each d 3 such that n, d 2 fi s calledProc (n) , d 3 E # do [15] Propagate (s calledProc (n) <p> One of the benefits of the IFDS framework is that it permits a simple implementation of a demand algorithm for interprocedural dataflow analysis [27,17]. Other work on demand interprocedural dataflow analysis includes [29] and <ref> [11] </ref>. The IDE Framework Recently, we generalized the IFDS framework to a larger class of problems, called the IDE framework.
Reference: 12. <author> Fischer, C.N. and LeBlanc, </author> <title> R.J., Crafting a Compiler, </title> <publisher> Benjamin/Cummings Publishing Company, Inc., </publisher> <address> Menlo Park, CA (1988). </address>
Reference-contexts: We will call this class the interprocedural, finite, distributive, subset problems, or IFDS problems, for short. All of the locally separable problems are IFDS problems. In addition, many non-separable problems of practical importance are also IFDS problemsfor example: truly-live variables [13], copy constant propagation <ref> [12, pp. 660] </ref>, and possibly-uninitialized variables. <p> 2 PathEdge -[8] od end procedure Propagate (e) begin [9] if e / PathEdge then Insert e into PathEdge; Insert e into WorkList fi end procedure ForwardTabulateSLRPs () begin [10] while WorkList do [11] Select and remove an edge s p , d 1 fi n, d 2 from WorkList <ref> [12] </ref> switch n [13] case n Call p : [14] for each d 3 such that n, d 2 fi s calledProc (n) , d 3 E # do [15] Propagate (s calledProc (n) , d 3 fi s calledProc (n) , d 3 ) [16] od [17] for each d
Reference: 13. <author> Giegerich, R., Moncke, U., and Wilhelm, R., </author> <title> Invariance of approxi mative semantics with respect to program transformation, pp. </title> <booktitle> 1-10 in Informatik-Fachberichte 50, </booktitle> <publisher> Springer-Verlag, </publisher> <address> New York, NY (1981). </address>
Reference-contexts: We will call this class the interprocedural, finite, distributive, subset problems, or IFDS problems, for short. All of the locally separable problems are IFDS problems. In addition, many non-separable problems of practical importance are also IFDS problemsfor example: truly-live variables <ref> [13] </ref>, copy constant propagation [12, pp. 660], and possibly-uninitialized variables. <p> od end procedure Propagate (e) begin [9] if e / PathEdge then Insert e into PathEdge; Insert e into WorkList fi end procedure ForwardTabulateSLRPs () begin [10] while WorkList do [11] Select and remove an edge s p , d 1 fi n, d 2 from WorkList [12] switch n <ref> [13] </ref> case n Call p : [14] for each d 3 such that n, d 2 fi s calledProc (n) , d 3 E # do [15] Propagate (s calledProc (n) , d 3 fi s calledProc (n) , d 3 ) [16] od [17] for each d 3 such that
Reference: 14. <author> Grove, D. and Torczon, L., </author> <title> Interprocedural constant propagation: A study of jump function implementation, pp. </title> <booktitle> 90-99 in Proceedings of the ACM SIGPLAN 93 Conference on Programming Language Design and Implementation, </booktitle> <address> (Albuquerque, NM, June 23-25, 1993), </address> <publisher> ACM, </publisher> <address> New York, NY (1993). </address>
Reference-contexts: [9] if e / PathEdge then Insert e into PathEdge; Insert e into WorkList fi end procedure ForwardTabulateSLRPs () begin [10] while WorkList do [11] Select and remove an edge s p , d 1 fi n, d 2 from WorkList [12] switch n [13] case n Call p : <ref> [14] </ref> for each d 3 such that n, d 2 fi s calledProc (n) , d 3 E # do [15] Propagate (s calledProc (n) , d 3 fi s calledProc (n) , d 3 ) [16] od [17] for each d 3 such that n, d 2 fi returnSite (n),
Reference: 15. <author> Holley, L.H. and Rosen, B.K., </author> <title> Qualified data flow problems, </title> <journal> IEEE Transactions on Software Engineering SE-7(1) pp. </journal> <month> 60-78 (January </month> <year> 1981). </year>
Reference-contexts: [10] while WorkList do [11] Select and remove an edge s p , d 1 fi n, d 2 from WorkList [12] switch n [13] case n Call p : [14] for each d 3 such that n, d 2 fi s calledProc (n) , d 3 E # do <ref> [15] </ref> Propagate (s calledProc (n) , d 3 fi s calledProc (n) , d 3 ) [16] od [17] for each d 3 such that n, d 2 fi returnSite (n), d 3 (E # SummaryEdge) do [18] Propagate (s p , d 1 fi returnSite (n), d 3 ) [19] <p> Holley and Rosen investigated qualified dataflow analysis problems, where qualifications are a device to specify that only certain paths in the flow graph are to be considered <ref> [15] </ref>. They employ an expansion phase that has some similarities to our creation of the exploded super-graph.
Reference: 16. <author> Horwitz, S., Reps, T., and Binkley, D., </author> <title> Interprocedural slicing using dependence graphs, </title> <journal> ACM Trans. Program. Lang. Syst. </journal> <pages> 12(1) pp. </pages> <month> 26-60 (January </month> <year> 1990). </year>
Reference-contexts: The algorithm runs in time O (ED 3 ); this is asymptotically faster than the best previously known algorithm for the problem <ref> [16] </ref>, which runs in time O (D 3 S Call p E p + D 4 p S Call p 3 ). g As discussed in Section 5, the new realizable-path reachability algorithm is adaptive, with asymptotically better performance when applied to common kinds of problem instances that have restricted form. <p> class of distributive flow-sensitive side-effect problems. (This and other related work is described in Section 7.) g The realizable-path reachability problem is also the heart of the problem of interprocedural program slicing, and the fastest previously known algorithm for the problem is the one given by Horwitz, Reps, and Bink-ley <ref> [16] </ref>. The realizable-path reachability algorithm described in this paper yields an improved interprocedural-slicing algorithmone whose running time is asymptotically faster than the Horwitz-Reps-Binkley algorithm. <p> n, d 2 from WorkList [12] switch n [13] case n Call p : [14] for each d 3 such that n, d 2 fi s calledProc (n) , d 3 E # do [15] Propagate (s calledProc (n) , d 3 fi s calledProc (n) , d 3 ) <ref> [16] </ref> od [17] for each d 3 such that n, d 2 fi returnSite (n), d 3 (E # SummaryEdge) do [18] Propagate (s p , d 1 fi returnSite (n), d 3 ) [19] od [20] end case [21] case n = e p : [22] for each c callers
Reference: 17. <author> Horwitz, S., Reps, T., and Sagiv, M., </author> <title> Demand interprocedural dataflow analysis, </title> <type> Unpublished Report, </type> <institution> Computer Sciences Department, University of Wisconsin, Madison, </institution> <note> WI (). (In preparation.) </note>
Reference-contexts: 2 from WorkList [12] switch n [13] case n Call p : [14] for each d 3 such that n, d 2 fi s calledProc (n) , d 3 E # do [15] Propagate (s calledProc (n) , d 3 fi s calledProc (n) , d 3 ) [16] od <ref> [17] </ref> for each d 3 such that n, d 2 fi returnSite (n), d 3 (E # SummaryEdge) do [18] Propagate (s p , d 1 fi returnSite (n), d 3 ) [19] od [20] end case [21] case n = e p : [22] for each c callers (p) do
Reference: 18. <author> Jones, N.D. and Mycroft, A., </author> <title> Data flow analysis of applicative pro grams using minimal function graphs, pp. </title> <booktitle> 296-306 in Conference Record of the Thirteenth ACM Symposium on Principles of Programming Languages, </booktitle> <address> (St. Petersburg, FL, </address> <month> Jan. </month> <pages> 13-15, </pages> <address> 1986), </address> <publisher> ACM, </publisher> <address> New York, NY (1986). </address>
Reference-contexts: s p , d. (The idea of inserting only relevant s p , d fi s p , d edges into WorkList is similar to the idea of avoiding unnecessary function applications during abstract interpretation, known variously as chaotic iteration with needed information only [10] or the minimal function-graph approach <ref> [18] </ref>.) It is important to note the role of lines [26]-[28] of Figure 3, which are executed only when a new summary edge is discovered: hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh declare PathEdge, WorkList, SummaryEdge: global edge set algorithm Tabulate (G IP # ) begin [1] Let (N # , E # ) = G IP <p> n, d 2 fi s calledProc (n) , d 3 E # do [15] Propagate (s calledProc (n) , d 3 fi s calledProc (n) , d 3 ) [16] od [17] for each d 3 such that n, d 2 fi returnSite (n), d 3 (E # SummaryEdge) do <ref> [18] </ref> Propagate (s p , d 1 fi returnSite (n), d 3 ) [19] od [20] end case [21] case n = e p : [22] for each c callers (p) do [23] for each d 4 , d 5 such that c, d 4 fi s p , d 1
Reference: 19. <author> Kernighan, B.W., </author> <title> Ratfor A preprocessor for a rational Fortran, </title> <journal> Software Practice& Experience 5(4) pp. </journal> <month> 395-406 </month> <year> (1975). </year>
Reference-contexts: [15] Propagate (s calledProc (n) , d 3 fi s calledProc (n) , d 3 ) [16] od [17] for each d 3 such that n, d 2 fi returnSite (n), d 3 (E # SummaryEdge) do [18] Propagate (s p , d 1 fi returnSite (n), d 3 ) <ref> [19] </ref> od [20] end case [21] case n = e p : [22] for each c callers (p) do [23] for each d 4 , d 5 such that c, d 4 fi s p , d 1 E # and e p , d 2 fi returnSite (c), d 5 <p> problem. (The current implementation of the front end does not account for aliases due to pointers.) The study used four example C programs: struct-beauty, the beautification phase of the Unix struct program [3]; twig, a code-generator generator [2]; ratfor, a preprocessor that converts a structured Fortran dialect to standard Fortran <ref> [19] </ref>; and C-parser, a lex/yacc-generated parser for C. Tests were carried out on a Sun SPARCstation 10 Model 30 with 32 MB of RAM.
Reference: 20. <author> Kildall, G., </author> <title> A unified approach to global program optimization, pp. </title> <booktitle> 194-206 in Conference Record of the First ACM Symposium on Principles of Programming Languages, ACM, </booktitle> <address> New York, NY (1973). </address>
Reference-contexts: 1. Introduction This paper shows how to find precise solutions to a large class of interprocedural dataflow-analysis problems in polynomial time. In contrast with intraprocedural dataflow analysis, where precise means meet-over-all-paths <ref> [20] </ref>, a precise interprocedural dataflow-analysis algorithm must provide the meet-over-all-valid-paths solution. (A path is valid if it respects the fact that when a procedure finishes it returns to the site of the most recent call [31,15,6,24,21,29]see Section 2.) Relevant previous work on precise interprocedural dataflow analysis can be categorized as follows: <p> These frameworks generalize Kildall's concept of the meet-over-all-paths solution of an intraprocedural dataflow-analysis problem <ref> [20] </ref> to the meet-over-all-valid-paths solution of an interprocedural dataflow-analysis problem. The IFDS framework is designed to be as general as possible (in particular, to support languages with procedure calls, parameters, and both global and local variables). <p> (s calledProc (n) , d 3 fi s calledProc (n) , d 3 ) [16] od [17] for each d 3 such that n, d 2 fi returnSite (n), d 3 (E # SummaryEdge) do [18] Propagate (s p , d 1 fi returnSite (n), d 3 ) [19] od <ref> [20] </ref> end case [21] case n = e p : [22] for each c callers (p) do [23] for each d 4 , d 5 such that c, d 4 fi s p , d 1 E # and e p , d 2 fi returnSite (c), d 5 E #
Reference: 21. <author> Knoop, J. and Steffen, B., </author> <title> The interprocedural coincidence theorem, pp. </title> <booktitle> 125-140 in Proceedings of the Fourth International Conference on Compiler Construction, (Paderborn, </booktitle> <address> FRG, </address> <month> October 5-7, </month> <year> 1992), </year> <booktitle> Lecture Notes in Computer Science, </booktitle> <volume> Vol. 641, </volume> <editor> ed. U. Kastens and P. Pfahler,Springer-Verlag, </editor> <address> New York, NY (1992). </address>
Reference-contexts: IFDS Framework for Distributive Interpro-cedural Dataflow-Analysis Problems The IFDS framework is a variant of Sharir and Pnueli's functional approach to interprocedural dataflow analysis [31], with an extension similar to the one given by Knoop and Steffen in order to handle programs in which recursive procedures have local variables and parameters <ref> [21] </ref>. These frameworks generalize Kildall's concept of the meet-over-all-paths solution of an intraprocedural dataflow-analysis problem [20] to the meet-over-all-valid-paths solution of an interprocedural dataflow-analysis problem. <p> , d 3 fi s calledProc (n) , d 3 ) [16] od [17] for each d 3 such that n, d 2 fi returnSite (n), d 3 (E # SummaryEdge) do [18] Propagate (s p , d 1 fi returnSite (n), d 3 ) [19] od [20] end case <ref> [21] </ref> case n = e p : [22] for each c callers (p) do [23] for each d 4 , d 5 such that c, d 4 fi s p , d 1 E # and e p , d 2 fi returnSite (c), d 5 E # do [24] if <p> Related Work Previous Interprocedural Dataflow-Analysis Frameworks The IFDS framework is based on earlier interprocedural dataflow-analysis frameworks defined by Sharir and Pnueli [31] and Knoop and Steffen <ref> [21] </ref>. <p> Condition (iii), however, generalizes the Sharir Pnueli framework and permits it to cover programming languages in which recursive procedures have local variables and parameters (which the Sharir-Pnueli framework does not). (A different generalization to handle recursive procedures with local variables and parameters was proposed by Knoop and Steffen <ref> [21] </ref>.) The IFDS problems can be solved by a number of previous algorithms, including the elimination, iterative, and call-strings algorithms given by Sharir and Pnueli [31] and the algorithm of Cousot and Cousot [10]. <p> However, for general IFDS problems both the iterative and call-strings algorithms can take exponential time in the worst case. Knoop and Steffen give an algorithm similar to Sharir and Pnueli's elimination algorithm <ref> [21] </ref>. The efficiencies of the Sharir-Pnueli and Knoop-Steffen elimination algorithms depend, among other things, on the way functions are represented. No representations are discussed in [31] and [21]. <p> Knoop and Steffen give an algorithm similar to Sharir and Pnueli's elimination algorithm <ref> [21] </ref>. The efficiencies of the Sharir-Pnueli and Knoop-Steffen elimination algorithms depend, among other things, on the way functions are represented. No representations are discussed in [31] and [21]. However, even if representation relations (as defined in Section 3.1) are used, because the Sharir-Pnueli and Knoop-Steffen algorithms manipulate functions as a whole, rather than pointwise, for distributive and h-sparse problems, they are not as efficient as the Tabulation Algorithm.
Reference: 22. <author> Knoop, J. and Steffen, B., </author> <title> Efficient and optimal bit-vector data flow analyses: A uniform interprocedural framework, </title> <type> Bericht Nr. 9309, </type> <institution> Institut fuer Informatik und Praktische Mathematik, Christian-Albrechts-Universitaet zu Kiel, Kiel, </institution> <address> Germany (April 1993). </address>
Reference-contexts: Authors' address: Computer Sciences Department; Univ. of Wisconsin; 1210 West Dayton Street; Madison, WI 53706; USA. Electronic mail: -reps, horwitz, sagiv-@cs.wisc.edu. kill problems), which include reaching definitions, available expressions, and live variables <ref> [22] </ref>. g Algorithms for a very general class of problems [10,31,21]. The work cited in the third category concentrated on generality and did not provide polynomial-time algorithms. <p> For example, there is an asymptotic improvement in the algorithm's performance for the common case of locally separable problems. Our work generalizes that of Knoop and Steffen <ref> [22] </ref> in the sense that our algorithm handles a much larger class of problems, yet on the locally separable problems the algorithm runs in the same time as that used by the Knoop-Steffen algorithmO (ED ). g Imprecise (overly conservative) answers to interpro cedural dataflow-analysis problems could be obtained by treating <p> , d 3 ) [16] od [17] for each d 3 such that n, d 2 fi returnSite (n), d 3 (E # SummaryEdge) do [18] Propagate (s p , d 1 fi returnSite (n), d 3 ) [19] od [20] end case [21] case n = e p : <ref> [22] </ref> for each c callers (p) do [23] for each d 4 , d 5 such that c, d 4 fi s p , d 1 E # and e p , d 2 fi returnSite (c), d 5 E # do [24] if c, d 4 fi returnSite (c), d
Reference: 23. <author> Kou, L.T., </author> <title> On live-dead analysis for global data flow problems, </title> <journal> Journal of the ACM 24(3) pp. </journal> <month> 473-483 (July </month> <year> 1977). </year>
Reference-contexts: for each d 3 such that n, d 2 fi returnSite (n), d 3 (E # SummaryEdge) do [18] Propagate (s p , d 1 fi returnSite (n), d 3 ) [19] od [20] end case [21] case n = e p : [22] for each c callers (p) do <ref> [23] </ref> for each d 4 , d 5 such that c, d 4 fi s p , d 1 E # and e p , d 2 fi returnSite (c), d 5 E # do [24] if c, d 4 fi returnSite (c), d 5 / SummaryEdge then [25] Insert c, <p> Other work on solving dataflow-analysis problems by reducing them to reachabil-ity problems has been done by Kou <ref> [23] </ref> and Cooper and Kennedy [7,8].
Reference: 24. <author> Landi, W. and Ryder, B.G., </author> <title> Pointer-induced aliasing: A problem classification, pp. </title> <booktitle> 93-103 in Conference Record of the Eighteenth ACM Symposium on Principles of Programming Languages, </booktitle> <address> (Orlando, FL, </address> <month> January </month> <year> 1991), </year> <booktitle> ACM, </booktitle> <address> New York, NY (1991). </address>
Reference-contexts: fact that when a procedure finishes it returns to the site of the most recent call [31,15,6,24,21,29]see Section 2.) Relevant previous work on precise interprocedural dataflow analysis can be categorized as follows: g Polynomial-time algorithms for specific individual problems (e.g., constant propagation [5,14], flow-sensitive summary information [6], and pointer analysis <ref> [24] </ref>). g A polynomial-time algorithm for a limited class of problems: the locally separable problems (the interpro-cedural versions of the classical bit-vector or gen-hhhhhhhhhhhhhhhhhhhhhhhhhhhhh Work performed while visiting the Datalogisk Institut, University of Copenhagen, Universitetsparken 1, DK-2100 Copenhagen East, Denmark. On leave from IBM Scientific Center, Haifa, Israel. <p> case [21] case n = e p : [22] for each c callers (p) do [23] for each d 4 , d 5 such that c, d 4 fi s p , d 1 E # and e p , d 2 fi returnSite (c), d 5 E # do <ref> [24] </ref> if c, d 4 fi returnSite (c), d 5 / SummaryEdge then [25] Insert c, d 4 fi returnSite (c), d 5 into SummaryEdge [26] for each d 3 such that s procOf (c) , d 3 fi c, d 4 PathEdge do [27] Propagate (s procOf (c) , d <p> Another example of pointwise tabulation is Landi and Ryder's algorithm for interprocedural alias analysis for single-level pointers <ref> [24] </ref>. The algorithm they give is simi lar to the Tabulation Algorithm. A limitation of the IFDS framework is that information at a return-site node can only be expressed as the meet of the information at the corresponding call node and the appropriate exit node. <p> typically a small constant, and for many problems it is 1.) For each summary edge c, d 4 fi returnSite (c ), d 5 , the conditional statement on lines <ref> [24] </ref>-[29] will be executed some number of times (on different iterations of the loop on lines [10]-[39]). In particular, line [24] will be executed every time the Tabulation Algorithm finds a three-edge path of the form [c, d 4 fi s p , d 1 , s p , d 1 fi e p , d 2 , e p , d 2 fi returnSite (c ), d 5 ] () <p> When we consider the set of all summary edges at a given call site c: - c, d 4 fi returnSite (c), d 5 -, the executions of line <ref> [24] </ref> can be placed in three categories: d 4 0 and d 5 0 There are at most D 2 choices for a (d 4 , d 5 ) pair, and for each such pair at most B 2 possible three-edge paths of the form (). d 4 = 0 and <p> Thus, the total cost of all executions of line <ref> [24] </ref> is bounded by O (Call B 2 D 2 ). Because of the test on line [24], the code on lines [25]-[28] will be executed exactly once for each possible summary edge. <p> Thus, the total cost of all executions of line <ref> [24] </ref> is bounded by O (Call B 2 D 2 ). Because of the test on line [24], the code on lines [25]-[28] will be executed exactly once for each possible summary edge. In particular, for each summary edge the cost of the loop on lines [26]-[28] is bounded by O (D).
Reference: 25. <author> Nielson, F. and Nielson, H.R., </author> <title> Finiteness conditions for fixed point iteration, </title> <booktitle> in Conference Record of the 1992 ACM Symposium on Lisp and Functional Programming, </booktitle> <address> (San Francisco, CA, June 22-24 1992), </address> <publisher> ACM, </publisher> <address> New York, NY (1992). </address>
Reference-contexts: (p) do [23] for each d 4 , d 5 such that c, d 4 fi s p , d 1 E # and e p , d 2 fi returnSite (c), d 5 E # do [24] if c, d 4 fi returnSite (c), d 5 / SummaryEdge then <ref> [25] </ref> Insert c, d 4 fi returnSite (c), d 5 into SummaryEdge [26] for each d 3 such that s procOf (c) , d 3 fi c, d 4 PathEdge do [27] Propagate (s procOf (c) , d 3 fi returnSite (c), d 5 ) [28] od [30] od [32] end <p> ( ) returnSite (n), d 3 Lines [14]-[16] Lines [17]-[19] o o p 1 4 fg (c) 2 p returnSite (c) , d 5 o o s , d ( ) c , d ( ) ( )s , d fg (c) 2 p returnSite (c) , d 5 Line <ref> [25] </ref> Lines [26]-[28] o o s , d ( ) 2 3 KEY path edge (possibly new) path edge (possibly new) summary edge ordinary edge # summary edge call-to-return-site # E edge or call-to-start or exit-to-return-site # E edge Lines [34]-[36] hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh meet-over-all-valid-paths solution to IP. <p> Algorithm finds a three-edge path of the form [c, d 4 fi s p , d 1 , s p , d 1 fi e p , d 2 , e p , d 2 fi returnSite (c ), d 5 ] () as shown in the diagram marked Line <ref> [25] </ref> of Figure 4.
Reference: 26. <author> Nielson, H.R. and Nielson, F., </author> <title> Bounded fixed point iteration, pp. </title> <booktitle> 71-82 in Conference Record of the Nineteenth ACM Symposium on Principles of Programming Languages, </booktitle> <address> (Albuquerque, NM, </address> <month> January </month> <year> 1992), </year> <booktitle> ACM, </booktitle> <address> New York, NY (1992). </address>
Reference-contexts: c, d 4 fi s p , d 1 E # and e p , d 2 fi returnSite (c), d 5 E # do [24] if c, d 4 fi returnSite (c), d 5 / SummaryEdge then [25] Insert c, d 4 fi returnSite (c), d 5 into SummaryEdge <ref> [26] </ref> for each d 3 such that s procOf (c) , d 3 fi c, d 4 PathEdge do [27] Propagate (s procOf (c) , d 3 fi returnSite (c), d 5 ) [28] od [30] od [32] end case [33] case n (N p Call p - e p -) <p> : [34] for each m, d 3 such that n, d 2 fi m, d 3 E # do [35] Propagate (s p , d 1 fi m, d 3 ) [36] od [37] end case [38] end switch [39] od hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh realizable paths exist in G IP # . <ref> [26] </ref> for each d 3 such that s procOf (c) , d 3 fi c, d 4 PathEdge do [27] Propagate (s procOf (c) , d 3 fi returnSite (c), d 5 ) [28] od Unlike edges in E # , edges are inserted into SummaryEdge on-the-fly.
Reference: 27. <author> Reps, T., Sagiv, M., and Horwitz, S., </author> <title> Interprocedural dataflow analysis via graph reachability, </title> <type> TR 94-14, </type> <institution> Datalogisk Institut, University of Copenhagen, Copenhagen, </institution> <address> Denmark (April 1994). </address> <note> (Available through World Wide Web at ftp://ftp.diku.dk/diku/semantics/papers/D-215.ps.Z.) </note>
Reference-contexts: Preliminary experimental results are reported in Section 6. Space constraints have forced us to treat some of the above material in an abbreviated form. Full detailsincluding proofs of all theorems stated in the paperas well as a great deal of additional material, can be found in <ref> [27] </ref>. 2. <p> This assumption is made strictly for expository purposes; the more general setting, in which for each procedure p there is a (possibly) different space of dataflow facts, D p , presents no additional difficulties <ref> [27] </ref>. Our implementation of the IFDS framework, discussed in Section 6, supports the more general setting. Definition 2.5. <p> (c), d 5 E # do [24] if c, d 4 fi returnSite (c), d 5 / SummaryEdge then [25] Insert c, d 4 fi returnSite (c), d 5 into SummaryEdge [26] for each d 3 such that s procOf (c) , d 3 fi c, d 4 PathEdge do <ref> [27] </ref> Propagate (s procOf (c) , d 3 fi returnSite (c), d 5 ) [28] od [30] od [32] end case [33] case n (N p Call p - e p -) : [34] for each m, d 3 such that n, d 2 fi m, d 3 E # do <p> [35] Propagate (s p , d 1 fi m, d 3 ) [36] od [37] end case [38] end switch [39] od hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh realizable paths exist in G IP # . [26] for each d 3 such that s procOf (c) , d 3 fi c, d 4 PathEdge do <ref> [27] </ref> Propagate (s procOf (c) , d 3 fi returnSite (c), d 5 ) [28] od Unlike edges in E # , edges are inserted into SummaryEdge on-the-fly. The purpose of line [27] is to restart the processing that finds same-level realizable paths from s procOf (c) , d 3 as <p> for each d 3 such that s procOf (c) , d 3 fi c, d 4 PathEdge do <ref> [27] </ref> Propagate (s procOf (c) , d 3 fi returnSite (c), d 5 ) [28] od Unlike edges in E # , edges are inserted into SummaryEdge on-the-fly. The purpose of line [27] is to restart the processing that finds same-level realizable paths from s procOf (c) , d 3 as if summary edge c, d 4 fi returnSite (c ), d 5 had been in place all along. <p> The dataflow functions, which are abstractions of the statements' semantics, should therefore be close to the identity function, and thus their representation relations should have roughly D edges. For many problems of practical interest h 2 (see <ref> [27] </ref>). Example. When the nodes of the control-flow graph represent individual statements and predicates, and there is no aliasing, every instance of the possibly-uninitialized-variables problem is 2-sparse. The only non-identity dataflow functions are those associated with assignment statements. <p> This can be achieved, for instance, by the representation described in <ref> [27, pp. 20] </ref>.
Reference: 28. <author> Reps, T., Horwitz, S., Sagiv, M., and Rosay, G., </author> <title> Speeding up slic ing, </title> <booktitle> SIGSOFT 94: Proceedings of the Second ACM SIGSOFT Symposium on the Foundations of Software Engineering, </booktitle> <address> (New Orleans, LA, </address> <month> December 7-9, </month> <year> 1994), </year> <note> ACM SIGSOFT Software Engineering Notes 19(December 1994). (To appear.) </note>
Reference-contexts: The realizable-path reachability algorithm described in this paper yields an improved interprocedural-slicing algorithmone whose running time is asymptotically faster than the Horwitz-Reps-Binkley algorithm. This algorithm has been found to run six times as fast as the Horwitz-Reps-Binkley algorithm <ref> [28] </ref>. g Our dataflow-analysis algorithm has been implemented and used to analyze several C programs. Preliminary experimental results are reported in Section 6. Space constraints have forced us to treat some of the above material in an abbreviated form. <p> d 5 / SummaryEdge then [25] Insert c, d 4 fi returnSite (c), d 5 into SummaryEdge [26] for each d 3 such that s procOf (c) , d 3 fi c, d 4 PathEdge do [27] Propagate (s procOf (c) , d 3 fi returnSite (c), d 5 ) <ref> [28] </ref> od [30] od [32] end case [33] case n (N p Call p - e p -) : [34] for each m, d 3 such that n, d 2 fi m, d 3 E # do [35] Propagate (s p , d 1 fi m, d 3 ) [36] od <p> [37] end case [38] end switch [39] od hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh realizable paths exist in G IP # . [26] for each d 3 such that s procOf (c) , d 3 fi c, d 4 PathEdge do [27] Propagate (s procOf (c) , d 3 fi returnSite (c), d 5 ) <ref> [28] </ref> od Unlike edges in E # , edges are inserted into SummaryEdge on-the-fly.
Reference: 29. <author> Reps, T., </author> <title> Solving demand versions of interprocedural analysis prob lems, pp. </title> <booktitle> 389-403 in Proceedings of the Fifth International Conference on Compiler Construction, </booktitle> <address> (Edinburgh, Scotland, </address> <month> April 7-9, </month> <year> 1994), </year> <booktitle> Lecture Notes in Computer Science, </booktitle> <volume> Vol. 786, </volume> <editor> ed. P. Fritzson,Springer-Verlag, </editor> <address> New York, NY (1994). </address>
Reference-contexts: Furthermore, for interprocedural problems the Holley-Rosen approach is equivalent to the (impractical) Sharir-Pnueli call-strings approach. Reps investigated the use of deductive databases (i.e., logic programs with a bottom-up evaluation engine) to implement locally separable interprocedural dataflow-analysis problems <ref> [29] </ref>. This approach can be viewed as a pointwise tabulation method. Although the present paper does not make use of logic-programming terminology, the Tabulation Algorithm has a straightforward implementation as a logic program. <p> One of the benefits of the IFDS framework is that it permits a simple implementation of a demand algorithm for interprocedural dataflow analysis [27,17]. Other work on demand interprocedural dataflow analysis includes <ref> [29] </ref> and [11]. The IDE Framework Recently, we generalized the IFDS framework to a larger class of problems, called the IDE framework.
Reference: 30. <author> Sagiv, M., Reps, T., and Horwitz, S., </author> <title> Precise interprocedural dataflow analysis with applications to constant propagation, </title> <type> Unpublished Report, </type> <institution> Comp. Sci. Dept., Univ. of Wisconsin, Madison, </institution> <address> WI (Oct. </address> <year> 1994). </year> <note> (Submitted for conference publication.) </note>
Reference-contexts: / SummaryEdge then [25] Insert c, d 4 fi returnSite (c), d 5 into SummaryEdge [26] for each d 3 such that s procOf (c) , d 3 fi c, d 4 PathEdge do [27] Propagate (s procOf (c) , d 3 fi returnSite (c), d 5 ) [28] od <ref> [30] </ref> od [32] end case [33] case n (N p Call p - e p -) : [34] for each m, d 3 such that n, d 2 fi m, d 3 E # do [35] Propagate (s p , d 1 fi m, d 3 ) [36] od [37] end <p> In the IDE framework, the dataflow facts are maps (environments) from some finite set of symbols to some (possibly infinite) set of values, and the dataflow functions are distributive environment transformers <ref> [30] </ref>. (IDE stands for Inter-procedural Distributive Environment problems.) The IDE problems are a proper superset of the IFDS problems in that there are certain IDE problems (including variants of interprocedural constant propagation) that cannot be encoded as IFDS problems.
Reference: 31. <author> Sharir, M. and Pnueli, A., </author> <title> Two approaches to interprocedural data flow analysis, pp. 189-233 in Program Flow Analysis: Theory and Applications, </title> <editor> ed. S.S. Muchnick and N.D. Jones,Prentice-Hall, </editor> <address> Englewood Cliffs, NJ (1981). </address>
Reference-contexts: Full detailsincluding proofs of all theorems stated in the paperas well as a great deal of additional material, can be found in [27]. 2. The IFDS Framework for Distributive Interpro-cedural Dataflow-Analysis Problems The IFDS framework is a variant of Sharir and Pnueli's functional approach to interprocedural dataflow analysis <ref> [31] </ref>, with an extension similar to the one given by Knoop and Steffen in order to handle programs in which recursive procedures have local variables and parameters [21]. <p> Therefore, this preliminary experiment suggests that the extra precision of meet-over-all-valid-paths solutions to interprocedural dataflow-analysis problems can be obtained by the Tabulation Algorithm with acceptable cost. 7. Related Work Previous Interprocedural Dataflow-Analysis Frameworks The IFDS framework is based on earlier interprocedural dataflow-analysis frameworks defined by Sharir and Pnueli <ref> [31] </ref> and Knoop and Steffen [21]. <p> parameters (which the Sharir-Pnueli framework does not). (A different generalization to handle recursive procedures with local variables and parameters was proposed by Knoop and Steffen [21].) The IFDS problems can be solved by a number of previous algorithms, including the elimination, iterative, and call-strings algorithms given by Sharir and Pnueli <ref> [31] </ref> and the algorithm of Cousot and Cousot [10]. However, for general IFDS problems both the iterative and call-strings algorithms can take exponential time in the worst case. Knoop and Steffen give an algorithm similar to Sharir and Pnueli's elimination algorithm [21]. <p> Knoop and Steffen give an algorithm similar to Sharir and Pnueli's elimination algorithm [21]. The efficiencies of the Sharir-Pnueli and Knoop-Steffen elimination algorithms depend, among other things, on the way functions are represented. No representations are discussed in <ref> [31] </ref> and [21]. However, even if representation relations (as defined in Section 3.1) are used, because the Sharir-Pnueli and Knoop-Steffen algorithms manipulate functions as a whole, rather than pointwise, for distributive and h-sparse problems, they are not as efficient as the Tabulation Algorithm.
Reference: 32. <author> Zadeck, F.K., </author> <title> Incremental data flow analysis in a structured program editor, </title> <booktitle> Proceedings of the SIGPLAN 84 Symposium on Compiler Construction, </booktitle> <address> (Montreal, Can., </address> <month> June 20-22, </month> <year> 1984), </year> <journal> ACM SIGPLAN Notices 19(6) pp. </journal> <month> 132-143 (June </month> <year> 1984). </year>
Reference-contexts: then [25] Insert c, d 4 fi returnSite (c), d 5 into SummaryEdge [26] for each d 3 such that s procOf (c) , d 3 fi c, d 4 PathEdge do [27] Propagate (s procOf (c) , d 3 fi returnSite (c), d 5 ) [28] od [30] od <ref> [32] </ref> end case [33] case n (N p Call p - e p -) : [34] for each m, d 3 such that n, d 2 fi m, d 3 E # do [35] Propagate (s p , d 1 fi m, d 3 ) [36] od [37] end case [38] <p> Zadeck developed intraprocedural dataflow analysis algorithms based on the idea of partitioning a problem into many independent problems (e.g., on a per-bit basis in the case of separable problems) <ref> [32] </ref>. Although our technique of exploding a problem into the exploded super-graph transforms locally separable problems into a number of independent per-fact subproblems, the technique does not yield independent subproblems for h-sparse and general distributive IFDS problems.
References-found: 32

