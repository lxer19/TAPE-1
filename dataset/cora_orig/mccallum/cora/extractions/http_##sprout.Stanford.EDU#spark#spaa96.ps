URL: http://sprout.Stanford.EDU/spark/spaa96.ps
Refering-URL: http://www.csl.sri.com/pvs.html
Root-URL: http://www.aic.nrl.navy.mil/~aha/people.html
Email: park@turnip.stanford.edu dill@cs.stanford.edu  
Title: Verification of FLASH Cache Coherence Protocol By Aggregation of Distributed Transactions  
Author: Seungjoon Park David L. Dill 
Address: Stanford University  
Affiliation: Computer Systems Laboratory  
Date: 288-296, June, 1996  
Note: Published in Proceedings of 8th ACM Symposium on Parallel Algorithms and Architectures, pp.  
Abstract: To verify cache coherence protocols for distributed multiprocessor architectures, we compare a state graph of the implementation with a specification which is a state graph representing the simplified behavior. The steps in the specification correspond to atomic transactions, which are not atomic in the implementation. The method relies on an abstraction function which aggregates the implementation steps of each transaction into a single atomic transaction in the specification. The key idea in defining the abstraction function is that it must complete transactions which have committed but are not finished. This approach is applied to verification of the cache coherence protocol in the FLASH multiprocessor system. We illustrate how to determine an abstraction function which reduces the protocol to an atomic specification. The protocol consisting of more than a hundred implementation steps has been reduced into six kinds of atomic transactions. Based on the reduced behavior, it is very easy to prove crucial properties of the protocol including data consistency of cached copies at the user level. Moreover, the reduced model allows us to write a simple executable memory model of the protocol. The aggregation method is also used to prove that the reduced protocol satisfies a desired memory consistency model. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> J. Archibald and J. Baer. </author> <title> An economic solution to the cache coherence problem. </title> <booktitle> In Proc. 11th International Symposium on Computer Architecture, </booktitle> <pages> pages 355-362, </pages> <month> June </month> <year> 1984. </year>
Reference-contexts: The protocols control a number of readable and writable copies of each memory line for multiprocessors. Modification of one copy of a datum may require updating of other copies to maintain consistency among them. Several coherence protocols have been proposed for distributed multiprocessor architectures but few are formally verified <ref> [1, 15, 2, 10] </ref>. fl This research was supported by the Advanced Research Projects Agency through NASA grant NAG-2-891. Formal verification is desirable because there could be subtle bugs as the complexity of protocols increases. <p> It can prints out the value of system variables at user-specified points while exploring all the reachable states of the system. We present a simple test program which shows different behavior between the two modes of the protocol. Proc [0] : st #1, A; ld B, %r1; Proc <ref> [1] </ref> : st #1, B; ld A, %r2; The following is excerpted from the Mur' description for the above test program. <p> Rule `condition that pc [0], pc <ref> [1] </ref> are in final state' ==&gt; begin `print out memory and registers'; end; The list of all possible outcomes of the test program generated by the description is shown below. As expected, the output of Delayed mode is equivalent to that of the sequential consistency memory model.
Reference: [2] <author> L. Censier and P. Feautrier. </author> <title> A new solution to coherence problems in multicache systems. </title> <journal> IEEE Transactions on Computers, </journal> <volume> 27(12) </volume> <pages> 1112-1118, </pages> <month> December </month> <year> 1978. </year>
Reference-contexts: The protocols control a number of readable and writable copies of each memory line for multiprocessors. Modification of one copy of a datum may require updating of other copies to maintain consistency among them. Several coherence protocols have been proposed for distributed multiprocessor architectures but few are formally verified <ref> [1, 15, 2, 10] </ref>. fl This research was supported by the Advanced Research Projects Agency through NASA grant NAG-2-891. Formal verification is desirable because there could be subtle bugs as the complexity of protocols increases.
Reference: [3] <author> D. Dill, A. Drexler, A. Hu, and C. Yang. </author> <title> Protocol verification as a hardware design aid. </title> <booktitle> In International Conference on Computer Design: VLSI in Computers. IEEE Computer Society, </booktitle> <year> 1992. </year>
Reference-contexts: Formal verification is desirable because there could be subtle bugs as the complexity of protocols increases. Although finite-state methods (e.g. <ref> [3, 5] </ref>) can solve many verification problems with little effort, they are basically limited to finite-state protocols. The finite-state techniques we have applied do not scale especially well for the implementation-detailed cache coherence protocols.
Reference: [4] <author> David Dill, Seungjoon Park, and Andreas Nowatzyk. </author> <title> Formal specification of abstract memory models. </title> <booktitle> In Research on Integrated Systems: Proceedings of the 1993 Symposium, </booktitle> <pages> pages 38-52. </pages> <publisher> MIT Press, </publisher> <month> March </month> <year> 1993. </year>
Reference-contexts: Moreover, the different behavior between the memory models is important to the users, especially to programmers, because the outputs of programs could be different depending on the modes the multiprocessor is running in. We have previously developed executable descriptions of memory models <ref> [4, 12] </ref>, derived from axiomatic specifications of memory models. We can apply the same technique for this protocol using the reduced behavior of the FLASH protocol in Table 1.
Reference: [5] <author> Asgeir Eirksson and Ken McMillan. </author> <title> Using formal verification/analysis methods on the critical path in system design: A case study. </title> <booktitle> In Computer Aided Verification, 7th International Conference, CAV'95, </booktitle> <pages> pages 367-380, </pages> <month> July </month> <year> 1995. </year>
Reference-contexts: Formal verification is desirable because there could be subtle bugs as the complexity of protocols increases. Although finite-state methods (e.g. <ref> [3, 5] </ref>) can solve many verification problems with little effort, they are basically limited to finite-state protocols. The finite-state techniques we have applied do not scale especially well for the implementation-detailed cache coherence protocols.
Reference: [6] <author> P. Gibbons, M. Merritt, and K. Gharachorloo. </author> <title> Proving sequential consistency of high-performance shared memories. </title> <booktitle> In Proc. 3rd ACM Symposium on Parallel Algorithms and Architectures, </booktitle> <pages> pages 292-303, </pages> <year> 1991. </year>
Reference-contexts: This difference is visible to users and may affect the correctness of synchronization code. In this section, we show that the Delayed mode implements the sequential consistency memory model [9], if the processors execute instructions in a sequential order one at a time, stalling at each cache miss <ref> [6] </ref>. For the proof, we use the aggregation method again.
Reference: [7] <author> Mark Heinrich. </author> <title> The FLASH Protocol. Internal document, </title> <institution> Stanford University FLASH Group, </institution> <year> 1993. </year>
Reference-contexts: We have recently developed a method for simplifying automatic proofs of cache coherence protocols and similar distributed algorithms using "aggregation" [13]. Using this method, we have formally verified the cache coherence protocol of the FLASH multiprocessor at the level of its formal description <ref> [8, 7] </ref>. The protocol consisting of more than a hundred different implementation steps has been reduced to a model with only six kinds of atomic transactions. <p> First, we must prove that the initial states of the protocol satisfy Inv, and second, that the implementation transition functions all preserve Inv. 3 FLASH Cache Coherence Protocol This section informally describes the cache coherence protocol used in the Stanford FLASH multiprocessor <ref> [8, 7] </ref>. The cache coherence protocol is directory-based so that it can support a large number of distributed processing nodes. Each cache line-sized block in memory is associated with directory header which keeps information about the line.
Reference: [8] <author> J. Kuskin, D. Ofelt, M. Heinrich, J. Heinlein, R. Simoni, K. Gharachorloo, J. Chapin, D. Nakahira, J. Baxter, M. Horowitz, A. Gupta, M. Rosenblum, and J. Hen-nessy. </author> <title> The Stanford FLASH multiprocessor. </title> <booktitle> In Proc. 21st International Symposium on Computer Architecture, </booktitle> <pages> pages 302-313, </pages> <month> April </month> <year> 1994. </year>
Reference-contexts: We have recently developed a method for simplifying automatic proofs of cache coherence protocols and similar distributed algorithms using "aggregation" [13]. Using this method, we have formally verified the cache coherence protocol of the FLASH multiprocessor at the level of its formal description <ref> [8, 7] </ref>. The protocol consisting of more than a hundred different implementation steps has been reduced to a model with only six kinds of atomic transactions. <p> First, we must prove that the initial states of the protocol satisfy Inv, and second, that the implementation transition functions all preserve Inv. 3 FLASH Cache Coherence Protocol This section informally describes the cache coherence protocol used in the Stanford FLASH multiprocessor <ref> [8, 7] </ref>. The cache coherence protocol is directory-based so that it can support a large number of distributed processing nodes. Each cache line-sized block in memory is associated with directory header which keeps information about the line.
Reference: [9] <author> Leslie Lamport. </author> <title> How to make a multiprocessor computer that correctly executes multiprocessor programs. </title> <journal> IEEE Transactions on Computers, </journal> <volume> 28(9) </volume> <pages> 690-691, </pages> <month> September </month> <year> 1979. </year>
Reference-contexts: This difference is visible to users and may affect the correctness of synchronization code. In this section, we show that the Delayed mode implements the sequential consistency memory model <ref> [9] </ref>, if the processors execute instructions in a sequential order one at a time, stalling at each cache miss [6]. For the proof, we use the aggregation method again.
Reference: [10] <author> D. Lenosky, J. Laudon, K. Gharachorloo, A. Gupta, and J. Hennessy. </author> <title> The directory-based cache coherence protocol for the DASH multiprocessor. </title> <booktitle> In Proc. 17th International Symposium on Computer Architecture, </booktitle> <pages> pages 148-159, </pages> <month> May </month> <year> 1990. </year>
Reference-contexts: The protocols control a number of readable and writable copies of each memory line for multiprocessors. Modification of one copy of a datum may require updating of other copies to maintain consistency among them. Several coherence protocols have been proposed for distributed multiprocessor architectures but few are formally verified <ref> [1, 15, 2, 10] </ref>. fl This research was supported by the Advanced Research Projects Agency through NASA grant NAG-2-891. Formal verification is desirable because there could be subtle bugs as the complexity of protocols increases.
Reference: [11] <author> S. Owre, J. Rushby, N. Shankar, and F. von Henke. </author> <title> Formal verification for fault-tolerant architectures: Prole-gomena to the design of PVS. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 21(2) </volume> <pages> 107-125, </pages> <month> February </month> <year> 1995. </year>
Reference-contexts: This method addresses the primary difficulty with using theorem proving for verification of real systems, which is the amount of human effort required to complete a proof, by making it easier to create appropriate abstraction functions. Although our work is based on using the PVS theorem-prover from SRI International <ref> [11] </ref>, the method is equally appropriate for other theorem-proving systems. For our method to be applicable, the description must have an identifiable set of transactions. Each transaction must have a unique commit step, at which a state change first becomes visible to the specification.
Reference: [12] <author> Seungjoon Park and David Dill. </author> <title> An executable specification, analyzer and verifier for RMO (Relaxed Memory Order). </title> <booktitle> In Proc. 7th ACM Symposium on Parallel Algorithms and Architectures, </booktitle> <pages> pages 34-41, </pages> <month> July </month> <year> 1995. </year>
Reference-contexts: Moreover, the different behavior between the memory models is important to the users, especially to programmers, because the outputs of programs could be different depending on the modes the multiprocessor is running in. We have previously developed executable descriptions of memory models <ref> [4, 12] </ref>, derived from axiomatic specifications of memory models. We can apply the same technique for this protocol using the reduced behavior of the FLASH protocol in Table 1.
Reference: [13] <author> Seungjoon Park and David Dill. </author> <title> Protocol verification by aggregation of distributed actions. </title> <booktitle> In Computer Aided Verification, 8th International Conference, </booktitle> <address> CAV'96, </address> <month> July </month> <year> 1996. </year>
Reference-contexts: Consequently, previous theorem proving approaches have not been able to verify a problem of the scale of a full multiprocessor cache coherence protocol. We have recently developed a method for simplifying automatic proofs of cache coherence protocols and similar distributed algorithms using "aggregation" <ref> [13] </ref>. Using this method, we have formally verified the cache coherence protocol of the FLASH multiprocessor at the level of its formal description [8, 7]. The protocol consisting of more than a hundred different implementation steps has been reduced to a model with only six kinds of atomic transactions.
Reference: [14] <author> Fong Pong and Michel Dubois. </author> <title> The verification of cache coherence protocols. </title> <booktitle> In Proc. 5th ACM Symposium on Parallel Algorithms and Architectures, </booktitle> <pages> pages 11-20, </pages> <year> 1993. </year>
Reference-contexts: The finite-state techniques we have applied do not scale especially well for the implementation-detailed cache coherence protocols. For example, Mur' verifier can barely handle the protocols with 3 processors and 2 memory lines, using 100 megabytes of memory in the process. Symbolic state models proposed by Pong and Dubois <ref> [14] </ref> use symbolic states which abstract away from exact number of configurations of replicated identical components by recording only whether there are zero, one, or more than zero replicated components.
Reference: [15] <author> W. C. Yen and W. L. Yen. </author> <title> Data coherence problem in a multicache system. </title> <journal> IEEE Transactions on Computers, </journal> <volume> 34(1), </volume> <month> January </month> <year> 1985. </year>
Reference-contexts: The protocols control a number of readable and writable copies of each memory line for multiprocessors. Modification of one copy of a datum may require updating of other copies to maintain consistency among them. Several coherence protocols have been proposed for distributed multiprocessor architectures but few are formally verified <ref> [1, 15, 2, 10] </ref>. fl This research was supported by the Advanced Research Projects Agency through NASA grant NAG-2-891. Formal verification is desirable because there could be subtle bugs as the complexity of protocols increases.
References-found: 15

