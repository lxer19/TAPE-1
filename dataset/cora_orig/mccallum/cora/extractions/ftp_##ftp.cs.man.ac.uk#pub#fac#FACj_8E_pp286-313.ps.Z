URL: ftp://ftp.cs.man.ac.uk/pub/fac/FACj_8E_pp286-313.ps.Z
Refering-URL: http://www.cs.man.ac.uk/fmethods/facj/e-papers/index.html
Root-URL: http://www.cs.man.ac.uk
Title: of Computing Compositional Minimisation of Finite State Systems Using Interface Specifications  
Author: Susanne Graf Bernhard Steffen and Gerald Luttgen 
Keyword: Bisimulation; Distributed system; Interface specification; Minimi-sation; State explosion problem  
Address: Germany  
Affiliation: 1 VERIMAG, Monbonnot, France 2 Fakultat fur Mathematik und Informatik, Universitat Passau,  
Note: Formal Aspects of Computing (1996) 8E: 286 313 c 1996 BCS Formal Aspects  
Abstract: We present a method for the compositional construction of the minimal transition system that represents the semantics of a given distributed system. Our aim is to control the state explosion caused by the interleavings of actions of communicating parallel components by reduction steps that exploit global communication constraints given in terms of interface specifications. The effect of the method, which is developed for bisimulation semantics here, depends on the structure of the distributed system under consideration, and the accuracy of the interface specifications. However, its correctness is independent of the correctness of the interface specifications provided by the program designer. 
Abstract-found: 1
Intro-found: 1
Reference: [BCG86] <author> Browne, M.C., Clarke, E.M. and Grumberg, O.: </author> <title> Reasoning about networks with many identical finite state processes. </title> <booktitle> ACM Symposium on Principle of Distributed Computing, </booktitle> <year> 1986. </year> <type> 312 S. </type> <institution> Graf et al. </institution>
Reference-contexts: Also Vaandrager [Vaa90] observes that in most situations partial information about the traces of processes is sufficient to prove that part of a specification is redundant and can be omitted. The methods proposed in <ref> [BCG86, KuM89, StG89, WoL89] </ref> are tailored to verify properties of classes of systems that are systematically built from large numbers of identical processes. These methods are somewhat orthogonal to ours. This suggests to consider a combination of both types of methods.
Reference: [BFH90] <author> Bouajjani, A., Fernandez, J.-C. and Halbwachs, N.: </author> <title> Minimal model generation. </title> <booktitle> In Workshop on Automatic Verification '90, volume 531 of LNCS, </booktitle> <year> 1990. </year>
Reference-contexts: In [LSW94] a constraint-oriented state-based proof methodology for concurrent software systems is presented which exploits compositionality and abstraction for the reduction of the (possibly infinite) verification problem under consideration. There, Modal Transition Systems are used for fine-granular, loose state-based specifications of constraints. Halbwachs et al. <ref> [BFH90] </ref> proposed a method of the second category. It constructs directly a transition system minimised with respect to bisimulations by successive refinement of a single state. In this method symbolic computation is needed in order to keep the expressions small which in general may grow exponentially.
Reference: [Bry86] <author> Bryant, R.: </author> <title> Graph-based algorithms for boolean function manipulation. </title> <journal> IEEE Transactions on Computation, </journal> <volume> 35(8), </volume> <year> 1986. </year>
Reference-contexts: These methods are somewhat orthogonal to ours. This suggests to consider a combination of both types of methods. In practice, Binary Decision Diagrams are used to code state graphs for an interesting class of systems <ref> [Bry86] </ref>. These codings do not explode directly, but they may explode during verification. All mentioned techniques can be accompanied by abstraction. Parallel systems may be dramatically reduced by suppressing constraints that are irrelevant for the verification of the particular property under consideration [CoC77, CGL92, ClR94, DGG93, LGS95]. 1.2.
Reference: [CoC77] <author> Cousot, P. and Cousot, R.: </author> <title> Abstract interpretation: A unified lattice model for static analysis of programs by construction and approximation of fixpoints. </title> <booktitle> In Symp. Principles of Programming Languages '77, </booktitle> <year> 1977. </year>
Reference-contexts: These codings do not explode directly, but they may explode during verification. All mentioned techniques can be accompanied by abstraction. Parallel systems may be dramatically reduced by suppressing constraints that are irrelevant for the verification of the particular property under consideration <ref> [CoC77, CGL92, ClR94, DGG93, LGS95] </ref>. 1.2. Structure of the Paper The remainder of the paper is structured as follows. Section 2 presents the basic notions, and Section 3 the reduction operators on which our method, the RM-Method, is based.
Reference: [CES83] <author> Clarke, E.M., Emerson, E.A. and Sistla, E.: </author> <title> Automatic verification of finite state concurrent systems using temporal logic specification: A practical approach. </title> <booktitle> In Symp. Principles of Programming Languages '83, </booktitle> <year> 1983. </year>
Reference-contexts: 1. Introduction Many tools for the automatic analysis or verification of finite state distributed systems are based on the construction of the global state graph of the system under consideration (cf. <ref> [CES83, CPS93, FSS83, Ste94] </ref>). Thus, they often fail because of the state explosion problem: the state space of a distributed system potentially increases exponentially in the number of its parallel components.
Reference: [CGL92] <author> Clarke, E.M., Grumberg, O. and Long, D.: </author> <title> Model checking and abstraction. </title> <booktitle> In Symp. Principles of Programming Languages '92, </booktitle> <year> 1992. </year>
Reference-contexts: These codings do not explode directly, but they may explode during verification. All mentioned techniques can be accompanied by abstraction. Parallel systems may be dramatically reduced by suppressing constraints that are irrelevant for the verification of the particular property under consideration <ref> [CoC77, CGL92, ClR94, DGG93, LGS95] </ref>. 1.2. Structure of the Paper The remainder of the paper is structured as follows. Section 2 presents the basic notions, and Section 3 the reduction operators on which our method, the RM-Method, is based.
Reference: [CLM89] <author> Clarke, E.M., Long, D. and McMillan, K.: </author> <title> Compositional model checking. </title> <booktitle> Proc. IEEE Symp. Logic in Computer Science, </booktitle> <pages> pages 353-362, </pages> <year> 1989. </year>
Reference-contexts: It constructs directly a transition system minimised with respect to bisimulations by successive refinement of a single state. In this method symbolic computation is needed in order to keep the expressions small which in general may grow exponentially. Another approach of this category was presented by Clarke et al. <ref> [CLM89] </ref>. They exploit the knowledge about the alphabet of interest in order to abstract and minimise the system's components. By using hLi operators together with an elementary rule for distributing them over the parallel operator (see Proposition 2.7) our method covers this approach. <p> Definition of P 1 , P 2 , and B. This proposition allows us to localise global hiding informations. In fact, this localisation is the essence of the construction of interface processes in <ref> [CLM89] </ref>. The proof of the proposition is done by induction similar to the proof of Theorem 3.9 including a case analysis according to Definition 2.5 in the induction step. We finish this section by presenting a simple example, which accompanies the development of our method. Example 2.8. <p> This is very important, because it allows the designer to simply "guess" interface specifications, while maintaining the reliability of a successful verification. Indeed, a way to obtain interface specifications is by using the property to be verified as interface specification. This is what Clarke et al. <ref> [CLM89] </ref> had in mind. However, their approach only exploits the alphabet of the property under consideration. A refined treatment of property constraints using our notion of interface specification is under investigation.
Reference: [CPS93] <author> Cleaveland, R., Parrow, J. and Steffen, B.: </author> <title> The Concurrency Workbench: A semantics-based tool for the verification of finite-state systems. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 15(1) </volume> <pages> 36-72, </pages> <month> January </month> <year> 1993. </year>
Reference-contexts: 1. Introduction Many tools for the automatic analysis or verification of finite state distributed systems are based on the construction of the global state graph of the system under consideration (cf. <ref> [CES83, CPS93, FSS83, Ste94] </ref>). Thus, they often fail because of the state explosion problem: the state space of a distributed system potentially increases exponentially in the number of its parallel components.
Reference: [ClR94] <author> Cleaveland, R. and Riely, J.: </author> <title> Testing-based abstractions for value passing systems. </title> <booktitle> In Proceedings of CONCUR'94, Stockholm (Sweden), volume 836 of LNCS, </booktitle> <year> 1994. </year>
Reference-contexts: These codings do not explode directly, but they may explode during verification. All mentioned techniques can be accompanied by abstraction. Parallel systems may be dramatically reduced by suppressing constraints that are irrelevant for the verification of the particular property under consideration <ref> [CoC77, CGL92, ClR94, DGG93, LGS95] </ref>. 1.2. Structure of the Paper The remainder of the paper is structured as follows. Section 2 presents the basic notions, and Section 3 the reduction operators on which our method, the RM-Method, is based.
Reference: [CS90a] <author> Cleaveland, R. and Steffen, B.: </author> <title> A preorder for partial process specifications. </title> <booktitle> In Proceedings of CONCUR'90, </booktitle> <address> Amsterdam (Netherlands), </address> <booktitle> volume 458 of LNCS, </booktitle> <year> 1990. </year>
Reference-contexts: Especially, isomorphic processes are d -equivalent. The following preorder which intuitively defines a "less defined than" rela tion between processes is the basis of the framework in which we establish the correctness of our RM-Method (cf. <ref> [CS90a] </ref>). Definition 2.10. (Specification Preorder) Let (S; A [ fo g; !; ") be an ex tended transition system. <p> We do not want to cover divergence, i.e. the potential of an infinite internal computation, but (guarded) undefinedness. This establishes as a specification-implementation relation: a partial specification p is met by an implementation q if and only if p q; in contrast to <ref> [CS90a, Wal88] </ref> we do not require an implementation of an a-undefined process to possess any a-transition. This modification enhances the practicality of the preorder as specification-implementation relation. A more detailed discussion can be found in [CS90a]. Observational equivalence and our specification-preorder induce slightly different semantics on processes. <p> This modification enhances the practicality of the preorder as specification-implementation relation. A more detailed discussion can be found in <ref> [CS90a] </ref>. Observational equivalence and our specification-preorder induce slightly different semantics on processes. However, by definitions of d , , and we have that d is a refinement of both. Proposition 2.11.
Reference: [CS90b] <author> Cleaveland, R. and Steffen, B.: </author> <title> When is "partial" adequate? A logic-based proof technique using partial specifications. </title> <booktitle> Proc. IEEE Symp. Logic in Computer Science, </booktitle> <year> 1990. </year>
Reference-contexts: This is mainly due to the fact that parts need to be considered that can never be reached in the global context. Partial or loose specifications allow us to "cut off" these unreachable parts. As in <ref> [CS90b, Kru89, LaT88, ShG90, Wal88] </ref> we exploit this feature to take advantage of context information. Furthermore, we refer to the size of the maximal transition system that is encountered by our method as the algorithmic complexity. <p> Proposition 2.11. For all processes p; q 2 P we have p d q implies p q and p q, and for totally defined processes d , , and coincide. 3 This definition of semantical equivalence is adapted from <ref> [CS90b] </ref> where it is presented for processes expressed in a CCS-based algebra. Compositional Minimisation of State Systems 295 Moreover, it can be proved in the usual way that both k and hLi preserve and d which is of particular importance for our minimisation method.
Reference: [DGG93] <author> Dams, D., Grumberg, G. and Gerth, R.: </author> <title> Generation of reduced models for checking fragments of CTL. </title> <booktitle> In Proceedings of the International Conference on Computer-Aided Verification (CAV'93), volume 697 of LNCS, </booktitle> <pages> pages 479-490, </pages> <year> 1993. </year>
Reference-contexts: These codings do not explode directly, but they may explode during verification. All mentioned techniques can be accompanied by abstraction. Parallel systems may be dramatically reduced by suppressing constraints that are irrelevant for the verification of the particular property under consideration <ref> [CoC77, CGL92, ClR94, DGG93, LGS95] </ref>. 1.2. Structure of the Paper The remainder of the paper is structured as follows. Section 2 presents the basic notions, and Section 3 the reduction operators on which our method, the RM-Method, is based.
Reference: [Fer88] <author> Fernandez, J.-C.: Aldebaran: </author> <title> Un Systeme de Verification par Reduction de Pro-cessus Communicants. </title> <type> PhD thesis, </type> <institution> Universite de Grenoble, </institution> <year> 1988. </year>
Reference-contexts: 1 k I 1 P 2 kB 2 k I 2 : : : k I n1 P n kB n )hftk 1 ; : : : ; tk n gi Table 1 summarises a quantitative evaluation of the effect of our method by means of the Aldebaran Verification Tool <ref> [Fer88] </ref>. It displays the size of the global state graph (its apparent complexity), the size of the maximal transition system constructed during stepwise minimisation when exploiting exact interface specifications (its algorithmic complexity), and the size of the minimised global state graph (its reduced complexity). <p> However, the RM-Method is not tailored to this particular semantic equivalence. Other equivalences can be dealt with by adapting the preorder definition and the minimisation function accordingly. The RM-Method is implemented as part of the MetaFrame environment [SMC96] and the Aldebaran verification tool <ref> [Fer88] </ref> for the reduction operator and the semantical equivalence d . The effect of our method, which is intended to get the algorithmic complexity as close as possible to the reduced complexity, depends on interface specifications, which we assume to be given by the program designer.
Reference: [FSS83] <author> Fernandez, J.-C., Schwartz, J.-Ph. and Sifakis, J.: </author> <title> An example of specification and verification in Cesar `the analysis of concurrent systems'. </title> <booktitle> Volume 207 of LNCS, </booktitle> <year> 1983. </year>
Reference-contexts: 1. Introduction Many tools for the automatic analysis or verification of finite state distributed systems are based on the construction of the global state graph of the system under consideration (cf. <ref> [CES83, CPS93, FSS83, Ste94] </ref>). Thus, they often fail because of the state explosion problem: the state space of a distributed system potentially increases exponentially in the number of its parallel components.
Reference: [GrL93] <author> Graf, S. and Loiseaux, C.: </author> <title> Program verification using compositional abstraction. </title> <booktitle> In Proceedings FASE/TAPSOFT'93, </booktitle> <year> 1993. </year>
Reference: [GSL95] <author> Graf, S., Steffen, B. and Luttgen, G.: </author> <title> Compositional minimization of finite state systems using interface specifications. </title> <type> Technical Report MIP-9505, </type> <institution> Universitat Passau, Passau, Germany, </institution> <month> January </month> <year> 1995. </year>
Reference-contexts: Finally, Section 5 draws our conclusions. A version of this paper including detailed proofs is available as technical report <ref> [GSL95] </ref>. 290 S. Graf et al. 2. General Notions Our framework is based on processes (systems) as labelled transition systems extended by an undefinedness predicate on states. Processes can be structured by means of parallel composition and hiding, thus allowing a hierarchical treatment.
Reference: [GoW91] <author> Godefroid, P. and Wolper, P.: </author> <title> Using partial orders for the efficient verification of deadlock freedom and safety properties. </title> <booktitle> In Proceedings of the International Workshop on Computer-Aided Verification (CAV'91), volume 575 of LNCS, </booktitle> <pages> pages 332-342, </pages> <year> 1991. </year>
Reference-contexts: The main disadvantage of his method is that the algorithm is exponential in the size of the assumptions about the environment. Other methods try to avoid the state explosion problem using preorders for verification <ref> [GoW91, Pel93, Val93] </ref> where unnecessary interleavings of actions are suppressed. In [LSW94] a constraint-oriented state-based proof methodology for concurrent software systems is presented which exploits compositionality and abstraction for the reduction of the (possibly infinite) verification problem under consideration.
Reference: [Hoa85] <author> Hoare, </author> <title> C.A.R.: Communicating Sequential Processes. </title> <publisher> Prentice Hall International, </publisher> <year> 1985. </year>
Reference-contexts: Intuitively, pkq is the parallel composition of the processes p and q with synchronisation of the actions common to both of their alphabets and interleaving of the others 292 S. Graf et al. (like in CSP <ref> [Hoa85] </ref>), and phLi is the process in which only the actions in L are observable.
Reference: [Jos87] <author> Josko, B.: </author> <title> MCTL an extension of CTL for modular verification of concurrent systems. </title> <booktitle> In Workshop on Temporal Logic in Specification, volume 398 of LNCS, </booktitle> <year> 1987. </year>
Reference-contexts: Compositional Minimisation of State Systems 289 on "guesses" for context specifications. However, in contrast to our method it requires a separate proof of the correctness of these guesses. Another method based on interface specifications which must be proved correct separately is given in [Kru89]. Josko <ref> [Jos87] </ref> also presented a method, where the assumptions on the environment of a component are expressed by a formula, which must be proved in a separate step. The main disadvantage of his method is that the algorithm is exponential in the size of the assumptions about the environment.
Reference: [Kil73] <author> Kildall, G. A.: </author> <title> A unified approach to global program optimization. </title> <booktitle> In Symp. Principles of Programming Languages '73, </booktitle> <pages> pages 194 - 206, </pages> <year> 1973. </year>
Reference-contexts: The local abstract semantics can be globalised according to two strategies: the "operational" join over all paths (JOP) strategy, which directly reflects the intuition behind the analysis problem, and the "denotational" minimal fixed point (MFP) strategy, which is algorithmic (cf. <ref> [Kil73, KaU77] </ref>). 9 In the following P [q; q 0 ] denotes the set of all finite paths from q to q 0 and c 0 the initial informa tion valid at the start state of p.
Reference: [KuM89] <author> Kurshan, R.P. and McMillan, K.: </author> <title> A structural induction theorem for processes. </title> <booktitle> In ACM Symposium on Principles of Distributed Computing, </booktitle> <year> 1989. </year>
Reference-contexts: Also Vaandrager [Vaa90] observes that in most situations partial information about the traces of processes is sufficient to prove that part of a specification is redundant and can be omitted. The methods proposed in <ref> [BCG86, KuM89, StG89, WoL89] </ref> are tailored to verify properties of classes of systems that are systematically built from large numbers of identical processes. These methods are somewhat orthogonal to ours. This suggests to consider a combination of both types of methods.
Reference: [Kru89] <author> Krumm, H.: </author> <title> Projections of the reachability graph and environment models, two approaches to facilitate the functional analysis of systems of cooperating finite state machines. In Workshop on Automatic Verification of Finite State Systems, Grenoble (France), </title> <booktitle> volume 407 of LNCS, </booktitle> <year> 1989. </year>
Reference-contexts: This is mainly due to the fact that parts need to be considered that can never be reached in the global context. Partial or loose specifications allow us to "cut off" these unreachable parts. As in <ref> [CS90b, Kru89, LaT88, ShG90, Wal88] </ref> we exploit this feature to take advantage of context information. Furthermore, we refer to the size of the maximal transition system that is encountered by our method as the algorithmic complexity. <p> Compositional Minimisation of State Systems 289 on "guesses" for context specifications. However, in contrast to our method it requires a separate proof of the correctness of these guesses. Another method based on interface specifications which must be proved correct separately is given in <ref> [Kru89] </ref>. Josko [Jos87] also presented a method, where the assumptions on the environment of a component are expressed by a formula, which must be proved in a separate step. The main disadvantage of his method is that the algorithm is exponential in the size of the assumptions about the environment.
Reference: [KaU77] <author> Kam, J. B. and Ullman, J. D.: </author> <title> Monotone data flow analysis frameworks. </title> <journal> Acta Informatica, </journal> <volume> 7 </volume> <pages> 309-317, </pages> <year> 1977. </year>
Reference-contexts: The local abstract semantics can be globalised according to two strategies: the "operational" join over all paths (JOP) strategy, which directly reflects the intuition behind the analysis problem, and the "denotational" minimal fixed point (MFP) strategy, which is algorithmic (cf. <ref> [Kil73, KaU77] </ref>). 9 In the following P [q; q 0 ] denotes the set of all finite paths from q to q 0 and c 0 the initial informa tion valid at the start state of p. <p> As in our application, this often leads to an algorithmic description. The well-known coincidence theorem of Kam and Ullman <ref> [KaU77] </ref> bridges the gap between the JOP-Solution and the MFP-Solution.
Reference: [LGS95] <author> Loiseaux, C., Graf, S., Sifakis, J., Bouajjani, A. and Bensalem, S.: </author> <title> Property preserving abstractions for the verification of concurrent systems. </title> <booktitle> Formal Methods in System Design, </booktitle> <volume> Vol 6, Iss 1, </volume> <year> 1995. </year>
Reference-contexts: These codings do not explode directly, but they may explode during verification. All mentioned techniques can be accompanied by abstraction. Parallel systems may be dramatically reduced by suppressing constraints that are irrelevant for the verification of the particular property under consideration <ref> [CoC77, CGL92, ClR94, DGG93, LGS95] </ref>. 1.2. Structure of the Paper The remainder of the paper is structured as follows. Section 2 presents the basic notions, and Section 3 the reduction operators on which our method, the RM-Method, is based.
Reference: [LSW94] <author> Larsen, K. G., Steffen, B. and Weise, C.: </author> <title> A constraint oriented proof methodology based on modal transition systems. </title> <booktitle> In BRICS Notes 94-6, </booktitle> <month> December </month> <year> 1994. </year> <title> Compositional Minimisation of State Systems 313 </title>
Reference-contexts: The main disadvantage of his method is that the algorithm is exponential in the size of the assumptions about the environment. Other methods try to avoid the state explosion problem using preorders for verification [GoW91, Pel93, Val93] where unnecessary interleavings of actions are suppressed. In <ref> [LSW94] </ref> a constraint-oriented state-based proof methodology for concurrent software systems is presented which exploits compositionality and abstraction for the reduction of the (possibly infinite) verification problem under consideration. There, Modal Transition Systems are used for fine-granular, loose state-based specifications of constraints.
Reference: [LaT88] <author> Larsen, K. G. and Thomsen, B.: </author> <title> Compositional proofs by partial specification of processes. </title> <booktitle> Proc. IEEE Symp. Logic in Computer Science, </booktitle> <year> 1988. </year>
Reference-contexts: This is mainly due to the fact that parts need to be considered that can never be reached in the global context. Partial or loose specifications allow us to "cut off" these unreachable parts. As in <ref> [CS90b, Kru89, LaT88, ShG90, Wal88] </ref> we exploit this feature to take advantage of context information. Furthermore, we refer to the size of the maximal transition system that is encountered by our method as the algorithmic complexity. <p> They exploit the knowledge about the alphabet of interest in order to abstract and minimise the system's components. By using hLi operators together with an elementary rule for distributing them over the parallel operator (see Proposition 2.7) our method covers this approach. Larsen and Thomsen <ref> [LaT88] </ref>, and Walker [Wal88] use partial specifications in order to take context constraints into account. Our method is an elaboration of theirs. It uses a more appropriate preorder and defines a concrete strategy for (semi-)automatic proofs where the required user support is kept to a minimum.
Reference: [LaX90] <author> Larsen, K.G. and Xinxin, L.: </author> <title> Compositionality through an operational semantics of contexts. </title> <booktitle> In ICALP'90, volume 443 of LNCS, </booktitle> <year> 1990. </year>
Reference-contexts: Unfortunately, the decomposition rules for processes involving the parallel operator are very restricted. Larsen and Xinxin <ref> [LaX90] </ref> follow a similar line, however, their decomposition rules are based on an operational semantics of contexts rather than the syntax.
Reference: [Mil80] <author> Milner, R.: </author> <title> A calculus for communicating systems. </title> <booktitle> Volume 92 of LNCS, </booktitle> <year> 1980. </year>
Reference-contexts: Graf et al. specifications are correct. 2 This guarantees the completeness of the RM Method. 3. P i has the least number of states and transitions in its semantic equivalence class. In this paper, we are dealing with a refinement d of observational equivalence <ref> [Mil80, Mil89] </ref>. However, the method also adapts to other equivalences. Technically, we use a new operator, called reduction operator, in each step P i where 1 i &lt; n. <p> Processes can be structured by means of parallel composition and hiding, thus allowing a hierarchical treatment. The introduction of undefinedness predicates naturally leads to a specification-implementation preorder between processes, which induces a slightly finer semantics on processes than observational equivalence <ref> [Mil80, Mil89] </ref>. This equivalence is captured by our technique, which is based on the notion of interface specification introduced subsequently. 2.1. <p> Our method concentrates on this form which is called standard concurrent form in CCS <ref> [Mil80, Mil89] </ref>. Usually, the following correspondence between the parallel operator and the window operators is exploited in compositional minimisation techniques. Proposition 2.7. (Window Operator Law) Let p; q 2 P and let L; L 0 be sets of visible actions such that L 0 L [(A p "A q ). <p> The `incoming' arrows point to the start states of the processes. 2.3. Semantical Equivalence and Preorder In this section we define a semantical equivalence of extended labelled transition systems in terms of observational equivalence <ref> [Mil80, Mil89] </ref> and establish a 294 S. Graf et al. specification-implementation relation in terms of a preorder, which is compatible with this semantics. This preorder plays a key role in the correctness proof of our RM-Method. <p> Moreover, d coincides with the well-known observational equivalence <ref> [Mil80, Mil89] </ref> if the first of the three defining requirements is dropped. Especially, isomorphic processes are d -equivalent. The following preorder which intuitively defines a "less defined than" rela tion between processes is the basis of the framework in which we establish the correctness of our RM-Method (cf. [CS90a]).
Reference: [Mil89] <author> Milner, R.: </author> <title> Communication and Concurrency. </title> <publisher> Prentice Hall, </publisher> <year> 1989. </year>
Reference-contexts: Graf et al. specifications are correct. 2 This guarantees the completeness of the RM Method. 3. P i has the least number of states and transitions in its semantic equivalence class. In this paper, we are dealing with a refinement d of observational equivalence <ref> [Mil80, Mil89] </ref>. However, the method also adapts to other equivalences. Technically, we use a new operator, called reduction operator, in each step P i where 1 i &lt; n. <p> Processes can be structured by means of parallel composition and hiding, thus allowing a hierarchical treatment. The introduction of undefinedness predicates naturally leads to a specification-implementation preorder between processes, which induces a slightly finer semantics on processes than observational equivalence <ref> [Mil80, Mil89] </ref>. This equivalence is captured by our technique, which is based on the notion of interface specification introduced subsequently. 2.1. <p> Our method concentrates on this form which is called standard concurrent form in CCS <ref> [Mil80, Mil89] </ref>. Usually, the following correspondence between the parallel operator and the window operators is exploited in compositional minimisation techniques. Proposition 2.7. (Window Operator Law) Let p; q 2 P and let L; L 0 be sets of visible actions such that L 0 L [(A p "A q ). <p> The `incoming' arrows point to the start states of the processes. 2.3. Semantical Equivalence and Preorder In this section we define a semantical equivalence of extended labelled transition systems in terms of observational equivalence <ref> [Mil80, Mil89] </ref> and establish a 294 S. Graf et al. specification-implementation relation in terms of a preorder, which is compatible with this semantics. This preorder plays a key role in the correctness proof of our RM-Method. <p> Moreover, d coincides with the well-known observational equivalence <ref> [Mil80, Mil89] </ref> if the first of the three defining requirements is dropped. Especially, isomorphic processes are d -equivalent. The following preorder which intuitively defines a "less defined than" rela tion between processes is the basis of the framework in which we establish the correctness of our RM-Method (cf. [CS90a]).
Reference: [Pel93] <author> Peled, D.: </author> <title> All from one, one for all: on model checking using representatives. </title> <booktitle> In Proceedings of the International Conference on Computer Aided Verification (CAV'93), volume 697 of LNCS, </booktitle> <year> 1993. </year>
Reference-contexts: The main disadvantage of his method is that the algorithm is exponential in the size of the assumptions about the environment. Other methods try to avoid the state explosion problem using preorders for verification <ref> [GoW91, Pel93, Val93] </ref> where unnecessary interleavings of actions are suppressed. In [LSW94] a constraint-oriented state-based proof methodology for concurrent software systems is presented which exploits compositionality and abstraction for the reduction of the (possibly infinite) verification problem under consideration.
Reference: [Pnu90] <author> Pnueli, A.: </author> <title> In transition from global to modular temporal reasoning about programs. In Logics and Models for Concurrent Systems, </title> <booktitle> volume 13 of NATO ASI Series F. </booktitle> <publisher> Springer Verlag, </publisher> <year> 1990. </year>
Reference-contexts: Larsen and Xinxin [LaX90] follow a similar line, however, their decomposition rules are based on an operational semantics of contexts rather than the syntax. In order to deal with the problems that arise from parallel compositions, Pnueli <ref> [Pnu90] </ref> proposed a "conditional" inference system where assertions of the form OEP can be derived, meaning that the program P satisfies the property under the condition that its environment satisfies OE.
Reference: [StG89] <author> Stadler, Z. and Grumberg, O.: </author> <title> Network grammars, communication behaviours and automatic verification. In Workshop on Automatic Verification Methods for Finite State Systems, Grenoble (France), </title> <booktitle> volume 407 of LNCS, </booktitle> <year> 1989. </year>
Reference-contexts: Also Vaandrager [Vaa90] observes that in most situations partial information about the traces of processes is sufficient to prove that part of a specification is redundant and can be omitted. The methods proposed in <ref> [BCG86, KuM89, StG89, WoL89] </ref> are tailored to verify properties of classes of systems that are systematically built from large numbers of identical processes. These methods are somewhat orthogonal to ours. This suggests to consider a combination of both types of methods.
Reference: [ShG90] <author> Shurek, G. and Grumberg, O.: </author> <title> The modular framework of computer-aided verification. </title> <booktitle> In Workshop on Automatic Verification '90, volume 531 of LNCS, </booktitle> <pages> pages 214-223, </pages> <year> 1990. </year>
Reference-contexts: This is mainly due to the fact that parts need to be considered that can never be reached in the global context. Partial or loose specifications allow us to "cut off" these unreachable parts. As in <ref> [CS90b, Kru89, LaT88, ShG90, Wal88] </ref> we exploit this feature to take advantage of context information. Furthermore, we refer to the size of the maximal transition system that is encountered by our method as the algorithmic complexity. <p> This inference system has been used by Shurek and Grumberg in <ref> [ShG90] </ref>, where a semiautomatic modular verification method is presented which, like ours, is based 2 This does not mean that, in general, P i and R i are semantically equivalent for 1 i n 1. Compositional Minimisation of State Systems 289 on "guesses" for context specifications.
Reference: [SMC96] <author> Steffen, B., Margaria, T. and Claen, A.: </author> <title> Heterogeneous analysis and verification for distributed systems. </title> <journal> Software|Concepts and Tools, </journal> <volume> 17 </volume> <pages> 13-25, </pages> <year> 1996. </year>
Reference-contexts: Following Definition 3.3, I 2 (p) can now be derived by inserting some additional undefinednesses indicating a transition of p which is preempted by the interface. The result of the computation, which we have obtained running the MetaFrame environment <ref> [SMC96] </ref>, can be investigated using the Graph Inspector of our tool: the field node syntax in Fig. 4 shows that the highlighted state (p12kb2) has an rb2-undefinedess. A further investigation would reveal the tk1-undefinedness of (p11kb3) and the rb2-undefinedness of (p13kb1). 3.2. <p> In terms of DFA, the Language Labelling Procedure computes the minimal fixed point solution with respect to the start information L (I). The Language Labelling Procedure 3.20 has been implemented by means of a workset algorithm, as part of the MetaFrame environment <ref> [SMC96] </ref>. Its time and space complexity can be estimated by the product of the number of transitions of p and the number of states of I. As the algorithm does not exploit the structure of the representation of in terface specifications; this proves Theorem 3.5. 4. <p> However, the RM-Method is not tailored to this particular semantic equivalence. Other equivalences can be dealt with by adapting the preorder definition and the minimisation function accordingly. The RM-Method is implemented as part of the MetaFrame environment <ref> [SMC96] </ref> and the Aldebaran verification tool [Fer88] for the reduction operator and the semantical equivalence d .
Reference: [Ste94] <author> Steffen, B.: </author> <title> Finite model checking and beyond. </title> <booktitle> In BRICS Notes 94-6, </booktitle> <month> December </month> <year> 1994. </year>
Reference-contexts: 1. Introduction Many tools for the automatic analysis or verification of finite state distributed systems are based on the construction of the global state graph of the system under consideration (cf. <ref> [CES83, CPS93, FSS83, Ste94] </ref>). Thus, they often fail because of the state explosion problem: the state space of a distributed system potentially increases exponentially in the number of its parallel components.
Reference: [Vaa90] <author> Vaandrager, F.W.: </author> <title> Some observations on redundancy in a context. </title> <editor> In J.C.M. Baeten, editor, </editor> <booktitle> Applications of Process Algebra, volume 17 of Cambridge Tracts in Theoretical Computer Science, </booktitle> <pages> pages 237-260. </pages> <publisher> Cambridge University Press, </publisher> <year> 1990. </year>
Reference-contexts: Our method is an elaboration of theirs. It uses a more appropriate preorder and defines a concrete strategy for (semi-)automatic proofs where the required user support is kept to a minimum. Also Vaandrager <ref> [Vaa90] </ref> observes that in most situations partial information about the traces of processes is sufficient to prove that part of a specification is redundant and can be omitted.
Reference: [Val93] <author> Valmari, A.: </author> <title> On-the-fly verification with stubborn sets. </title> <booktitle> In Proceedings of the International Conference on Computer Aided Verification (CAV'93), volume 697 of LNCS, </booktitle> <pages> pages 397-408, </pages> <year> 1993. </year>
Reference-contexts: The main disadvantage of his method is that the algorithm is exponential in the size of the assumptions about the environment. Other methods try to avoid the state explosion problem using preorders for verification <ref> [GoW91, Pel93, Val93] </ref> where unnecessary interleavings of actions are suppressed. In [LSW94] a constraint-oriented state-based proof methodology for concurrent software systems is presented which exploits compositionality and abstraction for the reduction of the (possibly infinite) verification problem under consideration.
Reference: [Wal88] <author> Walker, </author> <title> D.J.: Bisimulation and divergence in CCS. </title> <booktitle> Proc. IEEE Symp. Logic in Computer Science, </booktitle> <year> 1988. </year>
Reference-contexts: This is mainly due to the fact that parts need to be considered that can never be reached in the global context. Partial or loose specifications allow us to "cut off" these unreachable parts. As in <ref> [CS90b, Kru89, LaT88, ShG90, Wal88] </ref> we exploit this feature to take advantage of context information. Furthermore, we refer to the size of the maximal transition system that is encountered by our method as the algorithmic complexity. <p> They exploit the knowledge about the alphabet of interest in order to abstract and minimise the system's components. By using hLi operators together with an elementary rule for distributing them over the parallel operator (see Proposition 2.7) our method covers this approach. Larsen and Thomsen [LaT88], and Walker <ref> [Wal88] </ref> use partial specifications in order to take context constraints into account. Our method is an elaboration of theirs. It uses a more appropriate preorder and defines a concrete strategy for (semi-)automatic proofs where the required user support is kept to a minimum. <p> S satisfying (p; q) 2 R implies for all a 2 A [ f*g with :(p * a). 1. :(q * a), a =) p 0 implies 9q 0 : q a 3. q =) q 0 implies 9p 0 : p a is a variant of the divergence preorder <ref> [Wal88] </ref> in which a-divergence does not require the potential of an a-move. Our modification serves for a different intend. We do not want to cover divergence, i.e. the potential of an infinite internal computation, but (guarded) undefinedness. <p> We do not want to cover divergence, i.e. the potential of an infinite internal computation, but (guarded) undefinedness. This establishes as a specification-implementation relation: a partial specification p is met by an implementation q if and only if p q; in contrast to <ref> [CS90a, Wal88] </ref> we do not require an implementation of an a-undefined process to possess any a-transition. This modification enhances the practicality of the preorder as specification-implementation relation. A more detailed discussion can be found in [CS90a]. Observational equivalence and our specification-preorder induce slightly different semantics on processes.
Reference: [Win90] <author> Winskel, G.: </author> <title> Compositional checking of validity on finite state processes. </title> <booktitle> In Workshop on Theories of Communication, CONCUR, volume 458 of LNCS, </booktitle> <year> 1990. </year>
Reference-contexts: This minimal representation can subsequently be used for all kinds of verification. A pure approach to compositional verification has been proposed by Winskel in <ref> [Win90] </ref>, where rules are given to decompose assertions of the form P j= depending on the syntax of the program P and the formula . Unfortunately, the decomposition rules for processes involving the parallel operator are very restricted.
Reference: [WoL89] <author> Wolper, P. and Lovinfosse, V.: </author> <title> Verifying properties of large sets of processes with network invariants. In Workshop on Automatic Verification Methods for Finite State Systems, </title> <address> Grenoble (France), </address> <note> volume 407 of LNCS, 1989. Received February 1995 Accepted in a revised form in May 1996 by A. </note> <editor> J. R. G. </editor> <publisher> Milner </publisher>
Reference-contexts: Also Vaandrager [Vaa90] observes that in most situations partial information about the traces of processes is sufficient to prove that part of a specification is redundant and can be omitted. The methods proposed in <ref> [BCG86, KuM89, StG89, WoL89] </ref> are tailored to verify properties of classes of systems that are systematically built from large numbers of identical processes. These methods are somewhat orthogonal to ours. This suggests to consider a combination of both types of methods.
References-found: 40

