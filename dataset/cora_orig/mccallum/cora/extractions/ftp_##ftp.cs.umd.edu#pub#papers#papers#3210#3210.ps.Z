URL: ftp://ftp.cs.umd.edu/pub/papers/papers/3210/3210.ps.Z
Refering-URL: http://www.cs.umd.edu/TRs/TR.html
Root-URL: 
Title: Dynamic Reconfiguration of Distributed Applications  
Author: Christine R. Hofmeister 
Address: College Park, MD 20742  
Affiliation: Department of Computer Science University of Maryland  
Abstract: Applications requiring concurrency or access to specialized hardware are naturally written as distributed applications, where each software component (module) can execute on a different machine, and modules interact via bindings. In order to make changes to very long-running applications or those that must be continuously available, we must dynamically change the application. Dynamic reconfiguration of a distributed application is the act of changing the configuration of the application as it executes. Examples of configuration changes are replacing a module, moving a module to another machine, and adding or removing modules from the application. The most challenging aspect of dynamic reconfiguration is that an application in execution has state information, both within the modules and within the communication channels between modules. This state information may need to be transferred from the old configuration to the new in order to reach an application state compatible with the new configuration. Thus, in addition to requiring a mechanism for changing the configuration during execution, dynamic reconfiguration requires that modules be able to divulge and install state information, and requires a mechanism for coordinating the communication during reconfiguration. Prior to this work, all systems supporting some form of dynamic reconfiguration have given the application programmer no support nor even guidelines for capturing and restoring an application's state information. We have developed a machine-independent method for installing this functionality in the application, given a set of reconfiguration points designated by the programmer. This new technique has been implemented as part of the general framework we have developed to support dynamic reconfiguration of distributed applications. These reconfiguration capabilities were implemented on top of existing operating systems and compilers, requiring no modifications to either. They support dynamic reconfiguration for applications composed of mixed languages, communicat ing via message passing, running on a heterogeneous distributed platform. This research was supported by the National Science Foundation under contract NSF CCR 9021222. This paper is the author's PhD dissertation, as supervised by James M. Purtilo. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> A. Aho, R. Sethi, J. Ullman, </author> <title> "Run-Time Environments," </title> <booktitle> Compilers: Principles, Techniques, and Tools, Addison-Welsey, Chapter 7, </booktitle> <pages> pp. 389-462, </pages> <year> 1986. </year>
Reference: [2] <author> Y. Artsy, R. Finkel, </author> <title> "Designing a Process Migration Facility: The Charlotte Experience," </title> <journal> IEEE Computer Magazine, </journal> <volume> vol. 22, no. 9, </volume> <pages> pp. 47-56, </pages> <month> September </month> <year> 1989. </year>
Reference-contexts: The main examples of this approach are Amoeba [24], Charlotte <ref> [2] </ref>, Demos/MP [25], MOS [4], Sprite [12], and the V system [32]. Emerald [20] uses the same basic approach, although here the unit of granularity is an object, not a process.
Reference: [3] <author> M. Bach, </author> <title> The Design of the Unix Operating System, </title> <publisher> Prentice-Hall, </publisher> <pages> Chapters 6-7, pp. 146-246, </pages> <year> 1986. </year>
Reference: [4] <author> A. Barak, A. Litman, </author> <title> "MOS: A Multicomputer Distributed Operating System," </title> <journal> Software Practice and Experience, </journal> <volume> vol. 15, no. 8, </volume> <pages> pp. 725-737, </pages> <month> August </month> <year> 1985. </year>
Reference-contexts: The main examples of this approach are Amoeba [24], Charlotte [2], Demos/MP [25], MOS <ref> [4] </ref>, Sprite [12], and the V system [32]. Emerald [20] uses the same basic approach, although here the unit of granularity is an object, not a process.
Reference: [5] <author> M. Barbacci, D. Doubleday, C. Weinstock, </author> <title> "Application-Level Programming," </title> <booktitle> Proceedings of the 10th International Conference on Distributed Computing Systems, </booktitle> <pages> pp. 458-465, </pages> <year> 1990. </year>
Reference-contexts: Durra <ref> [5] </ref> [6] and Argus [7] have facilities for incorporating fault tolerance into an application, and they use these facilities to help support dynamic reconfiguration. But even with these facilities, module participation must be written by the programmer in order to perform reconfiguration.
Reference: [6] <author> M. Barbacci, C. Weinstock, D. Doubleday, M. Gardner, R. Lichota, "Durra: </author> <title> A Structure Description Language for Developing Distributed Applications," </title> <journal> IEE Software Engineering Journal, </journal> <volume> vol. 8, no. 2, </volume> <pages> pp. 83-94, </pages> <month> March </month> <year> 1993. </year>
Reference-contexts: Durra [5] <ref> [6] </ref> and Argus [7] have facilities for incorporating fault tolerance into an application, and they use these facilities to help support dynamic reconfiguration. But even with these facilities, module participation must be written by the programmer in order to perform reconfiguration.
Reference: [7] <author> T. Bloom, M. Day, </author> <title> "Reconfiguration and Module Replacement in Argus: </title> <journal> Theory and Practice," IEE Software Engineering Journal, </journal> <volume> vol. 8, no. 2, </volume> <pages> pp. 102-108, </pages> <month> March </month> <year> 1993. </year>
Reference-contexts: Durra [5] [6] and Argus <ref> [7] </ref> have facilities for incorporating fault tolerance into an application, and they use these facilities to help support dynamic reconfiguration. But even with these facilities, module participation must be written by the programmer in order to perform reconfiguration.
Reference: [8] <author> J. Callahan, J. Purtilo, </author> <title> "A Packaging System for Heterogeneous Execution Environments," </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> vol. 17, </volume> <pages> pp. 626-635, </pages> <year> 1991. </year>
Reference: [9] <author> S. Carson, S. Setia, </author> <title> "Optimal Write Batch Size in Log-structured File Systems," to appear, </title> <booktitle> Computing Systems. Currently available in Proceedings of the USENIX Workshop on File Systems, </booktitle> <pages> pp. 79-91, </pages> <month> May </month> <year> 1992. </year>
Reference-contexts: This application is a regenerative simulation used for studying disk I/O behavior <ref> [9] </ref>. This example was our first experience adapting for reconfiguration a previously existing application, one that was developed without any forethought of providing dynamic reconfiguration capabilities. The simulation's execution time varies from minutes to hours, depending on the command-line arguments given at start-up.
Reference: [10] <author> K. Chandy, J. Misra, </author> <title> "The Drinking Philosophers Problem," </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> vol. 6, no. 4, </volume> <pages> pp. 632-646, </pages> <month> October </month> <year> 1984. </year>
Reference-contexts: After eating, the diner returns to thinking, thus beginning the cycle again. Our implementation of this problem uses the decentralized algorithm developed by Chandy and Misra <ref> [10] </ref>. The details of this algorithm are not critical to our purpose here, so we show only the pseudo-code for a diner in Figure 1.2.
Reference: [11] <author> K. Chandy, C. Ramamoorthy, </author> <title> "Rollback and Recovery Strategies for Computer Programs," </title> <journal> IEEE Transactions on Computers, </journal> <volume> vol. C-21, no. 6, </volume> <pages> pp. 546-556, </pages> <month> June </month> <year> 1972. </year>
Reference-contexts: instead of at regular intervals during execution. 40 Because in checkpointing the run-time cost is that of capturing the process state at regular intervals, and a low run-time cost is desired, work on this topic generally assumes that the process state is saved by copying it out to secondary storage <ref> [11, 21, 29, 30] </ref>. This of course depends on the state being restored on a machine of the same architecture and operating system, whereas the focus of our work is to remove those dependencies. In our approach, only the flags are tested at regular intervals.
Reference: [12] <author> F. Douglis, J. Ousterhout, </author> <title> "Process Migration in Sprite: A Status Report," </title> <journal> IEEE Computer Society Technical Committee on Operating Systems Newsletter, </journal> <volume> vol. 3, no. 1, </volume> <pages> pp. 8-10, </pages> <month> Winter </month> <year> 1989. </year>
Reference-contexts: The main examples of this approach are Amoeba [24], Charlotte [2], Demos/MP [25], MOS [4], Sprite <ref> [12] </ref>, and the V system [32]. Emerald [20] uses the same basic approach, although here the unit of granularity is an object, not a process.
Reference: [13] <author> F.B. Dubach, R. Rutherford, C. Shub, </author> <title> "Process-Oriented Migration in a Heterogeneous Environment," </title> <booktitle> Proceedings of the ACM Seventeenth Annual Computer Science Conference, </booktitle> <pages> pp. 98-102, </pages> <month> February, </month> <year> 1989. </year>
Reference-contexts: Of course, direct examination of the activation record stack requires knowledge of its machine-specific layout, so this approach is not machine-independent. In this respect, it is similar to the work described in <ref> [13] </ref>. The method proposed in [31] supports heterogeneous process migration (moving a module) between every possible statement. These migration points are the places where the abstract state defined by the high-level source program and the state in the binary correspond.
Reference: [14] <author> M.R. Eskicioglu, </author> <title> L.F. Carbrera, "Process Migration: An Annotated Bibliography," </title> <journal> IEEE Technical Committee on Operating Systems and Applications Environments Newsletter, </journal> <volume> vol. 4, no. 4, </volume> <pages> pp. 5-16, </pages> <month> Winter </month> <year> 1990. </year>
Reference-contexts: to the original source program in a single pass, creating the transformed source program. 3.3.4 Discussion The large body of work on process migration deals mainly with homogeneous process migration, in which the process state is captured in a machine-specific format and restored on a machine of the same architecture <ref> [14] </ref>. The main examples of this approach are Amoeba [24], Charlotte [2], Demos/MP [25], MOS [4], Sprite [12], and the V system [32]. Emerald [20] uses the same basic approach, although here the unit of granularity is an object, not a process.
Reference: [15] <author> O. Frieder, M. Segal, </author> <title> "On Dynamically Updating a Computer Program: From Concept to Prototype," </title> <journal> Journal of Systems and Software,vol. </journal> <volume> 14, </volume> <pages> pp. 111-128, </pages> <year> 1991. </year>
Reference-contexts: One method uses the same approach we take: encode and decode operations are used to support module participation. The other approach requires the user to transfer state from an old guardian (module) to a new one. Podus, the updating environment described in <ref> [15] </ref>, requires that module participation be provided by the programmer when program state must be transferred from an old version to a new one. <p> Reconfiguration without module participation, as discussed in Chapter 2, is atomic at the module level because module state cannot be captured and restored (although there can be a partial execution of a module). Podus, a system that supports updates with procedure-level atomicity is described in <ref> [15] </ref>. This system is restricted to updating a program without moving it from the original machine. The program is updated by replacing each procedure when it is not executing.
Reference: [16] <author> M. Herlihy, B. Liskov, </author> <title> "A Value Transmission Method for Abstract Data Types," </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> vol. 2, </volume> <pages> pp. 527-551, </pages> <year> 1982. </year>
Reference-contexts: With this example, we show how the catalyst module is used for replacement with module participation. 3.2.1 Transmitting ADTs As a first step for capturing and restoring the module state, we use the approach for transmitting abstract data types (ADTs) presented in <ref> [16] </ref>. In this work, Herlihy and Liskov extend the ADT concept to include the new operations encode and decode, which map a particular implementation of the ADT into an external (canonical) representation and vice versa.
Reference: [17] <author> C. Hofmeister, J. Purtilo, </author> <title> "Dynamic Reconfiguration in Distributed Systems: Adapting Software Modules for Replacement," </title> <booktitle> Proceedings of the IEEE 13th International Conference on Distributed Computing Systems, </booktitle> <pages> pp. 101-110, </pages> <month> May </month> <year> 1993. </year>
Reference: [18] <author> C. Hofmeister, E. White, J. Purtilo, "SURGEON: </author> <title> A Packager for Dynamically Reconfigurable Distributed Applications," </title> <journal> IEE Software Engineering Journal, </journal> <volume> vol. 8, no. 2, </volume> <pages> pp. 95-101, </pages> <month> March </month> <year> 1993. </year>
Reference: [19] <author> Y. Hollander, G. Silberman, </author> <title> "A Mechanism for the Migration of Tasks in Heterogeneous Distributed Processing Systems," </title> <booktitle> Proceedings of the International Conference on Parallel Processing and Applications, </booktitle> <pages> pp. 93-98, </pages> <month> September </month> <year> 1987. </year>
Reference-contexts: These commands correspond to the module-level activities of moving to a compatible state, capturing process state, and restoring process state. In contrast to the Conic work, work by Hollander and Silberman addresses the problem of capturing the process state in an abstract format <ref> [19] </ref>. Although the goal of their work is to support heterogeneous process migration, not a full spectrum of dynamic reconfiguration activities, the Migration/Recovery points they use are similar to our reconfiguration points.
Reference: [20] <author> E. Jul, H. Levy, N. Hutchinson, A. Black, </author> <title> "Fine-Grained Mobility in the Emerald System," </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> vol. 6, no.1, </volume> <pages> pp. 109-133, </pages> <month> February </month> <year> 1988. </year>
Reference-contexts: The main examples of this approach are Amoeba [24], Charlotte [2], Demos/MP [25], MOS [4], Sprite [12], and the V system [32]. Emerald <ref> [20] </ref> uses the same basic approach, although here the unit of granularity is an object, not a process. These systems all rely on an operating system designed or customized to support migration, whereas our goal was to develop techniques that operate above the operating system.
Reference: [21] <author> R. Koo, S. Toueg, </author> <title> "Checkpointing and Rollback-Recovery for Distributed Systems," </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> vol. SE-13, no. 1, </volume> <pages> pp. 23-31, </pages> <month> January </month> <year> 1987. </year>
Reference-contexts: instead of at regular intervals during execution. 40 Because in checkpointing the run-time cost is that of capturing the process state at regular intervals, and a low run-time cost is desired, work on this topic generally assumes that the process state is saved by copying it out to secondary storage <ref> [11, 21, 29, 30] </ref>. This of course depends on the state being restored on a machine of the same architecture and operating system, whereas the focus of our work is to remove those dependencies. In our approach, only the flags are tested at regular intervals.
Reference: [22] <author> J. Kramer, J. Magee, </author> <title> "Dynamic Configuration for Distributed Systems," </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> vol. SE-11, no. 4, </volume> <pages> pp. 424-436, </pages> <year> 1985. </year>
Reference-contexts: Current research recognizes that a general solution to dynamic reconfiguration requires module participation. The dynamic reconfiguration environment provided by Conic <ref> [22] </ref> [23] supports the application-level reconfiguration activities of adding or deleting modules and the bindings between them, but requires the programmer to manually adapt a module to participate during reconfiguration. The reconfiguration framework of Conic is separated into configuration-level concerns and application-level concerns.
Reference: [23] <author> J. Kramer, J. Magee, </author> <title> "The Evolving Philosophers Problem: Dynamic Change Management," </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> vol. 16, no. 11, </volume> <pages> pp. 1293-1306, </pages> <year> 1990. </year>
Reference-contexts: Current research recognizes that a general solution to dynamic reconfiguration requires module participation. The dynamic reconfiguration environment provided by Conic [22] <ref> [23] </ref> supports the application-level reconfiguration activities of adding or deleting modules and the bindings between them, but requires the programmer to manually adapt a module to participate during reconfiguration. The reconfiguration framework of Conic is separated into configuration-level concerns and application-level concerns. <p> A platform that preserves atomicity at the statement level could support reconfiguration either at 41 every statement, or at certain reconfiguration points specified by the programmer. We take the latter approach, as does the reconfiguration framework of Conic <ref> [23] </ref>. In Conic, reconfiguration activities are separated into configuration level concerns and application level concerns. Configuration level activities are independent of the algorithms, protocols, and states of the application, and are guaranteed to leave the system in a consistent state, where consistency is defined in terms of the application. <p> other */ for (n=0; n &lt; new_num_nodes; n++) - /* start up new nodes */ mh_chg_obj (&(new_caps [n]), "add"); - filter_out (N, new_rows, new_cols); /* send state to new nodes */ 58 Chapter 5 Summary In extending the Polylith environment with reconfiguration primitives, we have corroborated the conclusions drawn in <ref> [23] </ref> about the basic activities that a dynamic reconfiguration environment must support. However, our reconfiguration environment supports modules written in standard procedural languages (such as C or Pascal), and the Polylith platform supports heterogeneous languages on heterogeneous machines.
Reference: [24] <author> S. Mullender, </author> <title> "Process Management in a Distributed Operating System," </title> <booktitle> Proceedings of the International Workshop on Experiences with Distributed Systems, </booktitle> <pages> pp. 38-51, </pages> <month> September </month> <year> 1987. </year>
Reference-contexts: The main examples of this approach are Amoeba <ref> [24] </ref>, Charlotte [2], Demos/MP [25], MOS [4], Sprite [12], and the V system [32]. Emerald [20] uses the same basic approach, although here the unit of granularity is an object, not a process.
Reference: [25] <author> M. Powell, B. Miller, </author> <title> "Process Migration in Demos/MP," </title> <booktitle> Proceedings of the Ninth ACM Symposium on Operating System Principles, </booktitle> <pages> pp. 110-119, </pages> <month> November </month> <year> 1983. </year>
Reference-contexts: The main examples of this approach are Amoeba [24], Charlotte [2], Demos/MP <ref> [25] </ref>, MOS [4], Sprite [12], and the V system [32]. Emerald [20] uses the same basic approach, although here the unit of granularity is an object, not a process.
Reference: [26] <author> T. Pratt, </author> <title> Programming Languages: Design and Implementation, </title> <publisher> Prentice-Hall, </publisher> <pages> Chapters 6-8, pp. 149-302, </pages> <year> 1984. </year> <month> 64 </month>
Reference: [27] <author> J. Purtilo, </author> <note> "The Polylith Software Toolbus," To appear, ACM Transactions on Program--ming Languages and Systems, January 1994. Also available as University of Maryland CSD Technical Report 2469, </note> <year> 1990. </year>
Reference-contexts: Because the algorithm is decentralized, the protocol for sharing forks is contained in each diner, and is based entirely on a diner's local state. We illustrate this problem on an existing distributed programming system, Polylith <ref> [27] </ref>. In order to run this example on a heterogeneous network using Polylith, the user provides an application specification, a simple description of the application's modular structure. The application specification describes the attributes of each module, including its interfaces, and defines the bindings between them. <p> The primary example of this type of information is the table of open file descriptors that the operating system maintains for each process. Our approach to meeting the above requirements is to build upon the existing Polylith software interconnection system <ref> [27] </ref>. Polylith provides users with an environment for easily constructing large (and possibly distributed) applications for use in heterogeneous execution environments. For these reasons, Polylith is a natural platform for reconfigurable applications. The Polylith bus organization satisfies our requirements concerning coercion of data's representation in a heterogeneous system.
Reference: [28] <author> J. Purtilo, C. Hofmeister, </author> <title> "Dynamic Reconfiguration of Distributed Programs," </title> <booktitle> Proceedings of the 11th International Conference on Distributed Computing Systems, </booktitle> <pages> pp. 560-571, </pages> <year> 1991. </year>
Reference: [29] <author> B. Randell, </author> <title> "System Structure for Software Fault Tolerance," </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> vol. SE-1, no. 2, </volume> <pages> pp. 220-232, </pages> <month> June </month> <year> 1975. </year>
Reference-contexts: instead of at regular intervals during execution. 40 Because in checkpointing the run-time cost is that of capturing the process state at regular intervals, and a low run-time cost is desired, work on this topic generally assumes that the process state is saved by copying it out to secondary storage <ref> [11, 21, 29, 30] </ref>. This of course depends on the state being restored on a machine of the same architecture and operating system, whereas the focus of our work is to remove those dependencies. In our approach, only the flags are tested at regular intervals.
Reference: [30] <author> D. Russell, </author> <title> "State Restoration in Systems of Communicating Processes," </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> vol. SE-6, no. 2, </volume> <pages> pp. 183-194, </pages> <month> March </month> <year> 1980. </year>
Reference-contexts: instead of at regular intervals during execution. 40 Because in checkpointing the run-time cost is that of capturing the process state at regular intervals, and a low run-time cost is desired, work on this topic generally assumes that the process state is saved by copying it out to secondary storage <ref> [11, 21, 29, 30] </ref>. This of course depends on the state being restored on a machine of the same architecture and operating system, whereas the focus of our work is to remove those dependencies. In our approach, only the flags are tested at regular intervals.
Reference: [31] <author> M. Theimer, B. Hayes, </author> <title> "Heterogeneous Process Migration by Recompilation," </title> <booktitle> Proceedings of the 11th International Conference on Distributed Computing Systems, </booktitle> <pages> pp. 18-25, </pages> <year> 1991. </year>
Reference-contexts: Next we show how to capture and restore the module state in the general case, which includes capturing and restoring local data (data allocated on the activation record stack), and includes reconfiguration points located in called procedures. The approach we take is similar to the technique proposed in <ref> [31] </ref> for heterogeneous process migration, where by compiling a special program that restores the process state, the authors force the compiler to manage the machine-specific details of restoring the activation record stack. <p> Of course, direct examination of the activation record stack requires knowledge of its machine-specific layout, so this approach is not machine-independent. In this respect, it is similar to the work described in [13]. The method proposed in <ref> [31] </ref> supports heterogeneous process migration (moving a module) between every possible statement. These migration points are the places where the abstract state defined by the high-level source program and the state in the binary correspond. <p> For capturing the activation record stack a separate, machine-specific translation program is required, (as in Figure 3.1), but for restoring the activation record stack the translation is embedded in the source program (as in Figure 3.2). The main advantages of our work over the technique described in <ref> [31] </ref> are that the state is captured abstractly and that the run-time cost is much lower. Their goal is to support heterogeneous process migration, requiring that migration points be transparent to the programmer and that they be available at as many places in the source code as possible.
Reference: [32] <author> M. Theimer, K. Lantz, D. Cheriton, </author> " <title> Preemptable Remote Execution Facilities for the V System," </title> <booktitle> Proceedings of the Tenth ACM Symposium on Operating System Principles, </booktitle> <pages> pp. 2-12, </pages> <month> December </month> <year> 1985. </year> <month> 65 </month>
Reference-contexts: The main examples of this approach are Amoeba [24], Charlotte [2], Demos/MP [25], MOS [4], Sprite [12], and the V system <ref> [32] </ref>. Emerald [20] uses the same basic approach, although here the unit of granularity is an object, not a process. These systems all rely on an operating system designed or customized to support migration, whereas our goal was to develop techniques that operate above the operating system.
References-found: 32

