URL: http://www.research.att.com/library/trs/TRs/98/98.3/98.3.2.body.ps
Refering-URL: http://www.research.att.com/library/trs/
Root-URL: http://www.aic.nrl.navy.mil/~aha/people.html
Email: fmab,jf,mstraussg@research.att.com  
Title: Compliance Checking in the PolicyMaker Trust Management System  
Author: Matt Blaze Joan Feigenbaum Martin Strauss 
Address: 180 Park Avenue Florham Park, NJ 07932 USA  
Affiliation: AT&T Labs Research  
Abstract: Emerging electronic commerce services that use public-key cryptography on a mass-market scale require sophisticated mechanisms for managing trust. For example, any service that receives a signed request for action is forced to answer the central question "Is the key used to sign this request authorized to take this action?" In some services, this question reduces to "Does this key belong to this person?" In others, the authorization question is more complicated, and resolving it requires techniques for formulating security policies and security credentials, determining whether particular sets of credentials satisfy the relevant policies, and deferring trust to third parties. Blaze, Feigenbaum, and Lacy [1] identified this trust management problem as a distinct and important component of network services and described a general tool for addressing it, the PolicyMaker trust management system. At the heart of a trust management system is an algorithm for compliance checking. The inputs to the compliance checker are a request, a policy, and a set of credentials. The compliance checker returns yes or no, depending on whether the credentials constitute a proof that the request complies with the policy. Thus a central challenge in trust management is to find an appropriate notion of "proof" and an efficient algorithm for checking proofs of compliance. In this paper, we present the notion of proof that is used in the current version of the PolicyMaker trust management system. We show that this notion of proof leads to a compliance-checking problem that is undecidable in its most general form and is NP-hard even if restricted in several natural ways. We identify a special case of the problem that is solvable in polynomial time and is widely applicable. The algorithm that we give for this special case has been implemented and is used in the current version of the PolicyMaker system.
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> M. Blaze, J. Feigenbaum, and J. Lacy, </author> <title> Decentralized Trust Management, </title> <booktitle> in Proceedings of the Symposium on Security and Privacy, </booktitle> <publisher> IEEE Computer Society Press, Los Alamitos, </publisher> <year> 1996, </year> <pages> pp. 164-173. </pages>
Reference-contexts: 1 Introduction Blaze, Feigenbaum, and Lacy <ref> [1] </ref> identified the trust management problem as a distinct and important component of security in network services. <p> Aspects of the trust management problem include formulation of policies and credentials, deferral of trust to third parties, and a mechanism for "proving" that a request, supported by one or more credentials, complies with a policy. In <ref> [1] </ref>, the authors describe a comprehensive approach to trust management that is independent of the needs of any particular product or service, and a trust management system, called PolicyMaker, that embodies the approach. They emphasize the following general principles. <p> He may trust self-labeling by the Disney Corporation and any labels by a labeler that is approved by Good Housekeeping. 1.2 Related Work While the concept of a "trust management system" per se originated in <ref> [1] </ref>, there is previous work on "protection systems" that is loosely related. We briefly recall two examples of such work here; more recent work that is similarly related to ours can be found in, e.g., [12]. <p> The compliance-checking question "is request r authorized by policy P and credential set C?" is analogous to the question "can subject s eventually obtain right r by transition rules " in the protection-system world. Part of the novelty of the PolicyMaker system <ref> [1] </ref> and of its analysis as given here is the realization that a single instance of request processing, especially one that involves deferral of trust, can require a moderately complex computation and not just a lookup in a precomputed data structure. <p> Readers already familiar with these arguments as put forth in <ref> [1, 2, 9, 10] </ref> should skip to the next section. Clearly, any product or service that requires some form of proof that requested transactions comply with policies could implement a special-purpose compliance checker from scratch. <p> Associating each assertion with the correct source-ID is the responsibility of the calling application, and it takes place before the POC instance is handed to the compliance checker; the rationale for this architectural decision is given in the original paper on the PolicyMaker trust management system <ref> [1] </ref>. The request r is a string encoding an action for which the calling application seeks a proof of compliance.
Reference: 2. <author> M. Blaze, J. Feigenbaum, P. Resnick, and M. Strauss, </author> <title> Managing Trust in an Information-Labeling System, </title> <journal> European Transactions on Telecommunications, </journal> <volume> 8 (1997), </volume> <pages> pp. 491-501. </pages> <booktitle> (Special issue of selected papers from the 1996 Amalfi Conference on Secure Communication in Networks.) </booktitle>
Reference-contexts: Readers already familiar with these arguments as put forth in <ref> [1, 2, 9, 10] </ref> should skip to the next section. Clearly, any product or service that requires some form of proof that requested transactions comply with policies could implement a special-purpose compliance checker from scratch.
Reference: 3. <author> Y.-H. Chu, J. Feigenbaum, B. LaMacchia, P. Resnick, and M. Strauss, REFEREE: </author> <title> Trust Management for Web Applications, World Wide Web Journal, </title> <booktitle> 2 (1997), </booktitle> <pages> pp. 127-139. </pages> <booktitle> (Reprinted from Proceedings of the 6th International World Wide Web Conference, World Wide Web Consortium, </booktitle> <address> Cambridge, </address> <year> 1997, </year> <pages> pp. 227-238.) </pages>
Reference-contexts: An open question for future work on trust management is the trade-off between the cost of building and analyzing such an execution environment and the potential power to be gained by using more sophisticated interactions to construct proofs of compliance. Preliminary work along those lines can be found in <ref> [3] </ref>. The choice of this simple communication mechanism implies that an important part of constructing a proof of compliance is choosing an order in which to execute assertions. PolicyMaker assigns the responsibility of choosing this order to the compliance checker and not, for example, to the calling application.
Reference: 4. <author> D. Denning, </author> <title> Cryptography and Data Security, </title> <publisher> Addison-Wesley, </publisher> <address> Reading, </address> <year> 1982. </year>
Reference-contexts: The main thrust of the work we present in this paper is twofold: We define a general "proof-of-compliance problem" that is intractable, and we isolate a special case of the problem that is both tractable and useful. Protection systems, as described by Denning <ref> [4] </ref>, address a similar (but not identical) problem to the one we address, and a similar type of result is sometimes obtained. Harrison, Ruzzo, and Ullman [7] analyze a general protection system based on the access matrix model. <p> Besides these transitions, subjects can create new nodes and remove their own rights over their immediate successors. Although rights are constrained to flow only via take-grant paths, take-grant systems do model nontrivial applications <ref> [4] </ref>. Jones, Lipton, and Snyder asked whether a right r over a node x possessed by node n 1 but not possessed by n 2 could ever be acquired by n 2 . <p> They showed that this question can be decided in time linear in the original graph by depth-first search. Thus Denning <ref> [4] </ref> concludes that, although safety in protection systems is usually undecidable, the results in, e.g., [7, 8] demonstrate that safety can be decided feasibly in systems with sets of transition rules from a restricted though nontrivial set.
Reference: 5. <author> S. Even, A. Selman, and Y. Yacobi, </author> <title> The Complexity of Promise Problems with Applications to Public-Key Cryptography, </title> <journal> Information and Control, </journal> <volume> 61 (1984), </volume> <pages> pp. 159-174. </pages>
Reference-contexts: Including a global runtime bound d obviously makes the POC problem decidable, as does including parameters c and l. 5 Results In stating and proving results about the complexity of POC, we use the notion of a promise problem <ref> [5] </ref>. In a standard decision problem, a language L is defined by a predicate R in that x 2 L , R (x). In a promise problem, there are two predicates, the promise Q and the property R.
Reference: 6. <author> M. Garey and D. Johnson, </author> <title> Computers and Intractability: A Guide to the Theory of NP-Completeness, </title> <publisher> Freeman, </publisher> <address> San Fancisco, </address> <year> 1979. </year>
Reference-contexts: In proving that certain POC variants, while decidable, are computationally intractable, we use the fact that the Bounded Post Correspondence Problem is NP-complete <ref> [6, Problem SR11] </ref>.
Reference: 7. <author> M. A. Harrison, W. L. Ruzzo, and J. D. Ullman, </author> <title> Protection in Operating Systems, </title> <journal> Communications of the ACM, </journal> <volume> 19 (1976), </volume> <pages> pp. 461-471. </pages>
Reference-contexts: Protection systems, as described by Denning [4], address a similar (but not identical) problem to the one we address, and a similar type of result is sometimes obtained. Harrison, Ruzzo, and Ullman <ref> [7] </ref> analyze a general protection system based on the access matrix model. <p> They showed that this question can be decided in time linear in the original graph by depth-first search. Thus Denning [4] concludes that, although safety in protection systems is usually undecidable, the results in, e.g., <ref> [7, 8] </ref> demonstrate that safety can be decided feasibly in systems with sets of transition rules from a restricted though nontrivial set. The related results on compliance checking that we present in Section 5 provide additional support for Denning's conclusion.
Reference: 8. <author> A. K. Jones, R. J. Lipton, and L. Snyder, </author> <title> A Linear Time Algorithm for Deciding Security, </title> <booktitle> in Proceedings of the Symposium on Foundations of Computer Science, </booktitle> <publisher> IEEE Computer Society Press, Los Alamitos, </publisher> <year> 1976, </year> <pages> pp. 33-41. </pages>
Reference-contexts: On the other hand, Harrison, Ruzzo, and Ullman identify several possible restrictions on and give decision algorithms for input subject to one of these restrictions. One restriction they consider yields a PSPACE-complete problem. Independently, Jones, Lipton, and Snyder <ref> [8] </ref> define and analyze take-grant directed-graph systems. Subjects and objects are nodes; an arc a from node n 1 to n 2 is labeled by the set of rights n 1 has over n 2 . <p> They showed that this question can be decided in time linear in the original graph by depth-first search. Thus Denning [4] concludes that, although safety in protection systems is usually undecidable, the results in, e.g., <ref> [7, 8] </ref> demonstrate that safety can be decided feasibly in systems with sets of transition rules from a restricted though nontrivial set. The related results on compliance checking that we present in Section 5 provide additional support for Denning's conclusion.
Reference: 9. <author> J. Lacy, D. P. Maher, and J. H. Snyder, </author> <title> Music on the Internet and the Intellectual Property Protection Problem, </title> <booktitle> in Proceedings of the International Symposium on Industrial Electronics, </booktitle> <publisher> IEEE Press, </publisher> <address> New York, </address> <year> 1997, </year> <pages> pp. </pages> <month> SS77-83. </month>
Reference-contexts: Note that these are realistic examples of the types of transactions that users want to perform; individually, none of them is very complicated. Collectively, they demonstrate that an expressive, flexible notion of "proof of compliance" is needed. More examples can be found in <ref> [1-3, 9, 10] </ref>. Example 1: Signed Email. Consider an email system in which messages arrive with headers that include, among other things, the sender's name, the sender's public key, and a digital signature. <p> Readers already familiar with these arguments as put forth in <ref> [1, 2, 9, 10] </ref> should skip to the next section. Clearly, any product or service that requires some form of proof that requested transactions comply with policies could implement a special-purpose compliance checker from scratch.
Reference: 10. <author> R. Levien, L. McCarthy, and M. </author> <title> Blaze, Transparent Internet E-mail Security, </title> <address> http://www.cs.umass.edu/~lmccarth/crypto/papers/email.ps </address>
Reference-contexts: Note that these are realistic examples of the types of transactions that users want to perform; individually, none of them is very complicated. Collectively, they demonstrate that an expressive, flexible notion of "proof of compliance" is needed. More examples can be found in <ref> [1-3, 9, 10] </ref>. Example 1: Signed Email. Consider an email system in which messages arrive with headers that include, among other things, the sender's name, the sender's public key, and a digital signature. <p> Readers already familiar with these arguments as put forth in <ref> [1, 2, 9, 10] </ref> should skip to the next section. Clearly, any product or service that requires some form of proof that requested transactions comply with policies could implement a special-purpose compliance checker from scratch.
Reference: 11. <author> E. Tardos, </author> <title> The Gap Between Monotone and Non-monotone Circuit Complexity is Exponential, </title> <journal> Combinatorica, </journal> <volume> 8 (1988), </volume> <pages> pp. 141-142. </pages>
Reference-contexts: This verifiability comes at a price; listing a finite output set is relatively inexpensive, but there are monotonic functions that require exponentially bigger circuits to express over a basis of AND and OR than they require over a basis of AND, OR, and NOT <ref> [11] </ref>. In some applications it may be cheaper, on average, to write assertions that are verifiably bounded and monotonic than to determine the set of sources trusted (even indirectly) by a given assertion and to judge whether they are trusted to be monotonic and bounded.
Reference: 12. <author> T. Y. C. Woo and S. S. Lam, </author> <title> Authorization in Distributed Systems: A New Approach, </title> <journal> Journal of Computer Security, </journal> <volume> 2 (1993), </volume> <pages> pp. 107-36. </pages>
Reference-contexts: We briefly recall two examples of such work here; more recent work that is similarly related to ours can be found in, e.g., <ref> [12] </ref>. The main thrust of the work we present in this paper is twofold: We define a general "proof-of-compliance problem" that is intractable, and we isolate a special case of the problem that is both tractable and useful.
References-found: 12

