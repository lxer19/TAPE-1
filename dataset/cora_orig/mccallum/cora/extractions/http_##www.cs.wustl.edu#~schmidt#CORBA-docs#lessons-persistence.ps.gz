URL: http://www.cs.wustl.edu/~schmidt/CORBA-docs/lessons-persistence.ps.gz
Refering-URL: http://www.cs.wustl.edu/~schmidt/corba-papers.html
Root-URL: 
Email: e-mail:-plasil, tuma-@kki.ms.mff.cuni.cz  
Phone: phone: (42 2) 2191 4266 fax: (42 2) 532 742  2  phone: (42 2) 6605 3291 fax: (42 2) 858 5789  
Title: Lessons Learned from Implementing the CORBA Persistent Object Service  
Author:  Jan Kleindienst Franti*ek Pl*il , Petr Tu ma Charles 
Address: Malostransk nmest 25, 118 00 Prague 1, Czech Republic  Pod vodrenskou ve 180 00 Prague 8 Czech Republic  
Affiliation: University Faculty of Mathematics and Physics, Department of Software Engineering  Institute of Computer Science Czech Academy of Sciences  
Note: 3 This work was done as a part of TOCOOS, a project funded by the COPERNICUS Program, project CP 940247; the work was also partially supported by GA C R Grant No. 201/95/0976  
Abstract: e-mail: -kleindie, plasil-@uivt.cas.cz Abstract. In this paper, the authors share their experiences gathered during the design and implementation of the CORBA Persistent Object Service. There are two problems related to a design and implementation of the Persistence Service: first, OMG intentionally leaves the functionality core of the Persistence Service unspecified; second, OMG encourages reuse of other Object Services without being specific enough in this respect. The paper identifies the key design issues implied both by the intentional lack of OMG specification and the limits of the implementation environment characteristics. At the same time, the paper discusses the benefits and drawbacks of reusing other Object Services, particularly the Relationship and Externalization Services, to support the Persistence Service. Surprisingly, the key lesson learned is that a direct reuse of these Object Services is impossible.
Abstract-found: 1
Intro-found: 1
Reference: [AJJ+92] <author> P. Amaral, C. Jacquemot, P. Jensen, R. Lea, and A. Mirowski: </author> <title> Transparent object migration in COOL-2. In Proceedings of Workshop on Dynamic Object Placement and Load Balancing in Parallel and Distributed Systems, </title> <address> ECOOP'92, Utrecht, </address> <month> June </month> <year> 1992 </year>
Reference-contexts: This approach is typically used when a persistent address space is supported. A number of approaches towards the persistent address space architecture exist. The most well-known of these are <ref> [AJJ+92, AJL92, PSWL94, SDP93, SF94, FS94b, SG91a, SKW92, DdBF+92, and HCF+95] </ref>. In this case, there was basically no problem with the decision since the limitations of a distributed environment set heavy odds against the direct access approach. <p> Grouping: The current status of relations among objects is not evaluated; dependencies are resolved implicitly by defining groups of object. Such a group must be closed with respect to inter-object references. As examples, see clusters in COOL <ref> [HMA90, AJJ+92, ALJ92] </ref> or groups in SOM [IBM94a, IBM94b]. Evaluation of dependencies: Dependencies are explicitly evaluated (typically, before each update of an object's persistent state). This can be either application-controlled or system-controlled (based on hardware-supported reference identification).
Reference: [AJL92] <author> P. Amaral, C. Jacquemot, and R. Lea: </author> <title> A model for persistent shared memory addressing in distributed systems. </title> <type> Technical report TR-92-52, </type> <institution> Chorus systemes, </institution> <year> 1992. </year>
Reference-contexts: This approach is typically used when a persistent address space is supported. A number of approaches towards the persistent address space architecture exist. The most well-known of these are <ref> [AJJ+92, AJL92, PSWL94, SDP93, SF94, FS94b, SG91a, SKW92, DdBF+92, and HCF+95] </ref>. In this case, there was basically no problem with the decision since the limitations of a distributed environment set heavy odds against the direct access approach. <p> Automatic: Updating is system-controlled, based on a consistency protocol which can be e.g. transaction based, virtual memory based, system event based, etc. <ref> [AJL92, HKPCS95] </ref>. Explicit: Updating is application-controlled, i.e. store and restore methods of the Persistence Service are called explicitly by the application. We chose the explicit approach for the current implementation.
Reference: [ALJ92] <author> P. Amaral, R. Lea, and C. Jacquemot: </author> <title> Implementing a modular object oriented operating system on top of CHORUS. </title> <booktitle> In Proceeding s of OpenForum 92, </booktitle> <address> Utrecht, </address> <month> November 92. </month>
Reference-contexts: Grouping: The current status of relations among objects is not evaluated; dependencies are resolved implicitly by defining groups of object. Such a group must be closed with respect to inter-object references. As examples, see clusters in COOL <ref> [HMA90, AJJ+92, ALJ92] </ref> or groups in SOM [IBM94a, IBM94b]. Evaluation of dependencies: Dependencies are explicitly evaluated (typically, before each update of an object's persistent state). This can be either application-controlled or system-controlled (based on hardware-supported reference identification).
Reference: [A93] <author> P. Amaral: PAS: </author> <title> A Framework for studying the implementation of multiple address spaces. </title> <type> PhD thesis, </type> <institution> Universite Paris VI, </institution> <year> 1993. </year>
Reference: [Ben95] <author> R. Ben-Nathar: </author> <title> CORBA: A guide to Common Object Request Broker Architecture. </title> <publisher> McGraw-Hill. </publisher> <year> 1995. </year>
Reference: [Bou94] <author> F. </author> <title> Bourdon: The Automatic Positioning of Objects in COOL V2. </title> <booktitle> In Proceedings of 14th ICDCS, </booktitle> <address> Poznan, </address> <publisher> IEEE Computer Society Press, </publisher> <month> June </month> <year> 1994. </year>
Reference: [CBHS93] <author> V. Cahill, S. Baker, C. Horn, and G. Starovic: </author> <title> The Amadeus GRT Generic Runtime Support for Distributed Persistent Programming. </title> <booktitle> Proceedings of OOPSLA'93, </booktitle> <pages> pages 144-161, </pages> <publisher> ACM Press, </publisher> <year> 1993. </year>
Reference: [CDK94] <author> G. Coulouris, J. Dollimore, and T. Kindberg: </author> <title> Distributed Systems. Concepts and Design. </title> <publisher> Addison-Wesley, </publisher> <address> 2nd Edition, </address> <year> 1994. </year>
Reference: [CTP96] <author> T. L. Casavant, P. Tvrdk, F. Pl*il (Editors.): </author> <title> Parallel Computers: Theory and Practice. </title> <publisher> IEEE Press, </publisher> <year> 1996. </year>
Reference: [DdBF+92] <author> A. Dearle, R. di Bona, J. Farrow, F. Henskens, A. Lindstrom, J. Rosenberg, and F. Vaughan: Grasshopper: </author> <title> An orthogonally Persistent Operating System. </title> <journal> Computer Systems, </journal> <volume> 7(3), </volume> <pages> pages 289-312, </pages> <year> 1992. </year>
Reference-contexts: This approach is typically used when a persistent address space is supported. A number of approaches towards the persistent address space architecture exist. The most well-known of these are <ref> [AJJ+92, AJL92, PSWL94, SDP93, SF94, FS94b, SG91a, SKW92, DdBF+92, and HCF+95] </ref>. In this case, there was basically no problem with the decision since the limitations of a distributed environment set heavy odds against the direct access approach.
Reference: [DOM93] <institution> DOME User Guide, Release 2.2, Object-Oriented Technologies Ltd., </institution> <year> 1993. </year>
Reference-contexts: In 1991, OMG defined an industry standard called the Common Object Request Broker Architecture (CORBA), based upon a concrete object model derived from the OMA abstract object model. Among the CORBA-compliant systems (CORBA implementations) currently available from different vendors are Orbix [ORBIXa, ORBIXb], SOM [IBM94a, IBM94b], DOME <ref> [DOM93] </ref>, NEO [NEO96], and HP ORB+ [HP95], The first version of the CORBA standard specification, CORBA 1.2 [OMG92], comprises many components together providing a foundation for performing transparent remote request calls from the requestors of services (clients or client applications) to the providers of services (servers).
Reference: [DRH+92] <author> A. Dearle, J. Rosenbergr, F. Henkens, F. Vaughan and K. Maciunas: </author> <title> An Examination of Operating System Support for Persistent Object Systems. </title> <booktitle> In Proceedings of the 25th Hawaii International Conference on System Services, </booktitle> <volume> 1, </volume> <publisher> IEEE Computer Society Press, </publisher> <year> 1992. </year>
Reference: [Ede92] <author> D. R. Edelson: </author> <title> Smart Pointers: They're Smart but They're Not Pointers. </title> <institution> UCSC-CRL-92-27, Baskin Center for Computer Engineering & Information Sciences, University of California, Santa Cruz, </institution> <year> 1992. </year>
Reference: [FS94a] <author> P. Ferreira and M. Shapiro: </author> <title> Garbage Collection and DSM Consistency. </title> <booktitle> In Proceedings of the first symposium on the Operating Systems Design and Implementation Conference, </booktitle> <address> Monterey, </address> <month> November </month> <year> 1994. </year>
Reference: [FS94b] <author> P. Ferreira and M. Shapiro: </author> <title> Garbage Collection of Persistent Objects in Distributed Shared Memory. </title> <booktitle> In Proceedings of the Persistent Object Systems, </booktitle> <address> Tarascon, </address> <month> September </month> <year> 1994. </year>
Reference-contexts: This approach is typically used when a persistent address space is supported. A number of approaches towards the persistent address space architecture exist. The most well-known of these are <ref> [AJJ+92, AJL92, PSWL94, SDP93, SF94, FS94b, SG91a, SKW92, DdBF+92, and HCF+95] </ref>. In this case, there was basically no problem with the decision since the limitations of a distributed environment set heavy odds against the direct access approach.
Reference: [FS96] <author> P. Ferreira and M. Shapiro: Larchant: </author> <title> Persistence by Reachability in Distributed Shared Memory through Garbage Collection, </title> <booktitle> In Proceedings of the 16th International Conference on Distributed Computing Systems, </booktitle> <address> Hong Kong, </address> <publisher> IEEE Computer Society Press, </publisher> <month> May </month> <year> 1996. </year>
Reference: [HCF+95] <author> D. Hagimont, P. Y. Chevalier, A. Freyssinet, S. Krakowiak, S. Lacourte, J. Mossiere, and X. R. de Pina: </author> <title> Persistent Shared Object Support in the Guide System Evaluation and Related Work. </title> <booktitle> In Proceedings of the 9th Annual Conference on OO Programming Systems, Languages, and Applications, Portland, </booktitle> <pages> pages 129-144, </pages> <month> October </month> <year> 1994. </year>
Reference: [HK93] <author> G. Hamilton and P. Kougiouris: </author> <title> The Spring nucleus: A microkernel for objects. </title> <booktitle> In Proceedings of the 1993 Summer Usenix conference, </booktitle> <address> Cincinnati, </address> <month> June </month> <year> 1993. </year>
Reference: [HKPCS95] <author> J. Hans, A. Knaff, E. Perez-Cotes, and F. Saunier: Arias: </author> <title> Generic Support for Persistent Runtimes. </title> <booktitle> In Proceedings of European Research Seminar on Advances in Distributed Systems, L'Alpe d'Huez, </booktitle> <pages> pages 220-226, </pages> <month> April </month> <year> 1995. </year>
Reference-contexts: Automatic: Updating is system-controlled, based on a consistency protocol which can be e.g. transaction based, virtual memory based, system event based, etc. <ref> [AJL92, HKPCS95] </ref>. Explicit: Updating is application-controlled, i.e. store and restore methods of the Persistence Service are called explicitly by the application. We chose the explicit approach for the current implementation.
Reference: [HP95] <institution> HP ORB Plus 2.0, </institution> <note> URL: http//www.hp.com </note>
Reference-contexts: Among the CORBA-compliant systems (CORBA implementations) currently available from different vendors are Orbix [ORBIXa, ORBIXb], SOM [IBM94a, IBM94b], DOME [DOM93], NEO [NEO96], and HP ORB+ <ref> [HP95] </ref>, The first version of the CORBA standard specification, CORBA 1.2 [OMG92], comprises many components together providing a foundation for performing transparent remote request calls from the requestors of services (clients or client applications) to the providers of services (servers).
Reference: [HMA90] <author> S. Habert, L. Mosseri, and V. Abrossimov: </author> <title> COOL: A Kernel Support for Object-Oriented Environments. </title> <booktitle> In Proceedings of the Joint ECOOP/OOPSLA Conference, Ottawa, </booktitle> <pages> pages 269-277, </pages> <month> October </month> <year> 1990. </year>
Reference-contexts: Grouping: The current status of relations among objects is not evaluated; dependencies are resolved implicitly by defining groups of object. Such a group must be closed with respect to inter-object references. As examples, see clusters in COOL <ref> [HMA90, AJJ+92, ALJ92] </ref> or groups in SOM [IBM94a, IBM94b]. Evaluation of dependencies: Dependencies are explicitly evaluated (typically, before each update of an object's persistent state). This can be either application-controlled or system-controlled (based on hardware-supported reference identification).
Reference: [IBM94a] <institution> IBM Corp. </institution> <note> SOMobjects Developer Toolkit Users Guide, Version 2.1, </note> <year> 1994. </year>
Reference-contexts: In 1991, OMG defined an industry standard called the Common Object Request Broker Architecture (CORBA), based upon a concrete object model derived from the OMA abstract object model. Among the CORBA-compliant systems (CORBA implementations) currently available from different vendors are Orbix [ORBIXa, ORBIXb], SOM <ref> [IBM94a, IBM94b] </ref>, DOME [DOM93], NEO [NEO96], and HP ORB+ [HP95], The first version of the CORBA standard specification, CORBA 1.2 [OMG92], comprises many components together providing a foundation for performing transparent remote request calls from the requestors of services (clients or client applications) to the providers of services (servers). <p> Grouping: The current status of relations among objects is not evaluated; dependencies are resolved implicitly by defining groups of object. Such a group must be closed with respect to inter-object references. As examples, see clusters in COOL [HMA90, AJJ+92, ALJ92] or groups in SOM <ref> [IBM94a, IBM94b] </ref>. Evaluation of dependencies: Dependencies are explicitly evaluated (typically, before each update of an object's persistent state). This can be either application-controlled or system-controlled (based on hardware-supported reference identification). In the latter case, the techniques of early or late pointer swizzling are typically used [SKW92, VD92].
Reference: [IBM94b] <institution> IBM Corp. </institution> <note> SOMobjects Developer Toolkit Programmers Reference Manual 2.1, </note> <year> 1994. </year>
Reference-contexts: In 1991, OMG defined an industry standard called the Common Object Request Broker Architecture (CORBA), based upon a concrete object model derived from the OMA abstract object model. Among the CORBA-compliant systems (CORBA implementations) currently available from different vendors are Orbix [ORBIXa, ORBIXb], SOM <ref> [IBM94a, IBM94b] </ref>, DOME [DOM93], NEO [NEO96], and HP ORB+ [HP95], The first version of the CORBA standard specification, CORBA 1.2 [OMG92], comprises many components together providing a foundation for performing transparent remote request calls from the requestors of services (clients or client applications) to the providers of services (servers). <p> Grouping: The current status of relations among objects is not evaluated; dependencies are resolved implicitly by defining groups of object. Such a group must be closed with respect to inter-object references. As examples, see clusters in COOL [HMA90, AJJ+92, ALJ92] or groups in SOM <ref> [IBM94a, IBM94b] </ref>. Evaluation of dependencies: Dependencies are explicitly evaluated (typically, before each update of an object's persistent state). This can be either application-controlled or system-controlled (based on hardware-supported reference identification). In the latter case, the techniques of early or late pointer swizzling are typically used [SKW92, VD92].
Reference: [KN93b] <author> Y. A. Khalidi and M. N. Nelson: </author> <title> The Spring Virtual Memory System. </title> <type> Technical Report SMLI-93-9, </type> <institution> Sun Microsystems, </institution> <year> 1993. </year>
Reference: [KPT95] <author> J. Kleindienst, F. Pl*il, P. Tuma: </author> <title> Implementing CORBA Persistence Service, </title> <type> TR 117, </type> <institution> Charles University Prague, Department of Software Engineering, </institution> <year> 1995. </year>
Reference: [KPT96] <author> J. Kleindienst, F. Pl*il, P. Tuma: </author> <title> CORBA and its Object Services. </title> <type> Invited Paper, </type> <note> SOFSEM'96, Springer LNCS (to appear), </note> <year> 1996. </year>
Reference: [LXC93] <author> S. B. Lim, L. Xao, and R. Campbell: </author> <title> Distributed Access to Persistent Objects. </title> <type> Technical report, </type> <institution> University of Illinois at Urbana-Champain, Dept. of Computer Science, </institution> <year> 1993. </year>
Reference: [MA90] <author> R. Morrison, M. P. Atkinson: </author> <title> Persistent Languages and Architectures. </title> <booktitle> In Proceedings of the Security and Persistence, </booktitle> <editor> J. Rosenberg and J. L. Keedy(ed.), </editor> <publisher> Springer, </publisher> <pages> pages 9-28, </pages> <year> 1990 </year>
Reference-contexts: This control is limited to those classes of objects which have been statically preselected [Mey88], e.g. by inheriting from a "PersistentObject" base class. Dynamic determination: This highly desirable approach allows the user to decide dynamically the persistence property of all objects (orthogonal persistence <ref> [MA90] </ref>). To be able to implement the dynamic determination approach that guarantees persistence for all objects, the C++ compiler used would have to provide ways for accessing runtime type information for each C++ class.
Reference: [Mey88] <author> B. Meyer: </author> <title> Object-Oriented Software Construction, </title> <publisher> Prentice Hall, </publisher> <year> 1988. </year>
Reference-contexts: Transitive closure of dependencies (of a persistent object PO) the set of all objects reachable from PO via references transitively over all nested dependencies; this is an analogy of the "deep copy" concept <ref> [Mey88, Str94] </ref>. 3.1.2 Determining object persistence property Basically, there are three ways to determine objects' persistence properties: static, semidynamic and dynamic determination. Static determination: At compilation time, certain application objects may be statically denoted as being persistent, typically by inheriting from a persistent base class. <p> This provides the user with the runtime ability to decide objects' persistence. This control is limited to those classes of objects which have been statically preselected <ref> [Mey88] </ref>, e.g. by inheriting from a "PersistentObject" base class. Dynamic determination: This highly desirable approach allows the user to decide dynamically the persistence property of all objects (orthogonal persistence [MA90]).
Reference: [MoZa95] <author> T.J. Mowbray, R. Zahavi: </author> <title> The Essential CORBA, </title> <editor> J. </editor> <publisher> Wiley & Sons, </publisher> <year> 1995. </year>
Reference: [MCCK94] <author> R. Morrison, R. C. H. Connor, Q. J. Cutts, and G. N. C. Kirby: </author> <title> Persistent Possibilities for Software Environments. In Proceedings of the The Intersection between Databases and Software Engineering, </title> <publisher> IEEE Computer Society Press, </publisher> <pages> pages 78-87, </pages> <year> 1994. </year>
Reference: [Mul94] <author> S. Mullender, </author> <title> editor: Distributed Systems. </title> <publisher> Addison-Wesley, </publisher> <address> 2nd Edition, </address> <year> 1994. </year>
Reference: [NEO96] <editor> Solaris NEO Operating Environment, </editor> <title> Product Overview, Part No. </title> <type> 95392-003, </type> <institution> Sunsoft Inc, </institution> <month> March 96. </month>
Reference-contexts: In 1991, OMG defined an industry standard called the Common Object Request Broker Architecture (CORBA), based upon a concrete object model derived from the OMA abstract object model. Among the CORBA-compliant systems (CORBA implementations) currently available from different vendors are Orbix [ORBIXa, ORBIXb], SOM [IBM94a, IBM94b], DOME [DOM93], NEO <ref> [NEO96] </ref>, and HP ORB+ [HP95], The first version of the CORBA standard specification, CORBA 1.2 [OMG92], comprises many components together providing a foundation for performing transparent remote request calls from the requestors of services (clients or client applications) to the providers of services (servers).
Reference: [OMG92] <institution> Object Service Architecture, OMG 92-8-4, </institution> <year> 1992. </year>
Reference-contexts: Among the CORBA-compliant systems (CORBA implementations) currently available from different vendors are Orbix [ORBIXa, ORBIXb], SOM [IBM94a, IBM94b], DOME [DOM93], NEO [NEO96], and HP ORB+ [HP95], The first version of the CORBA standard specification, CORBA 1.2 <ref> [OMG92] </ref>, comprises many components together providing a foundation for performing transparent remote request calls from the requestors of services (clients or client applications) to the providers of services (servers). In principle, a request requires an operation to be executed upon a target (or server object) provided by a server. <p> Generally, the request format is vendor-dependent. The CORBA 2.0 standard [OMG94d] specifies ways to interconnect different CORBAs either by transforming requests in a bridge/gateway or by transporting requests in the standardized Internet Inter-ORB Protocol (IIOP). The CORBA 1.2 standard also proposes a collection of Object Services <ref> [OMG92] </ref> that facilitate CORBA-supported objects with additional functionality such as creating and deleting new objects (Object Lifecycle Service), looking up a server with a specific interface in another CORBA environment (Object Trading Service), or managing persistent objects (Persistent Object Service).
Reference: [OMG92a] <author> Kala-Standardizing on Object Meta Services, </author> <title> Brief Response to the OMG services, Request for Information, </title> <booktitle> OMG 92-4-5, </booktitle> <year> 1992. </year>
Reference: [OMG94a] <institution> Common Object Services Volume I, OMG 94-1-1, </institution> <year> 1994. </year>
Reference-contexts: typically allows a server object to be used as an ordinary object (by generating an access to a stub or a proxy in the client); the abstraction provided for accessing a server object via a stub (proxy), both specified by the same IDL interface, is referred to as CORBA object <ref> [OMG94a] </ref>. Generally, the request format is vendor-dependent. The CORBA 2.0 standard [OMG94d] specifies ways to interconnect different CORBAs either by transforming requests in a bridge/gateway or by transporting requests in the standardized Internet Inter-ORB Protocol (IIOP). <p> The functionality of an Object Service is specified as a set of interfaces specified in IDL, e.g. <ref> [OMG94a, OMG94b] </ref>. There are two design principles that OMG follows: first, OMG intentionally leaves services not fully specified; second, services may be mutually dependent and, at the same time they should be able to exist separately, thus partially covering functionality of other services.
Reference: [OMG94b] <institution> Persistent Object Service Specification, OMG 94-10-7, </institution> <year> 1994. </year>
Reference-contexts: The functionality of an Object Service is specified as a set of interfaces specified in IDL, e.g. <ref> [OMG94a, OMG94b] </ref>. There are two design principles that OMG follows: first, OMG intentionally leaves services not fully specified; second, services may be mutually dependent and, at the same time they should be able to exist separately, thus partially covering functionality of other services. <p> Functionality should belong to the most appropriate service. Each service should build on previous services when appropriate." As the corresponding OMG document <ref> [OMG94b] </ref> leaves the design of the Persistence Service functionality core unspecified, the first goal of the paper is to analyze those important issues that have been left unresolved by the OMG specification and to report on lessons we have learned from our design and implementation. <p> The overall functionality of the service, however, should not be degraded by the decisions made as a result of meeting the requirements mentioned above. Furthermore, the service's implementation should fulfill the following objectives: a) The implementation should fully comply with the OMG Persistence Service specification <ref> [OMG94b] </ref>. b) The implementation should not depend on any other service unless a suitable implementation of it is readily available. c) The implementation should neither require any change to the C++ [Str94] and IDL [OMG95] languages, nor any modification of the hosting CORBA environment. 2.2 The OMG specification of the Persistence <p> any other service unless a suitable implementation of it is readily available. c) The implementation should neither require any change to the C++ [Str94] and IDL [OMG95] languages, nor any modification of the hosting CORBA environment. 2.2 The OMG specification of the Persistence Service The Persistence Service is specified in <ref> [OMG94b] </ref>, where the IDL specification of three basic interfaces are provided: Persistent Object (PO), Persistent Object Manager (POM), and Persistent Data Service (PDS). Fundamentally, these interfaces comprise the same methods: connect (), disconnect (), store (), restore () and delete (). A PDS supports a collection of pairs &lt;Datastore, Protocol&gt;. <p> A PDS supports a collection of pairs &lt;Datastore, Protocol&gt;. Datastore actually saves and loads the PO's data, Protocol describes the way a PDS transfers data into and from the PO. Both Datastore and Protocol are not standardized; however, <ref> [OMG94b] </ref> offers three examples of Protocol and a specification of Datastore_CLI, which might be used as "a uniform interface for accessing many different Datastores." Generally speaking, a PDS communicates with the PO through a Protocol, and with the datastore via either Datastore_CLI or a proprietary (not defined by OMG) Datastore interface. <p> In accordance with <ref> [OMG94b] </ref>, the Persistent Data Service is responsible for actually carrying out all Persistence Service requests. As discussed in Section 3.1.3, the Persistent Data Service accesses the persistent attributes of an object using the POProtocol interface (this interface is a part of protocol in terms of [OMG94b]). <p> In accordance with <ref> [OMG94b] </ref>, the Persistent Data Service is responsible for actually carrying out all Persistence Service requests. As discussed in Section 3.1.3, the Persistent Data Service accesses the persistent attributes of an object using the POProtocol interface (this interface is a part of protocol in terms of [OMG94b]). The object dependencies are processed together with an object (Section 3.1.6). The heart of the Persistent Data Service architecture is, therefore, an algorithm capable of recursively traversing all nodes of a persistent object graph, together with a list of all persistent objects being served by the Persistent Data Service. <p> A location can be emptied using the clear () call, or tested whether it is empty using the is_empty () call. As described in <ref> [OMG94b] </ref>, PID instances are created by an appropriate factory (once created, the PID remains valid until a PID::remove () call is issued): interface PIDFactory - PID get_root_PID ( ); PID create_unique_PID ( ); PID create_PID_from_string (in string pid_string); -; As PIDs are devised by the store itself, extra care needs to <p> As the only entity authorized to access a persistent object's internal state is the object itself, the services of this module are exported in the form of methods provided by each persistent object (2.4). Using the terms introduced in <ref> [OMG94b] </ref>, this is a part of the proprietary protocol. <p> In practice, the generic factory interface is more convenient for the purpose of obtaining specific object instances if it is extended by a mechanism for registering specific object factories. 4.4 Persistence Service Layer This layer incorporates both the Persistent Data Service and the Persistent Object Manager, both specified in <ref> [OMG94b] </ref>. According to the OMG specification, the main role of the Persistent Object Manager is to dispatch a function call to the appropriate Persistent Data Service. <p> module PersistenceManagement - interface PDS - PDS connect (in POProtocol object, in PID pid); void disconnect (in POProtocol object, in PID pid); void store (in POProtocol object, in PID pid); void restore (in POProtocol object, in PID pid); void delete (in POProtocol object, in PID pid); -; As defined in <ref> [OMG94b] </ref>, the connect () and disconnect () method turn on and off the automatic updating of the object's persistent state image in the datastore. In our implementation environment, the persistent data service has no way of detecting the moments when an object is modified. <p> At the same time, the reference to the Externalization Service in the Persistence Service specification <ref> [OMG94b, Section 6.17] </ref> reads: "... the Persistence Service could use this service as a POS protocol." However, neither of the OMG documents goes any further in specifying how the Externalization Service might be reused in the Persistence Service.
Reference: [OMG94d] <editor> Universal Networked Objects, ORB 2.0 RFP Submission, OMG 94-9-32, </editor> <year> 1994. </year>
Reference-contexts: Generally, the request format is vendor-dependent. The CORBA 2.0 standard <ref> [OMG94d] </ref> specifies ways to interconnect different CORBAs either by transforming requests in a bridge/gateway or by transporting requests in the standardized Internet Inter-ORB Protocol (IIOP).
Reference: [OMG94e] <institution> Relationship Service Specification, Joint Object Services Submission, OMG 94-5-5, </institution> <year> 1994. </year>
Reference-contexts: Our second goal is to share the lessons we have learned when trying to follow strictly the recommended OMG architecture strategy which strongly encourages reusing other Object Services to minimize duplication in functionality. In compliance with this recommendation, in our design and implementation, we focused on the Relationship Service <ref> [OMG94e] </ref> and the Externalization Service [OMG94g]. <p> = HisRole; MyRelationship = MyRelFactory-&gt;create (NamedRoles,IT_X); //IT_x serves to signal exception //Traversing pointer //Traversing relationship HisObject = MyObject-&gt;pointer; RelationshipHandle *MyRelHandle; MyRelHandle.the_relationship = MyRelationship; MyRelHandle.constant_random_id = MyRelationship-&gt;constant_random_id ( ); HisObject = MyRole-&gt; get_other_related_object (MyRelHandle,"B"); 5.1 Reusing Relationship Service 5.1.1 Building Persistence Service over Relationship Service The goal of the Relationship Service <ref> [OMG94e] </ref> is to provide tools for operating upon abstractions based on entity relationship diagram concepts. According to the abstractions it provides, the Relationship Service is hierarchically structured into 3 levels. The base level relationship provides Role and Relationship as a means for organizing entity objects (related objects) in entity-relationship-diagram-like structures. <p> In order to meet the minimum requirements of the Persistence Service (dependencies, transitive closure of dependencies) the Relationship Service implementation needs to fulfill at least the service levels 1 and 2 as defined in <ref> [OMG94e] </ref>. In the general case, the two reference types can coexist in the transitive closure of an object's dependencies. This even allows several subgraphs defined by different TraversalCriteria objects to participate in one transitive closure. The Persistence Service should respect this flexibility in defining subgraphs. <p> Thus, saving of the subgraph can take place only after all the r-objects representing the subgraph are found. In the following we discuss the possible approaches to storing the r-object. The discussion is based on the sound assumption deduced from the OMG Relationship Service specification <ref> [OMG94e] </ref> that all Roles belonging to a given relationship maintain a reference to the particular Relationship object and - vice versa the Relationship object keeps references to all its Roles. As an aside, such a reference can be a CORBA-reference.
Reference: [OMG94f] <editor> Compound LifeCycle Addendum. </editor> <booktitle> Joint Object Services Submission. OMG 94-5-6, </booktitle> <year> 1994. </year>
Reference: [OMG94g] <institution> Object Externalization Service. OMG 94-9-15, </institution> <year> 1995. </year>
Reference-contexts: In compliance with this recommendation, in our design and implementation, we focused on the Relationship Service [OMG94e] and the Externalization Service <ref> [OMG94g] </ref>. As the inter-dependencies among the three Object Services are rather complex and potentially circular, we will also aim at providing the reader with an analysis of inherent trade-offs. 1.3 Structure of the paper The paper has the following structure: Section 2 is focused on our project requirements and restriction. <p> Canonical format: Data on the external media is stored in a standardized format, possibly the Standard Stream Data Format defined in <ref> [OMG94g] </ref> with the bound IDL type set and identification keys reused from the Naming Service. Such a format, of course, has the advantage of being widely recognized and can be used for porting objects' data from one implementation to another. <p> Externalized objects are saved on media in the canonical form described by <ref> [OMG94g] </ref>. Thus the Externalization Service allows an easy transfer of objects between different CORBA architectures. The Externalization Service is based on three interfaces: Stream, StreamIO, and Streamable. The Stream interface represents a sequential stream of externalized objects. <p> The typical control flow is illustrated in Figure 4. The write_graph () method is called when the Relationship Service is used to represent relations among objects (Figure 5). An Externalization Service capable of cooperating with the Relationship Service is called the Compound Externalization Service <ref> [OMG94g] </ref>. To distinguish the two cases, the non-compound Externalization Service will be referred to as the Simple Externalization Service. <p> All in all, it should be emphasized that the Stream interface inherently implies a sequential way of saving and loading objects to and from external media. 5.2.2 Simple Externalization as a POS protocol As stated in the Externalization Service specification <ref> [OMG94g, Section 3.1] </ref>, the Externalization Service has been designed to be able to integrate with the Persistence Service as a specific POS protocol. <p> In principle, it would be possible to implement a specialized StreamIO interface, such that the Streamable interface could be used to access the persistent state of an object without imposing the limit mentioned above. Although not strictly adherent to the semantics described in <ref> [OMG94g] </ref>, the specialized StreamIO interface implementation could make it possible to reuse the Streamable code in a client application.
Reference: [OMG95] <institution> Common Object Request Broker Architecture and Specification Revision 2.0, OMG 96-3-4, </institution> <year> 1995. </year>
Reference-contexts: In principle, a request requires an operation to be executed upon a target (or server object) provided by a server. The functionality of server objects is specified via the Interface Description Language (IDL) defined in <ref> [OMG95] </ref>. <p> fulfill the following objectives: a) The implementation should fully comply with the OMG Persistence Service specification [OMG94b]. b) The implementation should not depend on any other service unless a suitable implementation of it is readily available. c) The implementation should neither require any change to the C++ [Str94] and IDL <ref> [OMG95] </ref> languages, nor any modification of the hosting CORBA environment. 2.2 The OMG specification of the Persistence Service The Persistence Service is specified in [OMG94b], where the IDL specification of three basic interfaces are provided: Persistent Object (PO), Persistent Object Manager (POM), and Persistent Data Service (PDS).
Reference: [OMG95b] <institution> Object Services RFP 5. OMG TC Document 95-3-25, </institution> <year> 1995. </year>
Reference-contexts: Throughout the paper, we show that it is non-trivial to fulfill one of the key design principals proposed by OMG in the Requests For Proposals (e.g. <ref> [OMG95b] </ref>), which has been referred to as the Bauhaus principle: "Minimize duplication of functionality. Functionality should belong to the most appropriate service. <p> More specifically, <ref> [OMG95b] </ref> reads: "Each service should build on previous services when appropriate" with the key motivation stated as "Functionality should belong to the most appropriate service." With respect to the Persistence Service, the corresponding OMG specification discusses the option of integrating the Persistence Service with other Object Services.
Reference: [OMG95c] <institution> Object Management Architecture Guide, </institution> <note> 3rd Edition, R.M. </note> <editor> Soley (Editor), </editor> <publisher> John Wiley & Sons, </publisher> <year> 1990. </year>
Reference-contexts: 1 Introduction 1.1 CORBA and TOCOOS Around 1990, the Object Management Group (OMG) introduced the Objects Management Architecture (OMA) for distributed systems <ref> [OMG95c] </ref>, which defines an abstract object model. In 1991, OMG defined an industry standard called the Common Object Request Broker Architecture (CORBA), based upon a concrete object model derived from the OMA abstract object model.
Reference: [ORBIXa] <author> Orbix, </author> <title> Programmer's Guide. </title> <publisher> IONA Technologies Ltd. </publisher> <address> Dublin, </address> <year> 1994 </year>
Reference-contexts: In 1991, OMG defined an industry standard called the Common Object Request Broker Architecture (CORBA), based upon a concrete object model derived from the OMA abstract object model. Among the CORBA-compliant systems (CORBA implementations) currently available from different vendors are Orbix <ref> [ORBIXa, ORBIXb] </ref>, SOM [IBM94a, IBM94b], DOME [DOM93], NEO [NEO96], and HP ORB+ [HP95], The first version of the CORBA standard specification, CORBA 1.2 [OMG92], comprises many components together providing a foundation for performing transparent remote request calls from the requestors of services (clients or client applications) to the providers of services
Reference: [ORBIXb] <author> Orbix, </author> <title> Advanced Programmer's Guide. </title> <publisher> IONA Technologies Ltd. </publisher> <address> Dublin, </address> <year> 1994. </year>
Reference-contexts: In 1991, OMG defined an industry standard called the Common Object Request Broker Architecture (CORBA), based upon a concrete object model derived from the OMA abstract object model. Among the CORBA-compliant systems (CORBA implementations) currently available from different vendors are Orbix <ref> [ORBIXa, ORBIXb] </ref>, SOM [IBM94a, IBM94b], DOME [DOM93], NEO [NEO96], and HP ORB+ [HP95], The first version of the CORBA standard specification, CORBA 1.2 [OMG92], comprises many components together providing a foundation for performing transparent remote request calls from the requestors of services (clients or client applications) to the providers of services <p> when storing/restoring parts of the given graph should be (subject to our current research). 5.1.4 Disadvantages of reusing Relationship Service Compared to the standard C++ dereference mechanism, using the Relationship Service may slow down the application considerably, even if local caching of relationship attributes (e.g. via smart proxies in Orbix <ref> [ORBIXb] </ref>) is used. When using the Relationship Service, dereferencing an object pointed to by a relation implies calling Role::get_other_rela-ted_object (). The get_other_related_object () method requires the Role object it is to be invoked upon and the Relationship object to be traversed.
Reference: [PG95] <author> F. Pl*il, M. Grf: </author> <title> An Overcoming of Inheritance Anomaly, TR 95-05-02, Department I n f o r m a t i q u e , I n s t i t u t n a t i o n a l d e s Telecommunications, </title> <address> Evry, France, </address> <year> 1995. </year>
Reference: [PSWL94] <author> G. D. Parrington, S. K. Shrivastava, S. M. Wheater, and M. C. Little: </author> <title> The Design and Implementation of Arjuna. BROADCAST Project deliverable report, </title> <type> 4, </type> <institution> University of Newcastle upon Type, </institution> <month> October </month> <year> 1994. </year>
Reference-contexts: This approach is typically used when a persistent address space is supported. A number of approaches towards the persistent address space architecture exist. The most well-known of these are <ref> [AJJ+92, AJL92, PSWL94, SDP93, SF94, FS94b, SG91a, SKW92, DdBF+92, and HCF+95] </ref>. In this case, there was basically no problem with the decision since the limitations of a distributed environment set heavy odds against the direct access approach.
Reference: [PT95] <author> F. Pl*il, P. Tuma: </author> <title> Memory Management in Spring. </title> <type> TR 95-05-03, </type> <institution> Department Informatique, Institut national des Telecommunications, Evry, France, </institution> <year> 1995. </year>
Reference: [RHB+90] <author> J. Rossenberg, F. Henskens, A. L. Brown, R. Morrison, and D. Munro: </author> <title> Stability in a Persistent Store Based on a Large Virtual Memory. In Security and Persistence, </title> <booktitle> Workshops in Computing, </booktitle> <pages> pages 229-245. </pages> <publisher> Springer, </publisher> <year> 1990. </year>
Reference: [SDP93] <author> S. K. Shrivastava, G. N. Dixon, and G. D. Parrington: </author> <title> An Overview of the Arjuna: A Programming System for Reliable Distributed Computing, </title> <journal> IEEE Software, </journal> <volume> 8(1), </volume> <pages> pages 63-73, </pages> <month> January </month> <year> 1991 </year>
Reference-contexts: This approach is typically used when a persistent address space is supported. A number of approaches towards the persistent address space architecture exist. The most well-known of these are <ref> [AJJ+92, AJL92, PSWL94, SDP93, SF94, FS94b, SG91a, SKW92, DdBF+92, and HCF+95] </ref>. In this case, there was basically no problem with the decision since the limitations of a distributed environment set heavy odds against the direct access approach.
Reference: [SF94] <author> M. Shapiro and P. Ferreira: Larchant-RDOSS: </author> <title> A distributed shared persistent memory and its garbage collector. </title> <booktitle> In Proceedings of the 9th Workshop on Distributed Algorithms (WADG), </booktitle> <address> Le Mont Saint Michel, </address> <month> Sept. </month> <year> 1995. </year>
Reference-contexts: This approach is typically used when a persistent address space is supported. A number of approaches towards the persistent address space architecture exist. The most well-known of these are <ref> [AJJ+92, AJL92, PSWL94, SDP93, SF94, FS94b, SG91a, SKW92, DdBF+92, and HCF+95] </ref>. In this case, there was basically no problem with the decision since the limitations of a distributed environment set heavy odds against the direct access approach.
Reference: [SG91a] <author> S. S. Simmel and I. Godard: </author> <title> The Kala Basket: A Semantic Primitive Unifying Object Transactions, Access Control, Versions, and Configurations. </title> <booktitle> In Proceedings of OOPLSA'91, </booktitle> <pages> pages. 230-246, </pages> <year> 1991. </year>
Reference-contexts: This approach is typically used when a persistent address space is supported. A number of approaches towards the persistent address space architecture exist. The most well-known of these are <ref> [AJJ+92, AJL92, PSWL94, SDP93, SF94, FS94b, SG91a, SKW92, DdBF+92, and HCF+95] </ref>. In this case, there was basically no problem with the decision since the limitations of a distributed environment set heavy odds against the direct access approach.
Reference: [SGH+91] <author> M. Shapiro, Y. Gourhant, S. Habert, L. Mosseri, M. Ruffin, and C. Valot: </author> <title> SOS: An Object-Oriented Operating System Assessment and Perspectives. </title> <booktitle> Computing Systems 2(4), </booktitle> <year> 1989. </year>
Reference: [Sha94a] <author> M. Shapiro: </author> <title> A Binding Protocol for Distributed Shared Objects. </title> <booktitle> In Proceedings of the International Conference on Distributed Computing Systems (ICDCS) , Poznan, </booktitle> <address> June1994. </address>
Reference: [Sim92] <author> S. S. Simmel: </author> <title> Providing commonality while supporting diversity. </title> <booktitle> Hotline on Object-Oriented Technology, </booktitle> <volume> 3(10), </volume> <month> Aug. </month> <year> 1992. </year>
Reference: [SKW92] <author> V. Singhal, S. V. Kakkad, and P. R. Wilson: </author> <title> Texas: An Efficient, Portable Persistent Store. </title> <booktitle> In Proceedings of the Persistent Object Systems, San Miniato, </booktitle> <editor> A. Albano and R. Morrison (Editors), </editor> <publisher> Springer, </publisher> <pages> pages 11-33, </pages> <year> 1992. </year>
Reference-contexts: This approach is typically used when a persistent address space is supported. A number of approaches towards the persistent address space architecture exist. The most well-known of these are <ref> [AJJ+92, AJL92, PSWL94, SDP93, SF94, FS94b, SG91a, SKW92, DdBF+92, and HCF+95] </ref>. In this case, there was basically no problem with the decision since the limitations of a distributed environment set heavy odds against the direct access approach. <p> Evaluation of dependencies: Dependencies are explicitly evaluated (typically, before each update of an object's persistent state). This can be either application-controlled or system-controlled (based on hardware-supported reference identification). In the latter case, the techniques of early or late pointer swizzling are typically used <ref> [SKW92, VD92] </ref>.
Reference: [Str94] <author> D. Stroustrup: </author> <title> The C++ Programming Language. 2nd Edition. </title> <publisher> Addison-Wesley, </publisher> <year> 1995. </year>
Reference-contexts: service's implementation should fulfill the following objectives: a) The implementation should fully comply with the OMG Persistence Service specification [OMG94b]. b) The implementation should not depend on any other service unless a suitable implementation of it is readily available. c) The implementation should neither require any change to the C++ <ref> [Str94] </ref> and IDL [OMG95] languages, nor any modification of the hosting CORBA environment. 2.2 The OMG specification of the Persistence Service The Persistence Service is specified in [OMG94b], where the IDL specification of three basic interfaces are provided: Persistent Object (PO), Persistent Object Manager (POM), and Persistent Data Service (PDS). <p> Transitive closure of dependencies (of a persistent object PO) the set of all objects reachable from PO via references transitively over all nested dependencies; this is an analogy of the "deep copy" concept <ref> [Mey88, Str94] </ref>. 3.1.2 Determining object persistence property Basically, there are three ways to determine objects' persistence properties: static, semidynamic and dynamic determination. Static determination: At compilation time, certain application objects may be statically denoted as being persistent, typically by inheriting from a persistent base class.
Reference: [SUZ96] <author> M. Steinder, A. Uszok, K. Zielinski: </author> <title> A Framework for Inter-ORB Request Level Bridge Construction. </title> <booktitle> In Proceedings of the IFIP/IEEE International Conference on Distributed Platforms, </booktitle> <publisher> Chapman & Hall, Dresden, </publisher> <pages> pages 86-99, </pages> <year> 1996. </year>
Reference-contexts: Since 1994, we have participated in the TOCOOS Copernicus project (CP940247 (other partners: Mari (UK), IONA Technologies (IE), CYFRONET (PL)), the goal of which is to design and implement the bridge between two CORBA implementations: Orbix and DOME <ref> [SUZ96] </ref> and also to design and implement a subset of the Object Services that would furnish the bridge with enhanced functionality, such as persistence and fault-tolerance. 1.2 The goal of the paper The purpose of the paper is to articulate the lessons we have learned from designing and implementing the CORBA
Reference: [Tan95] <author> A. S. Tanenbaum: </author> <title> Distributed Operating Systems. </title> <publisher> Prentice Hall, </publisher> <year> 1995. </year>
Reference: [VD92] <author> F. Vaugham and A. Dearle: </author> <title> Supporting Large Persistent Stores using Conventional Hardware. </title> <booktitle> In Proceedings of the Persistent Object Systems, San Miniato, </booktitle> <editor> A. Albano and R. Morrison (Editors), </editor> <publisher> Springer, </publisher> <pages> pages 35-53, </pages> <year> 1992. </year>
Reference-contexts: Evaluation of dependencies: Dependencies are explicitly evaluated (typically, before each update of an object's persistent state). This can be either application-controlled or system-controlled (based on hardware-supported reference identification). In the latter case, the techniques of early or late pointer swizzling are typically used <ref> [SKW92, VD92] </ref>.
References-found: 61

