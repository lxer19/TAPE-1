URL: http://www.cs.colostate.edu/~ftppub/TechReports/1993/tr-109.ps.Z
Refering-URL: http://www.cs.colostate.edu/~ftppub/
Root-URL: 
Affiliation: Department of Computer Science Colorado State University  
Abstract: Measuring Functional Cohesion James M. Bieman and Linda M. Ott Technical Report CS-93-109 July 7, 1993 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> A.L. Baker, J.M. Bieman, N. E. Fenton, A. C. Melton, and R.W. Whitty. </author> <title> A philosophy for software measurement. </title> <journal> Journal of Systems and Software, </journal> <volume> 12(3) </volume> <pages> 277-281, </pages> <month> July </month> <year> 1990. </year>
Reference-contexts: Measurement techniques used in the physical sciences guide us in our development of functional cohesion measures. Aspects of functional cohesion are internal product attributes related to properties of programs [9]. Physical science measurement techniques suggest the following process <ref> [1] </ref>: 1. Identify and define intuitive and well-understood attributes of cohesion. We must qualitatively understand what we want to measure. The categories of cohesion (functional | coincidental) have been identified and are fairly well understood. <p> The role of experimentation in software measurement research is to map structural measures back to goals. But, before we can conduct effective empirical research, we must first have sound measures <ref> [1] </ref>. Functional cohesion is actually an attribute of individual procedures or functions, rather than an attribute of a separately compilable program unit or module (depending on the programming language, modules may include several procedures and declarations). <p> We cannot measure semantic relations between program components that cannot be identified from the program text alone. For cohesion measures to provide meaningful measurements they must be rigorously defined, accurately reflect well understood software attributes, and be based on models that capture these attributes <ref> [1] </ref>. The measures should be specified independently from the measurement tools, and such tools should be based on the models.
Reference: [2] <author> V.R. Basili and H.D. Rombach. </author> <title> The TAME project: Towards improvement-oriented software environments. </title> <journal> IEEE Trans. Software Engineering, </journal> <volume> SE-14(6):758-773, </volume> <month> June </month> <year> 1988. </year>
Reference-contexts: In this paper, we address functional cohesion; we defer the treatment of abstract or data cohesion to future work. The relationship between software engineering objectives and cohesion measurement can be clarified through the Goal/Question/Metric (GQM) paradigm of Basili and Rombach <ref> [2] </ref>. The GQM paradigm requires that software measurements be tied to a software engineering goal. Our goal is to improve maintenance programmer productivity and effectiveness. This goal leads to questions (for example, `how can we develop code that is easy to modify?'). The answers to such questions lead to metrics.
Reference: [3] <author> J. Bieman, A. Baker, P. Clites, D. Gustafson, and A. Melton. </author> <title> A standard representation of imperative language programs for data collection and software measures specification. </title> <journal> The Journal of Systems and Software, </journal> <volume> 8(1) </volume> <pages> 13-37, </pages> <month> January </month> <year> 1988. </year>
Reference-contexts: The measures should be specified independently from the measurement tools, and such tools should be based on the models. For example, QUALMS [36] is based on the flow graph model, and the test coverage measurement tools of Bieman and Schultz [4, 5] are based on the standard representation model <ref> [3] </ref>. We use a slice abstraction of a program based on data slices to model cohesion [24]. Functional cohesion itself is a complex attribute and can be described in terms of sub-attributes. Particular sub-attributes of cohesion must be visible in the cohesion model.
Reference: [4] <author> J. Bieman and J. Schultz. </author> <title> Estimating the number of test cases required to satisfy the all-du-paths testing criterion. </title> <booktitle> Proc. Software Testing, Analysis and Verification Symposium (TAV3-SIGSOFT89), </booktitle> <pages> pages 179-186, </pages> <month> December </month> <year> 1989. </year>
Reference-contexts: The measures should be specified independently from the measurement tools, and such tools should be based on the models. For example, QUALMS [36] is based on the flow graph model, and the test coverage measurement tools of Bieman and Schultz <ref> [4, 5] </ref> are based on the standard representation model [3]. We use a slice abstraction of a program based on data slices to model cohesion [24]. Functional cohesion itself is a complex attribute and can be described in terms of sub-attributes.
Reference: [5] <author> J. Bieman and J. Schultz. </author> <title> An empirical evaluation (and specification) of the all-du-paths testing criterion. </title> <journal> Software Engineering Journal, </journal> <volume> 7(1) </volume> <pages> 43-51, </pages> <month> January </month> <year> 1992. </year>
Reference-contexts: The measures should be specified independently from the measurement tools, and such tools should be based on the models. For example, QUALMS [36] is based on the flow graph model, and the test coverage measurement tools of Bieman and Schultz <ref> [4, 5] </ref> are based on the standard representation model [3]. We use a slice abstraction of a program based on data slices to model cohesion [24]. Functional cohesion itself is a complex attribute and can be described in terms of sub-attributes.
Reference: [6] <author> J.-D. Choi, B. Miller, and P. Netzer. </author> <title> Techniques for debugging parallel programs. </title> <type> Technical Report 786, </type> <institution> Univ. Wisconsin-Madison, </institution> <year> 1988. </year>
Reference-contexts: Slices were proposed as potential debugging tools and program understanding aids. They have since been used in a broader class of applications (e.g., debugging parallel programs <ref> [6] </ref>, maintenance [11, 13, 23], and testing [15, 16, 20, 27]). Weiser's algorithm for computing slices is based on data flow analysis. It is suggested in [25] that a program dependence graph representation can be used to compute slices more efficiently and precisely.
Reference: [7] <author> T. J. Emerson. </author> <title> Program testing, path coverage, and the cohesion metric. </title> <booktitle> Proc. Computer Software and Applications Conf. (COMPSAC-84), </booktitle> <pages> pages 421-431, </pages> <year> 1984. </year> <month> 26 </month>
Reference-contexts: The insights gained from this earlier work were instrumental in developing the data slice model of cohesion and cohesion measures presented here. Other researchers have also examined the problem of measuring cohesion including Emerson <ref> [7, 8] </ref>, Lakhotia [18], Troy and Zweben [32], and Selby and Basili [30]. 21 success passwd address 3 3 3 procedure LookUp2 (A: Table; Size: integer; key: keytype; 1 1 1 var success: boolean; 1 1 var passwd: integer; 1 1 var address: string); begin 2 2 2 i := 1; <p> := true; end else 3 value := value mod 10; 2 2 small := false; end end; 35 = :83 15 fl 2 + 20 fl 3 = :43 0 = 0:0 23 6.1 Emerson's work Emerson bases his cohesion measure on a control flow graph representation of a module <ref> [7, 8] </ref>. The graph contains a node for each statement in the module that contains a variable. After construction of the graph, a reference set is constructed for each variable in the module which indicates the nodes in the control flow graph that reference that variable.
Reference: [8] <author> T. J. Emerson. </author> <title> A discriminant metric for module cohesion. </title> <booktitle> Proc. 7th Int. Conf. on Software Engineering (ICSE-7), </booktitle> <pages> pages 294-303, </pages> <year> 1984. </year>
Reference-contexts: The insights gained from this earlier work were instrumental in developing the data slice model of cohesion and cohesion measures presented here. Other researchers have also examined the problem of measuring cohesion including Emerson <ref> [7, 8] </ref>, Lakhotia [18], Troy and Zweben [32], and Selby and Basili [30]. 21 success passwd address 3 3 3 procedure LookUp2 (A: Table; Size: integer; key: keytype; 1 1 1 var success: boolean; 1 1 var passwd: integer; 1 1 var address: string); begin 2 2 2 i := 1; <p> := true; end else 3 value := value mod 10; 2 2 small := false; end end; 35 = :83 15 fl 2 + 20 fl 3 = :43 0 = 0:0 23 6.1 Emerson's work Emerson bases his cohesion measure on a control flow graph representation of a module <ref> [7, 8] </ref>. The graph contains a node for each statement in the module that contains a variable. After construction of the graph, a reference set is constructed for each variable in the module which indicates the nodes in the control flow graph that reference that variable. <p> The values for Emerson's complexity measure range from 0 to 1. Discrimination levels are suggested to map these values to three levels of cohesion: data cohesion, control cohesion, and superficial cohesion. Emerson indicates that his flow graph and reference set constructs are related to slicing <ref> [8] </ref>. Emerson computes flow subgraphs based on generating all vertices which are either reachable from an element of R or from which an element of R is reachable. Thus, these flow graphs are more closely related to metric slicing than Weiser's original definition of slicing [33].
Reference: [9] <author> N. Fenton. </author> <title> Software Metrics A Rigorous Approach. </title> <publisher> Chapman and Hall, </publisher> <address> London, </address> <year> 1991. </year>
Reference-contexts: The cohesion categories vary in desirability ranging from the most desirable (functional cohesion) to the least desirable (coincidental cohesion). All of these cohesion categories indicate the extent of the "functional strength" of a module, the contribution of module parts towards performing one task <ref> [9] </ref>. Our aim is to develop quantitative measures that Travel support for this work provided in part by a Faculty Development Grant from Michigan Technological University. J. <p> Note that one can also evaluate cohesion from the perspective of data abstraction [21]. Fenton describes this abstract or data cohesion as a different notion of cohesion with a different set of measurement attributes <ref> [9] </ref>. In this paper, we address functional cohesion; we defer the treatment of abstract or data cohesion to future work. The relationship between software engineering objectives and cohesion measurement can be clarified through the Goal/Question/Metric (GQM) paradigm of Basili and Rombach [2]. <p> In particular, we now focus on functional cohesion measures, with the ultimate goal of developing measures that can predict maintainability. Measurement techniques used in the physical sciences guide us in our development of functional cohesion measures. Aspects of functional cohesion are internal product attributes related to properties of programs <ref> [9] </ref>. Physical science measurement techniques suggest the following process [1]: 1. Identify and define intuitive and well-understood attributes of cohesion. We must qualitatively understand what we want to measure. The categories of cohesion (functional | coincidental) have been identified and are fairly well understood. <p> If there is also a `zeroness' relation, i.e. some of the entities observably possess nothing of the attribute, then the scale type is ratio since the zeroness relation must be mapped to 0. Absolute scales arise out of attributes which amount to simple counts of entities." <ref> [9] </ref> The scale of a measure determines the arithmetic operations that can be meaningfully performed on measurement values. For example, an arithmetic mean is well defined on interval, ratio, and absolute scale measures. However, an arithmetic mean of ordinal scale measurement values is not meaningful as an average. <p> measures are based solely on the number of slices and data tokens in a procedure, and the number of glue and super-glue tokens. 4 Discussion of Scale Properties Fenton defines the term "validation" as "the process of ensuring that the measure is a proper numerical characterization of the claimed attribute" <ref> [9] </ref>. This kind of validation is very difficult when the attribute to be measured is loosely understood. We need to rely on human intuition 10 to determine the relative levels of our cohesion properties, to see if they are consistent with the metric values.
Reference: [10] <author> L. Finkelstein. </author> <title> A review of the fundamental concepts of measurement. </title> <booktitle> Measurement, </booktitle> <volume> 2(1) </volume> <pages> 25-34, </pages> <year> 1984. </year>
Reference-contexts: The answers to such questions lead to metrics. Intuition suggests that "cohesive" modules are easier to understand and are thus easier to maintain. Our intuition concerning cohesion is important, since intuition is the first stage of measurement <ref> [10] </ref>. Thus, we are motivated to develop cohesion measures. In particular, we now focus on functional cohesion measures, with the ultimate goal of developing measures that can predict maintainability. Measurement techniques used in the physical sciences guide us in our development of functional cohesion measures.
Reference: [11] <author> Keith Brian Gallagher and James R. Lyle. </author> <title> Using program slicing in software maintenance. </title> <journal> IEEE Trans. Software Engineering, </journal> <volume> 17(8) </volume> <pages> 751-761, </pages> <year> 1991. </year>
Reference-contexts: Slices were proposed as potential debugging tools and program understanding aids. They have since been used in a broader class of applications (e.g., debugging parallel programs [6], maintenance <ref> [11, 13, 23] </ref>, and testing [15, 16, 20, 27]). Weiser's algorithm for computing slices is based on data flow analysis. It is suggested in [25] that a program dependence graph representation can be used to compute slices more efficiently and precisely.
Reference: [12] <author> Matthew S. Hecht. </author> <title> Flow Analysis of Computer Programs. </title> <publisher> North-Holland, </publisher> <year> 1977. </year>
Reference-contexts: Longworth [19] first studied their use as indicators of cohesion. In [28, 31], certain inconsistencies noted by Longworth are eliminated through the use of metric slices. A metric slice takes into account both the uses and used by data relationships <ref> [12] </ref>; that is, they are the union of Horwitz et.al.'s backward and forward slices. In order to analyze the effects of changes on slice measures, we modify this concept of metric slices to use data tokens (i.e., variable and constant definitions and references) rather than statements as the basic unit.
Reference: [13] <author> S. Horwitz, J. Prins, and T. Reps. </author> <title> Integrating non-interfering versions of programs. </title> <journal> ACM Trans. Programming Languages and Systems, </journal> <volume> 11(3) </volume> <pages> 345-386, </pages> <year> 1989. </year>
Reference-contexts: Slices were proposed as potential debugging tools and program understanding aids. They have since been used in a broader class of applications (e.g., debugging parallel programs [6], maintenance <ref> [11, 13, 23] </ref>, and testing [15, 16, 20, 27]). Weiser's algorithm for computing slices is based on data flow analysis. It is suggested in [25] that a program dependence graph representation can be used to compute slices more efficiently and precisely.
Reference: [14] <author> S. Horwitz, T. Reps, and D. Binkley. </author> <title> Interprocedural slicing using dependence graphs. </title> <journal> ACM Trans. Programming Languages and Systems, </journal> <volume> 12(1) </volume> <pages> 35-46, </pages> <year> 1990. </year>
Reference-contexts: It is suggested in [25] that a program dependence graph representation can be used to compute slices more efficiently and precisely. An algorithm for computing slices using a program dependence graph representation is presented by Horwitz, Reps, and Binkley <ref> [14, 29] </ref>. A slice is obtained by walking backwards over the program dependence graph to obtain all nodes which have an effect on the value of the variable of interest. <p> A slice is obtained by walking backwards over the program dependence graph to obtain all nodes which have an effect on the value of the variable of interest. Similarly, a forward slice <ref> [14] </ref> can be obtained by walking forward over the program dependence graph to obtain all nodes which are affected by the value of a variable. <p> We indicate, in the column for a slice variable, the number of data tokens in that line that are included in the slice. This profile was derived from an earlier method developed for visualizing slices [26, 31]. 1 That is from the FinalUse nodes as described in <ref> [14] </ref> 5 SumN ProdN Statement 2 2 procedure SumAndProduct ( N : integer; var SumN, ProdN : integer ); var 1 1 I : integer; begin 2 SumN := 0; 2 ProdN := 1; 3 3 for I := 1 to N do begin 3 SumN := SumN + I; 3
Reference: [15] <author> B. Korel and J. W. Laski. </author> <title> Dynamic program slicing. </title> <journal> Information Processing Letters, </journal> <volume> 29(3) </volume> <pages> 155-163, </pages> <year> 1988. </year>
Reference-contexts: Slices were proposed as potential debugging tools and program understanding aids. They have since been used in a broader class of applications (e.g., debugging parallel programs [6], maintenance [11, 13, 23], and testing <ref> [15, 16, 20, 27] </ref>). Weiser's algorithm for computing slices is based on data flow analysis. It is suggested in [25] that a program dependence graph representation can be used to compute slices more efficiently and precisely.
Reference: [16] <author> B. Korel and J. W. Laski. </author> <title> Stad a system for testing and debugging: User perspective. </title> <booktitle> In Proc. 2nd Workshop on Software Testing, Verification and Analysis, </booktitle> <year> 1988. </year>
Reference-contexts: Slices were proposed as potential debugging tools and program understanding aids. They have since been used in a broader class of applications (e.g., debugging parallel programs [6], maintenance [11, 13, 23], and testing <ref> [15, 16, 20, 27] </ref>). Weiser's algorithm for computing slices is based on data flow analysis. It is suggested in [25] that a program dependence graph representation can be used to compute slices more efficiently and precisely.
Reference: [17] <author> Arun Lakhotia. </author> <title> Insights into relationships between end-slices. </title> <type> Technical Report CACS TR-91-5-3, </type> <institution> University of Southwestern Louisiana, </institution> <month> September </month> <year> 1991. </year>
Reference-contexts: An output tuple with multiple components is considered to be multiple outputs. Since we are interested in the cohesion of the whole procedure, we use a concept similar to that of end-slices <ref> [17] </ref>. The "backward" slices are computed from the end of the procedure 1 and the "forward" slices are computed from the "top"s of the backward slices.
Reference: [18] <author> Arun Lakhotia. </author> <title> Rule-based approach to computing module cohesion. </title> <booktitle> In Proc. 15th Int. Conf. on Software Engineering (ICSE-15), </booktitle> <pages> pages 35-44, </pages> <year> 1993. </year>
Reference-contexts: The insights gained from this earlier work were instrumental in developing the data slice model of cohesion and cohesion measures presented here. Other researchers have also examined the problem of measuring cohesion including Emerson [7, 8], Lakhotia <ref> [18] </ref>, Troy and Zweben [32], and Selby and Basili [30]. 21 success passwd address 3 3 3 procedure LookUp2 (A: Table; Size: integer; key: keytype; 1 1 1 var success: boolean; 1 1 var passwd: integer; 1 1 var address: string); begin 2 2 2 i := 1; 2 2 2 <p> In contrast, our slice based cohesion measures are based on intuitively sound abstractions that are designed to isolate functional cohesion attributes from other factors. 6.2 Lakhotia's work Lakhotia developed a method for computing cohesion based on an analysis of the variable dependence graphs of a module <ref> [18] </ref>. Pairs of outputs are examined to identify any data or control dependences that exist between the two outputs. Rules are provided for determining the cohesion of the pairs.
Reference: [19] <author> H. D. Longworth. </author> <title> Slice based program metrics. </title> <type> Master's thesis, </type> <institution> Michigan Technological University, </institution> <year> 1985. </year>
Reference-contexts: Slices promote a more intuitive analysis since they are based on program text. Our measurement theory approach requires that a measure be consistent with intuition, and including program text in our abstraction eases intuitive analyses. 2.2 Data Slices In [35], Weiser defined several slice based measures. Longworth <ref> [19] </ref> first studied their use as indicators of cohesion. In [28, 31], certain inconsistencies noted by Longworth are eliminated through the use of metric slices. <p> A does indicate that Lookup3 is less cohesive than Lookup2, however, unlike SFC, A also indicates that there are some cohesive components. 6 Related Work Our current efforts are based on earlier work using slice based measures as indicators of cohesion <ref> [19, 31, 26, 28] </ref>. Longworth [19] and Thuss [31, 26] examined the potential of measures proposed by Weiser [33] as indicators of cohesion. Ott and Thuss first first noted the visual relationship that existed between the slices of a module and its cohesion as depicted in a slice profile [26]. <p> A does indicate that Lookup3 is less cohesive than Lookup2, however, unlike SFC, A also indicates that there are some cohesive components. 6 Related Work Our current efforts are based on earlier work using slice based measures as indicators of cohesion [19, 31, 26, 28]. Longworth <ref> [19] </ref> and Thuss [31, 26] examined the potential of measures proposed by Weiser [33] as indicators of cohesion. Ott and Thuss first first noted the visual relationship that existed between the slices of a module and its cohesion as depicted in a slice profile [26].
Reference: [20] <author> H. D. Longworth, L. M. Ottenstein [Ott], and M. R. Smith. </author> <title> The relationship between program complexity and slice complexity during debugging tasks. </title> <booktitle> In Proc. IEEE COMPSAC, </booktitle> <pages> pages 383-389, </pages> <year> 1986. </year>
Reference-contexts: Slices were proposed as potential debugging tools and program understanding aids. They have since been used in a broader class of applications (e.g., debugging parallel programs [6], maintenance [11, 13, 23], and testing <ref> [15, 16, 20, 27] </ref>). Weiser's algorithm for computing slices is based on data flow analysis. It is suggested in [25] that a program dependence graph representation can be used to compute slices more efficiently and precisely.
Reference: [21] <author> A. Macro and J. Buxton. </author> <title> The Craft of Software Engineering. </title> <publisher> Addison Wesley, </publisher> <year> 1987. </year>
Reference-contexts: Note that one can also evaluate cohesion from the perspective of data abstraction <ref> [21] </ref>. Fenton describes this abstract or data cohesion as a different notion of cohesion with a different set of measurement attributes [9]. In this paper, we address functional cohesion; we defer the treatment of abstract or data cohesion to future work.
Reference: [22] <author> A.C. Melton, D.A. Gustafson, J.M. Bieman, and A.L. Baker. </author> <title> A mathematical perspective for software measures research. </title> <journal> Software Engineering Journal, </journal> <volume> 5(5) </volume> <pages> 246-254, </pages> <year> 1990. </year>
Reference-contexts: To be measurable on an ordinal scale, an attribute must impart an ordering on the model. That is, the model of a procedure with "more" of one cohesion attribute must be ranked (according to the attribute ordering) higher than the model of a procedure with "less" of the attribute <ref> [22] </ref>. A measure is specified as a mapping from the model to a quantitative value. Such a measure must be consistent with the cohesion ordering. <p> In particular, the effect of multiplying the reference set by the cyclomatic complexity is to mask the view of cohesion. Cyclomatic complexity is a control flow measure, and combining the measures of different attributes weakens the discriminating power of a measure <ref> [22] </ref>. In contrast, our slice based cohesion measures are based on intuitively sound abstractions that are designed to isolate functional cohesion attributes from other factors. 6.2 Lakhotia's work Lakhotia developed a method for computing cohesion based on an analysis of the variable dependence graphs of a module [18].
Reference: [23] <author> Linda M. Ott. </author> <title> Using slice profiles and metrics during software maintenance. </title> <booktitle> In Proc. 10th Annual Software Reliability Symposium, </booktitle> <pages> pages 16-23, </pages> <year> 1992. </year>
Reference-contexts: A variation on program slices can model and measure functional cohesion [26]. A slice profile is one heuristic tool that can help one visualize the cohesion in a procedure <ref> [23] </ref>. In this paper, we focus on the development and analysis of quantitative measures that indicate the "amount of functional cohesion" in procedures. Procedure cohesion measures must indicate the cohesion that is expressed in the program text. <p> Slices were proposed as potential debugging tools and program understanding aids. They have since been used in a broader class of applications (e.g., debugging parallel programs [6], maintenance <ref> [11, 13, 23] </ref>, and testing [15, 16, 20, 27]). Weiser's algorithm for computing slices is based on data flow analysis. It is suggested in [25] that a program dependence graph representation can be used to compute slices more efficiently and precisely.
Reference: [24] <author> Linda M. Ott and James M. Bieman. </author> <title> Effects of software changes on module cohesion. </title> <booktitle> Proc. Conf. on Software Maintenance, </booktitle> <month> November </month> <year> 1992. </year>
Reference-contexts: For example, QUALMS [36] is based on the flow graph model, and the test coverage measurement tools of Bieman and Schultz [4, 5] are based on the standard representation model [3]. We use a slice abstraction of a program based on data slices to model cohesion <ref> [24] </ref>. Functional cohesion itself is a complex attribute and can be described in terms of sub-attributes. Particular sub-attributes of cohesion must be visible in the cohesion model. To be measurable on an ordinal scale, an attribute must impart an ordering on the model.
Reference: [25] <author> K. J. Ottenstein and L. M. Ottenstein [Ott]. </author> <title> The program dependence graph in a software development environment. </title> <booktitle> In Proc. ACM SIGSOFT/SIGPLAN Software Eng. Symp. on Practical Software Development Environments, </booktitle> <year> 1984. </year> <note> See also SIGPLAN Notices, 19,5, 177-184. </note>
Reference-contexts: They have since been used in a broader class of applications (e.g., debugging parallel programs [6], maintenance [11, 13, 23], and testing [15, 16, 20, 27]). Weiser's algorithm for computing slices is based on data flow analysis. It is suggested in <ref> [25] </ref> that a program dependence graph representation can be used to compute slices more efficiently and precisely. An algorithm for computing slices using a program dependence graph representation is presented by Horwitz, Reps, and Binkley [14, 29].
Reference: [26] <author> Linda M. Ott and Jeffrey J. Thuss. </author> <title> The relationship between slices and module cohesion. </title> <booktitle> In Proc. 11th International Conference on Software Engineering, </booktitle> <pages> pages 198-204, </pages> <year> 1989. </year>
Reference-contexts: We will use the term "procedure" to refer to both procedures and functions. 2 A program slice is the portion of program text that affects a specified program variable [33]. A variation on program slices can model and measure functional cohesion <ref> [26] </ref>. A slice profile is one heuristic tool that can help one visualize the cohesion in a procedure [23]. In this paper, we focus on the development and analysis of quantitative measures that indicate the "amount of functional cohesion" in procedures. <p> Figure 2 shows an example of a metric slice profile. We indicate, in the column for a slice variable, the number of data tokens in that line that are included in the slice. This profile was derived from an earlier method developed for visualizing slices <ref> [26, 31] </ref>. 1 That is from the FinalUse nodes as described in [14] 5 SumN ProdN Statement 2 2 procedure SumAndProduct ( N : integer; var SumN, ProdN : integer ); var 1 1 I : integer; begin 2 SumN := 0; 2 ProdN := 1; 3 3 for I := <p> A does indicate that Lookup3 is less cohesive than Lookup2, however, unlike SFC, A also indicates that there are some cohesive components. 6 Related Work Our current efforts are based on earlier work using slice based measures as indicators of cohesion <ref> [19, 31, 26, 28] </ref>. Longworth [19] and Thuss [31, 26] examined the potential of measures proposed by Weiser [33] as indicators of cohesion. Ott and Thuss first first noted the visual relationship that existed between the slices of a module and its cohesion as depicted in a slice profile [26]. <p> A does indicate that Lookup3 is less cohesive than Lookup2, however, unlike SFC, A also indicates that there are some cohesive components. 6 Related Work Our current efforts are based on earlier work using slice based measures as indicators of cohesion [19, 31, 26, 28]. Longworth [19] and Thuss <ref> [31, 26] </ref> examined the potential of measures proposed by Weiser [33] as indicators of cohesion. Ott and Thuss first first noted the visual relationship that existed between the slices of a module and its cohesion as depicted in a slice profile [26]. <p> Longworth [19] and Thuss [31, 26] examined the potential of measures proposed by Weiser [33] as indicators of cohesion. Ott and Thuss first first noted the visual relationship that existed between the slices of a module and its cohesion as depicted in a slice profile <ref> [26] </ref>. The insights gained from this earlier work were instrumental in developing the data slice model of cohesion and cohesion measures presented here. <p> Thus, these flow graphs are more closely related to metric slicing than Weiser's original definition of slicing [33]. Weiser only used "backwards slices" while Emerson's subflowgraph is clearly related to both forwards and backwards slicing. The measure defined by Emerson is somewhat analogous to the coverage measure defined in <ref> [26] </ref>. (coverage is the average of the lengths of each slice to the module length.) Emerson's measure is the ratio of the average of the size of the reference sets (weighted by the cyclomatic complexity of the subgraph generated from the reference set) to the size of the flow graph (weighted
Reference: [27] <author> Linda M. Ott and Jeffrey J. Thuss. </author> <title> Using slice profiles and metrics as tools in the production of reliable software. </title> <type> Technical Report CS-92-8, </type> <institution> Dept. Computer Science, Michigan Technological Univ., </institution> <month> April </month> <year> 1992. </year> <note> Also published as Technical Report CS-92-115 Dept. </note> <institution> Computer Science, Colorado State Univ. </institution>
Reference-contexts: Slices were proposed as potential debugging tools and program understanding aids. They have since been used in a broader class of applications (e.g., debugging parallel programs [6], maintenance [11, 13, 23], and testing <ref> [15, 16, 20, 27] </ref>). Weiser's algorithm for computing slices is based on data flow analysis. It is suggested in [25] that a program dependence graph representation can be used to compute slices more efficiently and precisely.
Reference: [28] <author> Linda M. Ott and Jeffrey J. Thuss. </author> <title> Slice based metrics for estimating cohesion. </title> <booktitle> Proc. IEEE-CS Int. Software Metrics Symp., </booktitle> <pages> pages 71-81, </pages> <year> 1993. </year>
Reference-contexts: Our measurement theory approach requires that a measure be consistent with intuition, and including program text in our abstraction eases intuitive analyses. 2.2 Data Slices In [35], Weiser defined several slice based measures. Longworth [19] first studied their use as indicators of cohesion. In <ref> [28, 31] </ref>, certain inconsistencies noted by Longworth are eliminated through the use of metric slices. A metric slice takes into account both the uses and used by data relationships [12]; that is, they are the union of Horwitz et.al.'s backward and forward slices. <p> SFC is very similar to the Tightness measure defined by Ott and Thuss <ref> [28] </ref>. However Tightness is defined in terms of statements shared by slices rather than data tokens. We can also measure cohesion in terms of the glue tokens in a slice abstraction. <p> Adhesiveness should indicate the relative strength of the glue in a procedure. Adhesiveness is most closely related to the coverage measure of Ott and Thuss <ref> [28] </ref>. It should be particularly sensitive to the cohesion resulting from glue tokens that lie on more than two slices, but do not lie on all slices. All of these cohesion measures (strong functional cohesion, weak functional cohesion, and adhesiveness) range in value from zero to one. <p> A does indicate that Lookup3 is less cohesive than Lookup2, however, unlike SFC, A also indicates that there are some cohesive components. 6 Related Work Our current efforts are based on earlier work using slice based measures as indicators of cohesion <ref> [19, 31, 26, 28] </ref>. Longworth [19] and Thuss [31, 26] examined the potential of measures proposed by Weiser [33] as indicators of cohesion. Ott and Thuss first first noted the visual relationship that existed between the slices of a module and its cohesion as depicted in a slice profile [26].
Reference: [29] <author> T. Reps and W. Yang. </author> <title> The semantics of program slicing and program integration. </title> <booktitle> In Proc. Colloquium on Current Issues in Programming Languages, </booktitle> <pages> pages 360-374, </pages> <year> 1989. </year> <booktitle> Lecture Notes in Computer Science, </booktitle> <volume> Vol. 352, </volume> <publisher> Springer-Verlag, </publisher> <address> New York, NY. </address>
Reference-contexts: It is suggested in [25] that a program dependence graph representation can be used to compute slices more efficiently and precisely. An algorithm for computing slices using a program dependence graph representation is presented by Horwitz, Reps, and Binkley <ref> [14, 29] </ref>. A slice is obtained by walking backwards over the program dependence graph to obtain all nodes which have an effect on the value of the variable of interest.
Reference: [30] <author> R. Selby and V. Basili. </author> <title> Analyzing Error-Prone System Coupling and Cohesion. </title> <type> Technical Report UMIACS-TR-88-46, </type> <institution> Computer Science, University of Maryland, </institution> <month> June </month> <year> 1988. </year>
Reference-contexts: The insights gained from this earlier work were instrumental in developing the data slice model of cohesion and cohesion measures presented here. Other researchers have also examined the problem of measuring cohesion including Emerson [7, 8], Lakhotia [18], Troy and Zweben [32], and Selby and Basili <ref> [30] </ref>. 21 success passwd address 3 3 3 procedure LookUp2 (A: Table; Size: integer; key: keytype; 1 1 1 var success: boolean; 1 1 var passwd: integer; 1 1 var address: string); begin 2 2 2 i := 1; 2 2 2 success:= false; 3 3 3 while not success and <p> Troy and Zweben did not attempt to show a relationship between these measures and cohesion. Selby and Basili examined a measure based on data interactions, called data bindings, as a basis for computing the cohesion and coupling of the components of a system <ref> [30] </ref>. Routines are placed into clusters based on the data bindings and the coupling of a cluster with other clusters is determined. A ratio of the cluster coupling factor to the internal strength of a cluster is computed.
Reference: [31] <author> Jeffrey J. Thuss. </author> <title> An investigation into slice based cohesion metrics. </title> <type> Master's thesis, </type> <institution> Michigan Technological University, </institution> <year> 1988. </year>
Reference-contexts: Our measurement theory approach requires that a measure be consistent with intuition, and including program text in our abstraction eases intuitive analyses. 2.2 Data Slices In [35], Weiser defined several slice based measures. Longworth [19] first studied their use as indicators of cohesion. In <ref> [28, 31] </ref>, certain inconsistencies noted by Longworth are eliminated through the use of metric slices. A metric slice takes into account both the uses and used by data relationships [12]; that is, they are the union of Horwitz et.al.'s backward and forward slices. <p> Figure 2 shows an example of a metric slice profile. We indicate, in the column for a slice variable, the number of data tokens in that line that are included in the slice. This profile was derived from an earlier method developed for visualizing slices <ref> [26, 31] </ref>. 1 That is from the FinalUse nodes as described in [14] 5 SumN ProdN Statement 2 2 procedure SumAndProduct ( N : integer; var SumN, ProdN : integer ); var 1 1 I : integer; begin 2 SumN := 0; 2 ProdN := 1; 3 3 for I := <p> A does indicate that Lookup3 is less cohesive than Lookup2, however, unlike SFC, A also indicates that there are some cohesive components. 6 Related Work Our current efforts are based on earlier work using slice based measures as indicators of cohesion <ref> [19, 31, 26, 28] </ref>. Longworth [19] and Thuss [31, 26] examined the potential of measures proposed by Weiser [33] as indicators of cohesion. Ott and Thuss first first noted the visual relationship that existed between the slices of a module and its cohesion as depicted in a slice profile [26]. <p> A does indicate that Lookup3 is less cohesive than Lookup2, however, unlike SFC, A also indicates that there are some cohesive components. 6 Related Work Our current efforts are based on earlier work using slice based measures as indicators of cohesion [19, 31, 26, 28]. Longworth [19] and Thuss <ref> [31, 26] </ref> examined the potential of measures proposed by Weiser [33] as indicators of cohesion. Ott and Thuss first first noted the visual relationship that existed between the slices of a module and its cohesion as depicted in a slice profile [26].
Reference: [32] <author> D. Troy and S. </author> <title> Zweben. Measuring the Quality of Structured Designs. </title> <journal> Journal of Systems and Software, </journal> <volume> 2 </volume> <pages> 113-120, </pages> <year> 1981. </year>
Reference-contexts: The insights gained from this earlier work were instrumental in developing the data slice model of cohesion and cohesion measures presented here. Other researchers have also examined the problem of measuring cohesion including Emerson [7, 8], Lakhotia [18], Troy and Zweben <ref> [32] </ref>, and Selby and Basili [30]. 21 success passwd address 3 3 3 procedure LookUp2 (A: Table; Size: integer; key: keytype; 1 1 1 var success: boolean; 1 1 var passwd: integer; 1 1 var address: string); begin 2 2 2 i := 1; 2 2 2 success:= false; 3 3 <p> We are able to generate relative levels of functional cohesion using our measures. 6.3 Other work related to cohesion Troy and Zweben examined the quality of structured designs using, in part, some design cohesion indicators <ref> [32] </ref>.
Reference: [33] <author> M. D. Weiser. </author> <title> Program slicing. </title> <booktitle> In Proceedings of the 5th International Conference on Software Engineering, </booktitle> <pages> pages 439-449, </pages> <year> 1981. </year>
Reference-contexts: We will use the term "procedure" to refer to both procedures and functions. 2 A program slice is the portion of program text that affects a specified program variable <ref> [33] </ref>. A variation on program slices can model and measure functional cohesion [26]. A slice profile is one heuristic tool that can help one visualize the cohesion in a procedure [23]. <p> In the case of procedures with multiple outputs, we see how closely the program parts that contribute to different outputs are bound. Using this approach, procedures with only one output exhibit maximum functional cohesion. 2.1 Program Slices Slicing is a method of program reduction introduced by Weiser <ref> [33, 34, 35] </ref>. A slice of a procedure at statement s with respect to variable v is the sequence of all statements and predicates that might affect the value of v at s. Slices were proposed as potential debugging tools and program understanding aids. <p> Longworth [19] and Thuss [31, 26] examined the potential of measures proposed by Weiser <ref> [33] </ref> as indicators of cohesion. Ott and Thuss first first noted the visual relationship that existed between the slices of a module and its cohesion as depicted in a slice profile [26]. <p> Emerson computes flow subgraphs based on generating all vertices which are either reachable from an element of R or from which an element of R is reachable. Thus, these flow graphs are more closely related to metric slicing than Weiser's original definition of slicing <ref> [33] </ref>. Weiser only used "backwards slices" while Emerson's subflowgraph is clearly related to both forwards and backwards slicing.
Reference: [34] <author> M. D. Weiser. </author> <title> Programmers use slices when debugging. </title> <journal> Communications of the ACM, </journal> <volume> 25(7) </volume> <pages> 446-452, </pages> <year> 1982. </year>
Reference-contexts: In the case of procedures with multiple outputs, we see how closely the program parts that contribute to different outputs are bound. Using this approach, procedures with only one output exhibit maximum functional cohesion. 2.1 Program Slices Slicing is a method of program reduction introduced by Weiser <ref> [33, 34, 35] </ref>. A slice of a procedure at statement s with respect to variable v is the sequence of all statements and predicates that might affect the value of v at s. Slices were proposed as potential debugging tools and program understanding aids.
Reference: [35] <author> M. D. Weiser. </author> <title> Program slicing. </title> <journal> IEEE Trans. Software Engineering, </journal> <volume> 10(4) </volume> <pages> 352-357, </pages> <year> 1984. </year>
Reference-contexts: In the case of procedures with multiple outputs, we see how closely the program parts that contribute to different outputs are bound. Using this approach, procedures with only one output exhibit maximum functional cohesion. 2.1 Program Slices Slicing is a method of program reduction introduced by Weiser <ref> [33, 34, 35] </ref>. A slice of a procedure at statement s with respect to variable v is the sequence of all statements and predicates that might affect the value of v at s. Slices were proposed as potential debugging tools and program understanding aids. <p> Slices promote a more intuitive analysis since they are based on program text. Our measurement theory approach requires that a measure be consistent with intuition, and including program text in our abstraction eases intuitive analyses. 2.2 Data Slices In <ref> [35] </ref>, Weiser defined several slice based measures. Longworth [19] first studied their use as indicators of cohesion. In [28, 31], certain inconsistencies noted by Longworth are eliminated through the use of metric slices.
Reference: [36] <author> L. Wilson and L. Leelasena. </author> <title> The QUALMS program documentation. </title> <type> Technical Report Alvey Project SE/69, </type> <institution> SBP/102, South Bank Polytechnic, </institution> <address> London, </address> <year> 1988. </year>
Reference-contexts: The measures should be specified independently from the measurement tools, and such tools should be based on the models. For example, QUALMS <ref> [36] </ref> is based on the flow graph model, and the test coverage measurement tools of Bieman and Schultz [4, 5] are based on the standard representation model [3]. We use a slice abstraction of a program based on data slices to model cohesion [24].
Reference: [37] <author> E. Yourdon and L. Constantine. </author> <title> Structured Design. </title> <address> Englewood Cliffs, NJ, </address> <publisher> Prentice-Hall, </publisher> <year> 1979. </year>
Reference-contexts: A highly cohesive software module is a module that has one basic function and is indivisible | it is difficult to split a cohesive module into separate components. Module cohesion can be classified using an ordinal scale that includes coincidental, logical, temporal, procedural, communicational, sequential, and functional cohesion <ref> [37] </ref>. Using this model, a module exhibits one of these seven cohesion categories. The cohesion categories vary in desirability ranging from the most desirable (functional cohesion) to the least desirable (coincidental cohesion). <p> Metrics based on the relative number of glue and super-glue tokens are intuitive and can easily be defined in terms of slice abstractions. According to Yourdon and Constantine <ref> [37] </ref>, a procedure with functional cohesion is one in which all parts are cohesive. This view recognizes only the strongest functional cohesion and is consistent with the use of the super-glue tokens as the basis for defining cohesion attributes and measures. <p> one output variable; it is undefined if it has no output variables; else it is the lowest cohesion of all pairs of the output variables of the module." Through examples Lakhotia argues that this method closely matches the original classifications (coincidental, logical, temporal, procedural, communicational, sequential, and functional) of cohesion <ref> [37] </ref>. Rather than develop an algorithmic mechanism to determine the original levels of cohesion, our objective is to quantify the amount of functional cohesion. Thus, in certain situations we will obtain differing results. For example, our measures will indicate that a significant part of a module is highly cohesive. <p> Strong functional cohesion (SFC) is based on the relative number of super-glue tokens in a procedure. SFC is the measure most closely related to the original definition of functional cohesion of Yourdan and Constantine <ref> [37] </ref>. Weak functional cohesion (WFC) is based on the relative number of glue tokens in a procedure and includes some notion of Yourdan and Constantine's weaker categories of cohesion.
Reference: [38] <author> H. Zuse and P. Bollmann. </author> <title> Software metrics: using measurement theory to describe the properties and scales of software complexity metrics. </title> <journal> ACM SIGPLAN Notices, </journal> <volume> 24(8) </volume> <pages> 23-33, </pages> <month> August </month> <year> 1989. </year>
Reference-contexts: Then we determine whether the metrics assume the requirements of a ratio scale. 4.1 Cohesion Measures and the Ordinal Scale For a real-valued ordinal scale measure of cohesion attributes to exist, our intuition about these attributes, called "empirical relations" or "viewpoints", must satisfy three axioms: reflexivity, transitivity, and completeness <ref> [38, 39, 40] </ref>. These are the requirements of a weak order. <p> These are the requirements of a weak order. From <ref> [38] </ref> we define a cohesion viewpoint as binary relations, ?, ? , and ? on programs P where: P 1 ?&gt; P 2 P 1 is more "cohesive" than P 2 P 1 ? P 2 P 1 is equally as "cohesive" as P 2 P 1 ? P 2 P <p> The measures are not additive, and are, thus, not on a ratio scale. However, the behavior of the measures under composition provides insight. One property that is required (but not sufficient) for a ratio scale measure is that the measure be consistent with the axiom of weak monotonicity <ref> [38] </ref>: P 1 ? P 2 ) P 1 ffi P 3 ? P 2 ffi P 3 We use the axiom of weak monotonicity as a mechanism for comparing the three cohesion measures.
Reference: [39] <author> H. Zuse. </author> <title> Software Complexity Measures and Methods. </title> <publisher> W. de Gruyter, </publisher> <address> Berlin, </address> <year> 1991. </year>
Reference-contexts: The direction of measurement changes provides a ranking of relative levels of cohesion before and after a code change. Our analysis also demonstrates the scale properties and the arithmetic operations that can be applied to the measurement values <ref> [39] </ref>. The scale type of a measure is of critical importance. A useful measure may be of nominal, ordinal, interval, ratio, or absolute scale. <p> We need to rely on human intuition 10 to determine the relative levels of our cohesion properties, to see if they are consistent with the metric values. Zuse shows that software measures can be validated in terms of their scale properties <ref> [39, 40] </ref>. We combine the methods of Fenton and Zuse to analytically validate the cohesion measures in terms of intuitive notions of cohesion and scale properties. First we show that the measures are on an ordinal scale that matches our intuition concerning the cohesion attributes that are measured. <p> Then we determine whether the metrics assume the requirements of a ratio scale. 4.1 Cohesion Measures and the Ordinal Scale For a real-valued ordinal scale measure of cohesion attributes to exist, our intuition about these attributes, called "empirical relations" or "viewpoints", must satisfy three axioms: reflexivity, transitivity, and completeness <ref> [38, 39, 40] </ref>. These are the requirements of a weak order. <p> The measures are on an ordinal scale to the extent that the orderings imposed by the measures match the users (of the measures) intuition concerning the elementary viewpoints of cohesion. 4.2 Cohesion Measures and the Ratio Scale Zuse shows that ratio scale measures are often more meaningful than interval scales <ref> [39] </ref>. Thus we evaluate our functional cohesion measures in terms of the requirements for ratio scale measurement. To demonstrate that a measure is on the ratio scale we include a program composition operator "ffi" to the relational system. Thus we have a relational system (P; ?; ffi). <p> The binary composition operator is a critical component to Zuse and Bollman's method of demonstrating whether a measure is on a ratio scale. One demonstrates the scale properties relative to the binary operation. Zuse and Bollman developed the technique to evaluate control flow complexity measures <ref> [39] </ref>, where binary composition is fairly easy to define for flow graphs. The difficulty of defining a composition operator for slice abstractions concerns the mechanism for combining the slices together. We define two mechanisms for combining two slice abstractions into one: Option 1: Tie slices together.
Reference: [40] <author> H. Zuse. </author> <title> Support of validation of software measures by measurement theory. </title> <booktitle> Invited Presentation at the 15th Int. Conf. on Software Engineering (ICSE-15) and the First IEEE-CS Int. Software Metrics Symp., </booktitle> <address> Baltimore, MD, </address> <month> May </month> <year> 1993. </year> <month> 28 </month>
Reference-contexts: We need to rely on human intuition 10 to determine the relative levels of our cohesion properties, to see if they are consistent with the metric values. Zuse shows that software measures can be validated in terms of their scale properties <ref> [39, 40] </ref>. We combine the methods of Fenton and Zuse to analytically validate the cohesion measures in terms of intuitive notions of cohesion and scale properties. First we show that the measures are on an ordinal scale that matches our intuition concerning the cohesion attributes that are measured. <p> Then we determine whether the metrics assume the requirements of a ratio scale. 4.1 Cohesion Measures and the Ordinal Scale For a real-valued ordinal scale measure of cohesion attributes to exist, our intuition about these attributes, called "empirical relations" or "viewpoints", must satisfy three axioms: reflexivity, transitivity, and completeness <ref> [38, 39, 40] </ref>. These are the requirements of a weak order.
References-found: 40

