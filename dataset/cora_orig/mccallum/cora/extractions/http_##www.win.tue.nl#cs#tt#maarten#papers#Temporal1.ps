URL: http://www.win.tue.nl/cs/tt/maarten/papers/Temporal1.ps
Refering-URL: http://www.win.tue.nl/cs/tt/maarten/
Root-URL: http://www.win.tue.nl
Email: maarten@win.tue.nl  
Title: A Transaction-Based Temporal Data Model for Real-Time Databases  
Author: M.P. Bodlaender fi P.D.V .v.d. Stok fi S.H. Son 
Address: The Netherlands USA  
Affiliation: Dept. of Computing Science fi Dept. of Computer Science Technical University Eindhoven University of Virginia  
Abstract: We propose a real-time database model that deals with the temporal nature of data. Previous models assigned validity intervals with data items. A value of a data item is then only valid within the corresponding interval. In the new model, it is recognized that validity depends on the usage of the data item, therefore temporal validity is a characteristic of transactions, rather than of data items. The paper shows the influence of this different modeling on the expressiveness of the specification. It compares the transaction-based model with existing models that cover the same area, by looking at implementations that are based on these models. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> B. Adelberg, B. Kao, and H. Garcia-Molina. </author> <title> Database support for efficiently maintained derived data. </title> <address> EDBT, </address> <year> 1996. </year>
Reference-contexts: This constraint is added to the relative temporal correctness constraint set t:rtc of the transaction t that derives Y . 7. An "always fresh" implementation The temporal database consistency requirement is implemented using the straightforward "always-fresh" approach (alternatively, "on demand" approaches are possible, see for instance <ref> [1] </ref>). Refresh transactions are scheduled such that all temporal items always satisfy the strongest absolute temporal requirement on that item.
Reference: [2] <author> N. Audsley, A. Burns, M. Richardson, and A. Wellings. </author> <title> Absolute and relative temporal constraints in hard real-time databases. </title> <booktitle> Proc. of the Fourth Euromicro Workshop on Real-time systems, </booktitle> <year> 1992. </year>
Reference-contexts: Real-time database systems have to deal with data that change in time. Traditional database fl This work is part of STW project EIF33.3129 theory [6, 9] does not suffice, as it guarantees only functional correctness. New correctness criteria <ref> [2, 4, 5, 10] </ref> have been developed that deal explicitly with the temporal nature of data. This paper presents a new model that is a generalization of the models presented in [2] and [4]. For brevity, only the model from [4] is compared with in this paper. <p> New correctness criteria [2, 4, 5, 10] have been developed that deal explicitly with the temporal nature of data. This paper presents a new model that is a generalization of the models presented in <ref> [2] </ref> and [4]. For brevity, only the model from [4] is compared with in this paper. A more complete paper is under preparation. In the next Section we discuss related work. The concept of temporal data is introduced in section 3. The temporal correctness criteria are defined in section 4. <p> Related work The scheduling problem in real-time databases is especially hard, because it combines two NP-complete problems: scheduling to meet all timing constraints, and scheduling to preserve functional correctness (see [6, 8, 9]). The temporal data model in <ref> [2] </ref> distinguishes between temporal and non-temporal data. Audsley, et.al. achieve a reduction in complexity by demanding the single writer property for temporal data. This reduces the complexity of the serializability requirement. Temporal validity is a characteristic of temporal data items. <p> Audsley, et.al. achieve a reduction in complexity by demanding the single writer property for temporal data. This reduces the complexity of the serializability requirement. Temporal validity is a characteristic of temporal data items. The temporal data model used in <ref> [2, 4, 10] </ref> assigns "temporal validity intervals" for each instance of a temporal data item. Instances of items are only valid within their temporal validity intervals. When the validity of an instance of a data item expires, a new instance (with a new value) should be created. <p> However, inconsistency in the Epsilon Serializability model arises from conflicting concurrently executing transactions (during execution, a transaction compromises the database consistency), while inconsistency in our model is caused by the passage of time (instances of data grow old). In that aspect, our model is closer to <ref> [2] </ref> and [4]. 3. A real-time database model with temporal data The database consists of a set of data items. Data items can be atomically read and written. <p> It is also possible that transactions require that a set of data is relatively temporally consistent. This means that all data in the set must have approximately the same age, such that time-dependent correlations can be made. 4.1. Absolute temporal correctness In the model presented in <ref> [2, 4] </ref>, absolute temporal correctness is realized by assigning an absolute temporal validity interval to each data item. As long as transactions read values within these intervals, the data is temporally correct.
Reference: [3] <author> M. Bodlaender, P. v. d. Stok, and S. Son. </author> <title> A transaction-based temporal data model for real-time databases. </title> <institution> Computing Science Note, Eind-hoven University of Technology, </institution> <year> 1997. </year>
Reference-contexts: Each temporal data item is written by a single transaction, that can be executed more than once. Instances of the same transaction are serialized according to their start-times. This is called the serialized writer property, and is further explained in <ref> [3] </ref>. Transaction t reads a set of items t:IN , and writes a set of items t:OU T . For each temporal item X 2 t:IN a maximal age t:m (X) can be defined. Instances of item X read by t should not be older than this maximal age. <p> The freedom in those decisions, and the resulting schedules vary for each specification method. In this example, we have explicitly parameterized these choices to see what the options are for the designer. The complete parameterization will appear in <ref> [3] </ref>. In our model, the system designer can vary X between 0 and 15, controlling the trade-off between the period-length of "radar image": X and "detect": 15 X, and Y can be varied from 0 to 30, to control the trade-off between "flight info": Y and "count": 60 Y .
Reference: [4] <author> Y.-K. Kim and S. H. Son. </author> <title> Supporting predictability in real-time database systems. </title> <booktitle> IEEE Real-Time Technology and Applications Symposium (RTAS'96), </booktitle> <pages> pp 38-48, </pages> <year> 1996. </year>
Reference-contexts: Real-time database systems have to deal with data that change in time. Traditional database fl This work is part of STW project EIF33.3129 theory [6, 9] does not suffice, as it guarantees only functional correctness. New correctness criteria <ref> [2, 4, 5, 10] </ref> have been developed that deal explicitly with the temporal nature of data. This paper presents a new model that is a generalization of the models presented in [2] and [4]. For brevity, only the model from [4] is compared with in this paper. <p> New correctness criteria [2, 4, 5, 10] have been developed that deal explicitly with the temporal nature of data. This paper presents a new model that is a generalization of the models presented in [2] and <ref> [4] </ref>. For brevity, only the model from [4] is compared with in this paper. A more complete paper is under preparation. In the next Section we discuss related work. The concept of temporal data is introduced in section 3. The temporal correctness criteria are defined in section 4. <p> New correctness criteria [2, 4, 5, 10] have been developed that deal explicitly with the temporal nature of data. This paper presents a new model that is a generalization of the models presented in [2] and <ref> [4] </ref>. For brevity, only the model from [4] is compared with in this paper. A more complete paper is under preparation. In the next Section we discuss related work. The concept of temporal data is introduced in section 3. The temporal correctness criteria are defined in section 4. <p> A more complete paper is under preparation. In the next Section we discuss related work. The concept of temporal data is introduced in section 3. The temporal correctness criteria are defined in section 4. Finally, comparisons are made between the temporal data model from <ref> [4] </ref> and the temporal data model that is presented in this paper, by providing mappings between the models and examining possible implementations of both models. 2. <p> Audsley, et.al. achieve a reduction in complexity by demanding the single writer property for temporal data. This reduces the complexity of the serializability requirement. Temporal validity is a characteristic of temporal data items. The temporal data model used in <ref> [2, 4, 10] </ref> assigns "temporal validity intervals" for each instance of a temporal data item. Instances of items are only valid within their temporal validity intervals. When the validity of an instance of a data item expires, a new instance (with a new value) should be created. <p> However, inconsistency in the Epsilon Serializability model arises from conflicting concurrently executing transactions (during execution, a transaction compromises the database consistency), while inconsistency in our model is caused by the passage of time (instances of data grow old). In that aspect, our model is closer to [2] and <ref> [4] </ref>. 3. A real-time database model with temporal data The database consists of a set of data items. Data items can be atomically read and written. <p> It is also possible that transactions require that a set of data is relatively temporally consistent. This means that all data in the set must have approximately the same age, such that time-dependent correlations can be made. 4.1. Absolute temporal correctness In the model presented in <ref> [2, 4] </ref>, absolute temporal correctness is realized by assigning an absolute temporal validity interval to each data item. As long as transactions read values within these intervals, the data is temporally correct. <p> Determining the expressiveness of the model The transaction-based model is compared with the item-based model from Kim and Son. We provide a short summary of <ref> [4] </ref>, and give a mapping to the transaction-based model. The mapping shows that the transaction-based model is at least as expressive as the item-based model. In section 7 an example shows that the transaction-based model is more expressive than the item-based model. 6.1. <p> Implementation according to Kim and Son's model Kim and Son describe an extensive database system that deals with hard real-time, as well as soft real-time transactions. We use the hard real-time scheduling part of <ref> [4] </ref>, thus obtaining the following requirements on periods and deadlines: radar image:p + radar image:dl 10 f light info:p + f light info:dl 10 detect:p + detect:dl 5: detect:dl radar image:dl count:p + count:dl 50: count:dl radar image:dl 7.2.
Reference: [5] <author> T.-W. Kuo and A. Mok. </author> <title> Ssp: a semantics-based protocol for real-time data access. </title> <booktitle> Proceedings 14th real-time systems symposium, </booktitle> <year> 1993. </year>
Reference-contexts: Real-time database systems have to deal with data that change in time. Traditional database fl This work is part of STW project EIF33.3129 theory [6, 9] does not suffice, as it guarantees only functional correctness. New correctness criteria <ref> [2, 4, 5, 10] </ref> have been developed that deal explicitly with the temporal nature of data. This paper presents a new model that is a generalization of the models presented in [2] and [4]. For brevity, only the model from [4] is compared with in this paper. <p> Instances of items are only valid within their temporal validity intervals. When the validity of an instance of a data item expires, a new instance (with a new value) should be created. Kuo and Mok present "view -similarity" <ref> [5] </ref> as a better solution to the NP-complete functional correctness scheduling problem. For each data item, a "similarity bound" is specified. The normal serializability constraint is replaced with a weaker constraint.
Reference: [6] <author> C. H. Papadimitriou. </author> <title> The serializability of concurrent database updates. </title> <journal> Journal of the association for computing machinery, </journal> <month> October </month> <year> 1979. </year>
Reference-contexts: Databases that support complex data models, and ensure both functional and temporal correctness can provide an important building block for real-time systems. Real-time database systems have to deal with data that change in time. Traditional database fl This work is part of STW project EIF33.3129 theory <ref> [6, 9] </ref> does not suffice, as it guarantees only functional correctness. New correctness criteria [2, 4, 5, 10] have been developed that deal explicitly with the temporal nature of data. This paper presents a new model that is a generalization of the models presented in [2] and [4]. <p> Related work The scheduling problem in real-time databases is especially hard, because it combines two NP-complete problems: scheduling to meet all timing constraints, and scheduling to preserve functional correctness (see <ref> [6, 8, 9] </ref>). The temporal data model in [2] distinguishes between temporal and non-temporal data. Audsley, et.al. achieve a reduction in complexity by demanding the single writer property for temporal data. This reduces the complexity of the serializability requirement. Temporal validity is a characteristic of temporal data items.
Reference: [7] <author> K. Ramamritham and C. Pu. </author> <title> A formal characterization of epsilon serializability. </title> <journal> IEEE Trans. on Knowledge and Data Engineering, </journal> <volume> vol. 7, no 6, </volume> <pages> pp 997-1007, </pages> <year> 1995. </year>
Reference-contexts: The rationale for this more liberal approach is that instances that are created at approximately the same time, are "similar" enough to be treated as the same instance. Epsilon Serializability (see <ref> [7] </ref>) is also directed at weakening the serializability constraint. Data items can be read, although their value is inconsistent. The amount of inconsistency is defined as the "distance" to a consistent state. Transactions that read data can express an "import-limit" on the amount of inconsistency that is allowed.
Reference: [8] <author> K. Vidyasankar. </author> <title> A simple characterization of database serializability. </title> <booktitle> 5th conf. on foundations of software technology and theoretical computer science, LNCS 206, </booktitle> <year> 1985. </year>
Reference-contexts: Related work The scheduling problem in real-time databases is especially hard, because it combines two NP-complete problems: scheduling to meet all timing constraints, and scheduling to preserve functional correctness (see <ref> [6, 8, 9] </ref>). The temporal data model in [2] distinguishes between temporal and non-temporal data. Audsley, et.al. achieve a reduction in complexity by demanding the single writer property for temporal data. This reduces the complexity of the serializability requirement. Temporal validity is a characteristic of temporal data items.
Reference: [9] <author> K. Vidyasankar. </author> <title> Unified theory of database seri-alizability. </title> <note> Fundamenta Informaticae XIV, </note> <year> 1991. </year>
Reference-contexts: Databases that support complex data models, and ensure both functional and temporal correctness can provide an important building block for real-time systems. Real-time database systems have to deal with data that change in time. Traditional database fl This work is part of STW project EIF33.3129 theory <ref> [6, 9] </ref> does not suffice, as it guarantees only functional correctness. New correctness criteria [2, 4, 5, 10] have been developed that deal explicitly with the temporal nature of data. This paper presents a new model that is a generalization of the models presented in [2] and [4]. <p> Related work The scheduling problem in real-time databases is especially hard, because it combines two NP-complete problems: scheduling to meet all timing constraints, and scheduling to preserve functional correctness (see <ref> [6, 8, 9] </ref>). The temporal data model in [2] distinguishes between temporal and non-temporal data. Audsley, et.al. achieve a reduction in complexity by demanding the single writer property for temporal data. This reduces the complexity of the serializability requirement. Temporal validity is a characteristic of temporal data items.
Reference: [10] <author> M. Xiong, J. Stankovic, K. Ramamritham, D. Towsley, and R. Sivasankaran. </author> <title> Maintaining temporal consistency: Issues and algorithms. </title> <booktitle> Proc. of the First International Workshop on Real-Time Databases: Issues and Applications, </booktitle> <year> 1996. </year>
Reference-contexts: Real-time database systems have to deal with data that change in time. Traditional database fl This work is part of STW project EIF33.3129 theory [6, 9] does not suffice, as it guarantees only functional correctness. New correctness criteria <ref> [2, 4, 5, 10] </ref> have been developed that deal explicitly with the temporal nature of data. This paper presents a new model that is a generalization of the models presented in [2] and [4]. For brevity, only the model from [4] is compared with in this paper. <p> Audsley, et.al. achieve a reduction in complexity by demanding the single writer property for temporal data. This reduces the complexity of the serializability requirement. Temporal validity is a characteristic of temporal data items. The temporal data model used in <ref> [2, 4, 10] </ref> assigns "temporal validity intervals" for each instance of a temporal data item. Instances of items are only valid within their temporal validity intervals. When the validity of an instance of a data item expires, a new instance (with a new value) should be created.
References-found: 10

