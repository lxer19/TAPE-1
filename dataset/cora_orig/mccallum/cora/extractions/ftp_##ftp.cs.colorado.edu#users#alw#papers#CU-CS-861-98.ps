URL: ftp://ftp.cs.colorado.edu/users/alw/papers/CU-CS-861-98.ps
Refering-URL: http://www.cs.colorado.edu/users/alw/RecentPubs.html
Root-URL: http://www.cs.colorado.edu
Email: (inverard@univaq.it) (alw@cs.colorado.edu) (dany@se.uba.ar)  
Title: Behavioral Type Checking of Architectural Components Based on Assumptions  
Author: Paola Inverardi Alexander L. Wolf Daniel Yankelevich 
Note: The work of A.L. Wolf was supported in part by the National Science Foundation under grant INT-95-14202.  
Address: I-67010 L'Aquila, Italy Boulder, CO 80309 USA Buenos Aires, Argentina  
Affiliation: Dipartimento di Matematica Department of Computer Science Departmento de Computacion Universita dell' Aquila University of Colorado Universidad de Buenos Aires  
Abstract: University of Colorado Department of Computer Science Technical Report CU-CS-861-98 April 1998 ABSTRACT A critical challenge faced by the developer of a software system is to understand whether the system's components correctly integrate. While type theory has provided substantial help in detecting and preventing errors in mismatched static properties, much work remains in the area of dynamics. In particular, components make assumptions about their behavioral interaction with other components, but currently we have only limited ways in which to state those assumptions and to analyze those assumptions for correctness. We have begun to formulate a method that addresses this problem. The method operates at the architectural level so that behavioral integration errors, such as deadlock, can be revealed early in development. For each component, a specification is given both of its own interaction behavior and of the assumptions that it makes about the interaction behavior of the external context in which it expects to operate. We have defined an algorithm that, given such specifications for a set of components, performs "adequacy" checks between the component context assumptions and the component interaction behaviors. A configuration of a system is possible if and only if a successful way of "matching" actual behaviors with assumptions can be found. In effect, we are extending the usual notion of type checking to include the checking of behavioral compatibility. c fl 1998 Paola Inverardi, Alexander L. Wolf, and Daniel Yankelevich
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> R. Allen and D. Garlan. </author> <title> A Case Study in Architectural Modeling: </title> <booktitle> The AEGIS System. In Proceedings of the 8th International Workshop on Software Specification and Design, </booktitle> <pages> pages 6-15. </pages> <publisher> IEEE Computer Society, </publisher> <month> March </month> <year> 1996. </year>
Reference-contexts: In that work, a description of potential behavior is given by a regular expression in which atomic elements represent calls to the component. The idea of using behavioral equivalence to check the dynamics of a software system at the architectural level has been explored by Allen and Garlan <ref> [2, 1] </ref>. In their architectural description language Wright [21], each component has one or more ports that represent points of interaction with other components. Rather than interacting directly, however, components interact indirectly through special components called connectors. Connectors themselves have special ports called roles.
Reference: [2] <author> R. Allen and D. Garlan. </author> <title> A Formal Basis for Architectural Connection. </title> <journal> ACM Transactions on Software Engineering and Methodology, </journal> <volume> 6(3) </volume> <pages> 213-249, </pages> <month> July </month> <year> 1997. </year>
Reference-contexts: In that work, a description of potential behavior is given by a regular expression in which atomic elements represent calls to the component. The idea of using behavioral equivalence to check the dynamics of a software system at the architectural level has been explored by Allen and Garlan <ref> [2, 1] </ref>. In their architectural description language Wright [21], each component has one or more ports that represent points of interaction with other components. Rather than interacting directly, however, components interact indirectly through special components called connectors. Connectors themselves have special ports called roles.
Reference: [3] <author> J.-P. Ban^atre and D. Le Metayer. </author> <title> The Gamma Model and its Discipline of Programming. </title> <booktitle> Science of Computer Programming, </booktitle> <volume> 15 </volume> <pages> 55-77, </pages> <year> 1990. </year>
Reference-contexts: It is built upon the chemical metaphor first proposed by Ban^atre and Le Metayer to illustrate their Gamma () formalism for parallel programming, in which programs can be seen as multiset transformers <ref> [3, 4] </ref>. The CHAM formalism provides a powerful set of primitives for computational modeling. Indeed, its generality, power, and utility have been clearly demonstrated by its use in formally capturing the semantics of familiar computational models such as CSP [13] and the CCS process calculus [17].
Reference: [4] <author> J.-P. Ban^atre and D. Le Metayer. </author> <title> Programming by Multiset Transformation. </title> <journal> Communications of the ACM, </journal> <volume> 36(1) </volume> <pages> 98-111, </pages> <month> January </month> <year> 1993. </year>
Reference-contexts: It is built upon the chemical metaphor first proposed by Ban^atre and Le Metayer to illustrate their Gamma () formalism for parallel programming, in which programs can be seen as multiset transformers <ref> [3, 4] </ref>. The CHAM formalism provides a powerful set of primitives for computational modeling. Indeed, its generality, power, and utility have been clearly demonstrated by its use in formally capturing the semantics of familiar computational models such as CSP [13] and the CCS process calculus [17].
Reference: [5] <author> G. Berry and G. Boudol. </author> <title> The Chemical Abstract Machine. </title> <journal> Theoretical Computer Science, </journal> <volume> 96 </volume> <pages> 217-248, </pages> <year> 1992. </year>
Reference-contexts: In previous work [8, 14, 15], we developed a specification and analysis method for software architectures based on the CHAM (CHemical Abstract Machine) formalism <ref> [5] </ref>. The CHAM formalism had, until then, been used primarily to describe the semantics of various models of concurrency and the semantics of various concurrent programming languages. We showed how it could be used instead to describe actual software systems. <p> The work described here is a step in that direction. 3 Background The CHAM formalism was developed by Berry and Boudol in the domain of theoretical computer science for the principal purpose of defining a generalized computational framework <ref> [5] </ref>. It is built upon the chemical metaphor first proposed by Ban^atre and Le Metayer to illustrate their Gamma () formalism for parallel programming, in which programs can be seen as multiset transformers [3, 4]. The CHAM formalism provides a powerful set of primitives for computational modeling.
Reference: [6] <author> G. Boudol. </author> <title> Some Chemical Abstract Machines. In A Decade of Concurrency, </title> <booktitle> number 803 in Lecture Notes in Computer Science, </booktitle> <pages> pages 92-123. </pages> <publisher> Springer-Verlag, </publisher> <month> May </month> <year> 1994. </year>
Reference-contexts: The CHAM formalism provides a powerful set of primitives for computational modeling. Indeed, its generality, power, and utility have been clearly demonstrated by its use in formally capturing the semantics of familiar computational models such as CSP [13] and the CCS process calculus [17]. Boudol <ref> [6] </ref> points out that the CHAM formalism has also been demonstrated as a modeling tool for concurrent-language definition and implementation.
Reference: [7] <author> R.H. </author> <title> Campbell and A.N. Habermann. The Specification of Process Synchronization by Path Expressions. </title> <booktitle> In Proceedings of an International Symposium on Operating Systems, number 16 in Lecture Notes in Computer Science, </booktitle> <pages> pages 89-102. </pages> <publisher> Springer-Verlag, </publisher> <month> April </month> <year> 1974. </year>
Reference-contexts: However, since it was aimed at modules and assembly of modules, the dynamics of the system are not considered. The use of sequences of actions associated locally with components to describe permissible interactions was introduced in Path Expressions <ref> [7] </ref>. In that work, a description of potential behavior is given by a regular expression in which atomic elements represent calls to the component.
Reference: [8] <author> D. Compare and P. Inverardi. </author> <title> Modelling Interoperability by CHAM: A Case Study. </title> <booktitle> In Proceedings of the First International Conference on Coordination Models and Languages, number 1061 in Lecture Notes in Computer Science, </booktitle> <pages> pages 428-431. </pages> <publisher> Springer-Verlag, </publisher> <month> April </month> <year> 1996. </year>
Reference-contexts: In particular, components make assumptions about their behavioral interaction with other components, but currently we have only limited ways in which to state those assumptions and to analyze those assumptions for correctness. In previous work <ref> [8, 14, 15] </ref>, we developed a specification and analysis method for software architectures based on the CHAM (CHemical Abstract Machine) formalism [5]. The CHAM formalism had, until then, been used primarily to describe the semantics of various models of concurrency and the semantics of various concurrent programming languages.
Reference: [9] <editor> D. Compare, P. Inverardi, and A.L. Wolf. </editor> <booktitle> Uncovering Architectural Mismatch in Dynamic Behavior. Science of Computer Programming, </booktitle> <year> 1998. </year> <note> To appear. </note>
Reference-contexts: One class of such errors involves mismatches in architectural components [11], where assumptions made by different components are in conflict. We showed how our method could be used to uncover architectural mismatch in component behavior <ref> [9] </ref>. There is, however, a significant shortcoming in the method as it was defined. This shortcoming limits the method's usefulness when one is developing a system by assembling existing architectural components. In particular, the method depends on the specification and analysis of a system's global component interaction behavior. <p> In this paper we give an initial demonstration of the feasibility of our approach by describing its application to a system, the Compressing Proxy, first investigated by Garlan, Kindred, and Wing [12], and later by Compare, Inverardi, and Wolf <ref> [9] </ref>. The system contains incompatibilities between the assumptions and the interaction behaviors of two of its components. Our algorithm successfully reveals the known fact that the error can result in a deadlock.
Reference: [10] <author> S.H. Edwards and B.W. Weide. </author> <booktitle> WISR8: 8th Annual Workshop on Software Reuse Summary and Working Group Reports. SIGSOFT Software Engineering Notes, </booktitle> <volume> 22(5) </volume> <pages> 17-32, </pages> <month> September </month> <year> 1997. </year>
Reference-contexts: resulting in a technique for uncovering architectural mismatch. 2 Within the reuse community, there is an awareness of the need to enhance the behavioral description of components in order to "reason about how the behavior exhibited by a component affects the behavior of a system into which it is integrated" <ref> [10] </ref>. In particular, they are looking for ways to capture the assumptions made by components about the behaviors of other components.
Reference: [11] <author> D. Garlan, R. Allen, and J. Ockerbloom. </author> <title> Architectural Mismatch: Why Reuse is So Hard. </title> <journal> IEEE Software, </journal> <volume> 12(6) </volume> <pages> 17-26, </pages> <month> November </month> <year> 1995. </year>
Reference-contexts: We showed how it could be used instead to describe actual software systems. The method has proven to be useful for uncovering a variety of errors at the architectural level. One class of such errors involves mismatches in architectural components <ref> [11] </ref>, where assumptions made by different components are in conflict. We showed how our method could be used to uncover architectural mismatch in component behavior [9]. There is, however, a significant shortcoming in the method as it was defined.
Reference: [12] <author> D. Garlan, D. Kindred, and J.M. Wing. </author> <title> Interoperability: Sample Problems and Solutions. </title> <type> Technical report, </type> <institution> Carnegie Mellon University, Pittsburgh, Pennsylvania, </institution> <note> In preparation. </note>
Reference-contexts: In effect, we are extending the usual notion of type checking to include the checking of behavioral compatibility. In this paper we give an initial demonstration of the feasibility of our approach by describing its application to a system, the Compressing Proxy, first investigated by Garlan, Kindred, and Wing <ref> [12] </ref>, and later by Compare, Inverardi, and Wolf [9]. The system contains incompatibilities between the assumptions and the interaction behaviors of two of its components. Our algorithm successfully reveals the known fact that the error can result in a deadlock. <p> This is discussed in Section 5, where we introduce the concept of the component CHAM. 4 The Compressing Proxy Problem In this section we present the design of the Compressing Proxy system. Our description is derived from that given by Garlan, Kindred, and Wing <ref> [12] </ref>. To improve the performance of UNIX-based World Wide Web browsers over slow networks, one could create an HTTP (Hyper Text Transfer Protocol) server that compresses and uncompresses data that it sends across the network.
Reference: [13] <author> C.A.R. Hoare. </author> <title> Communicating Sequential Processes. </title> <publisher> Prentice-Hall, </publisher> <address> Englewood Cliffs, New Jersey, </address> <year> 1985. </year>
Reference-contexts: Interaction occurs between two or more components by placing a connector between them and by associating each port in a component with a role in the connector. The semantics of ports and roles in Wright are given using a subset of the language CSP <ref> [13] </ref>. A notion of consistency is introduced via a behavioral equivalence between the CSP agents describing the semantics of corresponding ports and roles. Although roles were introduced explicitly to support connector reuse, the idea is related to our notion of expected behavior. <p> The CHAM formalism provides a powerful set of primitives for computational modeling. Indeed, its generality, power, and utility have been clearly demonstrated by its use in formally capturing the semantics of familiar computational models such as CSP <ref> [13] </ref> and the CCS process calculus [17]. Boudol [6] points out that the CHAM formalism has also been demonstrated as a modeling tool for concurrent-language definition and implementation.
Reference: [14] <author> P. Inverardi and A.L. Wolf. </author> <title> Formal Specification and Analysis of Software Architectures using the Chemical Abstract Machine Model. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 21(4) </volume> <pages> 373-386, </pages> <month> April </month> <year> 1995. </year>
Reference-contexts: In particular, components make assumptions about their behavioral interaction with other components, but currently we have only limited ways in which to state those assumptions and to analyze those assumptions for correctness. In previous work <ref> [8, 14, 15] </ref>, we developed a specification and analysis method for software architectures based on the CHAM (CHemical Abstract Machine) formalism [5]. The CHAM formalism had, until then, been used primarily to describe the semantics of various models of concurrency and the semantics of various concurrent programming languages. <p> Thus, we may not be able to completely control the sequence of transformations; we can only specify when rules are enabled. Finally, if no rules can be applied to a solution, then that solution is said to be inert. In our original formulation for software architectures <ref> [14] </ref> we structured CHAM specifications of a system into three parts: 1. a description of the syntax by which components of the system (i.e., the molecules) can be represented; 2. a solution representing the initial state of the system; and 3 3. a set of reaction rules describing how the components
Reference: [15] <author> P. Inverardi and D. Yankelevich. </author> <title> Relating CHAM Descriptions of Software Architectures. </title> <booktitle> In Proceedings of the 8th International Workshop on Software Specification and Design, </booktitle> <pages> pages 66-74. </pages> <publisher> IEEE Computer Society, </publisher> <month> March </month> <year> 1996. </year>
Reference-contexts: In particular, components make assumptions about their behavioral interaction with other components, but currently we have only limited ways in which to state those assumptions and to analyze those assumptions for correctness. In previous work <ref> [8, 14, 15] </ref>, we developed a specification and analysis method for software architectures based on the CHAM (CHemical Abstract Machine) formalism [5]. The CHAM formalism had, until then, been used primarily to describe the semantics of various models of concurrency and the semantics of various concurrent programming languages.
Reference: [16] <author> D.C. Luckham, J.J. Kenney, L.M. Augustin, J. Vera, D. Bryan, and W. Mann. </author> <title> Specification and Analysis of System Architecture Using Rapide. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 21(4) </volume> <pages> 336-355, </pages> <month> April </month> <year> 1995. </year>
Reference-contexts: Therefore, it is not unexpected that languages used to express concurrency semantics have been borrowed to describe the architectures of software systems. 1 Besides CSP and CHAM, other models being explored include the Pi Calculus [20] and Posets <ref> [16] </ref>. We believe that our approach is independent of the specification language used, but one advantage of the CHAM formalism is that it does not embed within it any particular form of interaction. In most other languages, synchronous or asynchronous broadcast, or point-to-point communication are implicit and unavoidable.
Reference: [17] <author> R. Milner. </author> <title> Communication and Concurrency. </title> <publisher> Prentice-Hall, </publisher> <address> Englewood Cliffs, New Jersey, </address> <year> 1989. </year>
Reference-contexts: The CHAM formalism provides a powerful set of primitives for computational modeling. Indeed, its generality, power, and utility have been clearly demonstrated by its use in formally capturing the semantics of familiar computational models such as CSP [13] and the CCS process calculus <ref> [17] </ref>. Boudol [6] points out that the CHAM formalism has also been demonstrated as a modeling tool for concurrent-language definition and implementation. <p> If a final solution is inert, then the explicit specification of that final state serves to distinguish it from an unintended deadlock state, which is also inert. The specification of final states is common in behavioral models, such as finite state machines. In process algebras like CCS <ref> [17] </ref>, a final state is identified using a special process, denoted as "nil", that does not perform any action. Notice that the preceding discussion of basic concepts is given mainly in terms of a monolithic specification of a whole system. <p> The idea is that all the nodes and arcs of the AS graph must be "covered" by the relation and, moreover, it should not be possible for an actual behavior to avoid providing the required interaction. Therefore, our equivalence is inspired by the familiar Milner bisimulation <ref> [17] </ref>. Why do we need a form of bisimulation? An AS graph should be completely satisfied by one or more AC graphs, which means that everything the AS graph requires must be provided by the context.
Reference: [18] <author> D.E. Perry. </author> <title> The Inscape Environment. </title> <booktitle> In Proceedings of the 11th International Conference on Software Engineering, </booktitle> <pages> pages 2-11. </pages> <publisher> IEEE Computer Society, </publisher> <month> May </month> <year> 1989. </year> <month> 22 </month>
Reference-contexts: In most other languages, synchronous or asynchronous broadcast, or point-to-point communication are implicit and unavoidable. From the perspective of Module Interconnection Languages, informal or semi-formal languages have been used to describe software architectures [22]. In those cases, it is more difficult to prove properties of the systems. Perry <ref> [18] </ref> presents a model in which the semantics of connections are taken into account to check when modules match. The semantic information in the modules, given as predicates, is used to verify some properties.
Reference: [19] <author> D.E. Perry and A.L. Wolf. </author> <title> Foundations for the Study of Software Architecture. </title> <booktitle> SIGSOFT Software Engineering Notes, </booktitle> <volume> 17(4) </volume> <pages> 40-52, </pages> <month> October </month> <year> 1992. </year>
Reference-contexts: Here, we add a fourth part: 4. a set of solutions representing the intended final states of the system. The syntactic description of the components is given by an algebra of molecules or, in other words, a syntax by which molecules can be built. Following Perry and Wolf <ref> [19] </ref>, we distinguish three classes of components: data elements, processing elements, and connecting elements. The processing elements are those components that perform the transformations on the data elements, while the data elements are those that contain the information that is used and transformed.
Reference: [20] <author> M. Radestock and S. Eisenbach. </author> <title> What Do You Get From a Pi-calculus Semantics? In Proceedings of PARLE'94 Parallel Architectures and Languages Europe, </title> <booktitle> number 817 in Lecture Notes in Computer Science, </booktitle> <pages> pages 635-647. </pages> <publisher> Springer-Verlag, </publisher> <year> 1994. </year>
Reference-contexts: Therefore, it is not unexpected that languages used to express concurrency semantics have been borrowed to describe the architectures of software systems. 1 Besides CSP and CHAM, other models being explored include the Pi Calculus <ref> [20] </ref> and Posets [16]. We believe that our approach is independent of the specification language used, but one advantage of the CHAM formalism is that it does not embed within it any particular form of interaction.
Reference: [21] <author> M. Shaw and D. Garlan. </author> <title> Software Architecture: Perspectives on an Emerging Discipline. </title> <publisher> Prentice-Hall, </publisher> <address> Englewood Cliffs, New Jersey, </address> <year> 1996. </year>
Reference-contexts: The idea of using behavioral equivalence to check the dynamics of a software system at the architectural level has been explored by Allen and Garlan [2, 1]. In their architectural description language Wright <ref> [21] </ref>, each component has one or more ports that represent points of interaction with other components. Rather than interacting directly, however, components interact indirectly through special components called connectors. Connectors themselves have special ports called roles.
Reference: [22] <author> A.L. Wolf, L.A. Clarke, and J.C. Wileden. </author> <title> The AdaPIC Tool Set: Supporting Interface Control and Analysis Throughout the Software Development Process. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 15(3) </volume> <pages> 250-263, </pages> <month> March </month> <year> 1989. </year>
Reference-contexts: In most other languages, synchronous or asynchronous broadcast, or point-to-point communication are implicit and unavoidable. From the perspective of Module Interconnection Languages, informal or semi-formal languages have been used to describe software architectures <ref> [22] </ref>. In those cases, it is more difficult to prove properties of the systems. Perry [18] presents a model in which the semantics of connections are taken into account to check when modules match. The semantic information in the modules, given as predicates, is used to verify some properties.
Reference: [23] <author> A.M. Zaremski and J.M. Wing. </author> <title> Specification Matching of Software Components. </title> <journal> ACM Transactions on Software Engineering and Methodology, </journal> <volume> 6(4) </volume> <pages> 333-369, </pages> <month> October </month> <year> 1997. </year> <month> 23 </month>
Reference-contexts: From your perspective, it is therefore insufficient to have only the behavior of your interaction with the host and your interaction with the partner described, but your assumptions about the global party context|that the host will introduce you to the partner|must also be described. Zaremski and Wing <ref> [23] </ref> describe a technique called specification matching that is intended primarily as a means to retrieve software components from a reuse library. They point out that their technique is currently limited in that it is based on simple input-output functional behavior.
References-found: 23

