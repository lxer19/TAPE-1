URL: http://http.cs.berkeley.edu/~sethg/papers/dec-note-18.ps
Refering-URL: http://http.cs.berkeley.edu/~sethg/papers.html
Root-URL: http://www.cs.berkeley.edu
Title: 18  An Abstract Machine to Implement Functions in LIFE  
Author: Seth Copen Goldstein 
Date: December 1992  
Affiliation: PARIS RESEARCH LABORATORY  
Abstract-found: 0
Intro-found: 1
Reference: 1. <author> Hassan At-Kaci and Andreas Podelski. </author> <title> Functions as passive constraints in LIFE. </title> <type> Research Report 13, </type> <institution> Digital Equipment Corporation, </institution> <note> Paris Research Laboratory (June 1991). Revised November 1992. </note>
Reference-contexts: Thus, all sorts are subsumed by &gt; and ? implies every sort. Intersection of sorts is carried out by the greatest lower bound 1 The details of sort implication and in particular how they relate to function invocation in LIFE can be found in <ref> [1] </ref> Technical Note No. 18 December 1992 2 Seth Copen Goldstein features. The capital letters in the nodes correspond to the variables used in the textual representation of the -term. operator, written, ^. -terms can be represented in many ways. <p> most common cases, that of direct entailment or disentailment, with surprising efficiency. 2.2 Examples In order to point out some of the difficulties in implementing functions, let's assume the definitions below and the sort hierarchy in Figure 3. 2 A formal treatment of functions in LIFE can be found in <ref> [1] </ref>. Technical Note No. 18 December 1992 4 Seth Copen Goldstein incr (X:int) ! X+1. incr (X:string) ! "increment". insurance (P:person (spouse ) S:temp)) ! 1. insurance (P:person (spouse ) S:person)) ! 2. isspouse (P:person (spouse ) S), S:person (spouse ) P)) ! true.
Reference: 2. <author> Hassan At-Kaci and Andreas Podelski. </author> <title> Towards a meaning of LIFE. </title> <type> PRL Research Report 11, </type> <institution> Digital Equipment Corporation, Paris Research Laboratory, </institution> <address> Rueil-Malmaison, France (1991). </address>
Reference-contexts: This should facilitate the implementation of both a LIFE-to-LAM compiler and a LAM-to-native-code compiler. While this document is intended to be self-contained, it is assumed that the reader is familiar with at least the informal parts of <ref> [2] </ref>. After presenting the basic properties of -terms we give a brief of description of matching, residuation, and currying in Section 2. Section 3 explains how function definitions are decomposed into constraint trees. <p> It is an extension of first-order terms to include sorts and features. For a coherent and complete discussion of -terms the reader can see <ref> [2] </ref>. Here I will briefly outline the notation.
Reference: 3. <author> Hassan At-Kaci, Andreas Podelski, and Seth Copen Goldstein. </author> <title> Order-sorted feature theory unification. </title> <year> (1992). </year>
Reference-contexts: However, we need to extend the model slightly to handle special cases of equality introduced by the function call. In spite of this shortcoming, LAM has led to valuable insights about LIFE. It has pointed the way towards the correct handling of lazy unification of order-sorted-feature terms <ref> [3] </ref>. In addition, by showing a possible approach to successfully compiling away the overhead of matching and residuation in LIFE, it should be a good starting point to the creation of the actual LIFE compiler.
Reference: 4. <author> Gerard Ellis and Peter Van Roy. </author> <title> Constraints + control = compilation, or how to compile matching and residuation in LIFE. </title> <note> draft (1991). </note>
Reference-contexts: Definitions as Constraint Trees In order to obtain the behavior described above, this note proposes a compilation scheme based on decomposing function definitions into function trees, where each clause of the function is represented by a constraint tree 3 . 3 The idea of using executable constraints was found in <ref> [4] </ref> December 1992 Digital PRL An Abstract Machine to Implement Functions in LIFE 7 Each function is defined by a (possibly unit) series of clauses. Each clause is tried in turn until either all are disentailed or one is entailed. <p> It is similar to the constraint tree in Figure 2. When a failure is detected, then control is transferred to the next clause node in the tree. The advantages in viewing a function definition this way are many. First, the wavefront algorithm <ref> [4, 6, 5] </ref> as implemented in this note treats the constraints on the arguments as if they were arranged in a tree. Second, one can classify the arcs and nodes in such a way as to guide optimizations.
Reference: 5. <author> A. Marien and B. Demoen. </author> <title> A new scheme for unification in wam. </title> <booktitle> In 1991 International Symposium on Logic Programming, </booktitle> <pages> pages 257-271. </pages> <publisher> MIT Press (Oct. </publisher> <year> 1991). </year>
Reference-contexts: It is similar to the constraint tree in Figure 2. When a failure is detected, then control is transferred to the next clause node in the tree. The advantages in viewing a function definition this way are many. First, the wavefront algorithm <ref> [4, 6, 5] </ref> as implemented in this note treats the constraints on the arguments as if they were arranged in a tree. Second, one can classify the arcs and nodes in such a way as to guide optimizations.

References-found: 5

