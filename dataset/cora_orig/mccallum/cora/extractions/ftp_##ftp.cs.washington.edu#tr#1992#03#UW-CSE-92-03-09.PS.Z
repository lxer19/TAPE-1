URL: ftp://ftp.cs.washington.edu/tr/1992/03/UW-CSE-92-03-09.PS.Z
Refering-URL: http://www.cs.washington.edu/homes/levy/opal/opalpapers.html
Root-URL: 
Title: Lightweight Shared Objects in a 64-Bit Operating System a runtime library, above a single virtual
Author: Jeffrey S. Chase, Henry M. Levy, Edward D. Lazowska, and Miche Baker-Harvey 
Note: sharing is supported in  
Date: March 1992 Revised June 1992  
Address: Seattle, WA 98195  
Affiliation: Department of Computer Science and Engineering, FR-35 University of Washington  
Pubnum: Technical Report 92-03-09  
Abstract: Object-oriented models are a popular basis for supporting uniform sharing of data and services in operating systems, distributed programming systems, and database systems. We term systems that use objects for these purposes object sharing systems. Operating systems in common use have nonuniform addressing models, making the uniform object naming required by object sharing systems expensive and difficult to implement. We argue that emerging 64-bit architectures make it practical to support uniform naming at the virtual addressing level, eliminating a key implementation problem for object sharing systems. We describe facilities for object-based sharing of persistent data and services in Opal, an operating system we are developing for paged 64-bit architectures. The distinctive feature of Opal is that object This paper will appear in identical form in the proceedings of the Conference on Object-Oriented Programming Systems, Languages, and Applications (OOPSLA), October 1992. This work was supported in part by the National Science Foundation under Grants No. CCR-8619663, CCR-8907666, CCR-9200832, and CDA-9123308; by the Wash-ington Technology Center; by the Boeing Corporation; and by Digital Equipment Corporation through the Systems Research Center, DECwest Engineering, the External Research Program, and the Graduate Engineering Education Program. 
Abstract-found: 1
Intro-found: 1
Reference: [Abrossimov et al. 90] <author> V. Abrossimov, S. Habert, and L. Mosseri. </author> <title> COOL: Kernel support for object-oriented environments. </title> <booktitle> In Proceedings of the ACM Conference on Object-Oriented Programming Systems, Languages, and Applications, </booktitle> <month> October </month> <year> 1990. </year>
Reference-contexts: A thread's default heap can be changed with a call to the runtime system. Our use of data segments as heaps for allocating objects makes them similar to clusters in Oisin [Cahill 88]. In contrast, the original COOL 7 system <ref> [Abrossimov et al. 90] </ref> viewed objects as composed of one or more segments; the COOL designers have pointed out that COOL objects are too expensive to represent most language objects.
Reference: [Allchin & McKendry 83] <author> J. Allchin and M. McK-endry. </author> <title> Synchronization and recovery of actions. </title> <booktitle> In Proceedings of the 2nd ACM Symposium on Principles of Distributed Computing, </booktitle> <pages> pages 31-44, </pages> <month> August </month> <year> 1983. </year>
Reference-contexts: For example, in early object-oriented operating systems, notably Clouds <ref> [Allchin & McKendry 83] </ref> and Eden [Almes et al. 85], service objects are coarse-grained, meaning that they are one-to-one with protection domains. More recently, Mach has supported protected objects directly in the kernel through its port abstraction.
Reference: [Almes et al. 85] <author> G. T. Almes, A. P. Black, E. D. Lazowska, and J. D. Noe. </author> <title> The Eden system: A technical review. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> SE-11(1):43-59, </volume> <month> January </month> <year> 1985. </year>
Reference-contexts: For example, in early object-oriented operating systems, notably Clouds [Allchin & McKendry 83] and Eden <ref> [Almes et al. 85] </ref>, service objects are coarse-grained, meaning that they are one-to-one with protection domains. More recently, Mach has supported protected objects directly in the kernel through its port abstraction.
Reference: [Anderson et al. 91] <author> T. E. Anderson, B. N. Ber-shad, E. D. Lazowska, and H. M. Levy. </author> <title> Scheduler activations: Effective kernel support of the user-level management of parallelism. </title> <booktitle> In Proceedings of the 13th Symposium on Operating System Principles, </booktitle> <pages> pages 95-109, </pages> <month> October </month> <year> 1991. </year>
Reference-contexts: Threads are multiplexed on processors, and different threads may execute in parallel on different processors. A thread can be suspended (e.g., for blocking synchronization 3 or timeslicing) and resumed later, possibly on another processor. Threads are implemented in a runtime library using techniques described in <ref> [Anderson et al. 91] </ref>. * Data Storage. All data (including executable code) is stored in virtual segments, sequences of virtual pages occupying a contiguous range of virtual address space (Figure 1).
Reference: [Appel et al. 88] <author> A. W. Appel, J. R. Ellis, and K. Li. </author> <title> Real-time concurrent garbage collection on stock multiprocessors. </title> <booktitle> SIG-PLAN Notices (Proceedings of the SIG-PLAN '88 Conference on Programming Language Design and Implementation), </booktitle> <volume> 23(7), </volume> <month> July </month> <year> 1988. </year>
Reference-contexts: Alternatively, virtual page protections can be used to trap references to old copies of objects that have moved <ref> [Appel et al. 88] </ref>. 4.3 Summary In this section we have described support for shared and persistent data objects in Opal.
Reference: [Bal & Tanenbaum 88] <author> H. E. Bal and A. S. Tanen-baum. </author> <title> Distributed programming with shared data. </title> <booktitle> In Proceedings of the International Conference on Computer Languages, </booktitle> <pages> pages 82-91, </pages> <month> October </month> <year> 1988. </year>
Reference-contexts: These object properties make object-oriented languages an attractive basis for language 1 integrated and type-checked access to shared and persistent data and services. These ideas have been used in object-oriented database systems, persistent object stores, and distributed programming systems <ref> [Jul et al. 88, Bal & Tanenbaum 88] </ref>. Most microkernel operating systems (e.g., Mach [Young et al. 87], Amoeba [Mullender & Tanenbaum 86], and Chorus [Rozier et al. 88]) represent protected system services as objects named by capabilities that can be passed between applications.
Reference: [Bershad 90] <author> B. N. Bershad. </author> <title> High Performance Cross-Address Space Communication. </title> <type> PhD dissertation, </type> <institution> University of Washington, </institution> <month> June </month> <year> 1990. </year> <institution> Department of Computer Science and Engineering Technical Report 90-06-02. </institution>
Reference-contexts: If the client and server are colocated, arguments and results can be passed through a small segment called a channel that is shared by the client and the server (this technique for lightweight RPC is described in <ref> [Bershad 90] </ref>). 2.2 Segments and Addressing In most operating systems, including segmented systems such as Multics [Daley & Dennis 68], each protection domain has a private virtual address space; a segment may be mapped to a different virtual address range by each domain that attaches it.
Reference: [Cahill 88] <author> V. Cahill. OISIN, </author> <title> the design of a distributed object-oriented kernel for CO-MANDOS. </title> <type> Master's thesis, </type> <institution> Department of Computer Science, Trinity College Dublin, </institution> <year> 1988. </year>
Reference-contexts: A thread's default heap can be changed with a call to the runtime system. Our use of data segments as heaps for allocating objects makes them similar to clusters in Oisin <ref> [Cahill 88] </ref>. In contrast, the original COOL 7 system [Abrossimov et al. 90] viewed objects as composed of one or more segments; the COOL designers have pointed out that COOL objects are too expensive to represent most language objects.
Reference: [Carter et al. 91] <author> J. B. Carter, J. K. Bennett, and W. Zwaenepoel. </author> <title> Implementation and performance of Munin. </title> <booktitle> In Proceedings of the Thirteenth Symposium on Operating Systems Principles, </booktitle> <pages> pages 152-164. </pages> <publisher> ACM, </publisher> <month> October </month> <year> 1991. </year> <month> 15 </month>
Reference-contexts: There are pure page-based solutions (e.g., Ivy [Li 86] and Camelot [Eppinger 89]), pure object-based solutions (e.g., Amber [Chase et al. 89, Feeley & Levy 92] and Argus [Liskov et al. 87]), and interesting hybrid solutions (e.g., Munin <ref> [Carter et al. 91] </ref> and Avalon [Detlefs et al. 88]). Our initial prototype uses primitive mechanisms, but any of these approaches could be used to ensure consistency and/or recoverability of an Opal segment.
Reference: [Chase et al. 89] <author> J. S. Chase, F. G. Amador, E. D. Lazowska, H. M. Levy, and R. J. Little-field. </author> <title> The Amber system: Parallel programming on a network of multiprocessors. </title> <booktitle> In Proceedings of the 12th ACM Symposium on Operating System Principles, </booktitle> <pages> pages 147-158, </pages> <month> December </month> <year> 1989. </year>
Reference-contexts: These are untested hypotheses. * Consistency of distributed and persistent segments. Several approaches to the problems of consistency and recoverability (transaction support) have been developed. There are pure page-based solutions (e.g., Ivy [Li 86] and Camelot [Eppinger 89]), pure object-based solutions (e.g., Amber <ref> [Chase et al. 89, Feeley & Levy 92] </ref> and Argus [Liskov et al. 87]), and interesting hybrid solutions (e.g., Munin [Carter et al. 91] and Avalon [Detlefs et al. 88]).
Reference: [Chase et al. 92a] <author> J. S. Chase, H. M. Levy, M. Baker-Harvey, and E. D. Lazowska. </author> <title> How to use a 64-bit virtual address space. </title> <type> Technical Report 92-03-02, </type> <institution> University of Washington, Department of Computer Science and Engineering, </institution> <month> February </month> <year> 1992. </year>
Reference-contexts: A full 64-bit address space can map 16 billion gigabytes of data; if consumed at the rate of 100 megabytes per second this address space would last for nearly 5000 years. We are building a new operating system called Opal <ref> [Chase et al. 92a, Chase et al. 92b] </ref> that exploits the wider virtual addresses of these emerging architectures by defining a single virtual address space that includes data on long-term storage and 2 across a local area network. <p> Hardware-based mem-ory protection exists within this uniform address space; programs execute in protection domains that restrict their access to global virtual storage. Our goal in this paper is not to explain or justify this system (we refer you to <ref> [Chase et al. 92a] </ref> for a discussion of the system and its relationship to previous work). Nor is our purpose to argue for 64-bit hardware; we assume that wide-address hardware will become widely available.
Reference: [Chase et al. 92b] <author> J. S. Chase, H. M. Levy, M. Baker-Harvey, and E. D. Lazowska. Opal: </author> <title> A single address space system for 64-bit architectures. </title> <booktitle> In Proceedings of the Third Workshop on Workstation Operating Systems, </booktitle> <month> April </month> <year> 1992. </year>
Reference-contexts: A full 64-bit address space can map 16 billion gigabytes of data; if consumed at the rate of 100 megabytes per second this address space would last for nearly 5000 years. We are building a new operating system called Opal <ref> [Chase et al. 92a, Chase et al. 92b] </ref> that exploits the wider virtual addresses of these emerging architectures by defining a single virtual address space that includes data on long-term storage and 2 across a local area network.
Reference: [Copeland et al. 90] <author> G. Copeland, M. Franklin, and G. Weikum. </author> <title> Uniform object management. </title> <editor> In F. Bancilon, C. Thanos, and D. Tsichritzis, editors, </editor> <booktitle> Advances in Database Technology International Conference on Extending Database Technology 1990 (Lecture Notes in Computer Science 416), </booktitle> <pages> pages 253-268. </pages> <publisher> Springer-Verlag, </publisher> <year> 1990. </year>
Reference-contexts: Virtual address pointers are simpler and more efficient, and they can be used directly as object references given wide-address hardware and proper operating system support for a uniform virtual address space. <ref> [Copeland et al. 90] </ref> outlines a similar proposal, and presents a case for the use of virtual addresses as persistent object references. One disadvantage of virtual address pointers is that moving an object to a different part of the address space invalidates all references to it.
Reference: [Daley & Dennis 68] <author> R. C. Daley and J. B. Dennis. </author> <title> Virtual memory, processes, and sharing in MULTICS. </title> <journal> Communications of the ACM, </journal> <volume> 11(5) </volume> <pages> 306-312, </pages> <month> May </month> <year> 1968. </year>
Reference-contexts: and server are colocated, arguments and results can be passed through a small segment called a channel that is shared by the client and the server (this technique for lightweight RPC is described in [Bershad 90]). 2.2 Segments and Addressing In most operating systems, including segmented systems such as Multics <ref> [Daley & Dennis 68] </ref>, each protection domain has a private virtual address space; a segment may be mapped to a different virtual address range by each domain that attaches it. In contrast, Opal has a single virtual address space shared by all protection domains.
Reference: [Detlefs et al. 88] <author> D. L. Detlefs, M. P. Herlihy, and J. M. Wing. </author> <title> Inheritance of synchronization and recovery properties in Avalon/C++. </title> <journal> IEEE Computer, </journal> <volume> 21(12) </volume> <pages> 57-69, </pages> <month> December </month> <year> 1988. </year>
Reference-contexts: There are pure page-based solutions (e.g., Ivy [Li 86] and Camelot [Eppinger 89]), pure object-based solutions (e.g., Amber [Chase et al. 89, Feeley & Levy 92] and Argus [Liskov et al. 87]), and interesting hybrid solutions (e.g., Munin [Carter et al. 91] and Avalon <ref> [Detlefs et al. 88] </ref>). Our initial prototype uses primitive mechanisms, but any of these approaches could be used to ensure consistency and/or recoverability of an Opal segment. These are existing problems that we have failed to resolve rather than new problems that we have introduced.
Reference: [Dig 92] <institution> Digital Equipment Corporation, May-nard, MA. Alpha Architecture Handbook, </institution> <year> 1992. </year>
Reference-contexts: The DEC Alpha <ref> [Dig 92] </ref> and the MIPS R4000 [MIP 91] are recent examples of wide-address architectures. Wide-address architectures remove the basic restrictions underlying the problem of nonuniform naming in computer systems.
Reference: [Eppinger 89] <author> J. L. Eppinger. </author> <title> Virtual Memory Management for Transaction Processing Systems. </title> <type> PhD dissertation, </type> <institution> Carnegie Mellon University, </institution> <month> February </month> <year> 1989. </year> <month> CMU-CS-89-115. </month>
Reference-contexts: These are untested hypotheses. * Consistency of distributed and persistent segments. Several approaches to the problems of consistency and recoverability (transaction support) have been developed. There are pure page-based solutions (e.g., Ivy [Li 86] and Camelot <ref> [Eppinger 89] </ref>), pure object-based solutions (e.g., Amber [Chase et al. 89, Feeley & Levy 92] and Argus [Liskov et al. 87]), and interesting hybrid solutions (e.g., Munin [Carter et al. 91] and Avalon [Detlefs et al. 88]).
Reference: [Fabry 74] <author> R. S. Fabry. </author> <title> Capability-Based Addressing. </title> <journal> Communications of the ACM, </journal> <volume> 17(7) </volume> <pages> 403-412, </pages> <month> July </month> <year> 1974. </year>
Reference-contexts: In system environments, where unsafe programming languages may be used, encapsulation is enforced by two means: (1) the object is separated from the client by a hardware-enforced memory protection boundary, and (2) the system or the hardware supports special object references called capabilities <ref> [Fabry 74] </ref> that cannot be forged; the client must hold a capability for the object in order to invoke it with a cross-domain (RPC) call. An object that is encapsulated in this way is called a protected object or a service object.
Reference: [Faust & Levy 90] <author> J. E. Faust and H. M. Levy. </author> <title> The performance of an object-oriented threads package. </title> <booktitle> In Proceedings of the ACM Conference on Object-Oriented Programming Systems, Languages, and Applications, </booktitle> <month> October </month> <year> 1990. </year>
Reference-contexts: This concurrency is inherent in our passive object model. We assume that all type implementations are reentrant and thread-safe. Synchronization is managed with explicit locking primitives. Threads and synchronization are implemented in a concurrency library similar to <ref> [Faust & Levy 90] </ref>, providing mutexes, condition variables, and spinlock types. Threads and locks are objects allocated from data segment heaps. Lock objects contain flag words that are set and cleared with atomic instructions (e.g., test-and-set). Thread objects include a runtime stack, control information, and register state.
Reference: [Feeley & Levy 92] <author> M. J. Feeley and H. M. Levy. </author> <title> Distributed shared memory with ver-sioned objects. </title> <booktitle> In Proceedings of the Conference on Object-Oriented Programming Systems, Languages, and Applications, </booktitle> <month> October </month> <year> 1992. </year> <note> University of Wash-ington CSE Technical Report 92-03-01. </note>
Reference-contexts: These are untested hypotheses. * Consistency of distributed and persistent segments. Several approaches to the problems of consistency and recoverability (transaction support) have been developed. There are pure page-based solutions (e.g., Ivy [Li 86] and Camelot [Eppinger 89]), pure object-based solutions (e.g., Amber <ref> [Chase et al. 89, Feeley & Levy 92] </ref> and Argus [Liskov et al. 87]), and interesting hybrid solutions (e.g., Munin [Carter et al. 91] and Avalon [Detlefs et al. 88]).
Reference: [Jul et al. 88] <author> E. Jul, H. Levy, N. Hutchinson, and A. Black. </author> <title> Fine-grained mobility in the Emerald system. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 6(1) </volume> <pages> 109-133, </pages> <month> Febru-ary </month> <year> 1988. </year>
Reference-contexts: These object properties make object-oriented languages an attractive basis for language 1 integrated and type-checked access to shared and persistent data and services. These ideas have been used in object-oriented database systems, persistent object stores, and distributed programming systems <ref> [Jul et al. 88, Bal & Tanenbaum 88] </ref>. Most microkernel operating systems (e.g., Mach [Young et al. 87], Amoeba [Mullender & Tanenbaum 86], and Chorus [Rozier et al. 88]) represent protected system services as objects named by capabilities that can be passed between applications.
Reference: [Khoshafian & Copeland 86] <author> S. N. Khoshafian and G. Copeland. </author> <title> Object identity. </title> <booktitle> In Proceedings of the Conference on Object-Oriented Programming Systems, Languages, and Applications, </booktitle> <pages> pages 406-416, </pages> <year> 1986. </year>
Reference-contexts: This property of object identity <ref> [Khoshafian & Copeland 86] </ref> allows object names (pointers or capabilities) to retain their meaning when they are stored in databases and passed between applications.
Reference: [Levy 84] <author> H. M. Levy. </author> <title> Capability-Based Computer Systems. </title> <publisher> Digital Press, </publisher> <address> Bedford, Mas-sachusetts, </address> <year> 1984. </year>
Reference-contexts: That is, protected services have no inherent privilege; in particular they do not run as "superuser". This use of object-orientation was originally emphasized in Hydra [Wulf 75] and capability-based computer architectures (surveyed in <ref> [Levy 84] </ref>). 5.1 Protected Pointers An Opal service object is simply a language object that is internal to a server protection domain.
Reference: [Li 86] <author> K. Li. </author> <title> Shared Virtual Memory on Loosely Coupled Multiprocessors. </title> <type> PhD dissertation, </type> <institution> Yale University, </institution> <month> September </month> <year> 1986. </year> <month> YALEU/DCS/RR-492. </month>
Reference-contexts: These are untested hypotheses. * Consistency of distributed and persistent segments. Several approaches to the problems of consistency and recoverability (transaction support) have been developed. There are pure page-based solutions (e.g., Ivy <ref> [Li 86] </ref> and Camelot [Eppinger 89]), pure object-based solutions (e.g., Amber [Chase et al. 89, Feeley & Levy 92] and Argus [Liskov et al. 87]), and interesting hybrid solutions (e.g., Munin [Carter et al. 91] and Avalon [Detlefs et al. 88]).
Reference: [Liskov et al. 87] <author> B. Liskov, D. Curtis, P. Johnson, and R. Scheifler. </author> <title> Implementation of Argus. </title> <booktitle> In Proceedings of the Eleventh ACM Symposium on Operating Systems Principles, </booktitle> <pages> pages 111-122, </pages> <month> November </month> <year> 1987. </year>
Reference-contexts: Several approaches to the problems of consistency and recoverability (transaction support) have been developed. There are pure page-based solutions (e.g., Ivy [Li 86] and Camelot [Eppinger 89]), pure object-based solutions (e.g., Amber [Chase et al. 89, Feeley & Levy 92] and Argus <ref> [Liskov et al. 87] </ref>), and interesting hybrid solutions (e.g., Munin [Carter et al. 91] and Avalon [Detlefs et al. 88]). Our initial prototype uses primitive mechanisms, but any of these approaches could be used to ensure consistency and/or recoverability of an Opal segment.
Reference: [Marques & Guedes 89] <author> J. A. Marques and P. Guedes. </author> <title> Extending the operating system to support an object-oriented environment. </title> <booktitle> In Proceedings of the ACM Conference on Object-Oriented Programming Systems, Languages, and Applications, </booktitle> <pages> pages 113-122, </pages> <month> September </month> <year> 1989. </year> <month> 16 </month>
Reference-contexts: These different uses of objects have been combined in operating systems that define all interactions between system components in terms of objects <ref> [Marques & Guedes 89, Shapiro et al. 89] </ref>. The common theme in all of these efforts is the use of object models to define and support sharing of data and services between applications.
Reference: [MIP 91] <institution> MIPS Computer Systems, Inc., Sunny--vale, CA. </institution> <note> MIPS R4000 Microprocessor User's Manual, first edition, </note> <year> 1991. </year>
Reference-contexts: The DEC Alpha [Dig 92] and the MIPS R4000 <ref> [MIP 91] </ref> are recent examples of wide-address architectures. Wide-address architectures remove the basic restrictions underlying the problem of nonuniform naming in computer systems.
Reference: [Moss 90] <author> J. E. B. Moss. </author> <title> Working with persistent objects: To swizzle or not to swizzle. </title> <type> COINS Object-Oriented Systems Laboratory Technical Report 90-38, </type> <institution> University of Massachusetts at Amherst, </institution> <month> May </month> <year> 1990. </year>
Reference-contexts: Also, software must use mapping tables to translate surrogates into virtual addresses before dereferencing them. This translation is expensive, even in systems that carefully localize and cache the mapping tables <ref> [Moss 90] </ref>. Swizzling is a technique to amortize this cost over multiple dereferences of the same pointer, by overwriting the surrogate in place with the virtual address after the first translation.
Reference: [Mullender & Tanenbaum 86] <author> S. Mullender and A. Tanenbaum. </author> <title> The design of a capability-based operating system. </title> <journal> The Computer Journal, </journal> <volume> 29(4) </volume> <pages> 289-299, </pages> <year> 1986. </year>
Reference-contexts: These ideas have been used in object-oriented database systems, persistent object stores, and distributed programming systems [Jul et al. 88, Bal & Tanenbaum 88]. Most microkernel operating systems (e.g., Mach [Young et al. 87], Amoeba <ref> [Mullender & Tanenbaum 86] </ref>, and Chorus [Rozier et al. 88]) represent protected system services as objects named by capabilities that can be passed between applications.
Reference: [Rozier et al. 88] <author> M. Rozier, V. Abrossimov, F. Ar-mand, I. Boule, M. Gien, M. Guillemont, F. Herrmann, P. Leonard, S. Langlois, and W. Neuhauser. </author> <title> Chorus distributed operating systems. </title> <journal> Computing Systems, </journal> <volume> 1(4), </volume> <year> 1988. </year>
Reference-contexts: These ideas have been used in object-oriented database systems, persistent object stores, and distributed programming systems [Jul et al. 88, Bal & Tanenbaum 88]. Most microkernel operating systems (e.g., Mach [Young et al. 87], Amoeba [Mullender & Tanenbaum 86], and Chorus <ref> [Rozier et al. 88] </ref>) represent protected system services as objects named by capabilities that can be passed between applications. These different uses of objects have been combined in operating systems that define all interactions between system components in terms of objects [Marques & Guedes 89, Shapiro et al. 89].
Reference: [Shapiro 86] <author> M. Shapiro. </author> <title> Structure and encapsulation in distributed systems: The proxy principle. </title> <booktitle> In Proceedings of the Sixth International Conference on Distributed Computing Systems, </booktitle> <month> May </month> <year> 1986. </year>
Reference-contexts: Thus data objects are cheap and service objects are protected. The details of accessing a service can be hidden from the application with language and runtime support for proxy objects <ref> [Shapiro 86] </ref>.
Reference: [Shapiro et al. 89] <author> M. Shapiro, P. Gautron, and L. Mosseri. </author> <title> Persistence and migration for C++ objects. </title> <booktitle> In Proceedings of the Third European Conference on Object-Oriented Programming, </booktitle> <month> July </month> <year> 1989. </year>
Reference-contexts: These different uses of objects have been combined in operating systems that define all interactions between system components in terms of objects <ref> [Marques & Guedes 89, Shapiro et al. 89] </ref>. The common theme in all of these efforts is the use of object models to define and support sharing of data and services between applications. <p> This should be viewed as a "hypothetical" object sharing system; the restrictions are merely to simplify our exposition and prototyp-ing effort. The premise is that a more comfortable language model would not significantly affect the underlying system issues. 6 3.1 Objects and Types Our terminology and object representations follow <ref> [Shapiro et al. 89] </ref>. In this paper we use the term object to mean an elementary object that contains no internal linked data structures. This is a definition rather than a restriction.
Reference: [Wilson 91] <author> P. R. Wilson. </author> <title> Pointer swizzling at page fault time: Efficiently supporting huge address spaces on standard hardware. </title> <journal> ACM SIGARCH Computer Architecture News, </journal> <volume> 19(4), </volume> <month> June </month> <year> 1991. </year> <institution> University of Illinois at Chicago Technical Report UIC-EECS-90-6, </institution> <month> December </month> <year> 1990. </year>
Reference-contexts: Furthermore, systems that use swizzling must choose between "eager" and "lazy" variants, each of which has additional disadvantages. Eager swiz-zling (e.g., <ref> [Wilson 91] </ref>) translates all pointers as data is read into memory; it further increases the overhead of translation because it unnecessarily translates pointers that are never used by the application. Faster processors cannot reduce this cost proportionately, because eager swizzling is memory-intensive rather than CPU-intensive.
Reference: [Wulf 75] <author> W. A. Wulf. </author> <title> Overview of the Hydra operating system. </title> <booktitle> In Proceedings of the 5th Symposium on Operating Systems Principles, </booktitle> <pages> pages 122-131, </pages> <month> November </month> <year> 1975. </year>
Reference-contexts: That is, protected services have no inherent privilege; in particular they do not run as "superuser". This use of object-orientation was originally emphasized in Hydra <ref> [Wulf 75] </ref> and capability-based computer architectures (surveyed in [Levy 84]). 5.1 Protected Pointers An Opal service object is simply a language object that is internal to a server protection domain.
Reference: [Young et al. 87] <author> M. Young, A. Tevanian, R. Rashid, D. Golub, J. Ep-pinger, J. Chew, W. Bolosky, D. Black, and R. Baron. </author> <title> The duality of memory and communication in the implementation of a multiprocessor operating system. </title> <booktitle> In Proceedings of the Eleventh ACM Symposium on Operating Systems Principles, </booktitle> <pages> pages 63-76, </pages> <month> November </month> <year> 1987. </year> <month> 17 </month>
Reference-contexts: These ideas have been used in object-oriented database systems, persistent object stores, and distributed programming systems [Jul et al. 88, Bal & Tanenbaum 88]. Most microkernel operating systems (e.g., Mach <ref> [Young et al. 87] </ref>, Amoeba [Mullender & Tanenbaum 86], and Chorus [Rozier et al. 88]) represent protected system services as objects named by capabilities that can be passed between applications.
References-found: 35

