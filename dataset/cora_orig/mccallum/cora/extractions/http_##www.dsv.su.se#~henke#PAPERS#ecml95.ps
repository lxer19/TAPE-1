URL: http://www.dsv.su.se/~henke/PAPERS/ecml95.ps
Refering-URL: http://www.dsv.su.se/~henke/Welcome.html
Root-URL: 
Email: henke@dsv.su.se  
Phone: Electrum 230, 164 40  fax: +46 8 703 90 25 tel: +46 8 16 16 16  
Title: Specialization of Recursive Predicates  
Author: Henrik Bostrom 
Address: Stockholm Univer sity  Sweden  
Affiliation: Dept. of Computer and Systems Sciences  Kista,  
Abstract: When specializing a recursive predicate in order to exclude a set of negative examples without excluding a set of positive examples, it may not be possible to specialize or remove any of the clauses in a refutation of a negative example without excluding any positive exam ples. A previously proposed solution to this problem is to apply program transformation in order to obtain non-recursive target predicates from recursive ones. However, the application of this method prevents recursive specializations from being found. In this work, we present the algorithm spectre ii which is not limited to specializing non-recursive predicates. The key idea upon which the algorithm is based is that it is not enough to specialize or remove clauses in refutations of negative examples in order to obtain correct specializations, but it is sometimes necessary to specialize clauses that appear only in refutations of positive examples. In contrast to its predecessor spectre, the new algorithm is not limited to specializing clauses defining one predicate only, but may specialize clauses defining multiple predicates. Furthermore, the positive and negative examples are no longer required to be instances of the same predicate. It is proven that the algorithm produces a correct specialization when all positive examples are logical consequences of the original program, there is a finite number of derivations of positive and negative examples and when no positive and negative examples have the same sequence of input clauses in their refutations.
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> Bain M. and Muggleton S., </author> <title> "Non-Monotonic Learning", </title> <editor> in Muggleton S. (ed.), </editor> <booktitle> Inductive Logic Programming, </booktitle> <publisher> Academic Press, </publisher> <address> London (1992) 145-161 </address>
Reference-contexts: Accuracy of the resulting specializations on the test examples. 6 Related Work In this section, we discuss other specialization techniques, and in particular how they work when specializing recursive predicates. In contrast to spectre ii, the techniques in <ref> [7, 1] </ref> attempt to minimally specialize logic programs. However, as pointed out in [16], the specializations produced by these techniques are not always minimal. That is the case when the specialized predicate appears in bodies of clauses, and this is true in particular when specializing a recursive predicate. <p> That is the case when the specialized predicate appears in bodies of clauses, and this is true in particular when specializing a recursive predicate. For example, given the following program and the negative example p (a,a): p (X,X). Then the specialization produced by the technique in <ref> [1] </ref> will be: p (X,X):- not (p1 (X)). p1 (a). Note that not only is the negative example excluded, but also p (f (a),g (a)), p (f (f (a)),g (g (a))), : : :, and thus the resulting specialization is certainly not minimal.
Reference: 2. <author> Bergadano F. and Giordana A., </author> <title> "A Knowledge Intensive Approach to Concept Induction", </title> <booktitle> Proceedings of the Fifth International Conference on Machine Learning, </booktitle> <publisher> Morgan Kaufmann, </publisher> <address> CA (1988) 305-317 </address>
Reference-contexts: In the field of inductive logic programming, the top-down search for an inductive hypothesis has been performed by using various specialization techniques, such as clause removal, addition of literals and goal reduction <ref> [13, 2, 9, 12, 11, 4, 15, 5, 10, 16, 3] </ref>. In this work, it is assumed that the overly general hypothesis is given as a logic program. In [3], the algorithm spectre is presented, which specializes logic programs by applying the transformation rule unfolding [14] together with clause removal. <p> However, the condition for when correct specializations can be obtained by clause removal can be relaxed significantly, if combined with program transformation, as shown by spectre ii. In <ref> [13, 2, 12, 11, 10] </ref>, clauses are specialized by adding literals to their bodies. The literals considered for being added are in these approaches restricted to those whose predicate symbols are defined in the original program. <p> But the resulting specialization will not be correct if there are any positive examples, since these are excluded as well. A number of previous specialization techniques use goal reduction to specialize clauses (ml-smart <ref> [2] </ref>, ana-ebl [4], focl [11], grendel [5], focl-frontier [10]). One major difference between spectre ii and these techniques is the way in which the search for a specialization is performed.
Reference: 3. <author> Bostrom H. and Idestam-Almquist P., </author> <title> "Specialization of Logic Programs by Pruning SLD-Trees", </title> <booktitle> Proceedings of the 4th International Workshop on Inductive Logic Programming, volume 237 of GMD-Studien, </booktitle> <institution> Gesellschaft fur Mathematik und Datenverarbeitung MBH (1994) 31-48 </institution>
Reference-contexts: In the field of inductive logic programming, the top-down search for an inductive hypothesis has been performed by using various specialization techniques, such as clause removal, addition of literals and goal reduction <ref> [13, 2, 9, 12, 11, 4, 15, 5, 10, 16, 3] </ref>. In this work, it is assumed that the overly general hypothesis is given as a logic program. In [3], the algorithm spectre is presented, which specializes logic programs by applying the transformation rule unfolding [14] together with clause removal. <p> In this work, it is assumed that the overly general hypothesis is given as a logic program. In <ref> [3] </ref>, the algorithm spectre is presented, which specializes logic programs by applying the transformation rule unfolding [14] together with clause removal. One limitation of the algorithm is that it assumes the target predicate to be non-recursive. <p> It should be noted that this is a general problem that is not limited to a particular type of specialization operator, but applies to all specialization techniques that exclude negative examples by specializing or removing clauses in their refutations. A solution to this problem that has been proposed in <ref> [3] </ref> is to apply the transformation rules definition, unfolding and folding [14] in order to obtain non-recursive target predicates from recursive ones. The draw-back of applying this transformation technique is that recursive specializations can not be obtained, which means that many desired specializations can not be found. <p> A i or A i+m+1 ; : : : ; A n , then replace C by the clause A A 1 ; : : : ; A i ; B; A i+m+1 ; : : : ; A n . 3 Applying SPECTRE to Recursive Predicates The algorithm spectre <ref> [3] </ref> specializes logic programs with respect to positive and negative examples by applying unfolding together with clause removal. This is done in the following way.
Reference: 4. <author> Cohen W. W., </author> <title> "The Generality of Overgenerality", </title> <booktitle> Machine Learning: Proceedings of the Eighth International Workshop, </booktitle> <publisher> Morgan Kaufmann (1991) 490-494 </publisher>
Reference-contexts: In the field of inductive logic programming, the top-down search for an inductive hypothesis has been performed by using various specialization techniques, such as clause removal, addition of literals and goal reduction <ref> [13, 2, 9, 12, 11, 4, 15, 5, 10, 16, 3] </ref>. In this work, it is assumed that the overly general hypothesis is given as a logic program. In [3], the algorithm spectre is presented, which specializes logic programs by applying the transformation rule unfolding [14] together with clause removal. <p> But the resulting specialization will not be correct if there are any positive examples, since these are excluded as well. A number of previous specialization techniques use goal reduction to specialize clauses (ml-smart [2], ana-ebl <ref> [4] </ref>, focl [11], grendel [5], focl-frontier [10]). One major difference between spectre ii and these techniques is the way in which the search for a specialization is performed.
Reference: 5. <author> Cohen W. W., </author> <title> "Compiling Prior Knowledge Into an Explicit Bias", </title> <booktitle> Machine Learning: Proceedings of the Ninth International Workshop, </booktitle> <publisher> Morgan Kaufmann (1992) 102-110 </publisher>
Reference-contexts: In the field of inductive logic programming, the top-down search for an inductive hypothesis has been performed by using various specialization techniques, such as clause removal, addition of literals and goal reduction <ref> [13, 2, 9, 12, 11, 4, 15, 5, 10, 16, 3] </ref>. In this work, it is assumed that the overly general hypothesis is given as a logic program. In [3], the algorithm spectre is presented, which specializes logic programs by applying the transformation rule unfolding [14] together with clause removal. <p> But the resulting specialization will not be correct if there are any positive examples, since these are excluded as well. A number of previous specialization techniques use goal reduction to specialize clauses (ml-smart [2], ana-ebl [4], focl [11], grendel <ref> [5] </ref>, focl-frontier [10]). One major difference between spectre ii and these techniques is the way in which the search for a specialization is performed.
Reference: 6. <author> Kanamori T. and Kawamura T., </author> <title> "Preservation of Stronger Equivalence in Unfold/Fold Logic Program Transformation (II)", </title> <type> ICOT Technical Report TR-403, </type> <address> Japan (1988) </address>
Reference-contexts: Proof: Since the length of at least one SLD-refutation of P 00 [ f e + g, where e + 2 E + , decreases when applying unfolding, and the number of SLD-refutations does not increase (proven in <ref> [6] </ref>), all input clauses in SLD-refutations of P 00 [ f e + g, for all e + 2 E + , will be unit clauses after a finite number of applications of unfolding.
Reference: 7. <author> Ling C. X., </author> <title> "Non-Monotonic Specialization", </title> <booktitle> Proceedings of International Workshop on Inductive Logic Programming, </booktitle> <address> Portugal (1991) 59-68 </address>
Reference-contexts: Accuracy of the resulting specializations on the test examples. 6 Related Work In this section, we discuss other specialization techniques, and in particular how they work when specializing recursive predicates. In contrast to spectre ii, the techniques in <ref> [7, 1] </ref> attempt to minimally specialize logic programs. However, as pointed out in [16], the specializations produced by these techniques are not always minimal. That is the case when the specialized predicate appears in bodies of clauses, and this is true in particular when specializing a recursive predicate.
Reference: 8. <author> Lloyd J. W., </author> <booktitle> Foundations of Logic Programming, (2nd edition), </booktitle> <publisher> Springer-Verlag (1987) </publisher>
Reference-contexts: In section five, we present some experimental results and in section six we discuss related work. Finally, in section seven we give concluding remarks and point out problems for future research. In the following, we assume the reader to be familiar with the standard terminology in logic programming <ref> [8] </ref>. 2 Preliminaries We first give a formal definition of the specialization problem that is studied, and then define the three transformation rules that are used in this work. 2.1 The Specialization Problem The problem of specializing a logic program (definite program) w.r.t. positive and negative examples can be stated as
Reference: 9. <author> Ourston D. and Mooney R. J., </author> <title> "Changing the Rules: A Comprehensive Approach to Theory Refinement", </title> <booktitle> Proceedings of the Eighth National Conference on Artificial Intelligence, </booktitle> <publisher> MIT Press (1990) 815-820 </publisher>
Reference-contexts: In the field of inductive logic programming, the top-down search for an inductive hypothesis has been performed by using various specialization techniques, such as clause removal, addition of literals and goal reduction <ref> [13, 2, 9, 12, 11, 4, 15, 5, 10, 16, 3] </ref>. In this work, it is assumed that the overly general hypothesis is given as a logic program. In [3], the algorithm spectre is presented, which specializes logic programs by applying the transformation rule unfolding [14] together with clause removal. <p> Another difference is that the only clauses that are considered for being specialized by mbr are those appearing in refutations of negative examples, since this is sufficient when specializing a program with respect to negative examples only. The only specialization operator that is used in <ref> [9, 15] </ref> is clause removal. These approaches are limited to removing clauses that appear in the original program that is to be specialized.
Reference: 10. <author> Pazzani M. and Brunk C., </author> <title> "Finding Accurate Frontiers: A Knowledge-Intensive Approach to Relational Learning", </title> <booktitle> Proceedings of the Eleventh National Conference on Artificial Intelligence, </booktitle> <publisher> Morgan Kaufmann (1993) 328-334 </publisher>
Reference-contexts: In the field of inductive logic programming, the top-down search for an inductive hypothesis has been performed by using various specialization techniques, such as clause removal, addition of literals and goal reduction <ref> [13, 2, 9, 12, 11, 4, 15, 5, 10, 16, 3] </ref>. In this work, it is assumed that the overly general hypothesis is given as a logic program. In [3], the algorithm spectre is presented, which specializes logic programs by applying the transformation rule unfolding [14] together with clause removal. <p> However, the condition for when correct specializations can be obtained by clause removal can be relaxed significantly, if combined with program transformation, as shown by spectre ii. In <ref> [13, 2, 12, 11, 10] </ref>, clauses are specialized by adding literals to their bodies. The literals considered for being added are in these approaches restricted to those whose predicate symbols are defined in the original program. <p> But the resulting specialization will not be correct if there are any positive examples, since these are excluded as well. A number of previous specialization techniques use goal reduction to specialize clauses (ml-smart [2], ana-ebl [4], focl [11], grendel [5], focl-frontier <ref> [10] </ref>). One major difference between spectre ii and these techniques is the way in which the search for a specialization is performed.
Reference: 11. <author> Pazzani M., Brunk C. and Silverstein G., </author> <title> "A Knowledge-Intensive Approach to Learning Relational Concepts", </title> <booktitle> Machine Learning: Proceedings of the Eighth International Workshop, </booktitle> <publisher> Morgan Kaufmann (1991) 432-436 </publisher>
Reference-contexts: In the field of inductive logic programming, the top-down search for an inductive hypothesis has been performed by using various specialization techniques, such as clause removal, addition of literals and goal reduction <ref> [13, 2, 9, 12, 11, 4, 15, 5, 10, 16, 3] </ref>. In this work, it is assumed that the overly general hypothesis is given as a logic program. In [3], the algorithm spectre is presented, which specializes logic programs by applying the transformation rule unfolding [14] together with clause removal. <p> However, the condition for when correct specializations can be obtained by clause removal can be relaxed significantly, if combined with program transformation, as shown by spectre ii. In <ref> [13, 2, 12, 11, 10] </ref>, clauses are specialized by adding literals to their bodies. The literals considered for being added are in these approaches restricted to those whose predicate symbols are defined in the original program. <p> But the resulting specialization will not be correct if there are any positive examples, since these are excluded as well. A number of previous specialization techniques use goal reduction to specialize clauses (ml-smart [2], ana-ebl [4], focl <ref> [11] </ref>, grendel [5], focl-frontier [10]). One major difference between spectre ii and these techniques is the way in which the search for a specialization is performed.
Reference: 12. <author> Quinlan J. R., </author> <title> "Learning Logical Definitions from Relations", </title> <note> Machine Learning 5 (1990) 239-266 </note>
Reference-contexts: In the field of inductive logic programming, the top-down search for an inductive hypothesis has been performed by using various specialization techniques, such as clause removal, addition of literals and goal reduction <ref> [13, 2, 9, 12, 11, 4, 15, 5, 10, 16, 3] </ref>. In this work, it is assumed that the overly general hypothesis is given as a logic program. In [3], the algorithm spectre is presented, which specializes logic programs by applying the transformation rule unfolding [14] together with clause removal. <p> However, the condition for when correct specializations can be obtained by clause removal can be relaxed significantly, if combined with program transformation, as shown by spectre ii. In <ref> [13, 2, 12, 11, 10] </ref>, clauses are specialized by adding literals to their bodies. The literals considered for being added are in these approaches restricted to those whose predicate symbols are defined in the original program. <p> The literals considered for being added are in these approaches restricted to those whose predicate symbols are defined in the original program. Various restrictions are also put on the variables in the literals (e.g. at least one of the variables should appear elsewhere in the clause <ref> [12] </ref>). It should be noted that literal addition is in general not sufficient to obtain correct specializations of logic programs. Consider again the program defining the predicate odd (X): odd (0). <p> One major difference between spectre ii and these techniques is the way in which the search for a specialization is performed. The algorithms ana-ebl, focl, grendel and focl-frontier, like mis [13] and foil <ref> [12] </ref>, use covering methods for finding correct specializations, i.e. the resulting definition is found by repeatedly specializing an overly general definition and for each repetition adding a clause to the resulting definition. This contrasts to spectre ii and ml-smart, which do not specialize the same definition more than once.
Reference: 13. <author> Shapiro E. Y., </author> <title> Algorithmic Program Debugging, </title> <publisher> MIT Press (1983) </publisher>
Reference-contexts: In the field of inductive logic programming, the top-down search for an inductive hypothesis has been performed by using various specialization techniques, such as clause removal, addition of literals and goal reduction <ref> [13, 2, 9, 12, 11, 4, 15, 5, 10, 16, 3] </ref>. In this work, it is assumed that the overly general hypothesis is given as a logic program. In [3], the algorithm spectre is presented, which specializes logic programs by applying the transformation rule unfolding [14] together with clause removal. <p> However, the condition for when correct specializations can be obtained by clause removal can be relaxed significantly, if combined with program transformation, as shown by spectre ii. In <ref> [13, 2, 12, 11, 10] </ref>, clauses are specialized by adding literals to their bodies. The literals considered for being added are in these approaches restricted to those whose predicate symbols are defined in the original program. <p> One major difference between spectre ii and these techniques is the way in which the search for a specialization is performed. The algorithms ana-ebl, focl, grendel and focl-frontier, like mis <ref> [13] </ref> and foil [12], use covering methods for finding correct specializations, i.e. the resulting definition is found by repeatedly specializing an overly general definition and for each repetition adding a clause to the resulting definition.
Reference: 14. <author> Tamaki H. and Sato T., </author> <title> "Unfold/Fold Transformations of Logic Programs", </title> <booktitle> Proceedings of the Second International Logic Programming Conference, </booktitle> <institution> Uppsala University, Uppsala, </institution> <address> Sweden (1984) 127-138 </address>
Reference-contexts: In this work, it is assumed that the overly general hypothesis is given as a logic program. In [3], the algorithm spectre is presented, which specializes logic programs by applying the transformation rule unfolding <ref> [14] </ref> together with clause removal. One limitation of the algorithm is that it assumes the target predicate to be non-recursive. <p> A solution to this problem that has been proposed in [3] is to apply the transformation rules definition, unfolding and folding <ref> [14] </ref> in order to obtain non-recursive target predicates from recursive ones. The draw-back of applying this transformation technique is that recursive specializations can not be obtained, which means that many desired specializations can not be found. <p> Furthermore, the positive and negative examples are no longer required to be instances of the same predicate. In the next section we give a formal definition of the specialization problem, and we also give definitions of the three transformation rules according to <ref> [14] </ref>. In section three, we exemplify the limitation of spectre, and in section four, we present spectre ii, which overcomes this limitation. We also prove that the algorithm produces correct specializations (under some assumptions). In section five, we present some experimental results and in section six we discuss related work. <p> M P , E + M P 0 and M P 0 " E = ; 1 . 1 M P denotes the least Herbrand model of P . 2.2 Transformation Rules The following rules for transformation of a definite program (below referred to as P ) are taken from <ref> [14] </ref>, where formal definitions can be found as well as proofs of their meaning preserving properties. Rule 1.
Reference: 15. <author> Wogulis J., </author> <title> "Revising Relational Domain Theories", </title> <booktitle> Machine Learning: Proceedings of the Eighth International Workshop, </booktitle> <publisher> Morgan Kaufmann (1991) 462-466 </publisher>
Reference-contexts: In the field of inductive logic programming, the top-down search for an inductive hypothesis has been performed by using various specialization techniques, such as clause removal, addition of literals and goal reduction <ref> [13, 2, 9, 12, 11, 4, 15, 5, 10, 16, 3] </ref>. In this work, it is assumed that the overly general hypothesis is given as a logic program. In [3], the algorithm spectre is presented, which specializes logic programs by applying the transformation rule unfolding [14] together with clause removal. <p> Another difference is that the only clauses that are considered for being specialized by mbr are those appearing in refutations of negative examples, since this is sufficient when specializing a program with respect to negative examples only. The only specialization operator that is used in <ref> [9, 15] </ref> is clause removal. These approaches are limited to removing clauses that appear in the original program that is to be specialized.
Reference: 16. <author> Wrobel S., </author> <title> "On the Proper Definition of Minimality in Specialization and Theory Revision", </title> <booktitle> Proceedings of the European Conference on Machine Learning, </booktitle> <month> Springer-Verlag </month> <year> (1993) </year> <month> 65-82 </month>
Reference-contexts: In the field of inductive logic programming, the top-down search for an inductive hypothesis has been performed by using various specialization techniques, such as clause removal, addition of literals and goal reduction <ref> [13, 2, 9, 12, 11, 4, 15, 5, 10, 16, 3] </ref>. In this work, it is assumed that the overly general hypothesis is given as a logic program. In [3], the algorithm spectre is presented, which specializes logic programs by applying the transformation rule unfolding [14] together with clause removal. <p> In contrast to spectre ii, the techniques in [7, 1] attempt to minimally specialize logic programs. However, as pointed out in <ref> [16] </ref>, the specializations produced by these techniques are not always minimal. That is the case when the specialized predicate appears in bodies of clauses, and this is true in particular when specializing a recursive predicate. For example, given the following program and the negative example p (a,a): p (X,X). <p> In <ref> [16] </ref> a technique for incremental specialization is presented, called mbr (Minimal Base Revision). It uses clause removal and addition of literals to prevent negative examples from being derived.
References-found: 16

