URL: http://www.cs.columbia.edu/~library/theses/franklin.ps.gz
Refering-URL: http://www.cs.columbia.edu/home/phd_prog/alumni.html
Root-URL: http://www.aic.nrl.navy.mil/~aha/people.html
Title: Complexity and Security of Distributed Protocols  
Author: Matthew Keith Franklin 
Degree: Submitted in partial fulfillment of the requirements for the degree of Doctor of Philosophy in the Graduate School of Arts and Sciences  
Date: 1993  
Affiliation: COLUMBIA UNIVERSITY  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> M. Abadi, J. Feigenbaum, and J. Kilian, </author> <title> "On hiding information from an oracle," </title> <journal> J. Comput. System Sci. </journal> <volume> 39 (1989), </volume> <pages> 21-50. </pages>
Reference-contexts: One approach is algebraic [62] [111], proving security by relating actual protocols homomorphically to theoretically perfect protocols. A second approach is logical [37], proving security with respect to some reasonable axiomatization. Lastly, we mention some general notions that are related to secure distributed computing. Instance-hiding schemes <ref> [1] </ref> [13] involve a weak computational agent exploiting one or more strong but untrusted computational agents to compute a function for secret inputs. <p> Their formal definition of information leakage is similar to the notion of information leakage used by Abadi, Feigenbaum, and Kilian <ref> [1] </ref> for characterizing instance-hiding schemes. <p> R finds [r; ] where (a) r = [r j : j 62 S] Q j ) mod N A (c) The public and easily computable function e is defined to be e (s; r) = [e 0 (s; r <ref> [1] </ref>); ; e 0 (s; r [k])]. 6.3.2 Heuristic Implementation of Oblivious Authentication Oblivious Authentication can be implemented heuristically using multiple blind RSA signatures, collision-free hash functions, and a cut-and-choose challenge procedure (see Figure 6.2).
Reference: [2] <author> M. Abadi and J. Feigenbaum, </author> <title> "Secure circuit evaluation: a protocol based on hiding information from an oracle," </title> <editor> J. </editor> <booktitle> Cryptology 2 (1990), </booktitle> <pages> 1-12. </pages>
Reference-contexts: Instance hiding may be thought of as a close cousin to secure distributed computation. It is listed in this section on preliminaries because two interesting protocols for secure distributed computation are in fact based directly on instance hiding as a primitive <ref> [2] </ref> [14]. 15 2.2 Models and Basic Protocols In this section, the background definitions and concepts are presented for secure distributed computing. Two fundamental protocols are formally described: Oblivious Transfer [126] and Byzantine Agreement [103]. <p> The discussion of the protocol itself is deferred to the section on multi-party cryptographic computation, since the same general protocol can handle any number of players. Abadi and Feigenbaum <ref> [2] </ref> present a two-party computation protocol that is similar to the protocol of Chaum, Damg-ard, and Van de Graaf. This protocol is described using the idea of 24 instance hiding from an oracle, which was discussed in Section 2.1.7.
Reference: [3] <author> C. van Antwerpen, </author> <title> "Electronic cash," </title> <type> Master's thesis, </type> <institution> Eindhoven University of Technology, </institution> <year> 1990. </year>
Reference-contexts: This approach is efficient but heuristic; no proof of security has been given that relies on assumptions about RSA that are simple or natural. In fact, refinements to their protocol <ref> [3] </ref> were later found to introduce security flaws [90], which underscores the risk of relying on heuristics. Other off-line coin schemes use blind signature schemes derived from Chaum and Pedersen [44].
Reference: [4] <author> L. Babai and S. Moran, </author> <title> "Arthur-Merlin games: A randomized proof system and a hierarchy of complexity classes," </title> <journal> J. Comput. System Sci. </journal> <volume> 36 (1988), </volume> <pages> 254-276. </pages>
Reference-contexts: unreadability requires that the two probability distributions be (almost) identical. 2.1.5 Interactive Proof Systems and Zero-Knowledge Proof An interactive proof system is a two-party protocol in which a "prover" conveys a convincing argument to a polynomially-bounded probabilistic "verifier;" this idea was introduced by Goldwasser, Micali, and Rackoff [86] and Babai <ref> [4] </ref>.
Reference: [5] <author> I. Barany and Z. Furedi, </author> <title> "Mental poker with three or more players," </title> <booktitle> Information and Control 59 (1983), </booktitle> <pages> 84-93. </pages>
Reference-contexts: Surprisingly, what is impossible in general for two players becomes possible when there are many players, by substituting secret-sharing, private channels, and "sufficient honesty" for cryptography. An early result in this area (demonstrating the difference when more than two players participate) was due to Barany and Furedi <ref> [5] </ref>, who give a 1-private non-cryptographic protocol for an aspect of the multi-player "Mental Poker" problem, i.e., how to deal a deck of cards among mutually untrustworthy players who can only communicate by sending messages.
Reference: [6] <author> J. Bar-Ilan and D. Beaver, </author> <title> "Non-cryptographic fault-tolerant computing in a constant number of rounds of interaction," </title> <booktitle> PODC 1989, </booktitle> <pages> 201-209. </pages>
Reference-contexts: Otherwise, the protocol is "non-cryptographic" (or "unconditional"), and there are no bounds on the running time of the programs. However, for most non-cryptographic protocols described in this paper, the programs for all players are polynomial-time (two exceptions are Bar-Ilan and Beaver <ref> [6] </ref> and Beaver, Feigenbaum, Kilian, and Rogaway [14]). Some minor variations in the definition of protocol appear in the literature. Two of these variations are mentioned at this time. The definition of protocol assumes that each player receives the result of a single computation. <p> This section presents some of what is currently known about constant-round non-cryptographic computation versus an active adversary. Bar-Ilan and Beaver <ref> [6] </ref> demonstrate that, even in the absence of cryptographic assumptions, the number of rounds of communication needed for secure distributed computation of a function need not be related to the depth of the arithmetic circuit for that function. <p> This can be converted into an n + 1 oracle instance-hiding scheme that is (log n)-private, by replacing each oracle query at x by n + 1 oracle queries at (log n)-shares of x. The method also relies on the constant-round poly-sized computation of functions with log-depth circuits <ref> [6] </ref>. Creation of appropriate oracle queries, polynomial interpolation, notarized envelope schemes, and majority-voting all have log-depth circuits, and so all are available as subprotocols in this way. <p> Some models have been proposed, but no clear favorite has yet emerged. One important open problem is general constant-round non-cryptographic secure distributed computation with polynomial-sized messages. The problem has been solved for functions with log-depth circuits <ref> [6] </ref>, or allowing exponential-length messages [6], or by reducing the resiliency [14], or by assuming the existence of one-way functions [16]. Another open question is the characterization of privately-computed multi-input functions. The two-input privately-computable functions have been completely characterized [10] [101]. <p> Some models have been proposed, but no clear favorite has yet emerged. One important open problem is general constant-round non-cryptographic secure distributed computation with polynomial-sized messages. The problem has been solved for functions with log-depth circuits <ref> [6] </ref>, or allowing exponential-length messages [6], or by reducing the resiliency [14], or by assuming the existence of one-way functions [16]. Another open question is the characterization of privately-computed multi-input functions. The two-input privately-computable functions have been completely characterized [10] [101]. A third open question is a more general question of efficiency. <p> Other examples where systematic parallelization applies are the private and resilient protocols of Chaum, Crepeau, and Damg-ard [41], the constant-round protocols of Bar-Ilan and Beaver <ref> [6] </ref>, and the general network topology protocols of Dolev, Dwork, Waarts, and Yung [61]. 3.3.5 Computing "Similar Circuits" in Parallel We also note that our parallel techniques are useful when circuits that are similar but not identical are to be computed on different sets of inputs.
Reference: [7] <author> D. Barrington, </author> <title> "Bounded-width branching programs recognize exactly those languages in N C 1 , J. </title> <journal> Comput. System Sci. </journal> <volume> 38 (1989), </volume> <pages> 150-164. </pages>
Reference-contexts: The circuit evaluation protocol takes advantage of the equivalence (shown by Barrington <ref> [7] </ref>) of N C 1 functions and width 5 permutation branching programs. Instead of scrambling a circuit, the appropriate permutation programs are randomized in a simple and straightforward manner; this leads to a constant-round evaluation protocol when the underlying function is in N C 1 . <p> That protocol assumed only the existence of any trapdoor function. In the same paper, multi-party computation is reduced to a succession of two-input computations, in such a way that privacy is maintained. Using a technique due to Barrington <ref> [7] </ref>, the depth D circuit to be computed can be represented as a straight-line program, of length at most 4 D , whose inputs are permutations in S 5 (the 120 possible permutations on five distinct elements). Each player can then privately convert his input into a single corresponding permutation.
Reference: [8] <author> R. Bar-Yehuda, B. Chor, and E. Kushilevitz, </author> <title> "Privacy, additional information, and communication," </title> <booktitle> IEEE Structure in Complexity Theory 1990, </booktitle> <pages> 55-65. </pages>
Reference-contexts: However, the function g (x; y) = min (1; x 2 mod 5; y) defined on the same domain is not partitionable, and hence not privately computable (see Figure 2). Bar-Yehuda, Chor, and Kushilevitz <ref> [8] </ref> consider two-party "nearly private" computation protocols for functions that are not partitionable; a "nearly private" protocol leaks some information about private inputs to the opposing player. <p> Previously, communication complexity for secure computation was studied only for the privacy model and only for the two-party case [101] <ref> [8] </ref> (see also [119] for results in the related model of cooperative two-party computation versus an eavesdropper). Recently, and independently, Kushilevitz [102] has studied the communication complexity of multi-party private addition (see our Lemma 3.2).
Reference: [9] <author> D. Beaver, </author> <title> "Multiparty protocols tolerating half faulty processors," </title> <booktitle> in Advances in Cryptology| CRYPTO '89 Proceedings (Lecture Notes in Computer Science, </booktitle> <volume> Vol. 435), </volume> <editor> ed. G. Brassard, </editor> <address> 560-572, </address> <publisher> Springer-Verlag, </publisher> <address> New York, </address> <year> 1990. </year>
Reference-contexts: The error correction procedure is also independent of the number of secrets hidden by the polynomial; as long as the ff i 's are chosen to be nth roots of unity, this procedure need not be changed for the parallel version. Rabin and Ben-Or [128] (see also Beaver <ref> [9] </ref>) have a protocol to securely compute any arithmetic circuit t-resiliently, where n 2t + 1, assuming broadcast, and allowing an exponentially small probability of error.
Reference: [10] <author> D. Beaver, </author> <title> "Perfect privacy for two-party protocols," </title> <booktitle> DIMACS Workshop on Distributed Computing and Cryptography, </booktitle> <editor> Feigenbaum and Merritt (eds.), </editor> <publisher> AMS, </publisher> <year> 1990, </year> <pages> 65-77. </pages>
Reference-contexts: For two player non-cryptographic protocols, a complete characterization of privately computable general functions (i.e., non-boolean) is given independently by Kushilevitz [101] and by Beaver <ref> [10] </ref>. <p> The problem has been solved for functions with log-depth circuits [6], or allowing exponential-length messages [6], or by reducing the resiliency [14], or by assuming the existence of one-way functions [16]. Another open question is the characterization of privately-computed multi-input functions. The two-input privately-computable functions have been completely characterized <ref> [10] </ref> [101]. A third open question is a more general question of efficiency. Most of the secure distributed computation schemes described in this paper are designed to be applicable to any possible function.
Reference: [11] <author> D. Beaver, </author> <title> "Foundations of secure interactive computing," </title> <booktitle> in Advances in Cryptology| CRYPTO '91 Proceedings (Lecture Notes in Computer Science, </booktitle> <volume> Vol. 576), </volume> <editor> ed. J. Feigenbaum, </editor> <address> 377-391, </address> <publisher> Springer-Verlag, </publisher> <address> New York, </address> <year> 1992. </year>
Reference-contexts: In this subsection, two proposals for such a definition are described. A third proposed definition, due to Goldwasser and Levin [84], will not be discussed. One proposal to put this area on a more formal foundation is due to Beaver <ref> [11] </ref>. He defines the idea of an "interface" to allow an adversary for one protocol to attack a second protocol; an interface is a Turing Machine that sends messages to the adversary and sends how-to-corrupt instructions to the second protocol. <p> Here an appropriate output is somewhat difficult to define (see, e.g., Beaver <ref> [11] </ref> and Micali and Rogaway [113] for more precise definition). We introduce the new and natural security requirement of t-unstoppability.
Reference: [12] <author> D. Beaver, </author> <title> "Secure multiparty protocols and zero-knowledge proof systems tolerating a faulty minority," </title> <editor> J. </editor> <booktitle> Cryptology (1991) 4: </booktitle> <pages> 75-122. </pages>
Reference-contexts: The first two [22] [41] achieve t-resilience whenever there are n &gt; 3t players, assuming a complete private network of channels. The last two [128] <ref> [12] </ref> achieve t-resilience when n &gt; 2t, but require a broadcast channel in addition to a complete private network, and must allow a small probability of error. <p> There is a protocol for doing this, based on the fact that degree t polynomials can be so verified, and that a share of an otherwise random degree 2t polynomial with zero constant term can be constructed privately from shares of t random degree t polynomials. Beaver <ref> [12] </ref> has observed, however, that this extra effort to randomize the higher-degree coefficients is wasted, since these will disappear after truncation anyway. The second difference is in the truncation step. A subprotocol is inserted to force all players to "validate" their inputs to the degree truncation step. <p> One natural question is whether the resilience can be increased by adding a broadcast channel. The affirmative answer was supplied T. Rabin and Ben-Or [128], and by Beaver <ref> [12] </ref>, both building on ideas from T. Rabin [127]. At the heart of the protocol is a verifiable secret sharing scheme, due to T. Rabin [127], that can correct up to t errors where n &gt; 2t, by giving up on absolute certainty of success. <p> Re-randomization is straightforward, due to Beaver's observation <ref> [12] </ref> that the only coefficients that need to be randomized are those that will survive the truncation step. Each player i can verifiably t-share a random value using a polynomial p i (x).
Reference: [13] <author> D. Beaver and J. Feigenbaum, </author> <title> "Hiding instances in multioracle queries," </title> <booktitle> STACS 1990, </booktitle> <pages> 37-48. 119 </pages>
Reference-contexts: One approach is algebraic [62] [111], proving security by relating actual protocols homomorphically to theoretically perfect protocols. A second approach is logical [37], proving security with respect to some reasonable axiomatization. Lastly, we mention some general notions that are related to secure distributed computing. Instance-hiding schemes [1] <ref> [13] </ref> involve a weak computational agent exploiting one or more strong but untrusted computational agents to compute a function for secret inputs. <p> In later sections, this VSS scheme will be used in secure computation protocols, as will a VSS scheme due to T. Rabin [127] that can tolerate any minority of faulty players with an exponentially small probability of error. 2.1.7 Instance Hiding Instance hiding schemes ([1], <ref> [13] </ref>) are a means for computing with encrypted data. Assume that a computationally weak player wishes to compute a complicated function with the help of powerful but untrusted players (called "oracles"). <p> Every function has a multiple oracle instance hiding scheme that leaks no information to any single oracle <ref> [13] </ref> (but which allows any two oracles to determine the intended computation). As an example, here is a 1-oracle instance-hiding scheme for computing the discrete logarithm. To find DLP p;g (a), choose a random i, 0 &lt; i &lt; p, and ask the oracle for DLP p;g (ag i ).
Reference: [14] <author> D. Beaver, J. Feigenbaum, J. Kilian, and P. Rogaway, </author> <title> "Security with low communication overhead," </title> <booktitle> in Advances in Cryptology|CRYPTO '90 Proceedings (Lecture Notes in Computer Science, </booktitle> <volume> Vol. 537), </volume> <editor> ed. A. Menzes and S. Vanstone, </editor> <address> 62-76, </address> <publisher> Springer-Verlag, </publisher> <address> New York, </address> <year> 1991. </year>
Reference-contexts: Instance hiding may be thought of as a close cousin to secure distributed computation. It is listed in this section on preliminaries because two interesting protocols for secure distributed computation are in fact based directly on instance hiding as a primitive [2] <ref> [14] </ref>. 15 2.2 Models and Basic Protocols In this section, the background definitions and concepts are presented for secure distributed computing. Two fundamental protocols are formally described: Oblivious Transfer [126] and Byzantine Agreement [103]. <p> Otherwise, the protocol is "non-cryptographic" (or "unconditional"), and there are no bounds on the running time of the programs. However, for most non-cryptographic protocols described in this paper, the programs for all players are polynomial-time (two exceptions are Bar-Ilan and Beaver [6] and Beaver, Feigenbaum, Kilian, and Rogaway <ref> [14] </ref>). Some minor variations in the definition of protocol appear in the literature. Two of these variations are mentioned at this time. The definition of protocol assumes that each player receives the result of a single computation. <p> Alternatively, using their technique, an arbitrary function can be securely computed in D= log n rounds, where D is the circuit depth, using polynomial-sized messages. Beaver, Feigenbaum, Kilian, and Rogaway <ref> [14] </ref> show how to achieve non-cryptographic computation of boolean circuits of any size in constant rounds with polynomial-sized messages, by decreasing the resilience to O (log n) faulty processors. The method relies on an instance-hiding scheme for any boolean function using n= log n + 1 oracles. <p> Some models have been proposed, but no clear favorite has yet emerged. One important open problem is general constant-round non-cryptographic secure distributed computation with polynomial-sized messages. The problem has been solved for functions with log-depth circuits [6], or allowing exponential-length messages [6], or by reducing the resiliency <ref> [14] </ref>, or by assuming the existence of one-way functions [16]. Another open question is the characterization of privately-computed multi-input functions. The two-input privately-computable functions have been completely characterized [10] [101]. A third open question is a more general question of efficiency. <p> In particular, we offer two security notions new in the setting of secure computation: unstoppability (to withstand fail-stop mode of failure) and detectability (to detect arbitrary deviation from the 1 For O (log n) faults only, a protocol due to Beaver, Feigenbaum, Kilian, and Rogaway <ref> [14] </ref> has bit complexity independent of circuit size (dependent on the input size and n); no known protocols tolerating a constant fraction of faulty players have this property. 51 specified protocol). These requirements are both in between the known "privacy" and "resilience" modes. <p> We have shown a tradeoff between bit complexity (multiplicative) and fault tolerance (additive); it is possible that other measures can be related as well (e.g., round complexity, level of security, error probability). Lastly, the resilient protocol of Beaver, Feigenbaum, Kilian, and Rogaway <ref> [14] </ref> has a bit complexity that is independent of circuit size, but is low in fault tolerance (i.e, can only tolerate O (log n) faulty players); whether fault tolerance can be improved while maintaining this independence remains open. 65 Chapter 4 Eavesdropping Games: A Graph-Theoretic Approach to Privacy in Distributed Systems
Reference: [15] <author> D. Beaver and S. Goldwasser, </author> <title> "Multiparty computation with faulty majority," </title> <booktitle> IEEE FOCS 1989, </booktitle> <pages> 468-473. </pages>
Reference-contexts: Oblivious Transfer is one of the most basic possible primitives that can break the "knowledge symmetry" between two players. In addition to other versions of Oblivious Transfer, more sophis ticated protocols can be built from this primitive. In fact, secure distributed computation can be reduced to Oblivious Transfer [96] <ref> [15] </ref> [84], as will be discussed in later sections. To give a sim pler reduction now, the following scheme, due to Crepeau [54], achieves bit commitment through oblivious transfer: 1. Player A chooses random b 1 ; ; b n such that b 1 b n = b. 2. <p> This assumes, however, that the adversary and the honest players have equivalent computing power; otherwise, the adversary could halt when only it had enough bits of the trapdoor key to determine the result (e.g., by exhaustive search of all completions of the key). Beaver and Goldwasser <ref> [15] </ref> present a different way of achieving fairness for boolean functions (similar to Luby et al. [107]), under the assumption that an Oblivious Transfer protocol exists (together with a network of private channels). It also does not rely on the computational equivalence of the adversary and the honest players.
Reference: [16] <author> D. Beaver, S. Micali, and P. Rogaway, </author> <title> "The round complexity of secure protocols," </title> <booktitle> ACM STOC 1990, </booktitle> <pages> 503-513. </pages>
Reference-contexts: The method also relies on the constant-round poly-sized computation of functions with log-depth circuits [6]. Creation of appropriate oracle queries, polynomial interpolation, notarized envelope schemes, and majority-voting all have log-depth circuits, and so all are available as subprotocols in this way. Lastly, Beaver, Micali, and Rogaway <ref> [16] </ref> show that constant-round poly-sized computation, resilient for a constant fraction of faulty processors, is achievable assuming that one-way functions exist. <p> One important open problem is general constant-round non-cryptographic secure distributed computation with polynomial-sized messages. The problem has been solved for functions with log-depth circuits [6], or allowing exponential-length messages [6], or by reducing the resiliency [14], or by assuming the existence of one-way functions <ref> [16] </ref>. Another open question is the characterization of privately-computed multi-input functions. The two-input privately-computable functions have been completely characterized [10] [101]. A third open question is a more general question of efficiency.
Reference: [17] <author> M. Bellare, L. Cowen, and S. Goldwasser, </author> <title> "On the structure of secret key exchange protocols," </title> <booktitle> DIMACS Workshop on Distributed Computing and Cryptography, </booktitle> <editor> Feigenbaum and Merritt (eds.), </editor> <publisher> AMS, </publisher> <year> 1990, </year> <pages> 79-92. </pages>
Reference-contexts: Adversary: t active, t &lt; n Security: 2-party oblivious transfer (e.g., noisy channels) Error Prob: 1 p (n) , for any poly p bit complexity: poly (C; n) roundcomplexity: O (D) Table 2.5: Summary of Beaver and Goldwasser 1989 functions is known to follow from the feasibility of oblivious transfer <ref> [17] </ref>. Goldwasser and Levin [84] extend the gradual revelation technique from boolean values to arbitrary values, again assuming only oblivious transfer. Representing the output as a boolean string, the computation stage reveals the bitwise xor of the output with a jointly created random mask.
Reference: [18] <author> J. Benaloh (Cohen), </author> <title> "Secret sharing homomorphisms: keeping shares of a secret secret," </title> <booktitle> in Advances in Cryptology|CRYPTO '86 Proceedings (Lecture Notes in Computer Science, </booktitle> <volume> Vol. 263), </volume> <editor> ed. A. Odlyzko, </editor> <address> 251-260, </address> <publisher> Springer-Verlag, </publisher> <address> New York, </address> <year> 1987. </year>
Reference-contexts: First, each player shares his secret input with all other players using a Shamir polynomial. Second, all players perform some computation on these shares. Third, the results of this computation are combined to find the actual output. Nice homomorphic properties of Shamir shares (first pointed out by Benaloh <ref> [18] </ref>) make stage two possible: any linear combination of shares of secrets is itself a share of the linear combination of secrets.
Reference: [19] <author> J. Benaloh (Cohen) and M. Yung, </author> <title> "Distributing the power of a government to enhance to privacy of voters," </title> <booktitle> PODC 1986, </booktitle> <pages> 52-62. </pages>
Reference-contexts: Electronic money [38] [39] is a collection of protocols (e.g, withdrawal, purchase, deposit) that implement payment schemes without any physical requirements. Secret-ballot election schemes [50] <ref> [19] </ref> [91] are essentially a special case of secure computation in which the function is a simple sum of ones and zeros. Early work in the formalization of cryptographic protocols is also of interest.
Reference: [20] <author> M. Ben-Or, R. Canetti, and O. Goldreich, </author> <title> "Asynchronous secure computation," </title> <booktitle> ACM STOC 1993, </booktitle> <pages> 52-61. </pages>
Reference-contexts: One of the features of this protocol is that all of the information held secret by the players must be continually reshared, so that the mobile adversary never gets enough consistent shares of any secret to recover it. 2.5.8 Non-Cryptographic Asynchronous Computation Ben-Or, Canetti and Goldreich <ref> [20] </ref> study secure computation among processors connected by a complete asynchronous network of untappable channels. If only crash failures are allowed (Fail-Stop faults), they show how to compute securely any function over a finite field while withstanding up to d n 3 e 1 faulty processors.
Reference: [21] <author> M. Ben-Or and R. Cleve, </author> <title> "Computing algebraic formulas using a constant number of registers," </title> <booktitle> ACM STOC 1988, </booktitle> <pages> 254-257. </pages>
Reference-contexts: Bar-Ilan and Beaver show how to compute any N C 1 circuit in constant rounds and polynomial-sized messages. One of the key ideas in this protocol is the use of a technique, due to Ben-Or and Cleve <ref> [21] </ref>, for mapping an arbitrary arithmetic function to the multiplication of a string of three by three 42 Channel: complete private network Adversary: t active, t &lt; c log n Security: unconditional Error Prob: zero bit complexity: poly (n; log jF j) roundcomplexity: O (1) Table 2.11: Summary of Beaver, Feigenbaum,
Reference: [22] <author> M. Ben-Or, S. Goldwasser, and A. Wigderson, </author> <title> "Completeness theorems for non-cryptographic fault-tolerant distributed computation," </title> <booktitle> ACM STOC 1988, </booktitle> <pages> 1-9. </pages>
Reference-contexts: This primitive is also used extensively in the secure computation protocols given in this paper. To illustrate the idea, we describe a VSS scheme due to Ben-Or, Goldwasser, and Wigderson <ref> [22] </ref> that can correct up to t player errors, with no probability of errors, if n &gt; 3t. The dealer chooses a degree t polynomial p (x; y) in two variables x and y, such that the secret s = p (0; 0). <p> The second type is an interactive gate-by-gate evaluation of the circuit for encrypted inputs. Note that secure two-party computation is not possible in general without some complexity assumption. As a simple example, Ben-Or, Goldwasser, and Wigderson <ref> [22] </ref> show that there cannot be an information-theoretically secure two-party protocol for computing the OR of two input bits. There are other impossibility results for unconditional two-party computation that are covered in Section 2.6. The first results in two-party secure computation are due to Yao [139]. <p> If fewer than one-third of the players are faulty, then error-correcting codes can be exploited <ref> [22] </ref>. For greater resilience, new techniques of verifiable secret sharing [127] can be used. These new techniques can require more interaction among players, even for linear operations. In this subsection, we will survey some of the non-cryptographic secure distributed computation protocols that have been developed. <p> t &lt; n=2 Security: unconditional bit complexity: O (n 2 C log jF j) round complexity: O (D) Table 2.6: Summary of Ben-Or, Goldwasser, and Wigderson 1988 (passive adversary) 2.5.2 Non-cryptographic Protocols versus Passive Adversaries The first two papers suggesting general non-cryptographic distributed computation are by Ben-Or, Goldwasser and Wigderson <ref> [22] </ref>, and by Chaum, Crepeau, and Damg-ard [41]. Both papers present protocols for t-private computation whenever n &gt; 2t. Provided that all players obey the protocols perfectly, no minority of players can pool their knowledge at the end of the protocol to gain further information about the honest players' inputs. <p> Provided that all players obey the protocols perfectly, no minority of players can pool their knowledge at the end of the protocol to gain further information about the honest players' inputs. In this subsection, we will describe both of these protocols. Ben-Or, Goldwasser, and Wigderson <ref> [22] </ref> present a protocol which allows t-private computation among 2t + 1 players without any cryptographic assumptions. A network of private channels connecting all players is required. This protocol, as with all protocols developed thus far for the non-cryptographic setting, is based on Shamir's method for secret sharing. <p> The first two <ref> [22] </ref> [41] achieve t-resilience whenever there are n &gt; 3t players, assuming a complete private network of channels. The last two [128] [12] achieve t-resilience when n &gt; 2t, but require a broadcast channel in addition to a complete private network, and must allow a small probability of error. <p> In the same paper that gave the protocol for t-private computation when n &gt; 2t (described in the preceding subsection), Ben-Or, Goldwasser and Wigderson <ref> [22] </ref> also demonstrated that t-resilient computation was possible for n &gt; 3t. The resilient protocol is identical to the private protocol except for changes to the secret-sharing method and to the multiplication stage. The verifiable secret sharing scheme outlined in Section 2.1.6 is used in place of simple secret sharing. <p> Prob: O (2 k ) bit complexity: O (n 6 k 3 jF j 4 log jF j) round complexity: O (D) Table 2.9: Summary of Beaver 1989 / Rabin and Ben-Or 1989 Since Byzantine Agreement requires that more than two-thirds of the players be honest, these two resilient protocols <ref> [22] </ref> [41] are the best possible for a network of private channels in the non-cryptographic setting. One natural question is whether the resilience can be increased by adding a broadcast channel. The affirmative answer was supplied T. <p> Ostrovsky and Yung [121] demonstrate the necessity of a complete network of private channels for implementing private multiparty computation among computationally unbounded players (sufficiency was shown by <ref> [22] </ref> and [41]). They consider the problem of dealing one card from a four card deck to each of three players. <p> Ben-Or, Goldwasser, and Wigderson <ref> [22] </ref> provide matching lower bounds for multiparty non-cryptographic computation on a network of private channels, for both passive and active adversary. <p> These solutions relied on unproven assumptions: the intractability of factoring, and the existence of trapdoor functions, respectively. Starting with Ben-Or, Goldwasser, and Wigderson <ref> [22] </ref>, and Chaum, Crepeau, and Damg-ard [41], more recent protocols have removed the reliance of multi-party protocols on unproven assumptions. These protocols rely instead on the physical assumption that untappable communication channels connect all pairs of processors; sometimes these are called "unconditional" or "non-cryptographic" protocols. <p> the linear combinations of multi-shared secrets, providing that the same secret locations and the same share locations were used for all multi-shares. 54 3.3.3 Parallel Private Computation In this section, we illustrate our parallelization technique by showing how the t-private arithmetic circuit computation protocol due to Ben-Or, Goldwasser, and Wigderson <ref> [22] </ref> (which will be called the "BGW-priv" protocol), can be parallelized. Multi-secret sharing replaces Shamir's single-secret sharing scheme, and the algebra is extended to manipulate multi-shares appropriately. <p> In all cases, a multiplicative factor of k, for any 1 k t, is gained in the amortized bit complexity, at the expense of an additive factor of k in the number of faulty players tolerated. In particular, Ben-Or, Goldwasser, and Wigderson <ref> [22] </ref> present a t-resilient perfectly-secure protocol (BGW-res) for computing any arithmetic circuit in C M over finite field F by n 3t + 1 players with communication complexity C BGW (C M ) = O (M n 2 t 3 log jF j) bits. <p> For example, the lowest bit complexity for t-resilient computation, where t is a constant fraction of n, is due to Ben-Or, Gold-wasser, and Wigderson <ref> [22] </ref>: O (M n 5 log jF j) bits to t-resiliently compute a circuit in C M (when n 3t + 1). <p> Each player i finds an otherwise random degree t 1 polynomial p i (x) such that p i (0) = s i , and gives to each player j the share s ij = p i (ff j ) using a protocol for Verifiable Secret Sharing (VSS), e.g., as in <ref> [22] </ref>. 2. Each player i finds n random degree t 1 polynomials r i1 (x); ; r in (x), and gives to each player j the shares r i1j = r i1 (ff j ); ; r inj = r in (ff j ) using VSS. <p> Related Work: Information-theoretic security for distributed tasks has been studied for many adversarial models involving non-mobile faults, beginning with Ben-Or et al. <ref> [22] </ref> and Chaum et al. [41]. A characterization of which boolean functions are privately computable on a complete network versus non-mobile eavesdroppers was given by Chor and Kushilevitz [55]. Variants of the problems we consider have been defined elsewhere. <p> For example, if a number of parties are all plugged into a graph, then they can use the graph as a complete network of untappable channels. In this way, they can compute any function over a finite field privately using protocols secure against a passive adversary <ref> [22] </ref> [41]. To describe our results about message transmission in the plug-in model, we need the following definition.
Reference: [23] <author> R. Berger, R. Peralta, and T. Tedrick, </author> <title> "A provably secure oblivious transfer protocol," </title> <booktitle> Euro-crypt 1984, </booktitle> <pages> 379-386. </pages>
Reference-contexts: Oblivious Transfer [26] <ref> [23] </ref> [34] is a fundamental two-party protocol that transfers a bit with uncertainty; it is discussed in more detail in Section 2.2.2.
Reference: [24] <author> E. Berlekamp, </author> <title> Algebraic Coding Theory, </title> <publisher> Aegean Park Press, </publisher> <address> Laguna Hills, CA, </address> <year> 1984. </year>
Reference-contexts: The importance of this choice for share locations is that the vector of n shares of any secret is a codeword of a generalized Reed-Muller error-correcting code <ref> [24] </ref>. This family of codes can correct a codeword in which up to one-third of the components are incorrect or missing. For our 39 purposes, this means that the n t honest players can reconstruct a shared secret after t arbitrary shares are corrupted by an active adversary.
Reference: [25] <author> D. Bienstock and P. Seymour, </author> <title> "Monotonicity in graph searching," </title> <editor> J. </editor> <booktitle> Algorithms 12 (1991), </booktitle> <pages> 230-245. </pages>
Reference-contexts: Our work on distributed database maintenance shows reductions between privacy and generalizations of graph searching games, a topic that has received much attention (e.g., [36] [110] [100] [104] <ref> [25] </ref>). Organization: In Section 4.2, we give the basic model of eavesdropping games. We consider the problem of secure message transmission in Section 4.3, and distributed database maintenance in Section 4.4. The sensitivity of the database problem to the choice of mobility setting is addressed in Section 4.5.
Reference: [26] <author> M. Blum, </author> <title> "Three applications of the Oblivious Transfer: Part I: Coin flipping by telephone; Part II: How to exchange secrets; Part III: How to send certified electronic mail," </title> <institution> Department of EECS, University of California, Berkeley, </institution> <address> CA, </address> <year> 1981. </year>
Reference-contexts: Bit commitment, a two-player version of secret sharing, is discussed in Section 2.1.4. Coin flipping <ref> [26] </ref> is a two-party protocol that arrives at a common random bit; this was one of the earliest cryptographic protocols. <p> Oblivious Transfer <ref> [26] </ref> [23] [34] is a fundamental two-party protocol that transfers a bit with uncertainty; it is discussed in more detail in Section 2.2.2. <p> This property is called "fairness." The problem of "contract signing," allowing two parties to agree on a contract in a mutually committed fashion, predates and is related to the fairness problem; protocols for contract signing were given by Blum <ref> [26] </ref>. Fairness itself was originally considered for the basic problem of secret key exchange.
Reference: [27] <author> M. Blum, </author> <title> "Coin flipping by telephone: a protocol for solving impossible problems," </title> <booktitle> IEEE Computer Conference 1982, </booktitle> <pages> 133-137. </pages>
Reference-contexts: The scheme is unreadable if the distributions of elements in the pre-image of zero and elements in the pre-image of one are indistinguishable to the receiver. The first bit commitment protocol was part of a protocol by Blum <ref> [27] </ref> for two-party coin flipping. A commitment by one party, followed by a guess by the second party, followed by a revelation by the first party, is equivalent to the flip of a coin.
Reference: [28] <author> M. Blum, </author> <title> "How to exchange (secret) keys," </title> <journal> ACM Trans. Comput. Sys. </journal> <volume> 1 (1983), </volume> <pages> 175-193. </pages>
Reference-contexts: Oblivious Transfer [26] [23] [34] is a fundamental two-party protocol that transfers a bit with uncertainty; it is discussed in more detail in Section 2.2.2. Secret exchange <ref> [28] </ref> [31] [107] [89] [140] is a two-party protocol that transfers a message in each direction with certainty; it is discussed in more detail in Section 2.4.4. Electronic money [38] [39] is a collection of protocols (e.g, withdrawal, purchase, deposit) that implement payment schemes without any physical requirements. <p> If each of two players conveys a secret to the other, then one player can quit the protocol at any moment to advantage if at that moment it has received "more" than it has sent. 33 Blum introduced the problem <ref> [28] </ref>, and gave an incorrect solution (generalized and corrected by Yao [139]) when the secrets were factorizations of large composite numbers. <p> If the adversary never can have such an advantage, then the protocol is said to be synchronous. Computational advantage can be defined to be an increased probability of successfully distinguishing the actual output from a possible output. Galil, Haber, and Yung describe a means (similar to Blum <ref> [28] </ref>, and following Yao [140]) for adding synchrony to a multi-party computation protocol, assuming that trapdoor functions exist. The n players jointly create a trapdoor key.
Reference: [29] <author> M. Blum, </author> <title> "How to prove a theorem so no one else can claim it," </title> <booktitle> Proc. of the International Congress of Mathematicians, </booktitle> <address> Berkeley, CA, </address> <year> 1986, </year> <pages> 1444-1451. 120 </pages>
Reference-contexts: By iterating this procedure, exponentially high confidence can be achieved by the verifier after a linear number of challenges. As an example of a cut-and-choose procedure, consider the following sketch of a zero-knowledge proof system for Hamiltonicity <ref> [29] </ref>. A Hamiltonian cycle in a graph is a set of edges that connects all vertices in a simple (non-self-intersecting) loop. Suppose that the prover wishes to convince the verifier that a graph G with n nodes has a Hamiltonian cycle.
Reference: [30] <author> M. Blum and S. Micali, </author> <title> "How to generate cryptographically strong sequences of pseudo random bits", </title> <journal> SIAM J. Comput. </journal> <volume> 13 (1984), </volume> <pages> 850-864. </pages>
Reference-contexts: The difficulty of the discrete logarithm problem is a standard cryptographic assumption first used by Diffie and Hellman [60] (on other basic uses and hard bits of the discrete log, see <ref> [30, 106] </ref>). A "communicating p.p.t. Turing Machine" is like a normal p.p.t.
Reference: [31] <author> M. Blum, U. Vazirani, and V. Vazirani, </author> <title> "Reducibility among protocols," </title> <booktitle> in Advances in Cryptology|CRYPTO '83 Proceedings, </booktitle> <pages> 137-146, </pages> <publisher> Plenum Press, </publisher> <year> 1984. </year>
Reference-contexts: Oblivious Transfer [26] [23] [34] is a fundamental two-party protocol that transfers a bit with uncertainty; it is discussed in more detail in Section 2.2.2. Secret exchange [28] <ref> [31] </ref> [107] [89] [140] is a two-party protocol that transfers a message in each direction with certainty; it is discussed in more detail in Section 2.4.4. Electronic money [38] [39] is a collection of protocols (e.g, withdrawal, purchase, deposit) that implement payment schemes without any physical requirements.
Reference: [32] <author> S. Brands, </author> <title> "Electronic cash systems based on the representation problem in groups of prime order," </title> <booktitle> in Advances in Cryptology|CRYPTO '93 Proceedings (Lecture Notes in Computer Science), </booktitle> <editor> ed. D. Stinson, </editor> <publisher> Springer-Verlag, </publisher> <address> New York (to appear). </address>
Reference-contexts: Subsequent to our work, other off-line coin schemes have also used line-based embedding schemes [71] <ref> [32] </ref>. Theorem 6.2 Under the Discrete Log Assumption, there exists a secure Embedding scheme Proof : Let p be a large prime such that p 1 has one large factor q, and let g 2 Z p . Let H be a hard bit for the discrete log.
Reference: [33] <author> G. Brassard, D. Chaum, and C. Crepeau, </author> <title> "Minimum disclosure proofs of knowledge," </title> <journal> J. Comput. System Sci. </journal> <month> 37 </month> <year> (1988) </year> <month> 156-189. </month>
Reference-contexts: The scheme is unalterable, since no element can be both a residue and a nonresidue; the scheme is unreadable by a polynomially bounded receiver under the QRA. Basic bit commitment requires that the receiver be polynomially-bounded. Another flavor of bit commitment, called "strong bit commitment" <ref> [33] </ref> [35] [115] allows the receiver to be unbounded.
Reference: [34] <author> G. Brassard, C. Crepeau, and J. Robert, </author> <title> "Information theoretic reductions among disclosure problems," </title> <booktitle> IEEE FOCS 1986, </booktitle> <pages> 168-173. </pages>
Reference-contexts: Oblivious Transfer [26] [23] <ref> [34] </ref> is a fundamental two-party protocol that transfers a bit with uncertainty; it is discussed in more detail in Section 2.2.2. Secret exchange [28] [31] [107] [89] [140] is a two-party protocol that transfers a message in each direction with certainty; it is discussed in more detail in Section 2.4.4. <p> There are many other types of Oblivious Transfer that have all been shown to be equivalent to the simple one <ref> [34] </ref> [54] [55]. One important alternative is called "1-2 Oblivious Transfer" [65] (abbreviated "1-2-OT"). In this version, player A begins with two secret bits b 0 and b 1 . Player B can choose to receive exactly one of these bits, without letting A know which bit was chosen.
Reference: [35] <author> G. Brassard, C. Crepeau, and M. Yung, </author> <title> "Perfectly concealing computationally convincing interactive proofs in constant rounds," </title> <note> Theoretical Computer Science (to appear). </note>
Reference-contexts: The scheme is unalterable, since no element can be both a residue and a nonresidue; the scheme is unreadable by a polynomially bounded receiver under the QRA. Basic bit commitment requires that the receiver be polynomially-bounded. Another flavor of bit commitment, called "strong bit commitment" [33] <ref> [35] </ref> [115] allows the receiver to be unbounded.
Reference: [36] <author> R. Breisch, </author> <title> "An intuitive approach to speleo-topology," </title> <booktitle> Southwestern Cavers (published by the Southwestern Region of the National Speleological Society) 6 (1967), </booktitle> <pages> 72-78. </pages>
Reference-contexts: Database maintenance was defined by Ostrovsky and Yung [122] under a mobile fault model, but assuming broadcast and a complete network of untappable channels. Our work on distributed database maintenance shows reductions between privacy and generalizations of graph searching games, a topic that has received much attention (e.g., <ref> [36] </ref> [110] [100] [104] [25]). Organization: In Section 4.2, we give the basic model of eavesdropping games. We consider the problem of secure message transmission in Section 4.3, and distributed database maintenance in Section 4.4. <p> At the end of every round, the adversary must not be able to predict the secrets with a success probability better than random guessing. 4.4.2 Characterization of Feasibility Node searching is a graph game with a long history <ref> [36] </ref> [123] [110] [100]. We generalize earlier formulations of the game as follows.
Reference: [37] <author> M. Burrows, M. Abadi, and R. Needham, </author> <title> "Authentication: A practical study in belief and action," </title> <booktitle> in Proceedings of the Second Conference on Theoretical Aspects of Reasoning about Knowledge, </booktitle> <editor> Moshe Vardi (ed.), </editor> <publisher> Morgan Kaufmann, </publisher> <year> 1988. </year>
Reference-contexts: Early work in the formalization of cryptographic protocols is also of interest. One approach is algebraic [62] [111], proving security by relating actual protocols homomorphically to theoretically perfect protocols. A second approach is logical <ref> [37] </ref>, proving security with respect to some reasonable axiomatization. Lastly, we mention some general notions that are related to secure distributed computing. Instance-hiding schemes [1] [13] involve a weak computational agent exploiting one or more strong but untrusted computational agents to compute a function for secret inputs.
Reference: [38] <author> D. Chaum, </author> <title> "Untraceable electronic mail, return addresses and digital pseudonyms," </title> <booktitle> CACM 24 (1981), </booktitle> <pages> 84-88. </pages>
Reference-contexts: Secret exchange [28] [31] [107] [89] [140] is a two-party protocol that transfers a message in each direction with certainty; it is discussed in more detail in Section 2.4.4. Electronic money <ref> [38] </ref> [39] is a collection of protocols (e.g, withdrawal, purchase, deposit) that implement payment schemes without any physical requirements. Secret-ballot election schemes [50] [19] [91] are essentially a special case of secure computation in which the function is a simple sum of ones and zeros.
Reference: [39] <author> D. Chaum, </author> <title> "Security without identification: transaction systems to make big brother obsolete," </title> <type> CACM 28, </type> <month> 10 (October </month> <year> 1985). </year>
Reference-contexts: Secret exchange [28] [31] [107] [89] [140] is a two-party protocol that transfers a message in each direction with certainty; it is discussed in more detail in Section 2.4.4. Electronic money [38] <ref> [39] </ref> is a collection of protocols (e.g, withdrawal, purchase, deposit) that implement payment schemes without any physical requirements. Secret-ballot election schemes [50] [19] [91] are essentially a special case of secure computation in which the function is a simple sum of ones and zeros. <p> motivated by the fact that, typically, such protocols are easily modifiable to produce a working practical variant (based perhaps on specialized assumptions and somewhat related heuristic tools, while keeping the basic protocol structure and computations). 100 6.1 Introduction 6.1.1 What is an Off-Line Electronic Coin Scheme? An electronic coin scheme <ref> [39] </ref> is a set of cryptographic protocols for withdrawal (by a customer from the bank), purchase (by a customer to a vendor while possibly involving the bank), and deposit (by a vendor to the bank), such that the security needs of all participants are satisfied: anonymity of purchase for the customer, <p> One direction is based on blind signatures, and the other is based on zero knowledge proofs of knowledge. Schemes Based on Blind Signatures A blind signature scheme of Chaum <ref> [39] </ref> is a protocol that enables one party (i.e., a customer) to receive a signature of a message of its choice under the second party's (i.e., the bank's) private signature key. The second party learns nothing about the message it helped to sign. <p> z 12 ; ; z jsj;1 ; z jsj;2 ]; h 1 ; ; h jsj ; i, the check for consistency is whether z i l;1 z l;2 = g h l mod p for each 1 l jsj. 2 6.5 Off-Line Coin Scheme Informally, an electronic coin scheme <ref> [39] </ref> is the simplest useful electronic payment system. Any customer can withdraw a coin from the bank, as the bank debits the customer's account. That coin can then be used to purchase from any vendor. The vendor will be able to trust that the coin is genuine.
Reference: [40] <author> D. Chaum, </author> <title> "The spymasters double-agent problem: multiparty computations secure unconditionally from minorities and cryptographically from majorities," </title> <booktitle> in Advances in Cryptology| CRYPTO '89 Proceedings (Lecture Notes in Computer Science, </booktitle> <volume> Vol. 435), </volume> <editor> ed. G. Brassard, </editor> <address> 591-601, </address> <publisher> Springer-Verlag, </publisher> <address> New York, </address> <year> 1990. </year>
Reference-contexts: This property suggests that computation that hides all inputs unconditionally might be possible, a suggestion which Section 2.5 confirms. This property can also be used in a clever way to achieve a "hybrid" computation protocol <ref> [40] </ref>, which protects both unconditionally (against a faulty minority) and cryptographically (against any faulty subset). <p> The only use of one-way functions is to guarantee the existence of pseudorandom generators, an equivalence shown by Impagliazzo, Levin and Luby [92] and H-astad [88]. 2.5.5 Hybrid Computation Protocols Chaum <ref> [40] </ref> combines both non-cryptographic and cryptographic computation into a single hybrid protocol. The security of this protocol is compromised only if both a majority of the players are faulty and the underlying cryptographic assumptions are violated.
Reference: [41] <author> D. Chaum, C. Crepeau, and I. Damg-ard, </author> <title> "Multiparty unconditionally secure protocols," </title> <booktitle> ACM STOC 1988, </booktitle> <pages> 11-19. </pages>
Reference-contexts: O (n 2 C log jF j) round complexity: O (D) Table 2.6: Summary of Ben-Or, Goldwasser, and Wigderson 1988 (passive adversary) 2.5.2 Non-cryptographic Protocols versus Passive Adversaries The first two papers suggesting general non-cryptographic distributed computation are by Ben-Or, Goldwasser and Wigderson [22], and by Chaum, Crepeau, and Damg-ard <ref> [41] </ref>. Both papers present protocols for t-private computation whenever n &gt; 2t. Provided that all players obey the protocols perfectly, no minority of players can pool their knowledge at the end of the protocol to gain further information about the honest players' inputs. <p> The first two [22] <ref> [41] </ref> achieve t-resilience whenever there are n &gt; 3t players, assuming a complete private network of channels. The last two [128] [12] achieve t-resilience when n &gt; 2t, but require a broadcast channel in addition to a complete private network, and must allow a small probability of error. <p> This can be done by private computation on shares of t + 1 (verifiably) degree t polynomials, in a manner similar to that used in the re-randomization step. Chaum, Crepeau and Damg-ard <ref> [41] </ref> also give a protocol for t-resilient computation whenever n &gt; 3t. There are several important similarities with the protocol of Ben-Or et al. First, this protocol also adapts a privacy-only protocol by overlaying verifiability subprotocols. <p> O (2 k ) bit complexity: O (n 6 k 3 jF j 4 log jF j) round complexity: O (D) Table 2.9: Summary of Beaver 1989 / Rabin and Ben-Or 1989 Since Byzantine Agreement requires that more than two-thirds of the players be honest, these two resilient protocols [22] <ref> [41] </ref> are the best possible for a network of private channels in the non-cryptographic setting. One natural question is whether the resilience can be increased by adding a broadcast channel. The affirmative answer was supplied T. Rabin and Ben-Or [128], and by Beaver [12], both building on ideas from T. <p> The computation of f fl is performed using the cryptographic protocol of Chaum, Damg-ard, and Van de Graaf [42] (see Section 2.4.3), where all n players jointly determine all messages sent by player n + 1. They do this by running a non-cryptographic protocol (e.g., <ref> [41] </ref>) whenever a message from this "player" is needed. Recall from Section 2.4.3 that the cryptographic protocol of Chaum, Damg-ard, and Van de Graaf can protect one player's input unconditionally; here this protection is granted to the jointly maintained player. <p> Ostrovsky and Yung [121] demonstrate the necessity of a complete network of private channels for implementing private multiparty computation among computationally unbounded players (sufficiency was shown by [22] and <ref> [41] </ref>). They consider the problem of dealing one card from a four card deck to each of three players. <p> These solutions relied on unproven assumptions: the intractability of factoring, and the existence of trapdoor functions, respectively. Starting with Ben-Or, Goldwasser, and Wigderson [22], and Chaum, Crepeau, and Damg-ard <ref> [41] </ref>, more recent protocols have removed the reliance of multi-party protocols on unproven assumptions. These protocols rely instead on the physical assumption that untappable communication channels connect all pairs of processors; sometimes these are called "unconditional" or "non-cryptographic" protocols. <p> A multiplicative factor of k in the amortized communication complexity is gained; an additive factor of k in the number of faulty players tolerated is required. The same ideas can be applied to the private computation protocol due to Chaum, Crepeau, and Damg-ard <ref> [41] </ref> (over fields of the proper form). In BGW-priv, each player shares its secret input using Shamir's scheme. In our parallelization, each player multi-shares its k inputs using the (t k + 1; t + 1; k; n)-multi-sharing scheme from the proof of Theorem 3.1. <p> Other examples where systematic parallelization applies are the private and resilient protocols of Chaum, Crepeau, and Damg-ard <ref> [41] </ref>, the constant-round protocols of Bar-Ilan and Beaver [6], and the general network topology protocols of Dolev, Dwork, Waarts, and Yung [61]. 3.3.5 Computing "Similar Circuits" in Parallel We also note that our parallel techniques are useful when circuits that are similar but not identical are to be computed on different <p> Related Work: Information-theoretic security for distributed tasks has been studied for many adversarial models involving non-mobile faults, beginning with Ben-Or et al. [22] and Chaum et al. <ref> [41] </ref>. A characterization of which boolean functions are privately computable on a complete network versus non-mobile eavesdroppers was given by Chor and Kushilevitz [55]. Variants of the problems we consider have been defined elsewhere. <p> For example, if a number of parties are all plugged into a graph, then they can use the graph as a complete network of untappable channels. In this way, they can compute any function over a finite field privately using protocols secure against a passive adversary [22] <ref> [41] </ref>. To describe our results about message transmission in the plug-in model, we need the following definition.
Reference: [42] <author> D. Chaum, I. Damg-ard, and J. van de Graaf, </author> <title> "Multiparty computations ensuring privacy of each party's input and correctness of the result," </title> <booktitle> in Advances in Cryptology|CRYPTO '87 Proceedings (Lecture Notes in Computer Science, </booktitle> <volume> Vol. 293), </volume> <editor> ed. C. Pomerance, </editor> <address> 87-119, </address> <publisher> Springer-Verlag, </publisher> <address> New York, </address> <year> 1988. </year>
Reference-contexts: Any polynomial-sized circuit can then be evaluated by considering it to be a cascade of N C 1 subcircuits (and being careful to enforce consistency between inputs and outputs of connected subcircuits). Unlike the previous protocols, a protocol due to Chaum, Damg-ard, and Van de Graaf <ref> [42] </ref> for two-party secure computation has both parties contribute to the scrambling of the circuit. <p> for n 1, unconditional for 1 Error Prob: O (2 s ) bit complexity: poly (n; s; C) round complexity: O (ns + D) Table 2.4: Summary of Chaum, Damg-ard, and Van de Graaf 1987 In Section 2.3.2, a two-party cryptographic protocol due to Chaum, Damg-ard, and Van de Graaf <ref> [42] </ref> was mentioned in which both players contributed to the "scrambling" of the circuit (truth table), and then both players evaluated the scrambled circuit at their private inputs. A more general version of this protocol works for any number of players. <p> Here each player i chooses the random r i . The computation of f fl is performed using the cryptographic protocol of Chaum, Damg-ard, and Van de Graaf <ref> [42] </ref> (see Section 2.4.3), where all n players jointly determine all messages sent by player n + 1. They do this by running a non-cryptographic protocol (e.g., [41]) whenever a message from this "player" is needed. <p> This gives a total message complexity of O (n 2 C) encrypted bits. In the circuit-scrambling approach, each party takes a turn modifying the truth tables of the gates of the circuit. In the protocol of Chaum, Damg-ard, and van de Graaf <ref> [42] </ref>, each party can randomly permute the rows, and can randomly complement certain of the rows and columns of each truth table.
Reference: [43] <author> D. Chaum, A. Fiat, and M. Naor, </author> <title> "Untraceable electronic cash," </title> <booktitle> in Advances in Cryptology| CRYPTO '88 Proceedings (Lecture Notes in Computer Science, </booktitle> <volume> Vol. 403), </volume> <editor> ed. S. Goldwasser, </editor> <address> 319-327, </address> <publisher> Springer-Verlag, </publisher> <address> New York, </address> <year> 1990. </year> <month> 121 </month>
Reference-contexts: A coin scheme has the interesting "off-line" property <ref> [43] </ref> if the purchase protocol does not involve the bank; everyday non-digital money is of course off-line. <p> This can be done by combining the blind signature scheme with a zero knowledge proof [86, 81] or "cut-and-choose" check [125] that the message has the right form. The first off-line coin scheme, due to Chaum, Fiat, and Naor <ref> [43] </ref> takes this approach, using the blind signature scheme based on RSA [129]. This approach is efficient but heuristic; no proof of security has been given that relies on assumptions about RSA that are simple or natural. <p> authent twice-reveal once-conceal authent identity revealed authent identity concealed identity embedded witness of hint for identity embedded witness of identity embedded passport w/ Mechanism Embedding Authent Oblivious @ @ @R @ @ - ? only prior Embedding scheme for an efficient off-line coin scheme, due to Chaum, Fiat, and Naor <ref> [43] </ref>, hides the secret in a collection of nested one-way functions that each hide a pair of xor shares of the secret. A hint of the witness is a particular "de-nesting" of the functions in a way that reveals one xor share from each pair ("hint" of the witness). <p> r), then it is easy to determine from z; h; i whether they are consistent (i.e., whether there exist s; r such that z = e (s; r) while h = W (s; r; i)). 112 6.4.2 Heuristic Implementation of Embedding Scheme The cut-and-choose scheme of Chaum, Fiat, and Naor <ref> [43] </ref> is a heuristic embedding scheme. Let f and g be two-argument collision-free functions, such that f is "similar to a random oracle", and such that g is one-to-one when its first argument is fixed. <p> The vendor is guaranteed that any acceptable purchase will lead to an acceptable deposit. The bank is guaranteed that no number of withdrawals can lead to a greater number of deposits. In an off-line coin scheme <ref> [43] </ref>, the bank is not contacted during purchases. Thus protection against the same coin being reused with different vendors can only be guaranteed indirectly. Repeated purchases with the same coin will be accepted initially, but the customer will be caught after the vendors make their deposits.
Reference: [44] <author> D. Chaum and T. Pederson, </author> <title> "Wallet databases with observers," </title> <booktitle> in Advances in Cryptology| CRYPTO '92 Proceedings (Lecture Notes in Computer Science), </booktitle> <editor> ed. E. Brickell, </editor> <address> 90-106, </address> <publisher> Springer-Verlag, </publisher> <address> New York, </address> <year> 1993. </year>
Reference-contexts: In fact, refinements to their protocol [3] were later found to introduce security flaws [90], which underscores the risk of relying on heuristics. Other off-line coin schemes use blind signature schemes derived from Chaum and Pedersen <ref> [44] </ref>. It is also possible to implement blind signatures using general secure 2-party computation protocols [140], as shown by Pfitzmann and Waidner [124], building on work of Damg-ard [56].
Reference: [45] <author> B. Chor, M. Gereb-Graus, and E. Kushilevitz, </author> <title> "Private computations over the integers," </title> <booktitle> IEEE FOCS 1990, </booktitle> <pages> 335-344. </pages>
Reference: [46] <author> B. Chor, S. Goldwasser, S. Micali, and B. Awerbuch, </author> <title> "Verifiable secret sharing and achieving simultaneity in the presence of faults," </title> <booktitle> IEEE FOCS 1985, </booktitle> <pages> 383-395. </pages>
Reference-contexts: Notice that this protocol has two phases. The dealer distributes t-shares during a "sharing phase," and the players interpolate to recover the secret during a "recovery phase." Verifiable secret sharing (VSS), first introduced by Chor, Goldwasser, Micali, and Awerbuch <ref> [46] </ref>, is a form of secret sharing in which cheating by the dealer and some of the players cannot prevent the honest players from receiving valid shares of some unique recoverable secret.
Reference: [47] <author> B. Chor and E. Kushilevitz, </author> <title> "A zero-one law for boolean privacy," </title> <booktitle> ACM STOC 1989, </booktitle> <pages> 62-72. </pages>
Reference: [48] <author> R. Cleve, </author> <title> "Limits on the security of coin flips when half the processors are faulty," </title> <booktitle> ACM STOC 1986, </booktitle> <pages> 364-369. </pages>
Reference-contexts: If a function has a t-private protocol, n 2t, then it has an (n 1)-private protocol. Moreover, every such n-ary function is equivalent to an xor of n single-input functions. For the case of an active adversary, Cleve <ref> [48] </ref> has impossibility results for the much simpler problem of computing a single random bit.
Reference: [49] <author> R. Cleve, </author> <title> "Controlled gradual disclosure schemes for random bits and their applications," </title> <booktitle> in Advances in Cryptology|CRYPTO '89 Proceedings (Lecture Notes in Computer Science, </booktitle> <volume> Vol. 435), </volume> <editor> ed. G. Brassard, </editor> <address> 573-588, </address> <publisher> Springer-Verlag, </publisher> <address> New York, </address> <year> 1990. </year>
Reference-contexts: At the end of this process, each player learns enough linear dependencies to recover the output. Any premature termination leaves the adversary with only a negligible chance to guess one additional linear dependency. Cleve <ref> [49] </ref> shows how to extend the secret exchange protocol of Luby et al. to allow for a "controlled disclosure" of information. Rather than having each party's guess of the other's bit merely converge to the correct result, the rate of convergence can also be specified.
Reference: [50] <author> J. (Benaloh) Cohen and M. Fisher, </author> <title> "A robust and verifiable cryptographically secure election scheme," </title> <booktitle> IEEE FOCS 1985, </booktitle> <pages> 372-382. </pages>
Reference-contexts: Electronic money [38] [39] is a collection of protocols (e.g, withdrawal, purchase, deposit) that implement payment schemes without any physical requirements. Secret-ballot election schemes <ref> [50] </ref> [19] [91] are essentially a special case of secure computation in which the function is a simple sum of ones and zeros. Early work in the formalization of cryptographic protocols is also of interest.
Reference: [51] <author> D. Coppersmith, </author> <title> "Cheating at mental poker," </title> <booktitle> in Advances in Cryptology|CRYPTO '85 Proceedings (Lecture Notes in Computer Science, </booktitle> <volume> Vol. 218), </volume> <editor> ed. H. Williams, </editor> <address> 104-107, </address> <publisher> Springer-Verlag, </publisher> <address> New York, </address> <year> 1986. </year>
Reference-contexts: Bit commitment, a two-player version of secret sharing, is discussed in Section 2.1.4. Coin flipping [26] is a two-party protocol that arrives at a common random bit; this was one of the earliest cryptographic protocols. Mental poker [133] [105] <ref> [51] </ref> [85] [141] [73] [52] [53] is a protocol for producing, and partially applying, a random permutation (i.e., shu*e and deal a deck of cards); as evidenced by the number of references, this problem was something of a critical test case for the cryptography community as the notion of security grew
Reference: [52] <author> C. Crepeau, </author> <title> "A secure poker protocol that minimizes the effect of player coalitions," </title> <booktitle> in Advances in Cryptology|CRYPTO '85 Proceedings (Lecture Notes in Computer Science, </booktitle> <volume> Vol. 218), </volume> <editor> ed. H. Williams, </editor> <address> 73-86, </address> <publisher> Springer-Verlag, </publisher> <address> New York, </address> <year> 1986. </year>
Reference-contexts: Bit commitment, a two-player version of secret sharing, is discussed in Section 2.1.4. Coin flipping [26] is a two-party protocol that arrives at a common random bit; this was one of the earliest cryptographic protocols. Mental poker [133] [105] [51] [85] [141] [73] <ref> [52] </ref> [53] is a protocol for producing, and partially applying, a random permutation (i.e., shu*e and deal a deck of cards); as evidenced by the number of references, this problem was something of a critical test case for the cryptography community as the notion of security grew in sophistication over the
Reference: [53] <author> C. Crepeau, </author> <title> "A zero-knowledge poker protocol that achieves confidentiality of the players' strategy, or How to achieve an electronic poker face," </title> <booktitle> in Advances in Cryptology|CRYPTO '86 Proceedings (Lecture Notes in Computer Science, </booktitle> <volume> Vol. 263), </volume> <editor> ed. A. Odlyzko, </editor> <address> 239-247, </address> <publisher> Springer-Verlag, </publisher> <address> New York, </address> <year> 1987. </year>
Reference-contexts: Bit commitment, a two-player version of secret sharing, is discussed in Section 2.1.4. Coin flipping [26] is a two-party protocol that arrives at a common random bit; this was one of the earliest cryptographic protocols. Mental poker [133] [105] [51] [85] [141] [73] [52] <ref> [53] </ref> is a protocol for producing, and partially applying, a random permutation (i.e., shu*e and deal a deck of cards); as evidenced by the number of references, this problem was something of a critical test case for the cryptography community as the notion of security grew in sophistication over the years.
Reference: [54] <author> C. Crepeau, </author> <title> "Equivalence between two flavours of Oblivious Transfer," </title> <booktitle> in Advances in Cryptology|CRYPTO '87 Proceedings (Lecture Notes in Computer Science, </booktitle> <volume> Vol. 293), </volume> <editor> ed. C. Pomerance, </editor> <address> 350-354, </address> <publisher> Springer-Verlag, </publisher> <address> New York, </address> <year> 1988. </year>
Reference-contexts: There are many other types of Oblivious Transfer that have all been shown to be equivalent to the simple one [34] <ref> [54] </ref> [55]. One important alternative is called "1-2 Oblivious Transfer" [65] (abbreviated "1-2-OT"). In this version, player A begins with two secret bits b 0 and b 1 . Player B can choose to receive exactly one of these bits, without letting A know which bit was chosen. <p> In fact, secure distributed computation can be reduced to Oblivious Transfer [96] [15] [84], as will be discussed in later sections. To give a sim pler reduction now, the following scheme, due to Crepeau <ref> [54] </ref>, achieves bit commitment through oblivious transfer: 1. Player A chooses random b 1 ; ; b n such that b 1 b n = b. 2. Player A sends each b i , in order, to player B by oblivious transfer. <p> Kilian [96] shows how to base oblivious circuit evaluation solely on Oblivious Transfer as a primitive (black-box reduction). In Section 2.2.2, we showed Crepeau's bit commitment scheme based on Oblivious Transfer <ref> [54] </ref>. At the heart of Kilian's construction is a method for extending this commitment scheme so that any NP statement can be proven about committed bits in a zero-knowledge fashion (i.e., without revealing anything further about the committed bits).
Reference: [55] <author> C. Crepeau and J. Kilian, </author> <title> "Achieving oblivious transfer using weakened security assumptions," </title> <booktitle> IEEE FOCS 1988, </booktitle> <pages> 42-52. </pages>
Reference-contexts: There are many other types of Oblivious Transfer that have all been shown to be equivalent to the simple one [34] [54] <ref> [55] </ref>. One important alternative is called "1-2 Oblivious Transfer" [65] (abbreviated "1-2-OT"). In this version, player A begins with two secret bits b 0 and b 1 . Player B can choose to receive exactly one of these bits, without letting A know which bit was chosen. <p> For the case of a passive adversary, more is known about when a function does or does not have a t-private protocol among n players when n 2t. Chor and Kushilevitz <ref> [55] </ref> find a "gap" in the maximum level of privacy, in the non-cryptographic zero-error setting for boolean functions. If a function has a t-private protocol, n 2t, then it has an (n 1)-private protocol. Moreover, every such n-ary function is equivalent to an xor of n single-input functions. <p> A characterization of which boolean functions are privately computable on a complete network versus non-mobile eavesdroppers was given by Chor and Kushilevitz <ref> [55] </ref>. Variants of the problems we consider have been defined elsewhere. Secure message transmission was originally defined by Dolev et al. [61] under a mobile fault model, but assuming that many channels connect the sender and receiver.
Reference: [56] <author> I. Damg-ard, </author> <title> "Payment systems and credential mechanisms with provable security against abuse by individuals," </title> <booktitle> in Advances in Cryptology|CRYPTO '88 Proceedings (Lecture Notes in Computer Science, </booktitle> <volume> Vol. 403), </volume> <editor> ed. S. Goldwasser, </editor> <address> 328-335, </address> <publisher> Springer-Verlag, </publisher> <address> New York, </address> <year> 1990. </year>
Reference-contexts: Other off-line coin schemes use blind signature schemes derived from Chaum and Pedersen [44]. It is also possible to implement blind signatures using general secure 2-party computation protocols [140], as shown by Pfitzmann and Waidner [124], building on work of Damg-ard <ref> [56] </ref>. A circuit to compute signatures is jointly computed by the bank and the customer, with the bank contributing one input (secret signature key), the customer contributing the other input (message 101 to be signed), and the customer alone receiving the output (signed message).
Reference: [57] <author> A. DeSantis and G. Persiano, </author> <title> "Communication efficient zero-knowledge proofs of knowledge (with applications to electronic cash)," </title> <booktitle> STACS 1992, </booktitle> <pages> 449-460. 122 </pages>
Reference-contexts: In a non-interactive zero knowledge proof of knowledge <ref> [57] </ref>, a single message is sent (from prover to verifier); in this case, the two parties are assumed to share a random string. DeSantis and Persiano [57] show that, when non-interactive zero knowledge proofs of knowledge are possible, blind signatures are not necessary for an off-line coin scheme (see also [117]). <p> In a non-interactive zero knowledge proof of knowledge <ref> [57] </ref>, a single message is sent (from prover to verifier); in this case, the two parties are assumed to share a random string. DeSantis and Persiano [57] show that, when non-interactive zero knowledge proofs of knowledge are possible, blind signatures are not necessary for an off-line coin scheme (see also [117]). The basic idea is that the bank gives an ordinary signature to the customer, but no one ever sees that signature again.
Reference: [58] <author> Y. Desmedt, </author> <title> "Society and group oriented cryptography: A new concept," </title> <booktitle> in Advances in Cryptology|CRYPTO '87 Proceedings (Lecture Notes in Computer Science, </booktitle> <volume> Vol. 293), </volume> <editor> ed. C. Pomerance, </editor> <address> 120-127, </address> <publisher> Springer-Verlag, </publisher> <address> New York, </address> <year> 1988. </year>
Reference-contexts: The notion of group-oriented cryptography, in which the power of a secret key holder is distributed over a number of participants, was introduced by Desmedt <ref> [58] </ref>. Practical implementations of group-oriented public-key encryption were given by Desmedt and Frankel [59]. (See also the related notion of fair public-key encryption [112].) We extend their implementations to achieve additional useful properties.
Reference: [59] <author> Y. Desmedt and Y. Frankel, </author> <title> "Threshold cryptosystems," </title> <booktitle> in Advances in Cryptology| CRYPTO '89 Proceedings (Lecture Notes in Computer Science, </booktitle> <volume> Vol. 435), </volume> <editor> ed. G. Brassard, </editor> <address> 307-315, </address> <publisher> Springer-Verlag, </publisher> <address> New York, </address> <year> 1990. </year>
Reference-contexts: The notion of group-oriented cryptography, in which the power of a secret key holder is distributed over a number of participants, was introduced by Desmedt [58]. Practical implementations of group-oriented public-key encryption were given by Desmedt and Frankel <ref> [59] </ref>. (See also the related notion of fair public-key encryption [112].) We extend their implementations to achieve additional useful properties. Our scheme, which we call "additive joint encryption," can then be used to reduce the message complexity of cryptographic multi-party circuit evaluation. <p> Finally, we use the term additive joint encryption scheme to denote a secure, blindable, xor-homomorphic, witnessed probabilistic public-key joint encryption scheme. Desmedt and Frankel <ref> [59] </ref> consider "threshold" encryption, which is essentially a public-key joint encryption scheme for which any sufficiently large subset of parties can decrypt a message. We do not include this property in our definition, because it is not needed for our main application, secure circuit evaluation. <p> Compact Additive Joint Encryption In this section, we show how additive joint encryption can be implemented compactly, i.e., such that the size of an encrypted bit does not depend on the number of parties participating in the encryption. 5.4.1 Intuition of El-Gamal Based Scheme As shown by Desmedt and Frankel <ref> [59] </ref>, it is possible to construct a joint encryption scheme from El-Gamal's method of public-key encryption [64]. Although blindable, this scheme is not xor-homomorphic, and thus not an additive joint encryption scheme. <p> This can be done, for example, by incorporating the modified shadow generation scheme based on Lagrange interpolation developed by Desmedt and Frankel <ref> [59] </ref> (which is possible when g and N are chosen as described in the next section). 5.4.3 Security of El-Gamal Based Scheme Theorem 5.1 If El-Gamal encryption with a composite modulus is GM-secure, then our compact encryption scheme is GM-secure. <p> Specifically, McCurley's proof is based on the choices g = 16, N = pq, p = 8r + 3, q = 8s 1 (where r; s have special structure), and this meets the condition of Desmedt and Frankel <ref> [59] </ref> for their modified shadow generation scheme based on Lagrange interpolation (i.e., that g have odd order in Z fl N ). 5.5 Message-Efficient General-Purpose Secure Computation Several solutions have been found to the problem of securely evaluating an arbitrary boolean circuit under cryptographic assumptions, beginning with the work of Yao
Reference: [60] <author> W. Diffie and M. Hellman, </author> <title> "New directions in cryptography," </title> <journal> IEEE Transactions on Information Theory, </journal> <volume> 22(6): </volume> <pages> 644-654, </pages> <year> 1976. </year>
Reference-contexts: The security of the original El-Gamal public-key encryption scheme reduces to the difficulty of breaking an instance of the Diffie-Hellman key exchange scheme <ref> [60] </ref> (i.e., a problem that is no more difficult than but not known to be equivalent to the discrete log problem). <p> The difficulty of the discrete logarithm problem is a standard cryptographic assumption first used by Diffie and Hellman <ref> [60] </ref> (on other basic uses and hard bits of the discrete log, see [30, 106]). A "communicating p.p.t. Turing Machine" is like a normal p.p.t.
Reference: [61] <author> D. Dolev, C. Dwork, O. Waarts, and M. Yung, </author> <title> "Perfectly secure message transmission," </title> <booktitle> JACM 40 (1993), </booktitle> <pages> 17-47. </pages>
Reference-contexts: Some cryptographic protocols assume only a complete network of "oblivious transfer channels" (i.e., private channels that allow OT by some means), and in fact require no additional cryptographic assumptions. Some work has been done in the unconditional setting with incomplete networks of private channels [128] <ref> [61] </ref>. Adversaries: A player is considered "correct" if it follows its program exactly, engaging in no additional communication or computation beyond what is specified by the protocol, and keeping all of its private tapes private. <p> Other types of adversaries are seen less frequently in the secure distributed computing literature. Fail-stop adversaries [78] are active adversaries that are limited to withholding outgoing messages from a faulty processor. Independent adversaries <ref> [61] </ref> are two or more adversaries (e.g., one or more passive and one or more active) for a single protocol, which control possibly overlapping sets of faulty processors, and which possibly cannot communicate during the course of the protocol. <p> For most of the protocols discussed in this paper (but not all [122] <ref> [61] </ref>), there is either a single static passive adversary or a single static active adversary. 2.2.2 Basic Protocols This section describes two basic protocols that are useful primitives for secure distributed computation: Oblivious Transfer and Byzantine Agreement. <p> This capability can be spliced into previously discussed protocols to achieve the stated result. Dolev, Dwork, Waarts, and Yung <ref> [61] </ref> show how to attain the same result without any probability of error. <p> As a surprising special case, private addition over a finite subrange of integers can be n-private, over the positive integers can be at most b n1 2 c-private, but over all the integers cannot even be 1-private. Dolev, Dwork, Waarts, and Yung <ref> [61] </ref> give lower bounds on security versus connectivity for the simpler but related problem of perfectly secure message transmission through an untrusted network. <p> Other examples where systematic parallelization applies are the private and resilient protocols of Chaum, Crepeau, and Damg-ard [41], the constant-round protocols of Bar-Ilan and Beaver [6], and the general network topology protocols of Dolev, Dwork, Waarts, and Yung <ref> [61] </ref>. 3.3.5 Computing "Similar Circuits" in Parallel We also note that our parallel techniques are useful when circuits that are similar but not identical are to be computed on different sets of inputs. We have inexpensive protocols to split and join multi-shares. <p> A characterization of which boolean functions are privately computable on a complete network versus non-mobile eavesdroppers was given by Chor and Kushilevitz [55]. Variants of the problems we consider have been defined elsewhere. Secure message transmission was originally defined by Dolev et al. <ref> [61] </ref> under a mobile fault model, but assuming that many channels connect the sender and receiver. Database maintenance was defined by Ostrovsky and Yung [122] under a mobile fault model, but assuming broadcast and a complete network of untappable channels. <p> We will identify and discuss some specific natural settings in Section 4.5. 4.3 Secure Message Transmission 4.3.1 Problem In the secure message transmission problem (isolated as a fundamental primitive for secure computation by Dolev et al. <ref> [61] </ref>), two parties wish to communicate by using the graph (network of processors with eavesdropping bugs) as a communication channel. <p> In the fifth step of every round, including the last round, nodes that are output ports may send messages to the receiver y. Secure message transmission is a primitive from which more general protocols can be built <ref> [61] </ref>. For example, if a number of parties are all plugged into a graph, then they can use the graph as a complete network of untappable channels. In this way, they can compute any function over a finite field privately using protocols secure against a passive adversary [22] [41].
Reference: [62] <author> D. Dolev and A. Yao, </author> <title> "On the security of public key protocols," </title> <booktitle> ACM FOCS 1981, </booktitle> <pages> 350-357. </pages>
Reference-contexts: Secret-ballot election schemes [50] [19] [91] are essentially a special case of secure computation in which the function is a simple sum of ones and zeros. Early work in the formalization of cryptographic protocols is also of interest. One approach is algebraic <ref> [62] </ref> [111], proving security by relating actual protocols homomorphically to theoretically perfect protocols. A second approach is logical [37], proving security with respect to some reasonable axiomatization. Lastly, we mention some general notions that are related to secure distributed computing.
Reference: [63] <author> J. Edmonds and R. Karp, </author> <title> "Theoretical improvements in algorithmic efficiency for network flow problems," </title> <booktitle> JACM 19 (1972), </booktitle> <pages> 248-264. </pages>
Reference: [64] <author> T. El-Gamal, </author> <title> "A public key cryptosystem and a signature scheme based on discrete logarithms," </title> <journal> IEEE Transactions on Information Theory, </journal> <volume> 31: </volume> <pages> 469-472, </pages> <year> 1985. </year>
Reference-contexts: compactly, i.e., such that the size of an encrypted bit does not depend on the number of parties participating in the encryption. 5.4.1 Intuition of El-Gamal Based Scheme As shown by Desmedt and Frankel [59], it is possible to construct a joint encryption scheme from El-Gamal's method of public-key encryption <ref> [64] </ref>. Although blindable, this scheme is not xor-homomorphic, and thus not an additive joint encryption scheme. However, we can convert this into an additive joint encryption scheme for which the size of an encryption is independent of the number of parties.
Reference: [65] <author> S. Even, O. Goldreich, and A. Lempel, </author> <title> "A randomized protocol for signing contracts," </title> <booktitle> CACM 28 (1985), </booktitle> <pages> 637-647. </pages>
Reference-contexts: There are many other types of Oblivious Transfer that have all been shown to be equivalent to the simple one [34] [54] [55]. One important alternative is called "1-2 Oblivious Transfer" <ref> [65] </ref> (abbreviated "1-2-OT"). In this version, player A begins with two secret bits b 0 and b 1 . Player B can choose to receive exactly one of these bits, without letting A know which bit was chosen. <p> Since the m ij values are random, a single element from a pair yields no useful information. Note that trapdoor permutations are needed in this protocol to implement 1-2-OT (via a construction due to Even, Goldreich, and Lempel <ref> [65] </ref>). Galil, Haber, and Yung [78] show how to reduce further the complexity assumption from trapdoor permutation to one-way function plus Oblivious Transfer. As before, one player is the "circuit" constructor, and the other is the "circuit" evaluator.
Reference: [66] <author> S. Even, O. Goldreich, and S. Micali, </author> <title> "On-line/off-line digital signatures," </title> <booktitle> in Advances in Cryptology|CRYPTO '89 Proceedings (Lecture Notes in Computer Science, </booktitle> <volume> Vol. 435), </volume> <editor> ed. G. Brassard, </editor> <address> 263-275, </address> <publisher> Springer-Verlag, </publisher> <address> New York, </address> <year> 1990. </year>
Reference-contexts: When Oblivious Authentication is realized in this way with an inefficient preparatory stage and an efficient main stage, it has a form similar to the "on-line/off-line" signature scheme of Even, Goldreich, and Micali <ref> [66] </ref>. 6.1.7 Structure of the Chapter Preliminary definitions and notions are given in Section 6.2. Oblivious Authentication is covered in Section 6.3, and Embedding schemes in Section 6.4. Section 6.5 covers off-line coins in a way that relates the notion to the previous two primitives.
Reference: [67] <author> S. Even, O. Goldreich, and Y. Yacobi, </author> <title> "Electronic Wallet," </title> <booktitle> in Advances in Cryptology| CRYPTO '83 Proceedings, </booktitle> <pages> 383-386, </pages> <publisher> Plenum Press, </publisher> <year> 1984. </year>
Reference-contexts: This agent, which we call a "trusted manufacturer" might fill each user's smart card memory once with a large number of strings, and then destroy its records. Unlike some physically based schemes <ref> [67] </ref>, the smart card memory does not need to be shielded in any way from the 104 owner of the smart card (i.e., no read or write restrictions are needed).
Reference: [68] <author> T. Feder, E. Kushilevitz, and M. Naor, </author> <title> "Amortized communication complexity," </title> <booktitle> IEEE FOCS 1991, </booktitle> <pages> 239-248. </pages>
Reference-contexts: Recently, and independently, Kushilevitz [102] has studied the communication complexity of multi-party private addition (see our Lemma 3.2). One basic question addressed by this chapter is the "direct sum problem" for the communication complexity of secure computation (recently addressed in the "non-secure" setting by Feder, Kushilevitz, and Naor <ref> [68] </ref>), i.e., when can parallelization reduce the amortized complexity of secure computation? We show that the answer is "sometimes," "sometimes not," and "almost always," depending (of course) on security setting and fault-tolerance tradeoffs. <p> It is natural to consider whether this cost is necessary, i.e., can a reduction in amortized bit complexity ever be achieved without affecting any other parameters? This is a version of the "direct-sum problem." The direct-sum problem for communication complexity has been considered recently by Feder, Kushilevitz, and Naor <ref> [68] </ref>. We present the first such results, one positive and one negative, for this problem for secure computation. We concentrate on the addition function.
Reference: [69] <author> U. Feige, A. Fiat, and A. Shamir, </author> <title> "Zero-Knowledge Proofs of Identity," </title> <journal> J. </journal> <note> Cryptology 1 (1988) 77-94. </note>
Reference-contexts: The use of validation in secure distributed computation protocol will be seen in Sections 2.4.3 and 2.5.3. We also mention zero-knowledge proof of knowledge <ref> [69] </ref> [136], in which the verifier is convinced that the prover holds an undisclosed witness for language membership; these proof systems are also important in the context of protocol validation. 2.1.6 Secret Sharing and Verifiable Secret Sharing Underlying many recent results in secure distributed computing is a secret sharing scheme due <p> Efficiency of protocols, which is a notion we try to capture in this work, can be formalized by requiring that "the communication complexity of the protocol is independent of the computational complexity of the honest participants". In schemes which lead to practical implementations, like identification schemes <ref> [69] </ref> [72] and basic practical operations like signature and encryption, this is the case (the communication is a low-degree polynomial function of the security parameter and the input size). <p> How reasonable is this assumption? Many cryptographic systems need a trusted center. Any complete public key system needs a trusted center of our kind to certify the connection between keys and users without risking impersonation attacks. The zero-knowledge identification scheme of Feige, Fiat, and Shamir <ref> [69] </ref> uses a trusted center to publish a modulus with unknown factorization and to maintain a public key directory; in the "keyless" version of their system, the trusted center issues tamper-resistant (unreadable, unwritable) smart cards to all participants.
Reference: [70] <author> P. Feldman and S. Micali, </author> <title> "Optimal algorithms for Byzantine agreement," </title> <booktitle> ACM STOC 1988, </booktitle> <pages> 148-161. </pages>
Reference-contexts: and knowing the private inputs of the faulty players; or (2) prevent any honest player from having the correct result on its output tape at the end of the protocol. 1 A fast probabilistic protocol for Byzantine Agreement in a network of private channels is due to Feldman and Micali <ref> [70] </ref>; this is closer to the model that we consider in this paper. 19 Note that the notion of "correct result" in the definition of t-resiliency is not straightforward. <p> More interestingly, if the adversary is active, then each broadcast can also be simulated on a private network if there are sufficiently few faulty players. Using Byzantine Agreement [103] <ref> [70] </ref>, a t-resilient protocol that requires a broadcast channel can be converted into a t-resilient protocol that needs only a network of private channels, whenever n &gt; 3t. 2.2.4 Unifying Protocol Models Rather than proving the above properties directly and individually, one may try to somehow capture all of the "good"
Reference: [71] <author> N. Ferguson, </author> <title> "Extensions of single-term coins," </title> <booktitle> in Advances in Cryptology|CRYPTO '93 Proceedings (Lecture Notes in Computer Science), </booktitle> <editor> ed. D. Stinson, </editor> <publisher> Springer-Verlag, </publisher> <address> New York (to appear). </address>
Reference-contexts: Subsequent to our work, other off-line coin schemes have also used line-based embedding schemes <ref> [71] </ref> [32]. Theorem 6.2 Under the Discrete Log Assumption, there exists a secure Embedding scheme Proof : Let p be a large prime such that p 1 has one large factor q, and let g 2 Z p . Let H be a hard bit for the discrete log.
Reference: [72] <author> A. Fiat and A. Shamir, </author> <title> "How to prove yourself: Practical solutions to identification and signature problems," </title> <booktitle> in Advances in Cryptology|CRYPTO '86 Proceedings (Lecture Notes in Computer Science, </booktitle> <volume> Vol. 263), </volume> <editor> ed. A. Odlyzko, </editor> <address> 186-194, </address> <publisher> Springer-Verlag, </publisher> <address> New York, </address> <year> 1987. </year> <month> 123 </month>
Reference-contexts: Efficiency of protocols, which is a notion we try to capture in this work, can be formalized by requiring that "the communication complexity of the protocol is independent of the computational complexity of the honest participants". In schemes which lead to practical implementations, like identification schemes [69] <ref> [72] </ref> and basic practical operations like signature and encryption, this is the case (the communication is a low-degree polynomial function of the security parameter and the input size).
Reference: [73] <author> S. Fortune and M. Merritt, </author> <title> "Poker protocols," </title> <booktitle> in Advances in Cryptology|CRYPTO '84 Proceedings (Lecture Notes in Computer Science), </booktitle> <pages> 454-464, </pages> <publisher> Springer-Verlag, </publisher> <address> New York, </address> <year> 1985. </year>
Reference-contexts: Bit commitment, a two-player version of secret sharing, is discussed in Section 2.1.4. Coin flipping [26] is a two-party protocol that arrives at a common random bit; this was one of the earliest cryptographic protocols. Mental poker [133] [105] [51] [85] [141] <ref> [73] </ref> [52] [53] is a protocol for producing, and partially applying, a random permutation (i.e., shu*e and deal a deck of cards); as evidenced by the number of references, this problem was something of a critical test case for the cryptography community as the notion of security grew in sophistication over
Reference: [74] <author> M. Franklin, Z. Galil, and M. Yung, </author> <title> "Eavesdropping games: A graph-theoretic approach to privacy in distributed systems," </title> <booktitle> IEEE FOCS 1993, </booktitle> <pages> 670-679. </pages>
Reference-contexts: The results from Chapter 4 are covered in "Eavesdropping games: a graph-theoretic approach to privacy in distributed systems," which is joint work with Zvi Galil and Moti Yung, and appears in the 1993 FOCS conference proceedings <ref> [74] </ref>. The results in Chapter 5 are discussed in "Joint encryption and message efficient secure computation," which is joint work with Stuart Haber, and appears in the 1993 Crypto conference proceedings [75].
Reference: [75] <author> M. Franklin and S. Haber, </author> <title> "Joint encryption and message-efficient secure computation," </title> <booktitle> in Advances in Cryptology|CRYPTO '93 Proceedings (Lecture Notes in Computer Science), </booktitle> <editor> ed. D. Stinson, </editor> <publisher> Springer-Verlag, </publisher> <address> New York (to appear). </address>
Reference-contexts: The results in Chapter 5 are discussed in "Joint encryption and message efficient secure computation," which is joint work with Stuart Haber, and appears in the 1993 Crypto conference proceedings <ref> [75] </ref>.
Reference: [76] <author> M. Franklin and M. Yung, </author> <title> "Communication complexity of secure computation," </title> <booktitle> ACM STOC 1992, </booktitle> <pages> 699-710. </pages>
Reference-contexts: Most of the results in this thesis have appeared previously in preliminary forms as extended abstracts at various conferences. The work from Chapter 3 is discussed in "Communication complexity of secure computation," which is joint work with Moti Yung, and appears in the 1992 STOC conference proceedings <ref> [76] </ref>. The results from Chapter 4 are covered in "Eavesdropping games: a graph-theoretic approach to privacy in distributed systems," which is joint work with Zvi Galil and Moti Yung, and appears in the 1993 FOCS conference proceedings [74].
Reference: [77] <author> M. Franklin and M. Yung, </author> <title> "Secure and efficient off-line digital money," </title> <booktitle> Proc. 20th International Colloquium on Automata, Languages and Programming (ICALP 1993), Lund, </booktitle> <address> Sweden, </address> <month> July </month> <year> 1993, </year> <booktitle> Lecture Notes in Computer Science 700, </booktitle> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1993, </year> <pages> 265-276. </pages>
Reference-contexts: The research in Chapter 6 is covered in "Secure and efficient off-line digital cash," which is joint work with Moti Yung, and appears in the 1993 ICALP conference proceedings <ref> [77] </ref>. 7 Chapter 2 A Survey of Secure Distributed Computing Suppose that the heads of the Fortune 500 companies agree to cooperate in a comprehensive study of their collective financial health.
Reference: [78] <author> Z. Galil, S. Haber, and M. Yung, </author> <title> "Cryptographic computation: secure fault-tolerant protocols and the public-key model," </title> <booktitle> in Advances in Cryptology|CRYPTO '87 Proceedings (Lecture Notes in Computer Science, </booktitle> <volume> Vol. 293), </volume> <editor> ed. C. Pomerance, </editor> <address> 135-155, </address> <publisher> Springer-Verlag, </publisher> <address> New York, </address> <year> 1988. </year>
Reference-contexts: Even within a single round, faulty players may be added dynamically, on the basis of messages and internal tapes of those players that have already been 17 corrupted. Other types of adversaries are seen less frequently in the secure distributed computing literature. Fail-stop adversaries <ref> [78] </ref> are active adversaries that are limited to withholding outgoing messages from a faulty processor. <p> Since the m ij values are random, a single element from a pair yields no useful information. Note that trapdoor permutations are needed in this protocol to implement 1-2-OT (via a construction due to Even, Goldreich, and Lempel [65]). Galil, Haber, and Yung <ref> [78] </ref> show how to reduce further the complexity assumption from trapdoor permutation to one-way function plus Oblivious Transfer. As before, one player is the "circuit" constructor, and the other is the "circuit" evaluator. <p> These shares are combined in the third stage to reveal only the output to all of the players. Another technique that is used by several of the protocols is to do "second-order" sharing, i.e., sharing of shares. This idea was first exploited by Galil, Haber, and Yung <ref> [78] </ref>, and is useful for allowing players to prove to one another that their actions are consistent and correct, as well as for enhancing fault tolerance. 26 Channel: broadcast only Adversary: t passive, t &lt; n Security: trapdoor function bit complexity: O (n 2 C) round complexity: O (n 2 D). <p> A total of O (n 2 ) swaps are necessary to maneuver each player's shares into adjacent locations. It is shown in the paper by Galil, Haber, and Yung <ref> [78] </ref> how to reduce the intractability assumption from the existence of trapdoor functions to the existence of one-way functions and a subprotocol for Oblivious Transfer. <p> In each of the two preceding multi-party cryptographic protocols, a simpler two-party protocol was repeated many times: permutation "swapping" for [82] "and-xoring," i.e., f ((x; y); z) = x (y ^ z) for <ref> [78] </ref>. In each case, a general protocol for two-party secure computation was then invoked to establish that the complete multi-party protocol was possible. Goldreich and Vainish [83] observe that general two-party secure computation is unnecessary for these two specific cases. <p> In a kinder world, even a suspected cheater's secret input would remain secret, and rehabilitation (i.e., reentry into an ongoing protocol) would be possible. Galil, Haber, and Yung <ref> [78] </ref> show how to modify the active adversary of Goldreich, Micali, and Wigderson to achieve this kinder world. The key idea is to use secondary shares (shares of shares) in the first stage of the protocol. <p> Yao [140] first defined fairness for two-party computation protocols for boolean functions. Informally, a two-party protocol is fair if neither player can violate the protocol in such a way that the violator learns the output while the other player is unable to learn it. Galil, Haber, and Yung <ref> [78] </ref> extend the notion of fairness to multi-party computation, where it is called "synchrony." Suppose that there are n players and that there is an active adversary. <p> First, this protocol also adapts a privacy-only protocol by overlaying verifiability subprotocols. Second, an important part of both protocols is that players operate on shares of shares of secrets. This is a technique that was first used in the cryptographic setting by Galil, Haber, and Yung <ref> [78] </ref> to tolerate faults without revealing inputs of faulty parties. There are also some significant differences between the two solutions. <p> In the gate-by-gate approach, each gate of the circuit is computed by having each pair of the n parties perform a private two-party protocol. In the protocol of Galil, Haber, and Yung <ref> [78] </ref>, with efficiency improvements by Goldreich and Vainish [83], each two-party protocol is a single instance of "One out of Two Oblivious Transfer" (1-2-OT).
Reference: [79] <author> M. Garey, D. Johnson, and L. Stockmeyer, </author> <title> "Some simplified NP-complete graph problems," </title> <booktitle> Theoretical Computer Science 1 (1976), </booktitle> <pages> 237-267. </pages>
Reference-contexts: The adversary can then succeed by occupying I 2 [ I 3 throughout the protocol. 2 Claim 4.1 : The decision problem for secure message transmission feasibility in the plug-in model is co-NP-complete Proof : The proof is by reduction from the complement of MIN EDGE-CUT INTO EQUAL-SIZED SUBSETS <ref> [79] </ref>. Let (G; k) be an instance of this latter decision problem, i.e., does there exist a set of fewer than k edges whose removal splits G = (V; E) into two subgraphs with jV j=2 nodes each? We construct an instance of the former decision problem as follows.
Reference: [80] <author> O. Goldreich and L. Levin, </author> <title> "A hard-core predicate for all one-way functions," </title> <booktitle> STOC 1989, </booktitle> <pages> 25-32. </pages>
Reference-contexts: Goldreich and Levin <ref> [80] </ref> showed that every one-way function has a hard bit.
Reference: [81] <author> O. Goldreich, S. Micali, and A. Wigderson, </author> <title> "Proofs that yield nothing but their validity and a methodology of cryptographic protocol design," </title> <booktitle> IEEE FOCS 1986, </booktitle> <pages> 174-187. </pages>
Reference-contexts: When one player has a secret circuit and the other player has non-secret data (or vice versa), then the problem of secure distributed computing reduces to a "minimum-knowledge" (or "zero-knowledge") circuit simulation, solved in the general case by <ref> [81] </ref>, and later improved by [95]. More will be said about zero-knowledge protocols in Section 2.1.5. Organization of the Chapter The next section of this chapter gives short descriptions of cryptographic and other primitives that are used in the upcoming protocols. <p> The main importance of zero-knowledge proof systems to secure distributed computation arises from the fact that every language in NP has a zero-knowledge proof system under the assumption that a one-way function exists (first shown by Goldreich, Micali and Wigderson <ref> [81] </ref> under the assumption that trapdoor permutations exist). In particular, the set of correct messages that can be sent by any player at any moment under any protocol is a language in NP. <p> Consider the set of all legal messages that can be sent at a given moment in the course of a protocol. As this is a language in NP, the actual message sent can be followed by a zero-knowledge proof of membership <ref> [81] </ref>. This "validates" the message without compromising security. In fact, a zero-knowledge proof of knowledge of membership suffices to validate each message in the protocol. This subsection is divided into three further subsubsections. The first describes multi-party computation in the presence of a passive ("gossiping only") adversary. <p> For use in an off-line coin scheme, the bank must be sure that the message it never sees has a certain form (i.e., that it embeds the customer's identity in the proper way). This can be done by combining the blind signature scheme with a zero knowledge proof <ref> [86, 81] </ref> or "cut-and-choose" check [125] that the message has the right form. The first off-line coin scheme, due to Chaum, Fiat, and Naor [43] takes this approach, using the blind signature scheme based on RSA [129].
Reference: [82] <author> O. Goldreich, S. Micali, and A. Wigderson, </author> <title> "How to play any mental game," </title> <booktitle> ACM STOC 1987, </booktitle> <pages> 218-229. </pages>
Reference-contexts: This reduces to function evaluation when, for each pair of inputs, there is only one element of the output distribution with non-zero probability. Assuming the intractability of factoring, Yao shows that every two-party interactive computational problem has a private protocol. Goldreich, Micali, and Wigderson <ref> [82] </ref> show how to weaken the intractability assumption from factoring to the existence of any trapdoor permutation. In fact, their protocol solves the following slightly different, but equivalent, problem of "combined oblivious transfer." There are two parties A and B, with private input bits a and b respectively. <p> Moreover, some of the solutions do rely on reducing the computation to a series of two-party computations, but in a more sophisticated manner. All of the protocols described in this subsection follow the three-stage paradigm introduced by Goldreich, Micali, and Wigderson <ref> [82] </ref>: an input sharing stage, a computation stage, and an output reconstruction stage. The idea is that computation is performed on shares of private inputs, ultimately producing shares of the final answer. These shares are combined in the third stage to reveal only the output to all of the players. <p> Table 2.1: Summary of Goldreich, Micali, and Wigderson 1987 (passive adversary) Some protocols (beginning with the results of Goldreich, Micali, and Wigderson <ref> [82] </ref>) that protect against an active adversary use zero-knowledge proofs in the course of the computation. As described in an earlier section, every language in NP has a zero-knowledge proof system. Such a proof system allows anyone to demonstrate membership in the language without leaking any additional information. <p> is denoted by D, and B Z (k) and R Z (k) denote the bit complexity and round complexity of a message validation via zero-knowledge proof (with security parameter k). 2.4.2 Multi-Party Cryptographic Protocols versus Passive Adversaries A two-party protocol for any two-input computation, due to Goldreich, Micali, and Wigderson <ref> [82] </ref>, was presented in Section 2.3.2. That protocol assumed only the existence of any trapdoor function. In the same paper, multi-party computation is reduced to a succession of two-input computations, in such a way that privacy is maintained. <p> Simple (boolean) algebra will verify that this gives each player an xor share of a ^ b. In each of the two preceding multi-party cryptographic protocols, a simpler two-party protocol was repeated many times: permutation "swapping" for <ref> [82] </ref> "and-xoring," i.e., f ((x; y); z) = x (y ^ z) for [78]. In each case, a general protocol for two-party secure computation was then invoked to establish that the complete multi-party protocol was possible. <p> 29 Channel: broadcast only Adversary: t active, t &lt; n=2 Security: trapdoor function Error Prob: O (2 k ) bit complexity: O (B Z (k)n 2 C) round complexity: O (R Z (k)n 2 D) Table 2.3: Summary of Goldreich, Micali, and Wigderson 1987 (active adversary) Goldreich, Micali, and Wigderson <ref> [82] </ref> show how to modify their multi-party private protocol to achieve a multi-party resilient protocol. In the first stage of the protocol, each player commits to its secret input and to the random bits (generated by the community of players) that it will use during the computation phase. <p> All non-cryptographic computation protocols described in this paper use this method in a "three-stage paradigm" <ref> [82] </ref>. First, each player shares his secret input with all other players using a Shamir polynomial. Second, all players perform some computation on these shares. Third, the results of this computation are combined to find the actual output. <p> The basic problem of designing protocols for arbitrary 50 arithmetic circuits was first solved for two processors by Yao [140], and for any number of processors by Goldreich, Micali, and Wigderson <ref> [82] </ref>. These solutions relied on unproven assumptions: the intractability of factoring, and the existence of trapdoor functions, respectively. Starting with Ben-Or, Goldwasser, and Wigderson [22], and Chaum, Crepeau, and Damg-ard [41], more recent protocols have removed the reliance of multi-party protocols on unproven assumptions. <p> The problem of securely evaluating an arbitrary boolean circuit under cryptographic assumptions has been much studied, beginning with the work of Yao [140] and Goldreich, Micali, and Wigderson <ref> [82] </ref>. The notion of group-oriented cryptography, in which the power of a secret key holder is distributed over a number of participants, was introduced by Desmedt [58]. <p> based on Lagrange interpolation (i.e., that g have odd order in Z fl N ). 5.5 Message-Efficient General-Purpose Secure Computation Several solutions have been found to the problem of securely evaluating an arbitrary boolean circuit under cryptographic assumptions, beginning with the work of Yao [140] and Goldreich, Micali, and Wigderson <ref> [82] </ref>.
Reference: [83] <author> O. Goldreich and R. Vainish, </author> <title> "How to solve any protocol problem an efficiency improvement," </title> <booktitle> in Advances in Cryptology|CRYPTO '87 Proceedings (Lecture Notes in Computer Science, </booktitle> <volume> Vol. 293), </volume> <editor> ed. C. Pomerance, </editor> <address> 73-86, </address> <publisher> Springer-Verlag, </publisher> <address> New York, </address> <year> 1988. </year>
Reference-contexts: In each case, a general protocol for two-party secure computation was then invoked to establish that the complete multi-party protocol was possible. Goldreich and Vainish <ref> [83] </ref> observe that general two-party secure computation is unnecessary for these two specific cases. Assuming a protocol for Oblivious Transfer, special-purpose private protocols can achieve the necessary aims directly. <p> In the gate-by-gate approach, each gate of the circuit is computed by having each pair of the n parties perform a private two-party protocol. In the protocol of Galil, Haber, and Yung [78], with efficiency improvements by Goldreich and Vainish <ref> [83] </ref>, each two-party protocol is a single instance of "One out of Two Oblivious Transfer" (1-2-OT). It is possible to implement two-party 1-2-OT privately using a constant number of encrypted bits under a cryptographic assumption (e.g., three encrypted bits suffice under the assumption that composite quadratic character is hard).
Reference: [84] <author> S. Goldwasser and L. Levin, </author> <title> "Fair computation of general functions in presence of immoral majority," </title> <booktitle> in Advances in Cryptology|CRYPTO '89 Proceedings (Lecture Notes in Computer Science, </booktitle> <volume> Vol. 435), </volume> <editor> ed. G. Brassard, </editor> <address> 75-84, </address> <publisher> Springer-Verlag, </publisher> <address> New York, </address> <year> 1990. </year>
Reference-contexts: In addition to other versions of Oblivious Transfer, more sophis ticated protocols can be built from this primitive. In fact, secure distributed computation can be reduced to Oblivious Transfer [96] [15] <ref> [84] </ref>, as will be discussed in later sections. To give a sim pler reduction now, the following scheme, due to Crepeau [54], achieves bit commitment through oblivious transfer: 1. Player A chooses random b 1 ; ; b n such that b 1 b n = b. 2. <p> In this subsection, two proposals for such a definition are described. A third proposed definition, due to Goldwasser and Levin <ref> [84] </ref>, will not be discussed. One proposal to put this area on a more formal foundation is due to Beaver [11]. <p> Goldwasser and Levin <ref> [84] </ref> extend the gradual revelation technique from boolean values to arbitrary values, again assuming only oblivious transfer. Representing the output as a boolean string, the computation stage reveals the bitwise xor of the output with a jointly created random mask. After this, the random mask is gradually revealed.
Reference: [85] <author> S. Goldwasser and S. Micali, </author> <title> "Probabilistic encryption," </title> <journal> J. Comput. System Sci. </journal> <volume> 28 (1984), </volume> <pages> 270-299. </pages>
Reference-contexts: Bit commitment, a two-player version of secret sharing, is discussed in Section 2.1.4. Coin flipping [26] is a two-party protocol that arrives at a common random bit; this was one of the earliest cryptographic protocols. Mental poker [133] [105] [51] <ref> [85] </ref> [141] [73] [52] [53] is a protocol for producing, and partially applying, a random permutation (i.e., shu*e and deal a deck of cards); as evidenced by the number of references, this problem was something of a critical test case for the cryptography community as the notion of security grew in <p> over Z fl p since (1) ag r mod p is uniformly distributed for random r 2 Z fl p and (2) DLP p;g (a) = DLP p;g (ag r mod p) r. 2.1.2 Indistinguishable Probability Distributions The indistinguishability of probability distributions, due to Yao [139] and Goldwasser and Micali <ref> [85] </ref>, combines computational assumptions with randomness in a condition that is useful for defining the security of cryptographic primitives. Informally, two distributions are indistinguishable 10 if a guesser cannot tell them apart. This condition will be used in later subsections to define probabilistic encryption, bit commitment, and zero-knowledge proof systems. <p> Notice that repeated public-key encryption of the same message always yields the same result, i.e., some information about a message is always revealed to an eavesdropper. This leakage is eliminated by using Goldwasser and Micali's "probabilistic public-key encryption" <ref> [85] </ref>, of which the following is an example. If n is a product of two primes each congruent to 3 modulo 4, and if the Quadratic Residuosity Assumption holds, then the inverse of QRP n () is a one-to-many trapdoor function, where the factorization of n is the trapdoor key. <p> A joint public-key encryption scheme is probabilistic if each E S is probabilistic; we write E S (M ) to denote a uniformly random choice of possible encryptions of M . A probabilistic public-key joint encryption scheme is secure if each E S is GM-secure <ref> [85] </ref> (computational indistinguishability of ciphertexts, even given the decryption functions fD i : i 2 S 0 g for any S 0 S). <p> For example, each encryption function e i could be an instance of the scheme due to Goldwasser and Micali <ref> [85] </ref>, based on quadratic residues and nonresidues, using a distinct modulus N i . Let d i be the decryption function corresponding to e i . An additive joint encryption scheme can be constructed as follows.
Reference: [86] <author> S. Goldwasser, S. Micali, and C. Rackoff, </author> <title> "The knowledge complexity of interactive proof systems," </title> <journal> SIAM J. Comput. </journal> <volume> 18 (1989), </volume> <pages> 186-208. </pages>
Reference-contexts: In this case, unreadability requires that the two probability distributions be (almost) identical. 2.1.5 Interactive Proof Systems and Zero-Knowledge Proof An interactive proof system is a two-party protocol in which a "prover" conveys a convincing argument to a polynomially-bounded probabilistic "verifier;" this idea was introduced by Goldwasser, Micali, and Rackoff <ref> [86] </ref> and Babai [4]. <p> An interactive proof system for a language L is "computational zero-knowledge" <ref> [86] </ref> if the verifier learns nothing from the interaction except the validity of the proof, even if the verifier behaves in an arbitrarily adversarial (probabilistic polynomial-time) manner. This vague condition can be formalized in terms of the computational indistinguishability of ensembles of probability distributions. <p> For use in an off-line coin scheme, the bank must be sure that the message it never sees has a certain form (i.e., that it embeds the customer's identity in the proper way). This can be done by combining the blind signature scheme with a zero knowledge proof <ref> [86, 81] </ref> or "cut-and-choose" check [125] that the message has the right form. The first off-line coin scheme, due to Chaum, Fiat, and Naor [43] takes this approach, using the blind signature scheme based on RSA [129]. <p> Thus, a scheme of this type is secure, but definitely not efficient. Schemes Based on Zero Knowledge Proofs of Knowledge A zero knowledge proof of knowledge <ref> [86] </ref> is a protocol between a prover and a verifier, in which the verifier is convinced that the prover possesses a witness (e.g., for membership in a language) without learning anything about that witness.
Reference: [87] <author> S. Haber, </author> <title> "Multiparty cryptographic computation: techniques and applications," </title> <type> Ph.D. thesis, </type> <institution> Columbia University, </institution> <year> 1988. </year> <month> 124 </month>
Reference: [88] <author> J.T. Hastad, </author> <title> "Pseudo-random generators under uniform assumptions," </title> <booktitle> STOC 1990, </booktitle> <pages> 395-404. </pages>
Reference-contexts: A commitment by one party, followed by a guess by the second party, followed by a revelation by the first party, is equivalent to the flip of a coin. Naor [114] shows a general construction for basing bit commitment on any one-way function, based on earlier reductions [92] <ref> [88] </ref>. A more specific example of a bit commitment scheme is based on quadratic residuosity. <p> The input decryption keys serve as seeds for a pseudorandom number generator (which can be based on any one-way function [92] <ref> [88] </ref>) that returns the output decryption key (yet another seed for the generator). Kilian [96] shows how to base oblivious circuit evaluation solely on Oblivious Transfer as a primitive (black-box reduction). In Section 2.2.2, we showed Crepeau's bit commitment scheme based on Oblivious Transfer [54]. <p> The only use of one-way functions is to guarantee the existence of pseudorandom generators, an equivalence shown by Impagliazzo, Levin and Luby [92] and H-astad <ref> [88] </ref>. 2.5.5 Hybrid Computation Protocols Chaum [40] combines both non-cryptographic and cryptographic computation into a single hybrid protocol. The security of this protocol is compromised only if both a majority of the players are faulty and the underlying cryptographic assumptions are violated. <p> Let sig be a signature scheme that is existentially unforgeable against a chosen message attack; such a scheme exists if one way functions exist [116] [130]. Let E be a symmetric-key encryption function, which also exists if one way functions exist <ref> [92, 93, 88] </ref>. 108 row row link link wind half wind half window window - J J J J J @ @ @ @R A A A A A A AU J J J J J J^ H H H Hj 7 J J^ 7 S Sw - - & %
Reference: [89] <author> J. H-astad and A. Shamir, </author> <title> "The cryptographic security of truncated linearly related variables," </title> <booktitle> STOC 1985, </booktitle> <pages> 356-362. </pages>
Reference-contexts: Oblivious Transfer [26] [23] [34] is a fundamental two-party protocol that transfers a bit with uncertainty; it is discussed in more detail in Section 2.2.2. Secret exchange [28] [31] [107] <ref> [89] </ref> [140] is a two-party protocol that transfers a message in each direction with certainty; it is discussed in more detail in Section 2.4.4. Electronic money [38] [39] is a collection of protocols (e.g, withdrawal, purchase, deposit) that implement payment schemes without any physical requirements.
Reference: [90] <author> R. </author> <title> Hirschfeld, "Making electronic refunds safer," </title> <booktitle> in Advances in Cryptology|CRYPTO '92 Proceedings (Lecture Notes in Computer Science), </booktitle> <editor> ed. E. Brickell, </editor> <address> 107-113, </address> <publisher> Springer-Verlag, </publisher> <address> New York, </address> <year> 1993. </year>
Reference-contexts: This approach is efficient but heuristic; no proof of security has been given that relies on assumptions about RSA that are simple or natural. In fact, refinements to their protocol [3] were later found to introduce security flaws <ref> [90] </ref>, which underscores the risk of relying on heuristics. Other off-line coin schemes use blind signature schemes derived from Chaum and Pedersen [44].
Reference: [91] <author> M. Huang and S. Teng, </author> <title> "Security, verifiability, and universality in distributed computing," </title> <editor> J. </editor> <booktitle> Algorithms 11 (1990), </booktitle> <pages> 492-521. </pages>
Reference-contexts: Electronic money [38] [39] is a collection of protocols (e.g, withdrawal, purchase, deposit) that implement payment schemes without any physical requirements. Secret-ballot election schemes [50] [19] <ref> [91] </ref> are essentially a special case of secure computation in which the function is a simple sum of ones and zeros. Early work in the formalization of cryptographic protocols is also of interest. One approach is algebraic [62] [111], proving security by relating actual protocols homomorphically to theoretically perfect protocols.
Reference: [92] <author> R. Impagliazzo, L. Levin, and M. Luby, </author> <title> "Pseudorandom number generation from one-way functions," </title> <booktitle> ACM STOC 1989, </booktitle> <pages> 12-24. </pages>
Reference-contexts: A commitment by one party, followed by a guess by the second party, followed by a revelation by the first party, is equivalent to the flip of a coin. Naor [114] shows a general construction for basing bit commitment on any one-way function, based on earlier reductions <ref> [92] </ref> [88]. A more specific example of a bit commitment scheme is based on quadratic residuosity. <p> The constructed circuit consists of a number of "gates," each of which enables a single decryption key (output) to be recovered from the knowledge of two decryption keys (inputs). The input decryption keys serve as seeds for a pseudorandom number generator (which can be based on any one-way function <ref> [92] </ref> [88]) that returns the output decryption key (yet another seed for the generator). Kilian [96] shows how to base oblivious circuit evaluation solely on Oblivious Transfer as a primitive (black-box reduction). In Section 2.2.2, we showed Crepeau's bit commitment scheme based on Oblivious Transfer [54]. <p> In addition to one-way functions, this protocol requires a broadcast channel and a network of private channels, and allows an exponentially small probability of error. The only use of one-way functions is to guarantee the existence of pseudorandom generators, an equivalence shown by Impagliazzo, Levin and Luby <ref> [92] </ref> and H-astad [88]. 2.5.5 Hybrid Computation Protocols Chaum [40] combines both non-cryptographic and cryptographic computation into a single hybrid protocol. The security of this protocol is compromised only if both a majority of the players are faulty and the underlying cryptographic assumptions are violated. <p> Let sig be a signature scheme that is existentially unforgeable against a chosen message attack; such a scheme exists if one way functions exist [116] [130]. Let E be a symmetric-key encryption function, which also exists if one way functions exist <ref> [92, 93, 88] </ref>. 108 row row link link wind half wind half window window - J J J J J @ @ @ @R A A A A A A AU J J J J J J^ H H H Hj 7 J J^ 7 S Sw - - & %
Reference: [93] <author> R. Impagliazzo and M. Luby, </author> <title> "One-way functions are essential for complexity based cryptography," </title> <booktitle> IEEE FOCS 1989, </booktitle> <pages> 230-235. </pages>
Reference-contexts: By hiding his secret using the inverted value (i.e., by xoring it with an inner product of the inverted value and a public random value), the weaker player can recover the secret exactly half the time. For the symmetric case, Impagliazzo and Luby <ref> [93] </ref> show that one-way functions are necessary for bit commitment, and hence necessary for secure computation. This paper also shows that Oblivious Transfer implies the existence of one-way functions. <p> Let sig be a signature scheme that is existentially unforgeable against a chosen message attack; such a scheme exists if one way functions exist [116] [130]. Let E be a symmetric-key encryption function, which also exists if one way functions exist <ref> [92, 93, 88] </ref>. 108 row row link link wind half wind half window window - J J J J J @ @ @ @R A A A A A A AU J J J J J J^ H H H Hj 7 J J^ 7 S Sw - - & %
Reference: [94] <author> R. Impagliazzo and S. Rudich, </author> <title> "Limits on the provable consequences of one-way permutations," </title> <booktitle> ACM STOC 1989, </booktitle> <pages> 44-61. </pages>
Reference-contexts: For the symmetric case, Impagliazzo and Luby [93] show that one-way functions are necessary for bit commitment, and hence necessary for secure computation. This paper also shows that Oblivious Transfer implies the existence of one-way functions. However, due to a relativization result from Impagliazzo and Rudich <ref> [94] </ref>, it is unlikely that the sufficiency of one-way functions for secure symmetric computation can be shown (i.e., a proof that only used one-way functions in a "black-box" manner would prove P 6= N P ).
Reference: [95] <author> R. Impagliazzo, and M. Yung, </author> <title> "Direct minimum-knowledge computation," </title> <booktitle> in Advances in Cryptology|CRYPTO '87 Proceedings (Lecture Notes in Computer Science, </booktitle> <volume> Vol. 293), </volume> <editor> ed. C. Pomerance, </editor> <address> 40-51, </address> <publisher> Springer-Verlag, </publisher> <address> New York, </address> <year> 1988. </year>
Reference-contexts: When one player has a secret circuit and the other player has non-secret data (or vice versa), then the problem of secure distributed computing reduces to a "minimum-knowledge" (or "zero-knowledge") circuit simulation, solved in the general case by [81], and later improved by <ref> [95] </ref>. More will be said about zero-knowledge protocols in Section 2.1.5. Organization of the Chapter The next section of this chapter gives short descriptions of cryptographic and other primitives that are used in the upcoming protocols.
Reference: [96] <author> J. Kilian, </author> <title> "Founding cryptography on oblivious transfer," </title> <booktitle> ACM STOC 1988, </booktitle> <pages> 20-31. </pages>
Reference-contexts: Oblivious Transfer is one of the most basic possible primitives that can break the "knowledge symmetry" between two players. In addition to other versions of Oblivious Transfer, more sophis ticated protocols can be built from this primitive. In fact, secure distributed computation can be reduced to Oblivious Transfer <ref> [96] </ref> [15] [84], as will be discussed in later sections. To give a sim pler reduction now, the following scheme, due to Crepeau [54], achieves bit commitment through oblivious transfer: 1. Player A chooses random b 1 ; ; b n such that b 1 b n = b. 2. <p> The input decryption keys serve as seeds for a pseudorandom number generator (which can be based on any one-way function [92] [88]) that returns the output decryption key (yet another seed for the generator). Kilian <ref> [96] </ref> shows how to base oblivious circuit evaluation solely on Oblivious Transfer as a primitive (black-box reduction). In Section 2.2.2, we showed Crepeau's bit commitment scheme based on Oblivious Transfer [54]. <p> By a self-randomization trick (similar to the method used by Kilian for the two-party case <ref> [96] </ref>), this long product of matrices can be securely computed using only two secret matrix multiplications: Y = M 1 M 2 M N = R 0 (R 0 1 M 2 R 2 ) (R N1 1 1 : Thus, if the players jointly create and share random invertible matrices <p> In particular, they show that Oblivious Transfer is possible, in either direction, assuming the existence of one-way functions. Since Kilian <ref> [96] </ref> reduces two-party circuit evaluation to Oblivious Transfer, it follows that any asymmetric two-party computation is possible if one-way functions exist.
Reference: [97] <author> J. Kilian, </author> <title> "Uses of Randomness in Algorithms and Protocols," </title> <publisher> ACM Distinguished Dissertation, MIT Press, </publisher> <year> 1990. </year>
Reference-contexts: This subsection will survey what is known about reductions and complexity results for this problem, i.e., what is just as hard as, and what is impossible for, secure distributed computation. 2.6.1 Reductions Among Primitives Kilian <ref> [97] </ref> shows how to base two-party oblivious circuit evaluation on a black box for Oblivious Transfer. A sketch of this important reduction was given in Section 2.3.2. <p> Alternatively, pre-processing can be implemented inefficiently using a general secure 2-party 107 computation protocol between the requestor and the authenticator. As shown by Kilian <ref> [97] </ref>, the assumption that Oblivious Transfer [126] (a basic cryptographic primitive) is possible suffices. Intuitively, the pre-processing stage supplies encrypted windows, where each window presigns both a zero and a one for a given bit position in the message.
Reference: [98] <author> J. Kilian, </author> <title> "A general completeness theorem for two-party games," </title> <booktitle> ACM STOC 1991, </booktitle> <pages> 553-560. </pages>
Reference-contexts: A sketch of this important reduction was given in Section 2.3.2. In later work <ref> [98] </ref>, Kilian extends the reduction by establishing a necessary and sufficient condition for basing two-party oblivious circuit evaluation on a black box for securely computing some 2-ary function F .
Reference: [99] <author> L. Kirousis and C. Papadimitriou, </author> <title> "Interval graphs and searching," </title> <note> Discrete Mathematics 55 (1985) 181-184. </note>
Reference-contexts: The node search number of a graph versus arbitrarily fast recontamination (I/fl/fl setting) has been shown to be connected to other topological properties of the graph (e.g., vertex separator [100], interval thickness <ref> [99] </ref>, topological bandwidth [108], cutwidth [108]).
Reference: [100] <author> L. Kirousis and C. Papadimitriou, </author> <title> "Searching and pebbling," </title> <booktitle> Theoretical Computer Science 47 (1986), </booktitle> <pages> 205-218. </pages>
Reference-contexts: Our work on distributed database maintenance shows reductions between privacy and generalizations of graph searching games, a topic that has received much attention (e.g., [36] [110] <ref> [100] </ref> [104] [25]). Organization: In Section 4.2, we give the basic model of eavesdropping games. We consider the problem of secure message transmission in Section 4.3, and distributed database maintenance in Section 4.4. The sensitivity of the database problem to the choice of mobility setting is addressed in Section 4.5. <p> At the end of every round, the adversary must not be able to predict the secrets with a success probability better than random guessing. 4.4.2 Characterization of Feasibility Node searching is a graph game with a long history [36] [123] [110] <ref> [100] </ref>. We generalize earlier formulations of the game as follows. At the start of the game, all edges of a graph are contaminated and guards occupy some nodes; the contaminated edges may be viewed as the possible locations of a fugitive that the guards are attempting to capture. <p> This definition of node searching is more general than earlier formulations (e.g., <ref> [100] </ref>). In earlier work on node searching, the contamination is typically assumed to spread as far as possible after each round of guard movement (i.e., stopping only where blocked by guards); this may be viewed as searching for a very fast fugitive. <p> Having the guards move once every jV j rounds is equivalent to allowing the contamination to spread arbitrarily fast every round, i.e., the original node search model due to Kirousis and Papadimitriou <ref> [100] </ref>. The following theorem can then be proven from the result of LaPaugh [104] that "recontamination doesn't help" in these settings, i.e., for any successful search there is a search without recontamination using the same number of guards (proof omitted). <p> The node search number of a graph versus arbitrarily fast recontamination (I/fl/fl setting) has been shown to be connected to other topological properties of the graph (e.g., vertex separator <ref> [100] </ref>, interval thickness [99], topological bandwidth [108], cutwidth [108]). <p> Since k = O (log n), these recurrences imply that the size (and search time) of G n is polynomial in n. A full ternary tree of height h requires h + 1 guards to node search in any I/fl/fl setting (by a theorem of Kirousis and Papadimitriou <ref> [100] </ref>). Since adding edges to a graph cannot decrease the search number in an I/fl/fl setting, each G n requires (log n) guards to search in any I/fl/fl setting. 2 For the family of graphs used to prove Theorem 4.5, success depends critically on the length of paths between subgraphs. <p> We know that this problem is in general PSPACE-complete, but it is interesting to consider the problem for natural settings. A complete answer can be given for Infrequent settings, and a partial answer for Frequent settings. By the NP-completeness of node searching as defined by Kirousis and Papadimitriou <ref> [100] </ref> [104] [110], together with Theorems 4.3 and 4.4, we can show the following claim (proof omitted). Claim 4.5 The node search decision problem in an I/fl/fl setting is NP-complete.
Reference: [101] <author> E. Kushilevitz, </author> <title> "Privacy and communication complexity," </title> <booktitle> IEEE FOCS 1989, </booktitle> <pages> 416-421. </pages>
Reference-contexts: For two player non-cryptographic protocols, a complete characterization of privately computable general functions (i.e., non-boolean) is given independently by Kushilevitz <ref> [101] </ref> and by Beaver [10]. <p> Another open question is the characterization of privately-computed multi-input functions. The two-input privately-computable functions have been completely characterized [10] <ref> [101] </ref>. A third open question is a more general question of efficiency. Most of the secure distributed computation schemes described in this paper are designed to be applicable to any possible function. <p> Since communication is a crucial resource, it is both natural and important to understand its intrinsic limits by showing lower bounds, and to reduce it by presenting improved upper bounds. Previously, communication complexity for secure computation was studied only for the privacy model and only for the two-party case <ref> [101] </ref> [8] (see also [119] for results in the related model of cooperative two-party computation versus an eavesdropper). Recently, and independently, Kushilevitz [102] has studied the communication complexity of multi-party private addition (see our Lemma 3.2).
Reference: [102] <author> E. Kushilevitz, </author> <title> "On computing the sum privately," </title> <type> manuscript. </type>
Reference-contexts: Previously, communication complexity for secure computation was studied only for the privacy model and only for the two-party case [101] [8] (see also [119] for results in the related model of cooperative two-party computation versus an eavesdropper). Recently, and independently, Kushilevitz <ref> [102] </ref> has studied the communication complexity of multi-party private addition (see our Lemma 3.2). <p> We also note that essentially the same result as Lemma 3.2 was found independently by Kushilevitz <ref> [102] </ref>, who gives exactly matching upper and lower bounds of 2 messages for multi-party private addition. However, performing in parallel many unstoppable addition protocols over any finite field, without reducing other parameters, cannot decrease the required amount of communication, as the following two lemmas indicate.
Reference: [103] <author> L. Lamport, R. Shostak, and M. Pease, </author> <title> "The Byzantine generals problem," </title> <journal> ACM Trans. on Programming Lang. and Systems (1982), </journal> <pages> 382-401. </pages>
Reference-contexts: Two fundamental protocols are formally described: Oblivious Transfer [126] and Byzantine Agreement <ref> [103] </ref>. <p> Moreover, we must have that b = b i if i is honest and all of the honest players had the same initial bit. This problem was initially considered by Lamport, Shostak, and Pease <ref> [103] </ref>, who showed that it can be solved if and only if less than one-third of the players are faulty. As will be shown in the next subsection, Byzantine Agreement can be used to eliminate the need for a broadcast channel in some secure distributed computation protocols. <p> This protocol can also be described using the model for fault-tolerant secure computation (although the purpose in not to conceal the inputs, and although channels are not private in the original model 1 <ref> [103] </ref>). Suppose that the consensus value will be 0 when the honest players do not have the same initial bit. Then each player i begins with private input b i on its tape. <p> Obviously, if the adversary is passive, then each broadcast can be simulated by sending the same message privately to each player. More interestingly, if the adversary is active, then each broadcast can also be simulated on a private network if there are sufficiently few faulty players. Using Byzantine Agreement <ref> [103] </ref> [70], a t-resilient protocol that requires a broadcast channel can be converted into a t-resilient protocol that needs only a network of private channels, whenever n &gt; 3t. 2.2.4 Unifying Protocol Models Rather than proving the above properties directly and individually, one may try to somehow capture all of the <p> For an active adversary, there are functions for which there is no t-private protocol among n players when n 3t; this follows directly from the lower bound for Byzantine Agreement <ref> [103] </ref>. For the case of a passive adversary, more is known about when a function does or does not have a t-private protocol among n players when n 2t. Chor and Kushilevitz [55] find a "gap" in the maximum level of privacy, in the non-cryptographic zero-error setting for boolean functions.
Reference: [104] <author> A. LaPaugh, </author> <title> "Recontamination does not help to search a graph," </title> <journal> JACM, </journal> <note> April 1993 (originally Princeton Technical Report 335). </note>
Reference-contexts: Our work on distributed database maintenance shows reductions between privacy and generalizations of graph searching games, a topic that has received much attention (e.g., [36] [110] [100] <ref> [104] </ref> [25]). Organization: In Section 4.2, we give the basic model of eavesdropping games. We consider the problem of secure message transmission in Section 4.3, and distributed database maintenance in Section 4.4. The sensitivity of the database problem to the choice of mobility setting is addressed in Section 4.5. <p> Having the guards move once every jV j rounds is equivalent to allowing the contamination to spread arbitrarily fast every round, i.e., the original node search model due to Kirousis and Papadimitriou [100]. The following theorem can then be proven from the result of LaPaugh <ref> [104] </ref> that "recontamination doesn't help" in these settings, i.e., for any successful search there is a search without recontamination using the same number of guards (proof omitted). Theorem 4.4 For any graph G, ns I=P=C (G) = ns I=P=H (G) = ns I=S=C (G) = ns I=S=H (G). <p> The theorem of LaPaugh <ref> [104] </ref> shows that, in an I/fl/fl setting, any graph G = (V; E) can be searched by ns I=fl=fl (G) guards in poly (jV j) steps. <p> We know that this problem is in general PSPACE-complete, but it is interesting to consider the problem for natural settings. A complete answer can be given for Infrequent settings, and a partial answer for Frequent settings. By the NP-completeness of node searching as defined by Kirousis and Papadimitriou [100] <ref> [104] </ref> [110], together with Theorems 4.3 and 4.4, we can show the following claim (proof omitted). Claim 4.5 The node search decision problem in an I/fl/fl setting is NP-complete.
Reference: [105] <author> R. Lipton, </author> <title> "How to cheat at mental poker," </title> <booktitle> proceedings of AMS short course on cryptography, </booktitle> <year> 1981. </year>
Reference-contexts: Bit commitment, a two-player version of secret sharing, is discussed in Section 2.1.4. Coin flipping [26] is a two-party protocol that arrives at a common random bit; this was one of the earliest cryptographic protocols. Mental poker [133] <ref> [105] </ref> [51] [85] [141] [73] [52] [53] is a protocol for producing, and partially applying, a random permutation (i.e., shu*e and deal a deck of cards); as evidenced by the number of references, this problem was something of a critical test case for the cryptography community as the notion of security
Reference: [106] <author> T. Long and A. Wigderson, </author> <title> "The discrete logarithm hides O(log n) bits," </title> <journal> SIAM J. Comput. </journal> <volume> 17 (1988), </volume> <pages> 363-372. </pages>
Reference-contexts: The difficulty of the discrete logarithm problem is a standard cryptographic assumption first used by Diffie and Hellman [60] (on other basic uses and hard bits of the discrete log, see <ref> [30, 106] </ref>). A "communicating p.p.t. Turing Machine" is like a normal p.p.t.
Reference: [107] <author> M. Luby, S. Micali, and C. Rackoff, </author> <title> "How to simultaneously exchange a secret bit by flipping a symmetrically-biased coin," </title> <booktitle> IEEE FOCS 1984, </booktitle> <pages> 11-21. </pages>
Reference-contexts: Oblivious Transfer [26] [23] [34] is a fundamental two-party protocol that transfers a bit with uncertainty; it is discussed in more detail in Section 2.2.2. Secret exchange [28] [31] <ref> [107] </ref> [89] [140] is a two-party protocol that transfers a message in each direction with certainty; it is discussed in more detail in Section 2.4.4. Electronic money [38] [39] is a collection of protocols (e.g, withdrawal, purchase, deposit) that implement payment schemes without any physical requirements. <p> When the secrets are single bits, then no deterministic algorithms are known. A probabilistic solution was found by Luby, Micali, and Rackoff <ref> [107] </ref>: alternating flips of slightly biased coins gradually yield statistical information about the values of the secrets, and quitting leaves one player with the negligible advantage of knowing the outcome of at most one additional coin-flip. <p> Beaver and Goldwasser [15] present a different way of achieving fairness for boolean functions (similar to Luby et al. <ref> [107] </ref>), under the assumption that an Oblivious Transfer protocol exists (together with a network of private channels). It also does not rely on the computational equivalence of the adversary and the honest players.
Reference: [108] <author> F. Makedon, C. Papadimitriou, and I. Sudborough, </author> <title> "Topological bandwidth," </title> <journal> SIAM J. Alg. Disc. Meth. </journal> <volume> 6 (1985), </volume> <pages> 418-444. </pages>
Reference-contexts: The node search number of a graph versus arbitrarily fast recontamination (I/fl/fl setting) has been shown to be connected to other topological properties of the graph (e.g., vertex separator [100], interval thickness [99], topological bandwidth <ref> [108] </ref>, cutwidth [108]). <p> The node search number of a graph versus arbitrarily fast recontamination (I/fl/fl setting) has been shown to be connected to other topological properties of the graph (e.g., vertex separator [100], interval thickness [99], topological bandwidth <ref> [108] </ref>, cutwidth [108]).
Reference: [109] <author> K. McCurley, </author> <title> "A key distribution system equivalent to factoring," </title> <journal> J. Cryptology, </journal> <volume> 1 (1988), </volume> <pages> 95-105. </pages>
Reference-contexts: The security of the original El-Gamal public-key encryption scheme reduces to the difficulty of breaking an instance of the Diffie-Hellman key exchange scheme [60] (i.e., a problem that is no more difficult than but not known to be equivalent to the discrete log problem). McCurley <ref> [109] </ref> showed how El-Gamal encryption with a composite modulus (and a careful choice of g and N ) can be 94 secure against an adversary who could break the Diffie-Hellman key exchange, or could factor the modulus, but not both.
Reference: [110] <author> N. Megiddo, S. Hakimi, M. Garey, D. Johnson, and C. Papadimitriou, </author> <title> "The complexity of searching a graph," </title> <booktitle> JACM 35 (1988), </booktitle> <pages> 18-44. </pages>
Reference-contexts: Database maintenance was defined by Ostrovsky and Yung [122] under a mobile fault model, but assuming broadcast and a complete network of untappable channels. Our work on distributed database maintenance shows reductions between privacy and generalizations of graph searching games, a topic that has received much attention (e.g., [36] <ref> [110] </ref> [100] [104] [25]). Organization: In Section 4.2, we give the basic model of eavesdropping games. We consider the problem of secure message transmission in Section 4.3, and distributed database maintenance in Section 4.4. <p> At the end of every round, the adversary must not be able to predict the secrets with a success probability better than random guessing. 4.4.2 Characterization of Feasibility Node searching is a graph game with a long history [36] [123] <ref> [110] </ref> [100]. We generalize earlier formulations of the game as follows. At the start of the game, all edges of a graph are contaminated and guards occupy some nodes; the contaminated edges may be viewed as the possible locations of a fugitive that the guards are attempting to capture. <p> A complete answer can be given for Infrequent settings, and a partial answer for Frequent settings. By the NP-completeness of node searching as defined by Kirousis and Papadimitriou [100] [104] <ref> [110] </ref>, together with Theorems 4.3 and 4.4, we can show the following claim (proof omitted). Claim 4.5 The node search decision problem in an I/fl/fl setting is NP-complete. <p> Proof : We show that determining the node search number in these settings is NP-hard, by modifying the proof of NP-hardness for edge searching versus a fast fugitive due to Megiddo et al <ref> [110] </ref>. Let G = (V; E) and K &gt; 0 be an instance of MIN-CUT INTO EQUAL-SIZED SUBSETS (i.e., determine whether V can be partitioned into equal sized subsets such that at most K edges of E are cut). We construct a corresponding node search problem as follows. <p> This is done in such a way that no vertex belongs to more than two cliques, which is possible since M is sufficiently large. [Note that this is the same construction as in <ref> [110] </ref> except that all edges between cliques have been contracted.] Call a clique unclear if it has at least one uncleared edge, and clear otherwise. Recall from Lemma 4.1 that every node in an unclear clique is adjacent to at least one uncleared clique edge.
Reference: [111] <author> M. Merritt, </author> <title> "Cryptographic protocols," </title> <type> Ph.D. thesis, </type> <institution> Georgia Institute of Technology, </institution> <year> 1983. </year>
Reference-contexts: Secret-ballot election schemes [50] [19] [91] are essentially a special case of secure computation in which the function is a simple sum of ones and zeros. Early work in the formalization of cryptographic protocols is also of interest. One approach is algebraic [62] <ref> [111] </ref>, proving security by relating actual protocols homomorphically to theoretically perfect protocols. A second approach is logical [37], proving security with respect to some reasonable axiomatization. Lastly, we mention some general notions that are related to secure distributed computing.
Reference: [112] <author> S. Micali, </author> <title> "Fair public-key cryptosystems," </title> <booktitle> in Advances in Cryptology|CRYPTO '92 Proceedings (Lecture Notes in Computer Science), </booktitle> <editor> ed. E. Brickell, </editor> <address> 114-139, </address> <publisher> Springer-Verlag, </publisher> <address> New York, </address> <year> 1993. </year>
Reference-contexts: The notion of group-oriented cryptography, in which the power of a secret key holder is distributed over a number of participants, was introduced by Desmedt [58]. Practical implementations of group-oriented public-key encryption were given by Desmedt and Frankel [59]. (See also the related notion of fair public-key encryption <ref> [112] </ref>.) We extend their implementations to achieve additional useful properties. Our scheme, which we call "additive joint encryption," can then be used to reduce the message complexity of cryptographic multi-party circuit evaluation.
Reference: [113] <author> S. Micali and P. Rogaway, </author> <title> "Secure computation," </title> <booktitle> in Advances in Cryptology|CRYPTO '91 Proceedings (Lecture Notes in Computer Science, </booktitle> <volume> Vol. 576), </volume> <editor> ed. J. Feigenbaum, </editor> <address> 392-404, </address> <publisher> Springer-Verlag, </publisher> <address> New York, </address> <year> 1992. </year>
Reference-contexts: Among the strengths of this definition is that it provides a single unifying security measure, and that it facilitates modularity in both protocol design and proof of security. Another proposed formalization, due to Micali and Rogaway <ref> [113] </ref>, builds on the successful definition of the zero-knowledge property for interactive proof systems. They define a "simulator" for a protocol, which can interact with an adversary in place of the network of processors. <p> Here an appropriate output is somewhat difficult to define (see, e.g., Beaver [11] and Micali and Rogaway <ref> [113] </ref> for more precise definition). We introduce the new and natural security requirement of t-unstoppability.
Reference: [114] <author> M. Naor, </author> <title> "Bit commitment using pseudo-randomness," </title> <booktitle> in Advances in Cryptology|CRYPTO '89 Proceedings (Lecture Notes in Computer Science, </booktitle> <volume> Vol. 435), </volume> <editor> ed. G. Brassard, </editor> <address> 128-136, </address> <publisher> Springer-Verlag, </publisher> <address> New York, </address> <year> 1990. </year>
Reference-contexts: The first bit commitment protocol was part of a protocol by Blum [27] for two-party coin flipping. A commitment by one party, followed by a guess by the second party, followed by a revelation by the first party, is equivalent to the flip of a coin. Naor <ref> [114] </ref> shows a general construction for basing bit commitment on any one-way function, based on earlier reductions [92] [88]. A more specific example of a bit commitment scheme is based on quadratic residuosity.
Reference: [115] <author> M. Naor, R. Ostrovsky, R. Venkatesan, and M. Yung, </author> <title> "Perfect zero-knowledge arguments for NP can be based on general complexity assumptions," </title> <type> manuscript, </type> <year> 1991. </year>
Reference-contexts: The scheme is unalterable, since no element can be both a residue and a nonresidue; the scheme is unreadable by a polynomially bounded receiver under the QRA. Basic bit commitment requires that the receiver be polynomially-bounded. Another flavor of bit commitment, called "strong bit commitment" [33] [35] <ref> [115] </ref> allows the receiver to be unbounded.
Reference: [116] <author> M. Naor and M. Yung, </author> <title> "Universal one-way hash functions and their cryptographic applications," </title> <booktitle> STOC 1989, </booktitle> <pages> 33-43. </pages>
Reference-contexts: Proof : First we describe the "struct" data structure that will be used for each instance of the O.A. protocol. Let sig be a signature scheme that is existentially unforgeable against a chosen message attack; such a scheme exists if one way functions exist <ref> [116] </ref> [130].
Reference: [117] <author> T. Okamoto and K. Ohta, </author> <title> "Disposable zero-knowledge authentications and their applications to untraceable electronic cash," </title> <booktitle> in Advances in Cryptology|CRYPTO '89 Proceedings (Lecture Notes in Computer Science, </booktitle> <volume> Vol. 435), </volume> <editor> ed. G. Brassard, </editor> <address> 481-496, </address> <publisher> Springer-Verlag, </publisher> <address> New York, </address> <year> 1990. </year>
Reference-contexts: DeSantis and Persiano [57] show that, when non-interactive zero knowledge proofs of knowledge are possible, blind signatures are not necessary for an off-line coin scheme (see also <ref> [117] </ref>). The basic idea is that the bank gives an ordinary signature to the customer, but no one ever sees that signature again.
Reference: [118] <author> T. Okamoto and K. Ohta, </author> <title> "Universal electronic cash," </title> <booktitle> in Advances in Cryptology|CRYPTO '91 Proceedings (Lecture Notes in Computer Science, </booktitle> <volume> Vol. 576), </volume> <editor> ed. J. Feigenbaum, </editor> <address> 324-337, </address> <publisher> Springer-Verlag, </publisher> <address> New York, </address> <year> 1992. </year>
Reference: [119] <author> A. Orlitsky and A. El Gamal, </author> <title> "Communication with secrecy constraints," </title> <booktitle> ACM STOC 1984, </booktitle> <pages> 217-224. </pages>
Reference-contexts: Previously, communication complexity for secure computation was studied only for the privacy model and only for the two-party case [101] [8] (see also <ref> [119] </ref> for results in the related model of cooperative two-party computation versus an eavesdropper). Recently, and independently, Kushilevitz [102] has studied the communication complexity of multi-party private addition (see our Lemma 3.2).
Reference: [120] <author> R. Ostrovsky, R. Venkatesan, and M. Yung, </author> <title> "Fair games against an all-powerful adversary," Sequences Workshop, </title> <address> Positano, Italy, </address> <month> July </month> <year> 1991. </year> <month> 126 </month>
Reference-contexts: Ostrovsky, Venkatesan, and Yung <ref> [120] </ref> consider the problem of sufficient conditions for various "asymmetric" two-party protocols, i.e., protocols in which one player is polynomially bounded while the other player is computationally unbounded. In particular, they show that Oblivious Transfer is possible, in either direction, assuming the existence of one-way functions.
Reference: [121] <author> R. Ostrovsky and M. Yung, </author> <title> "On necessary conditions for secure distributed computing," </title> <booktitle> DI--MACS Workshop on Distributed Computing and Cryptography, </booktitle> <editor> Feigenbaum and Merritt (eds.), </editor> <publisher> AMS, </publisher> <year> 1990, </year> <pages> 229-234. </pages>
Reference-contexts: However, due to a relativization result from Impagliazzo and Rudich [94], it is unlikely that the sufficiency of one-way functions for secure symmetric computation can be shown (i.e., a proof that only used one-way functions in a "black-box" manner would prove P 6= N P ). Ostrovsky and Yung <ref> [121] </ref> demonstrate the necessity of a complete network of private channels for implementing private multiparty computation among computationally unbounded players (sufficiency was shown by [22] and [41]). They consider the problem of dealing one card from a four card deck to each of three players.
Reference: [122] <author> R. Ostrovsky and M. Yung, </author> <title> "Robust computation in the presence of mobile viruses," </title> <booktitle> ACM PODC 1991, </booktitle> <pages> 51-59. </pages>
Reference-contexts: For most of the protocols discussed in this paper (but not all <ref> [122] </ref> [61]), there is either a single static passive adversary or a single static active adversary. 2.2.2 Basic Protocols This section describes two basic protocols that are useful primitives for secure distributed computation: Oblivious Transfer and Byzantine Agreement. <p> the t faulty players can prevent the sender and receiver from agreeing on one of the 2t + 1 random bits that is guaranteed to be uncorrupted, or allow the faulty players to learn the value of that bit. 2.5.7 Non-Cryptographic Protocols versus Mobile Adversaries (Virus Model) Ostrovsky and Yung <ref> [122] </ref> consider a more powerful adversary that models the behavior of a (detectable) virus in a computer network (with rebootable machines): a different set of up to t players can be under the adversary's control each round. <p> Mobile adversaries in the context of secure computation were introduced by Ostrovsky and Yung <ref> [122] </ref>. Unlike previous studies, this work takes a graph-theoretic perspective, to understand the relationship of network topology to the feasibility of fundamental privacy problems. We would like to characterize these fundamental problems combinatorially, and to analyze their complexity as well. <p> Variants of the problems we consider have been defined elsewhere. Secure message transmission was originally defined by Dolev et al. [61] under a mobile fault model, but assuming that many channels connect the sender and receiver. Database maintenance was defined by Ostrovsky and Yung <ref> [122] </ref> under a mobile fault model, but assuming broadcast and a complete network of untappable channels. Our work on distributed database maintenance shows reductions between privacy and generalizations of graph searching games, a topic that has received much attention (e.g., [36] [110] [100] [104] [25]). <p> Secure message transmission is possible for this example in the plug-in model, but not in the graph-only model. 73 4.4 Distributed Database Maintenance 4.4.1 Problem In the distributed database maintenance problem (first considered as a secure computation task by Ostrovsky and Yung <ref> [122] </ref>), one or more secrets (elements of a finite group) are initially shared among the nodes of the graph. Then t bugs are introduced into the graph, and some protocol is executed ongoingly.
Reference: [123] <author> T. Parsons, </author> <title> "Pursuit-evasion in a graph," in "Theory and application of graphs," </title> <editor> (Y. Alavi and D. Lick, eds.), </editor> <publisher> Springer-Verlag (1976), </publisher> <pages> 426-441. </pages>
Reference-contexts: At the end of every round, the adversary must not be able to predict the secrets with a success probability better than random guessing. 4.4.2 Characterization of Feasibility Node searching is a graph game with a long history [36] <ref> [123] </ref> [110] [100]. We generalize earlier formulations of the game as follows. At the start of the game, all edges of a graph are contaminated and guards occupy some nodes; the contaminated edges may be viewed as the possible locations of a fugitive that the guards are attempting to capture.
Reference: [124] <author> B. Pfitzmann and M. Waidner, </author> <title> "How to break and repair a `provably secure' untraceable payment system," </title> <booktitle> in Advances in Cryptology|CRYPTO '91 Proceedings (Lecture Notes in Computer Science, </booktitle> <volume> Vol. 576), </volume> <editor> ed. J. Feigenbaum, </editor> <address> 338-350, </address> <publisher> Springer-Verlag, </publisher> <address> New York, </address> <year> 1992. </year>
Reference-contexts: Other off-line coin schemes use blind signature schemes derived from Chaum and Pedersen [44]. It is also possible to implement blind signatures using general secure 2-party computation protocols [140], as shown by Pfitzmann and Waidner <ref> [124] </ref>, building on work of Damg-ard [56]. A circuit to compute signatures is jointly computed by the bank and the customer, with the bank contributing one input (secret signature key), the customer contributing the other input (message 101 to be signed), and the customer alone receiving the output (signed message).
Reference: [125] <author> M. Rabin, </author> <title> "Digital signatures," in Foundations of Secure Computation, </title> <editor> R. DeMillo, D. Dobkin, A. Jones, and R. Lipton (editors), </editor> <publisher> Academic Press, </publisher> <address> NY, </address> <year> 1978, </year> <pages> 155-168. </pages>
Reference-contexts: This can be done by combining the blind signature scheme with a zero knowledge proof [86, 81] or "cut-and-choose" check <ref> [125] </ref> that the message has the right form. The first off-line coin scheme, due to Chaum, Fiat, and Naor [43] takes this approach, using the blind signature scheme based on RSA [129].
Reference: [126] <author> M. Rabin, </author> <title> "How to exchange secrets by oblivious transfer," </title> <type> Tech. </type> <institution> Memo TR-81, Aiken Computation Laboratory, Harvard University, </institution> <year> 1981. </year>
Reference-contexts: Two fundamental protocols are formally described: Oblivious Transfer <ref> [126] </ref> and Byzantine Agreement [103]. <p> By contrast, A cannot determine that the transfer was successful any better than random guessing (or non-negligibly better than random guessing, with respect to some security parameter). This is a description of the simplest version of Oblivious Transfer, due to Rabin <ref> [126] </ref> (abbreviated "OT"). It is analogous to mail service by an incompetent Postal Service; any sent letter arrives at the proper destination half of the time, and disappears the other half of the time. <p> Alternatively, pre-processing can be implemented inefficiently using a general secure 2-party 107 computation protocol between the requestor and the authenticator. As shown by Kilian [97], the assumption that Oblivious Transfer <ref> [126] </ref> (a basic cryptographic primitive) is possible suffices. Intuitively, the pre-processing stage supplies encrypted windows, where each window presigns both a zero and a one for a given bit position in the message.
Reference: [127] <author> T. Rabin, </author> <title> "Robust sharing of secrets when the dealer is honest or cheating," M.Sc. </title> <type> Thesis, </type> <institution> Hebrew University, </institution> <year> 1988. </year>
Reference-contexts: In later sections, this VSS scheme will be used in secure computation protocols, as will a VSS scheme due to T. Rabin <ref> [127] </ref> that can tolerate any minority of faulty players with an exponentially small probability of error. 2.1.7 Instance Hiding Instance hiding schemes ([1], [13]) are a means for computing with encrypted data. <p> If fewer than one-third of the players are faulty, then error-correcting codes can be exploited [22]. For greater resilience, new techniques of verifiable secret sharing <ref> [127] </ref> can be used. These new techniques can require more interaction among players, even for linear operations. In this subsection, we will survey some of the non-cryptographic secure distributed computation protocols that have been developed. <p> One natural question is whether the resilience can be increased by adding a broadcast channel. The affirmative answer was supplied T. Rabin and Ben-Or [128], and by Beaver [12], both building on ideas from T. Rabin <ref> [127] </ref>. At the heart of the protocol is a verifiable secret sharing scheme, due to T. Rabin [127], that can correct up to t errors where n &gt; 2t, by giving up on absolute certainty of success. <p> The affirmative answer was supplied T. Rabin and Ben-Or [128], and by Beaver [12], both building on ideas from T. Rabin <ref> [127] </ref>. At the heart of the protocol is a verifiable secret sharing scheme, due to T. Rabin [127], that can correct up to t errors where n &gt; 2t, by giving up on absolute certainty of success. This scheme has a probability of failure that is exponentially small with respect to a security parameter. This VSS scheme also requires the existence of a broadcast channel.
Reference: [128] <author> T. Rabin and M. Ben-Or, </author> <title> "Verifiable secret sharing and multiparty protocols with honest majority," </title> <booktitle> ACM STOC 1989, </booktitle> <pages> 73-85. </pages>
Reference-contexts: Some cryptographic protocols assume only a complete network of "oblivious transfer channels" (i.e., private channels that allow OT by some means), and in fact require no additional cryptographic assumptions. Some work has been done in the unconditional setting with incomplete networks of private channels <ref> [128] </ref> [61]. Adversaries: A player is considered "correct" if it follows its program exactly, engaging in no additional communication or computation beyond what is specified by the protocol, and keeping all of its private tapes private. <p> The first two [22] [41] achieve t-resilience whenever there are n &gt; 3t players, assuming a complete private network of channels. The last two <ref> [128] </ref> [12] achieve t-resilience when n &gt; 2t, but require a broadcast channel in addition to a complete private network, and must allow a small probability of error. <p> One natural question is whether the resilience can be increased by adding a broadcast channel. The affirmative answer was supplied T. Rabin and Ben-Or <ref> [128] </ref>, and by Beaver [12], both building on ideas from T. Rabin [127]. At the heart of the protocol is a verifiable secret sharing scheme, due to T. Rabin [127], that can correct up to t errors where n &gt; 2t, by giving up on absolute certainty of success. <p> It is interesting to consider what weaker assumptions on the private network will still allow secure distributed computation without cryptographic assumptions. Rabin and Ben-Or <ref> [128] </ref> show how to perform any secure distributed computation t-resiliently in a network of at least 3t + 1 players, if the players are joined by a network of private channels with connectivity at least 2t + 1. <p> The error correction procedure is also independent of the number of secrets hidden by the polynomial; as long as the ff i 's are chosen to be nth roots of unity, this procedure need not be changed for the parallel version. Rabin and Ben-Or <ref> [128] </ref> (see also Beaver [9]) have a protocol to securely compute any arithmetic circuit t-resiliently, where n 2t + 1, assuming broadcast, and allowing an exponentially small probability of error.
Reference: [129] <author> R. Rivest, A. Shamir, and L. Adleman, </author> <title> "A method for obtaining digital signatures and public key cryptosystems," </title> <booktitle> CACM 21 (1978), </booktitle> <pages> 120-126. </pages>
Reference-contexts: Anyone can encrypt a message by applying the permutation to it, but only the holder of the trapdoor key can invert the permutation to recover the message. No permutation is known to be trapdoor, but one candidate is the RSA encryption function <ref> [129] </ref>: E (m) = m e mod n, where n = pq, and the trapdoor key is (p; q) (easily samplable given the family parameter k = jpj = jqj). <p> The first off-line coin scheme, due to Chaum, Fiat, and Naor [43] takes this approach, using the blind signature scheme based on RSA <ref> [129] </ref>. This approach is efficient but heuristic; no proof of security has been given that relies on assumptions about RSA that are simple or natural. In fact, refinements to their protocol [3] were later found to introduce security flaws [90], which underscores the risk of relying on heuristics.
Reference: [130] <author> J. Rompel, </author> <title> "One-way functions are necessary and sufficient for secure signatures," </title> <booktitle> STOC 1990, </booktitle> <pages> 387-394. </pages>
Reference-contexts: Proof : First we describe the "struct" data structure that will be used for each instance of the O.A. protocol. Let sig be a signature scheme that is existentially unforgeable against a chosen message attack; such a scheme exists if one way functions exist [116] <ref> [130] </ref>.
Reference: [131] <author> J. Schwartz, </author> <title> "Fast probabilistic algorithms for verification of polynomial identities," </title> <booktitle> JACM 27 (1980), </booktitle> <pages> 701-717. </pages>
Reference-contexts: This result is also a consequence of a theorem (relating number of zeros to total degree) due to Zippel [142] and independently to Schwartz <ref> [131] </ref>. Lemma 3.6 If p (x 1 ; ; x n ) has "degree" d over F , jF j = m, then p (x 1 ; ; x n ) = 0 has at most ndm n1 solutions.
Reference: [132] <author> A. Shamir, </author> <title> "How to share a secret," </title> <booktitle> CACM 22 (1979), </booktitle> <pages> 612-613. </pages>
Reference-contexts: These are the lines along which the bulk of this chapter is organized. Historical Background Secure distributed computing is a very general and powerful notion. It was preceded by numerous investigations of protocols for a variety of special-purpose (and interrelated) cryptographic tasks. Secret sharing <ref> [132] </ref> [134] is a multi-party protocol in which a designated player distributes a message for later recovery by some authorized subcollection of the remaining players; it is discussed in more detail in Section 2.1.6. Bit commitment, a two-player version of secret sharing, is discussed in Section 2.1.4. <p> which the verifier is convinced that the prover holds an undisclosed witness for language membership; these proof systems are also important in the context of protocol validation. 2.1.6 Secret Sharing and Verifiable Secret Sharing Underlying many recent results in secure distributed computing is a secret sharing scheme due to Shamir <ref> [132] </ref>. In this scheme, a secret s is shared by a "dealer" among n players by giving each player a point on an otherwise random degree t polynomial p (x) such that p (0) = s (e.g., give p (i) to the ith player). <p> Most subsequent protocols for non-cryptographic secure computation, and all of the ones given in this section, rely on the secret-sharing method due to Shamir <ref> [132] </ref>. <p> Proof : Let s 1 ; ; s k be the Dealer's secrets. Assume that ff 1 ; ; ff n and e 1 ; ; e k are preselected elements of F that are known to the Dealer and all n players. A generalization of Shamir's secret-sharing scheme <ref> [132] </ref> suffices. In the Distribution Phase, each player i receives the multi-share p (ff i ), where p (x) 2 F [x] is an otherwise random degree t polynomial such that p (e i ) = s i , 1 i k.
Reference: [133] <author> A. Shamir, R. Rivest, and L. Adleman, </author> <title> "Mental poker," </title> <type> Technical Report MIT/LCS/TR-125, </type> <institution> M.I.T., </institution> <year> 1979. </year>
Reference-contexts: Bit commitment, a two-player version of secret sharing, is discussed in Section 2.1.4. Coin flipping [26] is a two-party protocol that arrives at a common random bit; this was one of the earliest cryptographic protocols. Mental poker <ref> [133] </ref> [105] [51] [85] [141] [73] [52] [53] is a protocol for producing, and partially applying, a random permutation (i.e., shu*e and deal a deck of cards); as evidenced by the number of references, this problem was something of a critical test case for the cryptography community as the notion of
Reference: [134] <author> G. Simmons, </author> <title> "Geometric shared secret and/or shared control schemes," </title> <booktitle> in Advances in Cryptology|CRYPTO '90 Proceedings (Lecture Notes in Computer Science, </booktitle> <volume> Vol. 537), </volume> <editor> ed. A. Menzes and S. Vanstone, </editor> <address> 216-240, </address> <publisher> Springer-Verlag, </publisher> <address> New York, </address> <year> 1991. </year>
Reference-contexts: These are the lines along which the bulk of this chapter is organized. Historical Background Secure distributed computing is a very general and powerful notion. It was preceded by numerous investigations of protocols for a variety of special-purpose (and interrelated) cryptographic tasks. Secret sharing [132] <ref> [134] </ref> is a multi-party protocol in which a designated player distributes a message for later recovery by some authorized subcollection of the remaining players; it is discussed in more detail in Section 2.1.6. Bit commitment, a two-player version of secret sharing, is discussed in Section 2.1.4.
Reference: [135] <author> C. </author> <title> Small, Arithmetic of Finite Fields, </title> <journal> Monographs and Textbooks in Pure and Applied Mathematics (Vol. </journal> <volume> 148), </volume> <publisher> Marcel Dekker, Inc., </publisher> <address> New York, </address> <year> 1991. </year>
Reference-contexts: follows from the equivalence of performing k additions over a field of size m and performing a single addition over a field of size m k (since GF (m k ) can be constructed as GF (m)[X]=f (X)), where f 2 GF (m)[X] is any irreducible polynomial of degree k <ref> [135] </ref>).
Reference: [136] <author> M. Tompa and H. Woll, </author> <title> "Random self-reducibility and zero knowledge interactive proofs of possession of information," </title> <booktitle> IEEE FOCS 1987, </booktitle> <pages> 472-482. 127 </pages>
Reference-contexts: The use of validation in secure distributed computation protocol will be seen in Sections 2.4.3 and 2.5.3. We also mention zero-knowledge proof of knowledge [69] <ref> [136] </ref>, in which the verifier is convinced that the prover holds an undisclosed witness for language membership; these proof systems are also important in the context of protocol validation. 2.1.6 Secret Sharing and Verifiable Secret Sharing Underlying many recent results in secure distributed computing is a secret sharing scheme due to
Reference: [137] <author> U. Vazirani and V. Vazirani, </author> <title> "Trapdoor pseudo-random number generators, with applications to protocol design," </title> <booktitle> IEEE FOCS 1983, </booktitle> <pages> 23-30. </pages>
Reference-contexts: A probabilistic solution was found by Luby, Micali, and Rackoff [107]: alternating flips of slightly biased coins gradually yield statistical information about the values of the secrets, and quitting leaves one player with the negligible advantage of knowing the outcome of at most one additional coin-flip. Vazirani and Vazirani <ref> [137] </ref> investigated a similar but somewhat weaker notion of exchanging a secret for a valid receipt. Yao [140] first defined fairness for two-party computation protocols for boolean functions.
Reference: [138] <author> A. Yao, </author> <title> "Some complexity questions related to distributive computing," </title> <booktitle> ACM STOC 1979, </booktitle> <pages> 209-213. </pages>
Reference-contexts: They show that every n-ary boolean function is either n-private, b n1 2 c-private but not d n 2 e-private, or not 1-private. Their results follow from establishing a connection between private computability and communication complexity as defined by Yao <ref> [138] </ref>. As a surprising special case, private addition over a finite subrange of integers can be n-private, over the positive integers can be at most b n1 2 c-private, but over all the integers cannot even be 1-private.
Reference: [139] <author> A. Yao, </author> <title> "Protocols for secure computations," </title> <booktitle> IEEE FOCS 1982, </booktitle> <pages> 160-164. </pages>
Reference-contexts: p;g (a) is random self-reducible over Z fl p since (1) ag r mod p is uniformly distributed for random r 2 Z fl p and (2) DLP p;g (a) = DLP p;g (ag r mod p) r. 2.1.2 Indistinguishable Probability Distributions The indistinguishability of probability distributions, due to Yao <ref> [139] </ref> and Goldwasser and Micali [85], combines computational assumptions with randomness in a condition that is useful for defining the security of cryptographic primitives. Informally, two distributions are indistinguishable 10 if a guesser cannot tell them apart. <p> There are other impossibility results for unconditional two-party computation that are covered in Section 2.6. The first results in two-party secure computation are due to Yao <ref> [139] </ref>. He was interested in a setting in which both parties behaved honestly, but wished to maintain the secrecy of their inputs ("1-privacy" as defined in Section 2.2.3). <p> each of two players conveys a secret to the other, then one player can quit the protocol at any moment to advantage if at that moment it has received "more" than it has sent. 33 Blum introduced the problem [28], and gave an incorrect solution (generalized and corrected by Yao <ref> [139] </ref>) when the secrets were factorizations of large composite numbers. Each player takes turns revealing one bit of one prime factor, while proving that the bit is valid; being one bit "ahead" is of negligible advantage to a player who halts the protocol prematurely. <p> If one of the channels between two players is insecure (i.e., accessible to the third player), then some information about the distribution of the cards must be 46 leaked. 2.6.2 Necessary Conditions and Resources The first complexity results in this field are two impossibility results due to Yao <ref> [139] </ref>, one for a certain type of two-player secret exchange (swapping zeros of trapdoor functions), and the other for the generation of an arbitrarily biased bit by many players.
Reference: [140] <author> A. Yao, </author> <title> "How to generate and exchange secrets," </title> <booktitle> IEEE FOCS 1986, </booktitle> <pages> 162-167. </pages>
Reference-contexts: Oblivious Transfer [26] [23] [34] is a fundamental two-party protocol that transfers a bit with uncertainty; it is discussed in more detail in Section 2.2.2. Secret exchange [28] [31] [107] [89] <ref> [140] </ref> is a two-party protocol that transfers a message in each direction with certainty; it is discussed in more detail in Section 2.4.4. Electronic money [38] [39] is a collection of protocols (e.g, withdrawal, purchase, deposit) that implement payment schemes without any physical requirements. <p> In this same paper, Yao indicated without details that any 2-ary function f (x; y) could be computed privately by two players assuming the hardness of factoring. 2.3.2 Protocols The first general two-party secure computation protocol result is due to Yao <ref> [140] </ref>, who considers a task that is somewhat more general than the computation problem described in Section 2.2. Instead 21 of computing a deterministic function, an "interactive computational problem" has inputs and outputs that are distributed according to given probability distributions. <p> Vazirani and Vazirani [137] investigated a similar but somewhat weaker notion of exchanging a secret for a valid receipt. Yao <ref> [140] </ref> first defined fairness for two-party computation protocols for boolean functions. Informally, a two-party protocol is fair if neither player can violate the protocol in such a way that the violator learns the output while the other player is unable to learn it. <p> Computational advantage can be defined to be an increased probability of successfully distinguishing the actual output from a possible output. Galil, Haber, and Yung describe a means (similar to Blum [28], and following Yao <ref> [140] </ref>) for adding synchrony to a multi-party computation protocol, assuming that trapdoor functions exist. The n players jointly create a trapdoor key. Instead of performing a secure distributed computation of the actual function, the players securely compute the encryption of the output of the function using the trapdoor key. <p> Lastly, Beaver, Micali, and Rogaway [16] show that constant-round poly-sized computation, resilient for a constant fraction of faulty processors, is achievable assuming that one-way functions exist. The protocol, a generalization of the two-party protocol due to Yao <ref> [140] </ref> described in Section 2.3.2, has the players construct a scrambled version of the circuit, from which each player can compute the output on its own. <p> Misbehavior may be passive (e.g., pooling legally obtained information), or active (e.g., violating the protocol in an arbitrary coordinated attack). The basic problem of designing protocols for arbitrary 50 arithmetic circuits was first solved for two processors by Yao <ref> [140] </ref>, and for any number of processors by Goldreich, Micali, and Wigderson [82]. These solutions relied on unproven assumptions: the intractability of factoring, and the existence of trapdoor functions, respectively. <p> The problem of securely evaluating an arbitrary boolean circuit under cryptographic assumptions has been much studied, beginning with the work of Yao <ref> [140] </ref> and Goldreich, Micali, and Wigderson [82]. The notion of group-oriented cryptography, in which the power of a secret key holder is distributed over a number of participants, was introduced by Desmedt [58]. <p> for their modified shadow generation scheme based on Lagrange interpolation (i.e., that g have odd order in Z fl N ). 5.5 Message-Efficient General-Purpose Secure Computation Several solutions have been found to the problem of securely evaluating an arbitrary boolean circuit under cryptographic assumptions, beginning with the work of Yao <ref> [140] </ref> and Goldreich, Micali, and Wigderson [82]. <p> Other off-line coin schemes use blind signature schemes derived from Chaum and Pedersen [44]. It is also possible to implement blind signatures using general secure 2-party computation protocols <ref> [140] </ref>, as shown by Pfitzmann and Waidner [124], building on work of Damg-ard [56].
Reference: [141] <author> M. Yung, "Cryptoprotocols: </author> <title> subscription to a public key, the secret blocking and the multiplayer mental poker game," </title> <booktitle> in Advances in Cryptology|CRYPTO '84 Proceedings (Lecture Notes in Computer Science), </booktitle> <pages> 439-453, </pages> <publisher> Springer-Verlag, </publisher> <address> New York, </address> <year> 1985. </year>
Reference-contexts: Bit commitment, a two-player version of secret sharing, is discussed in Section 2.1.4. Coin flipping [26] is a two-party protocol that arrives at a common random bit; this was one of the earliest cryptographic protocols. Mental poker [133] [105] [51] [85] <ref> [141] </ref> [73] [52] [53] is a protocol for producing, and partially applying, a random permutation (i.e., shu*e and deal a deck of cards); as evidenced by the number of references, this problem was something of a critical test case for the cryptography community as the notion of security grew in sophistication
Reference: [142] <author> R. Zippel, </author> <title> "Probabilistic algorithms for sparse polynomials," </title> <booktitle> in Proc. EUROSAM '79 (Lecture Notes in Computer Science, </booktitle> <volume> Vol. 72), </volume> <pages> 216-226, </pages> <publisher> Springer-Verlag, </publisher> <year> 1979. </year> <month> 128 </month>
Reference-contexts: This result is also a consequence of a theorem (relating number of zeros to total degree) due to Zippel <ref> [142] </ref> and independently to Schwartz [131]. Lemma 3.6 If p (x 1 ; ; x n ) has "degree" d over F , jF j = m, then p (x 1 ; ; x n ) = 0 has at most ndm n1 solutions.
References-found: 142

