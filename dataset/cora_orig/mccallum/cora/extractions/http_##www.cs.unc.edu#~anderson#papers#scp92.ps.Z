URL: http://www.cs.unc.edu/~anderson/papers/scp92.ps.Z
Refering-URL: http://www.cs.unc.edu/~anderson/papers.html
Root-URL: http://www.cs.unc.edu
Title: Beyond Atomic Registers: Bounded Wait-Free Implementations of Nontrivial Objects  
Author: James H. Anderson Bojan Groselj 
Keyword: assertional reasoning, atomicity, atomic register, composite register, concurrency, counter, lin-earizability, read-modify-write, shared variable, snapshot, UNITY CR Categories: D.4.1, D.4.2, F.3.1  
Note: To appear in Science of Computer Programming. Preliminary version was presented at the Fifth International Workshop on Distributed Algorithms, Delphi, Greece,  Work supported in part by an award from the General Research Board, University of Maryland, and by NSF Contract CCR  On leave from: The  
Address: College Park College Park, Maryland 20742  Lafayette, Louisiana 70504.  
Affiliation: Department of Computer Science The University of Maryland at  Center for Advanced Computer Studies, University of Southwestern Louisiana,  
Email: E-mail: jha@cs.umd.edu.  E-mail: bojan@cs.umd.edu.  
Phone: 9109497.  
Date: January 1991 Revised September 1991, June 1992  October 1991.  
Abstract: We define a class of operations called pseudo read-modify-write (PRMW) operations, and show that nontrivial shared data objects with such operations can be implemented in a bounded, wait-free manner from atomic registers. A PRMW operation is similar to a "true" read-modify-write (RMW) operation in that it modifies the value of a shared variable based upon the original value of that variable. However, unlike an RMW operation, a PRMW operation does not return the value of the variable that it modifies. We consider a class of shared data objects that can either be read, written, or modified by an associative, commutative PRMW operation, and show that any object in this class can be implemented without waiting from atomic registers. The implementations that we present are polynomial in both space and time and thus are an improvement over previously published ones, all of which have unbounded space complexity. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> M. Abadi and L. Lamport, </author> <title> "The Existence of Refinement Mappings," </title> <journal> Theoretical Computer Science, </journal> <volume> Vol. 82, No. 2, </volume> <month> May </month> <year> 1990, </year> <pages> pp. 253-284. </pages>
Reference-contexts: The use of auxiliary history variables in correctness arguments is, of course, not new. Early references include the work of Clint [13] and also Owicki and Gries [25]. More recent references include Abadi and Lamport's work on refinement mappings <ref> [1] </ref> and Lam and Shankar's work on module specifications [20]. Our use of history variables was, in fact, motivated by the latter paper, where history variables are used to formally specify database serializability. <p> Quantified statements are allowed. For example, "h []i : 0 i &lt; N :: a [i] := b [i]i" is shorthand for "a [0] := b [0] [] a <ref> [1] </ref> := b [1] [] [] a [N 1] := b [N 1]," and "hki : 0 i &lt; N :: a [i] := b [i]i" is shorthand for "a [0]; a [1]; : : : ; a [N 1] := b [0]; b [1]; : : : ; b [N <p> Quantified statements are allowed. For example, "h []i : 0 i &lt; N :: a [i] := b [i]i" is shorthand for "a [0] := b [0] [] a <ref> [1] </ref> := b [1] [] [] a [N 1] := b [N 1]," and "hki : 0 i &lt; N :: a [i] := b [i]i" is shorthand for "a [0]; a [1]; : : : ; a [N 1] := b [0]; b [1]; : : : ; b [N 1]." A simple <p> &lt; N :: a [i] := b [i]i" is shorthand for "a [0] := b [0] [] a <ref> [1] </ref> := b [1] [] [] a [N 1] := b [N 1]," and "hki : 0 i &lt; N :: a [i] := b [i]i" is shorthand for "a [0]; a [1]; : : : ; a [N 1] := b [0]; b [1]; : : : ; b [N 1]." A simple multiple-assignment s may have a boolean guard B, denoted "s if B." The operational interpretation of such a statement is as follows: if "s if B" is executed when <p> [0] := b [0] [] a <ref> [1] </ref> := b [1] [] [] a [N 1] := b [N 1]," and "hki : 0 i &lt; N :: a [i] := b [i]i" is shorthand for "a [0]; a [1]; : : : ; a [N 1] := b [0]; b [1]; : : : ; b [N 1]." A simple multiple-assignment s may have a boolean guard B, denoted "s if B." The operational interpretation of such a statement is as follows: if "s if B" is executed when B is false, then the program state is not changed, and if
Reference: [2] <author> Y. Afek, H. Attiya, D. Dolev, E. Gafni, M. Merritt, and N. Shavit, </author> <title> "Atomic Snapshots of Shared Memory," </title> <booktitle> Proceedings of the Ninth Annual Symposium on Principles of Distributed Computing, </booktitle> <year> 1990, </year> <pages> pp. 1-14. </pages>
Reference-contexts: A composite register is an array-like shared data object that is partitioned into a number of components. As illustrated in Figure 1, an operation of such a register either writes a value to a single component, or reads the values of all components. Afek et al. <ref> [2] </ref> and Anderson [3, 4] have shown that composite registers can be implemented from atomic registers without waiting. <p> Given the results of <ref> [2, 3, 4] </ref>, this shows that any PRMW object can be implemented without waiting using only atomic registers. Our results stand in sharp contrast to those of [5, 15], where it is shown that RMW operations cannot, in general, be implemented from atomic registers without waiting. <p> The importance of (3) should not be overlooked. By the semantics of a counter, each Write operation should have the effect of completely overwriting the previous contents of the implemented counter. Assertions (1) and (3) imply that this is indeed the case. Given the results of <ref> [2, 3, 4] </ref> and the results of this section, we have the following theorem. Theorem: Counters can be implemented in a bounded, wait-free manner from atomic registers. 2 4 Proof of Consistency In this section, we formally prove that our counter implementation satisfies the Consistency condition. <p> The space complexity of an implementation is defined to be the number of single-reader, single-writer, single-bit atomic registers required to realize the implementation. If the implemented counter stores values ranging over fL; : : : ; Lg, then by the results of <ref> [2, 3, 4] </ref>, the space complexity is polynomial in L and N . 30 5.3 Generalizing the Implementation In the proof of Consistency, we considered an arbitrary well-formed history h, and showed that the partial order on operations defined by h can be extended to a total order that is consistent <p> An interesting research question is whether it is possible to develop a general mechanism for converting any unbounded wait-free implementation into a bounded one, provided the data object under consideration is syntactically bounded. 4 This question was noted previously by Afek et al. <ref> [2] </ref>. The correctness proof for our implementation is noteworthy because of the fact that it is assertional, rather than operational. Most proofs of wait-free implementations that have been presented in the literature are based upon operational concepts such as histories and events.
Reference: [3] <author> J. Anderson, </author> <title> "Multiple-Writer Composite Registers," </title> <type> Technical Report TR.89.26, </type> <institution> Department of Computer Sciences, University of Texas at Austin, </institution> <month> September </month> <year> 1989. </year> <month> 34 </month>
Reference-contexts: A composite register is an array-like shared data object that is partitioned into a number of components. As illustrated in Figure 1, an operation of such a register either writes a value to a single component, or reads the values of all components. Afek et al. [2] and Anderson <ref> [3, 4] </ref> have shown that composite registers can be implemented from atomic registers without waiting. <p> Given the results of <ref> [2, 3, 4] </ref>, this shows that any PRMW object can be implemented without waiting using only atomic registers. Our results stand in sharp contrast to those of [5, 15], where it is shown that RMW operations cannot, in general, be implemented from atomic registers without waiting. <p> The importance of (3) should not be overlooked. By the semantics of a counter, each Write operation should have the effect of completely overwriting the previous contents of the implemented counter. Assertions (1) and (3) imply that this is indeed the case. Given the results of <ref> [2, 3, 4] </ref> and the results of this section, we have the following theorem. Theorem: Counters can be implemented in a bounded, wait-free manner from atomic registers. 2 4 Proof of Consistency In this section, we formally prove that our counter implementation satisfies the Consistency condition. <p> The space complexity of an implementation is defined to be the number of single-reader, single-writer, single-bit atomic registers required to realize the implementation. If the implemented counter stores values ranging over fL; : : : ; Lg, then by the results of <ref> [2, 3, 4] </ref>, the space complexity is polynomial in L and N . 30 5.3 Generalizing the Implementation In the proof of Consistency, we considered an arbitrary well-formed history h, and showed that the partial order on operations defined by h can be extended to a total order that is consistent
Reference: [4] <author> J. Anderson, </author> <title> "Composite Registers," </title> <booktitle> Proceedings of the Ninth Annual Symposium on Principles of Dis--tributed Computing , 1990, </booktitle> <pages> pp. 15-30. </pages> <note> To appear in Distributed Computing. </note>
Reference-contexts: A composite register is an array-like shared data object that is partitioned into a number of components. As illustrated in Figure 1, an operation of such a register either writes a value to a single component, or reads the values of all components. Afek et al. [2] and Anderson <ref> [3, 4] </ref> have shown that composite registers can be implemented from atomic registers without waiting. <p> Given the results of <ref> [2, 3, 4] </ref>, this shows that any PRMW object can be implemented without waiting using only atomic registers. Our results stand in sharp contrast to those of [5, 15], where it is shown that RMW operations cannot, in general, be implemented from atomic registers without waiting. <p> The importance of (3) should not be overlooked. By the semantics of a counter, each Write operation should have the effect of completely overwriting the previous contents of the implemented counter. Assertions (1) and (3) imply that this is indeed the case. Given the results of <ref> [2, 3, 4] </ref> and the results of this section, we have the following theorem. Theorem: Counters can be implemented in a bounded, wait-free manner from atomic registers. 2 4 Proof of Consistency In this section, we formally prove that our counter implementation satisfies the Consistency condition. <p> The space complexity of an implementation is defined to be the number of single-reader, single-writer, single-bit atomic registers required to realize the implementation. If the implemented counter stores values ranging over fL; : : : ; Lg, then by the results of <ref> [2, 3, 4] </ref>, the space complexity is polynomial in L and N . 30 5.3 Generalizing the Implementation In the proof of Consistency, we considered an arbitrary well-formed history h, and showed that the partial order on operations defined by h can be extended to a total order that is consistent
Reference: [5] <author> J. Anderson and M. Gouda, </author> <title> "The Virtue of Patience: Concurrent Programming With and Without Waiting," </title> <type> Technical Report TR.90.23, </type> <institution> Department of Computer Sciences, University of Texas at Austin, </institution> <month> August </month> <year> 1987, </year> <month> revised July </month> <year> 1990. </year>
Reference-contexts: Given the results of [2, 3, 4], this shows that any PRMW object can be implemented without waiting using only atomic registers. Our results stand in sharp contrast to those of <ref> [5, 15] </ref>, where it is shown that RMW operations cannot, in general, be implemented from atomic registers without waiting. The problem of implementing PRMW objects without waiting has been studied independently by Aspnes and Herlihy in [7]. <p> case, the shared variables must all correspond to the components of a single composite register. 3 * Wait-Freedom Restriction: As mentioned in the introduction, each procedure is required to be "wait-free," i.e., idle-waiting primitives and unbounded busy-waiting loops are not allowed. (A more formal definition of wait-freedom is given in <ref> [5] </ref>.) We now define several concepts that are needed to state the correctness condition for an implementation. These definitions apply to a given implementation. <p> In the consensus problem, two processes are required to agree on a common boolean "decision value"; trivial solutions in which both processes agree on a predetermined value are not allowed. It has been shown by Anderson and Gouda <ref> [5] </ref>, by Chor, Israeli, and Li [12], by Herlihy [15], and by Loui and Abu-Amara [23] that two-process consensus cannot be solved in a wait-free manner using only atomic registers.
Reference: [6] <author> J. Anderson and M. Gouda, </author> <title> "A Criterion for Atomicity," </title> <journal> Formal Aspects of Computing: The International Journal of Formal Methods, </journal> <note> scheduled to appear in 1992. </note>
Reference: [7] <author> J. Aspnes and M. Herlihy, </author> <title> "Wait-Free Data Structures in the Asynchronous PRAM Model," </title> <booktitle> Proceedings of the Second Annual ACM Symposium on Parallel Architectures and Algorithms, </booktitle> <month> July, </month> <year> 1990. </year>
Reference-contexts: Our results stand in sharp contrast to those of [5, 15], where it is shown that RMW operations cannot, in general, be implemented from atomic registers without waiting. The problem of implementing PRMW objects without waiting has been studied independently by Aspnes and Herlihy in <ref> [7] </ref>. Aspnes and Herlihy give a general, wait-free implementation that can be used to implement any PRMW object. A counter implementation, which is obtained by optimizing the general implementation, is also given. <p> Our implementation is polynomial in both space and time, and thus is an improvement over the unbounded implementations of Aspnes and Herlihy <ref> [7] </ref>. It is interesting to note that our results can be applied to extend the notion of a composite register by allowing an additional associative, commutative PRMW operation on each component.
Reference: [8] <author> B. Awerbuch, L. Kirousis, E. Kranakis, P. Vitanyi, </author> <title> "On Proving Register Atomicity," </title> <type> Report CS-R8707, </type> <institution> Centre for Mathematics and Computer Science, </institution> <address> Amsterdam, </address> <year> 1987. </year> <title> A shorter version entitled "A Proof Technique for Register Atomicity" appeared in Proceedings of the Eighth Conference on Foundations of Software Techniques and Theoretical Computer Science, </title> <booktitle> Lecture Notes in Computer Science 338, </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1988, </year> <pages> pp. 286-303. </pages>
Reference-contexts: Our use of history variables was, in fact, motivated by the latter paper, where history variables are used to formally specify database serializability. We believe that history variables better facilitate the development of assertional proofs of wait-free implementations than do shrinking functions and their variants <ref> [8] </ref>. Acknowledgements: We would like to thank A. Udaya Shankar for several helpful discussions on the subject of this paper, and for bringing reference [20] to our attention. We would also like to thank John Tromp for his comments on a draft of this paper.
Reference: [9] <author> B. Bloom, </author> <title> "Constructing Two-Writer Atomic Registers," </title> <journal> IEEE Transactions on Computers, </journal> <volume> Vol. 37, No. 12, </volume> <month> December </month> <year> 1988, </year> <pages> pp. 1506-1514. </pages> <booktitle> Also appeared in Proceedings of the Sixth Annual Symposium on Principles of Distributed Computing , 1987, </booktitle> <pages> pp. 249-259. </pages>
Reference: [10] <author> J. Burns and G. Peterson, </author> <title> "Constructing Multi-Reader Atomic Values from Non-Atomic Values," </title> <booktitle> Proceedings of the Sixth Annual Symposium on Principles of Distributed Computing , 1987, </booktitle> <pages> pp. 222-231. </pages>
Reference: [11] <author> K. Chandy and J. Misra, </author> <title> Parallel Program Design: A Foundation, </title> <publisher> Addison-Wesley, </publisher> <year> 1988. </year>
Reference-contexts: all Increment operations ordered between w and r by . 2 In order to avoid confusion, we capitalize the terms "Read," "Write," and "Increment" when referring to the operations of the implemented counter, and leave them uncapitalized when referring to the variables used in the implementation. 3 The notation of <ref> [11] </ref> is used for quantification. <p> Theorem: Counters can be implemented in a bounded, wait-free manner from atomic registers. 2 4 Proof of Consistency In this section, we formally prove that our counter implementation satisfies the Consistency condition. We find it convenient to express the implementation in the UNITY programming notation of Chandy and Misra <ref> [11] </ref>. This version of the implementation is shown in Figure 5. In UNITY, the enabling condition of each assignment is explicitly stated; this eliminates the need for introducing notation for referring to the "control" of each process. A brief description of UNITY notation is presented in an appendix. <p> Our treatment will be necessarily brief and our descriptions operational. For a complete description of UNITY, the interested reader is referred to <ref> [11] </ref>. A UNITY program consists of four sections, namely declare, always, initially, and assign. The declare section gives variable declarations. The always section defines auxiliary variables that are functions of other variables. The initially section specifies initial conditions. The assign section gives the executable statements of the program.
Reference: [12] <author> B. Chor, A. Israeli, and M. Li, </author> <title> "On Processor Coordination Using Asynchronous Hardware," </title> <booktitle> Proceedings of the Sixth Annual Symposium on Principles of Distributed Computing , 1987, </booktitle> <pages> pp. 86-97. </pages>
Reference-contexts: In the consensus problem, two processes are required to agree on a common boolean "decision value"; trivial solutions in which both processes agree on a predetermined value are not allowed. It has been shown by Anderson and Gouda [5], by Chor, Israeli, and Li <ref> [12] </ref>, by Herlihy [15], and by Loui and Abu-Amara [23] that two-process consensus cannot be solved in a wait-free manner using only atomic registers.
Reference: [13] <author> M. Clint, </author> <title> "Program Proving: Coroutines," </title> <journal> Acta Informatica, </journal> <volume> Vol. 2, </volume> <pages> p. 50-63, </pages> <year> 1973. </year>
Reference-contexts: In our proof, auxiliary history variables are used to record the effect of each operation; these history variables serve as a basis for stating the required invariants. The use of auxiliary history variables in correctness arguments is, of course, not new. Early references include the work of Clint <ref> [13] </ref> and also Owicki and Gries [25]. More recent references include Abadi and Lamport's work on refinement mappings [1] and Lam and Shankar's work on module specifications [20].
Reference: [14] <author> P. Courtois, F. Heymans, and D. Parnas, </author> <title> "Concurrent Control with Readers and Writers," </title> <journal> Communications of the ACM , Vol. </journal> <volume> 14, No. 10, </volume> <month> October </month> <year> 1971, </year> <pages> pp. 667-668. </pages>
Reference-contexts: This work shows that, using only atomic registers of the simplest kind, it is possible to solve the classical readers-writers problem without requiring either readers or writers to wait <ref> [14] </ref>. Another shared data object of interest is the composite register, a data object that generalizes the notion of an atomic register. A composite register is an array-like shared data object that is partitioned into a number of components.
Reference: [15] <author> M. Herlihy, </author> <title> "Wait-Free Synchronization," </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> Vol. 13, No. 1, </volume> <year> 1991, </year> <pages> pp. 124-149. </pages>
Reference-contexts: Given the results of [2, 3, 4], this shows that any PRMW object can be implemented without waiting using only atomic registers. Our results stand in sharp contrast to those of <ref> [5, 15] </ref>, where it is shown that RMW operations cannot, in general, be implemented from atomic registers without waiting. The problem of implementing PRMW objects without waiting has been studied independently by Aspnes and Herlihy in [7]. <p> In the consensus problem, two processes are required to agree on a common boolean "decision value"; trivial solutions in which both processes agree on a predetermined value are not allowed. It has been shown by Anderson and Gouda [5], by Chor, Israeli, and Li [12], by Herlihy <ref> [15] </ref>, and by Loui and Abu-Amara [23] that two-process consensus cannot be solved in a wait-free manner using only atomic registers.
Reference: [16] <author> M. Herlihy and J. Wing, </author> <title> "Linearizability: A Correctness Condition for Concurrent Objects," </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> Vol. 12, No. 3, </volume> <year> 1990, </year> <pages> pp. 463-492. </pages>
Reference-contexts: apply assertional techniques in reasoning about wait-free implementations, a task that is complicated 1 Note that decrementing can be defined in terms of incrementing; thus, a counter actually supports four operations: read, write, increment, and decrement. 2 by the fact that the primary correctness condition for such implementations (i.e., linearizability <ref> [16] </ref>) refers to operational concepts such as histories, operations, and precedence relationships. In Section 5, we discuss several issues pertaining to our implementation, and show that the implementation can be generalized to implement any PRMW object. <p> It can be shown that the following definition is equivalent to the more general definition of linearizability given by Herlihy and Wing in <ref> [16] </ref>, when restricted to the special case of implementing a counter. <p> To ensure progress, statement selection is required to be fair. However, because linearizability is a safety property <ref> [16] </ref>, we have no need to consider such issues.
Reference: [17] <author> A. Israeli and M. Li, </author> <title> "Bounded time-stamps," </title> <booktitle> Proceedings of the 28th IEEE Symposium on Foundations of Computer Science, </booktitle> <year> 1987, </year> <pages> pp. 371-382. 35 </pages>
Reference: [18] <author> L. Kirousis, E. Kranakis, and P. Vitanyi, </author> <title> "Atomic Multireader Register," </title> <booktitle> Proceedings of the Second Inter--national Workshop on Distributed Computing, Lecture Notes in Computer Science 312, </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1987, </year> <pages> pp. 278-296. </pages>
Reference: [19] <author> C. Kruskal, L. Rudolph, M. Snir, </author> <title> "Efficient Synchronization on Multiprocessors with Shared Memory," </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> Vol. 10, No. 4, </volume> <month> October </month> <year> 1988, </year> <pages> pp. 579-601. </pages>
Reference-contexts: A PRMW object consists of a single shared variable that can either be read, written, or modified by an associative, commutative PRMW operation. The PRMW operation takes its name from the classical read-modify-write (RMW) operation as defined in <ref> [19] </ref>. The RMW operation has the form "temp; X := X; f (X)," 1 . . Reader 0 Reader N-1 Writer (i,0) Writer (i,M-1) component i component 0 component K-1 . . where X is a shared variable, temp is a private variable, and f is a function.
Reference: [20] <author> S. Lam and A. Shankar, </author> <title> "Specifying Modules to Satisfy Interfaces: A State Transition System Approach," </title> <type> Technical Report CS-TR-2082.3, </type> <institution> University of Maryland at College Park, </institution> <year> 1988. </year> <note> To appear in Distributed Computing. </note>
Reference-contexts: The use of auxiliary history variables in correctness arguments is, of course, not new. Early references include the work of Clint [13] and also Owicki and Gries [25]. More recent references include Abadi and Lamport's work on refinement mappings [1] and Lam and Shankar's work on module specifications <ref> [20] </ref>. Our use of history variables was, in fact, motivated by the latter paper, where history variables are used to formally specify database serializability. We believe that history variables better facilitate the development of assertional proofs of wait-free implementations than do shrinking functions and their variants [8]. <p> We believe that history variables better facilitate the development of assertional proofs of wait-free implementations than do shrinking functions and their variants [8]. Acknowledgements: We would like to thank A. Udaya Shankar for several helpful discussions on the subject of this paper, and for bringing reference <ref> [20] </ref> to our attention. We would also like to thank John Tromp for his comments on a draft of this paper.
Reference: [21] <author> L. Lamport, </author> <title> "On Interprocess Communication, Parts I and II," </title> <journal> Distributed Computing, </journal> <volume> Vol. 1, </volume> <pages> pp. 77-101, </pages> <year> 1986. </year>
Reference-contexts: An atomic register is a shared data object consisting of a single shared variable that can either be read or written in a single operation <ref> [21] </ref>. An N -reader, M -writer, L-bit atomic register consists of an L-bit variable that can be read by N processes and written by M processes.
Reference: [22] <author> M. Li, J. Tromp, and P. Vitanyi, </author> <title> "How to Construct Wait-Free Variables," </title> <booktitle> Proceedings of International Colloquium on Automata, Languages, and Programming , Lecture Notes in Computer Science 372, </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1989, </year> <pages> pp. 488-505. </pages>
Reference: [23] <author> M. Loui and H. Abu-Amara, </author> <title> "Memory Requirements for Agreement Among Unreliable Asynchronous Processes," </title> <booktitle> Advances in Computing Research, </booktitle> <publisher> JAI Press, </publisher> <year> 1987, </year> <pages> pp. 163-183. </pages>
Reference-contexts: It has been shown by Anderson and Gouda [5], by Chor, Israeli, and Li [12], by Herlihy [15], and by Loui and Abu-Amara <ref> [23] </ref> that two-process consensus cannot be solved in a wait-free manner using only atomic registers. Therefore, to prove that accumulator registers cannot be implemented from atomic registers without waiting, it suffices to prove that accumulator registers can be used to solve two-process consensus in a wait-free manner. accumulator register X.
Reference: [24] <author> R. Newman-Wolfe, </author> <title> "A Protocol for Wait-Free, Atomic, Multi-Reader Shared Variables, </title> <booktitle> Proceedings of the Sixth Annual Symposium on Principles of Distributed Computing , 1987, </booktitle> <pages> pp. 232-248. </pages>
Reference: [25] <author> S. Owicki and D. Gries, </author> <title> "An Axiomatic Proof Technique for Parallel Programs I," </title> <journal> Acta Informatica, </journal> <volume> Vol. 6, </volume> <pages> pp. 319-340, </pages> <year> 1976. </year>
Reference-contexts: The use of auxiliary history variables in correctness arguments is, of course, not new. Early references include the work of Clint [13] and also Owicki and Gries <ref> [25] </ref>. More recent references include Abadi and Lamport's work on refinement mappings [1] and Lam and Shankar's work on module specifications [20]. Our use of history variables was, in fact, motivated by the latter paper, where history variables are used to formally specify database serializability.
Reference: [26] <author> G. Peterson, </author> <title> "Concurrent Reading While Writing," </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> Vol. 5, </volume> <year> 1983, </year> <pages> pp. 46-55. </pages>
Reference: [27] <author> G. Peterson and J. Burns, </author> <title> "Concurrent Reading While Writing II: The Multi-Writer Case," </title> <booktitle> Proceedings of the 28th Annual Symposium on Foundations of Computer Science, </booktitle> <year> 1987. </year>
Reference: [28] <author> A. Singh, J. Anderson, and M. Gouda, </author> <title> "The Elusive Atomic Register, Revisited," </title> <booktitle> Proceedings of the Sixth Annual Symposium on Principles of Distributed Computing , 1987, </booktitle> <pages> pp. 206-221. </pages>
Reference: [29] <author> J. Tromp, </author> <title> "How to Construct an Atomic Variable," </title> <booktitle> Proceedings of the Third International Workshop on Distributed Algorithms, Lecture Notes in Computer Science 392, </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1989, </year> <pages> pp. 292-302. </pages>
Reference: [30] <author> P. Vitanyi and B. Awerbuch, </author> <title> "Atomic Shared Register Access by Asynchronous Hardware," </title> <booktitle> Proceedings of the 27th IEEE Symposium on the Foundations of Computer Science, </booktitle> <year> 1986, </year> <pages> pp. 233-243. 36 </pages>
References-found: 30

