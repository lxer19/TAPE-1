URL: http://www.cs.utah.edu/~sjt/seminar/papers/te-cw-setuid.ps
Refering-URL: http://www.cs.utah.edu/~sjt/seminar/refs.html
Root-URL: 
Title: A Comparison of Type Enforcement and Unix Setuid Implementation of Well-Formed Transactions  
Author: D. J. Thomsen J. T. Haigh 
Address: Arden Hills, MN 55112  
Affiliation: Secure Computing Technology Corporation  
Abstract:  
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> D.D. Clark and D.R. Wilson. </author> <title> "A Comparison of Commercial and Military Computer Security Policies". </title> <booktitle> Proceedings of 1987 IEEE Symp. Security and Privacy, </booktitle> <pages> pages 184-194, </pages> <address> Oakland, CA, </address> <month> April </month> <year> 1987. </year>
Reference-contexts: 1 Introduction In their seminal paper on integrity for computer systems <ref> [1] </ref>, Clark and Wilson introduce the notion of transformation procedures which are intended to perform integrity preserving or enhancing operations on various classes of data. These operations are called well-formed transactions. <p> More burden falls on the developers and maintainers of the system to ensure the code is correct. From Clark and Wilson <ref> [1] </ref>: It is desirable to minimize certification rules, because the certification process is complex, prone to error, and must be repeated after each program change. In extending this model, therefore, an important research goal must be to shift as much of the security burden as possible from certification to enforcement.
Reference: [2] <author> W.D. Young, </author> <title> P.A. Telega, and W.E. Boebert. "A Verified Labeler for the Secure Ada Target". </title> <booktitle> Proceedings of the 9th National Computer Security Conference, </booktitle> <pages> pages 55-61, </pages> <month> September </month> <year> 1986. </year>
Reference-contexts: In this paper we compare the effectiveness of two mechanisms for implementing the concept of a well-formed transaction, the Secure Ada Target (SAT) type enforcement mechanism and the Unix 1 setuid mechanism. Throughout the paper we illustrate our results using the labeler example developed by Young et.al. <ref> [2] </ref>. The mechanisms are compared with respect to the ease of certification for a well-formed transaction implemented using each mechanism and the generality of the class of applications to which each mechanism can be applied. <p> The more stringent the security requirements, the more extensive and expensive certification becomes. 1 Unix is a trademark of AT&T 1 2.1 Assured Pipelines Many integrity preserving or enhancing applications can be thought of as an assured pipeline <ref> [2] </ref>. An assured pipeline is a series of subjects that are used to transform a CDI from one state to another. The subjects correspond to TPs in the Clark and Wilson model, and transform the input UDI or CDI to the output CDI. <p> Certainly, assured pipelines are not the only form of integrity operation, but they provide a good basis for our comparison. 2.2 The Labeler Assured Pipeline The sample integrity application used throughout the paper is a labeler application based on the design of Young et.al. <ref> [2] </ref>. This labeler was designed to meet the TCSEC requirement of ensuring all documents are printed with the proper label [3]. The labeler subject canonicalizes, paginates, and labels a user document; and the printer driver buffers the labeled document to the actual printer (see Fig ure 2).
Reference: [3] <institution> Department of Defense. Trusted computer systems evaluation criteria. </institution> <type> Technical Report 5200.28.STD, </type> <institution> NCSC, </institution> <month> December </month> <year> 1985. </year>
Reference-contexts: This labeler was designed to meet the TCSEC requirement of ensuring all documents are printed with the proper label <ref> [3] </ref>. The labeler subject canonicalizes, paginates, and labels a user document; and the printer driver buffers the labeled document to the actual printer (see Fig ure 2). Thus the labeler assured pipeline has two T P s: the labeler and the printer driver.
Reference: [4] <author> W.E. Boebert and R.Y. Kain. </author> <title> "A Practical Alternative to Hierarchical Integrity Policies". </title> <booktitle> Proceedings of the 8th National Computer Security Conference, </booktitle> <pages> pages 18-27, </pages> <month> October </month> <year> 1985. </year>
Reference-contexts: The next two sections discuss how type enforcement and setuid implement the assured labeler pipeline. 3 Type Enforcement SAT type enforcement was presented as a security mechanism in "A Practical Alternative to Hierachical Integrity Policies" <ref> [4] </ref> (also see "Modeling Database Security Requirements" [5]).
Reference: [5] <author> J.T. Haigh. </author> <title> "Modeling Database Security Requirements". C.E. Landwehr, editor, Database Security: Status and Prospects. </title> <publisher> North-Holland, </publisher> <year> 1989. </year>
Reference-contexts: The next two sections discuss how type enforcement and setuid implement the assured labeler pipeline. 3 Type Enforcement SAT type enforcement was presented as a security mechanism in "A Practical Alternative to Hierachical Integrity Policies" [4] (also see "Modeling Database Security Requirements" <ref> [5] </ref>). Type enforcement is also an element of the LOCK system currently under development at SCTC [6]. 3.1 The Definition of Type Enforce ment The basic concept of type enforcement is that the object space is partitioned into equivalence classes based on the integrity properties of objects.
Reference: [6] <author> O. Sami Saydjari, J. Beckman, and J. Leaman. </author> <title> "LOCKing Computers Securely". </title> <booktitle> Proceedings of the 10th DoD/NBS Computer Security Conference, </booktitle> <pages> pages 129-140, </pages> <address> Gaithersburg, MD, </address> <month> September </month> <year> 1987. </year>
Reference-contexts: Type enforcement is also an element of the LOCK system currently under development at SCTC <ref> [6] </ref>. 3.1 The Definition of Type Enforce ment The basic concept of type enforcement is that the object space is partitioned into equivalence classes based on the integrity properties of objects. Each equivalence class is called an object type.
Reference: [7] <author> Maurice J. Bach. </author> <title> The Design of the Unix Operating System. </title> <publisher> Prentice-Hall, </publisher> <address> Englewood Cliffs, New Jersey, </address> <year> 1986. </year>
Reference-contexts: For example, User: rwx, Group: r-x, World: r-- indicates that the owner has read, write, and execute permission; the users in the group have read and execute permission; and all other users have only read access. From Bach's book on the Unix operating system <ref> [7] </ref>: A setuid program is an executable file that has the setuid bit set in its permission mode field. When a process execs a setuid program, the kernel sets the effective user ID fields in the process table and u area to the owner ID of the file.
Reference: [8] <author> Sun Microsystems, Inc. </author> <title> Sun 4.0 Reference Manuals, </title> <month> November </month> <year> 1987. </year> <month> 9 </month>
Reference-contexts: The two files that are setuid root are required so that T P i can change from a group that can read CDI i1 to a group that can execute T P i+1 . Some versions of Unix, such as Sun 4.0 <ref> [8] </ref>, provide a command that allows a program to change its group identity. Either method requires more trusted code, but the setuid root method is particularly dangerous because if any of the n 1 setuid root files are compromised, the entire system is compromised.
References-found: 8

