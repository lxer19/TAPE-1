URL: ftp://ftp.cs.indiana.edu/pub/liu/Cachet-KBSE95.ps
Refering-URL: http://www.cs.indiana.edu/hyplan/liu.html
Root-URL: http://www.cs.indiana.edu
Title: CACHET: An interactive, incremental-attribution-based program transformation system for deriving incremental programs  
Author: Yanhong A. Liu 
Address: Ithaca, NY 14853  
Affiliation: Department of Computer Science, Cornell University,  
Abstract: This paper describes the design and implementation of an interactive, incremental-attribution-based program transformation system, CACHET, that derives incremental programs from non-incremental programs written in a functional language. CACHET is designed as a programming environment and implemented using a language-based editor generator, the Synthesizer Generator, with extensions that support complex transformations. Transformations directly manipulate the program tree and take into consideration information obtained from program analyses. Program analyses are performed via attribute evaluation, which is done incrementally as transformations change the program tree. The overall approach also explores a general framework for describing dynamic program semantics using annotations, which allows interleaving transformations with external input, such as user input. Designing CACHET as a programming environment also facilitates the integration of program derivation and validation with interactive editing, compiling, debugging, and execution. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> A. V. Aho, R. Sethi, and J. D. Ullman. </author> <booktitle> Compilers, Principles, Techniques, and Tools. </booktitle> <publisher> Addison-Wesley, </publisher> <year> 1986. </year>
Reference-contexts: Incremental computation has wide applications through computer software, e.g., optimizing compilers <ref> [1, 5, 23] </ref>, transformational program development [3, 24, 31], and interactive systems [2, 22, 30]. Liu and Teitelbaum [19] give a systematic transformational approach for deriving an incremental program f 0 from a given program f and an input change .
Reference: [2] <author> R. A. Ballance, S. L. Graham, and M. L. Van De Vanter. </author> <title> The Pan language-based editing system. </title> <journal> ACM Trans. on Software Eng. and Methodology, </journal> <volume> 1(1) </volume> <pages> 95-127, </pages> <month> Jan. </month> <year> 1992. </year>
Reference-contexts: Incremental computation has wide applications through computer software, e.g., optimizing compilers [1, 5, 23], transformational program development [3, 24, 31], and interactive systems <ref> [2, 22, 30] </ref>. Liu and Teitelbaum [19] give a systematic transformational approach for deriving an incremental program f 0 from a given program f and an input change .
Reference: [3] <author> F. L. Bauer, B. Moller, H. Partsch, and P. Pepper. </author> <title> Formal program construction by transformations|computer-aided, </title> <journal> intuition-guided programming. IEEE Trans. on Software Eng., </journal> <volume> 15(2) </volume> <pages> 165-180, </pages> <month> Feb. </month> <year> 1989. </year>
Reference-contexts: 1 Introduction Program transformation systems are important tools that implement various program manipulations that preserve program semantics and improve program performance <ref> [3, 11, 12, 15, 24, 26, 28, 31] </ref>. Interactive program transformation. Program transformation systems are often required to be interactive, for at least the following two reasons. First, the goal of the system is often so ambitious that no fully automatic transformation can succeed; interaction allows convenient semi-automatic transformation. <p> Incremental computation has wide applications through computer software, e.g., optimizing compilers [1, 5, 23], transformational program development <ref> [3, 24, 31] </ref>, and interactive systems [2, 22, 30]. Liu and Teitelbaum [19] give a systematic transformational approach for deriving an incremental program f 0 from a given program f and an input change . <p> Eminent systems among them and recent systems include APTS [24], KIDS [31], CIP <ref> [3] </ref>, Focus [28], and ZAP [11]. Compared to these systems, the most important and unique characteristic of CACHET is its use of attribute grammars. This has at least two advantages. <p> This functionality provides a general solution to the finite differencing problem, which must be addressed in program derivation from specification and program improvement in general <ref> [3, 24, 25, 31] </ref> 6 Future work A number of problems need to be further studied. We discuss major ones here. Annotation. Annotation provides a declarative framework for describing dynamic program semantics. However, formal description of annotation in the context of attribute-grammars is needed.
Reference: [4] <author> J. Boyland and S. L. Graham. </author> <title> Composing tree attributions. </title> <booktitle> In Proc. of the 21th Ann. ACM Symp. on POPL, </booktitle> <pages> pages 375-388, </pages> <address> Portland, OR, </address> <month> Jan. </month> <year> 1994. </year>
Reference-contexts: This iteration can be automated with rewriting. Modular attribute evaluation. Heavy program transformations are usually composed of separate phases, where each phase conducts smaller program analyses and performs lighter transformations. Several approaches have been proposed for modular attribute specification <ref> [4, 7, 8, 10, 13] </ref> and modular attribute evaluation [10, 13]. Modular specification improves the readability of attribute grammars and allows more convenient modular evaluation. Modular evaluation provides the flexibility of turning on and off attribution modules as necessary, which results in evaluators that are speedier and more storage-efficient [10]. <p> For example, OPTRAN [18] is an attribute-grammar-based system extended with rewrite mechanisms. However, it is still a batch-oriented system mainly for compiler applications rather than general program transformations. Another difference is that traditional attribute-grammar-based programming environments perform code generation by attribution <ref> [4, 13, 30] </ref>, while CACHET transforms programs by direct manipulation. How to do program transformation by attribution in the presence of annotation is related to incremental replay, as discussed in Section 6. <p> Attribution has been traditionally used in programming environments for code generation [30]; it has also been proposed for general program transformation, including phase-based transformation. Approaches include attribute coupled grammars [13], higher-order attribute grammars [32], composable attribute grammars [10], and simple tree attributions <ref> [4] </ref>. Incremental attribute evaluation algorithms for these frameworks could be used for incremental code generation. However, these frameworks do not address external input. We need to extend them and study how annotations should be incorporated with incremental attribute evaluation for incremental program transformation.
Reference: [5] <author> J. Cocke and K. Kennedy. </author> <title> An algorithm for reduction of operator strength. </title> <journal> Communications of the ACM, </journal> 20(11) 850-856, Nov. 1977. 
Reference-contexts: Incremental computation has wide applications through computer software, e.g., optimizing compilers <ref> [1, 5, 23] </ref>, transformational program development [3, 24, 31], and interactive systems [2, 22, 30]. Liu and Teitelbaum [19] give a systematic transformational approach for deriving an incremental program f 0 from a given program f and an input change .
Reference: [6] <author> P. Deransart, M. Jourdan, and B. Lorho. </author> <title> Attribute Grammars: Definitions, Systems, and Bibliography, </title> <booktitle> vol. 323 of LNCS. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1988. </year>
Reference-contexts: It is implemented using the Synthesizer Generator, with extensions to support complex tree transformations. Incremental program analysis is performed by incremental attribute evaluation, provided automatically by the Synthesizer Generator. Attribute grammars and incremental attribute evaluation methods have been well addressed in the literature <ref> [6] </ref> for describing static program semantics. They are not the subject of this paper. Instead, this paper describes how to adopt a traditional programming environment and make it suitable for performing complex tree transformations, interleaving transformations with external inputs, such as user inputs, and making more use of attribution mechanisms.
Reference: [7] <author> G. D. P. Dueck and G. V. Cormack. </author> <title> Modular attribute grammars. </title> <journal> The Computer Journal, </journal> <volume> 33(2) </volume> <pages> 164-172, </pages> <month> Apr. </month> <year> 1990. </year>
Reference-contexts: This iteration can be automated with rewriting. Modular attribute evaluation. Heavy program transformations are usually composed of separate phases, where each phase conducts smaller program analyses and performs lighter transformations. Several approaches have been proposed for modular attribute specification <ref> [4, 7, 8, 10, 13] </ref> and modular attribute evaluation [10, 13]. Modular specification improves the readability of attribute grammars and allows more convenient modular evaluation. Modular evaluation provides the flexibility of turning on and off attribution modules as necessary, which results in evaluators that are speedier and more storage-efficient [10].
Reference: [8] <author> C. Farnum. </author> <title> Pattern-based tree attribution. </title> <booktitle> In Proc. of the 19th Ann. ACM Symp. on POPL, </booktitle> <pages> pages 211-222, </pages> <month> Jan. </month> <year> 1992. </year>
Reference-contexts: This iteration can be automated with rewriting. Modular attribute evaluation. Heavy program transformations are usually composed of separate phases, where each phase conducts smaller program analyses and performs lighter transformations. Several approaches have been proposed for modular attribute specification <ref> [4, 7, 8, 10, 13] </ref> and modular attribute evaluation [10, 13]. Modular specification improves the readability of attribute grammars and allows more convenient modular evaluation. Modular evaluation provides the flexibility of turning on and off attribution modules as necessary, which results in evaluators that are speedier and more storage-efficient [10].
Reference: [9] <author> R. Farrow. </author> <title> Automatic generation of fixed-point-finding evaluators for circular, but well-defined, attribute grammars. </title> <booktitle> In Proc. of the ACM SIGPLAN '86 Symp. on Compiler Construction, </booktitle> <pages> pages 85-98, </pages> <month> Jul. </month> <year> 1986. </year>
Reference-contexts: Circular attribute evaluation. Some program analyses are based on fixed point iteration. If such analyses are done by attribute evaluation, then circular attribute evaluation methods are needed. Although solutions to this problem have been proposed <ref> [9, 16] </ref>, they are rarely implemented due to complications and inefficiency. Here, we briefly describe how circular attribute evaluation can be simulated using tree transformations and annotations.
Reference: [10] <author> R. Farrow, T. J. Marlowe, and D. M. Yellin. </author> <title> Composable attribute grammars: Support for modularity in translator design and implementation. </title> <booktitle> In Proc. of the 19th Ann. ACM Symp. on POPL, </booktitle> <pages> pages 223-234, </pages> <month> Jan. </month> <year> 1992. </year>
Reference-contexts: This iteration can be automated with rewriting. Modular attribute evaluation. Heavy program transformations are usually composed of separate phases, where each phase conducts smaller program analyses and performs lighter transformations. Several approaches have been proposed for modular attribute specification <ref> [4, 7, 8, 10, 13] </ref> and modular attribute evaluation [10, 13]. Modular specification improves the readability of attribute grammars and allows more convenient modular evaluation. Modular evaluation provides the flexibility of turning on and off attribution modules as necessary, which results in evaluators that are speedier and more storage-efficient [10]. <p> This iteration can be automated with rewriting. Modular attribute evaluation. Heavy program transformations are usually composed of separate phases, where each phase conducts smaller program analyses and performs lighter transformations. Several approaches have been proposed for modular attribute specification [4, 7, 8, 10, 13] and modular attribute evaluation <ref> [10, 13] </ref>. Modular specification improves the readability of attribute grammars and allows more convenient modular evaluation. Modular evaluation provides the flexibility of turning on and off attribution modules as necessary, which results in evaluators that are speedier and more storage-efficient [10]. They are particularly useful for phase-based transformations. <p> Modular specification improves the readability of attribute grammars and allows more convenient modular evaluation. Modular evaluation provides the flexibility of turning on and off attribution modules as necessary, which results in evaluators that are speedier and more storage-efficient <ref> [10] </ref>. They are particularly useful for phase-based transformations. In particular, for phases not involving circular attributes, efficient evaluators for non-circular attribute grammars can be generated. 2.4 Replay A minimal approach to replaying transformations is to record the history or script of external input [28]. <p> Attribution has been traditionally used in programming environments for code generation [30]; it has also been proposed for general program transformation, including phase-based transformation. Approaches include attribute coupled grammars [13], higher-order attribute grammars [32], composable attribute grammars <ref> [10] </ref>, and simple tree attributions [4]. Incremental attribute evaluation algorithms for these frameworks could be used for incremental code generation. However, these frameworks do not address external input. We need to extend them and study how annotations should be incorporated with incremental attribute evaluation for incremental program transformation.
Reference: [11] <author> M. S. Feather. </author> <title> A system for assisting program transformation. </title> <journal> ACM Trans. on Programming Languages and Systems, </journal> <volume> 4(1) </volume> <pages> 1-20, </pages> <month> Jan. </month> <year> 1982. </year>
Reference-contexts: 1 Introduction Program transformation systems are important tools that implement various program manipulations that preserve program semantics and improve program performance <ref> [3, 11, 12, 15, 24, 26, 28, 31] </ref>. Interactive program transformation. Program transformation systems are often required to be interactive, for at least the following two reasons. First, the goal of the system is often so ambitious that no fully automatic transformation can succeed; interaction allows convenient semi-automatic transformation. <p> In particular, for phases not involving circular attributes, efficient evaluators for non-circular attribute grammars can be generated. 2.4 Replay A minimal approach to replaying transformations is to record the history or script of external input [28]. Powerful metalanguages can help reduce the recording work <ref> [11] </ref>; for example, with a metalanguage that allows rewrite, we can record one rewrite in place of a sequence of transformations involved in the rewrite. Replay is important not only for helping to understand the whole transformation, but also for incremental transformation under changes to the input program. <p> Eminent systems among them and recent systems include APTS [24], KIDS [31], CIP [3], Focus [28], and ZAP <ref> [11] </ref>. Compared to these systems, the most important and unique characteristic of CACHET is its use of attribute grammars. This has at least two advantages. <p> CACHET can benefit from a stronger metalan-guage, such as that pioneered by ZAP <ref> [11] </ref>, and certain replay functionality, such as that in Focus [28]. As discussed in Sections 2 and 3, a metalanguage for powerful tree transformation has been designed and is being implemented for CACHET.
Reference: [12] <author> M. S. Feather. </author> <title> A survey and classification of some program transformation approaches and techniques. </title> <booktitle> In Program Specification and Transformation, </booktitle> <pages> pages 165-195. </pages> <publisher> North-Holland, </publisher> <year> 1987. </year>
Reference-contexts: 1 Introduction Program transformation systems are important tools that implement various program manipulations that preserve program semantics and improve program performance <ref> [3, 11, 12, 15, 24, 26, 28, 31] </ref>. Interactive program transformation. Program transformation systems are often required to be interactive, for at least the following two reasons. First, the goal of the system is often so ambitious that no fully automatic transformation can succeed; interaction allows convenient semi-automatic transformation. <p> However, to see all the interesting intermediate results during the derivation, manual invocation is appropriate. 5 Related work Program transformation systems and the approaches and techniques used therein are described in a number of surveys, e.g., <ref> [12, 26] </ref>. Eminent systems among them and recent systems include APTS [24], KIDS [31], CIP [3], Focus [28], and ZAP [11]. Compared to these systems, the most important and unique characteristic of CACHET is its use of attribute grammars. This has at least two advantages.
Reference: [13] <author> H. Ganzinger and R. Giegerich. </author> <title> Attribute coupled grammars. </title> <booktitle> In Proc. of the ACM SIGPLAN '84 Symp. on Compiler Construction, </booktitle> <pages> pages 157-170, </pages> <month> Jun. </month> <year> 1984. </year>
Reference-contexts: This iteration can be automated with rewriting. Modular attribute evaluation. Heavy program transformations are usually composed of separate phases, where each phase conducts smaller program analyses and performs lighter transformations. Several approaches have been proposed for modular attribute specification <ref> [4, 7, 8, 10, 13] </ref> and modular attribute evaluation [10, 13]. Modular specification improves the readability of attribute grammars and allows more convenient modular evaluation. Modular evaluation provides the flexibility of turning on and off attribution modules as necessary, which results in evaluators that are speedier and more storage-efficient [10]. <p> This iteration can be automated with rewriting. Modular attribute evaluation. Heavy program transformations are usually composed of separate phases, where each phase conducts smaller program analyses and performs lighter transformations. Several approaches have been proposed for modular attribute specification [4, 7, 8, 10, 13] and modular attribute evaluation <ref> [10, 13] </ref>. Modular specification improves the readability of attribute grammars and allows more convenient modular evaluation. Modular evaluation provides the flexibility of turning on and off attribution modules as necessary, which results in evaluators that are speedier and more storage-efficient [10]. They are particularly useful for phase-based transformations. <p> For example, OPTRAN [18] is an attribute-grammar-based system extended with rewrite mechanisms. However, it is still a batch-oriented system mainly for compiler applications rather than general program transformations. Another difference is that traditional attribute-grammar-based programming environments perform code generation by attribution <ref> [4, 13, 30] </ref>, while CACHET transforms programs by direct manipulation. How to do program transformation by attribution in the presence of annotation is related to incremental replay, as discussed in Section 6. <p> Thus, tree attribution is used not only for semantics analysis, but also for recording transformed versions of the program. Attribution has been traditionally used in programming environments for code generation [30]; it has also been proposed for general program transformation, including phase-based transformation. Approaches include attribute coupled grammars <ref> [13] </ref>, higher-order attribute grammars [32], composable attribute grammars [10], and simple tree attributions [4]. Incremental attribute evaluation algorithms for these frameworks could be used for incremental code generation. However, these frameworks do not address external input.
Reference: [14] <author> R. Heckmann. </author> <title> A functional language for the specification of complex tree transformations. </title> <booktitle> In Proc. of the 2nd ESOP, vol. 300 of LNCS, </booktitle> <pages> pages 175-190, </pages> <address> France, </address> <month> Mar. </month> <year> 1988. </year>
Reference-contexts: The mechanisms needed for tree transformations are mainly pattern matching and pattern instantia-tion. Languages designed specifically for specifying complex tree transformations <ref> [14] </ref>, which may include sophisticated pattern matching languages with, for example, second-order patterns [15], can greatly facilitate programming various transformations. Transformations should be able to access attributes associated with the tree, since they are often conditioned on the results of program analyses, which are performed by tree attribution.
Reference: [15] <author> G. Huet and B. Lang. </author> <title> Proving and applying program transformations expressed with second-order patterns. </title> <journal> Acta Infor-matica, </journal> <volume> 11(1) </volume> <pages> 31-55, </pages> <year> 1978. </year>
Reference-contexts: 1 Introduction Program transformation systems are important tools that implement various program manipulations that preserve program semantics and improve program performance <ref> [3, 11, 12, 15, 24, 26, 28, 31] </ref>. Interactive program transformation. Program transformation systems are often required to be interactive, for at least the following two reasons. First, the goal of the system is often so ambitious that no fully automatic transformation can succeed; interaction allows convenient semi-automatic transformation. <p> The mechanisms needed for tree transformations are mainly pattern matching and pattern instantia-tion. Languages designed specifically for specifying complex tree transformations [14], which may include sophisticated pattern matching languages with, for example, second-order patterns <ref> [15] </ref>, can greatly facilitate programming various transformations. Transformations should be able to access attributes associated with the tree, since they are often conditioned on the results of program analyses, which are performed by tree attribution.
Reference: [16] <author> L. G. Jones. </author> <title> Efficient evaluation of circular attribute grammars. </title> <journal> ACM Trans. on Programming Languages and Systems, </journal> <volume> 12(3) </volume> <pages> 429-462, </pages> <month> Jul. </month> <year> 1990. </year>
Reference-contexts: Circular attribute evaluation. Some program analyses are based on fixed point iteration. If such analyses are done by attribute evaluation, then circular attribute evaluation methods are needed. Although solutions to this problem have been proposed <ref> [9, 16] </ref>, they are rarely implemented due to complications and inefficiency. Here, we briefly describe how circular attribute evaluation can be simulated using tree transformations and annotations.
Reference: [17] <author> G. E. Kaiser. </author> <title> Incremental dynamic semantics for language-based programming environments. </title> <journal> ACM Trans. on Programming Languages and Systems, </journal> <volume> 11(2) </volume> <pages> 168-193, </pages> <month> Apr. </month> <year> 1989. </year>
Reference-contexts: As program transformation generalizes symbolic, and thus normal, executions of programs, external input includes dynamic information that can be set during program executions, e.g., the breakpoints in a debugger or the instruction pointer in an interpreter. Such dynamic semantics <ref> [17] </ref> is needed for run-time support, symbolic debuggers, interpreters, as well as interactive program transformation systems. External input scattered in the middle of program execution or transformation is a new concept lacking in traditional declarative attribute-grammar-based environments. <p> Techniques that address such dynamic program semantics have been lacking in traditional attribute-grammar-based programming environments <ref> [17] </ref>. For example, OPTRAN [18] is an attribute-grammar-based system extended with rewrite mechanisms. However, it is still a batch-oriented system mainly for compiler applications rather than general program transformations.
Reference: [18] <author> P. Lipps, U. Moncke, and R. Wilhelm. OPTRAN: </author> <title> A language/system for the specification of program transformation|system overview and experiences. </title> <booktitle> In Proc. of the 2nd Workshop on Compiler Compilers and High Speed Compilation, vol. 371 of LNCS, </booktitle> <pages> pages 52-65, </pages> <address> Berlin, </address> <month> Oct. </month> <year> 1988. </year>
Reference-contexts: Techniques that address such dynamic program semantics have been lacking in traditional attribute-grammar-based programming environments [17]. For example, OPTRAN <ref> [18] </ref> is an attribute-grammar-based system extended with rewrite mechanisms. However, it is still a batch-oriented system mainly for compiler applications rather than general program transformations. Another difference is that traditional attribute-grammar-based programming environments perform code generation by attribution [4, 13, 30], while CACHET transforms programs by direct manipulation.
Reference: [19] <author> Y. A. Liu and T. Teitelbaum. </author> <title> Systematic derivation of incremental programs. </title> <booktitle> Science of Computer Programming, </booktitle> <volume> 24(1) </volume> <pages> 1-39, </pages> <month> Feb. </month> <year> 1995. </year>
Reference-contexts: Instead, this paper describes how to adopt a traditional programming environment and make it suitable for performing complex tree transformations, interleaving transformations with external inputs, such as user inputs, and making more use of attribution mechanisms. Deriving Incremental Programs. CACHET has special functionality for deriving incremental programs <ref> [19] </ref>. Given a program f and an input change , a program f 0 that computes the result of f (x y) efficiently by making use of the value of f (x) is called an incremental version of f under . <p> Incremental computation has wide applications through computer software, e.g., optimizing compilers [1, 5, 23], transformational program development [3, 24, 31], and interactive systems [2, 22, 30]. Liu and Teitelbaum <ref> [19] </ref> give a systematic transformational approach for deriving an incremental program f 0 from a given program f and an input change . <p> This efficient way of computing f (xy) is captured in the definition of f 0 (x; y; r). The transformational approach can be made automatic or semi-automatic depending on the required incrementalization power. CACHET performs function introduction with generalization <ref> [19] </ref> to introduce incremental versions with cached results of the previous computation as parameters, and it uses auxiliary specialization [19] to find subcomputations whose values can be retrieved from the cached results of the previous computation. <p> The transformational approach can be made automatic or semi-automatic depending on the required incrementalization power. CACHET performs function introduction with generalization <ref> [19] </ref> to introduce incremental versions with cached results of the previous computation as parameters, and it uses auxiliary specialization [19] to find subcomputations whose values can be retrieved from the cached results of the previous computation. CACHET has been used to derive numerous incremental programs, including most of the examples in [19, 20, 21]. <p> CACHET has been used to derive numerous incremental programs, including most of the examples in <ref> [19, 20, 21] </ref>. It has also been of great help in studying transformations for caching intermediate results [20] and discovering auxiliary information [21]. The rest of the paper is organized as follows. Section 2 gives an overview of the desired features, the problems to be solved, and the suggested solutions. <p> With pattern matching and instantiation, and with access to attributes, we can program various transformations, such as fold-unfold, simplification, specialization, and transformations enabled by equality analysis. Some transformations require more complicated treatment; in particular, function introduction with generalization <ref> [19] </ref> involves suspending transformation on the current tree and preparing a new subtree for recursive transformations. Finally, a metalanguage for complex tree transformations should include a rewrite engine that can apply a set of transformations repeatedly to a subtree in a certain traversal order. <p> Manual invocation is used mainly for two reasons. First, the Synthesizer Generator allows only subtree replacement and does not currently have a rewrite engine for a fully-automatic exhaustive application of basic transformations, in particular, for applicative-order reduction, as specified by the incrementalization approach <ref> [19] </ref>. Second, we want an interactive environment to study various transformations; thus, manual invocation is suitable most of the time. Mechanisms for defining combinations of transformations, especially rewrite mechanisms, are being added to the Synthesizer Generator to further automate derivations. <p> Techniques for managing the interactions among tree transformation, external input, and incremental attribution can be used to generate powerful and incremental transformation systems. 4 Example derivation CACHET is designed specifically for deriving incremental programs. It has been used for most of the examples in <ref> [19, 20, 21] </ref>. The programs transformed by CACHET are written in a first-order functional language, where expressions in function definitions are composed of variables, data constructions, primitive function applications, user-defined recursive function applications, conditional expressions, and binding expressions. An example is given in the back window of Figure 1. <p> The derivation above is performed by manually selecting the subexpression and clicking on one of the enabled transforms. After we implement the rewrite engine, we will be able to automate the derivation using an applicative-order rewrite <ref> [19] </ref>. However, to see all the interesting intermediate results during the derivation, manual invocation is appropriate. 5 Related work Program transformation systems and the approaches and techniques used therein are described in a number of surveys, e.g., [12, 26].
Reference: [20] <author> Y. A. Liu and T. Teitelbaum. </author> <title> Caching intermediate results for program improvement. </title> <booktitle> In Proc. of the ACM SIGPLAN Symp. on PEPM, </booktitle> <pages> pages 190-201, </pages> <address> La Jolla, CA, </address> <month> Jun. </month> <year> 1995. </year>
Reference-contexts: CACHET has been used to derive numerous incremental programs, including most of the examples in <ref> [19, 20, 21] </ref>. It has also been of great help in studying transformations for caching intermediate results [20] and discovering auxiliary information [21]. The rest of the paper is organized as follows. Section 2 gives an overview of the desired features, the problems to be solved, and the suggested solutions. <p> CACHET has been used to derive numerous incremental programs, including most of the examples in [19, 20, 21]. It has also been of great help in studying transformations for caching intermediate results <ref> [20] </ref> and discovering auxiliary information [21]. The rest of the paper is organized as follows. Section 2 gives an overview of the desired features, the problems to be solved, and the suggested solutions. Section 3 describes the implementation techniques used for CACHET. <p> So far, the need for modular attribute specification and implementation is not strong, but we expect that it would be very helpful when we implement the derivation approaches for exploiting intermediate results <ref> [20] </ref> and auxiliary information [21], since they are strongly phase-oriented. We believe these implementation issues form a very promising area. Program tree attribution provides a declarative framework for program analyses, which are needed to guide powerful program transformations. <p> Techniques for managing the interactions among tree transformation, external input, and incremental attribution can be used to generate powerful and incremental transformation systems. 4 Example derivation CACHET is designed specifically for deriving incremental programs. It has been used for most of the examples in <ref> [19, 20, 21] </ref>. The programs transformed by CACHET are written in a first-order functional language, where expressions in function definitions are composed of variables, data constructions, primitive function applications, user-defined recursive function applications, conditional expressions, and binding expressions. An example is given in the back window of Figure 1.
Reference: [21] <author> Y. A. Liu and T. Teitelbaum. </author> <title> Incremental computation for transformational software development. </title> <type> TR 95-1499, </type> <institution> Cornell University, </institution> <month> Mar. </month> <year> 1995. </year>
Reference-contexts: CACHET has been used to derive numerous incremental programs, including most of the examples in <ref> [19, 20, 21] </ref>. It has also been of great help in studying transformations for caching intermediate results [20] and discovering auxiliary information [21]. The rest of the paper is organized as follows. Section 2 gives an overview of the desired features, the problems to be solved, and the suggested solutions. <p> CACHET has been used to derive numerous incremental programs, including most of the examples in [19, 20, 21]. It has also been of great help in studying transformations for caching intermediate results [20] and discovering auxiliary information <ref> [21] </ref>. The rest of the paper is organized as follows. Section 2 gives an overview of the desired features, the problems to be solved, and the suggested solutions. Section 3 describes the implementation techniques used for CACHET. Section 4 contains a sample derivation of an incremental program using CACHET. <p> So far, the need for modular attribute specification and implementation is not strong, but we expect that it would be very helpful when we implement the derivation approaches for exploiting intermediate results [20] and auxiliary information <ref> [21] </ref>, since they are strongly phase-oriented. We believe these implementation issues form a very promising area. Program tree attribution provides a declarative framework for program analyses, which are needed to guide powerful program transformations. <p> Techniques for managing the interactions among tree transformation, external input, and incremental attribution can be used to generate powerful and incremental transformation systems. 4 Example derivation CACHET is designed specifically for deriving incremental programs. It has been used for most of the examples in <ref> [19, 20, 21] </ref>. The programs transformed by CACHET are written in a first-order functional language, where expressions in function definitions are composed of variables, data constructions, primitive function applications, user-defined recursive function applications, conditional expressions, and binding expressions. An example is given in the back window of Figure 1.
Reference: [22] <author> R. Medina-Mora and P. Feiler. </author> <title> An incremental programming environment. </title> <journal> IEEE Trans. on Software Eng., </journal> <volume> SE-7(5):472-482, </volume> <month> Sept. </month> <year> 1981. </year>
Reference-contexts: Incremental computation has wide applications through computer software, e.g., optimizing compilers [1, 5, 23], transformational program development [3, 24, 31], and interactive systems <ref> [2, 22, 30] </ref>. Liu and Teitelbaum [19] give a systematic transformational approach for deriving an incremental program f 0 from a given program f and an input change .
Reference: [23] <editor> S. S. Muchnick and N. D. Jones, editors. </editor> <title> Program Flow Analysis: Theory and Applications. </title> <publisher> Prentice-Hall, </publisher> <year> 1981. </year>
Reference-contexts: Incremental computation has wide applications through computer software, e.g., optimizing compilers <ref> [1, 5, 23] </ref>, transformational program development [3, 24, 31], and interactive systems [2, 22, 30]. Liu and Teitelbaum [19] give a systematic transformational approach for deriving an incremental program f 0 from a given program f and an input change .
Reference: [24] <author> R. Paige. </author> <title> Viewing a program transformation system at work. </title> <booktitle> In Proc. of Joint 6th Intl. Conf. on PLILP and 4th Intl. Conf. on ALP, vol. 844 of LNCS, </booktitle> <pages> pages 5-24, </pages> <month> Sept. </month> <year> 1994. </year>
Reference-contexts: 1 Introduction Program transformation systems are important tools that implement various program manipulations that preserve program semantics and improve program performance <ref> [3, 11, 12, 15, 24, 26, 28, 31] </ref>. Interactive program transformation. Program transformation systems are often required to be interactive, for at least the following two reasons. First, the goal of the system is often so ambitious that no fully automatic transformation can succeed; interaction allows convenient semi-automatic transformation. <p> The simple storage of the analysis results makes it hard to incrementalize the analyses under the transformations. This creates a performance bottleneck that is more severe for more automated systems <ref> [24] </ref>. Using an attribute-grammar-based programming environment. Interactive program transformation and incremental program analysis naturally lead one to consider an attribute-grammar-based programming environment. The Synthesizer Generator is a commercially available system that generates such environments [30]. <p> Incremental computation has wide applications through computer software, e.g., optimizing compilers [1, 5, 23], transformational program development <ref> [3, 24, 31] </ref>, and interactive systems [2, 22, 30]. Liu and Teitelbaum [19] give a systematic transformational approach for deriving an incremental program f 0 from a given program f and an input change . <p> However, to see all the interesting intermediate results during the derivation, manual invocation is appropriate. 5 Related work Program transformation systems and the approaches and techniques used therein are described in a number of surveys, e.g., [12, 26]. Eminent systems among them and recent systems include APTS <ref> [24] </ref>, KIDS [31], CIP [3], Focus [28], and ZAP [11]. Compared to these systems, the most important and unique characteristic of CACHET is its use of attribute grammars. This has at least two advantages. <p> To our knowledge, none of these other systems use incremental attribute evaluation, although incremental semantic analysis is desirable in all of them, especially for the more automatic approaches in APTS <ref> [24] </ref>. Also, since CACHET is implemented using a language-based editor generator, it has a flexible interactive user interface, as is provided by the existing technologies of program environments. Among the systems above, KIDS [31] seems to be the only one with such a flexible user interface. <p> This functionality provides a general solution to the finite differencing problem, which must be addressed in program derivation from specification and program improvement in general <ref> [3, 24, 25, 31] </ref> 6 Future work A number of problems need to be further studied. We discuss major ones here. Annotation. Annotation provides a declarative framework for describing dynamic program semantics. However, formal description of annotation in the context of attribute-grammars is needed.
Reference: [25] <author> R. Paige and S. Koenig. </author> <title> Finite differencing of computable expressions. </title> <journal> ACM Trans. on Programming Languages and Systems, </journal> <volume> 4(3) </volume> <pages> 402-454, </pages> <month> Jul. </month> <year> 1982. </year>
Reference-contexts: This functionality provides a general solution to the finite differencing problem, which must be addressed in program derivation from specification and program improvement in general <ref> [3, 24, 25, 31] </ref> 6 Future work A number of problems need to be further studied. We discuss major ones here. Annotation. Annotation provides a declarative framework for describing dynamic program semantics. However, formal description of annotation in the context of attribute-grammars is needed.
Reference: [26] <author> H. Partsch and R. Steinbruggen. </author> <title> Program transformation systems. </title> <journal> Computing Surveys, </journal> <volume> 15(3) </volume> <pages> 199-236, </pages> <month> Sept. </month> <year> 1983. </year>
Reference-contexts: 1 Introduction Program transformation systems are important tools that implement various program manipulations that preserve program semantics and improve program performance <ref> [3, 11, 12, 15, 24, 26, 28, 31] </ref>. Interactive program transformation. Program transformation systems are often required to be interactive, for at least the following two reasons. First, the goal of the system is often so ambitious that no fully automatic transformation can succeed; interaction allows convenient semi-automatic transformation. <p> However, to see all the interesting intermediate results during the derivation, manual invocation is appropriate. 5 Related work Program transformation systems and the approaches and techniques used therein are described in a number of surveys, e.g., <ref> [12, 26] </ref>. Eminent systems among them and recent systems include APTS [24], KIDS [31], CIP [3], Focus [28], and ZAP [11]. Compared to these systems, the most important and unique characteristic of CACHET is its use of attribute grammars. This has at least two advantages.
Reference: [27] <author> L. Paulson. </author> <title> A higher-order implementation of rewriting. </title> <booktitle> Science of Computer Programming, </booktitle> <volume> 3 </volume> <pages> 119-149, </pages> <year> 1983. </year>
Reference-contexts: Finally, a metalanguage for complex tree transformations should include a rewrite engine that can apply a set of transformations repeatedly to a subtree in a certain traversal order. Higher-order term rewriting <ref> [27] </ref> offers a framework for defining such rewrites. What needs to be provided is the ability to automatically interleave such repeated rewriting with incremental attribute evaluation. 2.2 External input as annotation Program transformations are often semi-automatic and involve interaction with users or other external facilities, such as theorem provers.
Reference: [28] <author> U. Reddy. </author> <title> Transformational derivation of programs using the Focus system. </title> <booktitle> In Proc. of the ACM SIGSOFT/SIGPLAN Software Eng. Symp. on Practical Software Development Environments, </booktitle> <pages> pages 163-172, </pages> <year> 1988. </year>
Reference-contexts: 1 Introduction Program transformation systems are important tools that implement various program manipulations that preserve program semantics and improve program performance <ref> [3, 11, 12, 15, 24, 26, 28, 31] </ref>. Interactive program transformation. Program transformation systems are often required to be interactive, for at least the following two reasons. First, the goal of the system is often so ambitious that no fully automatic transformation can succeed; interaction allows convenient semi-automatic transformation. <p> They are particularly useful for phase-based transformations. In particular, for phases not involving circular attributes, efficient evaluators for non-circular attribute grammars can be generated. 2.4 Replay A minimal approach to replaying transformations is to record the history or script of external input <ref> [28] </ref>. Powerful metalanguages can help reduce the recording work [11]; for example, with a metalanguage that allows rewrite, we can record one rewrite in place of a sequence of transformations involved in the rewrite. <p> Eminent systems among them and recent systems include APTS [24], KIDS [31], CIP [3], Focus <ref> [28] </ref>, and ZAP [11]. Compared to these systems, the most important and unique characteristic of CACHET is its use of attribute grammars. This has at least two advantages. <p> CACHET can benefit from a stronger metalan-guage, such as that pioneered by ZAP [11], and certain replay functionality, such as that in Focus <ref> [28] </ref>. As discussed in Sections 2 and 3, a metalanguage for powerful tree transformation has been designed and is being implemented for CACHET. How to integrate replay and incremental replay in an attribute grammar framework with annotation is a problem to be studied.
Reference: [29] <author> S. P. Reiss. </author> <title> Interacting with the FIELD environment. </title> <journal> Software|Practice and Experience, </journal> <volume> 20(S1):89-115, </volume> <month> Jun. </month> <year> 1990. </year>
Reference-contexts: Of course, a user can define the value of an annotation using anything, including attributes. The term annotation is used by Reiss in his FIELD environment <ref> [29] </ref> as the primary mechanism for interacting with the source file in an editor; for example, a breakpoint in the debugger is associated with an annotation in the editor.
Reference: [30] <author> T. Reps and T. Teitelbaum. </author> <title> The Synthesizer Generator: A System for Constructing Language-Based Editors. </title> <publisher> Springer-Verlag, </publisher> <year> 1988. </year>
Reference-contexts: This creates a performance bottleneck that is more severe for more automated systems [24]. Using an attribute-grammar-based programming environment. Interactive program transformation and incremental program analysis naturally lead one to consider an attribute-grammar-based programming environment. The Synthesizer Generator is a commercially available system that generates such environments <ref> [30] </ref>. With such a tool, the syntax of programs can be described using a context-free grammar, and properties of programs can be described using attribute equations. <p> Incremental computation has wide applications through computer software, e.g., optimizing compilers [1, 5, 23], transformational program development [3, 24, 31], and interactive systems <ref> [2, 22, 30] </ref>. Liu and Teitelbaum [19] give a systematic transformational approach for deriving an incremental program f 0 from a given program f and an input change . <p> An alternative to the direct tree manipulation framework for the purpose of replay is discussed in Section 6. 3 Implementation A prototype system, CACHET, based on the design principles in the previous section, has been implemented. It uses the Synthesizer Generator <ref> [30] </ref>, a system for generating language-based editors, and consists of about 18,000 lines of code written in SSL, the Synthesizer Generator language for specifying editors. <p> The values of these attributes can be displayed any time, as facilitated by the Synthesizer Generator <ref> [30] </ref>, to help the user understand the derivation. Of course, these attributes are evaluated incrementally after each transformation step. Methods for circular attribute evaluation still need to be implemented, either by extending the Synthesizer Generator or using the simulation proposed in the previous section. <p> For example, OPTRAN [18] is an attribute-grammar-based system extended with rewrite mechanisms. However, it is still a batch-oriented system mainly for compiler applications rather than general program transformations. Another difference is that traditional attribute-grammar-based programming environments perform code generation by attribution <ref> [4, 13, 30] </ref>, while CACHET transforms programs by direct manipulation. How to do program transformation by attribution in the presence of annotation is related to incremental replay, as discussed in Section 6. <p> Thus, tree attribution is used not only for semantics analysis, but also for recording transformed versions of the program. Attribution has been traditionally used in programming environments for code generation <ref> [30] </ref>; it has also been proposed for general program transformation, including phase-based transformation. Approaches include attribute coupled grammars [13], higher-order attribute grammars [32], composable attribute grammars [10], and simple tree attributions [4]. Incremental attribute evaluation algorithms for these frameworks could be used for incremental code generation.
Reference: [31] <author> D. R. Smith. KIDS: </author> <title> A semiautomatic program development system. </title> <journal> IEEE Trans. on Software Eng., </journal> <volume> 16(9) </volume> <pages> 1024-1043, </pages> <month> Sept. </month> <year> 1990. </year>
Reference-contexts: 1 Introduction Program transformation systems are important tools that implement various program manipulations that preserve program semantics and improve program performance <ref> [3, 11, 12, 15, 24, 26, 28, 31] </ref>. Interactive program transformation. Program transformation systems are often required to be interactive, for at least the following two reasons. First, the goal of the system is often so ambitious that no fully automatic transformation can succeed; interaction allows convenient semi-automatic transformation. <p> Incremental computation has wide applications through computer software, e.g., optimizing compilers [1, 5, 23], transformational program development <ref> [3, 24, 31] </ref>, and interactive systems [2, 22, 30]. Liu and Teitelbaum [19] give a systematic transformational approach for deriving an incremental program f 0 from a given program f and an input change . <p> However, to see all the interesting intermediate results during the derivation, manual invocation is appropriate. 5 Related work Program transformation systems and the approaches and techniques used therein are described in a number of surveys, e.g., [12, 26]. Eminent systems among them and recent systems include APTS [24], KIDS <ref> [31] </ref>, CIP [3], Focus [28], and ZAP [11]. Compared to these systems, the most important and unique characteristic of CACHET is its use of attribute grammars. This has at least two advantages. <p> Also, since CACHET is implemented using a language-based editor generator, it has a flexible interactive user interface, as is provided by the existing technologies of program environments. Among the systems above, KIDS <ref> [31] </ref> seems to be the only one with such a flexible user interface. <p> This functionality provides a general solution to the finite differencing problem, which must be addressed in program derivation from specification and program improvement in general <ref> [3, 24, 25, 31] </ref> 6 Future work A number of problems need to be further studied. We discuss major ones here. Annotation. Annotation provides a declarative framework for describing dynamic program semantics. However, formal description of annotation in the context of attribute-grammars is needed.
Reference: [32] <author> H. H. Vogt, D. Swierstra, and M. F. Kuiper. </author> <title> Higher order attribute grammars. </title> <booktitle> In Proc. of the ACM SIGPLAN '89 Conf. on PLDI, </booktitle> <pages> pages 131-145, </pages> <month> Jun. </month> <year> 1989. </year>
Reference-contexts: Attribution has been traditionally used in programming environments for code generation [30]; it has also been proposed for general program transformation, including phase-based transformation. Approaches include attribute coupled grammars [13], higher-order attribute grammars <ref> [32] </ref>, composable attribute grammars [10], and simple tree attributions [4]. Incremental attribute evaluation algorithms for these frameworks could be used for incremental code generation. However, these frameworks do not address external input.
References-found: 32

