URL: http://www.cs.rutgers.edu/~uli/cs671/altman-pldi95.ps
Refering-URL: http://www.cs.rutgers.edu/~uli/cs671/index.html
Root-URL: http://www.cs.rutgers.edu
Email: erik@macs.ee.mcgill.ca govind@cs.mun.ca gao@cs.mcgill.ca  
Title: Scheduling and Mapping: Software Pipelining in the Presence of Structural Hazards proposed formulation and a
Author: Erik R. Altman R. Govindarajan Guang R. Gao 
Note: The  10/30.  
Address: Montreal, H3A 2A7, CANADA St. John's, A1B 3X5, CANADA Montreal, H3A 2A7, CANADA  
Affiliation: Dept. of Electrical Engineering Dept. of Computer Science School of Computer Science McGill University Memorial Univ. of Newfoundland McGill University  
Abstract: Recently, software pipelining methods based on an ILP (Integer Linear Programming) framework have been successfully applied to derive rate-optimal schedules for architectures involving clean pipelines | pipelines without structural hazards. The problem for architectures beyond such clean pipelines remains open. One challenge is how, under a unified ILP framework, to simultaneously represent resource constraints for unclean pipelines, and the assignment or mapping of operations from a loop to those pipelines. In this paper we provide a framework which does exactly this, and in addition constructs rate-optimal software pipelined schedules. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> A. Aiken and A. Nicolau. </author> <title> Optimal loop parallelization. </title> <booktitle> In Proc. of the SIGPLAN '88 Conf. on Programming Language Design and Implementation, </booktitle> <pages> pages 308-317, </pages> <address> Atlanta, Georgia, </address> <month> Jun. </month> <pages> 22-24, </pages> <year> 1988. </year>
Reference-contexts: The t i variables in our linear periodic schedule form can be related to the A matrix as T = T K + A Transpose fi <ref> [0; 1; ; T 1] </ref> Transpose (1) where K and T are N -element vectors. <p> Notice that the A matrix specifies only the time step (in the repetitive pattern) at which an instruction is initiated. To determine resource requirements with T = <ref> [0; 1; 3; 5; 7; 11] </ref> Transpose ; K = [0; 0; 0; 1; 1; 2] Transpose ; and A = 6 4 0 1 0 1 0 0 0 0 1 0 1 1 7 5 : 6 ops fi (T = 4) 2 6 1 0 1 0 1 <p> Notice that the A matrix specifies only the time step (in the repetitive pattern) at which an instruction is initiated. To determine resource requirements with T = [0; 1; 3; 5; 7; 11] Transpose ; K = <ref> [0; 0; 0; 1; 1; 2] </ref> Transpose ; and A = 6 4 0 1 0 1 0 0 0 0 1 0 1 1 7 5 : 6 ops fi (T = 4) 2 6 1 0 1 0 1 0 0 1 0 1 0 0 3 7 non-pipelined <p> h1 X C r R r subject to X u t;i R r ; 8r 2 [0; h 1]; 8t 2 [0; T 1] (5) (d i 1) X a ((tl) mod T );i 8t 2 [0; T 1]; 8i 2 E T = T K + A Transpose fi <ref> [0; 1; ; T 1] </ref> Transpose (7) t j t i d i T m ij 8 (i; j) 2 E (8) t=0 t i 0; k i 0; a t;i 0 and u t;i 0 are integers (10) 8i 2 [0; N 1]; 8t 2 [0; T 1] 4.2 Coloring <p> 2 [0; s r 1]; 8t 2 [0; T 1]; and 8r 2 [0; h 1] c i c j 2 c j c i 2 8i; j 2 I (r); 8t 2 [0; T 1]; and 8r 2 [0; h 1] T = T K + A Transpose fi <ref> [0; 1; ; T 1] </ref> Transpose (22) T 1 X a t;i = 1 8i 2 [0; N 1] (23) U s [t; i] = l=0 r [l] (25) ft i 0; k i 0; a t;i 0; c i 1; 0 d i;j 1; U s [t; i] 0g : <p> In particular, in terms of resource constraints, the work reported in <ref> [1, 24, 18] </ref>, does not consider any resource constraint while the methods reported in [7, 11, 17, 20, 26, 27] deal with function unit constraints but with simple resource usage. Both function unit and register resource constraints are considered in [13, 5].
Reference: [2] <author> E.R. Altman. </author> <title> Two Approaches for Optimal Software Pipelining with Resource Constraints (In Preparation). </title> <type> PhD thesis, </type> <institution> McGill U., Montreal, Que., </institution> <year> 1995. </year>
Reference-contexts: There is experimental evidence that ILP approaches may produce better schedules than many heuristic methods for software pipelining [9]. One interesting question is: will cleverly designed exhaustive search methods be superior to an ILP solver in terms of efficiency? Although we have lately been working on exploiting such alternatives <ref> [2] </ref>, it is still too early to make a conclusion. In the meantime, we note that significant progress has been made in developing efficient ILP algorithms. We believe that ILP methods for software pipelining should take advantage of such developments and further improve their performance. <p> Notice that the A matrix specifies only the time step (in the repetitive pattern) at which an instruction is initiated. To determine resource requirements with T = [0; 1; 3; 5; 7; 11] Transpose ; K = <ref> [0; 0; 0; 1; 1; 2] </ref> Transpose ; and A = 6 4 0 1 0 1 0 0 0 0 1 0 1 1 7 5 : 6 ops fi (T = 4) 2 6 1 0 1 0 1 0 0 1 0 1 0 0 3 7 non-pipelined <p> Theorem 4.1 Equations 12 - 14 require that two nodes i and j be assigned different colors (mapped to different function units) if and only if they overlap. For a proof, please see <ref> [2] </ref> For our ILP formulation we require that there be at least as many function units of each type as colors.
Reference: [3] <author> R. P. Colwell, R. P. Nix, J. J. O'Donnell, D. B. Pap-worth, and P. K. Rodman. </author> <title> A VLIW architecture for a trace scheduling compiler. </title> <journal> IEEE Trans. on Computers, </journal> <pages> pages 967-979, </pages> <month> Aug. </month> <year> 1988. </year>
Reference-contexts: This fixed instruction (task) to FU mapping may also be essential in architectures with multiple register sets (such as the Multiflow Trace machine <ref> [3] </ref>), with each dedicated to one (or a group of) execution units. To illustrate the significance of this fixed assignment constraint, examine Schedule A in Table 1. <p> Notice that the A matrix specifies only the time step (in the repetitive pattern) at which an instruction is initiated. To determine resource requirements with T = <ref> [0; 1; 3; 5; 7; 11] </ref> Transpose ; K = [0; 0; 0; 1; 1; 2] Transpose ; and A = 6 4 0 1 0 1 0 0 0 0 1 0 1 1 7 5 : 6 ops fi (T = 4) 2 6 1 0 1 0 1
Reference: [4] <author> J. C. Dehnert and R. A. Towle. </author> <title> Compiling for Cydra 5. </title> <journal> Journal of Supercomputing, </journal> <volume> 7 </volume> <pages> 181-227, </pages> <month> May </month> <year> 1993. </year>
Reference-contexts: It is well known that the minimum initiation interval T min of successive iterations of a loop is constrained by both loop-carried dependences and available resources <ref> [4, 13, 16, 19, 20] </ref>. The loop-carried dependences put a lower bound, T dep , on T . The value of T dep is determined by the critical cycle (s) in the loop [23]. <p> Both function unit and register resource constraints are considered in [13, 5]. Software pipelining methods for complex usage patterns with limited function units was dealt with by <ref> [4, 16] </ref>. The methods proposed in these works that aim to be implementable in a practical compiler all use heuristic approaches. In this paper, we develop a clear mathematical formulation of the software pipelining problem.
Reference: [5] <author> A. E. Eichenberger, E. S. Davidson, and S. G. Abra-ham. </author> <title> Minimum register requirements for a modulo schedule. </title> <booktitle> In Proc. of the 27th Ann. Intl. Symp. on Microarchitecture, </booktitle> <pages> pages 75-84, </pages> <address> San Jose, Calif., Nov. 30-Dec.2, </address> <year> 1994. </year>
Reference-contexts: Notice that the A matrix specifies only the time step (in the repetitive pattern) at which an instruction is initiated. To determine resource requirements with T = <ref> [0; 1; 3; 5; 7; 11] </ref> Transpose ; K = [0; 0; 0; 1; 1; 2] Transpose ; and A = 6 4 0 1 0 1 0 0 0 0 1 0 1 1 7 5 : 6 ops fi (T = 4) 2 6 1 0 1 0 1 <p> Clearly, for fixed FU assignment, T d s . Further, it is necessary that no stage in a pipeline is used by an instruction at two time steps that are equal mod T . Such a constraint, known as the modulo scheduling constraint <ref> [5, 11, 19] </ref>, is necessary for fixed FU assignment. In the subsequent discussion we assume that the modulo scheduling constraint is always satisfied for the given T . Cases where the modulo scheduling constraint is not satisfied is beyond the scope of this paper. <p> Both function unit and register resource constraints are considered in <ref> [13, 5] </ref>. Software pipelining methods for complex usage patterns with limited function units was dealt with by [4, 16]. The methods proposed in these works that aim to be implementable in a practical compiler all use heuristic approaches. <p> It can incorporate minimizing buffers (logical registers) as in [18] or minimizing the maximum number of live values at any time step in the repetitive pattern, as in the method proposed by Eichenberger, Davidson and Abraham <ref> [5] </ref>. 8 Conclusions In this paper we have proposed a method to formulate scheduling and mapping problems in a unified framework. Our method can handle non-pipelined execution units and pipelines with structural hazards.
Reference: [6] <author> P. Feautrier. </author> <title> Fine-grain Scheduling under Resource Constraints. </title> <booktitle> In Seventh Annual Workshop on Languages and Compilers for Parallel Computing, </booktitle> <address> Ithaca, USA, </address> <month> August </month> <year> 1994. </year>
Reference-contexts: Integer Linear Programming (ILP)-based and other approaches have been proposed for finding an optimal periodic schedule on machines with simple resource usage <ref> [6, 9, 25] </ref>. However, this work has assumed that function units are either completely pipelined or have no pipelining at all. Furthermore, it did not address the issue of mapping, that is the assignment of instructions to specific function units. <p> For example if a loop has 3 divide instructions, a, b, and c and the architecture, 2 Divide units, X and Y, the mapping determines whether a is executed on X or Y, and likewise for b and c. Earlier work based on the ILP approach <ref> [6, 9] </ref> implicitly assumes that the mapping is done at run-time, based on which of the function units are available. <p> 13 14 Iteration = 0 i0 i1 i1 i2 i2 i3 i3 i4 i4 i5 Iteration = 1 i0 i1 i1 i2 i2 i3 i3 i4 i4 Iteration = 2 i0 i1 i1 i2 i2 i3 i3 Table 2: Alternative Schedule B for the Motivating Example (with T = 4) <ref> [0; 6] </ref>), a repetitive pattern ([7; 9]), and an epilog. <p> In [9] we compared three heuristic algorithms with an ILP scheduling method for clean pipelines. In <ref> [6] </ref> Feautrier independently gave an ILP formulation similar to our earlier work. Our method is unique in that it combines scheduling and mapping in a unified framework and attempts to achieve an optimal solution.
Reference: [7] <author> F. Gasperoni and U. Schwiegelshohn. </author> <title> Efficient algorithms for cyclic scheduling. Res. </title> <type> Rep. RC 17068, </type> <institution> IBM T. J. Watson Res. Center, Yorktown Heights, </institution> <year> 1991. </year>
Reference-contexts: The performance of a software-pipelined schedule is measured by the initiation rate of successive iterations. The problem of finding, under resource constraints, an optimal schedule (i.e. with the fastest possible or "rate-optimal" initiation rate) is NP-hard. Various heuristic solution methods <ref> [7, 13, 22, 26] </ref> have been proposed to solve the problem efficiently. In this paper, we are interested in solution methods based on ILP. In contrast to heuristic scheduling algorithms which find approximate (or suboptimal) solutions, ILP methods are based on a formulation where an objective optimality function is specified. <p> Notice that the A matrix specifies only the time step (in the repetitive pattern) at which an instruction is initiated. To determine resource requirements with T = <ref> [0; 1; 3; 5; 7; 11] </ref> Transpose ; K = [0; 0; 0; 1; 1; 2] Transpose ; and A = 6 4 0 1 0 1 0 0 0 0 1 0 1 1 7 5 : 6 ops fi (T = 4) 2 6 1 0 1 0 1 <p> In particular, in terms of resource constraints, the work reported in [1, 24, 18], does not consider any resource constraint while the methods reported in <ref> [7, 11, 17, 20, 26, 27] </ref> deal with function unit constraints but with simple resource usage. Both function unit and register resource constraints are considered in [13, 5]. Software pipelining methods for complex usage patterns with limited function units was dealt with by [4, 16].
Reference: [8] <author> R. Govindarajan, E. R. Altman, and G. R. Gao. </author> <title> Co-scheduling hardware and software pipelines. </title> <type> ACAPS Technical Memo 92, </type> <institution> School of Computer Science, McGill University, Montreal, Que., </institution> <year> 1995. </year>
Reference-contexts: The T , K, and A matrices for Schedule B are depicted in Figure 3. For example, the 1 in the 4th row, 3rd column of A indicates that i2 begins execution at the end of the Schedule B's loop pattern (times <ref> [8; 11] </ref> in Figure 2). Notice that the A matrix specifies only the time step (in the repetitive pattern) at which an instruction is initiated. <p> 0 1 2 3 Stage 1 1 0 0 0 Stage 2 0 1 0 0 Stage 3 0 1 1 0 (a) (T = 4) Time Steps 0 1 Stage 1 1 0 Stage 2 0 1 Stage 3 1 1 (b) (T = 2) the technique described in <ref> [8] </ref>. Due to space restrictions, we omit details of that technique here. For each function unit whose execution time d &lt; T , we extend the reservation table of the function unit to T columns by adding (T d) zero (column) vectors.
Reference: [9] <author> R. Govindarajan, E. R. Altman, and G. R. Gao. </author> <title> Minimizing register requirements under resource-constrained rate-optimal software pipelining. </title> <booktitle> In Proc. of the 27th Ann. Intl. Symp. on Microarchitecture, </booktitle> <pages> pages 85-94, </pages> <address> San Jose, Calif., Nov. 30-Dec.2, </address> <year> 1994. </year>
Reference-contexts: Integer Linear Programming (ILP)-based and other approaches have been proposed for finding an optimal periodic schedule on machines with simple resource usage <ref> [6, 9, 25] </ref>. However, this work has assumed that function units are either completely pipelined or have no pipelining at all. Furthermore, it did not address the issue of mapping, that is the assignment of instructions to specific function units. <p> For example if a loop has 3 divide instructions, a, b, and c and the architecture, 2 Divide units, X and Y, the mapping determines whether a is executed on X or Y, and likewise for b and c. Earlier work based on the ILP approach <ref> [6, 9] </ref> implicitly assumes that the mapping is done at run-time, based on which of the function units are available. <p> The basic formulation requires the casting of precedence constraints into linear form which is straightforward [24]. In [18], it was demonstrated that register storage requirements can also be represented in a simple linear form and integrated easily into the basic ILP framework. In <ref> [9] </ref>, we extended this framework further to include function unit constraints (also in linear form) for hardware pipelines without structural hazards. In the next section, we present an example which demonstrates this framework. Of course, finding optimal solutions for an ILP problem is NP-Hard. <p> A given loop is likely to have many good schedules from which to choose, and optimality criteria are essential to guide the selection of the best ones. There is experimental evidence that ILP approaches may produce better schedules than many heuristic methods for software pipelining <ref> [9] </ref>. One interesting question is: will cleverly designed exhaustive search methods be superior to an ILP solver in terms of efficiency? Although we have lately been working on exploiting such alternatives [2], it is still too early to make a conclusion. <p> The formulation is 143 based on our earlier work on integer programming for-mulation for clean pipelines <ref> [9] </ref>. The basic ILP formulation reported in [9] is extended to non-pipelined architectures in Section 4.1. In Section 4.2, we develop a graph coloring formulation which guarantees a schedule with fixed FU assignment for each instruction. <p> The formulation is 143 based on our earlier work on integer programming for-mulation for clean pipelines <ref> [9] </ref>. The basic ILP formulation reported in [9] is extended to non-pipelined architectures in Section 4.1. In Section 4.2, we develop a graph coloring formulation which guarantees a schedule with fixed FU assignment for each instruction. <p> In this way it can act as a heuristic to help guide the ILP. The objective function, then, is min r=0 Lastly, as shown in <ref> [9, 18, 23] </ref>, the dependence constraints specified by the DDG can be enforced on the schedule by t j t i d i T m ij 8 (i; j) 2 E (4) where d i is the latency of instruction i and m ij is the dependence distance from i to <p> Further, in order to guarantee that each instruction is scheduled exactly once in the repetitive pattern, we require additional constraints on the A matrix <ref> [9] </ref>. These con straints are shown in Equations (9) and (10). The 3 Since clean pipelines can initiate a new operation in each cycle, the resource usage for an instruction is, conceptually, for only one cycle. <p> These numbers ignore the fact that some of the variable lifetimes might be able to share the same physical register. In addition, they lump together both integer and floating point values. Note that we can easily include register requirements in the ILP framework as demonstrated in <ref> [9] </ref>, but for simplicity we choose not to do so in this Number Initiation Mean # Nodes of Loops Interval in DDG 735 T = T lb 6 20 T = T lb + 2 16 11 T = T lb + 4 17 Table 4: Scheduling Performance for Schedules Found <p> The proposed method is important for performance-critical kernel loops and is also useful in the context of a scheduling testbed where our optimal scheduling method can be used to judge how well other existing/newly proposed heuristics perform, and hence to improve them. In <ref> [9] </ref> we compared three heuristic algorithms with an ILP scheduling method for clean pipelines. In [6] Feautrier independently gave an ILP formulation similar to our earlier work. Our method is unique in that it combines scheduling and mapping in a unified framework and attempts to achieve an optimal solution. <p> For example, conditionals can be handled by techniques discussed in [27], while code size reduction can be achieved when using special hardware support such as rotating register files and predicated execution [21]. Furthermore, register constraints can be integrated in the framework as demonstrated in <ref> [9] </ref>. While the use of integer programming methods in practical compilers may not always be acceptable, we discovered that many loop bodies are common to a large number of loops, making it possible to pre-compute optimal schedules for these loops.
Reference: [10] <author> L. J. Hendren, G. R. Gao, E. R. Altman, and C. Muk-erji. </author> <title> A register allocation framework based on hierarchical cyclic interval graphs. </title> <editor> In U. Kastens and P. Pfahler, editors, </editor> <booktitle> Proc. of the Intl. Conf. on Compiler Construction, number 641 in Lec. Notes in Comp. Sci., </booktitle> <pages> pages 176-191. </pages> <publisher> Springer-Verlag, </publisher> <month> Oct. </month> <year> 1992. </year>
Reference-contexts: Specifically, * We extend our ILP method to architectures which are either non-pipelined or pipelined but containing arbitrary structural hazards, namely unclean pipelines. We show that the mapping required can be identified as an instance of the circular-arc graph coloring problem <ref> [10] </ref> and can be represented by integer linear constraints and smoothly integrated into our overall ILP framework. * We have implemented this extended framework and have performed tests on 1066 loops found in typical benchmark programs such as the SPEC92, the NAS kernels, linpack, and the livermore loops. <p> One important observation we have made is to identify the FU assignment problem as a circular-arc coloring problem <ref> [10] </ref>. In Section 4.2 we introduce this coloring as a linear constraint to the basic ILP formulation for handling non-pipelined FUs which will be presented in Section 4. <p> This problem bears a striking similarity to the problem of assigning variables with overlapping lifetimes to different registers. In particular, it is a circular arc coloring problem <ref> [10] </ref>. We must ensure that the two fragments corresponding to i2 get the same color, a fact represented by the dotted arc in Figure 4 (b). In addition the arcs of i2 overlap with both i3 and i4, meaning i2 must have a different color than either.
Reference: [11] <author> P.Y.T. Hsu. </author> <title> Highly concurrent scalar processing. </title> <type> Technical report, </type> <institution> University of Illinois at Urbana-Champagne, Urbana, IL, </institution> <year> 1986. </year> <type> Ph.D. Thesis. </type>
Reference-contexts: The T , K, and A matrices for Schedule B are depicted in Figure 3. For example, the 1 in the 4th row, 3rd column of A indicates that i2 begins execution at the end of the Schedule B's loop pattern (times <ref> [8; 11] </ref> in Figure 2). Notice that the A matrix specifies only the time step (in the repetitive pattern) at which an instruction is initiated. <p> Notice that the A matrix specifies only the time step (in the repetitive pattern) at which an instruction is initiated. To determine resource requirements with T = <ref> [0; 1; 3; 5; 7; 11] </ref> Transpose ; K = [0; 0; 0; 1; 1; 2] Transpose ; and A = 6 4 0 1 0 1 0 0 0 0 1 0 1 1 7 5 : 6 ops fi (T = 4) 2 6 1 0 1 0 1 <p> Clearly, for fixed FU assignment, T d s . Further, it is necessary that no stage in a pipeline is used by an instruction at two time steps that are equal mod T . Such a constraint, known as the modulo scheduling constraint <ref> [5, 11, 19] </ref>, is necessary for fixed FU assignment. In the subsequent discussion we assume that the modulo scheduling constraint is always satisfied for the given T . Cases where the modulo scheduling constraint is not satisfied is beyond the scope of this paper. <p> In particular, in terms of resource constraints, the work reported in [1, 24, 18], does not consider any resource constraint while the methods reported in <ref> [7, 11, 17, 20, 26, 27] </ref> deal with function unit constraints but with simple resource usage. Both function unit and register resource constraints are considered in [13, 5]. Software pipelining methods for complex usage patterns with limited function units was dealt with by [4, 16].
Reference: [12] <author> T. C. Hu. </author> <title> Integer Programming and Network Flows, page 270. </title> <publisher> Addison-Wesley Pub. Co., </publisher> <year> 1969. </year>
Reference-contexts: Alas, absolute value is not a linear operation, so Inequality 11 does not fit with the rest of our ILP framework. To surmount this problem, we adopt an approach outlined by Hu <ref> [12] </ref>. We introduce a set of w i;j integer, 0-1 variables, with one such variable for each pair of nodes using the same type of function unit. Roughly speaking these w i;j variables represent the sign of c i c j .
Reference: [13] <author> R. A. Huff. </author> <title> Lifetime-sensitive modulo scheduling. </title> <booktitle> In Proc. of the SIGPLAN '93 Conf. on Programming Language Design and Implementation, </booktitle> <pages> pages 258-267, </pages> <address> Al-buquerque, N. Mex., </address> <month> Jun. </month> <pages> 23-25, </pages> <year> 1993. </year>
Reference-contexts: The performance of a software-pipelined schedule is measured by the initiation rate of successive iterations. The problem of finding, under resource constraints, an optimal schedule (i.e. with the fastest possible or "rate-optimal" initiation rate) is NP-hard. Various heuristic solution methods <ref> [7, 13, 22, 26] </ref> have been proposed to solve the problem efficiently. In this paper, we are interested in solution methods based on ILP. In contrast to heuristic scheduling algorithms which find approximate (or suboptimal) solutions, ILP methods are based on a formulation where an objective optimality function is specified. <p> It is well known that the minimum initiation interval T min of successive iterations of a loop is constrained by both loop-carried dependences and available resources <ref> [4, 13, 16, 19, 20] </ref>. The loop-carried dependences put a lower bound, T dep , on T . The value of T dep is determined by the critical cycle (s) in the loop [23]. <p> Thus in the resource usage table for FP Stage 1 in Figure 2 (d), each FP operation (i2, i3, and i4) occurs at the same time as in Schedule C. (For software pipelining, we look only at the periodic pattern from <ref> [13; 16] </ref>.) Stage 2 however, is used starting one cycle after the start of the operation. Thus each FP operation is rotated one to the right from the resource usage table of Stage 1. <p> That is there was no feasible solution to the ILP at T lb meaning that the lower bound was not tight in those cases. This fraction is similar to what others have found <ref> [13, 16] </ref> for function units without structural hazards. The third column of Table 4 is the arithmetic mean of the number of nodes in the DDG. <p> Both function unit and register resource constraints are considered in <ref> [13, 5] </ref>. Software pipelining methods for complex usage patterns with limited function units was dealt with by [4, 16]. The methods proposed in these works that aim to be implementable in a practical compiler all use heuristic approaches.
Reference: [14] <author> IBM/Motorola. </author> <title> PowerPC 604 RISC Microprocessor Technical Summary, </title> <year> 1994. </year>
Reference-contexts: In our example the T res bound is given by both the FP 1 These latency values are assumed to make the illustrations in this section compact. More realistic values for the execution times based on PowerPC-604 <ref> [14] </ref> are assumed in the experimental section. unit and the Load/Store unit.
Reference: [15] <author> P. M. Kogge. </author> <title> The Architecture of Pipelined Computers. </title> <publisher> McGraw-Hill Book Company, New York, </publisher> <editor> N. Y., </editor> <year> 1981. </year>
Reference-contexts: In such a function unit, the resource usage of different stages of the pipeline is generally represented by a reservation table <ref> [15] </ref>. Once again we consider the example loop shown in 1 Load/Store unit of latency 3. However, we now assume that the FP and Load/Store units have structural hazards. <p> fixed FU assignment for non-pipelined execution units, we now extend that formulation to solve Problem 2's requirement that this be done for function units with structural hazards. 5.1 ILP Formulation In order to represent the usage of the various stages of a pipeline by each instruction, we use reservation tables <ref> [15] </ref>. A reservation table has s stages and d columns, where d is the execution time of an instruction in the pipeline. For simplicity sake we assume that an FU of a particular type r has a single reservation table describing its use of various stages.
Reference: [16] <author> M. Lam. </author> <title> Software pipelining: An effective scheduling technique for VLIW machines. </title> <booktitle> In Proc. of the SIG-PLAN '88 Conf. on Programming Language Design and Implementation, </booktitle> <pages> pages 318-328, </pages> <address> Atlanta, Georgia, </address> <month> Jun. </month> <pages> 22-24, </pages> <year> 1988. </year>
Reference-contexts: It is well known that the minimum initiation interval T min of successive iterations of a loop is constrained by both loop-carried dependences and available resources <ref> [4, 13, 16, 19, 20] </ref>. The loop-carried dependences put a lower bound, T dep , on T . The value of T dep is determined by the critical cycle (s) in the loop [23]. <p> Thus in the resource usage table for FP Stage 1 in Figure 2 (d), each FP operation (i2, i3, and i4) occurs at the same time as in Schedule C. (For software pipelining, we look only at the periodic pattern from <ref> [13; 16] </ref>.) Stage 2 however, is used starting one cycle after the start of the operation. Thus each FP operation is rotated one to the right from the resource usage table of Stage 1. <p> A is a 1-0 matrix with a t;i = 1 if and only if instruction i is scheduled to begin at time step t in the repetitive pattern. Otherwise a t;i = 0. As will be seen shortly, the A matrix captures the modulo-reservation table <ref> [16, 20] </ref> in a form that is suitable for representing resource constraints in a linear form. <p> That is there was no feasible solution to the ILP at T lb meaning that the lower bound was not tight in those cases. This fraction is similar to what others have found <ref> [13, 16] </ref> for function units without structural hazards. The third column of Table 4 is the arithmetic mean of the number of nodes in the DDG. <p> Both function unit and register resource constraints are considered in [13, 5]. Software pipelining methods for complex usage patterns with limited function units was dealt with by <ref> [4, 16] </ref>. The methods proposed in these works that aim to be implementable in a practical compiler all use heuristic approaches. In this paper, we develop a clear mathematical formulation of the software pipelining problem.
Reference: [17] <author> S-M. Moon and K. Ebcioglu. </author> <title> An efficient resource-constrained global scheduling technique for superscalar and VLIW processors. </title> <booktitle> In Proc. of the 25th Ann. Intl. Symp. on Microarchitecture, </booktitle> <pages> pages 55-71, </pages> <address> Portland, Ore., </address> <month> Dec. </month> <pages> 1-4, </pages> <year> 1992. </year>
Reference-contexts: In particular, in terms of resource constraints, the work reported in [1, 24, 18], does not consider any resource constraint while the methods reported in <ref> [7, 11, 17, 20, 26, 27] </ref> deal with function unit constraints but with simple resource usage. Both function unit and register resource constraints are considered in [13, 5]. Software pipelining methods for complex usage patterns with limited function units was dealt with by [4, 16].
Reference: [18] <author> Q. Ning and G. R. Gao. </author> <title> A novel framework of register allocation for software pipelining. </title> <booktitle> In Conf. Rec. of the Twentieth Ann. ACM SIGPLAN-SIGACT Symp. on Principles of Programming Languages, </booktitle> <pages> pages 29-42, </pages> <address> Charleston, South Carolina, </address> <month> Jan. </month> <pages> 10-13, </pages> <year> 1993. </year>
Reference-contexts: As a result, the mathematical formulation of software pipelining using an ILP framework appears to be quite natural. The basic formulation requires the casting of precedence constraints into linear form which is straightforward [24]. In <ref> [18] </ref>, it was demonstrated that register storage requirements can also be represented in a simple linear form and integrated easily into the basic ILP framework. In [9], we extended this framework further to include function unit constraints (also in linear form) for hardware pipelines without structural hazards. <p> In this way it can act as a heuristic to help guide the ILP. The objective function, then, is min r=0 Lastly, as shown in <ref> [9, 18, 23] </ref>, the dependence constraints specified by the DDG can be enforced on the schedule by t j t i d i T m ij 8 (i; j) 2 E (4) where d i is the latency of instruction i and m ij is the dependence distance from i to <p> In particular, in terms of resource constraints, the work reported in <ref> [1, 24, 18] </ref>, does not consider any resource constraint while the methods reported in [7, 11, 17, 20, 26, 27] deal with function unit constraints but with simple resource usage. Both function unit and register resource constraints are considered in [13, 5]. <p> Our method is unique in that it combines scheduling and mapping in a unified framework and attempts to achieve an optimal solution. An advantage of our method is that it can be extended to handle multi-function pipelines as well. It can incorporate minimizing buffers (logical registers) as in <ref> [18] </ref> or minimizing the maximum number of live values at any time step in the repetitive pattern, as in the method proposed by Eichenberger, Davidson and Abraham [5]. 8 Conclusions In this paper we have proposed a method to formulate scheduling and mapping problems in a unified framework.
Reference: [19] <author> B. R. Rau and J. A. Fisher. </author> <title> Instruction-level parallel processing: History, overview and perspective. </title> <journal> J. of Supercomputing, </journal> <volume> 7 </volume> <pages> 9-50, </pages> <month> May </month> <year> 1993. </year>
Reference-contexts: A variety of software pipelining algorithms [1, 5, 7, 11, 13, 16, 17, 18, 20, 24, 27, 26] have been proposed which operate under resource constraints. An excellent survey of these algorithms can be found in <ref> [19] </ref>. fl This work was supported by research grants from NSERC (Canada) and MICRONET -Network Centers of Excellence (Canada). Integer Linear Programming (ILP)-based and other approaches have been proposed for finding an optimal periodic schedule on machines with simple resource usage [6, 9, 25]. <p> It is well known that the minimum initiation interval T min of successive iterations of a loop is constrained by both loop-carried dependences and available resources <ref> [4, 13, 16, 19, 20] </ref>. The loop-carried dependences put a lower bound, T dep , on T . The value of T dep is determined by the critical cycle (s) in the loop [23]. <p> Clearly, for fixed FU assignment, T d s . Further, it is necessary that no stage in a pipeline is used by an instruction at two time steps that are equal mod T . Such a constraint, known as the modulo scheduling constraint <ref> [5, 11, 19] </ref>, is necessary for fixed FU assignment. In the subsequent discussion we assume that the modulo scheduling constraint is always satisfied for the given T . Cases where the modulo scheduling constraint is not satisfied is beyond the scope of this paper. <p> Rau and Fisher provide a comprehensive survey of these works in <ref> [19] </ref>. As stated in [19], software pipelining methods vary in several aspects: (1) whether or not they consider finite resources, (2) whether they model simple 4 Because of the way our compiler performed memory disambiguation, some of our DDG's contain edges with very large dependence distances|more than the number of iterations <p> Rau and Fisher provide a comprehensive survey of these works in <ref> [19] </ref>. As stated in [19], software pipelining methods vary in several aspects: (1) whether or not they consider finite resources, (2) whether they model simple 4 Because of the way our compiler performed memory disambiguation, some of our DDG's contain edges with very large dependence distances|more than the number of iterations in the loop.
Reference: [20] <author> B. R. Rau and C. D. Glaeser. </author> <title> Some scheduling techniques and an easily schedulable horizontal architecture for high performance scientific computing. </title> <booktitle> In Proc. of the 14th Ann. Microprogramming Work., </booktitle> <pages> pages 183-198, </pages> <address> Chatham, Mass., </address> <month> Oct. </month> <pages> 12-15, </pages> <year> 1981. </year>
Reference-contexts: It is well known that the minimum initiation interval T min of successive iterations of a loop is constrained by both loop-carried dependences and available resources <ref> [4, 13, 16, 19, 20] </ref>. The loop-carried dependences put a lower bound, T dep , on T . The value of T dep is determined by the critical cycle (s) in the loop [23]. <p> A is a 1-0 matrix with a t;i = 1 if and only if instruction i is scheduled to begin at time step t in the repetitive pattern. Otherwise a t;i = 0. As will be seen shortly, the A matrix captures the modulo-reservation table <ref> [16, 20] </ref> in a form that is suitable for representing resource constraints in a linear form. <p> In particular, in terms of resource constraints, the work reported in [1, 24, 18], does not consider any resource constraint while the methods reported in <ref> [7, 11, 17, 20, 26, 27] </ref> deal with function unit constraints but with simple resource usage. Both function unit and register resource constraints are considered in [13, 5]. Software pipelining methods for complex usage patterns with limited function units was dealt with by [4, 16].
Reference: [21] <author> B. R. Rau, M. Lee, P. P. Tirumalai, and M. S. Schlansker. </author> <title> Register allocation for software pipelined loops. </title> <booktitle> In Proc. of the SIGPLAN '92 Conf. on Programming Language Design and Implementation, </booktitle> <pages> pages 283-299, </pages> <address> San Francisco, Calif., </address> <month> Jun. </month> <pages> 17-19, </pages> <year> 1992. </year>
Reference-contexts: For example, conditionals can be handled by techniques discussed in [27], while code size reduction can be achieved when using special hardware support such as rotating register files and predicated execution <ref> [21] </ref>. Furthermore, register constraints can be integrated in the framework as demonstrated in [9].
Reference: [22] <author> B. R. Rau. </author> <title> Iterative modulo scheduling: An algorithm for software pipelining loops. </title> <booktitle> In Proc. of the 27th Ann. Intl. Symp. on Microarchitecture, </booktitle> <pages> pages 63-74, </pages> <address> San Jose, Calif., Nov. 30-Dec.2, </address> <year> 1994. </year>
Reference-contexts: The performance of a software-pipelined schedule is measured by the initiation rate of successive iterations. The problem of finding, under resource constraints, an optimal schedule (i.e. with the fastest possible or "rate-optimal" initiation rate) is NP-hard. Various heuristic solution methods <ref> [7, 13, 22, 26] </ref> have been proposed to solve the problem efficiently. In this paper, we are interested in solution methods based on ILP. In contrast to heuristic scheduling algorithms which find approximate (or suboptimal) solutions, ILP methods are based on a formulation where an objective optimality function is specified.
Reference: [23] <author> R. Reiter. </author> <title> Scheduling parallel computations. </title> <journal> J. of the ACM, </journal> <volume> 15(4) </volume> <pages> 590-599, </pages> <month> Oct. </month> <year> 1968. </year>
Reference-contexts: In contrast to heuristic scheduling algorithms which find approximate (or suboptimal) solutions, ILP methods are based on a formulation where an objective optimality function is specified. A software pipelined schedule can be represented in a linear periodic form <ref> [23] </ref>, under which an instruction i in iteration j is initiated at time j fl T + t i . T is the period (or initiation interval | often abbreviated as II in the literature) of the schedule. <p> The loop-carried dependences put a lower bound, T dep , on T . The value of T dep is determined by the critical cycle (s) in the loop <ref> [23] </ref>. Specifically T dep = sum of instruction execution times sum of dependence distances along the critical cycle (s). For the DDG in Figure1 (a), T dep is 2 corresponding to the self loop at instruction i2. Another lower bound T res on T is enforced by resource constraints. <p> In this way it can act as a heuristic to help guide the ILP. The objective function, then, is min r=0 Lastly, as shown in <ref> [9, 18, 23] </ref>, the dependence constraints specified by the DDG can be enforced on the schedule by t j t i d i T m ij 8 (i; j) 2 E (4) where d i is the latency of instruction i and m ij is the dependence distance from i to
Reference: [24] <author> V. Van Dongen, G. R. Gao, and Q. Ning. </author> <title> A polynomial time method for optimal software pipelining. </title> <booktitle> In Proc. of the Conf. on Vector and Parallel Processing, CONPAR-92, number 634 in Lec. Notes in Comp. Sci., </booktitle> <pages> pages 613-624, </pages> <address> Lyon, France, </address> <month> Sep. </month> <pages> 1-4, </pages> <year> 1992. </year>
Reference-contexts: The value t i is a constant and indicates the time at which i first executes. As a result, the mathematical formulation of software pipelining using an ILP framework appears to be quite natural. The basic formulation requires the casting of precedence constraints into linear form which is straightforward <ref> [24] </ref>. In [18], it was demonstrated that register storage requirements can also be represented in a simple linear form and integrated easily into the basic ILP framework. In [9], we extended this framework further to include function unit constraints (also in linear form) for hardware pipelines without structural hazards. <p> In particular, in terms of resource constraints, the work reported in <ref> [1, 24, 18] </ref>, does not consider any resource constraint while the methods reported in [7, 11, 17, 20, 26, 27] deal with function unit constraints but with simple resource usage. Both function unit and register resource constraints are considered in [13, 5].
Reference: [25] <author> S. R. Vegdahl. </author> <title> A Dynamic Programming Technique for Compacting Loops. </title> <booktitle> In Proc. of the 25th Ann. Intl. Symp. on Microarchitecture, </booktitle> <pages> pages 180-188, </pages> <address> Portland, Ore., </address> <month> Dec. </month> <pages> 1-4, </pages> <year> 1992. </year>
Reference-contexts: Integer Linear Programming (ILP)-based and other approaches have been proposed for finding an optimal periodic schedule on machines with simple resource usage <ref> [6, 9, 25] </ref>. However, this work has assumed that function units are either completely pipelined or have no pipelining at all. Furthermore, it did not address the issue of mapping, that is the assignment of instructions to specific function units.
Reference: [26] <author> J. Wang and E. Eisenbeis. </author> <title> A new approach to software pipelining of complicated loops with branches. Res. </title> <type> rep., </type> <institution> INRIA, Rocquencourt, France, </institution> <month> Jan. </month> <year> 1993. </year>
Reference-contexts: The performance of a software-pipelined schedule is measured by the initiation rate of successive iterations. The problem of finding, under resource constraints, an optimal schedule (i.e. with the fastest possible or "rate-optimal" initiation rate) is NP-hard. Various heuristic solution methods <ref> [7, 13, 22, 26] </ref> have been proposed to solve the problem efficiently. In this paper, we are interested in solution methods based on ILP. In contrast to heuristic scheduling algorithms which find approximate (or suboptimal) solutions, ILP methods are based on a formulation where an objective optimality function is specified. <p> In particular, in terms of resource constraints, the work reported in [1, 24, 18], does not consider any resource constraint while the methods reported in <ref> [7, 11, 17, 20, 26, 27] </ref> deal with function unit constraints but with simple resource usage. Both function unit and register resource constraints are considered in [13, 5]. Software pipelining methods for complex usage patterns with limited function units was dealt with by [4, 16].
Reference: [27] <author> N. J. Warter, J. W. Bockhaus, G. E. Haab, and K. Subramanian. </author> <title> Enhanced modulo scheduling for loops with conditional branches. </title> <booktitle> In Proc. of the 25th Ann. Intl. Symp. on Microarchitecture, </booktitle> <pages> pages 170-179, </pages> <address> Port-land, Ore., </address> <month> Dec. </month> <pages> 1-4, </pages> <year> 1992. </year> <month> 150 </month>
Reference-contexts: In particular, in terms of resource constraints, the work reported in [1, 24, 18], does not consider any resource constraint while the methods reported in <ref> [7, 11, 17, 20, 26, 27] </ref> deal with function unit constraints but with simple resource usage. Both function unit and register resource constraints are considered in [13, 5]. Software pipelining methods for complex usage patterns with limited function units was dealt with by [4, 16]. <p> The scope of periodic schedules and the ILP-based solution framework can be extended to a large variety of loops with conditionals. For example, conditionals can be handled by techniques discussed in <ref> [27] </ref>, while code size reduction can be achieved when using special hardware support such as rotating register files and predicated execution [21]. Furthermore, register constraints can be integrated in the framework as demonstrated in [9].
References-found: 27

