URL: ftp://ftp.cc.gatech.edu/pub/gvu/tr/1996/96-30.ps.Z
Refering-URL: http://www.cs.gatech.edu/gvu/reports/1996/
Root-URL: 
Title: Model-based User Interface Software Tools Current state of declarative models  
Author: by Egbert Schlungbaum 
Address: Atlanta, GA 30332-0280  
Affiliation: Graphics, Visualization Usability Center Georgia Institute of Technology  
Date: November 1996  
Pubnum: GIT-GVU-96-30  
Abstract-found: 0
Intro-found: 1
Reference: [Balzert96] <author> H. Balzert, F. Hofmann, V. Kruschinski, C. Niemann: </author> <title> The Janus Application Development Environment Generating More than the User Interface. </title> <editor> In: J. Vanderdonckt (ed.): </editor> <booktitle> Computer-Aided Design of User Interfaces. </booktitle> <address> Namur: </address> <publisher> Namur University Press, </publisher> <year> 1996, </year> <pages> 183-205. </pages>
Reference-contexts: Several model-based user interface software tools have been built. Some of these are UIDE [Foley88, Foley89, Foley95], ADEPT [Johnson95, Wilson93], HUMANOID [Szekely93], ITS [Wiecha90], MECANO [Puerta94b], Mobi-D [Puerta96a], MASTERMIND [Neches93, Szekely96a], TRIDENT [Bodart95, Bodart96], AME [Mrtin96], FUSE [Lonczewski96], GENIUS [Janssen93], JANUS <ref> [Balzert96] </ref>, TADEUS [Elwert95]. GIT-GVU-96-30 - 5 - 2 Model-based Interface Development Environments 2 . 1 Generic Architecture The typical components and the principal development procedure of a model-based interface development environment are shown in Fig. 1. <p> So it can be used for some sophisticated tools to support the end-user, e.g. automatic generation of contextsensitive, animated help [Sukaviriya90] or adaptive user interfaces [Sukaviriya93a]. AME and JANUS The AME [Mrtin96] and JANUS <ref> [Balzert96] </ref> systems are very similar from the point of view of declarative models. Both systems emphasize the automatic generation of the desired user interface from a much extended objectoriented domain model. During this automatic generation process both systems make use of different comprehensive knowledge bases. <p> - 16 - Table 1 Declarative Models and their application in MB-IDEs Task Domain U s e r Dialogue Presentation UIDE [Foley95] ADEPT [Johnson95] MASTERMIND [Szekely96a] MECANO [Puerta94b] Mobi-D [Puerta96a] TRIDENT [Bodart95,96] AME [Mrtin96] G E N I US [Janssen93] F U S E [Lonczewski96] J A N U S <ref> [Balzert96] </ref> TADEUS [Elwert94,95] model X in MB-IDE Y fits our definition model X in MB-IDE Y fits our definition but the model is much extended model X is included in the Interface Model of MB-IDE Y, but there are not any examples which make use of it GIT-GVU-96-30 - 17 - <p> with recent CASE tools Domain model Possibility for integration UIDE [Sukaviriya93b] C++ classes MASTERMIND [Szekely96a] CORBA IDL Mobi-D [Puerta96a] MIMIC Object model TRIDENT [Bodart95,96] ER model AME [Mrtin96] OO-Object model G E N I US [Janssen93] ER model F U S E [Lonczewski96] algebraic specification J A N U S <ref> [Balzert96] </ref> OO-Object model TADEUS [Elwert94,95] OO-Object model domain model is equivalent to the model of recent CASE tools integration of this domain model requires additional transformations a direkt integration is difficult GIT-GVU-96-30 - 18 - 3 Declarative models in future MB-IDEs The hitherto existing model-based user interface software tools could be
Reference: [Bodart95a] <author> F. Bodart, A.-M. Hennebert, J.-M. Leheureux, I. Provot, J. Vander-donckt: </author> <title> A Model-based Approach to Presentation: A Continuum from Task Analysis to Prototype. </title> <editor> In: F. Paterno (ed.): </editor> <title> Interactive Systems: Design, Specification and Verification. </title> <publisher> Berlin: Springer, </publisher> <year> 1995, </year> <pages> 77-94. </pages>
Reference-contexts: They do not include any other declarative models. Both systems generate user interface code GIT-GVU-96-30 - 13 - for different target systems like C++ source code in order to link it with UI toolkits or input files for UIMS like ISA Dialogue Manager or Open Interface. TRIDENT In TRIDENT <ref> [Bodart95a, Bodart95b, Bodart96] </ref> the designer has to specify a task model which is represented by an Activity Chaining Graph (ACG) and an application model in form of an entity-relationship diagram.
Reference: [Bodart95b] <editor> F. Bodart, A.-M. Hennebert, J.-M. Leheureux, I. Provot, B. Sacre, J. Vanderdonckt: </editor> <title> Towards a Systematic Building of Software Architectures: the TRIDENT Methodological Guide. </title> <editor> In P. Palanque, R. Bastide (eds.): </editor> <title> Design, Specification and Verification of Interactive Systems. </title> <publisher> Wien: Springer, </publisher> <year> 1995, </year> <pages> 262-278. </pages>
Reference-contexts: They do not include any other declarative models. Both systems generate user interface code GIT-GVU-96-30 - 13 - for different target systems like C++ source code in order to link it with UI toolkits or input files for UIMS like ISA Dialogue Manager or Open Interface. TRIDENT In TRIDENT <ref> [Bodart95a, Bodart95b, Bodart96] </ref> the designer has to specify a task model which is represented by an Activity Chaining Graph (ACG) and an application model in form of an entity-relationship diagram.
Reference: [Bodart96] <author> F. Bodart, A.-M. Hennebert, J.-M. Leheureux, I. Provot, J. Vanderdonckt, G. Zucchinetti: </author> <title> Key Activities for a Development Methodology of Interactive Applications. </title> <editor> In: D. Benyon, P. Palanque (eds.): </editor> <booktitle> Critical Issues in User Interface Systems Engineering. </booktitle> <address> London: </address> <publisher> Springer, </publisher> <year> 1996, </year> <pages> 109-134. </pages>
Reference-contexts: Several model-based user interface software tools have been built. Some of these are UIDE [Foley88, Foley89, Foley95], ADEPT [Johnson95, Wilson93], HUMANOID [Szekely93], ITS [Wiecha90], MECANO [Puerta94b], Mobi-D [Puerta96a], MASTERMIND [Neches93, Szekely96a], TRIDENT <ref> [Bodart95, Bodart96] </ref>, AME [Mrtin96], FUSE [Lonczewski96], GENIUS [Janssen93], JANUS [Balzert96], TADEUS [Elwert95]. GIT-GVU-96-30 - 5 - 2 Model-based Interface Development Environments 2 . 1 Generic Architecture The typical components and the principal development procedure of a model-based interface development environment are shown in Fig. 1. <p> They do not include any other declarative models. Both systems generate user interface code GIT-GVU-96-30 - 13 - for different target systems like C++ source code in order to link it with UI toolkits or input files for UIMS like ISA Dialogue Manager or Open Interface. TRIDENT In TRIDENT <ref> [Bodart95a, Bodart95b, Bodart96] </ref> the designer has to specify a task model which is represented by an Activity Chaining Graph (ACG) and an application model in form of an entity-relationship diagram.
Reference: [Browne96] <author> T. Browne, D. Davila, S. Rugaber, K. Stirewald: </author> <title> The MASTERMIND User Interface Generation Project. </title> <type> Research report, </type> <institution> Georgia Institute of Technology, Graphics, Visualization & Usability Center, GIT-GVU-96-31, </institution> <year> 1996. </year>
Reference-contexts: The user interface developer can change characteristica of a widget using its attributes. GIT-GVU-96-30 - 19 - ontology 2 of the Interface Model. The following suggestion is based on the current discussion in the MASTERMIND project team <ref> [Browne96] </ref>. The Interface Model ontology of future MB-IDEs is influenced by two ideas. The first is programming language design, which provides foundations for any modeling process. The second is objectoriented user interface toolkit technology, which provides abstractions and control mechanisms. User interface design is analogous to programming language design [Foley90].
Reference: [Castells97] <author> P. Castells, P. Szekely, E. Salcher: </author> <title> Declarative Models of Presentation. </title> <booktitle> In Proceedings of Intelligent User Interfaces '97, </booktitle> <address> New York: </address> <publisher> ACM Press, </publisher> <year> 1997, </year> <note> in press. </note>
Reference: [Diaper89] <author> D. Diaper (ed.): </author> <title> Task Analysis for Human-Computer Interaction. </title> <address> Chichester: </address> <publisher> Ellis Horwood, </publisher> <year> 1989. </year>
Reference-contexts: Before we discuss the use of the declarative models in certain MB-IDEs we introduce their definitions. Until now, there are not any clear definitions of the different declarative models used in the MB-IDEs [Wilson96b]. Task model The book <ref> [Diaper89] </ref> presents 5 different approaches to task analysis, but there is no consensus on the precise definition of a task. <p> The language analogy suggests applying the phases of programming language design to the simultaneous design of the input and output languages. There are three phases in this process: Semantic Design Semantics refers to the meaning or intentions of the end user. User task analysis <ref> [Diaper89] </ref> is applied to codify a system at this level. This is the understanding the end user will have in his or her mind when using the system. This conceptual model is refined into a detailed semantic model of the system by incorporating the functional requirements of the application.
Reference: [Elwert94] <author> T. Elwert, P. Forbrig, E. Schlungbaum: </author> <title> Meta Models for Task-oriented User Interface Development. </title> <booktitle> In: Proceedings 1. Workshop on Cognitive Modelling and Interface Development, Wien, 1994, S. </booktitle> <pages> 163-172. </pages> <address> GIT-GVU-96-30 - 23 </address> - 
Reference-contexts: A textual description of the user interface is generated which is an input for the UIMS ISA Dialogue Manager. TADEUS In TADEUS the user interface developer creates the task, domain, user, and dialogue models <ref> [Elwert94, Elwert95] </ref> which are the basis of subsequent development of the interactive and noninteractive parts of interactive applications. The task model represents a hierarchical structure of the tasks the end user plans to carry out using the interactive system.
Reference: [Elwert95] <author> T. Elwert, E. Schlungbaum: </author> <title> Modelling and Generation of Graphical User Interfaces in the TADEUS Approach. </title> <editor> In: P. Palanque, R. Bastide (eds.): </editor> <title> Designing, Specification, and Verification of Interactive Systems. </title> <publisher> Wien: Springer, </publisher> <year> 1995, </year> <pages> 193-208. </pages>
Reference-contexts: Several model-based user interface software tools have been built. Some of these are UIDE [Foley88, Foley89, Foley95], ADEPT [Johnson95, Wilson93], HUMANOID [Szekely93], ITS [Wiecha90], MECANO [Puerta94b], Mobi-D [Puerta96a], MASTERMIND [Neches93, Szekely96a], TRIDENT [Bodart95, Bodart96], AME [Mrtin96], FUSE [Lonczewski96], GENIUS [Janssen93], JANUS [Balzert96], TADEUS <ref> [Elwert95] </ref>. GIT-GVU-96-30 - 5 - 2 Model-based Interface Development Environments 2 . 1 Generic Architecture The typical components and the principal development procedure of a model-based interface development environment are shown in Fig. 1. The central component of each MB-IDE is the Interface Model which includes different declarative models. <p> A textual description of the user interface is generated which is an input for the UIMS ISA Dialogue Manager. TADEUS In TADEUS the user interface developer creates the task, domain, user, and dialogue models <ref> [Elwert94, Elwert95] </ref> which are the basis of subsequent development of the interactive and noninteractive parts of interactive applications. The task model represents a hierarchical structure of the tasks the end user plans to carry out using the interactive system.
Reference: [Foley88] <author> J. Foley, C. Gibbs, W. Kim, S. Kovacevic: </author> <title> A Knowledge-based User Interface Management System. </title> <editor> In: E. Soloway, D. Frye, S. Sheppard (eds.): </editor> <booktitle> Human Factors in Computing Systems. Proceedings CHI'88 (Washington, </booktitle> <address> May 1988). New York: </address> <publisher> ACM Press, </publisher> <year> 1988, </year> <pages> 67-72. </pages>
Reference-contexts: These criteria exclude Interface Builders (e.g., DevGuide, UIMX, NeXT) or interface design advisors (e.g., IDA [Reiterer94], EXPOSE [Gorny95]). Several model-based user interface software tools have been built. Some of these are UIDE <ref> [Foley88, Foley89, Foley95] </ref>, ADEPT [Johnson95, Wilson93], HUMANOID [Szekely93], ITS [Wiecha90], MECANO [Puerta94b], Mobi-D [Puerta96a], MASTERMIND [Neches93, Szekely96a], TRIDENT [Bodart95, Bodart96], AME [Mrtin96], FUSE [Lonczewski96], GENIUS [Janssen93], JANUS [Balzert96], TADEUS [Elwert95]. <p> Domain Model The first MB-IDEs were using a domain model to drive the user interface at runtime. These domain models describe the application in general and include some specific information for the user interface. For example, the UIDE domain model <ref> [Foley88, Foley89, Foley91] </ref> includes: a class hierarchy of objects which exist in the application, properties of the objects, actions which can performed on the objects, units of information (parameters) required by the actions, and GIT-GVU-96-30 - 10 - pre and postconditions for the actions.
Reference: [Foley89] <author> J. Foley, W. Kim, S. Kovacevic, K. Murray: </author> <title> The User Interface Design Environment A Computer Aided Software Engineering Tool for the User Computer Interface. </title> <journal> IEEE Software 6 (January 1989), </journal> <volume> 1, </volume> <pages> 25-32. </pages> <note> (Special Issue on User Interface Software) </note>
Reference-contexts: These criteria exclude Interface Builders (e.g., DevGuide, UIMX, NeXT) or interface design advisors (e.g., IDA [Reiterer94], EXPOSE [Gorny95]). Several model-based user interface software tools have been built. Some of these are UIDE <ref> [Foley88, Foley89, Foley95] </ref>, ADEPT [Johnson95, Wilson93], HUMANOID [Szekely93], ITS [Wiecha90], MECANO [Puerta94b], Mobi-D [Puerta96a], MASTERMIND [Neches93, Szekely96a], TRIDENT [Bodart95, Bodart96], AME [Mrtin96], FUSE [Lonczewski96], GENIUS [Janssen93], JANUS [Balzert96], TADEUS [Elwert95]. <p> Domain Model The first MB-IDEs were using a domain model to drive the user interface at runtime. These domain models describe the application in general and include some specific information for the user interface. For example, the UIDE domain model <ref> [Foley88, Foley89, Foley91] </ref> includes: a class hierarchy of objects which exist in the application, properties of the objects, actions which can performed on the objects, units of information (parameters) required by the actions, and GIT-GVU-96-30 - 10 - pre and postconditions for the actions. <p> Interface components, application-independent interface tasks, and operational constraints on these tasks are specified in the interface model. The application model drives a special purpose runtime system (e.g., the Simple User Interface Management System <ref> [Foley89] </ref>) to create the running user interface. In this way, the application semantic information which is stored in the application model is preserved from design time to run time.
Reference: [Foley90] <author> J. Foley, A. van Dam, S. Feiner, A. Hughes: </author> <title> Computer Graphics: </title> <booktitle> Principles and Practice. (2nd Ed.) </booktitle> <address> Reading: </address> <publisher> Addison Wesley, </publisher> <year> 1990. </year>
Reference-contexts: The Interface Model ontology of future MB-IDEs is influenced by two ideas. The first is programming language design, which provides foundations for any modeling process. The second is objectoriented user interface toolkit technology, which provides abstractions and control mechanisms. User interface design is analogous to programming language design <ref> [Foley90] </ref>. Interfaces can be thought of as being composed of two languages: one in which the end-user communicates to the computer, and one in which the computer communicates to the end-user. The act of engineering user interfaces can be therefore thought of as the simultaneous design of these two languages.
Reference: [Foley91] <author> J. Foley: </author> <title> User Interface Software Tools. </title> <institution> Research report GIT-GVU-91-29, Graphics, Visualization & Usability Center, Georgia Institute of Technology, </institution> <year> 1991. </year>
Reference-contexts: Domain Model The first MB-IDEs were using a domain model to drive the user interface at runtime. These domain models describe the application in general and include some specific information for the user interface. For example, the UIDE domain model <ref> [Foley88, Foley89, Foley91] </ref> includes: a class hierarchy of objects which exist in the application, properties of the objects, actions which can performed on the objects, units of information (parameters) required by the actions, and GIT-GVU-96-30 - 10 - pre and postconditions for the actions. <p> Jim Foley wrote: "... some information has to be specified twice, once by the software engineer and once by the user interface designer. These tools should clearly be merged to speed up the design process, avoid duplication of efforts, and avoid potential inconsistencies between the dual specification." <ref> [Foley91, p. 11] </ref>. In their basic form domain models should represent the important entities together with their attributes, methods, and relationships. This kind of a domain model corresponds to the object model of recent objectoriented software development methods.
Reference: [Foley95] <author> J. Foley, P. Sukaviriya: </author> <title> History, Results, and Bibliography of the User Interface Design Environment (UIDE), an Early Model-based System for User Interface Design and Implementation. </title> <editor> In: F. Paterno (ed.): </editor> <title> Interactive Systems: Design, Specification and Verification. </title> <publisher> Berlin: Springer, </publisher> <year> 1995, </year> <pages> 3-14. </pages>
Reference-contexts: These criteria exclude Interface Builders (e.g., DevGuide, UIMX, NeXT) or interface design advisors (e.g., IDA [Reiterer94], EXPOSE [Gorny95]). Several model-based user interface software tools have been built. Some of these are UIDE <ref> [Foley88, Foley89, Foley95] </ref>, ADEPT [Johnson95, Wilson93], HUMANOID [Szekely93], ITS [Wiecha90], MECANO [Puerta94b], Mobi-D [Puerta96a], MASTERMIND [Neches93, Szekely96a], TRIDENT [Bodart95, Bodart96], AME [Mrtin96], FUSE [Lonczewski96], GENIUS [Janssen93], JANUS [Balzert96], TADEUS [Elwert95]. <p> Furthermore, it incorporates principles of graphic design in order to give a comprehensive support to the dialogue designer. GIT-GVU-96-30 - 16 - Table 1 Declarative Models and their application in MB-IDEs Task Domain U s e r Dialogue Presentation UIDE <ref> [Foley95] </ref> ADEPT [Johnson95] MASTERMIND [Szekely96a] MECANO [Puerta94b] Mobi-D [Puerta96a] TRIDENT [Bodart95,96] AME [Mrtin96] G E N I US [Janssen93] F U S E [Lonczewski96] J A N U S [Balzert96] TADEUS [Elwert94,95] model X in MB-IDE Y fits our definition model X in MB-IDE Y fits our definition but the model
Reference: [Gorny95] <author> P. Gorny: </author> <title> An HCI-Counseling for User Interface Design. </title> <booktitle> In: Proceedings of the 5th IFIP TC13 Conference on Human-Computer Interaction INTERACT '95 (Lillehammer, </booktitle> <address> June 1995). London: </address> <publisher> Chapman & Hall, </publisher> <year> 1995, </year> <pages> 297-304. </pages>
Reference-contexts: That means, that there is some kind of automatic transformation (s) like knowledge-based generation or simple compilation to implement the running user interface. These criteria exclude Interface Builders (e.g., DevGuide, UIMX, NeXT) or interface design advisors (e.g., IDA [Reiterer94], EXPOSE <ref> [Gorny95] </ref>). Several model-based user interface software tools have been built. Some of these are UIDE [Foley88, Foley89, Foley95], ADEPT [Johnson95, Wilson93], HUMANOID [Szekely93], ITS [Wiecha90], MECANO [Puerta94b], Mobi-D [Puerta96a], MASTERMIND [Neches93, Szekely96a], TRIDENT [Bodart95, Bodart96], AME [Mrtin96], FUSE [Lonczewski96], GENIUS [Janssen93], JANUS [Balzert96], TADEUS [Elwert95].
Reference: [Gruber] <author> Tom Gruber. </author> <title> What is an Ontology? http://www-ksl.stanford.edu/kst/what-is-an-ontology.html. </title>
Reference-contexts: Dialogue techniques are syntactic; whereas the user tasks that these dialogue techniques are employed to accomplish are semantic. 2 Ontology: a description (like a formal specification of a program) of the concepts and relationships that can exist for an agent or a community of agents <ref> [Gruber] </ref>. GIT-GVU-96-30 - 20 - Lexical Design A lexical model, describing low-level tokens, is defined alongside the syntactic model. For the input language, these tokens include keystrokes, mouse clicks, or mouse motion. For the output language, these tokens include output characters, beeps, or graphical widgets.
Reference: [Hsi95] <author> I. Hsi, C. Potts: </author> <title> Towards Integrating Rationalistic and Ecological Design Methods for Interactive Systems. </title> <type> Research report, </type> <institution> Georgia Institute of Technology, Graphics, Visualization & Usability Center, GIT-GVU-95-27, </institution> <year> 1995. </year>
Reference-contexts: To achieve this, care must be taken. Task analysis methods tend to model ideal situations and they do not recognize real world obstacles <ref> [Hsi95] </ref>. Trouble arises if the accomplishment of goals depends on various factors inside the domain or involves different users like in CSCW systems. Therefore, a task model must include not only the tasks end users need to accomplish, but also tasks which deal with different obstaclesituations.
Reference: [Janssen93] <author> C. Janssen, A. Weisbecker, J. Ziegler: </author> <title> Generating User Interfaces from Data Models and Dialogue Net Specifications. </title> <editor> In: S. Ashlund, et.al. (eds.): </editor> <title> Bridges between Worlds. </title> <booktitle> Proceedings InterCHI'93 (Amsterdam, </booktitle> <address> April 1993). New York: </address> <publisher> ACM Press, </publisher> <year> 1993, </year> <pages> 418-423. </pages> <address> GIT-GVU-96-30 - 24 </address> - 
Reference-contexts: Several model-based user interface software tools have been built. Some of these are UIDE [Foley88, Foley89, Foley95], ADEPT [Johnson95, Wilson93], HUMANOID [Szekely93], ITS [Wiecha90], MECANO [Puerta94b], Mobi-D [Puerta96a], MASTERMIND [Neches93, Szekely96a], TRIDENT [Bodart95, Bodart96], AME [Mrtin96], FUSE [Lonczewski96], GENIUS <ref> [Janssen93] </ref>, JANUS [Balzert96], TADEUS [Elwert95]. GIT-GVU-96-30 - 5 - 2 Model-based Interface Development Environments 2 . 1 Generic Architecture The typical components and the principal development procedure of a model-based interface development environment are shown in Fig. 1. <p> Finally, a textual description of the user interface is generated by using of different comprehensive knowledge bases. G E N I US In GENIUS <ref> [Janssen93] </ref> the designer uses the existing data model of the application to design the user interface. This model of the application (domain model) is represented as an extended entity relationship model. <p> GIT-GVU-96-30 - 16 - Table 1 Declarative Models and their application in MB-IDEs Task Domain U s e r Dialogue Presentation UIDE [Foley95] ADEPT [Johnson95] MASTERMIND [Szekely96a] MECANO [Puerta94b] Mobi-D [Puerta96a] TRIDENT [Bodart95,96] AME [Mrtin96] G E N I US <ref> [Janssen93] </ref> F U S E [Lonczewski96] J A N U S [Balzert96] TADEUS [Elwert94,95] model X in MB-IDE Y fits our definition model X in MB-IDE Y fits our definition but the model is much extended model X is included in the Interface Model of MB-IDE Y, but there are not <p> of it GIT-GVU-96-30 - 17 - Table 2 Domain Models and their possibility for integration with recent CASE tools Domain model Possibility for integration UIDE [Sukaviriya93b] C++ classes MASTERMIND [Szekely96a] CORBA IDL Mobi-D [Puerta96a] MIMIC Object model TRIDENT [Bodart95,96] ER model AME [Mrtin96] OO-Object model G E N I US <ref> [Janssen93] </ref> ER model F U S E [Lonczewski96] algebraic specification J A N U S [Balzert96] OO-Object model TADEUS [Elwert94,95] OO-Object model domain model is equivalent to the model of recent CASE tools integration of this domain model requires additional transformations a direkt integration is difficult GIT-GVU-96-30 - 18 - 3
Reference: [Johnson92] <author> P. Johnson: </author> <title> Human-Computer Interaction. </title> <publisher> London: McGraw-Hill, </publisher> <year> 1992. </year>
Reference-contexts: The task model represents a hierarchical structure of the tasks the end user plans to carry out using the interactive system. Like TKS <ref> [Johnson92] </ref> each task representation includes a goal, a procedure to achieve this goal, preconditions and effects, and subtasks with an ordering.
Reference: [Johnson95] <author> P. Johnson, H. Johnson, S. Wilson: </author> <title> Rapid Prototyping of User Interfaces Driven by Task Models. </title> <editor> In: J. Carroll (ed.) </editor> <booktitle> Scenario-Based Design. </booktitle> <address> London: </address> <publisher> John Wiley & Son, </publisher> <year> 1995, </year> <pages> 209-246. </pages>
Reference-contexts: These criteria exclude Interface Builders (e.g., DevGuide, UIMX, NeXT) or interface design advisors (e.g., IDA [Reiterer94], EXPOSE [Gorny95]). Several model-based user interface software tools have been built. Some of these are UIDE [Foley88, Foley89, Foley95], ADEPT <ref> [Johnson95, Wilson93] </ref>, HUMANOID [Szekely93], ITS [Wiecha90], MECANO [Puerta94b], Mobi-D [Puerta96a], MASTERMIND [Neches93, Szekely96a], TRIDENT [Bodart95, Bodart96], AME [Mrtin96], FUSE [Lonczewski96], GENIUS [Janssen93], JANUS [Balzert96], TADEUS [Elwert95]. <p> Furthermore, it incorporates principles of graphic design in order to give a comprehensive support to the dialogue designer. GIT-GVU-96-30 - 16 - Table 1 Declarative Models and their application in MB-IDEs Task Domain U s e r Dialogue Presentation UIDE [Foley95] ADEPT <ref> [Johnson95] </ref> MASTERMIND [Szekely96a] MECANO [Puerta94b] Mobi-D [Puerta96a] TRIDENT [Bodart95,96] AME [Mrtin96] G E N I US [Janssen93] F U S E [Lonczewski96] J A N U S [Balzert96] TADEUS [Elwert94,95] model X in MB-IDE Y fits our definition model X in MB-IDE Y fits our definition but the model is much
Reference: [Lonczewski96] <author> F. Lonczewski, S. Schreiber: </author> <title> The FUSESystem: An Integrated User Interface Design Environment. </title> <editor> In: J. Vanderdonckt (ed.): </editor> <booktitle> Computer-Aided Design of User Interfaces. </booktitle> <address> Namur: </address> <publisher> Namur University Press, </publisher> <year> 1996, </year> <pages> 37-56. </pages>
Reference-contexts: Several model-based user interface software tools have been built. Some of these are UIDE [Foley88, Foley89, Foley95], ADEPT [Johnson95, Wilson93], HUMANOID [Szekely93], ITS [Wiecha90], MECANO [Puerta94b], Mobi-D [Puerta96a], MASTERMIND [Neches93, Szekely96a], TRIDENT [Bodart95, Bodart96], AME [Mrtin96], FUSE <ref> [Lonczewski96] </ref>, GENIUS [Janssen93], JANUS [Balzert96], TADEUS [Elwert95]. GIT-GVU-96-30 - 5 - 2 Model-based Interface Development Environments 2 . 1 Generic Architecture The typical components and the principal development procedure of a model-based interface development environment are shown in Fig. 1. <p> F U S E The use of declarative models in FUSE <ref> [Lonczewski96] </ref> is similar to TADEUS. The developer creates task, domain, user, and dialogue models. The task model represents a hierarchical structure of the end users tasks. <p> GIT-GVU-96-30 - 16 - Table 1 Declarative Models and their application in MB-IDEs Task Domain U s e r Dialogue Presentation UIDE [Foley95] ADEPT [Johnson95] MASTERMIND [Szekely96a] MECANO [Puerta94b] Mobi-D [Puerta96a] TRIDENT [Bodart95,96] AME [Mrtin96] G E N I US [Janssen93] F U S E <ref> [Lonczewski96] </ref> J A N U S [Balzert96] TADEUS [Elwert94,95] model X in MB-IDE Y fits our definition model X in MB-IDE Y fits our definition but the model is much extended model X is included in the Interface Model of MB-IDE Y, but there are not any examples which make use <p> 2 Domain Models and their possibility for integration with recent CASE tools Domain model Possibility for integration UIDE [Sukaviriya93b] C++ classes MASTERMIND [Szekely96a] CORBA IDL Mobi-D [Puerta96a] MIMIC Object model TRIDENT [Bodart95,96] ER model AME [Mrtin96] OO-Object model G E N I US [Janssen93] ER model F U S E <ref> [Lonczewski96] </ref> algebraic specification J A N U S [Balzert96] OO-Object model TADEUS [Elwert94,95] OO-Object model domain model is equivalent to the model of recent CASE tools integration of this domain model requires additional transformations a direkt integration is difficult GIT-GVU-96-30 - 18 - 3 Declarative models in future MB-IDEs The hitherto
Reference: [Mrtin96] <author> C. Mrtin: </author> <title> Software Life Cycle Automation for Interactive Applications: The AME Design Environment. </title> <editor> In: J. Vanderdonckt (ed.): </editor> <booktitle> Computer-Aided Design of User Interfaces. </booktitle> <address> Namur: </address> <publisher> Namur University Press, </publisher> <year> 1996, </year> <pages> 57-74. </pages>
Reference-contexts: Several model-based user interface software tools have been built. Some of these are UIDE [Foley88, Foley89, Foley95], ADEPT [Johnson95, Wilson93], HUMANOID [Szekely93], ITS [Wiecha90], MECANO [Puerta94b], Mobi-D [Puerta96a], MASTERMIND [Neches93, Szekely96a], TRIDENT [Bodart95, Bodart96], AME <ref> [Mrtin96] </ref>, FUSE [Lonczewski96], GENIUS [Janssen93], JANUS [Balzert96], TADEUS [Elwert95]. GIT-GVU-96-30 - 5 - 2 Model-based Interface Development Environments 2 . 1 Generic Architecture The typical components and the principal development procedure of a model-based interface development environment are shown in Fig. 1. <p> So it can be used for some sophisticated tools to support the end-user, e.g. automatic generation of contextsensitive, animated help [Sukaviriya90] or adaptive user interfaces [Sukaviriya93a]. AME and JANUS The AME <ref> [Mrtin96] </ref> and JANUS [Balzert96] systems are very similar from the point of view of declarative models. Both systems emphasize the automatic generation of the desired user interface from a much extended objectoriented domain model. During this automatic generation process both systems make use of different comprehensive knowledge bases. <p> GIT-GVU-96-30 - 16 - Table 1 Declarative Models and their application in MB-IDEs Task Domain U s e r Dialogue Presentation UIDE [Foley95] ADEPT [Johnson95] MASTERMIND [Szekely96a] MECANO [Puerta94b] Mobi-D [Puerta96a] TRIDENT [Bodart95,96] AME <ref> [Mrtin96] </ref> G E N I US [Janssen93] F U S E [Lonczewski96] J A N U S [Balzert96] TADEUS [Elwert94,95] model X in MB-IDE Y fits our definition model X in MB-IDE Y fits our definition but the model is much extended model X is included in the Interface Model of <p> there are not any examples which make use of it GIT-GVU-96-30 - 17 - Table 2 Domain Models and their possibility for integration with recent CASE tools Domain model Possibility for integration UIDE [Sukaviriya93b] C++ classes MASTERMIND [Szekely96a] CORBA IDL Mobi-D [Puerta96a] MIMIC Object model TRIDENT [Bodart95,96] ER model AME <ref> [Mrtin96] </ref> OO-Object model G E N I US [Janssen93] ER model F U S E [Lonczewski96] algebraic specification J A N U S [Balzert96] OO-Object model TADEUS [Elwert94,95] OO-Object model domain model is equivalent to the model of recent CASE tools integration of this domain model requires additional transformations a direkt
Reference: [Myers90] <author> B. A. Myers: </author> <title> A New Model for Handling Input. </title> <journal> ACM Transactions on Information Systems 8 (1990), </journal> <volume> 3, </volume> <pages> 289-320. </pages>
Reference: [Myers90b] <author> B. A. Myers, et. al.: Garnet: </author> <title> Comprehensive Support for Graphical, Highly Interactive User Interfaces. </title> <booktitle> IEEE Computer 23 (1990), </booktitle> <volume> 11, </volume> <pages> 71-85. </pages>
Reference-contexts: User-computer interfaces are characterized by bursts of tight, high volume, feedback intensive, input/output event sequences, and these sequences can be described by patterns. To represent lexical patterns, we pull ideas from object oriented UI toolkits. Object oriented toolkits like Garnet <ref> [Myers90b] </ref>, and Amulet [Myers96] provide interactors which encapsulate these tight input/output protocols into implemented units that may be selected from a library and specialized to a particular use. In both toolkits, the number of interactors is fixed and relatively small.
Reference: [Myers92] <author> B. A. Myers, M. B. Rosson: </author> <title> Survey on User Interface Programming. </title> <editor> In: P. Bauersfeld, J. Bennett, G. Lynch (eds.): Striking a Balance. </editor> <booktitle> Proceedings CHI'92 (Monterey, </booktitle> <address> May 1992), New York: </address> <publisher> ACM Press, </publisher> <year> 1992, </year> <pages> 195-202. </pages>
Reference-contexts: But such user interfaces are hard to design and implement. Different studies have shown that an average of 48% of the code of an application is devoted to the user interface, and that about 50% of the implementation time is devoted to implementing the user interface portion <ref> [Myers92] </ref>. As user interfaces become easier to use, they become harder to create. User interface developers need tools which provide a rich support for the development of advanced user interfaces. Over the last years several tools were created to support user interface developers, e.g.
Reference: [Myers95] <author> B. A. Myers: </author> <title> User Interface Software Tools. </title> <journal> ACM Transactions on Computer-Human Interaction 2 (1995), </journal> <volume> 1, </volume> <pages> 64-103. </pages>
Reference-contexts: Over the last years several tools were created to support user interface developers, e.g. Toolkits, User Interface Management Systems, Interface Builders, User Interface Development Environments. In his state of the art report B. Myers has introduced a classification of these user interface software tools <ref> [Myers95] </ref>. It is based on the way user interface developers can specify the layout and the dynamic behavior of a user interface.
Reference: [Myers96] <author> B. A. Myers, A. Ferrency, R. McDaniel, R. C. Miller, P. Doane, A. Mickish, A. Klimovitski: </author> <title> The Amulet V2.0 Reference Manual. </title> <institution> Carnegie-Mellon University, School of Computer Science, </institution> <type> Technical Report CMU-CS-95-166-R1, </type> <year> 1996. </year>
Reference-contexts: User-computer interfaces are characterized by bursts of tight, high volume, feedback intensive, input/output event sequences, and these sequences can be described by patterns. To represent lexical patterns, we pull ideas from object oriented UI toolkits. Object oriented toolkits like Garnet [Myers90b], and Amulet <ref> [Myers96] </ref> provide interactors which encapsulate these tight input/output protocols into implemented units that may be selected from a library and specialized to a particular use. In both toolkits, the number of interactors is fixed and relatively small.
Reference: [Neches93] <author> R. Neches, J. Foley, P. Szekely, P. Sukaviriya, P. Luo, S. Kovacevic, S. Hudson: </author> <title> Knowledgeable Development Environments Using Shared Design Models. </title> <editor> In: W. Gray, W. Hefley, D. Murray (ed.): </editor> <booktitle> Proceedings of the 1993 International Workshop on Intelligent User Interfaces (Orlando, January 1993). </booktitle> <address> New York: </address> <publisher> ACM Press, </publisher> <year> 1993, </year> <pages> 63-70. </pages>
Reference-contexts: These criteria exclude Interface Builders (e.g., DevGuide, UIMX, NeXT) or interface design advisors (e.g., IDA [Reiterer94], EXPOSE [Gorny95]). Several model-based user interface software tools have been built. Some of these are UIDE [Foley88, Foley89, Foley95], ADEPT [Johnson95, Wilson93], HUMANOID [Szekely93], ITS [Wiecha90], MECANO [Puerta94b], Mobi-D [Puerta96a], MASTERMIND <ref> [Neches93, Szekely96a] </ref>, TRIDENT [Bodart95, Bodart96], AME [Mrtin96], FUSE [Lonczewski96], GENIUS [Janssen93], JANUS [Balzert96], TADEUS [Elwert95]. GIT-GVU-96-30 - 5 - 2 Model-based Interface Development Environments 2 . 1 Generic Architecture The typical components and the principal development procedure of a model-based interface development environment are shown in Fig. 1.
Reference: [Olsen93] <author> D. Olsen, J. Foley, S. Hudson, J. Miller, B. Myers: </author> <title> Research directions for user interface software tools. </title> <booktitle> Behaviour & Information Technology 12 (1993), </booktitle> <volume> 2, </volume> <pages> 81-97. </pages> <address> GIT-GVU-96-30 - 25 </address> - 
Reference-contexts: The model-based user interface development approach and its supporting tools is an emerging technology to remedy these shortcomings of current technology through a comprehensive support of the whole life-cycle, and a user-centered design methodology with corresponding environments. Furthermore, Olsen et.al. <ref> [Olsen93] </ref> suggest the automatic user interface generation is an essential part of future user interface GIT-GVU-96-30 - 4 - development environments (e.g., Model-based User Interface Software Tools - MbUIST or Model-Based Interface Development Environments - MB-IDEs).
Reference: [Puerta94a] <author> A. Puerta, P. Szekely: </author> <title> Model-based Interface Development. </title> <booktitle> CHI'94 Tutorial Notes, </booktitle> <year> 1994. </year>
Reference-contexts: Domain, User Models Presentation, Dialogue Models Abstract & Concrete UI Specifications Knowledge Bases Design Knowledge Styleguides Guidelines Delivered Application Fig. 1 Generic architecture of a MB-IDE and model-based user interface development process GIT-GVU-96-30 - 7 - 2 . 2 Declarative Models Different model-based approaches use different declarative models (see also <ref> [Puerta94a] </ref>, [Wilson94], [Schlungbaum96a], [Wilson96b]). Generally, all MB-IDEs use either a task or a domain model. Some MB-IDEs use both. Many MB-IDEs use dialogue and/or presentation models. Furthermore, researchers mention user, implementation platform, and workplace models, but these are rarely used.
Reference: [Puerta94b] <author> A. Puerta, H. Eriksson, J. Gennari, M. Musen: </author> <title> Beyond Data Models for Automated User Interface Generation. </title> <editor> In: G. Cockton, S. Draper, G. Weir (eds.): </editor> <booktitle> People and Computers IX. Proceedings British HCI'94 (Glasgow UK, </booktitle> <month> August </month> <year> 1994). </year> <title> Cambridge: </title> <publisher> Cambridge University Press, </publisher> <year> 1994, </year> <pages> 353-366. </pages>
Reference-contexts: These criteria exclude Interface Builders (e.g., DevGuide, UIMX, NeXT) or interface design advisors (e.g., IDA [Reiterer94], EXPOSE [Gorny95]). Several model-based user interface software tools have been built. Some of these are UIDE [Foley88, Foley89, Foley95], ADEPT [Johnson95, Wilson93], HUMANOID [Szekely93], ITS [Wiecha90], MECANO <ref> [Puerta94b] </ref>, Mobi-D [Puerta96a], MASTERMIND [Neches93, Szekely96a], TRIDENT [Bodart95, Bodart96], AME [Mrtin96], FUSE [Lonczewski96], GENIUS [Janssen93], JANUS [Balzert96], TADEUS [Elwert95]. <p> The result of the generation procedure is a dialogue script file for an existing UIMS, e.g. the ISA Dialogue Manager. MECANO -&gt; Mobi-D The development of the Mobi-D modeling language (MIMIC) and the corresponding tool environment [Puerta96a] is based on the experience developing the MECANO system <ref> [Puerta94b] </ref>. While the MECANO system like the AME or JANUS systems only used a domain model to generate the final user interface the Mobi-D system supports the user interface developer to design the user interface through specifying task, domain, user, dialogue, and presentation models. <p> Furthermore, it incorporates principles of graphic design in order to give a comprehensive support to the dialogue designer. GIT-GVU-96-30 - 16 - Table 1 Declarative Models and their application in MB-IDEs Task Domain U s e r Dialogue Presentation UIDE [Foley95] ADEPT [Johnson95] MASTERMIND [Szekely96a] MECANO <ref> [Puerta94b] </ref> Mobi-D [Puerta96a] TRIDENT [Bodart95,96] AME [Mrtin96] G E N I US [Janssen93] F U S E [Lonczewski96] J A N U S [Balzert96] TADEUS [Elwert94,95] model X in MB-IDE Y fits our definition model X in MB-IDE Y fits our definition but the model is much extended model X is
Reference: [Puerta96a] <author> A. Puerta: </author> <title> The Mecano Project: Comprehensive and Integrated Support for Model-Based Interface Development. </title> <editor> In: J. Vanderdonckt (ed.): </editor> <booktitle> Computer-Aided Design of User Interfaces. </booktitle> <address> Namur: </address> <publisher> Namur University Press, </publisher> <year> 1996, </year> <pages> 19-36. </pages>
Reference-contexts: These criteria exclude Interface Builders (e.g., DevGuide, UIMX, NeXT) or interface design advisors (e.g., IDA [Reiterer94], EXPOSE [Gorny95]). Several model-based user interface software tools have been built. Some of these are UIDE [Foley88, Foley89, Foley95], ADEPT [Johnson95, Wilson93], HUMANOID [Szekely93], ITS [Wiecha90], MECANO [Puerta94b], Mobi-D <ref> [Puerta96a] </ref>, MASTERMIND [Neches93, Szekely96a], TRIDENT [Bodart95, Bodart96], AME [Mrtin96], FUSE [Lonczewski96], GENIUS [Janssen93], JANUS [Balzert96], TADEUS [Elwert95]. GIT-GVU-96-30 - 5 - 2 Model-based Interface Development Environments 2 . 1 Generic Architecture The typical components and the principal development procedure of a model-based interface development environment are shown in Fig. 1. <p> The result of the generation procedure is a dialogue script file for an existing UIMS, e.g. the ISA Dialogue Manager. MECANO -&gt; Mobi-D The development of the Mobi-D modeling language (MIMIC) and the corresponding tool environment <ref> [Puerta96a] </ref> is based on the experience developing the MECANO system [Puerta94b]. <p> Furthermore, it incorporates principles of graphic design in order to give a comprehensive support to the dialogue designer. GIT-GVU-96-30 - 16 - Table 1 Declarative Models and their application in MB-IDEs Task Domain U s e r Dialogue Presentation UIDE [Foley95] ADEPT [Johnson95] MASTERMIND [Szekely96a] MECANO [Puerta94b] Mobi-D <ref> [Puerta96a] </ref> TRIDENT [Bodart95,96] AME [Mrtin96] G E N I US [Janssen93] F U S E [Lonczewski96] J A N U S [Balzert96] TADEUS [Elwert94,95] model X in MB-IDE Y fits our definition model X in MB-IDE Y fits our definition but the model is much extended model X is included in <p> included in the Interface Model of MB-IDE Y, but there are not any examples which make use of it GIT-GVU-96-30 - 17 - Table 2 Domain Models and their possibility for integration with recent CASE tools Domain model Possibility for integration UIDE [Sukaviriya93b] C++ classes MASTERMIND [Szekely96a] CORBA IDL Mobi-D <ref> [Puerta96a] </ref> MIMIC Object model TRIDENT [Bodart95,96] ER model AME [Mrtin96] OO-Object model G E N I US [Janssen93] ER model F U S E [Lonczewski96] algebraic specification J A N U S [Balzert96] OO-Object model TADEUS [Elwert94,95] OO-Object model domain model is equivalent to the model of recent CASE tools integration
Reference: [Puerta96b] <author> A. Puerta: </author> <title> Issues in Automatic Generation of User Interfaces in Model-Based Systems. </title> <editor> In: J. Vanderdonckt (ed.): </editor> <booktitle> Computer-Aided Design of User Interfaces. </booktitle> <address> Namur: </address> <publisher> Namur University Press, </publisher> <year> 1996, </year> <pages> 323-325. </pages>
Reference: [Reiterer94] <author> H. Reiterer: </author> <title> A user interface design approach. </title> <editor> In: K. Brunnstein, E. Raubold (eds.): </editor> <booktitle> Applications and Impacts, Information Processing '94. Proceedings of the IFIP 13th World Computer Congress (Hamburg, </booktitle> <month> August </month> <year> 1994), </year> <title> Vol. </title> <booktitle> 2, IFIP Transactions A-52, </booktitle> <address> Amsterdam: </address> <publisher> North-Holland, </publisher> <year> 1994, </year> <pages> 180-187. </pages>
Reference-contexts: That means, that there is some kind of automatic transformation (s) like knowledge-based generation or simple compilation to implement the running user interface. These criteria exclude Interface Builders (e.g., DevGuide, UIMX, NeXT) or interface design advisors (e.g., IDA <ref> [Reiterer94] </ref>, EXPOSE [Gorny95]). Several model-based user interface software tools have been built. Some of these are UIDE [Foley88, Foley89, Foley95], ADEPT [Johnson95, Wilson93], HUMANOID [Szekely93], ITS [Wiecha90], MECANO [Puerta94b], Mobi-D [Puerta96a], MASTERMIND [Neches93, Szekely96a], TRIDENT [Bodart95, Bodart96], AME [Mrtin96], FUSE [Lonczewski96], GENIUS [Janssen93], JANUS [Balzert96], TADEUS [Elwert95].
Reference: [Rumbaugh91] <author> J. Rumbaugh, M. Blaha, W. Premerlain, F. Eddy, W. Lorenson: </author> <title> Objectoriented Modelling and Design. </title> <address> Englewood Cliffs: </address> <publisher> Prentice Hall, </publisher> <year> 1991. </year>
Reference-contexts: The domain model represents the GIT-GVU-96-30 - 14 - important entities (objects with attributes and methods) of the application domain using an object model known from objectoriented analysis methods like OMT <ref> [Rumbaugh91] </ref>. The user model describes prospective end users in terms of roles and their relations to the tasks they perform. On the basis of these three declarative models the dialogue developer creates the dialogue model. The dialogue design includes manual, computer-aided, and automatic steps.
Reference: [Schlungbaum96a] <author> E. Schlungbaum, T. Elwert: </author> <title> Automatic User Interface Generation from Declarative Models. </title> <editor> In: J. Vanderdonckt (ed.): </editor> <booktitle> Computer-Aided Design of User Interfaces. </booktitle> <address> Namur: </address> <publisher> Namur University Press, </publisher> <year> 1996, </year> <pages> 3-18. </pages>
Reference-contexts: Models Presentation, Dialogue Models Abstract & Concrete UI Specifications Knowledge Bases Design Knowledge Styleguides Guidelines Delivered Application Fig. 1 Generic architecture of a MB-IDE and model-based user interface development process GIT-GVU-96-30 - 7 - 2 . 2 Declarative Models Different model-based approaches use different declarative models (see also [Puerta94a], [Wilson94], <ref> [Schlungbaum96a] </ref>, [Wilson96b]). Generally, all MB-IDEs use either a task or a domain model. Some MB-IDEs use both. Many MB-IDEs use dialogue and/or presentation models. Furthermore, researchers mention user, implementation platform, and workplace models, but these are rarely used.
Reference: [Schlungbaum96b] <author> E. Schlungbaum, T. Elwert: </author> <title> Dialogue Graphs - a Formal and Visual Specification Technique for Dialogue Modelling. In: C.R. </title> <editor> Roast and J.I. Siddiqi (eds): </editor> <booktitle> BCS-FACS Workshop on Formal Aspects of the Human Computer Interface, </booktitle> <institution> Sheffield Hallam University, </institution> <month> 10-12 September </month> <year> 1996. </year> <title> Electronic Workshops in Computing, </title> <publisher> Springer-Verlag, </publisher> <address> Booklet ISBN: 3-540-76105-5, URL: http://www.springer.co.uk/eWiC/Workshops/FAHCI.html. </address>
Reference-contexts: The dialogue design includes manual, computer-aided, and automatic steps. Two levels of dialogue are distinguished in the TADEUS dialogue model: the navigation and the processing dialogue. The navigation dialogue describes the sequencing between different task-oriented presentation units called dialogue views. It can be specified by means of Dialogue graphs <ref> [Schlungbaum96b] </ref> which are based on Coloured Petri Nets. The processing dialogue deals with the description of the dialogue within a dialogue view including the realisation of state changes on the level of user interface objects.
Reference: [Schlungbaum96c] <author> E. Schlungbaum: </author> <title> Individual User Interfaces and Model-based User Interface Software Tools. </title> <type> Research report, </type> <institution> Georgia Institute of Technology, Graphics, Visualization & Usability Center, GIT-GVU-96-28, </institution> <month> November </month> <year> 1996. </year> <note> GIT-GVU-96-30 - 26 </note> - 
Reference-contexts: User Model A user model describes the characteristics of the desired end users or groups of end users (such a group is called a role) of the interactive system to be developed. The main purpose of a user model is to support the creation of individual user interfaces <ref> [Schlungbaum96c] </ref>. The individualization of a user interface can be constituted during design time or runtime.
Reference: [Schreiber95] <author> S. Schreiber: </author> <title> The BOSS System: Coupling Visual Programming with Model Based Interface Design. </title> <editor> In: F. Paterno (ed.): </editor> <title> Interactive Systems: Design, Specification and Verification. </title> <publisher> Berlin: Springer, </publisher> <year> 1995, </year> <pages> 161-179. </pages>
Reference-contexts: The dialogue model is generated by using the task, domain, and user models and additional dialogue design guidelines and can be modified by the UI developer. The dialogue model is represented by Hierarchic Interaction graph Templates (HIT) <ref> [Schreiber95] </ref> which are based on attribute grammers and dataflow diagrams. The final user interface is automatically generated from all four declarative models. Furthermore, the FUSE system allows the automatic generation of an intelligent user guidance component from the task and dialogue models.
Reference: [Storrs95] <author> G. Storrs: </author> <title> The Notion of Task in Human-Computer Interaction. </title> <editor> In: M. Kirby, A. Dix, J. Finlay (eds.): </editor> <booktitle> People and Computers X. Proceedings British HCI'95 (Huddersfield UK, </booktitle> <month> August </month> <year> 1995). </year> <title> Cambridge: </title> <publisher> Cambridge University Press, </publisher> <year> 1995, </year> <pages> 357-365. </pages>
Reference-contexts: G. Storrs has tried to unify the different definitions of a task. For our purposes we can reuse his definition: A task is a goal together with the ordered set of tasks and actions that would satisfy it in the appropriate context. <ref> [Storrs95, p.358] </ref> GIT-GVU-96-30 - 8 - This definition explicates the intertwining nature of tasks and goals. Actions are required to satisfy goals. Furthermore, the definition allows the decomposition of tasks into subtasks and there exist some ordering among the subtasks and actions. <p> In order to complete this definition we need to add the definition of goal and action: A goal is an intention to change or maintain the state of an artifact (based on <ref> [Storrs95, , p. 359] </ref>). An action is any act that has the effect of changing or maintaining the state of an artifact (based on [Storrs95, p. 359]). These two definitions imply that the artifact is essential for task performance. Without an artifact tasks lose their existence. <p> An action is any act that has the effect of changing or maintaining the state of an artifact (based on <ref> [Storrs95, p. 359] </ref>). These two definitions imply that the artifact is essential for task performance. Without an artifact tasks lose their existence. Artifacts are real things existing in the context of task performance in the domain. Artifacts are modeled as objects and represented in the domain model. <p> Artifacts are modeled as objects and represented in the domain model. This implies a close relationship between the task model and the domain model. With these definitions we can derive the information necessary to represent in a task model. According to <ref> [Storrs95] </ref>, one task description includes one goal, a nonempty set of actions or other tasks which are necessary to achieve the goal, a plan of how to select actions or tasks, and a model of an artifact which is influenced by the task.
Reference: [Sukaviriya90] <author> P. Sukaviriya, J. Foley: </author> <title> Coupling a UI Framework with Automatic Generation of ContextSensitive Animated Help. </title> <booktitle> In: Proceedings of the 3rd Annual Symposium on User Interface Software and Technology UIST90 (Snowbird, </booktitle> <address> October 1990). New York: </address> <publisher> ACM Press, </publisher> <year> 1990, </year> <pages> 152-166. </pages>
Reference-contexts: In this way, the application semantic information which is stored in the application model is preserved from design time to run time. So it can be used for some sophisticated tools to support the end-user, e.g. automatic generation of contextsensitive, animated help <ref> [Sukaviriya90] </ref> or adaptive user interfaces [Sukaviriya93a]. AME and JANUS The AME [Mrtin96] and JANUS [Balzert96] systems are very similar from the point of view of declarative models. Both systems emphasize the automatic generation of the desired user interface from a much extended objectoriented domain model.
Reference: [Sukaviriya93a] <author> P. Sukaviriya, J. Foley: </author> <title> Supporting Adaptive Interfaces in a Knowledge-based User Interface Environment. </title> <editor> In: W. Gray, W. Hefley, D. Murray (ed.): </editor> <booktitle> Proceedings of the 1993 International Workshop on Intelligent User Interfaces (Orlando, January 1993). </booktitle> <address> New York: </address> <publisher> ACM Press, </publisher> <year> 1993, </year> <pages> 107-114. </pages>
Reference-contexts: In this way, the application semantic information which is stored in the application model is preserved from design time to run time. So it can be used for some sophisticated tools to support the end-user, e.g. automatic generation of contextsensitive, animated help [Sukaviriya90] or adaptive user interfaces <ref> [Sukaviriya93a] </ref>. AME and JANUS The AME [Mrtin96] and JANUS [Balzert96] systems are very similar from the point of view of declarative models. Both systems emphasize the automatic generation of the desired user interface from a much extended objectoriented domain model.
Reference: [Sukaviriya93b] <author> P. Sukaviriya, J. Foley, T. Griffith: </author> <title> A Second Generation User Interface Design Environment. </title> <editor> In: S. Ashlund, et.al. (eds.): </editor> <title> Bridges between Worlds. </title> <booktitle> Proceedings InterCHI'93 (Amsterdam, </booktitle> <address> April 1993). New York: </address> <publisher> ACM Press, </publisher> <year> 1993, </year> <pages> 375-382. </pages>
Reference-contexts: All recent MB-IDEs support an separated development of the user interface and application parts. The presented information is summarized in Tables at the end of this section. UIDE In UIDE <ref> [Sukaviriya93b] </ref> the designer has to specify an application model (domain model) that consists of application actions, interface actions, and interaction techniques. Parameters, preconditions, and post-conditions are assigned to each action. <p> the model is much extended model X is included in the Interface Model of MB-IDE Y, but there are not any examples which make use of it GIT-GVU-96-30 - 17 - Table 2 Domain Models and their possibility for integration with recent CASE tools Domain model Possibility for integration UIDE <ref> [Sukaviriya93b] </ref> C++ classes MASTERMIND [Szekely96a] CORBA IDL Mobi-D [Puerta96a] MIMIC Object model TRIDENT [Bodart95,96] ER model AME [Mrtin96] OO-Object model G E N I US [Janssen93] ER model F U S E [Lonczewski96] algebraic specification J A N U S [Balzert96] OO-Object model TADEUS [Elwert94,95] OO-Object model domain model is equivalent
Reference: [Sukaviriya95] <author> P. Sukaviriya, J. Muthukumarasamy, M. Frank, J. Foley: </author> <title> A Model-Based User Interface Architecture: Enhancing a Runtime Environment with Declarative Knowledge. </title> <editor> In: F. Paterno (ed.): </editor> <title> Interactive Systems: Design, Specification and Verification. </title> <publisher> Berlin: Springer, </publisher> <year> 1995, </year> <pages> 181-197. </pages>
Reference-contexts: Parameters, preconditions, and post-conditions are assigned to each action. The pre and post-conditions are used to control the user interface during run time by means of the UIDE runtime system. An extension to UIDE <ref> [Sukaviriya95] </ref> provides an application model and an interface model. The application model consists of tasks which will be performed by end-users, their operational constraints, and objects on which these tasks operate. Interface components, application-independent interface tasks, and operational constraints on these tasks are specified in the interface model.
Reference: [Szekely93] <author> P. Szekely, P. Luo, R. Neches: </author> <title> Beyond Interface Builders: Model-Based Interface Tools. </title> <editor> In: S. Ashlund, et.al. (eds.): </editor> <title> Bridges between Worlds. </title> <booktitle> Proceedings InterCHI'93 (Amsterdam, </booktitle> <address> April 1993). New York: </address> <publisher> ACM Press, </publisher> <year> 1993, </year> <pages> 383-390. </pages>
Reference-contexts: These criteria exclude Interface Builders (e.g., DevGuide, UIMX, NeXT) or interface design advisors (e.g., IDA [Reiterer94], EXPOSE [Gorny95]). Several model-based user interface software tools have been built. Some of these are UIDE [Foley88, Foley89, Foley95], ADEPT [Johnson95, Wilson93], HUMANOID <ref> [Szekely93] </ref>, ITS [Wiecha90], MECANO [Puerta94b], Mobi-D [Puerta96a], MASTERMIND [Neches93, Szekely96a], TRIDENT [Bodart95, Bodart96], AME [Mrtin96], FUSE [Lonczewski96], GENIUS [Janssen93], JANUS [Balzert96], TADEUS [Elwert95].
Reference: [Szekely96a] <author> P. Szekely, P. Sukaviriya, P. Castells, J. Muthukumarasamy, E. Salcher: </author> <title> Declarative interface models for user interface construction tools: the MASTERMIND approach. </title> <editor> In: L. Bass, C. Unger (eds.): </editor> <title> Engineering for Human-Computer Interaction. </title> <booktitle> Proceedings of the IFIP TC2/WG2.7 working conference on engineering for human-computer interaction (Yellowstone Park, </booktitle> <month> August </month> <year> 1995). </year> <title> London: </title> <publisher> Chapman & Hall, </publisher> <year> 1996, </year> <pages> 120-150. </pages> <address> GIT-GVU-96-30 - 27 </address> - 
Reference-contexts: These criteria exclude Interface Builders (e.g., DevGuide, UIMX, NeXT) or interface design advisors (e.g., IDA [Reiterer94], EXPOSE [Gorny95]). Several model-based user interface software tools have been built. Some of these are UIDE [Foley88, Foley89, Foley95], ADEPT [Johnson95, Wilson93], HUMANOID [Szekely93], ITS [Wiecha90], MECANO [Puerta94b], Mobi-D [Puerta96a], MASTERMIND <ref> [Neches93, Szekely96a] </ref>, TRIDENT [Bodart95, Bodart96], AME [Mrtin96], FUSE [Lonczewski96], GENIUS [Janssen93], JANUS [Balzert96], TADEUS [Elwert95]. GIT-GVU-96-30 - 5 - 2 Model-based Interface Development Environments 2 . 1 Generic Architecture The typical components and the principal development procedure of a model-based interface development environment are shown in Fig. 1. <p> The final user interface is automatically generated from all four declarative models. Furthermore, the FUSE system allows the automatic generation of an intelligent user guidance component from the task and dialogue models. MASTERMIND In MASTERMIND <ref> [Szekely96a] </ref> the user interface developer has to create task, application (domain), and presentation models. The application model is specified using the CORBA interface definition language (IDL). <p> Furthermore, it incorporates principles of graphic design in order to give a comprehensive support to the dialogue designer. GIT-GVU-96-30 - 16 - Table 1 Declarative Models and their application in MB-IDEs Task Domain U s e r Dialogue Presentation UIDE [Foley95] ADEPT [Johnson95] MASTERMIND <ref> [Szekely96a] </ref> MECANO [Puerta94b] Mobi-D [Puerta96a] TRIDENT [Bodart95,96] AME [Mrtin96] G E N I US [Janssen93] F U S E [Lonczewski96] J A N U S [Balzert96] TADEUS [Elwert94,95] model X in MB-IDE Y fits our definition model X in MB-IDE Y fits our definition but the model is much extended model <p> extended model X is included in the Interface Model of MB-IDE Y, but there are not any examples which make use of it GIT-GVU-96-30 - 17 - Table 2 Domain Models and their possibility for integration with recent CASE tools Domain model Possibility for integration UIDE [Sukaviriya93b] C++ classes MASTERMIND <ref> [Szekely96a] </ref> CORBA IDL Mobi-D [Puerta96a] MIMIC Object model TRIDENT [Bodart95,96] ER model AME [Mrtin96] OO-Object model G E N I US [Janssen93] ER model F U S E [Lonczewski96] algebraic specification J A N U S [Balzert96] OO-Object model TADEUS [Elwert94,95] OO-Object model domain model is equivalent to the model of
Reference: [Szekely96b] <author> P. Szekely: </author> <title> Retrospective and Challenges for Model-Based Interface Development. </title> <editor> In: F. Bodart, J. Vanderdonckt (eds.): </editor> <title> Design, Specification, and Verification of Interactive Systems. </title> <publisher> Berlin: Springer, </publisher> <year> 1996, </year> <pages> 1-27. </pages>
Reference: [UML96] <institution> Unified Modeling Language for Real-Time Systems. </institution> <month> November, </month> <year> 1996. </year> <note> (http://www.rational.com/pst/tech_papers/uml_rt.html) </note>
Reference-contexts: This trend remains even though most of today's software developed is interactive. Even the most recent development by Grady Booch, James Rumbaugh, and Ivar Jacobson, the Unified Modeling Language, a third generation object-oriented modeling language <ref> [UML96] </ref>, does not change this longtime observed situation. Consequently, the only real way to integrate user interface and system development is the simultaneous use of the data model. That is why, recent MB-IDEs include a domain model known from the software engineering methods.
Reference: [Walsh89] <author> P. Walsh: </author> <title> Analysis for task object modelling (ATOM): towards a method of integrating task analysis with Jackson System Development for user interface software design. </title> <editor> In: D. Diaper (ed.): </editor> <title> Task Analysis for Human-Computer Interaction. </title> <address> Chichester: </address> <publisher> Ellis Horwood, </publisher> <year> 1989, </year> <pages> 186-209. </pages>
Reference-contexts: As Paul Walsh put it: "In different methods, it is possible to find a description of tasks expressed in terms of one, some or all of the following: objects, actions, roles, goals, procedures, functions, processes, forms, attributes, relations, predicates, rules, inputs/outputs, and transitions between states." <ref> [Walsh89, p.191] </ref> The task analysis community distinguishes between task processing and goals, but these are closely related. People act to achieve their purposes or goals. They do so by performing some actions which usually change the state of a certain artifact in a certain context.
Reference: [Wiecha90] <author> C. Wiecha, W. Bennett, S. Boies, J. Gould, S. Greene: </author> <title> ITS: A Tool for Rapidly Developing Interactive Applications. </title> <journal> ACM Transactions on Information Systems 8 (1990), </journal> <volume> 3, </volume> <pages> 204-236. </pages>
Reference-contexts: These criteria exclude Interface Builders (e.g., DevGuide, UIMX, NeXT) or interface design advisors (e.g., IDA [Reiterer94], EXPOSE [Gorny95]). Several model-based user interface software tools have been built. Some of these are UIDE [Foley88, Foley89, Foley95], ADEPT [Johnson95, Wilson93], HUMANOID [Szekely93], ITS <ref> [Wiecha90] </ref>, MECANO [Puerta94b], Mobi-D [Puerta96a], MASTERMIND [Neches93, Szekely96a], TRIDENT [Bodart95, Bodart96], AME [Mrtin96], FUSE [Lonczewski96], GENIUS [Janssen93], JANUS [Balzert96], TADEUS [Elwert95].
Reference: [Wilson93] <author> S. Wilson, P. Johnson, C. Kelly, J. Cunningham, P. Markopoulos: </author> <title> Beyond Hacking: A Model Based Approach to User Interface Design. </title> <editor> In: J. Alty, D. Diaper, S. Guest (eds.): </editor> <booktitle> People and Computers VIII. Proceedings British HCI'93 (Loughborough, </booktitle> <month> September </month> <year> 1993). </year> <title> Cambridge: </title> <publisher> Cambridge University Press, </publisher> <pages> 217-231. </pages>
Reference-contexts: These criteria exclude Interface Builders (e.g., DevGuide, UIMX, NeXT) or interface design advisors (e.g., IDA [Reiterer94], EXPOSE [Gorny95]). Several model-based user interface software tools have been built. Some of these are UIDE [Foley88, Foley89, Foley95], ADEPT <ref> [Johnson95, Wilson93] </ref>, HUMANOID [Szekely93], ITS [Wiecha90], MECANO [Puerta94b], Mobi-D [Puerta96a], MASTERMIND [Neches93, Szekely96a], TRIDENT [Bodart95, Bodart96], AME [Mrtin96], FUSE [Lonczewski96], GENIUS [Janssen93], JANUS [Balzert96], TADEUS [Elwert95].
Reference: [Wilson94] <author> S. Wilson, P. Johnson: </author> <title> From Work Tasks to Interactive System Designs (Tutorial Notes British HCI'94). </title> <type> Technical Report 693, </type> <institution> Department of Computer Science, Queen Mary and Westfield College, </institution> <year> 1994. </year>
Reference-contexts: User Models Presentation, Dialogue Models Abstract & Concrete UI Specifications Knowledge Bases Design Knowledge Styleguides Guidelines Delivered Application Fig. 1 Generic architecture of a MB-IDE and model-based user interface development process GIT-GVU-96-30 - 7 - 2 . 2 Declarative Models Different model-based approaches use different declarative models (see also [Puerta94a], <ref> [Wilson94] </ref>, [Schlungbaum96a], [Wilson96b]). Generally, all MB-IDEs use either a task or a domain model. Some MB-IDEs use both. Many MB-IDEs use dialogue and/or presentation models. Furthermore, researchers mention user, implementation platform, and workplace models, but these are rarely used.
Reference: [Wilson96a] <author> S. Wilson, P. Johnson: </author> <title> Bridging the Generation Gap: From Work Tasks to User Interface Designs. </title> <editor> In: J. Vanderdonckt (ed.): </editor> <booktitle> Computer-Aided Design of User Interfaces. </booktitle> <address> Namur: </address> <publisher> Namur University Press, </publisher> <year> 1996, </year> <pages> 77-93. </pages>
Reference-contexts: Consequently, the development of the task model and of the domain model is interrelated. MB-IDEs usually include one task model which describes the tasks end users plan to carry out using the developed interactive system. In the community of task-based design approaches <ref> [Wilson96a] </ref>, this task model is called envisioned task model. An envisioned task model is a result of a design step based on the existing task model. The existing task model describes the current work situation and can be a result of a task analysis.
Reference: [Wilson96b] <author> S. Wilson: </author> <title> Reflections on Model-Based Design: Definitions and Challenges. </title> <editor> In: J. Vanderdonckt (ed.): </editor> <booktitle> Computer-Aided Design of User Interfaces. </booktitle> <address> Namur: </address> <publisher> Namur University Press, </publisher> <year> 1996, </year> <pages> 327-333. </pages>
Reference-contexts: Presentation, Dialogue Models Abstract & Concrete UI Specifications Knowledge Bases Design Knowledge Styleguides Guidelines Delivered Application Fig. 1 Generic architecture of a MB-IDE and model-based user interface development process GIT-GVU-96-30 - 7 - 2 . 2 Declarative Models Different model-based approaches use different declarative models (see also [Puerta94a], [Wilson94], [Schlungbaum96a], <ref> [Wilson96b] </ref>). Generally, all MB-IDEs use either a task or a domain model. Some MB-IDEs use both. Many MB-IDEs use dialogue and/or presentation models. Furthermore, researchers mention user, implementation platform, and workplace models, but these are rarely used. <p> Before we discuss the use of the declarative models in certain MB-IDEs we introduce their definitions. Until now, there are not any clear definitions of the different declarative models used in the MB-IDEs <ref> [Wilson96b] </ref>. Task model The book [Diaper89] presents 5 different approaches to task analysis, but there is no consensus on the precise definition of a task.
References-found: 54

