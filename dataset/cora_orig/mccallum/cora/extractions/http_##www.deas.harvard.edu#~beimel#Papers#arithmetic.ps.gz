URL: http://www.deas.harvard.edu/~beimel/Papers/arithmetic.ps.gz
Refering-URL: http://www.deas.harvard.edu/~beimel/pub.html
Root-URL: 
Title: On Arithmetic Branching Programs  
Author: Amos Beimel Anna Gal 
Address: 40 Oxford st., Cambridge, MA 02138. Austin, TX 78712.  
Affiliation: Division of Engineering Applied Sciences Dept. of Computer Sciences Harvard University The University of Texas at Austin  
Abstract: We consider the model of arithmetic branching programs, which is a generalization of modular branching programs. We show that, up to a polynomial factor in size, arithmetic branching programs are equivalent to complements of dependency programs, a model introduced by Pudlak and Sgall [20]. Using this equivalence we prove that dependency programs are closed under conjunction over every field, answering an open problem of [20]. Furthermore, we show that span programs, an algebraic model of computation introduced by Karchmer and Wigderson [16], are at least as strong as arithmetic programs; every arithmetic program can be simulated by a span program of size not more than twice the size of the arithmetic program. Using the above results we give a new proof that N L/poly L/poly, first proved by Wigderson [25]. Our simulation of N L/poly is more efficient, and it holds for logspace counting classes over every field. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> E. Allender. </author> <title> Making computation count: Arith metic circuits in the nineties. </title> <journal> SIGACT NEWS, Complexity Theory Column, </journal> <volume> 28(4) </volume> <pages> 2-15, </pages> <year> 1997. </year>
Reference-contexts: 1 Introduction Algebraic models of computation have received much attention (e.g. <ref> [24, 13, 14, 1] </ref>). One fundamental question is the power of basic algebraic operations. For example, if we can compute the rank of a matrix then we can check if the rows of the matrix are dependent.
Reference: [2] <author> E. Allender, R. Beals, and M. Ogihara. </author> <title> The com plexity of matrix rank and feasible systems of linear equations. </title> <booktitle> In Proc. of the 28th Annu. ACM Symp. on the Theory of Computing, </booktitle> <pages> pages 161-167, </pages> <year> 1996. </year>
Reference-contexts: That is, a function can be computed by a polynomial size mod-p branching program if and only if it can be computed by a polynomial size span program over GF (p). Span programs were considered also in <ref> [5, 3, 4, 2, 12] </ref>. Pudlak and Sgall [20] defined a similar model called dependency programs. <p> It is proved in <ref> [2] </ref> that logspace uniform polynomial size span programs over the ratio-nals characterize the class L C = L . Similarly, logspace uniform polynomial size dependency programs over the rationals characterize the class C = L. <p> Similarly, logspace uniform polynomial size dependency programs over the rationals characterize the class C = L. Our results imply that logspace uniform polynomial size arithmetic programs over the rationals characterize the class co-C = L. (See <ref> [2] </ref> for definitions of these complexity classes.) Remark: Nisan [19] considered a similar complexity model called algebraic branching programs. These programs compute a function from R n to R (where R is a ring), while arithmetic branching programs compute functions from f0; 1g n to f0; 1g. <p> Thus, the three open problems are equivalent. We note that the uniform version of these problems over the rationals is equivalent to an open problem in <ref> [2] </ref> asking if the complexity class C = L is closed under complement (see also the Introduction). Acknowledgments We would like to thank Eric Allender, Allan Borodin, Eyal Kushilevitz, and Avi Wigderson for helpful discussions, and the anonymous referees for helpful comments.
Reference: [3] <author> L. Babai, A. Gal, J. Kollar, L. Ronyai, T. Szabo, and A. Wigderson. </author> <title> Extremal bipartite graphs and superpolynomial lower bounds for monotone span programs. </title> <booktitle> In Proc. of the 28th Annu. ACM Symp. on the Theory of Computing, </booktitle> <pages> pages 603-611, </pages> <year> 1996. </year>
Reference-contexts: That is, a function can be computed by a polynomial size mod-p branching program if and only if it can be computed by a polynomial size span program over GF (p). Span programs were considered also in <ref> [5, 3, 4, 2, 12] </ref>. Pudlak and Sgall [20] defined a similar model called dependency programs.
Reference: [4] <author> L. Babai, A. Gal, and A. Wigderson. </author> <title> Super polynomial lower bounds for monotone span programs. </title> <type> Technical Report 96-37, </type> <institution> DIMACS, </institution> <year> 1996. </year> <note> To appear in Combinatorica. </note>
Reference-contexts: That is, a function can be computed by a polynomial size mod-p branching program if and only if it can be computed by a polynomial size span program over GF (p). Span programs were considered also in <ref> [5, 3, 4, 2, 12] </ref>. Pudlak and Sgall [20] defined a similar model called dependency programs. <p> The proof is similar to the simulation in Lemma 4.1. A similar result for span programs was proved in [16] (see also <ref> [4] </ref>). Lemma 6.3 Let d be a positive integer and q be a prime-power. Then, AP GF (q) (f ) 2d 4 AP GF (q d ) (f ).
Reference: [5] <author> A. Beimel, A. Gal, and M. Paterson. </author> <title> Lower bounds for monotone span programs. </title> <journal> Computational Complexity, </journal> <volume> 6(1) </volume> <pages> 29-45, </pages> <year> 1997. </year> <note> Conference version: FOCS '95. </note>
Reference-contexts: That is, a function can be computed by a polynomial size mod-p branching program if and only if it can be computed by a polynomial size span program over GF (p). Span programs were considered also in <ref> [5, 3, 4, 2, 12] </ref>. Pudlak and Sgall [20] defined a similar model called dependency programs.
Reference: [6] <author> S. J. Berkowitz. </author> <title> On computing the determinant in small parallel time using a small number of processors. </title> <journal> Inform. Process. Lett., </journal> <volume> 18 </volume> <pages> 147-150, </pages> <year> 1984. </year>
Reference-contexts: That is, a function f has a small arithmetic program if and only if its complement f has a small dependency program. Our proof combines results on the computation of the rank <ref> [8, 6, 18] </ref> (for a survey on this subject and a complete list of bibliography see [14]) and the closure of arithmetic programs under disjunction. Our results also imply that dependency programs are closed under conjunction over every field, solving an open problem in [20]. <p> This arithmetic program is used to construct an arithmetic program which simulates the complement of the dependency program. The construction is based on the results of <ref> [8, 6, 18] </ref> that show that the computation of the rank of a matrix can be done in N C 2 over arbitrary fields. We start with some notation. <p> Then we use an arithmetic program simulating the construction of Borodin et al. [8] or Berkowitz <ref> [6] </ref> that compute the coefficients of the characteristic polynomial. There are some technical details left since the result of [18] uses some extension field of K, and we need to simulate the arithmetic over this field by an arithmetic program over K. <p> Thus, each coefficient of the characteristic polynomial det (I B (u)) is a polynomial of ff of degree less than 4s 2 . The result of Borodin et al. [8] or Berkowitz <ref> [6] </ref> imply that there is an arithmetic program that checks if a given coefficient of the characteristic polynomial is non-zero (for an alternative construction see Mahajan and Vinay [17]).
Reference: [7] <author> A. Borodin, A. A. Razborov, and R. </author> <title> Smolen sky. On lower bounds for read-k-times branching programs. </title> <journal> Computational Complexity, </journal> <volume> 3(1) </volume> <pages> 1-18, </pages> <year> 1993. </year>
Reference-contexts: We can assume, w.l.o.g., that there are no parallel edges labeled by 1 and every vertex touches an edge labeled by a literal, hence the number of edges labeled by 1 is at most twice the square of the number of edges labeled by a literal <ref> [7] </ref>. Furthermore, constant edges can be eliminated if we replace every edge labeled by 1 by two parallel edges, one labeled by x 1 and the other by x 1 .
Reference: [8] <author> A. Borodin, J. von zur Gathen, and J. Hopcroft. </author> <title> Fast parallel matrix and GCD computations. </title> <journal> Information and Control, </journal> <volume> 52(3) </volume> <pages> 241-256, </pages> <year> 1982. </year>
Reference-contexts: That is, a function f has a small arithmetic program if and only if its complement f has a small dependency program. Our proof combines results on the computation of the rank <ref> [8, 6, 18] </ref> (for a survey on this subject and a complete list of bibliography see [14]) and the closure of arithmetic programs under disjunction. Our results also imply that dependency programs are closed under conjunction over every field, solving an open problem in [20]. <p> This arithmetic program is used to construct an arithmetic program which simulates the complement of the dependency program. The construction is based on the results of <ref> [8, 6, 18] </ref> that show that the computation of the rank of a matrix can be done in N C 2 over arbitrary fields. We start with some notation. <p> Then we use an arithmetic program simulating the construction of Borodin et al. <ref> [8] </ref> or Berkowitz [6] that compute the coefficients of the characteristic polynomial. There are some technical details left since the result of [18] uses some extension field of K, and we need to simulate the arithmetic over this field by an arithmetic program over K. <p> Thus, each coefficient of the characteristic polynomial det (I B (u)) is a polynomial of ff of degree less than 4s 2 . The result of Borodin et al. <ref> [8] </ref> or Berkowitz [6] imply that there is an arithmetic program that checks if a given coefficient of the characteristic polynomial is non-zero (for an alternative construction see Mahajan and Vinay [17]). <p> Formally, for every edge (z; v) with weight aff k we construct edges (hz; ji; hv; j + ki) for 0 j 4s 2 2 Borodin et al. <ref> [8] </ref> were the first to present such reduction over arbitrary fields. The reduction in [8] is randomized while the reduction in [18] is deterministic. For the lemma the reduction of [8] suffices. k 1. <p> Formally, for every edge (z; v) with weight aff k we construct edges (hz; ji; hv; j + ki) for 0 j 4s 2 2 Borodin et al. <ref> [8] </ref> were the first to present such reduction over arbitrary fields. The reduction in [8] is randomized while the reduction in [18] is deterministic. For the lemma the reduction of [8] suffices. k 1. The weight of these edges is a and the label of these edges is the label of (z; v). <p> aff k we construct edges (hz; ji; hv; j + ki) for 0 j 4s 2 2 Borodin et al. <ref> [8] </ref> were the first to present such reduction over arbitrary fields. The reduction in [8] is randomized while the reduction in [18] is deterministic. For the lemma the reduction of [8] suffices. k 1. The weight of these edges is a and the label of these edges is the label of (z; v).
Reference: [9] <author> G. Buntrock, C. Damm, U. Hertrampf, and C. Meinel. </author> <title> Structure and importance of the logspace-mod class. </title> <journal> Math. Systems Theory, </journal> <volume> 25 </volume> <pages> 223-237, </pages> <year> 1992. </year>
Reference-contexts: of Computer Science of Princeton University, supported in part by NSF under contract STC-91-19999 and the New Jersey Commission on Science and Technology. dency programs [20]. (We give precise definitions of the above models in the next section.) Karchmer and Wigderson [16] defined span programs and showed, using results of <ref> [9] </ref>, that for every fixed prime p span programs over the finite fields GF (p) are equivalent in power to modular branching programs. <p> This model corresponds to nondeterministic logspace Turing machines that count the number of accepting paths; the class of functions that can be computed by polynomial size mod-p branching programs is equal to the class Mod p L/poly <ref> [9, 16] </ref>. Modular branching programs have been defined and studied in [9, 16], and were used to construct private simultaneous protocols in [15]. Modular branching programs are also referred to in the literature as counting branching programs. <p> This model corresponds to nondeterministic logspace Turing machines that count the number of accepting paths; the class of functions that can be computed by polynomial size mod-p branching programs is equal to the class Mod p L/poly <ref> [9, 16] </ref>. Modular branching programs have been defined and studied in [9, 16], and were used to construct private simultaneous protocols in [15]. Modular branching programs are also referred to in the literature as counting branching programs. <p> Furthermore, we show that span programs can simulate arithmetic programs very efficiently. For every function f it holds that SP K (f) 2 AP K (f ). This generalizes the result of [16] for programs over GF (2). For other fields only a polynomial relation was known <ref> [9, 20] </ref>. Our last result shows that, over any field, arithmetic programs can efficiently simulate nondeterministic branching programs. This generalizes a result of Wigderson [25] that modular branching programs over GF (2) (and any fixed finite field) can simulate nondeterministic branching programs (e.g., N L/poly L/poly). <p> Furthermore, constant edges can be eliminated if we replace every edge labeled by 1 by two parallel edges, one labeled by x 1 and the other by x 1 . A mod-p branching program <ref> [9, 16] </ref> is an arithmetic program over GF (p) where the weight of every edge is 1.
Reference: [10] <author> J. F. Buss, G. S. Frandsen, and J. O. Shallit. </author> <title> The computational complexity of some problems of linear algebra. </title> <editor> In R. Reischuk and M. Mor-van, editors, </editor> <booktitle> STACS '97, volume 1200 of Lecture Notes in Computer Science, </booktitle> <pages> pages 451-462. </pages> <publisher> Springer, </publisher> <year> 1997. </year> <note> See also: ECCC report TR97-009, http://www.eccc.uni-trier.de/eccc/, 1997. </note>
Reference-contexts: The arithmetic program is illustrated in Fig. 1. C 1 C 2 ts The arithmetic program for f 1 _f 2 is more complicated. The first construction works only over fields which are not algebraically closed. We use the following lemma of <ref> [10] </ref>. We include its proof for completeness. Lemma 3.2 ([10]) Let d 2.
Reference: [11] <author> A. Gal. </author> <title> Combinatorial methods in Boolean function complexity. </title> <type> PhD thesis, </type> <institution> University of Chicago, </institution> <year> 1995. </year> <note> See also: http://www.eccc.uni-trier.de/eccc-local/ECCC-Theses/eccc-theses.html. </note>
Reference-contexts: We construct a span program that computes f , and has size not more than twice the size of the arithmetic program. Since SP K (f ) = SP K (f ) (see <ref> [11, 20] </ref>) this suffices. Describing the span program requires some more notation. <p> This would enable to simulate span programs by arithmetic programs. On the other hand, if arithmetic programs are equivalent to span programs then they are closed under complement since span programs are closed under complement <ref> [11, 20] </ref>. Thus, the three open problems are equivalent. We note that the uniform version of these problems over the rationals is equivalent to an open problem in [2] asking if the complexity class C = L is closed under complement (see also the Introduction).
Reference: [12] <author> A. Gal. </author> <title> A characterization of span program size and improved lower bounds for monotone span programs. </title> <booktitle> In Proc. of the 30th Annu. ACM Symp. on the Theory of Computing, </booktitle> <year> 1998. </year> <note> To appear. </note>
Reference-contexts: That is, a function can be computed by a polynomial size mod-p branching program if and only if it can be computed by a polynomial size span program over GF (p). Span programs were considered also in <ref> [5, 3, 4, 2, 12] </ref>. Pudlak and Sgall [20] defined a similar model called dependency programs.
Reference: [13] <author> J. von zur Gathen. </author> <title> Algebraic complexity theory. </title> <journal> Ann. Review of Comp. Sci., </journal> <volume> 3 </volume> <pages> 317-347, </pages> <year> 1988. </year>
Reference-contexts: 1 Introduction Algebraic models of computation have received much attention (e.g. <ref> [24, 13, 14, 1] </ref>). One fundamental question is the power of basic algebraic operations. For example, if we can compute the rank of a matrix then we can check if the rows of the matrix are dependent.
Reference: [14] <author> J. von zur Gathen. </author> <title> Parallel linear algebra. </title> <editor> In J. H. Reif, editor, </editor> <booktitle> Synthesis of Parallel Algorithms, </booktitle> <pages> pages 573-617. </pages> <publisher> Morgan Kaufmann, </publisher> <year> 1993. </year>
Reference-contexts: 1 Introduction Algebraic models of computation have received much attention (e.g. <ref> [24, 13, 14, 1] </ref>). One fundamental question is the power of basic algebraic operations. For example, if we can compute the rank of a matrix then we can check if the rows of the matrix are dependent. <p> That is, a function f has a small arithmetic program if and only if its complement f has a small dependency program. Our proof combines results on the computation of the rank [8, 6, 18] (for a survey on this subject and a complete list of bibliography see <ref> [14] </ref>) and the closure of arithmetic programs under disjunction. Our results also imply that dependency programs are closed under conjunction over every field, solving an open problem in [20]. Furthermore, we show that span programs can simulate arithmetic programs very efficiently.
Reference: [15] <author> Y. Ishai and E. Kushilevitz. </author> <title> Private simultaneous messages protocols with applications. </title> <booktitle> In 5th Is-rael Symp. on Theory of Computing and Systems, </booktitle> <pages> pages 174-183, </pages> <year> 1997. </year>
Reference-contexts: Modular branching programs have been defined and studied in [9, 16], and were used to construct private simultaneous protocols in <ref> [15] </ref>. Modular branching programs are also referred to in the literature as counting branching programs. An arithmetic branching program (over a field K) is a branching program where every edge in the graph has a weight which is a number taken from the field K.
Reference: [16] <author> M. Karchmer and A. Wigderson. </author> <title> On span pro grams. </title> <booktitle> In Proc. of the 8th Annu. IEEE Structure in Complexity Theory, </booktitle> <pages> pages 102-111, </pages> <year> 1993. </year>
Reference-contexts: In this work we study algebraic models which supply an arena to study such questions. The algebraic models we consider are arithmetic branching programs, span programs <ref> [16] </ref> and depen fl Email: beimel@deas.harvard.edu. Supported by grants ONR-N00014-96-1-0550 and ARO-DAAL03-92-G0115. Part of this work was done while the author was a postdoctoral fellow at DIMACS, supported in part by NSF under contract STC-91-19999 and the New Jersey Commission on Science and Technology. y Email: panni@cs.utexas.edu. <p> was a postdoctoral fellow at DIMACS and the Dept. of Computer Science of Princeton University, supported in part by NSF under contract STC-91-19999 and the New Jersey Commission on Science and Technology. dency programs [20]. (We give precise definitions of the above models in the next section.) Karchmer and Wigderson <ref> [16] </ref> defined span programs and showed, using results of [9], that for every fixed prime p span programs over the finite fields GF (p) are equivalent in power to modular branching programs. <p> This model corresponds to nondeterministic logspace Turing machines that count the number of accepting paths; the class of functions that can be computed by polynomial size mod-p branching programs is equal to the class Mod p L/poly <ref> [9, 16] </ref>. Modular branching programs have been defined and studied in [9, 16], and were used to construct private simultaneous protocols in [15]. Modular branching programs are also referred to in the literature as counting branching programs. <p> This model corresponds to nondeterministic logspace Turing machines that count the number of accepting paths; the class of functions that can be computed by polynomial size mod-p branching programs is equal to the class Mod p L/poly <ref> [9, 16] </ref>. Modular branching programs have been defined and studied in [9, 16], and were used to construct private simultaneous protocols in [15]. Modular branching programs are also referred to in the literature as counting branching programs. <p> Furthermore, we show that span programs can simulate arithmetic programs very efficiently. For every function f it holds that SP K (f) 2 AP K (f ). This generalizes the result of <ref> [16] </ref> for programs over GF (2). For other fields only a polynomial relation was known [9, 20]. Our last result shows that, over any field, arithmetic programs can efficiently simulate nondeterministic branching programs. <p> The size of the smallest arithmetic program over K that computes f is denoted by AP K (f ). In the definition of the size of an arithmetic branching program we ignore edges labeled by 1. This is the common assumption in the definition of any branching program (e.g. <ref> [21, 16] </ref>). We can assume, w.l.o.g., that there are no parallel edges labeled by 1 and every vertex touches an edge labeled by a literal, hence the number of edges labeled by 1 is at most twice the square of the number of edges labeled by a literal [7]. <p> Furthermore, constant edges can be eliminated if we replace every edge labeled by 1 by two parallel edges, one labeled by x 1 and the other by x 1 . A mod-p branching program <ref> [9, 16] </ref> is an arithmetic program over GF (p) where the weight of every edge is 1. <p> A mod-p branching program [9, 16] is an arithmetic program over GF (p) where the weight of every edge is 1. The program accepts an assignment if the number of consistent paths is not equal to 0 mod-p. 1 1 In <ref> [16] </ref> the accepting criterion is different; the program accepts if the number of consistent paths is equal to 1 mod-p. Definition 2.2 (Span Program [16]) A span program over K is a triplet c M = hM; ; vi, where M is a matrix over K, v is a non-zero row <p> The program accepts an assignment if the number of consistent paths is not equal to 0 mod-p. 1 1 In <ref> [16] </ref> the accepting criterion is different; the program accepts if the number of consistent paths is equal to 1 mod-p. Definition 2.2 (Span Program [16]) A span program over K is a triplet c M = hM; ; vi, where M is a matrix over K, v is a non-zero row vector called the target vector (it has the same number of coordinates as the number of columns in M ), and is a labeling <p> So, f b f b (u)1 is also in span (M u ). This completes proving both claims. We have proved that the span program c M accepts exactly those inputs that satisfy f , as desired. Theorem 5.1 is a generalization of a result of Karch-mer and Wigderson <ref> [16] </ref>, who proved the theorem over GF (2). The construction of the span program in our proof is a generalization of their construction with a somewhat simpler proof. The constant 2 in Theorem 5.1 cannot be replaced by any smaller constant. <p> The proof is similar to the simulation in Lemma 4.1. A similar result for span programs was proved in <ref> [16] </ref> (see also [4]). Lemma 6.3 Let d be a positive integer and q be a prime-power. Then, AP GF (q) (f ) 2d 4 AP GF (q d ) (f ). <p> That is, SP K (f ) = O (n NBP (f )). We simulate the arithmetic program of Lemma 6.2 over an extension field with at least 2 2n elements by a span program using Theorem 5.1. The span program over smaller fields is obtained by the result of <ref> [16] </ref> stating that SP GF (q) (f) d SP GF (q d ) (f ) : 7 Open Problems We mention three open problems that arise from our work.
Reference: [17] <author> M. Mahajan and V Vinay. </author> <title> Determinant: Com binatorics, algorithm, and complexity. </title> <institution> Chicago Journal of Theoretical Computer Science, </institution> <address> http://www.cs.uchicago.edu/publications/cjtcs/, 1997:5, </address> <year> 1997. </year> <title> Preliminary version: A combinatorial algorithm for the determinant, </title> <booktitle> Proc. of the 8th Annu. ACM-SIAM Symp. on Discrete Algorithms, </booktitle> <pages> pages 730-738, </pages> <year> 1997. </year>
Reference-contexts: The result of Borodin et al. [8] or Berkowitz [6] imply that there is an arithmetic program that checks if a given coefficient of the characteristic polynomial is non-zero (for an alternative construction see Mahajan and Vinay <ref> [17] </ref>). That is, given a matrix B (x) over the field K (ff) and an integer ` there is an arithmetic program, denoted C ` , which accepts all the assignments u such that the coefficient of ` in the characteristic polynomial of B (u) is non-zero.
Reference: [18] <author> K. Mulmuley. </author> <title> A fast parallel algorithm to com pute the rank of a matrix over an arbitrary field. </title> <journal> Combinatorica, </journal> <volume> 7 </volume> <pages> 101-104, </pages> <year> 1987. </year>
Reference-contexts: That is, a function f has a small arithmetic program if and only if its complement f has a small dependency program. Our proof combines results on the computation of the rank <ref> [8, 6, 18] </ref> (for a survey on this subject and a complete list of bibliography see [14]) and the closure of arithmetic programs under disjunction. Our results also imply that dependency programs are closed under conjunction over every field, solving an open problem in [20]. <p> This arithmetic program is used to construct an arithmetic program which simulates the complement of the dependency program. The construction is based on the results of <ref> [8, 6, 18] </ref> that show that the computation of the rank of a matrix can be done in N C 2 over arbitrary fields. We start with some notation. <p> Furthermore, let A (x) be an sfis matrix. There exists an arithmetic program of size s O (1) which accepts an input u if and only if rank (A (u)) r. Proof: The proof is composed of two parts. We first use a result of Mulmuley <ref> [18] </ref> which reduces the problem of computing the rank of a matrix, over an arbitrary field, to the problem of computing the char acteristic polynomial of a related matrix 2 . <p> Then we use an arithmetic program simulating the construction of Borodin et al. [8] or Berkowitz [6] that compute the coefficients of the characteristic polynomial. There are some technical details left since the result of <ref> [18] </ref> uses some extension field of K, and we need to simulate the arithmetic over this field by an arithmetic program over K. Our simulation uses the closure under disjunction of arithmetic programs (Corollary 3.5). <p> Let X be a 2s fi 2s diagonal matrix where X i;i = ff i1 and the other entries are 0. Let 4 (A (x)) T 0 : Mulmuley <ref> [18] </ref> proved that for every u 2 f0; 1g n holds that rank (B (u)) = 2 rank (A (u)); and the rank of the matrix B (u) is 2s i, where i is the smallest index such that the coefficient of i in the characteristic polynomial of B, i.e. p <p> Formally, for every edge (z; v) with weight aff k we construct edges (hz; ji; hv; j + ki) for 0 j 4s 2 2 Borodin et al. [8] were the first to present such reduction over arbitrary fields. The reduction in [8] is randomized while the reduction in <ref> [18] </ref> is deterministic. For the lemma the reduction of [8] suffices. k 1. The weight of these edges is a and the label of these edges is the label of (z; v).
Reference: [19] <author> N. Nisan. </author> <title> Lower bounds for non-commutative computation. </title> <booktitle> In Proc. of the 23th Annu. ACM Symp. on the Theory of Computing, </booktitle> <pages> pages 410-418, </pages> <year> 1991. </year>
Reference-contexts: Similarly, logspace uniform polynomial size dependency programs over the rationals characterize the class C = L. Our results imply that logspace uniform polynomial size arithmetic programs over the rationals characterize the class co-C = L. (See [2] for definitions of these complexity classes.) Remark: Nisan <ref> [19] </ref> considered a similar complexity model called algebraic branching programs. These programs compute a function from R n to R (where R is a ring), while arithmetic branching programs compute functions from f0; 1g n to f0; 1g. The motivation of [19] was to prove lower bounds on non-commutative computations. <p> [2] for definitions of these complexity classes.) Remark: Nisan <ref> [19] </ref> considered a similar complexity model called algebraic branching programs. These programs compute a function from R n to R (where R is a ring), while arithmetic branching programs compute functions from f0; 1g n to f0; 1g. The motivation of [19] was to prove lower bounds on non-commutative computations. Organization: In Section 2 we define the computational models we consider. In Section 3 we prove that arithmetic programs are closed under conjunction and disjunction.
Reference: [20] <author> P. Pudlak and J. Sgall. </author> <title> Algebraic models of com putation and interpolation for algebraic proof systems. </title> <editor> In P. W. Beame and S. Buss, editors, </editor> <title> Proof Complexity and Feasible Arithmetic, </title> <booktitle> volume 39 of DIMACS Series in Discrete Mathematics and Theor. Comp. Sci., </booktitle> <pages> pages 279-296. </pages> <publisher> AMS, </publisher> <year> 1998. </year>
Reference-contexts: Part of this work was done while the author was a postdoctoral fellow at DIMACS and the Dept. of Computer Science of Princeton University, supported in part by NSF under contract STC-91-19999 and the New Jersey Commission on Science and Technology. dency programs <ref> [20] </ref>. (We give precise definitions of the above models in the next section.) Karchmer and Wigderson [16] defined span programs and showed, using results of [9], that for every fixed prime p span programs over the finite fields GF (p) are equivalent in power to modular branching programs. <p> That is, a function can be computed by a polynomial size mod-p branching program if and only if it can be computed by a polynomial size span program over GF (p). Span programs were considered also in [5, 3, 4, 2, 12]. Pudlak and Sgall <ref> [20] </ref> defined a similar model called dependency programs. They proved that span programs are at least as strong as dependency programs over every field, and for fixed finite fields the reverse also holds, that is over fixed finite fields span programs and dependency programs are equivalent. ([20] considered only fields GF <p> The model of arithmetic branching programs sheds more light on the models of span programs and dependency programs, e.g., we prove that dependency programs are closed under disjunction, over arbitrary fields, using arithmetic programs (solving an open problem in <ref> [20] </ref>). Furthermore, considering arithmetic branching programs allows us to study the relations between the three models over arbitrary fields. For the clarity of the presentation, we first describe the model of modular branching programs and then describe arithmetic branching programs. <p> To summarize the connections between the different models, denote the size of the smallest span program, dependency program and arithmetic program for a function f by SP K (f ), DP K (f) and AP K (f) respectively. Pudlak and Sgall <ref> [20] </ref> proved that (SP K (f )) 2 DP K f (AP K (f )) 2 (only modular branching programs were considered in [20], however their proof holds for arithmetic programs over arbitrary fields). An easy modification of the arguments in [20] gives DP K f 2 AP K (f ) <p> Pudlak and Sgall <ref> [20] </ref> proved that (SP K (f )) 2 DP K f (AP K (f )) 2 (only modular branching programs were considered in [20], however their proof holds for arithmetic programs over arbitrary fields). An easy modification of the arguments in [20] gives DP K f 2 AP K (f ) (see Appendix B). It is simple to show that arithmetic programs are closed under conjunction. <p> Pudlak and Sgall <ref> [20] </ref> proved that (SP K (f )) 2 DP K f (AP K (f )) 2 (only modular branching programs were considered in [20], however their proof holds for arithmetic programs over arbitrary fields). An easy modification of the arguments in [20] gives DP K f 2 AP K (f ) (see Appendix B). It is simple to show that arithmetic programs are closed under conjunction. Our first technical result is showing that arithmetic programs are closed under disjunction. We present two constructions. <p> Since finite fields are not algebraically closed, we prove the closure under disjunction of arithmetic programs over any field. Our second technical result is that over any field K AP K (f) DP K f : This result, together with results of <ref> [20] </ref>, implies that arithmetic programs are equivalent to complements of dependency programs (up to a polynomial factor in size). That is, a function f has a small arithmetic program if and only if its complement f has a small dependency program. <p> Our results also imply that dependency programs are closed under conjunction over every field, solving an open problem in <ref> [20] </ref>. Furthermore, we show that span programs can simulate arithmetic programs very efficiently. For every function f it holds that SP K (f) 2 AP K (f ). This generalizes the result of [16] for programs over GF (2). For other fields only a polynomial relation was known [9, 20]. <p> Furthermore, we show that span programs can simulate arithmetic programs very efficiently. For every function f it holds that SP K (f) 2 AP K (f ). This generalizes the result of [16] for programs over GF (2). For other fields only a polynomial relation was known <ref> [9, 20] </ref>. Our last result shows that, over any field, arithmetic programs can efficiently simulate nondeterministic branching programs. This generalizes a result of Wigderson [25] that modular branching programs over GF (2) (and any fixed finite field) can simulate nondeterministic branching programs (e.g., N L/poly L/poly). <p> The choice of the fixed vector v does not effect the size of the span program. It is always possible to replace v with any non-zero vector by changing the basis of the matrix M . The default value for the target vector is 1. Definition 2.3 (Dependency Program <ref> [20] </ref>) A dependency program over K is a pair c M = hM; i, where M is a matrix over K, and is a labeling of the rows of M by literals from fx 1 ; : : : ; x n ; x 1 ; : : : ; x <p> The size of c M is the number of rows in M . The size of the smallest dependency program over K that computes f is denoted by DP K (f). In <ref> [20] </ref>, the size of both dependency programs and span programs is defined as the number of columns in the matrix. <p> i=1 ! 0 0 k=2 _ f i A + AP K @ i=k=2+1 1 1 k i=1 If k is not a power of two then AP K W k 2k i=1 AP K (f i ) holds. 4 Arithmetic Programs are Equivalent to Complements of Dependency Programs In <ref> [20] </ref> it was proved that if a function f has a small arithmetic program then its complement f has a small dependency program (see Appendix B). In this section we prove the converse; if f has a small dependency program then the function f has a small arithmetic program. <p> In this section we prove the converse; if f has a small dependency program then the function f has a small arithmetic program. In particular this implies that dependency programs are closed under conjunction in every field, solving an open problem in <ref> [20] </ref>. ([20] proved the closure under conjunction over fixed finite fields.) We begin with an arithmetic program that checks if the rank of a given matrix is at least r. This arithmetic program is used to construct an arithmetic program which simulates the complement of the dependency program. <p> As we have mentioned already in the introduction, the simulation in the other direction, namely DP K (f ) 2 AP K f follows from the arguments of <ref> [20] </ref>. The results of [20] are stated only for modular branching programs, however they easily generalize to arithmetic branching programs and imply DP K (f ) O AP K f . An easy modification of the proof in [20] gives DP K (f ) 2 AP K completeness we prove this <p> As we have mentioned already in the introduction, the simulation in the other direction, namely DP K (f ) 2 AP K f follows from the arguments of <ref> [20] </ref>. The results of [20] are stated only for modular branching programs, however they easily generalize to arithmetic branching programs and imply DP K (f ) O AP K f . An easy modification of the proof in [20] gives DP K (f ) 2 AP K completeness we prove this statement in Appendix B. <p> K (f ) 2 AP K f follows from the arguments of <ref> [20] </ref>. The results of [20] are stated only for modular branching programs, however they easily generalize to arithmetic branching programs and imply DP K (f ) O AP K f . An easy modification of the proof in [20] gives DP K (f ) 2 AP K completeness we prove this statement in Appendix B. The next corollary is an immediate consequence of Theorem 4.2, Corollary 3.5 and Theorem B.1. Corollary 4.3 Let k be a power of 2. <p> The reason is that the conversion from an arithmetic program to a dependency program results in a non-monotone program. In <ref> [20] </ref> it is proved that every monotone dependency program for the function (x 1 _x 2 )^(x 3 _x 4 )^ : : : ^(x n1 _x n ) has size at least 2 n =n. <p> We construct a span program that computes f , and has size not more than twice the size of the arithmetic program. Since SP K (f ) = SP K (f ) (see <ref> [11, 20] </ref>) this suffices. Describing the span program requires some more notation. <p> This would enable to simulate span programs by arithmetic programs. On the other hand, if arithmetic programs are equivalent to span programs then they are closed under complement since span programs are closed under complement <ref> [11, 20] </ref>. Thus, the three open problems are equivalent. We note that the uniform version of these problems over the rationals is equivalent to an open problem in [2] asking if the complexity class C = L is closed under complement (see also the Introduction).
Reference: [21] <author> A. A. Razborov. </author> <title> Lower bounds for determin istic and nondeterministic branching programs. </title> <editor> In L. Budach, editor, </editor> <booktitle> Proc. of Fundamentals of Computation Theory (FCT '91), volume 529 of Lecture Notes in Computer Science, </booktitle> <pages> pages 47-60. </pages> <publisher> Springer-Verlag, </publisher> <year> 1991. </year>
Reference-contexts: The size of the smallest arithmetic program over K that computes f is denoted by AP K (f ). In the definition of the size of an arithmetic branching program we ignore edges labeled by 1. This is the common assumption in the definition of any branching program (e.g. <ref> [21, 16] </ref>). We can assume, w.l.o.g., that there are no parallel edges labeled by 1 and every vertex touches an edge labeled by a literal, hence the number of edges labeled by 1 is at most twice the square of the number of edges labeled by a literal [7]. <p> We give an alternative construction which is more efficient, i.e., the resulting arithmetic program is smaller (see Theorem 6.4). We note that there are different definitions for nondeterministic branching programs in different papers. For more information on nondeterministic branching programs the reader can refer for example to <ref> [21] </ref>. In this paper a nondeterministic branching program is a quadruple hG; ; s; ti where G is a directed acyclic graph, is a labeling of the edges by literals and s and t are vertices.
Reference: [22] <author> K. Reinhardt and E. Allender. </author> <title> Making nondeter minism unambiguous. </title> <booktitle> In Proc. of the 38th Annu. IEEE Symp. on Foundations of Computer Science, </booktitle> <pages> pages 244-253, </pages> <year> 1997. </year>
Reference-contexts: The construction of Wigderson [25] directly generalizes to arithmetic programs over arbitrary fields. The efficient simulation of nondeterministic branching programs by arithmetic programs over any field also follows from a recent result of Reinhardt and Allender <ref> [22] </ref> who proved, using the construction of [25], that N L/poly = U L/poly. However, we give an alternative construction which is more efficient, i.e., the resulting arithmetic program is smaller. The models considered in this paper are closely related to complexity classes defined by logspace bounded nondeterministic Turing machines.
Reference: [23] <author> C. </author> <title> Small. Arithmetic of finite fields. </title> <editor> M. Dekker, </editor> <year> 1991. </year>
Reference: [24] <author> V. Strassen. </author> <title> Algebraic complexity theory. </title> <editor> In J. van Leeuwen, editor, </editor> <booktitle> Handbook of Theoretical Computer Science, volume A, chapter 11, </booktitle> <pages> pages 635-672. </pages> <publisher> Elsevier and The MIT press, </publisher> <year> 1990. </year>
Reference-contexts: 1 Introduction Algebraic models of computation have received much attention (e.g. <ref> [24, 13, 14, 1] </ref>). One fundamental question is the power of basic algebraic operations. For example, if we can compute the rank of a matrix then we can check if the rows of the matrix are dependent.
Reference: [25] <author> A. Wigderson. N L=poly L=poly. </author> <booktitle> In Proc. of the 9th Annu. IEEE Structure in Complexity Theory, </booktitle> <pages> pages 59-62, </pages> <year> 1994. </year> <note> Journal version: </note> <author> A. Gal and A. Wigderson, </author> <title> Boolean complexity classes vs. their arithmetic analogs, Random Structures & Algorithms, </title> <booktitle> 9 </booktitle> <pages> 99-111, </pages> <year> 1996. </year> <note> See also: ECCC report TR95-049, http://www.eccc.uni-trier.de/eccc/, 1995. </note>
Reference-contexts: This generalizes the result of [16] for programs over GF (2). For other fields only a polynomial relation was known [9, 20]. Our last result shows that, over any field, arithmetic programs can efficiently simulate nondeterministic branching programs. This generalizes a result of Wigderson <ref> [25] </ref> that modular branching programs over GF (2) (and any fixed finite field) can simulate nondeterministic branching programs (e.g., N L/poly L/poly). The construction of Wigderson [25] directly generalizes to arithmetic programs over arbitrary fields. <p> Our last result shows that, over any field, arithmetic programs can efficiently simulate nondeterministic branching programs. This generalizes a result of Wigderson <ref> [25] </ref> that modular branching programs over GF (2) (and any fixed finite field) can simulate nondeterministic branching programs (e.g., N L/poly L/poly). The construction of Wigderson [25] directly generalizes to arithmetic programs over arbitrary fields. The efficient simulation of nondeterministic branching programs by arithmetic programs over any field also follows from a recent result of Reinhardt and Allender [22] who proved, using the construction of [25], that N L/poly = U L/poly. <p> The construction of Wigderson <ref> [25] </ref> directly generalizes to arithmetic programs over arbitrary fields. The efficient simulation of nondeterministic branching programs by arithmetic programs over any field also follows from a recent result of Reinhardt and Allender [22] who proved, using the construction of [25], that N L/poly = U L/poly. However, we give an alternative construction which is more efficient, i.e., the resulting arithmetic program is smaller. The models considered in this paper are closely related to complexity classes defined by logspace bounded nondeterministic Turing machines. <p> Wigderson <ref> [25] </ref> proved that modular branching programs over GF (2) (and any fixed finite field) can simulate nondeterministic branching programs (e.g., N L/poly L/poly). The construction of Wigderson [25] directly generalizes to arithmetic programs over arbitrary fields, and yields arithmetic programs of size O njV j 2 (NBP (f )) , where <p> Wigderson <ref> [25] </ref> proved that modular branching programs over GF (2) (and any fixed finite field) can simulate nondeterministic branching programs (e.g., N L/poly L/poly). The construction of Wigderson [25] directly generalizes to arithmetic programs over arbitrary fields, and yields arithmetic programs of size O njV j 2 (NBP (f )) , where n is the number of variables, and jV j and NBP (f ) are the number of vertices and the size, respectively, of the smallest nondeterministic branching
References-found: 25

