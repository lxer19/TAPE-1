URL: http://www.cs.toronto.edu/~ftp/pub/reports/na/cmplx-elem-fcns.ps.Z
Refering-URL: http://www.cs.toronto.edu/NA/reports.html
Root-URL: http://www.cs.toronto.edu
Title: Implementing Complex Elementary Functions Using Exception Handling  
Author: T. E. HULL and THOMAS F. FAIRGRIEVE PING TAK PETER TANG 
Keyword: Categories and Subject Descriptors: G.1 [Numerical Analysis]: General|error analysis, numerical algorithms; Approximation|elementary function approximation; G.4 [Mathematical Software]: Algorithm analysis; Reliability and robustness; Verification General Terms: Algorithms, design Additional Key Words and Phrases: Complex elementary functions, implementation  
Affiliation: University of Toronto and  Argonne National Laboratory  
Abstract: We develop algorithms for reliable and accurate evaluations of the complex elementary functions required in Fortran 77 and Fortran 90, namely cabs, csqrt, cexp, clog, csin and ccos. The algorithms are presented in a pseudo-code which has convenient exception handling facilities. A tight error bound is derived for each algorithm. Corresponding Fortran programs for an IEEE environment have also been developed to illustrate the practicality of the algorithms, and these programs have been tested very carefully to help confirm the correctness of the algorithms and their error bounds | the results of these tests are included in the paper, but the Fortran programs are not. 
Abstract-found: 1
Intro-found: 1
Reference: 1. <institution> American National Standard Programming Language FORTRAN. ANSI X3.9-1978. American National Standards Institute, Inc., </institution> <address> New York, </address> <year> 1978. </year>
Reference-contexts: 1. INTRODUCTION Our purpose is to develop algorithms, along with error bounds, for reliable and accurate evaluations of the complex elementary functions required in Fortran 77 <ref> [1] </ref> and Fortran 90 [4], namely cabs, csqrt, cexp, clog, csin, and ccos. These (seemingly oxymoronic) complex elementary functions can be expressed in terms of formulas involving only real arithmetic and real elementary functions. Complex arithmetic is not needed.
Reference: 2. <author> Hull, T. E., Fairgrieve, T. F., and Tang, P. T. P. </author> <title> Implementing complex elementary functions using exception handling. </title> <institution> Argonne National Laboratory, 9700 S. Cass Ave., Argonne, </institution> <address> Illinois 60439-4844. Preprint MCS-P338-1192 (Jan. </address> <year> 1993). </year>
Reference-contexts: An earlier version of this paper appeared as an Argonne Preprint <ref> [2] </ref>. 2. BASIC NUMERICAL OPERATIONS The complex elementary functions described in Section 4 depend on real arithmetic operations and on real elementary functions.
Reference: 3. <institution> IEEE Standard for Binary Floating-Point Arithmetic. ANSI/IEEE Standard 754-1985. The Institute of Electrical and Electronic Engineers, Inc., </institution> <address> New York, </address> <year> 1985. </year>
Reference-contexts: The pseudo-code algorithms are presented in Section 4, along with error analyses. Special implementations for testing are described in Section 5, and formulas for the error bounds derived in Section 4 are tabulated in Section 5, but extensive testing is done only for IEEE binary arithmetic <ref> [3] </ref> on Sun systems [6]. Issues to be considered in production implementations are discussed in Section 6, and concluding remarks are given in Section 7. We should emphasize that we assume throughout that the function arguments are exact. <p> Then log (1 + x) equals log (y (1 relerr)) = log (y) + log (1 relerr) = log (y) relerr to high accuracy. We have tested the program only in the standard rounding mode of IEEE <ref> [3] </ref> arithmetic (where the two elsif clauses are not needed), but we believe the program is 8 also valid for other arithmetic systems with reasonable rounding conventions, including truncation. 2.4 The logb and scalb Functions We need two functions for manipulating exponents. The first returns an integer value. <p> But for our present purposes it does not matter how such constructs are implemented. In particular, it does not matter whether the transfer of control takes place as soon as the first exception occurs, or whether, as is possible in an IEEE environment <ref> [3] </ref>, the calculation continues to the end of the enable block where a test is made to determine whether or not an exception occurred. We do not make use of any intermediate results that might have been obtained in the enable block. <p> The error bounds derived in this section are repeated in tabular form in Section 5. The term precision is used in the programs to denote the number of significant digits in the machine representations of real numbers | for example, in the IEEE <ref> [3] </ref> binary representation, single precision is 24. 10 4.1 Complex Absolute Value CABS We first consider the absolute value function j z j; where z = x + i y: The program in j z j = x 2 + y 2 : The result of any such calculation is a
Reference: 4. <author> ISO/IEC 1539 : 1991, </author> <title> Information technology Programming languages Fortran. International Standards Organization, </title> <address> Geneva, </address> <year> 1991. </year>
Reference-contexts: 1. INTRODUCTION Our purpose is to develop algorithms, along with error bounds, for reliable and accurate evaluations of the complex elementary functions required in Fortran 77 [1] and Fortran 90 <ref> [4] </ref>, namely cabs, csqrt, cexp, clog, csin, and ccos. These (seemingly oxymoronic) complex elementary functions can be expressed in terms of formulas involving only real arithmetic and real elementary functions. Complex arithmetic is not needed.
Reference: 5. <author> Kahan, W. </author> <title> Branch cuts for complex elementary functions, or Much ado about nothing's sign bit. In The State of the Art in Numerical Analysis: </title> <booktitle> Proceedings of the joint IMA/SIAM conference, </booktitle> <editor> A. Iserles and M. J. D. Powell, Eds. </editor> <publisher> Clarendon Press, Oxford, </publisher> <year> 1987, </year> <pages> pp. 165-211. </pages>
Reference-contexts: We also do not distinguish between signed zeros; for more about the latter in this context, see Kahan <ref> [5] </ref>.) Except for cabs, whose output is to be a normalized real floating-point number (if overflow is not returned), the output in each example is to be a normalized complex floating-point number (if no exception is returned).
Reference: 6. <editor> Numerical Computations Guide. </editor> <title> Part Number: 800-5277-10, Revision A. Sun Microsystems, </title> <publisher> Inc., </publisher> <address> 2550 Garcia Avenue, Mountain View, California 94043-1100. </address> <month> (Feb. 22, </month> <year> 1991). </year>
Reference-contexts: Special implementations for testing are described in Section 5, and formulas for the error bounds derived in Section 4 are tabulated in Section 5, but extensive testing is done only for IEEE binary arithmetic [3] on Sun systems <ref> [6] </ref>. Issues to be considered in production implementations are discussed in Section 6, and concluding remarks are given in Section 7. We should emphasize that we assume throughout that the function arguments are exact. <p> number, and j x j 10 6 ; we have determined that max (j (n=2) tan (x) j; j (n=2) cot (x) j) is almost 7:775 fi 10 12 : If P Iby2 is stored as accurately as possible in 66 bits (which is the default case in Sun systems <ref> [6, p. 53] </ref>), it turns out that E =2 &lt; 1:288 fi 10 21 ; so that max (j (n=2) tan (x) j; j (n=2) cot (x) j) E =2 &lt; 10:015 fi 10 9 = :168E: Under these circumstances, the above bound for the relative errors in the sine and <p> It would have been natural, with our interpretation, to use the "ieee handler" trap-handling facility provided by the Sun system <ref> [6, p. 67] </ref> but it turned out to be both inefficient and somewhat difficult to use. Testing the floating point exception flags using the "ieee flags" subroutine [6, p. 64] is also inefficient, so we instead accessed the flags by using the math library routine "swapEX ". <p> It would have been natural, with our interpretation, to use the "ieee handler" trap-handling facility provided by the Sun system [6, p. 67] but it turned out to be both inefficient and somewhat difficult to use. Testing the floating point exception flags using the "ieee flags" subroutine <ref> [6, p. 64] </ref> is also inefficient, so we instead accessed the flags by using the math library routine "swapEX ".
Reference: 7. <author> Payne, M. N., and Hanek, R. N. </author> <title> Radian reduction for trigonometric functions. </title> <journal> ACM SIGNUM Newsletter 18, </journal> <month> 1 (Jan. </month> <year> 1983), </year> <pages> 19-23. </pages>
Reference-contexts: Both P Iby2 and x 0 will be in relatively high precision. (For a good discussion of how this might be accomplished, see Payne and Hanek <ref> [7] </ref>.) The value of x 0 would now be rounded, to x 00 say, where x 00 = x 0 (1 + * 00 ) and j * 00 j is at least E; and then x 00 would be used as the argument for a sine or a cosine approximation
Reference: 8. <author> Tang, P. T. P. </author> <title> Table-driven implementation of the logarithm function in IEEE floating-point arithmetic. </title> <journal> ACM Trans. Math. Softw. </journal> <volume> 16, </volume> <month> 4 (Dec. </month> <year> 1990), </year> <pages> 378-400. </pages>
Reference-contexts: An implementation of log1p using log. After looking after three special cases, the program takes care to obtain an accurate approximation to log (1 + x): tion that does not rely on the log function, see Tang <ref> [8] </ref>.) The program in Figure 1 first looks after the exceptional case when x 1: Then, when x is so large that log1p (x) can be replaced by log (x); the program makes the replacement; it is sufficient to have x &gt; 1=E; and this also ensures that the replacement is
References-found: 8

