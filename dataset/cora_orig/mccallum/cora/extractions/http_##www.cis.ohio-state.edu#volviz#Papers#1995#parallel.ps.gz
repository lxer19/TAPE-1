URL: http://www.cis.ohio-state.edu/volviz/Papers/1995/parallel.ps.gz
Refering-URL: http://www.cis.ohio-state.edu/volviz/papers_date.html
Root-URL: http://www.cis.ohio-state.edu
Title: Data-Parallel Volume Rendering Algorithms  
Author: Roni Yagel and Raghu Machiraju 
Affiliation: Department of Computer and Information Science The Ohio State University  
Abstract: In this presentation we consider the image composition scheme for parallel volume rendering in which each processor is assigned a portion of the volume. A processor renders only its data by using any existing volume rendering algorithm. We describe one such parallel algorithm that also takes advantage of vector processing capabilities. The resulting images from all processors are then combined (composited) in visibility order to form the final image. The major advantage of this approach is that, as viewing and shading parameters change, only 2D partial images are communicated among processors and not 3D volume data. Through experimental results and performance analysis we show that our parallel algorithm is amenable to extremely efficient implementations on distributed memory MIMD (Multiple Instruction Multiple Data) vector-processor architectures. It is also very suitable for hardware implementation based on image composition architectures, it supports various volume rendering algorithms, and it can be extended to provide load-balanced execution. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Barnett, M., Littlefield, R., Payne, D.G., van de Geijn, R., </author> <title> Global Combine on Mesh Architec tures with Wormhole Routing, </title> <booktitle> Proceedings of International Parallel Processing Symposium, </booktitle> <year> 1993, </year> <month> pp.156-162 </month>
Reference-contexts: In log (p) steps, the final image is created. Image combining belongs to a class of operations called global combining which includes addition, subtraction, etc. of vectors. It is an associative, albeit non-commutative operation. Barnett et al. <ref> [1] </ref> proposed several methods to perform global combining on mesh connected machines. All but a few of these methods can be adapted to perform image combining. <p> Maa et al. [7] used a scheme called binary compositing which is similar to the recursive halving scheme proposed by Barnett et al. <ref> [1] </ref>. The recursive halving scheme, although more efficient, gives rise to more communication than the simple hierarchical method. A pipelined version of the simple hierarchical fan-in scheme can be used giving rise to a hybrid method. <p> The choice of one method of combining over the other can only be determined by the size of the images, the number of processors, the topology of the inter-connection network and the routing strategy used. Once again, Barnett et al. <ref> [1] </ref> performed a comparative study of the different methods of combining in which he concludes that for fewer number of processors, the simple fan-in scheme is more suitable. We now report example implementations on parallel machines.
Reference: [2] <author> Cameron, G.G, Underill, </author> <title> P.E.,Rendering Volumetric Medical Image Data on a SIMD Architec ture Computer, </title> <booktitle> SPIE, Visualization in Biomedical Computing 1992, </booktitle> <volume> Vol. 1808, </volume> <pages> pp. </pages> <address> 137- 142. </address>
Reference-contexts: Most current implementa 3 tions of image order methods are not inherently scalable and require a lot more data management, while data order methods scale better and require only limited data movement. However, reported implementation of data-order methods are fewer <ref> [2] </ref>, [4], [8], [14], since these methods are not very amenable to optimizations (such as adaptive sampling and early ray termination) and all voxels have to be considered to render the image. Elvins [4] and Machiraju and Yagel [8] used splatting as the reconstruction method of choice on MIMD machines. <p> The resulting implementation was not scalable since it required the communication of large amount of 3D volume data. It also suffered from the disadvantage of having computations and communication interspersed. The implementations by Schroeder and Salem [14], and Cameron and Underill <ref> [2] </ref> were conducted on SIMD (Single-Instruction-Multiple-Data) machines. In these data parallel implementations communication and computations are conducted in separate phases. However, the communication is too fine grained, extensive, and frequent for an efficient implementation on MIMD machines.
Reference: [3] <author> Corrie, B., Mackerras, P., </author> <title> Data Coherence in Volume Rendering Algorithm, </title> <booktitle> Proceedings of 1993 Parallel Rendering Symposium, </booktitle> <address> San Jose, CA, </address> <year> 1993, </year> <pages> pp. 23-26. </pages>
Reference-contexts: In the following section we describe previous work conducted in parallel volume rendering. 1.1 Parallel Volume Rendering There exists a growing amount of reported work on parallel volume rendering. Several researchers explored parallelization of the image order approach <ref> [3] </ref>, [10], [12], [15]. Most current implementa 3 tions of image order methods are not inherently scalable and require a lot more data management, while data order methods scale better and require only limited data movement.
Reference: [4] <author> Elvins, T. </author> <title> T.,Volume Rendering on a Distributed Memory Parallel Computer, </title> <booktitle> Proceedings of Visualization92, </booktitle> <address> Boston MA, </address> <month> October </month> <year> 1992, </year> <pages> pp. 93-98. </pages>
Reference-contexts: Most current implementa 3 tions of image order methods are not inherently scalable and require a lot more data management, while data order methods scale better and require only limited data movement. However, reported implementation of data-order methods are fewer [2], <ref> [4] </ref>, [8], [14], since these methods are not very amenable to optimizations (such as adaptive sampling and early ray termination) and all voxels have to be considered to render the image. Elvins [4] and Machiraju and Yagel [8] used splatting as the reconstruction method of choice on MIMD machines. <p> However, reported implementation of data-order methods are fewer [2], <ref> [4] </ref>, [8], [14], since these methods are not very amenable to optimizations (such as adaptive sampling and early ray termination) and all voxels have to be considered to render the image. Elvins [4] and Machiraju and Yagel [8] used splatting as the reconstruction method of choice on MIMD machines. Elvins in his implementation took a functional approach to parallelization, wherein the tasks were mapped to processors based on functions of the pipeline and not on the volume data itself.
Reference: [5] <author> Levoy, M., </author> <title> Display of Surfaces from Volume Data, </title> <journal> IEEE Computer Graphics and Applica tions, </journal> <volume> Vol. 8, No. 5, </volume> <month> May </month> <year> 1988, </year> <pages> pp. 29-37. </pages>
Reference-contexts: Backward or image-order techniques, on the other hand, determine all the voxels of a volume which affect a given pixel on the screen by following a sight ray from the pixel <ref> [5] </ref>. The voxels the ray pierces as it penetrates the volume are mapped to the original pixel. These approaches also differ in the way reconstruction is achieved. In the data-order approach the data samples are convolved with a finite filter kernel to reconstruct an original signal [16]. <p> These approaches also differ in the way reconstruction is achieved. In the data-order approach the data samples are convolved with a finite filter kernel to reconstruct an original signal [16]. In the image-order approach the original signal is reconstructed by a trilinear interpolation from a neighborhood of voxel values <ref> [5] </ref>. Considering the voluminous nature of 3D rasters and the overwhelming amounts of computations required for accurate reconstruction and rendering, it is obvious that special purpose hardware, parallel processing or a combination of both are imperative [18].
Reference: [6] <author> Lo, V., M., Rajopadhye, S., Gupta, G., </author> <title> Mapping Divide and Conquer Algorithms to Parallel Architectures, </title> <booktitle> Proceedings of International Conference on Parallel Processing, </booktitle> <volume> Vol. III, </volume> <pages> pp. 128-135, </pages> <month> Aug. </month> <year> 1991. </year>
Reference-contexts: It is an associative, albeit non-commutative operation. Barnett et al. [1] proposed several methods to perform global combining on mesh connected machines. All but a few of these methods can be adapted to perform image combining. Lo et al. <ref> [6] </ref> proposed a scheme to map divide and conquer algorithms to meshes, which can be adapted to the image combining problem, successfully achieving a very efficient implementation.
Reference: [7] <author> Maa, K., L., Painter, J., S., Hansen, C., D., Krogh, M., F., </author> <title> A Data Distributed, </title> <booktitle> Parallel Algo rithm for Ray-Trace Volume Rendering, Proceedings of 1993 Parallel Rendering Symposium, </booktitle> <address> October 1993, San Jose, CA, pp.15-22. </address>
Reference-contexts: The image composition approach is versatile and can be applied to many rendering methods. Later, we show how two data-order algorithms (splatting and Z-buffer) are implemented under the image compositing paradigm. Recently, Maa et al. proposed the use of image composition to implement a volume ray-caster <ref> [7] </ref>. The image composition paradigm allows also the subdivision of volume space in a variety of ways. One example would be the collection of subvolumes defined by a m-level octree or BSP tree. <p> All but a few of these methods can be adapted to perform image combining. Lo et al. [6] proposed a scheme to map divide and conquer algorithms to meshes, which can be adapted to the image combining problem, successfully achieving a very efficient implementation. Maa et al. <ref> [7] </ref> used a scheme called binary compositing which is similar to the recursive halving scheme proposed by Barnett et al. [1]. The recursive halving scheme, although more efficient, gives rise to more communication than the simple hierarchical method.
Reference: [8] <author> Machiraju, R., Yagel, R. </author> <title> Efficient Feed-Forward Volume Rendering Techniques for Vector and Parallel Processors, </title> <booktitle> Proceedings of SUPERCOMPUTING93, </booktitle> <address> Portland, Oregon, </address> <month> November </month> <year> 1993, </year> <pages> pp. 699-708. </pages>
Reference-contexts: Most current implementa 3 tions of image order methods are not inherently scalable and require a lot more data management, while data order methods scale better and require only limited data movement. However, reported implementation of data-order methods are fewer [2], [4], <ref> [8] </ref>, [14], since these methods are not very amenable to optimizations (such as adaptive sampling and early ray termination) and all voxels have to be considered to render the image. Elvins [4] and Machiraju and Yagel [8] used splatting as the reconstruction method of choice on MIMD machines. <p> However, reported implementation of data-order methods are fewer [2], [4], <ref> [8] </ref>, [14], since these methods are not very amenable to optimizations (such as adaptive sampling and early ray termination) and all voxels have to be considered to render the image. Elvins [4] and Machiraju and Yagel [8] used splatting as the reconstruction method of choice on MIMD machines. Elvins in his implementation took a functional approach to parallelization, wherein the tasks were mapped to processors based on functions of the pipeline and not on the volume data itself.
Reference: [9] <author> Molnar, S., Eyles, J., Poulton J., PixelFlow: </author> <title> High-Speed Rendering Using Image Composi tion, </title> <journal> Computer Graphics, </journal> <volume> Vol. 26, No. 2, </volume> <month> July </month> <year> 1992, </year> <pages> pp. 231-240. </pages>
Reference-contexts: In this paper we consider a general scheme for parallel volume rendering, presented in Section 1.1. We describe an algorithm that has an extremely efficient implementation on distributed memory MIMD architectures and is suitable for hardware implementation based on the image composition architectures <ref> [9] </ref>. This data parallel scheme assigns a portion of the volume to each processor which renders it with any one of the above mentioned rendering algorithms. The resulting images from all processors are then combined (composited) in visibility order to form the final image. <p> The algorithms are also very suitable for hardware implementation based on image composition architecture. Finally, Section 5 contains concluding remarks and future plans. 4 2. Volume Rendering by Parallel Image Composition Of late, image composition approaches are gaining attention from researchers. Molnar et al. proposed the image composition architecture <ref> [9] </ref> and built a prototype. Although their efforts were not directed towards volumes and primarily targeted towards hardware implementations, a similar approach can be adopted in software to render volumes on any given parallel architecture. <p> The reason lies in the network congestion that arises when all processors attempt to send their images to a single distinguished processor. Molnar used a ring as an interconnection network where the compositors function in a pipelined fashion (Figure 1b) <ref> [9] </ref>. Processors operate in a staggered fashion in which processor 1 finishes rendering its volume when the composited image (of 3 and 2) is ready and coming from processor 2.
Reference: [10] <author> Montani, C., Perego, R., Scopigno R., </author> <title> Parallel Volume Visualization on a Hypercube Architec ture, </title> <booktitle> Proceedings of 1992 Workshop on Volume Visualization, </booktitle> <address> October 1992, Boston, MA, </address> <pages> pp. 9-15. </pages>
Reference-contexts: In the following section we describe previous work conducted in parallel volume rendering. 1.1 Parallel Volume Rendering There exists a growing amount of reported work on parallel volume rendering. Several researchers explored parallelization of the image order approach [3], <ref> [10] </ref>, [12], [15]. Most current implementa 3 tions of image order methods are not inherently scalable and require a lot more data management, while data order methods scale better and require only limited data movement.
Reference: [11] <author> Neumann, U., </author> <title> Volume Reconstruction and Parallel Rendering Algorithms: A Comparative Analysis, </title> <type> Ph. D Thesis, </type> <institution> University of North Carolina at Chapel Hill, </institution> <year> 1993. </year>
Reference-contexts: The color assigned to a voxel can be computed from the Phong illumination model or from image space methods. Image space shading methods assign color to voxels based either only on the depth values or on the gradient of depth values [17]. Neumann <ref> [11] </ref> provides a comparison of splatting, ray casting, and multi-pass shears. He compares the execution efficiencies on workstations and the resulting quality of images produced.
Reference: [12] <author> Nieh, J., Levoy, </author> <title> M.,Volume Rendering on Scalable Shared-Memory MIMD Architecture, </title> <booktitle> Proceedings of 1992 Workshop on Volume Visualization, </booktitle> <address> Boston, MA, </address> <pages> pp. 17-24. </pages>
Reference-contexts: In the following section we describe previous work conducted in parallel volume rendering. 1.1 Parallel Volume Rendering There exists a growing amount of reported work on parallel volume rendering. Several researchers explored parallelization of the image order approach [3], [10], <ref> [12] </ref>, [15]. Most current implementa 3 tions of image order methods are not inherently scalable and require a lot more data management, while data order methods scale better and require only limited data movement.
Reference: [13] <author> Porter, T., Duff, </author> <title> T.,Compositing Digital Images, </title> <journal> Computer Graphics, </journal> <volume> Vol. 18, No.3, </volume> <month> July </month> <year> 1984, </year> <pages> pp. 253-259. </pages>
Reference-contexts: Splatting spreads opacity and color of a voxel to several pixels. Explicit hidden volume elimination is achieved by employing either the front-to-back or back-to-front methods [18]. Ideally, the composition operation is tantamount to evaluating an integral. However, a linear operator like the Porter and Duffs <ref> [13] </ref> over operator suffices for most practical renderings. Semi-transparent objects or surfaces can be rendered only if a linear or higher order compositing operator is employed. Alternatively, a Z-buffer can be used to generate depth-cued images for opaque volumes. The composition operator here takes the form of a minimum operator. <p> The incremental scheme of the previous section is used in the first stage of the pipeline. Shading is conducted using the Phong illumination model, while reconstruction through splatting is done with a Gaussian filter. The over operator is used to composite the current slice with the accumulated local image <ref> [13] </ref>. All local images are then combined in parallel using the over operator once again. The transformation and compositing stages are easily amenable to vectorization and have been implemented as vectorized algorithms. The performance of the splatting stage depends more on the nature of data than the other stages. <p> splatting stage is a set of reconstructed and shaded image slices of size I 2 on each processor of the parallel ensemble. c sh T sp c sp Ck 2 N p c sp 20 Composition The composition operation which is implemented as a linear Porter and Duff over operator <ref> [13] </ref> is highly amenable to pipelining or vector execution. Composition is a two dimensional operation and every instance of the operation occurs at I 2 pixel locations, where I is the screen size.
Reference: [14] <author> Schroder, P., Salem, J. B., </author> <title> Fast Rotation of Volume Data on Data Parallel Architecture, </title> <booktitle> Pro ceedings of Visualization91, </booktitle> <address> San Diego, CA, </address> <pages> pp. 50-57. </pages>
Reference-contexts: Most current implementa 3 tions of image order methods are not inherently scalable and require a lot more data management, while data order methods scale better and require only limited data movement. However, reported implementation of data-order methods are fewer [2], [4], [8], <ref> [14] </ref>, since these methods are not very amenable to optimizations (such as adaptive sampling and early ray termination) and all voxels have to be considered to render the image. Elvins [4] and Machiraju and Yagel [8] used splatting as the reconstruction method of choice on MIMD machines. <p> The resulting implementation was not scalable since it required the communication of large amount of 3D volume data. It also suffered from the disadvantage of having computations and communication interspersed. The implementations by Schroeder and Salem <ref> [14] </ref>, and Cameron and Underill [2] were conducted on SIMD (Single-Instruction-Multiple-Data) machines. In these data parallel implementations communication and computations are conducted in separate phases. However, the communication is too fine grained, extensive, and frequent for an efficient implementation on MIMD machines.
Reference: [15] <author> Schroder, P. and Krueger, </author> <title> Data Parallel Volume Rendering Algorithm for Interactive Visualiza tion, </title> <journal> The Visual Computer, </journal> <volume> 9, </volume> <pages> pp. 405-416, </pages> <year> 1993. </year>
Reference-contexts: In the following section we describe previous work conducted in parallel volume rendering. 1.1 Parallel Volume Rendering There exists a growing amount of reported work on parallel volume rendering. Several researchers explored parallelization of the image order approach [3], [10], [12], <ref> [15] </ref>. Most current implementa 3 tions of image order methods are not inherently scalable and require a lot more data management, while data order methods scale better and require only limited data movement.
Reference: [16] <author> Westover, </author> <title> L.,Footprint Evaluation for Volume Rendering,, </title> <journal> Computer Graphics, </journal> <volume> Vol. 24, No. 4, </volume> <month> August </month> <year> 1990, </year> <pages> pp. 367-376. </pages>
Reference-contexts: In the forward or data-order methods each voxel goes through the viewing transformation that maps it to the screen and determines which pixels are inuenced by the current voxel <ref> [16] </ref>. Backward or image-order techniques, on the other hand, determine all the voxels of a volume which affect a given pixel on the screen by following a sight ray from the pixel [5]. The voxels the ray pierces as it penetrates the volume are mapped to the original pixel. <p> The voxels the ray pierces as it penetrates the volume are mapped to the original pixel. These approaches also differ in the way reconstruction is achieved. In the data-order approach the data samples are convolved with a finite filter kernel to reconstruct an original signal <ref> [16] </ref>. In the image-order approach the original signal is reconstructed by a trilinear interpolation from a neighborhood of voxel values [5]. <p> Since no reconstruction is performed, such a direct application of the transformation matrix causes the appearance of holes (absence of voxels) or doubling (presence of multiple voxels) in pixels of the image. Splatting <ref> [16] </ref> is a reconstruction technique employed to reduce the impact of such artifacts. The effect of the splatting operation is equiva 7 lent to throwing a snowball onto a glass plane and it approximates a three dimensional convolution operation with several two dimensional convolution operations.
Reference: [17] <author> Yagel R., Cohen D. Kaufman A., </author> <title> Normal Estimation in 3D Discrete Space, </title> <journal> The Visual Com puter, </journal> <volume> 8, </volume> <pages> 5-6, </pages> <month> June </month> <year> 1992, </year> <pages> pp. 278-291. </pages>
Reference-contexts: The color assigned to a voxel can be computed from the Phong illumination model or from image space methods. Image space shading methods assign color to voxels based either only on the depth values or on the gradient of depth values <ref> [17] </ref>. Neumann [11] provides a comparison of splatting, ray casting, and multi-pass shears. He compares the execution efficiencies on workstations and the resulting quality of images produced. <p> Images generated by this method are shown in Figure 4b. 3.5 Opaque Rendering with Z-buffer The Z-buffer pipeline employs the composition, shading and combining stages after the transformation stage. Composition is achieved by using a Z-buffer, while deferred shading <ref> [17] </ref> provides the color for each visible pixel on a local image. In deferred shading only visible voxels are shaded, thereby allowing for a considerable savings in rendering time.
Reference: [18] <author> Yagel R., </author> <title> Volume Viewing: State of the Art Survey, </title> <booktitle> SIGGRAPH course notes, </booktitle> <volume> Vol. 41, </volume> <booktitle> Au gust 1993, </booktitle> <pages> pp. 109-129. </pages>
Reference-contexts: Considering the voluminous nature of 3D rasters and the overwhelming amounts of computations required for accurate reconstruction and rendering, it is obvious that special purpose hardware, parallel processing or a combination of both are imperative <ref> [18] </ref>. In the following section we describe previous work conducted in parallel volume rendering. 1.1 Parallel Volume Rendering There exists a growing amount of reported work on parallel volume rendering. Several researchers explored parallelization of the image order approach [3], [10], [12], [15]. <p> Splatting spreads opacity and color of a voxel to several pixels. Explicit hidden volume elimination is achieved by employing either the front-to-back or back-to-front methods <ref> [18] </ref>. Ideally, the composition operation is tantamount to evaluating an integral. However, a linear operator like the Porter and Duffs [13] over operator suffices for most practical renderings. Semi-transparent objects or surfaces can be rendered only if a linear or higher order compositing operator is employed.
References-found: 18

