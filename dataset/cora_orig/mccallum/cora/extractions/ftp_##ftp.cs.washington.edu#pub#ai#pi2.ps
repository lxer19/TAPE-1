URL: ftp://ftp.cs.washington.edu/pub/ai/pi2.ps
Refering-URL: http://www.cs.washington.edu/people/faculty/weld.html
Root-URL: http://www.cs.washington.edu
Title: Recent Advances in AI Planning  
Author: Daniel S. Weld 
Date: 1999 October 8, 1998  
Note: to appear in AI Magazine,  
Address: Box 352350 Seattle, WA 98195-2350 USA  
Affiliation: Department of Computer Science Engineering University of Washington,  
Pubnum: Technical Report UW-CSE-98-10-01;  
Abstract: The past five years have seen dramatic advances in planning algorithms, with an emphasis on propositional methods such as Graphplan and compilers that convert planning problems into propositional CNF formulae for solution via systematic or stochastic SAT methods. Related work on the Deep Space One spacecraft control algorithms advances our understanding of interleaved planning and execution. In this survey, we explain the latest techniques and suggest areas for future research. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> C. Anderson, D.E. Smith, and D. Weld. </author> <title> Conditional effects in graphplan. </title> <booktitle> In Proc. 4th Intl. Conf. AI Planning Systems, </booktitle> <month> June </month> <year> 1998. </year>
Reference-contexts: ?s) (location ?d) (road-connected ?s ?d)) :effect (and (at ?v ?d) (not (at ?v ?s)) (when (in cargo ?v) (and (at cargo ?v)) (not (at cargo ?s))) (when (in spare-tire ?v) (and (at spare-tire ?d)) (not (at spare-tire ?s))))) vehicle is empty or contains cargo and/or a spare tire. expansion <ref> [1] </ref>, and partially factored [64]. The simplest approach, full expansion, rewrites an action schema containing conditional effects into a number of mutually exclusive STRIPS schemata by considering all minimal consistent combinations of antecedents in the conditional effects. <p> The most tricky extension stems from the case when one conditional effect is induced by another | i.e., when it is impossible to execute one effect without causing the other to happen as well <ref> [1] </ref>. * Factored expansion also complicates the solution extraction, because of the need to perform the analog of confrontation [88, 107], i.e., prevent the antecedent of undesirable effects from occuring. The IPP planner [65] uses a third method for handling conditional effects which we call partially factored expansion. <p> This difference allows IPP to do less computation during graph expansion, but reduces the number of mutex constraints that will be found. For most domains, the differ ence doesn't matter, but in some cases (e.g., the movie watching domain <ref> [1] </ref>) factored expansion performs exponentially better than IPP. 18 (defschema (drive) :parameters (?v ?s ?d) :precondition (and (vehicle ?v) (at ?v ?s) (location ?s) (location ?d) (road-connected ?s ?d)) :effect (and (at ?v ?d) (not (at ?v ?s)) (forall (object ?o) (when (in ?o ?v) (and (at ?o ?v)) (not (at <p> ?s ?d) :precondition (and (vehicle ?v) (at ?v ?s) (location ?s) (location ?d) (road-connected ?s ?d)) :effect (and (at ?v ?d) (not (at ?v ?s)) (forall (object ?o) (when (in ?o ?v) (and (at ?o ?v)) (not (at ?o ?s)))))) 2.4.3 Universal Quantification The Graphplan descendants IPP [64] and SGP <ref> [1] </ref> each allow action schemata with universal quantification. In preconditions, universal quantification lets one conveniently describe real world actions like the UNIX rmdir command which deletes a directory only if all files inside it have already been deleted.
Reference: [2] <author> F. Bacchus and Y. W. Teh. </author> <title> Making forward chaining relevant. </title> <booktitle> In Proc. 4th Intl. Conf. AI Planning Systems, </booktitle> <pages> pages 54-61, </pages> <month> June </month> <year> 1998. </year>
Reference-contexts: Indeed, in many cases the plain encodings were unsolvable in the alloted time, while the DISCOPLAN-augmented encodings quickly yielded a plan. Other researchers have devised alternative methods for detecting constraints. For example, <ref> [2] </ref> describes a method similar to DISCOPLAN which, in addition, uses regression search to further restrict the predicate domains. Rinta-nen modified algorithms from computer-aided verification to discover binary 29 invariants [91]. Earlier work on the subject is presented in [57]. <p> Recent results extend the theory to handle partially HTN domains [46]. McDermott showed that an emphasis on (automatically) computing an informative heuristic can make an otherwise simple planner extremely effective [81]. TLPLAN uses (user-provided) domain specific control information to offset a simple, forward-chaining search strategy | with impressive results <ref> [2] </ref>. Hector 24 It is interesting to compare this work with similar research on subgoal ordering discussed earlier in the section on Solution Extraction as Constraint Satisfaction. Problem-space graphs [25] and operator graphs [97, 98] share many resemblances to causal graphs.
Reference: [3] <author> F. Bacchus and P. </author> <title> van Run. Dynamic variable ordering in csps. </title> <booktitle> In Proceedings of the 1995 conference on Principles and Practice of Constraint Programming, </booktitle> <pages> pages 258-275, </pages> <month> September </month> <year> 1995. </year>
Reference-contexts: variable collapses (i.e., it shrinks to the empty set), then the CSP solver should backtrack. [66] shows analytically that forward checking is an excellent strategy, strengthening previous empirical support. * Dynamic variable ordering refers to a class of heuristics for choosing which CSP variable should next be assigned a value <ref> [3] </ref>. Of course, eventually all variables must have values assigned but the order in which they are selected can have a huge impact on efficiency [67, 4]. Note that if a variable has only one choice, then it is clearly best to make that assignment immediately.
Reference: [4] <author> A. Barrett and D. Weld. </author> <title> Partial order planning: Evaluating possible efficiency gains. </title> <journal> J. Artificial Intelligence, </journal> <volume> 67(1) </volume> <pages> 71-112, </pages> <year> 1994. </year>
Reference-contexts: Of course, eventually all variables must have values assigned but the order in which they are selected can have a huge impact on efficiency <ref> [67, 4] </ref>. Note that if a variable has only one choice, then it is clearly best to make that assignment immediately. <p> Williams and Nayak formalize this intuition with a set of crisp constraints that are satisfied by the spacecraft domain. The most important of these restrictions is the presence of a serialization ordering for any (satisfiable) set of goals. As previous theoretical work has shown <ref> [67, 4] </ref>, serialized subgoals can be solved extremely quickly, because no backtracking is necessary between subgoals. To give an intuitive blocksworld example, the set of goals 1. Have block C on the table. 2. Have block B on block C. 3.
Reference: [5] <author> R. Bayardo and R. Schrag. </author> <title> Using csp look-back techniques to solve real-world SAT instances. </title> <booktitle> In Proc. 14th Nat. Conf. AI, </booktitle> <address> Providence, R.I., </address> <month> July </month> <year> 1997. </year>
Reference-contexts: The memoization process trades space for time, and although the space requirements can be large, the resulting speedups are significant. As stated, this memoization process is rather simplistic, and since more sophisticated approaches have proven effective in systematic SAT solvers <ref> [5] </ref>, one might suspect memoization improvements are possible. Indeed, recent work by Kambhampati [49] demonstrates dramatic speedups (e.g., between 1.6 and 120 times faster depending on domain). <p> Modify A by flipping the truth assignment of v. truth assignments. By incorporating CSP "Look Back" techniques such as conflict-directed backjumping and and its generalization, relevance-bounded learning, solver speed was increased substantially <ref> [5] </ref>. Another interesting direction is the construction of special-purpose SAT solvers, optimized for CNF encodings of planning problems.
Reference: [6] <author> A. Blum and M. Furst. </author> <title> Fast planning through planning graph analysis. </title> <booktitle> In Proc. 14th Int. Joint Conf. AI, </booktitle> <pages> pages 1636-1642, </pages> <year> 1995. </year>
Reference-contexts: "STanford Research Institute Problem Solver" a very famous and influential planner built in the 1970s to control an unstable mobile robot affec tionately known as "Shakey" [28]. 2 See ftp://ftp.cs.yale.edu/pub/mcdermott/software/pddl.tar.gz for the PDDL specification. 3 See ftp.cs.yale.edu/pub/mcdermott/aipscomp-results.html for competition results. 2 - Graphplan | the original, somewhat dated, C implementation <ref> [6] </ref> is still available from www.cs.cmu.edu/afs/cs.cmu.edu/user/avrim/www/graphplan.html. - IPP [64] is a highly optimized C implementation of Graphplan, extended to handle expressive actions (e.g., universal quantification and conditional effects); download from www.informatik.uni-freiburg.de/~koehler. - STAN is another highly-optimized C implementation which uses an in-place graph representation and performs sophisticated type analy sis to <p> The Medic planner [22] is a flexible testbed, implemented in Lisp, allowing direct comparison of over a dozen different SAT encodings see ftp://ftp.cs.washington.edu/pub/ai/medic.tar.gz. 2 Graphplan & Descendants Blum and Furst's Graphplan algorithm <ref> [6, 7] </ref> is one of the most exciting recent developments in AI planning for two reasons: * Graphplan is a simple, elegant algorithm that yields an extremely speedy planner | in many cases orders of magnitude faster than previous systems such as SNLP [78], Prodigy [82], or UCPOP [88]. * The <p> The benefit achieved by each of these optimizations depends on the specific planning problem to be solved. In the worst case, planning graph expansion is polynomial time while solution extraction is exponential <ref> [6] </ref>. <p> Koehler [63] describes a problem-specific method which speeds Graphplan by orders of magnitude on problems from many domains. 6 * The original Graphplan paper <ref> [6] </ref> describes a technique called memoization which caches for future use the results learned from exhaustive search about inconsistent subgoal sets. <p> Algorithms such as TWEAK [13], SNLP [78], UCPOP [88], and Graphplan <ref> [6] </ref> may all be viewed as special purpose theorem provers aimed at planning problems. However, recent improvements in the performance of propositional satisfia-bility methods [15] call this whole endeavor in doubt. <p> For example, with simple splitting, it would be impossible to have two instantiations of the same action schema execute at the same time, because their split fluents would interfere. Overloaded splitting 17 Contrast our definition of conflict with that of Graphplan <ref> [6] </ref> and [54]. Unlike Kautz and Selman's parallel encoding, but like their linear one, our encodings have axioms stating that actions imply their effects; their parallel encoding prohibits effect-effect conflicts instead. 26 further disallows two instantiations of different actions to execute at the same time, so it requires complete exclusion.
Reference: [7] <author> A. Blum and M. Furst. </author> <title> Fast planning through planning graph analysis. </title> <journal> J. Artificial Intelligence, </journal> <volume> 90(1-2):281-300, </volume> <year> 1997. </year>
Reference-contexts: Although researchers have studied planning since the early days of AI, recent developments have revolutionized the field. Two approaches, in particular have attracted much attention: * The two phase Graphplan <ref> [7] </ref> planning algorithm, and * Methods for compiling planning problems into propositional formulae for solution using the latest, speedy systematic and stochastic SAT algo rithms. These approaches have much in common and both are impacted by recent progress in constraint satisfaction and search technology. <p> The Medic planner [22] is a flexible testbed, implemented in Lisp, allowing direct comparison of over a dozen different SAT encodings see ftp://ftp.cs.washington.edu/pub/ai/medic.tar.gz. 2 Graphplan & Descendants Blum and Furst's Graphplan algorithm <ref> [6, 7] </ref> is one of the most exciting recent developments in AI planning for two reasons: * Graphplan is a simple, elegant algorithm that yields an extremely speedy planner | in many cases orders of magnitude faster than previous systems such as SNLP [78], Prodigy [82], or UCPOP [88]. * The
Reference: [8] <author> A. L. Blum and J. C. Langford. </author> <title> Probabilistic planning in the graphplan framework. </title> <booktitle> In AIPS98 Workshop on Planning as Combinatorial Search, </booktitle> <pages> pages 8-12, </pages> <month> June </month> <year> 1998. </year>
Reference-contexts: Neither CGP nor SGP incorporate numerical probabilistic reasoning; both build separate planning graph structures for each possible world specified by the problem's uncertainty, and so scaling is a concern. PGraphplan <ref> [8] </ref> adopts the MDP framework (i.e., numerical probability, complete observability) and builds an optimal n-step, contingent plan using a single planning-graph-like structure to accelerate forward-chaining search (see also [11]).
Reference: [9] <author> D. Bobrow, </author> <title> editor. Special issue on qualitative reasoning about physical systems. </title> <journal> J. Artificial Intelligence, </journal> <volume> 24, </volume> <month> December </month> <year> 1984. </year>
Reference-contexts: These variables have the domains shown below: valve-mode 2 fopen; closed; stuck-open; stuck-closedg f in ; F OU T 2 fpositive; zero; negativeg p in ; P OU T 2 fhigh; nominal; lowg Note the use of a discretized, qualitative representation <ref> [9, 108] </ref> of the real-valued flow and pressure variables. The cross product of these five variables defines state or if a failure has occurred.
Reference: [10] <author> C. Boutilier, T. Dean, and S. Hanks. </author> <title> Planning under uncertainty: Structural assumptions and computational leverage. </title> <booktitle> In Proceedings of the Second European Workshop on Planning, </booktitle> <year> 1995. </year>
Reference-contexts: However, recent work on MDP abstraction and aggregation [11, 19] calls this intuition into question. In order for the field to advance, more work needs to be done comparing these approaches and testing their relative strengths and limitations. Initial results in this area are a start <ref> [10, 72] </ref>, but empirical comparisons are badly needed. Several researchers have extended Graphplan to handle uncertainty.
Reference: [11] <author> C. Boutilier, R. Dearden, and M. Goldszmidt. </author> <title> Exploiting structure in policy construction. </title> <booktitle> In Proc. 14th Int. Joint Conf. AI, </booktitle> <pages> pages 1104-1111, </pages> <month> August </month> <year> 1995. </year>
Reference-contexts: In the past it was thought that planning-based approaches (by their goal-directed natures) were less sensitive to high-dimension state descriptions, i.e. the presence of many attributes in the initial state. However, recent work on MDP abstraction and aggregation <ref> [11, 19] </ref> calls this intuition into question. In order for the field to advance, more work needs to be done comparing these approaches and testing their relative strengths and limitations. Initial results in this area are a start [10, 72], but empirical comparisons are badly needed. <p> PGraphplan [8] adopts the MDP framework (i.e., numerical probability, complete observability) and builds an optimal n-step, contingent plan using a single planning-graph-like structure to accelerate forward-chaining search (see also <ref> [11] </ref>).
Reference: [12] <author> T. Bylander. </author> <title> Complexity results for planning. </title> <booktitle> In Proceedings of IJCAI-91, </booktitle> <pages> pages 274-279, </pages> <year> 1991. </year>
Reference-contexts: The beauty of Williams and Nayak's algorithm is its guarantee of a speedy response, which at first glance appears to contradict results showing STRIPS planning is PSPACE-complete <ref> [12] </ref>. Underlying Williams and Nayak's method is the insight that spacecraft configuration planning is far easier than general STRIPS planning, because spacecraft engineers specifically designed their creations to be controllable. Williams and Nayak formalize this intuition with a set of crisp constraints that are satisfied by the spacecraft domain.
Reference: [13] <author> D. Chapman. </author> <title> Planning for conjunctive goals. </title> <journal> J. Artificial Intelligence, </journal> <volume> 32(3) </volume> <pages> 333-377, </pages> <year> 1987. </year>
Reference-contexts: See MOLGEN [102] for seminal work on constraint-posting planning. TWEAK <ref> [13] </ref>, SNLP [78], and UCPOP [88] manipulated explicit codesignation and ordering constraints. [44] describes a planner that represented all of its decisions as constraints. [48] provides a formal framework of planning that compares different planners in terms of the way they handle constraints. <p> Algorithms such as TWEAK <ref> [13] </ref>, SNLP [78], UCPOP [88], and Graphplan [6] may all be viewed as special purpose theorem provers aimed at planning problems. However, recent improvements in the performance of propositional satisfia-bility methods [15] call this whole endeavor in doubt.
Reference: [14] <author> J. Cheng and K. B. Irani. </author> <title> Ordering problem subgoals. </title> <booktitle> In Proc. 11th Int. Joint Conf. AI, </booktitle> <pages> pages 931-936, </pages> <month> August </month> <year> 1989. </year>
Reference-contexts: Another method for determining a good subgoal ordering is through structural analysis of subgoal interactions <ref> [42, 14, 96] </ref>. Precomputation aimed at calculating speedy subgoal orderings is closely related to the use of abstraction in planning [59, 103, 114].
Reference: [15] <author> S. Cook and D. Mitchell. </author> <title> Finding hard instances of the satisfiability problem: A survey. Proceedings of the DIMACS Workshop on Satisfiability Problems, </title> <note> To Appear, 1997. 41 </note>
Reference-contexts: Algorithms such as TWEAK [13], SNLP [78], UCPOP [88], and Graphplan [6] may all be viewed as special purpose theorem provers aimed at planning problems. However, recent improvements in the performance of propositional satisfia-bility methods <ref> [15] </ref> call this whole endeavor in doubt. Initial results for compiling bounded-length planning problems to SAT were unremarkable [53], but recent experiments [54] suggest that compilation to SAT might yield the world's fastest STRIPS-style planner. e.g. MEDIC [22] or Blackbox [55]. <p> Many additional heuristics have been proposed to guide the choice of a splitting variable in preparation for the divide and conquer recursive call. For example, Satz selects variables by considering how much unit propagation is facilitated if it branches on that variable [71]. See <ref> [15] </ref> for a discussion of other heuristics. 30 Procedure DPLL (CNF formula: OE) If OE is empty, return yes. Else if there is an empty clause in OE return no.
Reference: [16] <author> J. Crawford and L. Auton. </author> <title> Experimental results on the cross-over point in satisfiability problems. </title> <booktitle> In Proc. 11th Nat. Conf. AI, </booktitle> <pages> pages 21-27, </pages> <year> 1993. </year>
Reference-contexts: Tableau <ref> [16] </ref> and Satz [71] are tight implementations of DPLL with careful attention to datastructures and indexing. Many additional heuristics have been proposed to guide the choice of a splitting variable in preparation for the divide and conquer recursive call.
Reference: [17] <author> M. Davis, G. Logemann, and D. Loveland. </author> <title> A machine program for theorem proving. </title> <journal> C. ACM, </journal> <volume> 5 </volume> <pages> 394-397, </pages> <year> 1962. </year>
Reference-contexts: Our discussion is therefore brief. SAT solvers are best distinguished by the type of search they perform: systematic or stochastic. 3.3.1 Systematic SAT Solvers Although it was discovered many years ago, the DPLL algorithm <ref> [17] </ref> remains a central algorithm, and it can be summarized with a minimum of background. Let OE be a CNF formula, i.e., a conjunction of clauses (disjunctions).
Reference: [18] <author> J. de Kleer. </author> <title> An assumption-based truth maintenance system. </title> <journal> J. Artificial Intelligence, </journal> <volume> 28 </volume> <pages> 127-162, </pages> <year> 1986. </year>
Reference-contexts: For stochastic methods to reach their potential, automated tuning methods (which don't require solving complete problem instances!) must be developed; [79] reports on work in this direction. 3.3.3 Incremental SAT Solving The problem of propositional satisfiability is closely related to that of truth maintenance <ref> [20, 77, 18] </ref>; we focus on LTMS-style truth maintenance systems [76]. Both problems concern a CNF formula represented as a set of clauses over a set of propositional variables V. A SAT solver seeks to find a truth assignment (i.e., a function from V to ftrue; falseg) that makes true.
Reference: [19] <author> R. Dearden and C. Boutilier. </author> <title> Abstraction and approximate decision-theoretic planning. </title> <journal> J. Artificial Intelligence, </journal> <volume> 89(1-2):219-283, </volume> <year> 1997. </year>
Reference-contexts: In the past it was thought that planning-based approaches (by their goal-directed natures) were less sensitive to high-dimension state descriptions, i.e. the presence of many attributes in the initial state. However, recent work on MDP abstraction and aggregation <ref> [11, 19] </ref> calls this intuition into question. In order for the field to advance, more work needs to be done comparing these approaches and testing their relative strengths and limitations. Initial results in this area are a start [10, 72], but empirical comparisons are badly needed.
Reference: [20] <author> J Doyle. </author> <title> A truth maintenance system. </title> <journal> J. Artificial Intelligence, </journal> <volume> 12 </volume> <pages> 231-272, </pages> <year> 1979. </year>
Reference-contexts: For stochastic methods to reach their potential, automated tuning methods (which don't require solving complete problem instances!) must be developed; [79] reports on work in this direction. 3.3.3 Incremental SAT Solving The problem of propositional satisfiability is closely related to that of truth maintenance <ref> [20, 77, 18] </ref>; we focus on LTMS-style truth maintenance systems [76]. Both problems concern a CNF formula represented as a set of clauses over a set of propositional variables V. A SAT solver seeks to find a truth assignment (i.e., a function from V to ftrue; falseg) that makes true.
Reference: [21] <author> D. Draper, S. Hanks, and D. Weld. </author> <title> Probabilistic planning with information gathering and contingent execution. </title> <booktitle> In Proc. 2nd Intl. Conf. AI Planning Systems, </booktitle> <month> June </month> <year> 1994. </year>
Reference-contexts: Causal-link planners such as XII [37] and PUCCINI [36], on the other hand, work competently. 5.3 Handling Uncertainty Starting with work on the CNLP [89], SENSp [26], Buridan [68, 69] and C-Buridan <ref> [21] </ref> systems, the AI planning community has more seriously considered extensions to action languages that allow the specification of uncertain effects and incomplete information. Of course, much related work has been performed by the UAI community, but usually with different assumptions.
Reference: [22] <author> M. Ernst, T. Millstein, and D. Weld. </author> <title> Automatic sat-compilation of planning problems. </title> <booktitle> In Proc. 15th Int. Joint Conf. AI, </booktitle> <year> 1997. </year>
Reference-contexts: Download from www.dur.ac.uk/~dcs0www/research/stanstuff/stanpage.html. - SGP [109] is a simple, pedagogical Lisp implementation of Graph-plan, extended to handle universal quantification, conditional effects, and uncertainty; see www.cs.washington.edu/research/projects/ai/www/sgp.html. * Systems based on compilation to SAT: The highest performance SAT compiler is Blackbox [55] available www.research.att.com/~kautz/blackbox/index.html. The Medic planner <ref> [22] </ref> is a flexible testbed, implemented in Lisp, allowing direct comparison of over a dozen different SAT encodings see ftp://ftp.cs.washington.edu/pub/ai/medic.tar.gz. 2 Graphplan & Descendants Blum and Furst's Graphplan algorithm [6, 7] is one of the most exciting recent developments in AI planning for two reasons: * Graphplan is a simple, elegant <p> However, recent improvements in the performance of propositional satisfia-bility methods [15] call this whole endeavor in doubt. Initial results for compiling bounded-length planning problems to SAT were unremarkable [53], but recent experiments [54] suggest that compilation to SAT might yield the world's fastest STRIPS-style planner. e.g. MEDIC <ref> [22] </ref> or Blackbox [55]. The compiler takes a planning problem as input, guesses a plan length, and generates a propositional logic formula, which if satisfied, implies the existence of a solution plan; a symbol table records the correspondence between propositional variables and the planning instance. <p> Two factors determine these sizes: the encoding and optimizations being used. Since the encoding is the more fundamental notion, we focus on it first, presenting a parameterized space of possibilities (developed in <ref> [22] </ref>) with two dimensions * The choice of a regular, simply split, overloaded split, or bitwise action representation specifies the correspondence between propositional variables and ground (fully-instantiated) plan actions. <p> Which action representation is the best? While more experiments need to be performed, preliminary results suggest that the regular and simply split representations are good choices <ref> [22] </ref>. In contrast, bitwise and overloaded result in convoluted encodings that resist simplification and type analysis. <p> t))_ (DriveArg1 (Truck9, t) ^ DriveArg2 (Seattle, t) ^ DriveArg3 (Kent, t)) _ : : : _ (DriveArg1 (Truck9, t) ^ DriveArg2 (Seattle, t) ^ DriveArg3 (Tacoma, t))) But this disjunction is really just enumerating all the possible destinations, which is silly, so the compiler can do a factoring optimization <ref> [22] </ref> by recognizing which parameters affect which literals, and generating simplified frames axioms 16 For this example, the compiler should generate (the vastly simpler): 16 In fact, the factoring optimization should be applied to all axiom types | not just frame axioms. 25 At (Truck9, t1)^:At (Truck9, t+1) ) (DriveArg1 (Truck9, <p> The bitwise action representation requires no action exclusion axioms. At any time step, only one fully-instantiated action's index can be represented by the bit symbols, so a total ordering is guaranteed. What is the best way to represent frame axioms? Experience <ref> [54, 22] </ref> shows that explanatory frame axioms are clearly superior to classical frames in almost every case. <p> Since parallel actions encode longer plans with the same number of time steps, conflict exclusion should be used whenever possible (e.g., with the regular action representation or with the minimal additional exclusions necessary for the simply split representation). 3.1.3 Other Kinds of Encodings The MEDIC planning compiler <ref> [22] </ref> uses the taxonomy described above to generate any of twelve different encodings. In addition, MEDIC incorporates many switch-selectable optimizations such as type analysis; these features make MEDIC a powerful testbed for research in SAT-based planning. <p> The same approaches can be used to shrink the size of the CNF formula that a SAT-compiler generates. The 28 MEDIC compiler performs optimizations that reduce CNF size by as much at 69% on a variety of problems <ref> [22] </ref>. Another way to optimize the CNF formula produced by a compiler is to add domain specific information. Typically this knowledge is impossible to express in terms of STRIPS actions but is natural when writing general logical axioms, and can be induced when processing action schemata and initial state specifications.
Reference: [23] <author> K. Erol, J. Hendler, and D. Nau. </author> <title> HTN planning: Complexity and expres-sivity. </title> <booktitle> In Proc. 12th Nat. Conf. AI, </booktitle> <pages> pages 1123-1128, </pages> <month> July </month> <year> 1994. </year>
Reference-contexts: Work has also been done exploring ways of encoding hierarchical task network (HTN) planning <ref> [23] </ref> as a SAT problem [75]. 3.1.4 Comparison with Graphplan Note the strong similarities between Graphplan-derivative and SAT-based planning systems. * Both approaches convert parameterized action schemata into a finite propo sitional structure (e.g., the planning graph and a CNF formula) represent ing the space of possible plans up to a
Reference: [24] <author> O. Etzioni and D. Weld. </author> <title> A softbot-based interface to the Internet. </title> <journal> C. ACM, </journal> <volume> 37(7) </volume> <pages> 72-6, </pages> <year> 1994. </year>
Reference-contexts: Regression focussing (described previously) provides some of these advantages to propositional planners. One situation where causal link planners still seem to excel are software domains in which the domain of discourse is unknown to the agent <ref> [24] </ref>. When an agent is faced with incomplete information, it can not construct the Herbrand base and hence is unable to use propositional planning methods.
Reference: [25] <author> Oren Etzioni. </author> <title> Acquiring search-control knowledge via static analysis. </title> <journal> Artificial Intelligence, </journal> <volume> 62(2) </volume> <pages> 255-302, </pages> <year> 1993. </year>
Reference-contexts: When these level-k + 2 conditions are short, then many searches can be terminated very quickly. These methods are 6 See <ref> [25, 97, 98] </ref> for additional uses of precomputation based on analysis of action interactions 11 (defschema (drive) :parameters (?v ?s ?d) :precondition (and (vehicle ?v) (location ?s) (location ?d) (road-connected ?s ?d) (at ?v ?s)) :effect (and (not (at ?v ?s)) (at ?v ?d))) source location to a destination. based on <p> TLPLAN uses (user-provided) domain specific control information to offset a simple, forward-chaining search strategy | with impressive results [2]. Hector 24 It is interesting to compare this work with similar research on subgoal ordering discussed earlier in the section on Solution Extraction as Constraint Satisfaction. Problem-space graphs <ref> [25] </ref> and operator graphs [97, 98] share many resemblances to causal graphs.
Reference: [26] <author> Oren Etzioni, Steve Hanks, Daniel Weld, Denise Draper, Neal Lesh, and Mike Williamson. </author> <title> An approach to planning with incomplete information. </title> <booktitle> In Proc. 3rd Int. Conf. on Principles of Knowledge Representation and Reasoning, </booktitle> <pages> pages 115-125, </pages> <year> 1992. </year>
Reference-contexts: Causal-link planners such as XII [37] and PUCCINI [36], on the other hand, work competently. 5.3 Handling Uncertainty Starting with work on the CNLP [89], SENSp <ref> [26] </ref>, Buridan [68, 69] and C-Buridan [21] systems, the AI planning community has more seriously considered extensions to action languages that allow the specification of uncertain effects and incomplete information. Of course, much related work has been performed by the UAI community, but usually with different assumptions.
Reference: [27] <author> B. Falkenhainer and K. Forbus. </author> <title> Setting up large scale qualitative models. </title> <booktitle> In Proc. 7th Nat. Conf. AI, </booktitle> <pages> pages 301-306, </pages> <month> August </month> <year> 1988. </year> <note> Reprinted in [108]. </note>
Reference-contexts: below is important. 2.3.1 Solution Extraction as Constraint Satisfaction By observing the connection between the Graphplan solution extraction process and constraint satisfaction problems, we can transfer many insights from the CSP field to planning. 4 There are many possible formulations, but the simplest is in terms of a dynamic CSP <ref> [27] </ref>, i.e. a constraint satisfaction problem in which the set of variables and associated constraints changes based on the selection of values to earlier variables. There is a CSP variable for subgoal literals at each proposition level after level zero.
Reference: [28] <author> R. Fikes and N. Nilsson. </author> <title> STRIPS: A new approach to the application of theorem proving to problem solving. </title> <journal> J. Artificial Intelligence, </journal> <volume> 2(3/4), </volume> <year> 1971. </year>
Reference-contexts: as a standard for teaching purposes and collaborative domain interchange for performance comparison. * Graphplan and its descendants: 1 The acronym STRIPS stands for "STanford Research Institute Problem Solver" a very famous and influential planner built in the 1970s to control an unstable mobile robot affec tionately known as "Shakey" <ref> [28] </ref>. 2 See ftp://ftp.cs.yale.edu/pub/mcdermott/software/pddl.tar.gz for the PDDL specification. 3 See ftp.cs.yale.edu/pub/mcdermott/aipscomp-results.html for competition results. 2 - Graphplan | the original, somewhat dated, C implementation [6] is still available from www.cs.cmu.edu/afs/cs.cmu.edu/user/avrim/www/graphplan.html. - IPP [64] is a highly optimized C implementation of Graphplan, extended to handle expressive actions (e.g., universal quantification and conditional
Reference: [29] <author> M. Fox and D. </author> <title> Long. The automatic inference of state invariants in TIM. </title> <type> Technical Report 11/98, </type> <institution> University of Durham, UK, </institution> <year> 1998. </year>
Reference-contexts: Fox et al. have devised more sophisticated, polynomial-time, planner-independent 13 type-inference methods that deduce state invariants, and they demonstrate that this analysis can significantly speed their version of Graphplan on some domains <ref> [29] </ref>. 7 Their method is based on the observation that a planning domain can be viewed as a collection of finite-state machines where domain constants traverse between states corresponding to predicates. 2.3.4 Regression Focussing As described previously, the planning graph with d proposition levels contains only 8 those actions which could <p> The principles and objectives underlying type analysis for SAT-compilation are the same as previously discussed in the context of Graphplan. Graphplan-based approaches (e.g., inertia optimization [64] and TIM <ref> [29] </ref>) aimed to shrink the size of the planning graph by eliminating static fluents and by avoiding nonsensical action-schemata instantiations. The same approaches can be used to shrink the size of the CNF formula that a SAT-compiler generates.
Reference: [30] <author> B. Gazen and C. Knoblock. </author> <title> Combining the expressivity of UCPOP with the efficiency of Graphplan. </title> <booktitle> In Proc. 4th European Conference on Planning, </booktitle> <month> Sept </month> <year> 1997. </year> <month> 42 </month>
Reference-contexts: Three methods have been devised for allowing Graphplan-derivative planners to handle action schemata with conditional effects: full expansion <ref> [30] </ref>, factored 16 (defschema (drive) :parameters (?v ?s ?d) :precondition (and (vehicle ?v) (at ?v ?s) (location ?s) (location ?d) (road-connected ?s ?d)) :effect (and (at ?v ?d) (not (at ?v ?s)) (when (in cargo ?v) (and (at cargo ?v)) (not (at cargo ?s))) (when (in spare-tire ?v) (and (at spare-tire <p> If a spare fuel drum could also be in the vehicle, then full expansion would generate eight STRIPS schemata. In general, if an action has n conditional effects, each containing m antecedent conjuncts, then full expansion may produce as many as n m STRIPS actions <ref> [30] </ref>. This explosion is common when the conditional effects are universally quantified as in Figure 11. In essence, this schema has one conditional effect for each object that could possibly be put in the truck.
Reference: [31] <author> M. Genesereth and N. Nilsson. </author> <booktitle> Logical Foundations of Artificial Intelli--gence. </booktitle> <publisher> Morgan Kaufmann Publishers, Inc., </publisher> <address> Los Altos, CA, </address> <year> 1987. </year>
Reference-contexts: stated explicitly or else some form on inheritance reasoning must be added to the graph expansion process. 19 where the i correspond to each possible interpretation of (x) under the universe of discourse, fC 1 ; : : : ; C n g, i.e. the possible objects of type t1 <ref> [31, p. 10] </ref>. In each i , all references to x have been replaced with the constant C i . For example, suppose that the universe of vehicle is ftruck37; loader55; plane7g.
Reference: [32] <author> I. Gent and T. Walsh. </author> <title> Towards an understanding of hill-climbing procedures for sat. </title> <booktitle> In Proc. 11th Nat. Conf. AI, </booktitle> <pages> pages 28-33. </pages> <publisher> MIT Press(AAAI), </publisher> <month> July </month> <year> 1993. </year>
Reference-contexts: On each flip, WALKSAT does one of two things; with probability p it chooses the same variable GSAT would have chosen, otherwise it selects a random variable from an unsatisfied clause. Many variants on these algorithms have been constructed and compared, e.g. <ref> [32, 79] </ref>. An especially promising new method, reported in [38], exploits the fact that the time required by the DPLL procedure is highly dependent on the choice of 18 Download from http://www.informatik.tu-darmstadt.de/AI/SATLIB. 32 splitting variable, producing a heavy-tailed distribution of running times (fig-ure 15).
Reference: [33] <author> A. Gerevini and L. Schubert. </author> <title> Accelerating partial-order planners: Some techniques for effective search control and pruning. </title> <journal> J. Artificial Intelligence Research, </journal> <volume> 5 </volume> <pages> 95-137, </pages> <year> 1996. </year>
Reference-contexts: In general, a good heuristic is to select the variable with the fewest remaining (nonconflicting) values and this information is readily available if forward checking is employed. 5 While not astounding, these 5 Similar heuristics have been investigated in the context of causal-link planners; see <ref> [97, 43, 113, 101, 33, 90] </ref>. techniques lead to significant (e.g., 50%) performance improvements in Graphplan [49]. Another method for determining a good subgoal ordering is through structural analysis of subgoal interactions [42, 14, 96].
Reference: [34] <author> A. Gerevini and L. Schubert. </author> <title> Inferring state constraints for domain-independent planning. </title> <booktitle> In Proc. 15th Nat. Conf. AI, </booktitle> <address> Madison, WI, </address> <month> July </month> <year> 1998. </year>
Reference-contexts: For example, one might specify that once trucks are loaded they should immediately move. DISCOPLAN <ref> [34] </ref> is a preprocessing system that infers state constraints from domain definitions. The basic idea is to look for four general axiom patterns (which can be discovered with low-order polynomial effort).
Reference: [35] <author> E. Giunchiglia, A. Massarotto, and R. Sebastiani. </author> <title> Act, and the rest will follow: Exploiting determinism in planning as satisfiability. </title> <booktitle> In Proc. 15th Nat. Conf. AI, </booktitle> <pages> pages 948-953, </pages> <address> Madison, WI, </address> <month> July </month> <year> 1998. </year>
Reference-contexts: This insight suggests a small change to DPLL: restrict the choice of splitting variables to action variables. Interestingly, the result of this restriction is dramatic: up to four orders of magnitude speedup <ref> [35] </ref>.
Reference: [36] <author> K. Golden. </author> <title> Leap before you look: </title> <booktitle> Information gathering in the PUCCINI planner. In Proc. 4th Intl. Conf. AI Planning Systems, </booktitle> <month> June </month> <year> 1998. </year>
Reference-contexts: When an agent is faced with incomplete information, it can not construct the Herbrand base and hence is unable to use propositional planning methods. Causal-link planners such as XII [37] and PUCCINI <ref> [36] </ref>, on the other hand, work competently. 5.3 Handling Uncertainty Starting with work on the CNLP [89], SENSp [26], Buridan [68, 69] and C-Buridan [21] systems, the AI planning community has more seriously considered extensions to action languages that allow the specification of uncertain effects and incomplete information.
Reference: [37] <author> Keith Golden, Oren Etzioni, and Dan Weld. </author> <title> Omnipotence without omniscience: Sensor management in planning. </title> <booktitle> In Proc. 12th Nat. Conf. AI, </booktitle> <pages> pages 1048-1054, </pages> <year> 1994. </year>
Reference-contexts: When an agent is faced with incomplete information, it can not construct the Herbrand base and hence is unable to use propositional planning methods. Causal-link planners such as XII <ref> [37] </ref> and PUCCINI [36], on the other hand, work competently. 5.3 Handling Uncertainty Starting with work on the CNLP [89], SENSp [26], Buridan [68, 69] and C-Buridan [21] systems, the AI planning community has more seriously considered extensions to action languages that allow the specification of uncertain effects and incomplete information.
Reference: [38] <author> C.P. Gomes, B. Selman, and H. Kautz. </author> <title> Boosting combinatorial search through randomization. </title> <booktitle> In Proc. 15th Nat. Conf. AI, </booktitle> <pages> pages 431-437, </pages> <address> Madison, WI, </address> <month> July </month> <year> 1998. </year>
Reference-contexts: Many variants on these algorithms have been constructed and compared, e.g. [32, 79]. An especially promising new method, reported in <ref> [38] </ref>, exploits the fact that the time required by the DPLL procedure is highly dependent on the choice of 18 Download from http://www.informatik.tu-darmstadt.de/AI/SATLIB. 32 splitting variable, producing a heavy-tailed distribution of running times (fig-ure 15).
Reference: [39] <author> C. Green. </author> <title> Application of theorem proving to problem solving. </title> <booktitle> In Proc. 1st Int. Joint Conf. AI, </booktitle> <pages> pages 219-239, </pages> <year> 1969. </year>
Reference-contexts: Since the resulting planning graph contains quantifier-free ground action instances, no changes are required during solution extraction. 3 Compilation of Planning to SAT Despite the early formulation of planning as theorem proving <ref> [39] </ref>, most researchers have long assumed that special-purpose planning algorithms are necessary for practical performance. Algorithms such as TWEAK [13], SNLP [78], UCPOP [88], and Graphplan [6] may all be viewed as special purpose theorem provers aimed at planning problems.
Reference: [40] <author> A. Haas. </author> <title> The case for domain-specific frame axioms. </title> <booktitle> In The Frame Problem in Artificial Intellegence, Proceedings of the 1987 Workshop. </booktitle> <publisher> Morgan Kaufmann, </publisher> <year> 1987. </year>
Reference-contexts: Therefore, if more than one action does occur in a time step, then either one can be selected to form a valid plan. Explanatory frame axioms <ref> [40] </ref> enumerate the set of actions that could have occurred in order to account for a state change.
Reference: [41] <author> R. M. Haralick and G. L. Elliott. </author> <title> Increasing tree search efficiency for constraint satisfaction problems. </title> <journal> J. Artificial Intelligence, </journal> <volume> 14 </volume> <pages> 263-313, </pages> <year> 1980. </year>
Reference-contexts: A better strategy, called forward checking <ref> [41] </ref>, checks unassigned variables in addition, shrinking their domain by eliminating any values that are inconsistent with the recent choice.
Reference: [42] <author> K. B. Irani and J. Cheng. </author> <title> Subgoal ordering and goal augmentation for heuristic problem solving. </title> <booktitle> In Proc. 10th Int. Joint Conf. AI, </booktitle> <pages> pages 1018-1024, </pages> <month> August </month> <year> 1987. </year>
Reference-contexts: Another method for determining a good subgoal ordering is through structural analysis of subgoal interactions <ref> [42, 14, 96] </ref>. Precomputation aimed at calculating speedy subgoal orderings is closely related to the use of abstraction in planning [59, 103, 114].
Reference: [43] <author> D. Joslin and M. Pollack. </author> <title> Least-cost flaw repair: A plan refinement strategy for partial-order planning. </title> <booktitle> In Proc. 12th Nat. Conf. AI, </booktitle> <month> July </month> <year> 1994. </year>
Reference-contexts: In general, a good heuristic is to select the variable with the fewest remaining (nonconflicting) values and this information is readily available if forward checking is employed. 5 While not astounding, these 5 Similar heuristics have been investigated in the context of causal-link planners; see <ref> [97, 43, 113, 101, 33, 90] </ref>. techniques lead to significant (e.g., 50%) performance improvements in Graphplan [49]. Another method for determining a good subgoal ordering is through structural analysis of subgoal interactions [42, 14, 96].
Reference: [44] <author> D. Joslin and M. Pollack. </author> <title> Is "early commitment" in plan generation ever a good idea? In Proc. </title> <booktitle> 13th Nat. Conf. AI, </booktitle> <pages> pages 1188-93, </pages> <year> 1996. </year> <month> 43 </month>
Reference-contexts: See MOLGEN [102] for seminal work on constraint-posting planning. TWEAK [13], SNLP [78], and UCPOP [88] manipulated explicit codesignation and ordering constraints. <ref> [44] </ref> describes a planner that represented all of its decisions as constraints. [48] provides a formal framework of planning that compares different planners in terms of the way they handle constraints. GEMPLAN [70] is a modern constraint-posting planner. 9 set of constraints are defined by the mutex relations.
Reference: [45] <author> R. Kambhampati, E. Lambrecht, and E. Parker. </author> <booktitle> Understanding and ex-tending graphplan. In Proc. 4th European Conference on Planning, </booktitle> <month> Sept </month> <year> 1997. </year>
Reference-contexts: Two optimizations have been proposed to make graph expansion more goal-directed: heuristically filtering facts from the initial state with a fact-generation graph [84] and backward expansion of the planning graph <ref> [45] </ref>. A fact-generation graph is an AND-OR-graph created from a problem goal and domain actions as follows. The root of the graph is an AND node corresponding to the goal and its children are the conjunctive subgoals. <p> Note that this approach is similar to (and motivated by) McDermott's greedy regression graph heuristic [81]. A similar approach, due to <ref> [45] </ref>, provides speedup without sacrificing completeness. Recall that Graphplan follows a simple loop: expand the planning graph with action and proposition levels, then attempt solution extraction, if no plan is found then repeat.
Reference: [46] <author> R. Kambhampati, A. Mali, and B. Srivastava. </author> <title> Hybrid planning for partially hierarchical domains. </title> <booktitle> In Proc. 15th Nat. Conf. AI, </booktitle> <pages> pages 882-888, </pages> <year> 1998. </year>
Reference-contexts: Recent results extend the theory to handle partially HTN domains <ref> [46] </ref>. McDermott showed that an emphasis on (automatically) computing an informative heuristic can make an otherwise simple planner extremely effective [81]. TLPLAN uses (user-provided) domain specific control information to offset a simple, forward-chaining search strategy | with impressive results [2].
Reference: [47] <author> S. Kambhampati. </author> <title> Challenges in bridging plan synthesis paradigms. </title> <booktitle> In Proc. 15th Int. Joint Conf. AI, </booktitle> <pages> pages 44-49, </pages> <year> 1997. </year>
Reference-contexts: One of the keys to BLACKBOX's performance is the observation that the simplification algorithm employed by Graphplan is more powerful than the unit propagation used in their previous SAT planning system <ref> [47, 55] </ref>.
Reference: [48] <author> S. Kambhampati. </author> <title> Refinement planning as a unifying framework for plan synthesis. </title> <journal> AI Magazine, </journal> <volume> 18(2) </volume> <pages> 67-97, </pages> <year> 1997. </year>
Reference-contexts: See MOLGEN [102] for seminal work on constraint-posting planning. TWEAK [13], SNLP [78], and UCPOP [88] manipulated explicit codesignation and ordering constraints. [44] describes a planner that represented all of its decisions as constraints. <ref> [48] </ref> provides a formal framework of planning that compares different planners in terms of the way they handle constraints. GEMPLAN [70] is a modern constraint-posting planner. 9 set of constraints are defined by the mutex relations. <p> generates control actions in real-time. 5 Discussion While, the focus of this paper has been on the dramatic explosion in SAT-planning and Graphplan-based algorithms, we close by briefly mentioning some other recent trends. 5.1 Planning as Search Refinement search forms an elegant framework for comparing different planning algorithms and representations <ref> [51, 48] </ref>. Recent results extend the theory to handle partially HTN domains [46]. McDermott showed that an emphasis on (automatically) computing an informative heuristic can make an otherwise simple planner extremely effective [81].
Reference: [49] <author> S. Kambhampati. </author> <title> Ebl and ddb for grapplan. </title> <institution> Department of Computer Science and Engineering TR-99-008, Arizona State University, </institution> <month> August </month> <year> 1998. </year>
Reference-contexts: the fewest remaining (nonconflicting) values and this information is readily available if forward checking is employed. 5 While not astounding, these 5 Similar heuristics have been investigated in the context of causal-link planners; see [97, 43, 113, 101, 33, 90]. techniques lead to significant (e.g., 50%) performance improvements in Graphplan <ref> [49] </ref>. Another method for determining a good subgoal ordering is through structural analysis of subgoal interactions [42, 14, 96]. Precomputation aimed at calculating speedy subgoal orderings is closely related to the use of abstraction in planning [59, 103, 114]. <p> As stated, this memoization process is rather simplistic, and since more sophisticated approaches have proven effective in systematic SAT solvers [5], one might suspect memoization improvements are possible. Indeed, recent work by Kambhampati <ref> [49] </ref> demonstrates dramatic speedups (e.g., between 1.6 and 120 times faster depending on domain). <p> This approach leads to much smaller (and hence more general) nogoods; for example, it might be the case that subgoals P , Q, and S are together unachievable, regardless of R. An additional idea (also described in <ref> [49] </ref>) is the regression of level k failure explanations through the action definitions for level k + 1 to calculate failure conditions for level k + 2. When these level-k + 2 conditions are short, then many searches can be terminated very quickly.
Reference: [50] <author> S. Kambhampati. </author> <title> On the relations between intelligent backtracking and failure-driven explanation based learning in constraint satisfaction and planning. </title> <institution> Department of Computer Science and Engineering TR-97-018, Arizona State University, </institution> <year> 1998. </year> <note> To appear in Artificial Intelligence. </note>
Reference-contexts: (?v ?s ?d) :precondition (and (vehicle ?v) (location ?s) (location ?d) (road-connected ?s ?d) (at ?v ?s)) :effect (and (not (at ?v ?s)) (at ?v ?d))) source location to a destination. based on Kambhampati's earlier work on the relationship between traditional planning-based speedup methods (e.g., explanation-based learning) and CSP methods <ref> [50] </ref>. 2.3.2 Closed World Assumption The closed world assumption says that any proposition not explicitly known to be true in the initial state can be presumed false.
Reference: [51] <author> S. Kambhampati, C. Knoblock, and Q. Yang. </author> <title> Planning as refinement search: A unified framework for evaluating design tradeoffs in partial order planning. </title> <journal> J. Artificial Intelligence, </journal> <volume> 76 </volume> <pages> 167-238, </pages> <year> 1995. </year>
Reference-contexts: generates control actions in real-time. 5 Discussion While, the focus of this paper has been on the dramatic explosion in SAT-planning and Graphplan-based algorithms, we close by briefly mentioning some other recent trends. 5.1 Planning as Search Refinement search forms an elegant framework for comparing different planning algorithms and representations <ref> [51, 48] </ref>. Recent results extend the theory to handle partially HTN domains [46]. McDermott showed that an emphasis on (automatically) computing an informative heuristic can make an otherwise simple planner extremely effective [81].
Reference: [52] <author> H. Kautz, D. McAllester, and B. Selman. </author> <title> Encoding plans in propositional logic. </title> <booktitle> In Proc. 5th Int. Conf. Principles of Knowledge Representation and Reasoning, </booktitle> <year> 1996. </year>
Reference-contexts: The resulting plan consists of a totally-ordered sequence of actions; indeed it corresponds roughly to a "linear" encoding in <ref> [52] </ref>, except that they include exclusion axioms (see below) to ensure that at most one action is active at a time. <p> In addition, MEDIC incorporates many switch-selectable optimizations such as type analysis; these features make MEDIC a powerful testbed for research in SAT-based planning. But there are several encodings which do not fit in our taxonomy and hence cannot be generated by MEDIC. The causal encoding <ref> [52] </ref> is based on the causal-link representation used by partial-order planners such as SNLP [78]. <p> For example, consider the dinner date proposition :garb at level 4 in figure 5; one obtains: :garb 4 ) (dolly 3 _ carry 3 _ maintain-no-garb 3 ) Kautz et al. <ref> [52] </ref> observe that this encoding is very close to the combination of explanatory frames with a regular action representation; there are two differences.
Reference: [53] <author> H. Kautz and B. Selman. </author> <title> Planning as satisfiability. </title> <booktitle> In Proc. 10th Eur. Conf. AI, </booktitle> <pages> pages 359-363, </pages> <address> Vienna, Austria, 1992. </address> <publisher> Wiley. </publisher>
Reference-contexts: However, recent improvements in the performance of propositional satisfia-bility methods [15] call this whole endeavor in doubt. Initial results for compiling bounded-length planning problems to SAT were unremarkable <ref> [53] </ref>, but recent experiments [54] suggest that compilation to SAT might yield the world's fastest STRIPS-style planner. e.g. MEDIC [22] or Blackbox [55].
Reference: [54] <author> H. Kautz and B. Selman. </author> <title> Pushing the envelope: Planning, propositional logic, and stochastic search. </title> <booktitle> In Proc. 13th Nat. Conf. AI, </booktitle> <pages> pages 1194-1201, </pages> <year> 1996. </year>
Reference-contexts: However, recent improvements in the performance of propositional satisfia-bility methods [15] call this whole endeavor in doubt. Initial results for compiling bounded-length planning problems to SAT were unremarkable [53], but recent experiments <ref> [54] </ref> suggest that compilation to SAT might yield the world's fastest STRIPS-style planner. e.g. MEDIC [22] or Blackbox [55]. <p> Since systematic solvers take worst-case time which is exponential in the number of variables, and large numbers of variables also slow stochastic solvers, one would like to reduce this number. In order to do this, <ref> [54] </ref> introduced simple action splitting, which replaces each n-ary action fluent with n unary fluents throughout the encoding. <p> For example, with simple splitting, it would be impossible to have two instantiations of the same action schema execute at the same time, because their split fluents would interfere. Overloaded splitting 17 Contrast our definition of conflict with that of Graphplan [6] and <ref> [54] </ref>. Unlike Kautz and Selman's parallel encoding, but like their linear one, our encodings have axioms stating that actions imply their effects; their parallel encoding prohibits effect-effect conflicts instead. 26 further disallows two instantiations of different actions to execute at the same time, so it requires complete exclusion. <p> The bitwise action representation requires no action exclusion axioms. At any time step, only one fully-instantiated action's index can be represented by the bit symbols, so a total ordering is guaranteed. What is the best way to represent frame axioms? Experience <ref> [54, 22] </ref> shows that explanatory frame axioms are clearly superior to classical frames in almost every case. <p> Indeed, Kautz and Selman <ref> [54] </ref> showed that the planning graph can be automatically converted into CNF notation for solution with SAT solvers, by con structing propositional formulae stating: 27 1. The (fully specified) initial state holds at level zero and the goal holds at the highest level (i.e., our init and goal axioms). 2. <p> No attempt is made to deduce optimality heuristics or simplifying assumptions | all constraints are completeness preserving. Never the less, the CNF formulae with DISCOPLAN-inferred axioms were solved many times faster than plain MEDIC or SATPLAN <ref> [54] </ref> formulae, regardless of SAT solver used. Indeed, in many cases the plain encodings were unsolvable in the alloted time, while the DISCOPLAN-augmented encodings quickly yielded a plan. Other researchers have devised alternative methods for detecting constraints.
Reference: [55] <author> H. Kautz and B. Selman. </author> <title> Blackbox: A new approach to the application of theorem proving to problem solving. </title> <booktitle> In AIPS98 Workshop on Planning as Combinatorial Search, </booktitle> <pages> pages 58-60, </pages> <month> June </month> <year> 1998. </year>
Reference-contexts: The current level of performance is quite impressive with several planners quickly solving problems which are orders of magnitude harder than the testpieces of only two years ago. As a single, representative example, the BLACKBOX planner <ref> [55] </ref> requires only six minutes to find a 105-action logistics plan in a world with 10 16 possible states. Furthermore, work on propositional planning is closely related to the algorithms used in the autonomous controller for NASA's Deep Space One spacecraft, scheduled to be launched in late 1998. <p> Download from www.dur.ac.uk/~dcs0www/research/stanstuff/stanpage.html. - SGP [109] is a simple, pedagogical Lisp implementation of Graph-plan, extended to handle universal quantification, conditional effects, and uncertainty; see www.cs.washington.edu/research/projects/ai/www/sgp.html. * Systems based on compilation to SAT: The highest performance SAT compiler is Blackbox <ref> [55] </ref> available www.research.att.com/~kautz/blackbox/index.html. <p> In other words, our previous description of solution extraction dictated finding a consistent set of actions at level i before performing any search at level i 2. However, this methodical order is unnecessary and potentially inefficient. For example, the BLACKBOX planner <ref> [55] </ref> takes the planning graph, compiles it to SAT, and uses fast stochastic methods to perform the equivalent of solution extraction in which search jumps around from level to level in a greedy fashion. Rintanen [91] describes an opportunistic, non-directional search strategy which bypasses conversion to SAT. <p> Initial results for compiling bounded-length planning problems to SAT were unremarkable [53], but recent experiments [54] suggest that compilation to SAT might yield the world's fastest STRIPS-style planner. e.g. MEDIC [22] or Blackbox <ref> [55] </ref>. The compiler takes a planning problem as input, guesses a plan length, and generates a propositional logic formula, which if satisfied, implies the existence of a solution plan; a symbol table records the correspondence between propositional variables and the planning instance. <p> Second, there are no axioms stating that actions imply their effects, so spurious actions may be included in the solution (these can be removed later by the decoder). Fortunately, the conflict exclusion axioms prevent these spurious actions from interfering with the rest of the plan. The BLACKBOX system <ref> [55] </ref> uses this Graphplan-based encoding to provide a very fast planner. BLACKBOX uses the graph expansion phase of IPP [64] to create the planning graph, then converts the graph into CNF rather than performing traditional solution extraction. <p> One of the keys to BLACKBOX's performance is the observation that the simplification algorithm employed by Graphplan is more powerful than the unit propagation used in their previous SAT planning system <ref> [47, 55] </ref>.
Reference: [56] <author> H. Kautz and B. Selman. </author> <title> The role of domain-specific knowledge in the planning as satisfiability framework. </title> <booktitle> In Proc. 4th Intl. Conf. AI Planning Systems, </booktitle> <month> June </month> <year> 1998. </year>
Reference-contexts: Domain axioms may be classified in terms of the logical relationship between the knowledge encoded and the original problem statement <ref> [56] </ref>: * Action conflicts and derived effects are entailed solely by the preconditions and effects of the domain's action schemata. * Heuristics which are entailed by the initial state in conjunction with the domain's action schemata include state invariants.
Reference: [57] <author> Kelleher and Cohen. </author> <title> Automatically synthesizing domain constraints from operator descriptions. </title> <booktitle> In Proc. 10th Eur. Conf. AI, </booktitle> <address> Vienna, Austria, 1992. </address> <publisher> Wiley. </publisher> <pages> 44 </pages>
Reference-contexts: For example, [2] describes a method similar to DISCOPLAN which, in addition, uses regression search to further restrict the predicate domains. Rinta-nen modified algorithms from computer-aided verification to discover binary 29 invariants [91]. Earlier work on the subject is presented in <ref> [57] </ref>. Despite these promising first-efforts, much more exciting work remains to done in the area of optimizing SAT encodings for speedy solution. 3.3 SAT Solvers Without an efficient solver, a planning-to-SAT compiler is useless; in this section we review the state of the art.
Reference: [58] <author> C. Knoblock. </author> <title> Learning abstraction hierarchies for problem solving. </title> <booktitle> In Proc. 8th Nat. Conf. AI, </booktitle> <pages> pages 923-928, </pages> <month> August </month> <year> 1990. </year>
Reference-contexts: Hector 24 It is interesting to compare this work with similar research on subgoal ordering discussed earlier in the section on Solution Extraction as Constraint Satisfaction. Problem-space graphs [25] and operator graphs [97, 98] share many resemblances to causal graphs. Knoblock's ALPINE abstraction system <ref> [58] </ref> can be viewed as finding a serialization ordering, and it can eliminate most search when given a problem with acyclic structure such as the towers of Hanoi [60]. 25 The causal graph is constructed o*ine from a compiled version of the domain theory which eliminates all reference to dependent variables.
Reference: [59] <author> C. Knoblock. </author> <title> Automatically Generating Abstractions for Problem Solving. </title> <type> PhD thesis, </type> <institution> Carnegie Mellon University, </institution> <year> 1991. </year> <note> Available as technical report CMU-CS-91-120. </note>
Reference-contexts: Another method for determining a good subgoal ordering is through structural analysis of subgoal interactions [42, 14, 96]. Precomputation aimed at calculating speedy subgoal orderings is closely related to the use of abstraction in planning <ref> [59, 103, 114] </ref>. In general, one can distinguish between domain-specific approaches (which are based on action definitions alone) and problem-specific approaches (which additionally use the goal and initial state specifications); problem-specific approaches typically provide more leverage, but the cost of domain-specific precomputation can be amortized amongst many planning problems.
Reference: [60] <author> C. Knoblock. </author> <title> An analysis of ABSTRIPS. </title> <booktitle> In Proc. 1st Intl. Conf. AI Planning Systems, </booktitle> <month> June </month> <year> 1992. </year>
Reference-contexts: Problem-space graphs [25] and operator graphs [97, 98] share many resemblances to causal graphs. Knoblock's ALPINE abstraction system [58] can be viewed as finding a serialization ordering, and it can eliminate most search when given a problem with acyclic structure such as the towers of Hanoi <ref> [60] </ref>. 25 The causal graph is constructed o*ine from a compiled version of the domain theory which eliminates all reference to dependent variables. 38 Geffner demonstrated impressive performance on planning competition prob-lems using heuristic search through the space of world-states. 5.2 Causal Link Planning Causal link planners, e.g.
Reference: [61] <author> C. Knoblock. </author> <title> Planning, executing, </title> <booktitle> sensing, and replanning for information gathering. In Proc. 14th Int. Joint Conf. AI, </booktitle> <pages> pages 1686-1693, </pages> <year> 1995. </year>
Reference: [62] <author> J. Koehler. </author> <title> Planning under resource constraints. </title> <booktitle> In Proc. 15th Eur. Conf. AI, </booktitle> <year> 1998. </year>
Reference-contexts: Since this representation is severely limited, this section discusses extensions to more expressive representations aimed at complex, real-world domains. We focus on disjunctive preconditions, conditional effects, and universally-quantified preconditions and effects because these areas have received the most attention. Koehler has developed methods for handling resource constraints <ref> [62] </ref>, and we discuss work on uncertainty at the end of this paper (after describing methods for compiling planning problems to SAT).
Reference: [63] <author> J. Koehler. </author> <title> Solving complex planning tasks through extraction of sub-problems. </title> <booktitle> In Proc. 4th Intl. Conf. AI Planning Systems, </booktitle> <address> Pittsburgh, PA, </address> <month> June </month> <year> 1998. </year>
Reference-contexts: In general, one can distinguish between domain-specific approaches (which are based on action definitions alone) and problem-specific approaches (which additionally use the goal and initial state specifications); problem-specific approaches typically provide more leverage, but the cost of domain-specific precomputation can be amortized amongst many planning problems. Koehler <ref> [63] </ref> describes a problem-specific method which speeds Graphplan by orders of magnitude on problems from many domains. 6 * The original Graphplan paper [6] describes a technique called memoization which caches for future use the results learned from exhaustive search about inconsistent subgoal sets.
Reference: [64] <author> J. Koehler, B. Nebel, J. Hoffmann, and Y Dimopoulos. </author> <title> Extending planning graphs to an adl subset. </title> <booktitle> In Proc. 4th European Conference on Planning, </booktitle> <pages> pages 273-285, </pages> <month> Sept </month> <year> 1997. </year>
Reference-contexts: and influential planner built in the 1970s to control an unstable mobile robot affec tionately known as "Shakey" [28]. 2 See ftp://ftp.cs.yale.edu/pub/mcdermott/software/pddl.tar.gz for the PDDL specification. 3 See ftp.cs.yale.edu/pub/mcdermott/aipscomp-results.html for competition results. 2 - Graphplan | the original, somewhat dated, C implementation [6] is still available from www.cs.cmu.edu/afs/cs.cmu.edu/user/avrim/www/graphplan.html. - IPP <ref> [64] </ref> is a highly optimized C implementation of Graphplan, extended to handle expressive actions (e.g., universal quantification and conditional effects); download from www.informatik.uni-freiburg.de/~koehler. - STAN is another highly-optimized C implementation which uses an in-place graph representation and performs sophisticated type analy sis to compute invariants. <p> ?s ?d)) :effect (and (at ?v ?d) (not (at ?v ?s)) (when (in cargo ?v) (and (at cargo ?v)) (not (at cargo ?s))) (when (in spare-tire ?v) (and (at spare-tire ?d)) (not (at spare-tire ?s))))) vehicle is empty or contains cargo and/or a spare tire. expansion [1], and partially factored <ref> [64] </ref>. The simplest approach, full expansion, rewrites an action schema containing conditional effects into a number of mutually exclusive STRIPS schemata by considering all minimal consistent combinations of antecedents in the conditional effects. <p> (drive) :parameters (?v ?s ?d) :precondition (and (vehicle ?v) (at ?v ?s) (location ?s) (location ?d) (road-connected ?s ?d)) :effect (and (at ?v ?d) (not (at ?v ?s)) (forall (object ?o) (when (in ?o ?v) (and (at ?o ?v)) (not (at ?o ?s)))))) 2.4.3 Universal Quantification The Graphplan descendants IPP <ref> [64] </ref> and SGP [1] each allow action schemata with universal quantification. In preconditions, universal quantification lets one conveniently describe real world actions like the UNIX rmdir command which deletes a directory only if all files inside it have already been deleted. <p> Fortunately, the conflict exclusion axioms prevent these spurious actions from interfering with the rest of the plan. The BLACKBOX system [55] uses this Graphplan-based encoding to provide a very fast planner. BLACKBOX uses the graph expansion phase of IPP <ref> [64] </ref> to create the planning graph, then converts the graph into CNF rather than performing traditional solution extraction. <p> The principles and objectives underlying type analysis for SAT-compilation are the same as previously discussed in the context of Graphplan. Graphplan-based approaches (e.g., inertia optimization <ref> [64] </ref> and TIM [29]) aimed to shrink the size of the planning graph by eliminating static fluents and by avoiding nonsensical action-schemata instantiations. The same approaches can be used to shrink the size of the CNF formula that a SAT-compiler generates.
Reference: [65] <author> J. Koehler, B. Nebel, J. Hoffmann, and Y. Dimopoulos. </author> <title> Extending planning graphs to an ADL subset. </title> <type> TR 88, </type> <institution> Institute for Computer Science, University of Freiburg, </institution> <year> 1997. </year> <note> See http://www.informatik.uni-freiburg.de/~ koehler/ipp.html. </note>
Reference-contexts: The IPP planner <ref> [65] </ref> uses a third method for handling conditional effects which we call partially factored expansion. The primary difference stems from IPP's mutex rules which state that two actions are marked as mutex only if their unconditional effects and preconditions are in conflict.
Reference: [66] <author> G. Kondrack and van Beek. P. </author> <title> A theoretical evaluation of selected backtracking algorithms. </title> <journal> J. Artificial Intelligence, </journal> <volume> 89 </volume> <pages> 365-387, </pages> <year> 1997. </year>
Reference-contexts: A better strategy, called forward checking [41], checks unassigned variables in addition, shrinking their domain by eliminating any values that are inconsistent with the recent choice. If the domain of any unassigned variable collapses (i.e., it shrinks to the empty set), then the CSP solver should backtrack. <ref> [66] </ref> shows analytically that forward checking is an excellent strategy, strengthening previous empirical support. * Dynamic variable ordering refers to a class of heuristics for choosing which CSP variable should next be assigned a value [3].
Reference: [67] <author> R. Korf. </author> <title> Planning as search: A quantitative approach. </title> <journal> J. Artificial Intelligence, </journal> <volume> 33(1) </volume> <pages> 65-88, </pages> <month> September </month> <year> 1987. </year>
Reference-contexts: Of course, eventually all variables must have values assigned but the order in which they are selected can have a huge impact on efficiency <ref> [67, 4] </ref>. Note that if a variable has only one choice, then it is clearly best to make that assignment immediately. <p> Williams and Nayak formalize this intuition with a set of crisp constraints that are satisfied by the spacecraft domain. The most important of these restrictions is the presence of a serialization ordering for any (satisfiable) set of goals. As previous theoretical work has shown <ref> [67, 4] </ref>, serialized subgoals can be solved extremely quickly, because no backtracking is necessary between subgoals. To give an intuitive blocksworld example, the set of goals 1. Have block C on the table. 2. Have block B on block C. 3.
Reference: [68] <author> N. Kushmerick, S. Hanks, and D. Weld. </author> <title> An Algorithm for Probabilistic Least-Commitment Planning. </title> <booktitle> In Proc. 12th Nat. Conf. AI, </booktitle> <year> 1994. </year>
Reference-contexts: Causal-link planners such as XII [37] and PUCCINI [36], on the other hand, work competently. 5.3 Handling Uncertainty Starting with work on the CNLP [89], SENSp [26], Buridan <ref> [68, 69] </ref> and C-Buridan [21] systems, the AI planning community has more seriously considered extensions to action languages that allow the specification of uncertain effects and incomplete information. Of course, much related work has been performed by the UAI community, but usually with different assumptions.
Reference: [69] <author> N. Kushmerick, S. Hanks, and D. Weld. </author> <title> An Algorithm for Probabilistic Planning. </title> <journal> J. Artificial Intelligence, </journal> <volume> 76 </volume> <pages> 239-286, </pages> <year> 1995. </year>
Reference-contexts: Causal-link planners such as XII [37] and PUCCINI [36], on the other hand, work competently. 5.3 Handling Uncertainty Starting with work on the CNLP [89], SENSp [26], Buridan <ref> [68, 69] </ref> and C-Buridan [21] systems, the AI planning community has more seriously considered extensions to action languages that allow the specification of uncertain effects and incomplete information. Of course, much related work has been performed by the UAI community, but usually with different assumptions.
Reference: [70] <author> A. L. Lansky. </author> <title> Localized planning with action-based constraints. </title> <journal> J. Artificial Intelligence, </journal> <volume> 98(1-2):49-136, </volume> <year> 1998. </year>
Reference-contexts: TWEAK [13], SNLP [78], and UCPOP [88] manipulated explicit codesignation and ordering constraints. [44] describes a planner that represented all of its decisions as constraints. [48] provides a formal framework of planning that compares different planners in terms of the way they handle constraints. GEMPLAN <ref> [70] </ref> is a modern constraint-posting planner. 9 set of constraints are defined by the mutex relations. For example, consider the process of solution extraction from the level four dinner date graph shown in figure 5.
Reference: [71] <author> C. Li and Anbulagan. </author> <title> Heuristics based on unit propagation for satisfia-bility problems. </title> <booktitle> In Proc. 15th Int. Joint Conf. AI, </booktitle> <month> August </month> <year> 1997. </year>
Reference-contexts: Tableau [16] and Satz <ref> [71] </ref> are tight implementations of DPLL with careful attention to datastructures and indexing. Many additional heuristics have been proposed to guide the choice of a splitting variable in preparation for the divide and conquer recursive call. <p> Many additional heuristics have been proposed to guide the choice of a splitting variable in preparation for the divide and conquer recursive call. For example, Satz selects variables by considering how much unit propagation is facilitated if it branches on that variable <ref> [71] </ref>. See [15] for a discussion of other heuristics. 30 Procedure DPLL (CNF formula: OE) If OE is empty, return yes. Else if there is an empty clause in OE return no.
Reference: [72] <author> M. Littman. </author> <title> Probabilistic propositional planning: Representations and complexity. </title> <booktitle> In Proc. 14th Nat. Conf. AI, </booktitle> <pages> pages 748-754, </pages> <year> 1997. </year> <month> 45 </month>
Reference-contexts: However, recent work on MDP abstraction and aggregation [11, 19] calls this intuition into question. In order for the field to advance, more work needs to be done comparing these approaches and testing their relative strengths and limitations. Initial results in this area are a start <ref> [10, 72] </ref>, but empirical comparisons are badly needed. Several researchers have extended Graphplan to handle uncertainty. <p> a Boolean formula with choice variables (variables whose truth status can be arbitrarily set) and chance variables (variables whose truth status is determined by a set of independent probabilities), find the setting of the choice variables that maximizes the probability of a satisfying assignment with respect to the chance variables. <ref> [72] </ref> [73] describes a planning compiler based on this idea, and presents a E-MAJSAT solver akin to DPLL. Caching expensive probability calculations leads to impressive efficiency gains [74]. 5.4 Conclusions In the past few years, the state of the art in AI planning systems has advanced with extraordinary speed.
Reference: [73] <author> S. M. Majercik and M. L. Littman. MAXPLAN: </author> <title> a new approach to probabilistic planning. </title> <booktitle> In Proc. 4th Intl. Conf. AI Planning Systems, </booktitle> <pages> pages 86-93, </pages> <month> June </month> <year> 1998. </year>
Reference-contexts: Boolean formula with choice variables (variables whose truth status can be arbitrarily set) and chance variables (variables whose truth status is determined by a set of independent probabilities), find the setting of the choice variables that maximizes the probability of a satisfying assignment with respect to the chance variables. [72] <ref> [73] </ref> describes a planning compiler based on this idea, and presents a E-MAJSAT solver akin to DPLL. Caching expensive probability calculations leads to impressive efficiency gains [74]. 5.4 Conclusions In the past few years, the state of the art in AI planning systems has advanced with extraordinary speed.
Reference: [74] <author> S. M. Majercik and M. L. Littman. </author> <title> Using caching to solve larger probabilistic planning problems. </title> <booktitle> In Proc. 15th Nat. Conf. AI, </booktitle> <pages> pages 954-960, </pages> <month> July </month> <year> 1998. </year>
Reference-contexts: Caching expensive probability calculations leads to impressive efficiency gains <ref> [74] </ref>. 5.4 Conclusions In the past few years, the state of the art in AI planning systems has advanced with extraordinary speed. Graphplan and SAT-based planning systems can quickly solve problems that are orders of magnitude harder than those tackled by the best previous planners.
Reference: [75] <author> A. D. Mali and S. Kambhampati. </author> <title> Encoding HTN planning in propositional logic. </title> <booktitle> In Proc. 4th Intl. Conf. AI Planning Systems, </booktitle> <month> June </month> <year> 1998. </year>
Reference-contexts: Work has also been done exploring ways of encoding hierarchical task network (HTN) planning [23] as a SAT problem <ref> [75] </ref>. 3.1.4 Comparison with Graphplan Note the strong similarities between Graphplan-derivative and SAT-based planning systems. * Both approaches convert parameterized action schemata into a finite propo sitional structure (e.g., the planning graph and a CNF formula) represent ing the space of possible plans up to a given length. * Both approaches
Reference: [76] <author> D. McAllester. </author> <title> An outlook on truth maintenance. </title> <type> Ai memo 551, </type> <institution> MIT AI LAB, </institution> <year> 1980. </year>
Reference-contexts: reach their potential, automated tuning methods (which don't require solving complete problem instances!) must be developed; [79] reports on work in this direction. 3.3.3 Incremental SAT Solving The problem of propositional satisfiability is closely related to that of truth maintenance [20, 77, 18]; we focus on LTMS-style truth maintenance systems <ref> [76] </ref>. Both problems concern a CNF formula represented as a set of clauses over a set of propositional variables V. A SAT solver seeks to find a truth assignment (i.e., a function from V to ftrue; falseg) that makes true.
Reference: [77] <author> D. McAllester. </author> <title> Truth maintenance. </title> <booktitle> In Proc. 8th Nat. Conf. AI, </booktitle> <pages> pages 1109-1116, </pages> <year> 1990. </year>
Reference-contexts: For stochastic methods to reach their potential, automated tuning methods (which don't require solving complete problem instances!) must be developed; [79] reports on work in this direction. 3.3.3 Incremental SAT Solving The problem of propositional satisfiability is closely related to that of truth maintenance <ref> [20, 77, 18] </ref>; we focus on LTMS-style truth maintenance systems [76]. Both problems concern a CNF formula represented as a set of clauses over a set of propositional variables V. A SAT solver seeks to find a truth assignment (i.e., a function from V to ftrue; falseg) that makes true.
Reference: [78] <author> D. McAllester and D. Rosenblitt. </author> <title> Systematic nonlinear planning. </title> <booktitle> In Proc. 9th Nat. Conf. AI, </booktitle> <pages> pages 634-639, </pages> <month> July </month> <year> 1991. </year>
Reference-contexts: & Descendants Blum and Furst's Graphplan algorithm [6, 7] is one of the most exciting recent developments in AI planning for two reasons: * Graphplan is a simple, elegant algorithm that yields an extremely speedy planner | in many cases orders of magnitude faster than previous systems such as SNLP <ref> [78] </ref>, Prodigy [82], or UCPOP [88]. * The representations used by Graphplan form the basis of the most successful encodings of planning problems into propositional SAT; hence familiarity with Graphplan aids in understanding SAT-based plannning systems (section 3). Graphplan alternates between two phases: graph expansion and solution extraction. <p> See MOLGEN [102] for seminal work on constraint-posting planning. TWEAK [13], SNLP <ref> [78] </ref>, and UCPOP [88] manipulated explicit codesignation and ordering constraints. [44] describes a planner that represented all of its decisions as constraints. [48] provides a formal framework of planning that compares different planners in terms of the way they handle constraints. <p> Algorithms such as TWEAK [13], SNLP <ref> [78] </ref>, UCPOP [88], and Graphplan [6] may all be viewed as special purpose theorem provers aimed at planning problems. However, recent improvements in the performance of propositional satisfia-bility methods [15] call this whole endeavor in doubt. <p> But there are several encodings which do not fit in our taxonomy and hence cannot be generated by MEDIC. The causal encoding [52] is based on the causal-link representation used by partial-order planners such as SNLP <ref> [78] </ref>. While this encoding has been shown to have the smallest encoding when measured asymptotically, the constant factors are large, and despite several efforts no one has succeeded in building a practical compiler based on the idea. <p> SNLP <ref> [78] </ref> and UCPOP [88], have received less attention in recent years because they are outperformed by Graphplan and SAT-PLAN in most domains. However, some of the intuitions underlying these planners have been adopted by the propositional approaches.
Reference: [79] <author> David McAllester, Bart Selman, and Henry Kautz. </author> <title> Evidence for invariants in local search. </title> <booktitle> In Proc. 14th Nat. Conf. AI, </booktitle> <pages> pages 321-326, </pages> <address> Providence, Rhode Island, </address> <month> July </month> <year> 1997. </year>
Reference-contexts: On each flip, WALKSAT does one of two things; with probability p it chooses the same variable GSAT would have chosen, otherwise it selects a random variable from an unsatisfied clause. Many variants on these algorithms have been constructed and compared, e.g. <ref> [32, 79] </ref>. An especially promising new method, reported in [38], exploits the fact that the time required by the DPLL procedure is highly dependent on the choice of 18 Download from http://www.informatik.tu-darmstadt.de/AI/SATLIB. 32 splitting variable, producing a heavy-tailed distribution of running times (fig-ure 15). <p> For stochastic methods to reach their potential, automated tuning methods (which don't require solving complete problem instances!) must be developed; <ref> [79] </ref> reports on work in this direction. 3.3.3 Incremental SAT Solving The problem of propositional satisfiability is closely related to that of truth maintenance [20, 77, 18]; we focus on LTMS-style truth maintenance systems [76].
Reference: [80] <author> J. McCarthy and P. J. Hayes. </author> <title> Some philosophical problems from the standpoint of artificial intelligence. </title> <booktitle> In Machine Intelligence 4, </booktitle> <pages> pages 463-502. </pages> <publisher> Edinburgh University Press, </publisher> <year> 1969. </year>
Reference-contexts: example, although the bitwise encoding yields the smallest number of propositional variables before simplification, the linear-time procedure described in [105] shrunk the CNF formulae from the other representations so much that afterwards bit wise had the most variables. 3.1.2 Frame Axioms Every encoding requires axioms to confront the frame problem <ref> [80] </ref>. frame Frame axioms constrain unaffected fluents when an action occurs. There are two alternatives: classical or explanatory frames. Classical frame axioms [80] state which fluents are left unchanged by a given action. <p> CNF formulae from the other representations so much that afterwards bit wise had the most variables. 3.1.2 Frame Axioms Every encoding requires axioms to confront the frame problem <ref> [80] </ref>. frame Frame axioms constrain unaffected fluents when an action occurs. There are two alternatives: classical or explanatory frames. Classical frame axioms [80] state which fluents are left unchanged by a given action.
Reference: [81] <author> D. McDermott. </author> <title> A heuristic estimator for means-ends analysis in planning. </title> <booktitle> In Proc. 3rd Intl. Conf. AI Planning Systems, </booktitle> <pages> pages 142-149, </pages> <month> May </month> <year> 1996. </year>
Reference-contexts: At the risk of incompleteness, one may try to speed planning by eliminating initial conditions (or ground actions) that don't appear (or appear infrequently) in the fact-generation graph [84]. Note that this approach is similar to (and motivated by) McDermott's greedy regression graph heuristic <ref> [81] </ref>. A similar approach, due to [45], provides speedup without sacrificing completeness. Recall that Graphplan follows a simple loop: expand the planning graph with action and proposition levels, then attempt solution extraction, if no plan is found then repeat. <p> Recent results extend the theory to handle partially HTN domains [46]. McDermott showed that an emphasis on (automatically) computing an informative heuristic can make an otherwise simple planner extremely effective <ref> [81] </ref>. TLPLAN uses (user-provided) domain specific control information to offset a simple, forward-chaining search strategy | with impressive results [2]. Hector 24 It is interesting to compare this work with similar research on subgoal ordering discussed earlier in the section on Solution Extraction as Constraint Satisfaction.
Reference: [82] <author> Steven Minton, Jaime G. Carbonell, Craig A. Knoblock, Daniel R. Kuokka, Oren Etzioni, and Yolanda Gil. </author> <title> Explanation-based learning: A problem-solving perspective. </title> <journal> J. Artificial Intelligence, </journal> <volume> 40(1-3):63-118, </volume> <year> 1989. </year>
Reference-contexts: Blum and Furst's Graphplan algorithm [6, 7] is one of the most exciting recent developments in AI planning for two reasons: * Graphplan is a simple, elegant algorithm that yields an extremely speedy planner | in many cases orders of magnitude faster than previous systems such as SNLP [78], Prodigy <ref> [82] </ref>, or UCPOP [88]. * The representations used by Graphplan form the basis of the most successful encodings of planning problems into propositional SAT; hence familiarity with Graphplan aids in understanding SAT-based plannning systems (section 3). Graphplan alternates between two phases: graph expansion and solution extraction.
Reference: [83] <author> P. Nayak and B. Williams. </author> <title> Fast context switching in real-time propositional reasoning. </title> <booktitle> In Proc. 14th Nat. Conf. AI, </booktitle> <address> Providence, R.I., </address> <month> July </month> <year> 1997. </year>
Reference-contexts: If a new clause is added to it may enable additional inference, and dependency records allow the LTMS to retract inferences that depended on clauses later removed from . Nayak and Williams <ref> [83] </ref> describe an especially efficient method for maintaining this mapping (which they call an ITMS), and the resulting algorithm is a powerful foundation for building real-time planning and execution systems, as we describe below. 4 Interleaved Planning & Execution Monitoring One of the most exciting recent developments is a partially SAT-based
Reference: [84] <author> B. Nebel, Y. Dimopoulos, and J. Koehler. </author> <title> Ignoring irrelevant facts and operators in plan generation. </title> <booktitle> In Proc. 4th European Conference on Planning, </booktitle> <month> Sept </month> <year> 1997. </year>
Reference-contexts: Two optimizations have been proposed to make graph expansion more goal-directed: heuristically filtering facts from the initial state with a fact-generation graph <ref> [84] </ref> and backward expansion of the planning graph [45]. A fact-generation graph is an AND-OR-graph created from a problem goal and domain actions as follows. The root of the graph is an AND node corresponding to the goal and its children are the conjunctive subgoals. <p> At the risk of incompleteness, one may try to speed planning by eliminating initial conditions (or ground actions) that don't appear (or appear infrequently) in the fact-generation graph <ref> [84] </ref>. Note that this approach is similar to (and motivated by) McDermott's greedy regression graph heuristic [81]. A similar approach, due to [45], provides speedup without sacrificing completeness.
Reference: [85] <author> F. Okushi. </author> <title> Parallel cooperative propositional theorem proving. </title> <note> (Submitted for publication; preliminary version presented at the Fifth International Symposium on Artificial Intelligence and Mathematics: http://rutcor.rutgers.edu/~amai), 1998. 46 </note>
Reference-contexts: This insight suggests a small change to DPLL: restrict the choice of splitting variables to action variables. Interestingly, the result of this restriction is dramatic: up to four orders of magnitude speedup [35]. The MODOC solver <ref> [104, 85] </ref> also uses the high-level structure of the planning problem to speed the SAT solver, but MODOC uses knowledge of which propositions correspond to goals (rather than to actions) to guide its search; the resulting solver is competitive with Walksat (described below). 31 Time to find a satisfying assignmentfl P
Reference: [86] <author> E. Pednault. </author> <title> ADL: Exploring the middle ground between STRIPS and the situation calculus. </title> <booktitle> In Proc. 1st Int. Conf. Principles of Knowledge Representation and Reasoning, </booktitle> <pages> pages 324-332, </pages> <year> 1989. </year>
Reference-contexts: and a consequent; execution of the action will have the consequent's effect just in the case that the antecedent is true immediately before execution (i.e., much like the action's precondition determines if execution itself is legal | for this reason the antecedent is sometimes referred to as a secondary precondition <ref> [86] </ref>). Note also that, like an action precondition, the antecedent part refers to the world before the action is executed while the consequent refers to the world after execution.
Reference: [87] <author> B. Pell, D. Bernard, S. Chien, E. Gat, N. Muscettola, P. Nayak, M. Wag-ner, and B. Williams. </author> <title> An autonomous spacecraft agent prototype. </title> <booktitle> In Proc. First Intl. Conf. Autonomous Agents, </booktitle> <pages> pages 253-261, </pages> <year> 1997. </year>
Reference-contexts: Pyro values may be opened (or closed) only once. spacecraft which is to be launched in autumn 1998. As one would expect given the magnitude of the task, the complete agent is quite complex <ref> [87] </ref>; we focus on the configuration planning and execution subsystem [110, 111] which are best explained with an example. Figure 16 shows a simplified schematic for the main engines of a spacecraft.
Reference: [88] <author> J.S. Penberthy and D. Weld. UCPOP: </author> <title> A sound, complete, partial order planner for ADL. </title> <booktitle> In Proc. 3rd Int. Conf. Principles of Knowledge Representation and Reasoning, </booktitle> <pages> pages 103-114, </pages> <month> October </month> <year> 1992. </year> <note> See also http: //www.cs.washington.edu/research/projects/ai/www/ucpop.html. </note>
Reference-contexts: Graphplan algorithm [6, 7] is one of the most exciting recent developments in AI planning for two reasons: * Graphplan is a simple, elegant algorithm that yields an extremely speedy planner | in many cases orders of magnitude faster than previous systems such as SNLP [78], Prodigy [82], or UCPOP <ref> [88] </ref>. * The representations used by Graphplan form the basis of the most successful encodings of planning problems into propositional SAT; hence familiarity with Graphplan aids in understanding SAT-based plannning systems (section 3). Graphplan alternates between two phases: graph expansion and solution extraction. <p> See MOLGEN [102] for seminal work on constraint-posting planning. TWEAK [13], SNLP [78], and UCPOP <ref> [88] </ref> manipulated explicit codesignation and ordering constraints. [44] describes a planner that represented all of its decisions as constraints. [48] provides a formal framework of planning that compares different planners in terms of the way they handle constraints. <p> extension stems from the case when one conditional effect is induced by another | i.e., when it is impossible to execute one effect without causing the other to happen as well [1]. * Factored expansion also complicates the solution extraction, because of the need to perform the analog of confrontation <ref> [88, 107] </ref>, i.e., prevent the antecedent of undesirable effects from occuring. The IPP planner [65] uses a third method for handling conditional effects which we call partially factored expansion. <p> Algorithms such as TWEAK [13], SNLP [78], UCPOP <ref> [88] </ref>, and Graphplan [6] may all be viewed as special purpose theorem provers aimed at planning problems. However, recent improvements in the performance of propositional satisfia-bility methods [15] call this whole endeavor in doubt. <p> SNLP [78] and UCPOP <ref> [88] </ref>, have received less attention in recent years because they are outperformed by Graphplan and SAT-PLAN in most domains. However, some of the intuitions underlying these planners have been adopted by the propositional approaches.
Reference: [89] <author> M. Peot and D. Smith. </author> <title> Conditional Nonlinear Planning. </title> <booktitle> In Proc. 1st Intl. Conf. AI Planning Systems, </booktitle> <pages> pages 189-197, </pages> <month> June </month> <year> 1992. </year>
Reference-contexts: When an agent is faced with incomplete information, it can not construct the Herbrand base and hence is unable to use propositional planning methods. Causal-link planners such as XII [37] and PUCCINI [36], on the other hand, work competently. 5.3 Handling Uncertainty Starting with work on the CNLP <ref> [89] </ref>, SENSp [26], Buridan [68, 69] and C-Buridan [21] systems, the AI planning community has more seriously considered extensions to action languages that allow the specification of uncertain effects and incomplete information. Of course, much related work has been performed by the UAI community, but usually with different assumptions.
Reference: [90] <author> M. E. Pollack, D. Joslin, and M. Paolucci. </author> <title> Flaw selection strategies for partial-order planning. </title> <journal> J. Artificial Intelligence Research, </journal> <volume> 6 </volume> <pages> 223-262, </pages> <year> 1997. </year>
Reference-contexts: In general, a good heuristic is to select the variable with the fewest remaining (nonconflicting) values and this information is readily available if forward checking is employed. 5 While not astounding, these 5 Similar heuristics have been investigated in the context of causal-link planners; see <ref> [97, 43, 113, 101, 33, 90] </ref>. techniques lead to significant (e.g., 50%) performance improvements in Graphplan [49]. Another method for determining a good subgoal ordering is through structural analysis of subgoal interactions [42, 14, 96].
Reference: [91] <author> J. T. Rintanen. </author> <title> A planning algorithm not based on directional search. </title> <booktitle> In Proc. 6th Int. Conf. Principles of Knowledge Representation and Reasoning, </booktitle> <month> June </month> <year> 1998. </year>
Reference-contexts: However, this methodical order is unnecessary and potentially inefficient. For example, the BLACKBOX planner [55] takes the planning graph, compiles it to SAT, and uses fast stochastic methods to perform the equivalent of solution extraction in which search jumps around from level to level in a greedy fashion. Rintanen <ref> [91] </ref> describes an opportunistic, non-directional search strategy which bypasses conversion to SAT. <p> Other researchers have devised alternative methods for detecting constraints. For example, [2] describes a method similar to DISCOPLAN which, in addition, uses regression search to further restrict the predicate domains. Rinta-nen modified algorithms from computer-aided verification to discover binary 29 invariants <ref> [91] </ref>. Earlier work on the subject is presented in [57].
Reference: [92] <author> B. Selman, H. Kautz, and B. Cohen. </author> <title> Noise strategies for improving local search. </title> <booktitle> In Proc. 12th Nat. Conf. AI, </booktitle> <pages> pages 337-343, </pages> <month> July </month> <year> 1994. </year>
Reference-contexts: After hill climbing for a fixed amount of flips (as directed by N flips ), GSAT starts anew with a freshly generated, random assignment. After N restarts many of these restarts, GSAT gives up. WALKSAT 18 <ref> [92, 93] </ref> improves upon GSAT by adding additional randomness akin to simulated annealing. On each flip, WALKSAT does one of two things; with probability p it chooses the same variable GSAT would have chosen, otherwise it selects a random variable from an unsatisfied clause.
Reference: [93] <author> B. Selman, H. Kautz, and B. Cohen. </author> <title> Local search strategies for satisfia-bility testing. </title> <booktitle> DIMACS Series in Discrete Mathematics and Theoretical Computer Science, </booktitle> <volume> 26 </volume> <pages> 521-532, </pages> <year> 1996. </year>
Reference-contexts: After hill climbing for a fixed amount of flips (as directed by N flips ), GSAT starts anew with a freshly generated, random assignment. After N restarts many of these restarts, GSAT gives up. WALKSAT 18 <ref> [92, 93] </ref> improves upon GSAT by adding additional randomness akin to simulated annealing. On each flip, WALKSAT does one of two things; with probability p it chooses the same variable GSAT would have chosen, otherwise it selects a random variable from an unsatisfied clause.
Reference: [94] <author> B. Selman, H. Levesque, and D.. Mitchell. </author> <title> A new method for solving hard satisfiability problems. </title> <booktitle> In Proc. 10th Nat. Conf. AI, </booktitle> <pages> pages 440-446, </pages> <month> July </month> <year> 1994. </year>
Reference-contexts: On the other hand, stochastic solvers are frequently much faster at finding satisfying assignments when they exist. The simple and popular GSAT solver is a random-restart, hill-climbing search algorithm (figure 14) <ref> [94] </ref>. The successors of a truth assignment are assignments that differ only in the value assigned to a single variable. GSAT performs a greedy search, prefering one assignment over another based on the number of satisfied clauses.
Reference: [95] <author> Bart Selman, Henry Kautz, and David McAllester. </author> <title> Computational challenges in propositional reasoning and search. </title> <booktitle> In Proc. 15th Int. Joint Conf. AI, </booktitle> <year> 1997. </year>
Reference-contexts: Perhaps the best summary is that this area of research is highly dynamic. Each year seems to bring a new method which eclipses the previous leader. Selman et al. <ref> [95] </ref> present an excellent summary of the state of the art in propositional reasoning, and sketches challenges for coming years. Our discussion is therefore brief.
Reference: [96] <author> D. Smith. </author> <title> Controlling backward inference. </title> <journal> J. Artificial Intelligence, </journal> <volume> 39 </volume> <pages> 145-208, </pages> <year> 1989. </year>
Reference-contexts: Another method for determining a good subgoal ordering is through structural analysis of subgoal interactions <ref> [42, 14, 96] </ref>. Precomputation aimed at calculating speedy subgoal orderings is closely related to the use of abstraction in planning [59, 103, 114].
Reference: [97] <author> D. Smith and M. Peot. </author> <title> Postponing threats in partial-order planning. </title> <booktitle> In Proc. 11th Nat. Conf. AI, </booktitle> <pages> pages 500-506, </pages> <month> June </month> <year> 1993. </year>
Reference-contexts: In general, a good heuristic is to select the variable with the fewest remaining (nonconflicting) values and this information is readily available if forward checking is employed. 5 While not astounding, these 5 Similar heuristics have been investigated in the context of causal-link planners; see <ref> [97, 43, 113, 101, 33, 90] </ref>. techniques lead to significant (e.g., 50%) performance improvements in Graphplan [49]. Another method for determining a good subgoal ordering is through structural analysis of subgoal interactions [42, 14, 96]. <p> When these level-k + 2 conditions are short, then many searches can be terminated very quickly. These methods are 6 See <ref> [25, 97, 98] </ref> for additional uses of precomputation based on analysis of action interactions 11 (defschema (drive) :parameters (?v ?s ?d) :precondition (and (vehicle ?v) (location ?s) (location ?d) (road-connected ?s ?d) (at ?v ?s)) :effect (and (not (at ?v ?s)) (at ?v ?d))) source location to a destination. based on <p> Hector 24 It is interesting to compare this work with similar research on subgoal ordering discussed earlier in the section on Solution Extraction as Constraint Satisfaction. Problem-space graphs [25] and operator graphs <ref> [97, 98] </ref> share many resemblances to causal graphs.
Reference: [98] <author> D. Smith and M. Peot. </author> <title> Suspending recurison in causal link planning. </title> <booktitle> In Proc. 3rd Intl. Conf. AI Planning Systems, </booktitle> <year> 1996. </year>
Reference-contexts: When these level-k + 2 conditions are short, then many searches can be terminated very quickly. These methods are 6 See <ref> [25, 97, 98] </ref> for additional uses of precomputation based on analysis of action interactions 11 (defschema (drive) :parameters (?v ?s ?d) :precondition (and (vehicle ?v) (location ?s) (location ?d) (road-connected ?s ?d) (at ?v ?s)) :effect (and (not (at ?v ?s)) (at ?v ?d))) source location to a destination. based on <p> Hector 24 It is interesting to compare this work with similar research on subgoal ordering discussed earlier in the section on Solution Extraction as Constraint Satisfaction. Problem-space graphs [25] and operator graphs <ref> [97, 98] </ref> share many resemblances to causal graphs.
Reference: [99] <author> D. Smith and D. Weld. Conformant Graphplan. </author> <booktitle> In Proc. 15th Nat. Conf. AI, </booktitle> <month> July </month> <year> 1998. </year> <month> 47 </month>
Reference-contexts: Initial results in this area are a start [10, 72], but empirical comparisons are badly needed. Several researchers have extended Graphplan to handle uncertainty. Con-formant graphplan (CGP) <ref> [99] </ref> handles uncertainty in the initial state and in action effects, but does not allow sensing; the resulting "conformant" plan works 39 in the presence of uncertainty by choosing robust actions that cover all eventu-alities.
Reference: [100] <author> D. Smith and D. Weld. </author> <title> Temporal graphplan. </title> <type> Technical report, </type> <institution> Univ. of Washington, Dept. of Computer Science and Engineering, </institution> <year> 1998. </year>
Reference-contexts: By adding an additional set of labels one may interleave forward and backward expansion of the planning graph. Using this scheme, the time and space costs of the expansion phase are vastly decreased, but the bookkeeping required is surprisingly tricky; see <ref> [100] </ref> for details and see also the STAN planner's "wavefront" representation. 9 Proof sketch: if A and B appear at both level i and i 2 and are mutex at level i then by definition this mutex must be due to inconsistent effects, interference, or competing needs.
Reference: [101] <author> R. Srinivasan and A. Howe. </author> <title> Comparison of methods for improving search efficiency in a partial-order planner. </title> <booktitle> In Proc. 14th Int. Joint Conf. AI, </booktitle> <pages> pages 1620-1626, </pages> <year> 1995. </year>
Reference-contexts: In general, a good heuristic is to select the variable with the fewest remaining (nonconflicting) values and this information is readily available if forward checking is employed. 5 While not astounding, these 5 Similar heuristics have been investigated in the context of causal-link planners; see <ref> [97, 43, 113, 101, 33, 90] </ref>. techniques lead to significant (e.g., 50%) performance improvements in Graphplan [49]. Another method for determining a good subgoal ordering is through structural analysis of subgoal interactions [42, 14, 96].
Reference: [102] <author> M. Stefik. </author> <title> Planning with constraints (MOLGEN: Part 1). </title> <journal> J. Artificial Intelligence, </journal> <volume> 14(2) </volume> <pages> 111-139, </pages> <year> 1981. </year>
Reference-contexts: The 4 Although there is a long history of research applying ideas from constraint satisfaction to planning, we focus on applications to Graphplan in this paper (although compilation of planning to SAT can be viewed as taking the constraint satisfaction perspective to its logical conclusion). See MOLGEN <ref> [102] </ref> for seminal work on constraint-posting planning.
Reference: [103] <author> J. Tenenberg. </author> <title> Abstraction in planning. </title> <type> Ph.d. thesis, </type> <institution> University of Rochester, Department of Computer Science, </institution> <month> May </month> <year> 1988. </year>
Reference-contexts: Another method for determining a good subgoal ordering is through structural analysis of subgoal interactions [42, 14, 96]. Precomputation aimed at calculating speedy subgoal orderings is closely related to the use of abstraction in planning <ref> [59, 103, 114] </ref>. In general, one can distinguish between domain-specific approaches (which are based on action definitions alone) and problem-specific approaches (which additionally use the goal and initial state specifications); problem-specific approaches typically provide more leverage, but the cost of domain-specific precomputation can be amortized amongst many planning problems.
Reference: [104] <author> A. Van Gelder and F. Okushi. </author> <title> A propositional theorem prover to solve planning and other problems. </title> <note> (Submitted for publication; preliminary version presented at the Fifth International Symposium on Artificial Intelligence and Mathematics: http://rutcor.rutgers.edu/~amai), 1998. </note>
Reference-contexts: This insight suggests a small change to DPLL: restrict the choice of splitting variables to action variables. Interestingly, the result of this restriction is dramatic: up to four orders of magnitude speedup [35]. The MODOC solver <ref> [104, 85] </ref> also uses the high-level structure of the planning problem to speed the SAT solver, but MODOC uses knowledge of which propositions correspond to goals (rather than to actions) to guide its search; the resulting solver is competitive with Walksat (described below). 31 Time to find a satisfying assignmentfl P
Reference: [105] <author> A. Van Gelder and Y. K. Tsuji. </author> <title> Satisfiability testing with more reasoning and less guessing. </title> <editor> In D. S. Johnson and M. Trick, editors, </editor> <title> Cliques, Coloring, and Satisfiability: Second DIMACS Implementation Challenge., </title> <booktitle> DIMACS Series in Discrete Mathematics and Theoretical Computer Science. </booktitle> <publisher> American Mathematical Society, </publisher> <year> 1996. </year>
Reference-contexts: The simplifier uses fast (linear time) techniques such as unit clause propagation and pure literal elimination (e.g., <ref> [105] </ref>) to shrink the CNF formula. <p> In contrast, bitwise and overloaded result in convoluted encodings that resist simplification and type analysis. For example, although the bitwise encoding yields the smallest number of propositional variables before simplification, the linear-time procedure described in <ref> [105] </ref> shrunk the CNF formulae from the other representations so much that afterwards bit wise had the most variables. 3.1.2 Frame Axioms Every encoding requires axioms to confront the frame problem [80]. frame Frame axioms constrain unaffected fluents when an action occurs. There are two alternatives: classical or explanatory frames.
Reference: [106] <author> Manuela Veloso. </author> <title> Flexible strategy learning: Analogical replay of problem solving episodes. </title> <booktitle> In Proc. 12th Nat. Conf. AI, </booktitle> <pages> pages 595-600, </pages> <month> July </month> <year> 1994. </year>
Reference: [107] <author> D. Weld. </author> <title> An introduction to least-commitment planning. </title> <journal> AI Magazine, </journal> <pages> pages 27-61, </pages> <month> Winter </month> <year> 1994. </year> <note> Available at ftp://ftp.cs.washington.- edu/pub/ai/. </note>
Reference-contexts: extension stems from the case when one conditional effect is induced by another | i.e., when it is impossible to execute one effect without causing the other to happen as well [1]. * Factored expansion also complicates the solution extraction, because of the need to perform the analog of confrontation <ref> [88, 107] </ref>, i.e., prevent the antecedent of undesirable effects from occuring. The IPP planner [65] uses a third method for handling conditional effects which we call partially factored expansion.
Reference: [108] <author> D. Weld and J. de Kleer, </author> <title> editors. Readings in Qualitative Reasoning about Physical Systems. </title> <publisher> Morgan Kaufmann, </publisher> <address> San Mateo, CA, </address> <month> August </month> <year> 1989. </year>
Reference-contexts: These variables have the domains shown below: valve-mode 2 fopen; closed; stuck-open; stuck-closedg f in ; F OU T 2 fpositive; zero; negativeg p in ; P OU T 2 fhigh; nominal; lowg Note the use of a discretized, qualitative representation <ref> [9, 108] </ref> of the real-valued flow and pressure variables. The cross product of these five variables defines state or if a failure has occurred.
Reference: [109] <author> D. S. Weld, C. R. Anderson, and D. E. Smith. </author> <title> Extending graphplan to handle uncertainty and sensing actions. </title> <booktitle> In Proc. 15th Nat. Conf. AI, </booktitle> <pages> pages 897-904, </pages> <month> July </month> <year> 1998. </year>
Reference-contexts: Download from www.dur.ac.uk/~dcs0www/research/stanstuff/stanpage.html. - SGP <ref> [109] </ref> is a simple, pedagogical Lisp implementation of Graph-plan, extended to handle universal quantification, conditional effects, and uncertainty; see www.cs.washington.edu/research/projects/ai/www/sgp.html. * Systems based on compilation to SAT: The highest performance SAT compiler is Blackbox [55] available www.research.att.com/~kautz/blackbox/index.html. <p> Several researchers have extended Graphplan to handle uncertainty. Con-formant graphplan (CGP) [99] handles uncertainty in the initial state and in action effects, but does not allow sensing; the resulting "conformant" plan works 39 in the presence of uncertainty by choosing robust actions that cover all eventu-alities. Sensory graphplan (SGP) <ref> [109] </ref> extends CGP to allow branching ("contingent") plans based on run-time information gathered by noiseless sensory actions which may have preconditions. Neither CGP nor SGP incorporate numerical probabilistic reasoning; both build separate planning graph structures for each possible world specified by the problem's uncertainty, and so scaling is a concern.
Reference: [110] <author> B. C. Williams and P. P. Nayak. </author> <title> A model-based approach to reactive self-configuring systems. </title> <booktitle> In Proc. 13th Nat. Conf. AI, </booktitle> <address> Portland, OR, </address> <month> August </month> <year> 1996. </year>
Reference-contexts: Pyro values may be opened (or closed) only once. spacecraft which is to be launched in autumn 1998. As one would expect given the magnitude of the task, the complete agent is quite complex [87]; we focus on the configuration planning and execution subsystem <ref> [110, 111] </ref> which are best explained with an example. Figure 16 shows a simplified schematic for the main engines of a spacecraft. <p> As shown in figure 17, these decisions are made by a pipeline of three major components: * The execution monitor (MI) 19 interprets limited sensor readings to de 19 For clarity and consistency, we use different terminology than Williams and Nayak's original papers <ref> [110, 111] </ref>, and we include their acronyms to facilitate correspondence for reader recourse to primary literature.
Reference: [111] <author> B. C. Williams and P. P. Nayak. </author> <title> A reactive planner for a model-based execution. </title> <booktitle> In Proc. 15th Int. Joint Conf. AI, </booktitle> <address> Nagoya, Japan, </address> <month> August </month> <year> 1997. </year>
Reference-contexts: Pyro values may be opened (or closed) only once. spacecraft which is to be launched in autumn 1998. As one would expect given the magnitude of the task, the complete agent is quite complex [87]; we focus on the configuration planning and execution subsystem <ref> [110, 111] </ref> which are best explained with an example. Figure 16 shows a simplified schematic for the main engines of a spacecraft. <p> As shown in figure 17, these decisions are made by a pipeline of three major components: * The execution monitor (MI) 19 interprets limited sensor readings to de 19 For clarity and consistency, we use different terminology than Williams and Nayak's original papers <ref> [110, 111] </ref>, and we include their acronyms to facilitate correspondence for reader recourse to primary literature.
Reference: [112] <author> Q. Yang. </author> <title> Formalizing planning knowledge for hierarchical planning. </title> <journal> Computational Intelligence, </journal> <volume> 6(1) </volume> <pages> 12-24, </pages> <month> February </month> <year> 1990. </year>
Reference: [113] <author> Q. Yang and A. Chan. </author> <title> Delaying variable binding committments in planning. </title> <booktitle> In Proc. 2nd Intl. Conf. AI Planning Systems, </booktitle> <pages> pages 182-187, </pages> <month> June </month> <year> 1994. </year>
Reference-contexts: In general, a good heuristic is to select the variable with the fewest remaining (nonconflicting) values and this information is readily available if forward checking is employed. 5 While not astounding, these 5 Similar heuristics have been investigated in the context of causal-link planners; see <ref> [97, 43, 113, 101, 33, 90] </ref>. techniques lead to significant (e.g., 50%) performance improvements in Graphplan [49]. Another method for determining a good subgoal ordering is through structural analysis of subgoal interactions [42, 14, 96].
Reference: [114] <author> Q. Yang and J. Tenenberg. ABTWEAK: </author> <title> Abstracting a nonlinear, least--commitment planner. </title> <booktitle> In Proc. 8th Nat. Conf. AI, </booktitle> <pages> pages 204-209, </pages> <month> August </month> <year> 1990. </year>
Reference-contexts: Another method for determining a good subgoal ordering is through structural analysis of subgoal interactions [42, 14, 96]. Precomputation aimed at calculating speedy subgoal orderings is closely related to the use of abstraction in planning <ref> [59, 103, 114] </ref>. In general, one can distinguish between domain-specific approaches (which are based on action definitions alone) and problem-specific approaches (which additionally use the goal and initial state specifications); problem-specific approaches typically provide more leverage, but the cost of domain-specific precomputation can be amortized amongst many planning problems.
References-found: 114

