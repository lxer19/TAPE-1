URL: http://www.win.tue.nl/~hooman/EHLRT.ps
Refering-URL: http://www.win.tue.nl/~hooman/EHLRT.html
Root-URL: http://www.win.tue.nl
Title: Extending Hoare Logic to Real-Time  
Author: Jozef Hooman 
Keyword: Formal specification; Top-down design; Compositionality; Real-time; Concurrency; Hoare logic  
Address: The Netherlands  
Affiliation: Department of Mathematics and Computing Science, Eindhoven University of Technology,  
Date: 1995 BCS  
Note: Formal Aspects of Computing (1994) 6A: 801-825 c  
Abstract: Classical Hoare triples are modified to specify and design distributed real-time systems. The assertion language is extended with primitives to express the timing of observable actions. Further the interpretation of triples is adapted such that both terminating and nonterminating computations can be specified. To verify that a concurrent program, with message passing along asynchronous channels, satisfies a real-time specification, we formulate a compositional proof system for our extended Hoare logic. The use of compositionality during top-down design is illustrated by a process control example of a chemical batch processing system. 
Abstract-found: 1
Intro-found: 1
Reference: [Ada83] <institution> The Programming Language Ada, </institution> <note> Reference Manual, </note> <year> 1983. </year>
Reference-contexts: This leads to the specification of a control component which is implemented in software. Extending Hoare Logic to Real-Time 3 * In section 6 we introduce a concurrent programming language, including a few basic real-time constructs inspired by Occam [Occ88] and Ada <ref> [Ada83] </ref>. Proving properties of such programs requires information about implementation details from which one usually abstracts in non-real-time models, such as the execution time of atomic statements. <p> Real-time is incorporated by delay-statements which suspend the execution for a certain period of time. Such a delay-statement is also allowed in a simple select statement (similar to a delay-statement in the select-construct of Ada <ref> [Ada83] </ref>). The statements of the programming language and their informal meaning, are listed below, using program variable x, expression e yielding a value in VAL, boolean expression b, and c 2 CHAN.
Reference: [AdLFS93] <author> T. Anderson, R. de Lemos, J.S. Fitzgerald, and A. Saeed. </author> <title> On formal support for industrial-scale requirements analysis. </title> <booktitle> In Workshop on Theory of Hybrid Systems, </booktitle> <pages> pages 426-451. </pages> <note> LNCS 736, </note> <year> 1993. </year>
Reference-contexts: This example is presented in section 3, based on a description in <ref> [AdLFS93] </ref>. <p> Example Chemical Batch Processing We consider a chemical batch processing example which is inspired by a description in <ref> [AdLFS93] </ref>. It consists of a batch processing plant which has a reaction vessel filled with chemicals. Heating two chemicals produces a third chemical which is hazardous and might lead to an explosion. <p> Given this property, there are several possible strategies for a control system when it detects that the temperature is too high. For instance it might cool the chemicals while they are in the vessel. Here we follow <ref> [AdLFS93] </ref> and decide to empty the contents into a cooled vat. Let CHL j 8t &lt; 1 : temp (t) &gt; ExpTemp ! empty at t. <p> To this end an atomic broadcast protocol has been specified and verified [ZH95]. In this paper the framework has been illustrated by a chemical batch processing system. This example is taken from <ref> [AdLFS93] </ref>, where a method is presented to obtain a requirements specification and to perform systematic analysis of safety requirements. Different formal techniques are applied during different stages of the analysis, leading to a specification of a safety controller by means of a Petri Net.
Reference: [AL92] <author> M. Abadi and L. Lamport. </author> <title> An old-fashioned recipe for real-time. </title> <booktitle> In REX Workshop on Real-Time: Theory in Practice, </booktitle> <pages> pages 1-27. </pages> <publisher> LNCS 600, Springer-Verlag, </publisher> <year> 1992. </year>
Reference-contexts: To express timing, we add a special variable now (similar to <ref> [AL92] </ref>) which represents in the precondition the starting time of the program whereas in the postcondition it denotes the termination time. In this way we can specify, e.g., bounds on the execution time of a program. <p> An important contribution of this calculus is the introduction of an integral primitive, expressing the duration of a certain state. Further we mention Lamport's temporal logic of actions (TLA) <ref> [AL92] </ref>, an assertional method which allows the top-down refinement of closed systems. It has been extended to real-time by adding a special variable now to represent time [Lam93].
Reference: [CHR91] <author> Zhou Chaochen, </author> <title> C.A.R. Hoare, and A.P. Ravn. A calculus of durations. </title> <journal> Information Processing Letters, </journal> <volume> 40 </volume> <pages> 269-276, </pages> <year> 1991. </year>
Reference-contexts: This chemical batch processing example is a typical hybrid system, and a large number of methods to deal with such systems can be found in [GNRR93]. Related to the first steps in our top-down approach is the Duration Calculus <ref> [CHR91] </ref>, a real-time interval logic based on the concept of the duration of states. An important contribution of this calculus is the introduction of an integral primitive, expressing the duration of a certain state.
Reference: [Dij76] <author> E.W. Dijkstra. </author> <title> A Discipline of Programming. </title> <publisher> Prentice-Hall, </publisher> <year> 1976. </year>
Reference-contexts: Related to our formal framework is an early paper by Haase [Haa81] in which real-time is introduced as a variable in the data space of the program and assertions are derived by Dijkstra's weakest precondition calculus <ref> [Dij76] </ref>. A non-compositional approach can be found in [SBM92] where a logic of proof outlines 24 J. Hooman with control predicates is extended to concurrent real-time programs by adding a primitive to express the time a control predicate last became true.
Reference: [GNRR93] <editor> R. Grossman, A. Nerode, A. Ravn, and H. Rischel, editors. </editor> <title> Hybrid Systems. </title> <publisher> LNCS 736. Springer-Verlag, </publisher> <year> 1993. </year>
Reference-contexts: Usually, this concerns distributed systems which have an intensive interaction with their environment, often called reactive systems [HP85]. Further these systems might consist of both software controlled components and physical components with a time-continuous nature; so-called hybrid system <ref> [GNRR93] </ref>. To verify (real-time) properties of such systems, we aim at a proof system in which it is possible to consider a part of the system as a black box and use its specification only. Furthermore, the method should support top-down program design. <p> Related to our approach is the use of modularity for the top-down developement of requirements. This chemical batch processing example is a typical hybrid system, and a large number of methods to deal with such systems can be found in <ref> [GNRR93] </ref>. Related to the first steps in our top-down approach is the Duration Calculus [CHR91], a real-time interval logic based on the concept of the duration of states. An important contribution of this calculus is the introduction of an integral primitive, expressing the duration of a certain state.
Reference: [Haa81] <author> V.H. Haase. </author> <title> Real-time behaviour of programs. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> SE-7(5):494-501, </volume> <year> 1981. </year>
Reference-contexts: Further we mention Lamport's temporal logic of actions (TLA) [AL92], an assertional method which allows the top-down refinement of closed systems. It has been extended to real-time by adding a special variable now to represent time [Lam93]. Related to our formal framework is an early paper by Haase <ref> [Haa81] </ref> in which real-time is introduced as a variable in the data space of the program and assertions are derived by Dijkstra's weakest precondition calculus [Dij76]. A non-compositional approach can be found in [SBM92] where a logic of proof outlines 24 J.
Reference: [Hoa69] <author> C.A.R. Hoare. </author> <title> An axiomatic basis for computer programming. </title> <journal> Communications of the ACM, </journal> <volume> 12(10) 576-580,583, </volume> <year> 1969. </year>
Reference-contexts: By means of a compositional proof system design steps can be verified during the process of top-down program construction. Observing the nice compositional rules for sequential composition and iteration of classical Hoare triples (precondition, program, postcondition) <ref> [Hoa69] </ref>, we have modified these triples to obtain a formalism for the specification and the verification of distributed real-time reactive systems. This has been achieved by extending the assertion language, in which the precondition and the postcon-dition are expressed, and modifying the interpretation of triples. <p> Thus %(o ) expresses observable events of P for oe 0 (now) o &lt; oe (now). Outside this interval the occurrence of actions is not restricted by the semantics of P , so arbitrary events are allowed. 2.3. Specifications Our specifications are based on Hoare triples (precondition, program, postcon-dition) <ref> [Hoa69] </ref>. To distinguish our modified triples from classical Hoare Logic, a slightly different notation will be introduced and we use the words "assumption" and "commitment" instead of, respectively, "precondition" and "postcondition".
Reference: [Hoo91] <author> J. Hooman. </author> <title> Specification and Compositional Verification of Real-Time Systems. </title> <publisher> LNCS 558, Springer-Verlag, </publisher> <year> 1991. </year>
Reference-contexts: We do not give a formal semantics of the programming language in this paper, but the essential ideas are reflected in the proof system of section 6.3. Details about the formulation of a denotational semantics for a real-time programming language are given in <ref> [Hoo91] </ref>, where also proofs of soundness and completeness can be found. 6.1. Syntax Programming Language We consider a real-time concurrent programming language with communication along asynchronous channels. Real-time is incorporated by delay-statements which suspend the execution for a certain period of time. <p> Concluding Remarks To design distributed real-time systems, a compositional method based on Hoare logic has been presented. In this paper the maximal parallelism assumption has been used to model the situation that each process has its own processor. In <ref> [Hoo91] </ref> we describe a generalization to multiprogramming where several processes may share a single processor and scheduling is based on priorities. Further [Hoo91] considers communication via synchronous channels where the sender waits until a communication partner is available. <p> In this paper the maximal parallelism assumption has been used to model the situation that each process has its own processor. In <ref> [Hoo91] </ref> we describe a generalization to multiprogramming where several processes may share a single processor and scheduling is based on priorities. Further [Hoo91] considers communication via synchronous channels where the sender waits until a communication partner is available. A combination of both types of channels and the use of local clocks in our framework is given in [Hoo93a].
Reference: [Hoo93a] <author> J. Hooman. </author> <title> A compositional approach to the design of hybrid systems. </title> <booktitle> In Workshop on Theory of Hybrid Systems, </booktitle> <pages> pages 121-148. </pages> <note> LNCS 736, </note> <year> 1993. </year>
Reference-contexts: Further [Hoo91] considers communication via synchronous channels where the sender waits until a communication partner is available. A combination of both types of channels and the use of local clocks in our framework is given in <ref> [Hoo93a] </ref>. To investigate the flexibility of our approach, in [Hoo93b, Hoo94] an application with a different communication mechanism is considered. There we specify and verify a distributed real-time arbitration protocol in which concurrent modules communicate by means of a common bus.
Reference: [Hoo93b] <author> J. Hooman. </author> <title> Specification and verification of a distributed real-time arbitration protocol. </title> <booktitle> In Proceedings 14th IEEE Real-Time Systems Symposium, </booktitle> <pages> pages 284-293. </pages> <publisher> IEEE, </publisher> <year> 1993. </year>
Reference-contexts: Further [Hoo91] considers communication via synchronous channels where the sender waits until a communication partner is available. A combination of both types of channels and the use of local clocks in our framework is given in [Hoo93a]. To investigate the flexibility of our approach, in <ref> [Hoo93b, Hoo94] </ref> an application with a different communication mechanism is considered. There we specify and verify a distributed real-time arbitration protocol in which concurrent modules communicate by means of a common bus.
Reference: [Hoo94] <author> J. Hooman. </author> <title> Compositional verification of a distributed real-time arbitration protocol. </title> <booktitle> Real-Time Systems, </booktitle> <volume> 6 </volume> <pages> 173-205, </pages> <year> 1994. </year>
Reference-contexts: Further [Hoo91] considers communication via synchronous channels where the sender waits until a communication partner is available. A combination of both types of channels and the use of local clocks in our framework is given in [Hoo93a]. To investigate the flexibility of our approach, in <ref> [Hoo93b, Hoo94] </ref> an application with a different communication mechanism is considered. There we specify and verify a distributed real-time arbitration protocol in which concurrent modules communicate by means of a common bus.
Reference: [HP85] <author> D. Harel and A. Pnueli. </author> <title> On the development of reactive systems. </title> <booktitle> In Logics and Models of Concurrent Systems, </booktitle> <pages> pages 477-498. </pages> <publisher> NATO, ASI-13, Springer-Verlag, </publisher> <year> 1985. </year>
Reference-contexts: 1. Introduction The general aim of this work is the development a formal framework for the specification and verification of real-time embedded systems. Usually, this concerns distributed systems which have an intensive interaction with their environment, often called reactive systems <ref> [HP85] </ref>. Further these systems might consist of both software controlled components and physical components with a time-continuous nature; so-called hybrid system [GNRR93].
Reference: [Lam83] <author> L. Lamport. </author> <title> What Good is Temporal Logic, pages 657-668. Information Processing, R.E. </title> <editor> Manson (ed). </editor> <publisher> North Holland, </publisher> <year> 1983. </year>
Reference-contexts: Having introduced timing primitives in the assertion language, however, we aim at a formalism in which, besides these safety properties, also liveness properties can be expressed. This goal is based on the observation of Lamport <ref> [Lam83] </ref> that the characterization of safety as "nothing bad will happen" and liveness as "eventually something good must happen" is not appropriate for real-time properties.
Reference: [Lam93] <author> L. Lamport. </author> <booktitle> Hybrid systems in TLA + . In Workshop on Theory of Hybrid Systems, </booktitle> <pages> pages 77-102. </pages> <note> LNCS 736, </note> <year> 1993. </year>
Reference-contexts: Further we mention Lamport's temporal logic of actions (TLA) [AL92], an assertional method which allows the top-down refinement of closed systems. It has been extended to real-time by adding a special variable now to represent time <ref> [Lam93] </ref>. Related to our formal framework is an early paper by Haase [Haa81] in which real-time is introduced as a variable in the data space of the program and assertions are derived by Dijkstra's weakest precondition calculus [Dij76].
Reference: [Occ88] <author> INMOS Limited. </author> <title> Occam 2 Reference Manual, </title> <year> 1988. </year>
Reference-contexts: This leads to the specification of a control component which is implemented in software. Extending Hoare Logic to Real-Time 3 * In section 6 we introduce a concurrent programming language, including a few basic real-time constructs inspired by Occam <ref> [Occ88] </ref> and Ada [Ada83]. Proving properties of such programs requires information about implementation details from which one usually abstracts in non-real-time models, such as the execution time of atomic statements.
Reference: [ORS92] <author> S. Owre, J. Rushby, and N. Shankar. PVS: </author> <title> A prototype verification system. </title> <booktitle> In 11th Conference on Automated Deduction, volume 607 of Lecture Notes in Artificial Intelligence, </booktitle> <pages> pages 748-752. </pages> <publisher> Springer-Verlag, </publisher> <year> 1992. </year>
Reference-contexts: A similar extension of Hoare logic is given in [Sha93] using a more general primitive to express the time that has elapsed since an assertion last held. Interesting in this last work is the use of the interactive proof checker PVS (Prototype Verification System) <ref> [ORS92] </ref>. Clearly for any system of reasonable size some tool support is indispensable. Therefore we are also experimenting with PVS to discharge simple verification conditions automatically and to check the proofs of design steps.
Reference: [SBM92] <author> F. Schneider, B. Bloom, and K. Marzullo. </author> <title> Putting time into proof outlines. </title> <booktitle> In Workshop on Real-Time: Theory in Practice, </booktitle> <pages> pages 618-639. </pages> <publisher> LNCS 600, Springer-Verlag, </publisher> <year> 1992. </year>
Reference-contexts: Related to our formal framework is an early paper by Haase [Haa81] in which real-time is introduced as a variable in the data space of the program and assertions are derived by Dijkstra's weakest precondition calculus [Dij76]. A non-compositional approach can be found in <ref> [SBM92] </ref> where a logic of proof outlines 24 J. Hooman with control predicates is extended to concurrent real-time programs by adding a primitive to express the time a control predicate last became true.
Reference: [Sha93] <author> N. Shankar. </author> <title> Verification of real-time systems using PVS. </title> <booktitle> In Computer Aided Verification '93, </booktitle> <pages> pages 280-291. </pages> <publisher> LNCS 697, Springer-Verlag, </publisher> <year> 1993. </year>
Reference-contexts: A non-compositional approach can be found in [SBM92] where a logic of proof outlines 24 J. Hooman with control predicates is extended to concurrent real-time programs by adding a primitive to express the time a control predicate last became true. A similar extension of Hoare logic is given in <ref> [Sha93] </ref> using a more general primitive to express the time that has elapsed since an assertion last held. Interesting in this last work is the use of the interactive proof checker PVS (Prototype Verification System) [ORS92]. Clearly for any system of reasonable size some tool support is indispensable.
Reference: [ZH95] <author> P. Zhou and J. Hooman. </author> <title> Formal specification and compositional verification of an atomic broadcast protocol. Real-Time Systems, </title> <note> to appear, </note> <year> 1995. </year>
Reference-contexts: Given this strong relation between real-time and fault-tolerance, we investigate the extension of our real-time framework to deal with fault-tolerance. To this end an atomic broadcast protocol has been specified and verified <ref> [ZH95] </ref>. In this paper the framework has been illustrated by a chemical batch processing system. This example is taken from [AdLFS93], where a method is presented to obtain a requirements specification and to perform systematic analysis of safety requirements.
References-found: 20

