URL: http://www.cs.wisc.edu/~ericro/TPRED_micro30.final.ps
Refering-URL: http://www.cs.wisc.edu/~ericro/
Root-URL: 
Email: qjacobso@ece.wisc.edu  ericro@cs.wisc.edu  jes@ece.wisc.edu  
Phone: Telephone:  
Title: Path-Based Next Trace Prediction  
Author: Quinn Jacobson Eric Rotenberg James E. Smith 
Note: Manager, Copyrights and Permissions IEEE  Intl. 908-562-3966  
Address: Wisconsin  Wisconsin  Wisconsin  445 Hoes Lane P.O. Box 1331 Piscataway, NJ 08855-1331, USA  
Affiliation: Department of Electrical Computer Engineering University of  Department of Computer Science University of  Department of Electrical Computer Engineering University of  Service Center  
Abstract: Copyright 1997 IEEE. Published in the Proceedings of Micro-30, December 1-3, 1997 in Research Triangle Park, North Carolina. Personal use of this material is permitted. However, permission to reprint/republish this material for advertising or promotional purposes or for creating new collective works for resale or redistribution to servers or lists, or to reuse any copyrighted component of this work in other works, must be obtained from the IEEE. Contact: 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> D. Burger, T. Austin and S. Bennett, </author> <title> Evaluating Future Microprocessors: The SimpleScalar Tool Set, </title> <institution> University of Wisconsin - Madison Technical Report #1308, </institution> <month> July </month> <year> 1996. </year> <note> (http://www.cs.wisc.edu.~mscalar/simplescalar.html) </note>
Reference-contexts: Simulation methodology 4.1. Simulator To study predictor performance, trace driven simulation with the Simplescalar tool set is used <ref> [1] </ref>. Simplescalar uses an instruction set largely based on MIPS, with the major deviation being that delayed branches have been replaced with conventional branches. We use the Gnu C compiler that targets Simplescalar.
Reference: [2] <author> P.-Y. Chang, E. Hao and Y. Patt, </author> <title> Target Prediction for Indirect Jumps, </title> <booktitle> in Proceedings of the 24 th International Symposium on Computer Architecture, </booktitle> <pages> pp. 274-283, </pages> <month> June </month> <year> 1997. </year>
Reference-contexts: We used a 16-bit GSHARE branch predictor, a perfect branch target buffer for branches with PC-relative and absolute address targets, a 64K entry correlated branch target buffer for branches with indirect targets <ref> [2] </ref>, and a perfect return address predictor. All of these predictors had ideal (immediate) updates. When simulating this mechanism, if one or more predictions within a trace was incorrect we counted it as one trace misprediction. This configuration represents a very aggressive, ideal predictor.
Reference: [3] <author> T. Conte, K. Menezes, P. Mills and B. Patel, </author> <title> Optimization of Instruction Fetch Mechanisms for High Issue Rates, </title> <booktitle> in Proceedings of the 22 nd International Symposium on Computer Architecture, </booktitle> <pages> pp. 333-343, </pages> <month> June </month> <year> 1995. </year>
Reference-contexts: Previous work A number of methods for fetching multiple basic blocks per cycle have been proposed. Yeh et al. [12] proposed a Branch Address Cache that predicted multiple branch target addresses every cycle. Conte et al. <ref> [3] </ref> proposed an interleaved branch target buffer to predict multiple branch targets and detect short forward branches that stay within the same cache line. Both these methods use conventional instruction caches, and both fetch multiple lines based on multiple branch predictions.
Reference: [4] <author> S. Dutta and M. Franklin, </author> <title> Control Flow Prediction with TreeLike Subgraphs for Superscalar Processors, </title> <booktitle> in Proceedings of the 28 th International Symposium on Microarchitecture, </booktitle> <pages> pp. 258-263, </pages> <month> December </month> <year> 1995. </year>
Reference-contexts: In order to support simultaneous fetching of multiple basic blocks, multiple branches must be predicted in a single cycle. A number of modifications to the correlated predictor discussed above have been proposed to support predicting multiple branches at once. Franklin and Dutta <ref> [4] </ref> proposed subgraph oriented branch prediction mechanisms that uses local history to form a prediction that encodes multiple branches. Yeh, et al. [13] proposed modifications to a GAg predictor to multiport the predictor and produce multiple branch predictions per cycle.
Reference: [5] <author> Q. Jacobson, S. Bennett, N. Sharms and J. E. Smith, </author> <title> Control Flow Speculation in Multiscalar Processors, </title> <booktitle> in Proceedings of the 3 rd International Symposium on High-Performance Computer Architecture, </booktitle> <pages> pp. 218-229, </pages> <month> February </month> <year> 1997. </year>
Reference-contexts: Hence, a branch is predicted using knowledge of the sequence, or path, of instructions that led up to it. This gives the predictor more specific information about prior control flow than the taken/not taken history of branch outcomes. Jacobson et al. <ref> [5] </ref> refined the path-based scheme and applied it to next task prediction for multiscalar processors. It is an adaptation of the multiscalar predictor that forms the core of the path-based next trace predictor presented here. 3. Path-based next trace predictors We consider predictors designed specifically to work with trace caches. <p> Unfortunately this is sometimes not practical because the prediction table is relatively small so the index must be restricted to a limited number of bits. The index generation mechanism is based on the method developed to do inter-task prediction for multiscalar processors <ref> [5] </ref>. The index generation mechanism uses a few bits from each of the hashed trace identifiers to form an index. The low order bits of the hashed trace identifiers are used. More bits are used from more recent traces. <p> More bits are used from more recent traces. The collection of selected bits from all the traces may be longer than the allowable index, in which case the collection of bits is folded over onto itself using an exclusive-or function to form the index. In <ref> [5] </ref>, the DOLC naming convention was developed for specifying the specific parameters of the index generation mechanism. The first variable Depth is the number of traces besides the last trace that are used for forming the index.
Reference: [6] <author> S. McFarling, </author> <title> Combining Branch Predictors, </title> <address> DEC WRL TN-36, </address> <month> June </month> <year> 1993 </year>
Reference-contexts: When the BHR alone is used to index into the PHT, the predictor is a GAg predictor [13]. When an exclusive-or function is used to combine an equal number of bits from the BHR and the branch PC address, the predictor is a GSHARE predictor <ref> [6] </ref>. GSHARE has been shown to offer consistently good prediction accuracy. The mapping of instructions to PHT entries is essentially implemented by a simple hashing function that does not detect or avoid collisions. Aliasing occurs when two unrelated branch instructions hash to the same PHT entry.
Reference: [7] <author> R. Nair, </author> <title> Dynamic Path-Based Branch Correlation, </title> <booktitle> in Proceedings of the 28 th International Symposium on Microarchitecture, </booktitle> <pages> pp. 15-23, </pages> <month> December </month> <year> 1995. </year>
Reference-contexts: The entries of the PHT have been modified to contain multiple two-bit saturating counters to allow simultaneous prediction of multiple branches. The predictor offers superior accuracy compared with the multiported GAg predictor, but does not quite achieve the overall accuracy of a single branch GSHARE predictor. Nair <ref> [7] </ref> proposed path-based prediction, a form of correlated branch prediction that has a single branch history register and prediction history table. The innovation is that the information stored in the branch history register is not the outcome of previous branches, but their truncated PC addresses.
Reference: [8] <author> S.-T. Pan, K. So and J. Rahmeh, </author> <title> Improving the Accuracy of Dynamic Branch Prediction Using Branch Correlation, </title> <booktitle> in Proceedings of the 5 th International Conference on Architecture Suport for Programming Languages and Operating Systems, </booktitle> <pages> pp. 76-84, </pages> <month> October </month> <year> 1992. </year>
Reference: [9] <author> S. Patel, D. Friendly and Y. Patt, </author> <title> Critical Issues Regarding the Trace Cache Fetch Mechanism. </title> <institution> University of Michigan Technical Report CSE-TR-335-97, </institution> <year> 1997. </year>
Reference-contexts: Yeh, et al. [13] proposed modifications to a GAg predictor to multiport the predictor and produce multiple branch predictions per cycle. Rotenberg et al. [10] also used the modified GAg for their trace cache study. Recently, Patel et al. <ref> [9] </ref> proposed a multiple branch predictor tailored to work with a trace cache. The predictor attempts to achieve the advantages of a GSHARE predictor while providing multiple predictions. The predictor uses a BHR and the address of the first instruction of a trace, exclusive-ored together, to index into the PHT.
Reference: [10] <author> E. Rotenberg, S. Bennett and J. E. Smith, </author> <title> Trace Cache: a Low Latency Approach to High Bandwidth Instruction Fetching, </title> <booktitle> in Proceedings of the 29 th International Symposium on Microarchitecture, </booktitle> <pages> pp. 24-34, </pages> <month> Dec. </month> <year> 1996. </year>
Reference-contexts: Franklin and Dutta [4] proposed subgraph oriented branch prediction mechanisms that uses local history to form a prediction that encodes multiple branches. Yeh, et al. [13] proposed modifications to a GAg predictor to multiport the predictor and produce multiple branch predictions per cycle. Rotenberg et al. <ref> [10] </ref> also used the modified GAg for their trace cache study. Recently, Patel et al. [9] proposed a multiple branch predictor tailored to work with a trace cache. The predictor attempts to achieve the advantages of a GSHARE predictor while providing multiple predictions.
Reference: [11] <author> J. E. Smith, </author> <title> A Study of Branch Prediction Strategies, </title> <booktitle> in Proceedings of the 8 th International Symposium on Computer Architecture, </booktitle> <pages> pp. 135-148, </pages> <month> May </month> <year> 1981. </year>
Reference-contexts: Branch prediction in some form is a fundamental part of next trace prediction (either implicitly or explicitly). Hardware branch predictors predict the outcome of branches based on previous branch behavior. At the heart of most branch predictors is a Pattern History Table (PHT), typically containing two-bit saturating counters <ref> [11] </ref>. The simplest way to associate a counter with a branch instruction is to use some bits from the PC address of the branch, typically the least significant bits, to index into the PHT [11]. <p> heart of most branch predictors is a Pattern History Table (PHT), typically containing two-bit saturating counters <ref> [11] </ref>. The simplest way to associate a counter with a branch instruction is to use some bits from the PC address of the branch, typically the least significant bits, to index into the PHT [11]. If the counters value is two or three, the branch is predicted to be taken, otherwise the branch is predicted to be not taken.
Reference: [12] <author> T.-Y. Yeh, D. Marr and Y. Patt, </author> <title> Increasing the Instruction Fetch Rate via Multiple Branch Prediction and a Branch Address Cache, </title> <booktitle> in Proceedings of the 7 th ACM International Conference on Supercomputing, </booktitle> <pages> pp. 67-76, </pages> <month> July </month> <year> 1993. </year>
Reference-contexts: For the six benchmarks that we studied the average misprediction rate is 26% lower for the proposed predictor than for the most aggressive previously proposed multiple-branch predictor. 2. Previous work A number of methods for fetching multiple basic blocks per cycle have been proposed. Yeh et al. <ref> [12] </ref> proposed a Branch Address Cache that predicted multiple branch target addresses every cycle. Conte et al. [3] proposed an interleaved branch target buffer to predict multiple branch targets and detect short forward branches that stay within the same cache line.
Reference: [13] <author> T.-Y. Yeh and Y. Patt, </author> <title> Two-Level Adaptive Branch Prediction, </title> <booktitle> In Proceedings of 24 th International Symposium on Microarchitecture, </booktitle> <pages> pp. 51-61, </pages> <month> November </month> <year> 1991. </year>
Reference-contexts: With a correlated predictor a PHT entry is associated not only with a branch instruction, but with a branch instruction in the context of a specific BHR value. When the BHR alone is used to index into the PHT, the predictor is a GAg predictor <ref> [13] </ref>. When an exclusive-or function is used to combine an equal number of bits from the BHR and the branch PC address, the predictor is a GSHARE predictor [6]. GSHARE has been shown to offer consistently good prediction accuracy. <p> A number of modifications to the correlated predictor discussed above have been proposed to support predicting multiple branches at once. Franklin and Dutta [4] proposed subgraph oriented branch prediction mechanisms that uses local history to form a prediction that encodes multiple branches. Yeh, et al. <ref> [13] </ref> proposed modifications to a GAg predictor to multiport the predictor and produce multiple branch predictions per cycle. Rotenberg et al. [10] also used the modified GAg for their trace cache study. Recently, Patel et al. [9] proposed a multiple branch predictor tailored to work with a trace cache.
References-found: 13

