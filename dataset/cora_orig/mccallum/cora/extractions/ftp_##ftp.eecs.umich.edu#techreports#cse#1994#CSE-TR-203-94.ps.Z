URL: ftp://ftp.eecs.umich.edu/techreports/cse/1994/CSE-TR-203-94.ps.Z
Refering-URL: http://www.cs.washington.edu/homes/pardo/sim.d/index4.d/Bib-REAL-106.html
Root-URL: 
Title: lDtrace A Tracing Tool for i486 Simulation  
Author: Jim Pierce Trevor Mudge 
Address: Ann Arbor, Michigan  
Affiliation: University of Michigan  Department of Electrical Engineering and Computer Science The University of Michigan  
Note: 1 of 25  
Pubnum: Technical Report CSE-TR-203-94  
Abstract: This technical report describes IDtrace, a program that produces execution traces for ix86 instruction set architectures using late-code modification. IDtrace provides a low cost method for producing input data for a wide variety of performance evaluation tools such as code profilers, branch prediction simulators, and cache simulators. IDtrace can generate several types of output traces: profile, branch, memory reference, and full execution traces. It currently runs on ix86 SysVR4 Unix systems. The report briey introduces various trace generation methods and discusses the advantages and disadvantages of late code modification over other code instrumentation techniques. The majority of the report describes the use of IDtrace and outlines the formats for all generated trace files. In addition, the issues involved in constructing such an instrumentation tool, including the challenges imposed by the i486s CISC-like features, are discussed. Architectural attributes such as the large number of memory referencing instructions, the complex instructions and addressing modes, and the variable instruction lengths make instrumentation difficult and sometimes impossible at the binary level. These problems and their possible solutions are discussed. Finally, the report includes some experimental results to illustrate the applicability of IDtrace. The experiments involve profiling the instructions frequencies of a subset of the SPEC92 benchmarks, evaluating a common branch prediction technique, deriving optimal cache configurations based on several application programs, and comparing the cache behavior of the i486 with that of the MIPS R3000. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> A. Borg, R. Kessler, and D. Wall, </author> <title> Generation and Analysis of Very Long Address Traces, </title> <booktitle> Proc. of 17th Annual International Symposium on Computer Architecture, </booktitle> <address> Seattle, WA, </address> <year> 1990, </year> <pages> pp. 270-281. </pages>
Reference: [2] <author> S. Eggers, D. Keppel, E. Koldinger, and H. Levy, </author> <title> Techniques for Efficient Inline Tracing on a Shared-Memory Multiprocessor, </title> <booktitle> Proc. of 1990 ACM Sigmetrics Conference on Measurement and Modeling of Computer Systems, </booktitle> <address> Boulder, CO, </address> <month> May </month> <year> 1990, </year> <pages> pp. 37-47. </pages>
Reference-contexts: Kernel Routines Kernel code is difficult or impossible to instrument in this manner. There are many examples of tools which instrument code at the source level. One of the best known is MPtrace written by Eggers et al. which runs on Sequent i386-based shared memory multiprocessor systems <ref> [2] </ref>. The generated trace is only a subset of the full execution trace to allow trace storage and to minimize time dilation during program execution. The latter is important for multiprocessor simulation which is the goal of MPtrace.
Reference: [3] <author> K. Flanagan, K. Grimsrud, J. Archibald, B. Nelson, BACH: </author> <title> BYU Address Collection Hardware, </title> <type> Technical Report TR-A150-92.1, </type> <institution> Dept. Of Electrical and Computer Engineering, Brigham Young University, </institution> <address> Provo, UT, </address> <month> Jan. </month> <year> 1992. </year>
Reference-contexts: An alternative approach is to add special processing and recording hardware to the system bus which monitors traffic and detects and saves selected events. BACH is an example of a i486-based tool which gathers traces in this manner <ref> [3] </ref>. While these methods present the fastest way to gather information, their speed can present a problem. A full address trace is difficult to gather and store because of the high data rate at which the references are produced.
Reference: [4] <author> M. Holliday, </author> <title> Techniques for Cache and Memory Simulation Using Address Reference Traces, </title> <journal> International Journal in Computer Simulation, </journal> <volume> Vol. 1, </volume> <pages> pp. 129-151, </pages> <year> 1991. </year>
Reference-contexts: The tools use affects the simulation and these effects must be taken into account and/or minimized. However, long continuous traces can be gathered easily and cheaply. An early approach to software monitoring was to use an OS trap on every instruction to record execution information <ref> [4] </ref>. This method is extremely slow and for instruction sets with a high density of memory references it is almost useless. A more common software approach is the use of a code instrumentation tool.
Reference: [5] <author> Intel Corp., </author> <title> i486 Microprocessor Programmers Reference Manual, </title> <year> 1990. </year>
Reference-contexts: If the line is copied from memory it is termed a memory prefetch. It can potentially increase performance by eliminating an instruction cache miss. Both the cache and prefetch buffer are updated on a memory prefetch. For more complete timing and memory system information see <ref> [5] </ref> and [6]. Table 6 shows the cycles required to run 10 million instructions of each benchmark for different cache configurations which bracket the on-chip cache found on the i486 (shown in bold in the table). Table 7 shows the combined statistics for all six benchmarks.
Reference: [6] <author> Intel Corp., </author> <title> i486 Microprocessor Hardware Reference Manual, </title> <year> 1990. </year>
Reference-contexts: If the line is copied from memory it is termed a memory prefetch. It can potentially increase performance by eliminating an instruction cache miss. Both the cache and prefetch buffer are updated on a memory prefetch. For more complete timing and memory system information see [5] and <ref> [6] </ref>. Table 6 shows the cycles required to run 10 million instructions of each benchmark for different cache configurations which bracket the on-chip cache found on the i486 (shown in bold in the table). Table 7 shows the combined statistics for all six benchmarks.
Reference: [7] <author> Kane, Gerry, </author> <title> MIPS R2000 RISC Architecture, </title> <publisher> Prentice Hall, </publisher> <address> Englewood, Cliffs, NJ, </address> <year> 1987. </year>
Reference: [8] <author> J. Larus, </author> <title> Abstract Execution: A Technique for Efficiently Tracing Programs, </title> <journal> Software Practice and Experience, </journal> <volume> Vol. 20, </volume> <pages> pp. 1241-1258, </pages> <month> December </month> <year> 1990. </year>
Reference-contexts: One advantage this approach has over assembly code modification is that the compiler can identify high-level code constructs and can use this knowledge to reduce the amount of instrumentation to construct a partial trace. Larus developed this approach for tool called AE <ref> [8] </ref>. A modified GNU C compiler generates instrumented code which upon execution will output a skeleton trace.
Reference: [9] <institution> MIPS Computer Systems, Inc., Language Programmers Guide, </institution> <year> 1986. </year>
Reference-contexts: At the very least, additional runtime overhead is likely to be incurred to overcome this loss. One of the earliest tools of this type is Pixie which runs on MIPS R3000-based systems <ref> [9] </ref>. It instruments an R3000 binary and produces a runable.pixie file. When the new binary is executed trace and statistics files are also generated. These files can be examined and various execution statistics generated by pixstats or fed into a cache simulator [15].
Reference: [10] <author> D. Nagle, R. Uhlig, T. Stanley, T. Mudge, S. Sechrest and R. Brown, </author> <title> Design Tradeoffs for Software-Managed TLBs, </title> <booktitle> Proc. of the 20th Annual International Symposium on Computer Architecture, </booktitle> <month> May </month> <year> 1993, </year> <pages> pp. 27-38. </pages>
Reference-contexts: Perhaps the most straightforward is to attach a logic analyzer to the processor pins or system bus, detect special situations, and use the analyzer to store these events. This approach was taken by Nagle et al. to measure TLB misses on a DECs-tation 3100 <ref> [10] </ref>. An alternative approach is to add special processing and recording hardware to the system bus which monitors traffic and detects and saves selected events. BACH is an example of a i486-based tool which gathers traces in this manner [3].
Reference: [11] <author> O.A. Olukotun, T.N. Mudge, and R.B. Brown, </author> <title> Implementing a cache for a high-performance GaAs microprocessor, </title> <booktitle> Proc. of the 18th Annual International Symposium on Computer Architecture, </booktitle> <month> May </month> <year> 1991, </year> <pages> pp. 138147 </pages>
Reference: [12] <author> J. Patel, </author> <title> How to Simulate 100 Billion Address References Cheaply?, </title> <booktitle> ISCA 90 Workshop on Processor Tracing Methodologies, </booktitle> <address> Seattle, WA, </address> <month> May </month> <year> 1990. </year>
Reference-contexts: It is also possible to use it in situations where trace sampling is considered sufficiently accurate <ref> [12] </ref>. Traces are produced by first instrumenting a program with IDtrace and then running it on an existing system. We noted above that hardware monitoring can give the most accurate and general traces. There are a number of ways of obtaining traces through hardware monitoring.
Reference: [13] <author> J. Pierce, IDtrace: </author> <title> A Trace Generation Tool for the ix86 Instruction Set, </title> <type> Technical report, </type> <institution> Intel Corp., Hillsboro, </institution> <address> OR, </address> <month> Sept. </month> <year> 1992. </year>
Reference: [14] <author> J. Quinlan, and K. Lai, Tynero: </author> <title> A Multiple Cache Simulator, </title> <type> Technical Report, </type> <institution> Intel Corp., Hillsboro, </institution> <address> OR, </address> <month> May </month> <year> 1991. </year>
Reference-contexts: The R3000 traces are generated by Pixie on a DECstation 5000 and the cache simulator used is a modified version of the multicache simulation tool, Tynero <ref> [14] </ref>. Table 8 shows some preliminary data in Cache Config. Cycles (M) Read Misses (K) Instr.
Reference: [15] <author> M. Smith, </author> <title> Tracing with Pixie, </title> <type> Technical Report, </type> <institution> Center for Integrated Systems, Stanford University. </institution>
Reference-contexts: It instruments an R3000 binary and produces a runable.pixie file. When the new binary is executed trace and statistics files are also generated. These files can be examined and various execution statistics generated by pixstats or fed into a cache simulator <ref> [15] </ref>. Pixie is compiler-independent and will instrument most but not all programs. One drawback of Pixie is that it suffers from significant runtime overhead. The reasons for this are described later. Another tool, Nixie, was written to reduce this overhead [18].
Reference: [16] <author> C. Stephens, B. Cogswell, J. Heinlein, G. Palmer, and J. Shen, </author> <title> Instruction Level Profiling and Evaluation of the IBM RS/6000, </title> <booktitle> Proc. of 18th Annual International Symposium on Computer Architecture, </booktitle> <address> Toronto, Canada, </address> <year> 1991, </year> <pages> pp. 180-189. </pages>
Reference-contexts: Sometimes these assumptions are incorrect and the modified program fails to run. In addition, many of assumptions are based on code sequences generated by a particular compiler thus making Nixie compiler dependent. Goblin is a tool similar to pixie built for the IBM RS/6000 architecture <ref> [16] </ref>. It instruments user code only and has been used for instruction mix, register liveness, and basic block statistical studies. Finally, Sun has a similar family of tracing tools for Sparc executables called Spixtools [17].
Reference: [17] <author> Sun Microsystems Laboratories, Inc., </author> <title> Introduction to SpixTools, </title> <type> Technical Report, </type> <institution> Mountain View, </institution> <address> CA, </address> <month> April </month> <year> 1992. </year>
Reference-contexts: Goblin is a tool similar to pixie built for the IBM RS/6000 architecture [16]. It instruments user code only and has been used for instruction mix, register liveness, and basic block statistical studies. Finally, Sun has a similar family of tracing tools for Sparc executables called Spixtools <ref> [17] </ref>. Despite the dominance of the ix86 family of architectures in the marketplace, a similar tool for it has not been widely available. We have created IDtrace to instrument ix86 programs at the executable level to allow low-cost and fast analysis of various architectural trade-offs.
Reference: [18] <author> D. Wall, </author> <title> Systems for Late Code Modification, </title> <institution> Digital Western Research Laboratory, Research Report, </institution> <month> June </month> <year> 1991. </year>
Reference-contexts: The module rewrite linker can perform intermodule register allocation, basic block counting and address trace generation, and instruction pipeline scheduling. Code and data relocation is done as described above. Another tool, Epoxie, relies on incremental linking which produces an executable containing a combined relocation dictionary and symbol table <ref> [18] </ref>. Its advantages over Mahler are that the standard linker can be used and data sections remain fixed so data relocation is not necessary. Epoxie produces address traces and block statistics. <p> This is referred to as late code modification <ref> [18] </ref>. Its virtue is its ease of use. It is now trivial for the user to collect trace and other runtime information. In principle, any binary can be instrumented with such a tool without the user knowing anything about the assembly code constructs or compilation process. <p> Pixie is compiler-independent and will instrument most but not all programs. One drawback of Pixie is that it suffers from significant runtime overhead. The reasons for this are described later. Another tool, Nixie, was written to reduce this overhead <ref> [18] </ref>. It is functionally equivalent to Pixie on a restricted set of programs. Nixie makes various assumptions about code structure to improve performance and reduce modified code size. Sometimes these assumptions are incorrect and the modified program fails to run.
Reference: [19] <author> D. Wall, </author> <title> Link-Time Code Modification, </title> <institution> Digital Western Research Laboratory, </institution> <note> Research Report 89/ 17, </note> <month> Sept. </month> <year> 1989. </year>
Reference-contexts: There are several tools which perform link-time modification. Mahler is a back-end code generator and linker for Titan, a DECWRL experimental workstation <ref> [19] </ref>. The module rewrite linker can perform intermodule register allocation, basic block counting and address trace generation, and instruction pipeline scheduling. Code and data relocation is done as described above. Another tool, Epoxie, relies on incremental linking which produces an executable containing a combined relocation dictionary and symbol table [18].
References-found: 19

