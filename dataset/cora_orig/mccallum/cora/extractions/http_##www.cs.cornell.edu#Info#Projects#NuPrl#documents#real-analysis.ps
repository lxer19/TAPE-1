URL: http://www.cs.cornell.edu/Info/Projects/NuPrl/documents/real-analysis.ps
Refering-URL: http://www.cs.cornell.edu/Info/Projects/NuPrl/html/publication.html
Root-URL: 
Email: forester@cs.cornell.edu  
Title: Formalizing Constructive Real Analysis  
Author: Max B. Forester 
Date: July 16, 1993  
Affiliation: Department of Computer Science Cornell University  
Abstract: This paper arises from a project with the Nuprl Proof Development System which involved formalizing parts of real analysis, up through the intermediate value theorem. Extensive development of the rational library was required as the real library was being built, resulting in the addition of about 125 rational theorems. The real library now contains about 150 theorems and includes enough basic results that further extensions of the library should be quite feasible. This paper aims to illustrate how higher mathematics can be implemented in a system like Nuprl, and also to introduce system users to the library.
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> E. Bishop. </author> <title> Foundations of Constructive Analysis. </title> <publisher> McGraw-Hill, </publisher> <address> New York, </address> <year> 1967. </year> <note> REFERENCES 24 </note>
Reference-contexts: Users interested in developing theories in analysis should find both sections helpful. 2 Real Analysis in Nuprl 2.1 Definitions In formalizing real analysis we follow the development of Bishop <ref> [1] </ref>. Real numbers are represented by infinite sequences of rationals, which are required to converge at a certain rate. <p> lemmas to which they refer. * ML case split let CaseSplit = ni.(if (i=0) then (IfThenElseCases 0 THENM RW bool to propC (-1) THENA Auto) else (IfThenElseCases i THENM RW bool to propC i THENA Auto)) ;; * ML qnd eval let qnd evalC = UnfoldsTopC ``qnumer qdenom`` ANDTHENC AddrC <ref> [1] </ref> (UnfoldTopC `qnum`) ANDTHENC (pi1 evalC ORELSEC pi2 evalC) ;; * ML expon unroll let expon unrollC = FwdMacroC `expon unrollC` (UnfoldC `expon` ANDTHENC HigherC YUnrollC ANDTHENC UnfoldC `expon gen` ANDTHENC ReduceC ANDTHENC FoldC `expon gen` ANDTHENC FoldC `expon` A TACTIC CODE 18 ) ;; * ML expand defs let lt <p> let rev convert relC = TryC (FirstC (map RevLemmaC ``ri eq q ri lt q ri le q``) ) * ML int to rat let int to ratC = rev convert relC ANDTHENC HigherC spread numerC ;; let RAuto = Auto THEN np.((if is equal term (concl p) then (UnfoldAtAddr <ref> [1] </ref> 0 THEN SAuto) else Id) p) ;; let PosHD = ni.(Unfold `pos` i THEN Unfold `exists sq` i THEN AbSetHD i) ;; let PosCD t = Unfold `pos` 0 THEN Unfold `exists sq` 0 THEN (Refine `dependent set memberFormation` [mk level exp arg (mk level exp [`i`,0]); mk term arg
Reference: [2] <author> D. S. </author> <title> Bridges. Constructive Functional Analysis. </title> <publisher> Pitman, </publisher> <address> London, </address> <year> 1979. </year>
Reference-contexts: `rmax evalC` 'maxfa,bg n' 'maxf (a n),(b n)g' ``rmax`` ;; let rmul gen evalC = SimpleMacroC `rmul gen evalC` 'a * b n' '((a (2 * (Ka * n))) * (b (2 * (Ka * n))))' ``rmul gen`` ;; let rsub evalC = MacroC `rsub evalC` (AllC [UnfoldC `rsub`;radd evalC;AddrC <ref> [2] </ref> rneg evalC]) 'a -r b n' (UnfoldC `qsub`) 'a (2 * n) - b (2 * n)' ;; let rabsval evalC = MacroC `rabsval evalC` (AllC [UnfoldC `rabsval`;rmax evalC;AddrC [2] rneg evalC]) '|a| n' (UnfoldC `qabsval`) '|a n|' ;; let real apply evalC = (SweepDnC (FirstC [rabsval evalC;rmax evalC;rmul gen <p> (b (2 * (Ka * n))))' ``rmul gen`` ;; let rsub evalC = MacroC `rsub evalC` (AllC [UnfoldC `rsub`;radd evalC;AddrC <ref> [2] </ref> rneg evalC]) 'a -r b n' (UnfoldC `qsub`) 'a (2 * n) - b (2 * n)' ;; let rabsval evalC = MacroC `rabsval evalC` (AllC [UnfoldC `rabsval`;rmax evalC;AddrC [2] rneg evalC]) '|a| n' (UnfoldC `qabsval`) '|a n|' ;; let real apply evalC = (SweepDnC (FirstC [rabsval evalC;rmax evalC;rmul gen evalC; rsub evalC;rneg evalC;radd evalC]) ANDTHENC TryC (UnfoldC `real rat` ANDTHENC ReduceC)) ;; Again we use some more visible notation. a is the real number i.a. * THM rr qadd
Reference: [3] <author> F. Brown, J. Chirimar and D. J. Howe, </author> <title> unpublished Nuprl libraries. </title>
Reference-contexts: positive epsilon we can do almost as well. * THM pos quasi decidable 8a:R. 8*:R + . a &lt; * _ a &gt; 0 2.4 The Intermediate Value Theorem Our implementation of the intermediate value theorem uses the bisection method, and follows the proof outline given in an earlier system <ref> [3] </ref>.
Reference: [4] <author> J. Chirimar and D. J. Howe. </author> <title> Implementing Constructive Real Analysis: A Preliminary Report. </title> <booktitle> In Symposium on Constructivity in Computer Science, Lecture Notes in Computer Science, </booktitle> <publisher> Springer Verlag, </publisher> <year> 1991. </year>
Reference: [5] <author> R. L. Constable, et al. </author> <title> Implementing Mathematics with the Nuprl Proof Development System. </title> <publisher> Prentice-Hall, </publisher> <address> Englewood Cliffs, New Jersey, </address> <year> 1986. </year>
Reference: [6] <author> W. M. Farmer and F. J. Thayer, </author> <title> Two Computer-Supported Proofs in Metric Space Topology, </title> <journal> Notices of the AMS, Nov 1991, </journal> <volume> Vol. 38, number 9, </volume> <pages> pp. 1133-1138. </pages>
Reference: [7] <author> J. Harrison, </author> <title> Constructing the real numbers in Higher Order Logic. </title>
Reference: [8] <author> J. Harrison and L. Thery, </author> <title> Extending the HOL theorem prover with a Computer Algebra System to Reason about the Reals. </title>
Reference: [9] <author> J. T. Udding, </author> <title> A Theory of Real Numbers and its Presentation in AUTOMATH, Vol. I-III, </title> <type> Master's Thesis, </type> <institution> Eindhoven University of Technology, </institution> <year> 1980. </year>
Reference-contexts: (x)) - (f (y))| *) 2 REAL ANALYSIS IN NUPRL 9 &gt;> 9c:[a,b]. |f (c)| &lt; * BY D 5 THENM With '*' (D 6) THENM D (-1) THENA Auto n 9. w (*) &gt; 0 &gt;> 9c:[a,b]. |f (c)| &lt; * BY Using [`b','b a'] (FwdThruLemma `halving to zero` <ref> [9] </ref>) THENM D (-1) THENA Auto n 12. 1/2^n * b a &lt; w (*) | BY InstLemma `bisection induction` ['a';'b';'f';'*';'n'] THENM Unfold `bisects` (-1) THENA Auto n | (9ff:[a,b]. 9fi:[a,b]. fi - ff = 1/2^n * b a^ &gt;> 9c:[a,b]. |f (c)| &lt; * BY D 13 THEN Auto %
References-found: 9

