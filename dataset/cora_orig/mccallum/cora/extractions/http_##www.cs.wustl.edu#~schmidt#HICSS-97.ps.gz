URL: http://www.cs.wustl.edu/~schmidt/HICSS-97.ps.gz
Refering-URL: http://www.cs.wustl.edu/~nanbor/cgi-bin/ace-cvs.cgi/ACE_wrappers/TAO/docs/releasenotes/index.html?r1=1.6&r2=1.7
Root-URL: 
Email: gokhale@cs.wustl.edu and schmidt@cs.wustl.edu  
Title: Principles for Optimizing CORBA Internet Inter-ORB Protocol Performance  
Author: Aniruddha Gokhale and Douglas C. Schmidt 
Address: St. Louis, MO 63130, USA 1  
Affiliation: Department of Computer Science, Washington University  
Abstract: This paper appeared in the Proceedings of the HICSS conference, Maui, Hawaii, January 9th, 1998. It was selected as the best paper in the Software Technology Track (188 submitted, 77 accepted). Abstract The Internet Inter-ORB Protocol (IIOP) enables heterogeneous CORBA-compliant Object Request Brokers (ORBs) to interoperate over TCP/IP networks. IIOP uses the Common Data Representation (CDR) transfer syntax to map OMG Interface Definition Language (IDL) data types into a portable network format. Due to the excessive marshaling/demarshaling overhead, data copying, and high-levels of function call overhead, conventional IIOP implementations yield relatively poor performance over high-speed networks. To meet the demands of emerging distributed multimedia applications, however, CORBA-compliant ORBs must support interoperable and highly efficient IIOP implementations. This paper provides two contributions to the study and design of efficient IIOP implementations. First, we pinpoint the key sources of overhead in the SunSoft IIOP implementation, which is a publically available implementation of IIOP written in C++, and measure its performance for transferring richly-typed data over a high-speed ATM network. Second, we demonstrate the empirical benefits of systematically optimizing SunSoft IIOP by optimizing for the common case; eliminating gratuitous waste; replacing general purpose methods with specialized, efficient ones; precomputing values; storing redundant state to speed up expensive operations; passing information between layers; and optimizing for better processor cache performance. The results of optimizing SunSoft IIOP improved its performance substantially for all data types. The resulting IIOP implementation is competitive with existing commercial ORBs using CORBA's static invocation interface and 2 to 4.5 times (depending on the data type) faster than commercial ORBs using the dynamic skeleton interface. We have integrated the optimized IIOP implementation into TAO, which is a CORBA ORB targeted for real-time systems. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> M. Abbott and L. Peterson. </author> <title> Increasing Network Throughput by Integrating Protocol Layers. </title> <journal> ACM Transactions on Networking, </journal> <volume> 1(5), </volume> <month> October </month> <year> 1993. </year>
Reference-contexts: The optimizations reported in [4] are based on Principle 1, which optimizes for the common case and Principle 3, which is precompute, if possible. We present the results of applying these principles to optimize IIOP in Sections 3.2.3, 3.2.4, and 3.2.5. <ref> [5, 1, 3] </ref> describe the application of an optimization mechanism called Integrated Layer Processing (ILP). ILP is based on the observation that data manipulation loops that operate on the same protocol data are wasteful and expensive.
Reference: [2] <author> Mary L. Bailey, Burra Gopal, Prasenjit Sarkar, Michael A. Pagels, and Larry L. Peterson. Pathfinder: </author> <title> A pattern-based packet classifier. </title> <booktitle> In Proceedings of the 1 st Symposium on Operating System Design and Implementation. USENIX Association, </booktitle> <month> November </month> <year> 1994. </year>
Reference-contexts: We demonstrate the application of this principle to IIOP in Section 3.2.4 where we eliminated unnecessary calls to the deep free method, which frees primitive data types. [3] cautions against improper use of ILP since this may increase processor cache misses. Packet filters <ref> [18, 2, 8] </ref> are a classic example of Principle 6, which recommends passing information between layers. Analysis for doubles Analysis for BinStructs Analysis for doubles Analysis for BinStructs A packet filter demultiplexes incoming packets to the appropriate target application (s).
Reference: [3] <author> Torsten Braun and Christophe Diot. </author> <title> Protocol Implementation Using Integrated Layer Processnig. </title> <booktitle> In Proceedings of the Symposium on Communications Architectures and Protocols (SIGCOMM). ACM, </booktitle> <month> September </month> <year> 1995. </year>
Reference-contexts: The optimizations reported in [4] are based on Principle 1, which optimizes for the common case and Principle 3, which is precompute, if possible. We present the results of applying these principles to optimize IIOP in Sections 3.2.3, 3.2.4, and 3.2.5. <ref> [5, 1, 3] </ref> describe the application of an optimization mechanism called Integrated Layer Processing (ILP). ILP is based on the observation that data manipulation loops that operate on the same protocol data are wasteful and expensive. <p> The ILP optimization scheme is based on Principle 2, which gets rid of gratuitous waste. We demonstrate the application of this principle to IIOP in Section 3.2.4 where we eliminated unnecessary calls to the deep free method, which frees primitive data types. <ref> [3] </ref> cautions against improper use of ILP since this may increase processor cache misses. Packet filters [18, 2, 8] are a classic example of Principle 6, which recommends passing information between layers.
Reference: [4] <author> David D. Clark, Van Jacobson, John Romkey, and Howard Salwen. </author> <title> An Analysis of TCP Processing Overhead. </title> <journal> IEEE Communications Magazine, </journal> <volume> 27(6):2329, </volume> <month> June </month> <year> 1989. </year>
Reference-contexts: In addition, we discuss related work on CORBA performance measurements and presentation layer marshaling. Related work based on optimization principles: <ref> [4] </ref> describes a technique called header prediction that predicts the message header of incoming TCP packets. This technique is based on the observation that many members in the header remaining constant between consecutive packets. This observation led to the creation of a template for the expected packet header. <p> This technique is based on the observation that many members in the header remaining constant between consecutive packets. This observation led to the creation of a template for the expected packet header. The optimizations reported in <ref> [4] </ref> are based on Principle 1, which optimizes for the common case and Principle 3, which is precompute, if possible.
Reference: [5] <author> David D. Clark and David L. Tennenhouse. </author> <title> Architectural Considerations for a New Generation of Protocols. </title> <booktitle> In Proceedings of the Symposium on Communications Architectures and Protocols (SIGCOMM), pages 200208, </booktitle> <address> Philadelphia, PA, </address> <month> September </month> <year> 1990. </year> <note> ACM. </note>
Reference-contexts: obtain an optimal ILP Data Type Analysis Method Name msec Called % double read 3,413 4,665 54.93 TypeCode::traverse 2,747 1,539 44.21 BinStruct TypeCode::traverse 27,976 4,195,331 91.94 TypeCode:: 1,151 4,201,475 3.78 typecode param Table 3: Receiver-side Overhead After Applying the Second Optimization (getting rid of waste and precomputation) (Integrated Layer Processing) <ref> [5] </ref> implementation of the interpreter. An ILP-based implementation can reduce the excessive data manipulation operations, which is essential to optimize RISC architectures. <p> The optimizations reported in [4] are based on Principle 1, which optimizes for the common case and Principle 3, which is precompute, if possible. We present the results of applying these principles to optimize IIOP in Sections 3.2.3, 3.2.4, and 3.2.5. <ref> [5, 1, 3] </ref> describe the application of an optimization mechanism called Integrated Layer Processing (ILP). ILP is based on the observation that data manipulation loops that operate on the same protocol data are wasteful and expensive.
Reference: [6] <author> Peter Druschel and Larry L. Peterson. Fbufs: </author> <title> A High-Bandwidth Cross-Domain Transfer Facility. </title> <booktitle> In Proceedings of the 14 th Symposium on Operating System Principles (SOSP), </booktitle> <month> December </month> <year> 1993. </year>
Reference-contexts: We applied Principle 6 for IIOP in Section 3.2.4 where we passed the TypeCode information and size of the element type of a sequence to the TypeCode interpreter. Therefore, the interpreter need not calculate the same quantities repeatedly. <ref> [6] </ref> describes a facility called fast buffers (FBUFS). FBUFS combines virtual page remapping with shared virtual memory to reduce unnecessary data copying and achieve high throughput.
Reference: [7] <author> Eric Eide, Kevin Frei, Bryan Ford, Jay Lepreau, and Gary Lindstrom. Flick: </author> <title> A Flexible, Optimizing IDL Compiler. </title> <booktitle> In Proceedings of ACM SIGPLAN '97 Conference on Programming Language Design and Implementation (PLDI), </booktitle> <address> Las Ve-gas, NV, </address> <month> June </month> <year> 1997. </year> <note> ACM. </note>
Reference-contexts: Conversely, skeletons demarshal the packet-level representation back into typed data that is meaningful to an application. An IDL compiler automatically transforms OMG IDL definitions into an application programming language like C++ or Java. IDL compilers eliminate common sources of network programming errors and provide opportunities for automated compiler optimizations <ref> [7] </ref>. Dynamic Invocation Interface (DII): The DII allows a client to access the underlying request transport mechanisms provided by the ORB Core. The DII is useful when an application has no compile-time knowledge of the interface it is accessing. <p> As explained in Section 5, we are currently implementing a CORBA IDL compiler [13] that can generate compiled stubs and skeletons. Our goal is to generate efficient stubs and skeletons by extending optimizations provided in USC [23] and Flick <ref> [7] </ref>, which is a flexible, optimizing IDL compiler. Flick uses an innovative scheme where intermediate representations guide the generation of optimized stubs.
Reference: [8] <author> Dawson R. Engler and M. Frans Kaashoek. DPF: </author> <title> Fast, Flexible Message Demultiplexing using Dynamic Code Generation. </title> <booktitle> In Proceedings of ACM SIGCOMM '96 Conference in Computer Communication Review, </booktitle> <pages> pages 5359, </pages> <institution> Stanford University, California, USA, </institution> <month> August </month> <year> 1996. </year> <note> ACM Press. </note>
Reference-contexts: Appendix C examines the run-time behavior of SunSoft IIOP by tracing the path taken by requests that transmit the sequence of BinStructs shown below: // BinStruct is 32 bytes (including padding). struct BinStruct - short s; char c; long l; octet o; double d; octet pad <ref> [8] </ref> -; // Richly typed data. interface ttcp_throughput - typedef sequence&lt;BinStruct&gt; StructSeq; // similarly for the rest of the types // Methods to send various data type sequences. oneway void sendStructSeq (in StructSeq ts); // similarly for rest of the types -; 3 Experimental Results of CORBA IIOP over ATM 3.1 <p> We demonstrate the application of this principle to IIOP in Section 3.2.4 where we eliminated unnecessary calls to the deep free method, which frees primitive data types. [3] cautions against improper use of ILP since this may increase processor cache misses. Packet filters <ref> [18, 2, 8] </ref> are a classic example of Principle 6, which recommends passing information between layers. Analysis for doubles Analysis for BinStructs Analysis for doubles Analysis for BinStructs A packet filter demultiplexes incoming packets to the appropriate target application (s).
Reference: [9] <author> Aniruddha Gokhale and Douglas C. Schmidt. </author> <title> Measuring the Performance of Communication Middleware on High-Speed Networks. </title> <booktitle> In Proceedings of SIGCOMM '96, </booktitle> <pages> pages 306317, </pages> <address> Stanford, CA, </address> <month> August </month> <year> 1996. </year> <note> ACM. </note>
Reference-contexts: Specialized mappings of GIOP can be defined for particular transport protocols. One such mapping is called the Internet Inter-ORB Protocol (IIOP), which is the standard GIOP mapping IIOP is the standard for interoperability for distributed object computing over TCP/IP. <ref> [9, 10, 11] </ref> show that the performance of conventional CORBA middleware implementations is relatively poor compared to lower-level implementations using sockets and C/C++ since the ORBs incur a significant amount of data copying, marshaling, demarshaling, and demultiplexing overhead. These results, however, focused entirely on the communication performance between homogeneous ORBs. <p> In addition, earlier work on measuring CORBA performance did not present the results of optimizations to reduce key sources of ORB overhead. In this paper, we measure the performance of SunSoft IIOP using a CORBA/ATM testbed environment similar to <ref> [9, 10, 11] </ref>. SunSoft IIOP is a freely available implementation of the iiop protocol. We measure the performance of SunSoft IIOP and precisely pinpoint its performance overheads. In addition, we describe the results of systemati cally applying seven principle-driven optimizations [26] that substantially improve the performance of SunSoft IIOP. <p> Our optimized version of SunSoft IIOP is now comparable to existing commercial ORBs <ref> [9, 10, 11] </ref> using the static invocation interface (SII) and around 2 to 4.5 times (depending on the data type) faster than commercial ORBs using the dynamic skeleton interface (DSI). <p> Optimizing such software is hard, particularly since seemingly minor mistakes, such as excessive data copying or dynamic allocation, can reduce performance significantly <ref> [9] </ref>. Therefore, developing high performance and predictable ORBs requires an iterative, multi-step process. The first step involves measuring the performance of the system and pinpointing the sources of overhead. The second step involves a careful analysis of these sources of overhead and application of optimizations to remove them. <p> We describe optimizatons for processor cache in Section 3.2.5. Related work on CORBA performance measurements: <ref> [9, 10, 11] </ref> show that the performance of CORBA middle-ware implementations is relatively poor, compared to lower level implementations using C/C++. <p> We describe optimizatons for processor cache in Section 3.2.5. Related work on CORBA performance measurements: [9, 10, 11] show that the performance of CORBA middle-ware implementations is relatively poor, compared to lower level implementations using C/C++. The primary source of ORB-level overhead stems from marshaling and demarshal-ing. <ref> [9] </ref> measures the performance of the static invocation interface. [10] measures the performance of the dynamic invocation interface and the dynamic skeleton interface. [11] measures performance of CORBA implementations in terms of latency and support for very large number of objects. <p> Our optimized implementation is now competitive with existing commercial ORBs <ref> [9, 11] </ref> using the static invocation interface (SII) and 2 to 4.5 times (depending on the data type) faster than commercial ORBs using the dynamic skeleton interface (DSI) [10].
Reference: [10] <author> Aniruddha Gokhale and Douglas C. Schmidt. </author> <title> The Performance of the CORBA Dynamic Invocation Interface and Dynamic Skeleton Interface over High-Speed ATM Networks. </title> <booktitle> In Proceedings of GLOBECOM '96, </booktitle> <pages> pages 5056, </pages> <address> London, England, </address> <month> November </month> <year> 1996. </year> <note> IEEE. </note>
Reference-contexts: Specialized mappings of GIOP can be defined for particular transport protocols. One such mapping is called the Internet Inter-ORB Protocol (IIOP), which is the standard GIOP mapping IIOP is the standard for interoperability for distributed object computing over TCP/IP. <ref> [9, 10, 11] </ref> show that the performance of conventional CORBA middleware implementations is relatively poor compared to lower-level implementations using sockets and C/C++ since the ORBs incur a significant amount of data copying, marshaling, demarshaling, and demultiplexing overhead. These results, however, focused entirely on the communication performance between homogeneous ORBs. <p> In addition, earlier work on measuring CORBA performance did not present the results of optimizations to reduce key sources of ORB overhead. In this paper, we measure the performance of SunSoft IIOP using a CORBA/ATM testbed environment similar to <ref> [9, 10, 11] </ref>. SunSoft IIOP is a freely available implementation of the iiop protocol. We measure the performance of SunSoft IIOP and precisely pinpoint its performance overheads. In addition, we describe the results of systemati cally applying seven principle-driven optimizations [26] that substantially improve the performance of SunSoft IIOP. <p> Our optimized version of SunSoft IIOP is now comparable to existing commercial ORBs <ref> [9, 10, 11] </ref> using the static invocation interface (SII) and around 2 to 4.5 times (depending on the data type) faster than commercial ORBs using the dynamic skeleton interface (DSI). <p> We describe optimizatons for processor cache in Section 3.2.5. Related work on CORBA performance measurements: <ref> [9, 10, 11] </ref> show that the performance of CORBA middle-ware implementations is relatively poor, compared to lower level implementations using C/C++. <p> Related work on CORBA performance measurements: [9, 10, 11] show that the performance of CORBA middle-ware implementations is relatively poor, compared to lower level implementations using C/C++. The primary source of ORB-level overhead stems from marshaling and demarshal-ing. [9] measures the performance of the static invocation interface. <ref> [10] </ref> measures the performance of the dynamic invocation interface and the dynamic skeleton interface. [11] measures performance of CORBA implementations in terms of latency and support for very large number of objects. <p> Our optimized implementation is now competitive with existing commercial ORBs [9, 11] using the static invocation interface (SII) and 2 to 4.5 times (depending on the data type) faster than commercial ORBs using the dynamic skeleton interface (DSI) <ref> [10] </ref>. The results of our optimizations provide sufficient proof that performance of complex distributed systems software can be improved by a systematic application of principle-driven optimizations.
Reference: [11] <author> Aniruddha Gokhale and Douglas C. Schmidt. </author> <title> Evaluating Latency and Scalability of CORBA Over High-Speed ATM Networks. </title> <booktitle> In Proceedings of the International Conference on Distributed Computing Systems, </booktitle> <address> Baltimore, Maryland, </address> <month> May </month> <year> 1997. </year> <note> IEEE. </note>
Reference-contexts: Specialized mappings of GIOP can be defined for particular transport protocols. One such mapping is called the Internet Inter-ORB Protocol (IIOP), which is the standard GIOP mapping IIOP is the standard for interoperability for distributed object computing over TCP/IP. <ref> [9, 10, 11] </ref> show that the performance of conventional CORBA middleware implementations is relatively poor compared to lower-level implementations using sockets and C/C++ since the ORBs incur a significant amount of data copying, marshaling, demarshaling, and demultiplexing overhead. These results, however, focused entirely on the communication performance between homogeneous ORBs. <p> In addition, earlier work on measuring CORBA performance did not present the results of optimizations to reduce key sources of ORB overhead. In this paper, we measure the performance of SunSoft IIOP using a CORBA/ATM testbed environment similar to <ref> [9, 10, 11] </ref>. SunSoft IIOP is a freely available implementation of the iiop protocol. We measure the performance of SunSoft IIOP and precisely pinpoint its performance overheads. In addition, we describe the results of systemati cally applying seven principle-driven optimizations [26] that substantially improve the performance of SunSoft IIOP. <p> Our optimized version of SunSoft IIOP is now comparable to existing commercial ORBs <ref> [9, 10, 11] </ref> using the static invocation interface (SII) and around 2 to 4.5 times (depending on the data type) faster than commercial ORBs using the dynamic skeleton interface (DSI). <p> We describe optimizatons for processor cache in Section 3.2.5. Related work on CORBA performance measurements: <ref> [9, 10, 11] </ref> show that the performance of CORBA middle-ware implementations is relatively poor, compared to lower level implementations using C/C++. <p> The primary source of ORB-level overhead stems from marshaling and demarshal-ing. [9] measures the performance of the static invocation interface. [10] measures the performance of the dynamic invocation interface and the dynamic skeleton interface. <ref> [11] </ref> measures performance of CORBA implementations in terms of latency and support for very large number of objects. However, the results of earlier CORBA benchmarking experiments were restricted to measuring the performance of communication between homogeneous ORBs. <p> Our optimized implementation is now competitive with existing commercial ORBs <ref> [9, 11] </ref> using the static invocation interface (SII) and 2 to 4.5 times (depending on the data type) faster than commercial ORBs using the dynamic skeleton interface (DSI) [10].
Reference: [12] <author> Aniruddha Gokhale and Douglas C. Schmidt. </author> <title> Evaluating the Performance of Demultiplexing Strategies for Real-time CORBA. </title> <booktitle> In Proceedings of GLOBECOM '97, </booktitle> <address> Phoenix, AZ, </address> <month> November </month> <year> 1997. </year> <note> IEEE. </note>
Reference-contexts: TAO's request demulti-plexing and dispatching process provides different strategies to demultiplex requests to skeletons, including linear search, dynamic hashing or perfect hashing of operation names, or direct demultiplexing <ref> [12] </ref>.
Reference: [13] <author> Aniruddha Gokhale, Douglas C. Schmidt, and Stan Moyer. </author> <title> Tools for Automating the Migration from DCE to CORBA. </title> <booktitle> In Proceedings of ISS 97: World Telecommunications Congress, </booktitle> <address> Toronto, Canada, </address> <month> September </month> <year> 1997. </year> <journal> IEEE Communications Society. </journal>
Reference-contexts: According to the SunSoft IIOP developers, interpretive marshaling is preferable since it decreases code size and increases the likelihood of remaining in the processor cache. As explained in Section 5, we are currently implementing a CORBA IDL compiler <ref> [13] </ref> that can generate compiled stubs and skeletons. Our goal is to generate efficient stubs and skeletons by extending optimizations provided in USC [23] and Flick [7], which is a flexible, optimizing IDL compiler. Flick uses an innovative scheme where intermediate representations guide the generation of optimized stubs.
Reference: [14] <author> Timothy H. Harrison, David L. Levine, and Douglas C. Schmidt. </author> <title> The Design and Performance of a Real-time CORBA Event Service. </title> <booktitle> In Proceedings of OOPSLA '97, </booktitle> <address> At-lanta, GA, </address> <month> October </month> <year> 1997. </year> <note> ACM. </note>
Reference-contexts: We plan to measure the tradeoffs of using the two marshaling schemes to achieve an optimal hybrid solution [15]. In addition, we have incorporated an Real-time Object Adapter <ref> [14] </ref> that supports de-layered active request demul-tiplexing and rate monotonic scheduling and dispatching of client requests into TAO. SunSoft IIOP does not provide a standard CORBA Object Adapter.
Reference: [15] <author> Phillip Hoschka and Christian Huitema. </author> <title> Automatic Generation of Optimized Code for Marshalling Routines. </title> <booktitle> In IFIP Conference of Upper Layer Protocols, Architectures and Applications ULPAA'94, </booktitle> <address> Barcelona, Spain, 1994. </address> <publisher> IFIP. </publisher>
Reference-contexts: An ILP-based implementation can reduce the excessive data manipulation operations, which is essential to optimize RISC architectures. Another technique to improve overall marshaling performance is to use a hybrid scheme <ref> [15] </ref> in which frequently transferred data types can be marshaled using fast, but large compiled stubs. In contrast, an interpretive scheme can be used to marshal data types that are seldom transferred. <p> Thus, in this scheme there is no necessity to decipher the type of the data to be marshaled at run-time. Instead, the type is known in advance, which can be used to marshal the data directly. <ref> [15] </ref> describes the tradeoffs of using compiled and inter preted marshaling schemes. Although compiled stubs are faster, they are also larger. In contrast, interpretive marshaling is slower, but smaller in size. [15] describes a hybrid scheme that combines compiled and interpretive marshaling to achieve better performance. <p> Instead, the type is known in advance, which can be used to marshal the data directly. <ref> [15] </ref> describes the tradeoffs of using compiled and inter preted marshaling schemes. Although compiled stubs are faster, they are also larger. In contrast, interpretive marshaling is slower, but smaller in size. [15] describes a hybrid scheme that combines compiled and interpretive marshaling to achieve better performance. This work was done in the context of the ASN.1/BER encoding [17]. <p> TAO is being used to compare the impact of using compiled marshaling stubs and skeletons vs. the interpretive scheme currently implemented in SunSoft IIOP. We plan to measure the tradeoffs of using the two marshaling schemes to achieve an optimal hybrid solution <ref> [15] </ref>. In addition, we have incorporated an Real-time Object Adapter [14] that supports de-layered active request demul-tiplexing and rate monotonic scheduling and dispatching of client requests into TAO. SunSoft IIOP does not provide a standard CORBA Object Adapter.
Reference: [16] <author> PureAtria Software Inc. </author> <title> Quantify User's Guide. </title> <institution> PureAtria Software Inc., </institution> <year> 1996. </year>
Reference-contexts: These buffers were repeatedly sent until a total of 64 Mbytes of data was transmitted. 3.1.3 Profiling Tools The profile information for the empirical analysis was obtained using the Quantify <ref> [16] </ref> performance measurement tool. Quantify analyzes performance bottlenecks and identifies sections of code that dominate execution time. Unlike traditional sampling-based profilers (such as the UNIX gprof tool), Quantify reports results without including its own overhead.
Reference: [17] <author> International Organization for Standardization. </author> <title> Information processing systems Open Systems Interconnection Specification of Basic Encoding Rules for Abstract Syntax No tation One (ASN.1), </title> <month> May </month> <year> 1987. </year>
Reference-contexts: Although compiled stubs are faster, they are also larger. In contrast, interpretive marshaling is slower, but smaller in size. [15] describes a hybrid scheme that combines compiled and interpretive marshaling to achieve better performance. This work was done in the context of the ASN.1/BER encoding <ref> [17] </ref>. According to the SunSoft IIOP developers, interpretive marshaling is preferable since it decreases code size and increases the likelihood of remaining in the processor cache. As explained in Section 5, we are currently implementing a CORBA IDL compiler [13] that can generate compiled stubs and skeletons.
Reference: [18] <author> Steven McCanne and Van Jacobson. </author> <title> The BSD Packet Filter: </title>
Reference-contexts: We demonstrate the application of this principle to IIOP in Section 3.2.4 where we eliminated unnecessary calls to the deep free method, which frees primitive data types. [3] cautions against improper use of ILP since this may increase processor cache misses. Packet filters <ref> [18, 2, 8] </ref> are a classic example of Principle 6, which recommends passing information between layers. Analysis for doubles Analysis for BinStructs Analysis for doubles Analysis for BinStructs A packet filter demultiplexes incoming packets to the appropriate target application (s).
References-found: 18

