URL: http://www.isse.gmu.edu:80/~csis/publications/mlstp-survey.ps
Refering-URL: http://www.isse.gmu.edu:80/~csis/publication.html
Root-URL: 
Email: atluri@andromeda.rutgers.edu  jajodia@gmu.edu  keefe@cse.psu.edu  mccollum@mitre.org  mukka@cs.odu.edu  
Phone: 2  3  4  5  
Title: Multilevel Secure Transaction Processing: Status and Prospects  
Author: Vijayalakshmi Atluri Sushil Jajodia Thomas F. Keefe Catherine McCollum and Ravi Mukkamala 
Address: NJ 07102, USA.  22030-4444, USA.  Park, PA 16802, USA.  1820 Dolley Madison Boulevard, McLean, VA 22102-3481, USA.  Norfolk, VA 23529-0162, USA.  
Affiliation: 1 Rutgers University MS/CIS Department, Newark,  George Mason University Center for Secure Information Systems and Department of Information and Software Systems Engineering, Fairfax, VA  Pennsylvania State University Department of Computer Science, University  The MITRE Corporation  Old Dominion University Department of Computer Science,  
Abstract: Since 1990, transaction processing in multilevel secure database management systems (DBMSs) has been receiving a great deal of attention from the database research community. Transaction processing in these systems requires modification of conventional scheduling algorithms and commit protocols. These modifications are necessary because preserving the usual transaction properties when transactions are executing at different security levels often conflicts with the enforcement of the security policy. Considerable effort has been devoted to the development of efficient, secure algorithms for the major types of secure DBMS architectures: kernelized, replicated, and distributed. An additional problem that arises uniquely in multilevel secure DBMSs 
Abstract-found: 1
Intro-found: 1
Reference: <institution> Air Force Studies Board (1983), Multilevel Data Management Security, National Research Council, National Academy Press, </institution> <address> Washington, DC. </address>
Reference-contexts: Thus, only very primitive handling of broken lock exceptions is possible at the application program level. 8 Multilevel Secure Transaction Processing: Status and Prospects 4.2 Research Solutions Concurrency Control for the Replicated Architecture. The replication-based approach <ref> (Air Force Studies Board 1983) </ref> provides an elegant way of reusing existing technology. The idea is to construct an MLS DBMS from single-level DBMSs. The DBMS at level l contains a replica of every data item that a subject at level l can access. <p> Thus, the system cannot respond effectively to dynamic workload variations. Concurrency Control for the Kernelized Architecture. To improve the situation, it is necessary to share resources (e.g., memory, I/O channels, CPUs) across security levels. This is most easily achieved with the kernelized architecture <ref> (Air Force Studies Board 1983) </ref>. Synchronizing readers and writers in an MLS environment is at the heart of the secure transaction processing problem. The solutions proposed by (Schaefer 1974, Lamport 1977, Reed & Kanodia 1979) are optimistic. High-level readers, before committing, must validate the objects they read.
Reference: <author> Ammann, P., Jaeckle, F. & Jajodia, S. </author> <year> (1992), </year> <title> A two snapshot algorithm for concurrency control in secure multi-level databases, </title> <booktitle> in `Proc. Symp. on Research in Security and Privacy', </booktitle> <address> Oakland, CA, </address> <pages> pp. 204-215. </pages>
Reference: <author> Ammann, P. & Jajodia, S. </author> <year> (1993), </year> <title> `Distributed timestamp generation in planar lattice networks', </title> <journal> ACM Trans. on Computer Systems 11(3), </journal> <pages> 205-225. </pages>
Reference-contexts: However, upon consideration, we see that choosing an order is impossible. Thus, the history is nonserializable and update projections will make no further progress. For a more detailed explanation of this problem, see <ref> (Ammann & Jajodia 1993) </ref> or (Kang & Keefe 1995). The results of (Ammann, Jajodia & Frankl 1996) apply to protocols that attempt to construct an order on transactions dynamically as they are propagated through the poset.
Reference: <author> Ammann, P. & Jajodia, S. </author> <year> (1994a), </year> <title> An efficient multiversion algorithm for secure servicing of transaction reads, </title> <booktitle> in `Proc. of the 1st ACM conference on Computer and Communication Security', </booktitle> <address> Fairfax, VA, </address> <pages> pp. 118-125. </pages>
Reference: <author> Ammann, P. & Jajodia, S. </author> <year> (1994b), </year> <title> Planar lattice security structures for multilevel replicated database, </title> <editor> in T. F. Keefe & C. E. Landwehr, eds, </editor> <title> `Database Security VII: Status and Prospects', </title> <publisher> North-Holland, Amsterdam, </publisher> <pages> pp. 125-134. </pages>
Reference: <author> Ammann, P., Jajodia, S. & Frankl, P. </author> <year> (1996), </year> <title> `Globally consistent event ordering in one-directional distributed environments', </title> <journal> IEEE Transactions on Parallel and Distributed Systems 7(6), </journal> <pages> 665-670. </pages>
Reference-contexts: Following this paper, several other papers attempted to characterize the set of "problem" security posets (Ammann & Jajodia 1993, Ammann & Jajodia 1994b, Kang & Keefe 1995). In <ref> (Ammann, Jajodia & Frankl 1996) </ref> the set of problematic security lattices is shown to be exactly those that embed a crown. An example of a crown is shown in figure 2. <p> However, upon consideration, we see that choosing an order is impossible. Thus, the history is nonserializable and update projections will make no further progress. For a more detailed explanation of this problem, see (Ammann & Jajodia 1993) or (Kang & Keefe 1995). The results of <ref> (Ammann, Jajodia & Frankl 1996) </ref> apply to protocols that attempt to construct an order on transactions dynamically as they are propagated through the poset. A method of avoiding this problem is to determine the order using timestamps generated when the transaction commits for the first time. <p> However, by taking the semantics of queries in a specific application into account, it may be possible to customize the transaction management (see for example <ref> (Ammann, Jajodia & Ray 1996) </ref>). However, no performance data is currently available for these systems.
Reference: <author> Ammann, P., Jajodia, S. & Ray, I. </author> <year> (1996), </year> <title> Ensuring atomicity of multilevel transactions, </title> <booktitle> in `Proc. IEEE Symp. on Security and Privacy', </booktitle> <address> Oakland, CA, </address> <pages> pp. 74-84. </pages>
Reference-contexts: Following this paper, several other papers attempted to characterize the set of "problem" security posets (Ammann & Jajodia 1993, Ammann & Jajodia 1994b, Kang & Keefe 1995). In <ref> (Ammann, Jajodia & Frankl 1996) </ref> the set of problematic security lattices is shown to be exactly those that embed a crown. An example of a crown is shown in figure 2. <p> However, upon consideration, we see that choosing an order is impossible. Thus, the history is nonserializable and update projections will make no further progress. For a more detailed explanation of this problem, see (Ammann & Jajodia 1993) or (Kang & Keefe 1995). The results of <ref> (Ammann, Jajodia & Frankl 1996) </ref> apply to protocols that attempt to construct an order on transactions dynamically as they are propagated through the poset. A method of avoiding this problem is to determine the order using timestamps generated when the transaction commits for the first time. <p> However, by taking the semantics of queries in a specific application into account, it may be possible to customize the transaction management (see for example <ref> (Ammann, Jajodia & Ray 1996) </ref>). However, no performance data is currently available for these systems.
Reference: <author> Atluri, V., Bertino, E. & Jajodia, S. </author> <year> (1995), </year> <title> Degrees of isolation, concurrency control protocols, and commit protocols, </title> <editor> in M. Morgenstern, J. Biskup & C. E. Landwehr, eds, </editor> <title> `Database Security, VII: Status and Prospects', </title> <publisher> North Holland, </publisher> <pages> pp. 259-274. </pages>
Reference: <author> Atluri, V. & Huang, W.-K. </author> <year> (1996), </year> <title> An extended petri net model for supporting workflows in a multilevel secure environment, </title> <booktitle> in `Proc. of the 10th IFIP WG 11.3 Workshop on Database Security', </booktitle> <pages> pp. 199-216. </pages>
Reference: <author> Bell, E. & LaPadula, L. J. </author> <year> (1975), </year> <title> Secure computer systems: Unified exposition and multics interpretations, </title> <type> Technical Report MTR-2997, </type> <institution> The Mitre Corporation, </institution> <address> Burlington Road, Bedford, MA 01730, USA. </address>
Reference: <author> Bernstein, P. A., Hadzilacos, V. & Goodman, N. </author> <year> (1987), </year> <title> Concurrency Control and Recovery in Database Systems., </title> <publisher> Addison-Wesley, </publisher> <address> Reading, MA. </address>
Reference-contexts: In a distributed database, an atomic commit protocol is additionally required to ensure atomicity. Distributed transaction processing requires proper integration of atomic commit and concurrency control protocols. 2.3 Concurrency Control Protocols Though there are a number of concurrency control algorithms to produce serializable execution of transactions <ref> (Bernstein, Hadzilacos & Goodman 1987) </ref>, the two most widely used protocols are two-phase locking (2PL) and timestamp ordering (TO). <p> Unfortunately, this requirement has grave implications on the commit protocols, especially the early prepare, since to guarantee serializability, it requires not only that each subtransaction must be two-phase, but that the distributed transaction as a whole must be two-phase as well <ref> (Bernstein et al. 1987) </ref>. To satisfy the latter requirement, all subtransactions must hold all their locks until the commit of the transaction, which unfortunately cannot be met in MLS systems (refer to section on secure commit protocols for an example). <p> The idea is to construct an MLS DBMS from single-level DBMSs. The DBMS at level l contains a replica of every data item that a subject at level l can access. The challenge is then to design a replica control protocol that will ensure one-copy serializability <ref> (Bernstein et al. 1987) </ref>. In the architecture most commonly used, transactions are submitted to a global transaction manager (GTM). The GTM routes the transactions to their sites of origin and propagates the update projections to each of the dominating containers in turn. <p> To ensure serializability, the protocol assumes that each local scheduler preserves, in its serialization order, the order in which it receives conflicting transactions. Examples of such schedulers are conservative 2PL and conservative TO <ref> (Bernstein et al. 1987) </ref>. Unfortunately, the protocol has a subtle flaw: there is no control over the relative serialization order of non-conflicting update projections. As is shown in (Kang & Keefe 1995), this lack of control can result in nonserializable histories. <p> This is done without aborting update projections by following the conservative timestamp protocol discussed in <ref> (Bernstein et al. 1987) </ref>. Solutions based on this approach are presented in (McDermott et al. 1991) and (Kang & Keefe 1995). These solutions suffer from starvation as does the conservative timestamp protocol on which they are based. <p> Through these multiple subtransactions, the multilevel update transaction is able to perform its task of reading and writing at multiple classification levels, while at the same time satisfying the simple and ?-properties. Each subtransaction is a flat transaction in the sense of <ref> (Bernstein et al. 1987) </ref>. Accomplishments 11 In many applications, it is desirable to ensure atomicity of multilevel update transactions. <p> All work on multilevel transactions cited above relies on the standard conflict-serializability <ref> (Bernstein et al. 1987) </ref> as the correctness criterion. Ammann, Jajodia & Ray (1996) propose an alternative notion of semantic atomicity which guarantees that either all or none of the actions of a multilevel transaction are present in any history.
Reference: <author> Bertino, E., Jajodia, S., Mancini, L. & Ray, I. </author> <year> (1996), </year> <title> `Advanced transaction processing in multilevel secure file stores', Accepted for publication in IEEE Transactions on Knowledge and Data 18 Multilevel Secure Transaction Processing: Status and Prospects Engineering </title> . 
Reference-contexts: Like SEP, ASEP sends an additional round of messages to all subtransactions which have read low data items. However, in ASEP, subtransactions can roll back to a prespecified save point and reexecute the subtransaction (as in <ref> (Bertino et al. 1996) </ref>) if they release their read locks on low data items. If a subtransaction successfully completes, then it sends a yes message. ASEP checks this by sending messages to these participants repeatedly until it receives all yes responses.
Reference: <author> Blaustein, B. T., Jajodia, S., McCollum, C. D. & Notargiacomo, L. </author> <year> (1993), </year> <title> A model of atomicity for multilevel transactions, </title> <booktitle> in `Proc. IEEE Symposium on Security and Privacy', </booktitle> <address> Oakland, California, </address> <pages> pp. 120-134. </pages>
Reference: <author> Bober, P. & Carey, M. </author> <year> (1994), </year> <title> Indexing alternatives for multiversion locking, </title> <booktitle> in `Proc. Int'l. Conf. on Extending Database Technology', </booktitle> <pages> pp. 145-158. </pages>
Reference-contexts: Maintaining B+-trees for database systems using a multiversion scheduling algorithm introduces additional issues by providing the option to map keys to logical data objects or to a particular version of that data object <ref> (Bober & Carey 1994) </ref>. Furthermore, index management must be done in a way that ensures recoverability. It is not clear how to adapt existing methods to an MLS environment. 5.3 Recovery Methods Efficient recovery algorithms are critical for good performance in systems that support transactions.
Reference: <author> Costich, O. </author> <year> (1992), </year> <title> Transaction processing using an untrusted scheduler in a multilevel database with replicated architecture, </title> <editor> in C. Landwehr & S. Jajodia, eds, </editor> <title> `Database Security V: Status and Prospects', </title> <publisher> North-Holland, Amsterdam, </publisher> <pages> pp. 173-190. </pages>
Reference: <author> Denning, D. E. </author> <year> (1982), </year> <title> Cryptography and Data Security, </title> <publisher> Addison-Wesley, </publisher> <address> Reading, MA. </address>
Reference-contexts: allowed to write a data item only if the former's security level is identical to the latter's security level. (Unlike in the BLP model, transactions are not allowed to write up for integrity reasons.) Although these restrictions prevent direct legal flow of information from a level to another nondominated level <ref> (Denning 1982) </ref>, they are not sufficient to ensure that security is not compromised since it could 6 Multilevel Secure Transaction Processing: Status and Prospects high: lock 2 [x]; r 2 [x] lock 2 [y]; w 2 [y] low: w 1 [x] will be delayed be possible for leakage of information to <p> When a high user wants to update a low data item, he or she must do so by first logging in as a low user and then initiating a low transaction <ref> (Denning 1982) </ref>. Accomplishments 7 Tsai & Srivastava 1993). This paper also provides a general framework for evaluating the security of concurrency control protocols. Similar problems are encountered even in distributed MLS systems.
Reference: <author> Denning, D. E., Lunt, T., Schell, R., Shockley, W. & Heckman, M. </author> <year> (1988), </year> <title> The Seaview security model, </title> <booktitle> in `Proc. IEEE Symp. on Security and Privacy', </booktitle> <address> Oakland, CA, </address> <pages> pp. 218-233. </pages>
Reference-contexts: Similarly, the ratio of read-only to read-write transactions and the characteristics of database operations such as SELECT (e.g., selectivity factor) and PROJECT (e.g., duplication factor) influence the performance. Kernelized architectures such as SeaView <ref> (Denning, Lunt, Schell, Shockley & Heckman 1988) </ref> include both horizontal and vertical partitioning of relations based on tuple and attribute class. While this partitioning of a multilevel relation into single-level relations satisfies the security requirements, its impact on storage and processing overhead during the reconstruction of a relation is significant.
Reference: <author> Gray, J. & Reuter, A. </author> <year> (1993), </year> <title> Transaction Processing: Concepts and Techniques, </title> <publisher> Morgan Kauf-mann, </publisher> <address> San Mateo, California. </address> <month> Informix </month> <year> (1993a), </year> <title> Informix-OnLine/Secure Administrator's Guide, Informix Software, </title> <publisher> Inc., </publisher> <address> Menlo Park, CA. </address> <month> Informix </month> <year> (1993b), </year> <title> Informix-OnLine/Secure Security Features User's Guide, Informix Software, </title> <publisher> Inc., </publisher> <address> Menlo Park, CA. </address>
Reference-contexts: Furthermore, index management must be done in a way that ensures recoverability. It is not clear how to adapt existing methods to an MLS environment. 5.3 Recovery Methods Efficient recovery algorithms are critical for good performance in systems that support transactions. Write-Ahead Logging (WAL) is a popular recovery technique <ref> (Gray & Reuter 1993) </ref>. The method provides good performance because transactions' updates are not forced to disk on commit. Only the log records written by the transaction must be on stable storage when the transaction commits.
Reference: <author> Jajodia, S. & Atluri, V. </author> <year> (1992), </year> <title> Alternative correctness criteria for concurrent execution of transactions in multilevel secure databases, </title> <booktitle> in `Proc. IEEE Symposium on Security and Privacy', </booktitle> <address> Oakland, California, </address> <pages> pp. 216-224. </pages>
Reference-contexts: For con-currency control, Sybase uses the usual 2PL, which was shown above not to be secure. Trusted Oracle, on the other hand, uses a combination of locking and multiversioning techniques. Although this hybrid algorithm is secure, it does not produce one-copy serializable histories <ref> (Jajodia & Atluri 1992) </ref>. Finally, Informix uses an approach by which a low-level transaction can acquire a write lock on a low data item, even if a high-level transaction holds a read lock on this data item. Thus, a low-level transaction is never delayed by a high-level transaction. <p> Often the impact is felt much more by the high-level users and to a lesser extent by the low-level users. As discussed above, the impact also depends on other design factors such as the decomposition method and the transaction management scheme <ref> (Jajodia & Mukkamala 1992, Mukkamala & Jajodia 1994) </ref>. 5.6 Integrity/Repair General techniques for database recovery compensate for the effects of occasional unavoidable but benign failures, either failures of individual transactions or more global failures affecting a system, device, or network.
Reference: <author> Jajodia, S. & Kogan, B. </author> <year> (1990), </year> <title> Integrating an object-oriented data model with multilevel security, </title> <booktitle> in `Proc. IEEE Symposium on Security and Privacy', </booktitle> <address> Oakland, California, </address> <pages> pp. 76-85. </pages>
Reference-contexts: Weaker Correctness Criteria. A solution to the problem of secure concurrency control can be obtained by viewing it in a different perspective. One can argue that the traditional notion of correctness is too restrictive for multilevel secure databases <ref> (Maimone & Greenberg 1990, Jajodia & Atluri 1992) </ref>. This is supported by the fact that the integrity constraints in multilevel databases are different from those in conventional databases.
Reference: <author> Jajodia, S. & McCollum, C. </author> <year> (1993), </year> <title> Using two-phase commit for crash recovery in federated multilevel secure database management systems, </title> <editor> in C. E. Landwehr, B. Randell & L. Simoncini, eds, </editor> <booktitle> `Dependable Computing and Fault Tolerant Systems, </booktitle> <volume> Vol. 8', </volume> <publisher> Springer-Verlag, </publisher> <address> New York, </address> <pages> pp. 365-381. </pages>
Reference-contexts: However, upon consideration, we see that choosing an order is impossible. Thus, the history is nonserializable and update projections will make no further progress. For a more detailed explanation of this problem, see <ref> (Ammann & Jajodia 1993) </ref> or (Kang & Keefe 1995). The results of (Ammann, Jajodia & Frankl 1996) apply to protocols that attempt to construct an order on transactions dynamically as they are propagated through the poset.
Reference: <author> Jajodia, S., McCollum, C. D. & Blaustein, B. T. </author> <year> (1994), </year> <title> Integrating concurrency control and commit algorithms in distributed multilevel secure databases, </title> <editor> in T. F. Keefe & C. E. Landwehr, eds, </editor> <title> `Database Security, VII: Status and Prospects', </title> <publisher> North-Holland, Amsterdam, </publisher> <pages> pp. 109-121. </pages>
Reference: <author> Jajodia, S. & Mukkamala, R. </author> <year> (1992), </year> <title> Effects of seaview decomposition of multilevel relations on database performance, </title> <editor> in C. E. Landwehr & S. Jajodia, eds, </editor> <title> `Database Security V: Status and Prospects', </title> <publisher> North-Holland, Amsterdam, </publisher> <pages> pp. 203-225. </pages>
Reference-contexts: For con-currency control, Sybase uses the usual 2PL, which was shown above not to be secure. Trusted Oracle, on the other hand, uses a combination of locking and multiversioning techniques. Although this hybrid algorithm is secure, it does not produce one-copy serializable histories <ref> (Jajodia & Atluri 1992) </ref>. Finally, Informix uses an approach by which a low-level transaction can acquire a write lock on a low data item, even if a high-level transaction holds a read lock on this data item. Thus, a low-level transaction is never delayed by a high-level transaction. <p> Often the impact is felt much more by the high-level users and to a lesser extent by the low-level users. As discussed above, the impact also depends on other design factors such as the decomposition method and the transaction management scheme <ref> (Jajodia & Mukkamala 1992, Mukkamala & Jajodia 1994) </ref>. 5.6 Integrity/Repair General techniques for database recovery compensate for the effects of occasional unavoidable but benign failures, either failures of individual transactions or more global failures affecting a system, device, or network.
Reference: <author> Jajodia, S. & Sandhu, R. </author> <year> (1991), </year> <title> A novel decomposition of multilevel relations into single-level relations, </title> <booktitle> in `Proc. IEEE Symp. on Security and Privacy', </booktitle> <address> Oakland, California, </address> <pages> pp. 300-313. </pages>
Reference: <author> Jajodia, S., Smith, K. P., Blaustein, B. T. & Notargiacomo, L. </author> <year> (1996), </year> <title> Securely executing multilevel transactions, </title> <editor> in S. K. Katsikas & D. Gritzalis, eds, </editor> <booktitle> `Information Systems Security', </booktitle> <publisher> Chapman & Hall, London, </publisher> <pages> pp. 259-270. </pages>
Reference-contexts: Following this paper, several other papers attempted to characterize the set of "problem" security posets (Ammann & Jajodia 1993, Ammann & Jajodia 1994b, Kang & Keefe 1995). In <ref> (Ammann, Jajodia & Frankl 1996) </ref> the set of problematic security lattices is shown to be exactly those that embed a crown. An example of a crown is shown in figure 2. <p> However, upon consideration, we see that choosing an order is impossible. Thus, the history is nonserializable and update projections will make no further progress. For a more detailed explanation of this problem, see (Ammann & Jajodia 1993) or (Kang & Keefe 1995). The results of <ref> (Ammann, Jajodia & Frankl 1996) </ref> apply to protocols that attempt to construct an order on transactions dynamically as they are propagated through the poset. A method of avoiding this problem is to determine the order using timestamps generated when the transaction commits for the first time. <p> However, by taking the semantics of queries in a specific application into account, it may be possible to customize the transaction management (see for example <ref> (Ammann, Jajodia & Ray 1996) </ref>). However, no performance data is currently available for these systems.
Reference: <author> Kang, I. E. & Keefe, T. F. </author> <year> (1992), </year> <title> On transaction processing for multilevel-secure replicated databases, </title> <booktitle> in `Proc. of the European Symposium on Research in Computer Security', </booktitle> <pages> pp. 329-347. </pages>
Reference: <author> Kang, I. E. & Keefe, T. F. </author> <year> (1995), </year> <title> `Transaction management for multilevel secure replicated databases', </title> <journal> Journal of Computer Security 3, </journal> <pages> 115-145. </pages>
Reference-contexts: Examples of such schedulers are conservative 2PL and conservative TO (Bernstein et al. 1987). Unfortunately, the protocol has a subtle flaw: there is no control over the relative serialization order of non-conflicting update projections. As is shown in <ref> (Kang & Keefe 1995) </ref>, this lack of control can result in nonserializable histories. Fortunately, the problem can be easily solved by executing update projections serially. <p> However, upon consideration, we see that choosing an order is impossible. Thus, the history is nonserializable and update projections will make no further progress. For a more detailed explanation of this problem, see (Ammann & Jajodia 1993) or <ref> (Kang & Keefe 1995) </ref>. The results of (Ammann, Jajodia & Frankl 1996) apply to protocols that attempt to construct an order on transactions dynamically as they are propagated through the poset. <p> This is done without aborting update projections by following the conservative timestamp protocol discussed in (Bernstein et al. 1987). Solutions based on this approach are presented in (McDermott et al. 1991) and <ref> (Kang & Keefe 1995) </ref>. These solutions suffer from starvation as does the conservative timestamp protocol on which they are based. The advantage of the replicated architecture approach is its simplicity and its ability to reuse DBMSs in their entirety.
Reference: <author> Kang, M., Froscher, J. & Mukkamala, R. </author> <year> (1994), </year> <title> Architectural impact on performance of a multilevel database system, </title> <booktitle> in `Proc. 10th Annual IEEE Computer Security Applications Conf.', </booktitle> <pages> pp. 76-85. </pages> <note> Technical Challenges 19 Keefe, </note> <author> T. F. & Tsai, W. T. </author> <year> (1990), </year> <title> Multiversion concurrency control for multilevel secure database systems, </title> <booktitle> in `Proc. IEEE Symposium on Security and Privacy', </booktitle> <address> Oakland, California, </address> <pages> pp. 369-383. </pages>
Reference: <author> Keefe, T. F., Tsai, W. T. & Srivastava, J. </author> <year> (1993), </year> <title> `Database concurrency control in multilevel secure database management systems', </title> <journal> IEEE Trans. on Knowledge and Data Engineering 5(6), </journal> <pages> 1039-1055. </pages>
Reference: <author> Lamport, L. </author> <year> (1977), </year> <title> `Concurrent reading and writing', </title> <journal> Comm. of ACM 20(11), </journal> <pages> 806-811. </pages>
Reference: <author> Maimone, W. T. & Greenberg, I. B. </author> <year> (1990), </year> <title> Single-level multiversion schedulers for multilevel secure database systems, </title> <booktitle> in `Proc. 6th Annual Computer Security Applications Conf.', </booktitle> <address> Tucson, Arizona, </address> <pages> pp. 137-147. </pages>
Reference-contexts: The algorithm assigns timestamps such that high-level readers are pushed behind writers in the serialization order. This allows us to control the abort rate of high-level readers by providing additional versions. It also simplifies an untrusted implementation as explained in <ref> (Maimone & Greenberg 1990) </ref>. There are four principal weaknesses of this protocol: (1) A high-level transaction, because it is not always given a current timestamp, can read arbitrarily stale data. The histories are serializable and are therefore consistency-preserving. <p> Weaker Correctness Criteria. A solution to the problem of secure concurrency control can be obtained by viewing it in a different perspective. One can argue that the traditional notion of correctness is too restrictive for multilevel secure databases <ref> (Maimone & Greenberg 1990, Jajodia & Atluri 1992) </ref>. This is supported by the fact that the integrity constraints in multilevel databases are different from those in conventional databases.
Reference: <author> Mathur, A. G. & Keefe, T. F. </author> <year> (1993), </year> <title> The concurrency control and recovery problem for multilevel update transactions in mls systems, </title> <booktitle> in `Proc. IEEE Computer Security Foundations Workshop', </booktitle> <address> Franconia, </address> <publisher> NH, </publisher> <pages> pp. 10-23. </pages>
Reference: <author> McDermott, J., Jajodia, S. & Sandhu, R. </author> <year> (1991), </year> <title> A single-level scheduler for replicated architecture for multilevel secure databases, </title> <booktitle> in `Proc. 7th Annual Computer Security Applications Conf.', </booktitle> <address> San Antonio, Texas, </address> <pages> pp. 2-11. </pages>
Reference-contexts: This is done without aborting update projections by following the conservative timestamp protocol discussed in (Bernstein et al. 1987). Solutions based on this approach are presented in <ref> (McDermott et al. 1991) </ref> and (Kang & Keefe 1995). These solutions suffer from starvation as does the conservative timestamp protocol on which they are based. The advantage of the replicated architecture approach is its simplicity and its ability to reuse DBMSs in their entirety.
Reference: <author> McDermott, J. & Mukkamala, R. </author> <year> (1994), </year> <title> Performance analysis of transaction management algorithm for the sintra replicated-architecture database system, </title> <editor> in T. F. Keefe & C. E. Landwehr, eds, </editor> <title> `Database Security VII: Status and Prospects', </title> <publisher> North-Holland, Amsterdam, </publisher> <pages> pp. 215-234. </pages>
Reference: <author> Meadows, C. & Jajodia, S. </author> <year> (1988), </year> <title> Integrity versus security in multi-level secure databases, </title> <editor> in C. </editor> <publisher> E. </publisher>
Reference-contexts: This is supported by the fact that the integrity constraints in multilevel databases are different from those in conventional databases. Enforcing integrity constraints in MLS databases is difficult or even impossible, especially those constraints that are defined over data at different security levels <ref> (Meadows & Jajodia 1988) </ref>. Since one cannot enforce the integrity constraints, there is no reason to insist on preserving serializability for these systems.
Reference: <author> Landwehr, ed., </author> <title> `Database Security, Status and Prospects', </title> <publisher> North-Holland, </publisher> <pages> pp. 89-101. </pages>
Reference: <author> Mukkamala, R. & Jajodia, S. </author> <year> (1994), </year> <title> A performance comparison of two decomposition techniques for multilevel database systems, </title> <editor> in T. F. Keefe & C. E. Landwehr, eds, </editor> <title> `Database Security VII: Status and Prospects', </title> <publisher> North-Holland, Amsterdam, </publisher> <pages> pp. </pages> <month> 199-214. </month> <title> Oracle (1992), Trusted Oracle Administrator's Guide, Oracle Corp., </title> <address> Redwood City, CA. </address>
Reference: <author> Pal, S. </author> <year> (1996), </year> <title> A locking protocol for multilevel secure databases providing support for long transactions, </title> <editor> in D. L. Spooner, S. A. Demurjian & J. E. Dobson, eds, </editor> <title> `Database Security IX: Status and Prospects', </title> <publisher> Chapman & Hall, London, </publisher> <pages> pp. 183-198. </pages>
Reference-contexts: Periodically, the snapshots are synchronized with the database. Because the snapshot must be commit consistent, the lifetime of a transaction is generally limited to the snapshot period. Pal suggests some cases in which this restriction can be relaxed <ref> (Pal 1996) </ref>. As with schedulers based on MVTO, there is a basic conflict between long-lived transactions and the freshness of the data they read. An open question is whether the snapshot algorithms can provide more precise control over this trade-off. Weaker Correctness Criteria. <p> This will require some way of maintaining consistency among the replicas. A drawback of this approach is its poor use of memory. Maintaining a single copy of each page is desirable, but it makes in-place access more difficult. A range of solutions to these problems is discussed in <ref> (Warner, Li, Keefe & Pal 1996) </ref>. 5.5 Performance The performance of MLS transaction processing systems is influenced by several design choices as well as the user profiles. Among the design choices, the decomposition method adopted for relation decomposition and the transaction management techniques have the greatest impact.
Reference: <author> Ray, I., Bertino, E., Jajodia, S. & Mancini, L. </author> <year> (1996), </year> <title> An advanced commit protocol for mls distributed database systems, </title> <booktitle> in `Proc. Third ACM Conference on Computer and Communications Security', </booktitle> <address> New Delhi, India, </address> <pages> pp. 119-128. </pages>
Reference-contexts: However, by taking the semantics of queries in a specific application into account, it may be possible to customize the transaction management (see for example <ref> (Ammann, Jajodia & Ray 1996) </ref>). However, no performance data is currently available for these systems.
Reference: <author> Reed, D. P. & Kanodia, R. K. </author> <year> (1979), </year> <title> `Synchronization with eventcounts and sequencers', </title> <journal> Comm. of ACM 22(5), </journal> <pages> 115-123. </pages>
Reference: <author> Schaefer, M. </author> <year> (1974), </year> <title> Quasi-synchronization of readers and writers in a secure multi-level environment, </title> <type> Technical Report TM-5407/003, </type> <institution> System Development Corp. </institution>
Reference-contexts: This is most easily achieved with the kernelized architecture (Air Force Studies Board 1983). Synchronizing readers and writers in an MLS environment is at the heart of the secure transaction processing problem. The solutions proposed by <ref> (Schaefer 1974, Lamport 1977, Reed & Kanodia 1979) </ref> are optimistic. High-level readers, before committing, must validate the objects they read. If those objects have been updated, the transaction must abort.
Reference: <author> Shasha, D. & Goodman, N. </author> <year> (1988), </year> <title> `Concurrent search structure algorithms', </title> <journal> ACM Trans. on Database Systems 13(1), </journal> <pages> 53-90. </pages>
Reference-contexts: Therefore, mapping users' requests to the physical data (index management) is critical to performance. One typical method of doing this is using B+-trees. Because contention for the index can be high, specialized synchronization techniques are often used <ref> (Shasha & Goodman 1988, Gray & Reuter 1993) </ref>. Maintaining B+-trees for database systems using a multiversion scheduling algorithm introduces additional issues by providing the option to map keys to logical data objects or to a particular version of that data object (Bober & Carey 1994).
Reference: <author> Smith, K. P., Blaustein, B. T., Jajodia, S. & Notargiacomo, L. </author> <year> (1996), </year> <title> `Correctness criteria for multilevel transactions', </title> <journal> IEEE Trans. on Knowledge and Data Engineering 8(1), </journal> <pages> 32-35. </pages>
Reference: <author> Stamos, J. W. & Cristian, F. </author> <year> (1993), </year> <title> `Coordinator log transaction execution protocol', Distributed and Parallel Databases 1, 383-408. Sybase (1993), Sybase Secure SQL Server Security Administrator's Guide, Sybase, </title> <publisher> Inc., Emeryville, </publisher> <address> CA. </address>
Reference-contexts: The two-phase commit protocol (2PC) is one of the most popular atomic commit protocols. Although many distributed systems rely on 2PC for ensuring atomic commit, most commercial systems use several optimizations of 2PC to reduce the number of message exchanges <ref> (Stamos & Cristian 1993) </ref>. In the presumed commit (abort), the acknowledgment is not sent from the participants if the subtransaction commits (aborts).


References-found: 44

