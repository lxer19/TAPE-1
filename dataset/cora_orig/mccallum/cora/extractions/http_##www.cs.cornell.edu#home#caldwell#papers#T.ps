URL: http://www.cs.cornell.edu/home/caldwell/papers/T.ps
Refering-URL: http://www.cs.cornell.edu/home/caldwell/papers.html
Root-URL: 
Title: A Short Ride Through a Vast Machine (A terse guide to System T  
Author: James Caldwell 
Date: January 1, 1992  
Abstract: This short note is a compilation of all the logical and typing rules that comprise the system loosely referred to as T ++ . These rules were presented in the advanced programming languages course CS611 in the Fall of 1991 by Robert Constable. In principle, the class notes produced by students of CS611 contain all the rules presented here. I have pulled all the rules together in a uniform presentation and have added short remarks following each section.
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Robert L. Constable et. al. </author> <title> Implementing Mathematics with the Nuprl Proof Development System. </title> <publisher> Prentice Hall, </publisher> <year> 1986. </year>
Reference-contexts: T ++ is a further extension that includes the disjoint union type (+), and the dependent product and dependent function types and as well. The Nuprl book <ref> [1] </ref> contains complete descriptions, including a section on the semantics, of all the rules presented here. It should be noted that the notation used there is the linear notation used in the Nuprl theorem prover and differs from the mathematical notation used here. <p> If we let [1::n] denote the type containing the natural numbers 1 through n then date,M and D types can be specified as follows: date = m : M:D M = <ref> [1; ::; 12] </ref> D = (m: if m 2 f1; 3; 5; 7; 8; 10; 12g then [1; ::31] elseif m 2 f4; 6; 9; 11g then [1; ::; 30] else [1; ::; 28]) By rule (I), hm; di 2 date if and only if m 2 M and d 2 <p> If we let [1::n] denote the type containing the natural numbers 1 through n then date,M and D types can be specified as follows: date = m : M:D M = [1; ::; 12] D = (m: if m 2 f1; 3; 5; 7; 8; 10; 12g then <ref> [1; ::31] </ref> elseif m 2 f4; 6; 9; 11g then [1; ::; 30] else [1; ::; 28]) By rule (I), hm; di 2 date if and only if m 2 M and d 2 D (m). 7 7 Universal Quantification and the -Type A 2 F B 2 F (8F ) <p> the natural numbers 1 through n then date,M and D types can be specified as follows: date = m : M:D M = [1; ::; 12] D = (m: if m 2 f1; 3; 5; 7; 8; 10; 12g then [1; ::31] elseif m 2 f4; 6; 9; 11g then <ref> [1; ::; 30] </ref> else [1; ::; 28]) By rule (I), hm; di 2 date if and only if m 2 M and d 2 D (m). 7 7 Universal Quantification and the -Type A 2 F B 2 F (8F ) A is a type B is a type x : <p> through n then date,M and D types can be specified as follows: date = m : M:D M = [1; ::; 12] D = (m: if m 2 f1; 3; 5; 7; 8; 10; 12g then [1; ::31] elseif m 2 f4; 6; 9; 11g then [1; ::; 30] else <ref> [1; ::; 28] </ref>) By rule (I), hm; di 2 date if and only if m 2 M and d 2 D (m). 7 7 Universal Quantification and the -Type A 2 F B 2 F (8F ) A is a type B is a type x : A:B is a type
Reference: [2] <author> Jean-Yevs Girard, Yves Lafont, and Paul Taylor. </author> <title> Proofs and Types. </title> <publisher> Cambridge University Press, </publisher> <year> 1989. </year>
Reference-contexts: 1 Introduction The system of rules informally known as T ++ is based on Godel's system T which (as presented by Girard in <ref> [2] </ref>) is the simply typed -calculus extended to include pairs, Peano arithmetic and Booleans. T ++ is a further extension that includes the disjoint union type (+), and the dependent product and dependent function types and as well.
Reference: [3] <author> Gordon D. Plotkin. </author> <title> LCF considered as a programming language. </title> <journal> Theoretical Computer Science, </journal> <volume> 5 </volume> <pages> 223-256, </pages> <year> 1977. </year>
Reference-contexts: Level Types . . . L i+1 f (L j ! L i )j j ig [ f (L i ! L j )j j ig . . . 1 (N ! N) T ++ should be contrasted with Plotkin's system PCF <ref> [3] </ref> which captures the general recursive functions in all finite types, i.e. it is Turing complete for functions (N ! N). 1.1 Propositions as Types The logic and typing rules are presented here in parallel to illustrate the Curry Howard isomorphism or notion propositions as types.
Reference: [4] <author> Simon Thompson. </author> <title> Type Theory and Functional Programming. </title> <publisher> Addison Wesley, </publisher> <year> 1991. </year> <month> 10 </month>
Reference-contexts: Thus we can write p 2 P to mean p is a proof of proposition P or equivalently (by the isomorphism) to mean the p is a term of type P . For a somewhat more detailed account see the unpublished CS611 class notes or Thompson <ref> [4] </ref>. Each logical and typing construct has four kinds of rules. Formation rules determine the syntactic classes of formulas and types. So the formation rules inductively specify syntax. The introduction rules specify how introduction of instances of each construct may be justified.
References-found: 4

