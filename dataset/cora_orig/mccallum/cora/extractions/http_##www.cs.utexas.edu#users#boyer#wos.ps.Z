URL: http://www.cs.utexas.edu/users/boyer/wos.ps.Z
Refering-URL: http://www.cs.utexas.edu/users/moore/best-ideas/nqthm/index.html
Root-URL: 
Title: The Boyer-Moore Theorem Prover and Its Interactive Enhancement  
Author: Robert S. Boyer Matt Kaufmann J Strother Moore 
Date: July 12, 1993  
Affiliation: University of Texas, Austin Computational Logic, Inc.  Computational Logic, Inc.  Computational Logic, Inc.  
Abstract: The so-called "Boyer-Moore Theorem Prover" (otherwise known as "Nqthm") has been used to perform a variety of verification tasks for two decades. We give an overview of both this system and an interactive enhancement of it, "Pc-Nqthm," from a number of perspectives. First we introduce the logic in which theorems are proved. Then we briefly describe the two mechanized theorem proving systems. Next, we present a simple but illustrative example in some detail in order to give an impression of how these systems may be used successfully. Finally, we give extremely short descriptions of a large number of applications of these systems, in order to give an idea of the breadth of their uses. This paper is intended as an informal introduction to systems that have been described in detail and similarly summarized in many other books and papers; no new results are reported here. 
Abstract-found: 1
Intro-found: 1
Reference: [ACL] <author> R. S. Boyer and J S. Moore. </author> <title> A Computational Logic. </title> <publisher> Academic Press, </publisher> <address> New York, </address> <year> 1979. </year>
Reference-contexts: By 1986 the system had also become known as Nqthm (pronounced en-queue-thum), an acronym for "New, Quantified THeoreM Prover," the little-considered name of the disk directory on which a rapidly evolving improvement resided that included a limited quantification capability. The 1978 book, A Computational Logic <ref> [ACL] </ref> is still a largely accurate and comprehensive description of how the theorem prover works. That version of the system has been reimplemented by at least three groups working from [ACL]. <p> The 1978 book, A Computational Logic <ref> [ACL] </ref> is still a largely accurate and comprehensive description of how the theorem prover works. That version of the system has been reimplemented by at least three groups working from [ACL]. The book A Computational Logic Handbook [ACLH] (often called the "Nqthm handbook") contains a precise description of the Nqthm logic as it stood in 1988. In addition, [ACLH] indicates by appropriate bibliographic citations how to reconstruct the 1988 version of Nqthm from [ACL] and numerous journal articles about subsequent improvements. <p> by at least three groups working from <ref> [ACL] </ref>. The book A Computational Logic Handbook [ACLH] (often called the "Nqthm handbook") contains a precise description of the Nqthm logic as it stood in 1988. In addition, [ACLH] indicates by appropriate bibliographic citations how to reconstruct the 1988 version of Nqthm from [ACL] and numerous journal articles about subsequent improvements. However, the handbook is primarily devoted to a description of how to use the Nqthm logic and its mechanization. We expect to release a new version of Nqthm in 1993. <p> Such "backchaining" invites infinite regress and heuristics are present to limit such backchaining. As noted previously, details are given in <ref> [ACL] </ref> and [ACLH] and the papers cited in the latter. 10 2.3 Hard Theorems Proved and the Importance of the User Among the hard theorems proved by Nqthm are * the existence and uniqueness of prime factorizations [ACL] * the invertibility of the RSA public key encryption algorithm [BM84c] * Wilson's <p> As noted previously, details are given in <ref> [ACL] </ref> and [ACLH] and the papers cited in the latter. 10 2.3 Hard Theorems Proved and the Importance of the User Among the hard theorems proved by Nqthm are * the existence and uniqueness of prime factorizations [ACL] * the invertibility of the RSA public key encryption algorithm [BM84c] * Wilson's theorem [Rus85], * Gauss's law of quadratic reciprocity [Rus92], * the tautology theorem (that every propositional tautology has a proof in Shoenfield's propositional logic) [Sha85], * Godel's incompleteness theorem (for Shoenfield's first order logic ex tended with <p> It also discusses successful styles of Nqthm use. Prospective users of Nqthm might also find the description of its heuristics in <ref> [ACL] </ref> to be of use, even though the description there is very low level. <p> Peter's version of it (Boyer, "basic/pr.events") a proof of the existence of nonprimitive recursive functions (Boyer and Moore, approximately Appendix A of <ref> [ACL] </ref>, "basic/proveall.events") 43 elementary list processing, number theory through Euclid's theorem and prime factorization, soundness and completeness of a tautology checker, correctness of the CANCEL metafunction, correctness of a simple assembly language program, correctness of a simple optimizing ex pression compiler (Boyer and Moore, [BM88a], "basic/quant.events") illustrations of the use of <p> Jamsek, "kaufmann/rpn.events") an exercise in reverse Polish notation evaluation (Kaufmann, "kaufmann/shuffle.events") another solution to the Gilbreath card trick challenge (see example file "basic/alternating.events") (Kunen, "kunen/ack.events") an illustrative definition of Ackermann's function (Kunen, "kunen/new-prime.events") an alternative proof of the fundamental theorem of arithmetic that - 47 unlike the one presented in <ref> [ACL] </ref> does not use concepts not involved in the statement of the theorem (Bevier, "numbers/bags.events") a library of useful definitions and lemmas about bags (Wilding, "numbers/extras.events") a trivial extension of the integers library used in fib2 below (Wilding, [Wil91], "numbers/fib2.events") a proof of Matijasevich's lemma about Fibonacci numbers (Bevier, Kaufmann, and
Reference: [ACLH] <author> R. S. Boyer and J S. Moore. </author> <title> A Computational Logic Handbook. </title> <publisher> Academic Press, </publisher> <address> New York, </address> <year> 1988. </year>
Reference-contexts: The 1978 book, A Computational Logic [ACL] is still a largely accurate and comprehensive description of how the theorem prover works. That version of the system has been reimplemented by at least three groups working from [ACL]. The book A Computational Logic Handbook <ref> [ACLH] </ref> (often called the "Nqthm handbook") contains a precise description of the Nqthm logic as it stood in 1988. In addition, [ACLH] indicates by appropriate bibliographic citations how to reconstruct the 1988 version of Nqthm from [ACL] and numerous journal articles about subsequent improvements. <p> That version of the system has been reimplemented by at least three groups working from [ACL]. The book A Computational Logic Handbook <ref> [ACLH] </ref> (often called the "Nqthm handbook") contains a precise description of the Nqthm logic as it stood in 1988. In addition, [ACLH] indicates by appropriate bibliographic citations how to reconstruct the 1988 version of Nqthm from [ACL] and numerous journal articles about subsequent improvements. However, the handbook is primarily devoted to a description of how to use the Nqthm logic and its mechanization. <p> Successful use of the extension principles require the proving of certain theorems that guarantee the conservation of the consistency of the logic. A precise description of the Nqthm logic may be found in Chapter 4 of the Nqthm handbook <ref> [ACLH] </ref>. The syntax of our logic resembles that of the Lisp programming language. For example, our definition of the Peano addition function is Definition. (PLUS I J) = (IF (ZEROP I) (FIX J) (ADD1 (PLUS (SUB1 I) J))). <p> The currently released version of Nqthm was first released in July of 1988, and no bugs affecting soundness have been reported as of the time of this writing. The chapter of the Nqthm handbook <ref> [ACLH] </ref> on installation describes in complete detail how to bring up Nqthm from the sources. It is our intention to release a new version of Nqthm, called Nqthm-1992, in 1993. <p> Such "backchaining" invites infinite regress and heuristics are present to limit such backchaining. As noted previously, details are given in [ACL] and <ref> [ACLH] </ref> and the papers cited in the latter. 10 2.3 Hard Theorems Proved and the Importance of the User Among the hard theorems proved by Nqthm are * the existence and uniqueness of prime factorizations [ACL] * the invertibility of the RSA public key encryption algorithm [BM84c] * Wilson's theorem [Rus85], <p> Almost all of the successful users of Nqthm have taken a course at the University of Texas at Austin on proving theorems in the Nqthm logic. The Nqthm handbook <ref> [ACLH] </ref> was written primarily to teach users how to use Nqthm's logic and the Nqthm system; the handbook describes in great detail the Nqthm commands and how to use them to control the system's behavior. It also discusses successful styles of Nqthm use.
Reference: [BBH72] <author> W. Bledsoe, R. S. Boyer, and W. Henneman. </author> <title> Computer proofs of limit theorems. </title> <journal> Artificial Intelligence, </journal> <volume> 3 </volume> <pages> 27-60, </pages> <year> 1972. </year>
Reference-contexts: Our theorem proving style has been inspired by the work of W. W. Bledsoe, most notably the work reported in [Ble71] and <ref> [BBH72] </ref>. The first version of the Boyer-Moore system was released in 1973 and we have continued to improve the system and periodically release new versions ever since.
Reference: [BGKM] <author> R.S. Boyer, D.M. Goldschlag, M. Kaufmann, and J S. Moore. </author> <title> Functional instantiation in first order logic. </title> <editor> In V. Lifschitz, editor, </editor> <booktitle> Artificial Intelligence and Mathematical Theory of Computation: Papers in Honor of John McCarthy, </booktitle> <pages> pages 7-26. </pages> <publisher> Academic Press, </publisher> <year> 1991. </year>
Reference-contexts: Nqthm-1992 differs from the older release pri 2 marily by supporting the introduction of undefined but constrained function symbols and the use of a derived rule of inference permitting the instantia-tion of function symbols, giving Nqthm-1992 a "higher-order" feel <ref> [BGKM] </ref>. Some performance improvements were made, a few new user commands were added, and many minor bugs were fixed. None of the bugs affected soundness. <p> Later, a derived rule of inference permits those theorems to be functionally instantiated, that is, the constrained function symbols may be replaced by other function symbols, provided it can be proved that the incoming symbols satisfy the constraints on the replaced ones. See <ref> [BGKM] </ref>. 6 2 Introduction to the Nqthm System The Nqthm system is a Common Lisp [Ste84] program of roughly one million characters. It is currently available by ftp from Internet host ftp.cli.com. There is no fee, but, at the insistence of our sponsors, a license agreement must be signed. <p> vehicle within a certain corridor of the desired course and, under more ideal conditions, homes to the course (Cowles, "basic/fibsums.events") proofs of several interesting theorems about the sums of Fibonacci num bers (Boyer and Moore, [BM81], "basic/fortran.events") supporting definitions for a Fortran verification condition generator (Boyer, Goldschlag, Kaufmann, and Moore, <ref> [BGKM] </ref>, "basic/fs-examples.events") illustrations of the use of constrained functions and functional instan tiation (Russinoff, [Rus92], "basic/gauss.events") the original Nqthm proof of Gauss' law of quadratic reciprocity (Russinoff, [Rus92], "basic/new-gauss.events") an improved proof of Gauss' law of quadratic reciprocity (after all, Gauss proved it eight times!) (Boyer and Moore, "basic/parser.events") a formalization
Reference: [BGM90] <author> R. S. Boyer, M. W. Green, and J S. Moore. </author> <title> The Use of a Formal Simulator to Verify a Simple Real Time Control Program. </title> <editor> In W.H.J. Feijen, A.J.M. van Gasteren, D. Gries, and J. Misra, editor, </editor> <title> Beauty is Our Business: A Birthday Salute to Edsger W. </title> <booktitle> Dijkstra, </booktitle> <pages> pages 54-66. </pages> <note> Springer-Verlag Texts and Monographs in Computer Science, </note> <year> 1990. </year>
Reference-contexts: that are described in the four papers cited above; the work includes a formalization of "string-functional semantics" for circuit descriptions and its use to verify the correctness properties of many circuits, including the Saxe-Leiserson retimed cor-relator, a pipelined ripple adder, and an abstract pipelined cpu 42 (Boyer, Moore, and Green, <ref> [BGM90] </ref>, "basic/controller.events") a model of the problem of controlling a vehicle's course and a proof that under certain conditions a particular program keeps the vehicle within a certain corridor of the desired course and, under more ideal conditions, homes to the course (Cowles, "basic/fibsums.events") proofs of several interesting theorems about the <p> the correctness of the FM9001 implementation (Boyer and Moore, [BM81], "fortran-vcg/fortran.events") the same file as basic/fortran, above, which is duplicated on this subdirectory for technical reasons (Boyer and Moore, [BM81], "fortran-vcg/fsrch.events") proofs of the verification conditions for a Fortran implementation of the Boyer-Moore fast string searching algorithm (Boyer and Moore, <ref> [BGM90] </ref>, "fortran-vcg/isqrt.events") proofs of the verification conditions for a Fortran implementation of the integer version of Newton's square root algorithm (Boyer and Moore, [BM91], "fortran-vcg/mjrty.events") proofs of the verification conditions for a Fortran implementation of a linear-time majority vote algorithm (Hunt, [Hun85], "hunt/fm8501.events") formalizations of the machine code for the 16-bit
Reference: [BKY90] <author> W. Bevier, M. Kaufmann, and W. Young. </author> <title> Translation of a Gypsy compiler example into the Boyer-Moore logic. Internal Note 169, Computational Logic, </title> <publisher> Inc., </publisher> <month> January </month> <year> 1990. </year> <month> 54 </month>
Reference: [BM75] <author> R. S. Boyer and J S. Moore. </author> <title> Proving theorems about Lisp func-tions. </title> <journal> JACM, </journal> <volume> 22(1) </volume> <pages> 129-144, </pages> <year> 1975. </year>
Reference: [BM77] <author> R. S. Boyer and J S. Moore. </author> <title> A lemma driven automatic theorem prover for recursive function theory. </title> <booktitle> In Proceedings of the 5th Joint Conference on Artificial Intelligence, </booktitle> <pages> pages 511-519. </pages> <booktitle> International Joint Conferences on Artifical Intelligence, </booktitle> <year> 1977. </year>
Reference: [BM81] <author> R. S. Boyer and J S. Moore. </author> <title> A verification condition generator for Fortran. In The Correctness Problem in Computer Science. </title> <publisher> Academic Press, </publisher> <address> London, </address> <year> 1981. </year>
Reference-contexts: a vehicle's course and a proof that under certain conditions a particular program keeps the vehicle within a certain corridor of the desired course and, under more ideal conditions, homes to the course (Cowles, "basic/fibsums.events") proofs of several interesting theorems about the sums of Fibonacci num bers (Boyer and Moore, <ref> [BM81] </ref>, "basic/fortran.events") supporting definitions for a Fortran verification condition generator (Boyer, Goldschlag, Kaufmann, and Moore, [BGKM], "basic/fs-examples.events") illustrations of the use of constrained functions and functional instan tiation (Russinoff, [Rus92], "basic/gauss.events") the original Nqthm proof of Gauss' law of quadratic reciprocity (Russinoff, [Rus92], "basic/new-gauss.events") an improved proof of Gauss' law of <p> correctness theorem for Piton); bounds on the program's execution time have been proved using Pc-Nqthm. 45 (Moore, [Moo88], "fm9001-piton/piton.events") the definition of the Piton assembly language, its implementation on the FM9001 via a compiler, assembler and linker, and a proof of the correctness of the FM9001 implementation (Boyer and Moore, <ref> [BM81] </ref>, "fortran-vcg/fortran.events") the same file as basic/fortran, above, which is duplicated on this subdirectory for technical reasons (Boyer and Moore, [BM81], "fortran-vcg/fsrch.events") proofs of the verification conditions for a Fortran implementation of the Boyer-Moore fast string searching algorithm (Boyer and Moore, [BGM90], "fortran-vcg/isqrt.events") proofs of the verification conditions for a Fortran <p> definition of the Piton assembly language, its implementation on the FM9001 via a compiler, assembler and linker, and a proof of the correctness of the FM9001 implementation (Boyer and Moore, <ref> [BM81] </ref>, "fortran-vcg/fortran.events") the same file as basic/fortran, above, which is duplicated on this subdirectory for technical reasons (Boyer and Moore, [BM81], "fortran-vcg/fsrch.events") proofs of the verification conditions for a Fortran implementation of the Boyer-Moore fast string searching algorithm (Boyer and Moore, [BGM90], "fortran-vcg/isqrt.events") proofs of the verification conditions for a Fortran implementation of the integer version of Newton's square root algorithm (Boyer and Moore, [BM91], "fortran-vcg/mjrty.events") proofs of the verification conditions
Reference: [BM81a] <author> R. S. Boyer and J S. Moore. </author> <title> The mechanical verification of a Fortran square root program. </title> <type> Csl report, </type> <institution> SRI International, </institution> <year> 1981. </year>
Reference: [BM81b] <author> R. S. Boyer and J S. Moore. Metafunctions: </author> <title> Proving them correct and using them efficiently as new proof procedures. In The Correctness Problem in Computer Science. </title> <publisher> Academic Press, </publisher> <address> London, </address> <year> 1981. </year>
Reference: [BM84a] <author> R. S. Boyer and J S. Moore. </author> <title> A mechanical proof of the Tur-ing completeness of Pure Lisp. In Automated Theorem Proving: </title> <type> After 25 Years, </type> <pages> pages 133-167. </pages> <publisher> American Mathematical Society, </publisher> <address> Providence, R.I., </address> <year> 1984. </year>
Reference-contexts: via the so-called "functional" and "inductive assertion" methods (Moore, "basic/tic-tac-toe.events") a formalization of what it means for a program to play non-losing tic-tac-toe, the proof that a certain algorithm does so, and the successive refinement of the algorithm into the functional expression of an iterative number-crunching program (Boyer and Moore, <ref> [BM84a] </ref>, "basic/tmi.events") proof of the Turing completeness of Pure Lisp (Boyer and Moore, [BM84b], "basic/unsolv.events") proof of the unsolvability of the halting problem for Pure Lisp (Russinoff, [Rus85], "basic/wilson.events") proof of Wilson's theorem (Moore, [Moo79], "basic/ztak.events") proof of the termination of Takeuchi's function (Bevier, [Bev87], "bevier/kit.events") the formalization, implementation and proof
Reference: [BM84b] <author> R. S. Boyer and J S. Moore. </author> <title> A mechanical proof of the unsolv-ability of the halting problem. </title> <journal> JACM, </journal> <volume> 31(3) </volume> <pages> 441-458, </pages> <year> 1984. </year>
Reference-contexts: what it means for a program to play non-losing tic-tac-toe, the proof that a certain algorithm does so, and the successive refinement of the algorithm into the functional expression of an iterative number-crunching program (Boyer and Moore, [BM84a], "basic/tmi.events") proof of the Turing completeness of Pure Lisp (Boyer and Moore, <ref> [BM84b] </ref>, "basic/unsolv.events") proof of the unsolvability of the halting problem for Pure Lisp (Russinoff, [Rus85], "basic/wilson.events") proof of Wilson's theorem (Moore, [Moo79], "basic/ztak.events") proof of the termination of Takeuchi's function (Bevier, [Bev87], "bevier/kit.events") the formalization, implementation and proof that a simple separation 44 kernel (implementing multi-processing on a uniprocessor) provides pro-cess
Reference: [BM84c] <author> R. S. Boyer and J S. Moore. </author> <title> Proof checking the RSA public key encryption algorithm. </title> <journal> American Mathematical Monthly, </journal> <volume> 91(3) </volume> <pages> 181-189, </pages> <year> 1984. </year>
Reference-contexts: given in [ACL] and [ACLH] and the papers cited in the latter. 10 2.3 Hard Theorems Proved and the Importance of the User Among the hard theorems proved by Nqthm are * the existence and uniqueness of prime factorizations [ACL] * the invertibility of the RSA public key encryption algorithm <ref> [BM84c] </ref> * Wilson's theorem [Rus85], * Gauss's law of quadratic reciprocity [Rus92], * the tautology theorem (that every propositional tautology has a proof in Shoenfield's propositional logic) [Sha85], * Godel's incompleteness theorem (for Shoenfield's first order logic ex tended with Cohen's axioms for hereditarily finite set theory, Z2) [Sha86], and * <p> language program, correctness of a simple optimizing ex pression compiler (Boyer and Moore, [BM88a], "basic/quant.events") illustrations of the use of V&C$ and FOR, including a study of several partial functions and functions, such as the "91 function," that recurse on the value of their own recursive calls (Boyer and Moore, <ref> [BM84c] </ref>, "basic/rsa.events") proof of the invertibility of the public key encryption algorithm of Rivest, Shamir, and Adleman (Moore, "basic/small-machine.events") a simple operational semantics and its use to prove program properties directly and via the so-called "functional" and "inductive assertion" methods (Moore, "basic/tic-tac-toe.events") a formalization of what it means for a program
Reference: [BM85] <author> R. S. Boyer and J S. Moore. </author> <title> Program verification. </title> <journal> Journal of Automated Reasoning, </journal> <volume> 1(1) </volume> <pages> 17-23, </pages> <year> 1985. </year>
Reference: [BM88a] <author> R. S. Boyer and J S. Moore. </author> <title> The addition of bounded quantification and partial functions to a computational logic and its theorem prover. </title> <journal> Journal of Automated Reasoning, </journal> <volume> 4(2) </volume> <pages> 117-172, </pages> <year> 1988. </year>
Reference-contexts: previously arranged into alternating colors; the Nqthm attack on this problem was inspired by Gerard Huet's use of the COQ theorem prover to do the proof [Hue91] (Moore, [Moo91], "basic/async18.events") a model of asynchronous communication and a proof of the reliability of the biphase mark communications protocol (Boyer and Moore, <ref> [BM88a] </ref>, "basic/binomial.events") the binomial theorem expressed with FOR and a proof thereof (Bronstein and Talcott, [BT88, Bro89, BT89b, BT89a], "bronstein/*.events") a collection of twenty six event files that are described in the four papers cited above; the work includes a formalization of "string-functional semantics" for circuit descriptions and its use to <p> and Moore, approximately Appendix A of [ACL], "basic/proveall.events") 43 elementary list processing, number theory through Euclid's theorem and prime factorization, soundness and completeness of a tautology checker, correctness of the CANCEL metafunction, correctness of a simple assembly language program, correctness of a simple optimizing ex pression compiler (Boyer and Moore, <ref> [BM88a] </ref>, "basic/quant.events") illustrations of the use of V&C$ and FOR, including a study of several partial functions and functions, such as the "91 function," that recurse on the value of their own recursive calls (Boyer and Moore, [BM84c], "basic/rsa.events") proof of the invertibility of the public key encryption algorithm of Rivest,
Reference: [BM88b] <author> R. S. Boyer and J S. Moore. </author> <title> Integrating decision procedures into heuristic theorem provers: A case study with linear arithmetic. </title> <booktitle> In Machine Intelligence 11. </booktitle> <publisher> Oxford University Press, </publisher> <year> 1988. </year>
Reference: [BM91] <author> R. S. Boyer and J S. Moore. </author> <title> MJRTY A Fast Majority Vote Algorithm, pages 105-117. Automated Reasoning Series, </title> <publisher> Kluwer Academic Publishers, </publisher> <address> Dordrecht, The Netherlands, </address> <year> 1991. </year>
Reference-contexts: for technical reasons (Boyer and Moore, [BM81], "fortran-vcg/fsrch.events") proofs of the verification conditions for a Fortran implementation of the Boyer-Moore fast string searching algorithm (Boyer and Moore, [BGM90], "fortran-vcg/isqrt.events") proofs of the verification conditions for a Fortran implementation of the integer version of Newton's square root algorithm (Boyer and Moore, <ref> [BM91] </ref>, "fortran-vcg/mjrty.events") proofs of the verification conditions for a Fortran implementation of a linear-time majority vote algorithm (Hunt, [Hun85], "hunt/fm8501.events") formalizations of the machine code for the 16-bit FM8501 microprocessor, a register transfer model of a microcoded implementation of the machine, and a proof of their correspondence (Kaufmann, see Young [You90],
Reference: [BSvHIS] <author> A. Bundy, A. Stevens, F. van Harmelen, A. Ireland, and A. Smaill. Rippling: </author> <title> A Heuristic for Guiding Inductive Proofs. </title> <note> Department of Artificial Intelligence Research Paper No. 567, Edinburgh University 1991. To appear in The Journal of Artificial Intelligence. </note>
Reference-contexts: We should note that in contrast to our approach, there has also been promising research on the mechanization of induction in the presence of quantifiers; see for example <ref> [BSvHIS] </ref>. When theorems are added to the data base, the user must specify how they are to be used later. The various proof techniques query different parts 9 of the data base for relevant theorems.
Reference: [BT88] <author> A. Bronstein and C. Talcott. </author> <title> String-functional semantics for formal verification of synchronous circuits, Report No. STAN-CS-88-1210. </title> <type> Technical report, </type> <institution> Computer Science Department, Stanford University, </institution> <year> 1988. </year>
Reference-contexts: Huet's use of the COQ theorem prover to do the proof [Hue91] (Moore, [Moo91], "basic/async18.events") a model of asynchronous communication and a proof of the reliability of the biphase mark communications protocol (Boyer and Moore, [BM88a], "basic/binomial.events") the binomial theorem expressed with FOR and a proof thereof (Bronstein and Talcott, <ref> [BT88, Bro89, BT89b, BT89a] </ref>, "bronstein/*.events") a collection of twenty six event files that are described in the four papers cited above; the work includes a formalization of "string-functional semantics" for circuit descriptions and its use to verify the correctness properties of many circuits, including the Saxe-Leiserson retimed cor-relator, a pipelined ripple
Reference: [BT89a] <author> A. Bronstein and C. Talcott. </author> <title> Formal verification of pipelines based on string-functional semantics. </title> <booktitle> In IFIP International Workshop on Applied Formal Methods for Correct VLSI Design, </booktitle> <address> Leuven, Belgium, </address> <year> 1989. </year>
Reference-contexts: Huet's use of the COQ theorem prover to do the proof [Hue91] (Moore, [Moo91], "basic/async18.events") a model of asynchronous communication and a proof of the reliability of the biphase mark communications protocol (Boyer and Moore, [BM88a], "basic/binomial.events") the binomial theorem expressed with FOR and a proof thereof (Bronstein and Talcott, <ref> [BT88, Bro89, BT89b, BT89a] </ref>, "bronstein/*.events") a collection of twenty six event files that are described in the four papers cited above; the work includes a formalization of "string-functional semantics" for circuit descriptions and its use to verify the correctness properties of many circuits, including the Saxe-Leiserson retimed cor-relator, a pipelined ripple
Reference: [BT89b] <author> A. Bronstein and C. Talcott. </author> <title> Formal verification of synchronous circuits based on string-functional semantics: The 7 Paillet circuits in Boyer-Moore. In C-Cube 1989 Workshop on Automatic Verification Methods for Finite State Systems. </title> <publisher> LNCS 407, </publisher> <pages> pages 317-333, </pages> <year> 1989. </year>
Reference-contexts: Huet's use of the COQ theorem prover to do the proof [Hue91] (Moore, [Moo91], "basic/async18.events") a model of asynchronous communication and a proof of the reliability of the biphase mark communications protocol (Boyer and Moore, [BM88a], "basic/binomial.events") the binomial theorem expressed with FOR and a proof thereof (Bronstein and Talcott, <ref> [BT88, Bro89, BT89b, BT89a] </ref>, "bronstein/*.events") a collection of twenty six event files that are described in the four papers cited above; the work includes a formalization of "string-functional semantics" for circuit descriptions and its use to verify the correctness properties of many circuits, including the Saxe-Leiserson retimed cor-relator, a pipelined ripple
Reference: [BY92] <author> R.S. Boyer and Y. Yu. </author> <title> A formal specification of some user mode instructions for the motorola 68020. </title> <type> Technical Report TR-92-04, </type> <institution> Computer Sciences Department, University of Texas, Austin, </institution> <month> February </month> <year> 1992. </year>
Reference-contexts: roots via Newton's method (Yu, "yu/log2.events") the correctness proof for the MC68020 machine code produced by the Gnu C compiler for a C program for computing integer logarithms (base 2) e.g., repeated division by 2 (Yu, [Yu92], "yu/mc20-0.events") some utilities involved in the formal specification of the MC68020 50 (Yu, <ref> [BY92] </ref>, "yu/mc20-1.events") the formal specification of about 80% of the user available instructions for the Motorola MC68020 microprocessor (Yu, [Yu92], "yu/mc20-2.events") a library of useful definitions and lemmas about the formalization of the MC68020 (Yu, "yu/mjrty.events") the correctness proof for the MC68020 machine code produced by the Gnu C compiler for
Reference: [Bev87] <author> W. Bevier. </author> <title> A Verified Operating System Kernel. </title> <type> PhD thesis, </type> <institution> University of Texas at Austin, </institution> <year> 1987. </year>
Reference-contexts: iterative number-crunching program (Boyer and Moore, [BM84a], "basic/tmi.events") proof of the Turing completeness of Pure Lisp (Boyer and Moore, [BM84b], "basic/unsolv.events") proof of the unsolvability of the halting problem for Pure Lisp (Russinoff, [Rus85], "basic/wilson.events") proof of Wilson's theorem (Moore, [Moo79], "basic/ztak.events") proof of the termination of Takeuchi's function (Bevier, <ref> [Bev87] </ref>, "bevier/kit.events") the formalization, implementation and proof that a simple separation 44 kernel (implementing multi-processing on a uniprocessor) provides pro-cess scheduling, error handling, message passing, and interfaces to asyn chronous devices (Cowles, "cowles/intro-eg.events") a brief introduction to Nqthm intended for mathematicians and a proof of a theorem about factorial (Cowles, "cowles/shell.events")
Reference: [Bev88] <author> W. Bevier. </author> <title> A library for hardware verification. Internal Note 57, Computational Logic, </title> <publisher> Inc., 1717 W. </publisher> <address> Sixth Street, Suite 290, Austin, TX 78703, </address> <month> August </month> <year> 1988. </year> <month> 56 </month>
Reference-contexts: useful definitions and lemmas about bags (Wilding, "numbers/extras.events") a trivial extension of the integers library used in fib2 below (Wilding, [Wil91], "numbers/fib2.events") a proof of Matijasevich's lemma about Fibonacci numbers (Bevier, Kaufmann, and Wilding, [Kau90a], "numbers/integers.events") a library of useful definitions and lemmas about the integers (Bevier, Kaufmann, and Wilding, <ref> [Bev88] </ref>, "numbers/naturals.events") a library of useful definitions and lemmas about the natural numbers (Wilding, "numbers/nim.events") a formalization of the game of Nim and a proof that a certain algorithm implements a winning strategy (Shankar, [Sha88], "shankar/church-rosser.events") a proof of the Church-Rosser theorem for lambda-calculus (Shankar, [Sha86], "shankar/goedel.events") a proof of Godel's <p> the ory (Kaufmann, "defn-sk/finite-state-machine-example.events") a little finite state machine example (Kaufmann, [Kau92b], "defn-sk/koenig.events") a formalization of Koenig's Tree Lemma, which says that any finitely branching tree which is infinite has an infinite branch 52 (Kaufmann, [Kau92b], "defn-sk/ramsey.events") proof of a formalization of the infinite Ramsey Theorem for exponent 2 (Bevier, <ref> [Bev88] </ref>, "dmg/bags.events") some supporting events about bags (Goldschlag, [Gol91], "dmg/dining.events") the verification of a dining philosopher's program, under the assumptions of deadlock freedom and strong fairness, using a mechanized im plementation of Unity on the Boyer-Moore prover (Goldschlag, [Gol90d], "dmg/fifo.events") the verification of both the safety and liveness properties of an <p> program satisfying both mutual exclusion and absence of starvation, using a mechanized implementation of Unity on the Boyer-Moore prover (Goldschlag [GolThesis], "dmg/min.events") the correctness of a distributed algorithm that computes the minimum node value in a tree, using a mechanized implementation of Unity on the Boyer-Moore prover (Bevier and Wilding, <ref> [Bev88] </ref>, "dmg/naturals.events") some supporting events about natural numbers (Kaufmann, [Kau91b], "generalize/*.events") the correctness of a generalization algorithm that operates in the presence of free variables; same as the corresponding events from the Nqthm example suite, except that the quantifier (DEFN-SK, [Kau92b]) events have been replaced by DCL and ADD-AXIOM events in
Reference: [Bev89] <author> W. Bevier. </author> <title> Kit and the short stack. </title> <journal> Journal of Automated Rea--soning, </journal> <volume> 5(4) </volume> <pages> 519-530, </pages> <year> 1989. </year>
Reference: [Ble71] <author> W. W. Bledsoe. </author> <title> Splitting and reduction heuristics in automatic theorem proving. </title> <journal> Artificial Intelligence, </journal> <volume> 2 </volume> <pages> 55-77, </pages> <year> 1971. </year>
Reference-contexts: Our theorem proving style has been inspired by the work of W. W. Bledsoe, most notably the work reported in <ref> [Ble71] </ref> and [BBH72]. The first version of the Boyer-Moore system was released in 1973 and we have continued to improve the system and periodically release new versions ever since.
Reference: [Bou68] <author> N. Bourbaki. </author> <title> Elements of Mathematics. </title> <publisher> Addison Wesley, </publisher> <address> Reading, Massachusetts, </address> <year> 1968. </year>
Reference: [Bro89] <author> A. Bronstein. </author> <title> MLP: String-functional semantics and Boyer-Moore mechanization for the formal verification of synchronous circuits. </title> <type> PhD thesis, </type> <institution> Stanford University, </institution> <year> 1989. </year>
Reference-contexts: Huet's use of the COQ theorem prover to do the proof [Hue91] (Moore, [Moo91], "basic/async18.events") a model of asynchronous communication and a proof of the reliability of the biphase mark communications protocol (Boyer and Moore, [BM88a], "basic/binomial.events") the binomial theorem expressed with FOR and a proof thereof (Bronstein and Talcott, <ref> [BT88, Bro89, BT89b, BT89a] </ref>, "bronstein/*.events") a collection of twenty six event files that are described in the four papers cited above; the work includes a formalization of "string-functional semantics" for circuit descriptions and its use to verify the correctness properties of many circuits, including the Saxe-Leiserson retimed cor-relator, a pipelined ripple
Reference: [Bur69] <author> R. Burstall. </author> <title> Proving properties of programs by structural induction. </title> <journal> The Computer Journal, </journal> <volume> 12(1) </volume> <pages> 41-48, </pages> <year> 1969. </year>
Reference-contexts: The mathematical logic behind our work was largely inspired by McCarthy's seminal papers on the logic of Lisp, including [McC60b], [McC62b], and [McC63]. See also <ref> [Bur69] </ref>, [Goo64], and [Sko67] for related work on quantifier free logics for arithmetic. Since Lisp may be viewed simultaneously as a logic and an applicative programming language, it is a natural vehicle for the expression of theorems about computations and constructive mathematics in general.
Reference: [Cho88] <author> S. Chou. </author> <title> Mechancial Geometry Theorem Proving. </title> <publisher> Reidel, </publisher> <year> 1988. </year>
Reference: [Fla92] <author> A. Flatau. </author> <title> A Verified Implementation of an Applicative Language with Dynamic Storage Allocation. </title> <type> PhD thesis, </type> <institution> University of Texas, </institution> <year> 1992. </year> <note> Also available through Computational Logic, </note> <institution> Inc., </institution> <address> Suite 290, 1717 West Sixth Street, Austin, TX 78703. </address>
Reference-contexts: multi-processing on a uniprocessor) provides pro-cess scheduling, error handling, message passing, and interfaces to asyn chronous devices (Cowles, "cowles/intro-eg.events") a brief introduction to Nqthm intended for mathematicians and a proof of a theorem about factorial (Cowles, "cowles/shell.events") alternative ways to decompose sequences and a study of Nqthm's shell principle (Flatau, <ref> [Fla92] </ref>, "flatau/app-c-d-e.events") the development and proof of correctness of a compiler and runtime system for a subset of the Nqthm language (including IF, CONS, and subroutine call) requiring dynamic storage allocation; this event list corresponds to Appendices C, D, and E of [Fla92] and deals with a runtime system that does <p> and a study of Nqthm's shell principle (Flatau, <ref> [Fla92] </ref>, "flatau/app-c-d-e.events") the development and proof of correctness of a compiler and runtime system for a subset of the Nqthm language (including IF, CONS, and subroutine call) requiring dynamic storage allocation; this event list corresponds to Appendices C, D, and E of [Fla92] and deals with a runtime system that does not provide a garbage collector. (Flatau, [Fla92], "flatau/app-f.events") this event file is analogous to the immediately preceding one, but corresponds to Appendix F of [Fla92] and deals with a runtime system including a reference counting garbage collector. (Moore, [Moo88], "fm9001-piton/big-add.events") a proof <p> correctness of a compiler and runtime system for a subset of the Nqthm language (including IF, CONS, and subroutine call) requiring dynamic storage allocation; this event list corresponds to Appendices C, D, and E of <ref> [Fla92] </ref> and deals with a runtime system that does not provide a garbage collector. (Flatau, [Fla92], "flatau/app-f.events") this event file is analogous to the immediately preceding one, but corresponds to Appendix F of [Fla92] and deals with a runtime system including a reference counting garbage collector. (Moore, [Moo88], "fm9001-piton/big-add.events") a proof of the correctness of a Piton program for adding arbitrarily long numbers in base 2 <p> subroutine call) requiring dynamic storage allocation; this event list corresponds to Appendices C, D, and E of <ref> [Fla92] </ref> and deals with a runtime system that does not provide a garbage collector. (Flatau, [Fla92], "flatau/app-f.events") this event file is analogous to the immediately preceding one, but corresponds to Appendix F of [Fla92] and deals with a runtime system including a reference counting garbage collector. (Moore, [Moo88], "fm9001-piton/big-add.events") a proof of the correctness of a Piton program for adding arbitrarily long numbers in base 2 32 (Brock and Hunt, [HB92], "fm9001-piton/fm9001.events") formalizations of a netlist description language, the machine code for the 32-bit
Reference: [GSY] <author> D. I. Good, Ann E. Siebert, and W. D. Young. </author> <title> Middle Gypsy 2.05 Definition. </title> <type> Technical Report 59, </type> <institution> Computational Logic, Inc., </institution> <month> May </month> <year> 1990. </year>
Reference-contexts: presence of free variables; same as the corresponding events from the Nqthm example suite, except that the quantifier (DEFN-SK, [Kau92b]) events have been replaced by DCL and ADD-AXIOM events in that version 53 (Young, [You89], "mg/*.events") a mechanically-verified code-generator for micro-Gypsy, which is a Pas cal-like language (Good, Siebert, Young, <ref> [GSY] </ref>, "middle-gypsy/*.events") a mathematical definition of a subset of the Gypsy 2.05 language, in cluding a preliminary rationals library created by Matt Wilding (Wilding, "wilding/ground-resolution.events") a proof of the completeness of ground resolution using Bledsoe's excess literal technique
Reference: [Gar60] <author> M. Gardner. </author> <title> Mathematical recreation column. </title> <journal> Scientific American, </journal> 203(2) 149-154, August, 1960. 
Reference-contexts: Each file has been successfully processed by PROVE-FILE. The files are listed in alphabetical order. Much of this text appears essentially in [Kau92a]. 5.1 Nqthm example event files First we list the example files for Nqthm. (Boyer, "basic/alternating.events") a formalization and correctness proof of the "Gilbreath Trick" <ref> [Gar60, Gil58] </ref>, a card trick having to do with the outcome of shu*ing a deck of cards that has been previously arranged into alternating colors; the Nqthm attack on this problem was inspired by Gerard Huet's use of the COQ theorem prover to do the proof [Hue91] (Moore, [Moo91], "basic/async18.events") a
Reference: [Gil58] <author> N. Gilbreath. </author> <title> Magnetic colors. The Linking Ring, </title> <address> 38(5):60, </address> <year> 1958. </year>
Reference-contexts: Each file has been successfully processed by PROVE-FILE. The files are listed in alphabetical order. Much of this text appears essentially in [Kau92a]. 5.1 Nqthm example event files First we list the example files for Nqthm. (Boyer, "basic/alternating.events") a formalization and correctness proof of the "Gilbreath Trick" <ref> [Gar60, Gil58] </ref>, a card trick having to do with the outcome of shu*ing a deck of cards that has been previously arranged into alternating colors; the Nqthm attack on this problem was inspired by Gerard Huet's use of the COQ theorem prover to do the proof [Hue91] (Moore, [Moo91], "basic/async18.events") a
Reference: [Gol90a] <author> D. M. Goldschlag. </author> <title> Proving proof rules: A proof system for concurrent programs. </title> <type> Compass '90, </type> <month> June </month> <year> 1990. </year>
Reference: [Gol90b] <author> D. M. Goldschlag. </author> <title> Mechanically verifying concurrent programs with the Boyer-Moore prover. </title> <journal> IEEE Transactions on Software Engineering, </journal> <month> September </month> <year> 1990. </year> <note> To appear. 57 </note>
Reference: [Gol90c] <author> D. M. Goldschlag. </author> <title> Mechanizing Unity. </title> <booktitle> In Proceedings of the IFIP TC2/WG2.3 Working Conference on Programming Concepts and Methods. </booktitle> <publisher> Elsevier, </publisher> <address> Amsterdam, </address> <year> 1990. </year>
Reference-contexts: under the assumptions of deadlock freedom and strong fairness, using a mechanized im plementation of Unity on the Boyer-Moore prover (Goldschlag, [Gol90d], "dmg/fifo.events") the verification of both the safety and liveness properties of an n-node delay insensitive fifo circuit, using a mechanized implementation of Unity on the Boyer-Moore prover (Goldschlag <ref> [Gol90c] </ref>, "dmg/interpreter.events") a mechanized implementation of Unity on the Boyer-Moore prover (Goldschlag [GolThesis], "dmg/me.events") verification of an n-processor program satisfying both mutual exclusion and absence of starvation, using a mechanized implementation of Unity on the Boyer-Moore prover (Goldschlag [GolThesis], "dmg/min.events") the correctness of a distributed algorithm that computes the minimum node
Reference: [Gol90d] <author> D. M. Goldschlag. </author> <title> Mechanically Verifying Safety and Liveness Properties of Delay Insensitive Circuits. </title> <booktitle> Computer Aided Verification 1991, </booktitle> <month> July, </month> <year> 1991. </year>
Reference-contexts: of a formalization of the infinite Ramsey Theorem for exponent 2 (Bevier, [Bev88], "dmg/bags.events") some supporting events about bags (Goldschlag, [Gol91], "dmg/dining.events") the verification of a dining philosopher's program, under the assumptions of deadlock freedom and strong fairness, using a mechanized im plementation of Unity on the Boyer-Moore prover (Goldschlag, <ref> [Gol90d] </ref>, "dmg/fifo.events") the verification of both the safety and liveness properties of an n-node delay insensitive fifo circuit, using a mechanized implementation of Unity on the Boyer-Moore prover (Goldschlag [Gol90c], "dmg/interpreter.events") a mechanized implementation of Unity on the Boyer-Moore prover (Goldschlag [GolThesis], "dmg/me.events") verification of an n-processor program satisfying both mutual
Reference: [Gol91] <author> D. M. Goldschlag. </author> <title> A Mechanical Formalization of Several Fairness Notions. </title> <editor> In S. Prehn and W.J. Toetenel, editors, </editor> <booktitle> VDM '91: Formal Software Development Methods, </booktitle> <pages> pages 133-167. </pages> <note> Springer-Verlag Lecture Notes in Computer Science 551, </note> <year> 1991. </year>
Reference-contexts: machine example (Kaufmann, [Kau92b], "defn-sk/koenig.events") a formalization of Koenig's Tree Lemma, which says that any finitely branching tree which is infinite has an infinite branch 52 (Kaufmann, [Kau92b], "defn-sk/ramsey.events") proof of a formalization of the infinite Ramsey Theorem for exponent 2 (Bevier, [Bev88], "dmg/bags.events") some supporting events about bags (Goldschlag, <ref> [Gol91] </ref>, "dmg/dining.events") the verification of a dining philosopher's program, under the assumptions of deadlock freedom and strong fairness, using a mechanized im plementation of Unity on the Boyer-Moore prover (Goldschlag, [Gol90d], "dmg/fifo.events") the verification of both the safety and liveness properties of an n-node delay insensitive fifo circuit, using a mechanized
Reference: [GolThesis] <author> D. M. Goldschlag. </author> <title> Mechanically Verifying Concurrent Programs. </title> <type> PhD thesis, </type> <institution> University of Texas at Austin, </institution> <year> 1992. </year>
Reference-contexts: im plementation of Unity on the Boyer-Moore prover (Goldschlag, [Gol90d], "dmg/fifo.events") the verification of both the safety and liveness properties of an n-node delay insensitive fifo circuit, using a mechanized implementation of Unity on the Boyer-Moore prover (Goldschlag [Gol90c], "dmg/interpreter.events") a mechanized implementation of Unity on the Boyer-Moore prover (Goldschlag <ref> [GolThesis] </ref>, "dmg/me.events") verification of an n-processor program satisfying both mutual exclusion and absence of starvation, using a mechanized implementation of Unity on the Boyer-Moore prover (Goldschlag [GolThesis], "dmg/min.events") the correctness of a distributed algorithm that computes the minimum node value in a tree, using a mechanized implementation of Unity on the <p> circuit, using a mechanized implementation of Unity on the Boyer-Moore prover (Goldschlag [Gol90c], "dmg/interpreter.events") a mechanized implementation of Unity on the Boyer-Moore prover (Goldschlag <ref> [GolThesis] </ref>, "dmg/me.events") verification of an n-processor program satisfying both mutual exclusion and absence of starvation, using a mechanized implementation of Unity on the Boyer-Moore prover (Goldschlag [GolThesis], "dmg/min.events") the correctness of a distributed algorithm that computes the minimum node value in a tree, using a mechanized implementation of Unity on the Boyer-Moore prover (Bevier and Wilding, [Bev88], "dmg/naturals.events") some supporting events about natural numbers (Kaufmann, [Kau91b], "generalize/*.events") the correctness of a generalization algorithm that operates in the
Reference: [Goo64] <author> R. L. Goodstein. </author> <title> Recursive Number Theory. </title> <publisher> North-Holland Publishing Company, </publisher> <address> Amsterdam, </address> <year> 1964. </year>
Reference-contexts: The mathematical logic behind our work was largely inspired by McCarthy's seminal papers on the logic of Lisp, including [McC60b], [McC62b], and [McC63]. See also [Bur69], <ref> [Goo64] </ref>, and [Sko67] for related work on quantifier free logics for arithmetic. Since Lisp may be viewed simultaneously as a logic and an applicative programming language, it is a natural vehicle for the expression of theorems about computations and constructive mathematics in general.
Reference: [HB92] <author> W.A. Hunt Jr. and B. Brock. </author> <title> A formal HDL and its use in the FM9001 verification. </title> <journal> Proceedings of the Royal Society, </journal> <note> (to appear, </note> <month> April </month> <year> 1992), 1992. </year>
Reference-contexts: is analogous to the immediately preceding one, but corresponds to Appendix F of [Fla92] and deals with a runtime system including a reference counting garbage collector. (Moore, [Moo88], "fm9001-piton/big-add.events") a proof of the correctness of a Piton program for adding arbitrarily long numbers in base 2 32 (Brock and Hunt, <ref> [HB92] </ref>, "fm9001-piton/fm9001.events") formalizations of a netlist description language, the machine code for the 32-bit FM9001 microprocessor, the design of an implementation of the processor, and a proof of the correspondence of the design and the machine code specification (Wilding, [Wil92], "fm9001-piton/nim-piton.events") a proof that a given 300-line Piton program plays the
Reference: [Hea08] <author> T. L. </author> <title> Heath (translation and commentary). The Thirteen Books of Euclid's Elements. </title> <publisher> Dover, </publisher> <address> New York, </address> <year> 1908. </year> <editor> p. </editor> <volume> 298, Vol 2., </volume> <pages> i.e. </pages> <note> Proposition 2, Book VII. </note>
Reference-contexts: 49 (Yu, [Yu92], "yu/fmax.events") the correctness proof for the MC68020 machine code produced by the Gnu C compiler for a trivial C program to compute the maximum of two integers according to a supplied comparison function (the object being to demonstrate that C "function pointers" are handled) (Yu, [Yu92] (also <ref> [Hea08] </ref>), "yu/gcd.events") the correctness proof for the MC68020 machine code produced by the Gnu C compiler for Euclid's greatest common divisor algorithm written in C (Yu, [Yu92], "yu/gcd3.events") the correctness proof for the MC68020 machine code produced by the Gnu C compiler for a C program consisting of two nested calls
Reference: [Hue91] <author> G. Huet. </author> <title> The Gilbreath trick: A case study in axiomatization and proof development in the COQ proof assistant. </title> <type> Technical Report 1511, </type> <institution> INRIA, Domaine de Voluceau, </institution> <address> Rocquencourt B.P. 105, 78153 Le Chesnay Cedex, France, </address> <year> 1991. </year>
Reference-contexts: of the "Gilbreath Trick" [Gar60, Gil58], a card trick having to do with the outcome of shu*ing a deck of cards that has been previously arranged into alternating colors; the Nqthm attack on this problem was inspired by Gerard Huet's use of the COQ theorem prover to do the proof <ref> [Hue91] </ref> (Moore, [Moo91], "basic/async18.events") a model of asynchronous communication and a proof of the reliability of the biphase mark communications protocol (Boyer and Moore, [BM88a], "basic/binomial.events") the binomial theorem expressed with FOR and a proof thereof (Bronstein and Talcott, [BT88, Bro89, BT89b, BT89a], "bronstein/*.events") a collection of twenty six event files
Reference: [Hun85] <author> W.A. Hunt, Jr. FM8501: </author> <title> A Verified Microprocessor. </title> <type> PhD thesis, </type> <institution> University of Texas at Austin, </institution> <year> 1985. </year>
Reference-contexts: the Boyer-Moore fast string searching algorithm (Boyer and Moore, [BGM90], "fortran-vcg/isqrt.events") proofs of the verification conditions for a Fortran implementation of the integer version of Newton's square root algorithm (Boyer and Moore, [BM91], "fortran-vcg/mjrty.events") proofs of the verification conditions for a Fortran implementation of a linear-time majority vote algorithm (Hunt, <ref> [Hun85] </ref>, "hunt/fm8501.events") formalizations of the machine code for the 16-bit FM8501 microprocessor, a register transfer model of a microcoded implementation of the machine, and a proof of their correspondence (Kaufmann, see Young [You90], "kaufmann/expr-compiler.events") the proof of correctness of a simple expression compiler, designed as an exercise for beginners (Kaufmann, "kaufmann/foldr.events")
Reference: [Hun89] <author> W. A. Hunt, Jr.. </author> <title> Microprocessor design verification. </title> <journal> Journal of Automated Reasoning, </journal> <volume> 5(4) </volume> <pages> 429-460, </pages> <year> 1989. </year>
Reference: [KR88] <author> B.W. Kernighan and D.M. Ritchie. </author> <title> The C Programming Language, Second Edition. </title> <publisher> Prentice Hall, </publisher> <year> 1988. </year> <month> 58 </month>
Reference-contexts: by the Gnu C compiler for a linear time majority vote algorithm written in C (Yu, "yu/qsort.events") the correctness proof for the MC68020 machine code produced by the Gnu C compiler for Hoare's in situ quick sort program written in C; the source code is that on page 87 of <ref> [KR88] </ref> except that inline code is used rather than the subroutine swap; Yu reports (private communication) that this change was made only because he was, at the time, investigating methods of proving recursive programs correct and did not want to be distracted by other subroutine calls (Yu, [Yu92], "yu/switch.events") the correctness
Reference: [KW89] <author> M. Kaufmann and M. Wilding. </author> <title> A parallel version of the Boyer--Moore prover. </title> <type> Technical Report 39, </type> <institution> Computational Logic, Inc., </institution> <month> February </month> <year> 1989. </year>
Reference: [KY87] <author> M. Kaufmann and W. D. Young. </author> <title> Comparing Gypsy and the Boyer-Moore logic for specifying secure systems. </title> <type> Technical report, </type> <institution> Institute for Computing Science, University of Texas at Austin, </institution> <month> May </month> <year> 1987. </year> <month> ICSCA-CMP-59. </month>
Reference: [Kau86] <author> M. Kaufmann. </author> <title> A mechanically-checked semi-interactive proof of correctness of Gries's algorithm for finding the largest size of a square true submatrix. Internal Note 236, </title> <institution> Institute for Computing Science, University of Texas at Austin, </institution> <month> October </month> <year> 1986. </year>
Reference-contexts: ugly formalization of the irrationality of the square root of 2 (Kaufmann, "basic/subset.events") some supporting events about lists and their use as an implementation of sets (Kaufmann, "basic/symmetric-difference.events") commutativity and associativity of symmetric difference as a set oper ation (Kaufmann, "basic/transitive-closure.events") proof of correctness of a transitive closure algorithm (Kaufmann, <ref> [Kau86] </ref>, "basic/tsquare.events") proof of correctness of a "true square" algorithm of Gries (Kaufmann, [Kau92b], "defn-sk/csb.events") proof of a formalization of the Schroeder-Bernstein theorem of set the ory (Kaufmann, "defn-sk/finite-state-machine-example.events") a little finite state machine example (Kaufmann, [Kau92b], "defn-sk/koenig.events") a formalization of Koenig's Tree Lemma, which says that any finitely branching tree
Reference: [Kau87] <author> M. Kaufmann. </author> <title> A formal semantics and proof of soundness for the logic of the Nqthm version of the Boyer-Moore theorem prover. Internal Note 229, </title> <institution> Institute for Computing Science, University of Texas at Austin, </institution> <month> February </month> <year> 1987. </year>
Reference: [Kau88] <author> M. Kaufmann. </author> <title> A user's manual for an interactive enhancement to the Boyer-Moore theorem prover. </title> <type> Technical Report 19, </type> <institution> Computational Logic, Inc., </institution> <month> May </month> <year> 1988. </year>
Reference-contexts: The low-level approach is also undesirable because it doesn't encourage the discovery of valuable rewrite rules that can be useful in subsequent proofs. A user's manual <ref> [Kau88] </ref> provides other examples and more detail about the logical foundations of the system's backward-directed proof method. It also covers advanced topics such as the writing of macro commands.
Reference: [Kau88a] <author> M. Kaufmann. </author> <title> Boyer-Moore-ish Micro Gypsy and a prototype hardware expander. Internal Note 73, Computational Logic, </title> <publisher> Inc., </publisher> <month> August </month> <year> 1988. </year>
Reference: [Kau88b] <author> M. Kaufmann. </author> <title> An example in Nqthm: Ramsey's theorem. Internal Note 100, Computational Logic, </title> <publisher> Inc., </publisher> <month> November </month> <year> 1988. </year>
Reference-contexts: free variables 46 (Kaufmann, [Kau92b], "kaufmann/koenig.events") a proof of Koenig's tree lemma (Kaufmann, [Kau91a], "kaufmann/locking.events") a model of a simple data base against which read and write transactions can occur (Kaufmann, "kaufmann/mergesort-demo.events") the correctness of a merge sort function, similar to the one in Section 4 in this paper (Kaufmann, <ref> [Kau88b] </ref>, "kaufmann/note-100.events") the proof of Ramsey's theorem for exponent 2, finite case, described in a style intended to assist those wishing to improve their effectiveness with Nqthm (Kaufmann, "kaufmann/partial.events") an approach to handling partial functions with Nqthm (Kaufmann, "kaufmann/permutationp-subbagp.events") a formalization of the notion of permutation via bags (Kaufmann, [Kau92b], "kaufmann/ramsey.events")
Reference: [Kau88c] <author> M. Kaufmann. </author> <title> A mutual recursion and dependency analysis tool for Nqthm. Internal Note 99, Computational Logic, </title> <publisher> Inc., </publisher> <year> 1988. </year>
Reference: [Kau89a] <author> M. Kaufmann. </author> <title> Addition of free variables to an interactive enhancement of the Boyer-Moore theorem prover. </title> <type> Technical Report 42, </type> <institution> Computational Logic, Inc., Austin, Texas, </institution> <month> May </month> <year> 1989. </year>
Reference-contexts: A user's manual [Kau88] provides other examples and more detail about the logical foundations of the system's backward-directed proof method. It also covers advanced topics such as the writing of macro commands. Little of substance has changed in the system since that manual was written; an update <ref> [Kau89a] </ref> describes the changes, notably variable instantiation, since the original manual. 15 4 An Example In this section we show a proof of correctness of a simple sorting function using Pc-Nqthm, and hence Nqthm (since Pc-Nqthm is built on top of Nqthm). In fact, we use (Pc-)Nqthm-1992 below.
Reference: [Kau89b] <author> M. Kaufmann. </author> <title> A user's manual for RCL. Internal Note 157, Computational Logic, </title> <publisher> Inc., </publisher> <month> October </month> <year> 1989. </year> <month> 59 </month>
Reference: [Kau90a] <author> M. Kaufmann. </author> <title> An integer library for Nqthm. Internal Note 182, Computational Logic, </title> <publisher> Inc., </publisher> <month> March </month> <year> 1990. </year>
Reference-contexts: not use concepts not involved in the statement of the theorem (Bevier, "numbers/bags.events") a library of useful definitions and lemmas about bags (Wilding, "numbers/extras.events") a trivial extension of the integers library used in fib2 below (Wilding, [Wil91], "numbers/fib2.events") a proof of Matijasevich's lemma about Fibonacci numbers (Bevier, Kaufmann, and Wilding, <ref> [Kau90a] </ref>, "numbers/integers.events") a library of useful definitions and lemmas about the integers (Bevier, Kaufmann, and Wilding, [Bev88], "numbers/naturals.events") a library of useful definitions and lemmas about the natural numbers (Wilding, "numbers/nim.events") a formalization of the game of Nim and a proof that a certain algorithm implements a winning strategy (Shankar, [Sha88],
Reference: [Kau90b] <author> M. Kaufmann. </author> <title> An instructive example for beginning users of the Boyer-Moore theorem prover. Internal Note 185, Computational Logic, </title> <publisher> Inc., 1717 W. </publisher> <address> Sixth Street, Suite 290, Austin, TX 78703, </address> <month> April </month> <year> 1990. </year>
Reference-contexts: case, described in a style intended to assist those wishing to improve their effectiveness with Nqthm (Kaufmann, "kaufmann/partial.events") an approach to handling partial functions with Nqthm (Kaufmann, "kaufmann/permutationp-subbagp.events") a formalization of the notion of permutation via bags (Kaufmann, [Kau92b], "kaufmann/ramsey.events") a proof of Ramsey's theorem for the infinite case (Kaufmann, <ref> [Kau90b] </ref>, "kaufmann/rotate.events") a proof about rotations of lists, intended as an introduction to Nqthm (Kaufmann and Jamsek, "kaufmann/rpn.events") an exercise in reverse Polish notation evaluation (Kaufmann, "kaufmann/shuffle.events") another solution to the Gilbreath card trick challenge (see example file "basic/alternating.events") (Kunen, "kunen/ack.events") an illustrative definition of Ackermann's function (Kunen, "kunen/new-prime.events") an alternative
Reference: [Kau91a] <author> M. Kaufmann. </author> <title> A simple example for Nqthm: Modeling locking. Internal Note 216, Computational Logic, </title> <publisher> Inc., 1717 W. </publisher> <address> Sixth Street, Suite 290, Austin, TX 78703, </address> <month> February </month> <year> 1991. </year>
Reference-contexts: compiler, designed as an exercise for beginners (Kaufmann, "kaufmann/foldr.events") an illustration of a method of proving permutation-independence of list processing functions (Kaufmann, [Kau91b], "kaufmann/generalize-all.events") the correctness of a generalization algorithm that operates in the pres ence of free variables 46 (Kaufmann, [Kau92b], "kaufmann/koenig.events") a proof of Koenig's tree lemma (Kaufmann, <ref> [Kau91a] </ref>, "kaufmann/locking.events") a model of a simple data base against which read and write transactions can occur (Kaufmann, "kaufmann/mergesort-demo.events") the correctness of a merge sort function, similar to the one in Section 4 in this paper (Kaufmann, [Kau88b], "kaufmann/note-100.events") the proof of Ramsey's theorem for exponent 2, finite case, described in
Reference: [Kau91b] <author> M. Kaufmann. </author> <title> Generalization in the presence of free variables: A mechanically-checked proof for one algorithm. </title> <journal> Journal of Automated Reasoning, </journal> <volume> 7(1), </volume> <month> March </month> <year> 1991. </year>
Reference-contexts: transfer model of a microcoded implementation of the machine, and a proof of their correspondence (Kaufmann, see Young [You90], "kaufmann/expr-compiler.events") the proof of correctness of a simple expression compiler, designed as an exercise for beginners (Kaufmann, "kaufmann/foldr.events") an illustration of a method of proving permutation-independence of list processing functions (Kaufmann, <ref> [Kau91b] </ref>, "kaufmann/generalize-all.events") the correctness of a generalization algorithm that operates in the pres ence of free variables 46 (Kaufmann, [Kau92b], "kaufmann/koenig.events") a proof of Koenig's tree lemma (Kaufmann, [Kau91a], "kaufmann/locking.events") a model of a simple data base against which read and write transactions can occur (Kaufmann, "kaufmann/mergesort-demo.events") the correctness of a <p> using a mechanized implementation of Unity on the Boyer-Moore prover (Goldschlag [GolThesis], "dmg/min.events") the correctness of a distributed algorithm that computes the minimum node value in a tree, using a mechanized implementation of Unity on the Boyer-Moore prover (Bevier and Wilding, [Bev88], "dmg/naturals.events") some supporting events about natural numbers (Kaufmann, <ref> [Kau91b] </ref>, "generalize/*.events") the correctness of a generalization algorithm that operates in the presence of free variables; same as the corresponding events from the Nqthm example suite, except that the quantifier (DEFN-SK, [Kau92b]) events have been replaced by DCL and ADD-AXIOM events in that version 53 (Young, [You89], "mg/*.events") a mechanically-verified code-generator
Reference: [Kau92a] <author> M. Kaufmann. </author> <title> Response to FM91 Survey of Formal Methods: Nqthm and Pc-Nqthm. </title> <type> Technical Report 75, </type> <institution> Computational Logic, Inc., Austin, Texas, </institution> <month> March </month> <year> 1992. </year>
Reference-contexts: Many of the files have explanatory comments. Each file has been successfully processed by PROVE-FILE. The files are listed in alphabetical order. Much of this text appears essentially in <ref> [Kau92a] </ref>. 5.1 Nqthm example event files First we list the example files for Nqthm. (Boyer, "basic/alternating.events") a formalization and correctness proof of the "Gilbreath Trick" [Gar60, Gil58], a card trick having to do with the outcome of shu*ing a deck of cards that has been previously arranged into alternating colors; the
Reference: [Kau92b] <author> M. Kaufmann. </author> <title> An extension of the Boyer-Moore theorem prover to support first-order quantification. </title> <journal> J. Automated Reasoning, </journal> <volume> 9(3) </volume> <pages> 355-372, </pages> <month> December </month> <year> 1992. </year>
Reference-contexts: It has been in existence since approximately 1987, and like Nqthm, is currently available by ftp from Internet host ftp.cli.com. Pc-Nqthm also provides full first-order quantification through a technique generally called Skolemization. This aspect of Pc-Nqthm has been thoroughly documented in <ref> [Kau92b] </ref>, and we'll say no more about it here, focusing instead on the system's interactive features. As with a variety of proof-checking systems, Pc-Nqthm is goal-directed in the following sense. One enters the system by presenting it with a theorem to be proved. <p> "kaufmann/expr-compiler.events") the proof of correctness of a simple expression compiler, designed as an exercise for beginners (Kaufmann, "kaufmann/foldr.events") an illustration of a method of proving permutation-independence of list processing functions (Kaufmann, [Kau91b], "kaufmann/generalize-all.events") the correctness of a generalization algorithm that operates in the pres ence of free variables 46 (Kaufmann, <ref> [Kau92b] </ref>, "kaufmann/koenig.events") a proof of Koenig's tree lemma (Kaufmann, [Kau91a], "kaufmann/locking.events") a model of a simple data base against which read and write transactions can occur (Kaufmann, "kaufmann/mergesort-demo.events") the correctness of a merge sort function, similar to the one in Section 4 in this paper (Kaufmann, [Kau88b], "kaufmann/note-100.events") the proof of <p> (Kaufmann, [Kau88b], "kaufmann/note-100.events") the proof of Ramsey's theorem for exponent 2, finite case, described in a style intended to assist those wishing to improve their effectiveness with Nqthm (Kaufmann, "kaufmann/partial.events") an approach to handling partial functions with Nqthm (Kaufmann, "kaufmann/permutationp-subbagp.events") a formalization of the notion of permutation via bags (Kaufmann, <ref> [Kau92b] </ref>, "kaufmann/ramsey.events") a proof of Ramsey's theorem for the infinite case (Kaufmann, [Kau90b], "kaufmann/rotate.events") a proof about rotations of lists, intended as an introduction to Nqthm (Kaufmann and Jamsek, "kaufmann/rpn.events") an exercise in reverse Polish notation evaluation (Kaufmann, "kaufmann/shuffle.events") another solution to the Gilbreath card trick challenge (see example file "basic/alternating.events") <p> some supporting events about lists and their use as an implementation of sets (Kaufmann, "basic/symmetric-difference.events") commutativity and associativity of symmetric difference as a set oper ation (Kaufmann, "basic/transitive-closure.events") proof of correctness of a transitive closure algorithm (Kaufmann, [Kau86], "basic/tsquare.events") proof of correctness of a "true square" algorithm of Gries (Kaufmann, <ref> [Kau92b] </ref>, "defn-sk/csb.events") proof of a formalization of the Schroeder-Bernstein theorem of set the ory (Kaufmann, "defn-sk/finite-state-machine-example.events") a little finite state machine example (Kaufmann, [Kau92b], "defn-sk/koenig.events") a formalization of Koenig's Tree Lemma, which says that any finitely branching tree which is infinite has an infinite branch 52 (Kaufmann, [Kau92b], "defn-sk/ramsey.events") proof of <p> set oper ation (Kaufmann, "basic/transitive-closure.events") proof of correctness of a transitive closure algorithm (Kaufmann, [Kau86], "basic/tsquare.events") proof of correctness of a "true square" algorithm of Gries (Kaufmann, <ref> [Kau92b] </ref>, "defn-sk/csb.events") proof of a formalization of the Schroeder-Bernstein theorem of set the ory (Kaufmann, "defn-sk/finite-state-machine-example.events") a little finite state machine example (Kaufmann, [Kau92b], "defn-sk/koenig.events") a formalization of Koenig's Tree Lemma, which says that any finitely branching tree which is infinite has an infinite branch 52 (Kaufmann, [Kau92b], "defn-sk/ramsey.events") proof of a formalization of the infinite Ramsey Theorem for exponent 2 (Bevier, [Bev88], "dmg/bags.events") some supporting events about bags (Goldschlag, [Gol91], "dmg/dining.events") the verification <p> of Gries (Kaufmann, <ref> [Kau92b] </ref>, "defn-sk/csb.events") proof of a formalization of the Schroeder-Bernstein theorem of set the ory (Kaufmann, "defn-sk/finite-state-machine-example.events") a little finite state machine example (Kaufmann, [Kau92b], "defn-sk/koenig.events") a formalization of Koenig's Tree Lemma, which says that any finitely branching tree which is infinite has an infinite branch 52 (Kaufmann, [Kau92b], "defn-sk/ramsey.events") proof of a formalization of the infinite Ramsey Theorem for exponent 2 (Bevier, [Bev88], "dmg/bags.events") some supporting events about bags (Goldschlag, [Gol91], "dmg/dining.events") the verification of a dining philosopher's program, under the assumptions of deadlock freedom and strong fairness, using a mechanized im plementation of Unity on the Boyer-Moore <p> implementation of Unity on the Boyer-Moore prover (Bevier and Wilding, [Bev88], "dmg/naturals.events") some supporting events about natural numbers (Kaufmann, [Kau91b], "generalize/*.events") the correctness of a generalization algorithm that operates in the presence of free variables; same as the corresponding events from the Nqthm example suite, except that the quantifier (DEFN-SK, <ref> [Kau92b] </ref>) events have been replaced by DCL and ADD-AXIOM events in that version 53 (Young, [You89], "mg/*.events") a mechanically-verified code-generator for micro-Gypsy, which is a Pas cal-like language (Good, Siebert, Young, [GSY], "middle-gypsy/*.events") a mathematical definition of a subset of the Gypsy 2.05 language, in cluding a preliminary rationals library created
Reference: [McC60a] <author> J. McCarthy. </author> <title> The Lisp Programmer's Manual. </title> <publisher> M.I.T. Computation Center, </publisher> <year> 1960. </year>
Reference: [McC60b] <author> J. McCarthy. </author> <title> Recursive functions of symbolic expressions and their computation by machine. </title> <journal> Communications of the Association for Computing Machinery, </journal> <volume> 3(4) </volume> <pages> 184-195, </pages> <year> 1960. </year>
Reference-contexts: Introduction In 1972, at the Metamathematics Unit of the University of Edinburgh, Scot-land, Boyer and Moore began work on what has become known as the Boyer-Moore Theorem Prover. The mathematical logic behind our work was largely inspired by McCarthy's seminal papers on the logic of Lisp, including <ref> [McC60b] </ref>, [McC62b], and [McC63]. See also [Bur69], [Goo64], and [Sko67] for related work on quantifier free logics for arithmetic. Since Lisp may be viewed simultaneously as a logic and an applicative programming language, it is a natural vehicle for the expression of theorems about computations and constructive mathematics in general.
Reference: [McC62a] <author> J. McCarthy. </author> <title> Computer programs for checking mathematical proofs. In Recursive Function Theory, </title> <booktitle> Proceedings of a Symposium in Pure Mathematics, volume V, </booktitle> <pages> pages 219-227, </pages> <address> Providence, Rhode Island, 1962. </address> <publisher> American Mathematical Society. </publisher>
Reference: [McC62b] <author> J. McCarthy. </author> <title> Towards a mathematical science of computation. </title> <booktitle> In Proceedings of IFIP Congress, </booktitle> <pages> pages 21-28. </pages> <publisher> North-Holland, </publisher> <year> 1962. </year> <month> 60 </month>
Reference-contexts: Introduction In 1972, at the Metamathematics Unit of the University of Edinburgh, Scot-land, Boyer and Moore began work on what has become known as the Boyer-Moore Theorem Prover. The mathematical logic behind our work was largely inspired by McCarthy's seminal papers on the logic of Lisp, including [McC60b], <ref> [McC62b] </ref>, and [McC63]. See also [Bur69], [Goo64], and [Sko67] for related work on quantifier free logics for arithmetic. Since Lisp may be viewed simultaneously as a logic and an applicative programming language, it is a natural vehicle for the expression of theorems about computations and constructive mathematics in general.
Reference: [McC63] <author> J. McCarthy. </author> <title> A basis for a mathematical theory of computation. </title> <booktitle> In Computer Programming and Formal Systems. </booktitle> <publisher> North-Holland Publishing Company, </publisher> <address> Amsterdam, The Netherlands, </address> <year> 1963. </year>
Reference-contexts: Introduction In 1972, at the Metamathematics Unit of the University of Edinburgh, Scot-land, Boyer and Moore began work on what has become known as the Boyer-Moore Theorem Prover. The mathematical logic behind our work was largely inspired by McCarthy's seminal papers on the logic of Lisp, including [McC60b], [McC62b], and <ref> [McC63] </ref>. See also [Bur69], [Goo64], and [Sko67] for related work on quantifier free logics for arithmetic. Since Lisp may be viewed simultaneously as a logic and an applicative programming language, it is a natural vehicle for the expression of theorems about computations and constructive mathematics in general.
Reference: [McC65] <author> J. McCarthy et al. </author> <title> LISP 1.5 Programmer's Manual. </title> <publisher> The MIT Press, </publisher> <address> Cambridge, Massachusetts, </address> <year> 1965. </year>
Reference: [Moo79] <author> J S. Moore. </author> <title> A mechanical proof of the termination of Takeuchi's function. </title> <journal> Information Processing Letters, </journal> <volume> 9(4) </volume> <pages> 176-181, </pages> <year> 1979. </year>
Reference-contexts: refinement of the algorithm into the functional expression of an iterative number-crunching program (Boyer and Moore, [BM84a], "basic/tmi.events") proof of the Turing completeness of Pure Lisp (Boyer and Moore, [BM84b], "basic/unsolv.events") proof of the unsolvability of the halting problem for Pure Lisp (Russinoff, [Rus85], "basic/wilson.events") proof of Wilson's theorem (Moore, <ref> [Moo79] </ref>, "basic/ztak.events") proof of the termination of Takeuchi's function (Bevier, [Bev87], "bevier/kit.events") the formalization, implementation and proof that a simple separation 44 kernel (implementing multi-processing on a uniprocessor) provides pro-cess scheduling, error handling, message passing, and interfaces to asyn chronous devices (Cowles, "cowles/intro-eg.events") a brief introduction to Nqthm intended for mathematicians
Reference: [Moo88] <author> J S. Moore. Piton: </author> <title> A verified assembly-level language. </title> <type> Technical Report CLI-22, </type> <institution> Computational Logic, Inc., Austin, Tx, </institution> <month> June </month> <year> 1988. </year>
Reference-contexts: and E of [Fla92] and deals with a runtime system that does not provide a garbage collector. (Flatau, [Fla92], "flatau/app-f.events") this event file is analogous to the immediately preceding one, but corresponds to Appendix F of [Fla92] and deals with a runtime system including a reference counting garbage collector. (Moore, <ref> [Moo88] </ref>, "fm9001-piton/big-add.events") a proof of the correctness of a Piton program for adding arbitrarily long numbers in base 2 32 (Brock and Hunt, [HB92], "fm9001-piton/fm9001.events") formalizations of a netlist description language, the machine code for the 32-bit FM9001 microprocessor, the design of an implementation of the processor, and a proof of <p> (Wilding, [Wil92], "fm9001-piton/nim-piton.events") a proof that a given 300-line Piton program plays the game of Nim optimally; the program is also shown to be loadable onto the FM9001 (satisfying the requirements of the correctness theorem for Piton); bounds on the program's execution time have been proved using Pc-Nqthm. 45 (Moore, <ref> [Moo88] </ref>, "fm9001-piton/piton.events") the definition of the Piton assembly language, its implementation on the FM9001 via a compiler, assembler and linker, and a proof of the correctness of the FM9001 implementation (Boyer and Moore, [BM81], "fortran-vcg/fortran.events") the same file as basic/fortran, above, which is duplicated on this subdirectory for technical reasons (Boyer
Reference: [Moo89] <author> J S. Moore. </author> <title> A mechanically verified language implementation. </title> <journal> Journal of Automated Reasoning, </journal> <volume> 5(4) </volume> <pages> 461-492, </pages> <year> 1989. </year>
Reference: [Moo89a] <author> J S. Moore et al. </author> <title> Special issue on system verification. </title> <journal> Journal of Automated Reasoning, </journal> <volume> 5(4) </volume> <pages> 409-530, </pages> <year> 1989. </year>
Reference: [Moo91] <author> J S. Moore. </author> <title> A formal model of asynchronous communication and its use in mechanically verifying a biphase mark protocol. </title> <type> Technical Report 68, </type> <institution> Computational Logic, Inc., 1717 W. </institution> <address> Sixth Street, Suite 290, Austin, TX 78703, </address> <month> August </month> <year> 1991. </year> <note> To appear in Formal Aspects of Computing, </note> <year> 1993. </year>
Reference-contexts: "Gilbreath Trick" [Gar60, Gil58], a card trick having to do with the outcome of shu*ing a deck of cards that has been previously arranged into alternating colors; the Nqthm attack on this problem was inspired by Gerard Huet's use of the COQ theorem prover to do the proof [Hue91] (Moore, <ref> [Moo91] </ref>, "basic/async18.events") a model of asynchronous communication and a proof of the reliability of the biphase mark communications protocol (Boyer and Moore, [BM88a], "basic/binomial.events") the binomial theorem expressed with FOR and a proof thereof (Bronstein and Talcott, [BT88, Bro89, BT89b, BT89a], "bronstein/*.events") a collection of twenty six event files that are
Reference: [NT91] <author> M. Nagayama and C. Talcott. </author> <title> An Nqthm mechanization of "An exercise in the verification of multi-process programs". </title> <type> Technical Report STAN-CS-91-1370, </type> <institution> Computer Science Department, Stan-ford University, </institution> <year> 1991. </year>
Reference-contexts: a proof of the Church-Rosser theorem for lambda-calculus (Shankar, [Sha86], "shankar/goedel.events") a proof of Godel's incompleteness theorem for Shoenfield's first order logic extended with Cohen's axioms for hereditarily finite set theory, Z2 (Shankar, [Sha85], "shankar/tautology.events") a proof that every tautology has a proof in Shoenfield's propositional logic (Nagayama and Talcott, <ref> [NT91] </ref>, "talcott/mutex-atomic.events") a proof of the local correctness of a mutual exclusion algorithm under a certain "atomicity assumption" 48 (Nagayama and Talcott, [NT91], "talcott/mutex-molecular.events") a proof of the local correctness of a mutual exclusion algorithm without the "atomicity assumption" mentioned above (Yu, "yu/amax.events") the correctness proof for the MC68020 machine code <p> extended with Cohen's axioms for hereditarily finite set theory, Z2 (Shankar, [Sha85], "shankar/tautology.events") a proof that every tautology has a proof in Shoenfield's propositional logic (Nagayama and Talcott, <ref> [NT91] </ref>, "talcott/mutex-atomic.events") a proof of the local correctness of a mutual exclusion algorithm under a certain "atomicity assumption" 48 (Nagayama and Talcott, [NT91], "talcott/mutex-molecular.events") a proof of the local correctness of a mutual exclusion algorithm without the "atomicity assumption" mentioned above (Yu, "yu/amax.events") the correctness proof for the MC68020 machine code produced by the Gnu C compiler for a C program that finds the maximum value in an integer array (Yu, [Yu92], "yu/asm.events")
Reference: [Rus85] <author> D. M. Russinoff. </author> <title> An experiment with the Boyer-Moore theorem prover: A proof of Wilson's theorem. </title> <journal> Journal of Automated Reasoning, </journal> <volume> 1(2) </volume> <pages> 121-139, </pages> <year> 1985. </year>
Reference-contexts: [ACLH] and the papers cited in the latter. 10 2.3 Hard Theorems Proved and the Importance of the User Among the hard theorems proved by Nqthm are * the existence and uniqueness of prime factorizations [ACL] * the invertibility of the RSA public key encryption algorithm [BM84c] * Wilson's theorem <ref> [Rus85] </ref>, * Gauss's law of quadratic reciprocity [Rus92], * the tautology theorem (that every propositional tautology has a proof in Shoenfield's propositional logic) [Sha85], * Godel's incompleteness theorem (for Shoenfield's first order logic ex tended with Cohen's axioms for hereditarily finite set theory, Z2) [Sha86], and * the correctness of many <p> certain algorithm does so, and the successive refinement of the algorithm into the functional expression of an iterative number-crunching program (Boyer and Moore, [BM84a], "basic/tmi.events") proof of the Turing completeness of Pure Lisp (Boyer and Moore, [BM84b], "basic/unsolv.events") proof of the unsolvability of the halting problem for Pure Lisp (Russinoff, <ref> [Rus85] </ref>, "basic/wilson.events") proof of Wilson's theorem (Moore, [Moo79], "basic/ztak.events") proof of the termination of Takeuchi's function (Bevier, [Bev87], "bevier/kit.events") the formalization, implementation and proof that a simple separation 44 kernel (implementing multi-processing on a uniprocessor) provides pro-cess scheduling, error handling, message passing, and interfaces to asyn chronous devices (Cowles, "cowles/intro-eg.events") a
Reference: [Rus92] <author> D.M. Russinoff. </author> <title> A mechanical proof of quadratic reciprocity. </title> <journal> Journal of Automated Reasoning, </journal> <volume> 8(1) </volume> <pages> 3-21, </pages> <year> 1992. </year>
Reference-contexts: latter. 10 2.3 Hard Theorems Proved and the Importance of the User Among the hard theorems proved by Nqthm are * the existence and uniqueness of prime factorizations [ACL] * the invertibility of the RSA public key encryption algorithm [BM84c] * Wilson's theorem [Rus85], * Gauss's law of quadratic reciprocity <ref> [Rus92] </ref>, * the tautology theorem (that every propositional tautology has a proof in Shoenfield's propositional logic) [Sha85], * Godel's incompleteness theorem (for Shoenfield's first order logic ex tended with Cohen's axioms for hereditarily finite set theory, Z2) [Sha86], and * the correctness of many algorithms, computer programs, and digital hardware designs <p> homes to the course (Cowles, "basic/fibsums.events") proofs of several interesting theorems about the sums of Fibonacci num bers (Boyer and Moore, [BM81], "basic/fortran.events") supporting definitions for a Fortran verification condition generator (Boyer, Goldschlag, Kaufmann, and Moore, [BGKM], "basic/fs-examples.events") illustrations of the use of constrained functions and functional instan tiation (Russinoff, <ref> [Rus92] </ref>, "basic/gauss.events") the original Nqthm proof of Gauss' law of quadratic reciprocity (Russinoff, [Rus92], "basic/new-gauss.events") an improved proof of Gauss' law of quadratic reciprocity (after all, Gauss proved it eight times!) (Boyer and Moore, "basic/parser.events") a formalization of the syntax and abbreviation conventions of the Nqthm extended logic, expressed as a <p> sums of Fibonacci num bers (Boyer and Moore, [BM81], "basic/fortran.events") supporting definitions for a Fortran verification condition generator (Boyer, Goldschlag, Kaufmann, and Moore, [BGKM], "basic/fs-examples.events") illustrations of the use of constrained functions and functional instan tiation (Russinoff, <ref> [Rus92] </ref>, "basic/gauss.events") the original Nqthm proof of Gauss' law of quadratic reciprocity (Russinoff, [Rus92], "basic/new-gauss.events") an improved proof of Gauss' law of quadratic reciprocity (after all, Gauss proved it eight times!) (Boyer and Moore, "basic/parser.events") a formalization of the syntax and abbreviation conventions of the Nqthm extended logic, expressed as a function from lists of ASCII character codes to the quotations of formal terms
Reference: [SLP82] <author> R. Shostak, L. Lamport, and M. Pease. </author> <title> The Byzantine generals problem. </title> <journal> ACM TOPLAS, </journal> <volume> 4(3) </volume> <pages> 382-401, </pages> <month> July </month> <year> 1982. </year> <month> 61 </month>
Reference: [Sha85] <author> N. Shankar. </author> <title> Towards mechanical metamathematics. </title> <journal> Journal of Automated Reasoning, </journal> <volume> 1(4) </volume> <pages> 407-434, </pages> <year> 1985. </year>
Reference-contexts: proved by Nqthm are * the existence and uniqueness of prime factorizations [ACL] * the invertibility of the RSA public key encryption algorithm [BM84c] * Wilson's theorem [Rus85], * Gauss's law of quadratic reciprocity [Rus92], * the tautology theorem (that every propositional tautology has a proof in Shoenfield's propositional logic) <ref> [Sha85] </ref>, * Godel's incompleteness theorem (for Shoenfield's first order logic ex tended with Cohen's axioms for hereditarily finite set theory, Z2) [Sha86], and * the correctness of many algorithms, computer programs, and digital hardware designs including simple compilers, operating systems, the Berkeley C string library as compiled by the gcc compiler <p> game of Nim and a proof that a certain algorithm implements a winning strategy (Shankar, [Sha88], "shankar/church-rosser.events") a proof of the Church-Rosser theorem for lambda-calculus (Shankar, [Sha86], "shankar/goedel.events") a proof of Godel's incompleteness theorem for Shoenfield's first order logic extended with Cohen's axioms for hereditarily finite set theory, Z2 (Shankar, <ref> [Sha85] </ref>, "shankar/tautology.events") a proof that every tautology has a proof in Shoenfield's propositional logic (Nagayama and Talcott, [NT91], "talcott/mutex-atomic.events") a proof of the local correctness of a mutual exclusion algorithm under a certain "atomicity assumption" 48 (Nagayama and Talcott, [NT91], "talcott/mutex-molecular.events") a proof of the local correctness of a mutual exclusion
Reference: [Sha86] <author> N. Shankar. </author> <title> Proof Checking Metamathematics. </title> <type> PhD thesis, </type> <institution> University of Texas at Austin, </institution> <year> 1986. </year>
Reference-contexts: encryption algorithm [BM84c] * Wilson's theorem [Rus85], * Gauss's law of quadratic reciprocity [Rus92], * the tautology theorem (that every propositional tautology has a proof in Shoenfield's propositional logic) [Sha85], * Godel's incompleteness theorem (for Shoenfield's first order logic ex tended with Cohen's axioms for hereditarily finite set theory, Z2) <ref> [Sha86] </ref>, and * the correctness of many algorithms, computer programs, and digital hardware designs including simple compilers, operating systems, the Berkeley C string library as compiled by the gcc compiler for the Mo torola MC68020, and a fabricated microprocessor. <p> integers (Bevier, Kaufmann, and Wilding, [Bev88], "numbers/naturals.events") a library of useful definitions and lemmas about the natural numbers (Wilding, "numbers/nim.events") a formalization of the game of Nim and a proof that a certain algorithm implements a winning strategy (Shankar, [Sha88], "shankar/church-rosser.events") a proof of the Church-Rosser theorem for lambda-calculus (Shankar, <ref> [Sha86] </ref>, "shankar/goedel.events") a proof of Godel's incompleteness theorem for Shoenfield's first order logic extended with Cohen's axioms for hereditarily finite set theory, Z2 (Shankar, [Sha85], "shankar/tautology.events") a proof that every tautology has a proof in Shoenfield's propositional logic (Nagayama and Talcott, [NT91], "talcott/mutex-atomic.events") a proof of the local correctness of a
Reference: [Sha88] <author> N. Shankar. </author> <title> A mechanical proof of the Church-Rosser theorem. </title> <journal> JACM, </journal> <volume> 35(3) </volume> <pages> 475-522, </pages> <year> 1988. </year>
Reference-contexts: [Kau90a], "numbers/integers.events") a library of useful definitions and lemmas about the integers (Bevier, Kaufmann, and Wilding, [Bev88], "numbers/naturals.events") a library of useful definitions and lemmas about the natural numbers (Wilding, "numbers/nim.events") a formalization of the game of Nim and a proof that a certain algorithm implements a winning strategy (Shankar, <ref> [Sha88] </ref>, "shankar/church-rosser.events") a proof of the Church-Rosser theorem for lambda-calculus (Shankar, [Sha86], "shankar/goedel.events") a proof of Godel's incompleteness theorem for Shoenfield's first order logic extended with Cohen's axioms for hereditarily finite set theory, Z2 (Shankar, [Sha85], "shankar/tautology.events") a proof that every tautology has a proof in Shoenfield's propositional logic (Nagayama and
Reference: [Sho67] <author> J. R. Shoenfield. </author> <title> Mathematical Logic. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, Ma., </address> <year> 1967. </year>
Reference: [Sko67] <author> T. </author> <title> Skolem. The foundations of elementary arithmetic established by means of the recursive mode of thought, without the use of apparent variables ranging over infinite domains. </title> <editor> In J. van Hei-jenoort, editor, </editor> <title> From Frege to Godel. </title> <publisher> Harvard University Press, </publisher> <address> Cambridge, Massachusetts, </address> <year> 1967. </year>
Reference-contexts: The mathematical logic behind our work was largely inspired by McCarthy's seminal papers on the logic of Lisp, including [McC60b], [McC62b], and [McC63]. See also [Bur69], [Goo64], and <ref> [Sko67] </ref> for related work on quantifier free logics for arithmetic. Since Lisp may be viewed simultaneously as a logic and an applicative programming language, it is a natural vehicle for the expression of theorems about computations and constructive mathematics in general.
Reference: [Sta87] <author> R. M. Stallman. </author> <title> GNU Emacs Manual. Free Software Foundation, </title> <address> 1000 Massachusetts Avenue, Cambridge, MA 02138, </address> <year> 1987. </year>
Reference-contexts: As noted above, the Nqthm user actually types commands to Common Lisp. That is, Nqthm commands are just Common Lisp programs the user invokes, using the available Common Lisp interaction protocols. We personally most often use Nqthm from within a Gnu Emacs text editor <ref> [Sta87] </ref> "shell buffer" running Common Lisp. We thus have available both the text processing convenience of Gnu Emacs and the computational power of Common Lisp to help us review what is happening in an Nqthm session and to create and record commands.
Reference: [Ste84] <author> G. L. Steele Jr. </author> <title> Common Lisp the Language. </title> <publisher> Digital Press, </publisher> <address> 30 North Avenue, Burlington, MA 01803, </address> <year> 1984. </year>
Reference-contexts: See [BGKM]. 6 2 Introduction to the Nqthm System The Nqthm system is a Common Lisp <ref> [Ste84] </ref> program of roughly one million characters. It is currently available by ftp from Internet host ftp.cli.com. There is no fee, but, at the insistence of our sponsors, a license agreement must be signed.
Reference: [Vit82] <author> B. L. Di Vito. </author> <title> Verification of Communications Protocols and Abstract Process Models. </title> <type> PhD thesis, </type> <institution> University of Texas at Austin, </institution> <year> 1982. </year>
Reference: [Wil91] <author> M. Wilding. </author> <title> Proving Matijasevich's lemma with a default arithmetic strategy. </title> <journal> Journal of Automated Reasoning, </journal> <volume> 7(3) </volume> <pages> 439-446, </pages> <year> 1991. </year>
Reference-contexts: fundamental theorem of arithmetic that - 47 unlike the one presented in [ACL] does not use concepts not involved in the statement of the theorem (Bevier, "numbers/bags.events") a library of useful definitions and lemmas about bags (Wilding, "numbers/extras.events") a trivial extension of the integers library used in fib2 below (Wilding, <ref> [Wil91] </ref>, "numbers/fib2.events") a proof of Matijasevich's lemma about Fibonacci numbers (Bevier, Kaufmann, and Wilding, [Kau90a], "numbers/integers.events") a library of useful definitions and lemmas about the integers (Bevier, Kaufmann, and Wilding, [Bev88], "numbers/naturals.events") a library of useful definitions and lemmas about the natural numbers (Wilding, "numbers/nim.events") a formalization of the game of
Reference: [Wil92] <author> M. Wilding. </author> <title> A proved application with simple real-time properties. </title> <type> Technical Report 78, </type> <institution> Computational Logic, Inc., 1717 W. </institution> <address> Sixth Street, Suite 290, Austin, TX 78703, </address> <year> 1992. </year>
Reference-contexts: adding arbitrarily long numbers in base 2 32 (Brock and Hunt, [HB92], "fm9001-piton/fm9001.events") formalizations of a netlist description language, the machine code for the 32-bit FM9001 microprocessor, the design of an implementation of the processor, and a proof of the correspondence of the design and the machine code specification (Wilding, <ref> [Wil92] </ref>, "fm9001-piton/nim-piton.events") a proof that a given 300-line Piton program plays the game of Nim optimally; the program is also shown to be loadable onto the FM9001 (satisfying the requirements of the correctness theorem for Piton); bounds on the program's execution time have been proved using Pc-Nqthm. 45 (Moore, [Moo88], "fm9001-piton/piton.events")
Reference: [Wos67] <author> L. Wos et al. </author> <title> The concept of demodulation in theorem proving. </title> <journal> Journal of the ACM, </journal> <volume> 14 </volume> <pages> 698-709, </pages> <year> 1967. </year>
Reference: [You89] <author> W. D. Young. </author> <title> A mechanically verified code generator. </title> <journal> Journal of Automated Reasoning, </journal> <volume> 5(4) </volume> <pages> 493-518, </pages> <year> 1989. </year> <month> 62 </month>
Reference-contexts: about natural numbers (Kaufmann, [Kau91b], "generalize/*.events") the correctness of a generalization algorithm that operates in the presence of free variables; same as the corresponding events from the Nqthm example suite, except that the quantifier (DEFN-SK, [Kau92b]) events have been replaced by DCL and ADD-AXIOM events in that version 53 (Young, <ref> [You89] </ref>, "mg/*.events") a mechanically-verified code-generator for micro-Gypsy, which is a Pas cal-like language (Good, Siebert, Young, [GSY], "middle-gypsy/*.events") a mathematical definition of a subset of the Gypsy 2.05 language, in cluding a preliminary rationals library created by Matt Wilding (Wilding, "wilding/ground-resolution.events") a proof of the completeness of ground resolution using Bledsoe's
Reference: [You90] <author> W. D. Young. </author> <title> A simple expression compiler: A programming and proof example for an Nqthm course. Internal Note 210, Computational Logic, </title> <publisher> Inc., 1717 W. </publisher> <address> Sixth Street, Suite 290, Austin, TX 78703, </address> <month> November </month> <year> 1990. </year>
Reference-contexts: [BM91], "fortran-vcg/mjrty.events") proofs of the verification conditions for a Fortran implementation of a linear-time majority vote algorithm (Hunt, [Hun85], "hunt/fm8501.events") formalizations of the machine code for the 16-bit FM8501 microprocessor, a register transfer model of a microcoded implementation of the machine, and a proof of their correspondence (Kaufmann, see Young <ref> [You90] </ref>, "kaufmann/expr-compiler.events") the proof of correctness of a simple expression compiler, designed as an exercise for beginners (Kaufmann, "kaufmann/foldr.events") an illustration of a method of proving permutation-independence of list processing functions (Kaufmann, [Kau91b], "kaufmann/generalize-all.events") the correctness of a generalization algorithm that operates in the pres ence of free variables 46 (Kaufmann,
Reference: [Yu90] <author> Y. Yu. </author> <title> Computer proofs in group theory. </title> <journal> Journal of Automated Reasoning, </journal> <volume> 6(3), </volume> <year> 1990. </year>
Reference-contexts: in C (Yu, [Yu92], "yu/gcd3.events") the correctness proof for the MC68020 machine code produced by the Gnu C compiler for a C program consisting of two nested calls of the GCD program (the object being to demonstrate that procedure call is handled in a way that allows hierarchical verification) (Yu, <ref> [Yu90] </ref>, "yu/group.events") proofs of two theorems in finite group theory, the first is about kernels of homomorphisms and the second is the Lagrange theorem (Yu, "yu/isqrt.events") the correctness proof for the MC68020 machine code produced by the GNU C compiler for C program for computing integer square roots via Newton's method
Reference: [Yu92] <author> Y. Yu. </author> <title> Automated Proofs of Object Code for a Widely Used Microprocessor. </title> <type> PhD thesis, </type> <institution> University of Texas, </institution> <year> 1992. </year> <month> 63 </month>
Reference-contexts: Talcott, [NT91], "talcott/mutex-molecular.events") a proof of the local correctness of a mutual exclusion algorithm without the "atomicity assumption" mentioned above (Yu, "yu/amax.events") the correctness proof for the MC68020 machine code produced by the Gnu C compiler for a C program that finds the maximum value in an integer array (Yu, <ref> [Yu92] </ref>, "yu/asm.events") the correctness proof for the MC68020 machine code produced by the Gnu C compiler for a trivial C program that uses embedded assembly code (the object being to demonstrate that embedded assembly code can be handled) (Yu, [Yu92], "yu/bsearch.events") the correctness proof for the MC68020 machine code produced by <p> program that finds the maximum value in an integer array (Yu, <ref> [Yu92] </ref>, "yu/asm.events") the correctness proof for the MC68020 machine code produced by the Gnu C compiler for a trivial C program that uses embedded assembly code (the object being to demonstrate that embedded assembly code can be handled) (Yu, [Yu92], "yu/bsearch.events") the correctness proof for the MC68020 machine code produced by the Gnu C compiler for a binary search program written in C (Yu, [Yu92], "yu/cstring.events") the correctness proofs for the MC68020 machine code produced by the Gnu C compiler for 21 of the 22 C String Library functions from <p> C compiler for a trivial C program that uses embedded assembly code (the object being to demonstrate that embedded assembly code can be handled) (Yu, <ref> [Yu92] </ref>, "yu/bsearch.events") the correctness proof for the MC68020 machine code produced by the Gnu C compiler for a binary search program written in C (Yu, [Yu92], "yu/cstring.events") the correctness proofs for the MC68020 machine code produced by the Gnu C compiler for 21 of the 22 C String Library functions from the Berkeley Unix C string library; the proof for each function is broken into two "phases;" the first phase establishes the correspondence of the machine <p> function is contained in a separate events file named for the string function, e.g., yu/memchr.events, yu/memcmp.events, yu/strnspn.events, etc. (Yu, "yu/fixnum-gcd.events") the correctness proof for the MC68020 machine code produced by the AKCL compiler for a Common Lisp program that computes the great est common divisor of two FIXNUMs 49 (Yu, <ref> [Yu92] </ref>, "yu/fmax.events") the correctness proof for the MC68020 machine code produced by the Gnu C compiler for a trivial C program to compute the maximum of two integers according to a supplied comparison function (the object being to demonstrate that C "function pointers" are handled) (Yu, [Yu92] (also [Hea08]), "yu/gcd.events") the <p> two FIXNUMs 49 (Yu, <ref> [Yu92] </ref>, "yu/fmax.events") the correctness proof for the MC68020 machine code produced by the Gnu C compiler for a trivial C program to compute the maximum of two integers according to a supplied comparison function (the object being to demonstrate that C "function pointers" are handled) (Yu, [Yu92] (also [Hea08]), "yu/gcd.events") the correctness proof for the MC68020 machine code produced by the Gnu C compiler for Euclid's greatest common divisor algorithm written in C (Yu, [Yu92], "yu/gcd3.events") the correctness proof for the MC68020 machine code produced by the Gnu C compiler for a C program consisting of two <p> maximum of two integers according to a supplied comparison function (the object being to demonstrate that C "function pointers" are handled) (Yu, <ref> [Yu92] </ref> (also [Hea08]), "yu/gcd.events") the correctness proof for the MC68020 machine code produced by the Gnu C compiler for Euclid's greatest common divisor algorithm written in C (Yu, [Yu92], "yu/gcd3.events") the correctness proof for the MC68020 machine code produced by the Gnu C compiler for a C program consisting of two nested calls of the GCD program (the object being to demonstrate that procedure call is handled in a way that allows hierarchical verification) (Yu, [Yu90], "yu/group.events") proofs of <p> produced by the Verdix Ada compiler from an Ada program for computing integer square roots via Newton's method (Yu, "yu/log2.events") the correctness proof for the MC68020 machine code produced by the Gnu C compiler for a C program for computing integer logarithms (base 2) e.g., repeated division by 2 (Yu, <ref> [Yu92] </ref>, "yu/mc20-0.events") some utilities involved in the formal specification of the MC68020 50 (Yu, [BY92], "yu/mc20-1.events") the formal specification of about 80% of the user available instructions for the Motorola MC68020 microprocessor (Yu, [Yu92], "yu/mc20-2.events") a library of useful definitions and lemmas about the formalization of the MC68020 (Yu, "yu/mjrty.events") the <p> compiler for a C program for computing integer logarithms (base 2) e.g., repeated division by 2 (Yu, <ref> [Yu92] </ref>, "yu/mc20-0.events") some utilities involved in the formal specification of the MC68020 50 (Yu, [BY92], "yu/mc20-1.events") the formal specification of about 80% of the user available instructions for the Motorola MC68020 microprocessor (Yu, [Yu92], "yu/mc20-2.events") a library of useful definitions and lemmas about the formalization of the MC68020 (Yu, "yu/mjrty.events") the correctness proof for the MC68020 machine code produced by the Gnu C compiler for a linear time majority vote algorithm written in C (Yu, "yu/qsort.events") the correctness proof for the MC68020 machine code <p> page 87 of [KR88] except that inline code is used rather than the subroutine swap; Yu reports (private communication) that this change was made only because he was, at the time, investigating methods of proving recursive programs correct and did not want to be distracted by other subroutine calls (Yu, <ref> [Yu92] </ref>, "yu/switch.events") the correctness proof for the MC68020 machine code produced by the GNU C compiler for a trivial C program that employs the switch statement (the object being to demonstrate the technique used to compile switch can be handled) (Yu, "yu/zero.events") the correctness proof for the MC68020 machine code produced
References-found: 94

