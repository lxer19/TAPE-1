URL: http://www.cis.ohio-state.edu/~paolo/research/publications/cs-tr-97-31.ps
Refering-URL: http://www.cis.ohio-state.edu/~paolo/research/
Root-URL: http://www.cis.ohio-state.edu
Title: A Method for the Specification, Composition, and Testing of Distributed Object Systems  
Author: Paolo A.G. Sivilotti 
Degree: Thesis by  In Partial Fulfillment of the Requirements for the Degree of Doctor of Philosophy  
Date: 1998 (Submitted December 1, 1997)  
Address: Pasadena, California  
Affiliation: California Institute of Technology  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> Martin Abadi and Leslie Lamport. </author> <title> Composing specifications. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 15(1) </volume> <pages> 73-132, </pages> <month> January </month> <year> 1993. </year>
Reference-contexts: That is, each component in a system must behave correctly only if the other components do. The circularity of this reasoning has been broken by various proposals, including rely-guarantee [46], hypothesis-conclusion [19], assumption-commitment [22], offers-using [52], and assumption-guarantee <ref> [1] </ref>. For example, the assumption-guarantee approach of Abadi and Lamport restricts the assumptions of environment behavior to safety properties. The modified rely-guarantee approach of Manohar and Sivilotti [62] allows progress properties to be part of the rely clause, but requires the explicit construction of an acyclic implication ladder.
Reference: [2] <author> American National Standards Institute, Inc. </author> <title> The Programming Language Ada Reference Manual. </title> <publisher> Springer-Verlag, </publisher> <address> Berlin, Germany, </address> <year> 1983. </year> <month> ANSI/MIL-STD-1815A. </month>
Reference-contexts: Both UNITY and TLA allow for stuttering (i.e., the repetition of global state in the trace of a computation). Implementation-language-specific notations that incorporate temporal logic have also been proposed, such as COL [48]. This specification language and its associated deadlock analyzer are part of an Ada <ref> [2] </ref> design environment. In [36], a procedural monitor-based programming language, VALET, is defined with a temporal logic semantics. Our fundamental operators ( initially , next , and transient ) are based on well-known operators in temporal logic. In particular, [69, 68] contains an excellent exposition of the latter two.
Reference: [3] <author> Krzysztof R. Apt. </author> <title> Correctness proofs of distributed termination algorithms. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 8(3) </volume> <pages> 388-405, </pages> <month> July </month> <year> 1986. </year>
Reference-contexts: It has been our experience that these services reappear frequently in the development of distributed algorithms. For example, they can be used to simplify the proof and exposition of algorithms as varied as mutual exclusion, dining philosophers [23], global snapshots [17], Byzantine generals [81], and termination detection <ref> [28, 3] </ref>. On the other hand, these two services do not comprise an exhaustive list of useful services. They are given as an illustration of the use of services and their integration in our model.
Reference: [4] <author> R. J. R. </author> <title> Back. On correct refinements of programs. </title> <journal> Journal of Computer and System Sciences, </journal> <volume> 23 </volume> <pages> 49-68, </pages> <year> 1981. </year>
Reference-contexts: That is, specifications and implementations are distinguished only by imple-mentability. This view has given rise to the study of the refinement from specification to implementation in a calculational manner. The refinement calculus, as it is known, was pioneered in <ref> [4] </ref>, [73], and [72]. A calculation approach to specification refinement has also met with considerable success in the area of asynchronous VLSI design. A CSP-like [41] specification is refined through a series of program transformations into a hardware implementation [65, 64].
Reference: [5] <author> T. J. Berners-Lee, R. Cailliau, J-F Groff, and B. Pollermann. </author> <title> World-wide web: The information universe. </title> <journal> Electronic Networking: Research, Applications, and Policy, </journal> <volume> 1(2) </volume> <pages> 52-58, </pages> <month> Spring </month> <year> 1992. </year>
Reference-contexts: Distributed systems are becoming more prevalent. With the proliferation of workstations and of networks of these machines, there is an established hardware base for these applications. By bridging large physical distances between users, networked computers are a significant communication resource. The explosion of the World Wide Web <ref> [6, 5] </ref> has been dramatic evidence of the potential in exploiting networks. In addition to information exchange, there is also considerable interest in distributed collaborative, commercial, and entertainment applications. Distributed programming is poised to enter the mainstream of commodity software. <p> For example, consider predicates x &gt; 10 and x &gt; 5 on a state space S that contains a variable x . The truth of the latter predicate is implied by the truth of the former. We write <ref> [x &gt; 10 ) x &gt; 5 ] </ref> as a shorthand for ( 8 s : s 2 S : (x &gt; 10 ) x &gt; 5 ):s ) . We also adopt the convention that formulas with unbound dummies are implicitly universally quantified over these dummies.
Reference: [6] <author> Tim Berners-Lee, Robert Cailliau, Ari Luotonen, Henrik Frystyk Nielsen, and Arthur Secret. </author> <title> The world-wide web. </title> <journal> Communications of the ACM, </journal> <volume> 37(8) </volume> <pages> 76-82, </pages> <month> August </month> <year> 1994. </year>
Reference-contexts: Distributed systems are becoming more prevalent. With the proliferation of workstations and of networks of these machines, there is an established hardware base for these applications. By bridging large physical distances between users, networked computers are a significant communication resource. The explosion of the World Wide Web <ref> [6, 5] </ref> has been dramatic evidence of the potential in exploiting networks. In addition to information exchange, there is also considerable interest in distributed collaborative, commercial, and entertainment applications. Distributed programming is poised to enter the mainstream of commodity software.
Reference: [7] <author> Garrett Birkhoff. </author> <title> Lattice Theory. </title> <publisher> American Mathematical Society, </publisher> <address> New York, New York, </address> <year> 1940. </year>
Reference-contexts: x = ( Min k : k 2 FP :x 0 : k )) (4.10) 4.1.2 Properties for Lattices A poset is called a lattice if every finite nonempty set has a greatest lower bound (or "meet," denoted # ) and a least upper bound (or "join," denoted " ) <ref> [7, 97] </ref>.
Reference: [8] <author> Dines Bjorner and Cliff B. Jones. </author> <title> Formal Specification and Software Development. </title> <address> Prentice/Hall, Englewood Cliffs, New Jersey, </address> <year> 1982. </year>
Reference-contexts: Another popular specification language, SDL [90], is used for the description of telecommunication systems, as is the Estelle language [14]. Both these notations are based on an extended finite state machine abstraction. VDM (the Vienna Development Method) <ref> [8, 47] </ref> has also enjoyed success in its application to large systems such as the specification of PL/I and Ada [9]. These specification languages can all be used to guide the selection of test data.
Reference: [9] <author> Dines Bjorner and O. N. Oest. </author> <title> Towards a Formal Description of Ada. </title> <booktitle> Number 98 in Lecture Notes in Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <address> New York, New York, </address> <year> 1980. </year>
Reference-contexts: Both these notations are based on an extended finite state machine abstraction. VDM (the Vienna Development Method) [8, 47] has also enjoyed success in its application to large systems such as the specification of PL/I and Ada <ref> [9] </ref>. These specification languages can all be used to guide the selection of test data. They are also consistent with the automatic generation of testing harnesses for implementations. 9.3 Software Validation Validation is the process whereby software is tested to ensure that it complies with its specification [45].
Reference: [10] <author> Manuel Blum. </author> <title> Designing programs to check their work. </title> <type> Technical Report TR-88-009, </type> <institution> International Computer Science Institute, </institution> <year> 1988. </year> <month> 138 </month>
Reference-contexts: The confidence problem has also been addressed by extending component implementations with result-checking code [11]. The central idea is that it can be easier (e.g., faster or more space efficient) to check the result of a computation than to perform the computation itself <ref> [10] </ref>.
Reference: [11] <author> Manuel Blum and Hal Wasserman. </author> <title> Program result-checking: a theory of testing meets a test of theory. </title> <booktitle> In Proceedings of the 35th Symposium on the Foundations of Computer Science, </booktitle> <pages> pages 382-392, </pages> <year> 1994. </year>
Reference-contexts: It is limited, however, to safety properties that are appropriate for verification by a type-checking algorithm. The confidence problem has also been addressed by extending component implementations with result-checking code <ref> [11] </ref>. The central idea is that it can be easier (e.g., faster or more space efficient) to check the result of a computation than to perform the computation itself [10].
Reference: [12] <author> Grady Booch. </author> <title> Object-Oriented Design with Applications. </title> <publisher> The Benjamin/Cummings Publishing Company, Inc., </publisher> <address> Redwood City, California 94065, </address> <year> 1991. </year>
Reference-contexts: In addition to information exchange, there is also considerable interest in distributed collaborative, commercial, and entertainment applications. Distributed programming is poised to enter the mainstream of commodity software. One methodology that is useful for managing the complexity of distributed systems is object orientation <ref> [12, 67] </ref>. This is a technique of program design that focuses attention on the data being manipulated [86, 91]. Object-oriented languages (such as C++ [96] and Oberon-2 [74]) contain sophisticated mechanisms for supporting user-defined data types, 2 known as classes.
Reference: [13] <author> Gilles Brassard and Paul Bratley. </author> <title> Algorithmics: Theory and Practice. </title> <publisher> Prentice-Hall, Inc., </publisher> <address> Englewood Cliffs, New Jersey 07632, </address> <year> 1988. </year>
Reference-contexts: Checks provided by the programmer, however, do allow the certificates to be tested at run-time. Also, the validity of the certificates can be formally established with an entirely local proof. 8.1 The Problem We consider a distributed tree search based on the branch and bound algorithm <ref> [13, Chapter 3] </ref>. Each node of the tree being searched has an associated value. The goal of the search is to identify the leaf node with the maximum value. The branch and bound tree search is based on the existence of two functions.
Reference: [14] <author> S. Budkowski and P. </author> <title> Dembinski. An introduction to Estelle: A specification language for distributed systems. </title> <journal> Computer Networks and ISDN Systems, </journal> <volume> 14(1) </volume> <pages> 3-23, </pages> <year> 1987. </year>
Reference-contexts: Interface languages have been designed for C [35], Modula-3 [35], Ada [34], and C++ [58] among others. Another popular specification language, SDL [90], is used for the description of telecommunication systems, as is the Estelle language <ref> [14] </ref>. Both these notations are based on an extended finite state machine abstraction. VDM (the Vienna Development Method) [8, 47] has also enjoyed success in its application to large systems such as the specification of PL/I and Ada [9].
Reference: [15] <author> David Carney. </author> <title> Assembling large systems from COTS components: Opportunities, cautions, and complexities. </title> <type> SEI monograph, </type> <institution> Software Engineering Institute, Carnegie Mellon University, Pittsburgh, Pennsylvania, </institution> <month> June </month> <year> 1997. </year>
Reference-contexts: The confluence of these two forces makes component-based technology attractive in a competitive software market. One of the proponents of commercial off-the-shelf (COTS) component assembly for software systems is the Software Engineering Institute at Carnegie Mellon University (and, in particular, the CBS initiative underway there) <ref> [15] </ref>. One of the challenges to COTS component assembly is establishing confidence in the correctness of the component being used. The Fox project supports the concept of "proof-carrying code" [76]. That is, a proof of correctness is embedded in the assembled implementation code, which the user can verify.
Reference: [16] <author> K. M. Chandy and C. Kesselman. </author> <title> CC++: A declarative concurrent object oriented programming language. </title> <type> Technical Report CS-TR-92-01, </type> <institution> Computer Science Department, California Institute of Technology, </institution> <address> 256-80 Caltech, Pasadena, California 91125, </address> <year> 1992. </year>
Reference-contexts: Other available implementations include Java [32] with RMI, CC++ <ref> [16, 93] </ref>, Fortran M [27], PVM [30], and MPI [95] to name a few. To avoid confusion in the presentation, a single practical context is used in this thesis, namely the CORBA standard. 2.4 Notation and Conventions 2.4.1 Functions and Operators The usual mathematical and logical operators are used.
Reference: [17] <author> K. M. Chandy and L. Lamport. </author> <title> Distributed snapshots: Determining global states of distributed systems. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 3(1) </volume> <pages> 63-75, </pages> <month> February </month> <year> 1985. </year>
Reference-contexts: It has been our experience that these services reappear frequently in the development of distributed algorithms. For example, they can be used to simplify the proof and exposition of algorithms as varied as mutual exclusion, dining philosophers [23], global snapshots <ref> [17] </ref>, Byzantine generals [81], and termination detection [28, 3]. On the other hand, these two services do not comprise an exhaustive list of useful services. They are given as an illustration of the use of services and their integration in our model.
Reference: [18] <author> K. Mani Chandy. </author> <title> Reasoning about continuous systems. </title> <booktitle> Science of Computer Programming, </booktitle> <address> 14(2-3):117-132, </address> <month> October </month> <year> 1990. </year>
Reference-contexts: The follows operator is similar to the detects operator in UNITY in that it combines safety and progress, and is similar to the method used in <ref> [18] </ref> to reason about continuous systems. Unlike detects, the follows operator deals with monotonic variables.
Reference: [19] <author> K. Mani Chandy and Jayadev Misra. </author> <title> Parallel Program Design: A Foundation. </title> <publisher> Addison-Wesley Publishing Company, </publisher> <address> Reading, Massachusetts, </address> <year> 1988. </year>
Reference-contexts: The distinction centers around the consideration of reachable states and is eliminated by the adoption of a substitution axiom similar to that of UNITY logic <ref> [19, 87, 69] </ref>. An example of an invariant property is that a variable is always positive. <p> one of the booleans thinking, hungry, and eating is true: invariant:((thinking j hungry j eating ) ^ (:thinking _ :hungry _ :eating )) 33 3.4.3 Certificate Leads-to A leads-to property, such as p ; q , expresses the fact that once p becomes true q is or will be true <ref> [19, Section 3.4.5] </ref>. Leads-to can be defined in terms of transience and next [68]. <p> j f definition of m : m 2 FP :x 0 g x m ^ f :x m next f assumption: f :x k ^ x k next x k g x m 4.3 The Earliest Meeting Time 4.3.1 Problem Definition The earliest meeting time problem has been discussed in <ref> [19] </ref>. The problem is to schedule a meeting for a group of people at the earliest time that is acceptable to every member of the group. Time is considered to be a nonnegative integer value. <p> As a result of this discipline, a component with a logical time of n has not received any messages sent at a logical time greater than n . One of the useful consequences of this system property is that a valid global snapshot <ref> [19, Chapter 10] </ref> can be recorded quite easily. It is sufficient for all components to record their state when their logical clocks have reached a particular value. Global snapshots are especially useful for the detection of stable properties (such as termination or deadlock). <p> That is, each component in a system must behave correctly only if the other components do. The circularity of this reasoning has been broken by various proposals, including rely-guarantee [46], hypothesis-conclusion <ref> [19] </ref>, assumption-commitment [22], offers-using [52], and assumption-guarantee [1]. For example, the assumption-guarantee approach of Abadi and Lamport restricts the assumptions of environment behavior to safety properties. <p> For example, the structure of the sequence may be linear or branching, finite or infinite. A common formulation, based on linear temporal logic, is sometimes called Manna-Pnueli theory [61, 51]. Several specification notations with strong ties to temporal logic have been developed. The UNITY model <ref> [19] </ref> defines a program to be a collection of assignment statements 129 from which, repeatedly, a statement is chosen for execution. The model gives a fairness requirement for this selection. Program properties are then given in terms of unless, ensures, and leads-to.
Reference: [20] <author> K. Mani Chandy and Beverly A. Sanders. </author> <title> Predicate transformers for reasoning about concurrent computation. </title> <booktitle> Science of Computer Programming, </booktitle> <volume> 24(2) </volume> <pages> 129-148, </pages> <month> April </month> <year> 1995. </year>
Reference-contexts: The validity of the statement does not depend on the environment in which the component is placed. Certificates enjoy a significant property: If a certificate is a property of a component, it is also a property of any system that contains that component. In the language of <ref> [20] </ref>, certificates are examples of "exists-component" properties. Despite the fact that specifications are meant to be visible to a component's environment, the presence of so-called local variables in these specification statements is not a cause for concern. <p> From these basic concepts we will derive two more constructs for expressing safety ( stable and invariant ) and one more for progress (leads-to, written ; ). This 25 formal system is known to be sound and relatively complete <ref> [20] </ref>. We will also derive a new construct ( follows ) that simultaneously expresses both safety and progress properties. <p> The property that the component will eventually stop eating is a progress property and is discussed in Section 3.3. The next operator has appeared in several forms, including the co operator in [69], the next operator in <ref> [20] </ref>, and the fl operator in temporal logic [51, 99]. 3.3 Progress 3.3.1 Certificate transient A progress property states that something eventually happens. We employ a single fundamental certificate for expressing progress: transient . A transient predicate is a predicate that once true is guaranteed to be falsified eventually. <p> The modified rely-guarantee approach of Manohar and Sivilotti [62] allows progress properties to be part of the rely clause, but requires the explicit construction of an acyclic implication ladder. The weakest guarantee approach of Chandy and Sanders <ref> [20, 21] </ref> breaks the circularity by considering requirements on the entire system rather than just the environment.
Reference: [21] <author> K. Mani Chandy and Beverly A. Sanders. </author> <title> Predicate transformers for reasoning about concurrent computation (volume 24, page 129, </title> <booktitle> 1995). Science of Computer Programming, </booktitle> <address> 29(3):335, </address> <month> September </month> <year> 1997. </year> <title> Correction. </title> <type> 139 </type>
Reference-contexts: The modified rely-guarantee approach of Manohar and Sivilotti [62] allows progress properties to be part of the rely clause, but requires the explicit construction of an acyclic implication ladder. The weakest guarantee approach of Chandy and Sanders <ref> [20, 21] </ref> breaks the circularity by considering requirements on the entire system rather than just the environment.
Reference: [22] <author> Pierre Collette. </author> <title> Composition of assumption-commitment specification in a UNITY style. </title> <booktitle> Science of Computer Programming, </booktitle> <volume> 23 </volume> <pages> 107-125, </pages> <year> 1994. </year>
Reference-contexts: That is, each component in a system must behave correctly only if the other components do. The circularity of this reasoning has been broken by various proposals, including rely-guarantee [46], hypothesis-conclusion [19], assumption-commitment <ref> [22] </ref>, offers-using [52], and assumption-guarantee [1]. For example, the assumption-guarantee approach of Abadi and Lamport restricts the assumptions of environment behavior to safety properties.
Reference: [23] <author> E. W. Dijkstra. </author> <title> Cooperating sequential processes. </title> <editor> In F. Genuys, editor, </editor> <booktitle> Programming Languages, </booktitle> <pages> pages 43-112. </pages> <publisher> Academic Press, </publisher> <address> New York, New York, </address> <year> 1968. </year>
Reference-contexts: The latter is often used to establish consistency and causality relationships. It has been our experience that these services reappear frequently in the development of distributed algorithms. For example, they can be used to simplify the proof and exposition of algorithms as varied as mutual exclusion, dining philosophers <ref> [23] </ref>, global snapshots [17], Byzantine generals [81], and termination detection [28, 3]. On the other hand, these two services do not comprise an exhaustive list of useful services. They are given as an illustration of the use of services and their integration in our model.
Reference: [24] <author> E. W. Dijkstra. </author> <title> A Discipline of Programming. Prentice-Hass Series in Automatic Computation. </title> <publisher> Prentice-Hall, </publisher> <address> Englewood Cliffs, New Jersey, </address> <year> 1976. </year>
Reference-contexts: This approach has been attributed to Floyd [26] and has been applied with success to sequential systems. The two primary forms of this style of specification for sequential programs are Hoare triples [40] and Dijkstra's weakest precondition <ref> [24, 25] </ref>. Axiomatic specification has also been demonstrated to be a powerful mechanism in the context of concurrent systems. Martin's seminal paper [63] gave an axiomatic definition of synchronization primitives (such as send-receive) in terms of boundedness, progress, and fairness.
Reference: [25] <author> Edsger W. Dijkstra and Carel S. Scholten. </author> <title> Predicate Calculus and Program Semantics. Texts and Monographs in Computer Science. </title> <publisher> Springer-Verlag, </publisher> <address> 175 Fifth Avenue, New York, New York 10010, </address> <year> 1990. </year>
Reference-contexts: If the entire range is understood from context, an abbreviated notation is used: ( 8 n :: p:n ) Universal quantification over the state space will be denoted by the "everywhere brackets" as in <ref> [25] </ref>. For example, consider predicates x &gt; 10 and x &gt; 5 on a state space S that contains a variable x . The truth of the latter predicate is implied by the truth of the former. <p> For example, the formula stable:(x = k ) where k is a dummy should be read as ( 8 k :: stable:(x = k ) ) . 2.4.3 Proof Format Our proof format is based on <ref> [25] </ref>. It gives a justification (or hint) for each step. <p> Thus, a certificate involving next must allow for actions that do not change local state. So given p next q , it follows that p implies q : (p next q ):C ) [p ) q ] (3.1) The square brackets ("[ ]") are "everywhere brackets" <ref> [25] </ref> representing universal quantification over all states. For example, consider the component Philosopher from the previous section that cycles between 3 states: thinking, hungry, and eating. <p> This approach has been attributed to Floyd [26] and has been applied with success to sequential systems. The two primary forms of this style of specification for sequential programs are Hoare triples [40] and Dijkstra's weakest precondition <ref> [24, 25] </ref>. Axiomatic specification has also been demonstrated to be a powerful mechanism in the context of concurrent systems. Martin's seminal paper [63] gave an axiomatic definition of synchronization primitives (such as send-receive) in terms of boundedness, progress, and fairness.
Reference: [26] <author> Robert W. Floyd. </author> <title> Assigning meanings to programs. </title> <booktitle> In Proceedings Symposium on Applied Mathematics, </booktitle> <volume> volume 19, </volume> <pages> pages 19-31, </pages> <year> 1967. </year>
Reference-contexts: Several approaches to the specification of concurrent and distributed systems have emerged. 9.1.1 Axiomatic Axiomatic specifications define fundamental language constructs by axioms that can then be composed using rules of inference to form more complicated language constructs. This approach has been attributed to Floyd <ref> [26] </ref> and has been applied with success to sequential systems. The two primary forms of this style of specification for sequential programs are Hoare triples [40] and Dijkstra's weakest precondition [24, 25]. Axiomatic specification has also been demonstrated to be a powerful mechanism in the context of concurrent systems.
Reference: [27] <author> Ian T. Foster and K. Mani Chandy. </author> <title> Fortran M: A language for modular parallel programming. </title> <journal> Journal of Parallel and Distributed Computing, </journal> <volume> 25(1), </volume> <month> February </month> <year> 1995. </year>
Reference-contexts: Other available implementations include Java [32] with RMI, CC++ [16, 93], Fortran M <ref> [27] </ref>, PVM [30], and MPI [95] to name a few. To avoid confusion in the presentation, a single practical context is used in this thesis, namely the CORBA standard. 2.4 Notation and Conventions 2.4.1 Functions and Operators The usual mathematical and logical operators are used.
Reference: [28] <author> Nissim Francez. </author> <title> Distributed termination. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 2(1) </volume> <pages> 42-55, </pages> <month> January </month> <year> 1980. </year>
Reference-contexts: It has been our experience that these services reappear frequently in the development of distributed algorithms. For example, they can be used to simplify the proof and exposition of algorithms as varied as mutual exclusion, dining philosophers [23], global snapshots [17], Byzantine generals [81], and termination detection <ref> [28, 3] </ref>. On the other hand, these two services do not comprise an exhaustive list of useful services. They are given as an illustration of the use of services and their integration in our model.
Reference: [29] <author> M. R. Garey and D. S. Johnson. </author> <title> Computers and Intractability: a Guide to the Theory of NP-Completeness. </title> <publisher> Freeman, </publisher> <address> San Francisco, California, </address> <year> 1983. </year>
Reference-contexts: It is applicable to any branch and bound tree search. For illustration purposes, however, we choose a particular instance of this class of problems to implement in Section 2.3. The particular problem we solve is a generalization of the 0-1 knapsack problem <ref> [29] </ref>. We are given a list of items, each with an integer weight and value. We are also given a list of knapsacks, each with an integer capacity.
Reference: [30] <author> Al Geist, Adam Beguelin, Jack Dongarra, Weicheng Jiang, Robert Manchek, and Vaidy Sunderam. </author> <title> PVM: Parallel Virtual Machine A Users' Guide and Tutorial for Networked Parallel Computing. </title> <publisher> MIT Press, </publisher> <address> 55 Hayward Street, Cambridge, Massachusetts 02142-1399, </address> <year> 1994. </year>
Reference-contexts: Other available implementations include Java [32] with RMI, CC++ [16, 93], Fortran M [27], PVM <ref> [30] </ref>, and MPI [95] to name a few. To avoid confusion in the presentation, a single practical context is used in this thesis, namely the CORBA standard. 2.4 Notation and Conventions 2.4.1 Functions and Operators The usual mathematical and logical operators are used.
Reference: [31] <author> J. B. Goodenough and S. L. Gerhart. </author> <title> Toward a theory of test data selection. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 1(2) </volume> <pages> 156-173, </pages> <month> June </month> <year> 1975. </year>
Reference-contexts: Of course, such testing cannot guarantee the absence of errors in a real system [42], but it can increase programmer confidence in the correctness of the system. Much work has been done on the development of test selection strategies, beginning with Goodenough and Gerhart's seminal paper <ref> [31] </ref>. There are two fundamental approaches to the selection of test data: (i) selecting tests based on the system specification, and (ii) selecting tests based on the structure of the implementation. Both approaches are discussed and further classified in [71].
Reference: [32] <author> James Gosling, Bill Joy, and Guy Steele. </author> <title> The Java Language Specification. </title> <publisher> Addison-Wesley Publishing Company, </publisher> <address> Reading, Massachusetts, </address> <year> 1996. </year>
Reference-contexts: Other available implementations include Java <ref> [32] </ref> with RMI, CC++ [16, 93], Fortran M [27], PVM [30], and MPI [95] to name a few.
Reference: [33] <author> M. Gouda, E. Manning, and Y. T. Yu. </author> <title> On the progress of communication between two finite state machines. </title> <journal> Information and Control, </journal> <volume> 63 </volume> <pages> 200-216, </pages> <month> April </month> <year> 1983. </year>
Reference-contexts: A common representation of a protocol for a communicating system is that of a finite state machine [43, 66, 70], where the transitions correspond to communication actions (i.e., the sending and receiving of messages) <ref> [33] </ref>. Consider a typical client-server model, where a server object waits in a dormant state for an RPC request. When such 31 a request is delivered, the appropriate method is executed (possibly resulting in several messages being sent) and the server returns to its dormant state. <p> The bidder state of having received a price announcement that it can beat is a mixed 97 node <ref> [33] </ref> in the bidder protocol. That is, from this state either a message can be received by the bidder (i.e., a new price announcement) or a message can be sent by the bidder (i.e., a competitive bid).
Reference: [34] <author> David Guaspari, Carla Marceau, and Wolfgang Polak. </author> <title> Formal verification of Ada programs. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 16(9) </volume> <pages> 1058-1075, </pages> <month> September </month> <year> 1990. </year> <month> 140 </month>
Reference-contexts: One tier is written in a common notation (the Larch Shared Language), while the other is written in an interface language tailored for a particular programming notation. Interface languages have been designed for C [35], Modula-3 [35], Ada <ref> [34] </ref>, and C++ [58] among others. Another popular specification language, SDL [90], is used for the description of telecommunication systems, as is the Estelle language [14]. Both these notations are based on an extended finite state machine abstraction.
Reference: [35] <author> John V. Guttag, James J. Horning, S. J. Garland, K. D. Jones, A. Modet, and J. M. Wing. </author> <title> Larch: Languages and Tools for Formal Specification. </title> <publisher> Springer-Verlag, </publisher> <address> New York, New York, </address> <year> 1993. </year>
Reference-contexts: Providing a refinement path from specification to implementation is not, however, the focus of our approach. 130 9.2 Specification Languages and Notations Several specification notations have found use in the development of real systems. Larch <ref> [35, 58] </ref> is a family of languages that support a two-tiered style of specification. One tier is written in a common notation (the Larch Shared Language), while the other is written in an interface language tailored for a particular programming notation. <p> Larch [35, 58] is a family of languages that support a two-tiered style of specification. One tier is written in a common notation (the Larch Shared Language), while the other is written in an interface language tailored for a particular programming notation. Interface languages have been designed for C <ref> [35] </ref>, Modula-3 [35], Ada [34], and C++ [58] among others. Another popular specification language, SDL [90], is used for the description of telecommunication systems, as is the Estelle language [14]. Both these notations are based on an extended finite state machine abstraction. <p> One tier is written in a common notation (the Larch Shared Language), while the other is written in an interface language tailored for a particular programming notation. Interface languages have been designed for C <ref> [35] </ref>, Modula-3 [35], Ada [34], and C++ [58] among others. Another popular specification language, SDL [90], is used for the description of telecommunication systems, as is the Estelle language [14]. Both these notations are based on an extended finite state machine abstraction.
Reference: [36] <author> B. Hailpern. </author> <title> Verifying Concurrent Processes Using Temporal Logic. </title> <booktitle> Number 129 in Lecture Notes in Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1982. </year>
Reference-contexts: Implementation-language-specific notations that incorporate temporal logic have also been proposed, such as COL [48]. This specification language and its associated deadlock analyzer are part of an Ada [2] design environment. In <ref> [36] </ref>, a procedural monitor-based programming language, VALET, is defined with a temporal logic semantics. Our fundamental operators ( initially , next , and transient ) are based on well-known operators in temporal logic. In particular, [69, 68] contains an excellent exposition of the latter two.
Reference: [37] <author> Eric C. R. Hehner. </author> <title> A practical theory of programming. </title> <booktitle> Science of Computer Programming, </booktitle> <address> 14(2-3):133-158, </address> <month> October </month> <year> 1990. </year>
Reference-contexts: We adopt a variation of Hehner's notation <ref> [37] </ref> for expressing functional next properties. We decorate the variables in the prepredicate with an apostrophe placed before the variable name. The next can then be replaced by an implication, and the result is a predicate on adjacent pairs of states in a computation.
Reference: [38] <author> D. P. Helmbold and D. C. Luckham. TSL: </author> <title> Task sequencing language. In Ada in Use: </title> <booktitle> Proceedings of the Ada International Conference, </booktitle> <pages> pages 255-274. </pages> <publisher> Cambridge University Press, </publisher> <month> May </month> <year> 1985. </year>
Reference-contexts: Both approaches are discussed and further classified in [71]. TSL (Task Sequencing Language) is a language for formally specifying the behavior of concurrent Ada programs, by specifying sequences of tasking events that can occur or are explicitly not allowed <ref> [38] </ref>. Work has been done towards the translation of these specifications into run-time checks [39]. This work has continued in the form of Rapide, an executable architecture definition language [60]. Another specification language designed with automated testing in mind is ADL by Sun Microsystems and the X/Open organization [89].
Reference: [39] <author> David P. Helmbold and Douglas L. Bryan. </author> <title> Design of run time monitors for concurrent programs. </title> <type> Technical Report CSL-TR-89-395, </type> <institution> Computer Systems Laboratory, Stanford University, </institution> <month> October </month> <year> 1989. </year>
Reference-contexts: TSL (Task Sequencing Language) is a language for formally specifying the behavior of concurrent Ada programs, by specifying sequences of tasking events that can occur or are explicitly not allowed [38]. Work has been done towards the translation of these specifications into run-time checks <ref> [39] </ref>. This work has continued in the form of Rapide, an executable architecture definition language [60]. Another specification language designed with automated testing in mind is ADL by Sun Microsystems and the X/Open organization [89].
Reference: [40] <author> C. A. R. Hoare. </author> <title> An axiomatic basis for computer programming. </title> <journal> Communications of the ACM, </journal> <volume> 12(10) </volume> <pages> 576-583, </pages> <month> October </month> <year> 1969. </year>
Reference-contexts: This approach has been attributed to Floyd [26] and has been applied with success to sequential systems. The two primary forms of this style of specification for sequential programs are Hoare triples <ref> [40] </ref> and Dijkstra's weakest precondition [24, 25]. Axiomatic specification has also been demonstrated to be a powerful mechanism in the context of concurrent systems. Martin's seminal paper [63] gave an axiomatic definition of synchronization primitives (such as send-receive) in terms of boundedness, progress, and fairness.
Reference: [41] <author> C. A. R. Hoare. </author> <title> Communicating sequential processes. </title> <journal> Communications of the ACM, </journal> <volume> 21(8) </volume> <pages> 666-677, </pages> <month> August </month> <year> 1978. </year>
Reference-contexts: The refinement calculus, as it is known, was pioneered in [4], [73], and [72]. A calculation approach to specification refinement has also met with considerable success in the area of asynchronous VLSI design. A CSP-like <ref> [41] </ref> specification is refined through a series of program transformations into a hardware implementation [65, 64]. Component specifications based on our certificates do form a lattice that is partially ordered by refinement.
Reference: [42] <author> W. E. Howden. </author> <title> Functional Program Testing and Analysis. </title> <publisher> McGraw-Hill, </publisher> <address> New York, New York, </address> <year> 1987. </year>
Reference-contexts: They are also consistent with the automatic generation of testing harnesses for implementations. 9.3 Software Validation Validation is the process whereby software is tested to ensure that it complies with its specification [45]. Of course, such testing cannot guarantee the absence of errors in a real system <ref> [42] </ref>, but it can increase programmer confidence in the correctness of the system. Much work has been done on the development of test selection strategies, beginning with Goodenough and Gerhart's seminal paper [31].
Reference: [43] <author> D. A. Huffman. </author> <title> The synthesis of sequential switching circuits. </title> <journal> Journal of the Franklin Institute, </journal> <volume> 257 </volume> <pages> 3-4, 161-190, </pages> <address> and 275-303, </address> <year> 1954. </year>
Reference-contexts: Another way to illustrate the role of clocks is to consider a representation of a component's protocol. A common representation of a protocol for a communicating system is that of a finite state machine <ref> [43, 66, 70] </ref>, where the transitions correspond to communication actions (i.e., the sending and receiving of messages) [33]. Consider a typical client-server model, where a server object waits in a dormant state for an RPC request.
Reference: [44] <author> G. E. Hughes and M. J. Cresswell. </author> <title> An Introduction to Modal Logic. </title> <publisher> Methuen, </publisher> <address> New York, New York, </address> <year> 1968. </year>
Reference-contexts: Our certificates are examples of "exists-component" properties. 9.1.2 Temporal Logic Modal logic, which has been studied since its appearance as a syllogism in Aristotle's De interpretatione, adds the operators "necessarily" and "possibly" to the usual ones of propositional logic (e.g., ^ , _ , : , ) ) <ref> [44] </ref>. Temporal logic can be viewed as a branch of modal logic in which these operators are given a temporal interpretation [83, 84].
Reference: [45] <author> IEEE. </author> <title> Standard Glossary of Software Engineering Terminology. </title> <publisher> IEEE, </publisher> <month> February </month> <year> 1991. </year> <note> ANSI/IEEE Std 610.12-1990. </note>
Reference-contexts: These specification languages can all be used to guide the selection of test data. They are also consistent with the automatic generation of testing harnesses for implementations. 9.3 Software Validation Validation is the process whereby software is tested to ensure that it complies with its specification <ref> [45] </ref>. Of course, such testing cannot guarantee the absence of errors in a real system [42], but it can increase programmer confidence in the correctness of the system. Much work has been done on the development of test selection strategies, beginning with Goodenough and Gerhart's seminal paper [31].
Reference: [46] <author> C. B. Jones. </author> <title> Tentative steps toward a development method for interfering programs. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 5(4) </volume> <pages> 596-619, </pages> <year> 1983. </year>
Reference-contexts: That is, each component in a system must behave correctly only if the other components do. The circularity of this reasoning has been broken by various proposals, including rely-guarantee <ref> [46] </ref>, hypothesis-conclusion [19], assumption-commitment [22], offers-using [52], and assumption-guarantee [1]. For example, the assumption-guarantee approach of Abadi and Lamport restricts the assumptions of environment behavior to safety properties.
Reference: [47] <author> Cliff B. Jones. </author> <title> Systematic Software Development Using VDM. </title> <booktitle> Series in Computer Science. Prentice-Hall International, </booktitle> <address> Englewood Cliffs, New Jersey 07632, </address> <year> 1986. </year> <month> 141 </month>
Reference-contexts: Another popular specification language, SDL [90], is used for the description of telecommunication systems, as is the Estelle language [14]. Both these notations are based on an extended finite state machine abstraction. VDM (the Vienna Development Method) <ref> [8, 47] </ref> has also enjoyed success in its application to large systems such as the specification of PL/I and Ada [9]. These specification languages can all be used to guide the selection of test data.
Reference: [48] <author> G. M. Karam and R. J. A. Buhr. </author> <title> Temporal logic-based deadlock analysis for Ada. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 17(10) </volume> <pages> 1109-1125, </pages> <year> 1991. </year>
Reference-contexts: Both UNITY and TLA allow for stuttering (i.e., the repetition of global state in the trace of a computation). Implementation-language-specific notations that incorporate temporal logic have also been proposed, such as COL <ref> [48] </ref>. This specification language and its associated deadlock analyzer are part of an Ada [2] design environment. In [36], a procedural monitor-based programming language, VALET, is defined with a temporal logic semantics.
Reference: [49] <author> Nils Klarlund, Jari Koistinen, and Michael I. Schwartzbach. </author> <title> Formal design constraints. </title> <journal> ACM SIGPLAN Notices, </journal> <volume> 31(10) </volume> <pages> 370-383, </pages> <month> October </month> <year> 1996. </year>
Reference-contexts: ADL has also been explored as an extension of CORBA IDL [88]. Both approaches base their functional specification on preconditions and postconditions of object methods. CDL (Constraint Design Language) is a language supported as an IDL extension and used for expressing constraints on object declarations <ref> [49] </ref>. This notation, however, is intended to support the definition of architectural elements rather than the functional specification of components. 9.5 Component Technology The modular development of programs has long been recognized as critical for the practical development of large systems [80].
Reference: [50] <author> Fred Kroger. LAR: </author> <title> A logic of alogrithmic reasoning. </title> <journal> Acta Informatica, </journal> <volume> 8 </volume> <pages> 243-266, </pages> <year> 1977. </year>
Reference-contexts: Temporal logic can be viewed as a branch of modal logic in which these operators are given a temporal interpretation [83, 84]. The use of temporal logic to formalize the behavior of computer systems was first proposed by Kroger for sequential systems <ref> [50] </ref>, and by Pnueli for concurrent ones [82]. A computation is viewed as a sequence of global states, and properties of a system are then given as temporal properties of these sequences.
Reference: [51] <author> Fred Kroger. </author> <title> Temporal Logic of Programs, </title> <booktitle> volume 8 of EATCS Monographs on Theoretical Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1987. </year>
Reference-contexts: The property that the component will eventually stop eating is a progress property and is discussed in Section 3.3. The next operator has appeared in several forms, including the co operator in [69], the next operator in [20], and the fl operator in temporal logic <ref> [51, 99] </ref>. 3.3 Progress 3.3.1 Certificate transient A progress property states that something eventually happens. We employ a single fundamental certificate for expressing progress: transient . A transient predicate is a predicate that once true is guaranteed to be falsified eventually. <p> Different characterizations of the sets of sequences to which the temporal operators apply lead to different versions of temporal logic. For example, the structure of the sequence may be linear or branching, finite or infinite. A common formulation, based on linear temporal logic, is sometimes called Manna-Pnueli theory <ref> [61, 51] </ref>. Several specification notations with strong ties to temporal logic have been developed. The UNITY model [19] defines a program to be a collection of assignment statements 129 from which, repeatedly, a statement is chosen for execution. The model gives a fairness requirement for this selection.
Reference: [52] <author> S. S. Lam and A. U. Shankar. </author> <title> A theory of interfaces and modules 1: Composition theorem. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 20(1) </volume> <pages> 55-71, </pages> <month> January </month> <year> 1994. </year>
Reference-contexts: That is, each component in a system must behave correctly only if the other components do. The circularity of this reasoning has been broken by various proposals, including rely-guarantee [46], hypothesis-conclusion [19], assumption-commitment [22], offers-using <ref> [52] </ref>, and assumption-guarantee [1]. For example, the assumption-guarantee approach of Abadi and Lamport restricts the assumptions of environment behavior to safety properties.
Reference: [53] <author> Leslie Lamport. </author> <title> Time, clocks, and the ordering of events in a distributed system. </title> <journal> Communications of the ACM, </journal> <volume> 21(7) </volume> <pages> 558-565, </pages> <month> July </month> <year> 1978. </year>
Reference-contexts: For example, a mutual exclusion algorithm might be 88 based on granting access to the critical section to components in the order in which their requests were made (in logical time) <ref> [53, 85] </ref>. The fact that logical time advances by some positive amount guarantees that all components are eventually granted access to the critical section. 6.3.3 Certificate Specification In a system that uses logical clocks, each component must satisfy the Clocked specification given in Program 6.2.
Reference: [54] <author> Leslie Lamport. </author> <title> win and sin: Predicate transformers for concurrency. </title> <type> Technical Report 17, </type> <institution> Digital Systems Research Center, Palo Alto, California, </institution> <month> May </month> <year> 1987. </year> <note> Revised December 1989. </note>
Reference-contexts: For example, Hoare triples were extended by Owicki and Gries [79, 78] with a requirement to establish noninterference between threads of execution. An extension of Dijkstra's weakest precondition was the notion of weakest and strongest invariants (win and sin) <ref> [54] </ref>. An alternate approach to the specification of components of concurrent systems has been the definition of component behavior given that its environment has a certain behavior. That is, each component in a system must behave correctly only if the other components do.
Reference: [55] <author> Leslie Lamport. </author> <title> A theorem on atomicity in distributed algorithms. </title> <journal> Distributed Computing, </journal> <volume> 4(2) </volume> <pages> 59-68, </pages> <year> 1990. </year>
Reference-contexts: It is therefore sufficient to examine the component state at the beginning and the end of these methods. Such an approach is valid under certain constraints on the message-passing layer. A set of constraints sufficient to ensure the validity of this approach has been given in <ref> [55] </ref>.
Reference: [56] <author> Leslie Lamport. </author> <title> The temporal logic of actions. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 16(3) </volume> <pages> 872-923, </pages> <month> May </month> <year> 1994. </year>
Reference-contexts: We prefer to work with total functions, so we adopt an untyped view of our specification language, where undefined values are determined by Hilbert's "choice" operator [59] (representing an arbitrary value taken from the set of possible values). This approach is similar to the TLA specification language <ref> [56, 57] </ref>. We will take care not to reference these values in properties or proofs. 3.5.2 Properties that Depend on Message-Delivery Discipline Unordered Channels. An unordered channel does not guarantee the preservation of the order of sent messages. It does guarantee, however, that messages arrive without loss or duplication. <p> The UNITY model [19] defines a program to be a collection of assignment statements 129 from which, repeatedly, a statement is chosen for execution. The model gives a fairness requirement for this selection. Program properties are then given in terms of unless, ensures, and leads-to. TLA <ref> [56] </ref> (standing for "temporal logic of actions") is a logic for system specification based on the fundamental operators 2 ("always") and 3 ("eventually") of temporal logic. TLA allows for the expression of different fairness requirements (known as strong and weak), as well as the hiding of variables in specifications.
Reference: [57] <author> Leslie Lamport and Lawrence C. Paulson. </author> <title> Should your specification language be typed? Technical Report 147, </title> <institution> Digital Systems Research Center, </institution> <address> 130 Lytton Avenue, Palo Alto, California 94301, </address> <month> May </month> <year> 1997. </year>
Reference-contexts: We prefer to work with total functions, so we adopt an untyped view of our specification language, where undefined values are determined by Hilbert's "choice" operator [59] (representing an arbitrary value taken from the set of possible values). This approach is similar to the TLA specification language <ref> [56, 57] </ref>. We will take care not to reference these values in properties or proofs. 3.5.2 Properties that Depend on Message-Delivery Discipline Unordered Channels. An unordered channel does not guarantee the preservation of the order of sent messages. It does guarantee, however, that messages arrive without loss or duplication.
Reference: [58] <author> Gary T. Leavens. </author> <title> An overview of Larch/C++: Behavioural specifications for C++ modules. </title> <type> Technical Report TR #96-01c, </type> <institution> Department of Computer Science, Iowa State University, 226 Atanasoff Hall, Ames, </institution> <address> Iowa 50011-1040, </address> <month> February </month> <year> 1996. </year> <note> Revised Jan-uary 1997. </note>
Reference-contexts: Providing a refinement path from specification to implementation is not, however, the focus of our approach. 130 9.2 Specification Languages and Notations Several specification notations have found use in the development of real systems. Larch <ref> [35, 58] </ref> is a family of languages that support a two-tiered style of specification. One tier is written in a common notation (the Larch Shared Language), while the other is written in an interface language tailored for a particular programming notation. <p> One tier is written in a common notation (the Larch Shared Language), while the other is written in an interface language tailored for a particular programming notation. Interface languages have been designed for C [35], Modula-3 [35], Ada [34], and C++ <ref> [58] </ref> among others. Another popular specification language, SDL [90], is used for the description of telecommunication systems, as is the Estelle language [14]. Both these notations are based on an extended finite state machine abstraction.
Reference: [59] <author> A. C. Leisenring. </author> <title> Mathematical Logic and Hilbert's " -Symbol. </title> <publisher> Gordon and Breach, Science Publishers, Inc., </publisher> <address> 150 Fifth Avenue, New York, New York 10011, </address> <year> 1969. </year> <month> 142 </month>
Reference-contexts: We prefer to work with total functions, so we adopt an untyped view of our specification language, where undefined values are determined by Hilbert's "choice" operator <ref> [59] </ref> (representing an arbitrary value taken from the set of possible values). This approach is similar to the TLA specification language [56, 57]. We will take care not to reference these values in properties or proofs. 3.5.2 Properties that Depend on Message-Delivery Discipline Unordered Channels.
Reference: [60] <author> David C. Luckham, John J. Kenney, Larry M. Augustin, James Vera, Doug Bryan, and Walter Mann. </author> <title> Specification and analysis of system architecture using Rapide. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 21(4) </volume> <pages> 336-355, </pages> <month> April </month> <year> 1995. </year> <note> Special Issue on Software Architecture. </note>
Reference-contexts: Work has been done towards the translation of these specifications into run-time checks [39]. This work has continued in the form of Rapide, an executable architecture definition language <ref> [60] </ref>. Another specification language designed with automated testing in mind is ADL by Sun Microsystems and the X/Open organization [89]. Originally built for the specification of C functions, it has been extended to C++ and Java [98].
Reference: [61] <author> Zohar Manna and Amir Pnueli. </author> <title> The Temporal Logic of Reactive and Concurrent Systems, volume 1. Specification. </title> <publisher> Springer-Verlag, </publisher> <address> 175 Fifth Avenue, New York, New York 10010, </address> <year> 1992. </year>
Reference-contexts: Each action then maps the current state to a new state. A computation, therefore, can either be viewed as a sequence of actions or as the corresponding sequence of states. As is common with such semantics, we permit stuttering <ref> [61, page 260] </ref>. <p> As defined in Chapter 2, a computation is an infinite sequence of such actions <ref> [61, pages 10-12] </ref>. We identify a computation with the corresponding infinite sequence of system states. A specification is a precise formal description of the behavior of a software system. We characterize the behavior of a system by the set of possible computations the system can generate. <p> A specification, therefore, defines a set of permissible computations, and a system is said to implement a specification if every computation of the system is one of the computations permitted by the specification <ref> [61, Chapter 3] </ref>. We will use predicates on computations, known as properties, as specification statements. Recall that components do not share state. <p> Different characterizations of the sets of sequences to which the temporal operators apply lead to different versions of temporal logic. For example, the structure of the sequence may be linear or branching, finite or infinite. A common formulation, based on linear temporal logic, is sometimes called Manna-Pnueli theory <ref> [61, 51] </ref>. Several specification notations with strong ties to temporal logic have been developed. The UNITY model [19] defines a program to be a collection of assignment statements 129 from which, repeatedly, a statement is chosen for execution. The model gives a fairness requirement for this selection.
Reference: [62] <author> Rajit Manohar and Paolo A. G. Sivilotti. </author> <title> Composing processes using modified rely-guarantee specifications. </title> <type> Technical Report CS-TR-96-22, </type> <institution> Computer Science Department, California Institute of Technology, </institution> <address> 256-80 Caltech, Pasadena, California 91125, </address> <month> June </month> <year> 1996. </year>
Reference-contexts: The circularity of this reasoning has been broken by various proposals, including rely-guarantee [46], hypothesis-conclusion [19], assumption-commitment [22], offers-using [52], and assumption-guarantee [1]. For example, the assumption-guarantee approach of Abadi and Lamport restricts the assumptions of environment behavior to safety properties. The modified rely-guarantee approach of Manohar and Sivilotti <ref> [62] </ref> allows progress properties to be part of the rely clause, but requires the explicit construction of an acyclic implication ladder. The weakest guarantee approach of Chandy and Sanders [20, 21] breaks the circularity by considering requirements on the entire system rather than just the environment.
Reference: [63] <author> Alain J. Martin. </author> <title> An axiomatic definition of synchronization primitives. </title> <journal> Acta Infor-matica, </journal> <volume> 16 </volume> <pages> 219-235, </pages> <year> 1981. </year>
Reference-contexts: The two primary forms of this style of specification for sequential programs are Hoare triples [40] and Dijkstra's weakest precondition [24, 25]. Axiomatic specification has also been demonstrated to be a powerful mechanism in the context of concurrent systems. Martin's seminal paper <ref> [63] </ref> gave an axiomatic definition of synchronization primitives (such as send-receive) in terms of boundedness, progress, and fairness. Attempts have also been made to extend the approaches taken with sequential 128 systems to concurrent ones.
Reference: [64] <author> Alain J. Martin. </author> <title> Formal methods for VLSI design, chapter Synthesis of Asynchronous VLSI Circuits. </title> <publisher> Elsevier Science Publishing Company, </publisher> <address> New York, New York, </address> <year> 1990. </year>
Reference-contexts: The refinement calculus, as it is known, was pioneered in [4], [73], and [72]. A calculation approach to specification refinement has also met with considerable success in the area of asynchronous VLSI design. A CSP-like [41] specification is refined through a series of program transformations into a hardware implementation <ref> [65, 64] </ref>. Component specifications based on our certificates do form a lattice that is partially ordered by refinement. The ordering relationship is given by implication and can be established using propositional calculus as illustrated in Chapters 7 and 8.
Reference: [65] <author> Alain J. Martin. </author> <title> Synthesis of asynchronous VLSI circuits. </title> <type> Technical Report Caltech-CS-TR-93-28, </type> <institution> Computer Science Department, California Institute of Technology, </institution> <address> 256-80 Caltech, Pasadena, California 91125, </address> <year> 1993. </year>
Reference-contexts: The refinement calculus, as it is known, was pioneered in [4], [73], and [72]. A calculation approach to specification refinement has also met with considerable success in the area of asynchronous VLSI design. A CSP-like [41] specification is refined through a series of program transformations into a hardware implementation <ref> [65, 64] </ref>. Component specifications based on our certificates do form a lattice that is partially ordered by refinement. The ordering relationship is given by implication and can be established using propositional calculus as illustrated in Chapters 7 and 8.
Reference: [66] <author> G. H. Mealy. </author> <title> A method for synthesizing sequential circuits. </title> <journal> Bell System Technical Journal, </journal> <volume> 34(5) </volume> <pages> 1045-1079, </pages> <year> 1955. </year>
Reference-contexts: Another way to illustrate the role of clocks is to consider a representation of a component's protocol. A common representation of a protocol for a communicating system is that of a finite state machine <ref> [43, 66, 70] </ref>, where the transitions correspond to communication actions (i.e., the sending and receiving of messages) [33]. Consider a typical client-server model, where a server object waits in a dormant state for an RPC request.
Reference: [67] <author> Bertrand Meyer. </author> <title> Object-Oriented Software Construction. </title> <booktitle> International Series in Computer Science. </booktitle> <publisher> Prentice Hall, </publisher> <year> 1988. </year>
Reference-contexts: In addition to information exchange, there is also considerable interest in distributed collaborative, commercial, and entertainment applications. Distributed programming is poised to enter the mainstream of commodity software. One methodology that is useful for managing the complexity of distributed systems is object orientation <ref> [12, 67] </ref>. This is a technique of program design that focuses attention on the data being manipulated [86, 91]. Object-oriented languages (such as C++ [96] and Oberon-2 [74]) contain sophisticated mechanisms for supporting user-defined data types, 2 known as classes.
Reference: [68] <author> Jayadev Misra. </author> <title> A logic for concurrent programming: Progress. </title> <journal> Journal of Computer & Software Engineering, </journal> <volume> 3(2) </volume> <pages> 273-300, </pages> <year> 1995. </year>
Reference-contexts: Leads-to can be defined in terms of transience and next <ref> [68] </ref>. <p> In [36], a procedural monitor-based programming language, VALET, is defined with a temporal logic semantics. Our fundamental operators ( initially , next , and transient ) are based on well-known operators in temporal logic. In particular, <ref> [69, 68] </ref> contains an excellent exposition of the latter two. Our derived operators ( stable , invariant , and leads-to) are also familiar from many temporal frameworks, but were inspired by their presentation in UNITY.
Reference: [69] <author> Jayadev Misra. </author> <title> A logic for concurrent programming: Safety. </title> <journal> Journal of Computer & Software Engineering, </journal> <volume> 3(2) </volume> <pages> 239-272, </pages> <year> 1995. </year>
Reference-contexts: The property that the component will eventually stop eating is a progress property and is discussed in Section 3.3. The next operator has appeared in several forms, including the co operator in <ref> [69] </ref>, the next operator in [20], and the fl operator in temporal logic [51, 99]. 3.3 Progress 3.3.1 Certificate transient A progress property states that something eventually happens. We employ a single fundamental certificate for expressing progress: transient . <p> The distinction centers around the consideration of reachable states and is eliminated by the adoption of a substitution axiom similar to that of UNITY logic <ref> [19, 87, 69] </ref>. An example of an invariant property is that a variable is always positive. <p> In [36], a procedural monitor-based programming language, VALET, is defined with a temporal logic semantics. Our fundamental operators ( initially , next , and transient ) are based on well-known operators in temporal logic. In particular, <ref> [69, 68] </ref> contains an excellent exposition of the latter two. Our derived operators ( stable , invariant , and leads-to) are also familiar from many temporal frameworks, but were inspired by their presentation in UNITY.
Reference: [70] <author> E. F. Moore. </author> <title> Automata Studies, chapter Gedanken experiments on sequential machines, </title> <address> pages 129-153. </address> <publisher> Princeton University Press, </publisher> <address> Princeton, New Jersey, </address> <year> 1956. </year> <month> 143 </month>
Reference-contexts: Another way to illustrate the role of clocks is to consider a representation of a component's protocol. A common representation of a protocol for a communicating system is that of a finite state machine <ref> [43, 66, 70] </ref>, where the transitions correspond to communication actions (i.e., the sending and receiving of messages) [33]. Consider a typical client-server model, where a server object waits in a dormant state for an RPC request.
Reference: [71] <author> L. J. Morell. </author> <title> Unit testing and analysis. Curriculum Module SEI-CM-9-1.1, </title> <institution> Software Engineering Institute, Carnegie Mellon University, Pittsburgh, Pennsylvania, </institution> <month> Decem-ber </month> <year> 1988. </year>
Reference-contexts: There are two fundamental approaches to the selection of test data: (i) selecting tests based on the system specification, and (ii) selecting tests based on the structure of the implementation. Both approaches are discussed and further classified in <ref> [71] </ref>. TSL (Task Sequencing Language) is a language for formally specifying the behavior of concurrent Ada programs, by specifying sequences of tasking events that can occur or are explicitly not allowed [38]. Work has been done towards the translation of these specifications into run-time checks [39].
Reference: [72] <author> Carroll Morgan. </author> <title> The specification statement. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 10(3) </volume> <pages> 7-30, </pages> <month> July </month> <year> 1988. </year>
Reference-contexts: That is, specifications and implementations are distinguished only by imple-mentability. This view has given rise to the study of the refinement from specification to implementation in a calculational manner. The refinement calculus, as it is known, was pioneered in [4], [73], and <ref> [72] </ref>. A calculation approach to specification refinement has also met with considerable success in the area of asynchronous VLSI design. A CSP-like [41] specification is refined through a series of program transformations into a hardware implementation [65, 64].
Reference: [73] <author> Joseph M. Morris. </author> <title> A theoretical basis for stepwise refinement and the progamming calculus. </title> <booktitle> Science of Computer Programming, </booktitle> <volume> 9(3) </volume> <pages> 287-306, </pages> <year> 1987. </year>
Reference-contexts: That is, specifications and implementations are distinguished only by imple-mentability. This view has given rise to the study of the refinement from specification to implementation in a calculational manner. The refinement calculus, as it is known, was pioneered in [4], <ref> [73] </ref>, and [72]. A calculation approach to specification refinement has also met with considerable success in the area of asynchronous VLSI design. A CSP-like [41] specification is refined through a series of program transformations into a hardware implementation [65, 64].
Reference: [74] <editor> Hanspeter Mossenbock. </editor> <booktitle> Object-Oriented Programming in Oberon-2. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1993. </year>
Reference-contexts: One methodology that is useful for managing the complexity of distributed systems is object orientation [12, 67]. This is a technique of program design that focuses attention on the data being manipulated [86, 91]. Object-oriented languages (such as C++ [96] and Oberon-2 <ref> [74] </ref>) contain sophisticated mechanisms for supporting user-defined data types, 2 known as classes. One of these mechanisms, encapsulation, provides the ability to collect data and functionality within logical units, and to separate the implementation of these units from their interface.
Reference: [75] <author> P. Naur. </author> <title> Revised report on algorithmic language Algol-60. </title> <journal> Computer Journal, </journal> <volume> 5(349), </volume> <year> 1960. </year>
Reference-contexts: They have the advantage of being suitable for automatic translation into run-time checks or warnings. Some of these simple certificates will be given a special syntax (that will be defined using standard Backus-Naur notation <ref> [75] </ref>). 3.6.1 Monotonicity We say a variable is monotonic if, in the course of a computation, its value is monotonically increasing or decreasing. This property requires that a partial order be defined on the type of the variable. The ordering relation is typically understood from the type.
Reference: [76] <author> George C. Necula and Peter Lee. </author> <title> Proof-carrying code. </title> <type> Technical Report CMU-CS-96-165, </type> <institution> Canegie Mellon University, Pittsburgh, Pennsylvania 15213, </institution> <month> September </month> <year> 1996. </year>
Reference-contexts: One of the challenges to COTS component assembly is establishing confidence in the correctness of the component being used. The Fox project supports the concept of "proof-carrying code" <ref> [76] </ref>. That is, a proof of correctness is embedded in the assembled implementation code, which the user can verify. This approach protects both the user of the component (from incorrect implementations) and the developer of the component (maintaining the privacy of the implementation code).
Reference: [77] <author> Object Management Group. </author> <title> The Common Object Request Broker: Architecture and Specification, </title> <month> July </month> <year> 1995. </year> <note> Revision 2.0. </note>
Reference-contexts: Commercial object-based frameworks for developing distributed systems typically use class declarations to verify a syntactic consistency between components. A class declaration of one component is used to verify that the component responds to a particular message (or method invocation). In recent years, an industry-wide standard, known as CORBA <ref> [77] </ref>, has emerged for object-based distributed system construction. <p> The mandate of this organization has been to promote the theory and practice of object technology for the development of distributed computing systems. One of the most significant contributions by the OMG has been a standard for distributed object-based systems, known as CORBA <ref> [77] </ref>. Introduced in 1991, the CORBA specification defined the middleware to support distributed object communication. Several implementations of this standard became available soon after. Adopted in 1995, a revision of the specification (CORBA 2.0) defined the requirements for interoperability between these implementations.
Reference: [78] <author> S. Owicki and D. Gries. </author> <title> An axiomatic proof technique for parallel programs I. </title> <journal> Acta Informatica, </journal> <volume> 6 </volume> <pages> 319-340, </pages> <year> 1976. </year>
Reference-contexts: Martin's seminal paper [63] gave an axiomatic definition of synchronization primitives (such as send-receive) in terms of boundedness, progress, and fairness. Attempts have also been made to extend the approaches taken with sequential 128 systems to concurrent ones. For example, Hoare triples were extended by Owicki and Gries <ref> [79, 78] </ref> with a requirement to establish noninterference between threads of execution. An extension of Dijkstra's weakest precondition was the notion of weakest and strongest invariants (win and sin) [54].
Reference: [79] <author> S. Owicki and D. Gries. </author> <title> Verifying properties of parallel programs: An axiomatic approach. </title> <journal> Communications of the ACM, </journal> <volume> 19(5) </volume> <pages> 279-285, </pages> <month> May </month> <year> 1976. </year>
Reference-contexts: Martin's seminal paper [63] gave an axiomatic definition of synchronization primitives (such as send-receive) in terms of boundedness, progress, and fairness. Attempts have also been made to extend the approaches taken with sequential 128 systems to concurrent ones. For example, Hoare triples were extended by Owicki and Gries <ref> [79, 78] </ref> with a requirement to establish noninterference between threads of execution. An extension of Dijkstra's weakest precondition was the notion of weakest and strongest invariants (win and sin) [54].
Reference: [80] <author> D. L. Parnas. </author> <title> A technique for software module specification with examples. </title> <journal> Communications of the ACM, </journal> <volume> 15(5) </volume> <pages> 330-336, </pages> <month> May </month> <year> 1972. </year>
Reference-contexts: This notation, however, is intended to support the definition of architectural elements rather than the functional specification of components. 9.5 Component Technology The modular development of programs has long been recognized as critical for the practical development of large systems <ref> [80] </ref>. At the same time, the high cost of construction of reliable software systems has made reuse (of implementation, architecture, and reasoning) a priority in many organizations. The confluence of these two forces makes component-based technology attractive in a competitive software market.
Reference: [81] <author> M. Pease, R. Shostak, and L. Lamport. </author> <title> Reaching agreement in the presence of faults. </title> <journal> Journal of the ACM, </journal> <volume> 27(2) </volume> <pages> 228-234, </pages> <month> April </month> <year> 1980. </year>
Reference-contexts: It has been our experience that these services reappear frequently in the development of distributed algorithms. For example, they can be used to simplify the proof and exposition of algorithms as varied as mutual exclusion, dining philosophers [23], global snapshots [17], Byzantine generals <ref> [81] </ref>, and termination detection [28, 3]. On the other hand, these two services do not comprise an exhaustive list of useful services. They are given as an illustration of the use of services and their integration in our model.
Reference: [82] <author> Amir Pnueli. </author> <title> The temporal logic of programs. </title> <booktitle> In Proceedings of the 18th IEEE Symposium on the Foundations of Computer Science, </booktitle> <pages> pages 46-57, </pages> <address> New York, New York, 1977. </address> <publisher> IEEE. </publisher>
Reference-contexts: Temporal logic can be viewed as a branch of modal logic in which these operators are given a temporal interpretation [83, 84]. The use of temporal logic to formalize the behavior of computer systems was first proposed by Kroger for sequential systems [50], and by Pnueli for concurrent ones <ref> [82] </ref>. A computation is viewed as a sequence of global states, and properties of a system are then given as temporal properties of these sequences. Different characterizations of the sets of sequences to which the temporal operators apply lead to different versions of temporal logic.
Reference: [83] <author> Arthur N. </author> <title> Prior. Time and Modality. </title> <type> John Locke lectures, </type> <pages> 1955-6. </pages> <publisher> Oxford, Clarendon Press, Oxford, </publisher> <year> 1957. </year> <month> 144 </month>
Reference-contexts: Temporal logic can be viewed as a branch of modal logic in which these operators are given a temporal interpretation <ref> [83, 84] </ref>. The use of temporal logic to formalize the behavior of computer systems was first proposed by Kroger for sequential systems [50], and by Pnueli for concurrent ones [82].
Reference: [84] <author> Nicholas Rescher and Alasdair Urquhart. </author> <title> Temporal Logic, volume 3 of Library of Exact Philosophy. </title> <publisher> Springer-Verlag, </publisher> <address> New York, New York, </address> <year> 1971. </year>
Reference-contexts: Temporal logic can be viewed as a branch of modal logic in which these operators are given a temporal interpretation <ref> [83, 84] </ref>. The use of temporal logic to formalize the behavior of computer systems was first proposed by Kroger for sequential systems [50], and by Pnueli for concurrent ones [82].
Reference: [85] <author> G. Ricart and A. Agrawala. </author> <title> An optimal algorithm for mutual exclusion in computer networks. </title> <journal> Communications of the ACM, </journal> <volume> 24(1) </volume> <pages> 9-17, </pages> <month> January </month> <year> 1981. </year>
Reference-contexts: For example, a mutual exclusion algorithm might be 88 based on granting access to the critical section to components in the order in which their requests were made (in logical time) <ref> [53, 85] </ref>. The fact that logical time advances by some positive amount guarantees that all components are eventually granted access to the critical section. 6.3.3 Certificate Specification In a system that uses logical clocks, each component must satisfy the Clocked specification given in Program 6.2.
Reference: [86] <author> James Rumbaugh, Michael Blaha, William Premerlani, Frederick Eddy, and William Lorensen. </author> <title> Object-Oriented Modeling and Design. </title> <publisher> Prentice Hall, </publisher> <address> Englewood Cliffs, New Jersey 07632, </address> <year> 1991. </year>
Reference-contexts: Distributed programming is poised to enter the mainstream of commodity software. One methodology that is useful for managing the complexity of distributed systems is object orientation [12, 67]. This is a technique of program design that focuses attention on the data being manipulated <ref> [86, 91] </ref>. Object-oriented languages (such as C++ [96] and Oberon-2 [74]) contain sophisticated mechanisms for supporting user-defined data types, 2 known as classes. One of these mechanisms, encapsulation, provides the ability to collect data and functionality within logical units, and to separate the implementation of these units from their interface.
Reference: [87] <author> Beverly A. Sanders. </author> <title> Eliminating the substitution axiom from UNITY logic. </title> <journal> Formal Aspects of Computing, </journal> <volume> 3 </volume> <pages> 189-205, </pages> <year> 1991. </year>
Reference-contexts: The distinction centers around the consideration of reachable states and is eliminated by the adoption of a substitution axiom similar to that of UNITY logic <ref> [19, 87, 69] </ref>. An example of an invariant property is that a variable is always positive.
Reference: [88] <author> Sriram Sankar and Roger Hayes. </author> <title> ADL an interface definition language for specifying and testing software. </title> <journal> ACM SIGPLAN Notices, </journal> <volume> 29(8) </volume> <pages> 13-21, </pages> <month> August </month> <year> 1994. </year>
Reference-contexts: For example, a Larch interface language for use with CORBA IDL has been studied [92]. ADL has also been explored as an extension of CORBA IDL <ref> [88] </ref>. Both approaches base their functional specification on preconditions and postconditions of object methods. CDL (Constraint Design Language) is a language supported as an IDL extension and used for expressing constraints on object declarations [49].
Reference: [89] <author> Sriram Sankar and Roger Hayes. </author> <title> Specifying and testing software components using ADL. </title> <type> Technical Report SMLI TR-94-23, </type> <institution> Sun Microsystems Laboratories, Inc., </institution> <address> M/S 29-01, 2550 Garcia Avenue, Mountain View, California 94043, </address> <month> April </month> <year> 1994. </year>
Reference-contexts: Work has been done towards the translation of these specifications into run-time checks [39]. This work has continued in the form of Rapide, an executable architecture definition language [60]. Another specification language designed with automated testing in mind is ADL by Sun Microsystems and the X/Open organization <ref> [89] </ref>. Originally built for the specification of C functions, it has been extended to C++ and Java [98]. In conjunction with a test-data description file, an ADL description is used to automatically generate a test program.
Reference: [90] <author> Roberto Saracco, J. R. W. Smith, and Rick Reed. </author> <title> Telecommunications Systems Engineering Using SDL. </title> <publisher> North-Holland, </publisher> <address> New York, New York, </address> <year> 1989. </year>
Reference-contexts: One tier is written in a common notation (the Larch Shared Language), while the other is written in an interface language tailored for a particular programming notation. Interface languages have been designed for C [35], Modula-3 [35], Ada [34], and C++ [58] among others. Another popular specification language, SDL <ref> [90] </ref>, is used for the description of telecommunication systems, as is the Estelle language [14]. Both these notations are based on an extended finite state machine abstraction.
Reference: [91] <author> Sally Shlaer and Stephen J. Mellor. </author> <title> Object-Oriented Systems Analysis: Modeling the World in Data. </title> <publisher> Yourdon Press Computing Series. Yourdon Press, </publisher> <address> Englewood Cliffs, New Jersey 07632, </address> <year> 1988. </year>
Reference-contexts: Distributed programming is poised to enter the mainstream of commodity software. One methodology that is useful for managing the complexity of distributed systems is object orientation [12, 67]. This is a technique of program design that focuses attention on the data being manipulated <ref> [86, 91] </ref>. Object-oriented languages (such as C++ [96] and Oberon-2 [74]) contain sophisticated mechanisms for supporting user-defined data types, 2 known as classes. One of these mechanisms, encapsulation, provides the ability to collect data and functionality within logical units, and to separate the implementation of these units from their interface.
Reference: [92] <author> Gowri Sandar Sivaprasad. Larch/CORBA: </author> <title> Specifying the behavior of CORBA-IDL interfaces. </title> <type> Master's thesis, </type> <institution> Iowa State University, 226 Atanasoff Hall, Ames, </institution> <address> Iowa 50011-1040, </address> <month> November </month> <year> 1995. </year> <type> TR #95-27. </type>
Reference-contexts: ADL is therefore less appropriate for the specification of peer-to-peer style distributed computations. 9.4 CORBA IDL Extensions Some of the notations discussed above have also been proposed as extensions to CORBA IDL. For example, a Larch interface language for use with CORBA IDL has been studied <ref> [92] </ref>. ADL has also been explored as an extension of CORBA IDL [88]. Both approaches base their functional specification on preconditions and postconditions of object methods. CDL (Constraint Design Language) is a language supported as an IDL extension and used for expressing constraints on object declarations [49].
Reference: [93] <author> Paolo A. G. Sivilotti and Peter A. Carlin. </author> <title> A tutorial for CC++. </title> <type> Technical Report CS-TR-94-02, </type> <institution> Computer Science Department, California Institute of Technology, </institution> <address> 256-80 Caltech, Pasadena, California 91125, </address> <year> 1994. </year>
Reference-contexts: Other available implementations include Java [32] with RMI, CC++ <ref> [16, 93] </ref>, Fortran M [27], PVM [30], and MPI [95] to name a few. To avoid confusion in the presentation, a single practical context is used in this thesis, namely the CORBA standard. 2.4 Notation and Conventions 2.4.1 Functions and Operators The usual mathematical and logical operators are used.
Reference: [94] <author> Paolo A. G. Sivilotti and K. Mani Chandy. </author> <title> A distributed infrastructure for software component technology. </title> <type> Technical Report CS-TR-97-32, </type> <institution> Computer Science Department, California Institute of Technology, </institution> <address> 256-80 Caltech, Pasadena, California 91125, </address> <month> September </month> <year> 1997. </year> <month> 145 </month>
Reference-contexts: The challenge is to provide an infrastructure to help component implementors locate publicly available proofs that are appropriate for them to use. The initial steps towards such an infrastructure are outlined in <ref> [94] </ref>, where we describe how a universal distributed type hierarchy could be established and maintained. Such a system could also address the issue of the dynamic location of components based on semantic information, in addition to the syntactic information (e.g., component name) used in today's technologies. 136 137
Reference: [95] <author> Marc Snir, Steve W. Otto, Steven Huss-Lederman, David W. Walker, and Jack Don-garra. </author> <title> MPI: The Complete Reference. </title> <publisher> MIT Press, </publisher> <address> 55 Hayward Street, Cambridge, Massachusetts 02142-1399, </address> <month> November </month> <year> 1995. </year>
Reference-contexts: Other available implementations include Java [32] with RMI, CC++ [16, 93], Fortran M [27], PVM [30], and MPI <ref> [95] </ref> to name a few. To avoid confusion in the presentation, a single practical context is used in this thesis, namely the CORBA standard. 2.4 Notation and Conventions 2.4.1 Functions and Operators The usual mathematical and logical operators are used. Function application is denoted with the infix "." operator.
Reference: [96] <author> Bjarne Stroustrup. </author> <title> The C++ Programming Language. </title> <publisher> Addison-Wesley Publishing Company, </publisher> <address> Reading, Massachusetts, </address> <note> second edition, </note> <year> 1991. </year>
Reference-contexts: One methodology that is useful for managing the complexity of distributed systems is object orientation [12, 67]. This is a technique of program design that focuses attention on the data being manipulated [86, 91]. Object-oriented languages (such as C++ <ref> [96] </ref> and Oberon-2 [74]) contain sophisticated mechanisms for supporting user-defined data types, 2 known as classes. One of these mechanisms, encapsulation, provides the ability to collect data and functionality within logical units, and to separate the implementation of these units from their interface.
Reference: [97] <author> Jan L. A. van de Snepscheut. </author> <title> On lattice theory and program semantics. </title> <type> Technical Report CS-TR-93-19, </type> <institution> Computer Science Department, California Institute of Technology, </institution> <address> 256-80 Caltech, Pasadena, California 91125, </address> <month> Spring </month> <year> 1993. </year>
Reference-contexts: x = ( Min k : k 2 FP :x 0 : k )) (4.10) 4.1.2 Properties for Lattices A poset is called a lattice if every finite nonempty set has a greatest lower bound (or "meet," denoted # ) and a least upper bound (or "join," denoted " ) <ref> [7, 97] </ref>.
Reference: [98] <author> Sreenivasa Rao Viswanadha and Sriram Sankar. </author> <title> Preliminary design of ADL/C++ a specification language for C++. </title> <booktitle> In Second Conference on Object-Oriented Technologies and Systems (COOTS), </booktitle> <month> June </month> <year> 1996. </year>
Reference-contexts: Another specification language designed with automated testing in mind is ADL by Sun Microsystems and the X/Open organization [89]. Originally built for the specification of C functions, it has been extended to C++ and Java <ref> [98] </ref>. In conjunction with a test-data description file, an ADL description is used to automatically generate a test program. Functional specifications are given as method postconditions, however, so they have a strong 131 client-server bias.
Reference: [99] <author> G. H. von Wright. </author> <title> And next. </title> <journal> Acta Philosophica Fennica, </journal> <volume> 18 </volume> <pages> 293-304, </pages> <year> 1965. </year>
Reference-contexts: The property that the component will eventually stop eating is a progress property and is discussed in Section 3.3. The next operator has appeared in several forms, including the co operator in [69], the next operator in [20], and the fl operator in temporal logic <ref> [51, 99] </ref>. 3.3 Progress 3.3.1 Certificate transient A progress property states that something eventually happens. We employ a single fundamental certificate for expressing progress: transient . A transient predicate is a predicate that once true is guaranteed to be falsified eventually.
References-found: 99

