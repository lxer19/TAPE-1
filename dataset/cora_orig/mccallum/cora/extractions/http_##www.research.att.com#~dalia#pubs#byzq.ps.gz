URL: http://www.research.att.com/~dalia/pubs/byzq.ps.gz
Refering-URL: http://www.research.att.com/~dalia/
Root-URL: http://www.aic.nrl.navy.mil/~aha/people.html
Email: fdalia,reiterg@research.att.com  
Title: Byzantine Quorum Systems  
Author: Dahlia Malkhi Michael Reiter 
Address: Murray Hill, NJ USA  
Affiliation: AT&T Labs|Research,  
Abstract: Quorum systems are well-known tools for ensuring the consistency and availability of replicated data despite the benign failure of data repositories. In this paper we consider the arbitrary (Byzantine) failure of data repositories and present the first study of quorum system requirements and constructions that ensure data availability and consistency despite these failures. We also consider the load associated with our quorum systems, i.e., the minimal access probability of the busiest server. For services subject to arbitrary failures, we demonstrate quorum systems over n servers with a load of O( 1 p n ), thus meeting the lower bound on load for benignly fault-tolerant quorum systems. We explore several variations of our quorum systems and extend our construc tions to cope with arbitrary client failures.
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Y. Afek, H. Attiya, D. Dolev, E. Gafni, M. Merritt and N. Shavit. </author> <title> Atomic snapshots of shared memory. </title> <journal> Journal of the ACM 40(4) </journal> <pages> 873-890, </pages> <month> September </month> <year> 1993. </year>
Reference-contexts: These semantics imply a safe variable [24] in the case of a single reader and single writer, which a set of correct clients can use to build other abstractions, e.g., atomic, multi-writer multi-reader registers [24, 21, 25], concurrent timestamp systems [12, 19], l-exclusion [11, 2], and atomic snapshot scan <ref> [1, 5] </ref>. Our quorum constructions can also be directly exploited in algorithms that employ "uniform" quorums for fault tolerance (by involving a threshold of processes), in order to improve efficiency or tolerate nonuniform failure scenarios.
Reference: [2] <author> Y. Afek, D. Dolev, E. Gafni, M. Merritt and N. Shavit. </author> <title> A bounded first-in first-enabled-solution to the l-exclusion problem. </title> <booktitle> In Proceedings of the 4th International Workshop on Distributed Algorithms, </booktitle> <publisher> LNCS 486, Springer-Verlag, </publisher> <year> 1990. </year>
Reference-contexts: These semantics imply a safe variable [24] in the case of a single reader and single writer, which a set of correct clients can use to build other abstractions, e.g., atomic, multi-writer multi-reader registers [24, 21, 25], concurrent timestamp systems [12, 19], l-exclusion <ref> [11, 2] </ref>, and atomic snapshot scan [1, 5]. Our quorum constructions can also be directly exploited in algorithms that employ "uniform" quorums for fault tolerance (by involving a threshold of processes), in order to improve efficiency or tolerate nonuniform failure scenarios.
Reference: [3] <author> D. Agrawal and A. El Abbadi. </author> <title> Integrating security with fault-tolerant distributed databases. </title> <journal> Computer Journal 33(1) </journal> <pages> 71-78, </pages> <month> February </month> <year> 1990. </year>
Reference-contexts: Quorum systems have been previously employed in the implementation of security mechanisms. Naor and Wool [31] described methods to construct an access-control service using quorums. Their constructions use cryptographic techniques to ensure that out-of-date (but correct) servers cannot grant access to unauthorized users. Agrawal and El Abbadi <ref> [3] </ref> and Mukkamala [29] considered the confidentiality of replicated data despite the disclosure of the contents of a threshold of the (otherwise correct) repositories.
Reference: [4] <author> D. Agrawal and A. El Abbadi. </author> <title> An efficient and fault-tolerant solution for distributed mutual exclusion. </title> <journal> ACM Transactions on Computer Systems 9(1) </journal> <pages> 1-20, </pages> <year> 1991. </year>
Reference-contexts: We conclude in Section 7. 2 Related work Our work was influenced by the substantial body of literature on quorum systems for benign failures and applications that make use of them, e.g., <ref> [15, 38, 26, 14, 17, 13, 9, 4, 30] </ref>. In particular, our grid construction of Section 4 was influenced by grid-like constructions for benign failures (e.g., [9]), and we borrow our definition of load from [30]. Quorum systems have been previously employed in the implementation of security mechanisms.
Reference: [5] <author> J. H. Anderson. </author> <title> Composite registers. </title> <booktitle> Distributed Computing 6(3) </booktitle> <pages> 141-154, </pages> <year> 1993. </year>
Reference-contexts: These semantics imply a safe variable [24] in the case of a single reader and single writer, which a set of correct clients can use to build other abstractions, e.g., atomic, multi-writer multi-reader registers [24, 21, 25], concurrent timestamp systems [12, 19], l-exclusion [11, 2], and atomic snapshot scan <ref> [1, 5] </ref>. Our quorum constructions can also be directly exploited in algorithms that employ "uniform" quorums for fault tolerance (by involving a threshold of processes), in order to improve efficiency or tolerate nonuniform failure scenarios.
Reference: [6] <author> H. Attiya, A. Bar-Noy and D. Dolev. </author> <title> Sharing Memory Robustly in Message-Passing Systems. </title> <journal> Journal of the ACM 42(1) </journal> <pages> 124-142, </pages> <month> January </month> <year> 1995. </year>
Reference-contexts: Our quorum constructions can also be directly exploited in algorithms that employ "uniform" quorums for fault tolerance (by involving a threshold of processes), in order to improve efficiency or tolerate nonuniform failure scenarios. Examples include algorithms for shared memory emulation <ref> [6] </ref>, randomized Byzantine agreement [39], reliable Byzantine multicast [8, 33, 27], and secure replicated data [18]. The rest of this paper is structured as follows. We begin in Section 2 with a description of related work. In Section 3 we present our system model and definitions.
Reference: [7] <author> P. A. Bernstein, V. Hadzilacos and N. Goodman. </author> <title> Concur-rency control and recovery in database systems. </title> <publisher> Addison-wesley, </publisher> <year> 1987. </year>
Reference: [8] <author> G. Bracha and S. Toueg. </author> <title> Asynchronous consensus and broadcast protocols. </title> <journal> Journal of the ACM 32(4) </journal> <pages> 824-840, </pages> <month> October </month> <year> 1985. </year>
Reference-contexts: Our quorum constructions can also be directly exploited in algorithms that employ "uniform" quorums for fault tolerance (by involving a threshold of processes), in order to improve efficiency or tolerate nonuniform failure scenarios. Examples include algorithms for shared memory emulation [6], randomized Byzantine agreement [39], reliable Byzantine multicast <ref> [8, 33, 27] </ref>, and secure replicated data [18]. The rest of this paper is structured as follows. We begin in Section 2 with a description of related work. In Section 3 we present our system model and definitions. <p> This update protocol could be implemented using well-known agreement protocols (e.g., <ref> [22, 8] </ref>), but only if the given fail-prone system B has the property that each B 2 B is of size less than jU j=3, and only by involving all of the servers in the system.
Reference: [9] <author> S. Y. Cheung, M. H. Ammar, and M. Ahamad. </author> <title> The grid protocol: A high performance scheme for maintaining replicated data. </title> <booktitle> In Proceedings of the 6th IEEE International Conference on Data Engineering, </booktitle> <pages> pages 438-445, </pages> <year> 1990. </year>
Reference-contexts: We conclude in Section 7. 2 Related work Our work was influenced by the substantial body of literature on quorum systems for benign failures and applications that make use of them, e.g., <ref> [15, 38, 26, 14, 17, 13, 9, 4, 30] </ref>. In particular, our grid construction of Section 4 was influenced by grid-like constructions for benign failures (e.g., [9]), and we borrow our definition of load from [30]. Quorum systems have been previously employed in the implementation of security mechanisms. <p> In particular, our grid construction of Section 4 was influenced by grid-like constructions for benign failures (e.g., <ref> [9] </ref>), and we borrow our definition of load from [30]. Quorum systems have been previously employed in the implementation of security mechanisms. Naor and Wool [31] described methods to construct an access-control service using quorums.
Reference: [10] <author> International Telegraph and Telephone Consultative Committee (CCITT). </author> <title> The Directory Authentication Framework, </title> <type> Recommendation X.509, </type> <year> 1988. </year>
Reference-contexts: A natural example is a database of public key certificates as found in many public key distribution systems (e.g., <ref> [10, 37, 23] </ref>). A public key certificate is a structure containing a name for a user and a public key, and represents the assertion that the indicated public key can be used to authenticate messages from the indicated user. <p> It is important to note that timestamps must be included as part of the self-verifying information, so they cannot be undetectably altered by faulty servers. In the case of the application described above, existing standards for public key certificates (e.g., <ref> [10] </ref>) already require a real-time timestamp in the certificate. The following lemma proves correctness of the above pro-tocol using dissemination quorum systems. The proof is almost identical to that for masking quorum systems.
Reference: [11] <author> D. Dolev, E. Gafni and N. Shavit. </author> <title> Toward a non-atomic era: l-exclusion as a test case. </title> <booktitle> In Proceedings of the 20th ACM Symposium on Theory of Computing, </booktitle> <pages> pages 78-92, </pages> <month> May </month> <year> 1988. </year>
Reference-contexts: These semantics imply a safe variable [24] in the case of a single reader and single writer, which a set of correct clients can use to build other abstractions, e.g., atomic, multi-writer multi-reader registers [24, 21, 25], concurrent timestamp systems [12, 19], l-exclusion <ref> [11, 2] </ref>, and atomic snapshot scan [1, 5]. Our quorum constructions can also be directly exploited in algorithms that employ "uniform" quorums for fault tolerance (by involving a threshold of processes), in order to improve efficiency or tolerate nonuniform failure scenarios.
Reference: [12] <author> D. Dolev and N. Shavit. </author> <title> Bounded concurrent time-stamp systems are constructible. </title> <journal> SIAM Journal of Computing, </journal> <volume> to appear. </volume> <booktitle> Also in Proceedings of the 21st ACM Symposium on the Theory of Computing, </booktitle> <pages> pages 454-466, </pages> <year> 1989. </year>
Reference-contexts: These semantics imply a safe variable [24] in the case of a single reader and single writer, which a set of correct clients can use to build other abstractions, e.g., atomic, multi-writer multi-reader registers [24, 21, 25], concurrent timestamp systems <ref> [12, 19] </ref>, l-exclusion [11, 2], and atomic snapshot scan [1, 5]. Our quorum constructions can also be directly exploited in algorithms that employ "uniform" quorums for fault tolerance (by involving a threshold of processes), in order to improve efficiency or tolerate nonuniform failure scenarios.
Reference: [13] <author> A. El Abbadi and S. Toueg. </author> <title> Maintaining availability in partitioned replicated databases. </title> <journal> ACM Transactions on Database Systems 14(2) </journal> <pages> 264-290, </pages> <month> June </month> <year> 1989. </year>
Reference-contexts: We conclude in Section 7. 2 Related work Our work was influenced by the substantial body of literature on quorum systems for benign failures and applications that make use of them, e.g., <ref> [15, 38, 26, 14, 17, 13, 9, 4, 30] </ref>. In particular, our grid construction of Section 4 was influenced by grid-like constructions for benign failures (e.g., [9]), and we borrow our definition of load from [30]. Quorum systems have been previously employed in the implementation of security mechanisms.
Reference: [14] <author> H. Garcia-Molina and D. Barbara. </author> <title> How to assign votes in a distributed system. </title> <journal> Journal of the ACM 32(4) </journal> <pages> 841-860, </pages> <month> October </month> <year> 1985. </year>
Reference-contexts: We conclude in Section 7. 2 Related work Our work was influenced by the substantial body of literature on quorum systems for benign failures and applications that make use of them, e.g., <ref> [15, 38, 26, 14, 17, 13, 9, 4, 30] </ref>. In particular, our grid construction of Section 4 was influenced by grid-like constructions for benign failures (e.g., [9]), and we borrow our definition of load from [30]. Quorum systems have been previously employed in the implementation of security mechanisms.
Reference: [15] <author> D. K. Gifford. </author> <title> Weighted voting for replicated data. </title> <booktitle> In Proceedings of the 7th ACM Symposium on Operating Systems Principles, </booktitle> <pages> pages 150-162, </pages> <year> 1979. </year>
Reference-contexts: We conclude in Section 7. 2 Related work Our work was influenced by the substantial body of literature on quorum systems for benign failures and applications that make use of them, e.g., <ref> [15, 38, 26, 14, 17, 13, 9, 4, 30] </ref>. In particular, our grid construction of Section 4 was influenced by grid-like constructions for benign failures (e.g., [9]), and we borrow our definition of load from [30]. Quorum systems have been previously employed in the implementation of security mechanisms.
Reference: [16] <author> M. Hall, Jr. </author> <title> Combinatorial Theory. </title> <booktitle> 2nd Ed. Wiley-Interscience Series in Discrete Mathematics, </booktitle> <year> 1986. </year>
Reference-contexts: Consider the nfin Hadamard matrix H (`), constructed recursively as follows: H (1) = 1 1 H (k 1) H (k 1) H (`) has the property that H (`)H (`) T = nI, where I is the n fi n identity matrix. Using well-known inductive arguments <ref> [16, Ch. 14] </ref>, it can be shown that (i) the first row and column consist entirely of 1's, (ii) the i-th row and i-th column, for each i 2, has 1's in n 2 positions (and similarly for 1's), and (iii) any two rows (and any two columns) i; j 2
Reference: [17] <author> M. Herlihy. </author> <title> A quorum-consensus replication method for abstract data types. </title> <journal> ACM Transactions on Computer Systems 4(1) </journal> <pages> 32-53, </pages> <month> February </month> <year> 1986. </year>
Reference-contexts: We conclude in Section 7. 2 Related work Our work was influenced by the substantial body of literature on quorum systems for benign failures and applications that make use of them, e.g., <ref> [15, 38, 26, 14, 17, 13, 9, 4, 30] </ref>. In particular, our grid construction of Section 4 was influenced by grid-like constructions for benign failures (e.g., [9]), and we borrow our definition of load from [30]. Quorum systems have been previously employed in the implementation of security mechanisms.
Reference: [18] <author> M. P. Herlihy and J. D. Tygar. </author> <title> How to make replicated data secure. </title> <booktitle> In Advances in Cryptology|CRYPTO '87 Proceedings (Lecture Notes in Computer Science 293), </booktitle> <pages> pages 379-391, </pages> <publisher> Springer-Verlag, </publisher> <year> 1988. </year>
Reference-contexts: Examples include algorithms for shared memory emulation [6], randomized Byzantine agreement [39], reliable Byzantine multicast [8, 33, 27], and secure replicated data <ref> [18] </ref>. The rest of this paper is structured as follows. We begin in Section 2 with a description of related work. In Section 3 we present our system model and definitions. <p> Our work differs from all of the above by considering arbitrarily faulty servers, and accommodating failure scenarios beyond a simple threshold of servers. Herlihy and Tygar <ref> [18] </ref> applied quorums with increased intersection to the problem of protecting the confidentiality and integrity of replicated data against a threshold of arbitrarily faulty servers.
Reference: [19] <author> A. Israeli and M. Li. </author> <title> Bounded time-stamps. </title> <booktitle> Distributed Computing 6(4) </booktitle> <pages> 205-209. </pages>
Reference-contexts: These semantics imply a safe variable [24] in the case of a single reader and single writer, which a set of correct clients can use to build other abstractions, e.g., atomic, multi-writer multi-reader registers [24, 21, 25], concurrent timestamp systems <ref> [12, 19] </ref>, l-exclusion [11, 2], and atomic snapshot scan [1, 5]. Our quorum constructions can also be directly exploited in algorithms that employ "uniform" quorums for fault tolerance (by involving a threshold of processes), in order to improve efficiency or tolerate nonuniform failure scenarios.
Reference: [20] <author> A. Kumar. </author> <title> Hierarchical quorum consensus: A new algorithm for managing replicated data. </title> <journal> IEEE Transactions on Computers 40(9) </journal> <pages> 996-1004, </pages> <year> 1991. </year>
Reference: [21] <author> A. Israeli and A. Shaham. </author> <title> Optimal multi-write multi-reader atomic register. </title> <booktitle> In Proceedings of the 11th ACM Symposium on Principles of Distributed Computing, </booktitle> <pages> pages 71-82, </pages> <year> 1992. </year>
Reference-contexts: These semantics imply a safe variable [24] in the case of a single reader and single writer, which a set of correct clients can use to build other abstractions, e.g., atomic, multi-writer multi-reader registers <ref> [24, 21, 25] </ref>, concurrent timestamp systems [12, 19], l-exclusion [11, 2], and atomic snapshot scan [1, 5]. Our quorum constructions can also be directly exploited in algorithms that employ "uniform" quorums for fault tolerance (by involving a threshold of processes), in order to improve efficiency or tolerate nonuniform failure scenarios. <p> From these, multi-writer multi-reader atomic variables can be built using well-known constructions <ref> [24, 21, 25] </ref>. A necessary and sufficient condition for the existence of a masking quorum system (and a construction for one, if it exists) for any given fail-prone system B is given in the following theorem: Theorem 4.3 Let B be a fail-prone system for a universe U .
Reference: [22] <author> L. Lamport, R. Shostak and M. Pease. </author> <title> The Byzantine generals problem. </title> <journal> ACM Transactions on Programming Languages and Systems 4(3) </journal> <pages> 382-401, </pages> <month> July </month> <year> 1982. </year>
Reference-contexts: This update protocol could be implemented using well-known agreement protocols (e.g., <ref> [22, 8] </ref>), but only if the given fail-prone system B has the property that each B 2 B is of size less than jU j=3, and only by involving all of the servers in the system.
Reference: [23] <author> B. Lampson, M. Abadi, M. Burrows, and E. Wobber. </author> <title> Authentication in distributed systems: </title> <journal> Theory and practice. ACM Transactions on Computer Systems 10(4) </journal> <pages> 265-310, </pages> <month> November </month> <year> 1992. </year>
Reference-contexts: A natural example is a database of public key certificates as found in many public key distribution systems (e.g., <ref> [10, 37, 23] </ref>). A public key certificate is a structure containing a name for a user and a public key, and represents the assertion that the indicated public key can be used to authenticate messages from the indicated user.
Reference: [24] <author> L. Lamport. </author> <title> On interprocess communication (part II: algorithms). </title> <booktitle> Distributed Computing 1 </booktitle> <pages> 86-101, </pages> <year> 1986. </year>
Reference-contexts: In this paper, however, we choose to demonstrate a variable supporting read and write operations with relatively weak semantics, in order to maintain focus on our quorum constructions. These semantics imply a safe variable <ref> [24] </ref> in the case of a single reader and single writer, which a set of correct clients can use to build other abstractions, e.g., atomic, multi-writer multi-reader registers [24, 21, 25], concurrent timestamp systems [12, 19], l-exclusion [11, 2], and atomic snapshot scan [1, 5]. <p> These semantics imply a safe variable [24] in the case of a single reader and single writer, which a set of correct clients can use to build other abstractions, e.g., atomic, multi-writer multi-reader registers <ref> [24, 21, 25] </ref>, concurrent timestamp systems [12, 19], l-exclusion [11, 2], and atomic snapshot scan [1, 5]. Our quorum constructions can also be directly exploited in algorithms that employ "uniform" quorums for fault tolerance (by involving a threshold of processes), in order to improve efficiency or tolerate nonuniform failure scenarios. <p> In Sections 4 and 5, we will argue the correctness of the above protocol|instantiated with quorums and a Result () function that we will define|according to the following semantics; a more formal treatment of these concepts can be found in <ref> [24] </ref>. <p> Then, for the above protocol to be correct, we require that any read that is concurrent with no writes returns the last value written in some serialization of the preceding writes. In the case of a single-reader, single-writer variable, this will immediately imply safe semantics <ref> [24] </ref>. 3.3 Load A measure of the inherent performance of a quorum system is its load. Naor and Wool [30] define the load of a quorum system as the probability of accessing the busiest server in the best case. <p> This is immediate, however, as if it did precede another write operation in W , that write operation would have a higher timestamp. 2 This lemma implies that the protocol above implements a single-writer single-reader safe variable <ref> [24] </ref>. From these, multi-writer multi-reader atomic variables can be built using well-known constructions [24, 21, 25]. <p> From these, multi-writer multi-reader atomic variables can be built using well-known constructions <ref> [24, 21, 25] </ref>. A necessary and sufficient condition for the existence of a masking quorum system (and a construction for one, if it exists) for any given fail-prone system B is given in the following theorem: Theorem 4.3 Let B be a fail-prone system for a universe U . <p> The above lemmata imply that the protocol above implements a single-writer single-reader regular variable <ref> [24] </ref>. Theorems analogous to the ones given for masking quorum systems above are easily derived for dissemination quorums. Below, we list these results without proof. Theorem 5.4 Let B be a fail-prone system for a universe U .
Reference: [25] <author> M. Li, J. Tromp and P. M. B. Vitanyi. </author> <title> How to share concurrent wait-free variables. </title> <journal> Journal of the ACM, </journal> <note> to appear. </note>
Reference-contexts: These semantics imply a safe variable [24] in the case of a single reader and single writer, which a set of correct clients can use to build other abstractions, e.g., atomic, multi-writer multi-reader registers <ref> [24, 21, 25] </ref>, concurrent timestamp systems [12, 19], l-exclusion [11, 2], and atomic snapshot scan [1, 5]. Our quorum constructions can also be directly exploited in algorithms that employ "uniform" quorums for fault tolerance (by involving a threshold of processes), in order to improve efficiency or tolerate nonuniform failure scenarios. <p> From these, multi-writer multi-reader atomic variables can be built using well-known constructions <ref> [24, 21, 25] </ref>. A necessary and sufficient condition for the existence of a masking quorum system (and a construction for one, if it exists) for any given fail-prone system B is given in the following theorem: Theorem 4.3 Let B be a fail-prone system for a universe U .
Reference: [26] <author> M. Maekawa. </author> <title> A p n algorithm for mutual exclusion in decentralized systems. </title> <journal> ACM Transactions on Computer Systems 3(2) </journal> <pages> 145-159, </pages> <year> 1985. </year>
Reference-contexts: We conclude in Section 7. 2 Related work Our work was influenced by the substantial body of literature on quorum systems for benign failures and applications that make use of them, e.g., <ref> [15, 38, 26, 14, 17, 13, 9, 4, 30] </ref>. In particular, our grid construction of Section 4 was influenced by grid-like constructions for benign failures (e.g., [9]), and we borrow our definition of load from [30]. Quorum systems have been previously employed in the implementation of security mechanisms.
Reference: [27] <author> D. Malkhi and M. Reiter. </author> <title> A high-throughput secure reliable multicast protocol. Journal of Computer Security, to appear. </title> <booktitle> Also in Proceedings of the 9th IEEE Computer Security Foundations Workshop, </booktitle> <pages> pages 9-17, </pages> <month> June </month> <year> 1996. </year>
Reference-contexts: Our motivation for exploring this generalization stems from our experience in constructing secure distributed services <ref> [34, 27] </ref>, i.e., distributed services that can tolerate the malicious corruption of some (typically, up to a threshold number of) component servers by an attacker. A criticism to assuming a simple threshold of corrupted servers is that server penetrations may not be independent. <p> Our quorum constructions can also be directly exploited in algorithms that employ "uniform" quorums for fault tolerance (by involving a threshold of processes), in order to improve efficiency or tolerate nonuniform failure scenarios. Examples include algorithms for shared memory emulation [6], randomized Byzantine agreement [39], reliable Byzantine multicast <ref> [8, 33, 27] </ref>, and secure replicated data [18]. The rest of this paper is structured as follows. We begin in Section 2 with a description of related work. In Section 3 we present our system model and definitions.
Reference: [28] <author> D. Malkhi, M. Reiter and A. Wool. </author> <title> Optimal Byzantine quorum systems. </title> <note> Submitted for publication, </note> <month> January </month> <year> 1997. </year>
Reference-contexts: In general, however, this construction yields a load of O ( f p n ), which is not optimal: Malkhi et al. <ref> [28] </ref> show a lower bound of q n on the load of any masking quorum sys tem for B = fB U : jBj = f g, and provide a construction whose load matches that bound. k shaded).
Reference: [29] <author> R. Mukkamala. </author> <title> Storage efficient and secure replicated distributed databases. </title> <journal> IEEE Transactions on Knowledge and Data Engineering 6(2) </journal> <pages> 337-341, </pages> <month> April </month> <year> 1994. </year>
Reference-contexts: Naor and Wool [31] described methods to construct an access-control service using quorums. Their constructions use cryptographic techniques to ensure that out-of-date (but correct) servers cannot grant access to unauthorized users. Agrawal and El Abbadi [3] and Mukkamala <ref> [29] </ref> considered the confidentiality of replicated data despite the disclosure of the contents of a threshold of the (otherwise correct) repositories.
Reference: [30] <author> M. Naor and A. Wool. </author> <title> The load, capacity, and availability of quorum systems. </title> <booktitle> In Proceedings of the 35th IEEE Symposium on Foundations of Computer Science, </booktitle> <pages> pages 214-225, </pages> <year> 1994. </year>
Reference-contexts: We conclude in Section 7. 2 Related work Our work was influenced by the substantial body of literature on quorum systems for benign failures and applications that make use of them, e.g., <ref> [15, 38, 26, 14, 17, 13, 9, 4, 30] </ref>. In particular, our grid construction of Section 4 was influenced by grid-like constructions for benign failures (e.g., [9]), and we borrow our definition of load from [30]. Quorum systems have been previously employed in the implementation of security mechanisms. <p> In particular, our grid construction of Section 4 was influenced by grid-like constructions for benign failures (e.g., [9]), and we borrow our definition of load from <ref> [30] </ref>. Quorum systems have been previously employed in the implementation of security mechanisms. Naor and Wool [31] described methods to construct an access-control service using quorums. Their constructions use cryptographic techniques to ensure that out-of-date (but correct) servers cannot grant access to unauthorized users. <p> In the case of a single-reader, single-writer variable, this will immediately imply safe semantics [24]. 3.3 Load A measure of the inherent performance of a quorum system is its load. Naor and Wool <ref> [30] </ref> define the load of a quorum system as the probability of accessing the busiest server in the best case. <p> A strength of this definition is that load is a property of a quorum system, and not of the protocol using it. A comparison of the definition of load to other seemingly plausible definitions is given in <ref> [30] </ref>. 4 Masking quorum systems In this section we introduce masking quorum systems, which can be used to mask the arbitrarily faulty behavior of data repositories. <p> construction, Q is a masking quorum iff M1 holds for Q, i.e., iff for all B 1 ; B 2 ; B 3 ; B 4 2 B: () U n (B 1 [ B 2 ) 6 B 3 [ B 4 2 The following theorem was proved in <ref> [30] </ref> for benign failure quorum systems, and holds for masking quorums as well (as a result of M1). Let c (Q) denote the size of the smallest quorum of Q. <p> Let c (Q) denote the size of the smallest quorum of Q. Theorem 4.5 If Q is a quorum system over a universe of n elements, then L (Q) maxf 1 c (Q) c (Q) The proof of this theorem in <ref> [30] </ref> employs rather complex methods. Here we present a simpler proof of their theorem. Proof. Let w be any strategy for the quorum system Q, and fix Q 1 2 Q such that jQ 1 j = c (Q).
Reference: [31] <author> M. Naor and A. Wool. </author> <title> Access control and signatures via quorum secret sharing. </title> <booktitle> In Proceedings of the 3rd ACM Conference on Computer and Communications Security, </booktitle> <pages> pages 157-168, </pages> <month> March </month> <year> 1996. </year>
Reference-contexts: In particular, our grid construction of Section 4 was influenced by grid-like constructions for benign failures (e.g., [9]), and we borrow our definition of load from [30]. Quorum systems have been previously employed in the implementation of security mechanisms. Naor and Wool <ref> [31] </ref> described methods to construct an access-control service using quorums. Their constructions use cryptographic techniques to ensure that out-of-date (but correct) servers cannot grant access to unauthorized users.
Reference: [32] <author> M. O. Rabin. </author> <title> Efficient dispersal of information for security, load balancing, and fault tolerance. </title> <journal> Journal of the ACM 36(2) </journal> <pages> 335-348, </pages> <year> 1989. </year>
Reference-contexts: Agrawal and El Abbadi [3] and Mukkamala [29] considered the confidentiality of replicated data despite the disclosure of the contents of a threshold of the (otherwise correct) repositories. Their constructions used quorums with increased intersection, combined with Rabin's dispersal scheme <ref> [32] </ref>, to enhance the confidentiality and availability of the data despite some servers crashing or their contents being observed. Our work differs from all of the above by considering arbitrarily faulty servers, and accommodating failure scenarios beyond a simple threshold of servers.
Reference: [33] <author> M. K. Reiter. </author> <title> Secure agreement protocols: Reliable and atomic group multicast in Rampart. </title> <booktitle> In Proceedings of the 2nd ACM Conference on Computer and Communications Security, </booktitle> <pages> pages 68-80, </pages> <month> November </month> <year> 1994. </year>
Reference-contexts: Our quorum constructions can also be directly exploited in algorithms that employ "uniform" quorums for fault tolerance (by involving a threshold of processes), in order to improve efficiency or tolerate nonuniform failure scenarios. Examples include algorithms for shared memory emulation [6], randomized Byzantine agreement [39], reliable Byzantine multicast <ref> [8, 33, 27] </ref>, and secure replicated data [18]. The rest of this paper is structured as follows. We begin in Section 2 with a description of related work. In Section 3 we present our system model and definitions.
Reference: [34] <author> M. K. Reiter. </author> <title> Distributing trust with the Rampart toolkit. </title> <journal> Communications of the ACM 39(4) </journal> <pages> 71-74, </pages> <month> April </month> <year> 1996. </year>
Reference-contexts: Our motivation for exploring this generalization stems from our experience in constructing secure distributed services <ref> [34, 27] </ref>, i.e., distributed services that can tolerate the malicious corruption of some (typically, up to a threshold number of) component servers by an attacker. A criticism to assuming a simple threshold of corrupted servers is that server penetrations may not be independent.
Reference: [35] <author> R. Rivest, A. Shamir, and L. Adleman. </author> <title> A method for obtaining digital signatures and public-key cryptosystems. </title> <journal> Communications of the ACM 21(2) </journal> <pages> 120-126, </pages> <month> February </month> <year> 1978. </year>
Reference-contexts: A public key certificate is a structure containing a name for a user and a public key, and represents the assertion that the indicated public key can be used to authenticate messages from the indicated user. This structure is digitally signed (e.g., <ref> [35] </ref>) by a certification authority so that anyone with the public key of this authority can verify this assertion and, providing it trusts the authority, use the indicated public key to authenticate the indicated user.
Reference: [36] <author> A. Shamir. </author> <title> How to share a secret. </title> <journal> Communications of the ACM 22(11) </journal> <pages> 612-613, </pages> <month> November </month> <year> 1979. </year>
Reference-contexts: In their constructions, replicated data is stored encrypted under a key that is shared among the servers using a threshold secret-sharing scheme <ref> [36] </ref>, and each client accesses a threshold number of servers to reconstruct the key prior to performing (encrypted) reads and writes.
Reference: [37] <author> J. J. Tardo and K. Alagappan. SPX: </author> <title> Global authentication using public key certificates. </title> <booktitle> In Proceedings of the 1991 IEEE Symposium on Research in Security and Privacy, </booktitle> <pages> pages 232-244, </pages> <month> May </month> <year> 1991. </year>
Reference-contexts: A natural example is a database of public key certificates as found in many public key distribution systems (e.g., <ref> [10, 37, 23] </ref>). A public key certificate is a structure containing a name for a user and a public key, and represents the assertion that the indicated public key can be used to authenticate messages from the indicated user.
Reference: [38] <author> R. H. Thomas. </author> <title> A majority consensus approach to concur-rency control for multiple copy databases. </title> <journal> ACM Transactions on Database Systems 4(2) </journal> <pages> 180-209, </pages> <year> 1979. </year>
Reference-contexts: We conclude in Section 7. 2 Related work Our work was influenced by the substantial body of literature on quorum systems for benign failures and applications that make use of them, e.g., <ref> [15, 38, 26, 14, 17, 13, 9, 4, 30] </ref>. In particular, our grid construction of Section 4 was influenced by grid-like constructions for benign failures (e.g., [9]), and we borrow our definition of load from [30]. Quorum systems have been previously employed in the implementation of security mechanisms.
Reference: [39] <author> S. Toueg. </author> <title> Randomized Byzantine agreement. </title> <booktitle> In Proceedings of the 3rd ACM Symposium on Principles of Distributed Computing, </booktitle> <pages> pages 163-178, </pages> <month> August </month> <year> 1984. </year>
Reference-contexts: Our quorum constructions can also be directly exploited in algorithms that employ "uniform" quorums for fault tolerance (by involving a threshold of processes), in order to improve efficiency or tolerate nonuniform failure scenarios. Examples include algorithms for shared memory emulation [6], randomized Byzantine agreement <ref> [39] </ref>, reliable Byzantine multicast [8, 33, 27], and secure replicated data [18]. The rest of this paper is structured as follows. We begin in Section 2 with a description of related work. In Section 3 we present our system model and definitions.
References-found: 39

