URL: file://ftp.di.unipi.it/pub/Papers/meo/IntNeg93tr.ps.gz
Refering-URL: http://www.di.unipi.it/di/groups/lp/papers.html
Root-URL: 
Email: e-mail: paola@csr.unibo.it flevifran, levi, meog@di.unipi.it  
Title: Intensional Negation in Constraint Logic Programs  
Author: Paola Bruscoli, Francesca Levi, Giorgio Levi, Maria Chiara Meo 
Address: C.so Italia, 40 56125 Pisa, Italy  
Affiliation: Dipartimento di Informatica, Universita di Pisa,  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> K. R. Apt. </author> <title> Introduction to Logic Programming. </title> <editor> In J. van Leeuwen, editor, </editor> <booktitle> Handbook of Theoretical Computer Science, volume B: Formal Models and Semantics, </booktitle> <pages> pages 495-574. </pages> <publisher> Elsevier, Amsterdam and The MIT Press, </publisher> <address> Cambridge, </address> <year> 1990. </year> <month> 25 </month>
Reference-contexts: The reference fixpoint semantics is usually based on Fitting's operator [12]. Unfortunately, the nice equivalence and completeness results proved for the semantics of positive logic programs <ref> [29, 2, 22, 1] </ref> are not valid in the case of normal programs. In particular, we need to impose strong conditions on programs and goals, in order to deal with various incompleteness problems (e.g. floundering, inconsistency of the completion, the combination of tertium non datur and non-termination).
Reference: [2] <author> K. R. Apt and M.H. van Emden. </author> <title> Contributions to the theory of logic programming. </title> <journal> Journal of the ACM, </journal> <volume> 29(3) </volume> <pages> 841-862, </pages> <year> 1982. </year>
Reference-contexts: The reference fixpoint semantics is usually based on Fitting's operator [12]. Unfortunately, the nice equivalence and completeness results proved for the semantics of positive logic programs <ref> [29, 2, 22, 1] </ref> are not valid in the case of normal programs. In particular, we need to impose strong conditions on programs and goals, in order to deal with various incompleteness problems (e.g. floundering, inconsistency of the completion, the combination of tertium non datur and non-termination).
Reference: [3] <author> R. Barbuti, P. Mancarella, D. Pedreschi, and F. Turini. </author> <title> Intensional Negation of Logic Programs: Examples and Implementation Techniques. </title> <editor> In H. Ehrig, R. Kowal-ski, G. Levi, and U. Montanari, editors, </editor> <booktitle> TAPSOFT '87, volume 250 of Lecture Notes in Computer Science, </booktitle> <pages> pages 96-110. </pages> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1987. </year>
Reference-contexts: The problem of handling "non-ground" literals was tackled by various extensions of Negation As Failure, called constructive negation. Examples are intensional negation <ref> [3, 4] </ref>, Chan's constructive negation [6, 7], the fail substitutions [23] and the fail answers [10, 9] techniques. The idea of intensional negation, originally formalized for positive logic programs [3, 4], is the following. <p> Examples are intensional negation <ref> [3, 4] </ref>, Chan's constructive negation [6, 7], the fail substitutions [23] and the fail answers [10, 9] techniques. The idea of intensional negation, originally formalized for positive logic programs [3, 4], is the following. Given a normal program P , we derive a new program P 0 , which contains clauses which allow us to compute the answers to negative queries. Example 1.2 Let P be the program even (0) even (s (s (X))) even (X). <p> For each predicate symbol q not defined in P , q : is defined in P by the unique clause q : ( X) . Note that we do not use the DCA as in <ref> [3, 4] </ref>. 10 Example 5.1 Let P be the normal program of example 4.1.
Reference: [4] <author> R. Barbuti, P.Mancarella, D. Pedreschi, and F. Turini. </author> <title> A transformational approach to negation in logic programming. </title> <journal> Journal of Logic Programming, </journal> <volume> 8 </volume> <pages> 201-228, </pages> <year> 1990. </year>
Reference-contexts: The problem of handling "non-ground" literals was tackled by various extensions of Negation As Failure, called constructive negation. Examples are intensional negation <ref> [3, 4] </ref>, Chan's constructive negation [6, 7], the fail substitutions [23] and the fail answers [10, 9] techniques. The idea of intensional negation, originally formalized for positive logic programs [3, 4], is the following. <p> Examples are intensional negation <ref> [3, 4] </ref>, Chan's constructive negation [6, 7], the fail substitutions [23] and the fail answers [10, 9] techniques. The idea of intensional negation, originally formalized for positive logic programs [3, 4], is the following. Given a normal program P , we derive a new program P 0 , which contains clauses which allow us to compute the answers to negative queries. Example 1.2 Let P be the program even (0) even (s (s (X))) even (X). <p> For each predicate symbol q not defined in P , q : is defined in P by the unique clause q : ( X) . Note that we do not use the DCA as in <ref> [3, 4] </ref>. 10 Example 5.1 Let P be the normal program of example 4.1.
Reference: [5] <author> A. Bottoni and G. Levi. </author> <title> The inverse of Fitting's functional. </title> <booktitle> In Proc. of the 3rd Kurt Goedel Colloquium on Computational Logic and Proof Theory, Lecture Notes in Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1993. </year> <note> To appear. </note>
Reference-contexts: We are also investigating the relation with the answers obtained by computing in the completion <ref> [5] </ref>, i.e. by explicitely using the formulas of the completion as rewrite rules. We can easily realize that, if we choose the frontier at depth one, also constructive negation is simply an implementation of computing with the completion.
Reference: [6] <author> D. Chan. </author> <title> Constructive Negation Based on the Completed Database. </title> <editor> In R. A. Kowalski and K. A. Bowen, editors, </editor> <booktitle> Proc. Fifth Int'l Conf. on Logic Programming, </booktitle> <pages> pages 111-125. </pages> <publisher> The MIT Press, </publisher> <address> Cambridge, Mass., </address> <year> 1988. </year>
Reference-contexts: The problem of handling "non-ground" literals was tackled by various extensions of Negation As Failure, called constructive negation. Examples are intensional negation [3, 4], Chan's constructive negation <ref> [6, 7] </ref>, the fail substitutions [23] and the fail answers [10, 9] techniques. The idea of intensional negation, originally formalized for positive logic programs [3, 4], is the following. <p> The range of applicability of intensional negation was increased by defining an extended derivation rule for positive logic programs with universal quantification parametric w.r.t. the DCA [20, 21]. Chan's constructive negation, which is a refinement of previous proposals [17, 30] in its original formulation <ref> [6] </ref> can be described as follows. Definition 1.3 Let :A be a (possibly non-ground) literal in the normal program P . <p> Such an interpretive technique, which is to explicitly compute answer substitutions to negative goals, was originally proposed in the framework of logic programming. Among the various proposals, the ones by Chan <ref> [6, 7] </ref>, set in the context of infinitary Herbrand universe, have inspired the generalization to the CLP schema, due to Stuckey [27, 28]. Informally, constructive negation can be described as follows.
Reference: [7] <author> D. Chan. </author> <title> An Extension of Constructive Negation and its Application in Coroutin-ing. </title> <editor> In E. Lusk and R. Overbeek, editors, </editor> <booktitle> Proc. North American Conf. on Logic Programming'89, </booktitle> <pages> pages 477-493. </pages> <publisher> The MIT Press, </publisher> <address> Cambridge, Mass., </address> <year> 1989. </year>
Reference-contexts: The problem of handling "non-ground" literals was tackled by various extensions of Negation As Failure, called constructive negation. Examples are intensional negation [3, 4], Chan's constructive negation <ref> [6, 7] </ref>, the fail substitutions [23] and the fail answers [10, 9] techniques. The idea of intensional negation, originally formalized for positive logic programs [3, 4], is the following. <p> The application of the above inference rule is undefined when the SLDtree is infinite. The mechanism of negative literals evaluation, inherited from Negation As Failure, is not "incremental", since it requires the construction of a full SLD-tree. This problem was solved in <ref> [7] </ref>, by considering a finite part of the SLD-tree, defined by a frontier, instead of the complete SLDtree. Using the Constraint Logic Programming (CLP) notation [16, 15], each node of the frontier is a goal e i 2B i containing both constraints (equalities) and literals. <p> Such an interpretive technique, which is to explicitly compute answer substitutions to negative goals, was originally proposed in the framework of logic programming. Among the various proposals, the ones by Chan <ref> [6, 7] </ref>, set in the context of infinitary Herbrand universe, have inspired the generalization to the CLP schema, due to Stuckey [27, 28]. Informally, constructive negation can be described as follows.
Reference: [8] <author> K. L. Clark. </author> <title> Negation as Failure. </title> <editor> In H. Gallaire and J. Minker, editors, </editor> <booktitle> Logic and Data Bases, </booktitle> <pages> pages 293-322. </pages> <publisher> Plenum Press, </publisher> <address> New York, </address> <year> 1978. </year>
Reference-contexts: 1 Introduction The most popular semantics for normal logic programs is based on SLDNF-resolution (SLD-resolution with Negation As Failure) as operational semantics and on the program completion as declarative semantics <ref> [8, 22] </ref>. The reference fixpoint semantics is usually based on Fitting's operator [12]. Unfortunately, the nice equivalence and completeness results proved for the semantics of positive logic programs [29, 2, 22, 1] are not valid in the case of normal programs. <p> In the following we consider a one-sorted signature and we do not make any other assumption on . Rather we require that the structure &lt;( C ; ) is a model of the standard theory CET , given in <ref> [8] </ref> to axiomatize unification. Moreover if the set of function symbols is finite we assume the (weak) domain closure axiom (DCA) be added to CET , thus achieving the completeness of the theory CET in the case of a 4 language with finite set of function symbols.
Reference: [9] <author> W. Drabent. </author> <title> SLS-resolution without floundering. </title> <booktitle> In Proc. of the Workshop on Logic Programming and Non-monotonic reasoning, </booktitle> <year> 1993. </year> <note> To appear. </note>
Reference-contexts: The problem of handling "non-ground" literals was tackled by various extensions of Negation As Failure, called constructive negation. Examples are intensional negation [3, 4], Chan's constructive negation [6, 7], the fail substitutions [23] and the fail answers <ref> [10, 9] </ref> techniques. The idea of intensional negation, originally formalized for positive logic programs [3, 4], is the following. Given a normal program P , we derive a new program P 0 , which contains clauses which allow us to compute the answers to negative queries. <p> The optimization is concerned with the management of disjunctions, which are handled by using essentially the SLDtree structure of positive Horn clauses. The resulting theory allows us to identify commonalities and differences between the various constructive negation techniques. It is worth noting that there exists one example <ref> [10, 9] </ref> of constructive negation technique, which is not based on the program completion and is not therefore easily comparable to our technique. Another problem is related to the formal semantics.
Reference: [10] <author> W. Drabent. </author> <title> What is Failure? An Approach to Constructive Negation. </title> <journal> Acta Informatica, </journal> <note> 1993. To appear. </note>
Reference-contexts: The problem of handling "non-ground" literals was tackled by various extensions of Negation As Failure, called constructive negation. Examples are intensional negation [3, 4], Chan's constructive negation [6, 7], the fail substitutions [23] and the fail answers <ref> [10, 9] </ref> techniques. The idea of intensional negation, originally formalized for positive logic programs [3, 4], is the following. Given a normal program P , we derive a new program P 0 , which contains clauses which allow us to compute the answers to negative queries. <p> The optimization is concerned with the management of disjunctions, which are handled by using essentially the SLDtree structure of positive Horn clauses. The resulting theory allows us to identify commonalities and differences between the various constructive negation techniques. It is worth noting that there exists one example <ref> [10, 9] </ref> of constructive negation technique, which is not based on the program completion and is not therefore easily comparable to our technique. Another problem is related to the formal semantics.
Reference: [11] <author> M. Falaschi, G. Levi, M. Martelli, and C. Palamidessi. </author> <title> A Model-Theoretic Reconstruction of the Operational Semantics of Logic Programs. </title> <journal> Information and Computation, </journal> <volume> 102, </volume> <year> 1993. </year>
Reference-contexts: In order to show this relation, we introduce a new preordering on sets in -(B : ), and we generalize it to -interpretations. 19 Definition 5.35 <ref> [11] </ref> Let I 1 , I 2 2 -(B : ). We define I 1 I 2 iff 8A 1 2 I 1 9A 2 2 I 2 such that A 1 v A 2 . Proposition 5.36 [11] The relation is a preorder on -(B : ). <p> -(B : ), and we generalize it to -interpretations. 19 Definition 5.35 <ref> [11] </ref> Let I 1 , I 2 2 -(B : ). We define I 1 I 2 iff 8A 1 2 I 1 9A 2 2 I 2 such that A 1 v A 2 . Proposition 5.36 [11] The relation is a preorder on -(B : ). The preorder is extended to the set of partial -interpretations, thus giving the new preorder 3 . Definition 5.37 Let I p ; J p 2 I.
Reference: [12] <author> M. </author> <title> Fitting. A Kripke-Kleene semantics for logic programs. </title> <journal> Journal of Logic Programming, </journal> <volume> 2 </volume> <pages> 295-312, </pages> <year> 1985. </year>
Reference-contexts: 1 Introduction The most popular semantics for normal logic programs is based on SLDNF-resolution (SLD-resolution with Negation As Failure) as operational semantics and on the program completion as declarative semantics [8, 22]. The reference fixpoint semantics is usually based on Fitting's operator <ref> [12] </ref>. Unfortunately, the nice equivalence and completeness results proved for the semantics of positive logic programs [29, 2, 22, 1] are not valid in the case of normal programs. <p> The 3-valued completion is also strongly related to the Fitting's operator P <ref> [12] </ref>, which acts upon 3-valued interpretations. The minimal 3-valued model M P of P fl is its least fixpoint P " ff. <p> Now we prove that [O 8 (P )] = [F 8 (P )] = P " !, where P is Fitting's operator described in <ref> [12] </ref> and extended to constraint logic programs in [13]. The proof is based on the analysis of the relation between [F 8 (P )] and P . In such a way a completeness and correctness result is inherited by intensional negation.
Reference: [13] <author> M. Fitting and M. Ben-Jacob. </author> <title> Stratified and Three-valued Logic Programming Semantics. </title> <editor> In R. A. Kowalski and K. A. Bowen, editors, </editor> <booktitle> Proc. Fifth Int'l Conf. on Logic Programming, </booktitle> <pages> pages 1054-1069. </pages> <publisher> The MIT Press, </publisher> <address> Cambridge, Mass., </address> <year> 1988. </year>
Reference-contexts: Now we prove that [O 8 (P )] = [F 8 (P )] = P " !, where P is Fitting's operator described in [12] and extended to constraint logic programs in <ref> [13] </ref>. The proof is based on the analysis of the relation between [F 8 (P )] and P . In such a way a completeness and correctness result is inherited by intensional negation. Proposition 6.1 Let P be a normal program and I p be a finite -interpretation.
Reference: [14] <author> M. Gabbrielli and G. Levi. </author> <title> Modeling Answer Constraints in Constraint Logic Programs. </title> <editor> In K. Furukawa, editor, </editor> <booktitle> Proc. Eighth Int'l Conf. on Logic Programming, pages 238- 252. </booktitle> <publisher> The MIT Press, </publisher> <address> Cambridge, Mass., </address> <year> 1991. </year>
Reference-contexts: The case of many-sorted signature is a straightforward generalization. 3 Partial -interpretations and -models We extend the notion of -interpretation as introduced in <ref> [14] </ref> in order to provide three-valued models of the completion of a CLP program.
Reference: [15] <author> J. Jaffar and J.-L. Lassez. </author> <title> Constraint Logic Programming. </title> <booktitle> In Proc. Fourteenth Annual ACM Symp. on Principles of Programming Languages, </booktitle> <pages> pages 111-119. </pages> <publisher> ACM, </publisher> <year> 1987. </year>
Reference-contexts: This problem was solved in [7], by considering a finite part of the SLD-tree, defined by a frontier, instead of the complete SLDtree. Using the Constraint Logic Programming (CLP) notation <ref> [16, 15] </ref>, each node of the frontier is a goal e i 2B i containing both constraints (equalities) and literals. The literal :A is now rewritten as the result of the normalization of the formula :(e 1 2B 1 _ : : : _ e n 2B n ). <p> A constrained atom c2p ( X ) is &lt;- solvable iff c is &lt;-solvable. The structures considered in CLP are the "solution compact" ones as defined in <ref> [16, 15] </ref>. The CLP completion of P , wrt the constraint structure &lt;, is denoted by P fl . In the following we consider a one-sorted signature and we do not make any other assumption on .
Reference: [16] <author> J. Jaffar and J.-L. Lassez. </author> <title> Constraint Logic Programming. </title> <type> Technical report, </type> <institution> De--partment of Computer Science, Monash University, </institution> <month> June </month> <year> 1986. </year>
Reference-contexts: This problem was solved in [7], by considering a finite part of the SLD-tree, defined by a frontier, instead of the complete SLDtree. Using the Constraint Logic Programming (CLP) notation <ref> [16, 15] </ref>, each node of the frontier is a goal e i 2B i containing both constraints (equalities) and literals. The literal :A is now rewritten as the result of the normalization of the formula :(e 1 2B 1 _ : : : _ e n 2B n ). <p> Some technical proofs are deferred to the appendix. 2 The language and its semantic domains We will first recall the basic CLP concepts as defined in <ref> [16] </ref>. The CLP framework is defined using a many-sorted first order language, where SORT = S SORT i denotes a finite set of sorts. A signature of an n-ary function, predicate or variable symbol f is a sequence of respectively n + 1; n; 1 elements of SORT. <p> In the following the symbol will denote a finite sequence of symbols. If t is a syntactic object, F V (t) is the set of variables which are not explicitely quantified in t. A sentence is a well formed formula with no free variables. Definition 2.1 (CLP normal programs) <ref> [16] </ref> Let = C [ B and C " B = ;. <p> In the CLP (X) framework, X stands for a specific constraint domain on which the computation is performed. The notion of structure gives the semantic interpretation of such a domain and is the key element in the algebraic semantics. Definition 2.3 <ref> [16] </ref> Let = C [ B and C " B = ;. <p> A constrained atom c2p ( X ) is &lt;- solvable iff c is &lt;-solvable. The structures considered in CLP are the "solution compact" ones as defined in <ref> [16, 15] </ref>. The CLP completion of P , wrt the constraint structure &lt;, is denoted by P fl . In the following we consider a one-sorted signature and we do not make any other assumption on . <p> Moreover the symbols 2 and ; will be interpreted as ^. All the following definitions are related to a given &lt; (and therefore to a given (; )). Definition 3.1 <ref> [16] </ref> The set of "domain instances" [c2p ( X )] of a constrained atom c2p ( X ) is defined as [c2p ( X )] = fp ( X ) j is an &lt;-solution of cg: Let S be a set of constrained atoms.
Reference: [17] <author> T. Khabaza. </author> <title> Negation as failure and parallelism. </title> <booktitle> In Proc. IEEE Symp. on Logic Programming, </booktitle> <pages> pages 70-75. </pages> <publisher> IEEE Press, </publisher> <year> 1984. </year>
Reference-contexts: The range of applicability of intensional negation was increased by defining an extended derivation rule for positive logic programs with universal quantification parametric w.r.t. the DCA [20, 21]. Chan's constructive negation, which is a refinement of previous proposals <ref> [17, 30] </ref> in its original formulation [6] can be described as follows. Definition 1.3 Let :A be a (possibly non-ground) literal in the normal program P .
Reference: [18] <author> K. Kunen. </author> <title> Negation in logic programming. </title> <journal> Journal of Logic Programming, </journal> <volume> 4 </volume> <pages> 289-308, </pages> <year> 1987. </year>
Reference-contexts: The 3-valued completion is also strongly related to the Fitting's operator P [12], which acts upon 3-valued interpretations. The minimal 3-valued model M P of P fl is its least fixpoint P " ff. Kunen's semantics <ref> [18] </ref> is also defined in terms of P , namely fL j P " n j= 3 L for a finite ng = fL j P fl j= 3 Lg. <p> The case of many-sorted signature is a straightforward generalization. 3 Partial -interpretations and -models We extend the notion of -interpretation as introduced in [14] in order to provide three-valued models of the completion of a CLP program. First of all, a partial interpretation, as defined in <ref> [18] </ref> is any total function F from the set of all ground atoms into ft; f ; ug, where ft; f ; ug are interpreted as true, false and undefined. <p> We have proved that, given a normal program P , [O 8 (P )] = [F 8 (P )] = P " !. Using our terminology, theorem 6 of [26] (which is a generalization of theorem 6.3 in <ref> [18] </ref> for languages other than those with infinitely many function symbols of all arities) can be stated for constraint logic programs as follows. The notation &lt; ^ P fl j= 3 S shows that the sentence S is a logical consequence of the theory P fl in the structure &lt;.
Reference: [19] <author> K. Kunen. </author> <title> Signed Data Dependencies in Logic Programs. </title> <journal> Journal of Logic Programming, </journal> <volume> 7(3) </volume> <pages> 231-245, </pages> <year> 1989. </year>
Reference-contexts: The completeness of SLDNF-resolution holds for a larger class of programs, if we consider the logical consequences of the completion P fl in a 3-valued logic. Theorem 1.1 <ref> [19] </ref> Let P be a normal program, G = L 1 ; : : : ; L n be a normal goal, such that P S fGg is allowed, if (L 1 ^ : : : ^ L n ) is a 3-valued logical consequence of P fl , then there
Reference: [20] <author> F. Levi. </author> <title> Negazione e quantificazione universale in programmazione logica. </title> <type> Master's thesis, </type> <institution> Dipartimento di Informatica, Universita di Pisa, </institution> <year> 1991. </year> <note> in italian. </note>
Reference-contexts: The range of applicability of intensional negation was increased by defining an extended derivation rule for positive logic programs with universal quantification parametric w.r.t. the DCA <ref> [20, 21] </ref>. Chan's constructive negation, which is a refinement of previous proposals [17, 30] in its original formulation [6] can be described as follows. Definition 1.3 Let :A be a (possibly non-ground) literal in the normal program P . <p> This relation was originally used in <ref> [20] </ref> for normal programs parametric with respect to the assumption of the Domain Closure Axiom. By abstracting the DCA, equality and inequality constraints are explicitely introduced in the clause bodies.
Reference: [21] <editor> F. Levi, P. Mancarella, and D. Pedreschi. Negazione Costruttiva e Quantificazione Universale in Programmazione Logica con Vincoli. In S. Costantini, editor, </editor> <booktitle> Proc. Seventh Italian Conference on Logic Programming, </booktitle> <pages> pages 273-287, </pages> <year> 1992. </year>
Reference-contexts: The range of applicability of intensional negation was increased by defining an extended derivation rule for positive logic programs with universal quantification parametric w.r.t. the DCA <ref> [20, 21] </ref>. Chan's constructive negation, which is a refinement of previous proposals [17, 30] in its original formulation [6] can be described as follows. Definition 1.3 Let :A be a (possibly non-ground) literal in the normal program P .
Reference: [22] <author> J. W. Lloyd. </author> <title> Foundations of Logic Programming. </title> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1987. </year> <note> Second edition. </note>
Reference-contexts: 1 Introduction The most popular semantics for normal logic programs is based on SLDNF-resolution (SLD-resolution with Negation As Failure) as operational semantics and on the program completion as declarative semantics <ref> [8, 22] </ref>. The reference fixpoint semantics is usually based on Fitting's operator [12]. Unfortunately, the nice equivalence and completeness results proved for the semantics of positive logic programs [29, 2, 22, 1] are not valid in the case of normal programs. <p> The reference fixpoint semantics is usually based on Fitting's operator [12]. Unfortunately, the nice equivalence and completeness results proved for the semantics of positive logic programs <ref> [29, 2, 22, 1] </ref> are not valid in the case of normal programs. In particular, we need to impose strong conditions on programs and goals, in order to deal with various incompleteness problems (e.g. floundering, inconsistency of the completion, the combination of tertium non datur and non-termination).
Reference: [23] <author> J. Maluszynski and T. Naslund. </author> <title> Fail Substitutions for Negation as Failure. </title> <editor> In E. Lusk and R. Overbeek, editors, </editor> <booktitle> Proc. North American Conf. on Logic Programming'89, </booktitle> <pages> pages 461-476. </pages> <publisher> The MIT Press, </publisher> <address> Cambridge, Mass., </address> <year> 1989. </year>
Reference-contexts: The problem of handling "non-ground" literals was tackled by various extensions of Negation As Failure, called constructive negation. Examples are intensional negation [3, 4], Chan's constructive negation [6, 7], the fail substitutions <ref> [23] </ref> and the fail answers [10, 9] techniques. The idea of intensional negation, originally formalized for positive logic programs [3, 4], is the following. <p> First, even if we start from normal logic programs, constructive negation forces the introduction of (possibly universally quantified) inequalities. One can stay within the logic programming setting based on substitution only by assuming the Domain Closure Axiom. This is, for example, the solution chosen in <ref> [23] </ref>. The most natural solution is then choosing the instance of CLP , where constraints are equalities and inequalities on the Herbrand domain.
Reference: [24] <author> P. Mancarella, S. Martini, and D. Pedreschi. </author> <title> Complete Logic Programs with Domain Closure Axiom. </title> <journal> Journal of Logic Programming, </journal> <volume> 5(3) </volume> <pages> 263-276, </pages> <year> 1988. </year>
Reference-contexts: Moreover if the set of function symbols is finite we assume the (weak) domain closure axiom (DCA) be added to CET , thus achieving the completeness of the theory CET in the case of a 4 language with finite set of function symbols. Informally the axiom DCA <ref> [24] </ref> ensures that in the interpretation domain of any model of the theory every object is a value of a non-variable term (under some variable valuation).
Reference: [25] <author> P. Mancarella, D. Pedreschi, M. Rondinelli, and M. Tagliatti. </author> <title> Algebraic Properties of a Class of Logic Programs. </title> <editor> In S. K. Debray and M. Hermenegildo, editors, </editor> <booktitle> Proc. North American Conf. on Logic Programming'90, </booktitle> <pages> pages 23-39. </pages> <publisher> The MIT Press, </publisher> <address> Cambridge, Mass., </address> <year> 1990. </year>
Reference-contexts: The standard semantics of positive logic programs is then applicable to the result of the intensional negation transformation for restricted classes of normal programs only <ref> [25] </ref>. The range of applicability of intensional negation was increased by defining an extended derivation rule for positive logic programs with universal quantification parametric w.r.t. the DCA [20, 21].
Reference: [26] <author> J. C. Shepherdson. </author> <title> Language and equality theory in logic programming. </title> <type> Technical Report PM-91-02, </type> <institution> School of Mathematics, University of Bristol, </institution> <year> 1991. </year>
Reference-contexts: The equality [F 8 (P )] = P " ! follows by theorem 6.4. We have proved that, given a normal program P , [O 8 (P )] = [F 8 (P )] = P " !. Using our terminology, theorem 6 of <ref> [26] </ref> (which is a generalization of theorem 6.3 in [18] for languages other than those with infinitely many function symbols of all arities) can be stated for constraint logic programs as follows.
Reference: [27] <author> P. J. Stuckey. </author> <title> Constructive Negation for Constraint Logic Programming. </title> <booktitle> In Proc. Sixth IEEE Symp. on Logic In Computer Science, </booktitle> <pages> pages 328-339. </pages> <publisher> IEEE Computer Society Press, </publisher> <year> 1991. </year>
Reference-contexts: The result of the computation is independent from the choice of the frontier. The above technique was then extended to CLP <ref> [27, 28] </ref> and a completeness result was proved. In this paper we define intensional negation in CLP and we prove its (non-ground) correctness and completeness w.r.t. the 3-valued completion. There are several motivations for choosing the CLP setting instead of the logic programming one. <p> The most natural solution is then choosing the instance of CLP , where constraints are equalities and inequalities on the Herbrand domain. Moving to the CLP (X) framework allows us to get more generality and to use the only existing formalization of constructive negation <ref> [27] </ref> for which there exists a completeness theorem. We consider the relation among the various constructive techniques. Intensional negation is clearly a "compile-time" technique. The transformation and the associated normalization process are performed once and for all on the source program. All the versions of constructive negation are instead interpretative. <p> The extension of a partial interpretation to ground constraints and to ground formulas is defined in <ref> [27] </ref>, by the following rules. * Let c be a ground constraint. c is true in F iff &lt; j= c and c is false in F iff &lt; j= :c. * We assume the usual strong three-valued interpretation of the symbols ^; _; :; 8; 9; !, and following Kunen, <p> Among the various proposals, the ones by Chan [6, 7], set in the context of infinitary Herbrand universe, have inspired the generalization to the CLP schema, due to Stuckey <ref> [27, 28] </ref>. Informally, constructive negation can be described as follows. <p> Given a normal program P , the operational mechanism (described by Stuckey in <ref> [27] </ref>), must handle the negative existential closure of formulae composed both of constraint and literals, which are naturally generated by the before mentioned decomposition. <p> Definition 4.2 <ref> [27] </ref> A complex normal subgoal is * p ( t) * :9 Z:(c q 2B 1 ; : : : ; B n ) where Z is a (possibly empty) set of variables, c q is a (possibly empty) constraint and the B i 's are complex normal subgoals, for i <p> In the following we describe a SLDCN -derivation <ref> [27] </ref>, where the depth in the derivation tree is one. <p> Therefore we need a notion of complex goal, similar to the one introduced for constructive negation <ref> [27] </ref>, and the derivation rule must be defined for complex goals. In addition to universally quantified disjunctions, since all the quantifiers need to be made explicit, complex goals contain also existentially quantified conjunctions. <p> Proof. If c2p ( X ) 2 O CN (P )), then, by theorem 7.1 in <ref> [27] </ref>, there ex ists a finite n such that [c2p ( X )] + P " n ([c2p ( X )] P " n) and by theorem 6.4 [c2p ( X )] [J + p ]) where J p = T 8 P " n.
Reference: [28] <author> P. J. Stuckey. </author> <title> Constructive Negation for Constraint Logic Programming. </title> <type> Technical report, </type> <institution> Department of Computer Science, University of Melbourne, </institution> <year> 1991. </year>
Reference-contexts: The result of the computation is independent from the choice of the frontier. The above technique was then extended to CLP <ref> [27, 28] </ref> and a completeness result was proved. In this paper we define intensional negation in CLP and we prove its (non-ground) correctness and completeness w.r.t. the 3-valued completion. There are several motivations for choosing the CLP setting instead of the logic programming one. <p> Among the various proposals, the ones by Chan [6, 7], set in the context of infinitary Herbrand universe, have inspired the generalization to the CLP schema, due to Stuckey <ref> [27, 28] </ref>. Informally, constructive negation can be described as follows. <p> The following theorems show the correctness and the completeness of SLD 8 -resolution with respect to the 3-valued logical consequences of P fl in the structure &lt;. Similar the orems were proved for constructive negation in <ref> [28] </ref>. Our proofs are strongly based on properties of F 8 (P ). 8F denotes the universal closure of F .
Reference: [29] <author> M. H. van Emden and R. A. Kowalski. </author> <title> The semantics of predicate logic as a programming language. </title> <journal> Journal of the ACM, </journal> <volume> 23(4) </volume> <pages> 733-742, </pages> <year> 1976. </year>
Reference-contexts: The reference fixpoint semantics is usually based on Fitting's operator [12]. Unfortunately, the nice equivalence and completeness results proved for the semantics of positive logic programs <ref> [29, 2, 22, 1] </ref> are not valid in the case of normal programs. In particular, we need to impose strong conditions on programs and goals, in order to deal with various incompleteness problems (e.g. floundering, inconsistency of the completion, the combination of tertium non datur and non-termination).
Reference: [30] <author> M. Wallace. </author> <title> Negation by Constraints: a Sound and Efficient Implementation of Negation in Deductive Databases. </title> <booktitle> In Proc. IEEE Int'l Symp. on Logic Programming, </booktitle> <pages> pages 253-263. </pages> <publisher> IEEE Press, </publisher> <year> 1987. </year> <month> 27 </month>
Reference-contexts: The range of applicability of intensional negation was increased by defining an extended derivation rule for positive logic programs with universal quantification parametric w.r.t. the DCA [20, 21]. Chan's constructive negation, which is a refinement of previous proposals <ref> [17, 30] </ref> in its original formulation [6] can be described as follows. Definition 1.3 Let :A be a (possibly non-ground) literal in the normal program P .
References-found: 30

