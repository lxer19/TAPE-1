URL: ftp://ftp.cs.brown.edu/pub/techreports/93/cs93-32.ps.Z
Refering-URL: http://www.cs.brown.edu/publications/techreports/reports/CS-93-32.html
Root-URL: 
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> B. Bhargava and S. R. Lian, </author> <title> ``Independent checkpointing and concurrent rollback for recovery - An optimistic approach,'' </title> <booktitle> Proc. IEEE Symp. on Reliable Distr. System, </booktitle> <pages> pp. </pages> <month> 3-12 </month> <year> (1988). </year>
Reference-contexts: 1. Introduction Checkpoints are used in many applications including parallel debugging [6, 9], distributed simulation [3], and fault-tolerant computing <ref> [1, 4] </ref>. A checkpoint is a saved intermediate state of an execution and can be analyzed post-mortem or used to restart the execution from that point. A global snapshot 3 of a distributed computation is a set of local checkpoints, one for each process.
Reference: [2] <author> K. M. Chandy and C. V. Ramamoorthy, </author> <title> ``Rollback and recovery strategies for computer programs,'' </title> <journal> IEEE Trans. on Computers 21 pp. </journal> <month> 546-556 (June </month> <year> 1972). </year>
Reference-contexts: Zigzag paths have applications to any problem that requires saving or analyzing consistent snapshots. For example, in a previous paper [10] we used zigzag paths to virtually eliminate rollback propagation in a checkpoint-ing and rollback recovery scheme for fault tolerance <ref> [2] </ref>. In such a scheme, the state of a distributed system is saved periodically in checkpoints during normal execution. Upon detecting a fault, recovery is performed by rolling the system back to a previous state not affected by the fault, and resuming normal execution.
Reference: [3] <author> D. R. Jefferson, </author> <title> ``Virtual Time,'' </title> <journal> ACM Trans. on Programming Languages and Systems, </journal> <pages> 7(3) pp. </pages> <month> 404-425 (July </month> <year> 1985). </year>
Reference-contexts: 1. Introduction Checkpoints are used in many applications including parallel debugging [6, 9], distributed simulation <ref> [3] </ref>, and fault-tolerant computing [1, 4]. A checkpoint is a saved intermediate state of an execution and can be analyzed post-mortem or used to restart the execution from that point. A global snapshot 3 of a distributed computation is a set of local checkpoints, one for each process.
Reference: [4] <author> R. Koo and S. Toueg, </author> <title> ``Checkpointing and rollback-recovery for distributed systems,'' </title> <journal> IEEE Trans. on Software Engineering SE-13(1) pp. </journal> <month> 23-31 (January </month> <year> 1987). </year>
Reference-contexts: 1. Introduction Checkpoints are used in many applications including parallel debugging [6, 9], distributed simulation [3], and fault-tolerant computing <ref> [1, 4] </ref>. A checkpoint is a saved intermediate state of an execution and can be analyzed post-mortem or used to restart the execution from that point. A global snapshot 3 of a distributed computation is a set of local checkpoints, one for each process.
Reference: [5] <author> L. Lamport, </author> <title> ``Time, Clocks, and the Ordering of Events in a Distributed System,'' </title> <journal> Comm. of the ACM 21(7) pp. </journal> <month> 558-565 (July </month> <year> 1978). </year>
Reference-contexts: A global snapshot is consistent if no local checkpoint happens before another; that is, there is no causal path from one checkpoint to another in the sense that a message (or sequence of messages) sent after one checkpoint is received before the other <ref> [5] </ref>. As a result, a consistent snapshot is a set of local states that actually occurred simultaneously during execution or had the potential of occurring simultaneously. Determining when individual local checkpoints can be combined with others to form a consistent snapshot is an important problem. <p> Model We next outline our model for representing executions of message-passing programs. A program execution is a pair, P = E, iiiiiHB , where E is a finite set of events and iiiiiHB is the happened-before relation defined over E <ref> [5] </ref>. An event represents the execution instance of a send, receive, or checkpoint operation. We assume that a fixed number of processes exist during execution, and that each process periodically saves (or checkpoints) its state in stable storage. <p> In addition, the checkpoint interval 3 July 5, 1993 S p,i is all the computation performed in process p between checkpoints C p,i and C p,i+1 (and includes C p,i but not C p,i+1 ). The happened-before relation, iiiiiHB , shows how events potentially affect one another <ref> [5] </ref>, and is defined as the irreexive transitive closure of the union of two other relations: iiiiiHB = ( iiiiiXO iiiiiM ) + . The iiiiiXO relation shows the order in which events in the same process execute.
Reference: [6] <author> R.H.B. Netzer and J. Xu, </author> <title> ``Adaptive Message Logging for Incremental Replay of Message-Passing Programs,'' </title> <booktitle> To appear in Supercomputing '93, P ortland, </booktitle> <address> OR, </address> <month> (November </month> <year> 1993). </year>
Reference-contexts: 1. Introduction Checkpoints are used in many applications including parallel debugging <ref> [6, 9] </ref>, distributed simulation [3], and fault-tolerant computing [1, 4]. A checkpoint is a saved intermediate state of an execution and can be analyzed post-mortem or used to restart the execution from that point.
Reference: [7] <author> B. Randell, </author> <title> ``System Structure for Software Fault Tolerance,'' </title> <journal> IEEE Trans. on Software Engineering SE-1(2) pp. </journal> <month> 220-232 (June </month> <year> 1975). </year>
Reference-contexts: In an independent checkpointing scheme (where there is no checkpoint coordination among processes), not all checkpoints are guaranteed to belong to a consistent snapshot, and in the worst case, rollback propagates and requires restarting from the execution's beginning <ref> [7] </ref>. We virtually eliminate rollback propagation by tracking zigzag paths on-line, allowing each process to adaptively take checkpoints at moments that minimize the number of checkpoints that cannot belong to a consistent snapshot [10]. Another application for consistent snapshots and consistent states in general is parallel and distributed debugging.
Reference: [8] <author> Y. M. Wang, A. Lowry, and W. K. Fuchs, </author> <title> ``Consistent Global Checkpoints Based on Direct Dependency Tracking,'' </title> <type> Research Report RC 18465, </type> <institution> IBM T.J. Watson Research Center, </institution> <address> Yorktown Heights, New York, </address> <month> (Oct. </month> <year> 1992). </year>
Reference-contexts: In Figure 1, neither of the checkpoints C 1,1 and C 3,1 happen before each other, and they can be combined with C 2,1 to form a consistent snapshot (as shown by the dashed line in Figure 1). However, as noticed by Wang, Lowry and Fuchs <ref> [8] </ref>, this condition is not sufficient. In Figure 1, checkpoints C 1,1 and C 3,2 also do not happen before each other, but they cannot be combined with any other checkpoint to form a consistent snapshot.
Reference: [9] <author> L. D. Wittie, </author> <title> ``Debugging Distributed C Programs by Real Time Replay,'' </title> <booktitle> SIGPLAN/SIGOPS Workshop on Parallel and Distributed Debugging, </booktitle> <pages> pp. </pages> <address> 57-67 Madison, WI, </address> <month> (May </month> <year> 1988). </year>
Reference-contexts: 1. Introduction Checkpoints are used in many applications including parallel debugging <ref> [6, 9] </ref>, distributed simulation [3], and fault-tolerant computing [1, 4]. A checkpoint is a saved intermediate state of an execution and can be analyzed post-mortem or used to restart the execution from that point.
Reference: [10] <author> J. Xu and R.H.B. Netzer, </author> <title> ``Adaptive Independent Checkpointing for Reducing Rollback Propagation,'' </title> <institution> Brown University Computer Science Dept. </institution> <type> Technical Report CS-93-25, </type> <month> (May </month> <year> 1993). </year> <month> 11 </month>
Reference-contexts: This zigzag path means that C 1,1 and C 3,2 can never belong together in any consistent snapshot. Zigzag paths have applications to any problem that requires saving or analyzing consistent snapshots. For example, in a previous paper <ref> [10] </ref> we used zigzag paths to virtually eliminate rollback propagation in a checkpoint-ing and rollback recovery scheme for fault tolerance [2]. In such a scheme, the state of a distributed system is saved periodically in checkpoints during normal execution. <p> We virtually eliminate rollback propagation by tracking zigzag paths on-line, allowing each process to adaptively take checkpoints at moments that minimize the number of checkpoints that cannot belong to a consistent snapshot <ref> [10] </ref>. Another application for consistent snapshots and consistent states in general is parallel and distributed debugging. A consistent state represents some state that could have occurred during an execution regardless of the relative speed of process execution or message delays.
References-found: 10

