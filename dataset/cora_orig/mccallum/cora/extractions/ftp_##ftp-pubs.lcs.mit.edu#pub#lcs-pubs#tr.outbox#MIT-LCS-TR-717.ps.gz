URL: ftp://ftp-pubs.lcs.mit.edu/pub/lcs-pubs/tr.outbox/MIT-LCS-TR-717.ps.gz
Refering-URL: ftp://ftp-pubs.lcs.mit.edu/pub/lcs-pubs/listings/tr700.html
Root-URL: 
Title: Revisiting the Paxos Algorithm  
Author: by Roberto De Prisco Prof. Nancy Lynch Prof. Arthur C. Smith 
Degree: Laurea in Computer Science (1991)  Submitted to the Department of Electrical Engineering and Computer Science in partial fulfillment of the requirements for the degree of Master of Science in Electrical Engineering and Computer Science at the  All rights reserved. Author Department of Electrical Engineering and Computer Science  Certified by  Professor of Software Science and Engineering Thesis Supervisor Accepted by  Chairman, Department Committee on Graduate Theses  
Date: June 3, 1997  June 3, 1997  
Address: Italy  
Affiliation: University of Salerno,  MASSACHUSETTS INSTITUTE OF TECHNOLOGY  c Massachusetts Institute of Technology.  NEC  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> P. Alsberg, J. Day, </author> <title> A principle for resilient sharing of distributed resources. </title> <booktitle> In Proc. of the 2 nd International Conference on Software Engineering, </booktitle> <pages> pp. 627-644, </pages> <month> Oct. </month> <year> 1976. </year>
Reference-contexts: These consistency issues depend on what requirements the replicated data has to satisfy. The strongest possible of such requirements is atomicity: clients accessing the replicated object obtain results as if there was a unique copy. Primary copy algorithms <ref> [1, 34] </ref> and voting algorithms [20, 23] are used to achieve atomicity. Achieving atomicity is expensive; therefore weaker consistency requirements are also considered.
Reference: [2] <author> A. Adya, R. Gruber, B. Liskov and U. Maheshwari, </author> <title> Efficient Optimistic Concurrency Control using Loosely Synchronized Clocks, </title> <booktitle> SIGMOD, </booktitle> <address> San Jose, CA, </address> <pages> pp. 23-34. </pages> <month> May </month> <year> 1995. </year>
Reference-contexts: This is really important in practice, since in the presence of failures it is practically not possible to provide a 132 reliable leader elector (this is due to the difficulty of detecting failures). Consensus algorithms currently used in practice are based on the 2-phase commit algorithm (e.g., <ref> [2, 25, 41, 48] </ref>, see also [22]) and sometime on the 3-phase commit algorithm (e.g. [47, 48]). The 2-phase commit protocol is not at all fault tolerant.
Reference: [3] <author> Y. Amir, D. Dolev, P. Melliar-Smith and L. Moser, </author> <title> Robust and Efficient Replication Using Group Communication, </title> <type> Technical Report 94-20, </type> <institution> Department of Computer Science, Hebrew University, </institution> <year> 1994. </year>
Reference-contexts: Their work seems to incorporate ideas similar to the ones used in paxos. Also the virtual synchrony group communication scheme of Fekete, Lynch and Shvartsman [16] based on previous work by Amir et. al. <ref> [3] </ref>, Keidar and Dolev [24] and Cristian and Schmuck [7], uses ideas somewhat similar to those used by paxos: quorums and timestamps (timestamps in paxos are basically the round numbers). Certainly a further step is a practical implementation of the paxos algorithm.
Reference: [4] <author> T.D. Chandra, V. Hadzilacos, S. Toueg, </author> <title> The weakest failure detector for solving consensus, </title> <booktitle> in Proceedings of the 11 th Annual ACM Symposium on Principles of Distributed Computing, </booktitle> <pages> pp. 147-158, </pages> <address> Vancouver, British Columbia, Canada, </address> <month> August </month> <year> 1992. </year>
Reference-contexts: No failure detector are actually implemented in [5]. The failure detector provided in this thesis, cannot be classified in the hierarchy defined in [5] since they do not consider channel failures. Chandra, Hadzilacos and Toueg <ref> [4] </ref> identified the "weakest" failure detector that can be used to solve the consensus problem. Failure detectors have practical relevance since it is often important to establish which processes are alive and which one are stopped.
Reference: [5] <author> T.D. Chandra, S. Toueg, </author> <title> Unreliable failure detector for asynchronous distributed systems, </title> <booktitle> Proceedings of PODC 91, </booktitle> <pages> pp. 325-340. </pages> <booktitle> in Proceedings of the 10 th Annual ACM Symposium on Principles of Distributed Computing, </booktitle> <pages> pp. 325-340, </pages> <month> August </month> <year> 1991. </year>
Reference-contexts: If a reliable failure detector were provided then the consensus problem would be solvable. This clearly implies that in a completely asynchronous setting no reliable failure detector can be provided. Chandra and Toueg <ref> [5] </ref> gave a definition of unreliable failure detector, and characterized failure detectors in terms of two properties: completeness, which requires that the failure detector 59 eventually suspect any stopped process, and accuracy, which restricts the mistakes a failure detector can make. No failure detector are actually implemented in [5]. <p> and Toueg <ref> [5] </ref> gave a definition of unreliable failure detector, and characterized failure detectors in terms of two properties: completeness, which requires that the failure detector 59 eventually suspect any stopped process, and accuracy, which restricts the mistakes a failure detector can make. No failure detector are actually implemented in [5]. The failure detector provided in this thesis, cannot be classified in the hierarchy defined in [5] since they do not consider channel failures. Chandra, Hadzilacos and Toueg [4] identified the "weakest" failure detector that can be used to solve the consensus problem. <p> No failure detector are actually implemented in <ref> [5] </ref>. The failure detector provided in this thesis, cannot be classified in the hierarchy defined in [5] since they do not consider channel failures. Chandra, Hadzilacos and Toueg [4] identified the "weakest" failure detector that can be used to solve the consensus problem. Failure detectors have practical relevance since it is often important to establish which processes are alive and which one are stopped.
Reference: [6] <author> E.C. Cooper, </author> <title> Replicated distributed programs. </title> <type> UCB/CSD 85/231, </type> <institution> University of Cali-fornia, Berkeley, </institution> <address> CA, </address> <month> May </month> <year> 1985. </year>
Reference-contexts: Write quorums and read quorums are just sets of processes satisfying the property that any two quorums, one of which is a write quorum and the other one is a read quorum, intersect (e.g., [16]). A simple quorum scheme is the write-all/read-one scheme (e.g., <ref> [6] </ref>) which gives fast access for non-update operations. 120 Another well-known replication technique relies on a primary copy.
Reference: [7] <author> F. Cristian and F. Schmuck, </author> <title> Agreeing on Processor Group Membership in Asynchronous Distributed Systems, </title> <type> Technical Report CSE95-428, </type> <institution> Department of Computer Science, University of California San Diego. </institution>
Reference-contexts: Their work seems to incorporate ideas similar to the ones used in paxos. Also the virtual synchrony group communication scheme of Fekete, Lynch and Shvartsman [16] based on previous work by Amir et. al. [3], Keidar and Dolev [24] and Cristian and Schmuck <ref> [7] </ref>, uses ideas somewhat similar to those used by paxos: quorums and timestamps (timestamps in paxos are basically the round numbers). Certainly a further step is a practical implementation of the paxos algorithm. We have shown that paxos is very efficient and fault tolerant in theory.
Reference: [8] <author> D. Dolev, </author> <title> Unanimity in an unknown and unreliable environment. </title> <booktitle> Proc. 22nd IEEE Symposium on Foundations of Computer Science, </booktitle> <pages> pp. 159-168, </pages> <year> 1981 </year> <month> 138 </month>
Reference: [9] <author> D. Dolev, </author> <title> The Byzantine generals strike again. </title> <journal> J. of Algorithms vol. </journal> <volume> 3 (1), </volume> <pages> pp. 14-30, </pages> <year> 1982. </year>
Reference: [10] <author> D. Dolev, C. Dwork, L. Stockmeyer, </author> <title> On the minimal synchrony needed for distributed consensus, </title> <journal> J. of the ACM, </journal> <volume> vol. 34 (1), </volume> <pages> pp. 77-97, </pages> <month> January </month> <year> 1987. </year>
Reference: [11] <author> C. Dwork, N. Lynch, L. Stockmeyer, </author> <title> Consensus in the presence of partial synchrony, </title> <journal> J. of the ACM, </journal> <volume> vol. 35 (2), </volume> <pages> pp. 288-323, </pages> <month> April </month> <year> 1988. </year>
Reference-contexts: This is not trivial, since having replicated copies implies that consistency has to be guaranteed and this may result in low fault tolerance. Independent work related to paxos has been carried out. The algorithms in <ref> [11, 34] </ref> have similar ideas. The algorithm of Dwork, Lynch and Stockmeyer [11] also uses rounds conducted by a leader, but the rounds are conducted sequentially, whereas in paxos a leader can start a round at any time and multiple simultaneous leaders are allowed. <p> This is not trivial, since having replicated copies implies that consistency has to be guaranteed and this may result in low fault tolerance. Independent work related to paxos has been carried out. The algorithms in [11, 34] have similar ideas. The algorithm of Dwork, Lynch and Stockmeyer <ref> [11] </ref> also uses rounds conducted by a leader, but the rounds are conducted sequentially, whereas in paxos a leader can start a round at any time and multiple simultaneous leaders are allowed. The strategy used in each round by the algorithm of [11] is somewhat different from the one used by <p> The algorithm of Dwork, Lynch and Stockmeyer <ref> [11] </ref> also uses rounds conducted by a leader, but the rounds are conducted sequentially, whereas in paxos a leader can start a round at any time and multiple simultaneous leaders are allowed. The strategy used in each round by the algorithm of [11] is somewhat different from the one used by paxos. Moreover the distributed model of [11] does not consider process recoveries. The time analysis provided in [11] is conditional on a "global stabilization time" after which process response times and message delivery times satisfy the time assumptions. <p> The strategy used in each round by the algorithm of <ref> [11] </ref> is somewhat different from the one used by paxos. Moreover the distributed model of [11] does not consider process recoveries. The time analysis provided in [11] is conditional on a "global stabilization time" after which process response times and message delivery times satisfy the time assumptions. <p> The strategy used in each round by the algorithm of <ref> [11] </ref> is somewhat different from the one used by paxos. Moreover the distributed model of [11] does not consider process recoveries. The time analysis provided in [11] is conditional on a "global stabilization time" after which process response times and message delivery times satisfy the time assumptions. <p> In [32] Lampson provides a brief overview of the paxos algorithm together with the key points for proving the correctness of the algorithm. In <ref> [11] </ref> three different partially synchronous models are considered. For each of them and for different types of failure an upper bound on the number of failures that can be tolerated is shown, and algorithms that achieve the bounds are given. A model studied in [11] considers a distributed setting similar to <p> In <ref> [11] </ref> three different partially synchronous models are considered. For each of them and for different types of failure an upper bound on the number of failures that can be tolerated is shown, and algorithms that achieve the bounds are given. A model studied in [11] considers a distributed setting similar to the one we consider in this thesis: a partially synchronous distributed system in which upper bounds on the process response time and message delivery time hold eventually; the failures considered are process stop failures (also other models that consider omission failures, Byzantine failures with <p> the one we consider in this thesis: a partially synchronous distributed system in which upper bounds on the process response time and message delivery time hold eventually; the failures considered are process stop failures (also other models that consider omission failures, Byzantine failures with and without authentication are studied in <ref> [11] </ref>). The protocol provided in [11], the DLS algorithm for short, needs a linear, in the number of processes, amount of time from the point in which the upper bounds on the process response time and message delivery time start holding. <p> this thesis: a partially synchronous distributed system in which upper bounds on the process response time and message delivery time hold eventually; the failures considered are process stop failures (also other models that consider omission failures, Byzantine failures with and without authentication are studied in <ref> [11] </ref>). The protocol provided in [11], the DLS algorithm for short, needs a linear, in the number of processes, amount of time from the point in which the upper bounds on the process response time and message delivery time start holding.
Reference: [12] <author> D.L. Eager and K.C. Sevcik, </author> <title> Achieving robustness in distributed database systems, </title> <journal> ACM Trans. on Database Systems vol. </journal> <volume> 8 (3), </volume> <pages> pp. 354-381, </pages> <month> September </month> <year> 1983. </year>
Reference: [13] <author> A. El Abbadi, D. Skeen, F. Cristian, </author> <title> An efficient fault-tolerant protocol for replicated data management, </title> <booktitle> Proc. of the 4 th ACM SIGACT/SIGMOD Conference on Principles of Database Systems, </booktitle> <year> 1985. </year>
Reference-contexts: The primary copy technique works better in practice if the primary copy does not fail. Complex recovery mechanisms are needed when the primary copy crashes. Various data replication algorithms based on the primary copy technique have been devised (e.g., <ref> [13, 14, 34] </ref>). Replication of the data object raises the issue of consistency among the replicas. These consistency issues depend on what requirements the replicated data has to satisfy.
Reference: [14] <author> A. El Abbadi, S. Toueg, </author> <title> Maintaining availability in partitioned replicated databases, </title> <booktitle> Proc. of the 5 th ACM SIGACT/SIGMOD Conference on Principles of Data Base Systems, </booktitle> <year> 1986 </year>
Reference-contexts: The primary copy technique works better in practice if the primary copy does not fail. Complex recovery mechanisms are needed when the primary copy crashes. Various data replication algorithms based on the primary copy technique have been devised (e.g., <ref> [13, 14, 34] </ref>). Replication of the data object raises the issue of consistency among the replicas. These consistency issues depend on what requirements the replicated data has to satisfy.
Reference: [15] <author> A.Fekete, F. Kaashoek, N. Lynch, </author> <title> Implementing Sequentially-Consistent Shared Objects Using Group and Point-to-Point Communication, </title> <booktitle> n the 15th International Conference on Distributed Computing Systems (ICDCS95), </booktitle> <pages> pp. 439-449, </pages> <address> Vancouver, Canada, </address> <month> May/June </month> <year> 1995, </year> <note> IEEE. Abstract/Paper. Also, Technical Report MIT/LCS/TR-518, </note> <institution> Laboratory for Computer Science, Massachusetts Institute of Technology, </institution> <address> Cambridge, MA, </address> <month> June </month> <year> 1995. </year>
Reference-contexts: Sequential consistency has been first defined by Lamport [26]. We base our definition on the one given in <ref> [15] </ref> which relies on the notion of atomic object [27, 28] (see also [35] for a description of an atomic object).
Reference: [16] <author> A. Fekete, N. Lynch, A. Shvartsman, </author> <title> Specifying and using a partitionable group communication service, </title> <type> manuscript, </type> <year> 1997. </year>
Reference-contexts: The time analysis provided in [11] is conditional on a "global stabilization time" after which process response times and message delivery times satisfy the time assumptions. This is similar to our analysis. (A similar time analysis, applied to a different problem, can be found in <ref> [16] </ref>.) multipaxos can be easily used to implement a data replication algorithm. In [34] a data replication algorithm is provided. It incorporates ideas similar to the ones used in paxos. paxos bears some similarities with the standard three-phase commit protocol: both require, in each round, an exchange of 5 messages. <p> Write quorums and read quorums are just sets of processes satisfying the property that any two quorums, one of which is a write quorum and the other one is a read quorum, intersect (e.g., <ref> [16] </ref>). A simple quorum scheme is the write-all/read-one scheme (e.g., [6]) which gives fast access for non-update operations. 120 Another well-known replication technique relies on a primary copy. <p> Their work seems to incorporate ideas similar to the ones used in paxos. Also the virtual synchrony group communication scheme of Fekete, Lynch and Shvartsman <ref> [16] </ref> based on previous work by Amir et. al. [3], Keidar and Dolev [24] and Cristian and Schmuck [7], uses ideas somewhat similar to those used by paxos: quorums and timestamps (timestamps in paxos are basically the round numbers).
Reference: [17] <author> M.J. Fischer, </author> <title> The consensus problem in unreliable distributed systems (a brief survey). </title> <type> Rep. </type> <institution> YALEU/DSC/RR-273. Dept. of Computer Science, Yale Univ., </institution> <address> New Have, Conn., </address> <month> June </month> <year> 1983. </year>
Reference-contexts: The termination condition states requirements about the termination of an algorithm that solves the problem (e.g., "each non-faulty process eventually outputs a value"). Distributed consensus has been extensively studied; a good survey of early results is provided in <ref> [17] </ref>. We refer the reader to [35] for a more up-to-date treatment of consensus problems. 1 We remark that the words "process" and "processor" are often used as synonyms. The word "processor" is more appropriate when referring to a physical component of a distributed system.
Reference: [18] <author> M.J. Fischer, N. Lynch and M. Paterson, </author> <title> Impossibility of distributed consensus with one faulty process, </title> <journal> Journal of the ACM, </journal> <volume> Vol. 32 (2), </volume> <pages> pp. 374-382, </pages> <month> April </month> <year> 1985. </year> <month> 139 </month>
Reference-contexts: Thus real distributed systems suffer timing failures, too. The possibility of timing failures in a partially synchronous distributed system means that the system may as well behave like an asynchronous one. Unfortunately, reaching consensus in asynchronous systems, is impossible, unless it is guaranteed that no failures happen <ref> [18] </ref>. Henceforth, to solve the problem we need to rely on the timing assumptions. Since timing failures are anyway possible, safety properties, that is, agreement and validity conditions, must not depend at all on timing assumptions. <p> Allowing timing failures, the partially synchronous system may behave as an asynchronous one. A fundamental theoretical result, proved by Fischer, Lynch and Paterson <ref> [18] </ref> states that in an asynchronous system there is no consensus algorithm even in the presence of only one stopping failure. Essentially the impossibility result stem from the inherent difficulty of determining whether a process has actually stopped or is only slow. The paxos algorithm was devised by Lamport. <p> An informal argument that explains this difficulty is that the leader election problem is somewhat similar to the consensus problem (which, in an asynchronous system subject to failures is unsolvable <ref> [18] </ref>) in the sense that to elect a leader all processes must reach consensus on which one is the leader. As for the failure detector, we need to rely on timing assumptions. It is fairly clear how a failure detector can be used to elect a leader. <p> This is why the consensus problem cannot be solved even in the case where at most one process fails <ref> [18] </ref>. If a reliable failure detector were provided then the consensus problem would be solvable. This clearly implies that in a completely asynchronous setting no reliable failure detector can be provided.
Reference: [19] <author> Z. Galil, A. Mayer, M. Yung, </author> <title> Resolving the message complexity of Byzantine agreement and beyond, </title> <booktitle> Proceedings of the 37 th IEEE Symposium on Foundations of Computer Science (FOCS), </booktitle> <pages> pp. 724-733, </pages> <year> 1995. </year>
Reference: [20] <author> D.K. Gifford, </author> <title> Weighted voting for replicated data. </title> <booktitle> Proc. of the 7th ACM Symposium on Operating Systems Principles, SIGOPS Operating Systems Review, </booktitle> <volume> vol. 13 (5), </volume> <pages> pp. 150-162. </pages> <month> December </month> <year> 1979. </year>
Reference-contexts: However this approach does not scale well as the number of clients increases and it is not fault-tolerant. Data replication allows faster access and provides fault tolerance by replicating the data object at several processes. One of the best known replication techniques is majority voting (e.g., <ref> [20, 23] </ref>). With this technique both update (write) and non-update (read) operations are performed at a majority of the processes of the distributed system. This scheme can be extended to consider any "write quorum" for an update operation and any "read quorum" for a non-update operation. <p> These consistency issues depend on what requirements the replicated data has to satisfy. The strongest possible of such requirements is atomicity: clients accessing the replicated object obtain results as if there was a unique copy. Primary copy algorithms [1, 34] and voting algorithms <ref> [20, 23] </ref> are used to achieve atomicity. Achieving atomicity is expensive; therefore weaker consistency requirements are also considered.
Reference: [21] <author> J. N. Gray. </author> <title> Notes on data base operating systems. </title> <editor> In R. Bayer, R. M. Graham, and G, Seegmuller, editors, </editor> <booktitle> Operating Systems: An Advanced Course, volume 60 of Lecture Notes in Computer Science, </booktitle> <pages> pp. 450-463, </pages> <address> Philadelphia, Pennsylvania, </address> <month> June </month> <year> 1978. </year>
Reference: [22] <author> J. N. Gray, A. Reuter. </author> <title> Transaction Processing: Concepts and Techniques, </title> <publisher> Morgan Kaufmann Publishers, Inc., </publisher> <address> San Mateo CA, </address> <year> 1993. </year>
Reference-contexts: Consensus algorithms currently used in practice are based on the 2-phase commit algorithm (e.g., [2, 25, 41, 48], see also <ref> [22] </ref>) and sometime on the 3-phase commit algorithm (e.g. [47, 48]). The 2-phase commit protocol is not at all fault tolerant. The reason why it is used in practice is that it is very easy to implement and the probability that failures affect the protocols is low.
Reference: [23] <author> M.P. Herlihy, </author> <title> A quorum-consensus replication method for abstract data types. </title> <journal> ACM Trans. on Computer Systems vol. </journal> <volume> 4 (1), </volume> <pages> 32-53, </pages> <month> February </month> <year> 1986. </year>
Reference-contexts: However this approach does not scale well as the number of clients increases and it is not fault-tolerant. Data replication allows faster access and provides fault tolerance by replicating the data object at several processes. One of the best known replication techniques is majority voting (e.g., <ref> [20, 23] </ref>). With this technique both update (write) and non-update (read) operations are performed at a majority of the processes of the distributed system. This scheme can be extended to consider any "write quorum" for an update operation and any "read quorum" for a non-update operation. <p> These consistency issues depend on what requirements the replicated data has to satisfy. The strongest possible of such requirements is atomicity: clients accessing the replicated object obtain results as if there was a unique copy. Primary copy algorithms [1, 34] and voting algorithms <ref> [20, 23] </ref> are used to achieve atomicity. Achieving atomicity is expensive; therefore weaker consistency requirements are also considered.
Reference: [24] <author> I. Keidar and D. Dolev, </author> <title> Efficient Message Ordering in Dynamic Networks, </title> <booktitle> in Proc. of 15th Annual ACM Symp. on Princ. of Distr. Comput., </booktitle> <pages> pp. 68-76, </pages> <year> 1996. </year>
Reference-contexts: Their work seems to incorporate ideas similar to the ones used in paxos. Also the virtual synchrony group communication scheme of Fekete, Lynch and Shvartsman [16] based on previous work by Amir et. al. [3], Keidar and Dolev <ref> [24] </ref> and Cristian and Schmuck [7], uses ideas somewhat similar to those used by paxos: quorums and timestamps (timestamps in paxos are basically the round numbers). Certainly a further step is a practical implementation of the paxos algorithm.
Reference: [25] <author> A. Kirmse, </author> <title> Implementation of the two-phase commit protocol in Thor, </title> <type> S.M. Thesis, </type> <institution> Lab. for Computer Science, Massachusetts Institute of Technology, </institution> <month> May </month> <year> 1995. </year>
Reference-contexts: This is really important in practice, since in the presence of failures it is practically not possible to provide a 132 reliable leader elector (this is due to the difficulty of detecting failures). Consensus algorithms currently used in practice are based on the 2-phase commit algorithm (e.g., <ref> [2, 25, 41, 48] </ref>, see also [22]) and sometime on the 3-phase commit algorithm (e.g. [47, 48]). The 2-phase commit protocol is not at all fault tolerant.
Reference: [26] <author> L. Lamport, </author> <title> Proving the correctness of multiprocess programs. </title> <journal> IEEE Transactions on Software Eng., </journal> <volume> Vol. SE-3, </volume> <pages> pp. 125-143, </pages> <month> Sept. </month> <year> 1977. </year>
Reference-contexts: Primary copy algorithms [1, 34] and voting algorithms [20, 23] are used to achieve atomicity. Achieving atomicity is expensive; therefore weaker consistency requirements are also considered. One of these weaker consistency requirements is sequential consistency <ref> [26] </ref>, which allows operations to be re-ordered as long as they remain consistent with the view of individual clients. 8.2 Sequential consistency In this section we formally define a sequential consistent read/update object. Sequential consistency has been first defined by Lamport [26]. <p> One of these weaker consistency requirements is sequential consistency <ref> [26] </ref>, which allows operations to be re-ordered as long as they remain consistent with the view of individual clients. 8.2 Sequential consistency In this section we formally define a sequential consistent read/update object. Sequential consistency has been first defined by Lamport [26]. We base our definition on the one given in [15] which relies on the notion of atomic object [27, 28] (see also [35] for a description of an atomic object).
Reference: [27] <author> L. Lamport, </author> <title> On interprocess communication, Part I: Basic formalism. </title> <journal> Distributed Computing, </journal> <volume> 1(2), </volume> <pages> pp. 77-85, </pages> <month> Apr. </month> <year> 1986. </year>
Reference-contexts: Sequential consistency has been first defined by Lamport [26]. We base our definition on the one given in [15] which relies on the notion of atomic object <ref> [27, 28] </ref> (see also [35] for a description of an atomic object). <p> In an atomic object, the operations appear "as if" they happened in some sequential order. The idea of "atomic object" originated in <ref> [27, 28] </ref>. Here we use the formal definition given in Chapter 13 of [35]. In a sequentially consistent object the above atomic requirement is weakened by allowing events to be reordered as long as the view of each client i does not change.
Reference: [28] <author> L. Lamport, </author> <title> On interprocess communication, Part II: Algorithms. </title> <journal> Distributed Computing, </journal> <volume> 1(2), </volume> <pages> pp. 86-101, </pages> <month> Apr. </month> <year> 1986. </year>
Reference-contexts: Sequential consistency has been first defined by Lamport [26]. We base our definition on the one given in [15] which relies on the notion of atomic object <ref> [27, 28] </ref> (see also [35] for a description of an atomic object). <p> In an atomic object, the operations appear "as if" they happened in some sequential order. The idea of "atomic object" originated in <ref> [27, 28] </ref>. Here we use the formal definition given in Chapter 13 of [35]. In a sequentially consistent object the above atomic requirement is weakened by allowing events to be reordered as long as the view of each client i does not change.
Reference: [29] <author> L. Lamport, </author> <note> The part-time parliament, Research Report 49, </note> <institution> Digital Equipment Corporation Systems Research Center, </institution> <address> Palo Alto, CA, </address> <month> September </month> <year> 1989. </year>
Reference-contexts: Any practical consensus algorithm needs to consider all the above practical issues. Moreover, the basic safety properties must not be affected by the occurrence of failures. Also, the performance of the algorithm should be good when there are no failures. paxos is an algorithm devised by Lamport <ref> [29] </ref> that solves the consensus problem. The model considered is a partially synchronous distributed system where each process has a direct communication channel with each other process. The failures allowed are timing failures, loss, duplication and reordering of messages, process stopping failures. <p> When the distributed system stabilizes, meaning that there are no failures nor process recoveries and a majority of the processes are not stopped, for a sufficiently long time, termination is achieved; the performance of the algorithm when the system stabilizes is good. In <ref> [29] </ref> there is also presented a variation of paxos that considers multiple concurrent runs of paxos when consensus has to be reached on a sequence of values. We call 12 this variation the multipaxos algorithm 2 . <p> Thus, paxos has good fault-tolerance properties and when the system is stable combines those fault-tolerance properties with the performance of an efficient algorithm, so that it can be useful in practice. In the original paper <ref> [29] </ref>, the paxos algorithm is described as the result of discoveries of archaeological studies of an ancient Greek civilization. That paper contains a sketch of a proof of correctness and a discussion of the performance analysis. The style used for the description of the algorithm often diverts the reader's attention. <p> It also contains a correctness proof and a time performance and fault-tolerance analysis. The multipaxos algorithm is also described together with an application to data replication. 2 paxos is the name of the ancient civilization studied in <ref> [29] </ref>. The actual algorithm is called the "single-decree synod" protocol and its variation for multiple consensus is called the "multi-decree parliament" protocol. <p> Essentially the impossibility result stem from the inherent difficulty of determining whether a process has actually stopped or is only slow. The paxos algorithm was devised by Lamport. In the original paper <ref> [29] </ref>, the paxos algorithm is described as the result of discoveries of archaeological studies of an ancient Greek civilization. The paxos algorithm is presented by explaining how the parliament of this ancient Greek civilization worked. A proof of correctness is provided in the appendix of that paper. <p> The paxos algorithm is presented by explaining how the parliament of this ancient Greek civilization worked. A proof of correctness is provided in the appendix of that paper. A time-performance analysis is discussed. Many practical optimizations of the algorithm are also discussed. In <ref> [29] </ref> there is also presented a variation of paxos that considers multiple concurrent runs of paxos when consensus has to be reached on a sequence of values. We call this variation the multipaxos algorithm. multipaxos can be easily used to implement a data replication algorithm. <p> However in asynchronous systems there is the inherent difficulty of distinguishing a stopped process from a slow one. 60 Chapter 6 The paxos algorithm paxos was devised a very long time ago 1 but its discovery, due to Lamport, dates back only to 1989 <ref> [29] </ref>. In this chapter we describe the paxos algorithm, provide an implementation using Clock GT automata, prove its correctness and analyze its performance. The performance analysis is given assuming that there are no failures nor recoveries, and a majority of the processes are alive for a sufficiently long time. <p> In basicpaxos processes try to reach a decision by running what we call a "round". A process starting a round is the leader of that round. basicpaxos guar 1 The most accurate information dates it back to the beginning of this millennium <ref> [29] </ref>. 61 antees that, no matter how many leaders start rounds, agreement and validity are not violated. However to have a complete algorithm that satisfies termination when there are no failures for a sufficiently long time, we need to augment basicpaxos with another module; we call this module starteralg. <p> Within additional ` time action Decide (v 0 ) j is executed. 6.5 Concluding remarks In this chapter we have provided a new presentation of the paxos algorithm. The paxos algorithm was devised in <ref> [29] </ref>. However, the algorithm seems to be not widely known or understood. We conclude this chapter with a few remarks. The first remark concerns the time analysis. <p> The multipaxos algorithm reaches consensus on a sequence of values; it was discovered by Lamport at the same time as paxos <ref> [29] </ref>. 7.1 Overview To achieve consensus on a sequence of values we can informally use an instance of paxos for each integer k, so that the k-th instance is used to agree on the k-th value. <p> It was discovered by Lamport at the same time as paxos <ref> [29] </ref>. multipaxos achieves consensus on a sequence of values utilizing an instance of paxos for each of them. AMP uses an instance of paxos to agree on each value of the sequence; remarks about paxos provided at the end of Chapter 6 apply also for multipaxos. <p> Both paxos and multipaxos were devised by Lamport <ref> [29] </ref>. <p> The paxos algorithm satisfy both requirements. We believe that paxos is the most practical solution to the consensus problem currently available. In the original paper <ref> [29] </ref>, the paxos algorithm is described as the result of discoveries of archaeological studies of an ancient Greek civilization. That paper contains a sketch of a proof of correctness and a discussion of the performance analysis. The style used for the description of the algorithm often diverts the reader's attention.
Reference: [30] <author> L. Lamport, R. Shostak, M. Pease, </author> <title> The Byzantine generals problem, </title> <journal> ACM Trans. on Program. Lang. Syst. </journal> <volume> 4 (3), </volume> <pages> 382-401, </pages> <month> July </month> <year> 1982. </year> <month> 140 </month>
Reference: [31] <author> B. Lampson, W. Weihl, U. Maheshwari, </author> <title> Principle of Computer Systems: </title> <booktitle> Lecture Notes for 6.826, Fall 1992, Research Seminar Series MIT/LCS/RSS 22, </booktitle> <institution> Laboratory for Computer Science, Massachusetts Institute of Technology, </institution> <address> Cambridge, MA 02139, </address> <month> July </month> <year> 1993. </year>
Reference-contexts: The correctness of each piece is proved by means of invariants, i.e., properties of system states that are always true in an execution. The key invariants we use in our proof are the same as in <ref> [31, 32] </ref>. The time performance and fault-tolerance analysis is conditional on the stabilization of the system behavior starting from some point in an execution. While it is easy to formalize process and channel failures, dealing formally with timing failures is harder. <p> In the class notes of the graduate level Principles of Computer Systems course <ref> [31] </ref> taught at MIT, a description of paxos is provided using a specification language called SPEC. The presentation in [31] contains the description of how a round of paxos is conducted. The leader election problem is not considered. <p> In the class notes of the graduate level Principles of Computer Systems course <ref> [31] </ref> taught at MIT, a description of paxos is provided using a specification language called SPEC. The presentation in [31] contains the description of how a round of paxos is conducted. The leader election problem is not considered. Timing issues are not 15 considered; for example, the problem of starting new rounds is not addressed. A proof of correctness, written also in SPEC, is outlined. <p> The leader election problem is not considered. Timing issues are not 15 considered; for example, the problem of starting new rounds is not addressed. A proof of correctness, written also in SPEC, is outlined. Our presentation differs from that of <ref> [31] </ref> in the following aspects: it is based on I/O automata models rather than on a programming language; it provides all the details of the algorithm; it provides a modular description of the algorithm, including auxiliary parts such as a failure detector module and a leader elector module; along with the <p> We call this variation the multipaxos algorithm. multipaxos can be easily used to implement a data replication algorithm. In [34] a data replication algorithm is provided. It incorporates ideas similar to the ones used in paxos. In the class notes of Principles of Computer Systems <ref> [31] </ref> taught at MIT, a description of paxos is provided using a specification language called SPEC. The presentation in [31] contains the description of how a round of paxos is conducted. The leader election problem is not considered. <p> In [34] a data replication algorithm is provided. It incorporates ideas similar to the ones used in paxos. In the class notes of Principles of Computer Systems <ref> [31] </ref> taught at MIT, a description of paxos is provided using a specification language called SPEC. The presentation in [31] contains the description of how a round of paxos is conducted. The leader election problem is not considered. Timing issues are not considered; for example, the problem of starting new rounds is not addressed. A proof of correctness, written also in SPEC, is provided. <p> The leader election problem is not considered. Timing issues are not considered; for example, the problem of starting new rounds is not addressed. A proof of correctness, written also in SPEC, is provided. Our presentation differs from that of <ref> [31] </ref> in the following aspects: it uses the I/O automata models; it provides all the details of the algorithm; it provides a modular description of the algorithm, including auxiliary 48 parts such as a failure detector module and a leader elector module; along with the proof of correctness, it provides a
Reference: [32] <author> B. Lampson, </author> <title> How to build a highly available system using consensus, </title> <booktitle> in Proceedings of the tenth international Workshop on Distributed Algorithms WDAG 96, Bologna, Italy, </booktitle> <pages> pp. 1-15, </pages> <year> 1996. </year>
Reference-contexts: The correctness of each piece is proved by means of invariants, i.e., properties of system states that are always true in an execution. The key invariants we use in our proof are the same as in <ref> [31, 32] </ref>. The time performance and fault-tolerance analysis is conditional on the stabilization of the system behavior starting from some point in an execution. While it is easy to formalize process and channel failures, dealing formally with timing failures is harder. <p> In <ref> [32] </ref> Lampson provides an overview of the paxos algorithm together with the key points for proving the correctness of the algorithm. In [43] the clock synchronization problem has been studied; the solution provided there introduces a new type of GTA, called the mixed automaton model. <p> In <ref> [32] </ref> Lampson provides a brief overview of the paxos algorithm together with the key points for proving the correctness of the algorithm. In [11] three different partially synchronous models are considered.
Reference: [33] <author> E.K. Lee, </author> <title> C.A. Thekkath, Petal: Distributed virtual disks, </title> <booktitle> In Proceedings of the Seventh International Conference on Architectural Support for Programming Languages and Operating Systems, </booktitle> <pages> pp. 84-92, </pages> <address> Cambridge, MA, </address> <month> October </month> <year> 1996. </year>
Reference-contexts: We recently learned that Lee and Thekkath <ref> [33] </ref> used paxos to replicate state information within their Petal systems which implements a distributed file server. In the Petal system several servers each with several disks cooperate to provide to the users a virtual, big and reliable storage unit. Virtual disks can be created and deleted.
Reference: [34] <author> B. Liskov, B. </author> <title> Oki, Viewstamped replication: A new primary copy method to support highly-available distributed systems, </title> <booktitle> in Proceedings of the 7 th Annual ACM Symposium on Principles of Distributed Computing, </booktitle> <pages> pp. 8-17, </pages> <month> August </month> <year> 1988. </year>
Reference-contexts: This is not trivial, since having replicated copies implies that consistency has to be guaranteed and this may result in low fault tolerance. Independent work related to paxos has been carried out. The algorithms in <ref> [11, 34] </ref> have similar ideas. The algorithm of Dwork, Lynch and Stockmeyer [11] also uses rounds conducted by a leader, but the rounds are conducted sequentially, whereas in paxos a leader can start a round at any time and multiple simultaneous leaders are allowed. <p> This is similar to our analysis. (A similar time analysis, applied to a different problem, can be found in [16].) multipaxos can be easily used to implement a data replication algorithm. In <ref> [34] </ref> a data replication algorithm is provided. It incorporates ideas similar to the ones used in paxos. paxos bears some similarities with the standard three-phase commit protocol: both require, in each round, an exchange of 5 messages. <p> In [29] there is also presented a variation of paxos that considers multiple concurrent runs of paxos when consensus has to be reached on a sequence of values. We call this variation the multipaxos algorithm. multipaxos can be easily used to implement a data replication algorithm. In <ref> [34] </ref> a data replication algorithm is provided. It incorporates ideas similar to the ones used in paxos. In the class notes of Principles of Computer Systems [31] taught at MIT, a description of paxos is provided using a specification language called SPEC. <p> The primary copy technique works better in practice if the primary copy does not fail. Complex recovery mechanisms are needed when the primary copy crashes. Various data replication algorithms based on the primary copy technique have been devised (e.g., <ref> [13, 14, 34] </ref>). Replication of the data object raises the issue of consistency among the replicas. These consistency issues depend on what requirements the replicated data has to satisfy. <p> These consistency issues depend on what requirements the replicated data has to satisfy. The strongest possible of such requirements is atomicity: clients accessing the replicated object obtain results as if there was a unique copy. Primary copy algorithms <ref> [1, 34] </ref> and voting algorithms [20, 23] are used to achieve atomicity. Achieving atomicity is expensive; therefore weaker consistency requirements are also considered.
Reference: [35] <author> N. Lynch, </author> <title> Distributed Algorithms, </title> <publisher> Morgan Kaufmann Publishers, </publisher> <address> San Francisco, </address> <year> 1996. </year>
Reference-contexts: The termination condition states requirements about the termination of an algorithm that solves the problem (e.g., "each non-faulty process eventually outputs a value"). Distributed consensus has been extensively studied; a good survey of early results is provided in [17]. We refer the reader to <ref> [35] </ref> for a more up-to-date treatment of consensus problems. 1 We remark that the words "process" and "processor" are often used as synonyms. The word "processor" is more appropriate when referring to a physical component of a distributed system. <p> Section 2.6 describes how automata are composed. 2.1 Overview The I/O automata models are formal models suitable for describing asynchronous and partially synchronous distributed systems. Various I/O automata models have been developed so far (see, for example, <ref> [35] </ref>). The simplest I/O automata model does not consider time and thus it is suitable for describing asynchronous systems. We remark that in the literature this simple I/O automata model is referred to as the "I/O automaton model". <p> Transforming MMTA into Clock GTA. The MMT automata are a special case of GT automata. There is a standard transformation technique that given an MMTA produces an equivalent GTA, i.e., one that has the same external behavior (see Section 23.2.2 of <ref> [35] </ref>). In this section, we show how to transform any MMT automaton (A; b) into an equivalent clock general timed automaton A 0 = clockgen (A; b). <p> collection of automata, output actions of the components become output actions of the composition, internal actions of the components become internal actions of the composition, and actions that are inputs to some components 3 The composition operation for BIOA is defined also for an infinite but countable collection of automata <ref> [35] </ref>, but we only consider the composition of a finite number of automata. 4 We remark that for the composition of an infinite countable collection of automata, there is a third condition on the definition of compatible signature [35]. <p> BIOA is defined also for an infinite but countable collection of automata <ref> [35] </ref>, but we only consider the composition of a finite number of automata. 4 We remark that for the composition of an infinite countable collection of automata, there is a third condition on the definition of compatible signature [35]. However this third condition is automatically satisfied when considering only finite sets of automata. 30 but outputs of none become input actions of the composition. <p> The MMT automaton model was designed by Merritt, Modugno, and Tuttle [42]. More work on the MMT automaton model has been done by Lynch and Attiya [36]. The GT automaton model was introduced by Lynch and Vaandrager [38, 39, 40]. The book by Lynch <ref> [35] </ref> contains a broad coverage of these models and more pointers to the relevant literature. 36 Chapter 3 The distributed setting In this chapter we discuss the distributed setting. We consider a complete network of n processes communicating by exchange of messages in a partially synchronous setting. <p> Sequential consistency has been first defined by Lamport [26]. We base our definition on the one given in [15] which relies on the notion of atomic object [27, 28] (see also <ref> [35] </ref> for a description of an atomic object). Formally a read/update shared object is defined by the set O of the possible states that the object can assume, a distinguished initial state O 0 , and set U of update operations which are functions up : O ! O. <p> In an atomic object, the operations appear "as if" they happened in some sequential order. The idea of "atomic object" originated in [27, 28]. Here we use the formal definition given in Chapter 13 of <ref> [35] </ref>. In a sequentially consistent object the above atomic requirement is weakened by allowing events to be reordered as long as the view of each client i does not change.
Reference: [36] <author> N. Lynch, H. Attiya. </author> <title> Using mappings to prove timing properties. </title> <journal> Distributed Computing, </journal> <volume> 6(2) </volume> <pages> 121-139, </pages> <month> September </month> <year> 1992. </year>
Reference-contexts: The MMT automaton model was designed by Merritt, Modugno, and Tuttle [42]. More work on the MMT automaton model has been done by Lynch and Attiya <ref> [36] </ref>. The GT automaton model was introduced by Lynch and Vaandrager [38, 39, 40]. The book by Lynch [35] contains a broad coverage of these models and more pointers to the relevant literature. 36 Chapter 3 The distributed setting In this chapter we discuss the distributed setting.
Reference: [37] <author> N. Lynch, </author> <title> M.R. Tuttle, An introduction to I/O automata, </title> <journal> CWI-Quarterly, </journal> <volume> 2 (3), </volume> <pages> 219-246, </pages> <address> CWI, Amsterdam, The Netherlands, </address> <month> September 89. </month> <note> Also Technical Memo MIT/LCS/TM-373, </note> <institution> Lab. for Computer Science, MIT, </institution> <address> Cambridge, MA, USA, </address> <month> Nov 88. </month>
Reference-contexts: Input/Output automata are simple state machines with transitions labelled with actions. They are suitable for describing asynchronous and partially synchronous distributed systems. The basic I/O automaton model, introduced by Lynch and Tuttle <ref> [37] </ref>, is suitable for modelling asynchronous distributed systems. For our purposes, we will use the general timed automaton (GTA) model, introduced by Lynch and Vandraager [38, 39, 40], which has formal mechanisms to represent the passage of time and is suitable for modelling partially synchronous distributed systems. <p> However we do not make this extension in this thesis, since for our purposes we do not need the composition of Clock GT automata to be a Clock GTA. 2.7 Bibliographic notes The basic I/O automata was introduced by Lynch and Tuttle in <ref> [37] </ref>. The MMT automaton model was designed by Merritt, Modugno, and Tuttle [42]. More work on the MMT automaton model has been done by Lynch and Attiya [36]. The GT automaton model was introduced by Lynch and Vaandrager [38, 39, 40].
Reference: [38] <author> N. Lynch, F. Vaandrager. </author> <title> Forward and backward simulations for timing-based systems. </title> <booktitle> in Real-Time: Theory in Practice, Vol. 600 of Lecture Notes in Computer Science, </booktitle> <publisher> Springer-Verlag, </publisher> <pages> pp. 397-446, </pages> <year> 1992. </year>
Reference-contexts: They are suitable for describing asynchronous and partially synchronous distributed systems. The basic I/O automaton model, introduced by Lynch and Tuttle [37], is suitable for modelling asynchronous distributed systems. For our purposes, we will use the general timed automaton (GTA) model, introduced by Lynch and Vandraager <ref> [38, 39, 40] </ref>, which has formal mechanisms to represent the passage of time and is suitable for modelling partially synchronous distributed systems. The correctness proof uses automaton composition and invariant assertion methods. Composition is useful for representing a system using separate components. <p> The MMT automaton model was designed by Merritt, Modugno, and Tuttle [42]. More work on the MMT automaton model has been done by Lynch and Attiya [36]. The GT automaton model was introduced by Lynch and Vaandrager <ref> [38, 39, 40] </ref>. The book by Lynch [35] contains a broad coverage of these models and more pointers to the relevant literature. 36 Chapter 3 The distributed setting In this chapter we discuss the distributed setting.
Reference: [39] <author> N. Lynch, F. Vaandrager. </author> <title> Forward and backward simulations|Part II: </title> <journal> Timing-based systems. </journal> <note> Technical Memo MIT/LCS/TM-487.b, </note> <institution> Lab. for Computer Science, MIT, </institution> <address> Cambridge, MA, USA, </address> <month> April </month> <year> 1993. </year>
Reference-contexts: They are suitable for describing asynchronous and partially synchronous distributed systems. The basic I/O automaton model, introduced by Lynch and Tuttle [37], is suitable for modelling asynchronous distributed systems. For our purposes, we will use the general timed automaton (GTA) model, introduced by Lynch and Vandraager <ref> [38, 39, 40] </ref>, which has formal mechanisms to represent the passage of time and is suitable for modelling partially synchronous distributed systems. The correctness proof uses automaton composition and invariant assertion methods. Composition is useful for representing a system using separate components. <p> The MMT automaton model was designed by Merritt, Modugno, and Tuttle [42]. More work on the MMT automaton model has been done by Lynch and Attiya [36]. The GT automaton model was introduced by Lynch and Vaandrager <ref> [38, 39, 40] </ref>. The book by Lynch [35] contains a broad coverage of these models and more pointers to the relevant literature. 36 Chapter 3 The distributed setting In this chapter we discuss the distributed setting.
Reference: [40] <author> N. Lynch, F. Vaandrager. </author> <title> Actions transducers and timed automata. </title> <type> Technical Memo MIT/LCS/TM-480.b, </type> <institution> Lab. for Computer Science, MIT, </institution> <address> Cambridge, MA, USA, </address> <month> Oct </month> <year> 1994. </year> <month> 141 </month>
Reference-contexts: They are suitable for describing asynchronous and partially synchronous distributed systems. The basic I/O automaton model, introduced by Lynch and Tuttle [37], is suitable for modelling asynchronous distributed systems. For our purposes, we will use the general timed automaton (GTA) model, introduced by Lynch and Vandraager <ref> [38, 39, 40] </ref>, which has formal mechanisms to represent the passage of time and is suitable for modelling partially synchronous distributed systems. The correctness proof uses automaton composition and invariant assertion methods. Composition is useful for representing a system using separate components. <p> The MMT automaton model was designed by Merritt, Modugno, and Tuttle [42]. More work on the MMT automaton model has been done by Lynch and Attiya [36]. The GT automaton model was introduced by Lynch and Vaandrager <ref> [38, 39, 40] </ref>. The book by Lynch [35] contains a broad coverage of these models and more pointers to the relevant literature. 36 Chapter 3 The distributed setting In this chapter we discuss the distributed setting.
Reference: [41] <author> C. Mohan, B. Lindsay, R. Obermarck, </author> <title> Transaction Management in R* Distributed Database Management System, </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> Vol. 11, No. 4, </volume> <pages> pp. 378-396, </pages> <month> December </month> <year> 1986. </year>
Reference-contexts: This is really important in practice, since in the presence of failures it is practically not possible to provide a 132 reliable leader elector (this is due to the difficulty of detecting failures). Consensus algorithms currently used in practice are based on the 2-phase commit algorithm (e.g., <ref> [2, 25, 41, 48] </ref>, see also [22]) and sometime on the 3-phase commit algorithm (e.g. [47, 48]). The 2-phase commit protocol is not at all fault tolerant.
Reference: [42] <author> M. Merritt, F. Modugno, </author> <title> and M.R. Tuttle. Time constrained automata. </title> <booktitle> CONCUR 91: 2nd International Conference on Concurrency Theory, Vol. 527 of Lecture Notes in Computer Science, </booktitle> <publisher> Springer-Verlag, </publisher> <pages> pp. 408-423, </pages> <year> 1991. </year>
Reference-contexts: The MMT automaton model was designed by Merritt, Modugno, and Tuttle <ref> [42] </ref>. More work on the MMT automaton model has been done by Lynch and Attiya [36]. The GT automaton model was introduced by Lynch and Vaandrager [38, 39, 40].
Reference: [43] <author> B. Patt, </author> <title> A theory of clock synchronization, </title> <type> Ph.D. Thesis, </type> <institution> Laboratory for Computer Science, Massachusetts Institute of Technology, </institution> <address> Cambridge, MA 02139, </address> <month> Oct </month> <year> 1994. </year>
Reference-contexts: In [32] Lampson provides an overview of the paxos algorithm together with the key points for proving the correctness of the algorithm. In <ref> [43] </ref> the clock synchronization problem has been studied; the solution provided there introduces a new type of GTA, called the mixed automaton model. The mixed automaton is similar to our Clock automaton with respect to the fact that both try to formally handle the local clocks of processes.
Reference: [44] <author> B. Patt-Shamir, S. Rajsbaum, </author> <title> A theory of clock synchronization, </title> <booktitle> in Proceedings of the 26 th Symposium on Theory of Computing, </booktitle> <month> May </month> <year> 1994. </year>
Reference: [45] <author> M. Pease, R. Shostak, L. Lamport, </author> <title> Reaching agreement in the presence of faults, </title> <journal> Journal of the ACM 27 (2), </journal> <pages> 228-234, </pages> <month> April </month> <year> 1980. </year>
Reference: [46] <author> D. Skeen, D.D. Wright, </author> <title> Increasing availability in partitioned database systems, </title> <type> TR 83-581, </type> <institution> Dept. of Computer Science, Cornell University, </institution> <month> Mar </month> <year> 1984. </year>
Reference: [47] <author> D. Skeen, </author> <title> Nonblocking Commit Protocols. </title> <booktitle> Proceedings of the ACM SIGMOD International Conference on Management of Data, </booktitle> <pages> pp. 133-142, </pages> <month> May </month> <year> 1981. </year>
Reference-contexts: Consensus algorithms currently used in practice are based on the 2-phase commit algorithm (e.g., [2, 25, 41, 48], see also [22]) and sometime on the 3-phase commit algorithm (e.g. <ref> [47, 48] </ref>). The 2-phase commit protocol is not at all fault tolerant. The reason why it is used in practice is that it is very easy to implement and the probability that failures affect the protocols is low.
Reference: [48] <author> A. Z. Spector, </author> <title> Distributed transaction processing and the Camelot system, </title> <institution> CMU-CS-87-100, Carnegie-Mellon Univ. Computer Science Dept., </institution> <year> 1987. </year>
Reference-contexts: This is really important in practice, since in the presence of failures it is practically not possible to provide a 132 reliable leader elector (this is due to the difficulty of detecting failures). Consensus algorithms currently used in practice are based on the 2-phase commit algorithm (e.g., <ref> [2, 25, 41, 48] </ref>, see also [22]) and sometime on the 3-phase commit algorithm (e.g. [47, 48]). The 2-phase commit protocol is not at all fault tolerant. <p> Consensus algorithms currently used in practice are based on the 2-phase commit algorithm (e.g., [2, 25, 41, 48], see also [22]) and sometime on the 3-phase commit algorithm (e.g. <ref> [47, 48] </ref>). The 2-phase commit protocol is not at all fault tolerant. The reason why it is used in practice is that it is very easy to implement and the probability that failures affect the protocols is low.
Reference: [49] <author> G. Varghese, N. Lynch, </author> <title> A tradeoff between safety and liveness for randomized coordinated attack protocols, </title> <journal> Information and Computation, </journal> <volume> vol 128, </volume> <editor> n. </editor> <month> 1 </month> <year> (1996), </year> <pages> pp. 57-71. </pages> <booktitle> Also in Proceedings of the 11 th Annual ACM Symposium on Principles of Distributed Computing, </booktitle> <pages> pp. 241-250, </pages> <address> Vancouver, British Columbia, Canada, </address> <month> August </month> <year> 1992. </year> <month> 142 </month>
References-found: 49

