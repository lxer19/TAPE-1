URL: http://www.eecs.umich.edu/~lauren/Dissertation.ps
Refering-URL: http://www.eecs.umich.edu/~lauren/
Root-URL: http://www.cs.umich.edu
Title: HIERARCHICAL TESTING USING PRECOMPUTED TESTS FOR MODULES  
Author: by Brian Thomas Murray Professor Ronald J. Lomax Professor Trevor N. Mudge John W. Hile, 
Degree: A dissertation submitted in partial fulfillment of the requirements for the degree of Doctor of Philosophy (Computer Science and Engineering) in The  Doctoral Committee: Professor John P. Hayes, Chairman Professor William  
Note: Research Fellow, General Motors  
Date: 1994  
Affiliation: University of Michigan  P. Birmingham  
Abstract-found: 0
Intro-found: 1
Reference: <institution> 205 BIBLIOGRAPHY </institution>
Reference: 1. <author> M. S. Abadir and M. A. Breuer. </author> <title> Test Schedules for VLSI Circuits Having Built-in Test Hardware, </title> <journal> IEEE Trans. Comput., </journal> <volume> Vol. 35, </volume> <pages> pp. 361367, </pages> <month> April </month> <year> 1985. </year>
Reference-contexts: A B ( ) A C ( ) B C ( )= 7 Behavioral statements such as these are often combined into text descriptions of a circuit C A B i 1+ Register A Register B A [3..0] B [3..0] S [3..0] Gates Adder Buses A B S [0] S <ref> [1] </ref> S [2] S [3] S C i+1 S C i+1 S C i+1 S C i+1 8 in a systematic form called a hardware description language (HDL). Note that there is no unique way of constructing behavioral models of this type. <p> An extension to Saturn called PF-TG (Program Fragment Test Generator) was developed by Shir-ley at MIT [88]. PF-TG generates tests by merging statements from precomputed tests, stored as A [0..3] B [0..3] A B S [0] S <ref> [1] </ref> S [2] S [3] S C i+1 S C i+1 S C i+1 S C i+1 21 fragments of test programs complete with loops and conditionals, into a test for the whole circuit using automatic program-writing techniques developed in AI research [8]. <p> For example, the decoder in Figure 2.5h is only partially transparent when , since not all of the inputs are decodedmost map to 0. Some propagation paths with specific transmission properties have been defined. Two of the more important ones are I-mode paths and T-mode paths <ref> [1] </ref>, both of which are fully transparent. is propagated from to without modification along propagation paths with I-modes. is propagated from to either unchanged or inverteda simple transformation, along paths with T-modes. <p> Similarly, the outputs of individual modules here are treated as one bus outside the ILA. In this diagram, we also assume that the outputs of the ( )-bit adder and the full adder contain both A B S [0] S <ref> [1] </ref> S [2] S [3] S C i+1 S C i+1 S C i+1 S C i+1 array. Carry-out Carry-in n 1 I M M n 1 A FA Z C = D1 D D D Di 93 data and control. <p> MUX in1 ctrl out in1 <ref> [1] </ref> MUX in1 ctrl out in1 [2] MUX in1 ctrl out in1 [4] MUX 121 detects all SSL faults in the multiplexer. The first row of corresponds to input data bus ctrl, the second row corresponds to in0, and the third row corresponds to in1. <p> b b a W W W W = R4 R1 W W P P P 165 ctrl in0 out (a) Basic cell: two-input, single-bit multiplexer MUX in1 ctrl out in1 [0] u0 u2 ctrl (b) Four basic cells combined to form a two-input, 4-bit multiplexer MUX in1 ctrl out in1 <ref> [1] </ref> MUX in1 ctrl out in1 [2] MUX in1 ctrl out in1 [4] MUX 166 that corresponds to Figure 5.10. The current value for each block i is in a box at the top of Fig ure 5.12.
Reference: 2. <author> M. Abramovici, M. Breuer, and A. Friedman. </author> <title> Digital Systems Testing and Testable Design, </title> <publisher> Computer Science Press, </publisher> <address> New York, NY, </address> <year> 1990. </year>
Reference-contexts: ICs manufactured using a new process often have many defects and it may take years for a process to mature to the point where the number of defects is negligible <ref> [2] </ref>. Problems of Testing. Testing is costly. It has become one of the most expensive aspects of manufacturing, a fact which has prompted many IC makers to seek testing methods that use cheaper testers, simpler test fixtures, and shorter test sequences. <p> Com 2 puter-aided design (CAD) tools for very large scale integrated (VLSI) circuits have significantly reduced some aspects of design time, but corresponding gains have not been made in the area of test generation, despite the fact that testing has been thoroughly studied for more than thirty years <ref> [2] </ref>. Adequate testing solutions have remained elusive mainly because requirements change as technology and design styles evolve, and because many test problems are truly intractable. The testability of ICs depends on how easily internal nodes of the circuits can be controlled and observed. <p> ( ) A C ( ) B C ( )= 7 Behavioral statements such as these are often combined into text descriptions of a circuit C A B i 1+ Register A Register B A [3..0] B [3..0] S [3..0] Gates Adder Buses A B S [0] S [1] S <ref> [2] </ref> S [3] S C i+1 S C i+1 S C i+1 S C i+1 8 in a systematic form called a hardware description language (HDL). Note that there is no unique way of constructing behavioral models of this type. Recently however, designers have begun to standardize HDL formats. <p> However, tests for these more accurate fault models can be generated and stored for register-level library modules, and later used as precomputed tests. Finally, some circuits, such as RAMs and ROMs, have unique failure modes <ref> [2] </ref>. RAMs for instance, can fail so that certain patterns written to and read back from a particular address will expose a fault, otherwise the fault is not observed. These circuits are usually tested using completely different methods from those used for logic circuits [2]. <p> and ROMs, have unique failure modes <ref> [2] </ref>. RAMs for instance, can fail so that certain patterns written to and read back from a particular address will expose a fault, otherwise the fault is not observed. These circuits are usually tested using completely different methods from those used for logic circuits [2]. Such tests can also be stored as precomputed tests. 1.2.3 Test Generation In principle, it is possible to generate tests without the use of an explicit fault model. <p> If the test generator cannot generate a test for the circuit in r timeframes, add a timeframe and begin test generation again <ref> [2] </ref>, If is unknown, then the algorithm must justify objectives backwards in time, as well as propagating error signals forward in time. <p> An extension to Saturn called PF-TG (Program Fragment Test Generator) was developed by Shir-ley at MIT [88]. PF-TG generates tests by merging statements from precomputed tests, stored as A [0..3] B [0..3] A B S [0] S [1] S <ref> [2] </ref> S [3] S C i+1 S C i+1 S C i+1 S C i+1 21 fragments of test programs complete with loops and conditionals, into a test for the whole circuit using automatic program-writing techniques developed in AI research [8]. <p> This is depicted in Figure 3.3a. In this case, each subfunction vector represents the mapping of values from a single input data port to values on multiple output data ports . Consider again the 3-bit, 2-input multiplexer in = F [(ctrl,in1);out0 [1..0]] and = F [(ctrl,in1);out0 <ref> [2] </ref>]. Then, Alternatively, each subfunction can be defined as , where F X X ,( ) Z ;[ ] W D MUX in1 Z D = out0 [1..0] ctrl X C 1 3 3 2 0,1,2,3,4,5,6,7 outputs at Z D for V (X C ) = 1. <p> Similarly, the outputs of individual modules here are treated as one bus outside the ILA. In this diagram, we also assume that the outputs of the ( )-bit adder and the full adder contain both A B S [0] S [1] S <ref> [2] </ref> S [3] S C i+1 S C i+1 S C i+1 S C i+1 array. Carry-out Carry-in n 1 I M M n 1 A FA Z C = D1 D D D Di 93 data and control. <p> MUX in1 ctrl out in1 [1] MUX in1 ctrl out in1 <ref> [2] </ref> MUX in1 ctrl out in1 [4] MUX 121 detects all SSL faults in the multiplexer. The first row of corresponds to input data bus ctrl, the second row corresponds to in0, and the third row corresponds to in1. <p> Events are scheduled by entering them into a timing wheel <ref> [2] </ref>. An event inherits the layer assignment of v. In MATSim, the layer associated with E determines the update routine that handles it. The routine process_events_at_current_time retrieves all of the events scheduled for the current time and initiates the appropriate action for each, depending on event type and layer. <p> A skeleton update routine is shown in Figure 5.7. Specialized versions of this routine exist for each layer. The update method is based on the one-pass evaluation strategy with suppression of multiple signal changes scheduled for the same time <ref> [2] </ref>. As noted above, the routine implements the value changes specified by an event . First, it assigns the value v (denoted event_value in Figure 5.7) to the bus Z (denoted event_bus in Figure 5.7). <p> W = R4 R1 W W P P P 165 ctrl in0 out (a) Basic cell: two-input, single-bit multiplexer MUX in1 ctrl out in1 [0] u0 u2 ctrl (b) Four basic cells combined to form a two-input, 4-bit multiplexer MUX in1 ctrl out in1 [1] MUX in1 ctrl out in1 <ref> [2] </ref> MUX in1 ctrl out in1 [4] MUX 166 that corresponds to Figure 5.10. The current value for each block i is in a box at the top of Fig ure 5.12.
Reference: 3. <author> Advanced Micro Devices. </author> <title> The Am2910, A Complete 12-bit Microprogram Sequence Controller, in AMD Data Book, </title> <address> Sunnyvale, CA, </address> <publisher> AMD Inc., </publisher> <year> 1978. </year>
Reference-contexts: A C ( ) B C ( )= 7 Behavioral statements such as these are often combined into text descriptions of a circuit C A B i 1+ Register A Register B A [3..0] B [3..0] S [3..0] Gates Adder Buses A B S [0] S [1] S [2] S <ref> [3] </ref> S C i+1 S C i+1 S C i+1 S C i+1 8 in a systematic form called a hardware description language (HDL). Note that there is no unique way of constructing behavioral models of this type. Recently however, designers have begun to standardize HDL formats. <p> An extension to Saturn called PF-TG (Program Fragment Test Generator) was developed by Shir-ley at MIT [88]. PF-TG generates tests by merging statements from precomputed tests, stored as A [0..3] B [0..3] A B S [0] S [1] S [2] S <ref> [3] </ref> S C i+1 S C i+1 S C i+1 S C i+1 21 fragments of test programs complete with loops and conditionals, into a test for the whole circuit using automatic program-writing techniques developed in AI research [8]. <p> In [58], they compare the performance of the first version of ARTEST to a gate-level test generator HITEC [72]. Using both programs, they generate tests for a version of the Am2910 microprogram sequencer <ref> [3] </ref>. ARTEST uses 61.75 CPU seconds to generate a test compared with 2,297 seconds for HITECa speedup factor of 37.6. ARTEST performs well for several circuits that contain global feedback loops and reconvergent fanout. However, all circuits tested have a very regular bus structure. <p> Similarly, the outputs of individual modules here are treated as one bus outside the ILA. In this diagram, we also assume that the outputs of the ( )-bit adder and the full adder contain both A B S [0] S [1] S [2] S <ref> [3] </ref> S C i+1 S C i+1 S C i+1 S C i+1 array. Carry-out Carry-in n 1 I M M n 1 A FA Z C = D1 D D D Di 93 data and control.
Reference: 4. <author> A. Akritas. </author> <title> Elements of Computer Algebra with Applications, </title> <publisher> John Wiley and Sons, </publisher> <address> New York, NY, </address> <year> 1989. </year>
Reference-contexts: We want to determine symbolically if (4.1) is equivalent to using an algorithm. To solve this problem, we turn to the field of computer algebra <ref> [4, 22, 74] </ref>, where mathematical formulas are manipulated symbolically. Maple [38] and Mathematica [102] are examples of programs that embody these techniques. To manipulate symbolic formulas algorithmically, it is usually necessary to convert them to a standard or canonical form. Arbitrary formulas are then simplified to match the standard form. <p> MUX in1 ctrl out in1 [1] MUX in1 ctrl out in1 [2] MUX in1 ctrl out in1 <ref> [4] </ref> MUX 121 detects all SSL faults in the multiplexer. The first row of corresponds to input data bus ctrl, the second row corresponds to in0, and the third row corresponds to in1. <p> P P P 165 ctrl in0 out (a) Basic cell: two-input, single-bit multiplexer MUX in1 ctrl out in1 [0] u0 u2 ctrl (b) Four basic cells combined to form a two-input, 4-bit multiplexer MUX in1 ctrl out in1 [1] MUX in1 ctrl out in1 [2] MUX in1 ctrl out in1 <ref> [4] </ref> MUX 166 that corresponds to Figure 5.10. The current value for each block i is in a box at the top of Fig ure 5.12.
Reference: 5. <author> V. D. Agrawal, K. T. Cheng, and P. Agrawal. </author> <title> CONTEST: A Concurrent Test Generator for Sequential Circuits, </title> <booktitle> Proc. 25th Design Automation Conf., </booktitle> <pages> pp. 8489, </pages> <month> June </month> <year> 1988. </year>
Reference-contexts: Another approach to sequential test generation is to randomly generate vectors from a given seed or set of seeds and fault-simulate them to determine their fitness for a test program according to a given cost metric. This approach is typified by the following algorithm <ref> [5] </ref>: (a) Combinational Comb. ip Pseudo Z (t ) ...
Reference: 6. <author> A. V. Aho, R. Sethi, and J. D. Ullman. </author> <booktitle> Compilers, Principles, Techniques, and Tools, </booktitle> <address> Addi-son-Wesley, Reading, MA, </address> <year> 1986. </year>
Reference: 7. <author> H. Ando. </author> <title> Testing VLSI With Random Access Scan, </title> <booktitle> in Comcon 80, </booktitle> <year> 1980. </year>
Reference-contexts: Therefore, connecting all memory modules of a circuit into a scan chain obviates the need for sequential test generation. There are many variations on the basic theme of scan design <ref> [7, 35, 92] </ref>. The most important design issue is whether to include all ip-op elements in scan chains (full scan) or only some of them (partial scan).
Reference: 8. <author> D. R. Barstow. </author> <title> Knowledge Based Program Construction. </title> <publisher> Elsevier North Holland, Inc., </publisher> <address> New York, NY, </address> <year> 1979. </year>
Reference-contexts: [0..3] B [0..3] A B S [0] S [1] S [2] S [3] S C i+1 S C i+1 S C i+1 S C i+1 21 fragments of test programs complete with loops and conditionals, into a test for the whole circuit using automatic program-writing techniques developed in AI research <ref> [8] </ref>. Its overall algorithm and circuit model are the same as Saturns, but propagation and justification through modules is accomplished explicitly by knowledge stored in a library. The technique is completely heuristic, and dependent on the test programmers skill in writing the test fragments for control and observation.
Reference: 9. <editor> F. Beenker et al. </editor> <title> A Testability Strategy for Silicon Compilers, </title> <booktitle> in Proc. Int. Test Conf., </booktitle> <pages> pp. 660668, </pages> <year> 1989. </year>
Reference-contexts: Very long scan chains can also be slow to load and unload during testing. Hierarchical approaches to design for testability are just beginning to appear <ref> [9, 12, 19, 26, 51, 61, 73, 82] </ref>. Some of these identify registers for partial scan by analyzing behavioral descriptions [19], while others seek to modify behavioral descriptions to avoid optimizations that create unnecessary loops [61]. Bhattacharya studied modifications to individual register-level modules to improve their testability [12]. <p> Bhattacharya studied modifications to individual register-level modules to improve their testability [12]. Finally, several hierarchical DFT techniques seek to ensure direct controllability and observability of every module <ref> [9, 26, 51, 73, 82] </ref>. Since abstract high-level representations of circuits are developed first and gate-level details are added later, hierarchical testability techniques can be introduced early in the design process. <p> This important capability is the main strategy in a number of experimental test generators <ref> [9, 58, 59, 68, 88, 93] </ref>. Currently evolving design styles, which rely heavily on CAD tools, are making this capability very desirable. Designers often reuse modules that have been stored in a library, and many of these modules do not have accurate gate-level models for test generation purposes. <p> In a circuit with a regular bus structure, all buses in the primary data path have a constant width n; no buses are truncated to smaller sizes. Since the initial development of PathPlan, several other experiments in test generation using precomputed tests have been published. In <ref> [9] </ref>, Beenker et al. of Philips describe their work on a test generation approach that relies heavily on special DFT techniques. The SPHINX tool box (later renamed Panther and marketed commercially) works in concert with the design system. <p> Propagation of test information through other modules is minimized; Panther is not designed to propagate the precom-puted tests through modules other than scan chains. No new general principles of hierarchical test generation are developed in Panther. Test generation becomes a matter of scheduling tests to be applied. In <ref> [9] </ref>, Beenker et al. describe how 36c c c c 24 their approach is applied to an error-correction circuit with 225,000 transistors [103], thus further demonstrating the practicality of precomputed tests for commercial circuits. The performance of Panther in testing this chip is impressive. <p> The performance of Panther in testing this chip is impressive. The test for the entire chip was generated in about 2 hours, which includes the time (80 minutes) to hierarchically generate tests for two programmable logic units which are then used as precomputed tests. It is claimed <ref> [9] </ref> that the DFT logic adds only about 8 percent to the chip area, however, the design style enforced by the CAD system naturally provides high controllability and observability and is not practical for all applications. <p> In general, the field of hierarchical test generation is still in its infancy. Hierarchical test generation techniques that can use precomputed tests <ref> [9, 58, 59, 68, 88, 93] </ref> have two particular advantages: (1) tests can be generated using multiple fault models for the same circuit, including the SSL fault model, as well as more accurate and technology-specific fault models; (2) tests that exist for previously designed modules can be reused when it is <p> In particular, full and partial scan design can be used to provide controllability and observability thus making circuits easier to test. In addition, direct access to modules can be provided by routing internal buses through special multiplexers. Variations on these techniques are used in <ref> [9, 26, 51, 82, 73] </ref>. An alternative approach to improving circuit observability for propagation is to modify non-transparent modules to increase their transparency; we will discuss this approach in Chapter IV. 2.6. <p> One technique for designing circuits that can easily propagate , is to route test points to primary outputs, perhaps through multiplexers [83]. Another technique is to use a hierarchical form of scan or boundary scan to ensure adequate observability <ref> [9] </ref>. These techniques lead to high routing overhead and highly constrained design styles. Both approaches provide additional paths for routing . An alternative approach is to modify modules on the normal data paths of the circuit to make them more transparent, that is, to synthesize transparent modules.
Reference: 10. <author> R. G. Bennetts et al. </author> <title> A Modular Approach to Test Sequence Generation for Large Digital Networks, </title> <booktitle> Digital Processes, </booktitle> <pages> pp. 323, </pages> <year> 1975. </year>
Reference-contexts: The more important hierarchical techniques will be reviewed in Section 1.3. Although hierarchical test generation techniques have been proposed since the mid-1970s <ref> [10] </ref>, only recently have they become practical to use, as design styles have evolved to the point where hierarchical design is well-supported. New CAD tools are able to synthesize gate and circuit-level simulation models from higher-level models [32, 95].
Reference: 11. <author> M. Bershteyn. </author> <title> Sequential Test Generation Tool for Embedded Cells, </title> <booktitle> in Proc. Workshop on Hierarchical Test Generation, Blacksburg, </booktitle> <address> VA, </address> <month> August 8-11, </month> <year> 1993. </year>
Reference-contexts: Performance results for most other circuits in Table 1.1 are similar. An approach similar to, and partly based on PathPlan has subsequently been implemented by Mitsubishi and used to test several circuits <ref> [11] </ref>. Despite this success, PathPlan is a preliminary system with a limited ability to propagate high-level signals. The propagation techniques used by PathPlan cannot handle general reconvergent fanout, or any irregularities in bus structure. <p> It has not been used to test commercial circuits, however, a similar program partly based on PathPlan has been used for production testing <ref> [11] </ref>. Our work developing PathPlan, as well as the work to develop necessary extensions to it, form the basis for this thesis. PathPlan propagates symbolic references to vector sequences representing and through circuit models using an algorithm similar to the D-algorithm.
Reference: 12. <author> D. Bhattacharya and J. P. Hayes. </author> <title> Hierarchical Modeling for VLSI Circuit Testing, </title> <publisher> Kluwer Academic Publishers, </publisher> <address> Boston, MA, </address> <year> 1990. </year>
Reference-contexts: These effects include such symptoms as register decoding errors, and data transfer errors. Other higher-level fault models are extensions of the SSL fault model. For example, Bhattacharya and Hayes <ref> [12] </ref> extended the SSL fault model to include all bits of a bus, leading to the concept of bus faults. <p> Very long scan chains can also be slow to load and unload during testing. Hierarchical approaches to design for testability are just beginning to appear <ref> [9, 12, 19, 26, 51, 61, 73, 82] </ref>. Some of these identify registers for partial scan by analyzing behavioral descriptions [19], while others seek to modify behavioral descriptions to avoid optimizations that create unnecessary loops [61]. Bhattacharya studied modifications to individual register-level modules to improve their testability [12]. <p> Some of these identify registers for partial scan by analyzing behavioral descriptions [19], while others seek to modify behavioral descriptions to avoid optimizations that create unnecessary loops [61]. Bhattacharya studied modifications to individual register-level modules to improve their testability <ref> [12] </ref>. Finally, several hierarchical DFT techniques seek to ensure direct controllability and observability of every module [9, 26, 51, 73, 82]. Since abstract high-level representations of circuits are developed first and gate-level details are added later, hierarchical testability techniques can be introduced early in the design process. <p> This behavior was empirically observed by Chandra and Patel [18]. Bhattacharya and Hayes defined a test generation methodology that uses high-level interconnections (buses) and fault models in addition to high-level modules <ref> [12] </ref>. Faults in this model affect all bits of a bus. A bus is totally stuck-at-0 if all bits are stuck at logic level 0, and totally stuck-at-1 if all lines are stuck at logic level 1. <p> In many such cases, it can be shown that a test generated for a total bus fault in the high-level model is guaranteed to detect all SSL faults on corresponding lines in a gate-level model of the circuit. Experiments conducted with medium scale ICs <ref> [12] </ref> suggest that tests generated for total bus faults in the high-level model detect more than 70 percent of the SSL faults in the corresponding gate-level model. <p> Moreover, using VPODEM and a gate-level model of the same circuit, we can still obtain 100 percent SSL fault coverage by generating tests for SSL faults not detected by tests for total bus faults. The circuit model used by Bhattacharya and Hayes <ref> [12] </ref> does not correspond directly to the circuit model as entered into a design system, so some work is required to construct the higher-level testing model. Moreover, the approach does not take full advantage of function and data abstractions in the original circuit, that is, its inherent high-level function. <p> Thus, they do not realize the full potential of high-level error propagation because of the low-level interconnection structure. Other hierarchical testing techniques use higher-level models and bus-level interconnection structures, but use high-level fault models that are difficult to relate to more precise and well-accepted models <ref> [12, 64] </ref>. Still other techniques are based almost entirely on heuristics, so no generally applicable principles of test generation have been developed for them [88, 89]. <p> When generating a test, we must ensure that every produces a different value than at a primary output, that is, propagate the error. In contrast, to control complexity most conventional test generators consider only a small number of the possible error values. For example, VPODEM <ref> [12] </ref> uses only two fixed error values: the all-zero vector (due to a bus totally-stuck-at-0) and the all-one vector (due to a bus totally-stuck-at-1). These errors are produced as a result of assumed faults on lines and buses according to the VPODEM fault model. <p> Vertdp has two registers, an inverting buffer, an adder, and a multiplexer. Rowdp has one register, an inverting buffer, two adders, and two multiplexers. Both can be tested completely by a test generated by Pathplan. Alu is a high-level model of the 74181 ALU/function generator described in <ref> [12] </ref>. Most of the modules in the high-level model employed by Alu are word gates. Finally, Progptr1 and Progptr2 are circuits used in a control unit. <p> Most circuits composed of high-level modules can be modeled as directed graphs in which modules are edges and connections are vertices, since most modules are unidirectional. Even circuits with tristate buses can often be modeled as directed graphs for particular operation cycles <ref> [12] </ref>. Since all connections in a directed graph can be treated as series or parallel connections (see Appendix A), we can model the behavior of the circuits of interest using operations based on just these two fundamental types of connections. <p> Most datapath circuits can be modeled as directed graphs, since most modules are unidirectional. Even circuits with tristate buses can often be modeled as directed graphs for particular operation cycles <ref> [12] </ref>. Therefore, most datapath circuits can be analyzed as a set of edges con nected in series and parallel. 198 APPENDIX B Propagation Algebra The propagation algebra describes the behavior of propagation functions in the same way that a Boolean algebra describes Boolean logic.
Reference: 13. <author> D. Bhattacharya, B. T. Murray, and J. P. Hayes. </author> <title> High-Level Test Generation for VLSI, </title> <journal> IEEE Computer, </journal> <volume> Vol. 22, </volume> <pages> pp. 1624, </pages> <month> April </month> <year> 1989. </year>
Reference-contexts: Flip-op 18 have been proposed, most of which simply address test generation. These range from well-defined extensions of gate-level algorithms to largely heuristic approaches inuenced by research in artificial intelligence <ref> [13] </ref>. High-level Models. Several of the proposed hierarchical techniques model the circuit in terms of high-level functional blocks interconnected by single-bit lines. The fault models can allow for arbitrary faults in these blocks, and the test generation algorithms used may be simple extensions of the classical ones described above.
Reference: 14. <author> G. Birkhoff. </author> <title> Lattice Theory, </title> <publisher> American Mathematical Society, </publisher> <address> Providence, Rhode Island, </address> <year> 1960. </year>
Reference-contexts: The lattice of partitions lacks these properties and is consequently not as special and well-studied as the Boolean algebras. Nevertheless, a number of useful theorems have been derived for general lattices <ref> [14, 42] </ref>. Let = ( , *, +) and = ( , *, +) be two algebras with sets and respectively, and binary operations * and +. is homomorphic to if and only if there exists an onto mapping , such that and , for any two elements .
Reference: 15. <author> D. Brahme and J. A. Abraham. </author> <title> Functional Testing of Microprocessors, </title> <journal> IEEE Trans. Com-put., </journal> <volume> Vol. 33, </volume> <pages> pp. 475485, </pages> <year> 1984. </year>
Reference: 16. <author> M. A. Breuer and A. D. Friedman. </author> <title> Diagnosis and Reliable Design of Digital Systems. </title> <publisher> Computer Science Press, </publisher> <address> Rickville, Maryland, </address> <year> 1976. </year>
Reference-contexts: Finally, the typical approach (described above) of extending gate-level combinational algorithms to handle sequential circuits has worst-case complexity , where m is the number of state variables <ref> [16] </ref>. We see from this that if all else is equal, reducing the number of modules in the circuit by increasing the abstraction level should decrease test generation complexity. Fault Simulation. <p> We commonly separate test packages into two main types: those containing test data for module faults called fault test packages (FTPs), and those containing propagation information for modules called propagation test packages (PTPs). These may be loosely compared to the fault D-cubes and propagation D-cubes of classical testing theory <ref> [16] </ref>. The test package for the multiplexer described above is an example of a FTP. PTPs define functions mapping specific inputs to outputs for the purposes of propagating test information. In a test package of the form , or may be vector sequences associated with several ports.
Reference: 17. <author> R. E. Bryant. </author> <title> Graph-Based Algorithms for Boolean Function Manipulation, </title> <journal> IEEE Trans. Comput., </journal> <volume> Vol. 35, </volume> <pages> pp. 677691, </pages> <month> August </month> <year> 1986. </year>
Reference: 18. <author> S. J. Chandra and J. H. Patel. </author> <title> A Hierarchical Approach to Test Vector Generation in Proc. </title> <booktitle> 24th Design Automation Conf., </booktitle> <pages> pp. 495501, </pages> <year> 1987. </year> <month> 206 </month>
Reference-contexts: The fault models can allow for arbitrary faults in these blocks, and the test generation algorithms used may be simple extensions of the classical ones described above. Somenzi et al. [90] described such a technique based on the D-algorithm, Chandra and Patel <ref> [18] </ref> proposed a similar technique based on PODEM, and more recently, SOCRATES [84] has included higher-level primitives. The fundamental advantage of higher-level modules is that there are fewer of them in the circuit to evaluate. <p> In addition, the algorithm has an exponential number of choices at each module, so there is a potential for excessive backtracking. This behavior was empirically observed by Chandra and Patel <ref> [18] </ref>. Bhattacharya and Hayes defined a test generation methodology that uses high-level interconnections (buses) and fault models in addition to high-level modules [12]. Faults in this model affect all bits of a bus. <p> However, current techniques have many drawbacks, and so have not been widely implemented. Some of these techniques make use of the hierarchical modules of typical circuits, but retain a bit-level interconnection structure and related fault models <ref> [18, 90] </ref>. Thus, they do not realize the full potential of high-level error propagation because of the low-level interconnection structure. Other hierarchical testing techniques use higher-level models and bus-level interconnection structures, but use high-level fault models that are difficult to relate to more precise and well-accepted models [12, 64].
Reference: 19. <author> C-H Chen, T. Karnik, and D. G. Saab. </author> <title> Structural and Behavioral Synthesis for Testability Techniques, </title> <journal> IEEE Trans. Computer-Aided Design, </journal> <volume> Vol. 13, </volume> <pages> pp. 777785, </pages> <month> June </month> <year> 1994. </year>
Reference-contexts: Very long scan chains can also be slow to load and unload during testing. Hierarchical approaches to design for testability are just beginning to appear <ref> [9, 12, 19, 26, 51, 61, 73, 82] </ref>. Some of these identify registers for partial scan by analyzing behavioral descriptions [19], while others seek to modify behavioral descriptions to avoid optimizations that create unnecessary loops [61]. Bhattacharya studied modifications to individual register-level modules to improve their testability [12]. <p> Very long scan chains can also be slow to load and unload during testing. Hierarchical approaches to design for testability are just beginning to appear [9, 12, 19, 26, 51, 61, 73, 82]. Some of these identify registers for partial scan by analyzing behavioral descriptions <ref> [19] </ref>, while others seek to modify behavioral descriptions to avoid optimizations that create unnecessary loops [61]. Bhattacharya studied modifications to individual register-level modules to improve their testability [12]. Finally, several hierarchical DFT techniques seek to ensure direct controllability and observability of every module [9, 26, 51, 73, 82].
Reference: 20. <author> D. R. Coelho. </author> <title> The VHDL Handbook, </title> <publisher> Kluwer Academic Publishers, </publisher> <address> Boston, MA, </address> <year> 1989. </year>
Reference-contexts: Note that there is no unique way of constructing behavioral models of this type. Recently however, designers have begun to standardize HDL formats. VHDL (the VHSIC Hardware Description Language <ref> [20] </ref>) has been mandated as a standard by the United States Government. Structural descriptions are modeled in HDLs as a list of wires and the corresponding modules they connect to; this is known as a netlist. <p> Test Packages. We refer to the information unit containing all test, propagation, and control information for a module or circuit as a test package. Test packages are the elements of the module library used for testing by the precomputed test method. Like packages in the hardware description language VHDL <ref> [20] </ref>, they hide and abstract information. The simplest form is the stimulus/ response pair , where and are, in general, vector sequences. A test package exhibits the same hierarchical structure as the underlying vector sequences.
Reference: 21. <author> D. Cohen. </author> <title> On Holy Wars and a Plea for Peace, </title> <journal> IEEE Computer, </journal> <volume> Vol. 14, </volume> <pages> pp. 4854, </pages> <month> Octo-ber </month> <year> 1981. </year>
Reference-contexts: Individual subsets of bus lines are described using standard array notation; for example, if , then The most significant bit of an n-bit bus is X [n-1]. This is commonly referred to as Big Endian notation <ref> [21] </ref>. The signal value associated with a bus or port X is denoted and the set of all possible values that can be assigned to X is denoted by . Specific values on multi-bit buses are represented as binary (marked with a subscript 2) or decimal numbers.
Reference: 22. <author> J. H. Davenport, Y. Siret, and E. Tournier. </author> <title> Computer Algebra: Systems and Algorithms for Algebraic Computation, </title> <publisher> Academic Press, </publisher> <address> San Diego, CA, </address> <year> 1988. </year>
Reference-contexts: We want to determine symbolically if (4.1) is equivalent to using an algorithm. To solve this problem, we turn to the field of computer algebra <ref> [4, 22, 74] </ref>, where mathematical formulas are manipulated symbolically. Maple [38] and Mathematica [102] are examples of programs that embody these techniques. To manipulate symbolic formulas algorithmically, it is usually necessary to convert them to a standard or canonical form. Arbitrary formulas are then simplified to match the standard form. <p> Unfortunately, there is no general agreement on what the standard form should be. However, we can follow some typical guidelines to obtain a standard form for symbolic expressions that allow us to symbolically match PEs to components of <ref> [22] </ref>. First we consider the requirements of a canonical symbolic expression; a representation of a propagation function. Let F be a set of functions and E be a set of expressions. <p> The canonical expressions have the same form as multi-variable polynomials with rational coefficients <ref> [22] </ref>. Each term of the expression can contain multiple vector-sequence variables as well as a rational coefficient, in this case, a fraction with denominator . A typical multi-variable PE is , where , , and are vector sequences and multiplication is represented by juxtaposition.
Reference: 23. <author> R. J. Duffin. </author> <title> Topology of Series-Parallel Networks, </title> <journal> Journal of Mathematical Analysis and Applications, </journal> <volume> Vol. 10, </volume> <pages> pp. 303318, </pages> <year> 1965. </year>
Reference-contexts: Two edges and are conuent if there do not exist two circuits and , each containing edges and , such that the direction imposed on exactly one of the two edges is reversed between and <ref> [23] </ref>. A graph is conuent if all its edges are conuent. Consider the graph G in Figure A.3, and consider the circuits = ( , , , , , , , , ), and . The direction of both and through edge is the same, namely . <p> However, the direction of through is , while the direction of through is . Therefore, G is not con-uent. In electrical circuit theory, where edges represent resistors or batteries, G is called a Wheatstone bridge. No graph with an embedded Wheatstone bridge is conuent <ref> [23] </ref>. On the other hand, directed graphs are all conuent, because the directions of the edges are already fixed; circuits must conform to the fixed direction in order to be valid. If a graph has no circuit, then it is trivially conuent. According to Duffin [23], every edge in a conuent <p> embedded Wheatstone bridge is conuent <ref> [23] </ref>. On the other hand, directed graphs are all conuent, because the directions of the edges are already fixed; circuits must conform to the fixed direction in order to be valid. If a graph has no circuit, then it is trivially conuent. According to Duffin [23], every edge in a conuent graph is part of a series-parallel con e n n ,( )= n n n e n e e n , , , , , , e n n e n n e e C C e e C C n n n n e
Reference: 24. <author> J. R. </author> <title> Durbin. Modern Algebra, </title> <publisher> John Wiley & Sons, </publisher> <address> New York, NY, </address> <year> 1979. </year>
Reference: 25. <author> E. B. Eichelberger and T. W. Williams. </author> <title> A Logic Design Structure for LSI Testability, </title> <booktitle> in Proc. 14th Design Automation Conf., </booktitle> <pages> pp. 462468, </pages> <year> 1977. </year>
Reference-contexts: Many companies compile long lists of such design for testability (DFT) rules. However, this ad hoc approach adds considerably to the designers burden and may still not provide satisfactory testability. A contrasting approach is systematic DFT. The basic idea of the most common systematic technique, scan design <ref> [25] </ref>, is the separation of memory modules from combinational modules during testing. Memory modules, e.g. ip-ops, are chained together into a shift register or scan chain when a special test mode is activated.
Reference: 26. <author> M. Emori et al. </author> <title> ASIC CAD System Based on Hierarchical Design-for-Testability, </title> <booktitle> in Proc. IEEE Int. Test Conf., </booktitle> <pages> pp. 404409, </pages> <year> 1990. </year>
Reference-contexts: Very long scan chains can also be slow to load and unload during testing. Hierarchical approaches to design for testability are just beginning to appear <ref> [9, 12, 19, 26, 51, 61, 73, 82] </ref>. Some of these identify registers for partial scan by analyzing behavioral descriptions [19], while others seek to modify behavioral descriptions to avoid optimizations that create unnecessary loops [61]. Bhattacharya studied modifications to individual register-level modules to improve their testability [12]. <p> Bhattacharya studied modifications to individual register-level modules to improve their testability [12]. Finally, several hierarchical DFT techniques seek to ensure direct controllability and observability of every module <ref> [9, 26, 51, 73, 82] </ref>. Since abstract high-level representations of circuits are developed first and gate-level details are added later, hierarchical testability techniques can be introduced early in the design process. <p> Panther provides the tools to implement the scan chains and test controllers hierarchically. When the design is completed, every test stimulus vector can be applied directly to every module via scan chains and buses. Similar techniques were also proposed in <ref> [26, 51,73, 82] </ref>. Propagation of test information through other modules is minimized; Panther is not designed to propagate the precom-puted tests through modules other than scan chains. No new general principles of hierarchical test generation are developed in Panther. Test generation becomes a matter of scheduling tests to be applied. <p> In particular, full and partial scan design can be used to provide controllability and observability thus making circuits easier to test. In addition, direct access to modules can be provided by routing internal buses through special multiplexers. Variations on these techniques are used in <ref> [9, 26, 51, 82, 73] </ref>. An alternative approach to improving circuit observability for propagation is to modify non-transparent modules to increase their transparency; we will discuss this approach in Chapter IV. 2.6.
Reference: 27. <author> Epoch Finesse User and Reference Manual, </author> <title> Cascade Design Automation, </title> <address> Bellevue, WA, </address> <year> 1993. </year>
Reference-contexts: Clearly, modifying a module to include a k-transparent test mode can significantly increase its size. The Finesse automatic logic synthesis program from Cascade Design Automation <ref> [27] </ref> was used to obtain the results for dec1.1 and dec1.2 using the standard parameters of the program; no effort was made to minimize the overheadwe are only interested in the relative performance of the OTF and EM methods.
Reference: 28. <author> K. E. Erickson. </author> <title> A New Operation for Analyzing Series-Paralled Networks, </title> <journal> IRE Trans. Circuit Theory, </journal> <pages> pp. 124126, </pages> <month> March </month> <year> 1959. </year>
Reference-contexts: If and are connected in parallel, then the admittance of the combination is given by . If and are connected in series, then their combined admittance is given by . (3.3) If we define a reduced sum operation * as , then we can express equation (3.3) as <ref> [28] </ref>. We now have a parallel connection operation + and a series connection operation * for admittances. Propagation functions represent information transmission properties of modules and circuits that are analogous to admittances, which represent electrical current transmission capability.
Reference: 29. <author> F. J. Ferguson and J. P. Shen. </author> <title> A CMOS Fault Extractor for Inductive Fault Analysis, </title> <journal> IEEE Trans. Computer-Aided Design, </journal> <volume> Vol. 7, </volume> <pages> pp. 11811194, </pages> <month> November, </month> <year> 1988. </year>
Reference-contexts: The second type is the bridging fault, where 10 physically separate wires in a circuit are connected by a fault. By modeling the effect of manufacturing defects on layout, Ferguson and Shen were able to inductively show that the most likely CMOS fault is a bridge between adjacent wires <ref> [29] </ref>. Modeling delay and bridging faults can result in better quality tests, but test generation procedures for them are much more complex than for SSL faults. However, tests for these more accurate fault models can be generated and stored for register-level library modules, and later used as precomputed tests.
Reference: 30. <author> S. Freeman. </author> <title> Test Generation for Data-Path Logic: The F-Path Method. </title> <journal> IEEE Journal of Solid-State Circuits, </journal> <volume> Vol. 23, </volume> <pages> pp. 421427, </pages> <month> April </month> <year> 1988. </year>
Reference-contexts: For example, Multiplexer 1 (Figure 2.5d) is transparent when . The concept of transparency is also defined similarly by Marhfer [66], and the path from to through a transparent module is called an F-path by Freeman <ref> [30] </ref>. M is partially transparent if for some , is distinguished from due to at least one . In this case, some changes at can be distinguished at , but not all.
Reference: 31. <author> A. D. Friedman. </author> <title> Easily Testable Iterative Systems, </title> <journal> IEEE Trans. Comput., </journal> <volume> Vol. 22, No. 12, </volume> <pages> pp. 10611064, </pages> <month> December, </month> <year> 1973. </year>
Reference: 32. <author> T. E. Fuhrman. </author> <title> Industrial Extensions to University High Level Synthesis Tools: Making It Work in the Real World, </title> <booktitle> in Proc. 28th Design Automation Conf., </booktitle> <pages> pp. 520525, </pages> <year> 1991. </year>
Reference-contexts: Although hierarchical test generation techniques have been proposed since the mid-1970s [10], only recently have they become practical to use, as design styles have evolved to the point where hierarchical design is well-supported. New CAD tools are able to synthesize gate and circuit-level simulation models from higher-level models <ref> [32, 95] </ref>. In many cases, designers compose circuits using libraries of large predefined modules such as ALUs and RAMs which have precom-puted tests, thus obviating the need for test generation at lower levels of abstraction, a fact which we explore here. <p> However, analysis of many performance-enhancing design trade-offs is only possible by high-level simulation. Such design trade-offs are becoming increasingly important as IC densities grow. Recently, a number of new CAD tools have been developed which are able to automatically synthesize gate and circuit-level descriptions from high-level behavioral descriptions <ref> [32] </ref>. These high-level synthesis tools show promise in automating digital design in a number of specialized areas, particularly signal-processing and digital control. 1.2.2 Fault Modeling Faults in ICs primarily result from physical defects introduced during manufacturing. <p> An example of a circuit that is relatively easy to test using precomputed test methods is shown in Figure 2.2. This circuit was generated by AutoCircuit, a high-level synthesis tool <ref> [32] </ref> being developed at General Motors Research and Development Center and based on the System Architects Workbench from Carnegie Mellon University [95]. The circuit Encode is part of a special-purpose communications chip. The modules in this circuit are synthesized by module generators. <p> MATSim uses modified version of a circuit data structure (Netstruct) developed at Carnegie Mellon University for representing circuits designed by high-level synthesis. The routines that access Netstruct, and the Verilog parser that produces it are part of the AutoCircuit synthesis tool <ref> [32] </ref>. The Verilog language was designed to describe both circuit structure and function, as well as the simulation environment, including the stimulus vectors. However, the semantics of Verilog do not support assignment of symbolic expressions. <p> These module functions can be difficult to construct for arbitrary modules. However, functional models for arbitrary modules can be implemented by decomposing the modules into dataow graphs of primitives. This method is already used in the AutoCircuit Verilog parser <ref> [32] </ref> which MATSim employs, so MATSim can be modified to include the capability. 5.2. PathPlan2 The PathPlan2 test generation algorithm is the successor to our original test generator PathPlan. It implements the extensions to PathPlan that we identified in Chapter II and uses MATSim to propagate signals.
Reference: 33. <author> H. Fujiwara. </author> <title> Logic Testing and Design for Testability. </title> <publisher> The MIT Press, </publisher> <address> Cambridge, MA., </address> <year> 1985. </year>
Reference-contexts: This process of determining complete and consistent specifications of circuit signal values is called justification. The most widely known test generation algorithm is the D-algorithm, first published in 1966 <ref> [33] </ref>. It provides a systematic implementation of the D-propagation and justification steps described above. In the case of D-propagation, several Ds (Ds) may be propagated simultaneously, since sometimes an error signal must be propagated along more than one path to reach an observable output. <p> A major reason is the fact that backtracking might be initiated at any gate in the circuit. The PODEM (Path Oriented DEcision Making) test generation algorithm avoids this problem by backtracking only at primary inputs <ref> [33] </ref>. In PODEM, internal values are not justified explicitly, as in the D-algorithm. To satisfy an internal objective such as a D or D on some internal line, a value is assigned to a primary input and the circuit is simulated. <p> PODEM traces a path from the site of an internal objective to be satisfied to a primary input. Along this path it transfers its initial objective gate by gate until an assignment is made to a primary input. A number of test generation techniques have been developed since PODEM <ref> [33, 52, 85] </ref>, most of which are simply extensions to it. Their goal is to reduce the number of backtracks by identifying choices a test generation algorithm might make that cannot lead to a solution, without actually pursuing every decision. <p> Their goal is to reduce the number of backtracks by identifying choices a test generation algorithm might make that cannot lead to a solution, without actually pursuing every decision. For example, the FAN algorithm <ref> [33] </ref> seeks to identify conicts at fanout branches within a circuit, thereby avoiding backtracks at the primary inputs and the cost of simulating large parts of the circuit. Conicting assignments at fanout branches cannot be satisfied by any assignment at primary inputs. Gate-level test generation speedups reported in [33] averaged about <p> FAN algorithm <ref> [33] </ref> seeks to identify conicts at fanout branches within a circuit, thereby avoiding backtracks at the primary inputs and the cost of simulating large parts of the circuit. Conicting assignments at fanout branches cannot be satisfied by any assignment at primary inputs. Gate-level test generation speedups reported in [33] averaged about 3.5 over PODEM. In general, new techniques for gate-level test generation like FAN do not result in order-of-magnitude speedups over previous techniques. Sequential Circuits. Algorithms such as the D-algorithm and PODEM cannot generate tests directly for sequential circuits because they assume that all assignments are instantaneously propagated.
Reference: 34. <author> H. Fujiwara and T. Shimono. </author> <title> On the Acceleration of Test Generation Algorithms, </title> <booktitle> in Proc. 13th Fault-Tolerant Computing Symp., </booktitle> <pages> pp. 98105, </pages> <month> June </month> <year> 1983. </year>
Reference: 35. <author> S. Funatsu, N. Wakatsuki, and T. </author> <title> Arima. Test Generation Systems in Japan, </title> <booktitle> in Proc. 12th Design Automation Conf., </booktitle> <pages> pp. 7784, </pages> <year> 1980. </year>
Reference-contexts: Therefore, connecting all memory modules of a circuit into a scan chain obviates the need for sequential test generation. There are many variations on the basic theme of scan design <ref> [7, 35, 92] </ref>. The most important design issue is whether to include all ip-op elements in scan chains (full scan) or only some of them (partial scan).
Reference: 36. <author> S. Gai, F. Somenzi, and E. Ulrich. </author> <title> Advances in Concurrent Multilevel Simulation, </title> <journal> IEEE Trans. Computer-Aided Design, </journal> <volume> Vol. 6, </volume> <pages> pp. 10061012, </pages> <month> November </month> <year> 1987. </year>
Reference: 37. <author> D. D. Gajski. </author> <title> Silicon compilation, </title> <booktitle> VLSI Systems Design, </booktitle> <pages> pp. 4864, </pages> <month> November </month> <year> 1985. </year>
Reference-contexts: In order to describe the hierarchy of abstractions that MATSim can exploit, we have developed a multidimensional view of the abstraction hierarchy relevant to test generation. It is illustrated in Figure 5.2 by a Y-chart similar to that used by Gajski <ref> [37] </ref> to define relevant dimensions of abstraction in layout synthesis. The three axes of the Y-chart are labeled information, time, and function. Abstraction in the information dimension ranges from bits to words to multi-word packets (vector sequences). The time dimension ranges from gate delays to clock cycles to instruction cycles.
Reference: 38. <author> K. O. Geddes. </author> <title> On the Design and Performance of the Maple System, </title> <booktitle> in Proc. 1984 MAC-SYMA Users Conference, pg. </booktitle> <volume> 199, </volume> <year> 1984. </year>
Reference-contexts: We want to determine symbolically if (4.1) is equivalent to using an algorithm. To solve this problem, we turn to the field of computer algebra [4, 22, 74], where mathematical formulas are manipulated symbolically. Maple <ref> [38] </ref> and Mathematica [102] are examples of programs that embody these techniques. To manipulate symbolic formulas algorithmically, it is usually necessary to convert them to a standard or canonical form. Arbitrary formulas are then simplified to match the standard form.
Reference: 39. <author> A. Ghosh, S. Devadas, and A. R. </author> <title> Newton. Sequential Test Generation at the Register-Transfer and Logic Levels, </title> <booktitle> in Proc 27th Design Automation Conf., </booktitle> <pages> pp. 580586, </pages> <year> 1990. </year> <month> 207 </month>
Reference: 40. <author> P. Goel. </author> <title> An Implicit Enumeration Algorithm to Generate Tests for Combinational Logic Circuits. </title> <journal> IEEE Trans. Comput., </journal> <volume> Vol. 30, </volume> <pages> pp. 215222, </pages> <month> March, </month> <year> 1981. </year>
Reference-contexts: For example, an alternative path can be followed from a point on the D-propagation path where a signal line branches in several directions. The D-algorithm has been successfully implemented for many years. Around 1980, it was shown to be inefficient for an important class of circuits called error-correction-and-translation circuits <ref> [40] </ref>; it may be inefficient for other useful circuits as well. Poor choices for D-propagation and justification in these circuits lead to an excessive number of backtracks and unacceptably long computation times. A major reason is the fact that backtracking might be initiated at any gate in the circuit. <p> The primary emphasis is on symbolic-layer propagation of fault-free signals such as and as expressions, and hierarchical propagation of test response errors at the symbolic and vector layers. It uses a test generation algorithm with forward-only signal propagation similar to PODEM <ref> [40] </ref>. Like PODEM, the T T ;( ) S R 173 basic structure of PathPlan2 is simple: generate new objectives, that is, internal signal values to be justified, relate the new objectives to the primary inputs, and perform forward implication (simulation) using MATSim.
Reference: 41. <author> P. Goel. </author> <title> Test Generation Costs Analysis and Projections, </title> <booktitle> in Proc. 17th Design Automation Conf., </booktitle> <pages> pp. 7784, </pages> <year> 1980. </year>
Reference-contexts: The fault detection problem, that is, the problem of computing a test to detect a given SSL fault, is NP-complete [50] for combinational circuits. The lower bound complexity of standard search-based test generation techniques is <ref> [41] </ref>, and in the average case [100], where N is the number of modules in the circuit. Finally, the typical approach (described above) of extending gate-level combinational algorithms to handle sequential circuits has worst-case complexity , where m is the number of state variables [16].
Reference: 42. <author> G. Grtzer. </author> <title> General Lattice Theory, </title> <publisher> Academic Press, </publisher> <address> New York, NY., </address> <year> 1978. </year>
Reference-contexts: P P ( )( )( )( ) P P P W M P P M M P P W W = 77 tion of the parallel connection operation # is the same as the intersection operation in the propaga tion set lattice described above, the propagation algebra is a semi-lattice <ref> [42] </ref>. Apart from the four major properties of commutativity, idempotence, absorption, and associativity, Table 3.1 lists some other typical properties of algebras encountered in digital sys tems. <p> The lattice of partitions lacks these properties and is consequently not as special and well-studied as the Boolean algebras. Nevertheless, a number of useful theorems have been derived for general lattices <ref> [14, 42] </ref>. Let = ( , *, +) and = ( , *, +) be two algebras with sets and respectively, and binary operations * and +. is homomorphic to if and only if there exists an onto mapping , such that and , for any two elements .
Reference: 43. <author> F. Harary. </author> <title> Graph Theory, </title> <publisher> Addison-Wesley, </publisher> <address> Reading, MA, </address> <year> 1969. </year>
Reference: 44. <author> J. Hartmanis and R. E. Stearns. </author> <title> Algebraic Structure Theory of Sequential Machines. </title> <address> Pren-tice-Hall, Englewood Cliffs, N. J., </address> <year> 1966. </year>
Reference-contexts: Let and be partitions on a set S. The intersection is the partition on S such that for any two elements , if and only if and <ref> [44] </ref>. This operation can be computed by intersecting (using set intersection) each block of with every block of . Let , and , then . Let and be partitions on a set S. <p> Let , and , then . Let and be partitions on a set S. The union is the partition on S such that two elements of S, s and t are equivalent, ie. , if and only if there exists a chain in S, for which either or , <ref> [44] </ref>. The union operation can be computed by the procedure shown in Figure A.1. <p> Transitive: a R b and b R c implies a R c, 3. Antisymmetric: a R b and b R a implies a = b. The set of all partitions on a set S, together with the ordering relation is a partial ordering <ref> [44] </ref>. Let (S, ) be a partially ordered set, and let P be a subset of S; then an element is the least upper bound (lub) of P if and only if for every , , and for every , implies that . <p> A lattice is a partially ordered set that has a lub and a glb for every pair of elements. The set of all partitions on a set S is a lattice, where for any two partitions and , , and <ref> [44] </ref>.
Reference: 45. <author> J. P. Hayes. </author> <title> A Calculus for Testing Complex Digital Systems, </title> <booktitle> in Proc. 10th Fault-Tolerant Computing Symp., </booktitle> <pages> pp. 115120, </pages> <address> Kyoto, Japan, </address> <year> 1980. </year>
Reference-contexts: In these examples, the basic elements of vector sequences are constants, but they can also be variables, as we show below. Certain vector sequences are used so frequently by themselves and in the construction of other sequences, that they have been given special names and symbols <ref> [45] </ref>. These include the n-bit all-0 vector sequence and the all-1 sequence which are used later, as well as , the counting sequence (the output of an n-bit counter), and , the diagonal sequence. Errors.
Reference: 46. <author> J. P. Hayes. </author> <title> Digital Simulation with Multiple Logic Values, </title> <journal> IEEE Trans. Computer-Aided Design, </journal> <volume> Vol. 5, </volume> <pages> pp. 274283, </pages> <month> April </month> <year> 1986. </year>
Reference-contexts: We can apply logic functions such as AND, OR, and NOT to by appropriately combining operations on the basic elements 0 and 1. We use the general method for extending basic algebras presented in <ref> [46] </ref>. Let be a set of constant values, for instance -0,1-, and let be an associated set of operations, such as -AND, OR, NOT so that together A and constitute an algebra denoted . A is referred to the basis set. <p> In other words, the new set is constructed by combining members from each of the sets in all possible ways. Equations (2.6) and (2.7) define an extension rule which is satisfied by many useful multiple-valued logics <ref> [46] </ref>. We can now use (2.6) and (2.7) to construct logic functions for . For example, consider the AND operation and . while The complete function table for an AND gate is shown in Table 2.1.
Reference: 47. <author> J. P. Hayes. </author> <title> Fault Modeling. </title> <booktitle> IEEE Design and Test, </booktitle> <pages> pp. 8895, </pages> <month> April </month> <year> 1985. </year>
Reference-contexts: Problems with the SSL model, particularly for CMOS circuits, were identified as early as 1978 [98], so CMOS circuits are sometimes modeled at the (very low) switch level <ref> [47] </ref>, where transistors are treated as idealized switches. Recently, designers have also become concerned about two alternative types of faults. The first type is the delay fault. Some defects cause the IC to generate correct logic values only after an excessive delay [63].
Reference: 48. <author> J. P. Hayes. </author> <title> Introduction to Digital Logic Design, </title> <publisher> Addison-Wesley, </publisher> <address> Reading, MA, </address> <year> 1993. </year>
Reference: 49. <author> E. V. Huntington. </author> <title> Sets of Independent Postulates for the Algebra of Logic, </title> <journal> Trans. American Mathematical Society, </journal> <volume> Vol. 5, </volume> <pages> pp. 288309, </pages> <year> 1904. </year>
Reference: 50. <author> O. H. Ibarra and S. K. Sahni. </author> <title> Polynomially Complete Fault Detection Problems. </title> <journal> IEEE Trans. Comput., </journal> <volume> Vol. 24, </volume> <pages> pp. 242249, </pages> <month> March </month> <year> 1975. </year>
Reference-contexts: We will discuss this further below. Complexity Issues. Test generation is well known to be a difficult practical problem and a number of theoretical results support this conclusion. The fault detection problem, that is, the problem of computing a test to detect a given SSL fault, is NP-complete <ref> [50] </ref> for combinational circuits. The lower bound complexity of standard search-based test generation techniques is [41], and in the average case [100], where N is the number of modules in the circuit.
Reference: 51. <author> V. Immaneni and S. Raman. </author> <title> Direct Access Test SchemeDesign of Block and Core Cells for Embedded ASICs, </title> <booktitle> in Proc. IEEE Int. Test Conf., </booktitle> <pages> pp. 488492, </pages> <year> 1990. </year>
Reference-contexts: Very long scan chains can also be slow to load and unload during testing. Hierarchical approaches to design for testability are just beginning to appear <ref> [9, 12, 19, 26, 51, 61, 73, 82] </ref>. Some of these identify registers for partial scan by analyzing behavioral descriptions [19], while others seek to modify behavioral descriptions to avoid optimizations that create unnecessary loops [61]. Bhattacharya studied modifications to individual register-level modules to improve their testability [12]. <p> Bhattacharya studied modifications to individual register-level modules to improve their testability [12]. Finally, several hierarchical DFT techniques seek to ensure direct controllability and observability of every module <ref> [9, 26, 51, 73, 82] </ref>. Since abstract high-level representations of circuits are developed first and gate-level details are added later, hierarchical testability techniques can be introduced early in the design process. <p> In particular, full and partial scan design can be used to provide controllability and observability thus making circuits easier to test. In addition, direct access to modules can be provided by routing internal buses through special multiplexers. Variations on these techniques are used in <ref> [9, 26, 51, 82, 73] </ref>. An alternative approach to improving circuit observability for propagation is to modify non-transparent modules to increase their transparency; we will discuss this approach in Chapter IV. 2.6.
Reference: 52. <author> T. Kirkland and M. R. Mercer. </author> <title> A Topological Search Algorithm for ATPG, </title> <booktitle> in Proc. 24th Design Automation Conf., </booktitle> <pages> pp. 502508, </pages> <year> 1987. </year>
Reference-contexts: PODEM traces a path from the site of an internal objective to be satisfied to a primary input. Along this path it transfers its initial objective gate by gate until an assignment is made to a primary input. A number of test generation techniques have been developed since PODEM <ref> [33, 52, 85] </ref>, most of which are simply extensions to it. Their goal is to reduce the number of backtracks by identifying choices a test generation algorithm might make that cannot lead to a solution, without actually pursuing every decision.
Reference: 53. <author> K. Knight. </author> <title> Unification: A Multidisciplinary Survey. </title> <journal> ACM Computing Surveys, </journal> <volume> Vol. 21, </volume> <pages> pp. 23124, </pages> <month> March </month> <year> 1989. </year>
Reference-contexts: The process of substituting the same value for all variables of the same name in a test package to be instantiated is called unification. The unification procedure is widely applied in computer science <ref> [53] </ref>, most notably in manipula A A X X X A A T X A TP a d 0, ,( ) a;( )= 2 1 R R 2 3 R R 3 1 1 1 d d 1 1= = = 1 0 0 1 = = A A A A
Reference: 54. <author> D. E. Knuth. </author> <booktitle> The Art of Computer Programming: Seminumerical Algorithms, </booktitle> <volume> Vol. 2, </volume> <booktitle> Second Edition, </booktitle> <publisher> Addison Wesley, </publisher> <address> Reading, MA, </address> <year> 1981. </year>
Reference-contexts: For simplicity therefore, all constants in MATSim are represented by rational numbers and implemented by integer pairs numerator/denominator. For example, the constant 0 is represented by 0/1, and 1 is represented by 1/1. Symbolic expressions are manipulated by well-known computer algebra techniques <ref> [54] </ref>, so that they are always maintained in exact and reduced form. Subtraction is implemented in MATSim as addition of a negative number. The sign of a vector sequence is associated with the numerator of its rational coefficient. Therefore, is represented as .
Reference: 55. <author> Z. Kohavi. </author> <title> Switching and Finite Automata Theory, 2nd Edition. </title> <publisher> McGraw-Hill, </publisher> <address> New York, NY, </address> <year> 1978. </year>
Reference-contexts: For instance, AND, OR, and NOT (word) gates introduce Boolean operations, giving rise to Boolean expressions. The most common canonical representation for a Boolean function is the sum-of-minterms or disjunctive normal form <ref> [55] </ref>. Boolean PEs can usually be simplified to reduce the number of both terms and literals. Most PEs contain a mixture of arithmetic and Boolean operations, as well as other higher-level operations. <p> The algebras and are said to be isomorphic if h is also one-to-one. In this case, and are identical except for the names of the elements. We can depict the ordering relation in a lattice L by means of a graph, called a Hasse diagram <ref> [55] </ref>, whose vertices are elements of L. Vertex a is drawn in a higher level than vertex b whenever , that is, and (in the case of module functions, ). Vertices a and b are adjacent if there is no element c, such that .
Reference: 56. <author> J-H. Kong and S. A. Szygenda. MixMOS: </author> <title> a mixed-level simulator for digital MOS circuits using a new algebraic approach, </title> <booktitle> Computer-Aided Design, </booktitle> <volume> Vol. 22, </volume> <pages> pp. 618632, </pages> <month> December </month> <year> 1990. </year>
Reference: 57. <author> B. Krishnamurthy. </author> <title> Hierarchical Test Generation: Can AI Help?, </title> <booktitle> in Proc. Int. Test Conf., </booktitle> <pages> pp. 694700, </pages> <year> 1987. </year>
Reference-contexts: Finally, as noted above, symbolic simulation for design verification is not part of the design cycle for most companies, nor does there appear to be a trend toward using it. Finally, Krishnamurthy <ref> [57] </ref> used AI techniques to describe fault propagation and line justification methods for each module in a design hierarchy to improve the performance of the conventional D-algorithm. This approach has subsequently been used in a number of experimental hierarchical test generators, notably SOCRATES [84]. Precomputed Tests.
Reference: 58. <author> J. Lee and J. H. Patel. </author> <title> An Architectural Level Test Generator for a Hierarchical Design Environment, </title> <booktitle> in Proc. 21st Fault-Tolerant Computing Symp., </booktitle> <pages> pp. 4451, </pages> <month> June </month> <year> 1991. </year>
Reference-contexts: This important capability is the main strategy in a number of experimental test generators <ref> [9, 58, 59, 68, 88, 93] </ref>. Currently evolving design styles, which rely heavily on CAD tools, are making this capability very desirable. Designers often reuse modules that have been stored in a library, and many of these modules do not have accurate gate-level models for test generation purposes. <p> Finally, Lee and Patel have reported on two versions of a test generator called ARTEST that they have developed for testing using precomputed tests <ref> [58, 59] </ref>. They assume that circuits are composed of two parts: a datapath containing large modules with precomputed tests, and a control unit which provides control signals to the datapath and is composed of gates and ip-ops. Each part has a separate test generation algorithm. <p> We will discuss this typing 25 approach to error propagation further in the next chapter and in Chapter IV. In the first version of ARTEST <ref> [58] </ref>, the datapath is tested using a hierarchical algorithm similar to PODEM. Each test vector is justified individually; no attempt is made to propagate tests symbolically as in PathPlan. In the second version [59], a relaxation algorithm is used to justify internal signal objectives such as precomputed test stimuli. <p> Faults propagated to the interface between the control unit and the datapath are propagated as high-level error signals (types) by the hierarchical test generator. Lee and Patel have evaluated ARTESTs performance on small and medium sized examples (a few thousand gates). In <ref> [58] </ref>, they compare the performance of the first version of ARTEST to a gate-level test generator HITEC [72]. Using both programs, they generate tests for a version of the Am2910 microprogram sequencer [3]. <p> In general, the field of hierarchical test generation is still in its infancy. Hierarchical test generation techniques that can use precomputed tests <ref> [9, 58, 59, 68, 88, 93] </ref> have two particular advantages: (1) tests can be generated using multiple fault models for the same circuit, including the SSL fault model, as well as more accurate and technology-specific fault models; (2) tests that exist for previously designed modules can be reused when it is <p> However, by abstracting signals, we can create a small fixed set of symbolic error signals. Lee and Patel pursued this approach for the test generator ARTEST <ref> [58] </ref>. <p> V = an assigned known value different from the correct value U = an assigned but unknown value, different from the correct value The symbolic error signal P-set constructed from this basis set is shown in Table 2.2 together with the symbols and their interpretation provided by Lee and Patel <ref> [58] </ref>. These interpretations are meant to clarify the meaning of the signal but are frequently ambiguous. Some signals such as X are similar to values in other signal value sets such as . Others, such as CGVFE. are unique to ARTEST. <p> Types are propagated in ARTEST using a set of rules for each module. Second, Error signal Symbol Interpretation (X,X) X Unassigned Table 2.2 The set of symbolic error signals used in ARTEST <ref> [58] </ref>. (X,V) CF Constant faulty (X,U) VF Variable faulty (V,X) CG Constant good (V,V) C Constant good and faulty (V,V) CGCFE Constant good and constant faulty effect (V,U) CGVF Constant good and variable faulty (V,U) CGVFE Constant good and variable faulty effect D T T ,( ) S 47 CGVFE can <p> We can analyze error propagation along a distributed propagation path, at least for the case where the distributed path is transparent relative to the response set of the MUT. Previously reported test generators such as PathPlan and ARTEST <ref> [58] </ref> cannot analyze such distributed propagation paths. <p> Signal Value Algebras. Symbolic signal values can be propagated through a circuit model using high-level module functions. Together the functions and signal value set form a symbolic signal value algebra. Lee and Patel introduced a symbolic signal-value (type) algebra in <ref> [58] </ref>. Their types are constructed in ad hoc fashion, and as a result, the associated module functions cannot be rigorously derived from basic operations on the underlying signal sets. The module functions are implemented using rule-based methods, which are often inefficient and difficult to prove correct. <p> Now let us analyze a similar set of symbolic signal values used for propagating error information: the typing scheme given in <ref> [58] </ref> for the test generator ARTEST that we discussed in Chapter II. The set of signal values used by ARTEST is summarized in Table 4.8, which repeats Table 2.2. The functions associated with this set are not discussed in [58], 1 -ADD,SUBTRACT,XOR,MULTIPLY-( input , : symbolic signal value) 2 - 4 <p> values used for propagating error information: the typing scheme given in <ref> [58] </ref> for the test generator ARTEST that we discussed in Chapter II. The set of signal values used by ARTEST is summarized in Table 4.8, which repeats Table 2.2. The functions associated with this set are not discussed in [58], 1 -ADD,SUBTRACT,XOR,MULTIPLY-( input , : symbolic signal value) 2 - 4 if ( == R && == R) 6 return ( ); 7 - 1 -AND,OR-( input , :symbolic signal value ) 2 - 4 if ( == R) = C; 6 return ( ); 7 - -AND,OR-. 1 2 <p> ARTEST was designed to support fault propagation from the output of a MUT, where the faulty value is not known, but is known to be faulty (denoted U). This technique is used by ARTEST to generate tests for datapath circuits. It is assumed in <ref> [58] </ref> that datapaths are controlled by control units which are tested by a separate algorithm. The interface between datapath and control circuits is assumed to be neither directly controllable nor observable (e.g., by a scan chain). <p> The control unit is tested by a conventional (low-level) test generation algorithm, and faults that are propagated to the interface are injected into the Error signal Symbol Interpretation (X,X) X Unassigned Table 4.8 The set of symbolic error signals or types used in ARTEST <ref> [58] </ref>. (X,V) CF Constant faulty (X,U) VF Variable faulty (V,X) CG Constant good (V,V) C Constant good and gaulty (V,V) CGCFE Constant good and constant faulty effect (V,U) CGVF Constant good and variable faulty (V,U) CGVFE Constant good and variable faulty effect 1 AND ( input , :symbolic signal value ) <p> Since R is blocked for MULTIPLY, AND, and OR, propagation of CGVFE will likewise be blocked for these module functions. To propagate R through these modules, ARTEST must perform a more detailed, low-level analysis for error propagation; the method for this is not discussed in <ref> [58] </ref>. 4.3. Design for Transparency In many circuits, error information is unavoidably lost as is propagated from the output of the MUT to primary outputs. In this case, an alternate test package with a slightly different response set can sometimes be used to test the MUT. <p> Finally, Lee has implemented an architectural-level fault simulator ARSIM to speed up simulation for hierarchical circuits with precomputed tests for modules [88]. However, ARSIM does not propagate signals at multiple levels of abstraction. It propagates the set of symbolic error signal values discussed earlier for ARTEST <ref> [58] </ref>, and relies on lower-level fault simulators to analyze fault coverage when these symbolic signals are blocked by non-transparent modules. 5.1.1 Dimensions of Abstraction As we saw in Chapter I, a large number of test generation tools use hierarchy in an attempt to speed up test generation. <p> After backtrace, PathPlan2 makes the assignment in4 := 1. The final symbolic test program is in1 := 0 in3_1 := in4 := 1 Recall that ARTEST <ref> [58] </ref> cannot propagate error information through circuits with irregular buses of the kind illustrated by Fltrdp in Figure 5.21. 5.2.5 Summary of PathPlan2 PathPlan2 automates the generation of test programs that employ precomputed tests and several levels of abstraction.
Reference: 59. <author> J. Lee and J. H. Patel. </author> <title> An Architectural Level Test Generator Based on Nonlinear Equation Solving, </title> <journal> Journal of Electronic Testing, </journal> <volume> Vol. 4, </volume> <pages> pp. 137150, </pages> <month> April </month> <year> 1993. </year>
Reference-contexts: This important capability is the main strategy in a number of experimental test generators <ref> [9, 58, 59, 68, 88, 93] </ref>. Currently evolving design styles, which rely heavily on CAD tools, are making this capability very desirable. Designers often reuse modules that have been stored in a library, and many of these modules do not have accurate gate-level models for test generation purposes. <p> Finally, Lee and Patel have reported on two versions of a test generator called ARTEST that they have developed for testing using precomputed tests <ref> [58, 59] </ref>. They assume that circuits are composed of two parts: a datapath containing large modules with precomputed tests, and a control unit which provides control signals to the datapath and is composed of gates and ip-ops. Each part has a separate test generation algorithm. <p> In the first version of ARTEST [58], the datapath is tested using a hierarchical algorithm similar to PODEM. Each test vector is justified individually; no attempt is made to propagate tests symbolically as in PathPlan. In the second version <ref> [59] </ref>, a relaxation algorithm is used to justify internal signal objectives such as precomputed test stimuli. Symbolic expressions with undefined variables are propagated from the inputs of the circuit. This creates a system of equations which must be solved individually for each test vector to be applied to the MUT. <p> In general, the field of hierarchical test generation is still in its infancy. Hierarchical test generation techniques that can use precomputed tests <ref> [9, 58, 59, 68, 88, 93] </ref> have two particular advantages: (1) tests can be generated using multiple fault models for the same circuit, including the SSL fault model, as well as more accurate and technology-specific fault models; (2) tests that exist for previously designed modules can be reused when it is
Reference: 60. <author> J. Lee. </author> <title> Architectural Level Test Generation and Fault Simulation. </title> <type> Ph.D. Thesis, </type> <institution> University of Illinois, </institution> <month> November </month> <year> 1992. </year> <month> 208 </month>
Reference: 61. <author> T-C Lee, N. K. Jha, and W. H. Wolf. </author> <title> Behavioral Synthesis of Highly Testable Data Paths Under the Non-Scan and Partial Scan Environments, </title> <booktitle> in Proc. 30th Design Automation Conf., </booktitle> <pages> pp. 292297, </pages> <year> 1993. </year>
Reference-contexts: Very long scan chains can also be slow to load and unload during testing. Hierarchical approaches to design for testability are just beginning to appear <ref> [9, 12, 19, 26, 51, 61, 73, 82] </ref>. Some of these identify registers for partial scan by analyzing behavioral descriptions [19], while others seek to modify behavioral descriptions to avoid optimizations that create unnecessary loops [61]. Bhattacharya studied modifications to individual register-level modules to improve their testability [12]. <p> Hierarchical approaches to design for testability are just beginning to appear [9, 12, 19, 26, 51, 61, 73, 82]. Some of these identify registers for partial scan by analyzing behavioral descriptions [19], while others seek to modify behavioral descriptions to avoid optimizations that create unnecessary loops <ref> [61] </ref>. Bhattacharya studied modifications to individual register-level modules to improve their testability [12]. Finally, several hierarchical DFT techniques seek to ensure direct controllability and observability of every module [9, 26, 51, 73, 82].
Reference: 62. <author> Y. H. Levendel and P. R. Menon. </author> <title> Test Generation Algorithms for Computer Hardware Description Languages, </title> <journal> IEEE Trans. Comput., </journal> <volume> Vol. 31, </volume> <pages> pp. 577588, </pages> <month> July </month> <year> 1982. </year>
Reference-contexts: Faults in this model typically represent erroneous data transfers; other fault types can be difficult or impossible to represent. Other approaches use functional descriptions of the circuit based on HDLs <ref> [62, 64, 75] </ref>. Levendel and Menon model faults as D's injected into the variables of a HDL description [62]. Because faults are modeled at such a low level, the advantages of the higher-level circuit model are somewhat offset, as we have seen before. <p> Faults in this model typically represent erroneous data transfers; other fault types can be difficult or impossible to represent. Other approaches use functional descriptions of the circuit based on HDLs [62, 64, 75]. Levendel and Menon model faults as D's injected into the variables of a HDL description <ref> [62] </ref>. Because faults are modeled at such a low level, the advantages of the higher-level circuit model are somewhat offset, as we have seen before. Lin and Su model a variety of faults, including incorrect instruction decoding, and incorrect register transfers. [64].
Reference: 63. <author> C. J. Lin and S. M. Reddy. </author> <title> On Delay Fault Testing in Logic Circuits. </title> <journal> IEEE Trans. Computer-Aided Design, </journal> <volume> Vol. 6, </volume> <pages> pp. 694703, </pages> <month> September </month> <year> 1987. </year>
Reference-contexts: Recently, designers have also become concerned about two alternative types of faults. The first type is the delay fault. Some defects cause the IC to generate correct logic values only after an excessive delay <ref> [63] </ref>. The second type is the bridging fault, where 10 physically separate wires in a circuit are connected by a fault.
Reference: 64. <author> T. Lin and S. Y. H Su. </author> <title> Functional Test Generation of Digital LSI/VLSI Systems Using Machine Symbolic Execution Technique, </title> <booktitle> in Proc. IEEE Int. Test Conf., </booktitle> <pages> pp. 660668, </pages> <year> 1984. </year>
Reference-contexts: At present, the coverage of SSL faults is the only well-accepted measure of test quality, and all other measures must be calibrated against this model. Few formal higher-level fault models exist, and those that do are often defined in imprecise terms. In Lin and Su's register-level fault model <ref> [64] </ref>, for example, faults are classified according to their effect on some register-level components. These effects include such symptoms as register decoding errors, and data transfer errors. Other higher-level fault models are extensions of the SSL fault model. <p> Faults in this model typically represent erroneous data transfers; other fault types can be difficult or impossible to represent. Other approaches use functional descriptions of the circuit based on HDLs <ref> [62, 64, 75] </ref>. Levendel and Menon model faults as D's injected into the variables of a HDL description [62]. Because faults are modeled at such a low level, the advantages of the higher-level circuit model are somewhat offset, as we have seen before. <p> Because faults are modeled at such a low level, the advantages of the higher-level circuit model are somewhat offset, as we have seen before. Lin and Su model a variety of faults, including incorrect instruction decoding, and incorrect register transfers. <ref> [64] </ref>. Recently, Rao et. al. [75] have proposed a similar approach for VHDL models. In their approach, as well as that of Thatte and Abraham [94], the faults are not described by well-accepted models, and the relationship of the faults to standard models is hard to quantify. Artificial Intelligence-Based Methods. <p> Thus, they do not realize the full potential of high-level error propagation because of the low-level interconnection structure. Other hierarchical testing techniques use higher-level models and bus-level interconnection structures, but use high-level fault models that are difficult to relate to more precise and well-accepted models <ref> [12, 64] </ref>. Still other techniques are based almost entirely on heuristics, so no generally applicable principles of test generation have been developed for them [88, 89].
Reference: 65. <author> M. Majewski and S. Pichumani. </author> <title> The Use of Silicon Compilation in the Design of a Gaussian Filter and a Template Matching Processor. </title> <booktitle> VLSI Systems Design, </booktitle> <pages> pp. </pages> <year> 2025, </year> <month> October </month> <year> 1987. </year>
Reference-contexts: In order to demonstrate the use of PathPlan, we describe its application to the Gaussian filter chip which is an IC designed at General Motors R&D Center for use in image processing applications <ref> [65] </ref>. It is a small but nontrivial CMOS design with approximately 40,000 transistors. All modules are synthesized using module generators as in Divfilt and Encode. Two on-chip RAMs support line buffering operations. Figure 2.10 shows a basic block of the circuit called Fltrdp. <p> Some results of applying PathPlan to other practical circuits are shown in Table 2.3, which repeats Table 1.1. Fltrdp has been described above. The modules named Vertdp and Rowdp are datapath circuits similar to Fltrdp and used in the template-matching IC described in <ref> [65] </ref>. Vertdp has two registers, an inverting buffer, an adder, and a multiplexer. Rowdp has one register, an inverting buffer, two adders, and two multiplexers. Both can be tested completely by a test generated by Pathplan. Alu is a high-level model of the 74181 ALU/function generator described in [12].
Reference: 66. <author> M. Marhfer. </author> <title> An Approach to Modular Test Generation Based on the Transparency of Modules, </title> <booktitle> in Proc. IEEE CompEuro 87, </booktitle> <pages> pp. 403406, </pages> <month> May </month> <year> 1987. </year>
Reference-contexts: That is, M is transparent if any change in value at is reected in a change in value at . For example, Multiplexer 1 (Figure 2.5d) is transparent when . The concept of transparency is also defined similarly by Marhfer <ref> [66] </ref>, and the path from to through a transparent module is called an F-path by Freeman [30]. M is partially transparent if for some , is distinguished from due to at least one . In this case, some changes at can be distinguished at , but not all. <p> Definition 3.9: Let M be a module with input data bus , input control bus , and output data bus . If and , then is a subpath of the data bus pair The following corollary to Theorem 3.3, which is also noted by Marhfer <ref> [66] </ref>, illustrates the importance of subpaths. Corollary 3.1: Let M be a module with input data bus , input control bus , and output data bus . Then if and only if there is a subpath such that the corresponding transmission function . <p> Sequential Transparency In the general definition of transmission functions, modules are controlled by sequences of inputs at . Control sequences longer than one timestep were studied by Marhfer <ref> [66] </ref>, but were not integrated into a formal theory of propagation, as we have done in Sections 3.1 and 3.2. Multi-step propagation is determined by intersecting incomparable transmission functions. The intersection of two transmission functions and is always at least as transparent as either or .
Reference: 67. <author> R. Marlett. EBT: </author> <title> A Comprehensive Test Generation Technique for Highly Sequential Circuits, </title> <booktitle> in 15th Design Automation Conf., </booktitle> <pages> pp. 335339, </pages> <month> June </month> <year> 1978. </year>
Reference-contexts: The reverse-time processing approach, exemplified by the extended backtrace (EBT) algorithm <ref> [67] </ref>, avoids this complication by processing gates strictly backwards through the circuit and backwards in time, determining events which must come last, then next to last, etc. It starts at a primary output and follows a predetermined path to the site of a fault chosen for testing.
Reference: 68. <author> B. T. Murray and J. P. Hayes. </author> <title> Hierarchical Test Generation Using Precomputed Tests for Modules, </title> <booktitle> in Proc. IEEE Int. Test Conf., </booktitle> <pages> pp. 221229, </pages> <year> 1988. </year>
Reference-contexts: This important capability is the main strategy in a number of experimental test generators <ref> [9, 58, 59, 68, 88, 93] </ref>. Currently evolving design styles, which rely heavily on CAD tools, are making this capability very desirable. Designers often reuse modules that have been stored in a library, and many of these modules do not have accurate gate-level models for test generation purposes. <p> Not only is the test generation effort reduced, fault simulation for fault grading is minimized. We developed an algorithm for test generation using precomputed tests and implemented it in a tool called PathPlan <ref> [68] </ref>. This program is one of the earliest to specifically use this approach. In PathPlan, precomputed tests are represented symbolically and propagated through modules in the circuit model. The test generation algorithm used is loosely based on the D-algorithm. <p> Since the circuit modeling level is much higher than the usual gate level of the D-algorithm, the number of components is substantially reduced. Moreover, the number of backtracking choices available at each module is also greatly reduced. Some performance results for PathPlan are shown in Table 1.1 <ref> [68] </ref>. The modules in these circuits are implemented by module generators which produce layouts rather than netlists of gates. However, we can estimate the number of gates in each module and therefore in each circuit. <p> In general, the field of hierarchical test generation is still in its infancy. Hierarchical test generation techniques that can use precomputed tests <ref> [9, 58, 59, 68, 88, 93] </ref> have two particular advantages: (1) tests can be generated using multiple fault models for the same circuit, including the SSL fault model, as well as more accurate and technology-specific fault models; (2) tests that exist for previously designed modules can be reused when it is <p> PathPlan PathPlan (for path planning) is our initial version of a hierarchical test generator using precomputed tests. It was developed at General Motors Research Laboratories in 1987 and was one of the earliest reported automatic test generators designed specifically to generate tests for circuits using precomputed tests for modules <ref> [68] </ref>. It has not been used to test commercial circuits, however, a similar program partly based on PathPlan has been used for production testing [11]. Our work developing PathPlan, as well as the work to develop necessary extensions to it, form the basis for this thesis. <p> It can only handle acyclic combinations of primitive modules 2. It uses only T-mode propagation Restriction 1 can easily be addressed in principle by extending PathPlan to include the same modifications used in conventional gate-level test generators to handle sequential circuits <ref> [68] </ref>. Restriction 2 simplifies the algorithm but shrinks the solution space by leaving out many possible solutions. For example, suppose that module of Fltrdp (Figure 2.10) is the MUT. As discussed above, cannot be propagated through module due to PathPlans reliance on T-modes.
Reference: 69. <author> B. T. Murray and J. P. Hayes. </author> <title> Hierarchical Test Generation Using Precomputed Tests for Modules, </title> <journal> IEEE Trans. Computer-Aided Design, </journal> <volume> Vol. 9, </volume> <pages> pp. 594603, </pages> <year> 1990. </year>
Reference: 70. <author> B. T. Murray and J. P. Hayes. </author> <title> Test Propagation Through Modules and Circuits, </title> <booktitle> in Proc. IEEE Int. Test Conf., </booktitle> <pages> pp. 748757, </pages> <year> 1991 </year>
Reference: 71. <author> M. </author> <title> Mukaidono. A Set of Independent and Complete Axioms for a Fuzzy Algebra (Kleene Algebra), </title> <booktitle> in Proc. Eleventh International Symposium on Multiple-Valued Logic, </booktitle> <pages> pp. 2734, </pages> <year> 1981. </year>
Reference: 72. <author> T. Niermann and J. H. Patel. HITEC: </author> <title> A Test Generation Package for Sequential Circuits, </title> <booktitle> in Proc. European Design Automation Conf., </booktitle> <pages> pp. 214218, </pages> <month> Feb. </month> <year> 1991. </year>
Reference-contexts: Lee and Patel have evaluated ARTESTs performance on small and medium sized examples (a few thousand gates). In [58], they compare the performance of the first version of ARTEST to a gate-level test generator HITEC <ref> [72] </ref>. Using both programs, they generate tests for a version of the Am2910 microprogram sequencer [3]. ARTEST uses 61.75 CPU seconds to generate a test compared with 2,297 seconds for HITECa speedup factor of 37.6. ARTEST performs well for several circuits that contain global feedback loops and reconvergent fanout.
Reference: 73. <author> T. Ogihara et al. </author> <title> Testable Design and Support Tool for Cell Based Test, </title> <booktitle> in Proc. IEEE Int. Test Conf., </booktitle> <pages> pp. 10561071, </pages> <year> 1990. </year>
Reference-contexts: Very long scan chains can also be slow to load and unload during testing. Hierarchical approaches to design for testability are just beginning to appear <ref> [9, 12, 19, 26, 51, 61, 73, 82] </ref>. Some of these identify registers for partial scan by analyzing behavioral descriptions [19], while others seek to modify behavioral descriptions to avoid optimizations that create unnecessary loops [61]. Bhattacharya studied modifications to individual register-level modules to improve their testability [12]. <p> Bhattacharya studied modifications to individual register-level modules to improve their testability [12]. Finally, several hierarchical DFT techniques seek to ensure direct controllability and observability of every module <ref> [9, 26, 51, 73, 82] </ref>. Since abstract high-level representations of circuits are developed first and gate-level details are added later, hierarchical testability techniques can be introduced early in the design process. <p> In particular, full and partial scan design can be used to provide controllability and observability thus making circuits easier to test. In addition, direct access to modules can be provided by routing internal buses through special multiplexers. Variations on these techniques are used in <ref> [9, 26, 51, 82, 73] </ref>. An alternative approach to improving circuit observability for propagation is to modify non-transparent modules to increase their transparency; we will discuss this approach in Chapter IV. 2.6.
Reference: 74. <author> R. Pavel, M. Rothstein, and J. Fitch. </author> <title> Computer Algebra, </title> <publisher> Scientific American, </publisher> <pages> pp. 136152, </pages> <month> December </month> <year> 1981. </year>
Reference-contexts: We want to determine symbolically if (4.1) is equivalent to using an algorithm. To solve this problem, we turn to the field of computer algebra <ref> [4, 22, 74] </ref>, where mathematical formulas are manipulated symbolically. Maple [38] and Mathematica [102] are examples of programs that embody these techniques. To manipulate symbolic formulas algorithmically, it is usually necessary to convert them to a standard or canonical form. Arbitrary formulas are then simplified to match the standard form.
Reference: 75. <author> S. Rao, B. Pan, and J. R. Armstrong. </author> <title> Hierarchical Test Generation for VHDL Behavioral Models, </title> <booktitle> in Proc. European Design Automation Conf., </booktitle> <month> Feb. </month> <year> 1993. </year>
Reference-contexts: Faults in this model typically represent erroneous data transfers; other fault types can be difficult or impossible to represent. Other approaches use functional descriptions of the circuit based on HDLs <ref> [62, 64, 75] </ref>. Levendel and Menon model faults as D's injected into the variables of a HDL description [62]. Because faults are modeled at such a low level, the advantages of the higher-level circuit model are somewhat offset, as we have seen before. <p> Because faults are modeled at such a low level, the advantages of the higher-level circuit model are somewhat offset, as we have seen before. Lin and Su model a variety of faults, including incorrect instruction decoding, and incorrect register transfers. [64]. Recently, Rao et. al. <ref> [75] </ref> have proposed a similar approach for VHDL models. In their approach, as well as that of Thatte and Abraham [94], the faults are not described by well-accepted models, and the relationship of the faults to standard models is hard to quantify. Artificial Intelligence-Based Methods.
Reference: 76. <author> G. D. Robinson. </author> <title> HitestIntelligent Test Generation, </title> <booktitle> In Proc. IEEE Int. Test Conf., </booktitle> <pages> pp. 311323, </pages> <year> 1983. </year>
Reference-contexts: PathPlan has been implemented and used to test several practical circuits. It consists of about 7,000 lines of C and accepts circuit descriptions written in an HDL similar to the commer cial test generator and simulator Hitest <ref> [76] </ref>. In order to demonstrate the use of PathPlan, we describe its application to the Gaussian filter chip which is an IC designed at General Motors R&D Center for use in image processing applications [65]. It is a small but nontrivial CMOS design with approximately 40,000 transistors.
Reference: 77. <author> W. A. Rogers, J. F. Guzolek, and J. Abraham. </author> <title> Concurent and Hierarchical Fault Simulation, </title> <journal> IEEE Trans. Computer-Aided Design, </journal> <volume> Vol. 6, </volume> <pages> pp. 848862, </pages> <month> September, </month> <year> 1987. </year>
Reference-contexts: However, fewer tests are generated when a fault simulator is used, which tends to speed up generation of a complete set of tests and results in more compact test sets. On the other hand, fault simulation can be computationally expensive. A few hierarchical fault simulators have been developed <ref> [77] </ref>, but these have not significantly reduced complexity in W N 2 ( ) O 2 N ( ) 2 m 1+ N 1+ 16 the general case and so are not widely employed. Fault simulation is most often included within test generation algorithms for combinational circuits [99]. <p> Future versions of MATSim will support user-defined functional modules; however, all functions must be decomposed into primitive functions, since the hierarchical signal value sets, discussed in Chapter IV, are designed for a fixed set of module functions. Abstraction and hierarchy have been used in fault simulation previously <ref> [77, 81, 89, 88] </ref>. The Multiple Abstraction Rule-Based Simulator (MARS) developed by Singh [89] propagates fault-free signals at several levels of abstraction. Module functions are implemented by rules stored in a database. However, only gate-level error signals are processed by MARS. <p> The Multiple Abstraction Rule-Based Simulator (MARS) developed by Singh [89] propagates fault-free signals at several levels of abstraction. Module functions are implemented by rules stored in a database. However, only gate-level error signals are processed by MARS. The CHIEFS concurrent, hierarchical fault simulator <ref> [77] </ref> also uses separate functional and structural models for each module in the structural hierarchy. When the inputs to a module M in CHIEFS are updated, a functional model is used to produce new outputs for M. As in MARS, only gate-level error signals are processed.
Reference: 78. <author> J. P. Roth. </author> <title> Computer Logic, Testing, and Verification, </title> <publisher> Computer Science Press, </publisher> <address> Potomac, Maryland, </address> <year> 1980. </year>
Reference-contexts: The mapping of inputs to outputs represented by a single block of a propagation function is similar to the mapping described by a singular cube, which is a representation of an incomplete Boolean function introduced by Roth <ref> [78] </ref>, and widely used in describing logic synthesis algorithms. It is written , where u is a set of values for input variables (ports), and v is a set of values for output variables (ports). Here each or must be either 0, 1, or d (dont care).
Reference: 79. <author> J. P. Roth. </author> <title> Diagnosis of Automata Failures: A Calculus and a Method, </title> <journal> IBM Journal of Research and Development, </journal> <volume> Vol. 10, </volume> <pages> pp. 278291, </pages> <month> July </month> <year> 1966. </year> <month> 209 </month>
Reference-contexts: Next it substitutes for variables named everywhere in producing . Finally, it intersects each value in with the value already assigned to its corresponding port, where intersection of two vector sequences is defined by the intersection of their corresponding bits in the usual way <ref> [79] </ref>: Here the empty set symbol denotes conict. In most cases, conicts can be analyzed symbolically, since different vector sequences are assigned different symbols in PathPlan. For example, if and refer to different vector sequences, then cannot be intersected with without con-ict.
Reference: 80. <author> K. Roy and J. A. Abraham. </author> <title> High Level Test Generation Using Data Flow Descriptions, </title> <booktitle> in Proc. IEEE European Design Automation Conf., </booktitle> <pages> pp. 480484, </pages> <year> 1990. </year>
Reference: 81. <author> D. G. Saab et al. CHAMP: </author> <title> Concurrent Hierarchical And Multilevel Program for Simulation, </title> <booktitle> in Proc. Int. Conf. Computer-Aided Design, </booktitle> <pages> pp. 246249, </pages> <year> 1988. </year>
Reference-contexts: Future versions of MATSim will support user-defined functional modules; however, all functions must be decomposed into primitive functions, since the hierarchical signal value sets, discussed in Chapter IV, are designed for a fixed set of module functions. Abstraction and hierarchy have been used in fault simulation previously <ref> [77, 81, 89, 88] </ref>. The Multiple Abstraction Rule-Based Simulator (MARS) developed by Singh [89] propagates fault-free signals at several levels of abstraction. Module functions are implemented by rules stored in a database. However, only gate-level error signals are processed by MARS. <p> CHIEFS traverses the hierarchy of structural models within M down to the gate level to update fault lists. Other hierarchical fault simulators such as CHAMP are concerned with T S Simulation report Stimulus Circuit test package Test program MATSim PathPlan2 Test Vector Generator 152 coverage of switch-level faults <ref> [81] </ref>. These fault simulators also do not process error signals more abstract than those due to SSL faults. Finally, Lee has implemented an architectural-level fault simulator ARSIM to speed up simulation for hierarchical circuits with precomputed tests for modules [88].
Reference: 82. <author> K. Sakashita et al. </author> <title> Cell-Based Design Method, </title> <booktitle> in Proc. IEEE Int. Test Conf., </booktitle> <pages> pp. 909916, </pages> <year> 1989. </year>
Reference-contexts: Very long scan chains can also be slow to load and unload during testing. Hierarchical approaches to design for testability are just beginning to appear <ref> [9, 12, 19, 26, 51, 61, 73, 82] </ref>. Some of these identify registers for partial scan by analyzing behavioral descriptions [19], while others seek to modify behavioral descriptions to avoid optimizations that create unnecessary loops [61]. Bhattacharya studied modifications to individual register-level modules to improve their testability [12]. <p> Bhattacharya studied modifications to individual register-level modules to improve their testability [12]. Finally, several hierarchical DFT techniques seek to ensure direct controllability and observability of every module <ref> [9, 26, 51, 73, 82] </ref>. Since abstract high-level representations of circuits are developed first and gate-level details are added later, hierarchical testability techniques can be introduced early in the design process. <p> Panther provides the tools to implement the scan chains and test controllers hierarchically. When the design is completed, every test stimulus vector can be applied directly to every module via scan chains and buses. Similar techniques were also proposed in <ref> [26, 51,73, 82] </ref>. Propagation of test information through other modules is minimized; Panther is not designed to propagate the precom-puted tests through modules other than scan chains. No new general principles of hierarchical test generation are developed in Panther. Test generation becomes a matter of scheduling tests to be applied. <p> In particular, full and partial scan design can be used to provide controllability and observability thus making circuits easier to test. In addition, direct access to modules can be provided by routing internal buses through special multiplexers. Variations on these techniques are used in <ref> [9, 26, 51, 82, 73] </ref>. An alternative approach to improving circuit observability for propagation is to modify non-transparent modules to increase their transparency; we will discuss this approach in Chapter IV. 2.6.
Reference: 83. <author> A. Samad and M. Bell. </author> <title> Automating ASIC Design-for-Testabilitythe VLSI Test Assistant, </title> <booktitle> in Proc. IEEE Int. Test Conf., </booktitle> <pages> pp. 819828, </pages> <year> 1989. </year>
Reference-contexts: In this section, we present some examples of how the propagation theory of Chapter III can be applied to increase transparency. One technique for designing circuits that can easily propagate , is to route test points to primary outputs, perhaps through multiplexers <ref> [83] </ref>. Another technique is to use a hierarchical form of scan or boundary scan to ensure adequate observability [9]. These techniques lead to high routing overhead and highly constrained design styles. Both approaches provide additional paths for routing .
Reference: 84. <author> T. M. Sarfert et al., </author> <title> Hierarchical Test Pattern Generation Based on High-Level Primitives, </title> <booktitle> in Proc. IEEE Int. Test Conf., </booktitle> <pages> pp. 10161026, </pages> <month> Sept. </month> <year> 1989. </year>
Reference-contexts: Somenzi et al. [90] described such a technique based on the D-algorithm, Chandra and Patel [18] proposed a similar technique based on PODEM, and more recently, SOCRATES <ref> [84] </ref> has included higher-level primitives. The fundamental advantage of higher-level modules is that there are fewer of them in the circuit to evaluate. <p> Finally, Krishnamurthy [57] used AI techniques to describe fault propagation and line justification methods for each module in a design hierarchy to improve the performance of the conventional D-algorithm. This approach has subsequently been used in a number of experimental hierarchical test generators, notably SOCRATES <ref> [84] </ref>. Precomputed Tests. A new, but growing class of test generators use hierarchical techniques as described above, but focus on the ability to justify precomputed tests for modules and propagate module test responses to outputs where they can be observed.
Reference: 85. <author> M. H. Schultz, E. Trischler, and T. M. Sarfert. SOCRATES: </author> <title> A Highly Efficient Automatic Test Pattern Generation System. </title> <journal> IEEE Trans. Computer-Aided Design, </journal> <volume> Vol. 7, </volume> <pages> pp. 126137, </pages> <month> January </month> <year> 1988. </year>
Reference-contexts: PODEM traces a path from the site of an internal objective to be satisfied to a primary input. Along this path it transfers its initial objective gate by gate until an assignment is made to a primary input. A number of test generation techniques have been developed since PODEM <ref> [33, 52, 85] </ref>, most of which are simply extensions to it. Their goal is to reduce the number of backtracks by identifying choices a test generation algorithm might make that cannot lead to a solution, without actually pursuing every decision.
Reference: 86. <author> C. E. Shannon, </author> <title> Collected Works, </title> <publisher> IEEE Press, </publisher> <address> New York, NY, </address> <year> 1993. </year>
Reference: 87. <author> M. Shirley et al. </author> <title> A Synergistic combination of Test Generation and Design for Testability, </title> <booktitle> in Proc. IEEE Int. Test Conf., </booktitle> <pages> pp. 701711, </pages> <year> 1987. </year>
Reference: 88. <author> M. H. Shirley. </author> <title> Generating Circuit Tests by Exploiting Designed Behavior. </title> <type> Ph.D. Thesis, </type> <institution> MIT Artificial Intelligence laboratory, </institution> <month> December </month> <year> 1988. </year>
Reference-contexts: Singhs work on Saturn was innovative and several test generators developed later used similar techniques, however, Saturns performance on the few small examples cited was modest. An extension to Saturn called PF-TG (Program Fragment Test Generator) was developed by Shir-ley at MIT <ref> [88] </ref>. <p> However, the resulting test has the characteristics of a test program and can therefore take advantage of tester features unused by typical test generation algorithms. Like Saturn and PF-TG, the circuit model for DB-TG <ref> [88] </ref> is described hierarchically and uses knowledge to constrain the search space. In contrast to PF-TG, however, this knowledge is not directly contributed by the user. Rather it is derived from earlier simulations of the circuit, using a symbolic simulator. During test generation, DB-TG relies on data it recorded earlier. <p> This important capability is the main strategy in a number of experimental test generators <ref> [9, 58, 59, 68, 88, 93] </ref>. Currently evolving design styles, which rely heavily on CAD tools, are making this capability very desirable. Designers often reuse modules that have been stored in a library, and many of these modules do not have accurate gate-level models for test generation purposes. <p> Still other techniques are based almost entirely on heuristics, so no generally applicable principles of test generation have been developed for them <ref> [88, 89] </ref>. Finally, few of the proposed techniques attempt a systematic approach to design for testability, despite the fact that hierarchical techniques can be implemented earlier in the design process. In general, the field of hierarchical test generation is still in its infancy. <p> In general, the field of hierarchical test generation is still in its infancy. Hierarchical test generation techniques that can use precomputed tests <ref> [9, 58, 59, 68, 88, 93] </ref> have two particular advantages: (1) tests can be generated using multiple fault models for the same circuit, including the SSL fault model, as well as more accurate and technology-specific fault models; (2) tests that exist for previously designed modules can be reused when it is <p> A few simple propagation modes are often sufficient. One additional aspect of test generation using precomputed tests often leads to problems; the propagation of signals through the MUT in timeframes other than when the FTP is instantiated. M T M 58 This issue is handled in DB-TG <ref> [88] </ref> by optimistically assuming that the MUT only affects signals in one timeframe. PathPlan assumes that propagation is blocked. This problem is rarely mentioned in the literature. In some instances, the errors produced by the MUT can be propagated through the MUT even when it is faulty. <p> Future versions of MATSim will support user-defined functional modules; however, all functions must be decomposed into primitive functions, since the hierarchical signal value sets, discussed in Chapter IV, are designed for a fixed set of module functions. Abstraction and hierarchy have been used in fault simulation previously <ref> [77, 81, 89, 88] </ref>. The Multiple Abstraction Rule-Based Simulator (MARS) developed by Singh [89] propagates fault-free signals at several levels of abstraction. Module functions are implemented by rules stored in a database. However, only gate-level error signals are processed by MARS. <p> These fault simulators also do not process error signals more abstract than those due to SSL faults. Finally, Lee has implemented an architectural-level fault simulator ARSIM to speed up simulation for hierarchical circuits with precomputed tests for modules <ref> [88] </ref>. However, ARSIM does not propagate signals at multiple levels of abstraction.
Reference: 89. <author> N. Singh. </author> <title> An Artificial Intelligence Approach to Test Generation. </title> <publisher> Kluwer Academic Publishers, </publisher> <address> Boston, </address> <year> 1987. </year>
Reference-contexts: Artificial Intelligence-Based Methods. Finally, we will discuss three methods based on heuristic principles derived from artificial intelligence (AI). Saturn is a test generator with a strong focus on design hierarchy <ref> [89] </ref>. The circuit model that it uses has information about the structural hierarchy R R I:R R i j 20 and also about the rules of circuit behavior at the various levels of abstraction. <p> Still other techniques are based almost entirely on heuristics, so no generally applicable principles of test generation have been developed for them <ref> [88, 89] </ref>. Finally, few of the proposed techniques attempt a systematic approach to design for testability, despite the fact that hierarchical techniques can be implemented earlier in the design process. In general, the field of hierarchical test generation is still in its infancy. <p> Future versions of MATSim will support user-defined functional modules; however, all functions must be decomposed into primitive functions, since the hierarchical signal value sets, discussed in Chapter IV, are designed for a fixed set of module functions. Abstraction and hierarchy have been used in fault simulation previously <ref> [77, 81, 89, 88] </ref>. The Multiple Abstraction Rule-Based Simulator (MARS) developed by Singh [89] propagates fault-free signals at several levels of abstraction. Module functions are implemented by rules stored in a database. However, only gate-level error signals are processed by MARS. <p> Abstraction and hierarchy have been used in fault simulation previously [77, 81, 89, 88]. The Multiple Abstraction Rule-Based Simulator (MARS) developed by Singh <ref> [89] </ref> propagates fault-free signals at several levels of abstraction. Module functions are implemented by rules stored in a database. However, only gate-level error signals are processed by MARS. The CHIEFS concurrent, hierarchical fault simulator [77] also uses separate functional and structural models for each module in the structural hierarchy.
Reference: 90. <editor> F. Somenzi et al. </editor> <title> Testing Strategy and Technique for Macro-Based Circuits. </title> <journal> IEEE Trans. Comput., </journal> <volume> Vol. 34, No. 1, </volume> <pages> pp. 8590, </pages> <month> January </month> <year> 1985. </year>
Reference-contexts: Several of the proposed hierarchical techniques model the circuit in terms of high-level functional blocks interconnected by single-bit lines. The fault models can allow for arbitrary faults in these blocks, and the test generation algorithms used may be simple extensions of the classical ones described above. Somenzi et al. <ref> [90] </ref> described such a technique based on the D-algorithm, Chandra and Patel [18] proposed a similar technique based on PODEM, and more recently, SOCRATES [84] has included higher-level primitives. The fundamental advantage of higher-level modules is that there are fewer of them in the circuit to evaluate. <p> However, current techniques have many drawbacks, and so have not been widely implemented. Some of these techniques make use of the hierarchical modules of typical circuits, but retain a bit-level interconnection structure and related fault models <ref> [18, 90] </ref>. Thus, they do not realize the full potential of high-level error propagation because of the low-level interconnection structure. Other hierarchical testing techniques use higher-level models and bus-level interconnection structures, but use high-level fault models that are difficult to relate to more precise and well-accepted models [12, 64].
Reference: 91. <author> E. Sternheim, R. Singh, and Y. Trivedi. </author> <title> Design with Verilog HDL, </title> <publisher> Automata Publishing Co., </publisher> <address> Cupertino, CA, </address> <year> 1990. </year>
Reference-contexts: Any other signal propagated to Z denotes a conict which, when detected, causes the test generator to backtrack. Verilog Parser and Circuit Data Structure. MATSim reads circuit descriptions written in netlist form using a stylized subset of the Verilog simulation language <ref> [91] </ref>. The netlist may be hierarchical as discussed in Chapter I. An important feature of the netlists is that they are executable by a standard Verilog digital simulator, so the results of MATSim can be correlated with results from other simulators.
Reference: 92. <author> J. H. Stewart. </author> <title> Future Testing of Large LSI Circuit Cards in Proc. </title> <booktitle> Semiconductor Test Symp., </booktitle> <pages> pp. 617, </pages> <year> 1977. </year>
Reference-contexts: Therefore, connecting all memory modules of a circuit into a scan chain obviates the need for sequential test generation. There are many variations on the basic theme of scan design <ref> [7, 35, 92] </ref>. The most important design issue is whether to include all ip-op elements in scan chains (full scan) or only some of them (partial scan).
Reference: 93. <author> C-C Su and C. R. Kime. </author> <title> Multiple Path Sensitization for Hierarchical Circuit Testing, </title> <booktitle> in Proc. IEEE Int. Test Conf., </booktitle> <pages> pp. 152161, </pages> <year> 1990. </year>
Reference-contexts: This important capability is the main strategy in a number of experimental test generators <ref> [9, 58, 59, 68, 88, 93] </ref>. Currently evolving design styles, which rely heavily on CAD tools, are making this capability very desirable. Designers often reuse modules that have been stored in a library, and many of these modules do not have accurate gate-level models for test generation purposes. <p> Panther is tightly coupled to the design style, and the test generation tools assume that each individual module is directly accessible. Su and Kime <ref> [93] </ref> have developed a tool called HPath for sensitizing multiple (multi-bit) paths in a hierarchical circuit. These paths deliver precomputed test data from primary inputs to module inputs and propagate test responses from module outputs to primary outputs. <p> Hpath suffers from a similar inability to propagate error information through circuits with an irregular bus structure. Since HPath primarily uses heuristics, very few general principles are developed in <ref> [93] </ref> that might lead to the development of more advanced hierarchical test generators. In [93], Su and Kime report the average time required to sensitize paths to modules in several circuits, but this information is not compatible with other benchmark data. <p> Hpath suffers from a similar inability to propagate error information through circuits with an irregular bus structure. Since HPath primarily uses heuristics, very few general principles are developed in <ref> [93] </ref> that might lead to the development of more advanced hierarchical test generators. In [93], Su and Kime report the average time required to sensitize paths to modules in several circuits, but this information is not compatible with other benchmark data. <p> In general, the field of hierarchical test generation is still in its infancy. Hierarchical test generation techniques that can use precomputed tests <ref> [9, 58, 59, 68, 88, 93] </ref> have two particular advantages: (1) tests can be generated using multiple fault models for the same circuit, including the SSL fault model, as well as more accurate and technology-specific fault models; (2) tests that exist for previously designed modules can be reused when it is
Reference: 94. <author> S. M. Thatte and J. A. Abraham. </author> <title> Test Generation for Microprocessors. </title> <journal> IEEE Trans. Com-put., </journal> <volume> Vol. 29, </volume> <pages> pp. 429441, </pages> <month> June </month> <year> 1980. </year>
Reference-contexts: Functional Approaches. Another class of test generators called functional test generators check for incorrect operation of high-level functions. For example, Thatte and Abraham proposed a high-level test generation scheme based on a graph model of the circuit under test <ref> [94] </ref>. Their method was primarily designed for microprocessors and programmable circuits of similar nature. <p> Lin and Su model a variety of faults, including incorrect instruction decoding, and incorrect register transfers. [64]. Recently, Rao et. al. [75] have proposed a similar approach for VHDL models. In their approach, as well as that of Thatte and Abraham <ref> [94] </ref>, the faults are not described by well-accepted models, and the relationship of the faults to standard models is hard to quantify. Artificial Intelligence-Based Methods. Finally, we will discuss three methods based on heuristic principles derived from artificial intelligence (AI).
Reference: 95. <author> D. E. Thomas et al. </author> <title> Algorithmic and Register-Transfer Level Synthesis: The System Architects Workbench. </title> <publisher> Kluwer Academic Publishers, </publisher> <year> 1990. </year>
Reference-contexts: Although hierarchical test generation techniques have been proposed since the mid-1970s [10], only recently have they become practical to use, as design styles have evolved to the point where hierarchical design is well-supported. New CAD tools are able to synthesize gate and circuit-level simulation models from higher-level models <ref> [32, 95] </ref>. In many cases, designers compose circuits using libraries of large predefined modules such as ALUs and RAMs which have precom-puted tests, thus obviating the need for test generation at lower levels of abstraction, a fact which we explore here. <p> This circuit was generated by AutoCircuit, a high-level synthesis tool [32] being developed at General Motors Research and Development Center and based on the System Architects Workbench from Carnegie Mellon University <ref> [95] </ref>. The circuit Encode is part of a special-purpose communications chip. The modules in this circuit are synthesized by module generators. They are similar to library modules and gate-level netlists suitable for test generation are not available for all modules.
Reference: 96. <author> E. G. Ulrich and T. G. Baker. </author> <title> Concurrent Simulation of Nearly Identical Digital Networks, </title> <journal> IEEE Computer, </journal> <volume> Vol. 7, </volume> <pages> pp. 3944, </pages> <month> April </month> <year> 1974. </year>
Reference: 97. <author> E. G. Ulrich et al. </author> <title> The Comparative and Concurrent Simulation of Discrete-Event Experiments, </title> <journal> Journal of Electronic Testing, </journal> <volume> Vol. 3, </volume> <pages> pp. 107118. </pages>
Reference: 98. <author> R. L. Wadsack. </author> <title> Fault Modeling and Logic Simulation of CMOS and MOS Integrated Circuits. </title> <journal> The Bell System Technical Journal, </journal> <volume> Vol. 57, </volume> <pages> pp. 14491474, </pages> <month> May-June </month> <year> 1978. </year>
Reference-contexts: Since the SSL model only approximates the physical faults that occur in ICs, a considerable amount of work has been devoted to verifying it and to developing new, more accurate models. Problems with the SSL model, particularly for CMOS circuits, were identified as early as 1978 <ref> [98] </ref>, so CMOS circuits are sometimes modeled at the (very low) switch level [47], where transistors are treated as idealized switches. Recently, designers have also become concerned about two alternative types of faults. The first type is the delay fault.

References-found: 99

