URL: http://charm.cs.uiuc.edu/version2/papers/StructDaggerEURO96.ps
Refering-URL: http://charm.cs.uiuc.edu/version2/papers/StructDaggerEURO96.html
Root-URL: http://www.cs.uiuc.edu
Email: fkale,milindg@cs.uiuc.edu  
Title: Structured Dagger: A Coordination Language for Message-Driven Programming  
Author: Laxmikant V. Kale and Milind A. Bhandarkar 
Address: Urbana IL  
Affiliation: Department of Computer Science University of Illinois,  
Abstract: Message-Driven Programming style avoids the use of blocking receives and allows overlap of computation and communication by scheduling processes (or objects) depending on availability of messages. Charm is a parallel programming system that uses message-driven execution to exhibit latency-tolerance. Charm supports objects whose methods can be triggered by remote objects asynchronously. Such asynchronous invocation capability endows Charm programs to tolerate communication latencies in an adaptive manner. However, many parallel object-based applications require the object to coordinate the sequencing of the execution of their methods. Structured Dagger is a coordination language built on top of Charm that supports such applications by facilitating a clear expression of the flow of control within the object without losing the performance benefits of adaptive message-driven execution.
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> G.Agha, </author> <title> Actors: A Model of Concurrent Computation in Distributed Systems. </title> <publisher> MIT Press. </publisher> <year> 1986. </year>
Reference-contexts: Primitives are provided to selectively enable execution of individual methods. Unlike Structured Dagger, no direct expression of control flow across method invocations is possible. The enable set construct [8] addresses the issue of synchronization within Actors <ref> [1] </ref>. Using this, one may specify which messages may be processed in the new state. Any other messages that are received by an actor are buffered until the current enable set includes them. The ordering constructs in Structured Dagger achieve this in a cleaner manner.
Reference: 2. <author> E. Arjomandi et. al., </author> <title> "ABC++: Concurrency by inheritance in C++", </title> <journal> IBM Systems Journal, </journal> <volume> Vol 34, No. 1, </volume> <year> 1995. </year>
Reference-contexts: ABC++ <ref> [2] </ref> is a thread-based object-parallel language. Both synchronous and asynchronous remote method invocations are allowed. There is a single thread associated with each parallel object. This thread receives messages corresponding to method invocations and decides when and whether to invoke methods.
Reference: 3. <author> A.Gursoy, </author> <title> Message Driven Execution and its Impact on the Performance of CFD and other Applications, </title> <type> Ph.D Thesis, </type> <institution> University of Illinois at Urbana-Champaign, </institution> <month> Jan </month> <year> 1993. </year>
Reference-contexts: However, imposing an order on the arrival of messages, as is done in the traditional message-passing systems, tends to make the parallel program inefficient by letting the communication latency affect its performance. To solve this problem, a coordination language called Dagger <ref> [3] </ref> was de-veloped on top of the Charm programming system. However, the structure of Dagger programs still does not clearly express the flow of control in certain situations. <p> Even for a simple program such as this, the cost of context-switching in a multi-threaded program is very high, which justifies our use of message-driven execution in Structured Dagger. Table 1. Performance Results Program Charm Multi-Threaded Structured Dagger Time (seconds) 1.390 5.654 1.890 5 Related Work Dagger <ref> [3] </ref> is an earlier attempt to build a coordination language on top of Charm. The concept and structure of when-blocks in Structured Daggeris borrowed from Dagger.
Reference: 4. <author> K.Mani Chandy and C. Kesselman, </author> <title> "Compositional C++: Compositional Parallel Programming", </title> <type> Technical Report no. </type> <institution> Caltech-CS-TR-92-13, Department of Computer Science, California Institute of Technology, </institution> <year> 1992. </year>
Reference-contexts: However, the structure of Dagger programs is not as perspicuous as Structured Dagger because a Dagger program is a flat collection of when-blocks. Structured Dagger adds on to Dagger the ability to express dependences between the when-blocks with a cleaner structure, while sacrificing the generality that Dagger provides. CC++ <ref> [4] </ref> is an object-parallel language that bears some similarities to Structured Dagger. CC++ is a thread-based system. A computation consists of one or more processor objects each with its own address space. Objects within these processor objects can be accessed by remote objects using global pointers.
Reference: 5. <author> M. Hainer, D. Cronk and P. Mehrotra, </author> <title> "On the Design of Chant: A Talking Threads Package", </title> <booktitle> Proceedings of Supercomputing '94, </booktitle> <month> Nov </month> <year> 1994. </year>
Reference-contexts: Also they can interleave only in a disciplined fashion: only entire when-blocks can be interleaved, based on the arrival of messages, and not the individual C statements. The most important difference between Structured Dagger and CC++ (and other systems such as Chant <ref> [5] </ref>) has to do with threads.
Reference: 6. <author> L.V.Kale, </author> <title> "The Chare Kernel parallel programming language and system", </title> <booktitle> Proceedings of the International Conference on Parallel Processing, </booktitle> <volume> Vol II, </volume> <month> Aug </month> <year> 1990, </year> <month> pp17-25. </month>
Reference-contexts: This scheme minimizes the performance impact of communication latency by scheduling a ready process for execution while other processes are waiting for data. Charm <ref> [6] </ref> is one of the first object-based portable parallel programming languages that embodies message-driven execution and promotes modularity while exhibiting latency tolerance. The order of execution of processes is determined by the order of messages received. <p> The next section describes Charm language. Sections 3 and 4 discuss Structured Dagger language and its implementation. We discuss related work in section 5 and conclude in section 6. 2 Charm Charm is a machine independent parallel programming system <ref> [6] </ref>. Programs written using this system run unchanged on MIMD machines with or without shared memory. The programs are written in C with a few syntactic extensions. Charm currently runs on many distributed and shared memory parallel machines, as well as workstation networks.
Reference: 7. <author> L.V.Kale et.al., </author> <title> "Converse: An Interoperable Framework for Parallel Programming", </title> <note> Submitted to International Parallel Processing Symposium, </note> <year> 1996. </year>
Reference-contexts: We compared the performance of our Structured Dagger program with a Charm program and also with a multi-threaded program written using thread-objects in Converse <ref> [7] </ref>. The results for 10000 round-trip messages (each of size 4 bytes) are in table 1. As can be seen from these results, Structured Dagger program does not add significant overhead to the native Charm code, while it reduces the program complexity.
Reference: 8. <author> C.Tomlinson, V.Singh, </author> <title> "Inheritance and Synchronization with Enabled-Sets", </title> <booktitle> ACM OOPSLA 1989 , pp103-112. </booktitle>
Reference-contexts: This thread receives messages corresponding to method invocations and decides when and whether to invoke methods. Primitives are provided to selectively enable execution of individual methods. Unlike Structured Dagger, no direct expression of control flow across method invocations is possible. The enable set construct <ref> [8] </ref> addresses the issue of synchronization within Actors [1]. Using this, one may specify which messages may be processed in the new state. Any other messages that are received by an actor are buffered until the current enable set includes them.
Reference: 9. <institution> The CHARM(4.0) programming language manual, Department of Computer Science, University of Illinois at Urbana-Champaign, Urbana, IL, </institution> <year> 1993. </year> <title> This article was processed using the L a T E X macro package with LLNCS style </title>
Reference-contexts: The information sharing abstractions supported include readonly variables, monotonic variables, writeonce variables, accumulators and distributed tables. Charm also provides a sophisticated module system that facilitates reuse, and large-scale programming for parallel software. Details about these features can be found in <ref> [9] </ref>. chare mult chare f int count, *row, *col; ChareIDType chareid; entry init: (message MSG *msg) f count = 2; MyChareID (&chareid); Find (Atable, msg-&gt;row index, recv row, &chareid,NOWAIT); Find (Btable, msg-&gt;col index,recv col,&chareid,NOWAIT);g entry recv row: (message TBL MSG *msg) f row = msg-&gt;data; if (--count == 0 ) multiply
References-found: 9

