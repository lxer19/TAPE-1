URL: http://ftp.eecs.umich.edu/people/rundenst/papers/r-95-17.ps
Refering-URL: http://ftp.eecs.umich.edu/people/rundenst/papers/
Root-URL: http://www.eecs.umich.edu
Email: e-mail: ygra@eecs.umich.edu, rundenst@eecs.umich.edu  
Title: A Transparent Schema Evolution System Based on Object-Oriented View Technology 1  
Author: Young-Gook Ra and Elke A. Rundensteiner 
Keyword: Index Terms Schema Evolution, Object-Oriented View System, Interoperability, Capacity-augmenting Views, Software Legacy Problem, Object-Oriented Database.  
Address: Ann Arbor, MI 48109-2122  
Affiliation: Software Systems Research Laboratory Department of Electrical Engineering and Computer Science The University of Michigan  
Abstract: When a database is shared by many users, updates to the database schema are almost always prohibited because there is a risk of making existing application programs obsolete when they run against the modified schema. This paper addresses the problem by integrating schema evolution with view facilities. When new requirements necessitate schema updates for a particular user, then the user specifies schema changes to his personal view rather than to the shared base schema. Our view schema evolution approach then computes a new view schema that reflects the semantics of the desired schema change, and replaces the old view with the new one. We show that our system provides the means for schema change without affecting other views (and thus without affecting existing application programs). The persistent data is shared by different views of the schema, i.e., both old as well as newly developed applications can continue to interoperate. This paper describes a solution approach of realizing the evolution mechanism as a working system, which as its key feature requires the underlying object-oriented view system to support capacity-augmenting views. In this paper, we present algorithms that implement the complete set of typical schema evolution operations as view definitions. Lastly, we describe the transparent schema evolution system (TSE) that we have built on top of GemStone, including our solution for supporting capacity-augmenting view mechanisms. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> S. Abiteboul and A. Bonner, </author> <title> "Objects and views," </title> <booktitle> SIGMOD, </booktitle> <pages> pp. 238-247, </pages> <year> 1991. </year>
Reference-contexts: Other OODBs typically represent an object as a chunk of contiguous storage determined at object creation time. They assume the invariant that an object belongs to exactly one class only | and indirectly also to all the class's superclasses <ref> [1] </ref>. This clearly is no longer acceptable as foundation for our object-oriented view and schema change tools as demonstrated by the example above.
Reference: [2] <author> J. Andany, M. Leonard, and C. Palisser, </author> <title> "Management of schema evolution in databases," </title> <booktitle> in VLDB, </booktitle> <pages> pp. 161-170, </pages> <month> September </month> <year> 1991. </year>
Reference-contexts: Table 23 shows the comparisons of our TSE system with other systems such as Encore [35], Orion [11], Goose <ref> [2] </ref>, CLOSQL [20] and Rose [19]. Many of these systems utilize traditional versioning concepts. They typically construct new versions of the schema as well as of the object instances, with instances being assigned to the schema version under which they have been created. <p> The extended MultiView object model has been implemented on top of Gemstone, providing the necessary features of multiple classification and dynamic data restructuring to the TSE system [22]. We have demonstrated the TSE approach on a comprehensive set of schema evolution operators, i.e., those typically supported by OODBs <ref> [35, 11, 10, 19, 20, 2, 16, 37, 21] </ref>. As a result, we have also shown that object-preserving algebra operators, as provided by MultiView, are sufficient for supporting a comprehensive set of schema changes.
Reference: [3] <author> J. Banerjee, W. Kim, H. J. Kim, and H. F. Korth, </author> <title> "Semantics and implementation of schema evolution in object-oriented databases," </title> <booktitle> SIGMOD, </booktitle> <pages> pp. 311-322, </pages> <year> 1987. </year>
Reference-contexts: 1 INTRODUCTION Schema evolution is an important issue in Object-Oriented Database (OODB) research <ref> [3, 19, 20, 36, 11, 37] </ref>, not only because data models are less stable than expected [17], but also because typical OODB application areas such as CAD/CAM and multimedia information systems are not well understood and require frequent schema changes. <p> In our approach, old tools don't have to be rewritten or even recompiled for schema evolution because the old schema is "alive" despite the schema change. In this paper, we present algorithms for the complete set of schema evolution operations typically supported by current OODB systems <ref> [3, 19, 20, 36, 11, 37] </ref>. These algorithms and their successful realization into a system demonstrate the feasibility of view evolution for schema transformation. Furthermore, we show that a comprehensive set of schema transformations can be realized with object-preserving view mechanisms rather than object-generating ones. <p> In contrast to these prior works, we demonstrate the feasibility of a schema version mechanism using a view approach by presenting general algorithms for a comprehensive set of schema evolution operators. We show that TSE realizes all schema changes traditionally supported by commercial OODBs, such as Ithasca <ref> [3] </ref>, GemStone [6], and O 2 [37]. In fact, we show that an object-preserving query language is sufficient. Lastly, the TSE algorithms create a view schema that achieves the semantics of the schema change operations in the context of the complete inheritance hierarchy rather than only on individual classes. <p> Content-based evolution utilizes a query language to restructure relevant objects based on their content rather than just performing a syntax (type)-based transformation as done by most popular current schema evolution mechanisms <ref> [3, 21, 37] </ref>. For a simple example, suppose we want to keep track of the parking permit number only for fulltime staff. <p> base classes, called the origin classes of the virtual class, are the ones to which an update on the virtual class eventually will propagate to. 6 ALGORITHMS FOR REALIZING SCHEMA CHANGES IN THE TSE SYSTEM One of the first object-oriented schema change taxonomies has been proposed by Banerjee et al. <ref> [3] </ref> for the ORION data model. Note that this taxonomy, adopted in most other schema evolution research for OODBs such as Encore [35], Goose [10], CLOSQL [20], Rose [19], OTGen [16] and COCOON [36], still corresponds to the most frequently used set of schema changes. <p> data value for this attribute would become null when the transformation was achieved using a composition of the delete/add attribute operators according to the semantics of operators defined by Zicari [37], while it retains the old value of the attribute when transformed directly by the change-domain-attribute in the Orion taxonomy <ref> [3] </ref>. Thus, we have selected our set of schema change operations based on the Orion taxonomy. However, some operations in the Orion taxonomy [3] that are specific to the Orion data model are omitted , such as change 19 the order of inheritance priority, add a shared value, drop the shared <p> the semantics of operators defined by Zicari [37], while it retains the old value of the attribute when transformed directly by the change-domain-attribute in the Orion taxonomy <ref> [3] </ref>. Thus, we have selected our set of schema change operations based on the Orion taxonomy. However, some operations in the Orion taxonomy [3] that are specific to the Orion data model are omitted , such as change 19 the order of inheritance priority, add a shared value, drop the shared value, etc. <p> for other operators can be found elsewhere [24]. 6.1 Implementing the Add-Attribute Schema Change in TSE 6.1.1 Semantics of the Add-Attribute Operator The schema change operator defined by "add attribute x:attribute-domain to C" augments the types of the class C and its subclasses C sub with the new attribute x <ref> [3] </ref>. The extents of the classes are not changed in terms of membership. However, the instance objects of the classes now have one additional attribute x. <p> NULL do for all subclasses (C sub ) of the class tmp if attribute x not locally defined in tmp then f defineVC C 0 sub as (refine C 0 :x for C sub ); 14 push C sub onto tmpStack; g 13 This corresponds to semantics chosen by Orion <ref> [3] </ref>. 14 The instances of the C sub class are restructured by refining the x attribute. 26 (a) Person Student TA salary register name : String : Integer : Status Old View Student TA Person Student TA name gpa salary ' register View-b Student'' TA'' : String : Status : Integer <p> An operator with these semantics is already provided by a command of the view specification language, removeFromView aClass, of MultiView [27]. A more complex version of this delete-class operator with the same semantics as the delete-class in Orion <ref> [3] </ref> can be achieved by composing several simpler change operators in our system. This will be shown in Section 6.11.2. 6.10 Implementing Rename Operators In our system, each view and global schema has their own name space. <p> Examples of achieving the complex schema change of inserting a class between two existing classes or of deleting a class with the same semantics as that of delete-class in Orion <ref> [3] </ref> are discussed below. 6.11.1 Constructing the Insert-Class Schema Change in TSE Semantics of the Insert-Class Operator: The schema change defined by "insert-class C insert between C sup -C sub " creates a class C insert as subclass of C sup and superclass of C sub .
Reference: [4] <author> E. Bertino, </author> <title> "A view mechanism for object-oriented databases," </title> <booktitle> in 3rd International Conference on Extending Database Technology, </booktitle> <pages> pp. 136-151, </pages> <month> March </month> <year> 1992. </year>
Reference-contexts: The use of view mechanisms to achieve schema evolution has also recently been advocated by other researchers <ref> [36, 32, 4] </ref>. For instance, [36] presents several examples of schema changes that can be simulated by views. However they do not give general algorithms and/or any implementation solutions. <p> However they do not give general algorithms and/or any implementation solutions. The O 2 view paper [32] refers to the issue of schema evolution as a potential feature but no details on how this could be achieved nor any examples are given. <ref> [4] </ref> is the closest work in the sense that it discusses how an individual class can be modified using view specifications in place of schema modification operators. However, the effect of such class modifications on its subclasses is not considered. <p> They state that schema evolution can be simulated using views if they are not capacity-augmenting. In this paper, we now take the opposite stand of exploring what extensions to view technology must be done to support such described schema changes. Bertino <ref> [4] </ref> also presents a view mechanism and indicates that it can be utilized to simulate schema evolution. Like our TSE system, the proposed mechanism is capacity-augmenting in that new stored attributes can be added to a view.
Reference: [5] <author> S. E. Bratsberg, </author> <title> "Unified class evolution by object-oriented views," </title> <booktitle> in Proc. 12th Intl. Conf. on the Entity-Relationship Approach, </booktitle> <pages> pp. 423-439, </pages> <year> 1992. </year>
Reference-contexts: Also, implementation issues such as how to deal with the requirements of multiple classification and flexible restructuring are not discussed. TSE system goes one step further by presenting the algorithms to achieve the schema evolution for a comprehensive set of schema change operations. Bratsberg <ref> [5] </ref> presents a design of a schema evolution system that is also based on object-oriented views. The system makes the evolution transparent like TSE, i.e., existing and new applications coexist and share the same set of objects.
Reference: [6] <author> P. Butterworth, A. Otis, and J. Stein, </author> <title> "The GemStone object database management systemversion," </title> <journal> Communications of the ACM, </journal> <volume> vol. 34, no. 10, </volume> <pages> pp. 64-77, </pages> <month> October </month> <year> 1991. </year>
Reference-contexts: In contrast to these prior works, we demonstrate the feasibility of a schema version mechanism using a view approach by presenting general algorithms for a comprehensive set of schema evolution operators. We show that TSE realizes all schema changes traditionally supported by commercial OODBs, such as Ithasca [3], GemStone <ref> [6] </ref>, and O 2 [37]. In fact, we show that an object-preserving query language is sufficient. Lastly, the TSE algorithms create a view schema that achieves the semantics of the schema change operations in the context of the complete inheritance hierarchy rather than only on individual classes.
Reference: [7] <author> S. M. Clamen, </author> <title> "Type evolution and instance adaptation," </title> <type> Technical Report CMU-CS-92-133R, </type> <institution> Carnegie Mellon University, School of Computer Science, </institution> <year> 1992. </year>
Reference-contexts: In such a system, the user's responsibility would be great even if the system provides the default conversion functions. In addition, the computation time for conversion might be a significant overhead, and extensions for handling new stored attributes appear not to have been dealt with. Clamen <ref> [7] </ref> also presents an alternative solution for the transparency issue. His work is a generalization of Zdonik's type change management [35], described above.
Reference: [8] <author> D. Fishman, </author> <title> "Iris: An object oriented database management system," </title> <journal> in ACM Transactions on Office Information Systems, </journal> <volume> volume 5, </volume> <pages> pp. 48-69, </pages> <month> January </month> <year> 1987. </year>
Reference-contexts: This situation of an object being classified as instance of more than one class even though the classes are not super/subclass of each other is commonly called multiple classification. To the best of our knowledge, current OODB systems do not support multiple classification. The only exception is IRIS <ref> [8] </ref> a functional database system that actually uses a relational database as storage structure, storing data from one object across many relations. Other OODBs typically represent an object as a chunk of contiguous storage determined at object creation time.
Reference: [9] <author> S. Heiler and S. B. Zdonik, </author> <title> "Object views: Extending the vision," </title> <booktitle> in IEEE International Conference on Data Engineering, </booktitle> <pages> pp. 86-93, </pages> <year> 1990. </year>
Reference-contexts: Create, delete, add, remove and set update operators applied to an instance of a virtual select class work on the source class. Creation, addition and setting values of objects that do not fulfill the selection predicate of the select class lead to the so-called value closure problem <ref> [9] </ref>. There are two solutions to this problem: (1) reject such creation/addition/set, or (2) allow them by inserting them into the source class or setting the value, even though the objects will not be visible through the select class.
Reference: [10] <author> H. J. Kim, </author> <title> Issues in Object-Oriented Database Systems, </title> <type> PhD thesis, </type> <institution> University of Texas at Austin, </institution> <month> May </month> <year> 1988. </year>
Reference-contexts: The new view is assigned to the user, while the old one is maintained by the system for other application programs. In TSE, unlike in other systems <ref> [11, 10] </ref>, the scope of a schema version (view) is not confined to the objects which have been created under this particular schema version. <p> Each of these advantages is further detailed below. 3.1 Instance Sharing Among Schema Versions Most schema version systems <ref> [11, 10] </ref> utilize traditional versioning concepts where new versions of the schema and object instances are constructed, with every instance of the old schema being copied and converted to become an instance of the new schema version. <p> Note that this taxonomy, adopted in most other schema evolution research for OODBs such as Encore [35], Goose <ref> [10] </ref>, CLOSQL [20], Rose [19], OTGen [16] and COCOON [36], still corresponds to the most frequently used set of schema changes. In fact, most commercial OODB systems such as O 2 [37] and GemStone [21] only support a subset of this taxonomy. <p> This is a MultiView module, too. 46 8 RELATED RESEARCH 8.1 Comparison Criteria The continued support of old programs when performing schema evolution has been recognized as a key issue in the literature <ref> [35, 11, 10, 19] </ref>. <p> Some systems require the user to provide the exception handlers to resolve the type mismatches between the underlying object instance representation and the schema to access it [35]. Others require the user to keep track of class versions for each valid schema <ref> [10] </ref>. * flexibility to build a new schema from class versions: It refers to the capability of composing various schemas by combining class versions. <p> By adopting the view mechanism as foundation for our approach, the object instances are shared by all views, independently from the order in which these view schemas were created. This removes the inconsistency caused by not allowing back propagation in the schema version approach. Kim et al. <ref> [10] </ref> propose the versioning of individual classes instead of the entire schema. A complete schema is constructed in Goose by selecting a version from each class. <p> The extended MultiView object model has been implemented on top of Gemstone, providing the necessary features of multiple classification and dynamic data restructuring to the TSE system [22]. We have demonstrated the TSE approach on a comprehensive set of schema evolution operators, i.e., those typically supported by OODBs <ref> [35, 11, 10, 19, 20, 2, 16, 37, 21] </ref>. As a result, we have also shown that object-preserving algebra operators, as provided by MultiView, are sufficient for supporting a comprehensive set of schema changes.
Reference: [11] <author> W. Kim and H. Chou, </author> <title> "Versions of schema for oodbs," </title> <booktitle> in Proc. 14th VLDB, </booktitle> <pages> pp. 148-159, </pages> <year> 1988. </year>
Reference-contexts: 1 INTRODUCTION Schema evolution is an important issue in Object-Oriented Database (OODB) research <ref> [3, 19, 20, 36, 11, 37] </ref>, not only because data models are less stable than expected [17], but also because typical OODB application areas such as CAD/CAM and multimedia information systems are not well understood and require frequent schema changes. <p> The new view is assigned to the user, while the old one is maintained by the system for other application programs. In TSE, unlike in other systems <ref> [11, 10] </ref>, the scope of a schema version (view) is not confined to the objects which have been created under this particular schema version. <p> In our approach, old tools don't have to be rewritten or even recompiled for schema evolution because the old schema is "alive" despite the schema change. In this paper, we present algorithms for the complete set of schema evolution operations typically supported by current OODB systems <ref> [3, 19, 20, 36, 11, 37] </ref>. These algorithms and their successful realization into a system demonstrate the feasibility of view evolution for schema transformation. Furthermore, we show that a comprehensive set of schema transformations can be realized with object-preserving view mechanisms rather than object-generating ones. <p> Each of these advantages is further detailed below. 3.1 Instance Sharing Among Schema Versions Most schema version systems <ref> [11, 10] </ref> utilize traditional versioning concepts where new versions of the schema and object instances are constructed, with every instance of the old schema being copied and converted to become an instance of the new schema version. <p> TA salary UnderGrad level Teaching Staff Support Staff Person name advisor boss lecture Staff permitNumber Parking-View1 Parking-View2 Staff2 permitNumber Fulltime Staff status Fulltime Staff2 View Specification: union ( TeachingStaff, SupportStaff ) Staff select Staff where status = 'fulltime' FulltimeStaff := := to FulltimeStaff Schema Evolution: (add-attribute ) 9 version systems <ref> [11, 35] </ref>. First, if instances have been copied for each version, all instance versions (duplicates) with the same object identity should be merged into a single instance. Second, the two separate schemas must be combined into one consistent schema, integrating also their generalization and aggregation hierarchies. <p> This is a MultiView module, too. 46 8 RELATED RESEARCH 8.1 Comparison Criteria The continued support of old programs when performing schema evolution has been recognized as a key issue in the literature <ref> [35, 11, 10, 19] </ref>. <p> Second, the content-based derivation power of views could be exploited to support more complex schema customizations as possible with the graph manipulation operators typically supported by schema evolution (See Section 3.2). Table 23 shows the comparisons of our TSE system with other systems such as Encore [35], Orion <ref> [11] </ref>, Goose [2], CLOSQL [20] and Rose [19]. Many of these systems utilize traditional versioning concepts. They typically construct new versions of the schema as well as of the object instances, with instances being assigned to the schema version under which they have been created. <p> This approach forces the user to manage the virtual versions of schemas by keeping track of which versions of types belong to which virtual versions 48 of the schema. The schema version mechanism proposed for Orion by Kim and Chou <ref> [11] </ref> keeps versions of the whole schema hierarchy instead of the individual classes or types. Every instance object of an old version schema can be copied and converted to become an instance of the new version schema. <p> The extended MultiView object model has been implemented on top of Gemstone, providing the necessary features of multiple classification and dynamic data restructuring to the TSE system [22]. We have demonstrated the TSE approach on a comprehensive set of schema evolution operators, i.e., those typically supported by OODBs <ref> [35, 11, 10, 19, 20, 2, 16, 37, 21] </ref>. As a result, we have also shown that object-preserving algebra operators, as provided by MultiView, are sufficient for supporting a comprehensive set of schema changes.
Reference: [12] <author> H. A. Kuno, Y. G. Ra, and E. A. Rundensteiner, </author> <title> "The object-slicing technique: A flexible object representation and its evaluation," </title> <type> Technical Report CSE-TR-241-95, </type> <institution> University of Michigan, </institution> <year> 1995. </year>
Reference-contexts: Below, we present the object model paradigm that we have developed to address these requirements 22 . 7.2 Solutions For the Required Properties We identify two general approaches for implementing multiple classification in OODBs: (1) the intersection-class approach and (2) the object-slicing approach <ref> [18, 12] </ref>. We'll describe these two approaches below, contrasting them with respect to how they meet the three identified requirements. Assume that given the schema in Figure 19 (a), we want to create a new car object o1 that is both of type J eep and of type Imported. <p> We have chosen the object-slicing approach as the basic architecture of our system because an explosion of intersection classes is likely to be generated in the intersection-class approach <ref> [12] </ref>. In the worst case, the number of intersection classes could grow exponentially with respect to the number of user-defined classes. Also, as demonstrated above, dynamic classification may require the creation and/or removal of intersection-classes on the fly.
Reference: [13] <author> H. A. Kuno and E. A. Rundensteiner, </author> <title> "Developing an object-oriented view management system," </title> <booktitle> in Centre for Advanced Studies Conference, </booktitle> <pages> pp. 548-562, </pages> <month> October </month> <year> 1993. </year>
Reference-contexts: our view approach makes the schema transition easy and smooth by keeping the old schema "alive" as long as needed. 3.2 Increased Functionality by Integrating View and Evolution Mechanisms Views allow a programmer to restructure the database to meet the specific needs of an application without affecting other application programs <ref> [13, 33, 27] </ref>. View mechanisms typically provide the functionality to restructure a base schema by hiding classes, by adding classes, by customizing the behavior or extent of classes, and by rearranging the generalization hierarchy. <p> Lastly, a prototype of MultiView has been implemented at the University of Michigan, and thus can be utilized as platform for constructing the TSE system <ref> [13, 22] </ref>. The MultiView system assumes an object model that corresponds to core object model features generally agreed-upon in the literature (for example, encapsulation, full inheritance, polymorphism, multiple inheritance, etc.). A detailed discussion can be found in [27]. <p> change into a set of object algebra statements that define all necessary virtual classes (corresponding to MultiView's object algebra extended as described in Section 5.1). * The Extended Object Algebra Processor takes a set of algebra statements as input and actually creates appropriate virtual classes (also see Section 5.1 and <ref> [13] </ref>).
Reference: [14] <author> H. A. Kuno and E. A. Rundensteiner, </author> <title> "Incremental update propagation algorithms for materialized object-oriented views in MultiView," </title> <type> Technical report, </type> <institution> University of Michigan, </institution> <address> Ann Arbor, </address> <month> June </month> <year> 1995. </year>
Reference-contexts: Another extension of TSE we are considering concerns the treatment of more powerful data models e.g., has-part aggregation and others such as semantic relationships, or even general constraints [31]. While we are currently developing algorithms for incremental maintenance of materialized views in MultiView <ref> [15, 14] </ref>, we also want to develop specialized optimization strategies for update propagation in our TSE system. This is important because the update on a virtual class may have to be propagated through chains of dependent classes. 51
Reference: [15] <author> H. A. Kuno and E. A. Rundensteiner, </author> <title> "Materialized object-oriented views in MultiView," </title> <booktitle> in ACM Research Issues in Data Engineering Workshop, </booktitle> <pages> pp. 78-85, </pages> <month> March </month> <year> 1995. </year>
Reference-contexts: Another extension of TSE we are considering concerns the treatment of more powerful data models e.g., has-part aggregation and others such as semantic relationships, or even general constraints [31]. While we are currently developing algorithms for incremental maintenance of materialized views in MultiView <ref> [15, 14] </ref>, we also want to develop specialized optimization strategies for update propagation in our TSE system. This is important because the update on a virtual class may have to be propagated through chains of dependent classes. 51
Reference: [16] <author> B. S. Lerner and A. N. Habermann, </author> <title> "Beyond schema evolution to database reorganization," </title> <booktitle> in OOPSLA, </booktitle> <pages> pp. 67-76, </pages> <year> 1990. </year>
Reference-contexts: Note that this taxonomy, adopted in most other schema evolution research for OODBs such as Encore [35], Goose [10], CLOSQL [20], Rose [19], OTGen <ref> [16] </ref> and COCOON [36], still corresponds to the most frequently used set of schema changes. In fact, most commercial OODB systems such as O 2 [37] and GemStone [21] only support a subset of this taxonomy. <p> The extended MultiView object model has been implemented on top of Gemstone, providing the necessary features of multiple classification and dynamic data restructuring to the TSE system [22]. We have demonstrated the TSE approach on a comprehensive set of schema evolution operators, i.e., those typically supported by OODBs <ref> [35, 11, 10, 19, 20, 2, 16, 37, 21] </ref>. As a result, we have also shown that object-preserving algebra operators, as provided by MultiView, are sufficient for supporting a comprehensive set of schema changes.
Reference: [17] <author> S. Marche, </author> <title> "Measuring the stability of data models," </title> <journal> European Journal of Information Systems, </journal> <volume> vol. 2, no. 1, </volume> <pages> pp. 37-47, </pages> <year> 1993. </year>
Reference-contexts: 1 INTRODUCTION Schema evolution is an important issue in Object-Oriented Database (OODB) research [3, 19, 20, 36, 11, 37], not only because data models are less stable than expected <ref> [17] </ref>, but also because typical OODB application areas such as CAD/CAM and multimedia information systems are not well understood and require frequent schema changes. However, even with the schema evolution support provided by most OODBs, schema updates on shared OODBs are problematic.
Reference: [18] <author> J. Martin and J. Odell, </author> <title> Object-Oriented Analysis and Design, </title> <publisher> Prentice-Hall, Inc., </publisher> <year> 1992. </year>
Reference-contexts: Below, we present the object model paradigm that we have developed to address these requirements 22 . 7.2 Solutions For the Required Properties We identify two general approaches for implementing multiple classification in OODBs: (1) the intersection-class approach and (2) the object-slicing approach <ref> [18, 12] </ref>. We'll describe these two approaches below, contrasting them with respect to how they meet the three identified requirements. Assume that given the schema in Figure 19 (a), we want to create a new car object o1 that is both of type J eep and of type Imported.
Reference: [19] <author> A. Mehta, D. L. Spooner, and M. Hardwick, </author> <title> "Resolution of type mismatches in an engineering persistent object system," in Techn. </title> <type> Report, </type> <institution> Computer Science Dept., Rensselaer Polytechnic Institute, </institution> <year> 1993. </year>
Reference-contexts: 1 INTRODUCTION Schema evolution is an important issue in Object-Oriented Database (OODB) research <ref> [3, 19, 20, 36, 11, 37] </ref>, not only because data models are less stable than expected [17], but also because typical OODB application areas such as CAD/CAM and multimedia information systems are not well understood and require frequent schema changes. <p> In our approach, old tools don't have to be rewritten or even recompiled for schema evolution because the old schema is "alive" despite the schema change. In this paper, we present algorithms for the complete set of schema evolution operations typically supported by current OODB systems <ref> [3, 19, 20, 36, 11, 37] </ref>. These algorithms and their successful realization into a system demonstrate the feasibility of view evolution for schema transformation. Furthermore, we show that a comprehensive set of schema transformations can be realized with object-preserving view mechanisms rather than object-generating ones. <p> Note that this taxonomy, adopted in most other schema evolution research for OODBs such as Encore [35], Goose [10], CLOSQL [20], Rose <ref> [19] </ref>, OTGen [16] and COCOON [36], still corresponds to the most frequently used set of schema changes. In fact, most commercial OODB systems such as O 2 [37] and GemStone [21] only support a subset of this taxonomy. <p> This is a MultiView module, too. 46 8 RELATED RESEARCH 8.1 Comparison Criteria The continued support of old programs when performing schema evolution has been recognized as a key issue in the literature <ref> [35, 11, 10, 19] </ref>. <p> Table 23 shows the comparisons of our TSE system with other systems such as Encore [35], Orion [11], Goose [2], CLOSQL [20] and Rose <ref> [19] </ref>. Many of these systems utilize traditional versioning concepts. They typically construct new versions of the schema as well as of the object instances, with instances being assigned to the schema version under which they have been created. <p> This gives flexibility to the user in constructing many possible schemas, but it also results in the overhead of figuring out whether a given schema is consistent. Mehta et. al propose a unique approach that enables the different schema versions to share the objects in the Rose system <ref> [19] </ref>. Instead of exception handlers for type mismatches between the object and the schema, an intelligent interface and object manager are used to resolve mismatches. The interface compares the schema of the persistent object and the schema defined by an application program and maps the persistent object into main memory. <p> The extended MultiView object model has been implemented on top of Gemstone, providing the necessary features of multiple classification and dynamic data restructuring to the TSE system [22]. We have demonstrated the TSE approach on a comprehensive set of schema evolution operators, i.e., those typically supported by OODBs <ref> [35, 11, 10, 19, 20, 2, 16, 37, 21] </ref>. As a result, we have also shown that object-preserving algebra operators, as provided by MultiView, are sufficient for supporting a comprehensive set of schema changes.
Reference: [20] <author> S. Monk and I. Sommerville, </author> <title> "Schema evolution in oodbs using class versioning," </title> <booktitle> in SIGMOD RECORD, </booktitle> <volume> VOL. 22, NO.3, </volume> <month> September </month> <year> 1993. </year>
Reference-contexts: 1 INTRODUCTION Schema evolution is an important issue in Object-Oriented Database (OODB) research <ref> [3, 19, 20, 36, 11, 37] </ref>, not only because data models are less stable than expected [17], but also because typical OODB application areas such as CAD/CAM and multimedia information systems are not well understood and require frequent schema changes. <p> In our approach, old tools don't have to be rewritten or even recompiled for schema evolution because the old schema is "alive" despite the schema change. In this paper, we present algorithms for the complete set of schema evolution operations typically supported by current OODB systems <ref> [3, 19, 20, 36, 11, 37] </ref>. These algorithms and their successful realization into a system demonstrate the feasibility of view evolution for schema transformation. Furthermore, we show that a comprehensive set of schema transformations can be realized with object-preserving view mechanisms rather than object-generating ones. <p> Note that this taxonomy, adopted in most other schema evolution research for OODBs such as Encore [35], Goose [10], CLOSQL <ref> [20] </ref>, Rose [19], OTGen [16] and COCOON [36], still corresponds to the most frequently used set of schema changes. In fact, most commercial OODB systems such as O 2 [37] and GemStone [21] only support a subset of this taxonomy. <p> Table 23 shows the comparisons of our TSE system with other systems such as Encore [35], Orion [11], Goose [2], CLOSQL <ref> [20] </ref> and Rose [19]. Many of these systems utilize traditional versioning concepts. They typically construct new versions of the schema as well as of the object instances, with instances being assigned to the schema version under which they have been created. <p> This approach is powerful for resolving type mismatches, but the performance of the interface may become the bottleneck of an application which requires lots of secondary storage access. The class versioning approach CLOSQL, proposed by Monk <ref> [20] </ref>, provides update/backdate functions for each attribute which convert the instances from the format in which the instance is stored to the format that an application program expects. In such a system, the user's responsibility would be great even if the system provides the default conversion functions. <p> The extended MultiView object model has been implemented on top of Gemstone, providing the necessary features of multiple classification and dynamic data restructuring to the TSE system [22]. We have demonstrated the TSE approach on a comprehensive set of schema evolution operators, i.e., those typically supported by OODBs <ref> [35, 11, 10, 19, 20, 2, 16, 37, 21] </ref>. As a result, we have also shown that object-preserving algebra operators, as provided by MultiView, are sufficient for supporting a comprehensive set of schema changes.
Reference: [21] <author> D. J. Penney and J. Stein, </author> <title> "Class modification in the gemstone object-oriented dbms," </title> <booktitle> in OOPSLA, </booktitle> <pages> pp. 111-117, </pages> <year> 1987. </year>
Reference-contexts: Content-based evolution utilizes a query language to restructure relevant objects based on their content rather than just performing a syntax (type)-based transformation as done by most popular current schema evolution mechanisms <ref> [3, 21, 37] </ref>. For a simple example, suppose we want to keep track of the parking permit number only for fulltime staff. <p> In fact, most commercial OODB systems such as O 2 [37] and GemStone <ref> [21] </ref> only support a subset of this taxonomy. To demonstrate the feasibility of the TSE approach, it is thus important to show that our approach can realize all the schema change operations supported by Orion. <p> The extended MultiView object model has been implemented on top of Gemstone, providing the necessary features of multiple classification and dynamic data restructuring to the TSE system [22]. We have demonstrated the TSE approach on a comprehensive set of schema evolution operators, i.e., those typically supported by OODBs <ref> [35, 11, 10, 19, 20, 2, 16, 37, 21] </ref>. As a result, we have also shown that object-preserving algebra operators, as provided by MultiView, are sufficient for supporting a comprehensive set of schema changes.
Reference: [22] <author> Y. G. Ra, H. A. Kuno, and E. A. Rundensteiner, </author> <title> "A flexible object-oriented database model and implementation for capacity-augmenting views," </title> <type> Technical Report CSE-TR-215-94, </type> <institution> University of Michigan, </institution> <year> 1994. </year>
Reference-contexts: Lastly, a prototype of MultiView has been implemented at the University of Michigan, and thus can be utilized as platform for constructing the TSE system <ref> [13, 22] </ref>. The MultiView system assumes an object model that corresponds to core object model features generally agreed-upon in the literature (for example, encapsulation, full inheritance, polymorphism, multiple inheritance, etc.). A detailed discussion can be found in [27]. <p> Based on the examples given in Section 6, it has become apparent that the implementation necessitates the underlying object-oriented view mechanism to be capacity-augmenting. Thus, MultiView has been extended with this capability <ref> [22] </ref>. We also discuss the requirements imposed on the object model to support the MultiView extension and the implementation issues of the required object model. <p> We have successfully addressed this problem using an object-slicing approach. The extended MultiView object model has been implemented on top of Gemstone, providing the necessary features of multiple classification and dynamic data restructuring to the TSE system <ref> [22] </ref>. We have demonstrated the TSE approach on a comprehensive set of schema evolution operators, i.e., those typically supported by OODBs [35, 11, 10, 19, 20, 2, 16, 37, 21].
Reference: [23] <author> Y. G. Ra and E. A. Rundensteiner, </author> <title> "OODB support for providing transparent schema changes," </title> <booktitle> in Centre for Advanced Studies Conference, </booktitle> <year> 1994. </year>
Reference-contexts: Object-Slicing Approach. Intersection-Class Approach. extension with capacity-augmentation capabilities, which are multiple classification, dynamic reclassification and flexible restructuring of the object representation (more details found in <ref> [23] </ref>). Below, we present the object model paradigm that we have developed to address these requirements 22 . 7.2 Solutions For the Required Properties We identify two general approaches for implementing multiple classification in OODBs: (1) the intersection-class approach and (2) the object-slicing approach [18, 12].
Reference: [24] <author> Y. G. Ra and E. A. Rundensteiner, </author> <title> "A transparent object-oriented schema change approach using view schema evolution," </title> <type> Technical Report CSE-TR-211-94, </type> <institution> University of Michigan, </institution> <year> 1994. </year> <month> 52 </month>
Reference-contexts: Below, we present algorithms for translating a schema change into a number of view definition statements for each primitive schema update operator. A verification of correctness is given for the add-attribute and add-class operations to demonstrate the general idea, while the verifications for other operators can be found elsewhere <ref> [24] </ref>. 6.1 Implementing the Add-Attribute Schema Change in TSE 6.1.1 Semantics of the Add-Attribute Operator The schema change operator defined by "add attribute x:attribute-domain to C" augments the types of the class C and its subclasses C sub with the new attribute x [3].
Reference: [25] <author> Y. G. Ra and E. A. Rundensteiner, </author> <title> "A transparent object-oriented schema change approach using view schema evolution," </title> <booktitle> in IEEE International Conference on Data Engineering, </booktitle> <pages> pp. 165-172, </pages> <month> March </month> <year> 1995. </year>
Reference-contexts: In fact, we show that an object-preserving query language is sufficient. Lastly, the TSE algorithms create a view schema that achieves the semantics of the schema change operations in the context of the complete inheritance hierarchy rather than only on individual classes. An earlier conference paper <ref> [25] </ref> contains a preliminary discussion of the TSE approach. In this current paper, we go beyond this work in several aspects. First, we now present TSE algorithms for all typical schema evolution operations, including proofs of correctness, and proofs of updatability.
Reference: [26] <author> J. Richardson and P. Schwarz, </author> <title> "Aspects: Extending objects to support multiple, independent roles," </title> <booktitle> SIGMOD, </booktitle> <pages> pp. 298-307, </pages> <year> 1991. </year>
Reference-contexts: The object-slicing techniques underlying the current implementation of MultiView can be compared to role modeling systems, such as Aspects <ref> [26] </ref>. In role modeling systems, objects dynamically gain and lose multiple interfaces (aka roles) throughout their lifetimes. These roles can be compared to the implementation objects of an object-slicing implementation, in that both permit objects to belong to multiple classes and change types dynamically.
Reference: [27] <author> E. A. Rundensteiner, </author> <title> "MultiView: A methodology for supporting multiple views in object-oriented databases," </title> <booktitle> in 18th VLDB Conference, </booktitle> <pages> pp. 187-198, </pages> <year> 1992. </year>
Reference-contexts: Another contribution of the work presented in this paper is to outline a strategy 2 A capacity-augmenting change is defined to be schema restructuring to enhance the information content of the schema. 2 for extending the MultiView system <ref> [27] </ref> to also support capacity-augmentation using views. The use of view mechanisms to achieve schema evolution has also recently been advocated by other researchers [36, 32, 4]. For instance, [36] presents several examples of schema changes that can be simulated by views. <p> our view approach makes the schema transition easy and smooth by keeping the old schema "alive" as long as needed. 3.2 Increased Functionality by Integrating View and Evolution Mechanisms Views allow a programmer to restructure the database to meet the specific needs of an application without affecting other application programs <ref> [13, 33, 27] </ref>. View mechanisms typically provide the functionality to restructure a base schema by hiding classes, by adding classes, by customizing the behavior or extent of classes, and by rearranging the generalization hierarchy. <p> problems based on object-oriented view mechanisms, as further outlined below. 5 MultiView: THE VIEW SYSTEM SUPPORTING TSE REALIZA TION Since our view schema evolution approach TSE is based on object-oriented view techniques, we describe below the view system we have developed towards the specification and maintenance of views, called MultiView <ref> [27] </ref>. Unlike most other object-oriented view mechanisms, MultiView creates a complete view schema rather than just 5 This relates to property of view independence defined in [27], that an OO view in our view system is not affected by global schema classification. 12 deriving individual virtual classes. <p> is based on object-oriented view techniques, we describe below the view system we have developed towards the specification and maintenance of views, called MultiView <ref> [27] </ref>. Unlike most other object-oriented view mechanisms, MultiView creates a complete view schema rather than just 5 This relates to property of view independence defined in [27], that an OO view in our view system is not affected by global schema classification. 12 deriving individual virtual classes. Furthermore, views in MultiView allow for the insertion of new classes or the modification of existing classes in the middle of the class hierarchy. <p> In addition, MultiView offers the following features that made it suitable as foundation for our schema change approach. First, it generates updatable views <ref> [27] </ref> (requirement 2). Second, several of the view specification subtasks are already automated, and can be reused in our system, such as virtual class insertion into the global schema [29] and generation of the view schema [28]. <p> The MultiView system assumes an object model that corresponds to core object model features generally agreed-upon in the literature (for example, encapsulation, full inheritance, polymorphism, multiple inheritance, etc.). A detailed discussion can be found in <ref> [27] </ref>. <p> For the first subtask, MultiView provides the user with an object algebra for class derivation <ref> [27, 30] </ref>. An example of a virtual class creation is shown in Figure 6. The second subtask is automated in MultiView by the classification algorithm [29]. <p> Using a view system as foundation of 13 TSE clearly offers a solution to requirement 3. MultiView has been shown to meet requirement 1 (which essentially corresponds to the view independency property shown in <ref> [27] </ref>). 5.1 Extending Object Algebra for Capacity-Augmenting Views Since our view schema evolution approach is built using the MultiView system, we utilize MultiView's view definition language, an object algebra [27, 30, 29, 28], as foundation of our TSE system. While a complete description of the algebra can be found elsewhere [27], <p> MultiView has been shown to meet requirement 1 (which essentially corresponds to the view independency property shown in [27]). 5.1 Extending Object Algebra for Capacity-Augmenting Views Since our view schema evolution approach is built using the MultiView system, we utilize MultiView's view definition language, an object algebra <ref> [27, 30, 29, 28] </ref>, as foundation of our TSE system. While a complete description of the algebra can be found elsewhere [27], below we briefly introduce the operators. We also discuss the necessary extension of some of these operators required for schema change support. <p> <ref> [27] </ref>). 5.1 Extending Object Algebra for Capacity-Augmenting Views Since our view schema evolution approach is built using the MultiView system, we utilize MultiView's view definition language, an object algebra [27, 30, 29, 28], as foundation of our TSE system. While a complete description of the algebra can be found elsewhere [27], below we briefly introduce the operators. We also discuss the necessary extension of some of these operators required for schema change support. In particular, we discuss how MultiView's object algebra has been extended to be capacity-augmenting as required for TSE (requirement 5). <p> It then renames the Student' and TA' classes to Student and TA within the context of VS2, respectively. Finally, generalization edges are generated by View Schema Generator for the classes selected for VS2 <ref> [27] </ref>. The result is depicted in Figure 8 (d). At last, the system replaces the old view VS1 with the newly generated view VS2. <p> The global schema is restructured for this schema change operator in order to add some new refining virtual classes. However, as shown elsewhere as the view independence property <ref> [27] </ref>, existing views are not affected by such global schema restructuring. 6.2 Implementing the Delete-Attribute Schema Change in TSE 6.2.1 Semantics of the Delete-Attribute Operator The schema change operator defined by "delete attribute attribute (x) from C" removes the attribute x from the types of the class C and its subclasses. <p> In fact, it doesn't affect any other class in its view except that it is dropped from the view schema. An operator with these semantics is already provided by a command of the view specification language, removeFromView aClass, of MultiView <ref> [27] </ref>. A more complex version of this delete-class operator with the same semantics as the delete-class in Orion [3] can be achieved by composing several simpler change operators in our system. <p> In Figure 18, two views VS1 and VS2 are defined such that VS1 consists of Person, Student and UnderGrad classes, and VS2 of Student, 21 The operation of removing a class from a view is supported by the view specification language in MultiView <ref> [27] </ref>. 38 Person UnderGrad name TA salary register TA' Grad advisor VS1 UnderGrad' Student Grad' VS2 defineVC UnderGrad' as ( refine credit for UnderGrad); defineVC Grad' as ( refine register for Grad); defineVC TA' as ( refine register for TA); VS1' add_attribute for add_attribute for credit Student; register Student; VS2 :VS1: <p> To support the view technology required for our approach, MultiView <ref> [27] </ref> is chosen because it generates up-datable views and complete view schemas rather than individual view classes. We have made several extensions to MultiView to successfully support view evolution, in particular, we added capacity-augmenting capabilities.
Reference: [28] <author> E. A. Rundensteiner, </author> <title> "Tools for view generation in OODBs," </title> <booktitle> in CIKM, </booktitle> <pages> pp. 635-644, </pages> <month> November </month> <year> 1993. </year>
Reference-contexts: It renames the Student' and TA' classes to Student and TA within the context of the view, respectively. Fourth, a new view schema VS2 is generated from the selected classes by running the schema generation algorithm <ref> [28] </ref>. At last, the system replaces the old view with the newly generated view. Note that the above algorithm runs in the context of a view, so it only creates virtual classes for all subclasses of a class C within a view. <p> First, it generates updatable views [27] (requirement 2). Second, several of the view specification subtasks are already automated, and can be reused in our system, such as virtual class insertion into the global schema [29] and generation of the view schema <ref> [28] </ref>. Lastly, a prototype of MultiView has been implemented at the University of Michigan, and thus can be utilized as platform for constructing the TSE system [13, 22]. <p> For the third subtask, we have developed a view schema generation algorithm for the construction of the view generalization hierarchy <ref> [28] </ref>. Automatic view generation [28] relieves the user of constructing the is-a hierarchy for each view schema and removes the potential inconsistencies in the view generalization hierarchy due to the potential mistakes of the user. <p> For the third subtask, we have developed a view schema generation algorithm for the construction of the view generalization hierarchy <ref> [28] </ref>. Automatic view generation [28] relieves the user of constructing the is-a hierarchy for each view schema and removes the potential inconsistencies in the view generalization hierarchy due to the potential mistakes of the user. Using a view system as foundation of 13 TSE clearly offers a solution to requirement 3. <p> MultiView has been shown to meet requirement 1 (which essentially corresponds to the view independency property shown in [27]). 5.1 Extending Object Algebra for Capacity-Augmenting Views Since our view schema evolution approach is built using the MultiView system, we utilize MultiView's view definition language, an object algebra <ref> [27, 30, 29, 28] </ref>, as foundation of our TSE system. While a complete description of the algebra can be found elsewhere [27], below we briefly introduce the operators. We also discuss the necessary extension of some of these operators required for schema change support. <p> Because this schema change does not modify the is-a relationships between classes, we know E = E 0 . The view schema generation algorithm of TSE, which is described in <ref> [28] </ref>, will generate the same is-a relationships as in E, and thus E 00 = E. This implies that E 00 = E 0 = E. <p> This module is reused from MultiView. * The View Manager takes a set of classes as an input and generates a consistent view schema including the appropriate generalization hierarchy (further described in <ref> [28] </ref>). This module is also one of the MultiView modules. * The View Schema History is a dictionary that keeps track of the history of each view schema, allowing for the substitution of the old view by the newly created one.
Reference: [29] <author> E. A. Rundensteiner, </author> <title> "A classification algorithm for supporting object-oriented views," </title> <booktitle> in CIKM, </booktitle> <pages> pp. 18-25, </pages> <month> November </month> <year> 1994. </year>
Reference-contexts: The dashed ellipses represent virtual classes, whereas the solid ellipses represent base classes. Second, the two virtual classes are integrated into the global schema by the classification algorithm of our view system (Figure 2 (d)) <ref> [29] </ref>. Third, the system selects the classes Person, Student' and TA' for the new view. It renames the Student' and TA' classes to Student and TA within the context of the view, respectively. <p> Thus, the merging of object instances is by design taken care of by our system. The integration of two schemas into one is also automatically achieved in our system, since the classification algorithm of our MultiView system integrates all virtual classes into one consistent global schema graph <ref> [29] </ref>. In our system, it is thus straightforward to determine based on the global schema whether the same named classes are really identical. Similarly, differently named classes of separate schemas are easily found to be identical if they refer to the same class in the global schema. <p> First, it generates updatable views [27] (requirement 2). Second, several of the view specification subtasks are already automated, and can be reused in our system, such as virtual class insertion into the global schema <ref> [29] </ref> and generation of the view schema [28]. Lastly, a prototype of MultiView has been implemented at the University of Michigan, and thus can be utilized as platform for constructing the TSE system [13, 22]. <p> For the first subtask, MultiView provides the user with an object algebra for class derivation [27, 30]. An example of a virtual class creation is shown in Figure 6. The second subtask is automated in MultiView by the classification algorithm <ref> [29] </ref>. The integration of virtual classes into one global schema provides many benefits, including detecting identical and thus redundant classes, sharing methods without code duplication among different views, and enabling efficient view schema generation. <p> MultiView has been shown to meet requirement 1 (which essentially corresponds to the view independency property shown in [27]). 5.1 Extending Object Algebra for Capacity-Augmenting Views Since our view schema evolution approach is built using the MultiView system, we utilize MultiView's view definition language, an object algebra <ref> [27, 30, 29, 28] </ref>, as foundation of our TSE system. While a complete description of the algebra can be found elsewhere [27], below we briefly introduce the operators. We also discuss the necessary extension of some of these operators required for schema change support. <p> it allows object-restructuring when an algebra operator (refine-attribute) requires additional state for the input objects. * The Classifier reclassifies the classes of the global schema to integrate the newly created virtual classes into the consistent global schema hierarchy, allowing for upwards inheritance for both base and virtual classes (see also <ref> [29] </ref>). This module is reused from MultiView. * The View Manager takes a set of classes as an input and generates a consistent view schema including the appropriate generalization hierarchy (further described in [28]).
Reference: [30] <author> E. A. Rundensteiner and L. Bic, </author> <title> "Set operations in new generation data models," </title> <journal> IEEE Transactions on Knowledge and Data Engineering, </journal> <volume> vol. 4, </volume> <pages> pp. 382-398, </pages> <month> August </month> <year> 1992. </year>
Reference-contexts: For the first subtask, MultiView provides the user with an object algebra for class derivation <ref> [27, 30] </ref>. An example of a virtual class creation is shown in Figure 6. The second subtask is automated in MultiView by the classification algorithm [29]. <p> MultiView has been shown to meet requirement 1 (which essentially corresponds to the view independency property shown in [27]). 5.1 Extending Object Algebra for Capacity-Augmenting Views Since our view schema evolution approach is built using the MultiView system, we utilize MultiView's view definition language, an object algebra <ref> [27, 30, 29, 28] </ref>, as foundation of our TSE system. While a complete description of the algebra can be found elsewhere [27], below we briefly introduce the operators. We also discuss the necessary extension of some of these operators required for schema change support. <p> All objects of the input set are also members of the output set. * Set operations. As the extent of classes are sets of objects, we can perform set operations as usual <ref> [30] </ref>. The criterion of duplicate elimination is object identity equality, not value equality as assumed in the relational model. We impose no restriction on the operand types of set operations (ultimately, they are all objects).
Reference: [31] <author> E. A. Rundensteiner, L. Bic, J. Gilbert, and M. Yin, </author> <title> "Set-restricted semantic groupings," </title> <journal> IEEE Transaction on Data and Knowledge Engineering,, </journal> <volume> vol. 6, no. 2, </volume> <pages> pp. 193-204, </pages> <month> April </month> <year> 1994. </year>
Reference-contexts: Thus this issue of updatability of such object-generating views represents a challenging open problem. Another extension of TSE we are considering concerns the treatment of more powerful data models e.g., has-part aggregation and others such as semantic relationships, or even general constraints <ref> [31] </ref>. While we are currently developing algorithms for incremental maintenance of materialized views in MultiView [15, 14], we also want to develop specialized optimization strategies for update propagation in our TSE system.
Reference: [32] <author> C. Santos, S. Abiteboul, and C. Delobel, </author> <title> "Virtual schemas and bases," </title> <booktitle> in International Conference on Extend ing Database Technology (EDBT), </booktitle> <year> 1994. </year>
Reference-contexts: The use of view mechanisms to achieve schema evolution has also recently been advocated by other researchers <ref> [36, 32, 4] </ref>. For instance, [36] presents several examples of schema changes that can be simulated by views. However they do not give general algorithms and/or any implementation solutions. <p> For instance, [36] presents several examples of schema changes that can be simulated by views. However they do not give general algorithms and/or any implementation solutions. The O 2 view paper <ref> [32] </ref> refers to the issue of schema evolution as a potential feature but no details on how this could be achieved nor any examples are given. [4] is the closest work in the sense that it discusses how an individual class can be modified using view specifications in place of schema
Reference: [33] <author> M. H. Scholl, C. Laasch, and M. Tresch, </author> <title> "Updatable views in object-oriented databases," </title> <booktitle> in Proceedings of the Second DOOD Conference, </booktitle> <month> December </month> <year> 1991. </year>
Reference-contexts: Furthermore, we show that a comprehensive set of schema transformations can be realized with object-preserving view mechanisms rather than object-generating ones. This is significant, since the former have been shown to be generally updatable <ref> [33] </ref> which is a key property for our TSE system. Our TSE solution requires capacity-augmenting 2 views, i.e., views that augment the information content of the underlying schema. <p> our view approach makes the schema transition easy and smooth by keeping the old schema "alive" as long as needed. 3.2 Increased Functionality by Integrating View and Evolution Mechanisms Views allow a programmer to restructure the database to meet the specific needs of an application without affecting other application programs <ref> [13, 33, 27] </ref>. View mechanisms typically provide the functionality to restructure a base schema by hiding classes, by adding classes, by customizing the behavior or extent of classes, and by rearranging the generalization hierarchy. <p> Thus, C2 is a subclass of the source class C. 5.2 Generic Update Operators In OODBs, updates are generally performed using type-specific update methods. We, however, provide a set of generic update operations to extend type-specific updates, similar as proposed in other view systems <ref> [33] </ref>. Such generic update operations can either be used directly or, if desired, overridden by type implementors to define type-specific methods. The generic update operations include create and delete to create and destroy objects and set to set attributes to new values. <p> This is the requirement 2 from Section 4. It has been shown that virtual classes created by an object-preserving algebra are updatable due to the one-to-one correspondence between base and virtual object instances <ref> [33] </ref>. In fact, all update operators have the same effect as if they were applied to the base class, because the virtual classes' extents are depending on the extents of base classes. <p> This is important since it assures that the resulting view schemas are updatable, because views generated by an object-preserving algebra have been shown to be updatable <ref> [33] </ref>. Some more complex schema evolution operators, such as transforming values to an object, partitioning a class, and coalescing classes, can't easily be simulated by an object-preserving algebra.
Reference: [34] <author> E. Sciore, </author> <title> "Object specialization," </title> <journal> ACM Transactions on Information Systems, </journal> <pages> pp. 103-122, </pages> <month> April </month> <year> 1989. </year>
Reference-contexts: Such changes are done explicitly by user request, and on an object-by-object basis. View systems, on the other hand, enable users to restructure the types and class membership of complete classes|based on content-based queries. In <ref> [34] </ref>, Sciore also proposes an approach for role modeling, namely an object specialization, in which a real world entity is modeled by multiple objects arranged in an object hierarchy. These object hierarchy objects inherit 50 from each other, enabling each individual entity object to decide its own inheritance hierarchy.
Reference: [35] <author> A. H. Skarra and S. B. Zdonik, </author> <title> "The management of changing types in an object-oriented databases," </title> <booktitle> in Proc. 1st OOPSLA, </booktitle> <pages> pp. 483-494, </pages> <year> 1986. </year>
Reference-contexts: TA salary UnderGrad level Teaching Staff Support Staff Person name advisor boss lecture Staff permitNumber Parking-View1 Parking-View2 Staff2 permitNumber Fulltime Staff status Fulltime Staff2 View Specification: union ( TeachingStaff, SupportStaff ) Staff select Staff where status = 'fulltime' FulltimeStaff := := to FulltimeStaff Schema Evolution: (add-attribute ) 9 version systems <ref> [11, 35] </ref>. First, if instances have been copied for each version, all instance versions (duplicates) with the same object identity should be merged into a single instance. Second, the two separate schemas must be combined into one consistent schema, integrating also their generalization and aggregation hierarchies. <p> Note that this taxonomy, adopted in most other schema evolution research for OODBs such as Encore <ref> [35] </ref>, Goose [10], CLOSQL [20], Rose [19], OTGen [16] and COCOON [36], still corresponds to the most frequently used set of schema changes. In fact, most commercial OODB systems such as O 2 [37] and GemStone [21] only support a subset of this taxonomy. <p> This is a MultiView module, too. 46 8 RELATED RESEARCH 8.1 Comparison Criteria The continued support of old programs when performing schema evolution has been recognized as a key issue in the literature <ref> [35, 11, 10, 19] </ref>. <p> Some systems require the user to provide the exception handlers to resolve the type mismatches between the underlying object instance representation and the schema to access it <ref> [35] </ref>. Others require the user to keep track of class versions for each valid schema [10]. * flexibility to build a new schema from class versions: It refers to the capability of composing various schemas by combining class versions. <p> Second, the content-based derivation power of views could be exploited to support more complex schema customizations as possible with the graph manipulation operators typically supported by schema evolution (See Section 3.2). Table 23 shows the comparisons of our TSE system with other systems such as Encore <ref> [35] </ref>, Orion [11], Goose [2], CLOSQL [20] and Rose [19]. Many of these systems utilize traditional versioning concepts. They typically construct new versions of the schema as well as of the object instances, with instances being assigned to the schema version under which they have been created. <p> We solve this problem by specifying the schema change directly on a view rather than on the global schema. 8.2 Versioning and Other Approaches for Schema Evolution Zdonik et al.'s approach towards type changes in the Encore System <ref> [35] </ref> is to keep different versions of each type, and to bind objects to a specific version of the type. Objects of different versions can be accessed by providing exception handlers for the properties that the types of the object instances do not contain. <p> In addition, the computation time for conversion might be a significant overhead, and extensions for handling new stored attributes appear not to have been dealt with. Clamen [7] also presents an alternative solution for the transparency issue. His work is a generalization of Zdonik's type change management <ref> [35] </ref>, described above. In Clamen's scheme, each instance is represented as a disjoint union of the representation of each version, while in Zdonik's, each instance is represented as an interface type, which is a minimal cover of every instance version. <p> The extended MultiView object model has been implemented on top of Gemstone, providing the necessary features of multiple classification and dynamic data restructuring to the TSE system [22]. We have demonstrated the TSE approach on a comprehensive set of schema evolution operators, i.e., those typically supported by OODBs <ref> [35, 11, 10, 19, 20, 2, 16, 37, 21] </ref>. As a result, we have also shown that object-preserving algebra operators, as provided by MultiView, are sufficient for supporting a comprehensive set of schema changes.
Reference: [36] <author> M. Tresch and M. H. Scholl, </author> <title> "Schema transformation without database reorganization," </title> <booktitle> in SIGMOD RECORD, </booktitle> <pages> pp. 21-27, </pages> <year> 1993. </year>
Reference-contexts: 1 INTRODUCTION Schema evolution is an important issue in Object-Oriented Database (OODB) research <ref> [3, 19, 20, 36, 11, 37] </ref>, not only because data models are less stable than expected [17], but also because typical OODB application areas such as CAD/CAM and multimedia information systems are not well understood and require frequent schema changes. <p> In our approach, old tools don't have to be rewritten or even recompiled for schema evolution because the old schema is "alive" despite the schema change. In this paper, we present algorithms for the complete set of schema evolution operations typically supported by current OODB systems <ref> [3, 19, 20, 36, 11, 37] </ref>. These algorithms and their successful realization into a system demonstrate the feasibility of view evolution for schema transformation. Furthermore, we show that a comprehensive set of schema transformations can be realized with object-preserving view mechanisms rather than object-generating ones. <p> The use of view mechanisms to achieve schema evolution has also recently been advocated by other researchers <ref> [36, 32, 4] </ref>. For instance, [36] presents several examples of schema changes that can be simulated by views. However they do not give general algorithms and/or any implementation solutions. <p> The use of view mechanisms to achieve schema evolution has also recently been advocated by other researchers [36, 32, 4]. For instance, <ref> [36] </ref> presents several examples of schema changes that can be simulated by views. However they do not give general algorithms and/or any implementation solutions. <p> Note that this taxonomy, adopted in most other schema evolution research for OODBs such as Encore [35], Goose [10], CLOSQL [20], Rose [19], OTGen [16] and COCOON <ref> [36] </ref>, still corresponds to the most frequently used set of schema changes. In fact, most commercial OODB systems such as O 2 [37] and GemStone [21] only support a subset of this taxonomy. <p> Besides, the representation of an instance is only augmented as a new version is created, and this might lead to an overhead in 49 terms of storage and performance. 8.3 Schema Evolution Using Views Tresch and Scholl <ref> [36] </ref> also advocate views as a suitable mechanism for simulating schema evolution. This article is based on example, while no precise algorithms are given. They state that schema evolution can be simulated using views if they are not capacity-augmenting.
Reference: [37] <author> R. Zicari, </author> <title> "A Framework for O 2 Schema Updates," in Building an Object-Oriented Database System: The Story of O 2 , F. </title> <editor> Bancilhon, C. Delobel, and P. Kanellakis, editors, </editor> <publisher> Morgan Kaufmann Pub., </publisher> <year> 1992. </year> <month> 53 </month>
Reference-contexts: 1 INTRODUCTION Schema evolution is an important issue in Object-Oriented Database (OODB) research <ref> [3, 19, 20, 36, 11, 37] </ref>, not only because data models are less stable than expected [17], but also because typical OODB application areas such as CAD/CAM and multimedia information systems are not well understood and require frequent schema changes. <p> In our approach, old tools don't have to be rewritten or even recompiled for schema evolution because the old schema is "alive" despite the schema change. In this paper, we present algorithms for the complete set of schema evolution operations typically supported by current OODB systems <ref> [3, 19, 20, 36, 11, 37] </ref>. These algorithms and their successful realization into a system demonstrate the feasibility of view evolution for schema transformation. Furthermore, we show that a comprehensive set of schema transformations can be realized with object-preserving view mechanisms rather than object-generating ones. <p> We show that TSE realizes all schema changes traditionally supported by commercial OODBs, such as Ithasca [3], GemStone [6], and O 2 <ref> [37] </ref>. In fact, we show that an object-preserving query language is sufficient. Lastly, the TSE algorithms create a view schema that achieves the semantics of the schema change operations in the context of the complete inheritance hierarchy rather than only on individual classes. <p> Content-based evolution utilizes a query language to restructure relevant objects based on their content rather than just performing a syntax (type)-based transformation as done by most popular current schema evolution mechanisms <ref> [3, 21, 37] </ref>. For a simple example, suppose we want to keep track of the parking permit number only for fulltime staff. <p> Note that this taxonomy, adopted in most other schema evolution research for OODBs such as Encore [35], Goose [10], CLOSQL [20], Rose [19], OTGen [16] and COCOON [36], still corresponds to the most frequently used set of schema changes. In fact, most commercial OODB systems such as O 2 <ref> [37] </ref> and GemStone [21] only support a subset of this taxonomy. To demonstrate the feasibility of the TSE approach, it is thus important to show that our approach can realize all the schema change operations supported by Orion. Zicari [37] shows that the schema evolution operations of Orion can be reduced <p> In fact, most commercial OODB systems such as O 2 <ref> [37] </ref> and GemStone [21] only support a subset of this taxonomy. To demonstrate the feasibility of the TSE approach, it is thus important to show that our approach can realize all the schema change operations supported by Orion. Zicari [37] shows that the schema evolution operations of Orion can be reduced to a small set of primitive schema change operators, which can be combined to achieve the semantics of more complex operators. <p> But, the data value for this attribute would become null when the transformation was achieved using a composition of the delete/add attribute operators according to the semantics of operators defined by Zicari <ref> [37] </ref>, while it retains the old value of the attribute when transformed directly by the change-domain-attribute in the Orion taxonomy [3]. Thus, we have selected our set of schema change operations based on the Orion taxonomy. <p> for the support of view systems. 43 Car Jeep Imported Hyundai loseType Jeep getType Jeep Car Imported Hyundai Conceptual Object O1 Conceptual Object O1 (a) MVClass Car Jeep Imported Hyundai color fuel nation rebate fuel O1 Jeep O1 Car color O1 Hyundai rebate O1 Imported nation dealing with name conflicts <ref> [37] </ref>, could be modified to avoid such rejections by allowing, for example, (1) a fixed ordering of superclasses to determine the choice of the method resolution or (2) user-constructs indicating priority among superclasses for the purposes of name resolution. 7.4 Dynamic Reclassification and Restructuring 7.4.1 Reclassification and Restructuring for Object Instances <p> The extended MultiView object model has been implemented on top of Gemstone, providing the necessary features of multiple classification and dynamic data restructuring to the TSE system [22]. We have demonstrated the TSE approach on a comprehensive set of schema evolution operators, i.e., those typically supported by OODBs <ref> [35, 11, 10, 19, 20, 2, 16, 37, 21] </ref>. As a result, we have also shown that object-preserving algebra operators, as provided by MultiView, are sufficient for supporting a comprehensive set of schema changes.
References-found: 37

