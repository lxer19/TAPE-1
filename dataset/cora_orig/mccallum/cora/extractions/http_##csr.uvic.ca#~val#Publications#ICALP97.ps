URL: http://csr.uvic.ca/~val/Publications/ICALP97.ps
Refering-URL: http://csr.uvic.ca/~val/val.html
Root-URL: http://www.aic.nrl.navy.mil/~aha/people.html
Email: email: monika@pa.dec.com.  email: val@csr.uvic.ca  
Phone: 2  
Title: Maintaining Minimum Spanning Trees in Dynamic Graphs algorithm uses O(n 1=3 log n) amortized time
Author: Monika R. Henzinger and Valerie King 
Note: n) per operation. To be precise, the  
Address: 130 Lytton Ave, Palo Alto, CA, USA 94301;  P.O. Box 3055, Victoria, BC., Canada, V8W 3P6;  
Affiliation: 1 Systems Research Center, Digital Equipment Corporation,  University of Victoria, Dept. of Computer Science,  
Abstract: We present the first fully dynamic algorithm for maintaining a minimum spanning tree in time o( p 
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> T. Corman, C. Leiserson, and Rivest. </author> <title> Introduction to Algorithms. </title> <publisher> MIT Press (1989), </publisher> <address> p. </address> <pages> 381-399. </pages>
Reference-contexts: Also we can test two vertices of the forest to determine whether they are in the same tree in time O (log d n). See for example <ref> [1, 11] </ref> for operations on B-trees. If d = n ff , for ff a positive constant, then the join and split operations take time O (d) and the test operation takes time O (1). We refer to the B-trees used to store ET-sequences as ET-trees.
Reference: 2. <author> D. Eppstein, </author> <title> "Dynamic Euclidean minimum spanning trees and extrema of binary functions", </title> <journal> Disc. Comp. Geom. </journal> <volume> 13 (1995), </volume> <pages> 111-122. </pages>
Reference-contexts: Our result immediately gives faster deterministic fully dynamic algorithms for the following problems: connectivity, bipartiteness, k-edge witness, maximal spanning forest decomposition, and Euclidean minimum spanning tree. See [9] for all but the last reduction; see Eppstein <ref> [2] </ref> for the last reduction. For these problems, the new algorithm achieves an O (n 1=6 = log n) factor improvement over the previously best deterministic running time. If randomization is allowed, however, much faster times are achievable [9, 10].
Reference: 3. <author> D. Eppstein, Z. Galil, G. F. </author> <title> Italiano, "Improved Sparsification", </title> <type> Tech. Report 93-20, </type> <institution> Department of Information and Computer Science, University of Califor-nia, </institution> <address> Irvine, CA 92717. </address>
Reference-contexts: In 1985 [7], Fredrickson introduced a data structure known as topology trees for the fully dynamic minimum spanning tree problem with a worst case cost of O ( m) per update His data structure permitted connectivity queries to be answered in O (1) time. In 1992, Eppstein et. al. <ref> [3, 4] </ref> improved the update time to O ( n) using the sparsification technique. If only edge insertions are allowed, the Sleator-Tarjan dynamic tree data structure [13] maintains the minimum spanning forest in time O (log n) per insertion or query. <p> In other words, letting m (i) denote the size of G (vertices and edges) after update i, the total amount of work for processing a sequence of updates of length l is O ( i=0 m (i) 1=3 log n). We then apply sparsification <ref> [3, 4] </ref> to reduce the running time for the sequence to O (ln 1=3 log n). Our result immediately gives faster deterministic fully dynamic algorithms for the following problems: connectivity, bipartiteness, k-edge witness, maximal spanning forest decomposition, and Euclidean minimum spanning tree. <p> For these problems, the new algorithm achieves an O (n 1=6 = log n) factor improvement over the previously best deterministic running time. If randomization is allowed, however, much faster times are achievable [9, 10]. Additionally, improvements can be achieved in the following static problems (see <ref> [4, 3] </ref>): randomly sampling spanning forests of a given graph [6]; finding a color-constrained minimum spanning tree [8]. The paper is structured as follows: In Section 2 we give a deletions-only minimum spanning tree algorithm.
Reference: 4. <author> D. Eppstein, Z. Galil, G. F. Italiano, A. Nissenzweig, </author> <title> "Sparsification ATech-nique for Speeding up Dynamic Graph Algorithms" Proc. </title> <booktitle> 33rd Symp. on Foundations of Computer Science, </booktitle> <year> 1992, </year> <pages> 60-69. </pages>
Reference-contexts: In 1985 [7], Fredrickson introduced a data structure known as topology trees for the fully dynamic minimum spanning tree problem with a worst case cost of O ( m) per update His data structure permitted connectivity queries to be answered in O (1) time. In 1992, Eppstein et. al. <ref> [3, 4] </ref> improved the update time to O ( n) using the sparsification technique. If only edge insertions are allowed, the Sleator-Tarjan dynamic tree data structure [13] maintains the minimum spanning forest in time O (log n) per insertion or query. <p> In other words, letting m (i) denote the size of G (vertices and edges) after update i, the total amount of work for processing a sequence of updates of length l is O ( i=0 m (i) 1=3 log n). We then apply sparsification <ref> [3, 4] </ref> to reduce the running time for the sequence to O (ln 1=3 log n). Our result immediately gives faster deterministic fully dynamic algorithms for the following problems: connectivity, bipartiteness, k-edge witness, maximal spanning forest decomposition, and Euclidean minimum spanning tree. <p> For these problems, the new algorithm achieves an O (n 1=6 = log n) factor improvement over the previously best deterministic running time. If randomization is allowed, however, much faster times are achievable [9, 10]. Additionally, improvements can be achieved in the following static problems (see <ref> [4, 3] </ref>): randomly sampling spanning forests of a given graph [6]; finding a color-constrained minimum spanning tree [8]. The paper is structured as follows: In Section 2 we give a deletions-only minimum spanning tree algorithm.
Reference: 5. <author> S. Even and Y. Shiloach, </author> <title> "An On-Line Edge-Deletion Problem", </title> <editor> J. </editor> <booktitle> ACM 28 (1981), </booktitle> <pages> 1-4. </pages>
Reference-contexts: Claim 1 O ( P w (T 1 )) summed over all smaller components T 1 which split from a tree T on any given level during all Replace operations is O (w (T ) log n). The proof of the claim is not hard and follows <ref> [5] </ref>. The details are omitted here. There are at most k edges per level (except for level 0, which has at most k nontree edges). Each L j (v) consists of edges from c levels.
Reference: 6. <author> T. Feder and M. Mihail, </author> <title> "Balanced matroids", </title> <booktitle> Proc. 24th ACm Symp. on Theory of Computing, </booktitle> <year> 1992, </year> <pages> 26-38. </pages>
Reference-contexts: If randomization is allowed, however, much faster times are achievable [9, 10]. Additionally, improvements can be achieved in the following static problems (see [4, 3]): randomly sampling spanning forests of a given graph <ref> [6] </ref>; finding a color-constrained minimum spanning tree [8]. The paper is structured as follows: In Section 2 we give a deletions-only minimum spanning tree algorithm.
Reference: 7. <author> G. N. Frederickson, </author> <title> "Data Structures for On-line Updating of Minimum Spanning Trees", </title> <journal> SIAM J. Comput., </journal> <volume> 14 (1985), </volume> <pages> 781-798. </pages>
Reference-contexts: In addition, the data structure permits the following type of query: connected (u,v): Determine if vertices u and v are connected. In 1985 <ref> [7] </ref>, Fredrickson introduced a data structure known as topology trees for the fully dynamic minimum spanning tree problem with a worst case cost of O ( m) per update His data structure permitted connectivity queries to be answered in O (1) time. <p> Our technique is very different from <ref> [7] </ref>.
Reference: 8. <author> G. N. Frederickson and M. A. Srinivas, </author> <title> "Algorithms and data structures for an expanded family of matroid intersection problems", </title> <journal> SIAM J. Comput. </journal> <volume> 18 (1989), </volume> <pages> 112-138. </pages>
Reference-contexts: If randomization is allowed, however, much faster times are achievable [9, 10]. Additionally, improvements can be achieved in the following static problems (see [4, 3]): randomly sampling spanning forests of a given graph [6]; finding a color-constrained minimum spanning tree <ref> [8] </ref>. The paper is structured as follows: In Section 2 we give a deletions-only minimum spanning tree algorithm.
Reference: 9. <author> M. R. Henzinger and V. King. </author> <title> Randomized Dynamic Graph Algorithms with Polylogarithmic Time per Operation. </title> <booktitle> Proc. 27th ACM Symp. on Theory of Computing, </booktitle> <year> 1995, </year> <pages> 519-527. </pages>
Reference-contexts: Using randomization, it was recently shown that the fully dynamic connec-tivity problem, i.e., the restricted problem where all edge costs are the same, can be solved in amortized time O (log 2 n) per update and O (log n) per connectivity query <ref> [9, 10] </ref>. <p> We then apply sparsification [3, 4] to reduce the running time for the sequence to O (ln 1=3 log n). Our result immediately gives faster deterministic fully dynamic algorithms for the following problems: connectivity, bipartiteness, k-edge witness, maximal spanning forest decomposition, and Euclidean minimum spanning tree. See <ref> [9] </ref> for all but the last reduction; see Eppstein [2] for the last reduction. For these problems, the new algorithm achieves an O (n 1=6 = log n) factor improvement over the previously best deterministic running time. If randomization is allowed, however, much faster times are achievable [9, 10]. <p> See [9] for all but the last reduction; see Eppstein [2] for the last reduction. For these problems, the new algorithm achieves an O (n 1=6 = log n) factor improvement over the previously best deterministic running time. If randomization is allowed, however, much faster times are achievable <ref> [9, 10] </ref>. Additionally, improvements can be achieved in the following static problems (see [4, 3]): randomly sampling spanning forests of a given graph [6]; finding a color-constrained minimum spanning tree [8]. The paper is structured as follows: In Section 2 we give a deletions-only minimum spanning tree algorithm. <p> Else if i is not the last level, call Replace (i + 1; u; v). 2.1 Data Structures The idea here is to use the ET-tree data structure developed in <ref> [9] </ref>: (1) to represent and update each tree in F , so that in constant time, we can quickly test if a given edge joins two trees; and (2) to represent each tree in an F i in such a way that we can quickly retrieve nontree edges in E i
Reference: 10. <author> M. R. Henzinger and M. </author> <title> Thorup. Improved Sampling with Applications to Dynamic Graph Algorithms. </title> <booktitle> To appear in Proc. 23rd International Colloquium on Automata, Languages, and Programming (ICALP), </booktitle> <publisher> LNCS 1099, Springer-Verlag, </publisher> <year> 1996. </year>
Reference-contexts: Using randomization, it was recently shown that the fully dynamic connec-tivity problem, i.e., the restricted problem where all edge costs are the same, can be solved in amortized time O (log 2 n) per update and O (log n) per connectivity query <ref> [9, 10] </ref>. <p> See [9] for all but the last reduction; see Eppstein [2] for the last reduction. For these problems, the new algorithm achieves an O (n 1=6 = log n) factor improvement over the previously best deterministic running time. If randomization is allowed, however, much faster times are achievable <ref> [9, 10] </ref>. Additionally, improvements can be achieved in the following static problems (see [4, 3]): randomly sampling spanning forests of a given graph [6]; finding a color-constrained minimum spanning tree [8]. The paper is structured as follows: In Section 2 we give a deletions-only minimum spanning tree algorithm.
Reference: 11. <author> K. Mehlhorn. </author> <title> "Data Structures and Algorithms 1: Sorting and Searching", </title> <publisher> Springer-Verlag, </publisher> <year> 1984. </year>
Reference-contexts: Also we can test two vertices of the forest to determine whether they are in the same tree in time O (log d n). See for example <ref> [1, 11] </ref> for operations on B-trees. If d = n ff , for ff a positive constant, then the join and split operations take time O (d) and the test operation takes time O (1). We refer to the B-trees used to store ET-sequences as ET-trees.
Reference: 12. <author> H. Nagamochi and T. Ibaraki, </author> <title> "Linear time algorithms for finding a sparse k-connected spanning subgraph of a k-connected graph", </title> <type> Algorithmica 7, </type> <year> 1992, </year> <pages> 583-596. </pages>
Reference: 13. <author> D. D. Sleator, R. E. Tarjan, </author> <title> "A data structure for dynamic trees" J. </title> <journal> Comput. System Sci. </journal> <volume> 24, </volume> <year> 1983, </year> <pages> 362-381. </pages>
Reference-contexts: In 1992, Eppstein et. al. [3, 4] improved the update time to O ( n) using the sparsification technique. If only edge insertions are allowed, the Sleator-Tarjan dynamic tree data structure <ref> [13] </ref> maintains the minimum spanning forest in time O (log n) per insertion or query. If only edge deletions are allowed ("deletions-only"), then no algorithm faster than the ( p n) fully dynamic algorithm was known. <p> Let s = dlg m 0 e. Initially, we build and maintain s simultaneous deletions-only data structures A s ; A s1 ; ::; A 1 and a set of edges B. We call this the composite data structure. We maintain the MST in a Sleator-Tarjan dynamic tree <ref> [13] </ref> and also in an ET-tree of degree maxfm 01=3 log n; n * g.
Reference: 14. <author> R. E. Tarjan, </author> <title> Data Structures and Network Flow, SIAM (1983) p. 71. This article was processed using the L a T E X macro package with LLNCS style </title>
Reference-contexts: The proof of the lemma is straightforward and is omitted here. The correctness of the algorithm follows easily from the invariant. We use the well-known fact that an edge is in the minimum spanning tree iff it is not the heaviest edge in any cycle ("red rule" <ref> [14] </ref>). We also note that every edge in the composite data structure is an edge in G. Let e be an edge of the MST which is deleted. Let e 0 be the correct replacement edge. Consider the state of the composite data structures right before the deletion of e.
References-found: 14

