URL: http://www-lia.deis.unibo.it/Research/Papers/LammaRiguzziPereira-nmr98.ps.Z
Refering-URL: http://www.uni-koblenz.de/~dix/NMR7/
Root-URL: http://www.aic.nrl.navy.mil/~aha/people.html
Email: felamma,friguzzig@deis.unibo.it  lmp@di.fct.unl.pt  
Title: Learning with Extended Logic Programs  
Author: Evelina Lamma and Fabrizio Riguzzi Lus Moniz Pereira 
Address: Viale Risorgimento 2 40136 Bologna, Italy,  2825 Monte da Caparica, Portugal  
Affiliation: DEIS, Universita di Bologna,  Centro de Intelig^encia Artificial (CENTRIA), Departamento de Informatica, Universidade Nova de Lisboa,  
Abstract: We discuss the adoption of a three-valued setting for inductive concept learning. Distinguishing between what is true, what is false and what is unknown can be useful in situations where decisions have to be taken on the basis of scarce information. In a three-valued setting, we want to learn a definition for both the target concept and its opposite, considering positive and negative examples as instances of two disjoint classes. To this purpose, we adopt extended logic programs under a well-founded semantics as the representation formalism for learning. In this way, we are able to represent both the concept and its opposite and deal with incomplete or unknown information. We discuss various approaches to be adopted in order to handle possible inconsistencies. Default negation is used to ensure consistency and to handle exceptions to general rules. Exceptions to a positive concept are identified from negative examples, whereas exceptions to a negative concept are identified from positive examples. Exceptions can be generalized, in their turn, by learning within a hierarchy of defaults. 
Abstract-found: 1
Intro-found: 1
Reference: <author> Alferes, J. J., and Pereira, L. M. </author> <year> 1996. </year> <title> Reasoning with Logic Programming, </title> <booktitle> volume 1111 of LNAI. </booktitle> <address> Heidelberg: </address> <publisher> SV. </publisher>
Reference-contexts: We enlarge this condition requiring that the program is consistent also for unseen atoms, i.e., B [ P 6j= L; :L for every atom L of the target concept. Since the SLX procedure is correct (in the sense specified in <ref> (Alferes & Pereira 1996) </ref>), coverage of examples is tested by adopting the SLX top-down interpreter for extended logic programs, defined in (Alferes, Damasio, & Pereira 1994; Alferes & Pereira 1996).
Reference: <author> Alferes, J.; Damasio, C.; and Pereira, L. </author> <year> 1994. </year> <title> Top-down query evaluation for well-founded semantics with explicit negation. </title> <booktitle> In Proceedings of the European Conference on Artificial Intelligenece ECAI94, </booktitle> <pages> 140-144. </pages> <publisher> Morgan Kauf-mann. </publisher>
Reference: <author> Alferes, J.; Przymusinski, T.; and Pereira, L. </author> <year> 1998. </year> <title> "Classical" negation in non-monotonic reasoning and logic programming. </title> <note> Journal of Automated Reasoning 1. </note>
Reference: <author> Bain, M., and Muggleton, S. </author> <year> 1992. </year> <title> Non-monotonic learning. </title> <editor> In Muggleton, S., ed., </editor> <booktitle> Inductive Logic Programming. </booktitle> <publisher> Academic Press. </publisher> <pages> 145-161. </pages>
Reference: <author> Baral, C., and Gelfond, M. </author> <year> 1994. </year> <title> Logic programming and knowledge representation. </title> <journal> Journal of Logic Programming </journal> 19/20:73-148. 
Reference: <author> De Raedt, L., and Bruynooghe, M. </author> <year> 1990. </year> <title> On negation and three-valued logic in interactive concept learning. </title> <booktitle> In Proceedings of the 9th European Conference on Artificial Intelligence. </booktitle>
Reference-contexts: As it has been pointed out in <ref> (De Raedt & Bruynooghe 1990) </ref>, this is typically the case of an autonomous agent that incrementally gathers information from its surrounding world. <p> Such situation is, for example, the one of an agent that incrementally gathers information from the surrounding world and has to select its own actions on the basis of such knowledge. If the agent learns in a two-valued settings, it can encounter the problems that have been highlighted in <ref> (De Raedt & Bruynooghe 1990) </ref>. When learning in a specific to general way, it will learn a cautious definition for the target concept and it will not be able to distinguish what is false from what is not yet known (see figure 1a). <p> In this way, the agent will know which part of the domain needs to be further explored and will not try actions with an unknown outcome unless setting (taken from <ref> (De Raedt & Bruynooghe 1990) </ref>) it is trying to expand its knowledge. Learning in a three-valued settings requires the adoption of a more expressible class of programs to be learned. <p> For concept learning, the use of the CWA for target predicates is no longer acceptable because it does not allow to distinguish between what is false and what is undefined. To avoid this problem, De Raedt and Bruynooghe <ref> (De Raedt & Bruynooghe 1990) </ref> proposed to use a three valued logic and an explicit definition of the negated concept in concept learning. This technique has been integrated within the CLINT system, an interactive concept-learner.
Reference: <author> Dimopoulos, Y., and Kakas, A. </author> <year> 1995. </year> <title> Learning Non-monotonic Logic Programs: Learning Exceptions. </title> <booktitle> In Proceedings of the 8th European Conference on Machine Learning. </booktitle>
Reference: <author> Dix, J. </author> <year> 1995a. </year> <title> A classification-theory of semantics of normal logic programs: I. strong properties. </title> <note> Fundamenta Informaticae XXII(3):227-255. </note>
Reference: <author> Dix, J. </author> <year> 1995b. </year> <title> A classification-theory of semantics of normal logic programs: Ii. weak properties. </title> <note> Fundamenta Informaticae XXII(3):257-288. </note>
Reference: <author> Esposito, F.; Lamma, E.; Malerba, D.; Mello, P.; Milano, M.; Riguzzi, F.; and Semeraro, G. </author> <year> 1996. </year> <title> Learning abduc-tive logic programs. </title> <editor> In Denecker, M.; De Raedt, L.; Flach, P.; and Kakas, A., eds., </editor> <booktitle> Proceedings of the ECAI96 Workshop on Abductive and Inductive Reasoning. </booktitle> <institution> Catholic University of Leuven. </institution>
Reference: <author> Esposito, F.; Ferilli, S.; Lamma, E.; Mello, P.; Milano, M.; Riguzzi, F.; and Semeraro, G. </author> <year> 1998. </year> <title> Cooperation of abduction and induction in logic programming. </title> <editor> In Flach, P., and Kakas, A., eds., </editor> <title> Abductive and Inductive Reasoning, </title> <journal> Pure and Applied Logic. </journal> <note> Kluwer. Submitted for publication. </note>
Reference: <author> Gelfond, M., and Lifschitz, V. </author> <year> 1991. </year> <title> Classical negation in logic programming and disjunctive databases. </title> <booktitle> New Generation Computing 9 </booktitle> <pages> 365-385. </pages>
Reference-contexts: Learning in a three-valued settings requires the adoption of a more expressible class of programs to be learned. This class can be represented by means of Extended Logic Programs, under a stable semantics <ref> (Gelfond & Lifschitz 1991) </ref>, or under a well-founded one (Pereira & Alferes 1992). In the following, we will adopt the well-founded semantics with explicit negation WFSX (Pereira & Alferes 1992).
Reference: <author> Inoue, K., and Kudoh, Y. </author> <year> 1997. </year> <title> Learning extended logic programs. </title> <booktitle> In Proceedings of the 15th International Joint Conference on Artificial Intelligence, </booktitle> <pages> 176-181. </pages> <publisher> Morgan Kaufmann. </publisher>
Reference-contexts: The ILP learning problem for the case of ELP has been first introduced in <ref> (Inoue & Kudoh 1997) </ref>: Given: * a set P of possible (extended logic) programs * a set E + of positive examples * a set E of negative examples * a consistent extended logic program B (background knowledge) Find: * an extended logic program P 2 P such that - B <p> This approach can be realized by adopting a bottom-up technique such as RLGG, for example by using the system GOLEM that implements it, as in <ref> (Inoue & Kudoh 1997) </ref>. The second approach consists in learning from positive and negative examples adopting a top-down learning algorithm where consistency of clauses (necessity stopping criterion in the top-down algorithm) is replaced by a weaker requirement. <p> In order to show the behaviour of the algorithm when learning exceptions and to compare it with those of LELP, we will consider the learning problem that is described in example 3.4 in <ref> (Inoue & Kudoh 1997) </ref> where the definition of the concept f lies is learned. <p> In the resulting system, both a positive and a negative definition are learned for a concept (predicate) p, stating, respectively, the conditions under which p is true and false. Furthermore, it is required that the concept descriptions be consistent. The system LELP (Learning ELP) <ref> (Inoue & Kudoh 1997) </ref> learns ELP under answer-set semantics. As our algorithm, LELP is able to learn non-deterministic default rules with a hierarchy of exceptions. <p> As our algorithm, LELP is able to learn non-deterministic default rules with a hierarchy of exceptions. From the point of view of the learning problems that the two algorithms can solve, they are equivalent when the background is a definite logic program: all the examples shown in <ref> (Inoue & Kudoh 1997) </ref> can be learned by our algorithm and, viceversa, example 2 can be learned by LELP. When the background is an ELP, instead, the adoption of a well-founded semantics gives a number of advantages with respect to the answer-set semantics. <p> It is worth mentioning that the treatment of exceptions by means of the addition of a non-abnormality literal to each rule (as we and <ref> (Inoue & Kudoh 1997) </ref> do) is similar to the approach for declarative debugging followed in (Pereira, Damasio, & Alferes 1993). In order to debug a logic program, in (Pereira, Damasio, & Alferes 1993) the authors first transform it by adding a different default literal to each rule.
Reference: <author> Inoue, K. </author> <year> 1998. </year> <title> Learning abductive and nonmonotonic logic programs. </title> <editor> In Flach, P., and Kakas, A., eds., </editor> <title> Abduc-tive and Inductive Reasoning, </title> <journal> Pure and Applied Logic. </journal> <note> Kluwer. Submitted for publication. </note>
Reference: <author> Kakas, A.; Mancarella, P.; and Dung, P. </author> <year> 1994. </year> <title> The acceptability semantics for logic programs. </title> <booktitle> In Proceedings of the 11th International Conference on Logic Programming. </booktitle>
Reference-contexts: In these frameworks, nonmonotonicity and exceptions are dealt with by learning logic programs with negation. In (Di-mopoulos & Kakas 1995) the authors rely on a language which uses a limited form of "classical" (or, better, syntactic) negation together with a priority relation among the sentences of the program <ref> (Kakas, Man-carella, & Dung 1994) </ref> which can be easily mapped into negation as default.
Reference: <author> Lapointe, S., and Matwin, S. </author> <year> 1992. </year> <title> Sub-unification: A tool for efficient induction of recursive programs. </title> <editor> In Slee-man, D., and Edwards, P., eds., </editor> <booktitle> Proceedings of the 9th International Workshop on Machine Learning, </booktitle> <pages> 273-281. </pages> <publisher> Morgan Kaufmann. </publisher>
Reference-contexts: Relative Least General Generalization (RLGG) (Plotkin 1970), Inverse Resolution (Muggleton & Bun-tine 1992) and Inverse Entailment <ref> (Lapointe & Matwin 1992) </ref> are examples of bottom-up techniques. GOLEM (Muggleton & Feng 1990) is a system that learns theories bottom-up by using RLGG.
Reference: <author> Lavrac, N., and Dzeroski, S. </author> <year> 1994. </year> <title> Inductive Logic Programming: Techniques and Applications. </title> <publisher> Ellis Horwood. </publisher>
Reference-contexts: Covered examples are removed from E + and the procedure is iterated until no uncovered positive example remains. Top-down systems, instead, share a basic algorithm that is given as follows (adapted from <ref> (Lavrac & Dzeroski 1994) </ref>): algorithm LearnTopDown ( inputs : E + ; E : training sets, B : background theory, outputs : H : learned theory) Initialize H := ; repeat (Covering loop) GenerateClause (E + ; E ; B; c) Remove from E + the e + covered by c
Reference: <author> Muggleton, S., and Buntine, W. </author> <year> 1992. </year> <title> Machine invention of first-order predicates by inverting resolution. </title> <editor> In Mug-gleton, S., ed., </editor> <booktitle> Inductive Logic Programming. </booktitle> <publisher> Academic Press. </publisher> <pages> 261-280. </pages>
Reference-contexts: In top-down methods clauses are constructed by starting with a general clause that covers all positive and negative examples and by specializing it until it does no longer cover any negative example while still covering at least one positive. Relative Least General Generalization (RLGG) (Plotkin 1970), Inverse Resolution <ref> (Muggleton & Bun-tine 1992) </ref> and Inverse Entailment (Lapointe & Matwin 1992) are examples of bottom-up techniques. GOLEM (Muggleton & Feng 1990) is a system that learns theories bottom-up by using RLGG.
Reference: <author> Muggleton, S., and Feng, C. </author> <year> 1990. </year> <title> Efficient induction of logic programs. </title> <booktitle> In Proceedings of the 1st Conference on Algorithmic Learning Theory, </booktitle> <pages> 368-381. </pages> <address> Ohmsma, Tokyo, Japan. </address>
Reference-contexts: Relative Least General Generalization (RLGG) (Plotkin 1970), Inverse Resolution (Muggleton & Bun-tine 1992) and Inverse Entailment (Lapointe & Matwin 1992) are examples of bottom-up techniques. GOLEM <ref> (Muggleton & Feng 1990) </ref> is a system that learns theories bottom-up by using RLGG. GOLEM generates a single clause by randomly picking couples of examples, by computing their RLGG and by choosing the one with the greatest coverage of positive examples.
Reference: <author> Muggleton, S. </author> <year> 1995. </year> <title> Inverse entailment and Progol. </title> <journal> New Generation Computing, </journal> <note> Special issue on Inductive Logic Programming 13(3-4):245-286. </note>
Reference-contexts: Generate all the possible refinements of c by adding a literal L to c Find the refinement c best that is best according to some heuristic function Assign c := c best until c does not cover any negative example return c (Necessity stopping criterion) FOIL (Quinlan 1990) and Progol <ref> (Muggleton 1995) </ref> are examples of top-down systems. Our approach to learning ELP consists in applying ordinary ILP techniques to learn definitions of the positive and negative concept.
Reference: <author> Pereira, L., and Alferes, J. </author> <year> 1992. </year> <title> Well founded semantics for logic programs with explicit negation. </title> <booktitle> In Proceedings of the European Conference on Artificial Intelligenece ECAI92, </booktitle> <pages> 102-106. </pages> <publisher> John Wiley and Sons. </publisher>
Reference-contexts: In order to represent three-valued theories of this kind, we adopt Extended Logic Programs (ELP for short) under the well-founded semantics with explicit negation WFSX <ref> (Pereira & Alferes 1992) </ref>. In (Pereira, Aparcio, & Alferes 1993; Alferes & Pereira 1996) it is shown how ELP can be applied to domains where negative information is made symmetric to positive one, e.g., concept hierarchies, reasoning about actions, counterfactuals, diagnosis, and debugging. <p> Learning in a three-valued settings requires the adoption of a more expressible class of programs to be learned. This class can be represented by means of Extended Logic Programs, under a stable semantics (Gelfond & Lifschitz 1991), or under a well-founded one <ref> (Pereira & Alferes 1992) </ref>. In the following, we will adopt the well-founded semantics with explicit negation WFSX (Pereira & Alferes 1992). <p> This class can be represented by means of Extended Logic Programs, under a stable semantics (Gelfond & Lifschitz 1991), or under a well-founded one <ref> (Pereira & Alferes 1992) </ref>. In the following, we will adopt the well-founded semantics with explicit negation WFSX (Pereira & Alferes 1992). We will denote negation by default by not and explicit negation by :. :A is said the opposite literal of A (and viceversa) and not A the complementary literal of A (and viceversa). <p> For each atom in the intersection, there are two partial stable models, one containing the atom in its positive version, the other containing the opposite literal. The atom is unknown, according to the well-founded semantics for explicit negation <ref> (Pereira & Alferes 1992) </ref>, i.e., in the least partial stable model. Note that the program B [ P can be non-stratified, either because the original background is already non-stratified or because the learned program is non-stratified.
Reference: <author> Pereira, L.; Aparcio; and Alferes, J. </author> <year> 1991. </year> <title> Nonmono-tonic reasoning with well founded semantics. </title> <booktitle> In Proceedings of the International Conference on Logic Programming ICLP91, </booktitle> <pages> 475-489. </pages> <publisher> The MIT Press. </publisher>
Reference: <author> Pereira, L.; Aparcio; and Alferes, J. </author> <year> 1993. </year> <title> Non-monotonic reasoning with logic programming. </title> <journal> Journal of Logic Programming 17 </journal> <pages> 227-263. </pages>
Reference-contexts: It is worth mentioning that the treatment of exceptions by means of the addition of a non-abnormality literal to each rule (as we and (Inoue & Kudoh 1997) do) is similar to the approach for declarative debugging followed in <ref> (Pereira, Damasio, & Alferes 1993) </ref>. In order to debug a logic program, in (Pereira, Damasio, & Alferes 1993) the authors first transform it by adding a different default literal to each rule. <p> worth mentioning that the treatment of exceptions by means of the addition of a non-abnormality literal to each rule (as we and (Inoue & Kudoh 1997) do) is similar to the approach for declarative debugging followed in <ref> (Pereira, Damasio, & Alferes 1993) </ref>. In order to debug a logic program, in (Pereira, Damasio, & Alferes 1993) the authors first transform it by adding a different default literal to each rule. These literals are then used as assumptions of the correctness of the rule, to be possibly revised in the face of a wrong solution.
Reference: <author> Pereira, L. M.; Damasio, C. V.; and Alferes, J. J. </author> <year> 1993. </year> <title> Diagnosis and debugging as contradiction removal. </title> <editor> In Pereira, L. M., and Nerode, A., eds., </editor> <booktitle> Proceedings of the 2nd International Workshop on Logic Programming and Non-monotonic Reasoning, </booktitle> <pages> 316-330. </pages> <publisher> MIT Press. </publisher>
Reference-contexts: It is worth mentioning that the treatment of exceptions by means of the addition of a non-abnormality literal to each rule (as we and (Inoue & Kudoh 1997) do) is similar to the approach for declarative debugging followed in <ref> (Pereira, Damasio, & Alferes 1993) </ref>. In order to debug a logic program, in (Pereira, Damasio, & Alferes 1993) the authors first transform it by adding a different default literal to each rule. <p> worth mentioning that the treatment of exceptions by means of the addition of a non-abnormality literal to each rule (as we and (Inoue & Kudoh 1997) do) is similar to the approach for declarative debugging followed in <ref> (Pereira, Damasio, & Alferes 1993) </ref>. In order to debug a logic program, in (Pereira, Damasio, & Alferes 1993) the authors first transform it by adding a different default literal to each rule. These literals are then used as assumptions of the correctness of the rule, to be possibly revised in the face of a wrong solution.
Reference: <author> Plotkin, G. </author> <year> 1970. </year> <title> A note on inductive generalization. </title> <booktitle> In Machine Intelligence, </booktitle> <volume> volume 5. </volume> <publisher> Edinburgh University Press. </publisher> <pages> 153-163. </pages>
Reference-contexts: In top-down methods clauses are constructed by starting with a general clause that covers all positive and negative examples and by specializing it until it does no longer cover any negative example while still covering at least one positive. Relative Least General Generalization (RLGG) <ref> (Plotkin 1970) </ref>, Inverse Resolution (Muggleton & Bun-tine 1992) and Inverse Entailment (Lapointe & Matwin 1992) are examples of bottom-up techniques. GOLEM (Muggleton & Feng 1990) is a system that learns theories bottom-up by using RLGG.
Reference: <author> Quinlan, J. </author> <year> 1990. </year> <title> Learning logical definitions from relations. </title> <booktitle> Machine Learning 5 </booktitle> <pages> 239-266. </pages>
Reference-contexts: : repeat (Specialization loop) Generate all the possible refinements of c by adding a literal L to c Find the refinement c best that is best according to some heuristic function Assign c := c best until c does not cover any negative example return c (Necessity stopping criterion) FOIL <ref> (Quinlan 1990) </ref> and Progol (Muggleton 1995) are examples of top-down systems. Our approach to learning ELP consists in applying ordinary ILP techniques to learn definitions of the positive and negative concept. <p> For example, FOIL <ref> (Quinlan 1990) </ref> uses a stopping criterion that is based on the encoding length restriction (Quinlan 1990) which restrict the total length of an induced clause to the number of bits needed to explicitly enumerate the training examples it covers. <p> For example, FOIL <ref> (Quinlan 1990) </ref> uses a stopping criterion that is based on the encoding length restriction (Quinlan 1990) which restrict the total length of an induced clause to the number of bits needed to explicitly enumerate the training examples it covers.
Reference: <author> Reiter, R. </author> <year> 1978. </year> <title> On closed-word data bases. </title> <editor> In Gallaire, H., and Minker, J., eds., </editor> <booktitle> Logic and Data Bases. </booktitle> <publisher> Plenum Press. </publisher> <pages> 55-76. </pages>
Reference-contexts: Introduction Most work on inductive concept learning considers a two-valued setting. In such a setting, what is not entailed by the learned theory is considered as false, by using the Closed World Assumption (CWA) <ref> (Reiter 1978) </ref>. However, in practice, it is more often the case that we know with certainty the truth or falsity of a limited number of facts and we are not able to draw any conclusion on the remaining facts, because the information available is too scarce.
References-found: 27

