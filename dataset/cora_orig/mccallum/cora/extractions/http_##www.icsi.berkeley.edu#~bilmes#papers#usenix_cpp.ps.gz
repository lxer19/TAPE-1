URL: http://www.icsi.berkeley.edu/~bilmes/papers/usenix_cpp.ps.gz
Refering-URL: http://www.icsi.berkeley.edu/~bilmes/papers/
Root-URL: http://www.icsi.berkeley.edu
Email: &lt;anderson@snow.berkeley.edu&gt;  &lt;bilmes@icsi.berkeley.edu&gt;  
Title: Concurrent Real-Time Music in C++  
Author: David P. Anderson yz Jeff Bilmes 
Note: UNIX, and on the Macintosh).  
Address: 1947 Center Street Berkeley, CA 94704  Berkeley, CA 94720  
Affiliation: yInternational Computer Science Institute  zComputer Science Division, EECS Department University of California at Berkeley  
Abstract: MOOD is a C++-based programming system for algorithmic and interactive music generation. MOOD uses multiple concurrent processes to generate different aspects of musical structure (pitches, rhythm, dynamic variation, etc.). It is composed of three layers. Layer one supplies deadline-scheduled lightweight processes and real-time event generation. Layer two allows processes to be collected into hierarchical group structures, with associated "virtual time systems" and nested musical transformations. Layer three provides pitches, scales, notes, rhythm specification, and higher-level musical abstractions. MOOD derives several benefits from C++ features such as inheritance and operator overloading: 1) a simple and versatile syntax for music representation; 2) a clean, layered structure for the internal scheduling mechanisms; 3) easy factorization of the machine-dependent parts (MOOD now runs on Sun 3 and 4 workstations under 
Abstract-found: 1
Intro-found: 1
Reference: [AK90] <author> David P. Anderson and Ron J. Kuivila. </author> <title> A System for Computer Music Performance. </title> <journal> Transaction on Computer Systems, </journal> <volume> 8(1) </volume> <pages> 56-82, </pages> <year> 1990. </year>
Reference-contexts: Figure 1 shows the MOOD class hierarchy and its division into layers. 2 Layer One: Basics Layer one provides the rest of MOOD with lightweight processes, accurately-timed event performance, and other low-level features. MOOD uses the scheduling model of FORMULA <ref> [AK90] </ref>. 2.1 Real-Time Processes MOOD uses several specialized types of processes. The PROCESS class abstracts the features common to these types. These include a stack, an SP save slot, and member functions for context switching and stack initialization. <p> For example, automatic harmonizer objects are planned as subclasses of OP GENERATOR. Other subclasses of GENERATOR could be used to build musical data structures such as the TTREE [Die88]. 7 Related Work Several computer languages for music are related to MOOD. FORMULA <ref> [AK90] </ref>, based on Forth, is a real-time language for algorithmic music composition. MOOD's multiple tasks and scheduling policies are derived from FORMULA. MOOD provides a cleaner and more intuitive syntax for algorithmic music specification.
Reference: [Dan89] <author> Roger B. Dannenberg. </author> <title> The Canon Score Language. </title> <journal> Computer Music Journal, </journal> <volume> 13(1), </volume> <month> Spring </month> <year> 1989. </year>
Reference-contexts: Also, since MOOD is written in an object oriented language, it is believed that MOOD is more easily extendible. MOOD is also integrable into other C++ user interface packages that desire musical features. MOOD, however, currently lacks an interactive environment which FORMULA uses extensively. The Canon score language <ref> [Dan89] </ref> for computer music, written in LISP, emphasizes nesting scores and operations (or transformations) on scores. Canon provides many inter esting transformations on scores that allow musical constructs to be defined and later ma-nipulated. Like MOOD, Canon Scores are not note lists, but are themselves programs.
Reference: [Die88] <author> Glendon Diener. TTrees: </author> <title> An Active Data Structure for Computer Music. </title> <booktitle> In Proc. International Computer Music Conference, </booktitle> <pages> pages 184-188. </pages> <publisher> Computer Music Association, </publisher> <year> 1988. </year>
Reference-contexts: Extensions need to be made for more sophisticated algorithmic music generation. For example, automatic harmonizer objects are planned as subclasses of OP GENERATOR. Other subclasses of GENERATOR could be used to build musical data structures such as the TTREE <ref> [Die88] </ref>. 7 Related Work Several computer languages for music are related to MOOD. FORMULA [AK90], based on Forth, is a real-time language for algorithmic music composition. MOOD's multiple tasks and scheduling policies are derived from FORMULA. MOOD provides a cleaner and more intuitive syntax for algorithmic music specification.
Reference: [ES90] <author> Margaret A. Ellis and Bjarne Stroustrup. </author> <title> The Annotated C++ Reference Manual. </title> <publisher> Addison-Wesley, </publisher> <year> 1990. </year>
Reference-contexts: We intend MOOD to support a variety of musical activities, including 1) algorithmic composition; 2) interactive performance environments, and 3) programmed score interpretation. We implemented MOOD as a set of C++ <ref> [ES90] </ref> classes. As discussed by Pope [Pop89], object-oriented programming languages are useful for computer music since they provide design techniques such as composition, refinement, factorization, and abstraction. Our additional reasons for using C++ include: 1) Familiarity: Programmers familiar with C++ can immediately use MOOD.
Reference: [Int89] <institution> The International MIDI Association, 5316 W. </institution> <address> 57th St., Los Angeles, CA 90056. </address> <note> MIDI 1.0 Detailed Specification, Document Version 4.1, </note> <year> 1989. </year>
Reference-contexts: 1 Introduction MOOD (Musical Object-Oriented Dialect) is a programming system for note-level computer music (e.g., computer control of MIDI <ref> [Int89] </ref> synthesizers). Unlike standard music sequencer programs that represent music as lists of note data structures, in MOOD the music is represented by the code itself; hence MOOD can specify musical algorithms as well as scores.
Reference: [JB89] <author> David Jaffe and Lee Boynton. </author> <title> An Overview of the Sound and Music Kits for the NeXT. </title> <journal> Computer Music Journal, </journal> <volume> 13(2), </volume> <month> Summer </month> <year> 1989. </year>
Reference-contexts: Users of MOOD may define abstract parameterized musical constructs either using inheritance or by writing a procedure. Canon does not have as concise a syntax as MOOD, nor does it support multiple processes or abstraction through inheritance. The NeXT Music Kit <ref> [JB89] </ref> is an Objective-C [NeX] musical interface to the NeXT machine. It provides a large assortment of well thought out tools one needs to build sequencers and sound editors, has an interface to play notes on the NeXT DSP chip, and is object-oriented and therefore extensible.
Reference: [Lan90] <author> Peter S. Langston. </author> <title> Little Languages for Music. </title> <booktitle> Computing Systems, </booktitle> <year> 1990. </year>
Reference-contexts: The Music Kit's syntax, however, is unwieldy (primarily due to Objective-C) and common operations on notes are not predefined as they are in MOOD. Also, the Music Kit does not provide multiple processes. 8 Conclusion MOOD provides a powerful language base for algorithmic computer music. Unlike musical "little languages" <ref> [Lan90] </ref>, MOOD provides a uniform, extensible, and familiar environment for algorithmic music composition. The features of C++ have contributed in many ways to the MOOD design. Inheritance allows us to define a graded set of process types, and to separate scheduling policies from the entities being scheduled.
Reference: [LCV87] <author> Mark A. Linton, Paul R. Calder, and John M. Vlissides. Interviews: </author> <title> A C++ Graphical Interface Toolkit. </title> <booktitle> In USENIX C++ Workshop Proceedings, </booktitle> <year> 1987. </year>
Reference-contexts: The ability to overload many operators enables us to provide a rich and concise syntax for expressing pitch structures. The availability of C++ toolkits such as Interviews <ref> [LCV87] </ref> will facilitate the integration of MOOD with a graphical user interface. An interactive language system (like Lisp, Forth, or Self [US87]) is often useful for computer music, and most current C++ implementations are non-interactive.
Reference: [NeX] <institution> NeXT, Inc., </institution> <address> 3475 Deer Creek Road, Palo Alto, CA 94394. </address> <booktitle> Object-Oriented Programming and Objective-C. NeXT Technical Documentation: </booktitle> <address> Appendices. </address>
Reference-contexts: Users of MOOD may define abstract parameterized musical constructs either using inheritance or by writing a procedure. Canon does not have as concise a syntax as MOOD, nor does it support multiple processes or abstraction through inheritance. The NeXT Music Kit [JB89] is an Objective-C <ref> [NeX] </ref> musical interface to the NeXT machine. It provides a large assortment of well thought out tools one needs to build sequencers and sound editors, has an interface to play notes on the NeXT DSP chip, and is object-oriented and therefore extensible.
Reference: [Pop89] <author> Stephen Travis Pope. </author> <title> Machine Tongues XI: Object-Oriented Software Design. </title> <journal> Computer Music Journal, </journal> <volume> 13(2), </volume> <month> Summer </month> <year> 1989. </year>
Reference-contexts: We intend MOOD to support a variety of musical activities, including 1) algorithmic composition; 2) interactive performance environments, and 3) programmed score interpretation. We implemented MOOD as a set of C++ [ES90] classes. As discussed by Pope <ref> [Pop89] </ref>, object-oriented programming languages are useful for computer music since they provide design techniques such as composition, refinement, factorization, and abstraction. Our additional reasons for using C++ include: 1) Familiarity: Programmers familiar with C++ can immediately use MOOD.
Reference: [US87] <author> David Ungar and Randall B. Smith. </author> <title> Self: The Power of Simplicity. </title> <booktitle> In OOPSLA'87 Conference Proceedings, </booktitle> <year> 1987. </year>
Reference-contexts: The ability to overload many operators enables us to provide a rich and concise syntax for expressing pitch structures. The availability of C++ toolkits such as Interviews [LCV87] will facilitate the integration of MOOD with a graphical user interface. An interactive language system (like Lisp, Forth, or Self <ref> [US87] </ref>) is often useful for computer music, and most current C++ implementations are non-interactive. A second inconvenience of C++ for our purposes is that one cannot add new control structures. This precludes language features such as FORMULA's "embedded process definitions". The advantages of C++, however, outweigh these disadvantages.
References-found: 11

