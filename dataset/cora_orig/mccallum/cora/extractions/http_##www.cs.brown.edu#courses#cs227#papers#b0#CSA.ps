URL: http://www.cs.brown.edu/courses/cs227/papers/b0/CSA.ps
Refering-URL: http://www.cs.brown.edu/courses/cs227/readinglist.html
Root-URL: http://www.cs.brown.edu/
Email: fgrogono,chaling@cs.concordia.ca  
Title: Copying, Sharing, and Aliasing  
Author: Peter Grogono and Patrice Chalin 
Address: Montreal, Quebec H3G 1M8  
Affiliation: Department of Computer Science, Concordia University  
Abstract: Study of the history of programming languages reveals a subtle interplay between semantics and implementation. Early languages, designed for maximum efficiency, provided simple abstractions of the underlying hardware. These languages were followed by languages that were "problem oriented" in that they attempted to hide the grosser details of the underlying hardware. Yet confusion between semantics and implementation persists, encouraged by the survival of low-level features that are deemed to be essential for efficiency. Copying, sharing, and aliasing are examples of concepts that render the task of the programmer more difficult by confusing semantics and implementation. For object oriented programs, the important distinction is not between values and references, but between mutable and immutable objects. This distinction is the basis for a model of computation that is untainted by implementation considerations and that provides the necessary foundation for object oriented modeling. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> H. Abelson and G. Sussman. </author> <title> Structure and Interpretation of Computer Programs. </title> <publisher> MIT Press, </publisher> <year> 1985. </year> <month> 11 </month>
Reference-contexts: The value may change during the lifetime of the object. Suppose that A and B represent people with bank accounts and that both accounts have a balance of $500 (cf. <ref> [1, pages 178-179] </ref>). The balance is a mutable object that contains an immutable value. In Figure 2, the two accounts share the object that contains the balance.
Reference: [2] <author> E. Ashcroft and W. Wadge. </author> <title> R x for semantics. </title> <journal> ACM Trans. Programming Languages and Systems, </journal> <volume> 4(2) </volume> <pages> 283-294, </pages> <year> 1982. </year>
Reference-contexts: In future work, we hope to explore the possibilities for compile time checking and optimization that they suggest. 5 Related Work Ashcroft and Wadge were the first to propose that semantic theory should be applied to the design of programming languages rather than merely to their description <ref> [2] </ref>. 9 Most functional languages, beginning with pure LISP [15], have used conventions similar to those that we have discussed in Section 3. The issues are, of course, much simpler for pure functional languages, because there are no mutable objects.
Reference: [3] <author> Henry G. Baker. </author> <title> Equal rights for functional objects or, the more things change, the more they stay the same. </title> <journal> OOPS Messenger, </journal> <volume> 4(4) </volume> <pages> 2-27, </pages> <month> October </month> <year> 1993. </year>
Reference-contexts: Correct semantics is sacrificed on the altar of efficiency. 3.3 Equality An examination of the meaning of equality casts further light on the effect of copying and sharing for objects. We discuss equality briefly in this section: for a detailed treatment, see <ref> [3] </ref> or [7]. B ~ ~ ~ ~ ~ ~: env (A) = env (B) We can distinguish two kinds of equality.
Reference: [4] <author> Rosario J. D'Souza and Richard J. LeBlanc, Jr. </author> <title> Class testing by examining pointers. </title> <journal> J. Object-Oriented Programming, </journal> <volume> 7(4) </volume> <pages> 33-39, </pages> <month> July-August </month> <year> 1994. </year>
Reference-contexts: The failure of languages to distinguish between containing and sharing leads to problems of the kind described by D'Souza and LeBlanc <ref> [4] </ref>. In one of their examples, three circles, C 1 , C 2 , and C 3 are initially concentric. As the program runs, C 1 remains stationary, C 2 oscillates vertically, and C 3 oscillates horizontally. Each circle moves correctly when tested individually. <p> The identity of each person is immutable, even though the attributes of the person may change. Problems arise, however, if both of the following conditions are true <ref> [4] </ref>: the key field used by the binary search algorithm is mutable; and the nodes of the tree are shared by other objects that can change 8 those keys. Under these conditions, the invariant of the binary search tree can be violated by an object external to the tree.
Reference: [5] <author> Margaret A. Ellis and Bjarne Stroustrup. </author> <title> The Annotated C++ Reference Manual. </title> <publisher> Addison Wesley, </publisher> <year> 1990. </year>
Reference-contexts: Liskov and Guttag recommend following the convention that immutable objects are equal if they have the same abstract value (extensional equality) and that mutable objects are equal if they are indistinguishable (intensional equality) [13, pages 93-94]. The language C++ <ref> [5] </ref> provides an obvious exception to the arguments that we have presented. The design of C++ was constrained in two important ways, however: it had to be upward compatible with C, and no feature was allowed to compromise efficiency [18]. Consequently, C++ provides values, pointers, and references.
Reference: [6] <author> Peter Grogono. </author> <title> Issues in the design of an object oriented programming language. </title> <journal> Structured Programming, </journal> <volume> 12(1) </volume> <pages> 1-15, </pages> <month> January </month> <year> 1991. </year>
Reference-contexts: We can eliminate many aliasing problems by choosing a problem-oriented abstraction, such as a sequence, set, or random-access structure, rather than an array. 4 Applying the Principles The principles discussed in this paper were applied, in a somewhat less developed form, to the design of the language Dee <ref> [6] </ref>. In Dee, as in CLU [13], a name in the program denotes a reference to an object, not the object itself. The Dee compiler determines whether a method has side effects. A method without side effects is labelled "pure".
Reference: [7] <author> Peter Grogono and Philip Santas. </author> <title> Equality and assignment in object oriented languages. </title> <booktitle> In EastEurOOPe'93, </booktitle> <month> November </month> <year> 1993. </year>
Reference-contexts: Correct semantics is sacrificed on the altar of efficiency. 3.3 Equality An examination of the meaning of equality casts further light on the effect of copying and sharing for objects. We discuss equality briefly in this section: for a detailed treatment, see [3] or <ref> [7] </ref>. B ~ ~ ~ ~ ~ ~: env (A) = env (B) We can distinguish two kinds of equality. <p> Dee provides an equality predicate, "=", for the built-in classes Bool, Int, Float, and String. The language does not provide default equality predicates for user-defined classes, because the compiler does not know the semantics of comparison <ref> [7] </ref>. Programmers can define equality predicates for their own classes, using structural induction on the built-in predicates. To facilitate optimization of user-defined equality tests, as described in Section 3.3, Dee provides another predicate: x : same (y) yields true if x and y refer to the same object.
Reference: [8] <author> Aaron Hillegass. </author> <title> An afternoon with Eiffel and C++. </title> <journal> J. Object-Oriented Programming, </journal> <volume> 7(3) </volume> <pages> 52-55, </pages> <month> June </month> <year> 1994. </year>
Reference-contexts: There is some recent evidence that the low-level features of C and C++ become a handicap in large applications: recent Eiffel compilers generate code that is substantially more efficient than C++ <ref> [8] </ref>. The language Eiffel was also designed according to principles similar to ours, but Eiffel has additional features that add to its complexity. The official reference is [16] but [17] has a more complete discussion of the rationale for the language.
Reference: [9] <author> C. A. R. Hoare. </author> <title> Hints on programming language design. </title> <editor> In C. Bunyan, editor, </editor> <booktitle> State of the Art 20: Computer Systems Reliability, </booktitle> <pages> pages 505-34, </pages> <address> Pergamon/Infotech, </address> <year> 1974. </year> <note> Reprinted in Essays in Computing Science, </note> <editor> C. A. R. Hoare and C. B. Jones (eds), </editor> <publisher> Prentice Hall International, </publisher> <year> 1989. </year>
Reference-contexts: Their introduction into high-level languages has been a step backward from which we may never recover" <ref> [9] </ref>. Consider, for example, the meaning of the assignment statement, x := E, in a modern programming language.
Reference: [10] <author> C. A. R. Hoare. </author> <title> Recursive data structures. </title> <journal> Int. J. of Computer and Information Sciences, </journal> <volume> 4(2) </volume> <pages> 105-132, </pages> <month> June </month> <year> 1975. </year> <note> Reprinted in Essays in Computing Science, </note> <editor> C. A. R. Hoare and C. B. Jones (eds), </editor> <publisher> Prentice Hall International, </publisher> <year> 1989. </year>
Reference-contexts: The issues are, of course, much simpler for pure functional languages, because there are no mutable objects. Consistently with his views on references in high-level languages, quoted above, Hoare described methods for handling recursive data structures without explicit pointers <ref> [10] </ref>. Although Hoare's paper contains many innovative suggestions, it is concerned mostly with immutable objects. The language CLU was designed according to principles very similar to those discussed here.
Reference: [11] <author> John Hogg. </author> <title> Islands: aliasing protection in object oriented languages. </title> <editor> In N. Meyrowitz, editor, </editor> <booktitle> Proc. ACM Conf. on Object-Oriented Programming Systems, Languages and Applications, </booktitle> <pages> pages 271-285, </pages> <year> 1991. </year>
Reference-contexts: Hogg et al. define aliasing as the presence of more than one path to an object. They consider aliasing to be a problem only if different paths to an object correspond to different "roles" of the object [12]. Hogg has also proposed a solution to the "problem" of aliasing <ref> [11] </ref>. 6 Conclusions The central argument of this paper is that, at the language level, objects should be classified by their mutability. Both the programmer and the compiler must know whether an object is mutable.
Reference: [12] <author> John Hogg, Doug Lea, Alan Wills, Dennis de Champeaux, and Richard Holt. </author> <title> The Geneva convention on the treatment of object aliasing. </title> <journal> OOPS Messenger, </journal> <volume> 3(2) </volume> <pages> 11-16, </pages> <month> April </month> <year> 1992. </year> <note> (Report on ECOOP'91 Workshop W3). </note>
Reference-contexts: Copying and cloning are different operations in Eiffel [16, pages 298-303]. Hogg et al. define aliasing as the presence of more than one path to an object. They consider aliasing to be a problem only if different paths to an object correspond to different "roles" of the object <ref> [12] </ref>. Hogg has also proposed a solution to the "problem" of aliasing [11]. 6 Conclusions The central argument of this paper is that, at the language level, objects should be classified by their mutability. Both the programmer and the compiler must know whether an object is mutable.
Reference: [13] <author> Barbara Liskov and John Guttag. </author> <title> Abstraction and Specification in Program Development. </title> <publisher> MIT Press, </publisher> <year> 1986. </year>
Reference-contexts: But this optimization is difficult to automate, because extensional equality cannot be built in to the language <ref> [13, page 93] </ref>. Consequently, language designers should allow programmers to perform this optimization explicitly. Address comparison should be provided in such a way, however, that immutable classes can use identity comparison for efficiency but can hide the operation from clients. <p> In Dee, as in CLU <ref> [13] </ref>, a name in the program denotes a reference to an object, not the object itself. The Dee compiler determines whether a method has side effects. A method without side effects is labelled "pure". <p> Although Hoare's paper contains many innovative suggestions, it is concerned mostly with immutable objects. The language CLU was designed according to principles very similar to those discussed here. CLU was considered by its designers to be "object oriented" <ref> [13, page 38] </ref>, although it is perhaps more "object based" in Wegner's classification [19]. Objects in CLU are either mutable or immutable. After executing the assignment operation x := E, the variable x refers to the object yielded by evaluation of the expression E. <p> Liskov and Guttag recommend following the convention that immutable objects are equal if they have the same abstract value (extensional equality) and that mutable objects are equal if they are indistinguishable (intensional equality) <ref> [13, pages 93-94] </ref>. The language C++ [5] provides an obvious exception to the arguments that we have presented. The design of C++ was constrained in two important ways, however: it had to be upward compatible with C, and no feature was allowed to compromise efficiency [18].
Reference: [14] <author> Bruce J. MacLennan. </author> <title> Values and objects in programming languages. </title> <journal> ACM SIGPLAN Notices, </journal> <volume> 17(12) </volume> <pages> 70-79, </pages> <month> December </month> <year> 1983. </year>
Reference-contexts: The object oriented model of computation that we discuss in this paper replaces the distinction between value and reference by a more fundamental distinction: whether or not an object changes during its lifetime. 2 Computational Objects In a widely-cited paper <ref> [14] </ref>, MacLennan distinguished "values" and "objects". A value is an abstraction. We cannot talk about, or compute with, values, but only with their representations. Five, cinq, 5, 101 2 , jjjjj 1 ; : : : are different representations of the same value.
Reference: [15] <author> John McCarthy, Paul W. Abrahams, Daniel J. Edwards, Timothy P. Hart, and Michael I. Levin. </author> <title> LISP 1.5 Programmer's Manual. </title> <publisher> MIT Press, </publisher> <year> 1962. </year>
Reference-contexts: explore the possibilities for compile time checking and optimization that they suggest. 5 Related Work Ashcroft and Wadge were the first to propose that semantic theory should be applied to the design of programming languages rather than merely to their description [2]. 9 Most functional languages, beginning with pure LISP <ref> [15] </ref>, have used conventions similar to those that we have discussed in Section 3. The issues are, of course, much simpler for pure functional languages, because there are no mutable objects.
Reference: [16] <author> Bertrand Meyer. </author> <title> Eiffel: the Language. </title> <publisher> Prentice Hall International, </publisher> <year> 1992. </year>
Reference-contexts: The language Eiffel was also designed according to principles similar to ours, but Eiffel has additional features that add to its complexity. The official reference is <ref> [16] </ref> but [17] has a more complete discussion of the rationale for the language. As in Dee and CLU, there is no explicit syntax for pointers. Nevertheless, objects of primitive and "expanded" classes have value semantics and objects of other classes have reference semantics. <p> Nevertheless, objects of primitive and "expanded" classes have value semantics and objects of other classes have reference semantics. Eiffel also provides both "shallow" and "deep" copy, although there appears to be little semantic justification for these operations. Copying and cloning are different operations in Eiffel <ref> [16, pages 298-303] </ref>. Hogg et al. define aliasing as the presence of more than one path to an object. They consider aliasing to be a problem only if different paths to an object correspond to different "roles" of the object [12]. <p> There are a few circumstances in which the programmer needs to duplicate an object. Since the assignment operator is not appropriate for rare operations, the language should provide special operations such as Eiffel's Copy and Clone <ref> [16] </ref> for this purpose. For assignment of immutable objects, the compiler should choose an implementation appropriate to the size of the object. Mutable objects should be assigned by reference. The semantics of the assignment operator should not depend on the form of its operands.
Reference: [17] <author> Bertrand Meyer. </author> <title> Object-oriented Software Construction. </title> <publisher> Prentice Hall International, </publisher> <year> 1988. </year>
Reference-contexts: This is a 5 very special use of copying, however, and it is preferable to give it an accurate name, such as "cloning" in Eiffel <ref> [17] </ref>. It may be necessary to have multiple incarnations of a mutable object, either in different memory spaces for efficiency, or at different storage levels for security. It is the responsibility of the compiler and run-time system, not the programmer, however, to create such copies and maintain consistency between them. <p> The language Eiffel was also designed according to principles similar to ours, but Eiffel has additional features that add to its complexity. The official reference is [16] but <ref> [17] </ref> has a more complete discussion of the rationale for the language. As in Dee and CLU, there is no explicit syntax for pointers. Nevertheless, objects of primitive and "expanded" classes have value semantics and objects of other classes have reference semantics.
Reference: [18] <author> Bjarne Stroustrup. </author> <title> A history of C++: 1979-1991. </title> <journal> ACM SIGPLAN Notices, </journal> <volume> 28(3) </volume> <pages> 271-298, </pages> <month> March </month> <year> 1993. </year> <title> Preprint of presentation at HOPL-II, </title> <address> Cambridge MA, </address> <month> April </month> <year> 1993. </year> <month> 12 </month>
Reference-contexts: The language C++ [5] provides an obvious exception to the arguments that we have presented. The design of C++ was constrained in two important ways, however: it had to be upward compatible with C, and no feature was allowed to compromise efficiency <ref> [18] </ref>. Consequently, C++ provides values, pointers, and references. Although C++ is clearly efficient for small programs, the complexity of the language makes it difficult for programmers to ensure that large programs are efficient.
Reference: [19] <author> Peter Wegner. </author> <title> The object-oriented classification paradigm. </title> <editor> In B. Shriver and Peter Wegner, editors, </editor> <booktitle> Research Directions in Object-Oriented Programming, </booktitle> <pages> pages 479-560, </pages> <publisher> MIT Press, </publisher> <year> 1987. </year> <month> 13 </month>
Reference-contexts: The language CLU was designed according to principles very similar to those discussed here. CLU was considered by its designers to be "object oriented" [13, page 38], although it is perhaps more "object based" in Wegner's classification <ref> [19] </ref>. Objects in CLU are either mutable or immutable. After executing the assignment operation x := E, the variable x refers to the object yielded by evaluation of the expression E.
References-found: 19

