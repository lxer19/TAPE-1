URL: http://www.cs.rice.edu/CS/PLT/Publications/popl91-cf.ps.gz
Refering-URL: http://www.cs.rice.edu/CS/PLT/Publications/
Root-URL: 
Title: Parameter-Passing and the Lambda Calculus a program rewriting semantics for a language with side-effects and
Author: Erik Crank Matthias Felleisen 
Date: January 19-22, 1991  
Note: 1.  The authors are supported in part by NSF and DARPA. The  generously provided facilities for preparing the final version of the paper. Appeared in: 18th POPL  Orlando, FL  
Address: Houston, TX 77251-1892  
Affiliation: Department of Computer Science Rice University  Instituto de Computacion of the Universidad de la Republica Oriental del Uruguay  
Abstract: The choice of a parameter-passing technique is an important decision in the design of a high-level programming language. To clarify some of the semantic aspects of the decision, we develop, analyze, and compare modifications of the -calculus for the most common parameter-passing techniques, i.e., call-by-value and call-by-name combined with pass-by-worth and pass-by-reference, respectively. More specifically, for each parameter-passing technique we provide 
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> Barendregt, </author> <title> H.P. The Lambda Calculus: Its Syntax and Semantics. Revised Edition. </title> <booktitle> Studies in Logic and the Foundations of Mathematics 103. </booktitle> <publisher> North-Holland, </publisher> <address> Amsterdam, </address> <year> 1984. </year>
Reference-contexts: The core of our languages, fl, consists of constants (c), variables (x ), -abstractions and applications of the -calculus: e ::= x j v j (ee) The languages extend fl with constructs for side-effects, which we describe in later sections. Following Barendregt's <ref> [1] </ref> conventions, we assume that, in the following definitions and theorems, the bound variables are distinct from the free variables in expressions, and we identify expressions that differ only by a renaming of the bound variables.
Reference: 2. <author> Cartwright, R. and D. Oppen. </author> <title> The logic of aliasing. </title> <journal> Acta Inf. </journal> <volume> 15, </volume> <year> 1981, </year> <pages> 365-384. </pages>
Reference-contexts: Finally, a number of researchers have studied parameter-passing in the context of Hoare-like axiomatic semantics [14, 12, 6]. These systems are generally for first-order subsets of Pascal and have a number of restrictions on procedure calls, such as aliasing. Cartwright and Oppen <ref> [2] </ref> overcome the aliasing restriction, but still do not allow procedures as arguments.
Reference: 3. <author> Church, A. </author> <title> The Calculi of Lambda-Conversion. </title> <publisher> Princeton University Press, Princeton, </publisher> <year> 1941. </year>
Reference-contexts: With this addition, the Strong Normalization Theorem for the notion of reduction s 0 also holds for s 0 [ seq. 3.4 Call-by-name/Pass-by-reference The Revised Report on Algol 60 [18] informally defined the semantics of call-by-name parameter-passing with the copy rule. The intention was to implement Church's <ref> [3] </ref> fi relation from the original -calculus as the parameter-passing technique of the new language. Copying an argument to every parameter occurrence was thought to be the computational equivalent to function evaluation in ordinary mathematics.
Reference: 4. <author> Crank, E. </author> <title> Parameter-passing and the lambda-calculus. </title> <type> Master's Thesis, </type> <institution> Rice University, </institution> <month> August </month> <year> 1990. </year>
Reference-contexts: Muller [17] recently analyzed some of the problems of deriving equational theories in the presence of call-by-text. Call-by-need is an optimization of call-by-name in a functional language, but produces different answers than call-by-name in the presence of side-effects. The extended version of this paper <ref> [4] </ref> contains a brief discussion of call-by-need. 2 From Operational Semantics to Cal culi In our analysis of parameter-passing, there are three main steps. First, we define an operational semantics for a language with a particular parameter-passing technique. <p> The reduction satisfies Church-Rosser and Curry-Feys Standardization lemmas that imply the soundness of the calculus. Otherwise, the proof is an adaptation of the proofs for the calculi of Plotkin [20] and Felleisen et al [9, 10]. For details, we refer the reader to the extended report <ref> [4] </ref>. Finally, we examine the question of whether there are decidable subsets of the calculus. In our case, the imperative subtheory v , that is, the theory based upon the transition relations that do not deal with procedure applications, is decidable. <p> Again, the details can be found in the extended report <ref> [4] </ref>. 3.2 Call-by-value/Pass-by-reference Pascal, Fortran and other languages allow pass-by-reference procedure parameters in addition to pass-by-worth parameters. Generally, these languages require that the actual argument for a pass-by-reference param eter be a variable.
Reference: 5. <author> Demers, A. and J. Donahue. </author> <title> Making variables abstract: an equational theory for Russell. </title> <booktitle> In Proc. 10th ACM Symposium on Principles of Programming Languages, </booktitle> <year> 1983, </year> <pages> 59-72. </pages>
Reference-contexts: Demers and Donahue <ref> [5] </ref> give an equational logic for reasoning about a higher-order language that uses call-by-value parameter-passing and has memory objects similar to reference cells. The equational theory contains several dozen axioms for which they present no formal results.
Reference: 6. <author> Donahue, </author> <title> J.E. Complementary Definitions of Programming Language Semantics. </title> <booktitle> Lecture Notes in Computer Science 42, </booktitle> <publisher> Springer-Verlag, </publisher> <address> Heidel-berg, </address> <year> 1980. </year>
Reference-contexts: Such descriptions specify precise set-theoretic interpretations of parameter-passing but do not provide an intuitive and simple set of equations nor other axiomatic theories. Finally, a number of researchers have studied parameter-passing in the context of Hoare-like axiomatic semantics <ref> [14, 12, 6] </ref>. These systems are generally for first-order subsets of Pascal and have a number of restrictions on procedure calls, such as aliasing. Cartwright and Oppen [2] overcome the aliasing restriction, but still do not allow procedures as arguments.
Reference: 7. <author> Dybvig, R. K. </author> <title> The Scheme Programming Language, </title> <publisher> Prentice-Hall, </publisher> <address> Englewood Cliffs, New Jersey, </address> <year> 1987. </year>
Reference-contexts: Since variables are no longer assignable, we treat them as values. The term language IS b extends the language of the v -calculus with the -expression, a set of reference cells and expressions for creating, assigning and dereferencing cells. Adopting Chez Scheme terminology <ref> [7] </ref>, we use the primitives box, setbox!, and unbox to perform these operations in IS b . The first part of Figure 3 contains the specification of the term language IS b . As usual, both -abstractions and -expressions are binding ex pressions, but while binds variables, binds reference cells.
Reference: 8. <author> Felleisen, M. </author> <title> On the expressive power of programming languages. </title> <booktitle> In Proc. 1990 European Symposium on Programming. </booktitle> <editor> Neil Jones, Ed. </editor> <booktitle> Lecture Notes in Computer Science, </booktitle> <volume> 432. </volume> <publisher> Springer Verlag, </publisher> <address> Berlin, </address> <year> 1990, </year> <pages> 134-151. </pages>
Reference-contexts: In fact, it is possible to show that IS b and IS v are equivalent in the formal sense of programming language expressiveness <ref> [8] </ref>. For the pass-by-reference language, the connection is not as clear, and we have no formal expressibility results. However, reference cells in the pass-by-worth language provide the ability to abstract over assignments to formal arguments (cells in this case), which was the original motivation for pass-by-reference.
Reference: 9. <author> Felleisen, M. and D.P. Friedman. </author> <title> A syntactic theory of sequential state. </title> <journal> Theor. Comput. Sci. </journal> <volume> 69(3), </volume> <year> 1989, </year> <month> 243-287. </month> <title> Preliminary version in: </title> <booktitle> Proc. 14th ACM Symposium on Principles of Programming Languages, </booktitle> <year> 1987, </year> <pages> 314-325. </pages>
Reference-contexts: Recently, Felleisen with Friedman <ref> [9] </ref> and Hieb [10] extended Plotkin's work to call-by-value programming languages with imperative constructs like assignments and jumps. Their result shows that, like functional constructs, imperative constructs have a simple rewriting semantics, and that there are conservative extensions of the v -calculus for reasoning about them, namely the v -fC,S,CSg-calculi. <p> Furthermore, the gc-nf of an answer is also an answer. 4 Although variables are values in the v -calculus, the addition of an assignment statement to the language requires that assignable variables not be values. Felleisen et al <ref> [9, 10] </ref> conservatively extend the v -calculus by enlarging the set of variables with a set of assignable variables. The original unassignable variables of the v -calculus are values, whereas the additional assignable variables are not. <p> For soundness, we derive a notion of reduction vw from &gt; vw and gc. The reduction satisfies Church-Rosser and Curry-Feys Standardization lemmas that imply the soundness of the calculus. Otherwise, the proof is an adaptation of the proofs for the calculi of Plotkin [20] and Felleisen et al <ref> [9, 10] </ref>. For details, we refer the reader to the extended report [4]. Finally, we examine the question of whether there are decidable subsets of the calculus. <p> Reference cells in a call-by-value/pass-by-worth language provide both options within the same, simple language. 4 Related Work Our equational systems were motivated by the work of Plotkin [20], who studied equational reasoning systems for call-by-name and call-by-value in functional languages, and Felleisen et al <ref> [9, 10] </ref> who developed calculi for call-by-value imperative languages. Demers and Donahue [5] give an equational logic for reasoning about a higher-order language that uses call-by-value parameter-passing and has memory objects similar to reference cells. The equational theory contains several dozen axioms for which they present no formal results.
Reference: 10. <author> Felleisen, M. and R. Hieb. </author> <title> The revised report on the syntactic theories of sequential control and state. </title> <type> Technical Report 100, </type> <institution> Rice University, </institution> <month> June </month> <year> 1989. </year>
Reference-contexts: Recently, Felleisen with Friedman [9] and Hieb <ref> [10] </ref> extended Plotkin's work to call-by-value programming languages with imperative constructs like assignments and jumps. Their result shows that, like functional constructs, imperative constructs have a simple rewriting semantics, and that there are conservative extensions of the v -calculus for reasoning about them, namely the v -fC,S,CSg-calculi. <p> In this section, we present a call-by-value/pass-by-worth language with assignment, derive a calculus for reasoning about the language, and show that it corresponds to the semantics. Both the language and calculus are variations on the work by Felleisen and Hieb <ref> [10] </ref>. The call-by-value term language, Idealized Scheme or IS v , extends fl with two new expressions. First, there is an assignment statement, (set! x e), which assigns to the variable x the value of the expression e. <p> The -expression establishes mutually recursive bindings of the variables to their associated values and returns the value of the sub-expression. The term language IS v is given in the first part of Figure 1. There are two basic differences between this language and the language of Felleisen and Hieb <ref> [10] </ref>. First, we use the assignment statement set! instead of the sigma capability. Although the sigma capability is a powerful programming construct, most languages implement weaker constructs such as the set! expression. <p> Second, like in Scheme, all variables are assignable, that is, they may occur in the variable position of a set! expression. Therefore, unlike in the v -calculus [20] and the v -S-calculus <ref> [10] </ref>, variables in our language are expressions, not values. 4 In addition to adopting Barendregt's conventions for free and bound variables, we identify -lists that differ only by the ordering of their pairs: (x 1 ; v 1 ) : : : (x n ; v n ) (x i 1 <p> Furthermore, the gc-nf of an answer is also an answer. 4 Although variables are values in the v -calculus, the addition of an assignment statement to the language requires that assignable variables not be values. Felleisen et al <ref> [9, 10] </ref> conservatively extend the v -calculus by enlarging the set of variables with a set of assignable variables. The original unassignable variables of the v -calculus are values, whereas the additional assignable variables are not. <p> For soundness, we derive a notion of reduction vw from &gt; vw and gc. The reduction satisfies Church-Rosser and Curry-Feys Standardization lemmas that imply the soundness of the calculus. Otherwise, the proof is an adaptation of the proofs for the calculi of Plotkin [20] and Felleisen et al <ref> [9, 10] </ref>. For details, we refer the reader to the extended report [4]. Finally, we examine the question of whether there are decidable subsets of the calculus. <p> Reference cells in a call-by-value/pass-by-worth language provide both options within the same, simple language. 4 Related Work Our equational systems were motivated by the work of Plotkin [20], who studied equational reasoning systems for call-by-name and call-by-value in functional languages, and Felleisen et al <ref> [9, 10] </ref> who developed calculi for call-by-value imperative languages. Demers and Donahue [5] give an equational logic for reasoning about a higher-order language that uses call-by-value parameter-passing and has memory objects similar to reference cells. The equational theory contains several dozen axioms for which they present no formal results.
Reference: 11. <author> Gordon, M.J. </author> <title> The Denotational Description of Programming Languages, </title> <publisher> Springer-Verlag, </publisher> <address> New York, </address> <year> 1979. </year>
Reference-contexts: Their logic is complete for the recursion-free, first-order fragment of Lisp with side-effects. In the area of denotational semantics, several authors <ref> [11, 22] </ref> have given denotational descriptions of the different parameter-passing techniques. Such descriptions specify precise set-theoretic interpretations of parameter-passing but do not provide an intuitive and simple set of equations nor other axiomatic theories.
Reference: 12. <author> Gries, D. and G. Levin. </author> <title> Assignment and Procedure Call Proof Rules. </title> <journal> ACM Trans. Program. Lang. Syst. </journal> <volume> 2(4), </volume> <year> 1980, </year> <pages> 564-579. </pages>
Reference-contexts: Such descriptions specify precise set-theoretic interpretations of parameter-passing but do not provide an intuitive and simple set of equations nor other axiomatic theories. Finally, a number of researchers have studied parameter-passing in the context of Hoare-like axiomatic semantics <ref> [14, 12, 6] </ref>. These systems are generally for first-order subsets of Pascal and have a number of restrictions on procedure calls, such as aliasing. Cartwright and Oppen [2] overcome the aliasing restriction, but still do not allow procedures as arguments.
Reference: 13. <author> Hoare, C. A. R. </author> <title> An axiomatic basis for computer programming. </title> <journal> Commun. ACM 12, </journal> <year> 1969, </year> <pages> 576-580. </pages>
Reference: 14. <author> Hoare, </author> <title> C.A.R. Procedures and parameters: An axiomatic approach. </title> <booktitle> In Symposium on Semantics of Algorithmic Languages, </booktitle> <editor> E. Engeler (Ed.). </editor> <booktitle> Lecture Notes in Mathematics 188. </booktitle> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1971, </year> <pages> 102-116. </pages>
Reference-contexts: Such descriptions specify precise set-theoretic interpretations of parameter-passing but do not provide an intuitive and simple set of equations nor other axiomatic theories. Finally, a number of researchers have studied parameter-passing in the context of Hoare-like axiomatic semantics <ref> [14, 12, 6] </ref>. These systems are generally for first-order subsets of Pascal and have a number of restrictions on procedure calls, such as aliasing. Cartwright and Oppen [2] overcome the aliasing restriction, but still do not allow procedures as arguments.
Reference: 15. <author> Landin, P.J. </author> <title> The next 700 programming languages. </title> <journal> Commun. ACM 9(3), </journal> <year> 1966, </year> <pages> 157-166. </pages>
Reference: 16. <author> Mason, I.A. and C. Talcott. </author> <title> A sound and complete axiomatization of operational equivalence between programs with memory. </title> <booktitle> In Proc. Symposium on Logic in Computer Science, </booktitle> <year> 1989, </year> <pages> 284-293. </pages> <note> An extended version will appear in Theor. </note> <institution> Comput. Sci. </institution>
Reference-contexts: Specifically, the notion of reduction consisting of these relations is strongly normalizing. This is a new result, which does not hold for the imperative fragment of the v -S-calculus. It is motivated by the completeness theorem for a non-recursive fragment of first-order Lisp by Mason and Talcott <ref> [16] </ref>. Theorem 3.2 Let ffi c be the modification of the relation E:ffi as follows: (f v) ! ffi (f; v); where ffi (f; v) 2 Consts (ffi c ) Let s = ffi c [ D v [ v [ [ [ gc. Then, s j= SN. Proof. <p> Demers and Donahue [5] give an equational logic for reasoning about a higher-order language that uses call-by-value parameter-passing and has memory objects similar to reference cells. The equational theory contains several dozen axioms for which they present no formal results. Mason and Talcott <ref> [16] </ref> present a conditional deduction system for observational equivalences of Lisp expressions with side-effects, a language similar to the imperative fragment of our reference cell language. Their logic is complete for the recursion-free, first-order fragment of Lisp with side-effects.
Reference: 17. <author> Muller, R. </author> <title> The operational semantics and equational logic of eval and fexprs. </title> <type> Unpublished manuscript. </type> <institution> Harvard University, </institution> <year> 1990. </year>
Reference-contexts: We discuss related work and compare the different techniques in Sections 4 and 5. 1 Two other delayed evaluation strategies, which we do not consider in this paper, are call-by-text and call-by-need. Call-by-text never evaluates procedure arguments, thus, delaying evaluation forever. Muller <ref> [17] </ref> recently analyzed some of the problems of deriving equational theories in the presence of call-by-text. Call-by-need is an optimization of call-by-name in a functional language, but produces different answers than call-by-name in the presence of side-effects.
Reference: 18. <author> Naur, P. (Ed.). </author> <title> Revised report on the algorithmic language ALGOL 60. </title> <journal> Comm. ACM 6(1), </journal> <year> 1963, </year> <pages> 1-17. </pages>
Reference-contexts: With this addition, the Strong Normalization Theorem for the notion of reduction s 0 also holds for s 0 [ seq. 3.4 Call-by-name/Pass-by-reference The Revised Report on Algol 60 <ref> [18] </ref> informally defined the semantics of call-by-name parameter-passing with the copy rule. The intention was to implement Church's [3] fi relation from the original -calculus as the parameter-passing technique of the new language.
Reference: 19. <author> Olderog, E. </author> <title> Sound and complete Hoare-like calculi based on copy rules. </title> <journal> Acta Inf. </journal> <volume> 16, </volume> <year> 1981, </year> <pages> 161-197. </pages>
Reference-contexts: These systems are generally for first-order subsets of Pascal and have a number of restrictions on procedure calls, such as aliasing. Cartwright and Oppen [2] overcome the aliasing restriction, but still do not allow procedures as arguments. Olderog <ref> [19] </ref> eliminates the restrictions on procedures, but his Hoare-like calculi explicitly require operational specifications of procedure calls using the copy rule. 5 Conclusions For several common parameter-passing techniques we presented a program rewriting semantics and derived a corresponding calculus.
Reference: 20. <author> Plotkin, G.D. </author> <title> Call-by-name, call-by-value, and the -calculus. </title> <journal> Theor. Comput. Sci. </journal> <volume> 1, </volume> <year> 1975, </year> <pages> 125-159. </pages>
Reference-contexts: The wide variety of techniques in modern languages, e.g., call-by-value, call-by-name, pass-by-reference, suggests a lack of consensus about the advantages and disadvantages of the various techniques. In this paper we analyze the most common techniques by studying and comparing equational theories for each of them. Plotkin <ref> [20] </ref> was the first to consider equational theories for the analysis of parameter-passing techniques. <p> The Analysis of Calculi Given a semantics, its observational equivalence relation and a calculus, it is natural to ask how the latter relates to the former. Plotkin <ref> [20] </ref> gave two criteria for correspondence between a calculus and a semantics. First, the calculus must be capable of evaluating programs. In particular, if the semantics defines the meaning of a program e to be a, then the two should be provably equivalent in the calculus. <p> Although the sigma capability is a powerful programming construct, most languages implement weaker constructs such as the set! expression. Second, like in Scheme, all variables are assignable, that is, they may occur in the variable position of a set! expression. Therefore, unlike in the v -calculus <ref> [20] </ref> and the v -S-calculus [10], variables in our language are expressions, not values. 4 In addition to adopting Barendregt's conventions for free and bound variables, we identify -lists that differ only by the ordering of their pairs: (x 1 ; v 1 ) : : : (x n ; v <p> For soundness, we derive a notion of reduction vw from &gt; vw and gc. The reduction satisfies Church-Rosser and Curry-Feys Standardization lemmas that imply the soundness of the calculus. Otherwise, the proof is an adaptation of the proofs for the calculi of Plotkin <ref> [20] </ref> and Felleisen et al [9, 10]. For details, we refer the reader to the extended report [4]. Finally, we examine the question of whether there are decidable subsets of the calculus. <p> The pass-by-reference semantics provides an alternative: it passes only variables and does not allow dereferencing variables when they occur as arguments. Reference cells in a call-by-value/pass-by-worth language provide both options within the same, simple language. 4 Related Work Our equational systems were motivated by the work of Plotkin <ref> [20] </ref>, who studied equational reasoning systems for call-by-name and call-by-value in functional languages, and Felleisen et al [9, 10] who developed calculi for call-by-value imperative languages.
Reference: 21. <editor> Rees, J. and W. Clinger (Eds.). </editor> <title> The revised 3 report on the algorithmic language Scheme. </title> <journal> SIG-PLAN Notices 21(12), </journal> <year> 1986, </year> <pages> 37-79. </pages>
Reference: 22. <author> Schmidt, D.A. </author> <title> Denotational Semantics: A Methodology for Language Development. </title> <publisher> Allyn and Bacon, </publisher> <address> Newton, Mass., </address> <year> 1986. </year>
Reference-contexts: Their logic is complete for the recursion-free, first-order fragment of Lisp with side-effects. In the area of denotational semantics, several authors <ref> [11, 22] </ref> have given denotational descriptions of the different parameter-passing techniques. Such descriptions specify precise set-theoretic interpretations of parameter-passing but do not provide an intuitive and simple set of equations nor other axiomatic theories.
Reference: 23. <institution> US Department of Defense. </institution> <note> The Programming Language Ada|Reference Manual , Lecture Notes in Computer Science 106, Springer-Verlag, 1981. 11 </note>
Reference-contexts: Theorem 3.4 Let s 0 = ffi c [ D 0 v [ v [ [ [ gc. Then, s 0 j= SN and fi r j= SN. 3.3 Call-by-value-result The programming languages Ada <ref> [23] </ref> and Algol W [24] specify a parameter-passing technique known as call-by-value-result, or copy-in/copy-out. 6 This parameter-passing technique uses the eager evaluation strategy and is similar to both the pass-by-worth and pass-by reference binding techniques. Like pass-by-reference, arguments to procedures must be variables.
Reference: 24. <author> Wirth N. </author> <title> and C.A.R. Hoare. A contribution to the development of ALGOL. </title> <journal> Commun. ACM 9(6), </journal> <year> 1966, </year> <pages> 413-432. </pages>
Reference-contexts: Theorem 3.4 Let s 0 = ffi c [ D 0 v [ v [ [ [ gc. Then, s 0 j= SN and fi r j= SN. 3.3 Call-by-value-result The programming languages Ada [23] and Algol W <ref> [24] </ref> specify a parameter-passing technique known as call-by-value-result, or copy-in/copy-out. 6 This parameter-passing technique uses the eager evaluation strategy and is similar to both the pass-by-worth and pass-by reference binding techniques. Like pass-by-reference, arguments to procedures must be variables.
References-found: 24

