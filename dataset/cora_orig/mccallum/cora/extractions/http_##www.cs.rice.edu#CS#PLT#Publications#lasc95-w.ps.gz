URL: http://www.cs.rice.edu/CS/PLT/Publications/lasc95-w.ps.gz
Refering-URL: http://www.cs.rice.edu/CS/PLT/Publications/
Root-URL: 
Email: wright@cs.rice.edu  
Title: Simple Imperative Polymorphism  
Author: ANDREW K. WRIGHT Editor: Ian A. Mason 
Keyword: Continuations, functional programming, polymorphism, references, state  
Address: Houston, TX 77251-1892  
Affiliation: Department of Computer Science, Rice University,  
Note: 1--13 cfl Kluwer Academic Publishers, Boston. Manufactured in The Netherlands.  
Abstract: This paper describes a simple extension of the Hindley-Milner polymorphic type discipline to call-by-value languages that incorporate imperative features like references, exceptions, and continuations. This extension sacrifices the ability to type every purely functional expression that is typable in the Hindley-Milner system. In return, it assigns the same type to functional and imperative implementations of the same abstraction. Hence with a module system that separates specifications from implementations, imperative features can be freely used to implement polymorphic specifications. A study of a number of ML programs shows that the inability to type all Hindley-Milner typable expressions seldom impacts realistic programs. Furthermore, most programs that are rendered untypable by the new system can be easily repaired. 
Abstract-found: 1
Intro-found: 1
Reference: 1. <institution> This observation is due to Stefan Kahrs. </institution>
Reference-contexts: Many call-by-value languages include imperative features like references, exceptions, and continuations that facilitate concise and efficient programs. Several solutions to integrating imperative features with Hindley-Milner polymorphism in call-by-value languages have been devised <ref> [1] </ref>, [3], [4], [8], [9], [11], [17], [18], [19]. These solutions range in complexity from Tofte's relatively simple method that Standard ML adopted to Talpin's sophisticated system that infers types, regions, and effects. <p> But such an imperative version of sort has the following imperative types in Tofte's system [18], MacQueen's system <ref> [1] </ref>, and Leroy's system [9], [11]: 8 ff: ( ff ! ff ! bool ) ! ( ff list) ! ( ff list) (Tofte) 8ff 2 : (ff 2 ! ff 2 ! bool ) ! (ff 2 list) ! (ff 2 list ) (MacQueen) 8ffLM N P: (ff L M <p> Exactly which type variables can be generalized is undecidable. A sound solution to typing reference cells must avoid generalizing type variables that appear in the types of shared reference cells. 2.1. Conservative solutions The solutions devised to date <ref> [1] </ref>, [3], [4], [8], [9], [11], [17], [18], [19] are conservative extensions of the Hindley-Milner type system. That is, they assign types to all HM-typable expressions. Conservative solutions require determining whether and to what degree a let-expression's binding uses imperative features. <p> In Standard ML the fastrev function defined above has type 8 ff: ( ff list) ! ( ff list). Weak Types: A system proposed by MacQueen has been used by Standard ML of New Jersey for several years <ref> [1] </ref>. Two approximations to it have recently been formalized by 5 Hoang, Mitchell, and Viswanathan [8] and Greiner [4]. These methods extend Tofte's method by assigning weakness numbers to type variables.
Reference: 2. <institution> See rules 100-102 of the Definition [14] and the footnote on page 55 of the Commentary [13]. </institution>
Reference-contexts: Hence removing applicative type variables from Tofte's system yields a system isomorphic to ours. 1 The existing proofs of type soundness for Tofte's system [18], [20] establish type soundness for ours. 7 We can easily establish that our system possesses a type inference algorithm which finds principal types <ref> [2] </ref>. The algorithm is the ordinary Hindley-Milner type inference algorithm run after a simple translation.
Reference: 3. <institution> This extension to ML's module system appears to be sound [Bob Harper, </institution> <type> personal communication, </type> <month> February </month> <year> 1993]. </year> <title> It may be possible to allow free type variables even in the absence of a signature constraint, but we have not investigated this more flexible extension. References 1. ``Standard ML of New Jersey release notes (version 0.93),'' </title> <institution> AT&T Bell Laboratories (November 1993). </institution>
Reference-contexts: Many call-by-value languages include imperative features like references, exceptions, and continuations that facilitate concise and efficient programs. Several solutions to integrating imperative features with Hindley-Milner polymorphism in call-by-value languages have been devised [1], <ref> [3] </ref>, [4], [8], [9], [11], [17], [18], [19]. These solutions range in complexity from Tofte's relatively simple method that Standard ML adopted to Talpin's sophisticated system that infers types, regions, and effects. <p> Exactly which type variables can be generalized is undecidable. A sound solution to typing reference cells must avoid generalizing type variables that appear in the types of shared reference cells. 2.1. Conservative solutions The solutions devised to date [1], <ref> [3] </ref>, [4], [8], [9], [11], [17], [18], [19] are conservative extensions of the Hindley-Milner type system. That is, they assign types to all HM-typable expressions. Conservative solutions require determining whether and to what degree a let-expression's binding uses imperative features. <p> M; (ff L M ! bool ) . P g. Although Leroy's original closure typing system [11] did not type all HM-typable expressions, his dissertation [9] corrects this oversight. Damas: Damas proposed one of the earliest systems for typing references <ref> [3] </ref>. His system assigns both a type and a set to each expression. The set is a finite set of the types of cells that may be allocated by evaluating the expression.
Reference: 2. <author> Damas, L. M. M. </author> <title> Principal Type Schemes for Functional Programs, </title> <booktitle> In Proceedings of the 9th Annual ACM Symposium on Principles of Programming Languages (January 1982) 207--212. </booktitle>
Reference-contexts: Hence removing applicative type variables from Tofte's system yields a system isomorphic to ours. 1 The existing proofs of type soundness for Tofte's system [18], [20] establish type soundness for ours. 7 We can easily establish that our system possesses a type inference algorithm which finds principal types <ref> [2] </ref>. The algorithm is the ordinary Hindley-Milner type inference algorithm run after a simple translation.
Reference: 3. <author> Damas, L. M. M. </author> <title> Type Assignment in Programming Languages, </title> <type> PhD thesis, </type> <institution> University of Edinburgh (1985). </institution>
Reference-contexts: Many call-by-value languages include imperative features like references, exceptions, and continuations that facilitate concise and efficient programs. Several solutions to integrating imperative features with Hindley-Milner polymorphism in call-by-value languages have been devised [1], <ref> [3] </ref>, [4], [8], [9], [11], [17], [18], [19]. These solutions range in complexity from Tofte's relatively simple method that Standard ML adopted to Talpin's sophisticated system that infers types, regions, and effects. <p> Exactly which type variables can be generalized is undecidable. A sound solution to typing reference cells must avoid generalizing type variables that appear in the types of shared reference cells. 2.1. Conservative solutions The solutions devised to date [1], <ref> [3] </ref>, [4], [8], [9], [11], [17], [18], [19] are conservative extensions of the Hindley-Milner type system. That is, they assign types to all HM-typable expressions. Conservative solutions require determining whether and to what degree a let-expression's binding uses imperative features. <p> M; (ff L M ! bool ) . P g. Although Leroy's original closure typing system [11] did not type all HM-typable expressions, his dissertation [9] corrects this oversight. Damas: Damas proposed one of the earliest systems for typing references <ref> [3] </ref>. His system assigns both a type and a set to each expression. The set is a finite set of the types of cells that may be allocated by evaluating the expression.
Reference: 4. <author> Greiner, J. </author> <title> ``Standard ML weak polymorphism can be sound,'' </title> <type> Technical Report CMU-CS-93-160R, </type> <institution> Carnegie Mellon University (September 1993). </institution>
Reference-contexts: Many call-by-value languages include imperative features like references, exceptions, and continuations that facilitate concise and efficient programs. Several solutions to integrating imperative features with Hindley-Milner polymorphism in call-by-value languages have been devised [1], [3], <ref> [4] </ref>, [8], [9], [11], [17], [18], [19]. These solutions range in complexity from Tofte's relatively simple method that Standard ML adopted to Talpin's sophisticated system that infers types, regions, and effects. <p> Exactly which type variables can be generalized is undecidable. A sound solution to typing reference cells must avoid generalizing type variables that appear in the types of shared reference cells. 2.1. Conservative solutions The solutions devised to date [1], [3], <ref> [4] </ref>, [8], [9], [11], [17], [18], [19] are conservative extensions of the Hindley-Milner type system. That is, they assign types to all HM-typable expressions. Conservative solutions require determining whether and to what degree a let-expression's binding uses imperative features. <p> Weak Types: A system proposed by MacQueen has been used by Standard ML of New Jersey for several years [1]. Two approximations to it have recently been formalized by 5 Hoang, Mitchell, and Viswanathan [8] and Greiner <ref> [4] </ref>. These methods extend Tofte's method by assigning weakness numbers to type variables. The weakness of a type variable indicates how many arguments must be supplied to a curried procedure before it allocates a reference containing that type variable.
Reference: 5. <author> Harper, R. and M. Lillibridge. </author> <title> ``Explicit polymorphism and CPS conversion,'' </title> <booktitle> In Conference Record of the 20th Annual ACM Symposium on Principles of Programming Languages (January 1993) 206--219. </booktitle>
Reference: 6. <author> Harper, R., B. F. Duba, and D. MacQueen. </author> <title> ``Typing first-class continuations in ML,'' </title> <journal> Journal of Functional Programming 3, </journal> <month> 4 (October </month> <year> 1993), </year> <month> 465--484. </month>
Reference-contexts: As -expressions are values, references can be freely used in procedure bodies without inhibiting polymorphism. The fastrev function (4) from Section 2 has the polymorphic type 8ff: (ff list) ! (ff list). A sound type system for continuations must not allow continuations to be polymorphic <ref> [6] </ref>, [20]. That is, in an expression like: let val x = callcc (fn k =&gt; : : : ) in : : : x must not be assigned a polymorphic type. (Consider the explanation of let-expressions as abbreviations.
Reference: 7. <author> Hindley, R. </author> <title> ``The principal type-scheme of an object in combinatory logic,'' </title> <journal> Transactions of the American Mathematical Society, </journal> <month> 146 (December </month> <year> 1969) </year> <month> 29--60. </month>
Reference-contexts: 1. Polymorphism, Imperative Features, and Modules The Hindley-Milner polymorphic type discipline <ref> [7] </ref>, [12] is an elegant and flexible type system for functional programming languages. Many call-by-value languages include imperative features like references, exceptions, and continuations that facilitate concise and efficient programs.
Reference: 8. <author> Hoang, M., J. Mitchell, and R. Viswanathan. </author> <title> ``Standard ML-NJ weak polymorphism and imperative constructs,'' </title> <booktitle> In Proceedings of the Eighth Annual Symposium on Logic in Computer Science (June 1993) 15--25. </booktitle>
Reference-contexts: Many call-by-value languages include imperative features like references, exceptions, and continuations that facilitate concise and efficient programs. Several solutions to integrating imperative features with Hindley-Milner polymorphism in call-by-value languages have been devised [1], [3], [4], <ref> [8] </ref>, [9], [11], [17], [18], [19]. These solutions range in complexity from Tofte's relatively simple method that Standard ML adopted to Talpin's sophisticated system that infers types, regions, and effects. <p> Exactly which type variables can be generalized is undecidable. A sound solution to typing reference cells must avoid generalizing type variables that appear in the types of shared reference cells. 2.1. Conservative solutions The solutions devised to date [1], [3], [4], <ref> [8] </ref>, [9], [11], [17], [18], [19] are conservative extensions of the Hindley-Milner type system. That is, they assign types to all HM-typable expressions. Conservative solutions require determining whether and to what degree a let-expression's binding uses imperative features. <p> Weak Types: A system proposed by MacQueen has been used by Standard ML of New Jersey for several years [1]. Two approximations to it have recently been formalized by 5 Hoang, Mitchell, and Viswanathan <ref> [8] </ref> and Greiner [4]. These methods extend Tofte's method by assigning weakness numbers to type variables. The weakness of a type variable indicates how many arguments must be supplied to a curried procedure before it allocates a reference containing that type variable.
Reference: 9. <author> Leroy, X. </author> <title> Typage polymorphe d'un langage algorithmique, </title> <type> PhD thesis, </type> <note> L'Universite Paris 7 (1992). </note>
Reference-contexts: Many call-by-value languages include imperative features like references, exceptions, and continuations that facilitate concise and efficient programs. Several solutions to integrating imperative features with Hindley-Milner polymorphism in call-by-value languages have been devised [1], [3], [4], [8], <ref> [9] </ref>, [11], [17], [18], [19]. These solutions range in complexity from Tofte's relatively simple method that Standard ML adopted to Talpin's sophisticated system that infers types, regions, and effects. <p> But such an imperative version of sort has the following imperative types in Tofte's system [18], MacQueen's system [1], and Leroy's system <ref> [9] </ref>, [11]: 8 ff: ( ff ! ff ! bool ) ! ( ff list) ! ( ff list) (Tofte) 8ff 2 : (ff 2 ! ff 2 ! bool ) ! (ff 2 list) ! (ff 2 list ) (MacQueen) 8ffLM N P: (ff L M ! bool ) N <p> Exactly which type variables can be generalized is undecidable. A sound solution to typing reference cells must avoid generalizing type variables that appear in the types of shared reference cells. 2.1. Conservative solutions The solutions devised to date [1], [3], [4], [8], <ref> [9] </ref>, [11], [17], [18], [19] are conservative extensions of the Hindley-Milner type system. That is, they assign types to all HM-typable expressions. Conservative solutions require determining whether and to what degree a let-expression's binding uses imperative features. <p> Weak types allow partial applications of imperative polymorphic procedures that are rejected by Tofte's system. Closure Typing: Leroy and Weis <ref> [9] </ref>, [11] observed that it is only necessary to prohibit generalization of type variables that appear in the types of cells reachable after the binding has been evaluated (i.e., cells that would not be reclaimed by garbage collection at this point). <p> M; (ff L M ! bool ) . P g. Although Leroy's original closure typing system [11] did not type all HM-typable expressions, his dissertation <ref> [9] </ref> corrects this oversight. Damas: Damas proposed one of the earliest systems for typing references [3]. His system assigns both a type and a set to each expression. The set is a finite set of the types of cells that may be allocated by evaluating the expression.
Reference: 10. <author> Leroy, X. </author> <title> ``Polymorphism by name for references and continuations,'' </title> <booktitle> In Conference Record of the 20th Annual ACM Symposium on Principles of Programming Languages (January 1993) 220--231. </booktitle>
Reference-contexts: If map2 must be polymorphic, potentially awkward global changes to the program are required. Leroy gives several other examples where it may be desirable to use imperative features in computing a polymorphic procedure <ref> [10] </ref>. 3.2.3. Expressions that compute polymorphic data structures Expressions that compute polymorphic data structures also require global program modifications to restore polymorphism, whether the computation is functional or imperative.
Reference: 11. <author> Leroy, X. and P. Weis. </author> <title> ``Polymorphic type inference and assignment,'' </title> <booktitle> In Proceedings of the 18th Annual Symposium on Principles of Programming Languages (January 1991) 291--302. </booktitle> <pages> 13 </pages>
Reference-contexts: Many call-by-value languages include imperative features like references, exceptions, and continuations that facilitate concise and efficient programs. Several solutions to integrating imperative features with Hindley-Milner polymorphism in call-by-value languages have been devised [1], [3], [4], [8], [9], <ref> [11] </ref>, [17], [18], [19]. These solutions range in complexity from Tofte's relatively simple method that Standard ML adopted to Talpin's sophisticated system that infers types, regions, and effects. All of these solutions assign types to all purely functional expressions that are typable by the Hindley-Milner system (henceforth called HM-typable expressions). <p> But such an imperative version of sort has the following imperative types in Tofte's system [18], MacQueen's system [1], and Leroy's system [9], <ref> [11] </ref>: 8 ff: ( ff ! ff ! bool ) ! ( ff list) ! ( ff list) (Tofte) 8ff 2 : (ff 2 ! ff 2 ! bool ) ! (ff 2 list) ! (ff 2 list ) (MacQueen) 8ffLM N P: (ff L M ! bool ) N ! <p> Exactly which type variables can be generalized is undecidable. A sound solution to typing reference cells must avoid generalizing type variables that appear in the types of shared reference cells. 2.1. Conservative solutions The solutions devised to date [1], [3], [4], [8], [9], <ref> [11] </ref>, [17], [18], [19] are conservative extensions of the Hindley-Milner type system. That is, they assign types to all HM-typable expressions. Conservative solutions require determining whether and to what degree a let-expression's binding uses imperative features. Hence these solutions record information about uses of imperative features in an expression's type. <p> Weak types allow partial applications of imperative polymorphic procedures that are rejected by Tofte's system. Closure Typing: Leroy and Weis [9], <ref> [11] </ref> observed that it is only necessary to prohibit generalization of type variables that appear in the types of cells reachable after the binding has been evaluated (i.e., cells that would not be reclaimed by garbage collection at this point). <p> Therefore an imperative implementation of sort has type 8ffLM N P: (ff L M ! bool ) N ! (ff list) P (ff list) with fff . M; (ff L M ! bool ) . P g. Although Leroy's original closure typing system <ref> [11] </ref> did not type all HM-typable expressions, his dissertation [9] corrects this oversight. Damas: Damas proposed one of the earliest systems for typing references [3]. His system assigns both a type and a set to each expression.
Reference: 12. <author> Milner, R. </author> <title> ``A theory of type polymorphism in programming,'' </title> <journal> Journal of Computer and System Sciences, </journal> <note> 17 (1978) 348--375. </note>
Reference-contexts: 1. Polymorphism, Imperative Features, and Modules The Hindley-Milner polymorphic type discipline [7], <ref> [12] </ref> is an elegant and flexible type system for functional programming languages. Many call-by-value languages include imperative features like references, exceptions, and continuations that facilitate concise and efficient programs.
Reference: 13. <author> Milner, R. and M. Tofte. </author> <title> Commentary on Standard ML, </title> <publisher> MIT Press, </publisher> <address> Cambridge, Massachusetts (1991). </address>
Reference: 14. <author> Milner, R., M. Tofte, and R. Harper. </author> <title> The Definition of Standard ML, </title> <publisher> MIT Press, </publisher> <address> Cambridge, Massachusetts (1990). </address>
Reference-contexts: All of these solutions assign types to all purely functional expressions that are typable by the Hindley-Milner system (henceforth called HM-typable expressions). However, they assign different types to imperative and functional polymorphic procedures that implement the same mathematical abstraction. For example, in Standard ML <ref> [14] </ref> we may define a polymorphic procedure that sorts lists of any kind, given an ordering function for elements: val sort = fn less =&gt; fn list =&gt; : : : sort : : : A functional implementation of this procedure has type: 8ff: (ff ! ff ! bool ) !
Reference: 15. <author> Ohori, A. </author> <title> ``A simple semantics for ML polymorphism,'' </title> <booktitle> In Proceedings of the Fourth International Conference on Functional Programming Languages and Computer Architecture (September 1989) 281-- 292. </booktitle>
Reference-contexts: In a call-by-value functional language without imperative features, we may explain the polymorphic let-expression: 3 as an abbreviation for the expansion: (e 1 ; e 2 [x=e 1 ]) (2) where e 2 [x=e 1 ] is the capture-avoiding substitution of e 1 for free x in e 2 <ref> [15] </ref>. Semantically, expressions (1) and (2) are equivalent. In the expansion, the first subexpression e 1 is evaluated and discarded to ensure that the expansion diverges when the let-expression does. Expressions (1) and (2) also have the same type. The expansion mimics polymorphism by replicating subexpression e 1 .
Reference: 16. <author> Reppy, J. H. </author> <title> Higher-order Concurrency, </title> <type> PhD thesis, </type> <institution> Cornell University (1991). </institution>
Reference-contexts: All were simple to fix. In no case did the modifications cause any detectable difference in performance. Reppy's Concurrent ML implementation <ref> [16] </ref> illustrates the benefit of assigning the same types to functional and imperative procedures. Concurrent ML makes extensive use of Standard ML of New Jersey's first-class continuations to implement threads.
Reference: 17. <author> Talpin, J.-P. and P. Jouvelot. </author> <title> ``The type and effect discipline,'' </title> <booktitle> In Proceedings of the Seventh Annual Symposium on Logic in Computer Science (June 1992) 162--173. </booktitle>
Reference-contexts: Many call-by-value languages include imperative features like references, exceptions, and continuations that facilitate concise and efficient programs. Several solutions to integrating imperative features with Hindley-Milner polymorphism in call-by-value languages have been devised [1], [3], [4], [8], [9], [11], <ref> [17] </ref>, [18], [19]. These solutions range in complexity from Tofte's relatively simple method that Standard ML adopted to Talpin's sophisticated system that infers types, regions, and effects. All of these solutions assign types to all purely functional expressions that are typable by the Hindley-Milner system (henceforth called HM-typable expressions). <p> Exactly which type variables can be generalized is undecidable. A sound solution to typing reference cells must avoid generalizing type variables that appear in the types of shared reference cells. 2.1. Conservative solutions The solutions devised to date [1], [3], [4], [8], [9], [11], <ref> [17] </ref>, [18], [19] are conservative extensions of the Hindley-Milner type system. That is, they assign types to all HM-typable expressions. Conservative solutions require determining whether and to what degree a let-expression's binding uses imperative features. Hence these solutions record information about uses of imperative features in an expression's type. <p> A more sophisticated system devised by Talpin and Jouvelot infers types, effects, and effect regions for expressions <ref> [17] </ref>. 3. A Simple Solution In conservative solutions, the need to identify uses of imperative features in an expression's type stems from a desire to admit all HM-typable expressions. To assign the same types to imperative and functional implementations of the same abstraction, we must sacrifice this ability. 3.1.
Reference: 18. <author> Tofte, M. </author> <title> ``Type inference for polymorphic references,'' </title> <journal> Information and Computation, </journal> <volume> 89, </volume> <month> 1 (November </month> <year> 1990) </year> <month> 1--34. </month>
Reference-contexts: Many call-by-value languages include imperative features like references, exceptions, and continuations that facilitate concise and efficient programs. Several solutions to integrating imperative features with Hindley-Milner polymorphism in call-by-value languages have been devised [1], [3], [4], [8], [9], [11], [17], <ref> [18] </ref>, [19]. These solutions range in complexity from Tofte's relatively simple method that Standard ML adopted to Talpin's sophisticated system that infers types, regions, and effects. All of these solutions assign types to all purely functional expressions that are typable by the Hindley-Milner system (henceforth called HM-typable expressions). <p> But such an imperative version of sort has the following imperative types in Tofte's system <ref> [18] </ref>, MacQueen's system [1], and Leroy's system [9], [11]: 8 ff: ( ff ! ff ! bool ) ! ( ff list) ! ( ff list) (Tofte) 8ff 2 : (ff 2 ! ff 2 ! bool ) ! (ff 2 list) ! (ff 2 list ) (MacQueen) 8ffLM N P: <p> Since this is impossible, the expression will be rejected. But not all uses of reference cells in a let-expression prevent generalization. If a let-expression is semantically equivalent to the expansion indicated above (2), then generalization can occur as usual. The following imperative function reverses a list in linear time <ref> [18] </ref>: let val fastrev = fn list =&gt; (4) let val left = ref list and right = ref [] in while !left &lt;&gt; [] do (right := hd (!left) :: !right; left := tl (!left)); !right end Reference cells left and right have type fi list ref but each use <p> Exactly which type variables can be generalized is undecidable. A sound solution to typing reference cells must avoid generalizing type variables that appear in the types of shared reference cells. 2.1. Conservative solutions The solutions devised to date [1], [3], [4], [8], [9], [11], [17], <ref> [18] </ref>, [19] are conservative extensions of the Hindley-Milner type system. That is, they assign types to all HM-typable expressions. Conservative solutions require determining whether and to what degree a let-expression's binding uses imperative features. Hence these solutions record information about uses of imperative features in an expression's type. <p> That is, they assign types to all HM-typable expressions. Conservative solutions require determining whether and to what degree a let-expression's binding uses imperative features. Hence these solutions record information about uses of imperative features in an expression's type. Standard ML: Standard ML adopts Tofte's solution <ref> [18] </ref>. This solution assigns type 8 ff: ff ! ( ffref ) to the ref operator where ff is an imperative type variable. Imperative type variables indicate values that may be placed in reference cells. <p> Hence removing applicative type variables from Tofte's system yields a system isomorphic to ours. 1 The existing proofs of type soundness for Tofte's system <ref> [18] </ref>, [20] establish type soundness for ours. 7 We can easily establish that our system possesses a type inference algorithm which finds principal types [2]. The algorithm is the ordinary Hindley-Milner type inference algorithm run after a simple translation.
Reference: 19. <author> Wright, A. K. </author> <title> ``Typing references by effect inference,'' </title> <booktitle> In Proceedings of the 4th European Symposium on Programming, Springer-Verlag Lecture Notes in Computer Science 582 (1992) 473--491. </booktitle>
Reference-contexts: Many call-by-value languages include imperative features like references, exceptions, and continuations that facilitate concise and efficient programs. Several solutions to integrating imperative features with Hindley-Milner polymorphism in call-by-value languages have been devised [1], [3], [4], [8], [9], [11], [17], [18], <ref> [19] </ref>. These solutions range in complexity from Tofte's relatively simple method that Standard ML adopted to Talpin's sophisticated system that infers types, regions, and effects. All of these solutions assign types to all purely functional expressions that are typable by the Hindley-Milner system (henceforth called HM-typable expressions). <p> Exactly which type variables can be generalized is undecidable. A sound solution to typing reference cells must avoid generalizing type variables that appear in the types of shared reference cells. 2.1. Conservative solutions The solutions devised to date [1], [3], [4], [8], [9], [11], [17], [18], <ref> [19] </ref> are conservative extensions of the Hindley-Milner type system. That is, they assign types to all HM-typable expressions. Conservative solutions require determining whether and to what degree a let-expression's binding uses imperative features. Hence these solutions record information about uses of imperative features in an expression's type. <p> Effects: Several systems for typing references based on effect inference have been proposed. A system proposed by the author extends Damas's system to attach effect sets () to all function type arrows <ref> [19] </ref>. This system assigns the type 8ff& 1 & 2 & 3 : (ff & 1 ff ! bool ) & 3 ! (ff list) ff& 1 & 2 & 3 ! (ff list) to an imperative version of sort.
Reference: 20. <author> Wright, A. K. and M. Felleisen. </author> <title> ``A Syntactic Approach to Type Soundness,'' </title> <type> Technical Report 91-160, </type> <institution> Rice University (April 1991). </institution> <note> To appear in Information and Computation, </note> <year> 1994. </year>
Reference-contexts: As -expressions are values, references can be freely used in procedure bodies without inhibiting polymorphism. The fastrev function (4) from Section 2 has the polymorphic type 8ff: (ff list) ! (ff list). A sound type system for continuations must not allow continuations to be polymorphic [6], <ref> [20] </ref>. That is, in an expression like: let val x = callcc (fn k =&gt; : : : ) in : : : x must not be assigned a polymorphic type. (Consider the explanation of let-expressions as abbreviations. <p> Hence removing applicative type variables from Tofte's system yields a system isomorphic to ours. 1 The existing proofs of type soundness for Tofte's system [18], <ref> [20] </ref> establish type soundness for ours. 7 We can easily establish that our system possesses a type inference algorithm which finds principal types [2]. The algorithm is the ordinary Hindley-Milner type inference algorithm run after a simple translation.
References-found: 22

