URL: http://www.csl.sri.com/reports/postscript/cav94.ps.gz
Refering-URL: http://www.csl.sri.com/fm-papers.html
Root-URL: 
Email: cyrluk@cs.stanford.edu  dran@cs.albany.edu  
Title: Ground Temporal Logic: A Logic for Hardware Verification  
Author: David Cyrluk Paliath Narendran 
Affiliation: Dept. of Computer Science Stanford University and Computer Science Laboratory SRI International  SUNY-ALBANY, Albany  
Address: Stanford, CA 1994).  NY  
Note: (Slightly expanded from the 6th International Conference on Computer Aided Verification (CAV '94), LNCS #818, pp 247-259,  
Abstract: We present a new temporal logic, GTL, appropriate for specifying properties of hardware at the register transfer level. We argue that this logic represents an improvement over model checking for some natural hardware verification problems. We show that the validity problem for this logic is 1 1 complete. We then identify a fragment of the logic that is decidable. We show that in this fragment we are still able to encode many interesting problems, including the correctness of pipelined microprocessors.
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Martn Abadi and Leslie Lamport. </author> <title> The existence of refinement mappings. </title> <booktitle> In Third Annual Symposium on Logic in Computer Science, </booktitle> <pages> pages 165-175. </pages> <publisher> IEEE, Computer Society Press, </publisher> <month> July </month> <year> 1988. </year>
Reference-contexts: The verification problem is illustrated in Figure 3 (a), where I represents the implementation next-state function and A represents the specification next-state function. The details and complications of this approach are beyond the scope of this paper, and the reader is referred to <ref> [20, 21, 10, 1] </ref> for them. Following the approach in [1, 21, 20, 16] 1 the proof of correctness makes use of an abstraction function that maps an implementation state into a corresponding specification state. <p> The details and complications of this approach are beyond the scope of this paper, and the reader is referred to [20, 21, 10, 1] for them. Following the approach in <ref> [1, 21, 20, 16] </ref> 1 the proof of correctness makes use of an abstraction function that maps an implementation state into a corresponding specification state.
Reference: [2] <author> Rajeev Alur. </author> <title> Techniques for Automatic Verification of Real-time Systems. </title> <institution> Dept. of computer science, Stanford University, </institution> <year> 1991. </year>
Reference-contexts: A computation is recurring iff it contains infinitely many configurations whose first component is q 0 . Lemma: <ref> [2] </ref> The problem of deciding whether a two-counter machine has a recurring compu tation is 1 1 -hard. 3.2 Encoding Natural Numbers in GTL The first step in encoding two counter machines is to enocode nautral numbers.
Reference: [3] <author> R. E. Bryant. </author> <title> Graph-based algorithms for boolean function manipulation. </title> <journal> IEEE Trans. Comput., </journal> <volume> C-35(8), </volume> <year> 1986. </year>
Reference-contexts: It also necessitates a bit-level description of alus and adders. To deal with this problem current research relies on tools such as BDD's to encode a large number of states into a small representation <ref> [3, 6, 5] </ref>. [8] makes use of abstractions to significantly reduce the state space that needs to be explored. However, the correctness argument for many of these circuits does not depend on a bit-level description of the circuit but only on a RTL description of the circuit.
Reference: [4] <author> R.E. Bryant, D. L. Beatty, and C.-J. Seger. </author> <title> Formal hardware verification by symbolic trajectory eval-uation. </title> <booktitle> In 28th ACM/IEEE Design Automation Conference, </booktitle> <year> 1991. </year>
Reference-contexts: Note that I is not capable of stating an initial state for the transition system. This is crucial for our decidability argument. Note also that the restrictions that S refer only to fixed length paths is similar to the restrictions explored in a propositional temporal logic in <ref> [4] </ref>. Before giving details we illustrate this with an example.
Reference: [5] <author> J. R. Burch, E. M. Clarke, K. L. McMillan, and D. L. Dill. </author> <title> Sequential circuit verification using symbolic model checking. </title> <booktitle> In 27th ACM/IEEE Design Automation Conference, </booktitle> <year> 1990. </year>
Reference-contexts: It also necessitates a bit-level description of alus and adders. To deal with this problem current research relies on tools such as BDD's to encode a large number of states into a small representation <ref> [3, 6, 5] </ref>. [8] makes use of abstractions to significantly reduce the state space that needs to be explored. However, the correctness argument for many of these circuits does not depend on a bit-level description of the circuit but only on a RTL description of the circuit. <p> Our fragment is also expressive enough to express the correctness of the pipelined ALU circuit that has become a benchmark in the model checking community <ref> [8, 6, 5] </ref>. A goal of the model checking community is to find techniques that allow them to effectively verify the pipelined ALU with increasingly larger datapaths and register file.
Reference: [6] <author> J. R. Burch, E.M. Clarke, and D.E. </author> <title> Long. Representing circuits more efficiently in symbolic model checking. </title> <booktitle> In 28th ACM/IEEE Design Automation Conference, </booktitle> <year> 1991. </year>
Reference-contexts: It also necessitates a bit-level description of alus and adders. To deal with this problem current research relies on tools such as BDD's to encode a large number of states into a small representation <ref> [3, 6, 5] </ref>. [8] makes use of abstractions to significantly reduce the state space that needs to be explored. However, the correctness argument for many of these circuits does not depend on a bit-level description of the circuit but only on a RTL description of the circuit. <p> Our fragment is also expressive enough to express the correctness of the pipelined ALU circuit that has become a benchmark in the model checking community <ref> [8, 6, 5] </ref>. A goal of the model checking community is to find techniques that allow them to effectively verify the pipelined ALU with increasingly larger datapaths and register file.
Reference: [7] <author> J. R. Burch and D. L. Dill. </author> <title> Automated verification of pipelined microprocessor control. </title> <booktitle> In CAV '94, </booktitle> <year> 1994. </year> <note> Submitted. </note>
Reference-contexts: Much, if not most, of this time is spent dealing with the overhead of a general-purpose higher-order theorem prover. There is current work in PVS to build better decision procedures for combining decidable theories. <ref> [7] </ref> reports on independent work that efficiently decides a fragment of GTL2. Efficient decision procedures for GTL2 should be able to build upon this work.
Reference: [8] <author> E. M. Clarke, O. Grumberg, and D. E. </author> <title> Long. Model checking and abstraction. </title> <booktitle> In Nineteenth Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 343-354, </pages> <year> 1992. </year>
Reference-contexts: It also necessitates a bit-level description of alus and adders. To deal with this problem current research relies on tools such as BDD's to encode a large number of states into a small representation [3, 6, 5]. <ref> [8] </ref> makes use of abstractions to significantly reduce the state space that needs to be explored. However, the correctness argument for many of these circuits does not depend on a bit-level description of the circuit but only on a RTL description of the circuit. <p> Our fragment is also expressive enough to express the correctness of the pipelined ALU circuit that has become a benchmark in the model checking community <ref> [8, 6, 5] </ref>. A goal of the model checking community is to find techniques that allow them to effectively verify the pipelined ALU with increasingly larger datapaths and register file. <p> In GTL the correctness of the pipelined ALU becomes: 2 [:stall read (ffi ffi ffi file; dstn) = alufun (op; read (ffi ffi file; src1); read (ffi ffi file; src2)) (10) In comparing this to the work done in <ref> [8] </ref> we note that we can abstract away the size of the data paths and the specific alu function without resorting to logarithms or any other clever means, and yet we do not lose decidability. This is still a toy example.
Reference: [9] <author> W Cullyer and C Pygott. </author> <title> Hardware proofs using LCF-LSM and ELLA. </title> <type> Memorandum 3832, </type> <institution> RSRE, </institution> <month> September </month> <year> 1985. </year>
Reference-contexts: Unfortunately this ground temporal logic is as undecidable as the full first-order logic. We identify a fragment of this logic that is straightforwardly decidable and yet still suitable for hardware verification. This fragment is expressive enough to express the correctness of the RSRE counter <ref> [9] </ref> verified using the interactive theorem prover, HOL. This example first motivated the definition of our language. On the one hand, we believed that the model-checking techniques associated with propositional temporal logic were more appropriate in verifying the correctness of the counter than theorem proving.
Reference: [10] <author> David Cyrluk. </author> <title> Microprocessor verification in PVS: A methodology and simple example. </title> <type> Technical Report SRI-CSL-93-12, </type> <institution> SRI Computer Science Laboratory, </institution> <month> December </month> <year> 1993. </year>
Reference-contexts: The cost we incur is that our fragment is much less temporally expressive than the decidable propositional temporal logics. Using theorem proving techniques we have in the past verified several microprocessors such as Saxe's pipeline <ref> [20, 10] </ref>. We are currently verifying a more realistic microprocessor|a Verilog model of a much simplified MIPS R3000 processor. The correctness of these circuits is also expressible in our decidable fragment. <p> We are, however, also able to state the correctness of microprocessors in this simple fragment. 8 6 Microprocessor Correctness In [20] microprocessor correctness is stated in a form similar to equation 1, where I and S are conditional equations with a universally quantified time variable. In <ref> [21, 10] </ref> the microprocessor correctness is stated in a form that does not mention time, but rather uses explicit next-state relationships. We now summarize the approach to microprocessor correctness in [21, 10] and show that it can be encoded in a decidable fragment of GTL. <p> In <ref> [21, 10] </ref> the microprocessor correctness is stated in a form that does not mention time, but rather uses explicit next-state relationships. We now summarize the approach to microprocessor correctness in [21, 10] and show that it can be encoded in a decidable fragment of GTL. Microprocessors can be described as state transition systems. <p> The verification problem is illustrated in Figure 3 (a), where I represents the implementation next-state function and A represents the specification next-state function. The details and complications of this approach are beyond the scope of this paper, and the reader is referred to <ref> [20, 21, 10, 1] </ref> for them. Following the approach in [1, 21, 20, 16] 1 the proof of correctness makes use of an abstraction function that maps an implementation state into a corresponding specification state. <p> This is captured in Figure 3 (a). The trace equivalence expressed in Figure 3 can be reduced to the commutativity of the diagram in Figure 3 (b). As discussed in <ref> [10, 21] </ref> the implementation machine may run at a different rate than the specification machine. <p> We assume that it is provided by the hardware designer or verifier. In <ref> [10, 20] </ref> this function is given by the following equation: num cycles = IF zero?(alu (IRD4, getOp (program (pc)))) THEN 5 ELSE 1 ENDIF 10 where IRD4 and pc are registers in the implementation machine, i.e. state variables in GTL.
Reference: [11] <author> T. Henzinger. </author> <title> Half-order modal logic: How to prove real-time properties. </title> <booktitle> In Proceedings of the Ninth Annual Symposium on Principles of Distributed Computing, </booktitle> <pages> pages 281-296. </pages> <publisher> ACM Press, </publisher> <year> 1990. </year>
Reference-contexts: One possible operator is atnext (p) t, which would denote the value of term t at the next time instance that formula p was true. While not identical, this line of research is similar in spirit to that in <ref> [11] </ref>. One difference is that in [11] all terms are considered rigid in order to obtain decidability. <p> One possible operator is atnext (p) t, which would denote the value of term t at the next time instance that formula p was true. While not identical, this line of research is similar in spirit to that in <ref> [11] </ref>. One difference is that in [11] all terms are considered rigid in order to obtain decidability. To summarize, in GTL and its fragments we have identified a practically useful temporal logic, that allows us to overcome some of the disadvantages inherent in both the model-checking and theorem proving approaches to hardware verification.
Reference: [12] <author> W.A. Hunt. </author> <title> The mechanical verification of a microprocessor design. </title> <booktitle> In Proc. of IFIP Working Conference on From H.D.L Descriptions to Guaranteed Correct Circuit Designs, </booktitle> <year> 1986. </year>
Reference-contexts: In [20] the specification is actually a non-pipelined microprocessor. In [21] the specification is a transition system corresponding to the instruction set architecture. In both [21, 20] the implementation is a pipelined microprocessor. Early work <ref> [12, 13] </ref> used the instruction set architecture as the specification and a non-pipelined machine as the implementation.
Reference: [13] <author> J. Joyce, G. Birtwistle, and M. Gordon. </author> <title> Proving a computer correct in higher order logic. </title> <type> Technical Report 100, </type> <institution> Computer Lab., University of Cambridge, </institution> <year> 1986. </year>
Reference-contexts: In [20] the specification is actually a non-pipelined microprocessor. In [21] the specification is a transition system corresponding to the instruction set architecture. In both [21, 20] the implementation is a pipelined microprocessor. Early work <ref> [12, 13] </ref> used the instruction set architecture as the specification and a non-pipelined machine as the implementation.
Reference: [14] <author> Fred Kroger. </author> <title> Temporal Logic of Programs, </title> <booktitle> volume 8 of EATCS Monographs on Theoretical Computer Science. </booktitle> <publisher> Springer Verlag, </publisher> <year> 1987. </year>
Reference-contexts: Section 6 shows how to enode aspects of microprocessor verification in our logic. The final section presents conclusions and future work. 2 Ground Temporal Logic In this section we give the syntax and semantics of the first-order temporal language we will be using. We follow the presentation of Kroger <ref> [14] </ref>. 2.1 Syntax Given a first order language, FOL, consisting of function symbols, constants (0-ary function symbols), predicate symbols, equality, but no variables, we define the language GTL as follows. <p> If A and B are formulas then so are :A; A ^ B; flA; and 2A. The language of GTL is the smallest language generated by these rules. Note that this language is the quantifier free, ground version of the language of First Order Temporal Logic as presented in <ref> [14] </ref> with the addition of our ffi operator. 2.2 Semantics Closely following the presentation in [14] we define the semantics of GTL. We define a model K = (S; W) for GTL as follows. S is a model for the first-order language F OL. <p> The language of GTL is the smallest language generated by these rules. Note that this language is the quantifier free, ground version of the language of First Order Temporal Logic as presented in <ref> [14] </ref> with the addition of our ffi operator. 2.2 Semantics Closely following the presentation in [14] we define the semantics of GTL. We define a model K = (S; W) for GTL as follows. S is a model for the first-order language F OL.
Reference: [15] <author> Leslie Lamport. </author> <title> The temporal logic of actions. </title> <type> Technical Report 79, </type> <institution> Digital Systems Research Center, </institution> <address> Palo Alto, California 94301, </address> <month> December </month> <year> 1991. </year>
Reference-contexts: We do this by providing an additional temporal operator, ffi that operates on terms. Other temporal logics have also provided notation equivalent to our ffi t <ref> [17, 15] </ref>. To our knowledge we are the first to analyze the complexity of ground temporal logics making use of this operator. We showed that the full GTL is undecidable. We then identified fragments of GTL that are both decidable and useful for real hardware verification, including microprocessor verification.
Reference: [16] <author> Paul Loewenstein and David Dill. </author> <title> Verification of multiprocessor cache protocol using simulation relations and higher-order logic. </title> <booktitle> In Computer-Aided Verification '90, </booktitle> <pages> pages 187-205. </pages> <publisher> DIMACS, American Mathematical Society, </publisher> <year> 1991. </year>
Reference-contexts: The details and complications of this approach are beyond the scope of this paper, and the reader is referred to [20, 21, 10, 1] for them. Following the approach in <ref> [1, 21, 20, 16] </ref> 1 the proof of correctness makes use of an abstraction function that maps an implementation state into a corresponding specification state.
Reference: [17] <author> Z. Manna and A. Pnueli. </author> <title> Verification of concurrent programs: A temporal proof system. </title> <editor> In J. W. de Bakker annd J. van Leeuwen, editor, </editor> <booktitle> Foundations of Computer Science IV, Distributed Systems: Part 2, Mathematical Centre Tracts 159, </booktitle> <pages> pages 163-255. </pages> <institution> Center for Mathematics and Computer Science, </institution> <address> Amsterdam, </address> <year> 1983. </year>
Reference-contexts: We do this by providing an additional temporal operator, ffi that operates on terms. Other temporal logics have also provided notation equivalent to our ffi t <ref> [17, 15] </ref>. To our knowledge we are the first to analyze the complexity of ground temporal logics making use of this operator. We showed that the full GTL is undecidable. We then identified fragments of GTL that are both decidable and useful for real hardware verification, including microprocessor verification.
Reference: [18] <author> G. Nelson and D. C. Oppen. </author> <title> Simplification by cooperating decision procedures. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 1(2) </volume> <pages> 245-257, </pages> <month> October </month> <year> 1979. </year>
Reference-contexts: It is still decidable as methods such as those found in <ref> [18] </ref> can be used to decide combinations of ground equalities with other decidable theories. We can also add to GTL2 further interpreted functions that have decidable quantifier free theories [18]. Just these simple extensions let us state the implementation and correctness for the pipelined ALU in Figure 5. <p> It is still decidable as methods such as those found in <ref> [18] </ref> can be used to decide combinations of ground equalities with other decidable theories. We can also add to GTL2 further interpreted functions that have decidable quantifier free theories [18]. Just these simple extensions let us state the implementation and correctness for the pipelined ALU in Figure 5.
Reference: [19] <author> Sam Owre, John M. Rushby, and Natarajan Shankar. PVS: </author> <title> A prototype verification system. </title> <editor> In Deepak Kapur, editor, </editor> <booktitle> Automated Deduction - CADE-11, 11th International Conference on Automated Deduction, Lecture Notes in Artifical Intelligence, </booktitle> <pages> pages 748-752. </pages> <publisher> Springer Verlag, </publisher> <month> June </month> <year> 1992. </year>
Reference-contexts: However, once the pipeline invariant is provided, the invariance of the pipeline invariant and the correctness of the microprocessor, assuming the pipeline invariant, can be stated in GTL2. 11 Theorem Proving We have carried out our experiments in processor verification in the context of a higher-order theorem prover <ref> [19] </ref>. In the theorem prover we state the correctness of the microprocessors in a more natural manner than indicated by equations 14 and 15. In the process of the verification we generate as intermediate goals statements that are instances of GTL2 formulas.
Reference: [20] <author> James B. Saxe, Stephen J. Garland, John V. Guttag, and James J. Horning. </author> <title> Using transformations and verification in circuit design. </title> <type> Technical Report 78, </type> <institution> Digital Systems Research Center, </institution> <address> Palo Alto, California 94301, </address> <month> September </month> <year> 1991. </year>
Reference-contexts: The cost we incur is that our fragment is much less temporally expressive than the decidable propositional temporal logics. Using theorem proving techniques we have in the past verified several microprocessors such as Saxe's pipeline <ref> [20, 10] </ref>. We are currently verifying a more realistic microprocessor|a Verilog model of a much simplified MIPS R3000 processor. The correctness of these circuits is also expressible in our decidable fragment. <p> This is still a toy example. We are, however, also able to state the correctness of microprocessors in this simple fragment. 8 6 Microprocessor Correctness In <ref> [20] </ref> microprocessor correctness is stated in a form similar to equation 1, where I and S are conditional equations with a universally quantified time variable. In [21, 10] the microprocessor correctness is stated in a form that does not mention time, but rather uses explicit next-state relationships. <p> The approach taken in verifying microprocessors is to use a simple transition system as the specification of the microprocessor, and a more complex transition system as the implementation. In <ref> [20] </ref> the specification is actually a non-pipelined microprocessor. In [21] the specification is a transition system corresponding to the instruction set architecture. In both [21, 20] the implementation is a pipelined microprocessor. <p> In [20] the specification is actually a non-pipelined microprocessor. In [21] the specification is a transition system corresponding to the instruction set architecture. In both <ref> [21, 20] </ref> the implementation is a pipelined microprocessor. Early work [12, 13] used the instruction set architecture as the specification and a non-pipelined machine as the implementation. <p> The verification problem is illustrated in Figure 3 (a), where I represents the implementation next-state function and A represents the specification next-state function. The details and complications of this approach are beyond the scope of this paper, and the reader is referred to <ref> [20, 21, 10, 1] </ref> for them. Following the approach in [1, 21, 20, 16] 1 the proof of correctness makes use of an abstraction function that maps an implementation state into a corresponding specification state. <p> The details and complications of this approach are beyond the scope of this paper, and the reader is referred to [20, 21, 10, 1] for them. Following the approach in <ref> [1, 21, 20, 16] </ref> 1 the proof of correctness makes use of an abstraction function that maps an implementation state into a corresponding specification state. <p> The trace equivalence expressed in Figure 3 can be reduced to the commutativity of the diagram in Figure 3 (b). As discussed in [10, 21] the implementation machine may run at a different rate than the specification machine. For example, in the microprocessor described in <ref> [20] </ref> the specification machine takes one state transition to execute each instruction, but the implementation machine might take five cycles to execute branch instructions, but only one cycle for non-branch instructions. In the following we assume that the specification machine always takes one cycle to execute an instruction. <p> We assume that it is provided by the hardware designer or verifier. In <ref> [10, 20] </ref> this function is given by the following equation: num cycles = IF zero?(alu (IRD4, getOp (program (pc)))) THEN 5 ELSE 1 ENDIF 10 where IRD4 and pc are registers in the implementation machine, i.e. state variables in GTL. <p> We denote the conditions under which num cycles = nc by cond nc . In the microprocessor verifications we have looked at, the state variables of the specification state are simply a subset of the state variables of the implementation state. For example, in <ref> [20] </ref> the specification machine is characterized by the contents of the program counter and register file. The implementation machine is also characterized by the contents of the program counter and register file as well as additional pipeline registers. <p> The implementation machine is also characterized by the contents of the program counter and register file as well as additional pipeline registers. The abstraction mapping maps each specification register from the corresponding implementation register, but not necessarily from the exactly corresponding state. For example, in <ref> [20] </ref> the abstraction mapping is given by the following equations: pc A = pc I (11) reg file A = ffi ffi ffi reg file I : (12) In other words the specification reg file is the implementation reg file, but three cycles into the future.
Reference: [21] <author> Mandayam Srivas and Mark Bickford. </author> <title> Formal verification of a pipelined microprocessor. </title> <journal> IEEE Software, </journal> <volume> 7(5) </volume> <pages> 52-64, </pages> <month> September </month> <year> 1990. </year> <month> 13 </month>
Reference-contexts: We are, however, also able to state the correctness of microprocessors in this simple fragment. 8 6 Microprocessor Correctness In [20] microprocessor correctness is stated in a form similar to equation 1, where I and S are conditional equations with a universally quantified time variable. In <ref> [21, 10] </ref> the microprocessor correctness is stated in a form that does not mention time, but rather uses explicit next-state relationships. We now summarize the approach to microprocessor correctness in [21, 10] and show that it can be encoded in a decidable fragment of GTL. <p> In <ref> [21, 10] </ref> the microprocessor correctness is stated in a form that does not mention time, but rather uses explicit next-state relationships. We now summarize the approach to microprocessor correctness in [21, 10] and show that it can be encoded in a decidable fragment of GTL. Microprocessors can be described as state transition systems. <p> The approach taken in verifying microprocessors is to use a simple transition system as the specification of the microprocessor, and a more complex transition system as the implementation. In [20] the specification is actually a non-pipelined microprocessor. In <ref> [21] </ref> the specification is a transition system corresponding to the instruction set architecture. In both [21, 20] the implementation is a pipelined microprocessor. Early work [12, 13] used the instruction set architecture as the specification and a non-pipelined machine as the implementation. <p> In [20] the specification is actually a non-pipelined microprocessor. In [21] the specification is a transition system corresponding to the instruction set architecture. In both <ref> [21, 20] </ref> the implementation is a pipelined microprocessor. Early work [12, 13] used the instruction set architecture as the specification and a non-pipelined machine as the implementation. <p> The verification problem is illustrated in Figure 3 (a), where I represents the implementation next-state function and A represents the specification next-state function. The details and complications of this approach are beyond the scope of this paper, and the reader is referred to <ref> [20, 21, 10, 1] </ref> for them. Following the approach in [1, 21, 20, 16] 1 the proof of correctness makes use of an abstraction function that maps an implementation state into a corresponding specification state. <p> The details and complications of this approach are beyond the scope of this paper, and the reader is referred to [20, 21, 10, 1] for them. Following the approach in <ref> [1, 21, 20, 16] </ref> 1 the proof of correctness makes use of an abstraction function that maps an implementation state into a corresponding specification state. <p> This is captured in Figure 3 (a). The trace equivalence expressed in Figure 3 can be reduced to the commutativity of the diagram in Figure 3 (b). As discussed in <ref> [10, 21] </ref> the implementation machine may run at a different rate than the specification machine. <p> It is an easy exercise to show that equations 14 and 15 are in GTL2. Pipeline Invariants The verification of some pipelined microprocessors requires the use of pipeline invariants. See <ref> [21] </ref> for example. Such microprocessors cannot be directly verified in GTL2 without being first provided the pipeline invariant.
References-found: 21

