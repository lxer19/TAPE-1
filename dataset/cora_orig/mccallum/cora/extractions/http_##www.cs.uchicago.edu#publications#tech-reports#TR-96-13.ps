URL: http://www.cs.uchicago.edu/publications/tech-reports/TR-96-13.ps
Refering-URL: http://cs-www.uchicago.edu/publications/tech-reports/
Root-URL: 
Email: (gopalan@cs.uchicago.edu)  
Phone: Tel: 312-702-3497 Fax: 312-702-8487  
Title: A Fine-Grained Notation for Lambda Terms and Its Use in Intensional Operations  
Author: Gopalan Nadathur 
Address: Ryerson Hall, 1100 E. 58th Street Chicago, IL 60637  
Affiliation: Department of Computer Science University of Chicago  
Abstract: We discuss issues relevant to the practical use of a previously proposed notation for lambda terms in contexts where the intensions of such terms have to be manipulated. This notation uses the `nameless' scheme of de Bruijn, includes expressions for encoding terms together with substitutions to be performed on them and contains a mechanism for combining such substitutions so that they can be effected in a common structure traversal. The combination mechanism is a general one and consequently difficult to implement. We propose a simplification to it that retains its functionality in situations that occur commonly in fi-reduction. We then describe a system for annotating terms to determine if they can be affected by substitutions generated by external fi-contractions. These annotations can lead to a conservation of space and time in implementations of reduction by permitting substitutions to be performed trivially in certain situations. The use of the resulting notation in the reduction and comparison of terms is examined. Notions of head normal forms and head reduction sequences are defined in its context and shown to be useful in equality computations. Our head reduction sequences generalize the usual ones for lambda terms so that they subsume the sequences of terms produced by a variety of graph- and environment-based reduction procedures for the lambda calculus. They can therefore be used in correctness arguments for such procedures. This fact and the efficacy of our notation are illustrated in the context of a particular reduction procedure that we present. The relevance of the present discussions to the unification of lambda terms is also outlined.
Abstract-found: 1
Intro-found: 1
Reference: [ACCL90] <author> Martn Abadi, Luca Cardelli, Pierre-Louis Curien, and Jean-Jacques Levy. </author> <title> Explicit substitutions. </title> <booktitle> In Seventeenth Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 31-46. </pages> <publisher> ACM Press, </publisher> <month> January </month> <year> 1990. </year>
Reference-contexts: An acceptable representation must enable this operation to be performed efficiently. In a previous paper [NW], we have described a notation for lambda terms called the suspension notation that provides a basis for meeting these various requirements. This notation is similar in spirit to those proposed in <ref> [ACCL90] </ref> and [Fie90], based on the Categorical Combinators of Curien [Cur86]. It also shares features with data structures that have been used in implementing fi-reduction, most notably those in [AP81]. <p> With respect to the latter, we note that our notation facilitates a complete proof of correctness of our reduction procedure and also permits an intermingling of normalization operations with operations such as comparisons of terms. Benefits such as these have also been noted for the -calculus <ref> [ACCL90] </ref> and flCCL [Fie90] and have been exploited recently in the description of a higher-order unification procedure [DHK95]. The rest of this paper is structured as follows. <p> This rule schema is in keeping with the behavior of reduction procedures that use environments [AP81, CCM87, HM76] and also parallels the auxiliary rule described in conjunction with the -calculus in <ref> [ACCL90] </ref>. The rule schema that we have actually chosen is better suited to the use made of our notation in Section 7, where reduction procedures will be expected to return suspension terms that are constants, variable references, abstractions or applications at the top-level.
Reference: [And71] <author> Peter B. Andrews. </author> <title> Resolution in type theory. </title> <journal> Journal of Symbolic Logic, </journal> <volume> 36 </volume> <pages> 414-432, </pages> <year> 1971. </year>
Reference-contexts: Although this property does not hold for arbitrary de Bruijn terms, it usually holds of subcollections of these terms that are used for representational purposes. It holds, for instance, of the class of (de Bruijn) terms restricted by a typing scheme based on simple types <ref> [And71, Chu40] </ref> that underlie the Prolog language. The notion of a head normal form provides a means for interleaving the reduction to fl fi -normal form with the checking for identity in determining the equality of terms.
Reference: [AP81] <author> L. Aiello and G. Prini. </author> <title> An efficient interpreter for the lambda-calculus. </title> <journal> The Journal of Computer and System Sciences, </journal> <volume> 23 </volume> <pages> 383-425, </pages> <year> 1981. </year>
Reference-contexts: This notation is similar in spirit to those proposed in [ACCL90] and [Fie90], based on the Categorical Combinators of Curien [Cur86]. It also shares features with data structures that have been used in implementing fi-reduction, most notably those in <ref> [AP81] </ref>. At a level of detail, the suspension notation uses a scheme suggested by de Bruijn [Bru72] for eliminating variable names from lambda terms. Further, it incorporates a generalized notion of an environment as a mechanism for delaying substitutions. <p> It is also closely related to the simplifier presented by Aiello and Prini <ref> [AP81] </ref>. With respect to the latter, we note that our notation facilitates a complete proof of correctness of our reduction procedure and also permits an intermingling of normalization operations with operations such as comparisons of terms. <p> This conclusion can, in fact, be reached without explicitly carrying out the potentially costly operation of substitution on the arguments. Along a different direction, laziness in substitution can be utilized to combine structure traversals needed in fi-reduction, leading to gains in efficiency <ref> [AP81] </ref>. The suspension notation for lambda terms [NW] refines the de Bruijn notation so as to support laziness in substitution. <p> This rule schema is in keeping with the behavior of reduction procedures that use environments <ref> [AP81, CCM87, HM76] </ref> and also parallels the auxiliary rule described in conjunction with the -calculus in [ACCL90]. <p> The discussions in this paper are, thus, extremely pertinent to implementing this procedure. In fact, certain aspects of our notation 1 A behavior of this sort is obtained in <ref> [AP81] </ref> by using a scheme for identifying bound variables that allows the same `renaming' of free variables to suffice in all contexts.
Reference: [Bar81] <author> H. P. Barendregt. </author> <title> The Lambda Calculus: Its Syntax and Semantics. </title> <publisher> North Holland Publishing Co., </publisher> <year> 1981. </year>
Reference-contexts: Such a sequence is obviously unique and terminates just in case there is an m 0 such that r m is a fl fi -hnf. The following proposition is proved for lambda terms in the conventional notation in, for instance, <ref> [Bar81] </ref> and this proof can be readily adapted to de Bruijn terms.
Reference: [BR91] <author> Pascal Brisset and Olivier Ridoux. </author> <title> Naive reverse can be linear. </title> <editor> In Koichi Fu-rukawa, editor, </editor> <booktitle> Eighth International Logic Programming Conference, </booktitle> <pages> pages 857-870, </pages> <address> Paris, France, June 1991. </address> <publisher> MIT Press. </publisher> <pages> 46 </pages>
Reference-contexts: Effecting substitutions in this manner can also have other benefits: it can lead to a conservation of space and can foster a greater sharing of work in a graph-based implementation of reduction that uses our notation. These benefits can be significant in practice, e.g., in the implementation of Prolog <ref> [BR91] </ref>. 2 This paper also considers the use of the notation developed in the comparison of lambda terms. This task is of special significance to us because it is a part of several operations on lambda terms that become important when they are employed as representational devices. <p> Furthermore, the propagation of the substitution eventually results in the replication of the entire structure of the term (( t 1 ) t 2 ). The unnecessary use of space and time in computing such substitutions has been noted to be significant in practice <ref> [BR91] </ref>, and the simplification rules presented in this section are of value from this perspective. 6 A refinement to the suspension notation We now modify the suspension notation to take into account the discussions of the last two sections.
Reference: [Bru72] <author> N. de Bruijn. </author> <title> Lambda calculus notation with nameless dummies, a tool for au-tomatic formula manipulation, with application to the Church-Rosser Theorem. </title> <journal> Indag. Math., </journal> <volume> 34(5) </volume> <pages> 381-392, </pages> <year> 1972. </year>
Reference-contexts: It also shares features with data structures that have been used in implementing fi-reduction, most notably those in [AP81]. At a level of detail, the suspension notation uses a scheme suggested by de Bruijn <ref> [Bru72] </ref> for eliminating variable names from lambda terms. Further, it incorporates a generalized notion of an environment as a mechanism for delaying substitutions. The ability to perform substitutions lazily, and the reflection of this ability into the notation, has several potential advantages. <p> We conclude the paper in Section 8 with remarks on the pertinence of the discussions here to a situation where the unification of lambda terms is considered. 2 Preliminaries We outline in this section the `nameless' notation for lambda terms proposed by de Bruijn <ref> [Bru72] </ref> and describe notions pertaining to it that are used in subsequent discussions. <p> If t i fl fl i for i 0, then S (t 0 ; t 1 ; t 2 ; t 3 ; : : :)fl fl fi S (t 0 1 ; t 0 3 ; : : :): The following proposition is proved (for de Bruijn terms) in <ref> [Bru72] </ref>. Proposition 2.6 The relation fl fi is confluent.
Reference: [Bru80] <author> N. de Bruijn. </author> <title> A survey of the project AUTOMATH. </title> <editor> In J. P. Seldin and J. R. Hindley, editors, To H. B. </editor> <booktitle> Curry: Essays on Combinatory Logic, Lambda Calculus and Formalism, </booktitle> <pages> pages 579-606. </pages> <publisher> Academic Press, </publisher> <year> 1980. </year>
Reference-contexts: reasons for interest in this matter: lambda terms provide a convenient means for representing objects whose structures incorporate the notion of binding [Chu40] and are used for this purpose in a number of computer systems and programming languages that support the manipulation of formulas, programs, proofs and other similar objects <ref> [Bru80, CAB + 86, CH88, GMW79, HHP93, NM88, Pau90, Pfe89] </ref>. In a sense specifically pertinent to this paper, objects are represented directly by lambda terms in systems like L [Mil91], Prolog [NM88], Isabelle 1 [Pau90] and Elf [Pfe89], to be manipulated by some form of higher-order unification [Hue75, Nip93].
Reference: [CAB + 86] <author> R. L. Constable, S. F. Allen, H. M. Bromley, W. R. Cleaveland, J. F. Cremer, R. W. Harper, D. J. Howe, T. B. Knoblock, N. P. Mendler, P. Panangaden, J. T. Sasaki, and S. F. Smith. </author> <title> Implementing Mathematics with the Nuprl Proof Development System. </title> <publisher> Prentice-Hall, </publisher> <year> 1986. </year>
Reference-contexts: reasons for interest in this matter: lambda terms provide a convenient means for representing objects whose structures incorporate the notion of binding [Chu40] and are used for this purpose in a number of computer systems and programming languages that support the manipulation of formulas, programs, proofs and other similar objects <ref> [Bru80, CAB + 86, CH88, GMW79, HHP93, NM88, Pau90, Pfe89] </ref>. In a sense specifically pertinent to this paper, objects are represented directly by lambda terms in systems like L [Mil91], Prolog [NM88], Isabelle 1 [Pau90] and Elf [Pfe89], to be manipulated by some form of higher-order unification [Hue75, Nip93].
Reference: [CCM87] <author> G. Cousineau, P-L. Curien, and M. Mauny. </author> <title> The categorical abstract machine. </title> <booktitle> The Science of Programming, </booktitle> <volume> 8(2) </volume> <pages> 173-202, </pages> <year> 1987. </year>
Reference-contexts: This rule schema is in keeping with the behavior of reduction procedures that use environments <ref> [AP81, CCM87, HM76] </ref> and also parallels the auxiliary rule described in conjunction with the -calculus in [ACCL90].
Reference: [CH88] <author> Thierry Coquand and Gerard Huet. </author> <title> The calculus of constructions. </title> <journal> Information and Computation, </journal> 76(2/3):95-120, February/March 1988. 
Reference-contexts: reasons for interest in this matter: lambda terms provide a convenient means for representing objects whose structures incorporate the notion of binding [Chu40] and are used for this purpose in a number of computer systems and programming languages that support the manipulation of formulas, programs, proofs and other similar objects <ref> [Bru80, CAB + 86, CH88, GMW79, HHP93, NM88, Pau90, Pfe89] </ref>. In a sense specifically pertinent to this paper, objects are represented directly by lambda terms in systems like L [Mil91], Prolog [NM88], Isabelle 1 [Pau90] and Elf [Pfe89], to be manipulated by some form of higher-order unification [Hue75, Nip93].
Reference: [Chu40] <author> Alonzo Church. </author> <title> A formulation of the simple theory of types. </title> <journal> Journal of Symbolic Logic, </journal> <volume> 5 </volume> <pages> 56-68, </pages> <year> 1940. </year>
Reference-contexts: There are significant reasons for interest in this matter: lambda terms provide a convenient means for representing objects whose structures incorporate the notion of binding <ref> [Chu40] </ref> and are used for this purpose in a number of computer systems and programming languages that support the manipulation of formulas, programs, proofs and other similar objects [Bru80, CAB + 86, CH88, GMW79, HHP93, NM88, Pau90, Pfe89]. <p> Although this property does not hold for arbitrary de Bruijn terms, it usually holds of subcollections of these terms that are used for representational purposes. It holds, for instance, of the class of (de Bruijn) terms restricted by a typing scheme based on simple types <ref> [And71, Chu40] </ref> that underlie the Prolog language. The notion of a head normal form provides a means for interleaving the reduction to fl fi -normal form with the checking for identity in determining the equality of terms.
Reference: [Cur86] <author> P-L. Curien. </author> <title> Categorical Combinators, Sequential Algorithms and Functional Programming. </title> <publisher> Pitman, </publisher> <year> 1986. </year>
Reference-contexts: In a previous paper [NW], we have described a notation for lambda terms called the suspension notation that provides a basis for meeting these various requirements. This notation is similar in spirit to those proposed in [ACCL90] and [Fie90], based on the Categorical Combinators of Curien <ref> [Cur86] </ref>. It also shares features with data structures that have been used in implementing fi-reduction, most notably those in [AP81]. At a level of detail, the suspension notation uses a scheme suggested by de Bruijn [Bru72] for eliminating variable names from lambda terms.
Reference: [DHK95] <author> Gilles Dowek, Therese Hardin, and Claude Kirchner. </author> <title> Higher-order unification via explicit substitutions. </title> <booktitle> In Tenth Annual IEEE Symposium on Logic in Computer Science, </booktitle> <pages> pages 366-374, </pages> <address> San Diego, California, June 1995. </address> <publisher> IEEE Computer Society Press. </publisher>
Reference-contexts: Benefits such as these have also been noted for the -calculus [ACCL90] and flCCL [Fie90] and have been exploited recently in the description of a higher-order unification procedure <ref> [DHK95] </ref>. The rest of this paper is structured as follows. The next two sections summarize notions pertaining to rewrite systems, the de Bruijn notation and the suspension notation that are relevant to this paper. In Section 4, we describe our simplification of the suspension notation.
Reference: [Fie90] <author> John Field. </author> <title> On laziness and optimality in lambda interpreters: Tools for specification and analysis. </title> <booktitle> In Seventeenth Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 1-15. </pages> <publisher> ACM Press, </publisher> <month> January </month> <year> 1990. </year>
Reference-contexts: An acceptable representation must enable this operation to be performed efficiently. In a previous paper [NW], we have described a notation for lambda terms called the suspension notation that provides a basis for meeting these various requirements. This notation is similar in spirit to those proposed in [ACCL90] and <ref> [Fie90] </ref>, based on the Categorical Combinators of Curien [Cur86]. It also shares features with data structures that have been used in implementing fi-reduction, most notably those in [AP81]. <p> We illustrate this by using it to establish the correctness of a particular reduction procedure that we present. This procedure is similar to interpreters for the lambda calculus proposed by Henderson and Morris [HM76] and Field <ref> [Fie90] </ref>; it differs from these mainly in that it finds head normal forms instead of only weak head normal forms. It is also closely related to the simplifier presented by Aiello and Prini [AP81]. <p> With respect to the latter, we note that our notation facilitates a complete proof of correctness of our reduction procedure and also permits an intermingling of normalization operations with operations such as comparisons of terms. Benefits such as these have also been noted for the -calculus [ACCL90] and flCCL <ref> [Fie90] </ref> and have been exploited recently in the description of a higher-order unification procedure [DHK95]. The rest of this paper is structured as follows. The next two sections summarize notions pertaining to rewrite systems, the de Bruijn notation and the suspension notation that are relevant to this paper.
Reference: [FT90] <author> John Field and Tim Teitelbaum. </author> <title> Incremental reduction in the lambda calculus. </title> <booktitle> In Proceedings of the 1990 ACM Conference on Lisp and Functional Programming, </booktitle> <pages> pages 307-322. </pages> <publisher> ACM Press, </publisher> <year> 1990. </year>
Reference-contexts: This is also a (weak) fl arfi s -hnf of s and thus the claim must, once again, be true. 2 It is instructive to compare the procedure in <ref> [FT90] </ref> to head norm when it attempts only to find weak head normal forms. <p> Ignoring the use of annotations, the main difference between these two procedures is in what they do when a term of the form [[t; ol; nl; e]] v in which t is not a suspension is encountered. The procedure in <ref> [FT90] </ref> tries to reduce t first, thereby permitting a sharing of this reduction, but leading to a proliferation of structure traversals and possibly preventing other kinds of sharing as noted in Section 4. <p> may be obtained by modifying our procedures to include suitable invocations of head norm from lazy read. 1 We remark that our definition of (weak) head fl arfi s -reduction sequences is general enough to encompass the ones produced by such a strategy as well as the one used in <ref> [FT90] </ref> and therefore provides a means for verifying the corresponding reduction procedures as well. 8 Conclusion In this paper we have presented a refinement to the notation for lambda terms described in [NW].
Reference: [GMW79] <author> Michael J. Gordon, Arthur J. Milner, and Christopher P. Wadsworth. </author> <title> Edin-burgh LCF: A Mechanised Logic of Computation, </title> <booktitle> volume 78 of Lecture Notes in Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1979. </year>
Reference-contexts: reasons for interest in this matter: lambda terms provide a convenient means for representing objects whose structures incorporate the notion of binding [Chu40] and are used for this purpose in a number of computer systems and programming languages that support the manipulation of formulas, programs, proofs and other similar objects <ref> [Bru80, CAB + 86, CH88, GMW79, HHP93, NM88, Pau90, Pfe89] </ref>. In a sense specifically pertinent to this paper, objects are represented directly by lambda terms in systems like L [Mil91], Prolog [NM88], Isabelle 1 [Pau90] and Elf [Pfe89], to be manipulated by some form of higher-order unification [Hue75, Nip93].
Reference: [Har86] <author> Robert Harper. </author> <title> Introduction to Standard ML. </title> <type> Technical Report ECS-LFCS-86-14, </type> <institution> Laboratory for Foundations of Computer Science, University of Edinburgh, </institution> <month> November </month> <year> 1986. </year> <note> Revised by Nick Rothwell, </note> <month> January </month> <year> 1989, </year> <title> with exercises by Kevin Mitchell. </title> <type> 47 </type>
Reference-contexts: To lend concreteness to the syntax of programs, we will use the language SML in this presentation. We assume a basic familiarity with this language, such as that which can be obtained from perusing <ref> [Har86] </ref>. We adopt the convention below of presenting programs in a typewriter font and of using italicized versions of the names of functions and types in discussions of their properties. The procedure that we describe employs a graph-based representation for terms.
Reference: [HHP93] <author> Robert Harper, Furio Honsell, and Gordon Plotkin. </author> <title> A framework for defining logics. </title> <journal> Journal of the ACM, </journal> <volume> 40(1) </volume> <pages> 143-184, </pages> <year> 1993. </year>
Reference-contexts: reasons for interest in this matter: lambda terms provide a convenient means for representing objects whose structures incorporate the notion of binding [Chu40] and are used for this purpose in a number of computer systems and programming languages that support the manipulation of formulas, programs, proofs and other similar objects <ref> [Bru80, CAB + 86, CH88, GMW79, HHP93, NM88, Pau90, Pfe89] </ref>. In a sense specifically pertinent to this paper, objects are represented directly by lambda terms in systems like L [Mil91], Prolog [NM88], Isabelle 1 [Pau90] and Elf [Pfe89], to be manipulated by some form of higher-order unification [Hue75, Nip93].
Reference: [HM76] <author> Peter Henderson and James H. Morris. </author> <title> A lazy evaluator. </title> <booktitle> In Third Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 95-103, </pages> <year> 1976. </year>
Reference-contexts: We illustrate this by using it to establish the correctness of a particular reduction procedure that we present. This procedure is similar to interpreters for the lambda calculus proposed by Henderson and Morris <ref> [HM76] </ref> and Field [Fie90]; it differs from these mainly in that it finds head normal forms instead of only weak head normal forms. It is also closely related to the simplifier presented by Aiello and Prini [AP81]. <p> This rule schema is in keeping with the behavior of reduction procedures that use environments <ref> [AP81, CCM87, HM76] </ref> and also parallels the auxiliary rule described in conjunction with the -calculus in [ACCL90].
Reference: [HS86] <author> J. Roger Hindley and Jonathan P. Seldin. </author> <title> Introduction to Combinatory Logic and Lambda Calculus. </title> <publisher> Cambridge University Press, </publisher> <year> 1986. </year>
Reference-contexts: If t is of the form (t 1 t 2 ), then each subterm of t 1 and of t 2 is also a subterm of t. Lambda terms in the notation described, for instance, in <ref> [HS86] </ref> can be translated into de Bruijn terms by the following process. Let the level of a subterm in a term be the number of abstractions in the term within which the subterm is embedded.
Reference: [Hue75] <author> Gerard Huet. </author> <title> A unification algorithm for typed -calculus. </title> <journal> Theoretical Computer Science, </journal> <volume> 1 </volume> <pages> 27-57, </pages> <year> 1975. </year>
Reference-contexts: In a sense specifically pertinent to this paper, objects are represented directly by lambda terms in systems like L [Mil91], Prolog [NM88], Isabelle 1 [Pau90] and Elf [Pfe89], to be manipulated by some form of higher-order unification <ref> [Hue75, Nip93] </ref>. The considerations here are motivated by implementation questions that arise in the context of such systems, particularly in the context of Prolog. <p> The comparison of lambda terms considered in this paper is intrinsic to most other operations on the intensions of such terms and the discussions here are therefore relevant in their contexts as well. An operation that is of particular interest to us is that of unifying (typed) lambda terms <ref> [Hue75] </ref>: this operation is central to Prolog, whose efficient implementation is a major reason for the investigations undertaken here.
Reference: [Mil91] <author> Dale Miller. </author> <title> A logic programming language with lambda-abstraction, function variables, and simple unification. </title> <journal> Journal of Logic and Computation, </journal> <volume> 1(4) </volume> <pages> 497-536, </pages> <year> 1991. </year>
Reference-contexts: In a sense specifically pertinent to this paper, objects are represented directly by lambda terms in systems like L <ref> [Mil91] </ref>, Prolog [NM88], Isabelle 1 [Pau90] and Elf [Pfe89], to be manipulated by some form of higher-order unification [Hue75, Nip93]. The considerations here are motivated by implementation questions that arise in the context of such systems, particularly in the context of Prolog.
Reference: [Nip93] <author> Tobias Nipkow. </author> <title> Functional unification of higher-order patterns. </title> <booktitle> In Eighth Annual IEEE Symposium on Logic in Computer Science, </booktitle> <pages> pages 64-74, </pages> <address> Montreal, Canada, June 1993. </address> <publisher> IEEE Computer Society Press. </publisher>
Reference-contexts: In a sense specifically pertinent to this paper, objects are represented directly by lambda terms in systems like L [Mil91], Prolog [NM88], Isabelle 1 [Pau90] and Elf [Pfe89], to be manipulated by some form of higher-order unification <ref> [Hue75, Nip93] </ref>. The considerations here are motivated by implementation questions that arise in the context of such systems, particularly in the context of Prolog.
Reference: [NJW93] <author> Gopalan Nadathur, Bharat Jayaraman, and Debra Sue Wilson. </author> <title> Implementation considerations for higher-order features in logic programming. </title> <type> Technical Report CS-1993-16, </type> <institution> Department of Computer Science, Duke University, </institution> <month> June </month> <year> 1993. </year>
Reference-contexts: This procedure has been presented recursively here, but it can be easily rendered in a stack-based form. It is, in fact, being used in this form in an implementation of Prolog <ref> [NJW93] </ref>. The comparison of lambda terms considered in this paper is intrinsic to most other operations on the intensions of such terms and the discussions here are therefore relevant in their contexts as well. <p> In essence, the comparison of terms requires the rule to be used in conjunction with head normal forms, and de Bruijn's scheme and suspensions permit a convenient implementation of this requirement. Some discussion of this aspect may be found in <ref> [NJW93] </ref>. Acknowledgements An early presentation of some of the ideas in this paper appears in [NW90]. We acknowledge the input obtained from Debra Wilson at that stage of this work. Useful comments were provided by Dale Miller and a reviewer of an earlier version of this paper.
Reference: [NM88] <author> Gopalan Nadathur and Dale Miller. </author> <title> An overview of Prolog. </title> <editor> In Kenneth A. Bowen and Robert A. Kowalski, editors, </editor> <booktitle> Fifth International Logic Programming Conference, </booktitle> <pages> pages 810-827, </pages> <address> Seattle, Washington, August 1988. </address> <publisher> MIT Press. </publisher>
Reference-contexts: reasons for interest in this matter: lambda terms provide a convenient means for representing objects whose structures incorporate the notion of binding [Chu40] and are used for this purpose in a number of computer systems and programming languages that support the manipulation of formulas, programs, proofs and other similar objects <ref> [Bru80, CAB + 86, CH88, GMW79, HHP93, NM88, Pau90, Pfe89] </ref>. In a sense specifically pertinent to this paper, objects are represented directly by lambda terms in systems like L [Mil91], Prolog [NM88], Isabelle 1 [Pau90] and Elf [Pfe89], to be manipulated by some form of higher-order unification [Hue75, Nip93]. <p> In a sense specifically pertinent to this paper, objects are represented directly by lambda terms in systems like L [Mil91], Prolog <ref> [NM88] </ref>, Isabelle 1 [Pau90] and Elf [Pfe89], to be manipulated by some form of higher-order unification [Hue75, Nip93]. The considerations here are motivated by implementation questions that arise in the context of such systems, particularly in the context of Prolog.
Reference: [NW] <author> Gopalan Nadathur and Debra Sue Wilson. </author> <title> A notation for lambda terms: A generalization of environments. </title> <note> Submitted. Early version appears as Technical Report CS-1994-03, </note> <institution> Department of Computer Science, Duke University, </institution> <month> January </month> <year> 1994. </year>
Reference-contexts: Finally, an operation of special significance is fi-reduction | this operation provides an encoding of substitution and is useful in realizing several higher-level operations. An acceptable representation must enable this operation to be performed efficiently. In a previous paper <ref> [NW] </ref>, we have described a notation for lambda terms called the suspension notation that provides a basis for meeting these various requirements. This notation is similar in spirit to those proposed in [ACCL90] and [Fie90], based on the Categorical Combinators of Curien [Cur86]. <p> The relation (on de Bruijn terms) defined by this rule schema is denoted by fl fi and is called fi-contraction. The corresponding reduction relation is also referred to as fi-reduction. The following proposition, which follows from discussions in <ref> [NW] </ref>, states a commuta-tivity property between substitution and fi-reduction. <p> This conclusion can, in fact, be reached without explicitly carrying out the potentially costly operation of substitution on the arguments. Along a different direction, laziness in substitution can be utilized to combine structure traversals needed in fi-reduction, leading to gains in efficiency [AP81]. The suspension notation for lambda terms <ref> [NW] </ref> refines the de Bruijn notation so as to support laziness in substitution. <p> The following proposition, proved in <ref> [NW] </ref>, establishes the legitimacy of the above definitions. Proposition 3.8 Let x be a well formed suspension expression and let y be such that xfl r y, xfl m y, xfl fi s y, xfl rm y, xfl rfi s y or x fl rmfi s y. <p> Proofs of these properties, where omitted, may be found in <ref> [NW] </ref>. Proposition 3.9 The relation fl rm is noetherian and confluent. <p> Proposition 3.17 and the confluence of fl fi 0 can be used to show that fl rmfi s is confluent. We refer the reader to <ref> [NW] </ref> for details. 4 Eliminating the merging rules The suspension notation for lambda terms is a general one that permits fi-reduction to be realized through a variety of rewriting sequences. However, the full generality of this notation may not be useful in practice and implementation considerations favor a simpler notation. <p> general enough to encompass the ones produced by such a strategy as well as the one used in [FT90] and therefore provides a means for verifying the corresponding reduction procedures as well. 8 Conclusion In this paper we have presented a refinement to the notation for lambda terms described in <ref> [NW] </ref>. We have also examined properties of the resulting notation that are relevant to its use in the comparison of lambda terms. In particular, we have shown the correspondence between this notation and the conventional notation for lambda terms.
Reference: [NW90] <author> Gopalan Nadathur and Debra Sue Wilson. </author> <title> A representation of lambda terms suitable for operations on their intensions. </title> <booktitle> In Proceedings of the 1990 ACM Conference on Lisp and Functional Programming, </booktitle> <pages> pages 341-348. </pages> <publisher> ACM Press, </publisher> <year> 1990. </year>
Reference-contexts: Some discussion of this aspect may be found in [NJW93]. Acknowledgements An early presentation of some of the ideas in this paper appears in <ref> [NW90] </ref>. We acknowledge the input obtained from Debra Wilson at that stage of this work. Useful comments were provided by Dale Miller and a reviewer of an earlier version of this paper. This work has been supported by NSF grants CCR-89-05825 and CCR-92-08465.
Reference: [Pau90] <author> Lawrence C. Paulson. </author> <title> Isabelle: The next 700 theorem provers. </title> <editor> In Piergiorgio Odifreddi, editor, </editor> <booktitle> Logic and Computer Science, </booktitle> <pages> pages 361-386. </pages> <publisher> Academic Press, </publisher> <year> 1990. </year>
Reference-contexts: reasons for interest in this matter: lambda terms provide a convenient means for representing objects whose structures incorporate the notion of binding [Chu40] and are used for this purpose in a number of computer systems and programming languages that support the manipulation of formulas, programs, proofs and other similar objects <ref> [Bru80, CAB + 86, CH88, GMW79, HHP93, NM88, Pau90, Pfe89] </ref>. In a sense specifically pertinent to this paper, objects are represented directly by lambda terms in systems like L [Mil91], Prolog [NM88], Isabelle 1 [Pau90] and Elf [Pfe89], to be manipulated by some form of higher-order unification [Hue75, Nip93]. <p> In a sense specifically pertinent to this paper, objects are represented directly by lambda terms in systems like L [Mil91], Prolog [NM88], Isabelle 1 <ref> [Pau90] </ref> and Elf [Pfe89], to be manipulated by some form of higher-order unification [Hue75, Nip93]. The considerations here are motivated by implementation questions that arise in the context of such systems, particularly in the context of Prolog.
Reference: [Pfe89] <author> Frank Pfenning. </author> <title> Elf: A language for logic definition and verified metaprogram-ming. </title> <booktitle> In Fourth Annual Symposium on Logic in Computer Science, </booktitle> <pages> pages 313-322, </pages> <address> Pacific Grove, California, June 1989. </address> <publisher> IEEE Computer Society Press. </publisher> <pages> 48 </pages>
Reference-contexts: reasons for interest in this matter: lambda terms provide a convenient means for representing objects whose structures incorporate the notion of binding [Chu40] and are used for this purpose in a number of computer systems and programming languages that support the manipulation of formulas, programs, proofs and other similar objects <ref> [Bru80, CAB + 86, CH88, GMW79, HHP93, NM88, Pau90, Pfe89] </ref>. In a sense specifically pertinent to this paper, objects are represented directly by lambda terms in systems like L [Mil91], Prolog [NM88], Isabelle 1 [Pau90] and Elf [Pfe89], to be manipulated by some form of higher-order unification [Hue75, Nip93]. <p> In a sense specifically pertinent to this paper, objects are represented directly by lambda terms in systems like L [Mil91], Prolog [NM88], Isabelle 1 [Pau90] and Elf <ref> [Pfe89] </ref>, to be manipulated by some form of higher-order unification [Hue75, Nip93]. The considerations here are motivated by implementation questions that arise in the context of such systems, particularly in the context of Prolog.
References-found: 29

