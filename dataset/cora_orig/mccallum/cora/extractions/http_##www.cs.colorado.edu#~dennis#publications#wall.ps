URL: http://www.cs.colorado.edu/~dennis/publications/wall.ps
Refering-URL: http://www.cs.colorado.edu/~dennis/publications/
Root-URL: http://www.cs.colorado.edu
Title: The ProcessWall: A Process State Server Approach to Process Programming  
Author: Dennis Heimbigner 
Address: Boulder, CO 80309-0430  
Affiliation: Department of Computer Science University of Colorado,  
Abstract: The ProcessWall is a process state server providing storage for process states plus operations for defining and manipulating the structure of those states. It separates the state of a software process from any program for constructing that state. Instead, client programs implement the processes for operating on the process state. This approach has a number of potential benefits such as support for process formalism interoperability, support for multiple process languages, low-cost retro-fitting of process into existing environments, and support for long-term execution of processes. The process server interface provides descriptive mechanisms for representing process state as well as product state. A classification of client programs is provided to show how the state server can be used in a variety of ways. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Michael Carey et al. </author> <title> The EXODUS Extensible DBMS Project: an Overview. </title> <editor> In Stan Zdonik and David Maier, editors, </editor> <booktitle> Readings in Object-Oriented Databases. </booktitle> <publisher> Morgan Kaufmann, </publisher> <address> San Mateo, CA, </address> <year> 1990. </year>
Reference-contexts: More specifically, A version of the ProcessWall is currently under construction using modules from the existing Triton system [6]. Triton may be briefly characterized as a serverized object repository providing persistent storage for typed objects, plus functions for manipulating those objects. Triton uses an existing object manager, Exodus <ref> [1] </ref>, to provide much of its functionality. Triton has modules for persistent storage (Exodus), for server interface management, for a catalog, and for a form of event management: all of which can be used in the Process-Wall.
Reference: [2] <author> Don Cohen. </author> <title> AP5 Manual. </title> <institution> Univ. of Southern California, Information Sciences Institute, </institution> <month> March </month> <year> 1988. </year>
Reference-contexts: Consistency between those two representations was maintained by embedding maintenance operations in the APPL/A tasks and by using triggers to propagate information between relations and between relations and the APPL/A tasks. A number of other languages such as AP5 <ref> [2] </ref> and Marvel [9], produced similar solutions to the ISPW6 problem. The state server idea elaborates on this use of an explicit process state.
Reference: [3] <author> Stuart I. Feldman. </author> <title> Make a program for maintaining computer programs. </title> <journal> Software Practice and Experience, </journal> <volume> 9:255 - 265, </volume> <year> 1979. </year>
Reference-contexts: One edge type in this graph has the semantics of "has-subtask", or inversely "is-subtask-of." The other class of edge in the ProcessWall formalism has the semantics of "precedes." used as a short example in this discussion. It is in fact a simple Makefile <ref> [3] </ref>, and corresponds to a particular process for constructing an object "x" from objects "y.o" and "z.o." For simplicity, the task types are not indicated. Figure 1 (a) shows the corresponding Make-file. This example is admittedly simplistic, but should suffice for purposes of demonstration.
Reference: [4] <author> NIST ISEE Working Group and ECMA TC33 Task Group. </author> <title> Reference Model for Frameworks of Software Engineering Environments. </title> <type> Technical Report Technical Report ECMA TR/55, </type> <note> 2nd Edition, ECMA & NIST, </note> <month> December </month> <year> 1991. </year>
Reference-contexts: Its development instance concept could be viewed as an approximation of process state. * Penedo addresses the issue of separating mod-elling from implementation. As with the PVM, implementation includes a state component and so there is a place to insert the process state server technology. The ECMA/NIST Reference Model <ref> [4] </ref> explicitly includes a notion of Process State Services.
Reference: [5] <author> Dennis Heimbigner. </author> <title> Proscription Versus Prescription in Process-Centered Environments. </title> <booktitle> In Proceedings of the 6th International Software Process Workshop, </booktitle> <address> Hokkaido, Japan, </address> <month> October </month> <year> 1990. </year>
Reference-contexts: There is agreement that the environment must have some form of process "component", but the exact nature and role of that component has not been decided. Additionally, there is some dispute <ref> [5] </ref> about the correct style of programming to be used in executable process programs; roughly, the debate may be characterized as rule-based versus procedural. <p> This is not to say that the state server has no biases; it will be clear (see section 4) that the choice of state model and product model introduces bias. But it still seems less restrictive than a complete process language. The style problem (rule-based versus procedural) <ref> [5] </ref> represents another issue that is addressed by this approach. The procedural style is good for describing the normal execution path for processes. Unfortunately, it is not psychologically plausible since it does not allow for programmer flexibility or unanticipated actions. <p> It was clear from those solutions that process state was important separate from any formalism for constructing it. The style problem <ref> [5] </ref> was also a factor. the problem there was to somehow reconcile the need for both prescriptive and proscriptive process languages. The key insight was to recognize that both styles could share a common state, even if they were constructed in different ways (by rules or procedurally).
Reference: [6] <author> Dennis Heimbigner. </author> <title> Experiences with an Object-Manager for A Process-Centered Environment. </title> <booktitle> In Proceedings of the Eighteenth International Conf. on Very Large Data Bases, </booktitle> <address> Vancouver, B.C., </address> <month> 24-27 August </month> <year> 1992. </year>
Reference-contexts: But it is certainly the case that the ProcessWall uses an object manager for support. More specifically, A version of the ProcessWall is currently under construction using modules from the existing Triton system <ref> [6] </ref>. Triton may be briefly characterized as a serverized object repository providing persistent storage for typed objects, plus functions for manipulating those objects. Triton uses an existing object manager, Exodus [1], to provide much of its functionality.
Reference: [7] <author> Hewlett-Packard. </author> <title> HP Encapsulator: Integrating Applications into the HP SoftBench Platform, 1989. HP Part No. </title> <publisher> B1626-90000. </publisher>
Reference-contexts: Once a state server has been introduced into an environment, it is possible to begin the automation process by "wrapping" tools so that they begin to automatically record their activities in the state server. There is a strong analog to such systems as the HP encapsu-lator <ref> [7] </ref>, which incrementally add control integration to environments by wrapping tools to signal and receive events. Here, instead of wrapping for events, one is wrapping for process. Returning to the process language issue, the state server has the advantage that no special language is required to write process control. <p> This provides a capability for clients to attach client-defined annotations (such as "task-stopped") to, for example, task nodes in a state graph. In fact this is the underlying mechanism used to implement operations such as Satisfied. 5 Event Management Event dispatching systems such as Field [14] and HP-SoftBench <ref> [7] </ref> have proven to be remarkably useful for integrating the control of tools in an environment. One tool can signal an event such as editing a source code file.
Reference: [8] <author> Karen E. Huff. </author> <title> Plan-based intelligent assistance: An approach to supporting the software development process. </title> <type> Technical Report COINS Technical Report 89-97, </type> <institution> University of Massachusetts, Amherst, </institution> <month> September </month> <year> 1989. </year>
Reference-contexts: Sometimes, the supertask may already exist in the process state, and this kind of client can act to merge previously independent process fragments. 3. Planning constructors are actually a generalization of procedural constructor. A good example of a process formalism using planning can be found in <ref> [8] </ref>. A planning system would look at the task to be expanded, and at a range of tasks actions and try to create a specific set of subtasks to satisfy the parent task.
Reference: [9] <author> Gail E. Kaiser. </author> <title> Rule-Based Modeling of the Software Development Process. </title> <booktitle> In Proc. 4th International Software Process Workshop, </booktitle> <month> October </month> <year> 1988. </year> <booktitle> Published in ACM SIGSOFT Software Engineering Notes, v. </booktitle> <volume> 14, </volume> <editor> n. </editor> <volume> 4, </volume> <month> June, </month> <year> 1989. </year>
Reference-contexts: Consistency between those two representations was maintained by embedding maintenance operations in the APPL/A tasks and by using triggers to propagate information between relations and between relations and the APPL/A tasks. A number of other languages such as AP5 [2] and Marvel <ref> [9] </ref>, produced similar solutions to the ISPW6 problem. The state server idea elaborates on this use of an explicit process state. <p> State Graph.(a). Makefile Contents. satisfied. Note that this operation deliberately says nothing about the semantics of task satisfaction (such as the postconditions of Marvel <ref> [9] </ref>), only that some external client deemed the task to have been satisfied. In some cases, this marking may be carried out automatically.
Reference: [10] <author> Gail E. Kaiser, Naser S. Barghouti, and Michael H. Sokolsky. </author> <title> Preliminary Experience with Process Modeling in the Marvel Software Development Environment Kernel. </title> <editor> In Bruce D. Shriver, editor, </editor> <booktitle> 23rd Annual Hawaii International Conference on System Sciences, </booktitle> <volume> volume II, </volume> <pages> pages 131-140, </pages> <address> 1990. Kona, Hawaii, </address> <month> January, </month> <year> 1990. </year>
Reference-contexts: If that grammar happens to match the state structure used by a process state server, then that server probably could be used as a component of that PVM. * Kaiser is proposing a rule-based process server based on Marvel <ref> [10] </ref>. Unlike the state server, this server contains a complete process programming language (Marvel). This style of server seems to submerge the state within a particular formalism in that it uses the Marvel rule-based language to manipulate any state in the server.
Reference: [11] <editor> T. Katyama, editor. </editor> <booktitle> Proceedings of the 6th International Software Process Workshop: Support for the Software Process. </booktitle> <publisher> IEEE Computer Society Press, </publisher> <address> Hakodate, Hokkaido, Japan, </address> <month> 28-31 Octo-ber </month> <year> 1990. </year>
Reference-contexts: 1 Introduction Much of the research into process programming [13] has been concerned with the formalisms needed to model and support processes. These formalisms are typically made explicit through process programming languages (PPL's) <ref> [11] </ref>, whose purpose is to support the definition of specific processes. These formalisms, and hence the associated PPL's may be divided into two classes: modeling and execution (or enaction). <p> To date, most of the work in process programming has been concerned with the definition of appropriate process languages <ref> [11] </ref> and with the construction of example process programs [12, 15] to test out the utility of those languages. What has been missing from this work is a consideration of how, concretely, such languages can be used to drive an environment.
Reference: [12] <author> Marc I. Kellner et al. </author> <title> Software Process Modeling Example Problem. </title> <editor> In Takuya Katayama, editor, </editor> <booktitle> Proceedings of the 6th International Software Process Workshop: Support for the Software Process. </booktitle> <publisher> IEEE Computer Society Press, </publisher> <address> 1991. Hakodate, Hokkaido, Japan, </address> <month> October, </month> <year> 1990. </year>
Reference-contexts: To date, most of the work in process programming has been concerned with the definition of appropriate process languages [11] and with the construction of example process programs <ref> [12, 15] </ref> to test out the utility of those languages. What has been missing from this work is a consideration of how, concretely, such languages can be used to drive an environment. <p> While the state server approach is influenced by a number of previous efforts, a primary source comes from observations on the ISPW6 Software Process Example and its solutions <ref> [12] </ref>. That example required the solutions to be able to dynamically create and abort various wallering tasks as part of the process. A common approach used in the solutions was to define and manage a "reified" (explicit) representation of the wallering tasks as part of the process program.
Reference: [13] <author> Leon J. Osterweil. </author> <title> Software Processes are Software Too. </title> <booktitle> In Proc. Ninth International Conference on Software Engineering, 1987. </booktitle> <address> Monterey, CA, March 30 - April 2, </address> <year> 1987. </year>
Reference-contexts: 1 Introduction Much of the research into process programming <ref> [13] </ref> has been concerned with the formalisms needed to model and support processes. These formalisms are typically made explicit through process programming languages (PPL's) [11], whose purpose is to support the definition of specific processes.
Reference: [14] <author> Steven P. Reiss. </author> <title> Connecting Tools Using Message Passing in the Field Environment. </title> <journal> IEEE Software, </journal> <pages> pages 57-67, </pages> <month> July </month> <year> 1990. </year>
Reference-contexts: Catalog: As described in section 6, this module maintains a queryable meta-database of information about the structure of the process state (process goal types and product types). Event Dispatcher: The event dispatcher provides functionality similar to the broadcast message server of Field <ref> [14] </ref>. It maintains a database of clients registered to receive events along with the event patterns defining the events of interest to each client. Process States: These are the actual state graphs and product objects and tuples. <p> This provides a capability for clients to attach client-defined annotations (such as "task-stopped") to, for example, task nodes in a state graph. In fact this is the underlying mechanism used to implement operations such as Satisfied. 5 Event Management Event dispatching systems such as Field <ref> [14] </ref> and HP-SoftBench [7] have proven to be remarkably useful for integrating the control of tools in an environment. One tool can signal an event such as editing a source code file.
Reference: [15] <author> S. M. Sutton Jr. et al. </author> <title> Programming a Software Requirements Specification Process. </title> <booktitle> In Proceedings of the First International Conference on the Software Process, </booktitle> <address> Redondo Beach, CA, </address> <month> October </month> <year> 1991. </year>
Reference-contexts: To date, most of the work in process programming has been concerned with the definition of appropriate process languages [11] and with the construction of example process programs <ref> [12, 15] </ref> to test out the utility of those languages. What has been missing from this work is a consideration of how, concretely, such languages can be used to drive an environment. <p> Unfortunately, it is not psychologically plausible since it does not allow for programmer flexibility or unanticipated actions. The rule-based style, by contrast, is quite flexible and can handle unanticipated actions. But it is difficult to understand the process flow. The REBUS program <ref> [15] </ref>, for example, uses this style and is not as easy to understand as one could wish. Style choices say something specific about how to construct a process state.
Reference: [16] <author> Stanley M. Sutton, Jr. APPL/A: </author> <title> A Prototype Language for Software-Process Programming. </title> <type> PhD thesis, </type> <institution> University of Colorado, </institution> <month> August </month> <year> 1990. </year>
Reference-contexts: A common approach used in the solutions was to define and manage a "reified" (explicit) representation of the wallering tasks as part of the process program. In the APPL/A <ref> [16] </ref> solution, for example, each task in the problem was represented by a corresponding Ada task in the program, thus providing a direct representation of the process elements in code. Additionally, the program included several APPL/A relations that stored information about the attributes and structure of these tasks.
Reference: [17] <author> Ian Thomas, </author> <title> editor. </title> <booktitle> Preprints for the 7th International Software Process Workshop. </booktitle> <institution> Rocky Mountain Institute of Software Engineering, </institution> <address> Youn-teville, Ca., </address> <month> 15-18 October </month> <year> 1991. </year> <month> 168 </month>
Reference-contexts: The key insight was to recognize that both styles could share a common state, even if they were constructed in different ways (by rules or procedurally). But others are certainly recognizing the importance of process state. For example, a number of the papers in <ref> [17] </ref> relate to the issue: * The Process Virtual Machine (PVM) of Balzer is substantially more ambitious than a process state server. But, it does assume that part of the PVM will be a grammar for a process state.
References-found: 17

