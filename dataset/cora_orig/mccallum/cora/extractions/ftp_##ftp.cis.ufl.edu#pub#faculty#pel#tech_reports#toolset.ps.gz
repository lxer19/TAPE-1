URL: ftp://ftp.cis.ufl.edu/pub/faculty/pel/tech_reports/toolset.ps.gz
Refering-URL: http://www.cis.ufl.edu/~pel/Ghinsu/gghinsu.html
Root-URL: http://www.cis.ufl.edu
Title: A Toolset for Program Understanding  
Author: Panos E. Livadas Scott D. Alden 
Address: Gainesville, FL 32611 Gainesville, FL 32611  
Affiliation: Computer and Information Sciences Computer and Information Sciences University of Florida University of Florida  
Abstract: Program understanding is associated with the hierarchy of abstractions and interpretations that are deduced from the code [16]. Therefore, the understanding process parallels that of the bottom-up programming process in that maintainers begin by associating small groupings of individual instructions with higher-level interpretations. The understanding process is repeated until the desired level of understanding is attained. Program understanding in this context requires the identification and study of the numerous complex interrelationships that are induced by the data flow, calling, and functional dependencies that exist in the software. Therefore, an environment is needed in order aid the programmer in understanding software. The internal program representation (IPR) plays a critical role in the nature of that environment. In an earlier paper, we discussed both an internal program representation and an environment that conforms to the requirements stated above.[11] The internal program representation, the system dependence graph (SDG), is a directed labeled multigraph that captures all control and data dependences, as well as the calling context of procedures; it is based on the one proposed in [8]. The toolset is referred to as Ghinsu and it supports a number of tasks over a program written in a subset of ANSI C such as slicing, dicing, and ripple analysis. In this paper we will present some background on the problems associated with program understanding and show how the Ghinsu toolset can aid the programmer in understanding software. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <institution> SERC Industrial Affiliates. </institution> <type> Personal communication, </type> <pages> 1989-1992. </pages>
Reference-contexts: On the other hand, a number of organizations have found that simply purchasing new tools does not automatically increase productivity <ref> [1] </ref>. What is needed is the creation of a process for each type of understanding that uses a set of tools designed within the framework of this process. These tools should allow the maintainer to ask questions about a program and be provided with precise answers.
Reference: [2] <author> A. V. Aho, R. Sethi, and J. D. Ullman. </author> <booktitle> Compilers: Principles, Techniques, and Tools. </booktitle> <publisher> Addison-Wesley, </publisher> <address> Reading, Mass. </address>
Reference-contexts: We then use the algorithm discussed in [6] to compute the control dependences. Data Dependence In order to compute the data dependences of a program, we must first calculate the reaching definitions for the entire program. We define the GEN and KILL sets <ref> [2] </ref> for each block on flowgraph. We then use the iterative algorithm presented in [2] to calculate the reaching definitions. A node x is data flow dependent from a node y if node y defines a variable that is used in em x. <p> Data Dependence In order to compute the data dependences of a program, we must first calculate the reaching definitions for the entire program. We define the GEN and KILL sets <ref> [2] </ref> for each block on flowgraph. We then use the iterative algorithm presented in [2] to calculate the reaching definitions. A node x is data flow dependent from a node y if node y defines a variable that is used in em x. We now consider the case of routine invocation.
Reference: [3] <author> B.W. Boehm. </author> <title> The High Cost of Software, Practical Strategies for Developing Large Software Systems, </title> <editor> E. Horowitz (ed.). </editor> <publisher> Addison-Wesley Reading, </publisher> <address> Mass. </address>
Reference-contexts: 1 Introduction Software maintenance is an expensive, demanding, and ongoing process. Boehm <ref> [3] </ref> has estimated that one US Air Force system cost $30 per instruction to develop and $4,000 per instruction to maintain over its lifetime.
Reference: [4] <author> V. Basili and H. Mills. </author> <title> Understanding and documenting programs. </title> <journal> IEEE Transactions on Software Engi--neering, </journal> <volume> SE-8(3):270-283, </volume> <year> 1982. </year>
Reference-contexts: A program is said to be understood if an overall interpretation of the program is achieved. Most of the proposed models fall into one of the two categories: code-driven (bottom-up) or problem-driven (top-down) <ref> [4, 5, 15] </ref>. We hypothesize that both strategies are employed by the programmers engaged in this activity. We also support the notion that different maintenance tasks require different kinds of program understanding, and therefore different processes are required.
Reference: [5] <author> R. Brooks. </author> <title> Towards a theory of the comprehension of computer programs. </title> <journal> Int'l J. Man-Machine Studies, </journal> <volume> 18 </volume> <pages> 543-554, </pages> <year> 1983. </year>
Reference-contexts: A program is said to be understood if an overall interpretation of the program is achieved. Most of the proposed models fall into one of the two categories: code-driven (bottom-up) or problem-driven (top-down) <ref> [4, 5, 15] </ref>. We hypothesize that both strategies are employed by the programmers engaged in this activity. We also support the notion that different maintenance tasks require different kinds of program understanding, and therefore different processes are required.
Reference: [6] <author> J. Ferrante, K. Ottenstein, and J. Warren. </author> <title> The program dependence graph and its use in optimization. </title> <journal> ACM TOPLAS, </journal> <volume> 9(3) </volume> <pages> 319-349, </pages> <year> 1987. </year>
Reference-contexts: Third, we use a parse tree as the basis of our SDG. This allows slicing to be more precise than if resolution of the SDG was only at the statement level. The improved precision occurs because the algorithm for slicing <ref> [6] </ref> requires the traversal of certain edges backwards. Hence, when a statement such as x = x + y +foo (&a) is encountered during the computation of the slice of a, then the union of the slices associated with x and y will be included in the slice of a. <p> In order to calculate control dependences, a control flowgraph of a program is needed. The control flowgraph's post-dominators are then calculated which is equivalent to calculating the dominators of the reverse control flowgraph (all edges of control flowgraph are reversed). We then use the algorithm discussed in <ref> [6] </ref> to compute the control dependences. Data Dependence In order to compute the data dependences of a program, we must first calculate the reaching definitions for the entire program. We define the GEN and KILL sets [2] for each block on flowgraph.
Reference: [7] <author> S. Horwitz, J. Prins, and T. Reps. </author> <title> Integrating non-interfering versions of programs. </title> <booktitle> In Proc. 15th ACM Symposium of Programming Languages, </booktitle> <year> 1988. </year>
Reference-contexts: We have implemented tools such as a slicer, dicer, ripple analyzer, dependency analyzer, DU-chains, UD-chains, a reaching definitions calculator (even if these definitions or chains span procedure boundaries), and a browser that utilize this SDG. The grammar proposed in <ref> [7] </ref> consists of a single (main) program and supports scalar variables, assignment statements, conditional statements, and while loops, but does not support variable declarations. The language consists of a collection of procedures whose parameters are passed by value-result, and which end with return statements.
Reference: [8] <author> S. Horwitz, T. Reps, and D. Binkley. </author> <title> Interprocedural slicing using dependence graphs. </title> <journal> ACM TOPLAS, </journal> <month> January </month> <year> 1990. </year>
Reference-contexts: Ottenstein et al. [14], show that an intraprocedural slice could be found in linear time by traversing a suitable graph representation of the program that they referred to as the program dependence graph (PDG). Horwitz et al. <ref> [8] </ref> introduce algorithms to construct interprocedural slices by extending the program dependence graph to a supergraph of the PDG, which is referred to as the system dependence graph (SDG). This extension captures the calling context of the procedures which was lacking in the method proposed by Weiser. <p> Finally, we use a parse tree as the basis of our SDG. This allows slicing to be more precise than if the "resolution" of the SDG was only at the statement level. Even though the SDG and the slicing algorithm are based on the work proposed in <ref> [8] </ref>, our methods are considerable extensions of previous works. First, our grammar is a superset of the grammar targeted in [8]. Second, our method of building the SDG differs in many respects. <p> Even though the SDG and the slicing algorithm are based on the work proposed in <ref> [8] </ref>, our methods are considerable extensions of previous works. First, our grammar is a superset of the grammar targeted in [8]. Second, our method of building the SDG differs in many respects. Our method eliminates the need to compute the GMOD and GREF sets of each procedure in the system and to construct a linkage grammar and its corresponding subordinate characteristic graphs of the linkage grammar's nonterminals.
Reference: [9] <author> S. Letovsky and E. Soloway. </author> <title> Strategies for documenting delocalized plans. </title> <booktitle> In Proc. Conf. on Software Maintenance, </booktitle> <pages> pages 144-151, </pages> <year> 1985. </year>
Reference-contexts: Program segments are not just as simple as the example above may erroneously indicate. The example contains only localized interactions. As Letovsky and Soloway <ref> [9] </ref> have established, programmers have difficulty understanding code that has non-local interactions. For example, if the call to procedure do something is un-commented, it is not clear which of the definitions of sum can reach the use of sum at statement number (5).
Reference: [10] <author> P.E. Livadas and P. Roy. </author> <title> Program dependence analysis. </title> <booktitle> In IEEE Conf. on Software Maintenance, </booktitle> <year> 1992. </year>
Reference-contexts: Most of our tools can be run on incomplete programs provided that they are compilable. Hence, these tools can be used even at the development stage. We have also developed an object finder that uses information from the SDG to group together related types, data, and routines <ref> [10, 12] </ref>. We note that this tool can help objectify code and capture the objects that the original designer had in mind. 3 The Internal Program Representation Weiser's slicers [18] were based on a flow-graph representation of programs.
Reference: [11] <author> P.E. Livadas and S. Croll. </author> <title> System Dependence Graphs Based on Parse Trees and their Use in Software Maintenance. </title> <journal> In Journal of Information Sciences, </journal> <note> (to appear). </note>
Reference: [12] <author> P.E. Livadas and T. Johnson. </author> <title> A new approach to finding objects in programs. </title> <type> Technical Report cis.ufl.edu:cis/tech-reports/tr92/tr92-037.ps.Z, </type> <institution> U. Florida Dept. of CIS, </institution> <year> 1992. </year>
Reference-contexts: Most of our tools can be run on incomplete programs provided that they are compilable. Hence, these tools can be used even at the development stage. We have also developed an object finder that uses information from the SDG to group together related types, data, and routines <ref> [10, 12] </ref>. We note that this tool can help objectify code and capture the objects that the original designer had in mind. 3 The Internal Program Representation Weiser's slicers [18] were based on a flow-graph representation of programs.
Reference: [13] <author> J.R. Lyle and M. Weiser. </author> <title> Automatic program bug location by program slicing. </title> <booktitle> In Proc. 2nd International Conference on Computers and Applications, </booktitle> <year> 1987. </year>
Reference-contexts: If the value of another variable, w, is computed correctly at statement n, then we may employ a method that was suggested in <ref> [13] </ref> and is referred to as dicing (computing the intersection of two slices).
Reference: [14] <author> K.J. Ottenstein and L.M. Ottenstein. </author> <title> The program dependence graph in a software development environment. </title> <journal> ACM SIGPLAN Notices 19,5, </journal> <year> 1984. </year>
Reference-contexts: We note that this tool can help objectify code and capture the objects that the original designer had in mind. 3 The Internal Program Representation Weiser's slicers [18] were based on a flow-graph representation of programs. Ottenstein et al. <ref> [14] </ref>, show that an intraprocedural slice could be found in linear time by traversing a suitable graph representation of the program that they referred to as the program dependence graph (PDG). <p> This new approach not only permits more precise slices than [18], it also permits slicing when the program contains calls to unknown procedures (procedures whose bodies are not available), provided that the transitive dependencies (discussed later) are known. As was pointed out in <ref> [14] </ref>, the internal program representation (IPR) chosen plays a critical role in the software development environment. An example of a SDG is shown in Figure 1 We have developed a prototype that accepts programs written in ANSI C or Pascal and generates a parse tree based SDG.
Reference: [15] <author> R.E. Seviora. </author> <title> Knowledge-based program debugging systems. </title> <journal> IEEE Software, </journal> <volume> 4(3) </volume> <pages> 20-32, </pages> <year> 1987. </year>
Reference-contexts: A program is said to be understood if an overall interpretation of the program is achieved. Most of the proposed models fall into one of the two categories: code-driven (bottom-up) or problem-driven (top-down) <ref> [4, 5, 15] </ref>. We hypothesize that both strategies are employed by the programmers engaged in this activity. We also support the notion that different maintenance tasks require different kinds of program understanding, and therefore different processes are required.
Reference: [16] <author> J. Wedo. </author> <title> Structured program analysis applied to software maintenance. </title> <booktitle> In Proc. Conf. on Software Maintenance, </booktitle> <pages> pages 28-34, </pages> <year> 1985. </year>
Reference-contexts: This domain lies outside of the domain of program interpretations, and requires program documentation for understanding. Program understanding is associated with the hierarchy of abstractions and interpretations that are deduced from the code <ref> [16] </ref>. Therefore, the understanding process parallels that of the bottom-up programming process in that maintainers begin by associating small groupings of individual instructions with higher-level interpretations. The understanding process is repeated until the desired level of understanding is attained.
Reference: [17] <author> M. Weiser. </author> <title> Programmers use slices when debugging. </title> <journal> CACM, </journal> <year> 1982. </year>
Reference-contexts: Weiser reports experimental results that experienced programmers use slicing when debugging <ref> [17] </ref>. Weiser found that programmers remembered the slice relevant to the bug as having been used or probably having been used in almost half the cases examined. When debugging, programmers view programs in ways that need not conform to the program's textual or modular structures. <p> Since debugging is a process in which programmers try to better understand code to find and eliminate bugs, and since programmers find slices when debugging, it is logical that a tool that automatically creates program slices would be useful not only in debugging but also in code understanding <ref> [17] </ref>. Suppose that during testing, we find that the value of a certain variable, v, is incorrectly computed at statement n. By obtaining a slice of v at n, we may extract a significantly smaller piece of code than the entire program in which to locate the bug. <p> Therefore, program slicing aids in code reuse. 1 Funded by the National Science Foundation, the Center's 15 industrial affiliates, and the Florida High Technology and Industry Council. The number of slices, their spatial arrangement, etc., may hold significant information about the structuring of a program <ref> [17] </ref>. Hence, an assortment of program metrics can be computed and their actual significance investigated. Useful metrics include coverage, overlap, clustering, and tightness. Ripple analysis identifies the statements that will be affected when a change is to be made at a given statement (i.e, ripple analysis is "forward" slicing).
Reference: [18] <author> M. Weiser. </author> <title> Program slicing. </title> <journal> IEEE Transactions on Software Engineering, </journal> <year> 1984. </year>
Reference-contexts: We note that this tool can help objectify code and capture the objects that the original designer had in mind. 3 The Internal Program Representation Weiser's slicers <ref> [18] </ref> were based on a flow-graph representation of programs. Ottenstein et al. [14], show that an intraprocedural slice could be found in linear time by traversing a suitable graph representation of the program that they referred to as the program dependence graph (PDG). <p> This extension captures the calling context of the procedures which was lacking in the method proposed by Weiser. This new approach not only permits more precise slices than <ref> [18] </ref>, it also permits slicing when the program contains calls to unknown procedures (procedures whose bodies are not available), provided that the transitive dependencies (discussed later) are known. As was pointed out in [14], the internal program representation (IPR) chosen plays a critical role in the software development environment.
Reference: [19] <author> N. Wilde. </author> <booktitle> SDTC Lecture Series 1: Software Development Environments. </booktitle> <address> CENET, </address> <month> October </month> <year> 1992. </year>
Reference-contexts: Given the complexity of the task, is not surprising therefore that programmers spend approximately 60% of the maintenance time "looking at" code <ref> [19] </ref>. Therefore one can conclude that maintenance quality and productivity can be improved by supplying the maintainer with a set of proper tools that he/she may employ for understanding the target software.
References-found: 19

