URL: file://ftp.cis.ohio-state.edu/pub/tech-report/1994/TR35.ps.gz
Refering-URL: ftp://ftp.cis.ohio-state.edu/pub/tech-report/TRList.html
Root-URL: 
Email: tick@informatik.mathematik.uni-mainz.de  ramachan@cis.ohio-state.edu  
Title: A Note on Set Bit Enumeration polynomial time computable n-set-bit-enumerators exist for all OptP func
Author: Thomas Schwentick J. Ramachandran 
Note: If  
Date: June 28, 1994  
Address: Mainz  
Affiliation: Johannes-Gutenberg Universitat  Ohio State University  
Abstract: An m-set-bit-enumerator for a function f is a source of information that, in response to the query: "How many set bits (`1's) are there in the binary representation of f(x)?", computes a list of m numbers, one of which is the correct value. This paper extends previous results on the hardness of set-bit-enumeration for the function classes OptP and # P. Our main theorems state: 
Abstract-found: 1
Intro-found: 1
Reference: [ABG90] <author> A. Amir, R. Beigel, and W. Gasarch. </author> <title> Some connections between bounded query classes and non-uniform complexity. </title> <booktitle> In Proc. Fifth Annual IEEE Structure in Complexity Theory Conference, </booktitle> <pages> pages 232-243, </pages> <year> 1990. </year>
Reference: [BDG88] <author> J. Balcazar, J. Diaz, and J. Gabarro. </author> <title> Structural Complexity I. </title> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1988. </year>
Reference-contexts: However for constant set-bit enumerators, and hence for the results of [Ram92], both definitions ecoincide. 2 2 Definitions and Notations In this section we present definitions and notation for the functions and classes considered. We use standard notation for languages and function classes as in <ref> [BDG88] </ref>.
Reference: [CH89] <author> J. Cai and L. Hemachandra. </author> <title> Enumerative counting is hard. </title> <journal> Information and Computation, </journal> <volume> 82 </volume> <pages> 34-44, </pages> <year> 1989. </year>
Reference-contexts: We will focus on Cai and Hemachan-dra's notion of enumerative counting. 1.1 Definition. <ref> [CH89] </ref> A function g is said to s ()-enumerate a function f if, for all x 2 fl , g (x) is a set of size s (jxj) guaranteed to contain f (x). <p> Our paper is organised as follows. * In Section 2 we define basic notations, * In Section 3, we outline the general method of the algorithms. The structure is similar to the "expand-prune" algorithms of <ref> [CH89] </ref>, * In Section 4 we show theorem 1.5 and discuss how the proof technique used there translates to other function classes, * In Section 5, we show how to construct a function's value, through queries to a 1-set-bit-enumerator, * In Section 6 we state and prove our main theorem about <p> We define # 1 (x) to be the number of ones in the binary representation of x. 3 The method in general The method we use to obtain our results about OptP and # P is in both cases essentially identical and is derived from similar methods in <ref> [CH89] </ref>. Therefore it seems to be useful to describe our method first in general. Let F denote the function class under examination. <p> It follows that for those classes the existence of set bit enumerators implies the existence of regular enumerators. But for those classes no general collapse result like [CH91] is known. On the other hand it is well-known that the result of <ref> [CH89] </ref> can be easily extended to those classes.
Reference: [CH91] <author> J. Cai and L. Hemachandra. </author> <title> A note on enumerative counting. </title> <journal> Information Processing Letters, </journal> <volume> 38 </volume> <pages> 215-219, </pages> <year> 1991. </year>
Reference-contexts: Thus, given a polynomial time regular enumerator for g, it can be verified in polynomial time whether a given list of values is valid and which of the values is maximum. In the case of # P, the proof is more complicated, the reader is refered to <ref> [CH91] </ref>. 3 Now we sketch the method for the first implication. <p> It follows that for those classes the existence of set bit enumerators implies the existence of regular enumerators. But for those classes no general collapse result like <ref> [CH91] </ref> is known. On the other hand it is well-known that the result of [CH89] can be easily extended to those classes. <p> They then draw conclusions from the hypothesis F A k is computable with less than k queries to A. Their results also implied the main theorem of <ref> [CH91] </ref>. Other generalizations could involve a further weakening of the information available from a set-bit-enumerator. 10 Acknowledgements We would like to thank Clemens Lautemann for helping us improve the readibility and correctness of this paper and Johannes Kobler for helpful comments.
Reference: [Kre88] <author> M. Krentel. </author> <title> The complexity of optimization problems. </title> <journal> J. Computer Systems Sci., </journal> <volume> 36 </volume> <pages> 490-509, </pages> <year> 1988. </year>
Reference-contexts: of f there exists a polynomial-time computable function h such that h (x) is a set of at most g (p (x)) numbers, one of which is # 1 (f (x)). 1 The emphasis in [Ram92] was shifted to weaker function classes as well, especially OptP, first defined by Krentel <ref> [Kre88] </ref>. It was proved that not all functions in OptP have polynomial time computable set-bit-enumerators giving constant many values, unless OptP already equals PF.
Reference: [Ram92] <author> J. Ramachandran. </author> <title> Set bit enumeration is hard. </title> <booktitle> In Proceedings, Seventh Annual Structure in Complexity Theory, </booktitle> <pages> pages 58-70, </pages> <address> 1992. </address> <publisher> IEEE Computer Society Press. </publisher> <pages> 11 </pages>
Reference-contexts: This is a negative result showing that it is unlikely that polynomial time computable enumerators exist for #P. It is natural to ask if weakening the notion of an enumerator for # P results in feasibly constructable approximations. In <ref> [Ram92] </ref> the information obtainable from an enumerator was modified from a set of m candidate values of f (x), to a set of m candidate values for the number of 1's (each 1 is called a set bit) in the binary representation of f (x) (denoted by # 1 (f (x))). <p> A function f is called g-set-bit-enumerable, if for every bound p of f there exists a polynomial-time computable function h such that h (x) is a set of at most g (p (x)) numbers, one of which is # 1 (f (x)). 1 The emphasis in <ref> [Ram92] </ref> was shifted to weaker function classes as well, especially OptP, first defined by Krentel [Kre88]. It was proved that not all functions in OptP have polynomial time computable set-bit-enumerators giving constant many values, unless OptP already equals PF. Specifically 1.4 Theorem. [Ram92] If for every function f in OptP there <p> # 1 (f (x)). 1 The emphasis in <ref> [Ram92] </ref> was shifted to weaker function classes as well, especially OptP, first defined by Krentel [Kre88]. It was proved that not all functions in OptP have polynomial time computable set-bit-enumerators giving constant many values, unless OptP already equals PF. Specifically 1.4 Theorem. [Ram92] If for every function f in OptP there is a constant m such that f has polynomial time computable m-set-bit-enumerators then OptP = PF. The constant m of the above proof was later elegantly improved by Beigel and Gasarch to O (log n) (personal communication) 1 . <p> Therefore the above result is somehow optimal. Furthermore we resolve the primary open problem stated in <ref> [Ram92] </ref> in a strong manner, showing that, unless # P = PF, set bit enumerators for # P-functions must, in general, give at least about p n values. 1.6 Theorem. If polynomial time computable n 1 2 * -set-bit-enumerators exist for all #P functions then #P = PF. <p> a function's value, through queries to a 1-set-bit-enumerator, * In Section 6 we state and prove our main theorem about the infeasiblity of set-bit enumerating # P functions, * In Section 7 we finally discuss our results and state some open problems. 1 Here, as in the original definition of <ref> [Ram92] </ref> n is the length of the input. However for constant set-bit enumerators, and hence for the results of [Ram92], both definitions ecoincide. 2 2 Definitions and Notations In this section we present definitions and notation for the functions and classes considered. <p> about the infeasiblity of set-bit enumerating # P functions, * In Section 7 we finally discuss our results and state some open problems. 1 Here, as in the original definition of <ref> [Ram92] </ref> n is the length of the input. However for constant set-bit enumerators, and hence for the results of [Ram92], both definitions ecoincide. 2 2 Definitions and Notations In this section we present definitions and notation for the functions and classes considered. We use standard notation for languages and function classes as in [BDG88]. <p> Therefore, if F is one of the mentioned classes, if for any * &gt; 0 every function in F has a min (jxj 1* ; n)-set-bit-enumerator then F = PF. 5 1-set-bit-enumerators for #P It was already shown in <ref> [Ram92] </ref> that if every # P-function has a 1-set-bit-enumerator, then # P = PF. In this section we show this result again with a simplified proof. <p> Then (1) BIT (y; i) = 0 () # 1 (y + 2 i ) = # 1 (y) + 1; and 5.2 Theorem. <ref> [Ram92] </ref> If every # P-function has a 1-set-bit-enumerator, then # P = PF. Proof. Let f 2 # P with bound p. Then the function g defined by g (x; y) := f (x) + y is also a # P-function.
References-found: 6

