URL: ftp://ftp.csd.uu.se/pub/papers/reports/0132.ps.gz
Refering-URL: http://www.csd.uu.se/papers/reports.html
Root-URL: 
Email: kung-kiu@cs.man.ac.uk ornaghi@hermes.mc.dsi.unimi.it  
Title: Forms of Logic Specifications: A Preliminary Study  
Author: Kung-Kiu Lau Mario Ornaghi 
Address: Manchester M13 9PL Via Comelico 39/41, Milano United Kingdom Italy  
Affiliation: Dept of Computer Science DSI University of Manchester Universita' degli studi di Milano  
Date: October, 1996 ISSN 1100-0686  
Note: 2  Part of this work was done while the first author was Visiting Professor in the Computing Science Dept at Uppsala University, supported by the European Union HCM project on Logic Program Synthesis and Transformation, contract no. 93/414. He wishes to thank Jonas Barklund for his invitation and hospitality.  
Abstract: UPMAIL Technical Report No. 132 Abstract There is no universal agreement on exactly what form a specification should take, what part it should play in synthesis, and what its precise relationship with the specified program should be. In logic programming, the role of specification is all the more unclear since logic programs are often used as executable specifications. In this paper we conduct a preliminary study of two useful forms of logic specifications: if-and-only-if and partial specifications. First we set up a three-tier formalism for synthesis. Then within this formalism we define these two forms of specifications, and discuss their roles in synthesis. fl A revised version of this paper will appear in the proceedings of LOPSTR 96, 28-30 August 1996, Stockholm, Sweden. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> J.L. Bates and R.L. Constable. </author> <title> Proofs as programs. </title> <journal> ACM TOPLAS 7(1) </journal> <pages> 113-136, </pages> <year> 1985. </year>
Reference-contexts: (x) and O (x; y) are input and output relations, to verify the total correctness of a program P to compute r. (13) is almost identical to our conditional specification, although it is not used for specification purposes. 14 In general, constructive synthesis follows the `proofs as programs' ap-proach (e.g. <ref> [1, 19] </ref>). 7 A specification consists of an input-output theorem of the form 8x9y r (x; y) (14) From a proof of this theorem, a program to compute r can be extracted. In logic programming, however, the connection between deductive and constructive synthesis is particularly close.
Reference: [2] <author> A. Bundy, A. Smaill and G. Wiggins. </author> <title> The synthesis of logic programs from inductive proofs. </title> <editor> In J.W. Lloyd, editor, </editor> <booktitle> Proc. Esprit Symposium on Computational Logic, </booktitle> <pages> pages 135-149, </pages> <publisher> Springer-Verlag, </publisher> <year> 1990. </year>
Reference-contexts: In logic programming, however, the connection between deductive and constructive synthesis is particularly close. For example, in the constructive synthesis method of <ref> [2] </ref>, the input-output relation r (x; y) in (14) is itself an if-and-only-if specification. In [14, 6], program extraction is performed by proving goals of the form 8x9y q (x; y) r (x) (15) using an extended Prolog execution mechanism.
Reference: [3] <author> K.L. Clark. </author> <title> Predicate Logic as a Computational Formalism. </title> <type> Tech. Rep. 79/59, </type> <institution> Imperial College, </institution> <year> 1979. </year>
Reference-contexts: For example, in [8, 4, 11], frameworks are not used, and if-and-only-if specifications are used in a proof-theoretic way to derive logic programs, and/or to prove them correct. Nevertheless, there are similarities between our specifications and some of their verification conditions. For example, Clark <ref> [3, Section 4] </ref> (see also [12, p.158]) uses the following correctness sentence: 8x; y (I (x) ! (r (x; y) $ O (x; y))) (13) where I (x) and O (x; y) are input and output relations, to verify the total correctness of a program P to compute r. (13) is
Reference: [4] <author> K.L. Clark. </author> <title> The Synthesis and Verification of Logic Programs. </title> <type> Tech. Rep. 81/36, </type> <institution> Imperial College, </institution> <year> 1981. </year>
Reference-contexts: If-and-only-if specifications are the most widely used forms of specifications in logic program synthesis, e.g. <ref> [8, 4, 11, 16, 17] </ref>. In these papers, 4 various techniques are described for systematically deriving standard logic programs ([8, 4, 11, 16]) or constraint logic programs ([17]). <p> In these papers, 4 various techniques are described for systematically deriving standard logic programs ([8, 4, 11, 16]) or constraint logic programs ([17]). However, it should be noted that in e.g. <ref> [8, 4, 11] </ref>, there is no (explicit) use of frameworks, or model-theoretic semantics of if-and-only-if specifications as described here. If-and-only-if specifications do provide a starting point for program synthesis. <p> Our use of frameworks distinguishes our approach to specifications from related work in deductive synthesis. Moreover, we use a model-theoretic approach whereas others predominantly adopt a proof-theoretic approach. For example, in <ref> [8, 4, 11] </ref>, frameworks are not used, and if-and-only-if specifications are used in a proof-theoretic way to derive logic programs, and/or to prove them correct. Nevertheless, there are similarities between our specifications and some of their verification conditions.
Reference: [5] <author> Y. Deville and K.K. Lau. </author> <title> Logic program synthesis. </title> <journal> J. Logic Programming 19,20:321-350, </journal> <year> 1994. </year> <title> Special issue: Ten years of logic programming. 7 Note that Manna & Waldinger uses `deductive synthesis' to refer to what we call `constructive synthesis' here. </title> <type> 15 </type>
Reference-contexts: For example in SET it is easy to see how we can derive the following program from (4): 5 sublist (nil ; Z) sublist (x:Y; Z) mem (x; Z); sublist (Y; Z) mem (x; x:Z) (5) 4 More details of these, and related papers, can be found in <ref> [5] </ref>. 5 The language of (5) is a sublanguage of that of F [ (4), but we cannot use sets in standard logic programs. 7 (5) of course corresponds to the program (executable specification) (1) in Section 2. <p> The model-theoretic semantics discussed here is used in [18] to define the model-theoretic relationship between frameworks, specifications and programs, in a three-tier formalism for logic program synthesis. The kinds of specifications presented here are intended for deductive synthesis, and not for constructive synthesis (see <ref> [5] </ref> for a survey of different approaches to logic program synthesis). Our use of frameworks distinguishes our approach to specifications from related work in deductive synthesis. Moreover, we use a model-theoretic approach whereas others predominantly adopt a proof-theoretic approach.
Reference: [6] <author> L. </author> <title> Fribourg. Extracting logic programs from proofs that use extended Prolog execution and induction. </title> <editor> In D.H.D. Warren and P. Szeredi, editors, </editor> <booktitle> Proc. 7 th Int. Conf. on Logic Programming , pages 685-699, </booktitle> <publisher> MIT Press, </publisher> <year> 1990. </year>
Reference-contexts: In logic programming, however, the connection between deductive and constructive synthesis is particularly close. For example, in the constructive synthesis method of [2], the input-output relation r (x; y) in (14) is itself an if-and-only-if specification. In <ref> [14, 6] </ref>, program extraction is performed by proving goals of the form 8x9y q (x; y) r (x) (15) using an extended Prolog execution mechanism. Here, r (x) can be regarded as an input, and q (x; y) as an output.
Reference: [7] <author> J. Goguen and J. Meseguer. </author> <title> Unifying functional, object-oriented and relational programming with logical semantics. </title> <editor> In B. Shriver and P. Wegner, editors, </editor> <booktitle> Research Directions in Object-Oriented Programming , pages 417-477, </booktitle> <publisher> MIT Press, </publisher> <year> 1987. </year>
Reference: [8] <author> A. Hansson and S. A. </author> <title> Tarnlund. A natural programming calculus. </title> <booktitle> In Proc. </booktitle> <pages> IJCAI 79 , pages 348-355, </pages> <year> 1979. </year>
Reference-contexts: If-and-only-if specifications are the most widely used forms of specifications in logic program synthesis, e.g. <ref> [8, 4, 11, 16, 17] </ref>. In these papers, 4 various techniques are described for systematically deriving standard logic programs ([8, 4, 11, 16]) or constraint logic programs ([17]). <p> In these papers, 4 various techniques are described for systematically deriving standard logic programs ([8, 4, 11, 16]) or constraint logic programs ([17]). However, it should be noted that in e.g. <ref> [8, 4, 11] </ref>, there is no (explicit) use of frameworks, or model-theoretic semantics of if-and-only-if specifications as described here. If-and-only-if specifications do provide a starting point for program synthesis. <p> Our use of frameworks distinguishes our approach to specifications from related work in deductive synthesis. Moreover, we use a model-theoretic approach whereas others predominantly adopt a proof-theoretic approach. For example, in <ref> [8, 4, 11] </ref>, frameworks are not used, and if-and-only-if specifications are used in a proof-theoretic way to derive logic programs, and/or to prove them correct. Nevertheless, there are similarities between our specifications and some of their verification conditions.
Reference: [9] <author> P.M. Hill and J.W. Lloyd. </author> <title> The Godel Programming Language. </title> <publisher> MIT Press, </publisher> <year> 1994. </year>
Reference-contexts: Both initial and isoinitial theories enjoy the properties of `no junk' and `no confusion' ([7]), but only isoinitial theories can handle negation. 1 That is a model where each element (of the domain) can be represented by a ground term. 2 Or in typed logic programming languages such as Godel <ref> [9] </ref>. 4 The existence of an isoinitial model is not always guaranteed though. Indeed, we distinguish between two kinds of frameworks: * Closed Frameworks. A closed framework F is a theory that has an isoinitial model.
Reference: [10] <author> W. Hodges. </author> <title> Logical features of Horn clauses. In D.M. </title> <editor> Gabbay, C.J. Hog-ger, and J.A. Robinson, editors, </editor> <booktitle> Handbook of Logic in Artificial Intelligence and Logic Programming , Vol 1, </booktitle> <pages> pages 449-503, </pages> <publisher> Oxford University Press, </publisher> <year> 1993. </year>
Reference: [11] <author> C.J. </author> <title> Hogger. Derivation of logic programs. </title> <editor> J. </editor> <booktitle> ACM , 28(2) </booktitle> <pages> 372-392, </pages> <month> April </month> <year> 1981. </year>
Reference-contexts: If-and-only-if specifications are the most widely used forms of specifications in logic program synthesis, e.g. <ref> [8, 4, 11, 16, 17] </ref>. In these papers, 4 various techniques are described for systematically deriving standard logic programs ([8, 4, 11, 16]) or constraint logic programs ([17]). <p> In these papers, 4 various techniques are described for systematically deriving standard logic programs ([8, 4, 11, 16]) or constraint logic programs ([17]). However, it should be noted that in e.g. <ref> [8, 4, 11] </ref>, there is no (explicit) use of frameworks, or model-theoretic semantics of if-and-only-if specifications as described here. If-and-only-if specifications do provide a starting point for program synthesis. <p> Our use of frameworks distinguishes our approach to specifications from related work in deductive synthesis. Moreover, we use a model-theoretic approach whereas others predominantly adopt a proof-theoretic approach. For example, in <ref> [8, 4, 11] </ref>, frameworks are not used, and if-and-only-if specifications are used in a proof-theoretic way to derive logic programs, and/or to prove them correct. Nevertheless, there are similarities between our specifications and some of their verification conditions.
Reference: [12] <author> C.J. </author> <title> Hogger. Introduction to Logic Programming. </title> <publisher> Academic Press, </publisher> <year> 1984. </year>
Reference-contexts: For example, in [8, 4, 11], frameworks are not used, and if-and-only-if specifications are used in a proof-theoretic way to derive logic programs, and/or to prove them correct. Nevertheless, there are similarities between our specifications and some of their verification conditions. For example, Clark [3, Section 4] (see also <ref> [12, p.158] </ref>) uses the following correctness sentence: 8x; y (I (x) ! (r (x; y) $ O (x; y))) (13) where I (x) and O (x; y) are input and output relations, to verify the total correctness of a program P to compute r. (13) is almost identical to our conditional
Reference: [13] <author> C.B. Jones. </author> <title> Systematic Software Development Using VDM. </title> <publisher> Prentice Hall, </publisher> <address> 2nd edition, </address> <year> 1990. </year>
Reference-contexts: If we follow the pre-post-condition style of program specification (e.g. <ref> [22, 13] </ref>), then a conditional specification defines a program P to compute r (x; y) in such a way that whenever IC (y) is satisfied, P satisfies OC (x) ^ R (x; y).
Reference: [14] <author> T. Kanamori and H. Seki. </author> <title> Verification of Prolog programs using an extension of execution. </title> <editor> In E. Shapiro, editor, </editor> <booktitle> Proc. 3 rd Int. Conf. on Logic Programming, Lecture Notes in Computer Science 225, </booktitle> <pages> pages 475-489, </pages> <year> 1986. </year>
Reference-contexts: In logic programming, however, the connection between deductive and constructive synthesis is particularly close. For example, in the constructive synthesis method of [2], the input-output relation r (x; y) in (14) is itself an if-and-only-if specification. In <ref> [14, 6] </ref>, program extraction is performed by proving goals of the form 8x9y q (x; y) r (x) (15) using an extended Prolog execution mechanism. Here, r (x) can be regarded as an input, and q (x; y) as an output.
Reference: [15] <author> K.K. Lau and M. Ornaghi. </author> <title> On specification frameworks and deductive synthesis of logic programs. </title> <editor> In L. Fribourg and F. Turini, editors, </editor> <booktitle> Proc. LOPSTR 94 and META 94 , Lecture Notes in Computer Science 883, </booktitle> <pages> pages 104-121, </pages> <publisher> Springer-Verlag, </publisher> <year> 1994. </year>
Reference-contexts: (x)), where R is any formula of the language, it may happen that the axioms of F are too weak to completely characterise the meaning of the new symbol r. 6 A useful criterion for adequacy is the existence of a totally correct program for computing the specified relation (see <ref> [15] </ref>). In other words, program synthesis can actually be used to expand F with adequate if-and-only-if specifications. The possibility of adding new closed symbols allows us to build up a specification language for specifying programs on the problem domain in a natural and purely declarative way.
Reference: [16] <author> K.K. Lau, M. Ornaghi and S. A. </author> <title> Tarnlund. The halting problem for deductive synthesis of logic programs. </title> <editor> In P. van Hentenryck, editor, </editor> <booktitle> Proc. 11 th Int. Conf. on Logic Programming , pages 665-683, </booktitle> <publisher> MIT Press, </publisher> <year> 1994. </year>
Reference-contexts: Indeed logic programs are often used as executable specifications, for instance in rapid prototyping. In our work in deductive synthesis of logic programs (see e.g. <ref> [16, 17] </ref>), we maintain a strict distinction between specifications and programs. We take the view that program synthesis should take place in a three-tier formalism (with model-theoretic semantics). At the bottom level, we have programs, for computing (specified) relations. <p> If-and-only-if specifications are the most widely used forms of specifications in logic program synthesis, e.g. <ref> [8, 4, 11, 16, 17] </ref>. In these papers, 4 various techniques are described for systematically deriving standard logic programs ([8, 4, 11, 16]) or constraint logic programs ([17]).
Reference: [17] <author> K.K. Lau and M. Ornaghi. </author> <title> A formal approach to deductive synthesis of constraint logic programs. </title> <editor> In J.W. Lloyd, editor, </editor> <booktitle> Proc. 1995 Int. Logic Programming Symp., </booktitle> <pages> pages 543-557, </pages> <publisher> MIT Press, </publisher> <year> 1995. </year>
Reference-contexts: Indeed logic programs are often used as executable specifications, for instance in rapid prototyping. In our work in deductive synthesis of logic programs (see e.g. <ref> [16, 17] </ref>), we maintain a strict distinction between specifications and programs. We take the view that program synthesis should take place in a three-tier formalism (with model-theoretic semantics). At the bottom level, we have programs, for computing (specified) relations. <p> If-and-only-if specifications are the most widely used forms of specifications in logic program synthesis, e.g. <ref> [8, 4, 11, 16, 17] </ref>. In these papers, 4 various techniques are described for systematically deriving standard logic programs ([8, 4, 11, 16]) or constraint logic programs ([17]).
Reference: [18] <author> K.K. Lau and M. Ornaghi. </author> <title> The relationship between logic programs and specifications | the subset example revisited. </title> <note> To appear in J. Logic Programming </note> . 
Reference-contexts: Open frameworks are very useful in that they allow us to introduce parameters, and to deal with incomplete information that can be supplied via parameters (see <ref> [18] </ref>). For simplicity, in this paper we will consider only specifications within closed frameworks. Such frameworks can be constructed incrementally, starting from a simple framework with an obvious isoinitial model, e.g. the term model generated by the constructor symbols (see e.g. [18]). <p> incomplete information that can be supplied via parameters (see <ref> [18] </ref>). For simplicity, in this paper we will consider only specifications within closed frameworks. Such frameworks can be constructed incrementally, starting from a simple framework with an obvious isoinitial model, e.g. the term model generated by the constructor symbols (see e.g. [18]). <p> Hence the program (12) is a correct implementation of S. 6 Discussion and Concluding Remarks We have presented a model-theoretic view of frameworks and specifications. The model-theoretic semantics discussed here is used in <ref> [18] </ref> to define the model-theoretic relationship between frameworks, specifications and programs, in a three-tier formalism for logic program synthesis. The kinds of specifications presented here are intended for deductive synthesis, and not for constructive synthesis (see [5] for a survey of different approaches to logic program synthesis).
Reference: [19] <author> Z. Manna and R. Waldinger. </author> <title> Fundamentals of deductive program synthesis. </title> <journal> IEEE Trans. on Soft. Eng. </journal> <volume> 18(8) </volume> <pages> 53-79, </pages> <year> 1992. </year>
Reference-contexts: (x) and O (x; y) are input and output relations, to verify the total correctness of a program P to compute r. (13) is almost identical to our conditional specification, although it is not used for specification purposes. 14 In general, constructive synthesis follows the `proofs as programs' ap-proach (e.g. <ref> [1, 19] </ref>). 7 A specification consists of an input-output theorem of the form 8x9y r (x; y) (14) From a proof of this theorem, a program to compute r can be extracted. In logic programming, however, the connection between deductive and constructive synthesis is particularly close.
Reference: [20] <author> P. Miglioli, U. Moscato and M. Ornaghi. </author> <title> Abstract parametric classes and abstract data types defined by classical and constructive logical methods. </title> <journal> J. Symb. Comp. </journal> <volume> 18 </volume> <pages> 41-81, </pages> <year> 1994. </year>
Reference: [21] <author> R.A. O'Keefe. </author> <title> What does subset mean? ALP Newsletter 8(3):10, </title> <month> August </month> <year> 1995. </year>
Reference-contexts: For example, consider the following Prolog program (in <ref> [21] </ref>) for subset : member (X, [X|_]). member (X, [_|Xs]) :- member (X, Xs). subset ([], _). subset ([X|Xs], Ys) :- member (X, Ys), subset (Xs, Ys). (1) As a program, the meaning of (1) is of course completely defined, for example, by the usual minimum model semantics. <p> For this reason, the intended meaning S of a program P used as an executable specification, needs to be specified separately. For instance, S for 2 (1) might be the following informal specification (also in <ref> [21] </ref>): "subset (X, Y) is to be true if: X and Y are two lists of integers and the set X represents is a subset of the set that Y represents." (2) Now, (2) uses the abstract data types of finite sets, lists, and integers, but it does not contain such
Reference: [22] <institution> J.M. Spivey. Understanding Z . Cambridge University Press, </institution> <year> 1988. </year>
Reference-contexts: If we follow the pre-post-condition style of program specification (e.g. <ref> [22, 13] </ref>), then a conditional specification defines a program P to compute r (x; y) in such a way that whenever IC (y) is satisfied, P satisfies OC (x) ^ R (x; y).
Reference: [23] <author> M. Wirsing. </author> <title> Algebraic specification. </title> <editor> In J. Van Leeuwen, editor, </editor> <booktitle> Handbook of Theoretical Computer Science, </booktitle> <pages> pages 675-788. </pages> <publisher> Elsevier, </publisher> <year> 1990. </year> <month> 17 </month>
Reference-contexts: Note that the syntax of a framework is similar to that used in algebraic abstract data types (e.g. <ref> [23] </ref>). 2 However, algebraic abstract data types are usually defined by equational or Horn axioms, whereas frameworks are defined by full first-order axioms. Therefore, an algebraic abstract data type is an initial model of its specification, whereas a framework has an isoinitial model.
References-found: 23

