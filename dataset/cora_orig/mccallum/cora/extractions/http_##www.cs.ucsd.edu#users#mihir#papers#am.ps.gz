URL: http://www.cs.ucsd.edu/users/mihir/papers/am.ps.gz
Refering-URL: http://www.cs.ucsd.edu/users/mihir/papers/complexity-papers.html
Root-URL: http://www.cs.ucsd.edu
Title: Randomness in Interactive Proofs  
Author: Mihir Bellare Oded Goldreich Shafi Goldwasser 
Keyword: Interactive proof systems, Arthur-Merlin games, randomness, sampling methods, error reduction, expander graphs, pairwise independence.  
Address: Israel.  545 Technology Square, Cambridge, MA 02139.  
Affiliation: Computer Science Department, Technion, Haifa,  MIT Laboratory for Computer Science,  
Note: Appears in Computational Complexity Vol. 3, 319-354, 1993. Preliminary version in FOCS 90.  Partially supported by grants No. 86-00301 and 89-00312 from the United States Israel Binational Science Foundation (BSF).  Supported in part by NSF grant No. CCR-8657527, DARPA grant No. DAAL03-86-K-0171 and grants No. 86-00301 and 89-00312 from the United States Israel Binational Science Foundation (BSF).  
Email: e-mail: oded@cs.technion.ac.il.  e-mail: shafi@theory.lcs.mit.edu.  
Date: February 1993  
Abstract: This paper initiates a study of the quantitative aspects of randomness in interactive proofs. Our main result, which applies to the equivalent form of IP known as Arthur-Merlin (AM) games, is a randomness-efficient technique for decreasing the error probability. Given an AM proof system for L which achieves error probability 1=3 at the cost of Arthur sending l(n) random bits per round, and given a polynomial k = k(n), we show how to construct an AM proof system for L which, in the same number of rounds as the original proof system, achieves error 2 k(n) at the cost of Arthur sending only O(l + k) random bits per round. Underlying the transformation is a novel sampling method for approximating the average value of an arbitrary function f : f0; 1g l ! [0; 1]. The method evaluates the function on O(* 2 log ffi 1 ) sample points generated using only O(l + log ffi 1 ) coin tosses to get an estimate which with probability at least 1 ffi is within * of the average value of the function. y Department of Computer Science & Engineering, Mail Code 0114, University of California at San Diego, 9500 Gilman Drive, La Jolla, CA 92093. E-mail: mihir@cs.ucsd.edu. Work done while author was at MIT, supported in part by NSF grant No. CCR-8719689 and DARPA grant No. N00014-89-J-1988. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> L. Adleman. </author> <title> Two Theorems on Random Polynomial Time. </title> <booktitle> Proceedings of the 19th Annual IEEE Symposium on the Foundations of Computer Science, IEEE (1978). </booktitle>
Reference-contexts: In general, not every result for RP and BPP translates easily (or at all) to a result on the class IP. Notable examples are results such as BPP equals almost-P [13] and BPP is contained in non-uniform P <ref> [1] </ref>. <p> The same tools lead to a novel sampling technique. The problem in question is to estimate the average value E [f ] def x2f0;1g l f (x) of a given function f : f0; 1g l ! <ref> [0; 1] </ref>. Our interest is in primitives for this task which we call (l; *; ffi)- approximators. Such an approximator is a two stage process. The first stage is randomized. <p> Our construction is optimal in the number of sample points, and, amongst the constructions that use this number of sample points, optimal in the number of coin tosses (both up to constant factors). It works for all functions f : f0; 1g l ! <ref> [0; 1] </ref>. It is interesting to note that (l; 1=6; ffi)-approximators for Boolean functions would suffice for error-reduction in BPP whereas our error-reduction for IP relies on (l; *; ffi)-approximators of arbitrary functions ranging in [0; 1] with * 1 being a polynomial. 5 1.6 Related Work Bellare and Rompel [11] <p> It works for all functions f : f0; 1g l ! <ref> [0; 1] </ref>. It is interesting to note that (l; 1=6; ffi)-approximators for Boolean functions would suffice for error-reduction in BPP whereas our error-reduction for IP relies on (l; *; ffi)-approximators of arbitrary functions ranging in [0; 1] with * 1 being a polynomial. 5 1.6 Related Work Bellare and Rompel [11] have investigated the randomness complexity of the operation of reducing the number of rounds of an AM game by one-half. <p> The error probability of A on input w with respect to a language L is defined as err L ( acc A (w) otherwise. The error probability of A with respect to L is the map from N ! <ref> [0; 1] </ref> whose value at n is sup jwj=n err L A (w). Thus an Arthur strategy A defines a proof system for L if its error probability with respect to L is 1=3. <p> Let c be positive and let A = (; G; l; q; s) be an Arthur strategy with error probability at most 1 2 n c with respect to the language L. Let *: N ! <ref> [0; 1] </ref> have polynomially bounded inverse. Then we can construct another Arthur strategy A fl = ( fl ; G; ffl; G 3 A n 2c * 1 q; s) with error probability at most * with respect to L. <p> For each i = 1; : : :; m define X i : f0; 1g c P l ! <ref> [0; 1] </ref> by X i (s) = acc A (w; r i 1 : : : r i t1 :P (1 l ; i; s)). <p> This concludes the proof of Theorem 5.1. 6 Randomness-Efficient Approximation Implicit in the previous sections is a new sampling method. An application of particular interest is to the problem of approximating the average value of an arbitrary real valued function. 6.1 Definitions For f : f0; 1g n ! <ref> [0; 1] </ref> we let E [f ] = 2 n P x2f0;1g n f (x) denote the average value of f . An (l; *; ffi)- approximator is a two stage process. <p> If F n is for each integer n a set of functions mapping f0; 1g n to <ref> [0; 1] </ref> then we will refer to F = fF n g as a class of functions. An approximator consists of a sampler S and an estimator E, and associated to it is the class of functions which it succeeds in approximating. <p> An approximator consists of a sampler S and an estimator E, and associated to it is the class of functions which it succeeds in approximating. Definition 6.3 Let l: N ! N and *; ffi: N ! <ref> [0; 1] </ref>. Let S be a (l; t; )-sampler and E a (l; t)- estimator, for some t; : N ! N. For each n and f : f0; 1g l (n) ! [0; 1] we define A n;f : f0; 1g (n) ! [0; 1] by and regard it as <p> Definition 6.3 Let l: N ! N and *; ffi: N ! <ref> [0; 1] </ref>. Let S be a (l; t; )-sampler and E a (l; t)- estimator, for some t; : N ! N. For each n and f : f0; 1g l (n) ! [0; 1] we define A n;f : f0; 1g (n) ! [0; 1] by and regard it as a random variable over the uniform distribution on f0; 1g (n) . <p> N and *; ffi: N ! <ref> [0; 1] </ref>. Let S be a (l; t; )-sampler and E a (l; t)- estimator, for some t; : N ! N. For each n and f : f0; 1g l (n) ! [0; 1] we define A n;f : f0; 1g (n) ! [0; 1] by and regard it as a random variable over the uniform distribution on f0; 1g (n) . <p> Let us now proceed to our theorem. Theorem 6.5 Let l: N ! N and *; ffi: N ! <ref> [0; 1] </ref> with l; * 1 and lg ffi 1 polynomially bounded and polynomial time computable. Then there exists an (l; *; ffi)-approximator for all functions which uses O (* 2 log ffi 1 ) sample points and O (l + log ffi 1 ) coin tosses. <p> For the analysis, fix f : f0; 1g l ! <ref> [0; 1] </ref>. Call a seed s 2 f0; 1g c P l bad if fi fi fi m i=1 fi fi fi where r i = P (1 n ; i; s) for i = 1; : : : ; m.
Reference: [2] <author> W. Aiello, S. Goldwasser and J. H -astad. </author> <title> On the Power of Interaction. </title> <type> Combinatorica 10(1), </type> <month> 3-25 </month> <year> (1990). </year>
Reference-contexts: If there is no randomness, then the prover can anticipate all the verifier's moves and IP would collapse to NP. So the real question lies in understanding what happens in between these extremes. In this regard, the role of interaction has received a lot of study <ref> [2, 5, 6, 7, 15] </ref>. The role of randomness remained, in contrast, unaddressed. This paper initiates a study of the role of randomness in interactive proofs. Below, we begin by reviewing some definitions and background, and briefly cover what is known on the role of interaction in interactive proof systems. <p> Moreover, the equivalence established by [28] preserves the number of rounds. The advantage of the AM formulation lies in its simpler combinatorial structure, and it is via AM games that most structural results (including ours and <ref> [5, 2, 6, 15, 11] </ref>) are proved. In the rest of this paper we consider AM proof systems. 1.2 The Role of Interaction Let AM [g (n)] denote the class of languages which possess AM proofs of membership of g (n) rounds of interaction. <p> Much attention has been devoted to understanding the hierarchy AM = IP = S c0 AM [n c ]. We now briefly review what is known. Babai [5] showed that any constant number of rounds is equivalent to two: AM [k] = AM <ref> [2] </ref> for any integer k 2. Later Babai and Moran [6] proved the "speedup" theorem which says that AM [2g (n)] = AM [g (n)] for any polynomial g (n). 1 Note that the speedup cannot be iterated more than a constant number of times. <p> Later Babai and Moran [6] proved the "speedup" theorem which says that AM [2g (n)] = AM [g (n)] for any polynomial g (n). 1 Note that the speedup cannot be iterated more than a constant number of times. In particular, whether or not AM = AM <ref> [2] </ref> remains an open question. <p> In the process they also provide a simpler proof of the speedup theorem. 3 round interactive proofs by showing that if it did, then the polynomial time hierarchy would collapse to the second level. Aiello, Goldwasser and H-astad <ref> [2] </ref> show that if ff (n) ! 1 then there are oracles separating AM [g (n)] from AM [g (n)=ff (n)]. However, we note that the results of [36, 42] indicate that rela-tivized separations are not evidence of real separations, for although IP=PSPACE, a random oracle separates them [29, 19]. <p> However, we note that the results of [36, 42] indicate that rela-tivized separations are not evidence of real separations, for although IP=PSPACE, a random oracle separates them [29, 19]. So a better than constant factor collapse in IP need not be ruled out by the relativized separation results of <ref> [2] </ref>. 1.3 Our Results The results in this paper represent the first attempt to understand the role of randomness in interactive proofs in a quantitative sense. The specific problem we consider is that of reducing the error probability of an Arthur-Merlin game in a randomness-efficient manner.
Reference: [3] <author> M. Ajtai, J. Komlos and E. Szemeredi. </author> <title> Deterministic Simulation in Logspace. </title> <booktitle> Proceedings of the 19th Annual ACM Symposium on the Theory of Computing, ACM (1987). </booktitle>
Reference-contexts: Cohen and Wigderson [20] and Impagliazzo and Zuckermann [33], using techniques of 4 Ajtai, Komlos and Szemeredi <ref> [3] </ref>, showed how the error could be decreased to 2 k at the cost of O (r + k) coins for any polynomially bounded k = k (n). <p> Error-reduction for AM games, however, seems more difficult to handle. The above mentioned techniques <ref> [44, 40, 34, 18, 20, 33, 3] </ref> are not directly applicable here as we are not dealing with witness-sets which are fixed beforehand, but rather with an adversary (cheating Merlin) that dynamically guides, by his responses to the verifier's coins, the search of the verifier for rejecting computations. <p> Furthermore, techniques based on assumptions of computational difficulty are of no use against a prover who has the power to invert one-way functions. Thus the verifier cannot use pseudo-random sequences in place of random ones. We note however that our construction will exploit techniques from [18] and <ref> [3] </ref>, but in a different manner. In general, not every result for RP and BPP translates easily (or at all) to a result on the class IP. Notable examples are results such as BPP equals almost-P [13] and BPP is contained in non-uniform P [1]. <p> Then P [Y j 1 2 B j 1 ; : : :; Y j b 2 B j b ] (2*) b=2 . We call the expansion constant of G; it depends only on the second eigenvalue of G. A proof of Lemma 5.6, following the ideas of <ref> [3] </ref>, appears in Appendix B. <p> A somewhat coarser kind of approximation to the average of a boolean function f : f0; 1g l ! f0; 1g can be obtained via a random walk on a 2 l node explicitly constructed expander graph (cf. <ref> [3, 20, 33] </ref>). For example, if E [f ] 99=100 then we can use O (l + log ffi 1 ) random bits to generate O (log ffi 1 ) sample points such that the average of f on these sample points is 2=3 with probability 1 ffi.
Reference: [4] <author> N. Alon. </author> <title> Eigenvalues and Expanders. </title> <type> Combinatorica 6(2), </type> <month> 83-96 </month> <year> (1986). </year>
Reference-contexts: Gabber and Galil [23] demonstrate the existence of families of explicitly constructible, d-regular, bipartite expanders. It will be convenient for us to assume the degree d is a power of 2. By adding edges we can easily modify the construction of [23] to achieve this; via Alon's result <ref> [4] </ref> we can be sure that the resulting graph is still an expander. To summarize: Theorem 5.5 [23] There exists an explicitly constructible family of d-regular expanders with the degree d being a power of 2.
Reference: [5] <author> L. Babai. </author> <title> Trading Group Theory for Randomness. </title> <booktitle> Proceedings of the 17th Annual ACM Symposium on the Theory of Computing, ACM (1985). </booktitle>
Reference-contexts: However, in the above mentioned development, the potential power of interactive proofs to serve as proof systems for languages outside NP was not taken advantage of. First indications to such potential were presented by Babai <ref> [5] </ref> and Goldreich, Micali and Wigderson [26]. But it is only in the last two years that a full understanding of the power of interactive proofs has emerged. <p> If there is no randomness, then the prover can anticipate all the verifier's moves and IP would collapse to NP. So the real question lies in understanding what happens in between these extremes. In this regard, the role of interaction has received a lot of study <ref> [2, 5, 6, 7, 15] </ref>. The role of randomness remained, in contrast, unaddressed. This paper initiates a study of the role of randomness in interactive proofs. Below, we begin by reviewing some definitions and background, and briefly cover what is known on the role of interaction in interactive proof systems. <p> This error probability can be decreased to 2 k (n) for any polynomial k (n) by standard techniques. Let IP denote the class of languages that possess interactive proofs. Arthur-Merlin (AM) games, introduced by Babai <ref> [5] </ref> (see also Babai and Moran [6]), can be viewed as special kinds of interactive proof systems; they are sometimes called interactive proof systems with public coins. Merlin is the prover and Arthur the verifier. <p> Moreover, the equivalence established by [28] preserves the number of rounds. The advantage of the AM formulation lies in its simpler combinatorial structure, and it is via AM games that most structural results (including ours and <ref> [5, 2, 6, 15, 11] </ref>) are proved. In the rest of this paper we consider AM proof systems. 1.2 The Role of Interaction Let AM [g (n)] denote the class of languages which possess AM proofs of membership of g (n) rounds of interaction. <p> Much attention has been devoted to understanding the hierarchy AM = IP = S c0 AM [n c ]. We now briefly review what is known. Babai <ref> [5] </ref> showed that any constant number of rounds is equivalent to two: AM [k] = AM [2] for any integer k 2. <p> It is well known that this error probability can be decreased to 2 k for any polynomially bounded k = k (n) by running the game O (k) times in parallel and taking a majority vote on the outcomes <ref> [5, 6] </ref>. Note that this maintains the number of rounds. Supposing that Arthur sent l = l (n) random bits per round in the original game, this results in a game in each round of which Arthur sends O (lk) random bits. <p> Specifically, appropriate reductions in the randomness complexity of error reduction for two prover one round proof systems would lead to improvement of the results of [9, 22, 8, 37]. 2 Preliminaries We review definitions and notation for the Arthur-Merlin games of Babai <ref> [5] </ref> and Babai and Moran [6], introduce the accepting probability function, and conclude by showing we can without loss of generality restrict our attention to a special case. 2.1 Arthur-Merlin Games An Arthur-Merlin game has two players called Merlin and Arthur. <p> As we said above, it actually suffices to consider an "optimal Merlin" that chooses all its messages in a way maximizing Arthur's accepting probability. This leads to the much more convenient formulation of Arthur-Merlin games in terms of max-average combinatorial games as developed by <ref> [5, 6] </ref>. We capture this formulation below with the definition of the accepting probability function of the game. Note that the optimal Merlin strategy depends on the Arthur strategy A. <p> For any Arthur strategy A we fix a particular optimal Merlin strategy which we denote by M opt 2.3 The Accepting Probability Function The game tree and its accepting probability function which we now describe are a convenient way of analyzing an Arthur Merlin game (cf. <ref> [5, 6] </ref>). Fix an input length n. We visualize a tree of depth equal to the number of moves 2g (n). Nodes in this tree are named according to their level: those at even levels are called Arthur nodes while those at odd levels are called Merlin nodes. <p> As an introduction to our error-reduction technique it is helpful to review the standard one <ref> [5, 6] </ref>. Given A = (; g; l; q) defining an Arthur-Merlin proof system for L with error 1=3 we are required to design A fl defining an error 2 k Arthur-Merlin proof system for L.
Reference: [6] <author> L. Babai and S. Moran. </author> <title> Arthur-Merlin Games: A Randomized Proof System, and a Hierarchy of Complexity Classes. </title> <journal> J. Computer and System Sciences 36, </journal> <month> 254-276 </month> <year> (1988). </year>
Reference-contexts: If there is no randomness, then the prover can anticipate all the verifier's moves and IP would collapse to NP. So the real question lies in understanding what happens in between these extremes. In this regard, the role of interaction has received a lot of study <ref> [2, 5, 6, 7, 15] </ref>. The role of randomness remained, in contrast, unaddressed. This paper initiates a study of the role of randomness in interactive proofs. Below, we begin by reviewing some definitions and background, and briefly cover what is known on the role of interaction in interactive proof systems. <p> This error probability can be decreased to 2 k (n) for any polynomial k (n) by standard techniques. Let IP denote the class of languages that possess interactive proofs. Arthur-Merlin (AM) games, introduced by Babai [5] (see also Babai and Moran <ref> [6] </ref>), can be viewed as special kinds of interactive proof systems; they are sometimes called interactive proof systems with public coins. Merlin is the prover and Arthur the verifier. Merlin plays just like a prover in an interactive proof system; the specialty is in the role of Arthur. <p> Moreover, the equivalence established by [28] preserves the number of rounds. The advantage of the AM formulation lies in its simpler combinatorial structure, and it is via AM games that most structural results (including ours and <ref> [5, 2, 6, 15, 11] </ref>) are proved. In the rest of this paper we consider AM proof systems. 1.2 The Role of Interaction Let AM [g (n)] denote the class of languages which possess AM proofs of membership of g (n) rounds of interaction. <p> We now briefly review what is known. Babai [5] showed that any constant number of rounds is equivalent to two: AM [k] = AM [2] for any integer k 2. Later Babai and Moran <ref> [6] </ref> proved the "speedup" theorem which says that AM [2g (n)] = AM [g (n)] for any polynomial g (n). 1 Note that the speedup cannot be iterated more than a constant number of times. In particular, whether or not AM = AM [2] remains an open question. <p> In particular, whether or not AM = AM [2] remains an open question. Boppana, H-astad and Zachos [15] provide some indication that co-NP does not have constant 1 In constructing a g (n) round Arthur-Merlin proof system for L from a 2g (n) round one, the proof of <ref> [6] </ref> blows up the message lengths of both parties by large polynomial factors. Recently, Bellare and Rompel [11] were able to reduce the randomness part of this blowup; see x1.6 for details. <p> It is well known that this error probability can be decreased to 2 k for any polynomially bounded k = k (n) by running the game O (k) times in parallel and taking a majority vote on the outcomes <ref> [5, 6] </ref>. Note that this maintains the number of rounds. Supposing that Arthur sent l = l (n) random bits per round in the original game, this results in a game in each round of which Arthur sends O (lk) random bits. <p> This improves on the construction of <ref> [6] </ref> in which Arthur sent O (lqg 3 log g) random bits per round in the g (n) round game. Of particular interest is the case where the message lengths of both parties are the same; here the blowup of [6] is polynomial while that of [11] is logarithmic. <p> This improves on the construction of <ref> [6] </ref> in which Arthur sent O (lqg 3 log g) random bits per round in the g (n) round game. Of particular interest is the case where the message lengths of both parties are the same; here the blowup of [6] is polynomial while that of [11] is logarithmic. We looked at how the power of IP varies with the amount of randomness. A different direction was taken by Schrift [41] who investigated how the power of an interactive proof varies with the quality of the random bits used. <p> Specifically, appropriate reductions in the randomness complexity of error reduction for two prover one round proof systems would lead to improvement of the results of [9, 22, 8, 37]. 2 Preliminaries We review definitions and notation for the Arthur-Merlin games of Babai [5] and Babai and Moran <ref> [6] </ref>, introduce the accepting probability function, and conclude by showing we can without loss of generality restrict our attention to a special case. 2.1 Arthur-Merlin Games An Arthur-Merlin game has two players called Merlin and Arthur. <p> As we said above, it actually suffices to consider an "optimal Merlin" that chooses all its messages in a way maximizing Arthur's accepting probability. This leads to the much more convenient formulation of Arthur-Merlin games in terms of max-average combinatorial games as developed by <ref> [5, 6] </ref>. We capture this formulation below with the definition of the accepting probability function of the game. Note that the optimal Merlin strategy depends on the Arthur strategy A. <p> For any Arthur strategy A we fix a particular optimal Merlin strategy which we denote by M opt 2.3 The Accepting Probability Function The game tree and its accepting probability function which we now describe are a convenient way of analyzing an Arthur Merlin game (cf. <ref> [5, 6] </ref>). Fix an input length n. We visualize a tree of depth equal to the number of moves 2g (n). Nodes in this tree are named according to their level: those at even levels are called Arthur nodes while those at odd levels are called Merlin nodes. <p> More formally, we have the following definition of the accepting probability function for an Arthur strategy A = (; g; l; q; 1). This is a variation of what <ref> [6] </ref> call the payoff function. * The value at a conversation (leaf of the tree) is the value of A's deciding predicate: acc A (w; r 1 y 1 : : : r g y g ) = (w; r 1 y 1 : : : r g y g ) <p> As an introduction to our error-reduction technique it is helpful to review the standard one <ref> [5, 6] </ref>. Given A = (; g; l; q) defining an Arthur-Merlin proof system for L with error 1=3 we are required to design A fl defining an error 2 k Arthur-Merlin proof system for L.
Reference: [7] <author> L. Babai and S. Moran. </author> <title> Proving Properties of Interactive Proofs by a Generalized Counting Technique. </title> <booktitle> Information and Computation 82, </booktitle> <month> 185-197 </month> <year> (1989). </year>
Reference-contexts: If there is no randomness, then the prover can anticipate all the verifier's moves and IP would collapse to NP. So the real question lies in understanding what happens in between these extremes. In this regard, the role of interaction has received a lot of study <ref> [2, 5, 6, 7, 15] </ref>. The role of randomness remained, in contrast, unaddressed. This paper initiates a study of the role of randomness in interactive proofs. Below, we begin by reviewing some definitions and background, and briefly cover what is known on the role of interaction in interactive proof systems.
Reference: [8] <author> M. Bellare. </author> <title> Interactive Proofs and Approximation. </title> <note> IBM Research Report RC 17969 (May 1992). </note>
Reference-contexts: Specifically, appropriate reductions in the randomness complexity of error reduction for two prover one round proof systems would lead to improvement of the results of <ref> [9, 22, 8, 37] </ref>. 2 Preliminaries We review definitions and notation for the Arthur-Merlin games of Babai [5] and Babai and Moran [6], introduce the accepting probability function, and conclude by showing we can without loss of generality restrict our attention to a special case. 2.1 Arthur-Merlin Games An Arthur-Merlin game
Reference: [9] <author> M. Bellare and P. Rogaway. </author> <title> The Complexity of Approximating a Nonlinear program. IBM Research Report RC 17831 (March 1992). </title> <type> 22 </type>
Reference-contexts: Specifically, appropriate reductions in the randomness complexity of error reduction for two prover one round proof systems would lead to improvement of the results of <ref> [9, 22, 8, 37] </ref>. 2 Preliminaries We review definitions and notation for the Arthur-Merlin games of Babai [5] and Babai and Moran [6], introduce the accepting probability function, and conclude by showing we can without loss of generality restrict our attention to a special case. 2.1 Arthur-Merlin Games An Arthur-Merlin game
Reference: [10] <author> M. Bellare and J. Rompel. </author> <title> Randomness-Efficient Sampling of Arbitrary Functions. </title> <type> MIT LCS Tech. </type> <note> Memo. TM-433. </note>
Reference-contexts: This requires O (tl) coin tosses and t function evaluations. The construction of randomness-efficient (l; *; ffi)-approximators has been a subject of much research, but existing constructions <ref> [18, 10, 11, 20, 33, 38] </ref> that save coins over the standard one suffer from various restrictions (see x6 for details). <p> For the purpose of the discussion that follows it is helpful to have the following Definition 6.4 <ref> [10, 11] </ref> An (l; *; ffi)-approximator (S; E) is called oblivious if E (1 n ; (x 1 ; : : : ; x t (n) )) = t (n) i=1 for all n and (x 1 ; : : : ; x t (n) ) 2 R l (n) , <p> Using higher independence and an iterated sampling technique, Bellare and Rompel <ref> [10, 11] </ref> are able to remove this restriction.
Reference: [11] <author> M. Bellare and J. Rompel. </author> <title> Trading Interaction for Randomness: Speedup at Logarithmic Cost. </title> <booktitle> Manuscript (1991). Presented at DIMACS Workshop on Structural Complexity and Cryptography, Rutgers 1990. </booktitle>
Reference-contexts: Moreover, the equivalence established by [28] preserves the number of rounds. The advantage of the AM formulation lies in its simpler combinatorial structure, and it is via AM games that most structural results (including ours and <ref> [5, 2, 6, 15, 11] </ref>) are proved. In the rest of this paper we consider AM proof systems. 1.2 The Role of Interaction Let AM [g (n)] denote the class of languages which possess AM proofs of membership of g (n) rounds of interaction. <p> Recently, Bellare and Rompel <ref> [11] </ref> were able to reduce the randomness part of this blowup; see x1.6 for details. In the process they also provide a simpler proof of the speedup theorem. 3 round interactive proofs by showing that if it did, then the polynomial time hierarchy would collapse to the second level. <p> This requires O (tl) coin tosses and t function evaluations. The construction of randomness-efficient (l; *; ffi)-approximators has been a subject of much research, but existing constructions <ref> [18, 10, 11, 20, 33, 38] </ref> that save coins over the standard one suffer from various restrictions (see x6 for details). <p> It is interesting to note that (l; 1=6; ffi)-approximators for Boolean functions would suffice for error-reduction in BPP whereas our error-reduction for IP relies on (l; *; ffi)-approximators of arbitrary functions ranging in [0; 1] with * 1 being a polynomial. 5 1.6 Related Work Bellare and Rompel <ref> [11] </ref> have investigated the randomness complexity of the operation of reducing the number of rounds of an AM game by one-half. <p> Of particular interest is the case where the message lengths of both parties are the same; here the blowup of [6] is polynomial while that of <ref> [11] </ref> is logarithmic. We looked at how the power of IP varies with the amount of randomness. A different direction was taken by Schrift [41] who investigated how the power of an interactive proof varies with the quality of the random bits used. <p> For the purpose of the discussion that follows it is helpful to have the following Definition 6.4 <ref> [10, 11] </ref> An (l; *; ffi)-approximator (S; E) is called oblivious if E (1 n ; (x 1 ; : : : ; x t (n) )) = t (n) i=1 for all n and (x 1 ; : : : ; x t (n) ) 2 R l (n) , <p> Obliviousness is useful in some applications (cf. <ref> [11] </ref>). 6.2 Approximation Methods The standard approximation method is to select t = O (* 2 log ffi 1 ) independent and uniformly distributed sample points and use as estimate the average value of the function on these sample points. <p> Using higher independence and an iterated sampling technique, Bellare and Rompel <ref> [10, 11] </ref> are able to remove this restriction.
Reference: [12] <author> M. Ben-Or, S. Goldwasser, J. Kilian and A. Wigderson. </author> <title> Multi-Prover Interactive Proofs: How to Remove Intractability Assumptions. </title> <booktitle> Proceedings of the 20th Annual ACM Symposium on the Theory of Computing, ACM (1988). </booktitle>
Reference-contexts: Namely, although there are many results known on reducing interaction, nothing is known about reducing randomness. A specific question is to find a randomness-efficient technique of reducing the error probability of a zero-knowledge proof. Another problem is to device methods for randomness-efficient error-reduction in multi-prover interactive proof systems <ref> [12] </ref>. This is particularly interesting in the context of the recent use of multi-prover proof systems to derive results on the hardness of approximation of optimization problems.
Reference: [13] <author> C. Bennet and J. Gill. </author> <title> Relative to a random Oracle A, P A 6= NP A 6= coNP A , with probability 1. </title> <journal> SIAM J. on Computing 10, </journal> <month> 96-113 </month> <year> (1981). </year>
Reference-contexts: We note however that our construction will exploit techniques from [18] and [3], but in a different manner. In general, not every result for RP and BPP translates easily (or at all) to a result on the class IP. Notable examples are results such as BPP equals almost-P <ref> [13] </ref> and BPP is contained in non-uniform P [1].
Reference: [14] <author> M. Blum and S. Micali. </author> <title> How to Generate Cryptographically Strong Sequences of Pseudo-Random Bits. </title> <note> SIAM Journal on Computing 13 (4), </note> <month> 850-864 </month> <year> (1984). </year>
Reference-contexts: Cohen and Wigderson [20] and Impagliazzo and Zuckermann [33], using techniques of 4 Ajtai, Komlos and Szemeredi [3], showed how the error could be decreased to 2 k at the cost of O (r + k) coins for any polynomially bounded k = k (n). Furthermore, pseudo-random sequences <ref> [14, 45] </ref> can be used to decrease the error of any BPP algorithm to n c while using only n * coins, for any constants * and c.
Reference: [15] <author> R. Boppana, J. Hastad and S. Zachos. </author> <title> Does coNP have Short Interactive Proofs? Info. </title> <journal> Processing Letters 25, </journal> <month> 127-132 </month> <year> (1987). </year>
Reference-contexts: If there is no randomness, then the prover can anticipate all the verifier's moves and IP would collapse to NP. So the real question lies in understanding what happens in between these extremes. In this regard, the role of interaction has received a lot of study <ref> [2, 5, 6, 7, 15] </ref>. The role of randomness remained, in contrast, unaddressed. This paper initiates a study of the role of randomness in interactive proofs. Below, we begin by reviewing some definitions and background, and briefly cover what is known on the role of interaction in interactive proof systems. <p> Moreover, the equivalence established by [28] preserves the number of rounds. The advantage of the AM formulation lies in its simpler combinatorial structure, and it is via AM games that most structural results (including ours and <ref> [5, 2, 6, 15, 11] </ref>) are proved. In the rest of this paper we consider AM proof systems. 1.2 The Role of Interaction Let AM [g (n)] denote the class of languages which possess AM proofs of membership of g (n) rounds of interaction. <p> In particular, whether or not AM = AM [2] remains an open question. Boppana, H-astad and Zachos <ref> [15] </ref> provide some indication that co-NP does not have constant 1 In constructing a g (n) round Arthur-Merlin proof system for L from a 2g (n) round one, the proof of [6] blows up the message lengths of both parties by large polynomial factors.
Reference: [16] <author> R. Canetti, G. Even and O. Goldreich. </author> <title> Lower bounds for sampling algorithms for estimating the average. </title> <institution> TR-686, Computer Science Dept., Technion, Haifa, Israel, </institution> <month> August </month> <year> 1991. </year>
Reference-contexts: Up to constant factors, the number of sample points used by our method is optimal. Namely, any (l; *; ffi)-approximator (even for just the class of boolean functions) must use (* 2 log ffi 1 ) sample points (cf. <ref> [16] </ref>). Furthermore, among methods using the optimal number of sample points, our method is nearly optimal in the number of coin tosses used (for a wide range of natural choices for the parameters). <p> Namely, any (l; *; ffi)-approximator (even for boolean functions) which uses O (* 2 log ffi 1 ) sample points must use at least l+lg ffi 1 lg * 2 O (1) coin tosses (cf. <ref> [16] </ref> and consider ffi &lt; * !(1) ). Let us now proceed to our theorem. Theorem 6.5 Let l: N ! N and *; ffi: N ! [0; 1] with l; * 1 and lg ffi 1 polynomially bounded and polynomial time computable.
Reference: [17] <author> L. Carter and M. Wegman. </author> <title> Universal Classes of Hash Functions. </title> <journal> J. Computer and System Sciences 18, </journal> <month> 143-154 </month> <year> (1979). </year>
Reference-contexts: a O (l) bit string s and, in time polynomial in l and m, specify a sequence of m 2 l strings of l bits each with the property that if s is chosen at random then the resulting sequence is pairwise independent and uniform over f0; 1g l (cf. <ref> [17] </ref>). Accordingly, we make the following Definition 4.4 Let P (; ; ) be a polynomial time algorithm which outputs strings of length equal to the length of its first input.
Reference: [18] <author> B. Chor and O. Goldreich. </author> <title> On the Power of Two-Point Based Sampling. </title> <editor> J. </editor> <booktitle> of Complexity 5, </booktitle> <month> 96-106 </month> <year> (1989). </year>
Reference-contexts: That such randomness-efficient error-reduction was possible was pointed out, non-constructively, by Sipser [44] and Santha [40]. The first constructions were obtained by Karp, Pippinger and Sipser [34] and Chor and Goldreich <ref> [18] </ref>, who showed that the error-probability of a BPP algorithm which used r = r (n) coin tosses could be reduced to n c for any given constant c while using only O (r) coin tosses. <p> Error-reduction for AM games, however, seems more difficult to handle. The above mentioned techniques <ref> [44, 40, 34, 18, 20, 33, 3] </ref> are not directly applicable here as we are not dealing with witness-sets which are fixed beforehand, but rather with an adversary (cheating Merlin) that dynamically guides, by his responses to the verifier's coins, the search of the verifier for rejecting computations. <p> Furthermore, techniques based on assumptions of computational difficulty are of no use against a prover who has the power to invert one-way functions. Thus the verifier cannot use pseudo-random sequences in place of random ones. We note however that our construction will exploit techniques from <ref> [18] </ref> and [3], but in a different manner. In general, not every result for RP and BPP translates easily (or at all) to a result on the class IP. Notable examples are results such as BPP equals almost-P [13] and BPP is contained in non-uniform P [1]. <p> This requires O (tl) coin tosses and t function evaluations. The construction of randomness-efficient (l; *; ffi)-approximators has been a subject of much research, but existing constructions <ref> [18, 10, 11, 20, 33, 38] </ref> that save coins over the standard one suffer from various restrictions (see x6 for details). <p> It is well known that pairwise independent generators exist. For completeness, let us sketch two implementations. The first implementation <ref> [18] </ref> uses finite fields. We identify the sets f0; 1g l and [2 l ] with GF (2 l ). <p> Chor and Goldreich <ref> [18] </ref>). The cost is in the number of sample points which now grows in proportion to ffi 1 rather than the lg ffi 1 of the standard method; if we want the number of sample points to be polynomial in n then we cannot attain exponentially small (in n) error.
Reference: [19] <author> R. Chang, B. Chor, O. Goldreich, J. Hartmanis, J. H -astad, D. Ranjan, and P. Rohatgi. </author> <title> The Random Oracle Hypothesis is False. </title> <note> Submitted to JCSS </note> . 
Reference-contexts: However, we note that the results of [36, 42] indicate that rela-tivized separations are not evidence of real separations, for although IP=PSPACE, a random oracle separates them <ref> [29, 19] </ref>. So a better than constant factor collapse in IP need not be ruled out by the relativized separation results of [2]. 1.3 Our Results The results in this paper represent the first attempt to understand the role of randomness in interactive proofs in a quantitative sense.
Reference: [20] <author> A. Cohen and A. Wigderson. Dispersers, </author> <title> Deterministic Amplification, and Weak Random Sources. </title> <booktitle> Proceedings of the 30th Annual IEEE Symposium on the Foundations of Computer Science, IEEE (1989). </booktitle>
Reference-contexts: Cohen and Wigderson <ref> [20] </ref> and Impagliazzo and Zuckermann [33], using techniques of 4 Ajtai, Komlos and Szemeredi [3], showed how the error could be decreased to 2 k at the cost of O (r + k) coins for any polynomially bounded k = k (n). <p> Furthermore, pseudo-random sequences [14, 45] can be used to decrease the error of any BPP algorithm to n c while using only n * coins, for any constants * and c. Coupling this with the results of <ref> [20, 33] </ref> and [32, 30], we get that the existence of one-way functions implies that the error of any BPP algorithm can be reduced to 2 k while using only n * + O (k) coins, for any constant * &gt; 0. <p> Error-reduction for AM games, however, seems more difficult to handle. The above mentioned techniques <ref> [44, 40, 34, 18, 20, 33, 3] </ref> are not directly applicable here as we are not dealing with witness-sets which are fixed beforehand, but rather with an adversary (cheating Merlin) that dynamically guides, by his responses to the verifier's coins, the search of the verifier for rejecting computations. <p> This requires O (tl) coin tosses and t function evaluations. The construction of randomness-efficient (l; *; ffi)-approximators has been a subject of much research, but existing constructions <ref> [18, 10, 11, 20, 33, 38] </ref> that save coins over the standard one suffer from various restrictions (see x6 for details). <p> A somewhat coarser kind of approximation to the average of a boolean function f : f0; 1g l ! f0; 1g can be obtained via a random walk on a 2 l node explicitly constructed expander graph (cf. <ref> [3, 20, 33] </ref>). For example, if E [f ] 99=100 then we can use O (l + log ffi 1 ) random bits to generate O (log ffi 1 ) sample points such that the average of f on these sample points is 2=3 with probability 1 ffi. <p> Namely, a BPP algorithm which has error 1=3 with respect to L and uses r = r (n) coins can be transformed into one which has error 2 k and uses O (r + k) coins <ref> [20, 33] </ref>. * Can our result be generalized to (general) interactive proof systems? We do not know of any direct non-trivial error-reduction technique for general interactive proof systems. <p> A BPP algorithm which has error 1=3 with respect to L and uses r = r (n) coins can be transformed, for any constant c &gt; 0, into one which has error n c and still uses only r coins (a result of [34] described in <ref> [20] </ref>) and one can then apply [20, 33] to reduce the error to 2 k at the cost of O (k) additional coins. Acknowledgments We thank John Rompel for many valuable ideas and discussions in the early stages of this research. We also thank Silvio Micali for many helpful discussions. <p> algorithm which has error 1=3 with respect to L and uses r = r (n) coins can be transformed, for any constant c &gt; 0, into one which has error n c and still uses only r coins (a result of [34] described in [20]) and one can then apply <ref> [20, 33] </ref> to reduce the error to 2 k at the cost of O (k) additional coins. Acknowledgments We thank John Rompel for many valuable ideas and discussions in the early stages of this research. We also thank Silvio Micali for many helpful discussions.
Reference: [21] <author> S. Cook. </author> <title> The Complexity of Theorem Proving Procedures. </title> <booktitle> Proceedings of the 3rd Annual ACM Symposium on the Theory of Computing, ACM (1971). </booktitle>
Reference-contexts: 1 Introduction The notion of an "efficiently verifiable proof" plays a fundamental role in the study of efficient computation. Traditionally this notion is associated with the complexity class NP <ref> [21] </ref>, the set of languages with short (polynomial length) and polynomial-time verifiable proofs of membership. In other words, NP as a proof system consists of a prover who provides a short proof and a verifier who checks it.
Reference: [22] <author> U. Feige and L. Lov asz. </author> <title> Two-Prover One Round Proof Systems: Their Power and their Problems. </title> <booktitle> Proceedings of the 24th Annual ACM Symposium on the Theory of Computing, ACM (1992). </booktitle>
Reference-contexts: Specifically, appropriate reductions in the randomness complexity of error reduction for two prover one round proof systems would lead to improvement of the results of <ref> [9, 22, 8, 37] </ref>. 2 Preliminaries We review definitions and notation for the Arthur-Merlin games of Babai [5] and Babai and Moran [6], introduce the accepting probability function, and conclude by showing we can without loss of generality restrict our attention to a special case. 2.1 Arthur-Merlin Games An Arthur-Merlin game
Reference: [23] <author> O. Gabber and Z. Galil. </author> <title> Explicit Construction of Linear Sized Superconcentrators. </title> <journal> J. Computer and System Sciences 22, </journal> <month> 407-420 </month> <year> (1981). </year>
Reference-contexts: We call 2 (G) = sup l1 2 (G l ) the second eigenvalue of G. Definition 5.4 Let G be a family of d-regular graphs. We call G a (family of) expanders if 2 (G) &lt; 1. Gabber and Galil <ref> [23] </ref> demonstrate the existence of families of explicitly constructible, d-regular, bipartite expanders. It will be convenient for us to assume the degree d is a power of 2. By adding edges we can easily modify the construction of [23] to achieve this; via Alon's result [4] we can be sure that <p> Gabber and Galil <ref> [23] </ref> demonstrate the existence of families of explicitly constructible, d-regular, bipartite expanders. It will be convenient for us to assume the degree d is a power of 2. By adding edges we can easily modify the construction of [23] to achieve this; via Alon's result [4] we can be sure that the resulting graph is still an expander. To summarize: Theorem 5.5 [23] There exists an explicitly constructible family of d-regular expanders with the degree d being a power of 2. <p> By adding edges we can easily modify the construction of <ref> [23] </ref> to achieve this; via Alon's result [4] we can be sure that the resulting graph is still an expander. To summarize: Theorem 5.5 [23] There exists an explicitly constructible family of d-regular expanders with the degree d being a power of 2. Let G be a d-regular undirected graph and A the matrix obtained by dividing every entry of the adjacency matrix of G by d.
Reference: [24] <author> O. Goldreich, R. Impagliazzo, L. Levin, R. Venkatesan and D. Zuckermann. </author> <title> Security Preserving Amplification of Hardness. </title> <booktitle> Proceedings of the 31st Annual IEEE Symposium on the Foundations of Computer Science, IEEE (1990). </booktitle>
Reference-contexts: We call the expansion constant of G; it depends only on the second eigenvalue of G. A proof of Lemma 5.6, following the ideas of [3], appears in Appendix B. A variant of this lemma appears in <ref> [24] </ref>. 5.2 The Protocol: Overview We will play in parallel v = O (k= log (kg)) copies of the game presented in x4, setting m such that the error in each of these games is at most an appropriately chosen *.
Reference: [25] <author> O. Goldreich and L. Levin. </author> <title> A Hard-Core Predicate for any One-Way Function. </title> <booktitle> Proceedings of the 21st Annual ACM Symposium on the Theory of Computing, ACM (1989). </booktitle>
Reference-contexts: So the above implementation is optimal in the number of random bits used. Goldreich and Levin <ref> [25] </ref> propose an alternative implementation which, although it uses slightly more random bits, has the advantage of being more efficient in practice. <p> In order to describe it we first recall that a l-by-l matrix [a ij ] is Toeplitz if a i;j = a i1;j1 for each i; j = 2; : : :; l, and thus such a matrix is specified by its first row and column. The implementation of <ref> [25] </ref> consists of using a 3l 1 bit seed s to specify an l bit vector b and an l by l (0; 1)-Toeplitz matrix M and setting P (1 l ; i; s) = M i + b, where i is being regarded as a l bit vector and the
Reference: [26] <author> O. Goldreich, S. Micali and A. Wigderson. </author> <title> Proofs that Yield Nothing but their Validity or All Languages in NP have Zero-Knowledge Proof Systems. </title> <journal> Journal of the ACM 38(1), </journal> <month> 691-729 </month> <year> (1991). </year>
Reference-contexts: The original motivation for their introduction was the introduction of zero-knowledge interactive proofs [27], which in turn were suggested as a principal tool for cryptographic protocol design [27]. The wide applicability of this tool was demonstrated by Goldreich, Micali and Wigderson <ref> [26] </ref>, yielding a dramatic effect on the theory and practice of cryptography. However, in the above mentioned development, the potential power of interactive proofs to serve as proof systems for languages outside NP was not taken advantage of. <p> However, in the above mentioned development, the potential power of interactive proofs to serve as proof systems for languages outside NP was not taken advantage of. First indications to such potential were presented by Babai [5] and Goldreich, Micali and Wigderson <ref> [26] </ref>. But it is only in the last two years that a full understanding of the power of interactive proofs has emerged. Lund, Fortnow, Karloff and Nisan [36] showed that IP contains the polynomial time hierarchy, and Shamir [42] extended this to show that IP equals PSPACE.
Reference: [27] <author> S. Goldwasser, S. Micali and C. Rackoff. </author> <title> The Knowledge Complexity of Interactive Proofs. </title> <journal> SIAM J. Computing 18(1), </journal> <month> 186-208 </month> <year> (1989). </year>
Reference-contexts: How the prover found the proof is immaterial; as long as the verifier can check it via some mechanical procedure then the proof is valid. More recently, Goldwasser, Micali and Rackoff suggested that the notion of "efficiently verifiable proofs" be extended to include interactive proof systems <ref> [27] </ref>. Interactive proof systems augment NP proof systems with two ingredients: interaction and randomness. The verifier is now no longer a silent partner; he is allowed to ask the prover questions. <p> IP is the class of languages possessing interactive proofs of membership. Since their inception interactive proofs have proven to be very useful. The original motivation for their introduction was the introduction of zero-knowledge interactive proofs <ref> [27] </ref>, which in turn were suggested as a principal tool for cryptographic protocol design [27]. The wide applicability of this tool was demonstrated by Goldreich, Micali and Wigderson [26], yielding a dramatic effect on the theory and practice of cryptography. <p> IP is the class of languages possessing interactive proofs of membership. Since their inception interactive proofs have proven to be very useful. The original motivation for their introduction was the introduction of zero-knowledge interactive proofs <ref> [27] </ref>, which in turn were suggested as a principal tool for cryptographic protocol design [27]. The wide applicability of this tool was demonstrated by Goldreich, Micali and Wigderson [26], yielding a dramatic effect on the theory and practice of cryptography. <p> Next, we turn to randomness, and describe our results and techniques. We conclude by discussing related work and possible avenues for further investigation. 2 1.1 Interactive Proofs and Arthur-Merlin Games An interactive proof system <ref> [27] </ref> consists of two communicating parties, the prover and the verifier. The verifier is restricted to probabilistic polynomial time while the prover is not computationally restricted. On a common input w of length n they exchange a sequence of messages, with the number of messages polynomial in n.
Reference: [28] <author> S. Goldwasser and M. Sipser. </author> <title> Private Coins versus Public Coins in Interactive Proof Systems. </title> <booktitle> Proceedings of the 18th Annual ACM Symposium on the Theory of Computing, ACM (1986). </booktitle> <pages> 23 </pages>
Reference-contexts: For convenience we usually focus on "symmetric" games in which the interaction consists of a sequence of "rounds;" a round consists of Arthur sending a message and Merlin a response. AM proof systems for a language L are defined just like interactive ones. Goldwasser and Sipser <ref> [28] </ref> showed that any language having an interactive proof system also has an AM proof system; the two systems are thus of equal power as far as language recognition is concerned. Moreover, the equivalence established by [28] preserves the number of rounds. <p> Goldwasser and Sipser <ref> [28] </ref> showed that any language having an interactive proof system also has an AM proof system; the two systems are thus of equal power as far as language recognition is concerned. Moreover, the equivalence established by [28] preserves the number of rounds. The advantage of the AM formulation lies in its simpler combinatorial structure, and it is via AM games that most structural results (including ours and [5, 2, 6, 15, 11]) are proved.
Reference: [29] <author> J. Hartmanis, R. Chang, D. Ranjan and P. Rohatgi. </author> <title> Structural Complexity Theory: Recent Surprizes. </title> <type> Technical Report 90-1117, </type> <institution> Dept. of Computer Science, Cornell University (April 1990). </institution>
Reference-contexts: However, we note that the results of [36, 42] indicate that rela-tivized separations are not evidence of real separations, for although IP=PSPACE, a random oracle separates them <ref> [29, 19] </ref>. So a better than constant factor collapse in IP need not be ruled out by the relativized separation results of [2]. 1.3 Our Results The results in this paper represent the first attempt to understand the role of randomness in interactive proofs in a quantitative sense.
Reference: [30] <author> J. H -astad. </author> <title> Pseudo-random generators under Uniform Assumptions. </title> <booktitle> Proceedings of the 22nd Annual ACM Symposium on the Theory of Computing, ACM (1990). </booktitle>
Reference-contexts: Furthermore, pseudo-random sequences [14, 45] can be used to decrease the error of any BPP algorithm to n c while using only n * coins, for any constants * and c. Coupling this with the results of [20, 33] and <ref> [32, 30] </ref>, we get that the existence of one-way functions implies that the error of any BPP algorithm can be reduced to 2 k while using only n * + O (k) coins, for any constant * &gt; 0. Error-reduction for AM games, however, seems more difficult to handle.
Reference: [31] <author> R. Impagliazzo. </author> <title> Private communication (December 1990). </title>
Reference-contexts: Recently Impagliazzo <ref> [31] </ref> presented a general technique to extend these kinds of results to real valued functions. 6.3 Our (l; *; ffi)-approximator We construct an (l; *; ffi)-approximator which uses O (l + log ffi 1 ) coin tosses and O (* 2 log ffi 1 ) sample points, and works for all
Reference: [32] <author> R. Impagliazzo, L. Levin and M. Luby. </author> <title> Pseudo-Random Generation from One-Way Functions. </title> <booktitle> Proceedings of the 21st Annual ACM Symposium on the Theory of Computing, ACM (1989). </booktitle>
Reference-contexts: Furthermore, pseudo-random sequences [14, 45] can be used to decrease the error of any BPP algorithm to n c while using only n * coins, for any constants * and c. Coupling this with the results of [20, 33] and <ref> [32, 30] </ref>, we get that the existence of one-way functions implies that the error of any BPP algorithm can be reduced to 2 k while using only n * + O (k) coins, for any constant * &gt; 0. Error-reduction for AM games, however, seems more difficult to handle.
Reference: [33] <author> R. Impagliazzo and D. Zuckerman. </author> <title> How to Recycle Random Bits. </title> <booktitle> Proceedings of the 30th Annual IEEE Symposium on the Foundations of Computer Science, IEEE (1989). </booktitle>
Reference-contexts: Cohen and Wigderson [20] and Impagliazzo and Zuckermann <ref> [33] </ref>, using techniques of 4 Ajtai, Komlos and Szemeredi [3], showed how the error could be decreased to 2 k at the cost of O (r + k) coins for any polynomially bounded k = k (n). <p> Furthermore, pseudo-random sequences [14, 45] can be used to decrease the error of any BPP algorithm to n c while using only n * coins, for any constants * and c. Coupling this with the results of <ref> [20, 33] </ref> and [32, 30], we get that the existence of one-way functions implies that the error of any BPP algorithm can be reduced to 2 k while using only n * + O (k) coins, for any constant * &gt; 0. <p> Error-reduction for AM games, however, seems more difficult to handle. The above mentioned techniques <ref> [44, 40, 34, 18, 20, 33, 3] </ref> are not directly applicable here as we are not dealing with witness-sets which are fixed beforehand, but rather with an adversary (cheating Merlin) that dynamically guides, by his responses to the verifier's coins, the search of the verifier for rejecting computations. <p> This requires O (tl) coin tosses and t function evaluations. The construction of randomness-efficient (l; *; ffi)-approximators has been a subject of much research, but existing constructions <ref> [18, 10, 11, 20, 33, 38] </ref> that save coins over the standard one suffer from various restrictions (see x6 for details). <p> Using the techniques of Impagliazzo and Zuckermann <ref> [33] </ref> one can construct an (l; *; ffi)- approximator for the class of boolean functions which uses O (* 2 log ffi 1 ) sample points and l + O (* 4 log 2 ffi 1 ) coin tosses as long as l = !(* 2 log ffi 1 ). <p> A somewhat coarser kind of approximation to the average of a boolean function f : f0; 1g l ! f0; 1g can be obtained via a random walk on a 2 l node explicitly constructed expander graph (cf. <ref> [3, 20, 33] </ref>). For example, if E [f ] 99=100 then we can use O (l + log ffi 1 ) random bits to generate O (log ffi 1 ) sample points such that the average of f on these sample points is 2=3 with probability 1 ffi. <p> Namely, a BPP algorithm which has error 1=3 with respect to L and uses r = r (n) coins can be transformed into one which has error 2 k and uses O (r + k) coins <ref> [20, 33] </ref>. * Can our result be generalized to (general) interactive proof systems? We do not know of any direct non-trivial error-reduction technique for general interactive proof systems. <p> algorithm which has error 1=3 with respect to L and uses r = r (n) coins can be transformed, for any constant c &gt; 0, into one which has error n c and still uses only r coins (a result of [34] described in [20]) and one can then apply <ref> [20, 33] </ref> to reduce the error to 2 k at the cost of O (k) additional coins. Acknowledgments We thank John Rompel for many valuable ideas and discussions in the early stages of this research. We also thank Silvio Micali for many helpful discussions.
Reference: [34] <author> R. Karp, N. Pippinger and M. Sipser. </author> <title> A Time-Randomness Tradeoff. </title> <booktitle> In AMS Conference on Probabilistic Computational Complexity, </booktitle> <address> Durham, New Hampshire (1985). </address>
Reference-contexts: That such randomness-efficient error-reduction was possible was pointed out, non-constructively, by Sipser [44] and Santha [40]. The first constructions were obtained by Karp, Pippinger and Sipser <ref> [34] </ref> and Chor and Goldreich [18], who showed that the error-probability of a BPP algorithm which used r = r (n) coin tosses could be reduced to n c for any given constant c while using only O (r) coin tosses. <p> Error-reduction for AM games, however, seems more difficult to handle. The above mentioned techniques <ref> [44, 40, 34, 18, 20, 33, 3] </ref> are not directly applicable here as we are not dealing with witness-sets which are fixed beforehand, but rather with an adversary (cheating Merlin) that dynamically guides, by his responses to the verifier's coins, the search of the verifier for rejecting computations. <p> A BPP algorithm which has error 1=3 with respect to L and uses r = r (n) coins can be transformed, for any constant c &gt; 0, into one which has error n c and still uses only r coins (a result of <ref> [34] </ref> described in [20]) and one can then apply [20, 33] to reduce the error to 2 k at the cost of O (k) additional coins. Acknowledgments We thank John Rompel for many valuable ideas and discussions in the early stages of this research.
Reference: [35] <author> A. Lubotzky, R. Phillips and P. Sarnak. </author> <title> Explicit Expanders and the Ramanujan Conjectures. </title> <booktitle> Proceedings of the 18th Annual ACM Symposium on the Theory of Computing, ACM (1986). </booktitle>
Reference: [36] <author> C. Lund, L. Fortnow, H. Karloff, and N. Nisan. </author> <title> Algebraic Methods for Interactive Proof Systems. </title> <booktitle> Proceedings of the 31st Annual IEEE Symposium on the Foundations of Computer Science, IEEE (1990). </booktitle>
Reference-contexts: First indications to such potential were presented by Babai [5] and Goldreich, Micali and Wigderson [26]. But it is only in the last two years that a full understanding of the power of interactive proofs has emerged. Lund, Fortnow, Karloff and Nisan <ref> [36] </ref> showed that IP contains the polynomial time hierarchy, and Shamir [42] extended this to show that IP equals PSPACE. We conclude that interaction and randomness make a potent brew. <p> Aiello, Goldwasser and H-astad [2] show that if ff (n) ! 1 then there are oracles separating AM [g (n)] from AM [g (n)=ff (n)]. However, we note that the results of <ref> [36, 42] </ref> indicate that rela-tivized separations are not evidence of real separations, for although IP=PSPACE, a random oracle separates them [29, 19].
Reference: [37] <author> C. Lund and M. Yannakakis. </author> <title> On the Hardness of Approximating Minimization Problems. </title> <booktitle> Proceedings of the 25th Annual ACM Symposium on the Theory of Computing, ACM (1993). </booktitle>
Reference-contexts: Specifically, appropriate reductions in the randomness complexity of error reduction for two prover one round proof systems would lead to improvement of the results of <ref> [9, 22, 8, 37] </ref>. 2 Preliminaries We review definitions and notation for the Arthur-Merlin games of Babai [5] and Babai and Moran [6], introduce the accepting probability function, and conclude by showing we can without loss of generality restrict our attention to a special case. 2.1 Arthur-Merlin Games An Arthur-Merlin game
Reference: [38] <author> N. Nisan. </author> <title> Pseudorandom Generators for Space Bounded Computation. </title> <booktitle> Proceedings of the 22nd Annual ACM Symposium on the Theory of Computing, ACM (1990). </booktitle>
Reference-contexts: This requires O (tl) coin tosses and t function evaluations. The construction of randomness-efficient (l; *; ffi)-approximators has been a subject of much research, but existing constructions <ref> [18, 10, 11, 20, 33, 38] </ref> that save coins over the standard one suffer from various restrictions (see x6 for details). <p> This is useful for many applications such as randomness-efficient error-reduction for BPP algorithms. Other randomness-efficient sampling techniques include that of Nisan <ref> [38] </ref> who shows how O (l log t) random bits suffice to produce a sequence of l bit strings r 1 ; : : :; r t such that jP [f (r 1 ) = = f (r t ) = 1] E [f ] t j &lt; 2 l for
Reference: [39] <author> N. Nisan and A. Wigderson. </author> <title> Hardness vs. Randomness. </title> <booktitle> Proceedings of the 29th Annual IEEE Symposium on the Foundations of Computer Science, IEEE (1988). </booktitle>
Reference-contexts: Notable examples are results such as BPP equals almost-P [13] and BPP is contained in non-uniform P [1]. The IP counterpart of the first was open for several years and finally proved by Nisan and Wigderson <ref> [39] </ref>, while the IP analogue of the second (i.e., IP is contained in non-uniform NP) is not believed to be true. 1.5 A Result About Sampling Our results use properties of low independence distributions and random walks on explicitly constructed expander graphs.
Reference: [40] <author> M. Santha. </author> <title> On Using Deterministic Functions to Reduce Randomness in Probabilistic Algorithms. </title> <booktitle> Information and Computation 74(3), </booktitle> <month> 241-249 </month> <year> (1987). </year>
Reference-contexts: That such randomness-efficient error-reduction was possible was pointed out, non-constructively, by Sipser [44] and Santha <ref> [40] </ref>. <p> Error-reduction for AM games, however, seems more difficult to handle. The above mentioned techniques <ref> [44, 40, 34, 18, 20, 33, 3] </ref> are not directly applicable here as we are not dealing with witness-sets which are fixed beforehand, but rather with an adversary (cheating Merlin) that dynamically guides, by his responses to the verifier's coins, the search of the verifier for rejecting computations.
Reference: [41] <author> A. </author> <title> Schrift. </title> <type> Chapter 4 of Ph.D Thesis, </type> <institution> Dept. of Applied Mathematics and Computer Science, Weiz-mann Institute. </institution>
Reference-contexts: We looked at how the power of IP varies with the amount of randomness. A different direction was taken by Schrift <ref> [41] </ref> who investigated how the power of an interactive proof varies with the quality of the random bits used.
Reference: [42] <author> A. Shamir. IP=PSPACE. </author> <booktitle> Proceedings of the 31st Annual IEEE Symposium on the Foundations of Computer Science, IEEE (1990). </booktitle>
Reference-contexts: But it is only in the last two years that a full understanding of the power of interactive proofs has emerged. Lund, Fortnow, Karloff and Nisan [36] showed that IP contains the polynomial time hierarchy, and Shamir <ref> [42] </ref> extended this to show that IP equals PSPACE. We conclude that interaction and randomness make a potent brew. We are well motivated then, to understand more the precise role played by these ingredients in the granting of so much power. <p> Aiello, Goldwasser and H-astad [2] show that if ff (n) ! 1 then there are oracles separating AM [g (n)] from AM [g (n)=ff (n)]. However, we note that the results of <ref> [36, 42] </ref> indicate that rela-tivized separations are not evidence of real separations, for although IP=PSPACE, a random oracle separates them [29, 19].
Reference: [43] <author> V. Shoup. </author> <title> New Algorithms for Finding Irreducible Polynomials over Finite Fields. </title> <booktitle> Proceedings of the 29th Annual IEEE Symposium on the Foundations of Computer Science, IEEE (1988). </booktitle>
Reference-contexts: It is well known that pairwise independent generators exist. For completeness, let us sketch two implementations. The first implementation [18] uses finite fields. We identify the sets f0; 1g l and [2 l ] with GF (2 l ). Using Shoup's (deterministic) algorithm <ref> [43] </ref> we can find a degree l irreducible polynomial over GF (2) in time polynomial in l, and this yields the ability to do polynomial time arithmetic in the field.
Reference: [44] <author> M. Sipser. Expanders, </author> <title> Randomness, or Time Versus Space. Structure in Complexity Theory (1986). </title>
Reference-contexts: That such randomness-efficient error-reduction was possible was pointed out, non-constructively, by Sipser <ref> [44] </ref> and Santha [40]. <p> Error-reduction for AM games, however, seems more difficult to handle. The above mentioned techniques <ref> [44, 40, 34, 18, 20, 33, 3] </ref> are not directly applicable here as we are not dealing with witness-sets which are fixed beforehand, but rather with an adversary (cheating Merlin) that dynamically guides, by his responses to the verifier's coins, the search of the verifier for rejecting computations.
Reference: [45] <author> A. Yao. </author> <title> Theory and Applications of Trapdoor Functions. </title> <booktitle> Proceedings of the 23rd Annual IEEE Symposium on the Foundations of Computer Science, IEEE (1982). </booktitle> <pages> 24 </pages>
Reference-contexts: Cohen and Wigderson [20] and Impagliazzo and Zuckermann [33], using techniques of 4 Ajtai, Komlos and Szemeredi [3], showed how the error could be decreased to 2 k at the cost of O (r + k) coins for any polynomially bounded k = k (n). Furthermore, pseudo-random sequences <ref> [14, 45] </ref> can be used to decrease the error of any BPP algorithm to n c while using only n * coins, for any constants * and c.
References-found: 45

