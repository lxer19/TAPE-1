URL: http://theory.lcs.mit.edu/~rajsbaum/boazmain.ps
Refering-URL: http://theory.lcs.mit.edu/~rajsbaum/
Root-URL: 
Email: E-mail: boaz@theory.lcs.mit.edu. E-mail: rajsbaum@theory.lcs.mit.edu.  
Title: A Theory of Clock Synchronization Extended Abstract  
Author: Boaz Patt-Shamir Sergio Rajsbaum 
Address: Cambridge, MA 02139  
Affiliation: Laboratory for Computer Science Massachusetts Institute of Technology  
Date: May 1994 1  
Note: To Appear in Proc. 26th Symp. on Theory of Computing,  Supported by Air Force Contract AFOSR F49620-92-J-0125, ONR contract N00014-91-J-1046, NSF contracts CCR-9114440 and 9225124, DARPA contracts N00014-92-J-1799 and N00014-92-J-4033, and a special grant from IBM.  On leave from Institute of Mathematics, U.N.A.M. Partly supported by DGAPA Projects.  
Abstract: We consider the problem of clock synchronization with uncertain message delays and bounded clock drifts. To analyze this classical problem we introduce a characterization theorem for the tightest achievable estimate of the readings of a remote clock in any given execution of the system. Using this theorem, we obtain the first optimal on-line distributed algorithms for clock synchronization. The algorithms are optimal for all executions, rather than only worst cases. The general algorithm for systems with drifting clocks has high space overhead, which is unavoidable, as we show. For systems with drift-free clocks (i.e., clocks that run at the rate of real time), we present a remarkably simple and efficient algorithm. The discussion focuses on the variant where one of the clocks shows real time, but we present results also for the case where real time is not available from within the system. Our approach encompasses various models, such as point-to-point or broadcast channels, perfect or faulty communication links, and it has fault-detection capablities. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> J. E. Abate, E. W. Butterline, R. A. Carley, P. Greendyk, A. M. Montenegro, C. D. Near, S. H. Richman, and G. P. Zampelli. </author> <title> AT&T new approach to the synchronization of telecommunication networks. </title> <journal> IEEE Communication Magazine, </journal> <pages> pages 35-45, </pages> <month> Apr. </month> <year> 1989. </year>
Reference-contexts: The large number of models is justified by the wide spectrum of applications. Considerable work has been dedicated to clock synchronization (see surveys [14, 13] and more recent works, e.g. <ref> [1, 5, 2, 12] </ref> and references therein). Some algorithms were proposed for systems where processors and links are reliable, but both delays and clock drifts are uncertain (e.g. [7, 10]). Although the algorithms are simple to state, their analyses tend to be complicated. <p> a set X = fx 1 ; : : : ; x k g to To Appear in Proc. 26th Symp. on Theory of Computing, May 1994 Page 7 be an expression of the form c 0 + P k i=1 c i x i , where c i 2 <ref> [1; 1] </ref> for all 1 i k and c 0 2 R. A special linear form for X is the sequence of coefficients of some special linear combination for X.
Reference: [2] <author> H. Attiya, A. Herzberg, and S. Rajsbaum. </author> <title> Optimal clock synchronization under different delay assumptions. </title> <booktitle> In Proceedings of the 12th Annual ACM Symposium on Principles of Distributed Computing, </booktitle> <pages> pages 109-120, </pages> <year> 1993. </year>
Reference-contexts: The large number of models is justified by the wide spectrum of applications. Considerable work has been dedicated to clock synchronization (see surveys [14, 13] and more recent works, e.g. <ref> [1, 5, 2, 12] </ref> and references therein). Some algorithms were proposed for systems where processors and links are reliable, but both delays and clock drifts are uncertain (e.g. [7, 10]). Although the algorithms are simple to state, their analyses tend to be complicated. <p> Although the algorithms are simple to state, their analyses tend to be complicated. Moreover, even for this case, no nontrivial lower bounds were known. The case of systems whose clocks are drift-free is better understood <ref> [8, 6, 2] </ref>. In [8, 6], the worst possible behaviors of the system (within its specifications) are analyzed, and optimal protocols for the worst case are proposed. The protocols send one message per link, because in the worst case no additional information is gained by sending more messages. <p> In [8, 6], the worst possible behaviors of the system (within its specifications) are analyzed, and optimal protocols for the worst case are proposed. The protocols send one message per link, because in the worst case no additional information is gained by sending more messages. Recently, Attiya et al. <ref> [2] </ref> proposed not viewing the system as an adversary; the problem they consider is how to get the tightest synchronization for any given execution (which often is much better than the worst possible). <p> For the internal synchronization problem, our algorithms (using a trivial reduction) give tightness which is at most twice the optimal. Additionally, we derive a lower bound for internal synchronization that generalizes the known bound <ref> [6, 2] </ref> to the case of drifting clocks. Finally, we discuss a few extensions of the basic model, including a way to incorporate additional a priori knowledge about the message traffic pattern; a simple way to detect faults; and how to deal with inaccurate source clocks. <p> logical time at state s is T "." Below, we outline our model for this problem, whose motivation is to facilitate comparison be To Appear in Proc. 26th Symp. on Theory of Computing, May 1994 Page 2 of a clock synchronization system. tween different algorithms for clock synchronization (see also <ref> [2] </ref>). The ultimate goal is that algorithms would perform optimally in each execution; the basic difficulty is that different algorithms may never share the same execution. For instance, some trivial algorithm that does not send any message could be considered optimal, in some degenerate sense. <p> This lower bound is a generalization of the known bounds for the drift-free case <ref> [6, 2] </ref>. Intuitively, the goal of internal synchronization is to keep logical clocks as close as possible. To avoid liveness issues when proving a lower bound, and following [4, 6], we use a "one shot" definition of the problem.
Reference: [3] <author> A. Borodin, M. Fischer, D. Kirkpatrick, N. Lynch, and M. Tompa. </author> <title> A time-space tradeoff for sorting on non-oblivious machines. </title> <journal> J. Comp. and Syst. Sci., </journal> <volume> 22 </volume> <pages> 351-364, </pages> <year> 1981. </year>
Reference-contexts: These bounds hold in the general case, where clocks are allowed to drift. The algorithm used to prove the upper bound has unbounded space overhead. However, we prove that in a suitably defined variant of the comparison branching program model <ref> [3] </ref>, the space complexity of any optimal algorithm for drifting clocks cannot be bounded by a function of the network size. The situation for systems with drift-free clocks is much better: for this case, we give an extremely simple and efficient protocol for external synchronization. <p> Our strategy to get around this difficulty is to use a generalization of the comparison branching program model <ref> [3] </ref>, thus obtaining a bound on the number of "control bits" required to run the program. <p> The nodes represent control configurations of the program (excluding the input), labeled by some expressions of the input variables. An execution proceeds by evaluating these expressions, and selecting the next configuration according to their outcome (e.g., in <ref> [3] </ref>, nodes specify pairs of input variables, and edges are labeled by "&lt;", "=", or "&gt;").
Reference: [4] <author> D. Dolev, J. Y. Halpern, and R. </author> <title> Strong. On the pos-siblity and impossibility of achieving clock synchronization. </title> <journal> J. Comp. and Syst. Sci., </journal> <volume> 32(2) </volume> <pages> 230-250, </pages> <year> 1986. </year>
Reference-contexts: This lower bound is a generalization of the known bounds for the drift-free case [6, 2]. Intuitively, the goal of internal synchronization is to keep logical clocks as close as possible. To avoid liveness issues when proving a lower bound, and following <ref> [4, 6] </ref>, we use a "one shot" definition of the problem. Specifically, we assume that for each node v, there is a special action called fire v .
Reference: [5] <author> J. Halpern and I. Suzuki. </author> <title> Clock synchronization and the power of broadcasting. </title> <booktitle> In Proc. of Allerton Conference, </booktitle> <pages> pages 588-597, </pages> <year> 1990. </year>
Reference-contexts: The large number of models is justified by the wide spectrum of applications. Considerable work has been dedicated to clock synchronization (see surveys [14, 13] and more recent works, e.g. <ref> [1, 5, 2, 12] </ref> and references therein). Some algorithms were proposed for systems where processors and links are reliable, but both delays and clock drifts are uncertain (e.g. [7, 10]). Although the algorithms are simple to state, their analyses tend to be complicated.
Reference: [6] <author> J. Y. Halpern, N. Megiddo, and A. A. Munshi. </author> <title> Optimal precision in the presence of uncertainty. </title> <journal> Journal of Complexity, </journal> <volume> 1 </volume> <pages> 170-196, </pages> <year> 1985. </year>
Reference-contexts: Although the algorithms are simple to state, their analyses tend to be complicated. Moreover, even for this case, no nontrivial lower bounds were known. The case of systems whose clocks are drift-free is better understood <ref> [8, 6, 2] </ref>. In [8, 6], the worst possible behaviors of the system (within its specifications) are analyzed, and optimal protocols for the worst case are proposed. The protocols send one message per link, because in the worst case no additional information is gained by sending more messages. <p> Although the algorithms are simple to state, their analyses tend to be complicated. Moreover, even for this case, no nontrivial lower bounds were known. The case of systems whose clocks are drift-free is better understood [8, 6, 2]. In <ref> [8, 6] </ref>, the worst possible behaviors of the system (within its specifications) are analyzed, and optimal protocols for the worst case are proposed. The protocols send one message per link, because in the worst case no additional information is gained by sending more messages. <p> For the internal synchronization problem, our algorithms (using a trivial reduction) give tightness which is at most twice the optimal. Additionally, we derive a lower bound for internal synchronization that generalizes the known bound <ref> [6, 2] </ref> to the case of drifting clocks. Finally, we discuss a few extensions of the basic model, including a way to incorporate additional a priori knowledge about the message traffic pattern; a simple way to detect faults; and how to deal with inaccurate source clocks. <p> This lower bound is a generalization of the known bounds for the drift-free case <ref> [6, 2] </ref>. Intuitively, the goal of internal synchronization is to keep logical clocks as close as possible. To avoid liveness issues when proving a lower bound, and following [4, 6], we use a "one shot" definition of the problem. <p> This lower bound is a generalization of the known bounds for the drift-free case [6, 2]. Intuitively, the goal of internal synchronization is to keep logical clocks as close as possible. To avoid liveness issues when proving a lower bound, and following <ref> [4, 6] </ref>, we use a "one shot" definition of the problem. Specifically, we assume that for each node v, there is a special action called fire v .
Reference: [7] <author> L. Lamport. </author> <title> Time, clocks, and the ordering of events in a distributed system. </title> <journal> Comm. ACM, </journal> <volume> 21(7) </volume> <pages> 558-565, </pages> <month> July </month> <year> 1978. </year>
Reference-contexts: Considerable work has been dedicated to clock synchronization (see surveys [14, 13] and more recent works, e.g. [1, 5, 2, 12] and references therein). Some algorithms were proposed for systems where processors and links are reliable, but both delays and clock drifts are uncertain (e.g. <ref> [7, 10] </ref>). Although the algorithms are simple to state, their analyses tend to be complicated. Moreover, even for this case, no nontrivial lower bounds were known. The case of systems whose clocks are drift-free is better understood [8, 6, 2]. <p> It is interesting to note that in many networks, the message delivery system is already appending "headers" to messages to facilitate delivery. 4 Formally (cf. <ref> [7] </ref>), we say that a point q can influence another point q 0 if either q occurs before q 0 at the same processor, or if q is a send point and q 0 is a receive point of the corresponding message, or if there is a point q 00 such
Reference: [8] <author> J. Lundelius and N. Lynch. </author> <title> An upper and lower bound for clock synchronization. Information and Computation, </title> <address> 62(2-3):190-204, </address> <year> 1984. </year>
Reference-contexts: Although the algorithms are simple to state, their analyses tend to be complicated. Moreover, even for this case, no nontrivial lower bounds were known. The case of systems whose clocks are drift-free is better understood <ref> [8, 6, 2] </ref>. In [8, 6], the worst possible behaviors of the system (within its specifications) are analyzed, and optimal protocols for the worst case are proposed. The protocols send one message per link, because in the worst case no additional information is gained by sending more messages. <p> Although the algorithms are simple to state, their analyses tend to be complicated. Moreover, even for this case, no nontrivial lower bounds were known. The case of systems whose clocks are drift-free is better understood [8, 6, 2]. In <ref> [8, 6] </ref>, the worst possible behaviors of the system (within its specifications) are analyzed, and optimal protocols for the worst case are proposed. The protocols send one message per link, because in the worst case no additional information is gained by sending more messages.
Reference: [9] <author> N. Lynch. </author> <title> Simulation techniques for proving properties of real-time systems. </title> <booktitle> In Rex Workshop '93, Lecture Notes in Computer Science, Mook, the Nether-lands, </booktitle> <year> 1994. </year> <note> Springer-Verlag. To appear. </note>
Reference-contexts: Due to lack of space, most proofs are omitted. 2 Overview of the Model In this section we give a high-level description of the system structure for the clock synchronization problem. The underlying formal model is based on the timed I/O Automata model of Lynch and Vaandrager <ref> [9] </ref>. The system is modeled as a collection of interacting state machines with input and output actions. The model associates real time, denoted real time, with every state and event. Real time is not directly observable by the processors.
Reference: [10] <author> K. Marzullo and S. Owicki. </author> <title> Maintaining the time in a distributed system. </title> <booktitle> In Proceedings of the 2nd Annual ACM Symposium on Principles of Distributed Computing, </booktitle> <pages> pages 44-54, </pages> <year> 1983. </year>
Reference-contexts: Considerable work has been dedicated to clock synchronization (see surveys [14, 13] and more recent works, e.g. [1, 5, 2, 12] and references therein). Some algorithms were proposed for systems where processors and links are reliable, but both delays and clock drifts are uncertain (e.g. <ref> [7, 10] </ref>). Although the algorithms are simple to state, their analyses tend to be complicated. Moreover, even for this case, no nontrivial lower bounds were known. The case of systems whose clocks are drift-free is better understood [8, 6, 2].
Reference: [11] <author> D. L. Mills. </author> <title> Internet time synchronization: the Network Time Protocol. </title> <journal> IEEE Trans. Comm., </journal> <volume> 39(10) </volume> <pages> 1482-1493, </pages> <month> Oct. </month> <year> 1991. </year>
Reference-contexts: The external clock synchronization task is especially useful in loosely coupled networks: for instance, the NTP protocol is used for external synchronization of the Internet <ref> [11] </ref>. In the internal synchronization problem, real time is not available from within the system, and the goal is to minimize the maximum difference between the readings of clocks, subject to some live-ness condition. The basic difficulty is that synchronization tends to deteriorate over time and space.
Reference: [12] <author> Y. Ofek. </author> <title> Generating a fault tolerant global clock using high-speed control signals for the MetaNet architecture. </title> <journal> IEEE Trans. Comm., </journal> <month> Dec. </month> <year> 1993. </year>
Reference-contexts: The large number of models is justified by the wide spectrum of applications. Considerable work has been dedicated to clock synchronization (see surveys [14, 13] and more recent works, e.g. <ref> [1, 5, 2, 12] </ref> and references therein). Some algorithms were proposed for systems where processors and links are reliable, but both delays and clock drifts are uncertain (e.g. [7, 10]). Although the algorithms are simple to state, their analyses tend to be complicated.
Reference: [13] <author> F. B. Schneider. </author> <title> Understanding protocols for byzan-tine clock synchronization. </title> <type> Research Report 87-859, </type> <institution> Department of Computer Science, Cornell University, </institution> <month> Aug. </month> <year> 1987. </year>
Reference-contexts: The large number of models is justified by the wide spectrum of applications. Considerable work has been dedicated to clock synchronization (see surveys <ref> [14, 13] </ref> and more recent works, e.g. [1, 5, 2, 12] and references therein). Some algorithms were proposed for systems where processors and links are reliable, but both delays and clock drifts are uncertain (e.g. [7, 10]). Although the algorithms are simple to state, their analyses tend to be complicated.
Reference: [14] <author> B. Simmons, J. L. Welch, and N. Lynch. </author> <title> An overview of clock synchronization. </title> <type> Research Report RC 6505 (63306), </type> <institution> IBM, </institution> <year> 1988. </year> <note> To Appear in Proc. 26th Symp. on Theory of Computing, May 1994 Page 10 </note>
Reference-contexts: The large number of models is justified by the wide spectrum of applications. Considerable work has been dedicated to clock synchronization (see surveys <ref> [14, 13] </ref> and more recent works, e.g. [1, 5, 2, 12] and references therein). Some algorithms were proposed for systems where processors and links are reliable, but both delays and clock drifts are uncertain (e.g. [7, 10]). Although the algorithms are simple to state, their analyses tend to be complicated.
References-found: 14

