URL: http://www.cs.toronto.edu/~csc2532h/ConGologLang.ps.gz
Refering-URL: http://www.cs.toronto.edu/~csc2532h/
Root-URL: http://www.cs.toronto.edu
Email: degiacomo@dis.uniroma1.it  lesperan@cs.yorku.ca  hector@cs.toronto.edu  
Title: ConGolog, a concurrent programming language based on the situation calculus: language and implementation.  
Author: Giuseppe De Giacomo Yves Lesperance Hector J. Levesque 
Address: Via Salaria 113, 00198 Roma, Italy  Toronto, ON, Canada M3J 1P3  Toronto, ON, Canada M5S 3H5  
Affiliation: Dipartimento di Informatica e Sistemistica Universita di Roma "La Sapienza"  Department of Computer Science York University  Department of Computer Science University of Toronto  
Abstract: As an alternative to planning, an approach to high-level agent control based on concurrent program execution is considered. A formal definition in the situation calculus of such a programming language is presented and illustrated with some examples. The language includes facilities for prioritizing the execution of concurrent processes, interrupting the execution when certain conditions become true, and dealing with exogenous actions. The language differs from other procedural formalisms for concurrency in that the initial state can be incompletely specified and the primitive actions can be user-defined by axioms in the situation calculus. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> G. R. Andrews, and F. B. Schneider. </author> <title> Concepts and notations for concurrent programming. </title> <journal> ACM Computing Surveys, </journal> <volume> 15:1, </volume> <pages> 3-43, </pages> <year> 1983. </year>
Reference-contexts: Internal synchronization primitives are easily added. 12 behave in a similar way to the test-and-set atomic instructions used to build semaphores in concurrent programming <ref> [1] </ref>. 9 The construct (ffi 1 k ffi 2 ) denotes the concurrent execution of the actions ffi 1 and ffi 2 . (ffi 1 ii ffi 2 ) denotes the concurrent execution of the actions ffi 1 and ffi 2 with ffi 1 having higher priority than ffi 2 .
Reference: [2] <author> M. E. Bratman, D.J. Israel, and M. E. Pollack. </author> <title> Plans and resource-bounded practical reasoning. </title> <journal> Computational Intelligence, </journal> <volume> 4, </volume> <pages> 349-355, </pages> <year> 1988. </year>
Reference-contexts: Thus, our work is related to earlier research on resource-bounded deliberative architectures such as <ref> [2] </ref> (IRMA) and [27] (PRS), and agent programming languages that are to some extent based on this kind of architectures, such as AGENT-0 [34], AgentSpeak (L) [26], and 3APL [15].
Reference: [3] <author> A. J. Bonner and M. Kifer. </author> <title> Concurrency and communication in transaction logic. </title> <booktitle> In Proceedings of the Joint International Conference and Symposium on Logic Programming (JICSLP), </booktitle> <pages> pages 142-156, </pages> <address> Bonn, Germany, </address> <month> Sept. </month> <year> 1996. </year>
Reference-contexts: The rule-based languages AgentSpeak (L) [26] and 3APL [15] as well as van Eijk et al.'s [10] concurrent-constraint-based language all come with formal semantics specified using transition systems. There are also similarities with the work of Bonner and Kifer <ref> [3] </ref>, where a logical formalism is proposed for concurrent database transactions. But it is difficult to make detailed comparisons between these languages which draw on different formalisms and focus on different issues.
Reference: [4] <author> J. De Bakker and E. De Vink. </author> <title> Control Flow Semantics. </title> <publisher> MIT Press, </publisher> <year> 1996. </year>
Reference-contexts: Of course ours is not the first formal model of concurrency. In fact, well developed approaches are available <ref> [16, 23, 4, 35] </ref> 1 and our work inherits many of the intuitions behind them. However, it is distinguished from these in at least two fundamental ways. First, it allows incomplete information about the environment surrounding the program.
Reference: [5] <author> G. De Giacomo and X. Chen. </author> <title> Reasoning about nondeterministic and concurrent actions: A process algebra approach. </title> <booktitle> In Proceedings of the 13th National Conference on Artificial Intelligence (AAAI'96), </booktitle> <pages> pages 658-663, </pages> <year> 1996. </year>
Reference-contexts: The section concludes with changes to the Golog specification required to handle concurrency. In Section 6, we illustrate the use of ConGolog by going over several example programs. Then in Section 7, we extend the specification given in Section 5 1 In <ref> [25, 5] </ref> a direct use of such approaches to model concurrent (complex) actions in AI is investigated. 2 to handle procedures and recursion. In Section 8, we present a Prolog interpreter for ConGolog and prove its correctness.
Reference: [6] <author> G. De Giacomo, Y. Lesperance, and H. J. Levesque. ConGolog, </author> <title> a concurrent programming language based on the situation calculus: </title> <booktitle> foundations. </booktitle> <year> 1998. </year> <note> Submitted. </note>
Reference-contexts: In Section 8, we present a Prolog interpreter for ConGolog and prove its correctness. In Section 9, we conclude by discussing some of the properties of ConGolog, its implementation, and topics for future research. Although this paper is self-contained, a companion paper <ref> [6] </ref> examines the mathematical foundations of ConGolog in detail. 2 The Situation Calculus As mentioned earlier, our high-level programs contain primitive actions and tests that are domain dependent. An interpreter for such programs must reason about the preconditions and effects of actions in the program to find legal executions. <p> It will be necessary to quantify over programs and so, unlike in [20], we need to encode Golog programs as first-order terms, including introducing constants denoting variables, and so on. This is laborious but quite straightforward. See the companion paper <ref> [6] </ref> for details. 6 We omit all such details here and simply use programs within formulas as if they were already first-order terms. 4.1 Trans and Final Let us formally define Trans and Final, which intuitively specify: * what are the possible transitions between configurations (Trans). * when a configuration can <p> It can be shown that for Golog programs such a definition for Do coincides with the one given in [20]. Indeed in the companion paper <ref> [6] </ref> the following theorem is proven: Theorem 1: Let Do 1 be the original definition of Do in [20], and Do 2 the new one given above. <p> A more complex program, typically involving interrupts, would be required, so that suitable "trajectory altering" actions are triggered under the appropriate conditions. 7 Procedures In this section we introduce procedures. This will require us to adopt a second-order definition of Trans and Final. Formal details can be found in <ref> [6] </ref>. 14 Let proc P 1 (~v 1 )ffi 1 end; : : : ; proc P n (~v n )ffi n end be a collection of procedure definitions. We call such a collection an environment and denote it by Env. <p> apply, so for e.g. in fproc P 1 () a end; P 2 (); P 1 ()g, P 1 is bound but P 2 is free. 14 Obviously, with respect to ConGolog programs without procedures, Trans and Final introduced here are equivalent to the versions introduced in Section 4, see <ref> [6] </ref>. 24 * [Env : P ( ~ t)], where Env is an environment, P a procedure name and ~ t actual parameters associated to the procedure P . [Env : P ( ~ t)] denotes a procedure call that has already been contextualized: the environment in which the definition of <p> See <ref> [6] </ref> for some examples and additional discussion. The need for a second-order definition of Trans (ffi; s; ffi 0 ; s 0 ) and Final (ffi; s) when procedures are introduced comes from recursive procedures. <p> If a goal poss (a; s), with free variables only on object terms and action terms, finitely fails, then D j= 8:Poss (a; s). 18 UNA is already enforced for programs, see <ref> [6] </ref>. 32 * The Prolog interpreter flounders (and hence does not return) on goals of the form not trans (ffi; s; ; ) 19 with non-ground ffi and s. 20 Observe that the hypotheses required for sub=4, holds=2 and poss=2 do hold when these predicates are defined as above and run <p> Now we come back to the assumption we made above for Trans and Final. In fact Final, being closed under the constraints on F in its definition, does actually satisfy the axioms F from Sections 4 and 5 as well as the one above <ref> [6] </ref>. However, Trans, which is not closed under the constraints for T in its definition, does not satisfy the assumption in general [6]. <p> Final, being closed under the constraints on F in its definition, does actually satisfy the axioms F from Sections 4 and 5 as well as the one above <ref> [6] </ref>. However, Trans, which is not closed under the constraints for T in its definition, does not satisfy the assumption in general [6].
Reference: [7] <author> G. De Giacomo, Y. Lesperance, and H. J. Levesque. </author> <title> Reasoning about concurrent execution, prioritized interrupts, </title> <booktitle> and exogenous actions in the situation calculus. In Proceedings of the 15th International Joint Conference on Artificial Intelligence (IJCAI'97), </booktitle> <pages> pages 1221-1226, </pages> <year> 1997. </year>
Reference-contexts: In this paper, we explore how to execute programs incorporating a rich account of concurrency. The execution task remains the same; what changes is that the programming language, which we call ConGolog (for Concurrent Golog) <ref> [7] </ref>, becomes considerably more expressive. One of the nice features of this language is that it allows us to conveniently formulate agent controllers that pursue goal-oriented tasks while concurrently monitoring and reacting to conditions in their environment. Of course ours is not the first formal model of concurrency.
Reference: [8] <author> G. De Giacomo and H. J. Levesque. </author> <title> An Incremental Interpreter for High-Level Programs with Sensing. </title> <booktitle> In Cognitive Robotics Papers from the 1998 AAAI Fall Symposium, </booktitle> <pages> pages 28-34, </pages> <address> Orlando, FL, </address> <month> October, </month> <year> 1998, </year> <note> Technical Report FS-98-02, AAAI Press. </note>
Reference-contexts: A ConGolog program is used to specify the complex behavior of the agents in such a system. A simple multiagent meeting scheduling example is specified in [32]. ConGolog-based tools for specifying and verifying complex multiagent systems are being investigated. Finally, in <ref> [8] </ref>, the transition semantics developed in this paper is adapted so that execution can be interleaved with program interpretation in order to accommodate sensing actions, that is, actions whose effect is not to change the world so much as to provide information to be used by the agent at runtime.
Reference: [9] <author> G. De Giacomo, E. Ternovskaia and R. Reiter. </author> <title> Non-terminating processes in the situation calculus. </title> <booktitle> In Proceedings of the AAAI'97 Workshop on Robots, Softbots, Immobots: Theories of Action, Planning and Control. </booktitle> <address> Providence, Rhode Island, </address> <month> July </month> <year> 1997. </year>
Reference-contexts: There are, however, many areas for future research. Let us mention one: handling non-termination, that is, developing accounts of program correctness (fairness, liveness etc.) appropriate for controllers expected to operate indefinitely as in <ref> [9] </ref>, but without giving up the agent's control over nondeterministic choices that characterizes the Do-based semantics for terminating programs.
Reference: [10] <author> R. M. van Eijk, F. S. de Boer, W. van der Hoek, and J.-J. Ch. Meyer. </author> <title> Information-passing and belief revision in multi-agent systems. </title> <booktitle> In Proceedings of ATAL'98, </booktitle> <editor> J. P. Muller, M. P. Singh, and A. S. Rao, editors, </editor> <address> pages 75-89, Paris, </address> <year> 1998. </year>
Reference-contexts: Concurrent MetateM [11] supports concurrency and uses a temporal logic to specify the behavior of agents. The rule-based languages AgentSpeak (L) [26] and 3APL [15] as well as van Eijk et al.'s <ref> [10] </ref> concurrent-constraint-based language all come with formal semantics specified using transition systems. There are also similarities with the work of Bonner and Kifer [3], where a logical formalism is proposed for concurrent database transactions.
Reference: [11] <author> M. Fisher. </author> <title> A survey of Concurrent MetateM the language and its applications. In D.M. </title> <editor> Gabbay and H.J. Ohlbach, editors, </editor> <booktitle> Temporal Logic Proceedings of the First International Conference, LNAI 827, </booktitle> <pages> pages 480-505, </pages> <publisher> Springer-Verlag, </publisher> <month> July, </month> <year> 1994. </year>
Reference-contexts: There has been much work on agent programming languages recently and several proposed languages share features with ConGolog. Concurrent MetateM <ref> [11] </ref> supports concurrency and uses a temporal logic to specify the behavior of agents. The rule-based languages AgentSpeak (L) [26] and 3APL [15] as well as van Eijk et al.'s [10] concurrent-constraint-based language all come with formal semantics specified using transition systems.
Reference: [12] <author> M. Gelfond and V. Lifschitz. </author> <title> Representing Action and Change by Logic Programs. </title> <journal> Journal of Logic Programming, </journal> <volume> 17, </volume> <pages> 301-327, </pages> <year> 1993. </year>
Reference-contexts: The manner in which state information is displayed can be specified easily and customized as required. Finally, a high-level Golog Domain Specification language (GDL) similar to Gelfond and Lifschitz's A <ref> [12] </ref> has also been developed. The toolkit includes a GDL compiler that takes a domain specification in GDL, generates successor state axioms for it, and then produces a Prolog implementation of the resulting domain theory. ConGolog has already been used in various applications.
Reference: [13] <author> C. C. Green. </author> <title> Theorem proving by resolution as a basis for question-answering systems. </title> <booktitle> In Machine Intelligence, </booktitle> <volume> vol. 4, </volume> <pages> pages 183-205. </pages> <publisher> Edinburgh University Press, </publisher> <year> 1969. </year>
Reference-contexts: For details, and for some of their metamathematical properties, see Lin and Reiter [18] and Reiter [29]. For any domain theory of the sort just described, we have a very clean specification of the planning task, which dates back to the work of Green <ref> [13] </ref>: Classical Planning: Given a domain theory D as above, and a goal formula OE (s) with a single free-variable s; the planning task is to find a sequence of actions ~a such that: D j= Legal (~a; S 0 ) ^ OE (do (~a; S 0 )) where do ([a
Reference: [14] <author> M. Hennessy. </author> <title> The Semantics of Programming Languages. </title> <publisher> John Wiley & Sons, </publisher> <year> 1990. </year>
Reference-contexts: ; s 00 ; s 0 ) def Do (x:ffi (x); s; s 0 ) = 9x Do (ffi (x); s; s 0 ) one for each construct in the language. 4 A Transition Semantics for Golog The kind of semantics Do associates to programs is sometimes called evaluation semantics <ref> [14] </ref> since it is based on the complete evaluation of the program. With the goal of eventually handling concurrency, it is convenient to give a slightly more refined kind of semantics called computational semantics [14], which is based on "single steps" of computation, or transitions. 5 A step here is either <p> Semantics for Golog The kind of semantics Do associates to programs is sometimes called evaluation semantics <ref> [14] </ref> since it is based on the complete evaluation of the program. With the goal of eventually handling concurrency, it is convenient to give a slightly more refined kind of semantics called computational semantics [14], which is based on "single steps" of computation, or transitions. 5 A step here is either a primitive action or testing whether a condition holds in the current state.
Reference: [15] <author> K. V. Hindriks, F. S. de Boer, W. van der Hoek, and J.-J. Ch. Meyer. </author> <title> A formal semantics for an abstract agent programming language. In M.P. </title> <editor> Singh, A. Rao, and M.J. Wooldridge, editors, </editor> <booktitle> Proceedings of ATAL'97, LNAI 1365, </booktitle> <pages> pages 215-229, </pages> <publisher> Springer-Verlag, </publisher> <year> 1998. </year>
Reference-contexts: Thus, our work is related to earlier research on resource-bounded deliberative architectures such as [2] (IRMA) and [27] (PRS), and agent programming languages that are to some extent based on this kind of architectures, such as AGENT-0 [34], AgentSpeak (L) [26], and 3APL <ref> [15] </ref>. One difference is that in ConGolog, domain dynamics are specified declaratively and the specification is used automatically in program execution; there is no need to program the updating of a world model when actions are performed. <p> There has been much work on agent programming languages recently and several proposed languages share features with ConGolog. Concurrent MetateM [11] supports concurrency and uses a temporal logic to specify the behavior of agents. The rule-based languages AgentSpeak (L) [26] and 3APL <ref> [15] </ref> as well as van Eijk et al.'s [10] concurrent-constraint-based language all come with formal semantics specified using transition systems. There are also similarities with the work of Bonner and Kifer [3], where a logical formalism is proposed for concurrent database transactions.
Reference: [16] <author> C. A. R. Hoare. </author> <title> Communicating Sequential Processes. </title> <publisher> Prentice Hall, </publisher> <year> 1985. </year>
Reference-contexts: Of course ours is not the first formal model of concurrency. In fact, well developed approaches are available <ref> [16, 23, 4, 35] </ref> 1 and our work inherits many of the intuitions behind them. However, it is distinguished from these in at least two fundamental ways. First, it allows incomplete information about the environment surrounding the program.
Reference: [17] <author> Y. Lesperance, M. Jenkin, and K. Tam. </author> <title> Reactivity in a logic-based robot programming framework. </title> <booktitle> In Cognitive Robotics Papers from the 1998 AAAI Fall Symposium, </booktitle> <pages> pages 98-105, </pages> <address> Orlando, FL, </address> <month> October, </month> <year> 1998, </year> <note> Technical Report FS-98-02, AAAI Press. </note>
Reference-contexts: The toolkit includes a GDL compiler that takes a domain specification in GDL, generates successor state axioms for it, and then produces a Prolog implementation of the resulting domain theory. ConGolog has already been used in various applications. Lesperance et al. <ref> [17] </ref> have implemented a "reactive" high-level control module for a mobile robot in ConGolog. The robot performs a mail-delivery task.
Reference: [18] <author> F. Lin and R. Reiter. </author> <title> State constraints revisited. </title> <journal> Journal of Logic and Computation, </journal> <volume> 4(5), </volume> <pages> 655-678, </pages> <year> 1994. </year>
Reference-contexts: So following this approach, a domain of application will be specified by a theory of the following form: * Axioms describing the initial situation, S 0 . 2 This discussion ignores the ramification and qualification problems; a treatment compatible with the approach described has been proposed by Lin and Reiter <ref> [18] </ref>. 4 * Action precondition axioms, one for each primitive action a, characterizing Poss (a; s). * Successor state axioms, one for each fluent F , stating under what conditions F (~x; do (a; s)) holds as function of what holds in situation s: * Unique names axioms for the primitive <p> Since the foundational axioms play no special role in this paper, we omit them. For details, and for some of their metamathematical properties, see Lin and Reiter <ref> [18] </ref> and Reiter [29].
Reference: [19] <author> F. Lin and R. Reiter. </author> <title> How to progress a database. </title> <journal> Artificial Intelligence, </journal> <volume> 92, </volume> <pages> 131-167, </pages> <year> 1997. </year>
Reference-contexts: If the program is willing to commit to a particular sequence of actions, it is possible progress the initial situation theory to a new initial situation theory representing the state of affairs after the sequence of actions <ref> [19] </ref>. 21 Subsequent queries can then be efficiently evaluated 21 In general, the progression of an initial situation database may not be first-order representable; but when the initial situation is completely known (as we are assuming in this implementation), its progression 37 with respect to this new initial situation database. <p> In this case, the domain theory includes fluents that model the beliefs and goals of the system's agents (this is done by adapting a possible-world semantics of such mental states to the is always first-order representable and can be computed efficiently; see <ref> [19] </ref> for details. 38 situation calculus). A ConGolog program is used to specify the complex behavior of the agents in such a system. A simple multiagent meeting scheduling example is specified in [32]. ConGolog-based tools for specifying and verifying complex multiagent systems are being investigated.
Reference: [20] <author> H. J. Levesque, R. Reiter, Y. Lesperance, F. Lin, and R. B. Scherl. GOLOG: </author> <title> A logic programming language for dynamic domains. </title> <journal> In Journal of Logic Programming, </journal> <volume> 31, </volume> <pages> 59-84, </pages> <year> 1997. </year>
Reference-contexts: 1 Introduction When it comes to providing high-level control for robots or other agents in dynamic and incompletely known worlds, approaches based on plan synthesis may end up being too demanding computationally in all but simple settings. An alternative approach that is showing promise is that of high-level program execution <ref> [20] </ref>. The idea, roughly, is that instead of searching for a sequence of actions that would take the agent from an initial 1 state to some goal state, the task is to find a sequence of actions that constitutes a legal execution of some high-level non-deterministic program. <p> Thus, in formulating a high-level program, the user gets to control the search effort required. The hope is that in many domains, what an agent needs to do can be conveniently expressed using a suitably rich high-level programming language. Previous work on the Golog language <ref> [20] </ref> considered how to reason about actions in programs containing conditionals, iteration, recursion, and non-deterministic operators, where the primitive actions and fluents where characterized by axioms of the situation calculus. In this paper, we explore how to execute programs incorporating a rich account of concurrency. <p> task is to find a sequence of actions that is executable (each action is executed in a context where its precondition is satisfied) and that achieves the goal (the goal formula OE holds in the final state that results from performing the actions in sequence). 3 Golog As presented in <ref> [20] </ref>, Golog is a logic-programming language whose primitive actions are those of a background domain theory. <p> In <ref> [20] </ref>, a simple inductive definition of Do was presented, containing rules such as: Do (a; s; s 0 ) = Poss (a [s]; s) ^ s 0 = do (a [s]; s) Do (ffi 1 ; ffi 2 ; s; s 0 ) = 9s 00 : Do (ffi 1 ; <p> Final and Trans will be characterized by a set of equivalence axioms, each depending on the structure of the first argument. It will be necessary to quantify over programs and so, unlike in <ref> [20] </ref>, we need to encode Golog programs as first-order terms, including introducing constants denoting variables, and so on. This is laborious but quite straightforward. <p> It can be shown that for Golog programs such a definition for Do coincides with the one given in <ref> [20] </ref>. Indeed in the companion paper [6] the following theorem is proven: Theorem 1: Let Do 1 be the original definition of Do in [20], and Do 2 the new one given above. <p> It can be shown that for Golog programs such a definition for Do coincides with the one given in <ref> [20] </ref>. Indeed in the companion paper [6] the following theorem is proven: Theorem 1: Let Do 1 be the original definition of Do in [20], and Do 2 the new one given above. <p> Similarly, (while OE do ffi; s) can evolve to (ffi 0 ; while OE do ffi; s 0 ), if OE [s] holds and (ffi; s) can evolve to (ffi 0 ; s 0 ). (if OE then ffi 1 else ffi 2 ; s) 9 In <ref> [20] </ref> a non-synchronized version of if-then else and while-loop is introduced by defining: if OE then ffi 1 else ffi 2 def = [(OE?; ffi 1 ) j (:OE?; ffi 2 )] and while OE do ffi def = [(OE?; ffi) fl ; :OE?]. <p> As well, the Prolog predicate sub=4 implements the substitution so that sub (x; y; t; t 0 ) means that t 0 = t x y . The definition of these two Prolog predicates is taken from <ref> [20, 31] </ref>.
Reference: [21] <author> J. W. Lloyd. </author> <title> Foundations of Logic Programming. </title> <publisher> Springer-Verlag, </publisher> <address> second edition, </address> <year> 1987. </year>
Reference-contexts: ) succeeds with computed answer , then: either (i) trans (ffi 1 ; s; ffi 0 1 ; s 0 ) succeeds with computed answer 1 , and = 0 1 where 0 = mgu (ffi 0 ; ffi 0 1 ii ffi 2 ) is the most general unifier <ref> [21] </ref> between ffi 0 and ffi 0 1 ii ffi 2 ; or (ii) trans (ffi 1 ; s; ; ) finitely fails and trans (ffi 2 ; s; ffi 0 2 ; s 0 ) succeeds with computed answer 2 and = mgu (ffi 0 ; ffi 1 ii ffi <p> Proof: Using Lemma 1. Success. Then there exists a successful SLDNF-derivation <ref> [21] </ref> . Such a derivation must contain a finite number k of selected literals of the form transfl (ffi 1 ; s 1 ; ffi 2 ; s 2 ). The thesis is proven by induction on such a number k. Failure. Then there exists a finitely failed SLDNF-tree [21] formed <p> SLDNF-derivation <ref> [21] </ref> . Such a derivation must contain a finite number k of selected literals of the form transfl (ffi 1 ; s 1 ; ffi 2 ; s 2 ). The thesis is proven by induction on such a number k. Failure. Then there exists a finitely failed SLDNF-tree [21] formed by failed SLDNF-derivations each of which contains a finite number of selected literals of the form transfl (ffi 1 ; s 1 ; ffi 2 ; s 2 ). <p> Hence we can prove the lemma using the following three nested induc tions: * Induction on the rank of successful SLDNF-derivations/finitely failed SLDNF-trees (i.e., the depth of nesting of auxiliary finitely failed SLDNF-trees) <ref> [21] </ref>. * Induction on the number of selected literals of the form trans (P ( ~ t); s 1 ; ffi 2 ; s 2 ) (final (P ( ~ t); s 1 )) occurring in a successful SLDNF-derivation, for success.
Reference: [22] <author> J. McCarthy and P. Hayes. </author> <title> Some philosophical problems from the standpoint of artificial intelligence. </title> <booktitle> In Machine Intelligence, </booktitle> <volume> vol. 4, </volume> <publisher> Edinburgh University Press, </publisher> <year> 1969. </year> <month> 40 </month>
Reference-contexts: An interpreter for such programs must reason about the preconditions and effects of actions in the program to find legal executions. So we need a language to specify such domain theories. For this, we use the situation calculus <ref> [22] </ref>, a first-order language (with some second-order features) for representing dynamic domains. In this formalism, all changes to the world are the result of named actions. A possible world history, which is simply a sequence of actions, is represented by a first-order term called a situation.
Reference: [23] <author> R. Milner. </author> <title> Communication and Concurrency. </title> <publisher> Prentice Hall, </publisher> <year> 1989. </year>
Reference-contexts: Of course ours is not the first formal model of concurrency. In fact, well developed approaches are available <ref> [16, 23, 4, 35] </ref> 1 and our work inherits many of the intuitions behind them. However, it is distinguished from these in at least two fundamental ways. First, it allows incomplete information about the environment surrounding the program.
Reference: [24] <author> G. Plotkin. </author> <title> A structural approach to operational semantics. </title> <type> Technical Report DAIMI-FN-19, </type> <institution> Computer Science Department Aarhus University Denmark, </institution> <year> 1981. </year>
Reference-contexts: already first-order terms. 4.1 Trans and Final Let us formally define Trans and Final, which intuitively specify: * what are the possible transitions between configurations (Trans). * when a configuration can be considered final (Final). 5 Both types of semantics belong to the family of structural operational semantics introduced in <ref> [24] </ref>. 6 Observe that Final and Trans cannot occur in tests, hence self-reference is disallowed. 7 It is convenient to introduce a special program nil, called the empty program, to denote the fact that nothing remains to be performed (legal termination).
Reference: [25] <author> D. Pym, L. Pryor, D. Murphy. </author> <title> Processes for plan-execution. </title> <booktitle> In Proceedings of the 14th Workshop of the UK Planning and Scheduling Special Interest Group, </booktitle> <year> 1995 </year>
Reference-contexts: The section concludes with changes to the Golog specification required to handle concurrency. In Section 6, we illustrate the use of ConGolog by going over several example programs. Then in Section 7, we extend the specification given in Section 5 1 In <ref> [25, 5] </ref> a direct use of such approaches to model concurrent (complex) actions in AI is investigated. 2 to handle procedures and recursion. In Section 8, we present a Prolog interpreter for ConGolog and prove its correctness.
Reference: [26] <author> A. S. Rao. AgentSpeak(L): </author> <title> BDI agents speak out in a logical computable language. In Agents Breaking Away, </title> <editor> W. Van der Velde and J. W. Perram, editors, </editor> <volume> LNAI 1038, </volume> <pages> pages 42-55, </pages> <publisher> Springer-Verlag, </publisher> <year> 1996. </year>
Reference-contexts: Thus, our work is related to earlier research on resource-bounded deliberative architectures such as [2] (IRMA) and [27] (PRS), and agent programming languages that are to some extent based on this kind of architectures, such as AGENT-0 [34], AgentSpeak (L) <ref> [26] </ref>, and 3APL [15]. One difference is that in ConGolog, domain dynamics are specified declaratively and the specification is used automatically in program execution; there is no need to program the updating of a world model when actions are performed. <p> There has been much work on agent programming languages recently and several proposed languages share features with ConGolog. Concurrent MetateM [11] supports concurrency and uses a temporal logic to specify the behavior of agents. The rule-based languages AgentSpeak (L) <ref> [26] </ref> and 3APL [15] as well as van Eijk et al.'s [10] concurrent-constraint-based language all come with formal semantics specified using transition systems. There are also similarities with the work of Bonner and Kifer [3], where a logical formalism is proposed for concurrent database transactions.
Reference: [27] <author> A. S. Rao and M. P. Georgeff. </author> <title> An abstract architecture for rational agents. </title> <booktitle> In Proceedings of the 3rd International Conference on Principles of Knowledge Representation and Reasoning (KR'92), </booktitle> <editor> B. Nebel, C. Rich, and W. Swartout, editors, </editor> <address> pages 439-449, </address> <publisher> Morgan Kaufmann Publishing, </publisher> <year> 1992. </year>
Reference-contexts: Thus, our work is related to earlier research on resource-bounded deliberative architectures such as [2] (IRMA) and <ref> [27] </ref> (PRS), and agent programming languages that are to some extent based on this kind of architectures, such as AGENT-0 [34], AgentSpeak (L) [26], and 3APL [15].
Reference: [28] <author> R. Reiter. </author> <title> The frame problem in the situation calculus: A simple solution (sometimes) and a completeness result for goal regression. </title> <booktitle> In Artificial Intelligence and Mathematical Theory of Computation: Papers in Honor of John McCarthy, </booktitle> <pages> pages 359-380. </pages> <publisher> Academic Press, </publisher> <year> 1991. </year>
Reference-contexts: This complicates the task of axiomatizing a domain and can make theorem proving extremely inefficient. To deal with the frame problem, we use an approach due to Reiter <ref> [28] </ref>. The basic idea behind this is to collect all effect axioms about a given fluent and make a completeness assumption, i.e. assume that they specify all of the ways that the value of the fluent may change.
Reference: [29] <author> R. Reiter. </author> <title> Proving properties of states in the situation calculus. </title> <journal> Artificial Intelligence, </journal> <volume> 64, </volume> <pages> 337-351, </pages> <year> 1993. </year>
Reference-contexts: Since the foundational axioms play no special role in this paper, we omit them. For details, and for some of their metamathematical properties, see Lin and Reiter [18] and Reiter <ref> [29] </ref>.
Reference: [30] <author> R. Reiter. </author> <title> Natural actions, concurrency and continuous time in the situation calculus. </title> <booktitle> In Proceedings of the 5th International Conference on Principles of Knowledge Representation and Reasoning (KR'96), </booktitle> <pages> pages 2-13, </pages> <publisher> Morgan Kaufmann Publishing, </publisher> <year> 1996. </year>
Reference-contexts: More--over, the prospect of replacing the filling action by a large number of component actions (that could be interleaved with the singing ones) is even less appealing. To deal with this type of case, we recommend the following approach (see <ref> [30] </ref> for a detailed presentation): instead of thinking of filling the bathtub as an action or group of actions, think of it as a state that an agent could be in, extending possibly over many situations.
Reference: [31] <author> R. Reiter. </author> <title> Knowledge in Action: Logical Foundation for Describing and Implementing Dynamical Systems. </title> <note> In preparation. </note>
Reference-contexts: As well, the Prolog predicate sub=4 implements the substitution so that sub (x; y; t; t 0 ) means that t 0 = t x y . The definition of these two Prolog predicates is taken from <ref> [20, 31] </ref>. <p> These restrictions force the closed world assumption (Prolog CWA) on the initial situation and the unique name assumption (UNA) on both actions and objects. For an in-depth study on action theories expressible as Prolog clauses, we refer to <ref> [31] </ref>. 8.1 Example Below, we give an implementation in Prolog of the two robots lifting a table scenario discussed in subsection 6.1. The code is written as close to the specification as possible. <p> on goals of the form not trans (ffi; s; ; ) 19 with non-ground ffi and s. 20 Observe that the hypotheses required for sub=4, holds=2 and poss=2 do hold when these predicates are defined as above and run by an interpreter that flounders on non ground negative goals (see <ref> [31] </ref>). Theorem 2: Under the hypotheses above the following holds: 1.
Reference: [32] <author> S. Shapiro, Y. Lesperance, and H.J. Levesque. </author> <title> Specifying communicative multiagent systems. </title> <editor> In W. Wobcke, M. Pagnucco, and C. </editor> <booktitle> Zhang Agents and Multi-Agent Systems - Formalisms, Methodologies, and Applications, LNAI 1441, </booktitle> <pages> pages 1-14, </pages> <publisher> Springer-Verlag, </publisher> <year> 1998. </year>
Reference-contexts: (conc (P1,P2),S) :- final (P1,S),final (P2,S). final (prconc (P1,P2),S) :- final (P1,S),final (P2,S). final (iterconc (P),S). final (pcall (P_Args)) :- sub (now,S,P_Args,P_ArgsS), proc (P_ArgsS,P),final (P,S). 28 /* trans*(Prog,Sit,Prog_r,Sit_r) */ trans*(P,S,P,S). trans*(P,S,Pr,Sr) :- trans (P,S,PP,SS), trans*(PP,SS,Pr,Sr). /* do (Prog,Sit,Sit_r) */ do (P,S,Sr) :- trans*(P,S,Pr,Sr),final (Pr,Sr). /* holds (Cond,Sit): as defined in <ref> [32] </ref> */ holds (and (F1,F2),S) :- holds (F1,S), holds (F2,S). holds (or (F1,F2),S) :- holds (F1,S); holds (F2,S). holds (all (V,F),S) :- holds (neg (some (V,neg (F))),S). holds (some (V,F),S) :- sub (V,_,F,Fr), holds (Fr,S). holds (neg (neg (F)),S) :- holds (F,S). holds (neg (and (F1,F2)),S) :- holds (or (neg (F1),neg <p> (neg (some (V,F)),S) :- not holds (some (V,F),S). /* Negation by failure */ holds (P_Xs,S) :- P_Xs"=and (_,_),P_Xs"=or (_,_),P_Xs"=neg (_),P_Xs"=all (_,_),P_Xs"=some (_._), sub (now,S,P_Xs,P_XsS), P_XsS. holds (neg (P_Xs),S) :- P_Xs"=and (_,_),P_Xs"=or (_,_),P_Xs"=neg (_),P_Xs"=all (_,_),P_Xs"=some (_._), sub (now,S,P_Xs,P_XsS), not P_XsS. /* Negation by failure */ /* sub (Const,Var,Term1,Term2): as defined in <ref> [32] </ref> */ sub (X,Y,T,Tr) :- var (T), Tr = T. sub (X,Y,T,Tr) :- T "= X, T =..[F|Ts], sub_list (X,Y,Ts,Trs), Tr =..[F|Trs]. sub_list (X,Y,[],[]). sub_list (X,Y,[T|Ts],[Tr|Trs]) :- sub (X,Y,T,Tr), sub_list (X,Y,Ts,Trs). In this implementation a ConGolog application is expected to have the following parts: 1. <p> The ConGolog controller was interfaced to navigation software and successfully tested on a RWI B12 mobile robot. Work has also been done on using ConGolog to model multiagent systems <ref> [32] </ref>. In this case, the domain theory includes fluents that model the beliefs and goals of the system's agents (this is done by adapting a possible-world semantics of such mental states to the is always first-order representable and can be computed efficiently; see [19] for details. 38 situation calculus). <p> A ConGolog program is used to specify the complex behavior of the agents in such a system. A simple multiagent meeting scheduling example is specified in <ref> [32] </ref>. ConGolog-based tools for specifying and verifying complex multiagent systems are being investigated.
Reference: [33] <author> J. R. Shoenfield. </author> <title> Mathematical Logic. </title> <publisher> Addison-Wesley, </publisher> <year> 1967. </year>
Reference-contexts: However, Trans, which is not closed under the constraints for T in its definition, does not satisfy the assumption in general [6]. However, we get the desired result by noticing that the equivalences assumed for Trans form a conservative extension (see e.g. <ref> [33] </ref>) of domain theory D plus the axioms needed for the encoding of programs as first-order terms, and appealing to the following general result: 35 Proposition 1: Let be a consistent theory, [ fg a conservative extension of where is a closed first-order formula, and P a predicate occurring in but
Reference: [34] <author> Y. Shoham. </author> <title> Agent-oriented programming. </title> <journal> Artificial Intelligence, </journal> <volume> 60, </volume> <pages> 51-92, </pages> <year> 1993. </year>
Reference-contexts: Thus, our work is related to earlier research on resource-bounded deliberative architectures such as [2] (IRMA) and [27] (PRS), and agent programming languages that are to some extent based on this kind of architectures, such as AGENT-0 <ref> [34] </ref>, AgentSpeak (L) [26], and 3APL [15]. One difference is that in ConGolog, domain dynamics are specified declaratively and the specification is used automatically in program execution; there is no need to program the updating of a world model when actions are performed.
Reference: [35] <author> C. Stirling. </author> <title> Modal and temporal logics for processes. In Logics for Concurrency: Structure versus Automata, </title> <publisher> LNCS 1043, </publisher> <pages> pages 149-237. </pages> <publisher> Springer-Verlag, </publisher> <year> 1996. </year>
Reference-contexts: Of course ours is not the first formal model of concurrency. In fact, well developed approaches are available <ref> [16, 23, 4, 35] </ref> 1 and our work inherits many of the intuitions behind them. However, it is distinguished from these in at least two fundamental ways. First, it allows incomplete information about the environment surrounding the program.
Reference: [36] <author> A. Tarski. </author> <title> A lattice-theoretical fixpoint theorem and its applications. </title> <journal> Pacific Journal of Mathematics,5, </journal> <pages> 285-309, </pages> <year> 1955. </year> <month> 41 </month>
References-found: 36

