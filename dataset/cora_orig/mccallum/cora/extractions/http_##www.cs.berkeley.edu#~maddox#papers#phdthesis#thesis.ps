URL: http://www.cs.berkeley.edu/~maddox/papers/phdthesis/thesis.ps
Refering-URL: http://http.cs.berkeley.edu/~maddox/papers/phdthesis/abstract.html
Root-URL: http://www.cs.berkeley.edu
Title: Incremental Static Semantic Analysis  
Author: William Harry Maddox III 
Date: January 31, 1997  
Abstract: 1 This research was supported in part by Advanced Research Projects Agency grant MDA972-92-J-1028, and by NSF grant CDA-8722788. The content of this paper does not necessarily reflect the position or the policy of the U. S. Government. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Harvey Abramson. </author> <title> Definite clause translation grammars. </title> <booktitle> In International Symposium on Logic Programming, </booktitle> <pages> pages 233-240. </pages> <publisher> IEEE Press, </publisher> <year> 1984. </year>
Reference-contexts: For example, the tuple type representing pairs of integers and strings is denoted (Integer, String), and has (1, "foo") as a 15 typical value. Likewise, the list type representing a sequence of integers is denoted [Integer] and has <ref> [1, 2, 3, 4, 5] </ref> as a typical value. A list may also be constructed by prepending a sequence of components to an existing list using the "|" notation. <p> A list may also be constructed by prepending a sequence of components to an existing list using the "|" notation. For example, if the variable Rest has been previously bound to the list [3, 4, 5], then <ref> [1, 2 | Rest] </ref> = [1, 2, 3, 4, 5]. The symbol "|" is part of the syntax of the list constructor, and may not be used in other contexts. Term types are similar in function to the variant records or type unions found in many other languages. <p> A list may also be constructed by prepending a sequence of components to an existing list using the "|" notation. For example, if the variable Rest has been previously bound to the list [3, 4, 5], then [1, 2 | Rest] = <ref> [1, 2, 3, 4, 5] </ref>. The symbol "|" is part of the syntax of the list constructor, and may not be used in other contexts. Term types are similar in function to the variant records or type unions found in many other languages. <p> Stack_Push (self.SUPPORTS <ref> [1] </ref>, *saved-supports*) Retract_Support (self.SUPPORTS [1]) self.SUPPORTS [1] = nil % Dynamically-bind DDC variables to node and visit % during evaluation of attributes. let *ddc-context* = self and *ddc-visit* = 1 in % Evaluate attributes here. % Invoke maintained function (method of remote object). : : : Ctx.VisibleBinding.EVAL (TextOf (self.Name)) : : <p> Stack_Push (self.SUPPORTS <ref> [1] </ref>, *saved-supports*) Retract_Support (self.SUPPORTS [1]) self.SUPPORTS [1] = nil % Dynamically-bind DDC variables to node and visit % during evaluation of attributes. let *ddc-context* = self and *ddc-visit* = 1 in % Evaluate attributes here. % Invoke maintained function (method of remote object). : : : Ctx.VisibleBinding.EVAL (TextOf (self.Name)) : : : % Clean up <p> Stack_Push (self.SUPPORTS <ref> [1] </ref>, *saved-supports*) Retract_Support (self.SUPPORTS [1]) self.SUPPORTS [1] = nil % Dynamically-bind DDC variables to node and visit % during evaluation of attributes. let *ddc-context* = self and *ddc-visit* = 1 in % Evaluate attributes here. % Invoke maintained function (method of remote object). : : : Ctx.VisibleBinding.EVAL (TextOf (self.Name)) : : : % Clean up 'stale' dependencies. <p> In the case of a non-maintained functional component, where we do not create an NLDL, the registration method is a dummy which does nothing but return false. 84 method Block.VISIT_1 (Ctx) Stack_Push (self.SUPPORTS <ref> [1] </ref>, *saved-supports*) Retract_Support (self.SUPPORTS [1]) self.SUPPORTS [1] = nil % Dynamically-bind DDC variables to node and visit % during evaluation of attributes. let *ddc-context* = self and *ddc-visit* = 1 in LocalBinding_STATUS = : : : % Attribute 'Parent' is in the closure for 'BodyCtx.VisibleBinding' % and must therefore be saved <p> In the case of a non-maintained functional component, where we do not create an NLDL, the registration method is a dummy which does nothing but return false. 84 method Block.VISIT_1 (Ctx) Stack_Push (self.SUPPORTS <ref> [1] </ref>, *saved-supports*) Retract_Support (self.SUPPORTS [1]) self.SUPPORTS [1] = nil % Dynamically-bind DDC variables to node and visit % during evaluation of attributes. let *ddc-context* = self and *ddc-visit* = 1 in LocalBinding_STATUS = : : : % Attribute 'Parent' is in the closure for 'BodyCtx.VisibleBinding' % and must therefore be saved within the AST. parent <p> In the case of a non-maintained functional component, where we do not create an NLDL, the registration method is a dummy which does nothing but return false. 84 method Block.VISIT_1 (Ctx) Stack_Push (self.SUPPORTS <ref> [1] </ref>, *saved-supports*) Retract_Support (self.SUPPORTS [1]) self.SUPPORTS [1] = nil % Dynamically-bind DDC variables to node and visit % during evaluation of attributes. let *ddc-context* = self and *ddc-visit* = 1 in LocalBinding_STATUS = : : : % Attribute 'Parent' is in the closure for 'BodyCtx.VisibleBinding' % and must therefore be saved within the AST. parent = Ctx <p> Caches are thus never provided for global functions. 7.8 Related Work Vogt, Swierstra, and Kuiper [75] have applied caching to the visit functions for evaluating OAGs in order to build an incremental evaluator for classical AGs in a functional setting. They extend their 87 method Block.VISIT_1 (Ctx) Stack_Push (self.SUPPORTS <ref> [1] </ref>, *saved-supports*) Retract_Support (self.SUPPORTS [1]) self.SUPPORTS [1] = nil let *ddc-context* = self and *ddc-visit* = 1 in LocalBinding_STATUS = : : : parent = Ctx self.BodyCtx_VisibleBinding_CHANGED = false when parent.Add_NLD_VisibleBinding (0) then self.BodyCtx_VisibleBinding_CHANGED = true unless parent == self.BodyCtx.Parent then self.BodyCtx.Parent = parent self.BodyCtx_VisibleBinding_CHANGED = true % Notify any context <p> They extend their 87 method Block.VISIT_1 (Ctx) Stack_Push (self.SUPPORTS <ref> [1] </ref>, *saved-supports*) Retract_Support (self.SUPPORTS [1]) self.SUPPORTS [1] = nil let *ddc-context* = self and *ddc-visit* = 1 in LocalBinding_STATUS = : : : parent = Ctx self.BodyCtx_VisibleBinding_CHANGED = false when parent.Add_NLD_VisibleBinding (0) then self.BodyCtx_VisibleBinding_CHANGED = true unless parent == self.BodyCtx.Parent then self.BodyCtx.Parent = parent self.BodyCtx_VisibleBinding_CHANGED = true % Notify any context that examines 'BodyCtx.Parent' remotely. <p> They extend their 87 method Block.VISIT_1 (Ctx) Stack_Push (self.SUPPORTS <ref> [1] </ref>, *saved-supports*) Retract_Support (self.SUPPORTS [1]) self.SUPPORTS [1] = nil let *ddc-context* = self and *ddc-visit* = 1 in LocalBinding_STATUS = : : : parent = Ctx self.BodyCtx_VisibleBinding_CHANGED = false when parent.Add_NLD_VisibleBinding (0) then self.BodyCtx_VisibleBinding_CHANGED = true unless parent == self.BodyCtx.Parent then self.BodyCtx.Parent = parent self.BodyCtx_VisibleBinding_CHANGED = true % Notify any context that examines 'BodyCtx.Parent' remotely. <p> Binds_STATUS = self.Decls.VISIT_1 () % If the child pointer has changed, the status value from the % child visit is not reliable. Binds_STATUS = Binds_STATUS or self.CHILD_MODIFIED <ref> [1] </ref> % Retry maintained relation if needed, determining exact change status. Binds_STATUS = Retry_Cached_Tuples (self.BodyCtx.Binds, Binds_STATUS) when Binds_STATUS then % Notify dynamic successors. NLDL_Notify (self.NLDL_Binds) % Since this is the last visit to 'Block', clear the % 'CHILD_MODIFIED' flags. CHILD_MODIFIED [1] = false return Changes to the tree structure are recorded <p> Binds_STATUS = Binds_STATUS or self.CHILD_MODIFIED <ref> [1] </ref> % Retry maintained relation if needed, determining exact change status. Binds_STATUS = Retry_Cached_Tuples (self.BodyCtx.Binds, Binds_STATUS) when Binds_STATUS then % Notify dynamic successors. NLDL_Notify (self.NLDL_Binds) % Since this is the last visit to 'Block', clear the % 'CHILD_MODIFIED' flags. CHILD_MODIFIED [1] = false return Changes to the tree structure are recorded in a vector of child-modified bits in each node, one for each child. The incremental parser sets a bit whenever it changes the value of the corresponding child pointer. <p> We provide a means for clients to register interest in these notifications via callback procedures. 8.6 Related Work Abramson's Definite Clause Translation Grammars <ref> [1] </ref> are essentially attribute grammars in which all attributes are synthesized relational attributes. His implementation is embedded in Prolog, whose "call by unification" parameter passing scheme allows data to flow in both directions, thus obtaining the effect of inherited as well as synthesized (non-relational) attributes.
Reference: [2] <author> Rolf Bahlke and Gregor Snelting. </author> <title> The PSG system: From formal language definitions to interactive programming environments. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 8(4) </volume> <pages> 547-576, </pages> <month> October </month> <year> 1986. </year>
Reference-contexts: Such fine-grained versioning is not provided in traditional environments, which track changes in terms of entire lines of text. A number of language-based programming environments have been constructed as research prototypes, including Gandalf [52], Centaur [8], the Synthesizer Generator [67], Pan [3], PSG <ref> [2] </ref>, and Integral-C [68]. <p> Vorthmann and LeBlanc [76] abandon generality altogether, providing instead a specialized high-level notation for specifying name resolution rules. A similar task-specific approach is taken in PSG <ref> [2] </ref>. 2.3 Enriching the AG Formalism Colander [4], the incremental analyzer for Pan, eschewed AG technology altogether, taking an alternate approach based on incremental logic programming. <p> For example, the tuple type representing pairs of integers and strings is denoted (Integer, String), and has (1, "foo") as a 15 typical value. Likewise, the list type representing a sequence of integers is denoted [Integer] and has <ref> [1, 2, 3, 4, 5] </ref> as a typical value. A list may also be constructed by prepending a sequence of components to an existing list using the "|" notation. <p> A list may also be constructed by prepending a sequence of components to an existing list using the "|" notation. For example, if the variable Rest has been previously bound to the list [3, 4, 5], then [1, 2 | Rest] = <ref> [1, 2, 3, 4, 5] </ref>. The symbol "|" is part of the syntax of the list constructor, and may not be used in other contexts. Term types are similar in function to the variant records or type unions found in many other languages.
Reference: [3] <author> R. A. Ballance, S. L. Graham, and M. L. Van De Vanter. </author> <title> The Pan language-based editing system. </title> <journal> ACM Transactions on Software Engineering and Methodology, </journal> <volume> 1(1) </volume> <pages> 95-127, </pages> <year> 1992. </year>
Reference-contexts: Such fine-grained versioning is not provided in traditional environments, which track changes in terms of entire lines of text. A number of language-based programming environments have been constructed as research prototypes, including Gandalf [52], Centaur [8], the Synthesizer Generator [67], Pan <ref> [3] </ref>, PSG [2], and Integral-C [68]. <p> For example, the tuple type representing pairs of integers and strings is denoted (Integer, String), and has (1, "foo") as a 15 typical value. Likewise, the list type representing a sequence of integers is denoted [Integer] and has <ref> [1, 2, 3, 4, 5] </ref> as a typical value. A list may also be constructed by prepending a sequence of components to an existing list using the "|" notation. <p> A list may also be constructed by prepending a sequence of components to an existing list using the "|" notation. For example, if the variable Rest has been previously bound to the list <ref> [3, 4, 5] </ref>, then [1, 2 | Rest] = [1, 2, 3, 4, 5]. The symbol "|" is part of the syntax of the list constructor, and may not be used in other contexts. <p> A list may also be constructed by prepending a sequence of components to an existing list using the "|" notation. For example, if the variable Rest has been previously bound to the list [3, 4, 5], then [1, 2 | Rest] = <ref> [1, 2, 3, 4, 5] </ref>. The symbol "|" is part of the syntax of the list constructor, and may not be used in other contexts. Term types are similar in function to the variant records or type unions found in many other languages. <p> The compiled descriptions are dynamically linked and loaded into the host environment on demand as needed. The compiler supports multiple back ends, allowing a single program to process language descriptions descriptions for all supported environments. Currently, Colander II supports two host environments: Pan <ref> [3] </ref> and Ensemble [29]. Support for Pan is the most complete, and was implemented by the author. A port to Ensemble was performed by Nicholas Weaver.
Reference: [4] <author> Robert Alan Ballance. </author> <title> Syntactic and semantic checking in language-based editing systems. </title> <type> Technical Report UCB/CSD 89/548, </type> <institution> Computer Science Division, University of California, Berkeley, </institution> <year> 1989. </year> <type> Ph.D. dissertation. </type>
Reference-contexts: Vorthmann and LeBlanc [76] abandon generality altogether, providing instead a specialized high-level notation for specifying name resolution rules. A similar task-specific approach is taken in PSG [2]. 2.3 Enriching the AG Formalism Colander <ref> [4] </ref>, the incremental analyzer for Pan, eschewed AG technology altogether, taking an alternate approach based on incremental logic programming. Colander introduced a new attribution paradigm called Logical Constraint Grammars in which the AST induces not a set of equational constraints, but a set of Prolog-like goals. <p> For example, the tuple type representing pairs of integers and strings is denoted (Integer, String), and has (1, "foo") as a 15 typical value. Likewise, the list type representing a sequence of integers is denoted [Integer] and has <ref> [1, 2, 3, 4, 5] </ref> as a typical value. A list may also be constructed by prepending a sequence of components to an existing list using the "|" notation. <p> A list may also be constructed by prepending a sequence of components to an existing list using the "|" notation. For example, if the variable Rest has been previously bound to the list <ref> [3, 4, 5] </ref>, then [1, 2 | Rest] = [1, 2, 3, 4, 5]. The symbol "|" is part of the syntax of the list constructor, and may not be used in other contexts. <p> A list may also be constructed by prepending a sequence of components to an existing list using the "|" notation. For example, if the variable Rest has been previously bound to the list [3, 4, 5], then [1, 2 | Rest] = <ref> [1, 2, 3, 4, 5] </ref>. The symbol "|" is part of the syntax of the list constructor, and may not be used in other contexts. Term types are similar in function to the variant records or type unions found in many other languages. <p> a named type object to a node where it is accessed by the function IsCyclic as a dynamic selection. 71 % These global variable hold the current dynamic dependency context. global *ddc-context* % Node currently being visited. global *ddc-visit* % Visit number of current visit. method TypeDecl.VISIT_4 (Ctx) Retract_Supports (self.SUPPORTS <ref> [4] </ref>) % Dynamically-bind DDC variables to node and visit % during evaluation of attributes. let *ddc-context* = self and *ddc-visit* = 1 in % Call out-of-line boolean-valued function. : : : CyclicType (self.TypeObj) : : : function CyclicType (Ty) CyclicTypeAux (Ty, nil) function CyclicTypeAux (Ty, Trail) % Register dynamic selection of <p> By caching the 1 This term is used by Hoover [37] in exactly the same sense as we use it here. We chose it in analogy to the "maintained properties" of Ballance's Colander system <ref> [4] </ref>, which inspired many aspects of the present work. 78 argument/result pairs observed at each function attribute, it can be determined when the observed mapping has actually changed, and thereby the status value for the attribute can be refined. First the "incoming" status is computed as before. <p> Although they call their technique "relational attribution," the relations are all defined at top-level, and do not decorate the tree. Only the assertions actually appear within the AST operators. Colander <ref> [4] </ref> provided collections as first-class objects that could be transmitted as data values within the language description. We eschew this generality in the interest of efficiency. Our relational attributes are much more amenable to static analysis than Colander's first-class collections. <p> which accommodated limitations in the incremental parser we rely on, which cannot handle situations requiring feedback from semantic analysis to the parser, e.g., the use of type names defined via typedef in C. * Modula-2 was used as a full-scale example for the old Colander system described by Bal lance <ref> [4] </ref>, allowing us to build a similar description for Colander II. Our coverage of the language is similar to the description developed for Colander by Ballance, omitting the contents of the SYSTEM module, as well as the new types LONGINT and LONGREAL introduced in later editions of the Modula-2 report.
Reference: [5] <editor> Fran~cois Bancilhon and Peter Buneman, editors. </editor> <booktitle> Advances in Database Programming Languages. </booktitle> <publisher> ACM Press, </publisher> <year> 1990. </year>
Reference-contexts: For example, the tuple type representing pairs of integers and strings is denoted (Integer, String), and has (1, "foo") as a 15 typical value. Likewise, the list type representing a sequence of integers is denoted [Integer] and has <ref> [1, 2, 3, 4, 5] </ref> as a typical value. A list may also be constructed by prepending a sequence of components to an existing list using the "|" notation. <p> A list may also be constructed by prepending a sequence of components to an existing list using the "|" notation. For example, if the variable Rest has been previously bound to the list <ref> [3, 4, 5] </ref>, then [1, 2 | Rest] = [1, 2, 3, 4, 5]. The symbol "|" is part of the syntax of the list constructor, and may not be used in other contexts. <p> A list may also be constructed by prepending a sequence of components to an existing list using the "|" notation. For example, if the variable Rest has been previously bound to the list [3, 4, 5], then [1, 2 | Rest] = <ref> [1, 2, 3, 4, 5] </ref>. The symbol "|" is part of the syntax of the list constructor, and may not be used in other contexts. Term types are similar in function to the variant records or type unions found in many other languages. <p> See, for example, the volume edited by Bancilhon and Buneman <ref> [5] </ref>. As we investigated the implementation issues, however, we retreated somewhat from the ideal of a DBPL to a formalism that had a straightforward operational semantics, thus having no need for query optimization or similar technology. <p> Declarations would then have to include a node reference for the declared name in the Binds relation, so that errors could be asserted at the proper location. 103 declare var r : integer; (A) type aryptr = pointer to ary; (B) type ary = array <ref> [ 5 ] </ref> of integer; (C) var v : ary; (D) var w : aryptr; (E) var x : array [ 10 ] of aryptr; (F) var y : integer; (G) var z : array [ 50 ] of integer (H) begin declare Repeat this block 25 times type p1 = <p> var y : integer; (G) var z : array [ 50 ] of integer (H) begin declare Repeat this block 25 times type p1 = pointer to p2; (I) type p2 = pointer to ary; (J) var s : p1; (K) var u : integer; (M) var v : array <ref> [ 5 ] </ref> of integer (N) begin y := 1; y := u + z [5]; (O) u := v [u]; declare var v : integer (P) begin v := v + u (Q) v := t^; t := s^ y := 1; Repeat next 5 statements 5 times z [5] <p> begin declare Repeat this block 25 times type p1 = pointer to p2; (I) type p2 = pointer to ary; (J) var s : p1; (K) var u : integer; (M) var v : array [ 5 ] of integer (N) begin y := 1; y := u + z <ref> [5] </ref>; (O) u := v [u]; declare var v : integer (P) begin v := v + u (Q) v := t^; t := s^ y := 1; Repeat next 5 statements 5 times z [5] := y; w^[1] := y; y := 1; Repeat next 5 statements 5 times z <p> [ 5 ] of integer (N) begin y := 1; y := u + z <ref> [5] </ref>; (O) u := v [u]; declare var v : integer (P) begin v := v + u (Q) v := t^; t := s^ y := 1; Repeat next 5 statements 5 times z [5] := y; w^[1] := y; y := 1; Repeat next 5 statements 5 times z [5] := y; w^[1] := y; end 104 Change Errors Timings Avg. <p> (O) u := v [u]; declare var v : integer (P) begin v := v + u (Q) v := t^; t := s^ y := 1; Repeat next 5 statements 5 times z <ref> [5] </ref> := y; w^[1] := y; y := 1; Repeat next 5 statements 5 times z [5] := y; w^[1] := y; end 104 Change Errors Timings Avg.
Reference: [6] <author> George McArthur Beshers and Roy Harold Campbell. </author> <title> Maintained and constructor attributes. </title> <booktitle> In ACM SIGPLAN '85 Symposium on Language Issues in Programming Environments, </booktitle> <pages> pages 34-42, </pages> <year> 1985. </year>
Reference-contexts: The need for direct support of long-distance attribute dependencies and aggregate attributes was recognized early, and a number of rather limited or ad hoc methods were proposed. Beshers and Campbell <ref> [6] </ref> provide a means to integrate handwritten subsystems, e.g., a symbol table package, with an attribute grammar. The mechanism is error prone, as it relies on the user to account for the dependencies carried by the handwritten code. <p> Given programmer-supplied declarations, the instances of the classes can be incorporated into an AG in a semi-automatic way, similar to the approach of Beshers and Campbell <ref> [6] </ref>. Boyland [10] permits remote access to the attributes of a node via a node reference, as if the entire node were itself an object in our sense. For example, rather than using an object to represent a declared entity, Boyland uses the entire attributed AST node for the declaration.
Reference: [7] <author> Gunther Blaschek and Gustave Pomberger. </author> <title> Introduction to Programming with Modula-2. </title> <publisher> Springer-Verlag, </publisher> <year> 1990. </year>
Reference-contexts: The Modula-2 report is unclear on many points, and is not an exemplary defining document. We relied on Blaschek and Pomberger <ref> [7] </ref> and Cornelius [14] for clarification on a number of points.
Reference: [8] <author> P Borras, D. Clement, Th. Despeyroux, J. Incerpi, G. Kahn, B. Lang, and V. Pascual. </author> <title> CENTAUR: The system. </title> <editor> In Peter Henderson, editor, </editor> <booktitle> ACM SIGSOFT '88: Third Symposium on Software Development Environments, </booktitle> <pages> pages 14-24, </pages> <year> 1988. </year>
Reference-contexts: Such fine-grained versioning is not provided in traditional environments, which track changes in terms of entire lines of text. A number of language-based programming environments have been constructed as research prototypes, including Gandalf [52], Centaur <ref> [8] </ref>, the Synthesizer Generator [67], Pan [3], PSG [2], and Integral-C [68].
Reference: [9] <author> John Boyland. </author> <type> Personal communication. </type>
Reference-contexts: Since such an object may be reached after an arbitrary number of traversals of the Type component, however, no finite prefix approximation can distinguish the case in which, say, the final component selected is IsCyclic from the one in which it is Type. Indeed, Boyland <ref> [9] </ref> claims that the prefix-based approximation as described by Farrow is flawed, and fails to account for all dependencies, according to the best understanding he could derive from the draft.
Reference: [10] <author> John Tang Boyland. </author> <title> Descriptional composition of compiler components. </title> <type> Technical Report UCB/CSD-96-916, </type> <institution> Computer Science Division, University of California, Berkeley, </institution> <month> September </month> <year> 1996. </year> <type> Ph.D. dissertation. </type>
Reference-contexts: We do not permit remote constraints, in contrast to Boyland's formalism <ref> [10] </ref>. 12 functions, due to the way that our implementation treats the incremental evaluation of functional attributes. Conceptually, a function represents a possibly infinite set of argument/result tuples. <p> ADL is thus quite conventional in this respect, although we have borrowed a few notations from the logic programming tradition. Recently, Boyland <ref> [10] </ref> has designed and implemented an elaborate attribute grammar extension aimed at constructing complete language descriptions from the composition of smaller components. The underlying attribution paradigm is highly unconventional, and, while interesting on its own terms, poses new implementation challenges that we chose to avoid in our own work. <p> Given programmer-supplied declarations, the instances of the classes can be incorporated into an AG in a semi-automatic way, similar to the approach of Beshers and Campbell [6]. Boyland <ref> [10] </ref> permits remote access to the attributes of a node via a node reference, as if the entire node were itself an object in our sense. For example, rather than using an object to represent a declared entity, Boyland uses the entire attributed AST node for the declaration. <p> Binds relation, so that errors could be asserted at the proper location. 103 declare var r : integer; (A) type aryptr = pointer to ary; (B) type ary = array [ 5 ] of integer; (C) var v : ary; (D) var w : aryptr; (E) var x : array <ref> [ 10 ] </ref> of aryptr; (F) var y : integer; (G) var z : array [ 50 ] of integer (H) begin declare Repeat this block 25 times type p1 = pointer to p2; (I) type p2 = pointer to ary; (J) var s : p1; (K) var u : integer;
Reference: [11] <author> Yih-Farn Chen, Michael Y. Nishimoto, and C. V. Ramamoorthy. </author> <title> The C information abstraction system. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 16(3) </volume> <pages> 325-334, </pages> <month> March </month> <year> 1990. </year>
Reference-contexts: In this way, the derived information created by any tool is available to any other that can make use of it. Code analysis and browsing tools such as the C Information Abstractor of Chen et al. <ref> [11] </ref> build a global program database that can then be queried by a programmer attempting to understand the structure 1 of a software system. Every source file is processed once by the compiler to produce an object file, and again by the browsing tool to update its database.
Reference: [12] <author> Henning Christiansen. </author> <title> Structure sharing in attribute grammars. </title> <editor> In J. Ma luszynski, editor, </editor> <booktitle> Programming Language Implementation and Logic Programming: International Workshop PLILP '88, volume 348 of Lecture Notes in Computer Science, </booktitle> <pages> pages 180-200. </pages> <publisher> Springer-Verlag, </publisher> <year> 1988. </year> <month> 152 </month>
Reference-contexts: The special treatment of static selections does play an important role, as will soon become apparent. In the following chapter, we will extend the DDC and supports lists mechanism to accommodate the maintenance of caches for functions and relations. 6.6 Related Work Christiansen <ref> [12] </ref> proposed that side-effects be used to simultaneously update the value of object (record) components at multiple remote attribute occurrences. He describes a static analysis that exploits structure-sharing to generate a more efficient static evaluator.
Reference: [13] <author> Keith L. Clark. </author> <title> Negation as failure. </title> <editor> In Herve Gallaire and Jack Minker, editors, </editor> <booktitle> Logic and Data Bases, </booktitle> <pages> pages 293-322. </pages> <publisher> Plenum Press, </publisher> <year> 1978. </year>
Reference-contexts: This restriction is required to assure the soundness of the declarative reading of a clause as the logical conjunction of a set of predicates. It serves the same purpose as the allowedness condition <ref> [13] </ref> in the theory of Prolog-style logic programming. The list inclusion predicate, denoted by the infix operator in, succeeds if the value of its left argument is included in that of its right, which must be a list.
Reference: [14] <author> B. J. Cornelius. </author> <title> Problems with the language Modula-2. </title> <journal> Software Practice and Experience, </journal> <volume> 18(6) </volume> <pages> 529-543, </pages> <month> June </month> <year> 1988. </year>
Reference-contexts: The Modula-2 report is unclear on many points, and is not an exemplary defining document. We relied on Blaschek and Pomberger [7] and Cornelius <ref> [14] </ref> for clarification on a number of points.
Reference: [15] <institution> Declarative Systems, Inc., </institution> <address> Palo Alto, CA. </address> <note> Linguist User's Manual, Version 6.3, </note> <month> March </month> <year> 1990. </year>
Reference-contexts: The problem and a proposed solution are presented by Farrow in a lamentably unpublished draft [22] describing an experimental extension to the Linguist <ref> [15] </ref> attribute grammar system. Farrow's approach is fundamentally different from ours, which we originally proposed in ignorance of his work. Farrow's treatment initially intrigued us, as it appears to be more general, permitting, for example, the fibering of tuples that are created dynamically within functions.
Reference: [16] <editor> DeGroot and Lindstrom, editors. </editor> <title> Logic Programming: Functions, Equations, and Relations. </title> <publisher> Prentice-Hall, </publisher> <year> 1986. </year>
Reference-contexts: Our language resembles some of the proposals that have been made to integrate predicate (clausal) logic and equational logic in logic programming, e.g., in the volume edited by Lindstrom and DeGroot <ref> [16] </ref>. We have gone much further than most of these, however, in compromising faithfulness to logical purity in favor of implementation efficiency.
Reference: [17] <author> Pierre Deransart, Martin Jourdan, and Bernard Lorho. </author> <title> Attribute Grammars: Definitions, Systems and Bibliography. </title> <publisher> Springer-Verlag, </publisher> <year> 1988. </year>
Reference-contexts: Engelfriet and File introduced the term `-ordered, and we follow their lead. Their terminology was also adopted in the comprehensive survey of attribute grammars by Deransart et al. <ref> [17] </ref>. 51 implementation of coroutines would be rather inefficient, however, as a separate program counter would be required for each node. In practice, the implementation is simplified by the fact that every VISIT and SUSPEND instruction contains a visit number. <p> The summary dependency graphs serve to characterize the transitive dependencies induced by all possible contexts in which the operator may occur within an AST. If the resulting augmented dependency graph for each AST operator is noncircular, then the AG belongs to the doubly noncircular (DNC) <ref> [17] </ref> class of attribute grammars, and the construction proceeds to the next step. If a cycle is found, however, the classical OAG construction fails, as the OAGs are a subclass of the DNC AGs.
Reference: [18] <author> J. Engelfriet. </author> <title> Attribute grammars: Attribute evaluation methods. </title> <editor> In B. Lorho, editor, </editor> <booktitle> Methods and Tools for Compiler Construction, </booktitle> <pages> pages 103-138. </pages> <publisher> Cambridge University Press, </publisher> <year> 1984. </year>
Reference-contexts: In our evaluator, we use an alternative implementation strategy in which visits are mapped onto ordinary subroutine calls in the target language of our implementation <ref> [18, 49] </ref>. An evaluation plan can be decomposed into a series of segments, each terminated by a SUSPEND instruction, and representing the actions to be performed upon the i-th visit. We construct a set of visit procedures for each AST operator, one for each segment of the evaluation plan. <p> Techniques for solving this problem, which arises in the construction of demand-driven evaluators for conventional AGs, are well known, and are described in Engelfriet <ref> [18] </ref> and Jourdan [41]. These methods are awkward when rendered in a strongly typed object-oriented target language, however. For this reason, we restrict functional attributes to be synthesized only.
Reference: [19] <author> J. Engelfriet and G. </author> <title> File. Passes, </title> <editor> sweeps, and visits. In S. Even and O. Kariv, editors, </editor> <booktitle> Proceedings of the Eighth International Conference on Automata, Languages, and Programming, volume 115 of Lecture Notes in Computer Science, </booktitle> <pages> pages 193-207. </pages> <publisher> Springer-Verlag, </publisher> <year> 1981. </year>
Reference-contexts: Farrow and Yellin [21] compare several methods for storage optimizations of this kind, and Julie and Parigot [44] present more recent results as employed in the FNC-2 system. In some cases, such as for the one-sweep <ref> [19] </ref> and `-attributed classes of attribute grammars, all attributes may be allocated in this way, provided that we are interested only in the values of one or more synthesized attributes of the root.
Reference: [20] <author> Joost Engelfriet and Gilberto File. </author> <title> Simple multi-visit attribute grammars. </title> <journal> Journal of Computer and System Sciences, </journal> <volume> 24 </volume> <pages> 283-314, </pages> <year> 1982. </year>
Reference-contexts: Our method is applicable to the `-ordered <ref> [20] </ref> class of attribute grammars. <p> The `-ordered class is more than adequate for practical purposes, as it contains all AGs evaluable in a fixed number of sweeps or passes as a proper subclass. Unfortunately, testing membership in 50 the `-ordered class been shown to be NP-complete by Engelfriet and File <ref> [20] </ref>, and is regarded as impractical for AGs of realistic size. The difficulty arises in the computation of the required family of total orders on the attributes of each phylum. It is a relatively straightforward polynomial-time computation to determine a family of partial orders with the required property. <p> A naive realization based on a general 1 There is some confusion in the terminology surrounding the `-ordered AG and OAG classes. According to Engelfriet and File <ref> [20] </ref>, Kastens originally used the term "ordered attribute grammar" in a 1978 technical report to refer to what we call the `-ordered AGs, then later redefined the class in his 1980 paper [47] in order to give it a polynomial-time membership test.
Reference: [21] <author> R. Farrow and D. M. Yellin. </author> <title> A comparison of storage optimizations in automatically-generated attribute grammars. </title> <journal> Acta Informatica, </journal> <volume> 23(4) </volume> <pages> 393-427, </pages> <year> 1986. </year>
Reference-contexts: It is usually possible to allocate these attributes in one or more auxiliary stacks or global variables used only while evaluation is in progress. Farrow and Yellin <ref> [21] </ref> compare several methods for storage optimizations of this kind, and Julie and Parigot [44] present more recent results as employed in the FNC-2 system.
Reference: [22] <author> Rodney Farrow. </author> <title> Fibered evaluation in Linguist. unpublished draft, Declarative Systems, </title> <publisher> Inc., </publisher> <address> Palo Alto, CA. </address>
Reference-contexts: We call the technique fibering, as it has similar goals and some conceptual similarity to a method of the same name described in an unpublished paper by Farrow <ref> [22] </ref>. Fibering is a compile-time transformation that does not impact our runtime machinery in any way. The fibering algorithm will be described in detail in the following section. In summary, it proceeds as follows: 1. <p> The problem and a proposed solution are presented by Farrow in a lamentably unpublished draft <ref> [22] </ref> describing an experimental extension to the Linguist [15] attribute grammar system. Farrow's approach is fundamentally different from ours, which we originally proposed in ignorance of his work.
Reference: [23] <author> P. Feiler, S. Dart, and G. Downey. </author> <title> Evaluation of the Rational environment. </title> <type> Technical Report CMU/SEI-88-TR-15, </type> <institution> Software Engineering Institute, Carnegie-Mellon University, </institution> <year> 1988. </year>
Reference-contexts: A number of language-based programming environments have been constructed as research prototypes, including Gandalf [52], Centaur [8], the Synthesizer Generator [67], Pan [3], PSG [2], and Integral-C [68]. Commercial systems include the SMARTsystem from PROCASE Corporation [60], Energize from Lucid, Inc. [51], the Rational Ada Environment <ref> [23] </ref>, and a commercial version of the 2 Synthesizer Generator [30]. 1 Our work was performed in the context of the Ensemble project [29], which is constructing a prototype integrated multilingual language-based software development environment based on an editor for structured multimedia documents.
Reference: [24] <author> Peter H. Feiler. </author> <title> A language-oriented interactive programming environment based on compilation technology. </title> <type> Technical Report CMU-CS-82-117, </type> <institution> Department of Computer Science, Carnegie-Mellon University, </institution> <year> 1982. </year> <type> Ph.D. dissertation. </type>
Reference-contexts: In contrast, hand-coded incremental language-based environments have favored re-analysis at the level of entire source-language procedures. Feiler <ref> [24] </ref> and Ross [68] describe systems of this kind. In a non-incremental attribute evaluator, many attributes are of use only transiently during attribute evaluation, and need not be present in the final attributed tree.
Reference: [25] <institution> Free Software Foundation, Inc. Bison Manual. </institution> <type> 59 Temple Place Suite 330, </type> <address> Boston, MA, 02111-1307. </address> <note> December 1993 Edition for Version 1.23. </note>
Reference-contexts: Parsing of the source code is performed by an LALR (1) parser, written in C and generated using flex [26] and bison <ref> [25] </ref>. The parser runs as a subprocess of C2C, and emits a sequence of abstract syntax trees, roughly one for each declaration or equation in the source file.
Reference: [26] <institution> Free Software Foundation, Inc. </institution> <type> Flex Manual. 59 Temple Place Suite 330, </type> <address> Boston, MA, 02111-1307. </address> <note> Edition 1.03 for Version 2.3.7. </note>
Reference-contexts: Parsing of the source code is performed by an LALR (1) parser, written in C and generated using flex <ref> [26] </ref> and bison [25]. The parser runs as a subprocess of C2C, and emits a sequence of abstract syntax trees, roughly one for each declaration or equation in the source file.
Reference: [27] <author> Franz, Inc. </author> <title> Allegro CL User Guide, </title> <month> March </month> <year> 1992. </year> <note> version 4.1. </note>
Reference-contexts: in S-expression form and is traversed using a pattern-matching conditional construct similar to the Standard ML case construct, implemented as a Lisp macro. 1 Funargs generated by lambda-expressions in VTM are only passed downward, and thus may always be stack-allocated. 135 We developed the compiler using the Allegro Common Lisp <ref> [27] </ref> implementation from Franz, Inc. The compiler is written almost entirely in portable Common Lisp, relying on implementation-specific extensions only for access to operating system facilities such as spawning processes and retrieving command-line arguments.
Reference: [28] <author> Neal M. Gafter. </author> <title> Parallel incremental compilation. </title> <type> Technical Report 349, </type> <institution> Department of Computer Science, University of Rochester, </institution> <month> June </month> <year> 1990. </year> <type> Ph.D. dissertation. </type>
Reference-contexts: The idea of keeping an AST approximately balanced using a balanced sequence representation was suggested by Pugh [61] in connection with a function-caching incremental AG evaluator similar to that of Vogt, et al. Gafter <ref> [28] </ref> independently proposed the same technique in connection with parallel execution of a compiler, in which balanced sequences lead to a better decomposition of the program into sub-problems. Gafter explicitly addressed incremental parsing with balanced sequences.
Reference: [29] <author> Susan L. Graham. </author> <title> Language and document support in software development environments. </title> <booktitle> In Proceedings of the Darpa'92 Software Technology Conference, </booktitle> <address> Los Angeles, </address> <month> April </month> <year> 1992. </year>
Reference-contexts: Commercial systems include the SMARTsystem from PROCASE Corporation [60], Energize from Lucid, Inc. [51], the Rational Ada Environment [23], and a commercial version of the 2 Synthesizer Generator [30]. 1 Our work was performed in the context of the Ensemble project <ref> [29] </ref>, which is constructing a prototype integrated multilingual language-based software development environment based on an editor for structured multimedia documents. <p> The compiled descriptions are dynamically linked and loaded into the host environment on demand as needed. The compiler supports multiple back ends, allowing a single program to process language descriptions descriptions for all supported environments. Currently, Colander II supports two host environments: Pan [3] and Ensemble <ref> [29] </ref>. Support for Pan is the most complete, and was implemented by the author. A port to Ensemble was performed by Nicholas Weaver.
Reference: [30] <author> GrammaTech, Inc. </author> <title> The Synthesizer Generator T M : Language-Sensitive Editing for CASE. One Hopkins Place, </title> <address> Ithaca, New York 14850. </address> <note> Undated product overview received in 1993. 153 </note>
Reference-contexts: Commercial systems include the SMARTsystem from PROCASE Corporation [60], Energize from Lucid, Inc. [51], the Rational Ada Environment [23], and a commercial version of the 2 Synthesizer Generator <ref> [30] </ref>. 1 Our work was performed in the context of the Ensemble project [29], which is constructing a prototype integrated multilingual language-based software development environment based on an editor for structured multimedia documents.
Reference: [31] <author> Ashish Gupta, Inderpal Singh Mumick, and V. S. Subrahmanian. </author> <title> Maintaining views incremen-tally. </title> <booktitle> SIGMOD Record, </booktitle> <volume> 22(2) </volume> <pages> 157-166, </pages> <month> June </month> <year> 1993. </year> <booktitle> Proceedings of the 1993 ACM SIGMOD International Conference on Management of Data. </booktitle>
Reference-contexts: Horwitz [39] and Horwitz and Teitelbaum [38] augmented a traditional attribute grammar with global relations into which the nodes of the AST could induce one or more tuples, possibly conditionally. They use incremental view-maintenance techniques, akin to those developed in the relational database community, e.g., by Gupta et al. <ref> [31] </ref>, in order to maintain additional derived relations. Their approach exploits static analysis to direct incremental re-evaluation, unlike Colander, and uses an efficient forward-inferencing procedure for updating derived relations.
Reference: [32] <author> Gorel Hedin. </author> <title> Incremental Semantic Analysis. </title> <type> Ph.D. dissertation, </type> <institution> Department of Computer Science, Lund University, </institution> <month> March </month> <year> 1992. </year>
Reference-contexts: Practical evaluators must avoid this inefficiency, either by extending the attribute grammar framework, e.g., Hedin's Door Attribute Grammars <ref> [32, 33] </ref>, or by using a mechanism to recognize and bypass copy rules automatically, such as those of Hoover [34] and Pennings [59]. <p> The inclusion of attributed object types with identity is a distinctive feature of ADL that provides an expressive mechanism for modeling language notions such as declared entities and binding contours. Attributed objects have appeared previously in Door Attribute Grammars <ref> [32, 33] </ref>, but in a manner that exposed the imperative nature of their implementation. Our system is unique in providing objects in such a way that the user cannot compromise the integrity of the declarative semantics, understood as maintenance of constraint consistency. <p> Colander [4] provided collections as first-class objects that could be transmitted as data values within the language description. We eschew this generality in the interest of efficiency. Our relational attributes are much more amenable to static analysis than Colander's first-class collections. Hedin's objects <ref> [32] </ref> may possess a special kind of component called a "collection," distinct from our usage of the term, which may be constrained to contain certain members remotely at sites where a reference to the object is available. <p> We lifted the declaration before use requirement because such restrictions are considered by many authors to be an artifact of conventional sequential batch-mode compilation, and an inappropriate restriction in an interactive language-based editing environment. Hedin <ref> [32] </ref>, for example, claims that even when the language definition requires definition before use, the restriction should be relaxed by the editor, and conformance restored when exporting source text by topologically sorting the declarations.
Reference: [33] <author> Gorel Hedin. </author> <title> An overview of door attribute grammars. </title> <editor> In Peter A. Fritzson, editor, </editor> <booktitle> Proceedings of the CC '94 International Conference on Compiler Construction, volume 786 of Lecture Notes in Computer Science, </booktitle> <pages> pages 31-51. </pages> <publisher> Springer-Verlag, </publisher> <year> 1994. </year>
Reference-contexts: Practical evaluators must avoid this inefficiency, either by extending the attribute grammar framework, e.g., Hedin's Door Attribute Grammars <ref> [32, 33] </ref>, or by using a mechanism to recognize and bypass copy rules automatically, such as those of Hoover [34] and Pennings [59]. <p> The inclusion of attributed object types with identity is a distinctive feature of ADL that provides an expressive mechanism for modeling language notions such as declared entities and binding contours. Attributed objects have appeared previously in Door Attribute Grammars <ref> [32, 33] </ref>, but in a manner that exposed the imperative nature of their implementation. Our system is unique in providing objects in such a way that the user cannot compromise the integrity of the declarative semantics, understood as maintenance of constraint consistency. <p> He describes a static analysis that exploits structure-sharing to generate a more efficient static evaluator. He mentions the possibility of refining the static dependencies with dynamic traces, but does not pursue the idea further. Hedin <ref> [33] </ref> originated the description of long-distance dependencies by explicit linkage of objects embedded in the AST, as well as the use of functionally-attributed objects to model aggregates.
Reference: [34] <author> Roger Hoover. </author> <title> Dynamically bypassing copy rule chains in attribute grammars. </title> <booktitle> In Proceedings of the Thirteenth Annual ACM Symposium on Principles of Programming Languges, </booktitle> <pages> pages 14-25, </pages> <month> January </month> <year> 1986. </year>
Reference-contexts: Practical evaluators must avoid this inefficiency, either by extending the attribute grammar framework, e.g., Hedin's Door Attribute Grammars [32, 33], or by using a mechanism to recognize and bypass copy rules automatically, such as those of Hoover <ref> [34] </ref> and Pennings [59]. With the elimination of copy rules, an incremental attribute evaluator can achieve fully incremental behavior to the extent that the attribute dependencies fully expose the dependency structure of the computation. For simple (e.g., scalar) attribute values, this condition obtains. <p> The mechanism is error prone, as it relies on the user to account for the dependencies carried by the handwritten code. Hoover developed a method to automatically bypass chains of copy rules, thus automatically implementing a class of long-distance dependencies <ref> [34] </ref>. Hoover's finite functions [35] and key trees [36] are built-in associative table data types supporting efficient incremental update of their components.
Reference: [35] <author> Roger Hoover. </author> <title> Efficient incremental evaluation of aggregate values in attribute grammars. </title> <booktitle> In Proceedings of the SIGPLAN '86 Symposium on Compiler Construction, </booktitle> <pages> pages 39-50, </pages> <month> June </month> <year> 1986. </year>
Reference-contexts: The mechanism is error prone, as it relies on the user to account for the dependencies carried by the handwritten code. Hoover developed a method to automatically bypass chains of copy rules, thus automatically implementing a class of long-distance dependencies [34]. Hoover's finite functions <ref> [35] </ref> and key trees [36] are built-in associative table data types supporting efficient incremental update of their components.
Reference: [36] <author> Roger Hoover. </author> <title> Incremental Graph Evaluation. </title> <type> Ph.D. dissertation, </type> <institution> Department of Computer Science, Cornell University, </institution> <year> 1987. </year>
Reference-contexts: The mechanism is error prone, as it relies on the user to account for the dependencies carried by the handwritten code. Hoover developed a method to automatically bypass chains of copy rules, thus automatically implementing a class of long-distance dependencies [34]. Hoover's finite functions [35] and key trees <ref> [36] </ref> are built-in associative table data types supporting efficient incremental update of their components.
Reference: [37] <author> Roger Hoover. Alphonse: </author> <title> Incremental computation as a programming abstraction. </title> <booktitle> In Proceedings of the ACM SIGPLAN '92 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 261-272, </pages> <year> 1992. </year>
Reference-contexts: Its value during the traversal indicates change status directly. The scheme described so far is unrealistically pessimistic in that it will re-evaluate every call to a functional attribute that is transitively dependent upon a changed scalar attribute. By caching the 1 This term is used by Hoover <ref> [37] </ref> in exactly the same sense as we use it here. <p> In common with Swierstra and Vogt, cache housekeeping is not adequately addressed, permitting the cache to contain stale entries, or entries that were flushed prematurely and must be unnecessarily regenerated. Hoover's Alphonse program transformation system <ref> [37] </ref> pioneered the combination of topological-order change propagation and function caching. In response to user-supplied annotations, calls to functions and methods in an imperative object-oriented language can be cached to permit efficient incremental execution.
Reference: [38] <author> Susan Horwitz and Tim Teitelbaum. </author> <title> Generating editing environments based on relations and attributes. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 8(4) </volume> <pages> 577-608, </pages> <month> October </month> <year> 1986. </year>
Reference-contexts: In fact, even this is not precisely true due to the existence of a few operations that are exempted from the consistency-maintenance discipline. 11 the excessive use of dynamic dependency traces. Horwitz [39] and Horwitz and Teitelbaum <ref> [38] </ref> augmented a traditional attribute grammar with global relations into which the nodes of the AST could induce one or more tuples, possibly conditionally. <p> Our notion of collections is borrowed from Horwitz [39] and Horwitz and Teitelbaum <ref> [38] </ref>, who carry the idea further by allowing the definition of incrementally-maintained derived relations. Although they call their technique "relational attribution," the relations are all defined at top-level, and do not decorate the tree. Only the assertions actually appear within the AST operators.
Reference: [39] <author> Susan B. Horwitz. </author> <title> Generating language-based editors: A relationally-attributed approach. </title> <type> Technical Report TR 85-696, </type> <institution> Department of Computer Science, Cornell University, </institution> <year> 1985. </year> <type> Ph.D. dissertation. </type>
Reference-contexts: In fact, even this is not precisely true due to the existence of a few operations that are exempted from the consistency-maintenance discipline. 11 the excessive use of dynamic dependency traces. Horwitz <ref> [39] </ref> and Horwitz and Teitelbaum [38] augmented a traditional attribute grammar with global relations into which the nodes of the AST could induce one or more tuples, possibly conditionally. <p> Because the use of relations does not commit to the data structure used to represent them, the implementation is given more freedom to choose an appropriate one. Our treatment of relations as full-fledged attributes was anticipated by Sataluri and Fleck [69]. Horwitz <ref> [39] </ref> defines a notion of relational attribution that is akin to our collections. Her relations are global, however, and do not decorate the AST itself. Throughout the discussion so far, we have hinted at the synergy between the ADL language design and the requirements of incremental execution. <p> Our notion of collections is borrowed from Horwitz <ref> [39] </ref> and Horwitz and Teitelbaum [38], who carry the idea further by allowing the definition of incrementally-maintained derived relations. Although they call their technique "relational attribution," the relations are all defined at top-level, and do not decorate the tree. Only the assertions actually appear within the AST operators. <p> A check for matching holes, then, becomes as efficient as an ordinary tuple lookup. The method we suggest here further extends the "notify and retry" paradigm that is pervasive in our approach to incrementality. Horwitz <ref> [39] </ref> implemented a scheme that adheres more closely to the traditional "change propagation" model, in which sets of tuples added and deleted from a relation are propagated to its successors in an apparently eager, data-driven manner. In reality, the implementation of her method uses generator functions much like ours.
Reference: [40] <editor> Paul Hudak et al. </editor> <title> Report on the programming language Haskell: A non-strict, purely functional language. </title> <journal> ACM SIGPLAN Notices, </journal> <volume> 27(5), </volume> <month> May </month> <year> 1992. </year>
Reference-contexts: The modern style of functional programming as embodied in Standard ML [54] and Haskell <ref> [40] </ref> makes extensive use of typed terms and pattern matching, and recent attribute grammar systems such as the Synthesizer Generator and FNC-2 [42] have followed suit. ADL is thus quite conventional in this respect, although we have borrowed a few notations from the logic programming tradition.
Reference: [41] <author> Martin Jourdan. </author> <title> An optimal-time recursive evaluator for attribute grammars. </title> <editor> In M. Paul and B. Robinet, editors, </editor> <booktitle> International Symposium on Programming: Proceedings of the 6th Colloquium, volume 167 of Lecture Notes in Computer Science, </booktitle> <pages> pages 167-178. </pages> <publisher> Springer-Verlag, </publisher> <month> April </month> <year> 1984. </year>
Reference-contexts: Techniques for solving this problem, which arises in the construction of demand-driven evaluators for conventional AGs, are well known, and are described in Engelfriet [18] and Jourdan <ref> [41] </ref>. These methods are awkward when rendered in a strongly typed object-oriented target language, however. For this reason, we restrict functional attributes to be synthesized only.
Reference: [42] <author> Martin Jourdan, Carole Le Bellec, and Didier Parigot. </author> <title> The OLGA attribute grammar description lanugage: Design, implementation, and evaluation. </title> <editor> In P. Deransart and M. Jourdan, editors, </editor> <title> Attribute Grammars and their Applications, </title> <booktitle> volume 461 of Lecture Notes in Computer Science, </booktitle> <pages> pages 222-237. </pages> <publisher> Springer-Verlag, </publisher> <year> 1990. </year>
Reference-contexts: The modern style of functional programming as embodied in Standard ML [54] and Haskell [40] makes extensive use of typed terms and pattern matching, and recent attribute grammar systems such as the Synthesizer Generator and FNC-2 <ref> [42] </ref> have followed suit. ADL is thus quite conventional in this respect, although we have borrowed a few notations from the logic programming tradition. Recently, Boyland [10] has designed and implemented an elaborate attribute grammar extension aimed at constructing complete language descriptions from the composition of smaller components.
Reference: [43] <author> Martin Jourdan and Didier Parigot. </author> <title> Internals and externals of the FNC-2 attribute grammar system. </title> <editor> In H. Alblas and B. Melichar, editors, </editor> <title> Attribute Grammars, </title> <booktitle> Applications and Systems, volume 545 of Lecture Notes in Computer Science, </booktitle> <pages> pages 485-504. </pages> <publisher> Springer-Verlag, </publisher> <year> 1991. </year> <month> 154 </month>
Reference-contexts: Jourdan and Parigot <ref> [43] </ref> outline a practical method for constructing visit procedures from an SNC attribute grammar, as employed in the implemented FNC-2 system.
Reference: [44] <author> Catherine Julie and Didier Parigot. </author> <title> Space optimization in the FNC-2 attribute grammar system. </title> <editor> In P. Deransart and M. Jourdan, editors, </editor> <title> Attribute Grammars and their Applications, </title> <booktitle> volume 461 of Lecture Notes in Computer Science, </booktitle> <pages> pages 29-45. </pages> <publisher> Springer-Verlag, </publisher> <year> 1990. </year>
Reference-contexts: Experience with implemented attribute grammar systems has shown that more than 90 percent of the attributes in a typical attribute grammar are temporary, according to Julie and Parigot <ref> [44] </ref>, who report a series of experiments with the FNC-2 system in which only 7.5 percent of the attributes (weighted by their number of occurrences) required storage in the tree. <p> It is usually possible to allocate these attributes in one or more auxiliary stacks or global variables used only while evaluation is in progress. Farrow and Yellin [21] compare several methods for storage optimizations of this kind, and Julie and Parigot <ref> [44] </ref> present more recent results as employed in the FNC-2 system.
Reference: [45] <author> Richard K. Jullig and Frank DeRemer. </author> <title> Regular right-part attribute grammars. </title> <booktitle> In Proceedings of the ACM SIGPLAN '84 Symposium on Compiler Construction, </booktitle> <pages> pages 171-178, </pages> <year> 1984. </year>
Reference-contexts: There is a constant-factor penalty due the the presence of singleton nodes, but even this may be eliminated at the cost of a small increase in implementation complexity. 4 These are taken from a set of six such patterns identified by Jullig and DeRemer <ref> [45] </ref> in connection with a notation for attributing regular right-part grammars.
Reference: [46] <author> U. Kastens, B. Hutt, and E. Zimmermann. GAG: </author> <title> A Practical Compiler Generator, </title> <booktitle> volume 141 of Lecture Notes in Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1982. </year>
Reference-contexts: For example, the up 1 Known optimal update algorithms, however, either require some explicit dependency information or restrictions on the class of acceptable attribute grammars. 9 ward remote attribute references introduced in the GAG system <ref> [46] </ref> permit a semantic function to refer directly to the instance of a named attribute occurring in the nearest ancestor node in which an occurrence appears. Generation-time analysis assures that such an instance will always exist, and generates inherited attributes to link the remote reference with the appropriate instance. <p> Toy languages used in expository papers invariably assume declaration before use, and several well-known published attribute grammars for the "full-strength" semantic analysis of real programming languages implement languages with strong declaration before use requirements, e.g., Pascal in Kastens <ref> [46] </ref> and Ada in Uhl, et al. [73]. The problem and a proposed solution are presented by Farrow in a lamentably unpublished draft [22] describing an experimental extension to the Linguist [15] attribute grammar system.
Reference: [47] <author> Uwe Kastens. </author> <title> Ordered attribute grammars. </title> <journal> Acta Informatica, </journal> <volume> 13 </volume> <pages> 229-256, </pages> <year> 1980. </year>
Reference-contexts: Unfortunately, however, there will in general be much freedom in converting the partial orders to the required total orders. Our implementation is thus based on the smaller, but polynomially-decidable class of ordered attribute grammars (OAGs), defined by Kastens <ref> [47] </ref>. 1 The OAG class is defined by a greedy strategy for computing the total orders, placing each attribute as early as possible in the total order for its phylum, subject to the requirement that it follow all of the attributes that precede it in the corresponding partial order. (If more <p> In the case of OAGs, there exists a standard and efficient method to compute these sequences, due to Kastens <ref> [47] </ref>. The sequence of pairs, or partition, defines a sequence of visits to be made to each instance of phylum X during the traversal and attribution of the AST. <p> According to Engelfriet and File [20], Kastens originally used the term "ordered attribute grammar" in a 1978 technical report to refer to what we call the `-ordered AGs, then later redefined the class in his 1980 paper <ref> [47] </ref> in order to give it a polynomial-time membership test. Engelfriet and File introduced the term `-ordered, and we follow their lead. <p> The multitude of control attributes introduced by fibering complicated the process of removing the so-called "Type 3" circularities <ref> [47] </ref> detected in the final step of the OAG evaluator construction. These "circularities" are artifacts of the greedy algorithm used by the OAG evaluator construction to determine a total ordering on the attributes given the partial order implied by the dependencies in the AG.
Reference: [48] <author> Uwe Kastens. </author> <title> Attribute grammars as a specification method. </title> <editor> In H. Alblas and B. Melichar, editors, </editor> <title> Attribute Grammars, </title> <booktitle> Applications and Systems, volume 545 of Lecture Notes in Computer Science, </booktitle> <pages> pages 16-47. </pages> <publisher> Springer-Verlag, </publisher> <year> 1991. </year>
Reference-contexts: Should the test fail, however, it applies the fibering transformation and then attempts the classical OAG construction again on 2 The notion of "dummy" attributes arises frequently in the literature, however the LIGA system <ref> [48, 78] </ref> is notable for its systematic use of such attributes to integrate imperative programming into attribute grammars in a reasonably clean manner. 3 As it turns out, the Example language is a degenerate case for fibering, and is thus not suitable for this purpose.
Reference: [49] <author> Uwe Kastens. </author> <title> Implementation of visit-oriented attribute evaluators. </title> <editor> In H. Alblas and B. Melichar, editors, </editor> <title> Attribute Grammars, </title> <booktitle> Applications and Systems, volume 545 of Lecture Notes in Computer Science, </booktitle> <pages> pages 114-139. </pages> <publisher> Springer-Verlag, </publisher> <year> 1991. </year>
Reference-contexts: In our evaluator, we use an alternative implementation strategy in which visits are mapped onto ordinary subroutine calls in the target language of our implementation <ref> [18, 49] </ref>. An evaluation plan can be decomposed into a series of segments, each terminated by a SUSPEND instruction, and representing the actions to be performed upon the i-th visit. We construct a set of visit procedures for each AST operator, one for each segment of the evaluation plan.
Reference: [50] <author> Peter Lipps, Ulrich Moncke, Matthias Olk, and Reinhard Wilhelm. </author> <title> Attribute (re)evaluation in OPTRAN. </title> <journal> Acta Informatica, </journal> <volume> 26, </volume> <year> 1988. </year>
Reference-contexts: Surprisingly, no one seems to have previously observed the implications of this technique for efficient coordinated evaluation, despite the fact that both Reps et al. [64] and Peckham [57] use other balanced data structures. User-supplied pragmatic annotations to control re-evaluation granularity were previously implemented in OPTRAN <ref> [50] </ref>, which used an incremental evaluation strategy similar to our own. <p> r : integer; (A) type aryptr = pointer to ary; (B) type ary = array [ 5 ] of integer; (C) var v : ary; (D) var w : aryptr; (E) var x : array [ 10 ] of aryptr; (F) var y : integer; (G) var z : array <ref> [ 50 ] </ref> of integer (H) begin declare Repeat this block 25 times type p1 = pointer to p2; (I) type p2 = pointer to ary; (J) var s : p1; (K) var u : integer; (M) var v : array [ 5 ] of integer (N) begin y := 1;
Reference: [51] <institution> Lucid, Inc. Sales literature. </institution>
Reference-contexts: A number of language-based programming environments have been constructed as research prototypes, including Gandalf [52], Centaur [8], the Synthesizer Generator [67], Pan [3], PSG [2], and Integral-C [68]. Commercial systems include the SMARTsystem from PROCASE Corporation [60], Energize from Lucid, Inc. <ref> [51] </ref>, the Rational Ada Environment [23], and a commercial version of the 2 Synthesizer Generator [30]. 1 Our work was performed in the context of the Ensemble project [29], which is constructing a prototype integrated multilingual language-based software development environment based on an editor for structured multimedia documents.
Reference: [52] <author> Raul Medina-Mora. </author> <title> Syntax directed editing: Towards integrated programming environments. </title> <type> Technical Report CMU-CS-81-113, </type> <institution> Department of Computer Science, Carnegie-Mellon University, </institution> <month> March </month> <year> 1982. </year> <type> Ph.D. dissertation. </type>
Reference-contexts: Such fine-grained versioning is not provided in traditional environments, which track changes in terms of entire lines of text. A number of language-based programming environments have been constructed as research prototypes, including Gandalf <ref> [52] </ref>, Centaur [8], the Synthesizer Generator [67], Pan [3], PSG [2], and Integral-C [68]. <p> Since it was intended for use only on small instructional programs, it was practical to perform a complete re-attribution after each editing operation. Clearly, such methods do not scale up to large modules. In the ALOE editor <ref> [52] </ref>, action routines are associated with each AST node type. Editing operations such as node insertion, deletion, and alteration of a child or parent pointer invoke the appropriate action routine for the node or nodes involved.
Reference: [53] <author> Josephine Micallef and Gail E. Kaiser. </author> <title> Extending attribute grammars to support programming-in-the-large. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 16(5) </volume> <pages> 1572-1612, </pages> <month> September </month> <year> 1994. </year>
Reference-contexts: There is no notion of a "system" of related files composing a single program. A more satisfactory solution is provided by the Segmentable Attribute Grammars of Micallef and Kaiser <ref> [53] </ref>, which allow separately stored and editable subtrees to be dynamically "grafted" onto another tree for attribution. 12.2.2 Scoping and Name Resolution Modula-2 defines a complex scoping discipline in which many language constructs establish binding environments, each with idiosyncratic name-resolution rules.
Reference: [54] <author> Robin Milner, Mads Tofte, and Robert Harper. </author> <title> The Definition of Standard ML. </title> <publisher> MIT Press, </publisher> <year> 1990. </year>
Reference-contexts: The modern style of functional programming as embodied in Standard ML <ref> [54] </ref> and Haskell [40] makes extensive use of typed terms and pattern matching, and recent attribute grammar systems such as the Synthesizer Generator and FNC-2 [42] have followed suit. ADL is thus quite conventional in this respect, although we have borrowed a few notations from the logic programming tradition.
Reference: [55] <author> Robert L. Nord and Frank Pfenning. </author> <title> The Ergo attribute system. </title> <booktitle> In Proceedings of the Third ACM SIGSOFT/SIGPLAN Software Engineering Symposium on Practical Software Development Environments, </booktitle> <pages> pages 110-120, </pages> <year> 1988. </year>
Reference-contexts: It is advisable, then, to consider the problem of sequence attribution in a manner uncommitted to a particular representation, and then to ask how efficiently various patterns of information flow can be rendered using the sequence representations under consideration. Nord and Pfenning <ref> [55] </ref> identify four important patterns of attribute flow in sequences: 4 1. Construction of a list containing the value of a given synthesized attribute at each child. 2. Distribution of an inherited attribute of the sequence to all children. 3.
Reference: [56] <author> Joan Peckham and Fred Maryanski. </author> <title> Semantic data models. </title> <journal> Computing Surveys, </journal> <volume> 20(3) </volume> <pages> 153-189, </pages> <month> September </month> <year> 1988. </year>
Reference-contexts: For example, object identity is invariably a first class notion, with "unique identifier" key values relegated to the hidden internals of an implementation. (Peckham and and Maryanski <ref> [56] </ref> provide a thorough and accessible survey of semantic data models.) Database programming languages (DBPLs) seek to eliminate the "impedance mismatch" between ordinary programming languages and embedded database query languages, and have been the subject of much research. See, for example, the volume edited by Bancilhon and Buneman [5].
Reference: [57] <author> Stephen B. Peckham. </author> <title> Globally partitionable attribute grammars. </title> <editor> In P. Deransart and M. Jour-dan, editors, </editor> <title> Attribute Grammars and their Applications, </title> <booktitle> volume 461 of Lecture Notes in Computer Science, </booktitle> <pages> pages 327-342. </pages> <publisher> Springer-Verlag, </publisher> <year> 1990. </year>
Reference-contexts: Good performance in the general case requires that change propagation originating from multiple initial sites of attribute inconsistency be coordinated in order to avoid this behavior. Several authors have addressed this issue, most notably Peckham <ref> [57, 58] </ref>, who developed an algorithm that maintains a favorable amortized complexity of O (k log n + jAFFECTEDj) in the presence 53 of multiple subtree replacements, where k is the number of subtree replacements and n is the total size of the tree. <p> The resulting algorithm is quite similar in effect to the OAG evaluator used in the Synthesizer Generator, but the visit caching viewpoint leads to a more straightforward implementation. The coordinated evaluators described by Reps, Marceau, and Teitelbaum [64], and Peckham <ref> [57] </ref> use additional static analysis, AG class restrictions, and complex auxiliary runtime data structures to account for dependencies linking disconnected inconsistent regions of the AST, thus assuring that evaluation always proceeds in topological order. <p> Gafter explicitly addressed incremental parsing with balanced sequences. Surprisingly, no one seems to have previously observed the implications of this technique for efficient coordinated evaluation, despite the fact that both Reps et al. [64] and Peckham <ref> [57] </ref> use other balanced data structures. User-supplied pragmatic annotations to control re-evaluation granularity were previously implemented in OPTRAN [50], which used an incremental evaluation strategy similar to our own.
Reference: [58] <author> Stephen B. Peckham. </author> <title> Incremental attribute evaluation and multiple subtree replacements. </title> <type> Technical Report 90-1093, </type> <institution> Department of Computer Science, Cornell University, </institution> <month> Februrary </month> <year> 1990. </year> <type> Ph.D. dissertation. </type>
Reference-contexts: Good performance in the general case requires that change propagation originating from multiple initial sites of attribute inconsistency be coordinated in order to avoid this behavior. Several authors have addressed this issue, most notably Peckham <ref> [57, 58] </ref>, who developed an algorithm that maintains a favorable amortized complexity of O (k log n + jAFFECTEDj) in the presence 53 of multiple subtree replacements, where k is the number of subtree replacements and n is the total size of the tree.
Reference: [59] <author> Maarten Pennings. </author> <title> Generating Incremental Attribute Evaluators. </title> <type> Ph.D. dissertation, </type> <institution> Utrecht University, </institution> <year> 1994. </year> <month> 155 </month>
Reference-contexts: Practical evaluators must avoid this inefficiency, either by extending the attribute grammar framework, e.g., Hedin's Door Attribute Grammars [32, 33], or by using a mechanism to recognize and bypass copy rules automatically, such as those of Hoover [34] and Pennings <ref> [59] </ref>. With the elimination of copy rules, an incremental attribute evaluator can achieve fully incremental behavior to the extent that the attribute dependencies fully expose the dependency structure of the computation. For simple (e.g., scalar) attribute values, this condition obtains.
Reference: [60] <institution> PROCASE Corporation, </institution> <address> 2694 Orchard Parkway, San Jose, California 95134. </address> <note> SMARTsystem TM Reference Guide, release 2.0 edition, </note> <month> March </month> <year> 1993. </year>
Reference-contexts: A number of language-based programming environments have been constructed as research prototypes, including Gandalf [52], Centaur [8], the Synthesizer Generator [67], Pan [3], PSG [2], and Integral-C [68]. Commercial systems include the SMARTsystem from PROCASE Corporation <ref> [60] </ref>, Energize from Lucid, Inc. [51], the Rational Ada Environment [23], and a commercial version of the 2 Synthesizer Generator [30]. 1 Our work was performed in the context of the Ensemble project [29], which is constructing a prototype integrated multilingual language-based software development environment based on an editor for structured
Reference: [61] <author> William Pugh and Tim Teitelbaum. </author> <title> Incremental computation via function caching. </title> <booktitle> In Conference Record of the Sixteenth Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 315-328. </pages> <publisher> ACM Press, </publisher> <month> January </month> <year> 1989. </year>
Reference-contexts: Under practical assumptions about the depth of ASTs, using a balanced representation for sequences, the asymptotic complexity is as least as good as any other published algorithm. The idea of keeping an AST approximately balanced using a balanced sequence representation was suggested by Pugh <ref> [61] </ref> in connection with a function-caching incremental AG evaluator similar to that of Vogt, et al. Gafter [28] independently proposed the same technique in connection with parallel execution of a compiler, in which balanced sequences lead to a better decomposition of the program into sub-problems. <p> Swierstra and Vogt have explored this technique [71], including an application to incremental name resolution. Pugh <ref> [61] </ref> explores function caching as a general technique for incremental computation. Although he discusses the application of function caching to classical incremental attribute evaluation, he is concerned principally with general recursive programs apart from attribute grammars.
Reference: [62] <author> Uday S. Reddy. </author> <title> On the relationship between logic and functional languages. </title> <editor> In DeGroot and Lindstrom, editors, </editor> <title> Logic Programming: Functions, Equations, </title> <booktitle> and Relations, </booktitle> <pages> pages 3-36. </pages> <publisher> Prentice-Hall, </publisher> <year> 1986. </year>
Reference-contexts: Our evaluation engine is based on a traditional call-by-value evaluation model, extended to allow for backtracking during relational computations. Our relational computations are required to be statically moded at determinate modes, in the terminology of Reddy <ref> [62] </ref>. Indeed, all arguments of a relation are of output mode only in our present implementation. Except for collections, which support indexed access, relations blindly generate their complete set of tuples, without taking advantage of the query context at all.
Reference: [63] <author> Raymond Reiter. </author> <title> On closed world data bases. </title> <editor> In Herve Gallaire and Jack Minker, editors, </editor> <booktitle> Logic and Data Bases, </booktitle> <pages> pages 55-76. </pages> <publisher> Plenum Press, </publisher> <year> 1978. </year>
Reference-contexts: Negation in ADL implements the familiar "negation as failure" rule from Prolog. Negation thus presupposes the so-called "closed-world assumption" <ref> [63] </ref> in which relations that are not specifically asserted to hold are assumed otherwise.
Reference: [64] <author> T. Reps, C. Marceau, and T. Teitelbaum. </author> <title> Remote attribute updating for language-based editors. </title> <booktitle> In Proceedings of the Thirteenth Annual ACM Symposium on Principles of Programming Languges, </booktitle> <pages> pages 1-13, </pages> <month> January </month> <year> 1986. </year>
Reference-contexts: The resulting algorithm is quite similar in effect to the OAG evaluator used in the Synthesizer Generator, but the visit caching viewpoint leads to a more straightforward implementation. The coordinated evaluators described by Reps, Marceau, and Teitelbaum <ref> [64] </ref>, and Peckham [57] use additional static analysis, AG class restrictions, and complex auxiliary runtime data structures to account for dependencies linking disconnected inconsistent regions of the AST, thus assuring that evaluation always proceeds in topological order. <p> Gafter explicitly addressed incremental parsing with balanced sequences. Surprisingly, no one seems to have previously observed the implications of this technique for efficient coordinated evaluation, despite the fact that both Reps et al. <ref> [64] </ref> and Peckham [57] use other balanced data structures. User-supplied pragmatic annotations to control re-evaluation granularity were previously implemented in OPTRAN [50], which used an incremental evaluation strategy similar to our own.
Reference: [65] <author> Thomas Reps. </author> <title> Generating language-based environments. </title> <type> Technical Report TR 82-514, </type> <institution> Department of Computer Science, Cornell University, </institution> <year> 1982. </year> <type> Ph.D. dissertation. </type>
Reference-contexts: Furthermore, Peckham's method is applicable only to a subclass of the ordered attribute grammars whose size and character has not been adequately assessed. An alternative approach, suggested by Reps <ref> [65] </ref>, merges the separate regions of attribute inconsistency into a single connected one. Before beginning re-evaluation, all previously computed attributes along paths connecting the edit sites are invalidated, resetting them to their original uninitialized state. In practice, a single bit within each node represents the validity status of its attributes.
Reference: [66] <author> Thomas Reps, Tim Teitelbaum, and Alan Demers. </author> <title> Incremental context-dependent analysis for language-based editors. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 5(3) </volume> <pages> 449-477, </pages> <month> July </month> <year> 1983. </year>
Reference-contexts: This performance criterion is nearly universally cited as the goal to which an incremental attribute evaluator should aspire, and is termed (asymptotic) optimal-time by Reps, Teitelbaum, and Demers <ref> [66] </ref>. Algorithms that achieve this complexity generally do so by assuring that an attribute is evaluated only after its predecessors have achieved their correct final values, 52 i.e., change propagation respects a topological ordering with respect to the attribute dependency graph. <p> Should the affected regions of the tree intersect, the topological ordering constraint may be violated, and the affected regions may have to be re-evaluated. Reps et al. <ref> [66] </ref> show that naive change propagation can be exponential in jAFFECTEDj for a depth-first traversal of the dependency graph, and quadratic if a breadth-first traversal is used. <p> Our work exploits many ideas that have appeared in one form or another in the previous 60 research literature. In comparison, however, our approach is in each case either simpler or more general. In their seminal paper, Reps et al. <ref> [66] </ref> defined the O (jAFFECTEDj) optimality criterion and the strategy of change propagation in topological order that achieves it. Their algorithm, employed in the Synthesizer Generator [67], works for arbitrary noncircular attribute grammars, but the overhead in space and time is prohibitive.
Reference: [67] <author> Thomas W. Reps and Tim Teitelbaum. </author> <title> The Synthesizer Generator: A System for Constructing Language-Based Editors. </title> <publisher> Springer-Verlag, </publisher> <year> 1989. </year>
Reference-contexts: Such fine-grained versioning is not provided in traditional environments, which track changes in terms of entire lines of text. A number of language-based programming environments have been constructed as research prototypes, including Gandalf [52], Centaur [8], the Synthesizer Generator <ref> [67] </ref>, Pan [3], PSG [2], and Integral-C [68]. <p> Given a partition for the phylum of an operator and those of its children, we can then construct a visit sequence, or evaluation plan for each operator. Following Reps and Teitelbaum <ref> [67] </ref>, an evaluation plan is a sequence of instructions of one of the following kinds: EVAL (i; a): Evaluate instance i:a, that is, the attribute a of child i. <p> Scheduling is performed entirely at runtime, without any prior analysis of the attribute dependencies, thus resulting in poor performance. The use of explicit attribute dependency graphs at runtime results in high space consumption as well. In later work <ref> [67] </ref>, Reps and Teitelbaum develop another algorithm, applicable only to ordered attribute grammars, as a variant of the classical non-incremental tree-walking (coroutining) evaluator. The essential idea is that a visit to a node may be skipped if it is known that the node contains no inconsistent attributes. <p> In comparison, however, our approach is in each case either simpler or more general. In their seminal paper, Reps et al. [66] defined the O (jAFFECTEDj) optimality criterion and the strategy of change propagation in topological order that achieves it. Their algorithm, employed in the Synthesizer Generator <ref> [67] </ref>, works for arbitrary noncircular attribute grammars, but the overhead in space and time is prohibitive. In later work, a simpler asymptotically-optimal evaluator for OAGs was developed, and its use recommended. <p> of the component Int1 that is accessed indirectly via an object reference. 10.3.1 Locating Potential Cycles The first step of the OAG evaluator construction algorithm computes an approximation to the dependencies among the attributes of each phylum, represented as a directed graph called a summary dependency graph. (Reps and Teitelbaum <ref> [67] </ref> use the term TDS graph, for "transitive dependencies of a symbol.") This approximation is conservative in that it covers the dependencies that exist at every instance of the phylum in every possible AST. Figure 10.3 shows the dependencies discovered among the attributes of the phylum Bar.
Reference: [68] <author> Graham Ross. </author> <title> Integral C A practical environment for C programming. </title> <booktitle> In Proceedings of the Second ACM SIGSOFT/SIGPLAN Symposium on Practical Software Development Environments, </booktitle> <pages> pages 42-48, </pages> <year> 1986. </year>
Reference-contexts: Such fine-grained versioning is not provided in traditional environments, which track changes in terms of entire lines of text. A number of language-based programming environments have been constructed as research prototypes, including Gandalf [52], Centaur [8], the Synthesizer Generator [67], Pan [3], PSG [2], and Integral-C <ref> [68] </ref>. <p> In contrast, hand-coded incremental language-based environments have favored re-analysis at the level of entire source-language procedures. Feiler [24] and Ross <ref> [68] </ref> describe systems of this kind. In a non-incremental attribute evaluator, many attributes are of use only transiently during attribute evaluation, and need not be present in the final attributed tree.
Reference: [69] <author> Srinivas R. Sataluri and Arthur C. Fleck. </author> <title> Semantic specifications using logic programs. </title> <editor> In Ewing L. Lusk and Ross A. Overbeek, editors, </editor> <booktitle> Logic Programming, Proceedings of the North American Conference 1989, </booktitle> <pages> pages 772-791. </pages> <publisher> MIT Press, </publisher> <year> 1989. </year>
Reference-contexts: Because the use of relations does not commit to the data structure used to represent them, the implementation is given more freedom to choose an appropriate one. Our treatment of relations as full-fledged attributes was anticipated by Sataluri and Fleck <ref> [69] </ref>. Horwitz [39] defines a notion of relational attribution that is akin to our collections. Her relations are global, however, and do not decorate the AST itself. Throughout the discussion so far, we have hinted at the synergy between the ADL language design and the requirements of incremental execution. <p> His implementation is embedded in Prolog, whose "call by unification" parameter passing scheme allows data to flow in both directions, thus obtaining the effect of inherited as well as synthesized (non-relational) attributes. He does not discuss incremental evaluation. Sataluri and Fleck <ref> [69] </ref> defines a variant of attribute grammars in which both inherited and synthesized relational attributes are permitted.
Reference: [70] <author> Guy L. Steele. </author> <title> Common Lisp: The Language. </title> <publisher> Digital Press, </publisher> <year> 1990. </year>
Reference-contexts: VTM incorporates a simple object model that maps cleanly onto the facilities provided by most statically typed object-oriented languages, as well as the more dynamic ones such as the Common Lisp Object System (CLOS) <ref> [70] </ref>. 134 In the VTM model, all functions are methods of an object. The program database object for a program document being edited is an instance of the analysis description class for the appropriate language. Global functions are methods of this object.
Reference: [71] <author> Doaitse Swierstra and Harald Vogt. </author> <title> Higher order attribute grammars. </title> <editor> In H. Alblas and B. Melichar, editors, </editor> <title> Attribute Grammars, </title> <booktitle> Applications and Systems, volume 545 of Lecture Notes in Computer Science, </booktitle> <pages> pages 256-296. </pages> <publisher> Springer-Verlag, </publisher> <year> 1991. </year>
Reference-contexts: Higher-order attributes may be used to model functions, allowing the dynamic call tree to be reified as an explicit data structure, which, in conjunction with caching, permits re-use of computation in a manner similar to our use of maintained functional attributes. Swierstra and Vogt have explored this technique <ref> [71] </ref>, including an application to incremental name resolution. Pugh [61] explores function caching as a general technique for incremental computation. Although he discusses the application of function caching to classical incremental attribute evaluation, he is concerned principally with general recursive programs apart from attribute grammars.
Reference: [72] <author> T. Teitelbaum and T. Reps. </author> <title> The Cornell Program Synthesizer: A syntax-directed programming environment. </title> <journal> Communications of the ACM, </journal> <volume> 24(9) </volume> <pages> 563-573, </pages> <month> September </month> <year> 1981. </year>
Reference-contexts: In this chapter, we survey the traditional approaches to incremental attribution, then present an overview of our own. 2.1 Ad hoc Methods One of the earliest syntax-directed editors, the Cornell Program Synthesizer <ref> [72] </ref>, made no attempt to perform incremental analysis at all. Since it was intended for use only on small instructional programs, it was practical to perform a complete re-attribution after each editing operation. Clearly, such methods do not scale up to large modules.
Reference: [73] <author> J. Uhl, S. Drossopoulos, G. Persch, et al. </author> <title> An Attributed Grammar for the Semantic Analysis of Ada, </title> <booktitle> volume 139 of Lecture Notes in Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1982. </year>
Reference-contexts: Toy languages used in expository papers invariably assume declaration before use, and several well-known published attribute grammars for the "full-strength" semantic analysis of real programming languages implement languages with strong declaration before use requirements, e.g., Pascal in Kastens [46] and Ada in Uhl, et al. <ref> [73] </ref>. The problem and a proposed solution are presented by Farrow in a lamentably unpublished draft [22] describing an experimental extension to the Linguist [15] attribute grammar system. Farrow's approach is fundamentally different from ours, which we originally proposed in ignorance of his work.
Reference: [74] <author> Michael Lee Van De Vanter. </author> <title> User interaction in language-based editing systems. </title> <type> Technical Report UCB/CSD 93/726, </type> <institution> Computer Science Division (EECS), University of California, Berkeley, </institution> <month> December </month> <year> 1992. </year> <type> Ph.D. dissertation. 156 </type>
Reference-contexts: Since users are fully aware of the inconsistency, it is unnecessary and intrusive to notify them of the transient constraint violations that appear. We wish to support the policy, advocated by Van De Vanter <ref> [74] </ref> and adopted in Pan, of updating the analysis only when the user explicitly requests a service that depends on it, such as notification of constraint violations.
Reference: [75] <author> Harald Vogt, Doaitse Swierstra, and Mattijs Kuiper. </author> <title> Efficient incremental evaluation of higher--order attribute grammars. </title> <editor> In J. Ma luszynski and M. Wirsing, editors, </editor> <booktitle> Proceedings of PLILP '91, volume 528 of Lecture Notes in Computer Science, </booktitle> <pages> pages 231-242. </pages> <publisher> Springer-Verlag, </publisher> <year> 1991. </year>
Reference-contexts: Nonetheless, both the number of attribute re-evaluations and the bookkeeping overhead remain O (jAFFECTEDj). The topological ordering required to assure optimal-time evaluation is implicit in the statically-computed evaluation schedule. Since dependency graphs need not be maintained at runtime, overhead is greatly reduced. Vogt, Swierstra, and Kuiper <ref> [75] </ref> have investigated incremental attribution of OAGs in a functional setting. In this case, an AST cannot be modified, but new trees may be created that share most of their structure with an existing one. <p> Non-temporary attributes are awkward to handle in a functional context, requiring that they be collected in a temporary tree structure called a binding which is then passed as an argument to subsequent visits as if it were an additional inherited attribute. (See Vogt et al. <ref> [75] </ref> for details.) Performing a subtree replacement requires that all nodes on the path from the edit site to the root be created afresh, precluding optimal-time performance. 5.3 Multiple Subtree Replacements In practice, the restriction to a single subtree replacement is inadequate. <p> The allocation of fresh tree nodes along the spine above each subtree replacement is analogous to attribute invalidation. It is therefore not surprising that the method achieves the same time complexity, O (jAFFECTEDj + jEDIT_ANCESTORSj) <ref> [75] </ref>. 5.4 Our Incremental Evaluator Our evaluator is based on visit procedures. To make the evaluator incremental, we cache ("memoize") the calls to the visit procedures in a manner reminiscent of the functional evaluator of Vogt et al. <p> In later work, a simpler asymptotically-optimal evaluator for OAGs was developed, and its use recommended. Our evaluator was obtained by adapting to an imperative setting an alternative scheme for OAGs based on visit caching developed by Vogt et al. <ref> [75] </ref>. The resulting algorithm is quite similar in effect to the OAG evaluator used in the Synthesizer Generator, but the visit caching viewpoint leads to a more straightforward implementation. <p> Since they are evaluated only once at initialization time, we cannot apply the cache maintenance protocol described here. Caches are thus never provided for global functions. 7.8 Related Work Vogt, Swierstra, and Kuiper <ref> [75] </ref> have applied caching to the visit functions for evaluating OAGs in order to build an incremental evaluator for classical AGs in a functional setting.
Reference: [76] <author> Scott Vorthmann and Richard J. LeBlanc. </author> <title> A naming specification language for syntax-directed editors. </title> <booktitle> In Proceedings of the IEEE 1988 International Conference on Computer Languages, </booktitle> <pages> pages 250-257, </pages> <year> 1988. </year>
Reference-contexts: While they appear adequate for many purposes, including name resolution in Algol-like languages, their generality is limited. Furthermore, efficient propagation of changes to the entire aggregate value relies on the ability to capture the relations between aggregate values directly in the finite function update primitive. Vorthmann and LeBlanc <ref> [76] </ref> abandon generality altogether, providing instead a specialized high-level notation for specifying name resolution rules. A similar task-specific approach is taken in PSG [2]. 2.3 Enriching the AG Formalism Colander [4], the incremental analyzer for Pan, eschewed AG technology altogether, taking an alternate approach based on incremental logic programming.
Reference: [77] <author> Tim A. Wagner and Susan L. Graham. </author> <title> Integrating incremental analysis with version management. </title> <editor> In Wilhelm Schafer and Pere Botella, editors, </editor> <booktitle> Software Engineering - ESEC '95, number 989 in Lecture Notes in Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1995. </year> <booktitle> Proceedings of the 5th European Software Engineering Conference. </booktitle>
Reference-contexts: A further benefit of incremental analysis is that changes can be tracked at very fine granularity, and in semantically relevant terms. For example, Wagner and Graham <ref> [77] </ref> track code revisions at the granularity of individual AST nodes, their parent-child relationships, and the annotations provided by analysis tools. Such fine-grained versioning is not provided in traditional environments, which track changes in terms of entire lines of text.
Reference: [78] <author> W. M. Waite. </author> <title> Use of attribute grammars in compiler construction. </title> <editor> In P. Deransart and M. Jourdan, editors, </editor> <title> Attribute Grammars and their Applications, </title> <booktitle> volume 461 of Lecture Notes in Computer Science, </booktitle> <pages> pages 255-265. </pages> <publisher> Springer-Verlag, </publisher> <year> 1990. </year>
Reference-contexts: Should the test fail, however, it applies the fibering transformation and then attempts the classical OAG construction again on 2 The notion of "dummy" attributes arises frequently in the literature, however the LIGA system <ref> [48, 78] </ref> is notable for its systematic use of such attributes to integrate imperative programming into attribute grammars in a reasonably clean manner. 3 As it turns out, the Example language is a degenerate case for fibering, and is thus not suitable for this purpose. <p> This very likely is related to the fact that attribute grammars have been extensively studied in the academic literature, but are seldom employed in constructing real compilers, as noted by Waite <ref> [78] </ref>. Toy languages used in expository papers invariably assume declaration before use, and several well-known published attribute grammars for the "full-strength" semantic analysis of real programming languages implement languages with strong declaration before use requirements, e.g., Pascal in Kastens [46] and Ada in Uhl, et al. [73].
Reference: [79] <author> R. C. Waters. </author> <title> Program editors should not abandon text oriented commands. </title> <journal> SIGPLAN Notices, </journal> <volume> 17(7) </volume> <pages> 39-46, </pages> <year> 1982. </year>
Reference-contexts: Indeed, many modifications of an existing program that are easily performed with a conventional text editor become extremely awkward in an explicit subtree-replacement model, as noted by Waters <ref> [79] </ref>. For this reason, many language-based editors, including Ensemble, allow textual editing operations applied to a textual view of the underlying AST, and map them automatically to tree modifications with an incremental parser.
Reference: [80] <author> David A. Watt. </author> <title> An extended attribute grammar for Pascal. </title> <journal> SIGPLAN Notices, </journal> <volume> 14(2) </volume> <pages> 60-74, </pages> <year> 1979. </year>
Reference-contexts: Since the edges of the graph are directed in this case, a functional mapping suffices. A clever trick, used by Watt in a published attribute grammar <ref> [80] </ref> for Pascal, exploits the fact that any cycle in a type descriptor must contain at least one reference to a named type. In Pascal, every such cycle is completed by a named type reference occurring in the definition of a pointer type.
Reference: [81] <author> David A. Watt and Ole Lehrmann Madsen. </author> <title> Extended attribute grammars. </title> <journal> The Computer Journal, </journal> <volume> 26(2) </volume> <pages> 142-153, </pages> <year> 1983. </year>
Reference-contexts: The two patterns not shown here reflect constraints as well as attribute propagation, as Jullig and DeRemer were working in the framework of Extended Attribute Grammars <ref> [81] </ref>, a restricted variant of two-level grammars. 58 constraint ! analyze child_name with f attribute_definition g + when [ ] =&gt; f constraint g + when [ singleton_name ] =&gt; f constraint g + when [ left_subseq_name ^ right_subseq_name ] =&gt; f constraint g + end ; We use AVL trees
Reference: [82] <author> Tim Wilkinson. Kaffe: </author> <title> A free virtual machine to run Java T M code. </title> <note> web page. http://www.tjwassoc.demon.co.uk/kaffe/kaffe.htm. </note>
Reference-contexts: This option is not available, however, when developing under Ensemble. The recent popularity of the Java T M language, and the availability of a freely redistributable "just in time" compiler for the Java byte code instruction set <ref> [82] </ref>, raises the intriguing possibility of generating Java byte codes directly from VTM source. The strongly typed, object-oriented, garbage-collected nature of the Java virtual machine is a good match for the semantics of VTM.
Reference: [83] <author> Taiichi Yuasa and Masami Hagiya. </author> <title> Kyoto Common Lisp Report. </title> <institution> Research Institute for Mathematical Sciences, Kyoto University, undated, </institution> <month> circa </month> <year> 1984. </year> <title> Distributed with the KCL implementation, </title> <note> available at ftp://ftp.cli.com/pub/kcl/. See also GNU Common Lisp, at ftp://ftp.cli.com/pub/gcl/. 157 </note>
Reference-contexts: The translation to C ++ is somewhat more complicated but nonetheless straightforward, compiling to C ++ code similar to that generated by other compilers for Lisp and Lisp-like languages that use C as an intermediate language, such as Kyoto Common Lisp <ref> [83] </ref>. The VTM has proven a very useful abstraction. The VTM to Common Lisp translation fits comfortably in a single source file, isolating the remainder of the compiler from any dependency on the target language.
References-found: 83

