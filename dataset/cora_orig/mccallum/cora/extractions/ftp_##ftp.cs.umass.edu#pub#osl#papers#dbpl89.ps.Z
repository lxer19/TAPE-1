URL: ftp://ftp.cs.umass.edu/pub/osl/papers/dbpl89.ps.Z
Refering-URL: http://spa-www.cs.umass.edu/bibliography.html
Root-URL: 
Email: Moss@cs.umass.edu  
Title: Addressing Large Distributed Collections of Persistent Objects: The Mneme Project's Approach  
Author: J. Eliot B. Moss 
Date: June 1989  
Note: (Internet); (413) 545-4206  
Address: Amherst, MA 01003  
Affiliation: Department of Computer and Information Science University of Massachusetts  
Abstract: The Mneme persistent object store project has as one of its primary goals to support cooperative, concurrent, and reliable use of large, distributed collections of objects. In our case, distribution is intended to mean not only physical dispersion, but also some autonomy or independence of subcollections of objects|that is, the object space is under some degree of decentralized management. Providing independence of subcollections of objects has interesting implications as to how to address and retrieve objects efficiently. Here we describe the need for and benefits of independent subcollections of objects, examine the addressing implications, and show how these implications have affected the design of Mneme. Most particularly, we argue against the appropriateness of a large flat store of bytes or even of object identifiers, and in favor of richer, more flexible, structures. We also contend that comparable performance can be achieved by careful implementation of the richer structures, with considerably more functionality and flexibility than flat structures provide. The cost is increased complexity of the supporting software. 
Abstract-found: 1
Intro-found: 1
Reference: [Bishop, 1977] <author> Peter B. Bishop. </author> <title> Computer Systems with a Very Large Address Space and Garbage Collection. </title> <type> PhD thesis, </type> <institution> Massachusetts Institute of Technology, </institution> <address> Cambridge, MA, </address> <month> May </month> <year> 1977. </year>
Reference-contexts: A flat space makes it difficult to locate and extract a meaningful subset of data, insert it into a similar space elsewhere, and then use it meaningfully. * As argued in <ref> [Bishop, 1977] </ref>, localities are essential for effective garbage collection in very large address spaces 1 . <p> Finally, there is the overhead in design, the distortion of program structure, and, in the case of reference counting storage reclamation, higher run-time cost. 1 Bishop called localities areas. Let us turn to a space structured as a collection of independently managed localities. Following Bishop <ref> [Bishop, 1977] </ref>, we distinguish between intra-locality and inter-locality references. Inter-locality references require special interpretation, which may be done by the referenced locality.
Reference: [Brown and Cockshott, 1986] <author> A. L. Brown and W. P. Cockshott. </author> <title> The CPOMS persistent object management system. </title> <type> Tech. Rep. </type> <institution> Persistent Programming Research Project 13, University of St. </institution> <address> Andrews, Scotland, </address> <year> 1986. </year>
Reference-contexts: Systems that have taken the large virtual memory approach include the Intel 432 [Organick, 1983; Intel Corporation, 1981], the IBM RT [Chang and Mergen, 1988], the Bubba project [Copeland et al., 1988], CPOMS and related systems <ref> [Brown and Cockshott, 1986; Cockshott, 1987; Connor et al., 1989] </ref>, and MONADS [Keedy and Rosenberg, 1989]. [Chang and Mergen, 1988] and [Copeland et al., 1988] deal more especially and completely with problems of concurrent access and reliability (transaction support).
Reference: [Chang and Mergen, 1988] <author> Albert Chang and Mark F. Mergen. </author> <title> 801 storage: Architecture and programming. </title> <journal> ACM Trans. Comput. Syst. </journal> <volume> 6, </volume> <month> 1 (Feb. </month> <year> 1988), </year> <pages> 28-50. </pages>
Reference-contexts: Systems that have taken the large virtual memory approach include the Intel 432 [Organick, 1983; Intel Corporation, 1981], the IBM RT <ref> [Chang and Mergen, 1988] </ref>, the Bubba project [Copeland et al., 1988], CPOMS and related systems [Brown and Cockshott, 1986; Cockshott, 1987; Connor et al., 1989], and MONADS [Keedy and Rosenberg, 1989]. [Chang and Mergen, 1988] and [Copeland et al., 1988] deal more especially and completely with problems of concurrent access and <p> have taken the large virtual memory approach include the Intel 432 [Organick, 1983; Intel Corporation, 1981], the IBM RT <ref> [Chang and Mergen, 1988] </ref>, the Bubba project [Copeland et al., 1988], CPOMS and related systems [Brown and Cockshott, 1986; Cockshott, 1987; Connor et al., 1989], and MONADS [Keedy and Rosenberg, 1989]. [Chang and Mergen, 1988] and [Copeland et al., 1988] deal more especially and completely with problems of concurrent access and reliability (transaction support). In particular, past objections to flat stores that have been addressed with some success include concurrency control, recovery, and buffer management.
Reference: [Cockshott, 1987] <author> P. Cockshott. </author> <title> Stable virtual memory. In Persistent Object Systems: Their Design, Implementation, and Use (University of St. </title> <address> Andrews, Scotland, </address> <month> Aug. </month> <year> 1987), </year> <booktitle> Department of Computational Science, </booktitle> <pages> pp. 470-476. </pages>
Reference-contexts: Systems that have taken the large virtual memory approach include the Intel 432 [Organick, 1983; Intel Corporation, 1981], the IBM RT [Chang and Mergen, 1988], the Bubba project [Copeland et al., 1988], CPOMS and related systems <ref> [Brown and Cockshott, 1986; Cockshott, 1987; Connor et al., 1989] </ref>, and MONADS [Keedy and Rosenberg, 1989]. [Chang and Mergen, 1988] and [Copeland et al., 1988] deal more especially and completely with problems of concurrent access and reliability (transaction support).
Reference: [Connor et al., 1989] <author> R. Connor, A. Brown, R. Carrick, A. Dearle, and R. Morrison. </author> <title> The persistent abstract machine. In Persistent Object Systems: Their Design, Implementation, </title> <institution> and Use (University of Newcastle, NSW, Australia, </institution> <month> Jan. </month> <year> 1989), </year> <institution> Department of Computer Science, </institution> <note> pp. 80-95. </note>
Reference-contexts: Systems that have taken the large virtual memory approach include the Intel 432 [Organick, 1983; Intel Corporation, 1981], the IBM RT [Chang and Mergen, 1988], the Bubba project [Copeland et al., 1988], CPOMS and related systems <ref> [Brown and Cockshott, 1986; Cockshott, 1987; Connor et al., 1989] </ref>, and MONADS [Keedy and Rosenberg, 1989]. [Chang and Mergen, 1988] and [Copeland et al., 1988] deal more especially and completely with problems of concurrent access and reliability (transaction support).
Reference: [Copeland et al., 1988] <author> George Copeland, Mike Franklin, and Gerhard Weikum. </author> <title> Uniform object management. </title> <type> MCC Technical Report ACA-ST-411-88, </type> <institution> Microelectronics and Computer Technology Corporation, Austin, TX, </institution> <month> Dec. </month> <year> 1988. </year>
Reference-contexts: This speeds and simplifies object and search structure traversal, avoids format conversions, and reduces the amount of object copying required, as noted in <ref> [Copeland et al., 1988] </ref>. * Hardware support is well understood and easy to justify. Systems that have taken the large virtual memory approach include the Intel 432 [Organick, 1983; Intel Corporation, 1981], the IBM RT [Chang and Mergen, 1988], the Bubba project [Copeland et al., 1988], CPOMS and related systems [Brown <p> amount of object copying required, as noted in <ref> [Copeland et al., 1988] </ref>. * Hardware support is well understood and easy to justify. Systems that have taken the large virtual memory approach include the Intel 432 [Organick, 1983; Intel Corporation, 1981], the IBM RT [Chang and Mergen, 1988], the Bubba project [Copeland et al., 1988], CPOMS and related systems [Brown and Cockshott, 1986; Cockshott, 1987; Connor et al., 1989], and MONADS [Keedy and Rosenberg, 1989]. [Chang and Mergen, 1988] and [Copeland et al., 1988] deal more especially and completely with problems of concurrent access and reliability (transaction support). <p> memory approach include the Intel 432 [Organick, 1983; Intel Corporation, 1981], the IBM RT [Chang and Mergen, 1988], the Bubba project <ref> [Copeland et al., 1988] </ref>, CPOMS and related systems [Brown and Cockshott, 1986; Cockshott, 1987; Connor et al., 1989], and MONADS [Keedy and Rosenberg, 1989]. [Chang and Mergen, 1988] and [Copeland et al., 1988] deal more especially and completely with problems of concurrent access and reliability (transaction support). In particular, past objections to flat stores that have been addressed with some success include concurrency control, recovery, and buffer management. <p> This need has been recognized by database system implementors, presented as a complaint about the inappropriateness of common operating system virtual memory management policies for database page management. More modern systems support some policy variation, for example, <ref> [Copeland et al., 1988] </ref> describes a system with two policies. <p> The alternative is to impose ad hoc, unenforced, and probably unenforceable rules (i.e., programming conventions) about where to insert levels of indirection, to restrict the patterns of inter-object references (e.g., the data must form a tree in the system described by <ref> [Copeland et al., 1988] </ref>), or to forego garbage collection|itself a problem since compacting garbage collection and the resulting reclustering and compaction of objects have significant performance advantages over time.
Reference: [Goldberg and Robson, 1983] <author> Adele Goldberg and David Robson. </author> <title> Smalltalk-80: The Language and its Implementation. </title> <publisher> Addison-Wesley, </publisher> <year> 1983. </year>
Reference-contexts: We believe this because of our experience with various heap-oriented programming languages, such as Clu [Liskov et al., 1977; Liskov et al., 1981], LISP [Steele Jr., 1984; McCarthy et al., 1984], Trellis/Owl [Schaffert et al., 1986], and Smalltalk <ref> [Goldberg and Robson, 1983] </ref>. We feel these languages are more representative of future programming concerning object size and use of pointers than are traditional (e.g., relational) databases, where pointers are rare. In heap oriented languages, pointers seem to comprise 30% to 50% or more of the data in many programs.
Reference: [Intel Corporation, 1981] <author> Intel Corporation. </author> <title> Introduction to the iAPX 432 Architecture, Manual 171821-001. </title> <publisher> Intel Corporation, </publisher> <address> Santa Clara, CA, </address> <year> 1981. </year>
Reference-contexts: Systems that have taken the large virtual memory approach include the Intel 432 <ref> [Organick, 1983; Intel Corporation, 1981] </ref>, the IBM RT [Chang and Mergen, 1988], the Bubba project [Copeland et al., 1988], CPOMS and related systems [Brown and Cockshott, 1986; Cockshott, 1987; Connor et al., 1989], and MONADS [Keedy and Rosenberg, 1989]. [Chang and Mergen, 1988] and [Copeland et al., 1988] deal more especially
Reference: [Kaehler and Krasner, 1983] <author> Ted Kaehler and Glenn Krasner. </author> <title> LOOM-large object-oriented memory for Smalltalk-80 systems. In Smalltalk-80: Bits of History, Words of Advice, </title> <editor> Glenn Krasner, Ed. </editor> <publisher> Addison-Wesley, </publisher> <year> 1983, </year> <journal> ch. </journal> <volume> 14, </volume> <pages> pp. 251-270. </pages>
Reference-contexts: In this section we consider narrow client addresses. The following section considers narrow addresses in secondary storage. 5.1 Loom Accessing a large space of objects from a machine with a narrower address space has certainly been done before. One well known system, Loom, is described in <ref> [Kaehler and Krasner, 1983] </ref> and [Kaehler, 1986]. Loom stands for "large object oriented memory", and it provided access from a 16 bit wide machine to objects residing in a 32 bit addressed store on disk.
Reference: [Kaehler, 1986] <author> Ted Kaehler. </author> <title> Virtual memory on a narrow machine for an object-oriented language. </title> <booktitle> In Proceedings of the Conference on Object-Oriented Programming Systems, Languages, and Applications (Portland, </booktitle> <address> OR, </address> <month> Sept. </month> <year> 1986), </year> <booktitle> ACM, </booktitle> <pages> pp. 87-106. </pages>
Reference-contexts: The following section considers narrow addresses in secondary storage. 5.1 Loom Accessing a large space of objects from a machine with a narrower address space has certainly been done before. One well known system, Loom, is described in [Kaehler and Krasner, 1983] and <ref> [Kaehler, 1986] </ref>. Loom stands for "large object oriented memory", and it provided access from a 16 bit wide machine to objects residing in a 32 bit addressed store on disk. The only goal of that system was to expand the effective virtual memory; we have additional goals.
Reference: [Keedy and Rosenberg, 1989] <author> James Leslie Keedy and John Rosenberg. </author> <title> Support for objects in the MONADS architecture. In Persistent Object Systems: Their Design, Implementation, </title> <institution> and Use (University of Newcastle, NSW, Australia, </institution> <month> Jan. </month> <year> 1989), </year> <institution> Department of Computer Science, </institution> <note> pp. 202-213. </note>
Reference-contexts: Systems that have taken the large virtual memory approach include the Intel 432 [Organick, 1983; Intel Corporation, 1981], the IBM RT [Chang and Mergen, 1988], the Bubba project [Copeland et al., 1988], CPOMS and related systems [Brown and Cockshott, 1986; Cockshott, 1987; Connor et al., 1989], and MONADS <ref> [Keedy and Rosenberg, 1989] </ref>. [Chang and Mergen, 1988] and [Copeland et al., 1988] deal more especially and completely with problems of concurrent access and reliability (transaction support). In particular, past objections to flat stores that have been addressed with some success include concurrency control, recovery, and buffer management.
Reference: [Khoshafian and Copeland, 1986] <author> Setrag N. Khoshafian and George P. Copeland. </author> <title> Object identity. </title> <booktitle> In Proceedings of the Conference on Object-Oriented Programming Systems, Languages, and Applications (Portland, </booktitle> <address> OR, </address> <month> Sept. </month> <year> 1986), </year> <booktitle> ACM, </booktitle> <pages> pp. 406-416. </pages>
Reference-contexts: An id does not directly encode the object's location (though it may contain a hint), so there must be additional mapping information. Such names are thus location independent <ref> [Khoshafian and Copeland, 1986] </ref>. If we are willing to give up some location independence, we can reduce the mapping overhead by tying the name (id) to the location of the object within a large shared virtual address space.
Reference: [Liskov et al., 1977] <author> B. Liskov, A. Snyder, R. Atkinson, and C. Schaffert. </author> <title> Abstraction mechanisms in CLU. </title> <journal> Commun. ACM 20, </journal> <month> 8 (Aug. </month> <year> 1977), </year> <pages> 564-576. </pages>
Reference-contexts: Even if somehow it is only addresses (pointers) that are widened there is still likely to be a considerable increase in size. We believe this because of our experience with various heap-oriented programming languages, such as Clu <ref> [Liskov et al., 1977; Liskov et al., 1981] </ref>, LISP [Steele Jr., 1984; McCarthy et al., 1984], Trellis/Owl [Schaffert et al., 1986], and Smalltalk [Goldberg and Robson, 1983].
Reference: [Liskov et al., 1981] <author> B. Liskov, R. Atkinson, T. Bloom, E. Moss, C. Schaffert, R. Scheifler, and A. Snyder. </author> <title> CLU Reference Manual. </title> <publisher> Springer-Verlag, </publisher> <year> 1981. </year>
Reference-contexts: Even if somehow it is only addresses (pointers) that are widened there is still likely to be a considerable increase in size. We believe this because of our experience with various heap-oriented programming languages, such as Clu <ref> [Liskov et al., 1977; Liskov et al., 1981] </ref>, LISP [Steele Jr., 1984; McCarthy et al., 1984], Trellis/Owl [Schaffert et al., 1986], and Smalltalk [Goldberg and Robson, 1983].
Reference: [McCarthy et al., 1984] <author> John McCarthy, Paul W. Abrahams, Daniel J. Edwards, Timothy P. Hart, and Michael I. Levin. </author> <title> LISP 1.5 Programmer's Manual, second ed. </title> <publisher> MIT Press, </publisher> <address> Cambridge, MA, </address> <year> 1984. </year>
Reference-contexts: Even if somehow it is only addresses (pointers) that are widened there is still likely to be a considerable increase in size. We believe this because of our experience with various heap-oriented programming languages, such as Clu [Liskov et al., 1977; Liskov et al., 1981], LISP <ref> [Steele Jr., 1984; McCarthy et al., 1984] </ref>, Trellis/Owl [Schaffert et al., 1986], and Smalltalk [Goldberg and Robson, 1983]. We feel these languages are more representative of future programming concerning object size and use of pointers than are traditional (e.g., relational) databases, where pointers are rare.
Reference: [Moss and Sinofsky, 1988] <author> J. Eliot B. Moss and Steven Sinofsky. </author> <title> Managing persistent data with Mneme: Designing a reliable, shared object interface. </title> <booktitle> In Advances in Object-Oriented Database Systems (Sept. 1988), vol. 334 of Lecture Notes in Computer Science, </booktitle> <publisher> Springer-Verlag, </publisher> <pages> pp. 298-316. </pages>
Reference-contexts: A single user, non-distributed prototype has been running since September 1988. Further information on Mneme, its goals and concepts, and implementation strategies taken in the first prototype can be found in <ref> [Moss and Sinofsky, 1988] </ref>. 1.3 The opposing view Our position is that relatively short, contextual addresses for objects will work best, on cost and functionality grounds. The opposing view is that long, non-contextual (global) addresses are better. In this view, every object would have a globally unique object identifier.
Reference: [Organick, 1983] <author> Elliott I. Organick. </author> <title> A Programmer's View of the Intel 432. </title> <publisher> McGraw-Hill, </publisher> <address> New York, </address> <year> 1983. </year>
Reference-contexts: Systems that have taken the large virtual memory approach include the Intel 432 <ref> [Organick, 1983; Intel Corporation, 1981] </ref>, the IBM RT [Chang and Mergen, 1988], the Bubba project [Copeland et al., 1988], CPOMS and related systems [Brown and Cockshott, 1986; Cockshott, 1987; Connor et al., 1989], and MONADS [Keedy and Rosenberg, 1989]. [Chang and Mergen, 1988] and [Copeland et al., 1988] deal more especially
Reference: [Schaffert et al., 1986] <author> Craig Schaffert, Topher Cooper, Bruce Bullis, Mike Kilian, and Carrie Wilpolt. </author> <title> An introduction to Trellis/Owl. </title> <booktitle> In Proceedings of the Conference on Object-Oriented Programming Systems, Languages, and Applications (Portland, </booktitle> <address> OR, </address> <month> Sept. </month> <year> 1986), </year> <title> vol. </title> <journal> 21(11) of ACM SIGPLAN Notices, ACM, </journal> <pages> pp. 9-16. </pages>
Reference-contexts: We believe this because of our experience with various heap-oriented programming languages, such as Clu [Liskov et al., 1977; Liskov et al., 1981], LISP [Steele Jr., 1984; McCarthy et al., 1984], Trellis/Owl <ref> [Schaffert et al., 1986] </ref>, and Smalltalk [Goldberg and Robson, 1983]. We feel these languages are more representative of future programming concerning object size and use of pointers than are traditional (e.g., relational) databases, where pointers are rare.
Reference: [Steele Jr., 1984] <author> Guy L. Steele Jr. </author> <title> Common Lisp: The Language. </title> <publisher> Digital Press, </publisher> <address> Burlington, MA, </address> <year> 1984. </year>
Reference-contexts: Even if somehow it is only addresses (pointers) that are widened there is still likely to be a considerable increase in size. We believe this because of our experience with various heap-oriented programming languages, such as Clu [Liskov et al., 1977; Liskov et al., 1981], LISP <ref> [Steele Jr., 1984; McCarthy et al., 1984] </ref>, Trellis/Owl [Schaffert et al., 1986], and Smalltalk [Goldberg and Robson, 1983]. We feel these languages are more representative of future programming concerning object size and use of pointers than are traditional (e.g., relational) databases, where pointers are rare.
References-found: 19

