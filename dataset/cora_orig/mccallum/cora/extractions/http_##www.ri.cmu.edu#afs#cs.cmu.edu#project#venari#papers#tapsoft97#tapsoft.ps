URL: http://www.ri.cmu.edu/afs/cs.cmu.edu/project/venari/papers/tapsoft97/tapsoft.ps
Refering-URL: http://www.ri.cmu.edu/afs/cs.cmu.edu/project/venari/www/tapsoft97.html
Root-URL: 
Title: Protective Interface Specifications Keywords: Protective specifications; Specification languages; Underspecifica-tion; Partiality; Larch. languages, theory, Larch, VDM,
Author: Gary T. Leavens and Jeannette M. Wing TR #-c Gary T. Leavens and Jeannette M. Wing. 
Degree: All rights reserved.  
Address: 226 Atanasoff Hall  Ames, Iowa 50011-1040, USA  
Affiliation: Department of Computer Science  Iowa State University  
Note: 1996 CR Categories: D.2.1 [Software Engineering] Requirements/Specifications  c Copyright 1996, 1997 by  
Date: April 1996, Revised October, December 1996, February 1997  
Abstract: A version of this paper, without the appendix sections, will appear in the proceedings of the Colloquium on Formal Approaches in Software Engineering (FASE), TAPSOFT '97, Lille, France, April 1996, to be published by Springer-Verlag in their Lecture Notes in Computer Science Series. An earlier version of this paper was called "Protection from the Underspecified". This technical report is also CMU-CS-96-129R. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> D. Andrews et al. </author> <title> Information technology programming languages - VDM-SL: First committee draft standard CD1387-1. Document ISO/IEC JTC1/SC22/WG19 N-20, </title> <booktitle> International Standards Organization, </booktitle> <month> Nov. </month> <year> 1993. </year> <month> ftp://gatekeeper.dec.com/pub/standards/vdmsl/. </month>
Reference-contexts: For example, VDM-SL <ref> [18, 1] </ref> uses a logic called LPF [18, Section 3.3] [2, 3, 19], which has three logical values and two kinds of equality. 1 As another example, the specification languages COLD-K [10], uses a logic having just two logical values, but in which all other types have an improper value, ?,
Reference: [2] <author> H. Barringer, J. H. Cheng, and C. B. Jones. </author> <title> A logic covering undefinedness in program proofs. </title> <journal> Acta Informatica, </journal> <volume> 21(3) </volume> <pages> 251-269, </pages> <month> Oct. </month> <year> 1984. </year>
Reference-contexts: For example, VDM-SL [18, 1] uses a logic called LPF [18, Section 3.3] <ref> [2, 3, 19] </ref>, which has three logical values and two kinds of equality. 1 As another example, the specification languages COLD-K [10], uses a logic having just two logical values, but in which all other types have an improper value, ?, which models the "undefined" results of partial functions, and also
Reference: [3] <author> J. Bicarregui, J. S. Fitgerald, P. A. Lindsay, R. Moore, and B. Ritchie. </author> <title> Proof in VDM: A Practitioner's Guide. </title> <publisher> Springer-Verlag, </publisher> <address> New York, N.Y., </address> <year> 1994. </year>
Reference-contexts: For example, VDM-SL [18, 1] uses a logic called LPF [18, Section 3.3] <ref> [2, 3, 19] </ref>, which has three logical values and two kinds of equality. 1 As another example, the specification languages COLD-K [10], uses a logic having just two logical values, but in which all other types have an improper value, ?, which models the "undefined" results of partial functions, and also
Reference: [4] <author> A. Bijlsma. </author> <title> Semantics of quasi-boolean expressions. </title> <editor> In W. H. J. Feijen et al., editors, </editor> <booktitle> Beauty is Our Business, </booktitle> <pages> pages 27-35. </pages> <publisher> Springer-Verlag, </publisher> <year> 1990. </year>
Reference-contexts: In COLD-K there is also a definedness predicate, D, that allows one to reason explicitly about whether a term denotes a proper value or not. There are several other languages with similar concepts <ref> [4, 6, 26, 20, 28] </ref>. The second concept of protection we discuss is appropriate for BISLs that use a logic that does not admit the existence of partial functions, but uses underspecifica-tion. In such a logic, one avoids specifying a value for undefined terms [13, 17].
Reference: [5] <author> A. Blikle. </author> <title> The clean termination of iterative programs. </title> <journal> Acta Informatica, </journal> <volume> 16 </volume> <pages> 199-217, </pages> <year> 1981. </year> <month> 19 </month>
Reference-contexts: = fact 0 (k): The proof would proceed by induction on k. 3.2 Exact Predicates For use in proving protection, we define predicates of the form Exact (`E'), based on the form (i.e., the text) of each expression E. (These resemble the domain predicates, Dom (`E'), described by some authors <ref> [12, 9, 5] </ref>. However, they have a different purpose, since an operator, such as choose on nonempty sets, may be underspecified for a reason other than being partial.
Reference: [6] <author> A. Blikle. </author> <title> Three-valued predicates for software specification and validation. </title> <journal> Fun-damenta Informaticae, </journal> <volume> XIV:387-410, </volume> <year> 1991. </year>
Reference-contexts: In COLD-K there is also a definedness predicate, D, that allows one to reason explicitly about whether a term denotes a proper value or not. There are several other languages with similar concepts <ref> [4, 6, 26, 20, 28] </ref>. The second concept of protection we discuss is appropriate for BISLs that use a logic that does not admit the existence of partial functions, but uses underspecifica-tion. In such a logic, one avoids specifying a value for undefined terms [13, 17].
Reference: [7] <author> M. Broy and M. Wirsing. </author> <title> Partial abstract types. </title> <journal> Acta Informatica, </journal> <volume> 18(1) </volume> <pages> 47-64, </pages> <month> Nov. </month> <year> 1982. </year>
Reference-contexts: However, they have a different purpose, since an operator, such as choose on nonempty sets, may be underspecified for a reason other than being partial. They also resemble the definedness predicate (D) used in studies of partial algebras <ref> [7] </ref> and in COLD [10]; however D is defined model-theoretically, not syntactically.) The definition of Exact (`') is based on the exact clauses given in the trait's implications (and those of included traits).
Reference: [8] <author> J. H. Cheng and C. B. Jones. </author> <title> On the usability of logics which handle partial functions. </title> <editor> In C. Morgan and J. C. P. Woodcock, editors, </editor> <booktitle> Proceedings of the Third Refinement Workshop, Workshops in Computing Series, </booktitle> <pages> pages 51-69, </pages> <address> Berlin, 1990. </address> <publisher> Springer-Verlag. </publisher>
Reference-contexts: In this paper we consider what protection means with respect to partiality and underspecification. Our treatment of protection is not meant to be exhaustive, but merely to illustrate concepts that are useful with some logics that are widely used for formal specification. (See <ref> [8, 13] </ref> for surveys that also cover additional kinds of logics that might be used in formal specification, and hence might need their own concepts of protection.
Reference: [9] <author> D. Coleman and J. W. Hughes. </author> <title> The clean termination of Pascal programs. </title> <journal> Acta Informatica, </journal> <volume> 11 </volume> <pages> 195-210, </pages> <year> 1979. </year>
Reference-contexts: = fact 0 (k): The proof would proceed by induction on k. 3.2 Exact Predicates For use in proving protection, we define predicates of the form Exact (`E'), based on the form (i.e., the text) of each expression E. (These resemble the domain predicates, Dom (`E'), described by some authors <ref> [12, 9, 5] </ref>. However, they have a different purpose, since an operator, such as choose on nonempty sets, may be underspecified for a reason other than being partial.
Reference: [10] <author> L. M. G. Feijs and H. B. M. Jonkers. </author> <title> Formal Specification and Design, </title> <booktitle> volume 35 of Cambridge Tracts in Theoretical Computer Science. </booktitle> <publisher> Cambridge University Press, </publisher> <address> Cambridge, UK, </address> <year> 1992. </year>
Reference-contexts: For example, VDM-SL [18, 1] uses a logic called LPF [18, Section 3.3] [2, 3, 19], which has three logical values and two kinds of equality. 1 As another example, the specification languages COLD-K <ref> [10] </ref>, uses a logic having just two logical values, but in which all other types have an improper value, ?, which models the "undefined" results of partial functions, and also models computations that go into infinite loops or cause errors. <p> However, they have a different purpose, since an operator, such as choose on nonempty sets, may be underspecified for a reason other than being partial. They also resemble the definedness predicate (D) used in studies of partial algebras [7] and in COLD <ref> [10] </ref>; however D is defined model-theoretically, not syntactically.) The definition of Exact (`') is based on the exact clauses given in the trait's implications (and those of included traits).
Reference: [11] <author> S. J. Garland, J. V. Guttag, and J. J. Horning. </author> <title> Debugging Larch Shared Language specifications. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 16(6) </volume> <pages> 1044-1057, </pages> <month> Sept. </month> <year> 1990. </year>
Reference-contexts: The concept of an exact term is based on an extension to LSL that allows one to specify which terms are not intended to be underspecified. This extension to LSL provides better documentation and allows enhanced debugging (in the sense of <ref> [11] </ref> [14, Chapter 7]) of LSL specifications. 13 uses IntSetTrait; int pick (IntSet s); behavior - requires size (s^) &gt; 0; ensures result = choose (s^) ^ s' = delete (choose (s^), s^); - notations s^ and s' mean the starting and ending values of s. <p> B.1 Conversion In a LSL trait, one can state redundant properties (theorems) that one believes do (or should) hold. These redundant properties are stated in the implies section of the specification. Proofs of such properties can be attempted, and are a way of debugging the trait <ref> [11] </ref> [14, Chapter 7]. For our purposes, the most interesting kind of redundant property one can state in the implies section is that an operator is well-defined with respect to other operators. This is done by using a converts clause, as was done in Figure 14.
Reference: [12] <author> S. M. </author> <title> German. Automating proofs of the absence of common runtime errors. </title> <booktitle> In Conference record of the Fifth Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 105-118. </pages> <publisher> ACM, </publisher> <month> Jan. </month> <year> 1978. </year>
Reference-contexts: = fact 0 (k): The proof would proceed by induction on k. 3.2 Exact Predicates For use in proving protection, we define predicates of the form Exact (`E'), based on the form (i.e., the text) of each expression E. (These resemble the domain predicates, Dom (`E'), described by some authors <ref> [12, 9, 5] </ref>. However, they have a different purpose, since an operator, such as choose on nonempty sets, may be underspecified for a reason other than being partial.
Reference: [13] <author> D. Gries and F. B. Schneider. </author> <title> Avoiding the undefined by underspecification. </title> <editor> In J. van Leeuwen, editor, </editor> <booktitle> Computer Science Today: Recent Trends and Developments, number 1000 in Lecture Notes in Computer Science, </booktitle> <pages> pages 366-373. </pages> <publisher> Springer-Verlag, </publisher> <address> New York, N.Y., </address> <year> 1995. </year>
Reference-contexts: In this paper we consider what protection means with respect to partiality and underspecification. Our treatment of protection is not meant to be exhaustive, but merely to illustrate concepts that are useful with some logics that are widely used for formal specification. (See <ref> [8, 13] </ref> for surveys that also cover additional kinds of logics that might be used in formal specification, and hence might need their own concepts of protection. <p> The second concept of protection we discuss is appropriate for BISLs that use a logic that does not admit the existence of partial functions, but uses underspecifica-tion. In such a logic, one avoids specifying a value for undefined terms <ref> [13, 17] </ref>. In this approach, to make a term "undefined" one simply does not specify its value; hence it will not be possible to prove what its value is. <p> For example, head (empty) denotes some element of the appropriate type, even if the user has not specified what element that term denotes. Where an LSL specification is silent, terms take on some (unspecified) value. In common with other logics that use underspecification to avoid the undefined <ref> [13] </ref>, the logic of LSL is classical, and thus has several pleasing formal properties. However, as Jones pointed out in a recent paper [17], there are a few subtle aspects to this kind of logic that users should be aware of. <p> For example, one can writing factTrait as in Figure 6, where the equation for the recursive case is only postulated to hold for its intended domain <ref> [13] </ref>. By writing factTrait in that way, one avoids postulating Equation (8); that is, nothing at all is specified about the value of fact (-1).
Reference: [14] <author> J. V. Guttag, J. J. Horning, S. Garland, K. Jones, A. Modet, and J. Wing. </author> <title> Larch: Languages and Tools for Formal Specification. </title> <publisher> Springer-Verlag, </publisher> <address> New York, N.Y., </address> <year> 1993. </year>
Reference-contexts: In such a logic, one avoids specifying a value for undefined terms [13, 17]. In this approach, to make a term "undefined" one simply does not specify its value; hence it will not be possible to prove what its value is. For example, the Larch family BISLs <ref> [14] </ref> use a mathematical component, LSL [14, Chapter 4] [15], which has this kind of 1 However, in LPF nonstrict (i.e., strong) equality and the definedness operator, , are only used in meta-arguments, since the logic is designed so that one only needs to use strict (i.e., weak) equality in proofs. <p> In this approach, to make a term "undefined" one simply does not specify its value; hence it will not be possible to prove what its value is. For example, the Larch family BISLs [14] use a mathematical component, LSL <ref> [14, Chapter 4] </ref> [15], which has this kind of 1 However, in LPF nonstrict (i.e., strong) equality and the definedness operator, , are only used in meta-arguments, since the logic is designed so that one only needs to use strict (i.e., weak) equality in proofs. 4 logic. (See Appendix A for <p> Finally we define the notion of underspec-protection itself. The notion of a primed trait and term is a variation of the idea of "priming" traits and terms found in the Larch Prover (where it is used in proving that an operator is "converted" <ref> [14, pp. 142-4] </ref>). Definition 2.2 (Primed Trait, T 0 ) Let T be an LSL trait. <p> also no way to separate underspecification that is used to make operators "partial" from underspecification that is used to make specifications intentionally less constraining, as in a choose operator for sets. 3 A trait is a specification of mathematical vocabulary in an augmented form of first-order logic with equality; see <ref> [14, Chapter 4] </ref> for details. 6 factTrait: trait includes Integer introduces fact: Int ! Int asserts 8 i: Int fact (0) == 1; (i &gt; 0) ) (fact (i) = i * fact (i-1)); operators are left alone: * all operators in the built-in trait Boolean, * all operators in all <p> The trait factTrait 0 has fact replaced by fact 0 , but true and the boolean operators are not primed, and neither are 0, pred, and succ, because they are mentioned in the generated by clause of the trait Integer <ref> [14, p. 161] </ref>. (Operators mentioned in a generated by clause are meant to give a way to produce all values of a given sort; priming these would add "junk" to the specification.) Similarly, if P is a term in the language of T , then let P 0 be a copy <p> A more interesting example is that, for factTrait, the term fact (27) is completely-defined, but both fact (-1) and fact (x), where x:Int, are not. As another example, the term choose (f1g [ f2g) is not completely-defined for the trait ChoiceSet (of <ref> [14, p. 176] </ref>). The following definition of when a procedure specification is protective says, in essence, that the precondition must be completely-defined for the used trait, and that whenever the precondition holds, then the postcondition must be completely-defined. <p> This is done by using a converts clause. A converts clause says that the axioms of the trait uniquely define the operators named in the clause, "relative to the other operators in the trait" <ref> [14, p. 142] </ref>. (See Appendix B for a more complete explanation of conversion.) 8 biggerTrait: trait includes Integer introduces muchBigger, somewhatBigger: Int ! Int asserts 8 i: Int somewhatBigger (i) == muchBigger (i); implies converts somewhatBigger: Int ! Int somewhatBigger (i) is not completely-defined. factTraitE: trait includes factTrait implies exact 8 <p> The concept of an exact term is based on an extension to LSL that allows one to specify which terms are not intended to be underspecified. This extension to LSL provides better documentation and allows enhanced debugging (in the sense of [11] <ref> [14, Chapter 7] </ref>) of LSL specifications. 13 uses IntSetTrait; int pick (IntSet s); behavior - requires size (s^) &gt; 0; ensures result = choose (s^) ^ s' = delete (choose (s^), s^); - notations s^ and s' mean the starting and ending values of s. <p> For example, the operator that returns the head of a list can be modeled as a partial function on lists; if that is done, then head (empty) fails to denote an element. (That is, head (empty) is "undefined.") The logic used by the Larch Shared Language (LSL) <ref> [14, Chapter 4] </ref> [15] deals with partiality by using underspecification. As noted in the main body, this means that one avoids specifying a value for undefined terms, but the logic assumes that all functions are total. <p> B.1 Conversion In a LSL trait, one can state redundant properties (theorems) that one believes do (or should) hold. These redundant properties are stated in the implies section of the specification. Proofs of such properties can be attempted, and are a way of debugging the trait [11] <ref> [14, Chapter 7] </ref>. For our purposes, the most interesting kind of redundant property one can state in the implies section is that an operator is well-defined with respect to other operators. This is done by using a converts clause, as was done in Figure 14. <p> This is done by using a converts clause, as was done in Figure 14. A converts clause says that the axioms of the trait uniquely define the operators named in the clause, "relative to the other operators in the trait" <ref> [14, p. 142] </ref>. To prove this, one must show it for all possible arguments. The Larch Prover (LP) uses the following proof technique [14, pp. 142-4]. Let T ( ~ f) be a trait, which names operators ~ f in converts 17 clauses in its implies section. <p> A converts clause says that the axioms of the trait uniquely define the operators named in the clause, "relative to the other operators in the trait" [14, p. 142]. To prove this, one must show it for all possible arguments. The Larch Prover (LP) uses the following proof technique <ref> [14, pp. 142-4] </ref>. Let T ( ~ f) be a trait, which names operators ~ f in converts 17 clauses in its implies section. <p> B.2 An extension to LSL The exempting clause in the current LSL <ref> [14, Chapter 4] </ref> [15] does not have enough expressive power to state, in general, what is left underspecified. One can only exempt a class of terms that are described by constants or universally quantified variables.
Reference: [15] <author> J. V. Guttag, J. J. Horning, and A. Modet. </author> <title> Report on the Larch Shared Language: Version 2.3. </title> <type> Technical Report 58, </type> <institution> Digital Equipment Corporation, Systems Research Center, </institution> <address> 130 Lytton Avenue, Palo Alto, CA 94301, </address> <month> Apr. </month> <year> 1990. </year> <title> Order from src-report@src.dec.com. </title>
Reference-contexts: In this approach, to make a term "undefined" one simply does not specify its value; hence it will not be possible to prove what its value is. For example, the Larch family BISLs [14] use a mathematical component, LSL [14, Chapter 4] <ref> [15] </ref>, which has this kind of 1 However, in LPF nonstrict (i.e., strong) equality and the definedness operator, , are only used in meta-arguments, since the logic is designed so that one only needs to use strict (i.e., weak) equality in proofs. 4 logic. (See Appendix A for more about underspecification <p> For example, the operator that returns the head of a list can be modeled as a partial function on lists; if that is done, then head (empty) fails to denote an element. (That is, head (empty) is "undefined.") The logic used by the Larch Shared Language (LSL) [14, Chapter 4] <ref> [15] </ref> deals with partiality by using underspecification. As noted in the main body, this means that one avoids specifying a value for undefined terms, but the logic assumes that all functions are total. <p> B.2 An extension to LSL The exempting clause in the current LSL [14, Chapter 4] <ref> [15] </ref> does not have enough expressive power to state, in general, what is left underspecified. One can only exempt a class of terms that are described by constants or universally quantified variables.
Reference: [16] <author> I. Hayes, </author> <title> editor. Specification Case Studies. </title> <booktitle> International Series in Computer Science. </booktitle> <publisher> Prentice-Hall, Inc., </publisher> <address> second edition, </address> <year> 1993. </year>
Reference-contexts: It also seems that the draft standard for Z <ref> [16, 25] </ref>, has decided to use this kind of logic [29]. It is not the purpose of this paper to advocate one kind of logic over another. Instead, this paper explores concepts of protection, with the aim of improving intuition about it and providing more guidance to specifiers.
Reference: [17] <author> C. Jones. </author> <title> Partial functions and logics: A warning. </title> <journal> Inf. Process. Lett., </journal> <volume> 54(2) </volume> <pages> 65-67, </pages> <year> 1995. </year>
Reference-contexts: The second concept of protection we discuss is appropriate for BISLs that use a logic that does not admit the existence of partial functions, but uses underspecifica-tion. In such a logic, one avoids specifying a value for undefined terms <ref> [13, 17] </ref>. In this approach, to make a term "undefined" one simply does not specify its value; hence it will not be possible to prove what its value is. <p> Where an LSL specification is silent, terms take on some (unspecified) value. In common with other logics that use underspecification to avoid the undefined [13], the logic of LSL is classical, and thus has several pleasing formal properties. However, as Jones pointed out in a recent paper <ref> [17] </ref>, there are a few subtle aspects to this kind of logic that users should be aware of. We translate Jones's first example into the LSL trait shown in Figure 14. This trait defines a sort, OneElem, a constant it, and a function f. <p> This trait defines a sort, OneElem, a constant it, and a function f. Because of the generated by clause, the sort OneElem has only one element, the constant it. (The current version of LSL allows such sorts, contrary to <ref> [17] </ref>.) In LSL f (-1) = it, because f has to take on some value when applied to -1, and the only possible value is it.
Reference: [18] <author> C. B. Jones. </author> <title> Systematic Software Development Using VDM. </title> <booktitle> International Series in Computer Science. </booktitle> <publisher> Prentice Hall, </publisher> <address> Englewood Cliffs, N.J., </address> <note> second edition, 1990. 20 </note>
Reference-contexts: For example, VDM-SL <ref> [18, 1] </ref> uses a logic called LPF [18, Section 3.3] [2, 3, 19], which has three logical values and two kinds of equality. 1 As another example, the specification languages COLD-K [10], uses a logic having just two logical values, but in which all other types have an improper value, ?, <p> For example, VDM-SL [18, 1] uses a logic called LPF <ref> [18, Section 3.3] </ref> [2, 3, 19], which has three logical values and two kinds of equality. 1 As another example, the specification languages COLD-K [10], uses a logic having just two logical values, but in which all other types have an improper value, ?, which models the "undefined" results of partial
Reference: [19] <author> C. B. Jones and K. Middelburg. </author> <title> A typed logic of partial functions reconstructed classically. </title> <journal> Acta Informatica, </journal> <volume> 31(5) </volume> <pages> 399-430, </pages> <year> 1994. </year>
Reference-contexts: For example, VDM-SL [18, 1] uses a logic called LPF [18, Section 3.3] <ref> [2, 3, 19] </ref>, which has three logical values and two kinds of equality. 1 As another example, the specification languages COLD-K [10], uses a logic having just two logical values, but in which all other types have an improper value, ?, which models the "undefined" results of partial functions, and also
Reference: [20] <author> B. Konikowska, A. Tarlecki, and A. Blikle. </author> <title> A three-valued logic for software specification and validation. </title> <note> Fundamenta Informaticae, XIV:411-453, </note> <year> 1991. </year>
Reference-contexts: In COLD-K there is also a definedness predicate, D, that allows one to reason explicitly about whether a term denotes a proper value or not. There are several other languages with similar concepts <ref> [4, 6, 26, 20, 28] </ref>. The second concept of protection we discuss is appropriate for BISLs that use a logic that does not admit the existence of partial functions, but uses underspecifica-tion. In such a logic, one avoids specifying a value for undefined terms [13, 17].
Reference: [21] <author> G. T. Leavens. </author> <note> Larch/C++ Reference Manual. Version 5.1. Available in ftp://ftp.cs.iastate.edu/pub/larchc++/lcpp.ps.gz or on the world wide web at the URL http://www.cs.iastate.edu/~leavens/larchc++.html, Jan. </note> <year> 1997. </year>
Reference-contexts: - requires informally "x is not too big"; ensures informally "result is the factorial of x"; - int factorial (int x); behavior - requires informally "x is nonnegative and x is not too big"; ensures informally "result is the factorial of x"; - the postcondition. (The keyword informally in Larch/C++ <ref> [21] </ref> signals the start of an informal predicate.) This specification is ill-defined, because it is not clear what the procedure should return when x is negative.
Reference: [22] <author> B. Meyer. </author> <title> Object-oriented Software Construction. </title> <publisher> Prentice Hall, </publisher> <address> New York, N.Y., </address> <year> 1988. </year>
Reference-contexts: Checks that a VDM-SL procedure is underspec-protective can be done in same way as we described them for the Larch family. Both kinds of protection may also be useful for writers of executable specifications. For example, in a language like Eiffel <ref> [22] </ref>, partiality-protection for a procedure would ensure that its precondition would be flagged as false instead of encountering an error, allowing an error to happen in its body, or encountering an error in its postcondition.
Reference: [23] <author> W. F. Ogden, M. Sitaraman, B. W. Weide, and S. H. </author> <title> Zweben. Part I: The RESOLVE framework and discipline | a research synopsis. </title> <booktitle> ACM SIGSOFT Software Engineering Notes, </booktitle> <volume> 19(4) </volume> <pages> 23-28, </pages> <month> Oct </month> <year> 1994. </year>
Reference-contexts: strong) equality and the definedness operator, , are only used in meta-arguments, since the logic is designed so that one only needs to use strict (i.e., weak) equality in proofs. 4 logic. (See Appendix A for more about underspecification and its relation to LSL.) The BISLs of the RESOLVE family <ref> [23] </ref> also use this kind of logic. It also seems that the draft standard for Z [16, 25], has decided to use this kind of logic [29]. It is not the purpose of this paper to advocate one kind of logic over another.
Reference: [24] <author> S. Owre, J. Rushby, N. Shankar, and F. von Henke. </author> <title> Formal verification for fault-tolerant architectures: Prolegomena to the design of PVS. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 21(2) </volume> <pages> 107-125, </pages> <month> Feb. </month> <year> 1995. </year>
Reference-contexts: Also PVS <ref> [24] </ref> represents another kind of specification logic that should be considered in extending our concepts.) The first concept of protection we discuss is appropriate for behavioral interface specification languages (BISLs) that use a logic that accepts the existence of partial functions and has various non-classical ways to reason about them.
Reference: [25] <author> J. M. Spivey. </author> <title> The Z Notation: A Reference Manual. </title> <booktitle> International Series in Computer Science. </booktitle> <publisher> Prentice-Hall, </publisher> <address> New York, N.Y., </address> <note> second edition, </note> <year> 1992. </year>
Reference-contexts: It also seems that the draft standard for Z <ref> [16, 25] </ref>, has decided to use this kind of logic [29]. It is not the purpose of this paper to advocate one kind of logic over another. Instead, this paper explores concepts of protection, with the aim of improving intuition about it and providing more guidance to specifiers.
Reference: [26] <author> D. S. Stefan Kahrs and A. Tarlecki. </author> <title> The definition of Extended ML: a gentle introduction. </title> <type> Technical Report ECS-LFCS-95-322, </type> <institution> Laboratory for Foundations of Computer Science, University of Edinburgh, </institution> <month> Oct. </month> <year> 1995. </year> <note> To appear in Theoretical Computer Science. </note>
Reference-contexts: In COLD-K there is also a definedness predicate, D, that allows one to reason explicitly about whether a term denotes a proper value or not. There are several other languages with similar concepts <ref> [4, 6, 26, 20, 28] </ref>. The second concept of protection we discuss is appropriate for BISLs that use a logic that does not admit the existence of partial functions, but uses underspecifica-tion. In such a logic, one avoids specifying a value for undefined terms [13, 17].
Reference: [27] <author> J. M. Wing. </author> <title> A two-tiered approach to specifying programs. </title> <type> Technical Report TR-299, </type> <institution> Massachusetts Institute of Technology, Laboratory for Computer Science, </institution> <year> 1983. </year>
Reference-contexts: Instead, this paper explores concepts of protection, with the aim of improving intuition about it and providing more guidance to specifiers. We also discuss how to prove protection from the effects of underspecification. 2 Protective Procedure Specifications The idea of protection in a BISL was first formulated by Wing <ref> [27, Section 5.1.4] </ref>.
Reference: [28] <author> U. Wolter, K. Didrich, F. Cornelius, M. Klar, R. Wessaly, and H. Ehrig. </author> <title> How to cope with the spectrum of spectrum. </title> <editor> In M. Broy and S. Jahnichen, editors, KORSO: </editor> <booktitle> Methods, Languages and Tools for the Construction of Correct Software, volume 1009 of Lecture Notes in Computer Science, </booktitle> <pages> pages 173-189. </pages> <publisher> Springer-Verlag, </publisher> <address> New York, N.Y., </address> <year> 1995. </year>
Reference-contexts: In COLD-K there is also a definedness predicate, D, that allows one to reason explicitly about whether a term denotes a proper value or not. There are several other languages with similar concepts <ref> [4, 6, 26, 20, 28] </ref>. The second concept of protection we discuss is appropriate for BISLs that use a logic that does not admit the existence of partial functions, but uses underspecifica-tion. In such a logic, one avoids specifying a value for undefined terms [13, 17].
Reference: [29] <author> J. Woodcock and D. Jackson. </author> <title> About the semantics of partial functions in Z. </title> <type> Personal communication, </type> <month> Apr. </month> <year> 1996. </year>
Reference-contexts: It also seems that the draft standard for Z [16, 25], has decided to use this kind of logic <ref> [29] </ref>. It is not the purpose of this paper to advocate one kind of logic over another. Instead, this paper explores concepts of protection, with the aim of improving intuition about it and providing more guidance to specifiers.
References-found: 29

