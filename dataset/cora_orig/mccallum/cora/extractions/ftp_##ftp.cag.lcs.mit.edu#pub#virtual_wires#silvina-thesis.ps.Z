URL: ftp://ftp.cag.lcs.mit.edu/pub/virtual_wires/silvina-thesis.ps.Z
Refering-URL: http://www.cag.lcs.mit.edu/vwires/papers/index.html
Root-URL: 
Title: InnerView Hardware Debugger: A Logic Analysis Tool for the Virtual Wires Emulation System  
Author: by Silvina Zimi Hanono Anant Agarwal 
Degree: Submitted to the Department of Electrical Engineering and Computer Science in partial fulfillment of the requirements for the degree of Master of Science at the  The author hereby grants to MIT permission to reproduce and to distribute copies of this thesis document in whole or in part. Signature of Author  Certified by  Associate Professor of Computer Science and Electrical Engineering Thesis Supervisor Accepted by Fred Morgenthaler Chairman, Departmental Committee on Graduate Students  
Note: c Massachusetts Institute of Technology,  
Date: January 1992  February 1995  1995  January 20, 1995  
Address: University,  
Affiliation: B.S. Electrical Engineering Cornell  MASSACHUSETTS INSTITUTE OF TECHNOLOGY  Department of Electrical Engineering and Computer Science  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> J. Babb, R. Tessier, and A. Agarwal. </author> <title> Virtual Wires: Overcoming Pin Limitations in FPGA-based Logic Emulators. </title> <booktitle> In IEEE Workshop on FPGAs for Custom Computing Machines, </booktitle> <address> Napa, CA, </address> <month> April </month> <year> 1993. </year>
Reference-contexts: INTRODUCTION lated signal (logical wire). These logical wires are not active simultaneously and are only switched at emulation clock speeds. The Virtual Wires <ref> [1] </ref> emulation system overcomes this pin limitation by intelligently multiplexing each physical wire among multiple logical wires and pipelining these connections at the maximum clocking frequency of the FPGA as shown in Figure 1-1. <p> The user can enable and disable as many of the triggers as needed. Figure 3-2 gives an example of the triggering capabilities. If trigger [0] is connected to signal A, and trigger <ref> [1] </ref> is connected to signal B, then at 3.3. SIMULATOR INTERFACE SIGNALS 29 runtime the user specifies that he/she wants a readback to occur if either signal A or B goes high by setting the mask to three. <p> USING THE INNERVIEW HARDWARE DEBUGGER 45 module PTEST_EM ( COUNT, RESET, FUNC, A, B, CLK, RESULT, DOREAD, MASK); output COUNT, RESET, CLK, DOREAD; output [2:0] FUNC; output [7:0] A, B, RESULT; output [15:0] MASK; ALU_FULL U0 (.RESET (RESET), .FUNC_2_ (FUNC [2]), .FUNC_1_ (FUNC <ref> [1] </ref>), .FUNC_0_ (FUNC [0]), .A_7_ (A [7]), .A_6_ (A [6]), .A_5_ (A [5]), .A_4_ (A [4]), .A_3_ (A [3]), .A_2_ (A [2]), .A_1_ (A [1]), .B_4_ (B [4]), .B_3_ (B [3]), .B_2_ (B [2]), .B_1_ (B [1]), .B_0_ (B [0]), .COUNT (COUNT), .MASK_15_ (MASK [15]), .MASK_14_ (MASK [14]), .MASK_13_ (MASK [13]), <p> MASK); output COUNT, RESET, CLK, DOREAD; output [2:0] FUNC; output [7:0] A, B, RESULT; output [15:0] MASK; ALU_FULL U0 (.RESET (RESET), .FUNC_2_ (FUNC [2]), .FUNC_1_ (FUNC <ref> [1] </ref>), .FUNC_0_ (FUNC [0]), .A_7_ (A [7]), .A_6_ (A [6]), .A_5_ (A [5]), .A_4_ (A [4]), .A_3_ (A [3]), .A_2_ (A [2]), .A_1_ (A [1]), .B_4_ (B [4]), .B_3_ (B [3]), .B_2_ (B [2]), .B_1_ (B [1]), .B_0_ (B [0]), .COUNT (COUNT), .MASK_15_ (MASK [15]), .MASK_14_ (MASK [14]), .MASK_13_ (MASK [13]), .MASK_12_ (MASK [12]), .MASK_11_ (MASK [11]), .MASK_10_ (MASK [10]), .MASK_9_ (MASK [9]), .MASK_8_ (MASK [8]), .MASK_7_ (MASK [7]), .MASK_6_ (MASK [6]), .MASK_5_ (MASK [5]), <p> B, RESULT; output [15:0] MASK; ALU_FULL U0 (.RESET (RESET), .FUNC_2_ (FUNC [2]), .FUNC_1_ (FUNC <ref> [1] </ref>), .FUNC_0_ (FUNC [0]), .A_7_ (A [7]), .A_6_ (A [6]), .A_5_ (A [5]), .A_4_ (A [4]), .A_3_ (A [3]), .A_2_ (A [2]), .A_1_ (A [1]), .B_4_ (B [4]), .B_3_ (B [3]), .B_2_ (B [2]), .B_1_ (B [1]), .B_0_ (B [0]), .COUNT (COUNT), .MASK_15_ (MASK [15]), .MASK_14_ (MASK [14]), .MASK_13_ (MASK [13]), .MASK_12_ (MASK [12]), .MASK_11_ (MASK [11]), .MASK_10_ (MASK [10]), .MASK_9_ (MASK [9]), .MASK_8_ (MASK [8]), .MASK_7_ (MASK [7]), .MASK_6_ (MASK [6]), .MASK_5_ (MASK [5]), .MASK_4_ (MASK [4]), .MASK_3_ (MASK [3]), .MASK_2_ (MASK [2]), .MASK_1_ (MASK [1]), <p> <ref> [1] </ref>), .B_0_ (B [0]), .COUNT (COUNT), .MASK_15_ (MASK [15]), .MASK_14_ (MASK [14]), .MASK_13_ (MASK [13]), .MASK_12_ (MASK [12]), .MASK_11_ (MASK [11]), .MASK_10_ (MASK [10]), .MASK_9_ (MASK [9]), .MASK_8_ (MASK [8]), .MASK_7_ (MASK [7]), .MASK_6_ (MASK [6]), .MASK_5_ (MASK [5]), .MASK_4_ (MASK [4]), .MASK_3_ (MASK [3]), .MASK_2_ (MASK [2]), .MASK_1_ (MASK [1]), .MASK_0_ (MASK [0]), .CLK (CLK), .RESULT_7_ (RESULT [7]), .RESULT_6_ (RESULT [6]), .RESULT_5_ (RESULT [5]), .RESULT_4_ (RESULT [4]), .RESULT_3_ (RESULT [3]), .RESULT_2_ (RESULT [2]), .RESULT_1_ (RESULT [1]), .RESULT_0_ (RESULT [0]), .DOREAD (DOREAD) ); HOST_EM U1 ( .COUNT (COUNT), .RESET (RESET), .FUNC (FUNC), .A (A), .B (B), .RESULT (RESULT), .CLK (CLK), .MASK <p> [9]), .MASK_8_ (MASK [8]), .MASK_7_ (MASK [7]), .MASK_6_ (MASK [6]), .MASK_5_ (MASK [5]), .MASK_4_ (MASK [4]), .MASK_3_ (MASK [3]), .MASK_2_ (MASK [2]), .MASK_1_ (MASK <ref> [1] </ref>), .MASK_0_ (MASK [0]), .CLK (CLK), .RESULT_7_ (RESULT [7]), .RESULT_6_ (RESULT [6]), .RESULT_5_ (RESULT [5]), .RESULT_4_ (RESULT [4]), .RESULT_3_ (RESULT [3]), .RESULT_2_ (RESULT [2]), .RESULT_1_ (RESULT [1]), .RESULT_0_ (RESULT [0]), .DOREAD (DOREAD) ); HOST_EM U1 ( .COUNT (COUNT), .RESET (RESET), .FUNC (FUNC), .A (A), .B (B), .RESULT (RESULT), .CLK (CLK), .MASK (MASK)); endmodule top level design 46CHAPTER 5.
Reference: [2] <author> Cadence Design Systems, Inc. </author> <title> Programming Language Interface Reference Manual, </title> <year> 1992. </year>
Reference-contexts: To support serial communication with the board, it was necessary to let the Verilog simulation send data to a C program, which would then send the data over to the board. This can be accomplished by using the Programming Language Interface <ref> [2] </ref> provided by Cadence in order to call specific C procedures from Verilog. To use these C routines, one must compile a new Verilog executable which includes the desired procedures. <p> USING THE INNERVIEW HARDWARE DEBUGGER 45 module PTEST_EM ( COUNT, RESET, FUNC, A, B, CLK, RESULT, DOREAD, MASK); output COUNT, RESET, CLK, DOREAD; output [2:0] FUNC; output [7:0] A, B, RESULT; output [15:0] MASK; ALU_FULL U0 (.RESET (RESET), .FUNC_2_ (FUNC <ref> [2] </ref>), .FUNC_1_ (FUNC [1]), .FUNC_0_ (FUNC [0]), .A_7_ (A [7]), .A_6_ (A [6]), .A_5_ (A [5]), .A_4_ (A [4]), .A_3_ (A [3]), .A_2_ (A [2]), .A_1_ (A [1]), .B_4_ (B [4]), .B_3_ (B [3]), .B_2_ (B [2]), .B_1_ (B [1]), .B_0_ (B [0]), .COUNT (COUNT), .MASK_15_ (MASK [15]), .MASK_14_ (MASK [14]), <p> CLK, RESULT, DOREAD, MASK); output COUNT, RESET, CLK, DOREAD; output [2:0] FUNC; output [7:0] A, B, RESULT; output [15:0] MASK; ALU_FULL U0 (.RESET (RESET), .FUNC_2_ (FUNC <ref> [2] </ref>), .FUNC_1_ (FUNC [1]), .FUNC_0_ (FUNC [0]), .A_7_ (A [7]), .A_6_ (A [6]), .A_5_ (A [5]), .A_4_ (A [4]), .A_3_ (A [3]), .A_2_ (A [2]), .A_1_ (A [1]), .B_4_ (B [4]), .B_3_ (B [3]), .B_2_ (B [2]), .B_1_ (B [1]), .B_0_ (B [0]), .COUNT (COUNT), .MASK_15_ (MASK [15]), .MASK_14_ (MASK [14]), .MASK_13_ (MASK [13]), .MASK_12_ (MASK [12]), .MASK_11_ (MASK [11]), .MASK_10_ (MASK [10]), .MASK_9_ (MASK [9]), .MASK_8_ (MASK [8]), .MASK_7_ (MASK [7]), .MASK_6_ (MASK [6]), <p> output [7:0] A, B, RESULT; output [15:0] MASK; ALU_FULL U0 (.RESET (RESET), .FUNC_2_ (FUNC <ref> [2] </ref>), .FUNC_1_ (FUNC [1]), .FUNC_0_ (FUNC [0]), .A_7_ (A [7]), .A_6_ (A [6]), .A_5_ (A [5]), .A_4_ (A [4]), .A_3_ (A [3]), .A_2_ (A [2]), .A_1_ (A [1]), .B_4_ (B [4]), .B_3_ (B [3]), .B_2_ (B [2]), .B_1_ (B [1]), .B_0_ (B [0]), .COUNT (COUNT), .MASK_15_ (MASK [15]), .MASK_14_ (MASK [14]), .MASK_13_ (MASK [13]), .MASK_12_ (MASK [12]), .MASK_11_ (MASK [11]), .MASK_10_ (MASK [10]), .MASK_9_ (MASK [9]), .MASK_8_ (MASK [8]), .MASK_7_ (MASK [7]), .MASK_6_ (MASK [6]), .MASK_5_ (MASK [5]), .MASK_4_ (MASK [4]), .MASK_3_ (MASK [3]), .MASK_2_ (MASK [2]), <p> <ref> [2] </ref>), .B_1_ (B [1]), .B_0_ (B [0]), .COUNT (COUNT), .MASK_15_ (MASK [15]), .MASK_14_ (MASK [14]), .MASK_13_ (MASK [13]), .MASK_12_ (MASK [12]), .MASK_11_ (MASK [11]), .MASK_10_ (MASK [10]), .MASK_9_ (MASK [9]), .MASK_8_ (MASK [8]), .MASK_7_ (MASK [7]), .MASK_6_ (MASK [6]), .MASK_5_ (MASK [5]), .MASK_4_ (MASK [4]), .MASK_3_ (MASK [3]), .MASK_2_ (MASK [2]), .MASK_1_ (MASK [1]), .MASK_0_ (MASK [0]), .CLK (CLK), .RESULT_7_ (RESULT [7]), .RESULT_6_ (RESULT [6]), .RESULT_5_ (RESULT [5]), .RESULT_4_ (RESULT [4]), .RESULT_3_ (RESULT [3]), .RESULT_2_ (RESULT [2]), .RESULT_1_ (RESULT [1]), .RESULT_0_ (RESULT [0]), .DOREAD (DOREAD) ); HOST_EM U1 ( .COUNT (COUNT), .RESET (RESET), .FUNC (FUNC), .A (A), .B (B), .RESULT (RESULT), <p> [10]), .MASK_9_ (MASK [9]), .MASK_8_ (MASK [8]), .MASK_7_ (MASK [7]), .MASK_6_ (MASK [6]), .MASK_5_ (MASK [5]), .MASK_4_ (MASK [4]), .MASK_3_ (MASK [3]), .MASK_2_ (MASK <ref> [2] </ref>), .MASK_1_ (MASK [1]), .MASK_0_ (MASK [0]), .CLK (CLK), .RESULT_7_ (RESULT [7]), .RESULT_6_ (RESULT [6]), .RESULT_5_ (RESULT [5]), .RESULT_4_ (RESULT [4]), .RESULT_3_ (RESULT [3]), .RESULT_2_ (RESULT [2]), .RESULT_1_ (RESULT [1]), .RESULT_0_ (RESULT [0]), .DOREAD (DOREAD) ); HOST_EM U1 ( .COUNT (COUNT), .RESET (RESET), .FUNC (FUNC), .A (A), .B (B), .RESULT (RESULT), .CLK (CLK), .MASK (MASK)); endmodule top level design 46CHAPTER 5.
Reference: [3] <author> M. Dahl, J. Babb, R. Tessier, S. Hanono, D. Hoki, and A. Agarwal. </author> <title> Emulation of the Sparcle Microprocessor with the MIT Virtual Wires Emulation System. </title> <booktitle> In IEEE Workshop on FPGAs for Custom Computing Machines, </booktitle> <address> Napa, CA, </address> <month> April </month> <year> 1994. </year>
Reference-contexts: Just type make after ensuring that you have ample space in your directory to write all the resulting bit files. Building the emulator consumes between 10-50 Mbytes of disk space depending on the size of the particular design. For further information about the Virtual Wires compiler, see <ref> [3] </ref> [4]. 5.2 Using the InnerView Hardware Debugger Once your design has been compiled, you need to write a control file which is used by the simulator interface and debugger. This file tells the system which .exo file to load into the FPGAs. <p> FUNC, A, B, CLK, RESULT, DOREAD, MASK); output COUNT, RESET, CLK, DOREAD; output [2:0] FUNC; output [7:0] A, B, RESULT; output [15:0] MASK; ALU_FULL U0 (.RESET (RESET), .FUNC_2_ (FUNC [2]), .FUNC_1_ (FUNC [1]), .FUNC_0_ (FUNC [0]), .A_7_ (A [7]), .A_6_ (A [6]), .A_5_ (A [5]), .A_4_ (A [4]), .A_3_ (A <ref> [3] </ref>), .A_2_ (A [2]), .A_1_ (A [1]), .B_4_ (B [4]), .B_3_ (B [3]), .B_2_ (B [2]), .B_1_ (B [1]), .B_0_ (B [0]), .COUNT (COUNT), .MASK_15_ (MASK [15]), .MASK_14_ (MASK [14]), .MASK_13_ (MASK [13]), .MASK_12_ (MASK [12]), .MASK_11_ (MASK [11]), .MASK_10_ (MASK [10]), .MASK_9_ (MASK [9]), .MASK_8_ (MASK [8]), .MASK_7_ (MASK [7]), <p> output [2:0] FUNC; output [7:0] A, B, RESULT; output [15:0] MASK; ALU_FULL U0 (.RESET (RESET), .FUNC_2_ (FUNC [2]), .FUNC_1_ (FUNC [1]), .FUNC_0_ (FUNC [0]), .A_7_ (A [7]), .A_6_ (A [6]), .A_5_ (A [5]), .A_4_ (A [4]), .A_3_ (A <ref> [3] </ref>), .A_2_ (A [2]), .A_1_ (A [1]), .B_4_ (B [4]), .B_3_ (B [3]), .B_2_ (B [2]), .B_1_ (B [1]), .B_0_ (B [0]), .COUNT (COUNT), .MASK_15_ (MASK [15]), .MASK_14_ (MASK [14]), .MASK_13_ (MASK [13]), .MASK_12_ (MASK [12]), .MASK_11_ (MASK [11]), .MASK_10_ (MASK [10]), .MASK_9_ (MASK [9]), .MASK_8_ (MASK [8]), .MASK_7_ (MASK [7]), .MASK_6_ (MASK [6]), .MASK_5_ (MASK [5]), .MASK_4_ (MASK [4]), .MASK_3_ (MASK [3]), <p> <ref> [3] </ref>), .B_2_ (B [2]), .B_1_ (B [1]), .B_0_ (B [0]), .COUNT (COUNT), .MASK_15_ (MASK [15]), .MASK_14_ (MASK [14]), .MASK_13_ (MASK [13]), .MASK_12_ (MASK [12]), .MASK_11_ (MASK [11]), .MASK_10_ (MASK [10]), .MASK_9_ (MASK [9]), .MASK_8_ (MASK [8]), .MASK_7_ (MASK [7]), .MASK_6_ (MASK [6]), .MASK_5_ (MASK [5]), .MASK_4_ (MASK [4]), .MASK_3_ (MASK [3]), .MASK_2_ (MASK [2]), .MASK_1_ (MASK [1]), .MASK_0_ (MASK [0]), .CLK (CLK), .RESULT_7_ (RESULT [7]), .RESULT_6_ (RESULT [6]), .RESULT_5_ (RESULT [5]), .RESULT_4_ (RESULT [4]), .RESULT_3_ (RESULT [3]), .RESULT_2_ (RESULT [2]), .RESULT_1_ (RESULT [1]), .RESULT_0_ (RESULT [0]), .DOREAD (DOREAD) ); HOST_EM U1 ( .COUNT (COUNT), .RESET (RESET), .FUNC (FUNC), .A (A), .B <p> [11]), .MASK_10_ (MASK [10]), .MASK_9_ (MASK [9]), .MASK_8_ (MASK [8]), .MASK_7_ (MASK [7]), .MASK_6_ (MASK [6]), .MASK_5_ (MASK [5]), .MASK_4_ (MASK [4]), .MASK_3_ (MASK <ref> [3] </ref>), .MASK_2_ (MASK [2]), .MASK_1_ (MASK [1]), .MASK_0_ (MASK [0]), .CLK (CLK), .RESULT_7_ (RESULT [7]), .RESULT_6_ (RESULT [6]), .RESULT_5_ (RESULT [5]), .RESULT_4_ (RESULT [4]), .RESULT_3_ (RESULT [3]), .RESULT_2_ (RESULT [2]), .RESULT_1_ (RESULT [1]), .RESULT_0_ (RESULT [0]), .DOREAD (DOREAD) ); HOST_EM U1 ( .COUNT (COUNT), .RESET (RESET), .FUNC (FUNC), .A (A), .B (B), .RESULT (RESULT), .CLK (CLK), .MASK (MASK)); endmodule top level design 46CHAPTER 5.
Reference: [4] <author> M. L. Dahl. </author> <title> An Implementation of the Virtual Wires Interconnect Scheme. </title> <type> Master's thesis, </type> <institution> Massachusetts Institute of Technology, </institution> <month> February </month> <year> 1994. </year>
Reference-contexts: Logic emulation normally uses multiple FPGAs because the FPGAs have a relatively low density of less than 20,000 logic gates per chip versus non-programmable gate arrays with over 100,000 gates per chip <ref> [4] </ref>. Existing FPGA-based logic emulators suffer from limited inter-chip communication bandwidth, resulting in low gate utilization. These emulators use only a fraction of their potential communication bandwidth because they dedicate each FPGA pin (physical wire) to a single emu 13 14 CHAPTER 1. INTRODUCTION lated signal (logical wire). <p> Just type make after ensuring that you have ample space in your directory to write all the resulting bit files. Building the emulator consumes between 10-50 Mbytes of disk space depending on the size of the particular design. For further information about the Virtual Wires compiler, see [3] <ref> [4] </ref>. 5.2 Using the InnerView Hardware Debugger Once your design has been compiled, you need to write a control file which is used by the simulator interface and debugger. This file tells the system which .exo file to load into the FPGAs. <p> ( COUNT, RESET, FUNC, A, B, CLK, RESULT, DOREAD, MASK); output COUNT, RESET, CLK, DOREAD; output [2:0] FUNC; output [7:0] A, B, RESULT; output [15:0] MASK; ALU_FULL U0 (.RESET (RESET), .FUNC_2_ (FUNC [2]), .FUNC_1_ (FUNC [1]), .FUNC_0_ (FUNC [0]), .A_7_ (A [7]), .A_6_ (A [6]), .A_5_ (A [5]), .A_4_ (A <ref> [4] </ref>), .A_3_ (A [3]), .A_2_ (A [2]), .A_1_ (A [1]), .B_4_ (B [4]), .B_3_ (B [3]), .B_2_ (B [2]), .B_1_ (B [1]), .B_0_ (B [0]), .COUNT (COUNT), .MASK_15_ (MASK [15]), .MASK_14_ (MASK [14]), .MASK_13_ (MASK [13]), .MASK_12_ (MASK [12]), .MASK_11_ (MASK [11]), .MASK_10_ (MASK [10]), .MASK_9_ (MASK [9]), .MASK_8_ (MASK [8]), <p> RESET, CLK, DOREAD; output [2:0] FUNC; output [7:0] A, B, RESULT; output [15:0] MASK; ALU_FULL U0 (.RESET (RESET), .FUNC_2_ (FUNC [2]), .FUNC_1_ (FUNC [1]), .FUNC_0_ (FUNC [0]), .A_7_ (A [7]), .A_6_ (A [6]), .A_5_ (A [5]), .A_4_ (A <ref> [4] </ref>), .A_3_ (A [3]), .A_2_ (A [2]), .A_1_ (A [1]), .B_4_ (B [4]), .B_3_ (B [3]), .B_2_ (B [2]), .B_1_ (B [1]), .B_0_ (B [0]), .COUNT (COUNT), .MASK_15_ (MASK [15]), .MASK_14_ (MASK [14]), .MASK_13_ (MASK [13]), .MASK_12_ (MASK [12]), .MASK_11_ (MASK [11]), .MASK_10_ (MASK [10]), .MASK_9_ (MASK [9]), .MASK_8_ (MASK [8]), .MASK_7_ (MASK [7]), .MASK_6_ (MASK [6]), .MASK_5_ (MASK [5]), .MASK_4_ (MASK [4]), <p> <ref> [4] </ref>), .B_3_ (B [3]), .B_2_ (B [2]), .B_1_ (B [1]), .B_0_ (B [0]), .COUNT (COUNT), .MASK_15_ (MASK [15]), .MASK_14_ (MASK [14]), .MASK_13_ (MASK [13]), .MASK_12_ (MASK [12]), .MASK_11_ (MASK [11]), .MASK_10_ (MASK [10]), .MASK_9_ (MASK [9]), .MASK_8_ (MASK [8]), .MASK_7_ (MASK [7]), .MASK_6_ (MASK [6]), .MASK_5_ (MASK [5]), .MASK_4_ (MASK [4]), .MASK_3_ (MASK [3]), .MASK_2_ (MASK [2]), .MASK_1_ (MASK [1]), .MASK_0_ (MASK [0]), .CLK (CLK), .RESULT_7_ (RESULT [7]), .RESULT_6_ (RESULT [6]), .RESULT_5_ (RESULT [5]), .RESULT_4_ (RESULT [4]), .RESULT_3_ (RESULT [3]), .RESULT_2_ (RESULT [2]), .RESULT_1_ (RESULT [1]), .RESULT_0_ (RESULT [0]), .DOREAD (DOREAD) ); HOST_EM U1 ( .COUNT (COUNT), .RESET (RESET), .FUNC (FUNC), <p> [12]), .MASK_11_ (MASK [11]), .MASK_10_ (MASK [10]), .MASK_9_ (MASK [9]), .MASK_8_ (MASK [8]), .MASK_7_ (MASK [7]), .MASK_6_ (MASK [6]), .MASK_5_ (MASK [5]), .MASK_4_ (MASK <ref> [4] </ref>), .MASK_3_ (MASK [3]), .MASK_2_ (MASK [2]), .MASK_1_ (MASK [1]), .MASK_0_ (MASK [0]), .CLK (CLK), .RESULT_7_ (RESULT [7]), .RESULT_6_ (RESULT [6]), .RESULT_5_ (RESULT [5]), .RESULT_4_ (RESULT [4]), .RESULT_3_ (RESULT [3]), .RESULT_2_ (RESULT [2]), .RESULT_1_ (RESULT [1]), .RESULT_0_ (RESULT [0]), .DOREAD (DOREAD) ); HOST_EM U1 ( .COUNT (COUNT), .RESET (RESET), .FUNC (FUNC), .A (A), .B (B), .RESULT (RESULT), .CLK (CLK), .MASK (MASK)); endmodule top level design 46CHAPTER 5.
Reference: [5] <author> P. Hansen. </author> <title> Design for Testability: Its Impact on Testing at the Board Level. </title> <publisher> Teradyne, Inc., </publisher> <address> Boston, MA. </address>
Reference-contexts: There is now much more information available so that the user may determine where an error has occurred. 1.2 Background InnerView's basic operation is analogous to other scan based test techniques that are used for debugging designs. A boundary scan is the conventional method used to test a design <ref> [5] </ref>. It simplifies the diagnosis of pin-level and interconnect faults on a board. 16 CHAPTER 1. INTRODUCTION Here a shift path is formed around the periphery of the chip on each I/O pin. <p> A possible solution to this problem is to use the boundary scan in conjunction with an internal scan which is very useful for testing static, sequential logic circuits. The internal scan <ref> [5] </ref> deals with the issue of testing sequential circuits. The problem with sequential logic is that it generally requires huge test patterns in order to get adequate fault coverage. <p> 45 module PTEST_EM ( COUNT, RESET, FUNC, A, B, CLK, RESULT, DOREAD, MASK); output COUNT, RESET, CLK, DOREAD; output [2:0] FUNC; output [7:0] A, B, RESULT; output [15:0] MASK; ALU_FULL U0 (.RESET (RESET), .FUNC_2_ (FUNC [2]), .FUNC_1_ (FUNC [1]), .FUNC_0_ (FUNC [0]), .A_7_ (A [7]), .A_6_ (A [6]), .A_5_ (A <ref> [5] </ref>), .A_4_ (A [4]), .A_3_ (A [3]), .A_2_ (A [2]), .A_1_ (A [1]), .B_4_ (B [4]), .B_3_ (B [3]), .B_2_ (B [2]), .B_1_ (B [1]), .B_0_ (B [0]), .COUNT (COUNT), .MASK_15_ (MASK [15]), .MASK_14_ (MASK [14]), .MASK_13_ (MASK [13]), .MASK_12_ (MASK [12]), .MASK_11_ (MASK [11]), .MASK_10_ (MASK [10]), .MASK_9_ (MASK [9]), <p> [1]), .B_4_ (B [4]), .B_3_ (B [3]), .B_2_ (B [2]), .B_1_ (B [1]), .B_0_ (B [0]), .COUNT (COUNT), .MASK_15_ (MASK [15]), .MASK_14_ (MASK [14]), .MASK_13_ (MASK [13]), .MASK_12_ (MASK [12]), .MASK_11_ (MASK [11]), .MASK_10_ (MASK [10]), .MASK_9_ (MASK [9]), .MASK_8_ (MASK [8]), .MASK_7_ (MASK [7]), .MASK_6_ (MASK [6]), .MASK_5_ (MASK <ref> [5] </ref>), .MASK_4_ (MASK [4]), .MASK_3_ (MASK [3]), .MASK_2_ (MASK [2]), .MASK_1_ (MASK [1]), .MASK_0_ (MASK [0]), .CLK (CLK), .RESULT_7_ (RESULT [7]), .RESULT_6_ (RESULT [6]), .RESULT_5_ (RESULT [5]), .RESULT_4_ (RESULT [4]), .RESULT_3_ (RESULT [3]), .RESULT_2_ (RESULT [2]), .RESULT_1_ (RESULT [1]), .RESULT_0_ (RESULT [0]), .DOREAD (DOREAD) ); HOST_EM U1 ( .COUNT (COUNT), .RESET <p> [13]), .MASK_12_ (MASK [12]), .MASK_11_ (MASK [11]), .MASK_10_ (MASK [10]), .MASK_9_ (MASK [9]), .MASK_8_ (MASK [8]), .MASK_7_ (MASK [7]), .MASK_6_ (MASK [6]), .MASK_5_ (MASK <ref> [5] </ref>), .MASK_4_ (MASK [4]), .MASK_3_ (MASK [3]), .MASK_2_ (MASK [2]), .MASK_1_ (MASK [1]), .MASK_0_ (MASK [0]), .CLK (CLK), .RESULT_7_ (RESULT [7]), .RESULT_6_ (RESULT [6]), .RESULT_5_ (RESULT [5]), .RESULT_4_ (RESULT [4]), .RESULT_3_ (RESULT [3]), .RESULT_2_ (RESULT [2]), .RESULT_1_ (RESULT [1]), .RESULT_0_ (RESULT [0]), .DOREAD (DOREAD) ); HOST_EM U1 ( .COUNT (COUNT), .RESET (RESET), .FUNC (FUNC), .A (A), .B (B), .RESULT (RESULT), .CLK (CLK), .MASK (MASK)); endmodule top level design 46CHAPTER 5.
Reference: [6] <author> J. K. Ousterhout. </author> <title> Tcl and the Tk Toolkit, </title> <year> 1994. </year>
Reference-contexts: Given this information, one can then run getdata on a single chip. Again, the details about the format of this instruction are provided in section 5.2.2. 4.3 X-Windows Interface In order to make InnerView more user friendly, we have developed a Tcl x-windows interface <ref> [6] </ref> for both the simulation interface and the getdata and getcell software. The simulator interface is run by typing vw run. This will pop up a window as shown in Figure 4-1. It first initializes all of its fields based on the user's control file. <p> INNERVIEW HARDWARE DEBUGGER 45 module PTEST_EM ( COUNT, RESET, FUNC, A, B, CLK, RESULT, DOREAD, MASK); output COUNT, RESET, CLK, DOREAD; output [2:0] FUNC; output [7:0] A, B, RESULT; output [15:0] MASK; ALU_FULL U0 (.RESET (RESET), .FUNC_2_ (FUNC [2]), .FUNC_1_ (FUNC [1]), .FUNC_0_ (FUNC [0]), .A_7_ (A [7]), .A_6_ (A <ref> [6] </ref>), .A_5_ (A [5]), .A_4_ (A [4]), .A_3_ (A [3]), .A_2_ (A [2]), .A_1_ (A [1]), .B_4_ (B [4]), .B_3_ (B [3]), .B_2_ (B [2]), .B_1_ (B [1]), .B_0_ (B [0]), .COUNT (COUNT), .MASK_15_ (MASK [15]), .MASK_14_ (MASK [14]), .MASK_13_ (MASK [13]), .MASK_12_ (MASK [12]), .MASK_11_ (MASK [11]), .MASK_10_ (MASK [10]), <p> [2]), .A_1_ (A [1]), .B_4_ (B [4]), .B_3_ (B [3]), .B_2_ (B [2]), .B_1_ (B [1]), .B_0_ (B [0]), .COUNT (COUNT), .MASK_15_ (MASK [15]), .MASK_14_ (MASK [14]), .MASK_13_ (MASK [13]), .MASK_12_ (MASK [12]), .MASK_11_ (MASK [11]), .MASK_10_ (MASK [10]), .MASK_9_ (MASK [9]), .MASK_8_ (MASK [8]), .MASK_7_ (MASK [7]), .MASK_6_ (MASK <ref> [6] </ref>), .MASK_5_ (MASK [5]), .MASK_4_ (MASK [4]), .MASK_3_ (MASK [3]), .MASK_2_ (MASK [2]), .MASK_1_ (MASK [1]), .MASK_0_ (MASK [0]), .CLK (CLK), .RESULT_7_ (RESULT [7]), .RESULT_6_ (RESULT [6]), .RESULT_5_ (RESULT [5]), .RESULT_4_ (RESULT [4]), .RESULT_3_ (RESULT [3]), .RESULT_2_ (RESULT [2]), .RESULT_1_ (RESULT [1]), .RESULT_0_ (RESULT [0]), .DOREAD (DOREAD) ); HOST_EM U1 ( <p> [14]), .MASK_13_ (MASK [13]), .MASK_12_ (MASK [12]), .MASK_11_ (MASK [11]), .MASK_10_ (MASK [10]), .MASK_9_ (MASK [9]), .MASK_8_ (MASK [8]), .MASK_7_ (MASK [7]), .MASK_6_ (MASK <ref> [6] </ref>), .MASK_5_ (MASK [5]), .MASK_4_ (MASK [4]), .MASK_3_ (MASK [3]), .MASK_2_ (MASK [2]), .MASK_1_ (MASK [1]), .MASK_0_ (MASK [0]), .CLK (CLK), .RESULT_7_ (RESULT [7]), .RESULT_6_ (RESULT [6]), .RESULT_5_ (RESULT [5]), .RESULT_4_ (RESULT [4]), .RESULT_3_ (RESULT [3]), .RESULT_2_ (RESULT [2]), .RESULT_1_ (RESULT [1]), .RESULT_0_ (RESULT [0]), .DOREAD (DOREAD) ); HOST_EM U1 ( .COUNT (COUNT), .RESET (RESET), .FUNC (FUNC), .A (A), .B (B), .RESULT (RESULT), .CLK (CLK), .MASK (MASK)); endmodule top level design 46CHAPTER 5.
Reference: [7] <author> R. Tessier, J. Babb, M. Dahl, S. Hanono, and A. Agarwal. </author> <title> The Virtual Wires Emulation System: A Gate-Efficient ASIC Prototyping Environment. </title> <booktitle> In 1994 ACM International Workshop on Field-Programmable Gate Arrays, </booktitle> <address> Berkeley, CA, </address> <month> February </month> <year> 1994. </year>
Reference-contexts: Chapter 3 Providing Hardware Debugging Capabilities 3.1 Logic Analysis Highlights The Virtual Wires emulation board consists of a two dimensional array of Xilinx 4005 FPGAs <ref> [7] </ref>. These FPGAs have the capability of performing a readback [9]. That is, they allow one to read back the internal state of the RAM, combinational logic blocks, and Input/Output blocks. <p> USING THE INNERVIEW HARDWARE DEBUGGER 45 module PTEST_EM ( COUNT, RESET, FUNC, A, B, CLK, RESULT, DOREAD, MASK); output COUNT, RESET, CLK, DOREAD; output [2:0] FUNC; output [7:0] A, B, RESULT; output [15:0] MASK; ALU_FULL U0 (.RESET (RESET), .FUNC_2_ (FUNC [2]), .FUNC_1_ (FUNC [1]), .FUNC_0_ (FUNC [0]), .A_7_ (A <ref> [7] </ref>), .A_6_ (A [6]), .A_5_ (A [5]), .A_4_ (A [4]), .A_3_ (A [3]), .A_2_ (A [2]), .A_1_ (A [1]), .B_4_ (B [4]), .B_3_ (B [3]), .B_2_ (B [2]), .B_1_ (B [1]), .B_0_ (B [0]), .COUNT (COUNT), .MASK_15_ (MASK [15]), .MASK_14_ (MASK [14]), .MASK_13_ (MASK [13]), .MASK_12_ (MASK [12]), .MASK_11_ (MASK [11]), <p> [3]), .A_2_ (A [2]), .A_1_ (A [1]), .B_4_ (B [4]), .B_3_ (B [3]), .B_2_ (B [2]), .B_1_ (B [1]), .B_0_ (B [0]), .COUNT (COUNT), .MASK_15_ (MASK [15]), .MASK_14_ (MASK [14]), .MASK_13_ (MASK [13]), .MASK_12_ (MASK [12]), .MASK_11_ (MASK [11]), .MASK_10_ (MASK [10]), .MASK_9_ (MASK [9]), .MASK_8_ (MASK [8]), .MASK_7_ (MASK <ref> [7] </ref>), .MASK_6_ (MASK [6]), .MASK_5_ (MASK [5]), .MASK_4_ (MASK [4]), .MASK_3_ (MASK [3]), .MASK_2_ (MASK [2]), .MASK_1_ (MASK [1]), .MASK_0_ (MASK [0]), .CLK (CLK), .RESULT_7_ (RESULT [7]), .RESULT_6_ (RESULT [6]), .RESULT_5_ (RESULT [5]), .RESULT_4_ (RESULT [4]), .RESULT_3_ (RESULT [3]), .RESULT_2_ (RESULT [2]), .RESULT_1_ (RESULT [1]), .RESULT_0_ (RESULT [0]), .DOREAD (DOREAD) ); <p> [15]), .MASK_14_ (MASK [14]), .MASK_13_ (MASK [13]), .MASK_12_ (MASK [12]), .MASK_11_ (MASK [11]), .MASK_10_ (MASK [10]), .MASK_9_ (MASK [9]), .MASK_8_ (MASK [8]), .MASK_7_ (MASK <ref> [7] </ref>), .MASK_6_ (MASK [6]), .MASK_5_ (MASK [5]), .MASK_4_ (MASK [4]), .MASK_3_ (MASK [3]), .MASK_2_ (MASK [2]), .MASK_1_ (MASK [1]), .MASK_0_ (MASK [0]), .CLK (CLK), .RESULT_7_ (RESULT [7]), .RESULT_6_ (RESULT [6]), .RESULT_5_ (RESULT [5]), .RESULT_4_ (RESULT [4]), .RESULT_3_ (RESULT [3]), .RESULT_2_ (RESULT [2]), .RESULT_1_ (RESULT [1]), .RESULT_0_ (RESULT [0]), .DOREAD (DOREAD) ); HOST_EM U1 ( .COUNT (COUNT), .RESET (RESET), .FUNC (FUNC), .A (A), .B (B), .RESULT (RESULT), .CLK (CLK), .MASK (MASK)); endmodule top level design 46CHAPTER 5.
Reference: [8] <author> N. H. E. Weste and K. Eshraghian. </author> <title> Principles of CMOS VLSI Design, </title> <booktitle> A Systems Perspective, </booktitle> <pages> pages 489-491. </pages> <publisher> Addison-Wesley Publishing Company, </publisher> <address> second edition, </address> <year> 1993. </year>
Reference-contexts: In addition, the remaining interesting nodes may be examined by loading them in parallel into the shift register and then shifting those bits out serially for viewing by the tester. An example of an internal scan approach is the Level Sensitive Scan Design (LSSD) introduced by IBM <ref> [8] </ref>. It is based on two points. First of all, the circuit is assumed to be level sensitive. That is, the steady state response to any input change should be independent of the circuit and wire delays within the system. <p> [4]), .A_3_ (A [3]), .A_2_ (A [2]), .A_1_ (A [1]), .B_4_ (B [4]), .B_3_ (B [3]), .B_2_ (B [2]), .B_1_ (B [1]), .B_0_ (B [0]), .COUNT (COUNT), .MASK_15_ (MASK [15]), .MASK_14_ (MASK [14]), .MASK_13_ (MASK [13]), .MASK_12_ (MASK [12]), .MASK_11_ (MASK [11]), .MASK_10_ (MASK [10]), .MASK_9_ (MASK [9]), .MASK_8_ (MASK <ref> [8] </ref>), .MASK_7_ (MASK [7]), .MASK_6_ (MASK [6]), .MASK_5_ (MASK [5]), .MASK_4_ (MASK [4]), .MASK_3_ (MASK [3]), .MASK_2_ (MASK [2]), .MASK_1_ (MASK [1]), .MASK_0_ (MASK [0]), .CLK (CLK), .RESULT_7_ (RESULT [7]), .RESULT_6_ (RESULT [6]), .RESULT_5_ (RESULT [5]), .RESULT_4_ (RESULT [4]), .RESULT_3_ (RESULT [3]), .RESULT_2_ (RESULT [2]), .RESULT_1_ (RESULT [1]), .RESULT_0_ (RESULT [0]),
Reference: [9] <institution> The Programmable Logic Data Book, 1993. Xilinx Inc., </institution> <address> San Jose, CA. </address> <month> 59 </month>
Reference-contexts: These FPGAs do not provide the capability to write to the registers, rather only to read them. The Xilinx FPGAs have dedicated hardware for doing readback. Upon the receipt of a readback trigger, all the nodes which may be examined are loaded into special holding registers <ref> [9] </ref>. These registers are then connected as a serial shift register and sent out through a special data port. The advantage of using these dedicated holding registers is that the system could be allowed to continue running while a readback function is performed. <p> Chapter 3 Providing Hardware Debugging Capabilities 3.1 Logic Analysis Highlights The Virtual Wires emulation board consists of a two dimensional array of Xilinx 4005 FPGAs [7]. These FPGAs have the capability of performing a readback <ref> [9] </ref>. That is, they allow one to read back the internal state of the RAM, combinational logic blocks, and Input/Output blocks. The problem with most Logic Emulators is that if there is an error in the design, it is extremely difficult to analyze where the root of the problem lies. <p> [5]), .A_4_ (A [4]), .A_3_ (A [3]), .A_2_ (A [2]), .A_1_ (A [1]), .B_4_ (B [4]), .B_3_ (B [3]), .B_2_ (B [2]), .B_1_ (B [1]), .B_0_ (B [0]), .COUNT (COUNT), .MASK_15_ (MASK [15]), .MASK_14_ (MASK [14]), .MASK_13_ (MASK [13]), .MASK_12_ (MASK [12]), .MASK_11_ (MASK [11]), .MASK_10_ (MASK [10]), .MASK_9_ (MASK <ref> [9] </ref>), .MASK_8_ (MASK [8]), .MASK_7_ (MASK [7]), .MASK_6_ (MASK [6]), .MASK_5_ (MASK [5]), .MASK_4_ (MASK [4]), .MASK_3_ (MASK [3]), .MASK_2_ (MASK [2]), .MASK_1_ (MASK [1]), .MASK_0_ (MASK [0]), .CLK (CLK), .RESULT_7_ (RESULT [7]), .RESULT_6_ (RESULT [6]), .RESULT_5_ (RESULT [5]), .RESULT_4_ (RESULT [4]), .RESULT_3_ (RESULT [3]), .RESULT_2_ (RESULT [2]), .RESULT_1_ (RESULT [1]), <p> The Virtual Wires board has a dedicated FPGA which may be used to implement this Sbus interface. This can greatly reduce the latency in receiving readback data, as well as normal I/O. The fastest the readback can be clocked, as specified by the Xilinx data book <ref> [9] </ref>, is at 1MHz. Also, the exact number of bits transmitted per Xilinx 4005 FPGA is 94,976 bits of data including the frame start and stop bits. So theoretically, the readback of the entire board could be performed in 1.52 seconds.
References-found: 9

