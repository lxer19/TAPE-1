URL: ftp://ftp.cse.ucsc.edu/pub/tr/ucsc-crl-94-30.ps.Z
Refering-URL: ftp://ftp.cse.ucsc.edu/pub/tr/README.html
Root-URL: http://www.cse.ucsc.edu
Title: An Empirical Study of the Branch Coverage of Different Fault Classes classes of faults are
Author: Melissa S. Cline Linda. L. Werner 
Keyword: branch testing, code coverage, fault classification  
Note: Which  This work was partially supported by the International Business Machines Corporation grant STL93215.  
Address: Santa Cruz, CA 95064 USA  
Affiliation: Baskin Center for Computer Engineering Information Sciences University of California, Santa Cruz  
Pubnum: UCSC-CRL-94-30  
Date: September 5, 1994  
Abstract: This paper introduces the term Affected Branch Coverage. An affected branch is a branch which had to be modified in order to fix a fault. Affected Branch Coverage describes the percentage of affected branches that had been exercised in testing. The study was done on a leading on-line transaction processing product, analyzing ninety eight field errors. The specific questions addressed are: * Is affected branch coverage related to the maturity of the software? Our results show that whether or not a fault would appear in covered code depends strongly on the fault class. While this was true in both newer and older code, it was more vivid in newer code. Overall, we found that affected branch coverage was slightly less than 50%, suggesting that increasing branch coverage would offer limited gains in fault detection. 
Abstract-found: 1
Intro-found: 1
Reference: <institution> References </institution>
Reference: [Basili and Selby, 1987] <author> V. Basili and R. Selby. </author> <title> Comparing the effectiveness of software testing strategies. </title> <journal> IEEE Transactions of Software Engineering, </journal> <volume> SE-13(12):1278-1296, </volume> <month> December </month> <year> 1987. </year>
Reference-contexts: However, any form of structural testing has a limited effectiveness at fault detection. Even when testing with a criterion of 100% coverage, structural testing is not likely to reveal more than half of the faults in a body of code <ref> [Basili and Selby, 1987] </ref> [Girgis and Woodward, 1986] [Selby, 1986]. <p> A third study showed statement coverage to be more effective at detecting faults of commission than omission, and weakest at detecting cosmetic, interface, and data faults <ref> [Basili and Selby, 1987] </ref>. Therefore, we decided to examine a large, industrial software product and the testing that is performed on it.
Reference: [Girgis and Woodward, 1986] <author> M. R. Girgis and M. R. Woodward. </author> <title> An experimental comparison of the error exposing ability of program testing criteria. </title> <booktitle> In Workshop on Software Testing, </booktitle> <volume> volume 36, </volume> <pages> pages 64-73, </pages> <month> July </month> <year> 1986. </year>
Reference-contexts: However, any form of structural testing has a limited effectiveness at fault detection. Even when testing with a criterion of 100% coverage, structural testing is not likely to reveal more than half of the faults in a body of code [Basili and Selby, 1987] <ref> [Girgis and Woodward, 1986] </ref> [Selby, 1986]. Additionally, high code coverage can be a very expensive goal. 100% code coverage may not be feasible outside of unit test for a number of factors including code handling "impossible" error conditions, dead code, hooks for new functionality, and code requiring special hardware. <p> Another study showed that structural testing in general is more effective in finding domain faults than computation faults, and that branch testing in particular is not effective in detecting the wrong arithmetic operator or a statement wrongly placed in a logical expression <ref> [Girgis and Woodward, 1986] </ref>. A third study showed statement coverage to be more effective at detecting faults of commission than omission, and weakest at detecting cosmetic, interface, and data faults [Basili and Selby, 1987].
Reference: [Grady, 1993] <author> R. Grady. </author> <title> Practical results from measuring software quality. </title> <journal> Communications of the ACM, </journal> <volume> 36(11) </volume> <pages> 62-68, </pages> <month> November </month> <year> 1993. </year>
Reference-contexts: High coverage is also a goal that must be pursued deliberately | when coverage on a software product is measured for the first time, those involved with the testing are often surprised to learn how low the coverage really is <ref> [Grady, 1993] </ref> [Piwowarski et al., 1993]. When attempting to increase coverage, testing teams will sometimes become overly focused on increasing coverage and will lose sight of the underlying quality goals [Su and Ritter, 1991].
Reference: [Piwowarski et al., 1993] <author> P. Piwowarski, M. Ohba, and J. Caruso. </author> <title> Coverage measurement experience during function test. </title> <booktitle> In 15th International Conference on Software Engineering, </booktitle> <pages> pages 287-301. </pages> <publisher> IEEE, </publisher> <month> April </month> <year> 1993. </year>
Reference-contexts: While branch coverage is most often measured in unit testing, in recent years it has gained popularity as a measure of various forms of system-level testing. Prior work describes a strong, direct relationship between statement coverage and fault detection in functional test <ref> [Piwowarski et al., 1993] </ref>. It seems reasonable to expect that the relationship between branch coverage and fault detection is at least as strong. However, any form of structural testing has a limited effectiveness at fault detection. <p> High coverage is also a goal that must be pursued deliberately | when coverage on a software product is measured for the first time, those involved with the testing are often surprised to learn how low the coverage really is [Grady, 1993] <ref> [Piwowarski et al., 1993] </ref>. When attempting to increase coverage, testing teams will sometimes become overly focused on increasing coverage and will lose sight of the underlying quality goals [Su and Ritter, 1991].
Reference: [Ramsey and Basili, 1985] <author> J. Ramsey and V. Basili. </author> <title> Analyzing the test process using structural coverage. </title> <booktitle> In 8th International Conference on Software Engineering, </booktitle> <pages> pages 306-312. </pages> <publisher> IEEE, </publisher> <month> April </month> <year> 1985. </year>
Reference-contexts: A study comparing structural coverage in operational usage and functional testing found a high correlation: the sections of code that functional testers execute are likely to be the same sections of code that users execute <ref> [Ramsey and Basili, 1985] </ref>. It might be that wrong algorithm faults have a low affected branch coverage because the faults are associated with code not executed by the users, and covered code is also code executed by the users. <p> The study proposed here might not be possible on anything but a recent project. On a different note, it is very interesting that code executed under functional test is probably also executed by the users <ref> [Ramsey and Basili, 1985] </ref>. Sadly, that particular finding came from studying a small software product. It would be very useful to see if the finding holds for a very large software product such as the one studied here.
Reference: [Selby, 1986] <author> R. Selby. </author> <title> Combining software testing strategies: an empirical evaluation. </title> <journal> IEEE Workshops on Software Testing, </journal> <volume> 36(11) </volume> <pages> 82-90, </pages> <month> July </month> <year> 1986. </year>
Reference-contexts: However, any form of structural testing has a limited effectiveness at fault detection. Even when testing with a criterion of 100% coverage, structural testing is not likely to reveal more than half of the faults in a body of code [Basili and Selby, 1987] [Girgis and Woodward, 1986] <ref> [Selby, 1986] </ref>. Additionally, high code coverage can be a very expensive goal. 100% code coverage may not be feasible outside of unit test for a number of factors including code handling "impossible" error conditions, dead code, hooks for new functionality, and code requiring special hardware.
Reference: [Shimeall and Leveson, 1991] <author> T. Shimeall and N. Leveson. </author> <title> An empirical comparison of software fault tolerance and fault elimination. </title> <journal> IEEE Transactions of Software Engineering, </journal> <volume> SE-17(2):173-182, </volume> <month> February </month> <year> 1991. </year>
Reference-contexts: One prior study showed that while structural testing revealed more faults than 2-version voting, code reading, assertions, or static analysis, there were classes of faults for which it was ineffective. These classes included missing checks, parameter reversal, substitution, and calculation faults <ref> [Shimeall and Leveson, 1991] </ref>. Another study showed that structural testing in general is more effective in finding domain faults than computation faults, and that branch testing in particular is not effective in detecting the wrong arithmetic operator or a statement wrongly placed in a logical expression [Girgis and Woodward, 1986].
Reference: [Su and Ritter, 1991] <author> J. Su and P. Ritter. </author> <title> Experience in testing the motif interface. </title> <journal> IEEE Software, </journal> <volume> 8(2) </volume> <pages> 26-33, </pages> <month> March </month> <year> 1991. </year>
Reference-contexts: When attempting to increase coverage, testing teams will sometimes become overly focused on increasing coverage and will lose sight of the underlying quality goals <ref> [Su and Ritter, 1991] </ref>. So therefore, when we set out to increase branch coverage, it is important to know exactly what gains can be expected. One factor in this equation is what classes of faults are detected effectively by branch testing.
Reference: [Sullivan and Chillarege, 1992] <author> M. Sullivan and R. Chillarege. </author> <title> A comparison of software defects in database management systems and operating systems. </title> <booktitle> In 22nd International Symposium on Fault Tolerant Computing, </booktitle> <volume> volume 36, </volume> <pages> pages 475-484. </pages> <publisher> IEEE, </publisher> <month> July </month> <year> 1992. </year>
Reference-contexts: For the classes of faults, we chose to use the same taxonomy used in previous studies of database and on-line transaction processing (OLTP) systems <ref> [Sullivan and Chillarege, 1992] </ref>. This breakdown focuses on software implementation faults rather than faults earlier in the lifecycle. The fault classes used are listed in 2.3 For each of these categories, we investigate the relationship between affected branch coverage and fault incidence. <p> The descriptions in RETAIN did not include a fault classification system: rather, they favored a textual description of the fault. We chose to use the following fault classification that has been used previously in studies of systems similar to the one discussed in this paper <ref> [Sullivan and Chillarege, 1992] </ref>. Allocation Management : One module deallocates a region of memory before it has completely finished using the region. After the region is reallocated, the original module continues to use it in its original capacity.
Reference: [Wade, 1994] <author> B. Wade, </author> <year> 1994. </year> <title> Personal communications with Barbara Wade of IBM, </title> <institution> Santa Teresa Labs. </institution> <month> 15 </month>
Reference-contexts: The number of affected branches relates to the complexity of fixing the fault by indicating the number of separate sections of code that must be touched by the fix. This is used as a measure of the cost of the fix <ref> [Wade, 1994] </ref>. As shown in this table, allocation management faults are by far the most complicated to fix. The fault class with the next highest number of affected branches is also one of the more common fault classes | synchronization.
References-found: 11

