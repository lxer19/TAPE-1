URL: file://ftp.cis.ohio-state.edu/pub/tech-report/1995/TR45.ps.gz
Refering-URL: ftp://ftp.cis.ohio-state.edu/pub/tech-report/TRList.html
Root-URL: 
Title: A Low-overhead Recovery Technique Using Quasi-synchronous Checkpointing  
Author: D. Manivannan Mukesh Singhal 
Keyword: Distributed checkpointing, failure recovery, fault-tolerance.  
Address: Columbus, OH 43210  Columbus, OH 43210  
Affiliation: Distributed Systems Research Group Comp. Info. Science Dept. The Ohio State University  Distributed Systems Research Group Comp. Info. Science Dept. The Ohio State University  
Abstract: In this paper, we propose a quasi-synchronous checkpointing algorithm and a low-overhead recovery algorithm based on it. The checkpointing algorithm preserves process autonomy by allowing them to take checkpoints asynchronously and uses communication-induced checkpoint coordination for the progression of the recovery line which helps bound rollback propagation during a recovery. Thus, it has the easeness and low overhead of asynchronous checkpointing and the recovery time advantages of synchronous checkpointing. There is no extra message overhead involved during checkpointing and the additional checkpointing overhead is nominal. The algorithm ensures the existence of a recovery line consistent with the latest checkpoint of any process all the time. The recovery algorithm exploits this feature to restore the system to a state consistent with the latest checkpoint of a failed process. The recovery algorithm has no domino effect and a failed process needs only to rollback to its latest checkpoint and request the other processes to roll back to a consistent checkpoint. To avoid domino effect, it uses selective pessimistic message logging at the receiver end. The recovery is asynchronous for single process failure. Neither the recovery algorithm nor the checkpointing algorithm requires the channels to be FIFO. We do not use vector timestamps for determining dependency between checkpoints since vector timestamps generally result in high message overhead during failure-free operation. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> A. Acharya, B. R. Badrinath, and T. Imielinski. </author> <title> "Checkpointing Distributed Applications on Mobile Computing Systems". </title> <type> Technical report, </type> <institution> Department of Computer Science, Rutgers University, </institution> <year> 1994. </year>
Reference-contexts: This causes processes to suspend the normal computation for making checkpoint decisions which greatly increases the overhead during normal computation. The QSA does not cause any such overhead and avoids domino effect completely during recovery. In Acharya et al.'s <ref> [1] </ref> asynchronous checkpointing algorithm for mobile computing systems, a process takes a checkpoint whenever a message reception is preceded by a message transmission.
Reference: [2] <author> B. Bhargava and P. Leu. </author> <title> "Concurrent Robust Checkpointing and Recovery in Distributed Systems". </title> <booktitle> In Proc. of 4 th IEEE Int. Conf. Data Eng., </booktitle> <pages> pages 154-163, </pages> <month> February </month> <year> 1988. </year>
Reference-contexts: latest checkpoint of the failed process is greater than the sequence numbers of the latest checkpoints of all the other processes, then no process other than the failed process needs to roll back; they only need to take a checkpoint. 7 Comparison With Existing Work The checkpointing algorithms proposed in <ref> [9, 2] </ref> have a two-phase structure. This causes processes to suspend the normal computation for making checkpoint decisions which greatly increases the overhead during normal computation. The QSA does not cause any such overhead and avoids domino effect completely during recovery.
Reference: [3] <author> B. Bhargava and S. R. Lian. </author> <title> "Independent Checkpointing and Concurrent Rollback for Recovery in Distributed Systems-An Optimistic Approach.". </title> <booktitle> In Proc. 7 th IEEE Symp. Reliable Distributed Syst., </booktitle> <pages> pages 3-12, </pages> <year> 1988. </year>
Reference-contexts: When a failure occurs, a rollback protocol uses the checkpoints and message logs to restore the system to a consistent global state [14]. In the literature, several checkpointing schemes have been proposed for distributed systems. They can be broadly classified into two categories asynchronous and synchronous. In asynchronous checkpointing <ref> [3, 10, 20] </ref>, processes take checkpoints periodically without any coordination with others. To recover from a failure, a process communicates with other processes to determine if their local states are causally related.
Reference: [4] <author> Luis Moura e Silva and Jouao Gabriel Silva. </author> <title> "Global Checkpointing for Distributed Programs". </title> <booktitle> In Proc. Symp. Reliable Distributed Systems, </booktitle> <pages> pages 155-162, </pages> <year> 1992. </year>
Reference-contexts: In synchronous checkpointing schemes, domino-free recovery is achieved by sacrificing process autonomy and incurring extra message overhead during checkpointing. In this approach, processes synchronize their checkpointing activities so that a globally consistent set of checkpoints is always maintained in the system <ref> [4, 9, 11, 12] </ref>. The storage requirement for the 1 checkpoints is minimum because each process keeps only one checkpoint in the stable storage at any given time. Process execution may have to be suspended during the checkpointing coordination as in [7, 9], resulting in performance degradation.
Reference: [5] <author> D. B. Johnson and W. Zwaenepoel. </author> <title> "Recovery in Distributed Systems Using Optimistic Message Logging and Checkpointing". </title> <journal> J. Algorithms, </journal> <volume> 11(3) </volume> <pages> 462-491, </pages> <month> September </month> <year> 1990. </year>
Reference-contexts: To reduce domino effect, Kim et al. [8] and Venkatesh et al. [18] use the dependency tracking and insert checkpoints before processing a new message that introduces dependency. Message logging <ref> [5, 6, 16, 17, 22] </ref> and message reordering [21] have been suggested in the literature to cope with the domino effect. Asynchronous checkpointing requires multiple checkpoints to be stored at each process.
Reference: [6] <author> T. T-Y. Juang and S. Venkatesan. </author> <title> "Crash Recovery with Little Overhead". </title> <booktitle> In Proc. of 11 th International Conf. on Distributed Comput. Syst., </booktitle> <pages> pages 454-461, </pages> <year> 1991. </year>
Reference-contexts: To reduce domino effect, Kim et al. [8] and Venkatesh et al. [18] use the dependency tracking and insert checkpoints before processing a new message that introduces dependency. Message logging <ref> [5, 6, 16, 17, 22] </ref> and message reordering [21] have been suggested in the literature to cope with the domino effect. Asynchronous checkpointing requires multiple checkpoints to be stored at each process.
Reference: [7] <author> Junguk L. Kim and Taesoon Park. </author> <title> "An Efficient Protocol for Checkpointing recovery in Distributed Systems". </title> <journal> IEEE Trans. on Parallel and Distributed Systems, </journal> <volume> 4(8) </volume> <pages> 955-960, </pages> <month> August </month> <year> 1993. </year>
Reference-contexts: The storage requirement for the 1 checkpoints is minimum because each process keeps only one checkpoint in the stable storage at any given time. Process execution may have to be suspended during the checkpointing coordination as in <ref> [7, 9] </ref>, resulting in performance degradation. Paper Objectives In this paper, we first present a quasi-synchronous checkpointing algorithm which has the easeness and low overhead of asynchronous checkpointing and the recovery time advantages of synchronous checkpointing.
Reference: [8] <author> K. H Kim. </author> <title> "A Scheme for Coordinated Execution of Independently Designed Recoverable Distributed Processes". </title> <booktitle> In Proc. of 16 th IEEE Symp. Fault-Tolerant Comput., </booktitle> <pages> pages 130-135, </pages> <month> June </month> <year> 1986. </year>
Reference-contexts: This approach allows maximum process autonomy and has low checkpointing overhead. However, this approach may suffer from the domino effect, in which the processes roll back recursively while determining a consistent set of checkpoints. To reduce domino effect, Kim et al. <ref> [8] </ref> and Venkatesh et al. [18] use the dependency tracking and insert checkpoints before processing a new message that introduces dependency. Message logging [5, 6, 16, 17, 22] and message reordering [21] have been suggested in the literature to cope with the domino effect.
Reference: [9] <author> R. Koo and S. Toueg. </author> <title> "Checkpointing and Roll-back Recovery for Distributed Systems". </title> <journal> IEEE Trans. on Software Eng., </journal> <volume> SE-13(1):23-31, </volume> <month> January </month> <year> 1987. </year>
Reference-contexts: In synchronous checkpointing schemes, domino-free recovery is achieved by sacrificing process autonomy and incurring extra message overhead during checkpointing. In this approach, processes synchronize their checkpointing activities so that a globally consistent set of checkpoints is always maintained in the system <ref> [4, 9, 11, 12] </ref>. The storage requirement for the 1 checkpoints is minimum because each process keeps only one checkpoint in the stable storage at any given time. Process execution may have to be suspended during the checkpointing coordination as in [7, 9], resulting in performance degradation. <p> The storage requirement for the 1 checkpoints is minimum because each process keeps only one checkpoint in the stable storage at any given time. Process execution may have to be suspended during the checkpointing coordination as in <ref> [7, 9] </ref>, resulting in performance degradation. Paper Objectives In this paper, we first present a quasi-synchronous checkpointing algorithm which has the easeness and low overhead of asynchronous checkpointing and the recovery time advantages of synchronous checkpointing. <p> latest checkpoint of the failed process is greater than the sequence numbers of the latest checkpoints of all the other processes, then no process other than the failed process needs to roll back; they only need to take a checkpoint. 7 Comparison With Existing Work The checkpointing algorithms proposed in <ref> [9, 2] </ref> have a two-phase structure. This causes processes to suspend the normal computation for making checkpoint decisions which greatly increases the overhead during normal computation. The QSA does not cause any such overhead and avoids domino effect completely during recovery.
Reference: [10] <author> K.Tsuruoka, A. Kaneko, and Y. Nishihara. </author> <title> "Dynamic Recovery Schemes for Distributed Process". </title> <booktitle> In Proceedings of IEEE 2nd Symp. on Reliability in Distributed Software and Database Systems, </booktitle> <pages> pages 124-130, </pages> <year> 1981. </year>
Reference-contexts: When a failure occurs, a rollback protocol uses the checkpoints and message logs to restore the system to a consistent global state [14]. In the literature, several checkpointing schemes have been proposed for distributed systems. They can be broadly classified into two categories asynchronous and synchronous. In asynchronous checkpointing <ref> [3, 10, 20] </ref>, processes take checkpoints periodically without any coordination with others. To recover from a failure, a process communicates with other processes to determine if their local states are causally related.
Reference: [11] <author> T. H. Lai and T. H. Yang. </author> <title> "On Distributed Snapshots". </title> <journal> Information Processing Letters, </journal> <volume> 25 </volume> <pages> 153-158, </pages> <month> May </month> <year> 1987. </year>
Reference-contexts: In synchronous checkpointing schemes, domino-free recovery is achieved by sacrificing process autonomy and incurring extra message overhead during checkpointing. In this approach, processes synchronize their checkpointing activities so that a globally consistent set of checkpoints is always maintained in the system <ref> [4, 9, 11, 12] </ref>. The storage requirement for the 1 checkpoints is minimum because each process keeps only one checkpoint in the stable storage at any given time. Process execution may have to be suspended during the checkpointing coordination as in [7, 9], resulting in performance degradation.
Reference: [12] <author> K. Li, J. F. Naughton, and J. S. Plank. </author> <title> "Checkpointing Multicomputer Applications". </title> <booktitle> In Proc. 10 th Symp. on Reliable Distributed Systems, </booktitle> <pages> pages 2-11, </pages> <year> 1991. </year>
Reference-contexts: In synchronous checkpointing schemes, domino-free recovery is achieved by sacrificing process autonomy and incurring extra message overhead during checkpointing. In this approach, processes synchronize their checkpointing activities so that a globally consistent set of checkpoints is always maintained in the system <ref> [4, 9, 11, 12] </ref>. The storage requirement for the 1 checkpoints is minimum because each process keeps only one checkpoint in the stable storage at any given time. Process execution may have to be suspended during the checkpointing coordination as in [7, 9], resulting in performance degradation.
Reference: [13] <author> D. Manivannan and M. Singhal. </author> <title> A quasi-synchronous algorithm for checkpointing in distributed systems. </title> <type> Technical Report OSU-CISRC-10/95-TR43, </type> <institution> The Ohio State University, Department of Computer and Information Science, </institution> <year> 1995. </year>
Reference-contexts: The results of the analysis in these two cases are given in Assertions 1 and 2, respectively below. The proofs of these assertions can be found in <ref> [13] </ref>. Assertion 1: Assume that under a basic checkpointing pattern, each process takes a basic checkpoint at the end of every x time units, and the local clocks of the processes can drift by at most ffi where ffi &lt; 1 2 fl x.
Reference: [14] <author> S. L. Peterson and Phil Kearns. </author> <title> "Rollback Based on Vector Time". </title> <booktitle> In Proc. 12 th Symp. on Reliable Distributed Systems, </booktitle> <pages> pages 68-77, </pages> <year> 1993. </year> <month> 20 </month>
Reference-contexts: The use of checkpoints on a stable storage and rollback-recovery protocols are well established techniques for dealing with process failures in a distributed system. When a failure occurs, a rollback protocol uses the checkpoints and message logs to restore the system to a consistent global state <ref> [14] </ref>. In the literature, several checkpointing schemes have been proposed for distributed systems. They can be broadly classified into two categories asynchronous and synchronous. In asynchronous checkpointing [3, 10, 20], processes take checkpoints periodically without any coordination with others. <p> The optimistic recovery algorithm proposed by Strom and Yemini [17] suffers from domino effect. The recovery protocols proposed by Peterson and Kearns <ref> [14] </ref> is synchronous and tolerates single process failure. It requires the channels to be FIFO. Recovery proposed by Sistla and Welch [16] is synchronous for single process failure, requires the channels to be FIFO and uses vector timestamps.
Reference: [15] <author> David B. Johnson Sean W. Smith and J. D. Tygar. </author> <title> "Completely Asynchronous Optimistic recovery with Minimal Rollbacks". </title> <booktitle> In Proc. of 25 th International Symposium on Fault-Tolerant Computing, </booktitle> <pages> pages 361-370. </pages> <publisher> IEEE, </publisher> <year> 1995. </year>
Reference-contexts: The recovery protocols proposed by Peterson and Kearns [14] is synchronous and tolerates single process failure. It requires the channels to be FIFO. Recovery proposed by Sistla and Welch [16] is synchronous for single process failure, requires the channels to be FIFO and uses vector timestamps. Smith and Johnson <ref> [15] </ref> proposed an asynchronous recovery algorithm for multiple process failures; however, the size of the vector clock is O (N 2 ) which results in high overhead during failure free operation. 8 Conclusion We presented a novel quasi-synchronous checkpointing algorithm and a comprehensive recovery algorithm based on it.
Reference: [16] <author> A. P. Sistla and J. L. Welch. </author> <title> "Efficient Distributed Recovery Using Message Logging". </title> <booktitle> In Proc. of 8 th ACM Symp. Principles Distributed Comput., </booktitle> <pages> pages 223-238, </pages> <month> August </month> <year> 1989. </year>
Reference-contexts: To reduce domino effect, Kim et al. [8] and Venkatesh et al. [18] use the dependency tracking and insert checkpoints before processing a new message that introduces dependency. Message logging <ref> [5, 6, 16, 17, 22] </ref> and message reordering [21] have been suggested in the literature to cope with the domino effect. Asynchronous checkpointing requires multiple checkpoints to be stored at each process. <p> The optimistic recovery algorithm proposed by Strom and Yemini [17] suffers from domino effect. The recovery protocols proposed by Peterson and Kearns [14] is synchronous and tolerates single process failure. It requires the channels to be FIFO. Recovery proposed by Sistla and Welch <ref> [16] </ref> is synchronous for single process failure, requires the channels to be FIFO and uses vector timestamps.
Reference: [17] <author> R. E. Strom and S. Yemini. </author> <title> "Optimistic Recovery in Distributed Systems". </title> <journal> ACM Trans. Comput. Syst., </journal> <volume> 3(3) </volume> <pages> 204-226, </pages> <month> August </month> <year> 1985. </year>
Reference-contexts: To reduce domino effect, Kim et al. [8] and Venkatesh et al. [18] use the dependency tracking and insert checkpoints before processing a new message that introduces dependency. Message logging <ref> [5, 6, 16, 17, 22] </ref> and message reordering [21] have been suggested in the literature to cope with the domino effect. Asynchronous checkpointing requires multiple checkpoints to be stored at each process. <p> No as sumption is made about the FIFO nature of the channels. We make the following assumptions about the failure of processes: * Processes are fail-stop. All failures are detected immediately and result in halting failed processes and initiating recovery action <ref> [17] </ref>. * A process can be inactive due to failure for an arbitrarily long, but finite time. * An inactive process can be detected by other processes. <p> The optimistic recovery algorithm proposed by Strom and Yemini <ref> [17] </ref> suffers from domino effect. The recovery protocols proposed by Peterson and Kearns [14] is synchronous and tolerates single process failure. It requires the channels to be FIFO.
Reference: [18] <author> K. Venkatesh and T. Radhakrishnan. </author> <title> "Optimal Checkpointing and Local Encoding for Domino-free Rollback Recovery". </title> <journal> Information Processing Letters, </journal> <volume> 25 </volume> <pages> 295-303, </pages> <month> July </month> <year> 1987. </year>
Reference-contexts: This approach allows maximum process autonomy and has low checkpointing overhead. However, this approach may suffer from the domino effect, in which the processes roll back recursively while determining a consistent set of checkpoints. To reduce domino effect, Kim et al. [8] and Venkatesh et al. <ref> [18] </ref> use the dependency tracking and insert checkpoints before processing a new message that introduces dependency. Message logging [5, 6, 16, 17, 22] and message reordering [21] have been suggested in the literature to cope with the domino effect. Asynchronous checkpointing requires multiple checkpoints to be stored at each process.
Reference: [19] <author> Y. M. Wang and W. K. Fuchs. </author> <title> "Lazy checkpoint Coordination for Bounding Rollback Propagation". </title> <type> Technical Report CRHC-92-26, </type> <institution> Coordinated Science Laboratory, University of Illinois at Urbana-Champaign, </institution> <year> 1992. </year>
Reference-contexts: This might force the processes to take as many checkpoints as the number of messages if the message reception and transmission are interleaved, which would result in high checkpointing overhead. Wang et al. <ref> [19] </ref> proposed lazy checkpoint coordination for bounding rollback propagation. Like our approach, their technique requires the checkpoint number being piggybacked on the computation messages so that the receiving processes can take an extra checkpoint when required.
Reference: [20] <author> Y. M. Wang and W. K. Fuchs. </author> <title> "Optimistic Message Logging for Independent Check-pointing in Message Passing Systems". </title> <booktitle> In Proc. Symp. on Reliable Distributed Systems, </booktitle> <pages> pages 147-154, </pages> <month> October </month> <year> 1992. </year>
Reference-contexts: When a failure occurs, a rollback protocol uses the checkpoints and message logs to restore the system to a consistent global state [14]. In the literature, several checkpointing schemes have been proposed for distributed systems. They can be broadly classified into two categories asynchronous and synchronous. In asynchronous checkpointing <ref> [3, 10, 20] </ref>, processes take checkpoints periodically without any coordination with others. To recover from a failure, a process communicates with other processes to determine if their local states are causally related.
Reference: [21] <author> Y. M. Wang and W. K. Fuchs. </author> <title> "Scheduling Message Processing for Reducing Rollback Propagation". </title> <booktitle> In Proc. IEEE Fault-Tolerant Computing Symposium, </booktitle> <pages> pages 204-211, </pages> <month> July </month> <year> 1992. </year>
Reference-contexts: To reduce domino effect, Kim et al. [8] and Venkatesh et al. [18] use the dependency tracking and insert checkpoints before processing a new message that introduces dependency. Message logging [5, 6, 16, 17, 22] and message reordering <ref> [21] </ref> have been suggested in the literature to cope with the domino effect. Asynchronous checkpointing requires multiple checkpoints to be stored at each process. In synchronous checkpointing schemes, domino-free recovery is achieved by sacrificing process autonomy and incurring extra message overhead during checkpointing.
Reference: [22] <author> Y. M. Wang, Y. Huang, and W. K. Fuchs. </author> <title> "Progressive Retry for Software Recovery in Distributed Systems". </title> <booktitle> In Proc. IEEE Fault-Tolerant Computing Symposium, </booktitle> <pages> pages 138-144, </pages> <month> June </month> <year> 1993. </year> <month> 21 </month>
Reference-contexts: To reduce domino effect, Kim et al. [8] and Venkatesh et al. [18] use the dependency tracking and insert checkpoints before processing a new message that introduces dependency. Message logging <ref> [5, 6, 16, 17, 22] </ref> and message reordering [21] have been suggested in the literature to cope with the domino effect. Asynchronous checkpointing requires multiple checkpoints to be stored at each process.
References-found: 22

