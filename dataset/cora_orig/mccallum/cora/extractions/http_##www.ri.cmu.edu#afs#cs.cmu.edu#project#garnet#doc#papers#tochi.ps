URL: http://www.ri.cmu.edu/afs/cs.cmu.edu/project/garnet/doc/papers/tochi.ps
Refering-URL: http://www.ri.cmu.edu/afs/cs/project/garnet/www/papers.html
Root-URL: 
Email: bvz@cs.utk.edu brad.myers@cs.cmu.edu szekely@isi.edu dzg@cs.cmu.edu  
Title: Integrating Pointer Variables into One-Way Constraint Models  
Author: Brad Vander Zanden Brad A. Myers Pedro Szekely Dario A. Giuse 
Keyword: Categories and Subject Descriptors: D.2.2 [Software Engineering]: Tools and TechniquesUser Interfaces; D.2.3 [Software Engineering]: CodingProgram editors; D.2.6 [Software Engineering]: Programming Environments; I.1.2 [Computing Methodologies]: AlgorithmsNonalgebraic Algorithms; I.1.3 [Computing Methodologies]: Languages and SystemsEvaluation Strategies General Terms: Algorithms, Design, Languages Additional Keywords and Phrases: Constraints, development tools, incremental algorithms, Garnet  
Address: 4676 Admiralty Way Knoxville, TN 37996 Pittsburgh, PA 15213 Marina del Rey, CA 90292  
Affiliation: Computer Science Department School of Computer Science USC/Information Sciences Institute University of Tennessee Carnegie Mellon University  
Abstract: Pointer variables have long been considered useful for constructing and manipulating data structures in traditional programming languages. This paper discusses how pointer variables can be integrated into one-way constraint models and indicates how these constraints can be usefully employed in user interfaces. Pointer variables allow constraints to model a wide array of dynamic application behavior, simplify the implementation of structured objects and demonstrational systems, and improve the storage and efficiency of constraint-based applications. This paper also presents two incremental algorithmsone lazy and one eagerfor solving constraints with pointer variables. Both algorithms are capable of handling 1) arbitrary systems of one-way constraints, including constraints that involve cycles; and 2) editing models that allow multiple changes between calls to the constraint solver. These algorithms are also fault-tolerant in that they can gracefully handle and recover from formulas that crash due to programmer error. Constraints that use pointer variables have been implemented in a comprehensive user interface toolkit, Garnet, and our experiences with applications written in Garnet have proven the usefulness of pointer-variable constraints. Many large scale applications have now been implemented using these constraints. 
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> Alfred V. Aho, John E. Hopcroft, and Jeffrey D. Ullman. </author> <title> The Design and Analysis of Computer Algorithms. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, Massachusetts, </address> <year> 1974. </year>
Reference-contexts: Cycles are detected using an algorithm that finds the strongly connected components of a graph <ref> [1, pp. 189-195] </ref>. A strongly connected component is a set of nodes such that for every pair of nodes v and w, there is a path from v to w and a path from w to v. Any strongly connected component of size greater than one is a cycle. <p> The handling of non-cyclic variables is not altered. reorder has been modified so that its depth-first search is capable of detecting and handling cycles. The backbone of the algorithm is shown in Figure 23 (the algorithm detects strongly connected components and is adapted from <ref> [1, pp. 189-195] </ref>), while the complete algorithm that detects cycles and assigns position numbers is shown in Figure 22. <p> In both figures, a dfnumber of i indicates that this is the ith node visited during the depth-first search. lowlink is defined as ( <ref> [1] </ref>, 190): v.lowlink = min (-v.dfnumber -w.dfnumber | there is a cross edge or back edge from a descendant of v to w, and the root of the strongly connected component containing w is an ancestor of v The definition of lowlink implies that if a variable's lowlink j is lower
Reference: 2. <author> Alduss. </author> <month> Alduss Intellidraw. </month>
Reference-contexts: 1 Introduction Many tools, including user interface toolkits [33, 13, 3, 5, 14], programming environments [40], and picture drawing tools <ref> [49, 39, 26, 2] </ref>, are increasingly integrating constraints into their programming models. A constraint denotes a relationship among two or more objects.
Reference: 3. <author> Paul Barth. </author> <title> "An Object-Oriented Approach to Graphical Interfaces". </title> <journal> ACM Transactions on Graphics 5, </journal> <month> 2 (April </month> <year> 1986), </year> <pages> 142-172. </pages>
Reference-contexts: 1 Introduction Many tools, including user interface toolkits <ref> [33, 13, 3, 5, 14] </ref>, programming environments [40], and picture drawing tools [49, 39, 26, 2], are increasingly integrating constraints into their programming models. A constraint denotes a relationship among two or more objects. <p> Many other systems, such as Sketchpad [47], CONSTRAINTS [46], Grow <ref> [3] </ref>, Apogee [20], Peridot [31], COOL [26], the Cornell Synthesizer Generator [41], MetaMouse [30], and CONSTRAINT [51], have used constraints but not pointer variables. Pointer variables have also been explored in several somewhat different constraint contexts.
Reference: 4. <author> Alan Borning. </author> <title> "The Programming Language Aspects of ThingLab; a Constraint-Oriented Simulation Laboratory". </title> <journal> ACM Transactions on Programming Languages and Systems 3, </journal> <month> 4 (Oct. </month> <year> 1981), </year> <pages> 353-387. </pages>
Reference-contexts: This approach is used, for example, in ThingLab <ref> [4] </ref>. However, dynamic modifications to the objects' structure cannot be directly handled in this scheme because the objects referenced by the paths are not allowed to change dynamically. <p> ThingLab <ref> [4] </ref> provides a limited form of indirect reference constraints. Designers can construct pathnames that allow a constraint to traverse a structure hierarchy to find an object. If one of the components in the structure hierarchy changes, the new object will be automatically referenced by the constraint.
Reference: 5. <author> Alan Borning and Robert Duisberg. </author> <title> "Constraint-Based Tools for Building User Interfaces". </title> <journal> ACM Transactions on Graphics 5, </journal> <month> 4 (Oct. </month> <year> 1986), </year> <pages> 345-374. </pages>
Reference-contexts: 1 Introduction Many tools, including user interface toolkits <ref> [33, 13, 3, 5, 14] </ref>, programming environments [40], and picture drawing tools [49, 39, 26, 2], are increasingly integrating constraints into their programming models. A constraint denotes a relationship among two or more objects.
Reference: 6. <author> A. Borning, R. Duisberg, B. Freeman-Benson, A. Kramer, M. Woolf. </author> <title> Constraint Hierarchies. </title> <booktitle> OOPSLA'87 Conference Proceedings, </booktitle> <year> 1987, </year> <pages> pp. 48-60. </pages>
Reference-contexts: If the user expects it to change width, then the object will move instead of resizing, much to the user's surprise. The notion of attaching priorities to constraints, called constraint hierarchies, has been advanced to help the user better manage this problem <ref> [6] </ref>. However, there are no widespread studies on their usefulness to programmers or on whether they fully solve the manageability problem.
Reference: 7. <author> Jacques Cohen. </author> <title> "Constraint Logic Programming Languages". </title> <journal> Communications of the ACM 33, </journal> <month> 7 (July </month> <year> 1990), </year> <pages> 52-68. </pages>
Reference-contexts: The pointer model presented in this paper differs from the Kaleidoscope model in that pointer variables are directly handled by the constraint satisfaction algorithms rather than by asserting and retracting constraints. Pointer variables have also been examined in the context of logic-oriented languages, such as CLP [24], Prolog3 <ref> [7] </ref>, and Concurrent Constraint Programming [44]. Pointer variables can be represented 5 The Rendezvous constraint solver currently supports these programmer written specifications. The source expressions to be dynamically evaluated are specified by filling in code templates.
Reference: 8. <author> J.E. Dennis, Jr., and R.B. Schnabel. </author> <title> Numerical Methods for Unconstrained Optimization and Nonlinear Equations. </title> <publisher> Prentice Hall, </publisher> <address> New York, NY, </address> <year> 1983. </year>
Reference-contexts: The constraints themselves are still direct-reference constraints and the algorithms that satisfy them can only handle direct reference constraints. There are many domain-dependent constraint satisfiers, such as simultaneous linear equation solvers [49, 27, 28], non-linear solvers <ref> [54, 8] </ref>, and inequality solvers [25], that can solve more expressive constraints than one-way constraints, but they are less flexible, since they are typically limited to one domain, and they are slower on the subclass of constraints that one-way constraint satisfiers can solve.
Reference: 9. <author> Bjorn N. Freeman-Benson. </author> <title> "A Module Mechanism for Constraints in Smalltalk". </title> <journal> Sigplan Notices 24, </journal> <month> 10 (Oct. </month> <year> 1989), </year> <pages> 389-396. </pages> <booktitle> ACM Conference on Object-Oriented Programming; Systems Languages and Applications; OOPSLA'89. </booktitle>
Reference-contexts: The use of pointer variables does not preclude the use of other optimization techniques, such as constant propagation and compiling constraints into modules of constraints <ref> [9] </ref>, although as in compiler optimization, pointer variables can make this analysis more difficult. Storage improvements come in two forms. First, by allowing objects to be constrained to many different objects, indirect reference constraints may significantly decrease the number of objects which an application creates. <p> Constraint Models - 48 - multi-way solvers were considered too slow to incorporate in user interface systems, but this has changed with the introduction of fast incremental solvers, such as IncrementalPdof [52], DeltaBlue [11], and SkyBlue [42], and the use of optimization techniques such as constant propagation and plan caching <ref> [29, 9, 50] </ref>. However, each of these algorithms has drawbacks. IncrementalPdof does not incorporate a management scheme like constraint hierarchies, and DeltaBlue and SkyBlue are not designed to find 6 solutions to a constraint graph with cycles .
Reference: 10. <author> Bjorn N. Freeman-Benson. </author> <title> Kaleidoscope: Mixing Objects, Constraints, and Imperative Programming. </title> <booktitle> OOPSLA/ECOOP'90 Conference Proceedings, </booktitle> <year> 1990, </year> <pages> pp. 77-88. </pages>
Reference-contexts: Many other systems, such as Sketchpad [47], CONSTRAINTS [46], Grow [3], Apogee [20], Peridot [31], COOL [26], the Cornell Synthesizer Generator [41], MetaMouse [30], and CONSTRAINT [51], have used constraints but not pointer variables. Pointer variables have also been explored in several somewhat different constraint contexts. Kaleidoscope <ref> [10] </ref> supports a different type of abstractionconstraint abstraction rather than procedural abstractionin which procedures (called constraint constructors) consist of a set of constraint statements and produce as output a set of constraints instantiated with the parameters passed to the procedure.
Reference: 11. <author> Bjorn N. Freeman-Benson, John Maloney, and Alan Borning. </author> <title> "An Incremental Constraint Solver". </title> <journal> Comm. ACM 33, </journal> <month> 1 (Jan. </month> <year> 1990), </year> <pages> 54-63. </pages>
Reference-contexts: Thus Kaleidoscope can satisfy constraints using an appropriate algorithm that handles direct references, such as DeltaBlue <ref> [11] </ref>. The pointer model presented in this paper differs from the Kaleidoscope model in that pointer variables are directly handled by the constraint satisfaction algorithms rather than by asserting and retracting constraints. <p> Both of these drawbacks arise from the need to first plan how to satisfy the constraints, before actually satisfying the constraints. Typically each constraint has multiple methods for solving it, and the plan selects one method for each constraint <ref> [11, 12, 52] </ref>. The methods are then executed in topological order, just as in one-way constraint solving. Thus the algorithms presented in this paper can be used in the evaluation phase of multi-way constraint satisfaction. <p> Until recently, Pointers in Constraint Models - 48 - multi-way solvers were considered too slow to incorporate in user interface systems, but this has changed with the introduction of fast incremental solvers, such as IncrementalPdof [52], DeltaBlue <ref> [11] </ref>, and SkyBlue [42], and the use of optimization techniques such as constant propagation and plan caching [29, 9, 50]. However, each of these algorithms has drawbacks. <p> MultiGarnet, developed by Michael Sannella, is an experimental version of Garnet which uses such a scheme. MultiGarnet uses a direct reference algorithm called SkyBlue [42] that extends the DeltaBlue multi-way constraint algorithm <ref> [11] </ref> to handle multi-output constraints and to more gracefully handle cycles. MultiGarnet currently handles changes to indirect references by removing the changed constraint, and re-adding it with the updated reference.
Reference: 12. <author> Jim Gosling. </author> <title> Algebraic Constraints. </title> <type> Tech. </type> <institution> Rept. CMU-CS-83-132, Carnegie Mellon University Computer Science Department, </institution> <year> 1983. </year> <title> Pointers in Constraint Models - 50 </title> - 
Reference-contexts: Both of these drawbacks arise from the need to first plan how to satisfy the constraints, before actually satisfying the constraints. Typically each constraint has multiple methods for solving it, and the plan selects one method for each constraint <ref> [11, 12, 52] </ref>. The methods are then executed in topological order, just as in one-way constraint solving. Thus the algorithms presented in this paper can be used in the evaluation phase of multi-way constraint satisfaction.
Reference: 13. <author> Tyson R. Henry and Scott E. Hudson. </author> <title> Using Active Data in a UIMS. </title> <booktitle> ACM SIGGRAPH Symposium on User Interface Software and Technology, Proceedings UIST'88, </booktitle> <address> Banff, Alberta, Canada, </address> <month> Oct., </month> <year> 1988, </year> <pages> pp. 167-178. </pages>
Reference-contexts: 1 Introduction Many tools, including user interface toolkits <ref> [33, 13, 3, 5, 14] </ref>, programming environments [40], and picture drawing tools [49, 39, 26, 2], are increasingly integrating constraints into their programming models. A constraint denotes a relationship among two or more objects.
Reference: 14. <author> Ralph D. Hill. </author> <title> Languages for the Construction of Multi-User Multi-Media Synchronous (MUMMS) Applications. </title> <editor> In Brad A. Myers, Ed., </editor> <title> Languages for Developing User Interfaces, </title> <publisher> Jones and Bartlett Publishers, </publisher> <address> Boston, MA, </address> <year> 1992, </year> <pages> pp. 125-143. </pages>
Reference-contexts: 1 Introduction Many tools, including user interface toolkits <ref> [33, 13, 3, 5, 14] </ref>, programming environments [40], and picture drawing tools [49, 39, 26, 2], are increasingly integrating constraints into their programming models. A constraint denotes a relationship among two or more objects. <p> Since each variable has a fixed number of input edges, it is possible to simply adjust edges instead. For example, if a pointer variable causes a constraint to reference B.left rather than A.left, the incoming edge can be adjusted so that it originates from B.left rather than A.left. Rendezvous <ref> [14, 15] </ref> supports indirect constraints for both the sources and targets of a constraint, permits both variable numbers of sources and targets, and allows constraints to consist of arbitrary Lisp expressions.
Reference: 15. <author> Ralph D. Hill. </author> <title> The Rendezvous Constraint Maintenance System. </title> <booktitle> ACM SIGGRAPH Symposium on User Interface Software and Technology, Proceedings UIST'93, </booktitle> <address> Atlanta, GA, </address> <month> Nov., </month> <year> 1993, </year> <pages> pp. 225-234. </pages>
Reference-contexts: Garnet has over 100 users in over 60 projects who have used indirect reference constraints to generate numerous applications. Many of these applications contain thousands of indirect reference constraints. The success of indirect constraints in Garnet has inspired their use in many other systems including MultiGarnet [43], Rendezvous <ref> [15] </ref>, and Eval/vite [23]. Pointers in Constraint Models - 3 - The rest of this paper is organized as follows. The next section describes how a number of user interface applications can be implemented using indirect reference constraints. <p> Since each variable has a fixed number of input edges, it is possible to simply adjust edges instead. For example, if a pointer variable causes a constraint to reference B.left rather than A.left, the incoming edge can be adjusted so that it originates from B.left rather than A.left. Rendezvous <ref> [14, 15] </ref> supports indirect constraints for both the sources and targets of a constraint, permits both variable numbers of sources and targets, and allows constraints to consist of arbitrary Lisp expressions.
Reference: 16. <author> R. </author> <title> Hoover. Incremental Graph Evaluation. </title> <type> Ph.D. </type> <institution> Th., Department of Computer Science, Cornell University, </institution> <address> Ithaca, NY, </address> <year> 1987. </year>
Reference-contexts: The eager evaluator presented in this paper assigns position numbers to variables based on their position in topological order and evaluates constraints in the order indicated by these position numbers. This eager algorithm uses a variation of an eager evaluator presented by Hoover <ref> [16] </ref>. Both of the algorithms presented in this paper can handle arbitrary systems of one-way constraints, including systems that contain cycles. They can also handle multiple edits to the constraint system (e.g., adding constraints, deleting constraints, or changing the values of variables) between successive calls to the constraint solver. <p> However, it is not difficult to add this code or data structures to the algorithm presented in this paper, and thus evaluate the optimal number of variables. 4.3 Eager Evaluation without Cycles The eager evaluation algorithm uses a variation of an eager evaluator developed by Roger Hoover <ref> [16] </ref>. Like the lazy evaluator, this algorithm makes use of dataflow graphs. However, it assigns position numbers to the nodes in the graph, indicating the nodes' relative position in topological order (Figure 13.a). A node's position number is always greater than the position numbers of any of its successors.
Reference: 17. <author> Roger Hoover. "Alphonse: </author> <title> Incremental Computation as a Programming Abstraction". </title> <journal> Sigplan Notices 27, </journal> <month> 7 (July </month> <year> 1992), </year> <pages> 261-272. </pages> <booktitle> ACM SIGPLAN'92 Conference on Programming Language Design and Implementation. </booktitle>
Reference-contexts: The problem with overspecification can be solved by allowing programmer written specifications to be Pointers in Constraint Models - 46 - 5 dynamically evaluated , although programmer written specifications introduce a potential source of errors that automatic source detection avoids. Alphonse <ref> [17] </ref> is a program transformation system that takes a program annotated with Alphonse notations and converts it to an incremental program. Both caching and incremental graph evaluation algorithms are used to implement the programs. <p> Both caching and incremental graph evaluation algorithms are used to implement the programs. Like the indirect reference constraints in this paper, Alphonse supports pointer variables and dynamically changing sets of input variables. The description of Alphonse in <ref> [17] </ref> does not specify a specific algorithm that should be used for evaluating variables. However, it does describe how the dependency graph is dynamically maintained and its approach differs from the timestamp approach used in this paper.
Reference: 18. <author> Bruce Horn. </author> <title> Properties of User Interface Systems and the Siri Programming Language. </title> <editor> In Brad A. Myers, Ed., </editor> <title> Languages for Developing User Interfaces, </title> <publisher> Jones and Bartlett Publishers, </publisher> <address> Boston, MA, </address> <year> 1992, </year> <pages> pp. 211-238. </pages>
Reference-contexts: The programmer can represent changeable state by asserting and retracting clauses and constraint relationships over time. These assertions and retractions allow the same constraints to be instantiated with different objects at different times. Term rewriting systems provide yet another means for representing pointer variables within constraints. Bertrand [27], Siri <ref> [18, 19] </ref>, and Equate [53] are several examples of such systems. Term rewriting systems bear a certain resemblance to logic languages in that the user writes a set of rewrite rules, each of which contains a pattern as a ``head'', and one or more expressions as a ``body''.
Reference: 19. <author> Bruce Horn. </author> <title> "Constraint Patterns As a Basis For Object Oriented Programming". </title> <journal> Sigplan Notices 27, </journal> <month> 10 (Oct. </month> <year> 1992), </year> <pages> 218-233. </pages> <booktitle> ACM Conference on Object-Oriented Programming Systems, Languages, and Applications; OOPSLA'92. </booktitle>
Reference-contexts: The programmer can represent changeable state by asserting and retracting clauses and constraint relationships over time. These assertions and retractions allow the same constraints to be instantiated with different objects at different times. Term rewriting systems provide yet another means for representing pointer variables within constraints. Bertrand [27], Siri <ref> [18, 19] </ref>, and Equate [53] are several examples of such systems. Term rewriting systems bear a certain resemblance to logic languages in that the user writes a set of rewrite rules, each of which contains a pattern as a ``head'', and one or more expressions as a ``body''.
Reference: 20. <author> Scott E. Hudson. </author> <title> Graphical Specification of Flexible User Interface Displays. </title> <booktitle> ACM SIGGRAPH Symposium on User Interface Software and Technology, Proceedings UIST'89, </booktitle> <address> Williamsburg, VA, </address> <month> Nov., </month> <year> 1989, </year> <pages> pp. 105-114. </pages>
Reference-contexts: Many other systems, such as Sketchpad [47], CONSTRAINTS [46], Grow [3], Apogee <ref> [20] </ref>, Peridot [31], COOL [26], the Cornell Synthesizer Generator [41], MetaMouse [30], and CONSTRAINT [51], have used constraints but not pointer variables. Pointer variables have also been explored in several somewhat different constraint contexts.
Reference: 21. <author> Scott E. Hudson. </author> <title> An Enhanced Spreadsheet Model for User Interface Specification. </title> <type> Tech. </type> <institution> Rept. TR90-33, The University of Arizona, </institution> <year> 1990. </year>
Reference-contexts: Programmers had to know whether a slot of an object was a pointer variable or not, and use the appropriate procedure to set it. In addition, the values of pointer variables could not themselves be defined using a constraint, thus restricting the applicability of the indirect reference constraints. Penguims <ref> [21] </ref> and Eval/vite [23] support a model of indirect reference constraints that is somewhat more restricted than the one presented in this paper. The newer system, Eval/vite, allows constraints to be written in a limited subset of C++.
Reference: 22. <author> Scott E. Hudson. </author> <title> "Incremental Attribute Evaluation: A Flexible Algorithm for Lazy Update". </title> <journal> ACM TOPLAS 13, </journal> <month> 3 (July </month> <year> 1991), </year> <pages> 315-341. </pages>
Reference-contexts: The lazy evaluator presented in this paper uses a nullification/reevaluation scheme and can incorporate Hudson's optimal lazy evaluation algorithm <ref> [22] </ref> for direct reference constraints. The eager evaluator presented in this paper assigns position numbers to variables based on their position in topological order and evaluates constraints in the order indicated by these position numbers. This eager algorithm uses a variation of an eager evaluator presented by Hoover [16]. <p> This temporary assignment allows new values to be introduced into cycles. For example, if a is given a new value, the value will be propagated automatically to b. Multiple edits may be made before the constraint solver is called, and, adopting the terminology of Hudson <ref> [22] </ref>, the set of edits between invocations of the constraint solver is called a transaction. <p> transaction i. i These dependency edges represent variables that the variables in affected depended on i in previous transactions but which are no longer depended on in transaction i. 4.2 Lazy Evaluation A lazy evaluation scheme for indirect reference constraints can be implemented using a variation of the nullification/reevaluation strategy <ref> [22, 40] </ref>. When the value of a variable changes, either by directly modifying the value or by installing a new formula in the variable, all variables that directly or indirectly depend on this changed variable are marked out-of-date (nullification phase). <p> If these variables are out-of-date, they will recursively demand the values of the variables they depend on, until eventually variables are reached whose values are up-to-date, at which point the constraints can compute their value and return <ref> [22, 40] </ref>. For example, suppose that the user changes the width of the selected object B in Figure 6.a. variables that can be reached from B.width are marked out-of-date. Figure 8.b shows the variables that will be reevaluated if the value of the label object's string attribute is requested. <p> The eval code can be as simple as a call to an expression written by the user. This is what is done in Garnet [33]. Alternatively, it could use Hudson's lazy evaluator <ref> [22] </ref>. In this case, eval would first request the values of the variables that the formula currently depends on and make sure that at least one of them has changed before evaluating the formula expression written by the user. <p> The variable and dependency data structures would also have to be augmented with a number of additional fields to perform this test. See <ref> [22] </ref> for details on how to do this. nullify ( v : variable ) v.outofdate = true for each dependency v.dependencies do if dependency.timestamp &lt; dependency.var.timestamp then v.dependencies = v.dependencies - -dependency else if dependency.var.outofdate = false then nullify ( dependency.var ) get_value ( v : variable ) demanding_var = top <p> Even this bound is unduly pessimistic because in most i Pointers in Constraint Models - 22 - transactions, some of the variables in affected will already be out-of-date and thus will not be i charged to this transaction <ref> [22] </ref>. It is also important to note that for simplicity of presentation, we have not included the code or data structures that Hudson uses to prevent unnecessary evaluations of variables in [22]. <p> of the variables in affected will already be out-of-date and thus will not be i charged to this transaction <ref> [22] </ref>. It is also important to note that for simplicity of presentation, we have not included the code or data structures that Hudson uses to prevent unnecessary evaluations of variables in [22]. However, it is not difficult to add this code or data structures to the algorithm presented in this paper, and thus evaluate the optimal number of variables. 4.3 Eager Evaluation without Cycles The eager evaluation algorithm uses a variation of an eager evaluator developed by Roger Hoover [16].
Reference: 23. <author> Scott E. Hudson. </author> <title> A System for Efficient and Flexible One-Way Constraint Evaluation in C++. </title> <type> Tech. </type> <institution> Rept. 93-15, Graphics Visualizaton and Usability Center, College of Computing, Georgia Institute of Technology, </institution> <month> April, </month> <year> 1993. </year>
Reference-contexts: Many of these applications contain thousands of indirect reference constraints. The success of indirect constraints in Garnet has inspired their use in many other systems including MultiGarnet [43], Rendezvous [15], and Eval/vite <ref> [23] </ref>. Pointers in Constraint Models - 3 - The rest of this paper is organized as follows. The next section describes how a number of user interface applications can be implemented using indirect reference constraints. <p> In addition, the values of pointer variables could not themselves be defined using a constraint, thus restricting the applicability of the indirect reference constraints. Penguims [21] and Eval/vite <ref> [23] </ref> support a model of indirect reference constraints that is somewhat more restricted than the one presented in this paper. The newer system, Eval/vite, allows constraints to be written in a limited subset of C++. <p> All of these solvers are also incapable of handling pointer variables. Domain-independent, multi-way constraints are also more powerful than one-way constraints, but they can produce unexpected results and may fail to find a solution when one exists <ref> [23] </ref>. Both of these drawbacks arise from the need to first plan how to satisfy the constraints, before actually satisfying the constraints. Typically each constraint has multiple methods for solving it, and the plan selects one method for each constraint [11, 12, 52].
Reference: 24. <author> J. Jaffar and J. Lassez. </author> <title> Constraint Logic Programming. </title> <booktitle> Proceedings of the Principles of Programming Languages Conference, </booktitle> <address> Munich, Germany, </address> <month> Jan., </month> <year> 1987, </year> <pages> pp. 111-119. </pages>
Reference-contexts: The pointer model presented in this paper differs from the Kaleidoscope model in that pointer variables are directly handled by the constraint satisfaction algorithms rather than by asserting and retracting constraints. Pointer variables have also been examined in the context of logic-oriented languages, such as CLP <ref> [24] </ref>, Prolog3 [7], and Concurrent Constraint Programming [44]. Pointer variables can be represented 5 The Rendezvous constraint solver currently supports these programmer written specifications. The source expressions to be dynamically evaluated are specified by filling in code templates.
Reference: 25. <author> J. Jaffar, S. Michaylov, P.J. Stuckey, and R.H.C. Yap. </author> <title> "The CLP(R) Language and System". </title> <journal> ACM TOPLAS 14, </journal> <month> 3 (July </month> <year> 1992), </year> <pages> 339-395. </pages>
Reference-contexts: The constraints themselves are still direct-reference constraints and the algorithms that satisfy them can only handle direct reference constraints. There are many domain-dependent constraint satisfiers, such as simultaneous linear equation solvers [49, 27, 28], non-linear solvers [54, 8], and inequality solvers <ref> [25] </ref>, that can solve more expressive constraints than one-way constraints, but they are less flexible, since they are typically limited to one domain, and they are slower on the subclass of constraints that one-way constraint satisfiers can solve. All of these solvers are also incapable of handling pointer variables.
Reference: 26. <author> Tomihisa Kamada and Satoru Kawai. </author> <title> "A General Framework for Visualizing Abstract Objects and Relations". </title> <journal> ACM Transactions on Graphics 10, </journal> <month> 1 (Jan. </month> <year> 1990), </year> <pages> 1-39. </pages>
Reference-contexts: 1 Introduction Many tools, including user interface toolkits [33, 13, 3, 5, 14], programming environments [40], and picture drawing tools <ref> [49, 39, 26, 2] </ref>, are increasingly integrating constraints into their programming models. A constraint denotes a relationship among two or more objects. <p> Many other systems, such as Sketchpad [47], CONSTRAINTS [46], Grow [3], Apogee [20], Peridot [31], COOL <ref> [26] </ref>, the Cornell Synthesizer Generator [41], MetaMouse [30], and CONSTRAINT [51], have used constraints but not pointer variables. Pointer variables have also been explored in several somewhat different constraint contexts.
Reference: 27. <author> W. Leler. </author> <title> Constraint Programming Languages: Their Specification and Generation. </title> <publisher> Addison-Wesley Publishing Company, </publisher> <address> New York, </address> <year> 1988. </year>
Reference-contexts: The programmer can represent changeable state by asserting and retracting clauses and constraint relationships over time. These assertions and retractions allow the same constraints to be instantiated with different objects at different times. Term rewriting systems provide yet another means for representing pointer variables within constraints. Bertrand <ref> [27] </ref>, Siri [18, 19], and Equate [53] are several examples of such systems. Term rewriting systems bear a certain resemblance to logic languages in that the user writes a set of rewrite rules, each of which contains a pattern as a ``head'', and one or more expressions as a ``body''. <p> Rather, the old constraints are retracted and new constraints that reference the changed objects are added. The constraints themselves are still direct-reference constraints and the algorithms that satisfy them can only handle direct reference constraints. There are many domain-dependent constraint satisfiers, such as simultaneous linear equation solvers <ref> [49, 27, 28] </ref>, non-linear solvers [54, 8], and inequality solvers [25], that can solve more expressive constraints than one-way constraints, but they are less flexible, since they are typically limited to one domain, and they are slower on the subclass of constraints that one-way constraint satisfiers can solve.
Reference: 28. <author> J. Li. </author> <title> Constraint Hierarchies as Triangular Systems. </title> <type> Tech. </type> <institution> Rept. TRITA-NA-P9130, Dept of Numerical Analysis and Computing Science, Royal Institute of Technology, </institution> <address> S-100 44 Stockholm, Sweden, </address> <year> 1991. </year>
Reference-contexts: Rather, the old constraints are retracted and new constraints that reference the changed objects are added. The constraints themselves are still direct-reference constraints and the algorithms that satisfy them can only handle direct reference constraints. There are many domain-dependent constraint satisfiers, such as simultaneous linear equation solvers <ref> [49, 27, 28] </ref>, non-linear solvers [54, 8], and inequality solvers [25], that can solve more expressive constraints than one-way constraints, but they are less flexible, since they are typically limited to one domain, and they are slower on the subclass of constraints that one-way constraint satisfiers can solve.
Reference: 29. <author> John Maloney, Alan Borning, and Bjorn Freeman-Benson. </author> <title> "Constraint Technology for User-Interface Construction in ThingLabII". </title> <journal> Sigplan Notices 24, </journal> <month> 10 (Oct. </month> <year> 1989), </year> <pages> 381-388. </pages> <booktitle> ACM Conference on Object-Oriented Programming; Systems Languages and Applications; OOPSLA'89. Pointers in Constraint Models - 51 </booktitle> - 
Reference-contexts: Constraint Models - 48 - multi-way solvers were considered too slow to incorporate in user interface systems, but this has changed with the introduction of fast incremental solvers, such as IncrementalPdof [52], DeltaBlue [11], and SkyBlue [42], and the use of optimization techniques such as constant propagation and plan caching <ref> [29, 9, 50] </ref>. However, each of these algorithms has drawbacks. IncrementalPdof does not incorporate a management scheme like constraint hierarchies, and DeltaBlue and SkyBlue are not designed to find 6 solutions to a constraint graph with cycles .
Reference: 30. <author> David L. Maulsby, Ian H. Witten, and Kenneth A. Kittlitz. Metamouse: </author> <title> Specifying Graphical Procedures by Example. </title> <booktitle> Computer Graphics, Proceedings SIGGRAPH'89, </booktitle> <address> Boston, MA, </address> <month> July, </month> <year> 1989, </year> <pages> pp. 127-136. </pages>
Reference-contexts: Many other systems, such as Sketchpad [47], CONSTRAINTS [46], Grow [3], Apogee [20], Peridot [31], COOL [26], the Cornell Synthesizer Generator [41], MetaMouse <ref> [30] </ref>, and CONSTRAINT [51], have used constraints but not pointer variables. Pointer variables have also been explored in several somewhat different constraint contexts.
Reference: 31. <author> Brad A. Myers. </author> <title> Creating User Interfaces by Demonstration. </title> <publisher> Academic Press, </publisher> <address> Boston, </address> <year> 1988. </year>
Reference-contexts: Many other systems, such as Sketchpad [47], CONSTRAINTS [46], Grow [3], Apogee [20], Peridot <ref> [31] </ref>, COOL [26], the Cornell Synthesizer Generator [41], MetaMouse [30], and CONSTRAINT [51], have used constraints but not pointer variables. Pointer variables have also been explored in several somewhat different constraint contexts.
Reference: 32. <author> Brad A. Myers, Brad Vander Zanden, and Roger B. Dannenberg. </author> <title> Creating Graphical Interactive Application Objects by Demonstration. </title> <booktitle> ACM SIGGRAPH Symposium on User Interface Software and Technology, Proceedings UIST'89, </booktitle> <address> Williamsburg, VA, </address> <month> Nov., </month> <year> 1989, </year> <pages> pp. 95-104. </pages>
Reference-contexts: Pointers in Constraint Models - 7 - (a) (b) subtree rooted at b swapped with the subtree rooted at f. 2.5 Programming by Example Indirect reference constraints make it easier to implement systems that employ demonstrational programming [37], such as the graphical interactive design tool Lapidary <ref> [32] </ref>. In a demonstrational system, a user draws an example picture or demonstrates an example behavior, and then the system creates a generalized prototype object or behavior by figuring out which values in the picture or behavior should be parameters. <p> Finally, a variable can be marked out-of-date in 70 microseconds. Garnet's constraint solver can solve indirect reference constraints quickly enough to allow feedback objects to track the mouse in real time or to perform smooth, realtime animations, even in large, constraint-based applications. For example, the Lapidary interactive design tool <ref> [32] </ref> consists of 16,000 lines of Lisp code and 16,700 constraints, all of which are indirect reference constraints, and is fast enough to provide instantaneous feedback to the user.
Reference: 33. <author> Brad A. Myers, Dario A. Giuse, Roger B. Dannenberg, Brad Vander Zanden, David S. Kosbie, Ed Pervin, Andrew Mickish, and Philippe Marchal. "Garnet: </author> <title> Comprehensive Support for Graphical, Highly-Interactive User Interfaces". </title> <booktitle> IEEE Computer 23, </booktitle> <address> 11 (Nov. </address> <year> 1990), </year> <pages> 71-85. </pages>
Reference-contexts: 1 Introduction Many tools, including user interface toolkits <ref> [33, 13, 3, 5, 14] </ref>, programming environments [40], and picture drawing tools [49, 39, 26, 2], are increasingly integrating constraints into their programming models. A constraint denotes a relationship among two or more objects. <p> Indirect references were the key extension to constraints which allowed Garnet to be the first comprehensive user interface toolkit to be built on top of the constraint system <ref> [33, 35] </ref>. This includes the graphical object system, the handling of the input, all the widget libraries, and the higher-level interactive tools. For example, a Garnet text button widget contains 43 constraints internally and the Lapidary graphical interface builder contains 16,700 constraints [36]. <p> The eval code can be as simple as a call to an expression written by the user. This is what is done in Garnet <ref> [33] </ref>. Alternatively, it could use Hudson's lazy evaluator [22]. In this case, eval would first request the values of the variables that the formula currently depends on and make sure that at least one of them has changed before evaluating the formula expression written by the user.
Reference: 34. <author> Brad A. Myers. </author> <title> Graphical Techniques in a Spreadsheet for Specifying User Interfaces. </title> <booktitle> Human Factors in Computing Systems, Proceedings SIGCHI'91, </booktitle> <address> New Orleans, LA, </address> <month> April, </month> <year> 1991, </year> <pages> pp. 243-249. </pages>
Reference-contexts: Until these problems are solved to the satisfaction of programmers and users, one-way constraints are likely to remain more popular. 7 Future Research There are several directions for future research. First, we are examining graphical means of tracing constraints so that designers can debug them more easily <ref> [34] </ref>. Another direction for future work is to develop multi-way indirect reference constraint systems. We have a design for a two-way indirect reference constraint system, based on the ideas in this paper.
Reference: 35. <author> Brad A. Myers and Brad Vander Zanden. </author> <title> "An Environment for Rapid Creation of Interactive Design Tools". </title> <journal> The Visual Computer; International Journal of Computer Graphics 8, </journal> <volume> 3 (1992), </volume> <pages> 94-116. </pages>
Reference-contexts: Indirect references were the key extension to constraints which allowed Garnet to be the first comprehensive user interface toolkit to be built on top of the constraint system <ref> [33, 35] </ref>. This includes the graphical object system, the handling of the input, all the widget libraries, and the higher-level interactive tools. For example, a Garnet text button widget contains 43 constraints internally and the Lapidary graphical interface builder contains 16,700 constraints [36].
Reference: 36. <author> Brad A. Myers, Dario A. Giuse, and Brad Vander Zanden. </author> <title> "Declarative Programming in a Prototype-Instance System: Object-Oriented Programming Without Writing Methods". </title> <journal> Sigplan Notices 27, </journal> <month> 10 (Oct. </month> <year> 1992), </year> <pages> 184-200. </pages> <booktitle> ACM Conference on Object-Oriented Programming Systems, Languages, and Applications; OOPSLA'92. </booktitle>
Reference-contexts: This includes the graphical object system, the handling of the input, all the widget libraries, and the higher-level interactive tools. For example, a Garnet text button widget contains 43 constraints internally and the Lapidary graphical interface builder contains 16,700 constraints <ref> [36] </ref>. In Garnet, constraints are used instead of methods to implement many types of behavior. <p> This emphasis on constraints helps define a new style of programming, one in which the focus is on computing data values instead of writing methods <ref> [36] </ref>. The desirability of this approach has been validated in practice. Garnet has over 100 users in over 60 projects who have used indirect reference constraints to generate numerous applications. Many of these applications contain thousands of indirect reference constraints.
Reference: 37. <author> Brad A. Myers. </author> <title> "Demonstrational Interfaces: A Step Beyond Direct Manipulation". </title> <booktitle> IEEE Computer 25, </booktitle> <month> 8 (Aug. </month> <year> 1992), </year> <pages> 61-73. </pages>
Reference-contexts: Pointers in Constraint Models - 7 - (a) (b) subtree rooted at b swapped with the subtree rooted at f. 2.5 Programming by Example Indirect reference constraints make it easier to implement systems that employ demonstrational programming <ref> [37] </ref>, such as the graphical interactive design tool Lapidary [32]. In a demonstrational system, a user draws an example picture or demonstrates an example behavior, and then the system creates a generalized prototype object or behavior by figuring out which values in the picture or behavior should be parameters.
Reference: 38. <author> Brad Myers, Dario A. Giuse, Andrew Mickish, and David Kosbie. </author> <title> Making Structured Graphics and Constraints Practical for Large-Scale Applications. </title> <note> Submitted for Publication. </note>
Reference-contexts: The variables on this path still maintain dependency pointers to the constraint, so that if one of these variables changes, the path can be reevaluated and a new value cached for it. Another optimization that has been used in Garnet is constant propagation <ref> [38] </ref>. The user is allowed to declare certain slots in an object to be constant. This information is then propagated by the constraint solver to other slots. <p> This technique saves both time and space, since fewer constraints must be evaluated and the storage for discarded constraints can be reclaimed. For example, constant propagation eliminates 30 of the 43 constraints in the text button discussed in Section 1 and results in a space savings of 27% <ref> [38] </ref>. Another implementation issue that arises is what to do with constraints containing pointer variables that are unbound or which reference deleted objects.
Reference: 39. <author> Greg Nelson. Juno, </author> <title> a Constraint-Based Graphics System. </title> <booktitle> Computer Graphics, Proceedings SIGGRAPH'85, </booktitle> <address> San Francisco, CA, </address> <month> July, </month> <year> 1985, </year> <pages> pp. 235-243. </pages>
Reference-contexts: 1 Introduction Many tools, including user interface toolkits [33, 13, 3, 5, 14], programming environments [40], and picture drawing tools <ref> [49, 39, 26, 2] </ref>, are increasingly integrating constraints into their programming models. A constraint denotes a relationship among two or more objects.
Reference: 40. <author> T. Reps, T. Teitelbaum, and A. Demers. </author> <title> "Incremental Context-Dependent Analysis for Language-Based Editors". </title> <journal> ACM TOPLAS 5, </journal> <month> 3 (July </month> <year> 1983), </year> <pages> 449-477. </pages>
Reference-contexts: 1 Introduction Many tools, including user interface toolkits [33, 13, 3, 5, 14], programming environments <ref> [40] </ref>, and picture drawing tools [49, 39, 26, 2], are increasingly integrating constraints into their programming models. A constraint denotes a relationship among two or more objects. <p> transaction i. i These dependency edges represent variables that the variables in affected depended on i in previous transactions but which are no longer depended on in transaction i. 4.2 Lazy Evaluation A lazy evaluation scheme for indirect reference constraints can be implemented using a variation of the nullification/reevaluation strategy <ref> [22, 40] </ref>. When the value of a variable changes, either by directly modifying the value or by installing a new formula in the variable, all variables that directly or indirectly depend on this changed variable are marked out-of-date (nullification phase). <p> If these variables are out-of-date, they will recursively demand the values of the variables they depend on, until eventually variables are reached whose values are up-to-date, at which point the constraints can compute their value and return <ref> [22, 40] </ref>. For example, suppose that the user changes the width of the selected object B in Figure 6.a. variables that can be reached from B.width are marked out-of-date. Figure 8.b shows the variables that will be reevaluated if the value of the label object's string attribute is requested.
Reference: 41. <author> T. Reps and T. Teitelbaum. </author> <title> The Synthesizer Generator. </title> <publisher> Springer-Verlag, </publisher> <address> New York, </address> <year> 1988. </year>
Reference-contexts: Many other systems, such as Sketchpad [47], CONSTRAINTS [46], Grow [3], Apogee [20], Peridot [31], COOL [26], the Cornell Synthesizer Generator <ref> [41] </ref>, MetaMouse [30], and CONSTRAINT [51], have used constraints but not pointer variables. Pointer variables have also been explored in several somewhat different constraint contexts.
Reference: 42. <author> Michael Sannella. </author> <title> The SkyBlue Constraint Solver. </title> <type> Tech. </type> <institution> Rept. 92-07-02, Computer Science Department, University of Washington, </institution> <month> July, </month> <year> 1992. </year>
Reference-contexts: Until recently, Pointers in Constraint Models - 48 - multi-way solvers were considered too slow to incorporate in user interface systems, but this has changed with the introduction of fast incremental solvers, such as IncrementalPdof [52], DeltaBlue [11], and SkyBlue <ref> [42] </ref>, and the use of optimization techniques such as constant propagation and plan caching [29, 9, 50]. However, each of these algorithms has drawbacks. <p> It is also be possible to build multi-way constraint systems that support indirect references, but which internally use direct reference algorithms. MultiGarnet, developed by Michael Sannella, is an experimental version of Garnet which uses such a scheme. MultiGarnet uses a direct reference algorithm called SkyBlue <ref> [42] </ref> that extends the DeltaBlue multi-way constraint algorithm [11] to handle multi-output constraints and to more gracefully handle cycles. MultiGarnet currently handles changes to indirect references by removing the changed constraint, and re-adding it with the updated reference.
Reference: 43. <author> Michael Sannella and Alan Borning. Multi-Garnet: </author> <title> Integrating Multi-Way Constraints with Garnet. </title> <type> Tech. </type> <institution> Rept. 92-07-01, Department of Computer Science and Engineering, University of Washington, </institution> <month> Sept., </month> <year> 1992. </year>
Reference-contexts: Garnet has over 100 users in over 60 projects who have used indirect reference constraints to generate numerous applications. Many of these applications contain thousands of indirect reference constraints. The success of indirect constraints in Garnet has inspired their use in many other systems including MultiGarnet <ref> [43] </ref>, Rendezvous [15], and Eval/vite [23]. Pointers in Constraint Models - 3 - The rest of this paper is organized as follows. The next section describes how a number of user interface applications can be implemented using indirect reference constraints.
Reference: 44. <author> V. A. Saraswat. </author> <title> Concurrent Constraint Programming Languages. </title> <type> Ph.D. </type> <institution> Th., School of Computer Science, </institution> <address> CMU, Pittsburgh, PA, </address> <year> 1989. </year>
Reference-contexts: Pointer variables have also been examined in the context of logic-oriented languages, such as CLP [24], Prolog3 [7], and Concurrent Constraint Programming <ref> [44] </ref>. Pointer variables can be represented 5 The Rendezvous constraint solver currently supports these programmer written specifications. The source expressions to be dynamically evaluated are specified by filling in code templates. Pointers in Constraint Models - 47 - as unbound variables that can be subsequently unified with some object.
Reference: 45. <author> Daniel D. Sleator and Paul F. Dietz. </author> <title> Two Algorithms for Maintaining Order in a List. </title> <type> Tech. </type> <institution> Rept. CMU-CS-88-113, Carnegie Mellon University, </institution> <month> September, </month> <year> 1988. </year>
Reference-contexts: As a result, the depth-first search will stop at this node on any future visits. In effect, the new position number is a visited mark, and thus an explicit visited field is not necessary. The position numbers are maintained in an ordered list using an algorithm described in <ref> [45] </ref>. Each node in the dataflow graph points to one of these position numbers.
Reference: 46. <author> Guy L. Steele, Jr. </author> <title> The Definition and Implementation of A Computer Programming Language based on Constraints. </title> <type> Ph.D. </type> <institution> Th., Department of Computer Science, MIT, </institution> <address> Boston, MA, </address> <year> 1980. </year>
Reference-contexts: Many other systems, such as Sketchpad [47], CONSTRAINTS <ref> [46] </ref>, Grow [3], Apogee [20], Peridot [31], COOL [26], the Cornell Synthesizer Generator [41], MetaMouse [30], and CONSTRAINT [51], have used constraints but not pointer variables. Pointer variables have also been explored in several somewhat different constraint contexts.
Reference: 47. <author> Ivan E. Sutherland. </author> <title> Sketchpad: A Man-Machine Graphical Communication System. </title> <booktitle> AFIPS Spring Joint Computer Conference, </booktitle> <year> 1963, </year> <pages> pp. 329-346. </pages>
Reference-contexts: As pointed out in Section 4.2.1, if edges are removed from the dependency graph before it is certain that they are no longer needed, it is not possible to guarantee that formulas will be properly evaluated in the future if they crash. Many other systems, such as Sketchpad <ref> [47] </ref>, CONSTRAINTS [46], Grow [3], Apogee [20], Peridot [31], COOL [26], the Cornell Synthesizer Generator [41], MetaMouse [30], and CONSTRAINT [51], have used constraints but not pointer variables. Pointer variables have also been explored in several somewhat different constraint contexts.
Reference: 48. <author> Pedro A. Szekely and Brad A. Myers. </author> <title> "A User Interface Toolkit Based on Graphical Objects and Constraints". </title> <journal> Sigplan Notices 23, </journal> <volume> 11 (Nov. </volume> <year> 1988), </year> <pages> 36-45. </pages> <booktitle> ACM Conference on Object-Oriented Programming; Systems Languages and Applications; OOPSLA'88. Pointers in Constraint Models - 52 </booktitle> - 
Reference-contexts: If one of the components in the structure hierarchy changes, the new object will be automatically referenced by the constraint. However, the constraint solving algorithm does not support arbitrary references to objects through pointer variables. Coral also supported a restricted version of indirect reference constraints <ref> [48] </ref>. Coral allowed designers to declare the slots of an object that could be used as pointer variables for indirect reference constraints. Designers could then define constraints that accessed objects indirectly via these variables, like Garnet allows. However, the Coral pointer variables were not completely integrated into the constraint system.
Reference: 49. <author> Christopher J. Van Wyk. </author> <title> "A High-level Language for Specifying Pictures". </title> <journal> ACM Transactions on Graphics 1, </journal> <month> 2 (April </month> <year> 1982), </year> <pages> 163-182. </pages>
Reference-contexts: 1 Introduction Many tools, including user interface toolkits [33, 13, 3, 5, 14], programming environments [40], and picture drawing tools <ref> [49, 39, 26, 2] </ref>, are increasingly integrating constraints into their programming models. A constraint denotes a relationship among two or more objects. <p> Rather, the old constraints are retracted and new constraints that reference the changed objects are added. The constraints themselves are still direct-reference constraints and the algorithms that satisfy them can only handle direct reference constraints. There are many domain-dependent constraint satisfiers, such as simultaneous linear equation solvers <ref> [49, 27, 28] </ref>, non-linear solvers [54, 8], and inequality solvers [25], that can solve more expressive constraints than one-way constraints, but they are less flexible, since they are typically limited to one domain, and they are slower on the subclass of constraints that one-way constraint satisfiers can solve.
Reference: 50. <author> Brad T. Vander Zanden. </author> <title> Incremental Constraint Satisfaction and Its Application to Graphical Interfaces. </title> <type> Ph.D. </type> <institution> Th., Cornell University, </institution> <address> Ithaca, NY, </address> <year> 1988. </year>
Reference-contexts: For example, suppose constraints control the layout of the binary tree in Figure 3.a and 1 that an application swaps two subtrees as shown in Figure 3.b The swap command can be implemented 1 The layout rules for the binary trees can be found in <ref> [50, pp. 286-287] </ref>. Pointers in Constraint Models - 6 - (a) (c) as a rectangle and some text (b). Each object maintains pointers to its parent and its children, so that constraints can indirectly reference objects through pointers. <p> Constraint Models - 48 - multi-way solvers were considered too slow to incorporate in user interface systems, but this has changed with the introduction of fast incremental solvers, such as IncrementalPdof [52], DeltaBlue [11], and SkyBlue [42], and the use of optimization techniques such as constant propagation and plan caching <ref> [29, 9, 50] </ref>. However, each of these algorithms has drawbacks. IncrementalPdof does not incorporate a management scheme like constraint hierarchies, and DeltaBlue and SkyBlue are not designed to find 6 solutions to a constraint graph with cycles .
Reference: 51. <author> Brad T. Vander Zanden. </author> <title> Constraint Grammars--A New Model for Specifying Graphical Applications. </title> <booktitle> Human Factors in Computing Systems, Proceedings SIGCHI'89, </booktitle> <address> Austin, TX, </address> <month> April, </month> <year> 1989, </year> <pages> pp. 325-330. </pages>
Reference-contexts: Many other systems, such as Sketchpad [47], CONSTRAINTS [46], Grow [3], Apogee [20], Peridot [31], COOL [26], the Cornell Synthesizer Generator [41], MetaMouse [30], and CONSTRAINT <ref> [51] </ref>, have used constraints but not pointer variables. Pointer variables have also been explored in several somewhat different constraint contexts.
Reference: 52. <author> Brad Vander Zanden. </author> <title> A Domain-Independent Algorithm for Incrementally Satisfying Multi-Way Constraints. </title> <type> Tech. </type> <institution> Rept. CS-92-160, University of Tennessee, </institution> <month> July, </month> <year> 1992. </year>
Reference-contexts: Both of these drawbacks arise from the need to first plan how to satisfy the constraints, before actually satisfying the constraints. Typically each constraint has multiple methods for solving it, and the plan selects one method for each constraint <ref> [11, 12, 52] </ref>. The methods are then executed in topological order, just as in one-way constraint solving. Thus the algorithms presented in this paper can be used in the evaluation phase of multi-way constraint satisfaction. <p> Until recently, Pointers in Constraint Models - 48 - multi-way solvers were considered too slow to incorporate in user interface systems, but this has changed with the introduction of fast incremental solvers, such as IncrementalPdof <ref> [52] </ref>, DeltaBlue [11], and SkyBlue [42], and the use of optimization techniques such as constant propagation and plan caching [29, 9, 50]. However, each of these algorithms has drawbacks.
Reference: 53. <author> Michael R. Wilk. "Equate: </author> <title> An Object-Oriented Constraint Solver". </title> <journal> Sigplan Notices 26, </journal> <volume> 11 (Nov. </volume> <year> 1991), </year> <pages> 286-298. </pages> <booktitle> ACM Conference on Object-Oriented Programming Systems, Languages, and Applications; OOPSLA'91. </booktitle>
Reference-contexts: These assertions and retractions allow the same constraints to be instantiated with different objects at different times. Term rewriting systems provide yet another means for representing pointer variables within constraints. Bertrand [27], Siri [18, 19], and Equate <ref> [53] </ref> are several examples of such systems. Term rewriting systems bear a certain resemblance to logic languages in that the user writes a set of rewrite rules, each of which contains a pattern as a ``head'', and one or more expressions as a ``body''.

References-found: 53

