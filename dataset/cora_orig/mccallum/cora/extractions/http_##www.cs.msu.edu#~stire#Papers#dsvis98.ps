URL: http://www.cs.msu.edu/~stire/Papers/dsvis98.ps
Refering-URL: http://www.cs.msu.edu/~stire/
Root-URL: http://www.cs.msu.edu
Title: Practical Dialogue Refinement  A  
Author: R. E. Kurt Stirewalt Gregory D. Abowd 
Keyword: Dialogue modeling, refinement, LOTOS  
Date: June 1998  
Note: U. S.  U. S. A To appear in: 5th Eurographics Workshop on Design, Specification, and Verification  
Address: East Lansing, Michigan 48824,  Atlanta, Georgia 30332-0280,  (DSV-IS'98), London, England,  
Affiliation: Department of Computer Science, Michigan State University  GVU Center College of Computing, Georgia Institute of Technology  of Interactive Systems  
Abstract: Researchers have suggested viewing interactive system design as the refinement of an abstract user-task model into an object-oriented interaction model[1, 14]. Inherent in this view is a shift in the nature of the behavior being modeled. We explore the manifestations of such a shift by critically analyzing properties of the forms used to represent task and interaction models. The analysis enabled us to uncover four obstacles to dialogue refinement. We believe that if designers cannot systematically address these obstacles, then the task-model refinement process of development will not be practical on any large scale. We then suggest a refinement framework that systematically deals with these obstacles and demonstrate it on a small, but significant example. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> L. Bass and J. Coutaz. </author> <title> Developing Software for the User Interface. SEI Series in Software Engineering. </title> <publisher> Addison-Wesley, </publisher> <year> 1991. </year>
Reference-contexts: 1 Introduction Dialogue refers to the two-way user-computer conversation of an interactive system [5]. Engineers require design methodologies to guide them in implementing this conversation in software. To answer this need, researchers have proposed interactive system life-cycle models, some of which <ref> [1, 14] </ref> characterize design as a process of refining dialogue from an abstract action-oriented form into a concrete object-oriented form. Inherent in these approaches is a design shift in the nature of behavior being modeled from one expression of the dialogue to its refinement. <p> This shift potentially makes dialogue refinement impractical as a means for developing interactive systems. In this paper, we explore the manifestations of this shift in order to assess the practicality of this process model. Both Bass and Coutaz <ref> [1] </ref> and Patern o [14] suggest viewing interactive system design as the refinement of an abstract user-task model into an object-oriented interaction model. Task models specify the temporal decomposition of tasks, and they generally represent the first specification of dialogue. Interaction models specify input device level operations and their orderings.
Reference: [2] <editor> F. Bodart et al. </editor> <title> Key activities for a development methodology of interactive applications. </title> <editor> In D. Benyon and P. Palanque, editors, </editor> <title> Critical Issues in User Interface Systems Engineering. </title> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1995. </year>
Reference: [3] <author> T. Bolognesi and E. Brinksma. </author> <title> Introduction to the ISO specification language LOTOS. </title> <journal> Computer Network ISDN Systems, </journal> <volume> 14(1), </volume> <year> 1987. </year>
Reference-contexts: Such a technique is complicated by the fact that task and interaction models are most naturally expressed in different notations. Task models, for example, are easily expressed in a temporal action language like LOTOS <ref> [3] </ref>. Interaction models, on the other hand, are easily expressed in an object-oriented language like the OMT [15] dynamic modeling notation. With models expressed in different notations, it is difficult to rigorously define refinement. <p> Moreover, with an existing application that we did not write, we will be able to make objective comparisons between analysis and design (future work). We propose a task model in which the rules of the game are represented in the LOTOS <ref> [3] </ref> notation. We express the interaction model using Harel-style state diagram notation [7] as used in the Object Modeling Technique (OMT) of Rumbaugh et-al.[15].
Reference: [4] <author> T. P. Browne et al. </author> <title> Using declarative descriptions to model user interfaces with MASTERMIND. </title> <editor> In F. Patern o and P. Palanque, editors, </editor> <title> Formal Methods in Human Computer Interaction. </title> <publisher> Springer-Verlag, </publisher> <year> 1997. </year>
Reference-contexts: Such techniques are critical to support systematic refinement. Other model-based approaches view task models as evolving entities within the life cycle of an interactive system. In MASTERMIND <ref> [12, 18, 4] </ref>, task models are one of three models used to generate user-interface code. In ADEPT [9, 20], task models are refined into implementation models for which there is a code generator.
Reference: [5] <author> A. J. Dix et al. </author> <title> Human-Computer Interaction. </title> <publisher> Prentice Hall, </publisher> <year> 1993. </year>
Reference-contexts: 1 Introduction Dialogue refers to the two-way user-computer conversation of an interactive system <ref> [5] </ref>. Engineers require design methodologies to guide them in implementing this conversation in software. To answer this need, researchers have proposed interactive system life-cycle models, some of which [1, 14] characterize design as a process of refining dialogue from an abstract action-oriented form into a concrete object-oriented form.
Reference: [6] <editor> J. D. Foley et al. </editor> <booktitle> Computer Graphics: Principles and Practice. </booktitle> <publisher> Addison Wesley, </publisher> <address> Reading, Massachusetts, </address> <year> 1997. </year>
Reference-contexts: The global user-computer conversation is cast into a carefully selected collection of interaction techniques, which blend presentation graphics and device behavior. Interaction techniques are difficult to design and implement <ref> [6] </ref>, and so they tend to be collected into toolkits and reused. We use the term interactor to define a customizable specification of an interaction technique. Interaction models are collections of interactors customized to a particular application and connected together to implement user tasks.
Reference: [7] <author> D. Harel. Statecharts: </author> <title> a visual formalism for complex systems. </title> <booktitle> Science of Computer Programming, </booktitle> <volume> 8, </volume> <year> 1987. </year>
Reference-contexts: We propose a task model in which the rules of the game are represented in the LOTOS [3] notation. We express the interaction model using Harel-style state diagram notation <ref> [7] </ref> as used in the Object Modeling Technique (OMT) of Rumbaugh et-al.[15].
Reference: [8] <author> P. Johnson. </author> <title> Human-Computer Interaction, Psychology, Task analysis, and Software Engineering. </title> <publisher> McGraw-Hill, </publisher> <address> London, </address> <year> 1991. </year>
Reference-contexts: The TRIDENT environment [19] supports the generation of systems from data mod-els (based on entity-relationship diagrams) and a behavior notation an activity chaining graph (ACG). Though TRIDENT does not contain an explicit task model, its representations are derived from a TKS <ref> [8] </ref> specified hierarchical task model. Bodart et al.[2] demonstrate how TKS models suggest entities and relationships, from which the data model can be derived, and temporal ordering cues from which the Activity Chaining Graph can be derived. Such techniques are critical to support systematic refinement.
Reference: [9] <author> P. Johnson et al. </author> <title> ADEPT advanced design environment for prototyping with task models. In Bridges Between Worlds: </title> <booktitle> Human Factors in Computing Systems: </booktitle> <address> INTERCHI'93, </address> <year> 1993. </year>
Reference-contexts: Such techniques are critical to support systematic refinement. Other model-based approaches view task models as evolving entities within the life cycle of an interactive system. In MASTERMIND [12, 18, 4], task models are one of three models used to generate user-interface code. In ADEPT <ref> [9, 20] </ref>, task models are refined into implementation models for which there is a code generator.
Reference: [10] <author> P. Markopoulos. </author> <title> On the expression of interaction properties within an interac-tor model. In Design Specification and Verification of Interactive Systems (DSV-IS'95), </title> <year> 1995. </year>
Reference-contexts: Paterno [13] defines an interactor as a software component with a fixed set of incoming and outgoing data-flow paths. These paths support the transfer of control, data, and presentation and may be connected to paths of the opposite polarity in other interactors. Markopoulos <ref> [10] </ref> uses a similar definition of interactor, but his are structured according to a different user-interface architecture. Markopoulos and Patern o define interactors formally as LOTOS processes. This is useful for reasoning about task refinement since task models can also be expressed in LOTOS.
Reference: [11] <author> B. A. Myers et al. </author> <title> The Amulet environment: New models for effective user interface software development. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 23(6):347365, </volume> <month> June </month> <year> 1997. </year>
Reference-contexts: Interactors in our framework encapsulate a complete gesture between the user and an input device like the mouse or keyboard. We represent these gestures using state diagrams much like those used in the Amulet environment <ref> [11] </ref>. Paterno [13] defines an interactor as a software component with a fixed set of incoming and outgoing data-flow paths. These paths support the transfer of control, data, and presentation and may be connected to paths of the opposite polarity in other interactors. <p> The formality offered by these methods allows us to isolate and precisely articulate model semantics which must be preserved by restructuring. Moreover, we can use this formal understanding to critique automated refinement frameworks. The subject application is an interactive checkers program taken from the Amulet <ref> [11] </ref> source distribution. We chose this application because the rules of the game are described at a level of abstraction that resembles the structure of an hierarchical task model. <p> In the latter, the Interim state represents any time in which the text entry interactor has keyboard focus, and the transition from Interim to Action is initiated by hitting the tab or return key. This generic topology is consistent with that used in the Amulet interactors <ref> [11] </ref>. As discussed in Section 5.2, action sequencing information must be preserved in the translation to interactors. Stirewalt [17] has demonstrated the feasibility of automatically generating this temporal information from a LOTOS specification. Task-level Fig. 8. Generic interactor behavior. dialogue is specified as the sequencing and temporal dependence of actions.
Reference: [12] <author> R. Neches et al. </author> <title> Knowledgeable development environments using shared design models. </title> <booktitle> In Intelligent Interfaces Workshop, </booktitle> <pages> pages 6370, </pages> <year> 1993. </year>
Reference-contexts: Such techniques are critical to support systematic refinement. Other model-based approaches view task models as evolving entities within the life cycle of an interactive system. In MASTERMIND <ref> [12, 18, 4] </ref>, task models are one of three models used to generate user-interface code. In ADEPT [9, 20], task models are refined into implementation models for which there is a code generator.
Reference: [13] <author> F. Patern o. </author> <title> A theory of user-interaction objects. </title> <journal> Journal of Visual Languages and Computing, </journal> <volume> 5:227249, </volume> <year> 1994. </year>
Reference-contexts: Interactors in our framework encapsulate a complete gesture between the user and an input device like the mouse or keyboard. We represent these gestures using state diagrams much like those used in the Amulet environment [11]. Paterno <ref> [13] </ref> defines an interactor as a software component with a fixed set of incoming and outgoing data-flow paths. These paths support the transfer of control, data, and presentation and may be connected to paths of the opposite polarity in other interactors.
Reference: [14] <author> F. Patern o and S. Meniconi. TLIM: </author> <title> a systematic method for the design of interactive systems. </title> <editor> In F. Patern o and P. Palanque, editors, </editor> <title> Formal Methods in Human Computer Interaction. </title> <publisher> Springer-Verlag, </publisher> <year> 1997. </year>
Reference-contexts: 1 Introduction Dialogue refers to the two-way user-computer conversation of an interactive system [5]. Engineers require design methodologies to guide them in implementing this conversation in software. To answer this need, researchers have proposed interactive system life-cycle models, some of which <ref> [1, 14] </ref> characterize design as a process of refining dialogue from an abstract action-oriented form into a concrete object-oriented form. Inherent in these approaches is a design shift in the nature of behavior being modeled from one expression of the dialogue to its refinement. <p> This shift potentially makes dialogue refinement impractical as a means for developing interactive systems. In this paper, we explore the manifestations of this shift in order to assess the practicality of this process model. Both Bass and Coutaz [1] and Patern o <ref> [14] </ref> suggest viewing interactive system design as the refinement of an abstract user-task model into an object-oriented interaction model. Task models specify the temporal decomposition of tasks, and they generally represent the first specification of dialogue. Interaction models specify input device level operations and their orderings. <p> Markopoulos and Patern o define interactors formally as LOTOS processes. This is useful for reasoning about task refinement since task models can also be expressed in LOTOS. Patern o defines a development methodology called TLIM for analyzing and transforming task models into system models <ref> [14] </ref>. The obstacles to dialogue refinement, which we present in Section 5, occur in these other interactor frameworks. 2.2 Multiple models and interactive system design The use of multiple models in the design of interactive systems is not new.
Reference: [15] <author> J. Rumbaugh et al. </author> <title> Object-Oriented Modeling and Design. </title> <publisher> Prentice-Hall, </publisher> <year> 1991. </year>
Reference-contexts: Task models, for example, are easily expressed in a temporal action language like LOTOS [3]. Interaction models, on the other hand, are easily expressed in an object-oriented language like the OMT <ref> [15] </ref> dynamic modeling notation. With models expressed in different notations, it is difficult to rigorously define refinement. This makes it is more difficult to assess whether or not the process is systematic and, therefore, practical. <p> Transitions in this diagram are concurrent transitions of the components separated by the dashed line. For brevity, Figure 4 only demonstrates control of one interactor instance, RED CHECKER # 3, but other instances are easily included by orthogonal state diagram composition (See Rumbaugh <ref> [15, pg. 99] </ref> for more details). This extension intrudes on the specification of interactors only minimally, but it does intrude. Specifically, transition conditions have been added to enable and disable the interactor, and the interactor must at some point issue an event which coerces the controller into a new state.
Reference: [16] <author> E. Schlungbaum and T. Elwert. </author> <title> Dialogue graphs: A formal and visual specification technique for dialogue modelling. </title> <booktitle> In Formal Aspects of the Human Computer Interface, BCS-FACS Workshop, </booktitle> <year> 1996. </year>
Reference-contexts: In MASTERMIND [12, 18, 4], task models are one of three models used to generate user-interface code. In ADEPT [9, 20], task models are refined into implementation models for which there is a code generator. The TADEUS <ref> [16] </ref> environment uses a visual representation called the Dialogue Graph to support automatic generation of interactive systems in a task-oriented development methodology. 2.3 Refinement through composition To refine a task model, designers must incorporate device interaction idioms and presentation structure into the user-computer conversation.
Reference: [17] <author> R. E. K. Stirewalt. </author> <title> Automatic Generation of Interactive Systems from Declarative Models. </title> <type> PhD thesis, </type> <institution> Georgia Institute of Technology, </institution> <year> 1997. </year>
Reference-contexts: This generic topology is consistent with that used in the Amulet interactors [11]. As discussed in Section 5.2, action sequencing information must be preserved in the translation to interactors. Stirewalt <ref> [17] </ref> has demonstrated the feasibility of automatically generating this temporal information from a LOTOS specification. Task-level Fig. 8. Generic interactor behavior. dialogue is specified as the sequencing and temporal dependence of actions.
Reference: [18] <author> P. Szekely et al. </author> <title> Declarative interface models for user interface construction tools : The MASTERMIND approach. </title> <editor> In L. Bass and C. Unger, editors, </editor> <title> Engineering for Human-Computer Interaction. </title> <publisher> Chapman & Hall, </publisher> <year> 1996. </year>
Reference-contexts: The model-based approach to design bases system analysis, design, and implementation on a common repository of models. Developers using this approach build models that describe the desired system, rather than writing a program that exhibits the behavior <ref> [18] </ref>. The TRIDENT environment [19] supports the generation of systems from data mod-els (based on entity-relationship diagrams) and a behavior notation an activity chaining graph (ACG). Though TRIDENT does not contain an explicit task model, its representations are derived from a TKS [8] specified hierarchical task model. <p> Such techniques are critical to support systematic refinement. Other model-based approaches view task models as evolving entities within the life cycle of an interactive system. In MASTERMIND <ref> [12, 18, 4] </ref>, task models are one of three models used to generate user-interface code. In ADEPT [9, 20], task models are refined into implementation models for which there is a code generator.
Reference: [19] <author> J. M. Vanderdonckt and F. </author> <title> Bodart. Encapsulating knowledge for intelligent automatic interaction objects selection. In Bridges Between Worlds: </title> <booktitle> Human Factors in Computing Systems: </booktitle> <address> INTERCHI'93, </address> <year> 1993. </year>
Reference-contexts: The model-based approach to design bases system analysis, design, and implementation on a common repository of models. Developers using this approach build models that describe the desired system, rather than writing a program that exhibits the behavior [18]. The TRIDENT environment <ref> [19] </ref> supports the generation of systems from data mod-els (based on entity-relationship diagrams) and a behavior notation an activity chaining graph (ACG). Though TRIDENT does not contain an explicit task model, its representations are derived from a TKS [8] specified hierarchical task model.
Reference: [20] <author> S. Wilson et al. </author> <title> Beyond hacking: A model based approach to user interface de-sign. </title> <editor> In J. L. Alty, D. Diaper, and S. Guest, editors, </editor> <booktitle> People and Computers VIII, Proceedings of the HCI '93 Conference, </booktitle> <year> 1993. </year>
Reference-contexts: Such techniques are critical to support systematic refinement. Other model-based approaches view task models as evolving entities within the life cycle of an interactive system. In MASTERMIND [12, 18, 4], task models are one of three models used to generate user-interface code. In ADEPT <ref> [9, 20] </ref>, task models are refined into implementation models for which there is a code generator.
Reference: [21] <author> P. Zave and M. Jackson. </author> <title> Conjunction as composition. </title> <journal> ACM Transactions on Software Engineering and Methodology, </journal> <volume> 2(4):371411, </volume> <year> 1993. </year>
Reference-contexts: Interactors, the building blocks of interaction models, are partial specifications of system functionality expressed in a notation that conveniently encodes input device behavior. In Section 6, we outline a strategy for systematically managing task refinement by treating task and interactor specifications as constraints that compose by conjunction <ref> [21] </ref>. Composition by conjunction allows partial specifications to influence each other directly through a shared vocabulary.
Reference: [22] <author> P. Zave and M. Jackson. </author> <title> Where do operations come from? a multiparadigm specification technique. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 22(7):508 528, </volume> <month> July </month> <year> 1996. </year>
Reference-contexts: For the task sequencing to be preserved, this addition of information cannot violate the model's meaning. We view this as a classic multi-paradigm specification problem <ref> [22] </ref>. The task model is a partial specification of system functionality expressed in a notation that conveniently encodes complex sequencing behavior. Interactors, the building blocks of interaction models, are partial specifications of system functionality expressed in a notation that conveniently encodes input device behavior.
References-found: 22

