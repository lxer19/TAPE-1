URL: ftp://ftp.cs.umass.edu/pub/lesser/neiman-jpdc.ps
Refering-URL: http://dis.cs.umass.edu/~dann/dann-pubs.html
Root-URL: 
Email: DANN@CS.UMASS.EDU  
Title: Issues in the Design and Control of Parallel Rule-Firing Production Systems  
Author: Daniel E. Neiman 
Date: December 28, 1993  
Address: Amherst, MA 01003  
Affiliation: Computer Science Department University of Massachusetts  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> Daniel D. Corkill. </author> <title> Design alternatives for parallel and distributed blackboard systems. </title> <editor> In V. Ja-gannathan, Rajendra Dodhiawala, and Lawrence S. Baum, editors, </editor> <booktitle> Blackboard Architectures and Applications, </booktitle> <pages> pages 99-136. </pages> <publisher> Academic Press, </publisher> <year> 1989. </year>
Reference-contexts: A region lock typically prohibits access to a class of working memory elements, possibly restricted by value and, depending on the precision with which the region can be identified, may prove unduly pessimistic in restricting access to working memory <ref> [ 1, 2 ] </ref> . UMPOPS provides a mechanism similar in nature to region locking that allows a single working memory element to be locked, even before that element has been created.
Reference: [2] <author> R. D. Fennell and V. R. Lesser. </author> <title> Parallelism in AI problem solving: A case study of Hearsay-II. </title> <journal> IEEE Transactions on Computers, </journal> <volume> C-26(2):198-111, </volume> <month> February </month> <year> 1977. </year>
Reference-contexts: A region lock typically prohibits access to a class of working memory elements, possibly restricted by value and, depending on the precision with which the region can be identified, may prove unduly pessimistic in restricting access to working memory <ref> [ 1, 2 ] </ref> . UMPOPS provides a mechanism similar in nature to region locking that allows a single working memory element to be locked, even before that element has been created.
Reference: [3] <author> C. L. Forgy. </author> <title> OPS5 user's manual. </title> <type> Technical Report CMU-CS-81-135, </type> <institution> CMU Computer Science Department, </institution> <month> July </month> <year> 1981. </year>
Reference-contexts: Stonebraker, Sellis, and Hanson in a system that used database locking techniques to detect rules that should be triggered following database updates [ 31 ] . 6 There are cases in which one rule will always disable another; in such cases, interaction detection algorithms need 13 In the Rete net <ref> [ 3 ] </ref> , when a working memory element is positively matched, a token representing that element is concatenated to a set of tokens being propagated through the network. We can similarly create a pseudo-token corresponding to a successful match of a negated element.
Reference: [4] <author> Anoop Gupta. </author> <title> Parallelism in Production Systems. </title> <publisher> Morgan Kaufmann Publishers, </publisher> <address> Los Altos, CA, </address> <year> 1987. </year>
Reference-contexts: The beta nodes are the most time-consuming component of the pattern matching process and the number of beta nodes executed can be used to create an estimate of relative costs. Using the statistics gathered by Gupta <ref> [ 4 ] </ref> , we note that the average rule instantiation activates approximately 40 beta node and memory operations, with the actual figures, of course, depending on the size and complexity of the lefthand side conditions.
Reference: [5] <author> Wilson Harvey, Dirk Kalp, Milind Tambe, David McKeown, and Allen Newell. </author> <title> The effectiveness of task-level parallelism for production systems. </title> <journal> Journal of Parallel and Distributed Computing, </journal> <volume> 13(4) </volume> <pages> 395-411, </pages> <month> December </month> <year> 1991. </year>
Reference-contexts: resolution policies to concurrently executing groups of instantiations is similar to the Multiple-Context-Multiple-Rule (MCMR) control scheme developed by Kuo and Moldovan [ 12 ] or Ishida's rulesets [ 7 ] although the division of processing into semantically distinct tasks more closely resembles the application parallelism discussed by Harvey, et al. <ref> [ 5 ] </ref> . Control tasks not only allow localized control mechanisms to be applied to specific sets of rule instances, but also present a partial solution to the problem of determining local quiescence in a computation.
Reference: [6] <author> T. Ishida and S. Stolfo. </author> <title> Towards the parallel execution of rules in production system programs. </title> <booktitle> In Proceedings of the IEEE International Conference on Parallel Processing, </booktitle> <pages> pages 568-575, </pages> <year> 1985. </year>
Reference-contexts: Although this approach does not guarantee correctness and places a design burden on the programmer, we justify the approach by analyzing the overhead of guaranteeing correctness and comparing its overhead to a design-oriented approach. 3.1 Guaranteeing Serializability: Previous Work Ishida and Stolfo <ref> [ 6 ] </ref> first identified the compatibility problem underlying parallel rule execution. If multiple productions execute simultaneously, they may interact in pathological ways, causing corruption of the working memory and incorrect results. Ishida and Stolfo's solution to this problem was to produce, at compile-time, a compatibility matrix.
Reference: [7] <author> Toru Ishida. </author> <title> Methods and effectiveness of parallel rule firing. </title> <booktitle> In Sixth IEEE Conference on Artificial Intelligence Applications, </booktitle> <month> March </month> <year> 1990. </year>
Reference-contexts: The ability to assign rule-firing and conflict resolution policies to concurrently executing groups of instantiations is similar to the Multiple-Context-Multiple-Rule (MCMR) control scheme developed by Kuo and Moldovan [ 12 ] or Ishida's rulesets <ref> [ 7 ] </ref> although the division of processing into semantically distinct tasks more closely resembles the application parallelism discussed by Harvey, et al. [ 5 ] .
Reference: [8] <author> Toru Ishida. </author> <title> Parallel rule firing in production systems. </title> <journal> IEEE Transactions on Knowledge and Data Engineering, </journal> <month> March </month> <year> 1991. </year>
Reference-contexts: The scheduler then ensures that all domain rules have executed before allowing a mode-changing rule to fire. Similar mechanisms have been independently derived by a number of researchers <ref> [ 8, 12, 18, 23 ] </ref> .
Reference: [9] <author> Leonard Kleinrock. </author> <title> Queueing Systems, Volume I: Theory. </title> <publisher> John Wiley and Sons, </publisher> <year> 1975. </year>
Reference-contexts: When evaluating the behavior of this architecture in terms of maximum rule throughput, we can assume that rules are generated as fast as they can be executed, and that rules fire as soon as they become eligible. This is equivalent to modeling the rule-firing architecture as an M=M=1 queue <ref> [ 9 ] </ref> . If we assume an infinite (or very large) number of servers to execute rules and that parallel matching takes place independently, by Amdahl's Law, the limiting factor in the system will be the rate at which rules can be placed in the execution queues.
Reference: [10] <author> Vipin Kumar, K. Ramesh, and V. Nageshwara Rao. </author> <title> Parallel best-first search of state-space graphs: A summary of results. </title> <booktitle> In Proceedings of the Seventh National Conference on Artificial Intelligence, </booktitle> <pages> pages 122-127, </pages> <year> 1988. </year>
Reference-contexts: Executing rules asynchronously just means that a certain amount of this work takes place before the solution is found. An analysis of this aspect of the parallel nature of the travelling salesperson problem can be found in <ref> [ 10 ] </ref> . 4.2.3 Merging Solutions The Travelling Salesperson problem was developed primarily to illustrate two points about parallel rule-firing; the elimination of the need for rule interference detection by partitioning the problem into independent states (this idea is developed further in [ 20 ] ) and the idiom for
Reference: [11] <author> Chin-Ming Kuo, Daniel Miranker, and James C. Browne. </author> <title> On the performance of the CREL system. </title> <journal> Journal of Parallel and Distributed Computing, </journal> <volume> 13(4) </volume> <pages> 424-441, </pages> <month> December </month> <year> 1991. </year>
Reference-contexts: different tasks can fire asynchronously and in parallel; however they are not guaranteed to access discrete resources, so locking of working memory elements accessed within tasks is necessary. 2 This possible interaction between tasks distinguishes UMPOPS's tasks from Miranker and Kuo's notion of a set of independent clusters firing asynchronously <ref> [ 14, 11 ] </ref> . <p> An extended version of the analysis of one of the three algorithms described in the latter work is contained in Section 3.3. Most, if not all, contemporary parallel rule-firing systems reported in the literature (e.g. <ref> [ 11, 12, 29 ] </ref> ) employ some form of rule-interaction analysis. Of these, the most innovative approach is taken in the PARULEL system [ 29 ] . The designers of PARULEL reject conventional conflict resolution control mechanisms in favor of a meta-rule oriented approach to control. <p> Previous schemes for detecting interactions between rule instantiations due to negated elements have relied on run-time interaction detection using specific tests developed during a compile-time analysis, e.g. <ref> [ 11, 23 ] </ref> .
Reference: [12] <author> Steve Kuo and Dan Moldovan. </author> <title> Implementation of multiple rule firing production systems on hypercube. </title> <booktitle> In Proceedings of the Ninth National Conference on Artificial Intelligence, </booktitle> <pages> pages 305-309, </pages> <year> 1991. </year>
Reference-contexts: The scheduler then ensures that all domain rules have executed before allowing a mode-changing rule to fire. Similar mechanisms have been independently derived by a number of researchers <ref> [ 8, 12, 18, 23 ] </ref> . <p> The ability to assign rule-firing and conflict resolution policies to concurrently executing groups of instantiations is similar to the Multiple-Context-Multiple-Rule (MCMR) control scheme developed by Kuo and Moldovan <ref> [ 12 ] </ref> or Ishida's rulesets [ 7 ] although the division of processing into semantically distinct tasks more closely resembles the application parallelism discussed by Harvey, et al. [ 5 ] . <p> An extended version of the analysis of one of the three algorithms described in the latter work is contained in Section 3.3. Most, if not all, contemporary parallel rule-firing systems reported in the literature (e.g. <ref> [ 11, 12, 29 ] </ref> ) employ some form of rule-interaction analysis. Of these, the most innovative approach is taken in the PARULEL system [ 29 ] . The designers of PARULEL reject conventional conflict resolution control mechanisms in favor of a meta-rule oriented approach to control.
Reference: [13] <author> Steve Kuo and Dan Moldovan. </author> <title> The state of the art in parallel production systems. </title> <journal> The Journal of Parallel and Distributed Computing, </journal> <volume> 15(1) </volume> <pages> 1-26, </pages> <month> May </month> <year> 1992. </year>
Reference: [14] <author> Daniel Miranker, Chin-Ming Kuo, and James C. Browne. </author> <title> Parallelizing transformations for a concurrent rule execution language. </title> <type> Technical Report TR-89-30, </type> <institution> Department of Computer Science, University of Texas at Austin, </institution> <month> October </month> <year> 1989. </year> <month> 29 </month>
Reference-contexts: different tasks can fire asynchronously and in parallel; however they are not guaranteed to access discrete resources, so locking of working memory elements accessed within tasks is necessary. 2 This possible interaction between tasks distinguishes UMPOPS's tasks from Miranker and Kuo's notion of a set of independent clusters firing asynchronously <ref> [ 14, 11 ] </ref> .
Reference: [15] <author> Daniel P. Miranker. </author> <title> An algorithmic basis for integrating production systems and large databases. </title> <booktitle> In Proceedings of the Sixth International Conference on Data Engineering, </booktitle> <address> Los Angeles, CA, </address> <month> February </month> <year> 1990. </year>
Reference-contexts: The primary difficulty in developing parallel Alexsys was in managing large amounts of data and allocating this data in a fair manner to competing processes; perhaps the current research in integrating production and database systems (e.g. <ref> [ 15 ] </ref> ) will ease this problem in future rule-based systems. 4.5 Summary of Experiments This section has examined three programs modified to take advantage of parallel rule execution: Toru-Waltz, Travelling Salesperson, and Alexsys.
Reference: [16] <author> D. I. Moldovan. Rubic: </author> <title> a multiprocessor for rule-based systems. </title> <journal> IEEE Transactions on Systems, Man, and Cybernetics, </journal> <volume> 19(4) </volume> <pages> 699-706, </pages> <month> July/August </month> <year> 1989. </year>
Reference: [17] <author> Daniel Neiman. </author> <title> Control issues in parallel rule-firing production systems. </title> <booktitle> In Proceedings of the Ninth National Conference on Artificial Intelligence, </booktitle> <pages> pages 310-316, </pages> <year> 1991. </year>
Reference-contexts: There are other control issues raised by parallel rule-firing, for example, the development of righthand side mapping and iteration constructs and a set-oriented syntax that eliminates the need for sequences of serial rule-firings (and consequent manipulation of the conflict resolution routines) to implement loops <ref> [ 32, 17 ] </ref> . Issues raised by introducing heuristic control mechanisms into an asynchronous rule-firing system are touched upon briefly in Section 4.2 and in more detail in [ 19 ] .
Reference: [18] <author> Daniel Neiman. </author> <title> Parallel OPS5 user's manual and technical report. </title> <type> COINS Technical Report 92-28 (Supersedes TR 91-1), </type> <institution> Computer and Information Sciences Dept., University of Massachusetts, </institution> <month> April </month> <year> 1992. </year>
Reference-contexts: UMPOPS contains a number of language constructs designed to support parallel design; these are documented in depth in <ref> [ 18 ] </ref> and [ 19 ] . UMPOPS is designed around the idea that the ideal architecture for a parallel rule-firing system is one in which rules fire as soon as they become eligible, thereby ensuring the maximum usage of processing resources. <p> The scheduler then ensures that all domain rules have executed before allowing a mode-changing rule to fire. Similar mechanisms have been independently derived by a number of researchers <ref> [ 8, 12, 18, 23 ] </ref> . <p> To avoid such race conditions, local synchronization operators have been added to UMass Parallel OPS5; these operators are described in detail in <ref> [ 18 ] </ref> . 2.2 Control Tasks It is likely that the programmer will occasionally wish to perform synchronous conflict resolution within the context of certain tasks or sequences of rule firings, while allowing other activities to take place asynchronously. <p> the computation can overlap or be pipelined, the use of mode elements can cause unnecessary serialization of the computation; in these cases, the rules in the overlapping stages should be placed in the same partition so that they may fire asynchronously. 9 The text of these benchmarks is included in <ref> [ 18 ] </ref> and [ 19 ] . 18 The use of modal working memory elements can seriously slow down a computation because otherwise eligible productions can not enter the conflict set until the mode of the element is changed.
Reference: [19] <author> Daniel E. Neiman. </author> <title> Design and Control of Parallel Rule-Firing Production Systems. </title> <type> PhD thesis, </type> <institution> University of Massachusetts, </institution> <month> September </month> <year> 1992. </year>
Reference-contexts: UMPOPS contains a number of language constructs designed to support parallel design; these are documented in depth in [ 18 ] and <ref> [ 19 ] </ref> . UMPOPS is designed around the idea that the ideal architecture for a parallel rule-firing system is one in which rules fire as soon as they become eligible, thereby ensuring the maximum usage of processing resources. <p> Issues raised by introducing heuristic control mechanisms into an asynchronous rule-firing system are touched upon briefly in Section 4.2 and in more detail in <ref> [ 19 ] </ref> . <p> The architecture of this system is illustrated in Figure 7. The program used to test the performance of the locking mechanism 8 is a version of Toru-Waltz, an implementation of the Waltz line-labelling algorithm implemented in OPS5 by Toru Ishida (see <ref> [ 19 ] </ref> for a full description of this program). Two versions of Toru-Waltz were implemented, one version that requires locking only positive condition elements, and one version that requires checking for disabling conditions on negative condition elements. <p> The design of these programs demonstrates techniques for avoiding or resolving rule interactions by taking advantage of the semantics of the computation. Space limitations prohibit a complete discussion of these programs, a more complete design discussion may be found in <ref> [ 19 ] </ref> . The first benchmark, a rule-based implementation of the Waltz line filtering algorithm [ 33 ] , was originally written by Toru Ishida and is called Toru-Waltz. <p> or be pipelined, the use of mode elements can cause unnecessary serialization of the computation; in these cases, the rules in the overlapping stages should be placed in the same partition so that they may fire asynchronously. 9 The text of these benchmarks is included in [ 18 ] and <ref> [ 19 ] </ref> . 18 The use of modal working memory elements can seriously slow down a computation because otherwise eligible productions can not enter the conflict set until the mode of the element is changed.
Reference: [20] <author> Daniel E. Neiman. </author> <title> A multiple worlds implementation for parallel rule-firing production systems, </title> <month> August </month> <year> 1992. </year> <note> Technical Report in preparation. </note>
Reference-contexts: travelling salesperson problem can be found in [ 10 ] . 4.2.3 Merging Solutions The Travelling Salesperson problem was developed primarily to illustrate two points about parallel rule-firing; the elimination of the need for rule interference detection by partitioning the problem into independent states (this idea is developed further in <ref> [ 20 ] </ref> ) and the idiom for merging results from parallel search processes. Eventually, each parallel search path that has not been pruned terminates and posts a possible solution.
Reference: [21] <author> A. Pasik and S. Stolfo. </author> <title> Improving production system performance on parallel architectures by creating constrained copies of rules. </title> <type> Technical report, </type> <institution> Computer Science Dept., Columbia University, </institution> <year> 1987. </year>
Reference-contexts: Contention for memory nodes can be decreased through the use of compilation techniques, for example, the copy and constrain algorithm devised by Pasik <ref> [ 21 ] </ref> could be used to split bottleneck nodes into two or more equivalent nodes.
Reference: [22] <author> Judea Pearl. </author> <title> Heuristics: Intelligent Search Strategies for Computer Problem Solving. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, Massachusetts, </address> <year> 1984. </year>
Reference-contexts: There are a number of well-known admissible heuristics for ordering the traversal of the search space in TSP; the one chosen for this example is the minimum spanning tree (MST) <ref> [ 22 ] </ref> . Rules are placed in the execution priority queue according to the value returned by the MST heuristic.
Reference: [23] <author> James G. Schmolze. </author> <title> Guaranteeing serializable results in synchronous parallel production systems. </title> <journal> Journal of Parallel and Distributed Computing, </journal> <volume> 13(4), </volume> <month> December </month> <year> 1991. </year>
Reference-contexts: The scheduler then ensures that all domain rules have executed before allowing a mode-changing rule to fire. Similar mechanisms have been independently derived by a number of researchers <ref> [ 8, 12, 18, 23 ] </ref> . <p> Rules that could potentially interfere with each other were labelled as incompatible. At run time, this table was used to prevent incompatible rules from being executed simultaneously, thus conflicts were avoided. It was later demonstrated by Schmolze <ref> [ 23 ] </ref> that this algorithm was unduly pessimistic in the set of rules that it allowed to coexecute. <p> The result is that there is a trade-off between the cost and precision of interaction detection algorithms. Order statistics for Schmolze's algorithm are provided in <ref> [ 23 ] </ref> and an estimate of the effect of these algorithms were presented in [ 24 ] . An extended version of the analysis of one of the three algorithms described in the latter work is contained in Section 3.3. <p> In contrast, the overhead associated with the schemes proposed by Schmolze and others is at best O (N 2 ) where N is the number of instantiations in the eligibility set <ref> [ 23 ] </ref> . 3 As will be seen in the following section, guaranteeing full serializability using an expanded locking scheme may impose a serial delay of as much as 10% of rule execution time, thus limiting the maximum obtainable parallelism to a factor of 10. <p> Previous schemes for detecting interactions between rule instantiations due to negated elements have relied on run-time interaction detection using specific tests developed during a compile-time analysis, e.g. <ref> [ 11, 23 ] </ref> .
Reference: [24] <author> James G. Schmolze and Daniel E. Neiman. </author> <title> Comparison of three algorithms for ensuring serializability in parallel production systems. </title> <booktitle> In Proceedings of the National Conference on Artificial Intelligence (AAAI-92), </booktitle> <month> July </month> <year> 1992. </year>
Reference-contexts: The result is that there is a trade-off between the cost and precision of interaction detection algorithms. Order statistics for Schmolze's algorithm are provided in [ 23 ] and an estimate of the effect of these algorithms were presented in <ref> [ 24 ] </ref> . An extended version of the analysis of one of the three algorithms described in the latter work is contained in Section 3.3. <p> rules scheduled for execution to be a small multiple of the number of available processors when executing rules synchronously. 4 Interaction detection does not necessarily imply synchronization; Schmolze has recently developed an asynchronous version of his interaction detection algorithm in which eligible rules are checked against only currently executing rules. <ref> [ 24 ] </ref> . 11 No compile-time analysis is required: Because all working memory elements read or written by a rule instantiation are automatically determined at run-time, no compile-time analysis is required. <p> These tests are applied to potentially executable instantiations on a pair-wise basis with all other eligible instantiations. (In Schmolze's asynchronous algorithm <ref> [ 24 ] </ref> , the eligible instantiation is compared against all currently executing rules in order to confirm that none of their working memory modifications will disable it.) When examined, the comparison tests which are applied to eligible rules look very similar to those tests performed within the pattern matcher, and
Reference: [25] <author> Timos Sellis, Chih-Chen Lin, and Louiqa Raschid. </author> <title> Implementing large production systems in a dbms environment: Concepts and algorithms. </title> <type> Technical Report CS-TR-1960, </type> <institution> Dept. of Computer Science, University of Maryland at College Park, </institution> <year> 1987. </year>
Reference-contexts: a possible race condition within the Rete net. 3.2.1 Region Locks and the Make-Unique Construct The concept of locking elements to prevent interactions due to concurrent modifications is widely used in database systems and a similar scheme to the one just described has been implemented in a DBMS-based production system <ref> [ 25 ] </ref> . This implementation uses region locks to prevent interactions due to negative conditions.
Reference: [26] <author> William Siler, Douglas Tucker, and James Buckley. </author> <title> A parallel rule firing fuzzy production system with resolution of memory conflicts by weak fuzzy monotonicity, applied to the classification of multiple objects characterized by multiple uncertain features. </title> <journal> International Journal of Man-Machine Studies, </journal> <volume> 26 </volume> <pages> 321-332, </pages> <year> 1987. </year>
Reference-contexts: As will be seen in Section 4.2.3, the make-unique mechanism is crucial for implementing common programming idioms such as merging the results of a parallel search. Other schemes for resolving conflicts at a local level have been developed. For example, <ref> [ 26 ] </ref> describes a method for resolving conflicts in working memory assignments by allowing only changes that allow the working memory element to approach an ideal value. 3.2.2 Principal Advantages of a Working Memory Locking Scheme The working memory locking scheme presents a number of advantages over the serializability guarantees
Reference: [27] <author> J. Srivastava and J.-H. Wang. </author> <title> A transaction model for parallel production systems. </title> <type> Technical Report AHPCRC TR 91-17, </type> <institution> University of Minnesota, </institution> <year> 1991. </year>
Reference-contexts: One final approach to maintaining correctness has been proposed by Srivastava and Wang <ref> [ 27 ] </ref> . Based on a transaction model of processing, this algorithm adds a commit phase to rule execution.
Reference: [28] <author> Salvatore J. Stolfo, Hasanat M. Dewan, and Ouri Wolfson. </author> <title> The PARULEL parallel rule language. </title> <booktitle> In 1991 International Conference on Parallel Processing, </booktitle> <pages> pages II-36-45, </pages> <year> 1991. </year> <month> 30 </month>
Reference-contexts: The advantage of the meta-rules is that the definition of conflict is left up to the programmer and thus the detection of rule interactions can be based on more than simple syntactic features of rules (given that a suitable vocabulary for expressing conflicts is provided). As reported in <ref> [ 29, 28 ] </ref> simulations of the performance of the PARULEL system on various benchmarks indicate that the meta-redaction model provides considerable parallelism, however this parallelism is measured only in reduction of production cycles and not actual run time. <p> There are many subtle aspects of the allocation process that are not germane to the discussion at hand; for a more complete description of the Alexsys system and its potential for parallel speedup, see <ref> [ 28, 30 ] </ref> . In Alexsys, the control structure of the process by which pools are assigned to contracts is divided into three major parts: initialization, pool allocation, and report generation.
Reference: [29] <author> Salvatore J. Stolfo, Ouri Wolfson, Philip K. Chan, Hasanat M. Dewan, Leland Woodbury, Jason S. Glazier, and David A Ohsie. PARULEL: </author> <title> Parallel rule processing using meta-rules for redaction. </title> <journal> Journal of Parallel and Distributed Computing, </journal> <volume> 13(4) </volume> <pages> 366-382, </pages> <month> December </month> <year> 1991. </year>
Reference-contexts: An extended version of the analysis of one of the three algorithms described in the latter work is contained in Section 3.3. Most, if not all, contemporary parallel rule-firing systems reported in the literature (e.g. <ref> [ 11, 12, 29 ] </ref> ) employ some form of rule-interaction analysis. Of these, the most innovative approach is taken in the PARULEL system [ 29 ] . The designers of PARULEL reject conventional conflict resolution control mechanisms in favor of a meta-rule oriented approach to control. <p> Most, if not all, contemporary parallel rule-firing systems reported in the literature (e.g. [ 11, 12, 29 ] ) employ some form of rule-interaction analysis. Of these, the most innovative approach is taken in the PARULEL system <ref> [ 29 ] </ref> . The designers of PARULEL reject conventional conflict resolution control mechanisms in favor of a meta-rule oriented approach to control. These meta-rules redact or eliminate offending rules from the conflict set. <p> The advantage of the meta-rules is that the definition of conflict is left up to the programmer and thus the detection of rule interactions can be based on more than simple syntactic features of rules (given that a suitable vocabulary for expressing conflicts is provided). As reported in <ref> [ 29, 28 ] </ref> simulations of the performance of the PARULEL system on various benchmarks indicate that the meta-redaction model provides considerable parallelism, however this parallelism is measured only in reduction of production cycles and not actual run time. <p> Stolfo and colleagues have investigated the use of the meta-rule constructs of the PARULEL system to eliminate the need for mode-changing operations; their results are reported in <ref> [ 29 ] </ref> .
Reference: [30] <author> Salvatore J. Stolfo, Leland Woodbury, Jason Glazier, and Philip Chan. </author> <title> The ALEXSYS mortgage pool allocation expert system: A case study of speeding up rule-based programs. </title> <booktitle> In AI and Business Workshop, AAAI-90, </booktitle> <year> 1990. </year>
Reference-contexts: that contention. 4.4 Alexsys: Parallelization of a Real-World Rule-based System This section investigates the issues involved in parallelizing Alexsys, a rule-based system developed at Columbia University in conjunction with Citicorp to handle the problem of fulfilling contracts to trade pools of mortgages in such a way as to maximize profit <ref> [ 30 ] </ref> . <p> There are many subtle aspects of the allocation process that are not germane to the discussion at hand; for a more complete description of the Alexsys system and its potential for parallel speedup, see <ref> [ 28, 30 ] </ref> . In Alexsys, the control structure of the process by which pools are assigned to contracts is divided into three major parts: initialization, pool allocation, and report generation. <p> This last sequentiality, as was reported in <ref> [ 30 ] </ref> , is caused by the need to update working memory elements acting as state variables to record the progress of the solution, in particular, the amount of millions allocated to a contract, and the amount still required. <p> For the record, the version of Alexsys discussed in <ref> [ 30 ] </ref> , which used the same data set reported on here, executed in 4.15 minutes, achieving a profit of 95.6% of the theoretical maximum.
Reference: [31] <author> M. Stonebraker, T. Sellis, and E. Hanson. </author> <title> An analysis of rule indexing implementations in data base systems. </title> <editor> In L. Kershberg, editor, </editor> <booktitle> Expert Database Systems: Proceedings of the First International Workshop, </booktitle> <pages> pages 353-363. </pages> <publisher> Benjamin/Cummings Publishing Company, </publisher> <address> Menlo Park, CA, </address> <year> 1986. </year>
Reference-contexts: any modifications to either the algorithms or the implementation language. 6 5 The similarity between locking and pattern-matching in rule-based systems was exploited in the opposite direction by Stonebraker, Sellis, and Hanson in a system that used database locking techniques to detect rules that should be triggered following database updates <ref> [ 31 ] </ref> . 6 There are cases in which one rule will always disable another; in such cases, interaction detection algorithms need 13 In the Rete net [ 3 ] , when a working memory element is positively matched, a token representing that element is concatenated to a set of
Reference: [32] <author> M. van Biema, D. P. Miranker, and S. J. Stolfo. </author> <title> The do-loop considered harmful in production system programming. </title> <booktitle> In First International Conference on Expert Database Systems, </booktitle> <pages> pages 88-97, </pages> <year> 1986. </year>
Reference-contexts: There are other control issues raised by parallel rule-firing, for example, the development of righthand side mapping and iteration constructs and a set-oriented syntax that eliminates the need for sequences of serial rule-firings (and consequent manipulation of the conflict resolution routines) to implement loops <ref> [ 32, 17 ] </ref> . Issues raised by introducing heuristic control mechanisms into an asynchronous rule-firing system are touched upon briefly in Section 4.2 and in more detail in [ 19 ] .
Reference: [33] <author> David Waltz. </author> <title> Understanding line drawings of scenes with shadows. </title> <editor> In Patrick H. Winston, editor, </editor> <booktitle> The Psychology of Computer Vision. </booktitle> <publisher> McGraw-Hill Book Company, </publisher> <address> New York, </address> <year> 1975. </year>
Reference-contexts: Space limitations prohibit a complete discussion of these programs, a more complete design discussion may be found in [ 19 ] . The first benchmark, a rule-based implementation of the Waltz line filtering algorithm <ref> [ 33 ] </ref> , was originally written by Toru Ishida and is called Toru-Waltz. We have substantially modified this program to increase the clarity of the rules and to incorporate UMPOPS constructs, however it remains functionally identical to the original.

References-found: 33

