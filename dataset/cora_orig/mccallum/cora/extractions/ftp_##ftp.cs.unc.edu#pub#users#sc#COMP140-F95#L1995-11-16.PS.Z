URL: ftp://ftp.cs.unc.edu/pub/users/sc/COMP140-F95/L1995-11-16.PS.Z
Refering-URL: http://www.cs.unc.edu/~sc/teaching/COMP140-F1995/lectures.html
Root-URL: http://www.cs.unc.edu
Title: COMP 140: Introduction to Translator Systems Assembly (Lecture 3 of 3)  
Author: Siddhartha Chatterjee 
Date: 16 November 1995  
Abstract: Assemblers can be of two types: module assemblers and load-and-go assemblers. A module assembler generates an object module, possibly with external references that are undefined and other references that need to be relocated. A linking and loading phase must follow to convert multiple object modules into an executable module. A load-and-go assembler, on the other hand, forgoes the creation of an object module and generates absolute code that can be directly executed. The code is generated directly in core, and execution starts immediately after assembly. This mode of compilation sacrifices modular development for faater turnaround time. It would be appropriate for introductory programming classes where the entire program is in a single file. (Q: How would you handle the standard runtime library of the language in such a model?) Today, we will first review the design of a two-pass module assembler and then see how a one-pass assembler may be designed. This will introduce a general implementation technique called backpatching. The two-pass structure of a module assembler is a direct result of forward references in the assembly source. The first pass associates labels in the source with location counter values (for text as well as data segment references), while the second phase performs the actual assembly and generates relocation records. As we discussed earlier, symbols and their attributes are stored in a symbol table. A symbol may have several possible attributes: the character string representing its name that will be used as its search key; its memory address; the segment to which it is a reference (text, data, etc.); its access typelocal (accessible only within this module), global (accessible from other modules), or external (referenced in this module but defined in another module); and the kind of reference it is (e.g., a 16-bit immediate, a 16-bit offset, a 26-bit jump address, a 32-bit reference to the symbol's virtual address). The actions taken on encountering a symbol depend on where the encounter occurs. A symbol may be found in several places in the source text: as a label, as an operand in an assembly language instruction, or as an operand in an assembler directive. Example 1 If we encounter the symbol fib in the assembly language instruction jal fib, we insert this symbol into the symbol table if it is not already present there. The only attributes we can instantiate at this point are its name ("fib"), its segment (text), and the reference type (26-bit jump address). It would also be reasonable to initialize its location counter value to an invalid value and to mark it as an external reference. If we encounter a label $L1: in the text segment, we can set its name to "$L1", its memory address to the current value of the text segment's location counter, its segment to text, and its access type as local. (This is the default for a defined symbol; a .globl directive is required to make a symbol defined in this module global; an undefined symbol defaults to access type external; the directive .extern explicitly makes a symbol's access type external.) 
Abstract-found: 1
Intro-found: 1
References-found: 0

