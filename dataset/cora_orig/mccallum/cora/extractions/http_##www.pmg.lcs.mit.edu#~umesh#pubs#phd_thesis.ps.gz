URL: http://www.pmg.lcs.mit.edu/~umesh/pubs/phd_thesis.ps.gz
Refering-URL: http://www.pmg.lcs.mit.edu/~umesh/pubs/
Root-URL: 
Title: Garbage Collection in a Large, Distributed Object Store  
Author: by Umesh Maheshwari Barbara Liskov Arthur C. Smith 
Degree: Submitted to the Department of Electrical Engineering and Computer Science in partial fulfillment of the requirements for the degree of Doctor of Philosophy in Computer Science and Engineering at the  All rights reserved. Author  Certified by  Ford Professor of Engineering Thesis Supervisor Accepted by  Chairman, Departmental Committee on Graduate Students  
Date: September 1997  September 5, 1997  
Affiliation: MASSACHUSETTS INSTITUTE OF TECHNOLOGY  c Massachusetts Institute of Technology 1997.  Department of Electrical Engineering and Computer Science  
Abstract-found: 0
Intro-found: 1
Reference: [ABC + 83] <author> M. P. Atkinson, P. J. Bailey, K. J. Chisholm, P. W. Cockshott, and R. Morrison. </author> <title> An approach to persistent programming. </title> <journal> Computer Journal, </journal> <volume> 26(4) </volume> <pages> 360-365, </pages> <year> 1983. </year>
Reference-contexts: An object is reachable from an application only if it is reachable from a persistent root or an application variable. Reachability is determined by the existence of a path of zero or more connecting references. This model for storage management is often known as persistence by reachability <ref> [ABC + 83] </ref>. In a distributed object store, objects may contain references to objects at other sites. Objects are expected to be clustered at sites such that remote references are infrequent compared to local references. However, garbage collection must account for local as well as remote references to determine reachability.
Reference: [Ady94] <author> A. Adya. </author> <title> Transaction management for mobile objects using optimistic concurrency control. </title> <type> Master's thesis, </type> <institution> Massachusetts Institute of Technology, </institution> <year> 1994. </year>
Reference-contexts: If the objects are in fact garbage, they will be collected by local tracing; otherwise, they will survive, although displaced from their original sites. We assume an underlying mechanism for migrating objects that is robust against concurrent mutations and that updates references to migrated objects <ref> [DLMM94, Ady94] </ref>. In Thor, a migrated object leaves a surrogate object at the old location that contains a forwarding reference to the new location of the object. Old references to a surrogate are updated in the background.
Reference: [AFFS95] <author> L. Amsaleg, P. Ferreira, M. Franklin, and M. Shapiro. </author> <title> Evaluating garbage collection for large persistent stores. </title> <booktitle> In Addendum to Proc. OOPSLA Workshop on Object Database Behavior. </booktitle> <publisher> ACM Press, </publisher> <year> 1995. </year>
Reference-contexts: In our experiments, however, we accounted for the expected log overhead from these actions; they were found to be negligible. 3.5.2 Workload Amsaleg et al. pointed out the lack of a standard benchmark for database garbage collectors <ref> [AFFS95] </ref>; such a benchmark remains absent today. Therefore, we designed a micro-benchmark specifically for evaluating the overhead of maintaining insets. The benchmark database consists of a homogenous collection of small objects, each of which has a single reference and some data fields.
Reference: [AGF95] <author> L. Amsaleg, O. Gruber, and M. Franklin. </author> <title> Efficient incremental garbage collection for workstation-server database systems. </title> <booktitle> In Proc. 21st VLDB. </booktitle> <publisher> ACM Press, </publisher> <year> 1995. </year>
Reference-contexts: Thus, timeliness and efficiency require that the disk space be divided into smaller partitions that are traced independently. This is the approach taken in many single-site systems with large, disk-based heaps <ref> [Bis77, YNY94, AGF95, MMH96, CKWZ96] </ref>. Ideally, partitions should be large enough to be an efficient unit of tracing, and small enough to fit in a fraction of main memory. <p> behaves atomically with respect to other transactions and crashes [Gra78].) Partitioned garbage collection involves a wide range of other issues such as the choice of the tracing algorithm (marking, copying [Bak78], replicating [ONG93], etc.), the selection of partitions to trace [CWZ94], the rate of starting traces [CKWZ96], handling transactional rollback <ref> [AGF95] </ref>, etc. This thesis either does not cover the above issues or addresses them only marginally. <p> Further, new handles given to the application during an aborted transaction are revoked and cannot be used subsequently. Applications may use handles obtained during one transaction in subsequent transactions. Some other systems constrain applications to release all handles with each transaction <ref> [AGF95] </ref>, so an application must start each transaction from the persistent root. This constraint implies that garbage collection need not account for the handles held by applications. However, it makes writing applications inconvenient. <p> Thor does not use this policy for reasons provided in [Ghe95]. Not installing uncommitted data also simplifies garbage collection. Other researchers have solved garbage-collection problems due to uncommitted data that is installed <ref> [AGF95] </ref>. Their solutions can be used in conjunction with the techniques suggested in this thesis. 2.6 Failure Model A server is expected to recover from crashes without much delay. When a server crashes, it loses the data in its main memory but retains the data on its disk. <p> Therefore, a trace of the entire disk is likely to have poor locality of reference with respect to available memory. It would thrash on disk, i.e., fetch and evict a disk page many times in order to scan different objects in the page <ref> [YNY94, AGF95] </ref>. On the other hand, a partition trace fetches the pages of one partition into memory and scans all live objects in them before fetching another partition. <p> On the other hand, big partitions mean more memory space used by the collector, which reduces the memory available for the server cache. Further, if the partition does not fit in the available memory, the trace would thrash on disk <ref> [AGF95] </ref>. Therefore, partitions should fit in a fraction, say, a tenth, of main memory. Given current memory sizes, a partition may be a few megabytes to tens of megabytes. <p> However, identifying such references requires additional information, which varies among existing schemes for partitioned or distributed collection, e.g., remembered sets [Ung84, Sob88], reference counts [Bev87, Piq91], and reference source-listing <ref> [Bis77, SDP92, BEN + 93, ML94, AGF95, MMH96] </ref>. Section 3.3 presents a new form of reference source-listing that makes it efficient to both add and remove references in insets, while using less space than any previous scheme. The above scheme successfully collects chains of garbage objects across multiple partitions. <p> Arranging inter-partition references into translists and sharing them between insets and outsets provides a cheap mechanism to maintain both insets and outsets. 3.3.1 Comparison with Previous Work Most other single-site partitioned collectors implement insets as a sequence of pairs hreference, source-partitioni and do not provide mechanisms to find the outset <ref> [AGF95, MMH96] </ref>. The scheme by Amsaleg et al. scans the insets of all partitions after a trace to remove untraced references [AGF95]. This approach would not scale to a large number of partitions. <p> The scheme by Amsaleg et al. scans the insets of all partitions after a trace to remove untraced references <ref> [AGF95] </ref>. This approach would not scale to a large number of partitions. The scheme by Moss et al. computes the outset whenever a page is fetched and also when a modified page is evicted, and applies the differences to insets [HM92, MMH96]. <p> Finally, the use of slotted pages allows a mark-and-sweep scheme to compact live objects by sliding them within their pages, as discussed later in Section 3.4.4. Amsaleg et al. also chose a mark-and-sweep scheme for these reasons in the context of another object database <ref> [AGF95] </ref>. 3.4.1 Safe Tracing A trace that runs concurrently with ongoing transactions needs to see a safe view of the object graph such that it does not miss any references due to concurrent modifications.
Reference: [AGLM95] <author> A. Adya, R. Gruber, B. Liskov, and U. Maheshwari. </author> <title> Efficient optimistic concurrency control using loosely synchronized clocks. </title> <booktitle> In Proc. SIGMOD, </booktitle> <pages> pages 23-34. </pages> <publisher> ACM Press, </publisher> <year> 1995. </year>
Reference-contexts: Not locking objects puts a greater demand on garbage collection because clients might cache old copies of objects that are invalid. For concreteness, we describe the transactional mechanisms employed in Thor. Thor uses optimistic concurrency control <ref> [AGLM95] </ref>. A transaction does not lock the objects it uses; instead, it is validated against previous transactions when it commits. Validation requires information about the objects read and modified by the transaction. This information is logged by the client and sent to the servers at commit time.
Reference: [Ali85] <author> K. A. M. Ali. </author> <title> Garbage collection schemes for distributed storage systems. </title> <booktitle> In Proc. Workshop on Implementation of Functional Languages, </booktitle> <pages> pages 422-428, </pages> <year> 1985. </year>
Reference-contexts: Such a trace would not be timely or fault tolerant because every site must wait until the global trace has finished. Timeliness and fault tolerance require that a site trace local objects independently of other sites. This is the approach taken in many distributed systems <ref> [Ali85, Bev87, SDP92, JJ92, BEN + 93, ML94] </ref>. Local tracing minimizes inter-site dependence. In particular, garbage that is not referenced from other sites is collected locally. Further, a chain of garbage objects spanning multiple sites is collected through cooperation within the sites holding the chain. <p> Thus, global marking might never complete in a large system. The challenge in collecting an inter-site garbage cycle is to preserve the locality property, that is, to involve only the sites containing the cycle. This has proven difficult: most previous schemes do not preserve locality <ref> [Ali85, JJ92, LQP92, MKI + 95, RJ96] </ref>. The few that do seem prohibitively complex or costly [SGP90, Sch89, LC97]. We present the first practical scheme with locality to collect inter-site cycles. It has two parts. The first part identifies objects that are highly likely to be cyclic garbagethe suspects. <p> Minimizing inter-site dependence requires the locality property: Collecting a garbage cycle should involve only the sites containing it. Locality has proven surprisingly difficult to preserve in collecting inter-site cycles; most previous schemes do not preserve locality. For example, some conduct periodic global marking in addition to site-marking <ref> [Ali85, JJ92] </ref>. The drawbacks of global marking can be alleviated by marking within groups of selected sites [LQP92, MKI + 95, RJ96], but inter-group cycles might never be collected. Few schemes for collecting inter-site cycles have the locality property. <p> Global Tracing A complementary global trace is conducted periodically to collect cyclic garbage, while other garbage is collected more quickly by local tracing <ref> [Ali85, JJ92] </ref>. Termination of the global trace is detected using the model for diffusive computation [Aug87, DS89]. The drawback of global tracing is that it may not complete in a system with a large number of faulty sites.
Reference: [Aug87] <author> L. Augusteijn. </author> <title> Garbage collection in a distributed environment. </title> <editor> In J. W. de Bakker, L. Nijman, and P. C. Treleaven, editors, </editor> <booktitle> PARLE'87 Parallel Architectures and Languages Europe, volume 258/259 of Lecture Notes in Computer Science, </booktitle> <pages> pages 75-93. </pages> <publisher> Springer-Verlag, </publisher> <year> 1987. </year>
Reference-contexts: Global Tracing A complementary global trace is conducted periodically to collect cyclic garbage, while other garbage is collected more quickly by local tracing [Ali85, JJ92]. Termination of the global trace is detected using the model for diffusive computation <ref> [Aug87, DS89] </ref>. The drawback of global tracing is that it may not complete in a system with a large number of faulty sites. Hughes's algorithm propagates timestamps from inrefs to outrefs and collects objects times-tamped below a certain global threshold [Hug85].
Reference: [Bak78] <author> H. G. Baker. </author> <title> List processing in real-time on a serial computer. </title> <journal> CACM, </journal> <volume> 21(4) </volume> <pages> 280-94, </pages> <year> 1978. </year>
Reference-contexts: modified objects; most object stores contain such a log to support transactions. (A transaction is a sequence of operations that behaves atomically with respect to other transactions and crashes [Gra78].) Partitioned garbage collection involves a wide range of other issues such as the choice of the tracing algorithm (marking, copying <ref> [Bak78] </ref>, replicating [ONG93], etc.), the selection of partitions to trace [CWZ94], the rate of starting traces [CKWZ96], handling transactional rollback [AGF95], etc. This thesis either does not cover the above issues or addresses them only marginally.
Reference: [Bak93] <author> H. G. Baker. </author> <title> `Infant mortality' and generational garbage collection. </title> <journal> ACM SIGPLAN Notices, </journal> <volume> 28(4), </volume> <year> 1993. </year>
Reference-contexts: This is similar to generational collectors which collect newer partitions more frequently [Ung84]. Although the age-based heuristics of generational collectors are not applicable to persistent stores <ref> [Bak93] </ref>, other heuristics are available for selecting partitions [CWZ94]. Fourth, if the server crashes in the middle of a trace, the work done during the trace is wasted. <p> We chose a mark-and-sweep scheme for tracing. A copying collector would use twice the space used by mark-and-sweep. Further, persistent stores often have little garbage to be collected <ref> [Bak93] </ref>, so a copying collector would spend significant time copying many live objects. Finally, the use of slotted pages allows a mark-and-sweep scheme to compact live objects by sliding them within their pages, as discussed later in Section 3.4.4.
Reference: [BE86] <author> M. J. Beckerle and K. Ekanadham. </author> <title> Distributed garbage collection with no global synchronisation. </title> <type> Research Report RC 11667 (#52377), </type> <institution> IBM, </institution> <year> 1986. </year>
Reference-contexts: However, a single site can hold down the global threshold, prohibiting garbage collection in the entire system. Central Service Beckerle and Ekanadham proposed that each site send inref-outref reachability information to a fixed site, which uses the information to detect inter-site garbage cycles <ref> [BE86] </ref>. However, the fixed site becomes a performance and fault tolerance bottleneck. Ladin and Liskov proposed a logically central but physically replicated service that tracks inter-site references and uses Hughes's algorithm to collect cycles [LL92]. The central service avoids the need for a distributed algorithm to compute the global threshold.
Reference: [BEN + 93] <author> A. Birrell, D. Evers, G. Nelson, S. Owicki, and E. Wobber. </author> <title> Distributed garbage collection for network objects. </title> <type> Technical Report 116, </type> <institution> Digital Systems Research Center, </institution> <year> 1993. </year>
Reference-contexts: Such a trace would not be timely or fault tolerant because every site must wait until the global trace has finished. Timeliness and fault tolerance require that a site trace local objects independently of other sites. This is the approach taken in many distributed systems <ref> [Ali85, Bev87, SDP92, JJ92, BEN + 93, ML94] </ref>. Local tracing minimizes inter-site dependence. In particular, garbage that is not referenced from other sites is collected locally. Further, a chain of garbage objects spanning multiple sites is collected through cooperation within the sites holding the chain. <p> However, identifying such references requires additional information, which varies among existing schemes for partitioned or distributed collection, e.g., remembered sets [Ung84, Sob88], reference counts [Bev87, Piq91], and reference source-listing <ref> [Bis77, SDP92, BEN + 93, ML94, AGF95, MMH96] </ref>. Section 3.3 presents a new form of reference source-listing that makes it efficient to both add and remove references in insets, while using less space than any previous scheme. The above scheme successfully collects chains of garbage objects across multiple partitions. <p> Any partition trace scans all of these pages for relevant roots. On the other hand, many distributed collectors maintain both insets and outsets for inter-site references <ref> [SDP92, BEN + 93, ML94] </ref>. However, insets and outsets at different sites do not share translists. <p> On the other hand, different sites conduct local traces asynchronously, so inter-site references in modified objects must be processed eagerly. Nonetheless, there are various protocols for deferring or avoiding add messages without compromising safety and for tolerating lost messages <ref> [SDP92, BEN + 93, ML94] </ref>. Sections 5.2 and 5.3 describe new protocols to add client-to-server and server-to-server references. When S does a local trace, it removes the references in its outlists that were not traced, and sends remove messages for them to their target sites. <p> When the count of a reference reduces to zero, it is removed from the inset. On the other hand, our scheme effectively records the identities of the source sites for each reference in the inset, a technique known as reference listing <ref> [Mah93a, BEN + 93] </ref>. Reference listing keeps more information than reference counting, but we use it for the following reasons: 1. Reference listing tolerates permanent site failures. If a client or a server X fails permanently, other servers need simply remove their inlists from X.
Reference: [Bev87] <author> D. I. Bevan. </author> <title> Distributed garbage collection using reference counting. </title> <booktitle> In PARLE, volume 259 of Lecture Notes in Computer Science, </booktitle> <pages> pages 176-187. </pages> <publisher> Springer-Verlag, </publisher> <year> 1987. </year>
Reference-contexts: Such a trace would not be timely or fault tolerant because every site must wait until the global trace has finished. Timeliness and fault tolerance require that a site trace local objects independently of other sites. This is the approach taken in many distributed systems <ref> [Ali85, Bev87, SDP92, JJ92, BEN + 93, ML94] </ref>. Local tracing minimizes inter-site dependence. In particular, garbage that is not referenced from other sites is collected locally. Further, a chain of garbage objects spanning multiple sites is collected through cooperation within the sites holding the chain. <p> However, identifying such references requires additional information, which varies among existing schemes for partitioned or distributed collection, e.g., remembered sets [Ung84, Sob88], reference counts <ref> [Bev87, Piq91] </ref>, and reference source-listing [Bis77, SDP92, BEN + 93, ML94, AGF95, MMH96]. Section 3.3 presents a new form of reference source-listing that makes it efficient to both add and remove references in insets, while using less space than any previous scheme. <p> The outset of a site contains the translists to other sites, while the inset either contains copies of the translists from other sites or it consists of a single set of incoming references with a count of the source sites for each reference <ref> [Bev87, Piq91] </ref>. If this organization were used for inter-partition references, it would have a higher space overhead and require safety invariants between insets and outsets. We experimented with such a technique earlier [ML96]; it was much more complex than the current technique due to the need to maintain invariants. <p> In systems using inter-site reference counting, the target site records a count of the source sites that hold a reference to a given local objectwithout recording the identities of the individual source sites <ref> [Bev87, Piq91] </ref>. When the count of a reference reduces to zero, it is removed from the inset. On the other hand, our scheme effectively records the identities of the source sites for each reference in the inset, a technique known as reference listing [Mah93a, BEN + 93].
Reference: [Bis77] <author> P. B. Bishop. </author> <title> Computer systems with a very large address space and garbage collection. </title> <type> Technical Report MIT/LCS/TR-178, </type> <institution> MIT, </institution> <year> 1977. </year>
Reference-contexts: Thus, timeliness and efficiency require that the disk space be divided into smaller partitions that are traced independently. This is the approach taken in many single-site systems with large, disk-based heaps <ref> [Bis77, YNY94, AGF95, MMH96, CKWZ96] </ref>. Ideally, partitions should be large enough to be an efficient unit of tracing, and small enough to fit in a fraction of main memory. <p> However, identifying such references requires additional information, which varies among existing schemes for partitioned or distributed collection, e.g., remembered sets [Ung84, Sob88], reference counts [Bev87, Piq91], and reference source-listing <ref> [Bis77, SDP92, BEN + 93, ML94, AGF95, MMH96] </ref>. Section 3.3 presents a new form of reference source-listing that makes it efficient to both add and remove references in insets, while using less space than any previous scheme. The above scheme successfully collects chains of garbage objects across multiple partitions. <p> Few schemes for collecting inter-site cycles have the locality property. A prominent technique is to migrate an inter-site garbage cycle to a single site, where it is collected by site-marking <ref> [Bis77, SGP90] </ref>. However, previous schemes based on migration are prone to migrating live objects besides garbage cycles, which is undesirable because migration is expensive. We present a practical scheme with locality to collect inter-site cycles. It has two parts. <p> Old references to a surrogate are updated in the background. As with normal objects, a surrogate is collected when it is not reachable from applications. Migration has been proposed earlier to collect distributed cycles <ref> [Bis77, SGP90] </ref>. However, previous proposals used weak heuristics to decide which objects to migrate. A popular heuristic was to move to all objects not locally reachable from a global root. <p> Schemes with Locality Few schemes for collecting cyclic garbage have the locality property. The oldest among these is migrating a suspected distributed garbage cycle to a single site <ref> [Bis77] </ref>. Since migration is expensive, it is crucial to use a good heuristic for finding suspects; we proposed the distance heuristic in this context earlier [ML95]. However, some systems do not support migration due to security or autonomy constraints or due to heterogeneous architecture.
Reference: [BN84] <author> A. D. Birrell and B. J. Nelson. </author> <title> Implementing remote procedure calls. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 2(1), </volume> <year> 1984. </year>
Reference-contexts: Another problem concerns recording inter-server references. Previous distributed collectors were mostly designed for RPC-based (or control-shipping) systems, where inter-server references were created through remote procedure calls <ref> [BN84] </ref>. However, in client-caching (or data-shipping) transactional systems, inter-server references are created when clients commit transactions. We present a new protocol for recording inter-server references created this manner.
Reference: [CDN93] <author> M. J. Carey, D. J. DeWitt, and J. F. Naughton. </author> <title> The OO7 benchmark. </title> <booktitle> In Proc. SIGMOD, </booktitle> <pages> pages 12-21. </pages> <publisher> ACM Press, </publisher> <year> 1993. </year>
Reference-contexts: Inter-partition cycles are common in practice; for example, in many CAD applications a container object points to its parts and the parts point back to the containerthus creating a huge tree with doubly linked edges <ref> [CDN93] </ref>. We present a site-wide marking scheme for collecting cycles between partitions on the same site. Complementary global marking has been proposed earlier to collect cyclic garbage in partitioned schemes. We present the first such scheme that has the following features [ML97b]: 12 1.
Reference: [CFZ94] <author> M. Carey, M. Franklin, and M. Zaharioudakis. </author> <title> Fine-graned sharing in a page server OODBMS. </title> <booktitle> In Proc. SIGMOD, </booktitle> <address> Minneapolis, MN, 1994. </address> <publisher> ACM Press. </publisher>
Reference-contexts: In particular, a client need not lock objects before using them; locking objects would require contacting the server and possibly other clients <ref> [CFZ94] </ref>. Not locking objects puts a greater demand on garbage collection because clients might cache old copies of objects that are invalid. For concreteness, we describe the transactional mechanisms employed in Thor. Thor uses optimistic concurrency control [AGLM95].
Reference: [CKWZ96] <author> J. E. Cook, A. W. Klauser, A. L. Wolf, and B. G. Zorn. </author> <title> Semi-automatic, self-adaptive control of garbage collection rates in object databases. </title> <booktitle> In Proc. SIGMOD. </booktitle> <publisher> ACM Press, </publisher> <year> 1996. </year>
Reference-contexts: Thus, timeliness and efficiency require that the disk space be divided into smaller partitions that are traced independently. This is the approach taken in many single-site systems with large, disk-based heaps <ref> [Bis77, YNY94, AGF95, MMH96, CKWZ96] </ref>. Ideally, partitions should be large enough to be an efficient unit of tracing, and small enough to fit in a fraction of main memory. <p> sequence of operations that behaves atomically with respect to other transactions and crashes [Gra78].) Partitioned garbage collection involves a wide range of other issues such as the choice of the tracing algorithm (marking, copying [Bak78], replicating [ONG93], etc.), the selection of partitions to trace [CWZ94], the rate of starting traces <ref> [CKWZ96] </ref>, handling transactional rollback [AGF95], etc. This thesis either does not cover the above issues or addresses them only marginally.
Reference: [CWZ94] <author> J. E. Cook, A. L. Wolf, and B. G. Zorn. </author> <title> Partition selection policies in object databases garbage collection. </title> <booktitle> In Proc. SIGMOD. </booktitle> <publisher> ACM Press, </publisher> <year> 1994. </year>
Reference-contexts: support transactions. (A transaction is a sequence of operations that behaves atomically with respect to other transactions and crashes [Gra78].) Partitioned garbage collection involves a wide range of other issues such as the choice of the tracing algorithm (marking, copying [Bak78], replicating [ONG93], etc.), the selection of partitions to trace <ref> [CWZ94] </ref>, the rate of starting traces [CKWZ96], handling transactional rollback [AGF95], etc. This thesis either does not cover the above issues or addresses them only marginally. <p> This is similar to generational collectors which collect newer partitions more frequently [Ung84]. Although the age-based heuristics of generational collectors are not applicable to persistent stores [Bak93], other heuristics are available for selecting partitions <ref> [CWZ94] </ref>. Fourth, if the server crashes in the middle of a trace, the work done during the trace is wasted. <p> This heuristic favors tracing partitions that contain the head-ends of garbage chains; therefore, it is likely to make quick progress in collecting garbage chains. Cook et al. have suggested some other heuristics for selecting partitions <ref> [CWZ94] </ref>. This thesis does not examine these heuristics any further; this issue is an important direction for future work. 24 3.3 Insets This section describes new techniques for organizing and updating insets. <p> In Section 3.2, we suggested the reduced-inset heuristic for selecting partitions. Cook et al. have suggested some other heuristics for selecting partitions <ref> [CWZ94] </ref>. However, more work is needed to devise sophisticated heuristics for prompt collection of both partition-local and inter-partition garbage. Delta Lists We used delta lists to defer and batch additions to translists.
Reference: [DLMM94] <author> M. Day, B. Liskov, U. Maheshwari, and A. Myers. </author> <title> References to remote mobile objects in Thor. </title> <journal> Letters on Programming Languages and Systems, </journal> <volume> 2(1-4):115-126, </volume> <year> 1994. </year>
Reference-contexts: If the objects are in fact garbage, they will be collected by local tracing; otherwise, they will survive, although displaced from their original sites. We assume an underlying mechanism for migrating objects that is robust against concurrent mutations and that updates references to migrated objects <ref> [DLMM94, Ady94] </ref>. In Thor, a migrated object leaves a surrogate object at the old location that contains a forwarding reference to the new location of the object. Old references to a surrogate are updated in the background.
Reference: [DS89] <author> E. W. Dijkstra and C. S. Scholten. </author> <title> Termination detection for diffusing computations. </title> <journal> Information Processing Letters, </journal> <volume> 11, </volume> <year> 1989. </year>
Reference-contexts: Global Tracing A complementary global trace is conducted periodically to collect cyclic garbage, while other garbage is collected more quickly by local tracing [Ali85, JJ92]. Termination of the global trace is detected using the model for diffusive computation <ref> [Aug87, DS89] </ref>. The drawback of global tracing is that it may not complete in a system with a large number of faulty sites. Hughes's algorithm propagates timestamps from inrefs to outrefs and collects objects times-tamped below a certain global threshold [Hug85].
Reference: [EH84] <author> W. Effelsberg and T. Haerder. </author> <title> Principles of database buffer management. </title> <journal> ACM Transaction on Database Systems, </journal> <volume> 9(4) </volume> <pages> 560-595, </pages> <year> 1984. </year>
Reference-contexts: Again, modifications might be installed out of order. Applying and installing modifications out of order makes it difficult for the garbage collector to obtain a safe view of the object graph. Some object stores use steal buffer management <ref> [EH84] </ref>, which allows uncommitted modifications to be installed on disk pages. Thor does not use this policy for reasons provided in [Ghe95]. Not installing uncommitted data also simplifies garbage collection. Other researchers have solved garbage-collection problems due to uncommitted data that is installed [AGF95].
Reference: [FS96] <author> P. Ferreira and M. Shapiro. Larchant: </author> <title> Persistence by reachability in distributed shared memory through garbage collection. </title> <booktitle> In Proc. 16th ICDCS, </booktitle> <year> 1996. </year>
Reference-contexts: However, newly created inter-site references must be processed eagerly because different sites trace partitions asynchronously. Most of the previous partitioned collectors are designed for either a distributed system with one partition per site or a single-site system with multiple partitions. Few collectors handle multiple partitions within multiple sites <ref> [FS96] </ref>, but they do not differentiate between inter-partition and inter-site references. We present techniques to support client-server mechanisms such as client caching and multi-server transactions. Server sites store objects on disk, while a client runs at each application site and executes operations on local copies of objects.
Reference: [Fuc95] <author> M. Fuchs. </author> <title> Garbage collection on an open network. </title> <editor> In H. Baker, editor, </editor> <booktitle> Proc. IWMM, Lecture Notes in Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1995. </year>
Reference-contexts: The second technique traces back from the suspects to check if they are reachable from a persistent root. Unlike forward global tracing, this approach preserves locality and scalability. Back tracing was proposed earlier by Fuchs <ref> [Fuc95] </ref>. However, this proposal assumed that inverse information was available for references, and it ignored problems due to concurrent mutations and forward local traces. We present efficient techniques for conducting back tracing that handle these and other practical problems. <p> However, some systems do not support migration. The second technique traces back from the suspects to check if they are reachable from any global root. Unlike forward global marking, this approach preserves locality and scalability. Back tracing was proposed earlier by Fuchs <ref> [Fuc95] </ref>. However, that proposal assumed that inverse information was available to trace references backwards, and it ignored problems due to concurrent mutations and forward local traces. The organization of the full scheme is illustrated in Figure 6.1. Section 6.1 describes the distance heuristic for finding suspects. <p> However, it too requires full inref-outref reachability information, and its space overhead is even larger: each inref i stores a set of vector timestamps; each vector corresponds to a path i is reachable from. Back tracing was proposed earlier by Fuchs <ref> [Fuc95] </ref>. However, this proposal assumed that inverse information was available for references, and it ignored problems due to concurrent mutations and forward local traces.
Reference: [GF93] <author> A. Gupta and W. K. Fuchs. </author> <title> Garbage collection in a distributed object-oriented system. </title> <journal> IEEE Transactions on Knowledge and Data Engineering, </journal> <volume> 5(2), </volume> <year> 1993. </year>
Reference-contexts: If the suspicion threshold distance is 10, e 2 will be batched for migration with e, while b 2 will not be migrated. This is desirable because b 2 is likely to be live. 6.2.1 Where to Migrate Some previous schemes migrate objects to a fixed dump site <ref> [GF93] </ref>, but this can be a performance or fault-tolerance bottleneck in a large system. Other schemes migrate objects to sites that refer to them.
Reference: [Ghe95] <author> S. Ghemawat. </author> <title> The modified object buffer: A storage management technique for object-oriented databases. </title> <type> Technical Report MIT/LCS/TR-666, </type> <institution> MIT Laboratory for Computer Science, </institution> <year> 1995. </year>
Reference-contexts: The header of each object contains a reference to its class object. A server maintains a cache of pages to serve fetch requests from clients. Besides a page cache, the server contains a modified object buffer to store newly persistent or modified copies of objects returned by clients <ref> [Ghe95] </ref>. This buffer allows the server to defer and batch the installation of new and modified objects into their disk pages. 2.4 Concurrency Control The techniques described in this thesis are applicable to a wide range of transactional systems. <p> When a server prepares a transaction, it stores the new and modified objects into a prepare record in a stable log. Conventional systems use a disk-based log, but Thor uses an in-memory log replicated on several machines <ref> [Ghe95] </ref>. Modifications stored in prepare records are not visible to clients. When a transaction commits, the server applies the objects in the prepare record by moving them into the modified object buffer, which is also a part of the in-memory stable log. <p> Some object stores use steal buffer management [EH84], which allows uncommitted modifications to be installed on disk pages. Thor does not use this policy for reasons provided in <ref> [Ghe95] </ref>. Not installing uncommitted data also simplifies garbage collection. Other researchers have solved garbage-collection problems due to uncommitted data that is installed [AGF95]. <p> On the other hand, a partition trace fetches the pages of one partition into memory and scans all live objects in them before fetching another partition. This saves disk bandwidth, which is a performance bottleneck in many object stores and is crucial for good performance of many applications <ref> [Ghe95] </ref>. Second, avoiding thrashing on disk also results in faster collection of garbage. However, faster collection through partitioned tracing is based on the assumption that most garbage is either local to a partition (i.e., not reachable from outside the partition), or is reachable from garbage chains passing through few partitions.
Reference: [Gra78] <author> J. N. Gray. </author> <title> Notes on database operating systems. </title> <editor> In R. Bayer, R. Graham, and G. Seegmuller, editors, </editor> <booktitle> Operating Systems: An Advanced Course, number 60 in Lecture Notes in Computer Science, </booktitle> <pages> pages 393-481. </pages> <publisher> Springer-Verlag, </publisher> <year> 1978. </year>
Reference-contexts: These techniques exploit a stable log of modified objects; most object stores contain such a log to support transactions. (A transaction is a sequence of operations that behaves atomically with respect to other transactions and crashes <ref> [Gra78] </ref>.) Partitioned garbage collection involves a wide range of other issues such as the choice of the tracing algorithm (marking, copying [Bak78], replicating [ONG93], etc.), the selection of partitions to trace [CWZ94], the rate of starting traces [CKWZ96], handling transactional rollback [AGF95], etc. <p> An application groups its operations into transactions to tolerate failures and concurrent modifications by other applications. A transaction behaves as if its operations happened atomically with respect to failures and other transactions <ref> [Gra78] </ref>. An application specifies transaction boundaries by requesting a commit, which ends the ongoing transaction and starts another. A transaction might fail to commit, or abort, for various reasons. In this case, the updates made during the transaction are undone. <p> If there is more than one participant, it uses the following two-phase commit protocol <ref> [Gra78] </ref>. It sends the copies of new and modified objects to a participant chosen as the coordinator. The coordinator sends a prepare message to each participant. A participant tries to validate the transaction.
Reference: [HM92] <author> R. L. Hudson and J. E. B. Moss. </author> <title> Incremental garbage collection for mature objects. </title> <booktitle> In Proc. IWMM, volume 637 of Lecture Notes in Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1992. </year>
Reference-contexts: This approach would not scale to a large number of partitions. The scheme by Moss et al. computes the outset whenever a page is fetched and also when a modified page is evicted, and applies the differences to insets <ref> [HM92, MMH96] </ref>. This approach would delay applications when they fetch pages. Some generational collectors implement insets as remembered sets [Ung84, Sob88]. They record the locationsat the level of a word, object, or pagethat may contain inter-partition references. <p> Thus, a inter-partition garbage cycle that spans partitions P i1 ; : : : ; P im is collected when the partition numbered M ax (i1; : : : ; im) is traced. System PMOS collects inter-partition garbage cycles by grouping partitions into trains <ref> [HM92, MMH96] </ref>. Trains are ordered by age. When a partition is traced, objects that are reachable from a site-level root or a newer train are copied to newer trains, while other objects are copied to a new partition within the same train.
Reference: [Hug85] <author> R. J. M. Hughes. </author> <title> A distributed garbage collection algorithm. </title> <booktitle> In Proc. 1985 FPCA, volume 201 of Lecture Notes in Computer Science, </booktitle> <pages> pages 256-272. </pages> <publisher> Springer-Verlag, </publisher> <year> 1985. </year>
Reference-contexts: This collects inter-partition garbage cycles because they are not reachable from the site-level roots. Similar marking schemes have been proposed earlier in the context of distributed garbage collection to collect cyclic garbage. However, previous schemes either propagate marks separately from partition-marks [JJ92], or delay the collection of non-cyclic garbage <ref> [Hug85] </ref>, or are not guaranteed to terminate correctly in the presence of concurrent mutations [LQP92]. Our scheme for site-marking has the following desirable properties: * Site-marking is piggybacked on partition-marking so that it has little overhead. * Site-marking does not delay the collection of non-cyclic garbage. <p> Otherwise, site-mark bits for just the inter-partition references would suffice, as in <ref> [Hug85, LQP92] </ref>. 4.2 Starting a Phase When a phase starts, only references in the site's inset are site-marked. The partitions containing these references are unflagged and the rest are flagged. (This satisfies the site-marking invariant.) These actions are performed incrementally as follows. <p> The drawback of global tracing is that it may not complete in a system with a large number of faulty sites. Hughes's algorithm propagates timestamps from inrefs to outrefs and collects objects times-tamped below a certain global threshold <ref> [Hug85] </ref>. The persistent roots always have the current time, and a global algorithm is used to compute the threshold. The advantage of using timestamps over mark bits is that, in effect, multiple marking phases can proceed concurrently.
Reference: [JJ92] <author> N.-C. Juul and E. </author> <month> Jul. </month> <title> Comprehensive and robust garbage collection in a distributed system. </title> <booktitle> In Proc. IWMM, volume 637 of Lecture Notes in Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1992. </year>
Reference-contexts: Such a trace would not be timely or fault tolerant because every site must wait until the global trace has finished. Timeliness and fault tolerance require that a site trace local objects independently of other sites. This is the approach taken in many distributed systems <ref> [Ali85, Bev87, SDP92, JJ92, BEN + 93, ML94] </ref>. Local tracing minimizes inter-site dependence. In particular, garbage that is not referenced from other sites is collected locally. Further, a chain of garbage objects spanning multiple sites is collected through cooperation within the sites holding the chain. <p> Thus, global marking might never complete in a large system. The challenge in collecting an inter-site garbage cycle is to preserve the locality property, that is, to involve only the sites containing the cycle. This has proven difficult: most previous schemes do not preserve locality <ref> [Ali85, JJ92, LQP92, MKI + 95, RJ96] </ref>. The few that do seem prohibitively complex or costly [SGP90, Sch89, LC97]. We present the first practical scheme with locality to collect inter-site cycles. It has two parts. The first part identifies objects that are highly likely to be cyclic garbagethe suspects. <p> In Emerald distributed system, the inset stores only the set of incoming references with no additional information, making it impossible to determine when to remove references from it without doing a global trace <ref> [JJ92] </ref>. Such systems rely on a complementary global trace to collect inter-partition cycles as well as chains. 3.3.2 Maintaining Insets Translists, insets, and outsets are kept on disk for two reasons. <p> This collects inter-partition garbage cycles because they are not reachable from the site-level roots. Similar marking schemes have been proposed earlier in the context of distributed garbage collection to collect cyclic garbage. However, previous schemes either propagate marks separately from partition-marks <ref> [JJ92] </ref>, or delay the collection of non-cyclic garbage [Hug85], or are not guaranteed to terminate correctly in the presence of concurrent mutations [LQP92]. <p> Minimizing inter-site dependence requires the locality property: Collecting a garbage cycle should involve only the sites containing it. Locality has proven surprisingly difficult to preserve in collecting inter-site cycles; most previous schemes do not preserve locality. For example, some conduct periodic global marking in addition to site-marking <ref> [Ali85, JJ92] </ref>. The drawbacks of global marking can be alleviated by marking within groups of selected sites [LQP92, MKI + 95, RJ96], but inter-group cycles might never be collected. Few schemes for collecting inter-site cycles have the locality property. <p> Global Tracing A complementary global trace is conducted periodically to collect cyclic garbage, while other garbage is collected more quickly by local tracing <ref> [Ali85, JJ92] </ref>. Termination of the global trace is detected using the model for diffusive computation [Aug87, DS89]. The drawback of global tracing is that it may not complete in a system with a large number of faulty sites.
Reference: [JL92] <author> R. E. Jones and R. D. Lins. </author> <title> Cyclic weighted reference counting without delay. </title> <type> Technical Report 28-92, </type> <institution> Computing Laboratory, The University of Kent at Canterbury, </institution> <year> 1992. </year>
Reference-contexts: This scheme requires two distributed traces over objects in a subgraph. Jones and Lins improved the scheme such that multiple sites could conduct traces in parallel, but it required global synchronization between sites <ref> [JL92] </ref>. Group Tracing Another method to alleviate the drawbacks of global tracing is to trace within a group of selected sites, thus collecting garbage cycles within the group. A group trace treats all references from outside the group as roots.
Reference: [KW93] <author> E. K. Kolodner and W. E. Weihl. </author> <title> Atomic incremental garbage collection and recovery for large stable heap. </title> <booktitle> In Proc. 1993 SIGMOD, </booktitle> <pages> pages 177-186, </pages> <year> 1993. </year>
Reference-contexts: tracing a partition, but it might be significant when the disk is traced as a unit. (The trace of a 10 gigabyte disk might take a day to finish.) It is possible to conduct a trace such that it can be resumed after a crash, but this adds substantial complexity <ref> [KW93] </ref>. 3.1.2 The Structure of Partitions A partition may contain many pages, possibly non-adjacent. This approach has important advantages. First, the page size is chosen for efficient fetching and caching, while a partition is chosen to be an efficient unit of tracing.
Reference: [LAC + 96] <author> B. Liskov, A. Adya, M. Castro, M. Day, S. Ghemawat, R. Gruber, U. Maheshwari, A. Myers, and L. Shrira. </author> <title> Safe and efficient sharing of persistent objects in Thor. </title> <booktitle> In Proc. SIGMOD, </booktitle> <pages> pages 318-329. </pages> <publisher> ACM Press, </publisher> <year> 1996. </year>
Reference-contexts: finding suspected cyclic garbage and two techniques for checking them. * Chapter 7 contains conclusions on the overall design, some guidelines for evaluating the performance, and some directions for future research. 15 Chapter 2 The Context This thesis was developed in the context of Thor, a state-of-the-art distributed object database <ref> [LAC + 96] </ref>. This chapter describes the parts of Thor that are relevant to the garbage collector.
Reference: [LC97] <author> S. Louboutin and V. Cahill. </author> <title> Comprehensive distributed garbage collection by tracking the causal dependencies of relevant mutator events. </title> <booktitle> In Proc. </booktitle> <address> ICDCS. </address> <publisher> IEEE Press, </publisher> <year> 1997. </year>
Reference-contexts: This has proven difficult: most previous schemes do not preserve locality [Ali85, JJ92, LQP92, MKI + 95, RJ96]. The few that do seem prohibitively complex or costly <ref> [SGP90, Sch89, LC97] </ref>. We present the first practical scheme with locality to collect inter-site cycles. It has two parts. The first part identifies objects that are highly likely to be cyclic garbagethe suspects. <p> The space occupied by inreaches or outreaches is O (n i fi n o ), where n i and n o are the number of suspected inrefs and suspected outrefs. The space overhead is less than other non-migration-based schemes with locality <ref> [Sch89, LC97] </ref>. These other schemes require complete local-reachability information between inrefs and outrefsnot just suspected ones, and they store additional path information for each inref. 6.3.3 Concurrency The description so far assumed that back traces used the information computed during previous local traces and there were no intervening modifications. <p> The space overhead is more than migration, which consists of destination information in suspected inrefs and outrefs (O (n i + n o )), and storage of surrogates for migrated objects. However, the space overhead of back tracing is less than other schemes with locality <ref> [Sch89, LC97] </ref>. These other schemes require complete local-reachability information between inrefs and outrefsnot just suspected ones, and they store additional path information for each inref. Back traces are conducted concurrently with modifications and forward local traces. <p> An inref i records a set of paths instead of source sites; each path indicates a sequence of inrefs leading to i. Collecting a cycle located on N sites might take O (N 3 ) messages. Recently, Louboutin presented an improved scheme that sends only O (N ) messages <ref> [LC97] </ref>. However, it too requires full inref-outref reachability information, and its space overhead is even larger: each inref i stores a set of vector timestamps; each vector corresponds to a path i is reachable from. Back tracing was proposed earlier by Fuchs [Fuc95].
Reference: [LeL77] <author> G. LeLann. </author> <title> Distributed systems, towards a formal approach. </title> <booktitle> In IFIP Congress, </booktitle> <pages> pages 155-160, </pages> <year> 1977. </year>
Reference-contexts: In this case, object b will be migrated to S, while object d will be migrated to R. Unlike some leader election algorithms <ref> [LeL77] </ref>, estimating the destination does not incorporate termination detection, so sites must guess when destination propagation has completed; we discuss how to make this guess in the next section.
Reference: [LGG + 91] <author> B. Liskov, S. Ghemawat, R. Gruber, P. Johnson, L. Shrira, and M. Williams. </author> <title> Replication in the Harp file system. </title> <booktitle> In Proc. SOSP, </booktitle> <pages> pages 226-238. </pages> <publisher> ACM Press, </publisher> <year> 1991. </year>
Reference-contexts: When a server crashes, it loses the data in its main memory but retains the data on its disk. Further, the server log is stable through replication <ref> [LGG + 91] </ref>. This thesis does not account for disk failures or other non-recoverable failures in servers. 20 A Thor client might crash at any time and never recover. We assume that clients are well-behaved and their crashes do not cause arbitrary or malicious behavior.
Reference: [LJ93] <author> R. D. Lins and R. E. Jones. </author> <title> Cyclic weighted reference counting. </title> <editor> In K. Boyanov, editor, </editor> <booktitle> Proc. Workshop on Parallel and Distributed Processing. </booktitle> <publisher> North Holland, </publisher> <year> 1993. </year>
Reference-contexts: Thus, the scheme does not possess the locality property. Lins et al. proposed such a scheme as cyclic reference counting in a system that used reference counting for local collection instead of local tracing <ref> [LJ93] </ref>. This scheme requires two distributed traces over objects in a subgraph. Jones and Lins improved the scheme such that multiple sites could conduct traces in parallel, but it required global synchronization between sites [JL92].
Reference: [LL92] <author> R. Ladin and B. Liskov. </author> <title> Garbage collection of a distributed heap. </title> <booktitle> In Proc. </booktitle> <address> ICDCS. </address> <publisher> IEEE Press, </publisher> <year> 1992. </year>
Reference-contexts: However, the fixed site becomes a performance and fault tolerance bottleneck. Ladin and Liskov proposed a logically central but physically replicated service that tracks inter-site references and uses Hughes's algorithm to collect cycles <ref> [LL92] </ref>. The central service avoids the need for a distributed algorithm to compute the global threshold. However, cycle collection still depends on timely correspondence between the service and all sites in the system.
Reference: [LQP92] <author> B. Lang, C. Queinniec, and J. Piquer. </author> <title> Garbage collecting the world. </title> <booktitle> In Proc. POPL '92, </booktitle> <pages> pages 39-50. </pages> <publisher> ACM Press, </publisher> <year> 1992. </year>
Reference-contexts: Thus, global marking might never complete in a large system. The challenge in collecting an inter-site garbage cycle is to preserve the locality property, that is, to involve only the sites containing the cycle. This has proven difficult: most previous schemes do not preserve locality <ref> [Ali85, JJ92, LQP92, MKI + 95, RJ96] </ref>. The few that do seem prohibitively complex or costly [SGP90, Sch89, LC97]. We present the first practical scheme with locality to collect inter-site cycles. It has two parts. The first part identifies objects that are highly likely to be cyclic garbagethe suspects. <p> Similar marking schemes have been proposed earlier in the context of distributed garbage collection to collect cyclic garbage. However, previous schemes either propagate marks separately from partition-marks [JJ92], or delay the collection of non-cyclic garbage [Hug85], or are not guaranteed to terminate correctly in the presence of concurrent mutations <ref> [LQP92] </ref>. Our scheme for site-marking has the following desirable properties: * Site-marking is piggybacked on partition-marking so that it has little overhead. * Site-marking does not delay the collection of non-cyclic garbage. <p> Otherwise, site-mark bits for just the inter-partition references would suffice, as in <ref> [Hug85, LQP92] </ref>. 4.2 Starting a Phase When a phase starts, only references in the site's inset are site-marked. The partitions containing these references are unflagged and the rest are flagged. (This satisfies the site-marking invariant.) These actions are performed incrementally as follows. <p> While site-marking may increase the processor overhead of a trace by rescanning some objects, it does not increase the disk overhead of the trace: the partition's pages are fetched into memory for partition-marking anyway. Some previous proposals piggybacked site-marking on partition-marking by dividing the trace into two parts <ref> [LQP92] </ref>. The first traced from site-marked roots and site-marked all objects it reached. The second traced from unmarked roots without site-marking any object. This two-part scheme does not rescan any object. <p> Locality has proven surprisingly difficult to preserve in collecting inter-site cycles; most previous schemes do not preserve locality. For example, some conduct periodic global marking in addition to site-marking [Ali85, JJ92]. The drawbacks of global marking can be alleviated by marking within groups of selected sites <ref> [LQP92, MKI + 95, RJ96] </ref>, but inter-group cycles might never be collected. Few schemes for collecting inter-site cycles have the locality property. A prominent technique is to migrate an inter-site garbage cycle to a single site, where it is collected by site-marking [Bis77, SGP90]. <p> A group trace treats all references from outside the group as roots. The problem with group tracing is configuring groups in order to collect all inter-site cycles. Lang et al.. proposed using a tree-like hierarchy of embedded groups <ref> [LQP92] </ref>. This ensures that each cycle is covered by some group, but the smallest group covering, say, a two-site cycle may contain many more sites. Further, the policy for forming and disbanding groups dynamically is unclear. Maeda et al. proposed forming groups using subgraph tracing [MKI + 95].
Reference: [LSW91] <author> B. Liskov, L. Shrira, and J. Wroclawski. </author> <title> Efficient at-most-once messages based on synchronized clocks. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 9(2) </volume> <pages> 125-142, </pages> <year> 1991. </year>
Reference-contexts: Clients and servers may be distributed over a wide-area network. We assume the presence of a reliable channel for ordered delivery of messages between any pair of sites. Such delivery can be provided efficiently even if the underlying network is unreliable <ref> [Pos81, LSW91, Mah97] </ref>. However, all practical protocols for reliable delivery might lose the last message if an end-site crashes.
Reference: [Mah93a] <author> U. Maheshwari. </author> <title> Distributed garbage collection in a client-server persistent object system. </title> <editor> In E. Moss, P. R. Wilson, and B. Zorn, editors, </editor> <booktitle> OOPSLA/ECOOP '93 Workshop on Garbage Collection in Object-Oriented Systems, </booktitle> <year> 1993. </year>
Reference-contexts: When the count of a reference reduces to zero, it is removed from the inset. On the other hand, our scheme effectively records the identities of the source sites for each reference in the inset, a technique known as reference listing <ref> [Mah93a, BEN + 93] </ref>. Reference listing keeps more information than reference counting, but we use it for the following reasons: 1. Reference listing tolerates permanent site failures. If a client or a server X fails permanently, other servers need simply remove their inlists from X.
Reference: [Mah93b] <author> U. Maheshwari. </author> <title> Distributed garbage collection in a client-server, transactional, persistent object system. Technical Report MIT/LCS/TR-574, </title> <publisher> MIT Press, </publisher> <year> 1993. </year>
Reference-contexts: This protocol uses a proxy server per client that must be contacted whenever the client approaches a new server. This approach is not suitable if clients browse over many different servers; a light-weight protocol is desirable in that case. We have studied one such protocol based on leases <ref> [Mah93b] </ref>. Here, a client must periodically renew leases with servers that have stored information for it. A ban protocol may be applied to fields outside of garbage collection where it is necessary for all servers to ban a client before discarding state about the client, e.g., in on-line financial services.
Reference: [Mah97] <author> U. Maheshwari. Hula: </author> <title> An efficient protocol for reliable delivery of messages. </title> <type> Technical Report Technical Report MIT/LCS/TR-720, </type> <institution> MIT Laboratory for Computer Science, </institution> <year> 1997. </year>
Reference-contexts: Clients and servers may be distributed over a wide-area network. We assume the presence of a reliable channel for ordered delivery of messages between any pair of sites. Such delivery can be provided efficiently even if the underlying network is unreliable <ref> [Pos81, LSW91, Mah97] </ref>. However, all practical protocols for reliable delivery might lose the last message if an end-site crashes.
Reference: [MKI + 95] <author> M. Maeda, H. Konaka, Y. Ishikawa, T. T. iyo, A. Hori, and J. Nolte. </author> <title> On-the-fly global garbage collection based on partly mark-sweep. </title> <editor> In H. Baker, editor, </editor> <booktitle> Proc. IWMM, Lecture Notes in Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1995. </year>
Reference-contexts: Thus, global marking might never complete in a large system. The challenge in collecting an inter-site garbage cycle is to preserve the locality property, that is, to involve only the sites containing the cycle. This has proven difficult: most previous schemes do not preserve locality <ref> [Ali85, JJ92, LQP92, MKI + 95, RJ96] </ref>. The few that do seem prohibitively complex or costly [SGP90, Sch89, LC97]. We present the first practical scheme with locality to collect inter-site cycles. It has two parts. The first part identifies objects that are highly likely to be cyclic garbagethe suspects. <p> Locality has proven surprisingly difficult to preserve in collecting inter-site cycles; most previous schemes do not preserve locality. For example, some conduct periodic global marking in addition to site-marking [Ali85, JJ92]. The drawbacks of global marking can be alleviated by marking within groups of selected sites <ref> [LQP92, MKI + 95, RJ96] </ref>, but inter-group cycles might never be collected. Few schemes for collecting inter-site cycles have the locality property. A prominent technique is to migrate an inter-site garbage cycle to a single site, where it is collected by site-marking [Bis77, SGP90]. <p> This ensures that each cycle is covered by some group, but the smallest group covering, say, a two-site cycle may contain many more sites. Further, the policy for forming and disbanding groups dynamically is unclear. Maeda et al. proposed forming groups using subgraph tracing <ref> [MKI + 95] </ref>. A group consists of sites reached transitively from some objects suspected to be cyclic garbage. This work was done in the context of local tracing and inter-site weighted reference counting. Rodrigues and Jones proposed an improved scheme in the context of inter-site reference listing [RJ96].
Reference: [ML94] <author> U. Maheshwari and B. Liskov. </author> <title> Fault-tolerant distributed garbage collection in a client-server object-oriented database. </title> <booktitle> In Proc. </booktitle> <address> PDIS. </address> <publisher> IEEE Press, </publisher> <year> 1994. </year> <month> 95 </month>
Reference-contexts: Such a trace would not be timely or fault tolerant because every site must wait until the global trace has finished. Timeliness and fault tolerance require that a site trace local objects independently of other sites. This is the approach taken in many distributed systems <ref> [Ali85, Bev87, SDP92, JJ92, BEN + 93, ML94] </ref>. Local tracing minimizes inter-site dependence. In particular, garbage that is not referenced from other sites is collected locally. Further, a chain of garbage objects spanning multiple sites is collected through cooperation within the sites holding the chain. <p> However, identifying such references requires additional information, which varies among existing schemes for partitioned or distributed collection, e.g., remembered sets [Ung84, Sob88], reference counts [Bev87, Piq91], and reference source-listing <ref> [Bis77, SDP92, BEN + 93, ML94, AGF95, MMH96] </ref>. Section 3.3 presents a new form of reference source-listing that makes it efficient to both add and remove references in insets, while using less space than any previous scheme. The above scheme successfully collects chains of garbage objects across multiple partitions. <p> Any partition trace scans all of these pages for relevant roots. On the other hand, many distributed collectors maintain both insets and outsets for inter-site references <ref> [SDP92, BEN + 93, ML94] </ref>. However, insets and outsets at different sites do not share translists. <p> On the other hand, different sites conduct local traces asynchronously, so inter-site references in modified objects must be processed eagerly. Nonetheless, there are various protocols for deferring or avoiding add messages without compromising safety and for tolerating lost messages <ref> [SDP92, BEN + 93, ML94] </ref>. Sections 5.2 and 5.3 describe new protocols to add client-to-server and server-to-server references. When S does a local trace, it removes the references in its outlists that were not traced, and sends remove messages for them to their target sites. <p> A client may fetch a large amount of data from a server, potentially containing millions of references. Recording all such references in a translist will use a lot of space and time, and delay fetch requests <ref> [ML94] </ref>. Another problem with treating all references held by clients as roots is that it might prevent the collection of garbage objects: If the pages cached by a client happen to contain a bunch of garbage objects, the server will not collect that garbage.
Reference: [ML95] <author> U. Maheshwari and B. Liskov. </author> <title> Collecting cyclic distributed garbage by controlled migration. </title> <booktitle> In Proc. PODC, </booktitle> <pages> pages 57-63, </pages> <year> 1995. </year>
Reference-contexts: This part has the luxury of using techniques that would be too costly if applied to all objects but are acceptable if applied only to suspects. We present two alternatives for checking suspects. The first migrates the suspects such that a distributed cycle converges to a single site <ref> [ML95] </ref>. Unlike previous migration-based proposals [SGP90], it avoids migration as much as possible: both in the number of objects migrated and the number of times they are migrated. The second technique traces back from the suspects to check if they are reachable from a persistent root. <p> The oldest among these is migrating a suspected distributed garbage cycle to a single site [Bis77]. Since migration is expensive, it is crucial to use a good heuristic for finding suspects; we proposed the distance heuristic in this context earlier <ref> [ML95] </ref>. However, some systems do not support migration due to security or autonomy constraints or due to heterogeneous architecture. Those that do must patch references to migrated objects. Shapiro et al.. suggested virtual migration [SGP90]. Here, an object changes its logical space without migrating physically.
Reference: [ML96] <author> U. Maheshwari and B. Liskov. </author> <title> Partitioned garbage collection of a large object store. </title> <type> Technical Report MIT/LCS/TR-699, </type> <institution> MIT LCS, </institution> <year> 1996. </year>
Reference-contexts: If this organization were used for inter-partition references, it would have a higher space overhead and require safety invariants between insets and outsets. We experimented with such a technique earlier <ref> [ML96] </ref>; it was much more complex than the current technique due to the need to maintain invariants.
Reference: [ML97a] <author> U. Maheshwari and B. Liskov. </author> <title> Collecting distributed garbage cycles by back tracing. </title> <booktitle> In Proc. </booktitle> <address> PODC, </address> <year> 1997. </year>
Reference-contexts: The suspect barrier is implemented by examining the set of objects accessed by a transaction at prepare time. (For a description of the suspect barrier in an RPC-based system, where references are transferred between sites by direct messages, see <ref> [ML97a] </ref>.) Since suspected objects are highly likely to be garbage, the suspect barrier is rarely invoked. The suspect barrier maintains the local safety invariant: For any suspected outref o, o:inreach includes all inrefs o is locally reachable from. We show below that the suspect barrier preserves the local safety invariant. <p> For a proof of safety of the clean rule in an RPC-based system, see <ref> [ML97a] </ref>. Below we discuss safety in a transactional system. An additional problem arises in transactional systems because servers may prepare a transaction at different times. The problem is illustrated in the context of Figure 6.16.
Reference: [ML97b] <author> U. Maheshwari and B. Liskov. </author> <title> Partitioned garbage collection in a large object store. </title> <booktitle> In Proc. SIGMOD. </booktitle> <publisher> ACM Press, </publisher> <year> 1997. </year>
Reference-contexts: We present a site-wide marking scheme for collecting cycles between partitions on the same site. Complementary global marking has been proposed earlier to collect cyclic garbage in partitioned schemes. We present the first such scheme that has the following features <ref> [ML97b] </ref>: 12 1. It piggybacks site-wide marking on partition tracing, adding little overhead to the base scheme. 2. It does not delay the collection of non-cyclic garbage. 3. It terminates correctly in the presence of concurrent modifications. The scheme also preserves the disk-efficient nature of partition tracing.
Reference: [MMH96] <author> J. E. B. Moss, D. S. Munro, and R. L. Hudson. Pmos: </author> <title> A complete and coarse-grained incremental garbage collector for persistent object stores. </title> <booktitle> In Proc. 7th Workshop on Persistent Object Systems, </booktitle> <year> 1996. </year>
Reference-contexts: Thus, timeliness and efficiency require that the disk space be divided into smaller partitions that are traced independently. This is the approach taken in many single-site systems with large, disk-based heaps <ref> [Bis77, YNY94, AGF95, MMH96, CKWZ96] </ref>. Ideally, partitions should be large enough to be an efficient unit of tracing, and small enough to fit in a fraction of main memory. <p> However, identifying such references requires additional information, which varies among existing schemes for partitioned or distributed collection, e.g., remembered sets [Ung84, Sob88], reference counts [Bev87, Piq91], and reference source-listing <ref> [Bis77, SDP92, BEN + 93, ML94, AGF95, MMH96] </ref>. Section 3.3 presents a new form of reference source-listing that makes it efficient to both add and remove references in insets, while using less space than any previous scheme. The above scheme successfully collects chains of garbage objects across multiple partitions. <p> Arranging inter-partition references into translists and sharing them between insets and outsets provides a cheap mechanism to maintain both insets and outsets. 3.3.1 Comparison with Previous Work Most other single-site partitioned collectors implement insets as a sequence of pairs hreference, source-partitioni and do not provide mechanisms to find the outset <ref> [AGF95, MMH96] </ref>. The scheme by Amsaleg et al. scans the insets of all partitions after a trace to remove untraced references [AGF95]. This approach would not scale to a large number of partitions. <p> This approach would not scale to a large number of partitions. The scheme by Moss et al. computes the outset whenever a page is fetched and also when a modified page is evicted, and applies the differences to insets <ref> [HM92, MMH96] </ref>. This approach would delay applications when they fetch pages. Some generational collectors implement insets as remembered sets [Ung84, Sob88]. They record the locationsat the level of a word, object, or pagethat may contain inter-partition references. <p> Thus, a inter-partition garbage cycle that spans partitions P i1 ; : : : ; P im is collected when the partition numbered M ax (i1; : : : ; im) is traced. System PMOS collects inter-partition garbage cycles by grouping partitions into trains <ref> [HM92, MMH96] </ref>. Trains are ordered by age. When a partition is traced, objects that are reachable from a site-level root or a newer train are copied to newer trains, while other objects are copied to a new partition within the same train.
Reference: [Mos92] <author> J. E. B. Moss. </author> <title> Working with persistent objects: To swizzle or not to swizzle. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 18(3), </volume> <year> 1992. </year>
Reference-contexts: One solution is to type-check an object when it is fetched into the client cache or when a reference is unswizzled <ref> [Mos92] </ref>, and to abort the transaction on a mismatch. Since fetch-time type-checking is expensive in a system with subtyping, we provide alternative solutions to the two mismatch problems based on invalidation messages.
Reference: [ONG93] <author> J. W. O'Toole, S. M. Nettles, and D. Gifford. </author> <title> Concurrent compacting garbage collection of a persistent heap. </title> <booktitle> In Proc. 14th SOSP, </booktitle> <pages> pages 161-174, </pages> <year> 1993. </year>
Reference-contexts: most object stores contain such a log to support transactions. (A transaction is a sequence of operations that behaves atomically with respect to other transactions and crashes [Gra78].) Partitioned garbage collection involves a wide range of other issues such as the choice of the tracing algorithm (marking, copying [Bak78], replicating <ref> [ONG93] </ref>, etc.), the selection of partitions to trace [CWZ94], the rate of starting traces [CKWZ96], handling transactional rollback [AGF95], etc. This thesis either does not cover the above issues or addresses them only marginally. <p> The significance of these techniques is evaluated in Section 3.5. New inter-partition references are found lazily by scanning modified objects in the log. (Other garbage collectors have used the log to process modified objects lazily for various purposes <ref> [ONG93] </ref>.) We refer to scanning objects for inter-partition references as inter-scanning to distinguish it from scanning objects as part of a trace. An object in the log must be inter-scanned before it is installed, since information about the modification is lost at that point.
Reference: [Piq91] <author> J. M. Piquer. </author> <title> Indirect reference counting: A distributed garbage collection algorithm. </title> <editor> In Aarts et al., editors, </editor> <booktitle> PARLE'91 Parallel Architectures and Languages Europe, volume 505 of Lecture Notes in Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1991. </year>
Reference-contexts: However, identifying such references requires additional information, which varies among existing schemes for partitioned or distributed collection, e.g., remembered sets [Ung84, Sob88], reference counts <ref> [Bev87, Piq91] </ref>, and reference source-listing [Bis77, SDP92, BEN + 93, ML94, AGF95, MMH96]. Section 3.3 presents a new form of reference source-listing that makes it efficient to both add and remove references in insets, while using less space than any previous scheme. <p> The outset of a site contains the translists to other sites, while the inset either contains copies of the translists from other sites or it consists of a single set of incoming references with a count of the source sites for each reference <ref> [Bev87, Piq91] </ref>. If this organization were used for inter-partition references, it would have a higher space overhead and require safety invariants between insets and outsets. We experimented with such a technique earlier [ML96]; it was much more complex than the current technique due to the need to maintain invariants. <p> In systems using inter-site reference counting, the target site records a count of the source sites that hold a reference to a given local objectwithout recording the identities of the individual source sites <ref> [Bev87, Piq91] </ref>. When the count of a reference reduces to zero, it is removed from the inset. On the other hand, our scheme effectively records the identities of the source sites for each reference in the inset, a technique known as reference listing [Mah93a, BEN + 93]. <p> of R to T ) ) (b 2 inlist of T from R) or (b 2 guardlist at G and b 2 outlist of G to T ) or (b 2 guardlist at T ) The Commit Part of the Add Protocol The add protocol is similar to indirect protection <ref> [Piq91, SDP92] </ref>. The problem in implementing it in a client-caching system is that the client does not always know who the guardian is. If the client is not a guardian itself, any participant could be a guardian. Therefore, it must broadcast a request to guard b to all participants.
Reference: [Pos81] <author> J. Postel. </author> <title> DoD standard transmition control protocol. </title> <address> DARPA-Internet RFC-793, </address> <year> 1981. </year>
Reference-contexts: Clients and servers may be distributed over a wide-area network. We assume the presence of a reliable channel for ordered delivery of messages between any pair of sites. Such delivery can be provided efficiently even if the underlying network is unreliable <ref> [Pos81, LSW91, Mah97] </ref>. However, all practical protocols for reliable delivery might lose the last message if an end-site crashes.
Reference: [RJ96] <author> H. Rodrigues and R. Jones. </author> <title> A cyclic distributed garbage collector for network objects. </title> <booktitle> In Proc. 10th Workshop on Distributed Algorithms, </booktitle> <year> 1996. </year>
Reference-contexts: Thus, global marking might never complete in a large system. The challenge in collecting an inter-site garbage cycle is to preserve the locality property, that is, to involve only the sites containing the cycle. This has proven difficult: most previous schemes do not preserve locality <ref> [Ali85, JJ92, LQP92, MKI + 95, RJ96] </ref>. The few that do seem prohibitively complex or costly [SGP90, Sch89, LC97]. We present the first practical scheme with locality to collect inter-site cycles. It has two parts. The first part identifies objects that are highly likely to be cyclic garbagethe suspects. <p> Locality has proven surprisingly difficult to preserve in collecting inter-site cycles; most previous schemes do not preserve locality. For example, some conduct periodic global marking in addition to site-marking [Ali85, JJ92]. The drawbacks of global marking can be alleviated by marking within groups of selected sites <ref> [LQP92, MKI + 95, RJ96] </ref>, but inter-group cycles might never be collected. Few schemes for collecting inter-site cycles have the locality property. A prominent technique is to migrate an inter-site garbage cycle to a single site, where it is collected by site-marking [Bis77, SGP90]. <p> A group consists of sites reached transitively from some objects suspected to be cyclic garbage. This work was done in the context of local tracing and inter-site weighted reference counting. Rodrigues and Jones proposed an improved scheme in the context of inter-site reference listing <ref> [RJ96] </ref>. One drawback of this approach is that multiple sites on the same cycle may initiate separate groups simultaneously, 85 which would fail to collect the cycle. Conversely, a group may include more sites than necessary because a garbage cycle may point to chains of garbage or live objects.
Reference: [Sch89] <author> M. Schelvis. </author> <title> Incremental distribution of timestamp packets a new approach to distributed garbage collection. </title> <journal> ACM SIGPLAN Notices, </journal> <volume> 24(10) </volume> <pages> 37-48, </pages> <year> 1989. </year>
Reference-contexts: This has proven difficult: most previous schemes do not preserve locality [Ali85, JJ92, LQP92, MKI + 95, RJ96]. The few that do seem prohibitively complex or costly <ref> [SGP90, Sch89, LC97] </ref>. We present the first practical scheme with locality to collect inter-site cycles. It has two parts. The first part identifies objects that are highly likely to be cyclic garbagethe suspects. <p> The space occupied by inreaches or outreaches is O (n i fi n o ), where n i and n o are the number of suspected inrefs and suspected outrefs. The space overhead is less than other non-migration-based schemes with locality <ref> [Sch89, LC97] </ref>. These other schemes require complete local-reachability information between inrefs and outrefsnot just suspected ones, and they store additional path information for each inref. 6.3.3 Concurrency The description so far assumed that back traces used the information computed during previous local traces and there were no intervening modifications. <p> The space overhead is more than migration, which consists of destination information in suspected inrefs and outrefs (O (n i + n o )), and storage of surrogates for migrated objects. However, the space overhead of back tracing is less than other schemes with locality <ref> [Sch89, LC97] </ref>. These other schemes require complete local-reachability information between inrefs and outrefsnot just suspected ones, and they store additional path information for each inref. Back traces are conducted concurrently with modifications and forward local traces. <p> Shapiro et al.. suggested virtual migration [SGP90]. Here, an object changes its logical space without migrating physically. However, a logical space may span a number of sites, so a local trace must involve inter-site tracing messages. Schelvis proposed forwarding local-reachability information along outgoing inter-site references <ref> [Sch89] </ref>. Objects are identified by unique timestamps to detect concurrent mutator activity. This algorithm is intricate and difficult to understand; however, some of its problems are apparent. The algorithm requires full reachability information between all inrefs and outrefs (not just suspected ones).
Reference: [SDP92] <author> M. Shapiro, P. Dickman, and D. Plainfoss e. </author> <title> Robust, distributed references and acyclic garbage collection. </title> <booktitle> In Proc. </booktitle> <address> PODC, </address> <year> 1992. </year>
Reference-contexts: Such a trace would not be timely or fault tolerant because every site must wait until the global trace has finished. Timeliness and fault tolerance require that a site trace local objects independently of other sites. This is the approach taken in many distributed systems <ref> [Ali85, Bev87, SDP92, JJ92, BEN + 93, ML94] </ref>. Local tracing minimizes inter-site dependence. In particular, garbage that is not referenced from other sites is collected locally. Further, a chain of garbage objects spanning multiple sites is collected through cooperation within the sites holding the chain. <p> However, identifying such references requires additional information, which varies among existing schemes for partitioned or distributed collection, e.g., remembered sets [Ung84, Sob88], reference counts [Bev87, Piq91], and reference source-listing <ref> [Bis77, SDP92, BEN + 93, ML94, AGF95, MMH96] </ref>. Section 3.3 presents a new form of reference source-listing that makes it efficient to both add and remove references in insets, while using less space than any previous scheme. The above scheme successfully collects chains of garbage objects across multiple partitions. <p> Any partition trace scans all of these pages for relevant roots. On the other hand, many distributed collectors maintain both insets and outsets for inter-site references <ref> [SDP92, BEN + 93, ML94] </ref>. However, insets and outsets at different sites do not share translists. <p> On the other hand, different sites conduct local traces asynchronously, so inter-site references in modified objects must be processed eagerly. Nonetheless, there are various protocols for deferring or avoiding add messages without compromising safety and for tolerating lost messages <ref> [SDP92, BEN + 93, ML94] </ref>. Sections 5.2 and 5.3 describe new protocols to add client-to-server and server-to-server references. When S does a local trace, it removes the references in its outlists that were not traced, and sends remove messages for them to their target sites. <p> of R to T ) ) (b 2 inlist of T from R) or (b 2 guardlist at G and b 2 outlist of G to T ) or (b 2 guardlist at T ) The Commit Part of the Add Protocol The add protocol is similar to indirect protection <ref> [Piq91, SDP92] </ref>. The problem in implementing it in a client-caching system is that the client does not always know who the guardian is. If the client is not a guardian itself, any participant could be a guardian. Therefore, it must broadcast a request to guard b to all participants.
Reference: [SGP90] <author> M. Shapiro, O. Gruber, and D. Plainfoss e. </author> <title> A garbage detection protocol for a realistic distributed object-support system. </title> <institution> Rapports de Recherche 1320, INRIA-Rocquencourt, </institution> <year> 1990. </year>
Reference-contexts: This has proven difficult: most previous schemes do not preserve locality [Ali85, JJ92, LQP92, MKI + 95, RJ96]. The few that do seem prohibitively complex or costly <ref> [SGP90, Sch89, LC97] </ref>. We present the first practical scheme with locality to collect inter-site cycles. It has two parts. The first part identifies objects that are highly likely to be cyclic garbagethe suspects. <p> We present two alternatives for checking suspects. The first migrates the suspects such that a distributed cycle converges to a single site [ML95]. Unlike previous migration-based proposals <ref> [SGP90] </ref>, it avoids migration as much as possible: both in the number of objects migrated and the number of times they are migrated. The second technique traces back from the suspects to check if they are reachable from a persistent root. <p> Few schemes for collecting inter-site cycles have the locality property. A prominent technique is to migrate an inter-site garbage cycle to a single site, where it is collected by site-marking <ref> [Bis77, SGP90] </ref>. However, previous schemes based on migration are prone to migrating live objects besides garbage cycles, which is undesirable because migration is expensive. We present a practical scheme with locality to collect inter-site cycles. It has two parts. <p> Old references to a surrogate are updated in the background. As with normal objects, a surrogate is collected when it is not reachable from applications. Migration has been proposed earlier to collect distributed cycles <ref> [Bis77, SGP90] </ref>. However, previous proposals used weak heuristics to decide which objects to migrate. A popular heuristic was to move to all objects not locally reachable from a global root. <p> Other schemes migrate objects to sites that refer to them. To ensure that objects in a cycle converge on the same site instead of following each other in circles, sites are totally ordered and migration is allowed in one direction only, say, from higher-id sites to lower-id sites <ref> [SGP90] </ref>. We refer to this rule as the one-way rule. The one-way rule ensures convergence, but objects on a multi-site cycle might be migrated multiple times before they converge on a site. <p> However, some systems do not support migration due to security or autonomy constraints or due to heterogeneous architecture. Those that do must patch references to migrated objects. Shapiro et al.. suggested virtual migration <ref> [SGP90] </ref>. Here, an object changes its logical space without migrating physically. However, a logical space may span a number of sites, so a local trace must involve inter-site tracing messages. Schelvis proposed forwarding local-reachability information along outgoing inter-site references [Sch89].
Reference: [Sob88] <author> P. Sobalvarro. </author> <title> A lifetime-based garbage collector for Lisp systems on general-purpose computers. </title> <type> Technical Report AITR-1417, </type> <institution> MIT, AI Lab, </institution> <year> 1988. </year>
Reference-contexts: Therefore, any reference e that is in the inset of another partition on account of P alone and that was not visited by the trace of P is removed. However, identifying such references requires additional information, which varies among existing schemes for partitioned or distributed collection, e.g., remembered sets <ref> [Ung84, Sob88] </ref>, reference counts [Bev87, Piq91], and reference source-listing [Bis77, SDP92, BEN + 93, ML94, AGF95, MMH96]. Section 3.3 presents a new form of reference source-listing that makes it efficient to both add and remove references in insets, while using less space than any previous scheme. <p> The scheme by Moss et al. computes the outset whenever a page is fetched and also when a modified page is evicted, and applies the differences to insets [HM92, MMH96]. This approach would delay applications when they fetch pages. Some generational collectors implement insets as remembered sets <ref> [Ung84, Sob88] </ref>. They record the locationsat the level of a word, object, or pagethat may contain inter-partition references. The location information allows the collector to update references when an object is 25 moved for compacting storage. <p> Further, storing locations at a fine granularity results in more information if multiple locations contain the same reference. Some other generational schemes use card marking, which remembers a single set of pages that might contain inter-partition referencesundistinguished by the target partition <ref> [Sob88] </ref>. Any partition trace scans all of these pages for relevant roots. On the other hand, many distributed collectors maintain both insets and outsets for inter-site references [SDP92, BEN + 93, ML94]. However, insets and outsets at different sites do not share translists.
Reference: [Tar72] <author> R. Tarjan. </author> <title> Depth first search and linear graph algorithms. </title> <journal> SIAM Journal of Computing, </journal> <volume> 1(2), </volume> <year> 1972. </year>
Reference-contexts: In general, a backward edge introduces a strongly connected component, and the outreaches of objects in a strongly connected component should all be equal. Fortunately, strongly connected components can be computed efficiently during a depth first traversal with linear performance <ref> [Tar72] </ref>. For each object, the algorithm finds the first object visited in its component, called its leader. The algorithm uses a counter to mark objects in the order they are visited. It also uses an auxiliary stack to find the objects in a component.
Reference: [Ung84] <author> D. M. Ungar. </author> <title> Generation scavenging: A non-disruptive high performance storage reclamation algorithm. </title> <journal> ACM SIGPLAN Notices, </journal> <volume> 19(5) </volume> <pages> 157-167, </pages> <year> 1984. </year>
Reference-contexts: Third, partitions provide an opportunity for faster and more efficient garbage collection because the collector can focus on partitions that are likely to contain the most garbage. This is similar to generational collectors which collect newer partitions more frequently <ref> [Ung84] </ref>. Although the age-based heuristics of generational collectors are not applicable to persistent stores [Bak93], other heuristics are available for selecting partitions [CWZ94]. Fourth, if the server crashes in the middle of a trace, the work done during the trace is wasted. <p> Therefore, any reference e that is in the inset of another partition on account of P alone and that was not visited by the trace of P is removed. However, identifying such references requires additional information, which varies among existing schemes for partitioned or distributed collection, e.g., remembered sets <ref> [Ung84, Sob88] </ref>, reference counts [Bev87, Piq91], and reference source-listing [Bis77, SDP92, BEN + 93, ML94, AGF95, MMH96]. Section 3.3 presents a new form of reference source-listing that makes it efficient to both add and remove references in insets, while using less space than any previous scheme. <p> The scheme by Moss et al. computes the outset whenever a page is fetched and also when a modified page is evicted, and applies the differences to insets [HM92, MMH96]. This approach would delay applications when they fetch pages. Some generational collectors implement insets as remembered sets <ref> [Ung84, Sob88] </ref>. They record the locationsat the level of a word, object, or pagethat may contain inter-partition references. The location information allows the collector to update references when an object is 25 moved for compacting storage. <p> We describe distributed schemes in Chapter 6. Here, we describe schemes used in single-site, partitioned systems. Generational collectors collect inter-partition garbage cycles <ref> [Ung84] </ref>. They order the partitions, say P 1 ; : : : ; P n (often by age such that P 1 is the newest partition and P n the oldest).
Reference: [WLM92] <author> P. R. Wilson, M. S. Lam, and T. G. Moher. </author> <title> Caching considerations for generational garbage collection. </title> <booktitle> In Conference Record of the 1992 ACM Symposium on Lisp and Functional Programming, </booktitle> <pages> pages 32-42. </pages> <publisher> ACM Press, </publisher> <year> 1992. </year> <month> 96 </month>
Reference-contexts: An old-view trace scans an object at most oncethe state of the object when the trace startedand it need not scan new objects created during the trace because they are created marked. Such a trace is also known as snapshot at the beginning <ref> [WLM92] </ref>. A new-view trace sees the most recent view of the heap. It must scan new and modified objects, possibly multiple times, such that when the last object is scanned, no further modifications are pending. Such tracing is also known as incremental update [WLM92]. <p> also known as snapshot at the beginning <ref> [WLM92] </ref>. A new-view trace sees the most recent view of the heap. It must scan new and modified objects, possibly multiple times, such that when the last object is scanned, no further modifications are pending. Such tracing is also known as incremental update [WLM92]. An old-view trace is more conservative because garbage generated during the current trace is not collected until the next trace.
Reference: [YNY94] <author> V. Yong, J. Naughton, and J. Yu. </author> <title> Storage reclamation and reorganization in client--server persistent object stores. </title> <booktitle> In Proc. Data Engineering, </booktitle> <pages> pages 120-133. </pages> <publisher> IEEE Press, </publisher> <year> 1994. </year>
Reference-contexts: Each site may have a large disk space and a relatively small main memory. Often, the memory size is only a hundredth of the disk size. Therefore, a trace of the site's objects is likely to thrash on disk due to poor locality of references <ref> [YNY94] </ref>. In particular, a disk page might be fetched and evicted many times as different objects on the page are scanned. This is undesirable for two reasons. First, the trace might take a long time to finish, preventing timely collection of garbage. <p> Thus, timeliness and efficiency require that the disk space be divided into smaller partitions that are traced independently. This is the approach taken in many single-site systems with large, disk-based heaps <ref> [Bis77, YNY94, AGF95, MMH96, CKWZ96] </ref>. Ideally, partitions should be large enough to be an efficient unit of tracing, and small enough to fit in a fraction of main memory. <p> Therefore, a trace of the entire disk is likely to have poor locality of reference with respect to available memory. It would thrash on disk, i.e., fetch and evict a disk page many times in order to scan different objects in the page <ref> [YNY94, AGF95] </ref>. On the other hand, a partition trace fetches the pages of one partition into memory and scans all live objects in them before fetching another partition.
References-found: 62

