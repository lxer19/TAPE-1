URL: http://www.csc.ncsu.edu/faculty/savage/AVAILABLE_FOR_MAILING/restricted_growth_gc.ps
Refering-URL: http://www.csc.ncsu.edu/faculty/savage/papers.html
Root-URL: http://www.csc.ncsu.edu
Title: Gray Codes for Set Partitions and Restricted Growth Tails  
Author: Frank Ruskey Carla Savage 
Address: Victoria, B.C., V8W 3P6, Canada  Raleigh, North Carolina, 27612-8206  
Affiliation: Department of Computer Science University of Victoria  Department of Computer Science North Carolina State University  
Abstract: We survey results on generating set partitions, S(n), and restricted growth tails, T (n; k), with an emphasis on Gray code listings, in which the change between successive elements is minimal. Although there is a well-known bijection between S(n) and T (n; 0), it preserves minimal changes in only one direction. We show that a minimal Gray code listing for T (n; k) is not always possible, although for a slight relaxation of the adjacency criterion, we can construct Gray codes for all n &gt; 0, k 0. One consequence is a Gray code for S(n) in which only one element changes, to a cyclically adjacent block, between successive partitions on the list. This generalizes earlier work of Knuth for S(n) and Ehrlich for T (n; 0). Our construction for T (n; k) yields Gray codes which can be required to be cyclic, or to go from the lexicographically minimum to maximum elements, properties not possessed by the Gray codes of Ehrlich and Knuth. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> G. Ehrlich, </author> <title> "Loopless algorithms for generating permutations, combinations, and other combinatorial configurations," </title> <note> Journal of the ACM 20 (1973) 500-513. </note>
Reference-contexts: A listing of R (n) is a strict Gray code if successive elements are strictly adjacent. Ehrlich observed that a strict Gray code for R (n) is impossible for infinitely many values of n <ref> [1] </ref>. <p> b (n) = fa 1 : : : a n 2 R (n) j maxfa 1 ; : : : ; a n g = bg: Ehrlich presents an algorithm for generating S b (n) in which successive partitions differ only in that two elements have moved to different blocks <ref> [1] </ref>. Ruskey describes a Gray code for R b (n) in which successive elements differ in one position, but possibly by more than 1 in that position [7]. We show in this section that in general, R b (n) has neither a strict nor a weak Gray code. <p> Assume that a listing algorithm must generate N objects of size O (n), where usually n o N. The efficiency is measured by the time to generate the first object and the delay between successive elements generated. In a loop-free algorithm <ref> [1] </ref>, the start-up time is O (n) and the worst-case delay is constant, independent of n and N. Next best is to have a constant amortized time (CAT) algorithm in which the total time is O (N), even though some delays may be large [7]. In his 1973 paper, Ehrlich [1] <p> <ref> [1] </ref>, the start-up time is O (n) and the worst-case delay is constant, independent of n and N. Next best is to have a constant amortized time (CAT) algorithm in which the total time is O (N), even though some delays may be large [7]. In his 1973 paper, Ehrlich [1] gave a loop-free implementation of his Gray code algorithm for R (n) and a loop-free algorithm for generating S b (n), results which have been overlooked by some later papers. Kaye's 1976 paper contains a CAT implementation of Knuth's Gray code for S (n) [4].
Reference: [2] <author> J.A. Fill and E.M. Reingold, </author> <title> Solutions Manual for Combinatorial Algorithms: Theory and Practice, </title> <publisher> Prentice-Hall, </publisher> <year> 1977. </year>
Reference-contexts: Kaye's 1976 paper contains a CAT implementation of Knuth's Gray code for S (n) [4]. The solutions manual by Fill and Reingold <ref> [2] </ref> for the book by Reingold, Nievergelt, and Deo [5] also presents a Gray Code for S b (n), which they attibute to Brian Hansche. Ruskey gives a CAT implementation of his Gray code for S b (n) [7].
Reference: [3] <author> J. T. Joichi, D. E. White, and S. G. Williamson, </author> <title> "Combinatorial Gray codes," </title> <journal> SIAM Journal on Computing 9, </journal> <volume> No. </volume> <month> 1 </month> <year> (1980) </year> <month> 130-141. 11 </month>
Reference-contexts: For n = 4, the bijection is illustrated in the first two columns of Figure 1. A Gray code for a combinatorial family is a listing of the objects in the family so that successive objects differ in some pre-specified, usually small, way <ref> [3] </ref>. Although any listing algorithm for one of S (n) or R (n) can be used for the other, small changes between objects of one family may be magnified by the bijection.
Reference: [4] <author> R. Kaye, </author> <title> "A Gray code for set partitions," </title> <journal> Information Processing Letters 5, </journal> <volume> No. </volume> <month> 6 </month> <year> (1976) </year> <month> 171-173. </month>
Reference-contexts: However, the RG functions associated with 1 and 2 are 0 0 1 2 0 1 and 0 1 0 2 1 0, which differ in several positions. In <ref> [4] </ref>, Kaye describes a Gray code L (n) for S (n), attributed to Knuth, where between successive partitions, only one element moves and that move is to an adjacent block. <p> Kaye's 1976 paper contains a CAT implementation of Knuth's Gray code for S (n) <ref> [4] </ref>. The solutions manual by Fill and Reingold [2] for the book by Reingold, Nievergelt, and Deo [5] also presents a Gray Code for S b (n), which they attibute to Brian Hansche. Ruskey gives a CAT implementation of his Gray code for S b (n) [7].
Reference: [5] <author> E.M. Reingold and J. Nievergelt and N. Deo, </author> <title> Combinatorial Algorithms: Theory and Practice, </title> <publisher> Prentice-Hall, </publisher> <year> 1977. </year>
Reference-contexts: Kaye's 1976 paper contains a CAT implementation of Knuth's Gray code for S (n) [4]. The solutions manual by Fill and Reingold [2] for the book by Reingold, Nievergelt, and Deo <ref> [5] </ref> also presents a Gray Code for S b (n), which they attibute to Brian Hansche. Ruskey gives a CAT implementation of his Gray code for S b (n) [7]. We conjecture that our new Gray codes for RG tails, T (n; k), can be implemented by a CAT algorithm.
Reference: [6] <author> F. Ruskey, </author> <title> Combinatorial Generation, </title> <note> book in preparation. </note>
Reference-contexts: On the other hand, if R (n) can be listed so that successive elements differ in just one position, then in the corresponding listing of S (n), only one element moves to a different block. In <ref> [6] </ref>, Ruskey describes a modification of Knuth's algorithm in which the associated RG functions differ by at most 2, as follows: if , of odd rank on L (n 1), has b blocks, but its successor has only b 1 blocks, then to the RG function for , append successively 0;
Reference: [7] <author> F. Ruskey, </author> <title> "Simple combinatorial Gray codes constructed by reversing sublists," </title> <booktitle> 4th ISAAC, Hong Kong, Lecture Notes in Computer Science, </booktitle> <month> #762 </month> <year> (1993) </year> <month> 201-208. </month>
Reference-contexts: Ruskey describes a Gray code for R b (n) in which successive elements differ in one position, but possibly by more than 1 in that position <ref> [7] </ref>. We show in this section that in general, R b (n) has neither a strict nor a weak Gray code. <p> In a loop-free algorithm [1], the start-up time is O (n) and the worst-case delay is constant, independent of n and N. Next best is to have a constant amortized time (CAT) algorithm in which the total time is O (N), even though some delays may be large <ref> [7] </ref>. In his 1973 paper, Ehrlich [1] gave a loop-free implementation of his Gray code algorithm for R (n) and a loop-free algorithm for generating S b (n), results which have been overlooked by some later papers. <p> The solutions manual by Fill and Reingold [2] for the book by Reingold, Nievergelt, and Deo [5] also presents a Gray Code for S b (n), which they attibute to Brian Hansche. Ruskey gives a CAT implementation of his Gray code for S b (n) <ref> [7] </ref>. We conjecture that our new Gray codes for RG tails, T (n; k), can be implemented by a CAT algorithm. Acknowledgement. We are grateful to Malcolm Smith for his help with the figures and to the referee for a very careful reading of the paper.
Reference: [8] <author> D. Stanton and D. White, </author> <title> Constructive Combinatorics, </title> <publisher> Springer-Verlag (1986). </publisher>
Reference: [9] <author> S. G. </author> <type> Williamson, </type> <institution> Combinatorics for Computer Science, Computer Science Press (1985). </institution>
Reference-contexts: of Ehrlich to the set of restricted growth tails, T (n; k), which are strings of non-negative integers satisfying a 1 k and a i 1 + maxfa 1 ; : : : ; a i1 ; k 1g. (These are a variation of the T (n; m) used in <ref> [9] </ref> (p. 97) for ranking and unranking set partitions.) Note that T (n; 0) = R (n). In Section 2, we show that for all k there are infinitely many values of n for which T (n; k) has no strict Gray code.
References-found: 9

