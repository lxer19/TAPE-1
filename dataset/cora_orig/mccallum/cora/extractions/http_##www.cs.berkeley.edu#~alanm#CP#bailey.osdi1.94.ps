URL: http://www.cs.berkeley.edu/~alanm/CP/bailey.osdi1.94.ps
Refering-URL: http://www.cs.berkeley.edu/~alanm/CP/bib.html
Root-URL: 
Title: PATHFINDER: A Pattern-Based Packet Classifier  
Author: Mary L. Bailey Burra Gopal Michael A. Pagels Larry L. Peterson Prasenjit Sarkar 
Address: Tucson, AZ 85721  
Affiliation: Department of Computer Science University of Arizona  
Date: November 1994.  
Note: Appears in "Proceedings of the First Symposium on Operating Systems Design and Implementation," Usenix Association,  
Abstract: This paper describes a pattern-based approach to building packet classifiers. One novelty of the approach is that it can be implemented efficiently in both software and hardware. A performance study shows that the software implementation is about twice as fast as existing mechanisms, and that the hardware implementation is currently able to keep up with OC-12 (622Mbps) network links and is likely to operate at gigabit speeds in the near future. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> M. B. Abbott and L. L. Peterson. </author> <title> Increasing network throughput by integrating protocol layers. </title> <journal> IEEE/ACM Transactions on Networking, </journal> <volume> 1(5) </volume> <pages> 600-610, </pages> <month> Oct. </month> <year> 1993. </year>
Reference-contexts: First, it can use this information to determine what code should be invoked to process the packet. For example, it might select a user-level protocol stack [5], or it might call a procedure that has been optimized to handle packets that follow a particular path through the system <ref> [8, 1] </ref>. Second, the OS can use the classification information to acquire the resources needed to process the packet. For example, it might select a buffer into which a packet should be placed [3], or it might determine the priority at which the packet should be processed.
Reference: [2] <author> D. Cohen, G. Finn, R. Felderman, and A. DeSchon. </author> <title> ATOMIC: A low-cost, very-high-speed, local communications architecture. </title> <booktitle> In Proceedings of the 1993 Conference on Parallel Processing, </booktitle> <month> Aug. </month> <year> 1993. </year>
Reference-contexts: One final possibility is to put the classifier on both the host and the adaptor, and to treat the hardware implementation as a cache. We have experimented with this configuration on Sparc workstations connected by the ATOMIC network <ref> [2] </ref>. In this example, the ATOMIC adaptor has a 3-MIPS on-board processor, which was powerful enough to implement only a very restricted version of the software implementation of PATHFINDER.
Reference: [3] <author> P. Druschel and L. L. Peterson. Fbufs: </author> <title> A high-bandwidth cross-domain transfer facility. </title> <booktitle> In Proceedings of the Fourteenth ACM Symposium on Operating Systems Principles, </booktitle> <pages> pages 189-202, </pages> <month> Dec. </month> <year> 1993. </year>
Reference-contexts: Second, the OS can use the classification information to acquire the resources needed to process the packet. For example, it might select a buffer into which a packet should be placed <ref> [3] </ref>, or it might determine the priority at which the packet should be processed. The OS programs a classifier by giving it a set of specifications, each of which is bound to some identifier. <p> As a consequence, it does not support a mechanism like fbufs <ref> [3] </ref>. Buffering on the adaptor implies that incoming packets are held in adaptor memory and only header information is copied to host memory so the classifier can inspect it. Once the classifier makes a decision, the packet can be moved into host memory using either DMA or Programmed I/O.
Reference: [4] <author> P. Druschel, L. L. Peterson, and B. S. Davie. </author> <title> Experience with a high-speed network adaptor: A software perspective. </title> <booktitle> In Proceedings of the SIGCOMM '94 Symposium, </booktitle> <month> Aug. </month> <year> 1994. </year>
Reference-contexts: Each ATM cell has a virtual circuit identifier (VCI) that can be used to demultiplex it <ref> [4] </ref>. One could argue that the availability of VCI's diminishes the need for a PATHFINDER-like classifier.
Reference: [5] <author> C. Maeda and B. Bershad. </author> <title> Protocol service decomposition for high-performance networking. </title> <booktitle> In Proceedings of the Fourteenth ACM Symposium on Operating Systems Principles, </booktitle> <month> Dec. </month> <year> 1993. </year>
Reference-contexts: An operating system can take advantage of a classified packet in several ways. First, it can use this information to determine what code should be invoked to process the packet. For example, it might select a user-level protocol stack <ref> [5] </ref>, or it might call a procedure that has been optimized to handle packets that follow a particular path through the system [8, 1]. Second, the OS can use the classification information to acquire the resources needed to process the packet.
Reference: [6] <author> S. McCnne and V. Jacobson. </author> <title> The bsd packet filter: A new architecture for user-level packet capture. </title> <booktitle> In Proceedings of the USENIX '93 Winter Conference, </booktitle> <pages> pages 259-269, </pages> <month> Jan. </month> <year> 1993. </year>
Reference-contexts: The specification can either be given by a block of imperative code, in which case the classifier can be viewed as an interpretor (this is the case with three well-known systems, MPF [9], BPF <ref> [6] </ref> and CSPF [7]), or the specification can be declarative, that is, given by a pattern to be matched (this is the case for the classifier presented in this paper).
Reference: [7] <author> J. C. Mogul, R. F. Rashid, and M. J. Accetta. </author> <title> The packet filter: An efficient mechanism for user-level network code. </title> <booktitle> In Proceedings of the Eleventh ACM Symposium on Operating Systems Principles, </booktitle> <pages> pages 39-51, </pages> <month> Nov. </month> <year> 1987. </year>
Reference-contexts: The specification can either be given by a block of imperative code, in which case the classifier can be viewed as an interpretor (this is the case with three well-known systems, MPF [9], BPF [6] and CSPF <ref> [7] </ref>), or the specification can be declarative, that is, given by a pattern to be matched (this is the case for the classifier presented in this paper).
Reference: [8] <author> A. B. Montz, D. Mosberger, S. W. O'Malley, L. L. Pe-tersonand, T. A. Proebsting, and J. H. Hartman. </author> <title> Scout: A communications-oriented operating system. </title> <type> Technical Report 94-20, </type> <institution> Department of Computer Science, University of Arizona, </institution> <month> June </month> <year> 1994. </year>
Reference-contexts: First, it can use this information to determine what code should be invoked to process the packet. For example, it might select a user-level protocol stack [5], or it might call a procedure that has been optimized to handle packets that follow a particular path through the system <ref> [8, 1] </ref>. Second, the OS can use the classification information to acquire the resources needed to process the packet. For example, it might select a buffer into which a packet should be placed [3], or it might determine the priority at which the packet should be processed. <p> For the purpose of this paper, a path is an abstraction that encapsulates the code block and all the resources required to process the packet <ref> [8] </ref>. This paper concentrates on how PATHFINDER determines the path to which a packet belongs, and not on how the OS implements and exploits paths.
Reference: [9] <author> M. Yuhara, B. N. Bershad, C. Maeda, and J. E. Moss. </author> <title> Efficient packet demultiplexing for multiple endpoints and large messages. </title> <booktitle> In Winter 1994 Usenix Conference, </booktitle> <month> Jan. </month> <year> 1994. </year>
Reference-contexts: The specification can either be given by a block of imperative code, in which case the classifier can be viewed as an interpretor (this is the case with three well-known systems, MPF <ref> [9] </ref>, BPF [6] and CSPF [7]), or the specification can be declarative, that is, given by a pattern to be matched (this is the case for the classifier presented in this paper). <p> We compiled it on each platform using the native C compiler with full optimization. 4.1.1 Lookup Costs Table 1 compares the per-packet latency of PATHFINDER and MPF <ref> [9] </ref> on the DECStation 5000/200 for a TCP/IP protocol stack having ten open TCP/IP connections that wait for packets to arrive. The experiments were done with both cold and warm caches.
References-found: 9

