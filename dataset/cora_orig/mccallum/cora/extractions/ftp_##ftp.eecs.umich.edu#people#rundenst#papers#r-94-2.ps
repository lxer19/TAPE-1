URL: ftp://ftp.eecs.umich.edu/people/rundenst/papers/r-94-2.ps
Refering-URL: http://www.eecs.umich.edu/~rundenst/group/papers.html
Root-URL: http://www.cs.umich.edu
Email: e-mail: ygra@eecs.umich.edu, rundenst@eecs.umich.edu  
Title: A Transparent Object-Oriented Schema Change Approach Using View Evolution 1  
Author: Young-Gook Ra and Elke A. Rundensteiner 
Keyword: Index Terms Schema Evolution, Object-Oriented View System, Interoperability, Capacity-augmenting Views, Object-Oriented Database.  
Date: April, 1994  
Address: Ann Arbor, MI 48109-2122  
Affiliation: Software Systems Research Laboratory Department of Electrical Engineering and Computer Science The University of Michigan  
Abstract: When a database is shared by many users, updates to the database schema are almost always prohibited because there is a risk of making existing application programs obsolete when they run against the modified schema. This paper addresses the problem by integrating schema evolution with view facilities. Each user is assigned his or her own database view, and develops application programs against the view. When new requirements necessitate schema updates for a particular user, then the user specifies schema changes to his personal view rather than to the shared base schema. Our view schema evolution approach then computes a new view schema that reflects the semantics of the desired schema change, and replaces the old view with the new one. This approach provides the means for schema change without affecting other views (and thus without affecting existing application programs). The persistent data is shared by different views of the schema, i.e. by both old as well as newly developed applications can continue to interoperate. To realize our approach, this paper identifies key features of how views must be extended to be capacity-augmenting. We then present algorithms that implement the set of typical schema evolution operations as view definitions. Throughout the paper we present examples that demonstrate our approach. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> S. Abiteboul and A. Bonner, </author> <title> "Objects and Views," </title> <booktitle> in Proc. ACM SIGMOD, </booktitle> <pages> pp. 238-247, </pages> <year> 1991. </year>
Reference-contexts: Other advantages of relational views are data independence, access control and security. Perceiving the importance of views, many researchers have begun to investigate their counterpart in the object-oriented world <ref> [1, 6, 9, 24, 22, 19, 21] </ref>. The diverse view mechanisms proposed typically provide the functionality to restructure a base schema by hiding classes, by adding classes, by customizing the behavior or extent of classes, and by rearranging the generalization hierarchy.
Reference: [2] <author> F. Bancilhon and W. Kim, </author> <title> "Object-Oriented Database Systems: In Transition," </title> <booktitle> in SIGMOD RECORD, </booktitle> <volume> volume 19, </volume> <month> December 90. </month>
Reference-contexts: In summary, schema evolution is a pervasive problem in many large systems, and there certainly is a need for the capability of managing the evolution of a schema without any service interruption [25]. There is active research on schema evolution <ref> [4, 2, 10, 14, 11, 15, 29, 8, 31, 32] </ref>. Most work focuses on the modification of a database schema and the corresponding migration of database instances from the old to the modified schema.
Reference: [3] <author> J. Banerjee, H. Chou, and W. Kim, </author> <title> "Data Model issues for Object-Oriented Applications," </title> <journal> ACM Trans. on Office Information Systems, </journal> <volume> vol. 5, no. 1, </volume> <pages> pp. 3-26, </pages> <month> January 87. </month>
Reference-contexts: An operator with these semantics is already provided by a command of the view specification language, removeFromView aClass, of MultiView [19]. More complex version of this delete-class operator with the same semantics as the delete-class in Orion <ref> [3] </ref> can be achieved by composing several simpler change operators in our system. This will be shown in Section 6.9.2. 6.9 Constructing More Complex Schema Change Operators The schema evolution capability of our system is not limited to the schema change operators discussed so far. <p> For example, we can achieve the complex schema change of inserting a class between two existing classes or of deleting a class with the same semantics as that of delete-class in Orion <ref> [3] </ref> as follows. 6.9.1 Constructing the Insert-Class Schema Change in TSE Semantics of the Insert-Class Operator: The schema change defined by "insert-class C insert between C sup -C sub " creates a class C insert as subclass of C sup and superclass of C sub .
Reference: [4] <author> J. Banerjee, W. Kim, and H. Kim, </author> <title> "Semantics and Implementation of Schema Evolution in Object-Oriented Database ," in ACM SIGMOD, </title> <year> 1987. </year>
Reference-contexts: In summary, schema evolution is a pervasive problem in many large systems, and there certainly is a need for the capability of managing the evolution of a schema without any service interruption [25]. There is active research on schema evolution <ref> [4, 2, 10, 14, 11, 15, 29, 8, 31, 32] </ref>. Most work focuses on the modification of a database schema and the corresponding migration of database instances from the old to the modified schema. <p> In this paper, we detail a view change approach that successfully addresses all of these issues. 3 Extending MultiView System for Transparent Schema Changes In this paper, we assume a typical OO data model, such as COCOON's [28], MultiView's [22] and Orion's <ref> [4] </ref>. <p> definition statements for each primitive schema update operator. 6.1 Implementing the Add-Attribute Schema Change in TSE 6.1.1 Semantics of the Add-Attribute Operator The schema change operator defined by "add attribute x:attribute-def to C" augments the types of the class C and its subclasses C sub with the new attribute `x' <ref> [4] </ref>. The extents of the classes are not changed in terms of membership. However, the instance objects of the classes now have one additional attribute x. If there is a property in class C with the same name x, the operation is rejected.
Reference: [5] <author> D. Fishman, </author> <title> "Iris: An Object Oriented Database Management System," </title> <journal> in ACM Trans. on Office Info. Sys., </journal> <volume> volume 5, </volume> <pages> pp. 48-69, </pages> <month> January </month> <year> 1987. </year>
Reference-contexts: To the best of our knowledge, current OODB systems do not support multiple classification | the only exception is IRIS <ref> [5] </ref> a functional database system that actually uses a relational database as storage structure, storing data from one object across many relations. Other OODBs typically represent an object as a chunk of contiguous storage determined at object creation time.
Reference: [6] <author> S. Heiler and S. B. Zdonik, </author> <title> "Object views: Extending the vision," </title> <booktitle> in Proc. IEEE Data Engineering Conf.,Los Angeles, </booktitle> <pages> pp. 86 - 93, </pages> <month> February </month> <year> 1990. </year>
Reference-contexts: Other advantages of relational views are data independence, access control and security. Perceiving the importance of views, many researchers have begun to investigate their counterpart in the object-oriented world <ref> [1, 6, 9, 24, 22, 19, 21] </ref>. The diverse view mechanisms proposed typically provide the functionality to restructure a base schema by hiding classes, by adding classes, by customizing the behavior or extent of classes, and by rearranging the generalization hierarchy. <p> Create, delete, add, remove and set update operators applied to an instance of a virtual select class work on the source class. Creation, addition and setting values of objects that do not fulfill the selection predicate of the select class lead to the so-called value closure problem <ref> [6] </ref>. There are two solutions to this problem: (1) reject such creation/addition/set, or (2) allow them by inserting them into the source class or setting the value.
Reference: [7] <author> H. Kim, </author> " <title> Issues in Object-Oriented Database Schemas," in Diss., </title> <institution> Dept. of Comp. Sci., Univ. of Texas at Austin, TR-88-20, </institution> <month> May </month> <year> 1988. </year>
Reference-contexts: Thus, our approach keeps the old versions of a schema instead of modifying them; achieving schema versioning using a view system. Note that in our approach, unlike in other systems <ref> [8, 7, 11] </ref>, the scope of a schema version is not confined to the objects which have been created under this particular schema version. <p> Note that this taxonomy, adopted in most other schema evolution research for OODBs such as Encore [27], Goose <ref> [7, 11] </ref>, CLOSQL [15], Rose [14], OTGen [10] and COCOON [30], still corresponds to the most frequently used set of schema changes. In fact, most commercial OODB systems such as O 2 [31] and GemStone [16] only support a subset of this taxonomy. <p> The updatability and view preservation is automatically guaranteed because the macro only consists of our primitive operators. 7 Version Merging Using Views Differing from other schema version systems <ref> [8, 7, 11] </ref>, which keep track of constituting classes for each schema version, the version system of TSE is simple to implement having only to keep track of view names that correspond to schema versions. <p> The user can of course rename them within the context of VS.3, if desired. 8 Related Research The continued support of old programs when performing schema evolution has been recognized as a key issue in the literature <ref> [27, 8, 7, 14] </ref>. <p> Some systems require the user to provide the exception handlers to resolve the type mismatches between the underlying object instance representation and the schema to access it [27]. Others require the user to keep track of class versions for each valid schema <ref> [7] </ref>. * flexibility to build a new schema from class versions: It refers to the capability of composing various schemas by combining class versions. <p> To the best of our knowledge, other schema evolution database systems have not addressed this issue. Table 2 shows the comparisons of our TSE system with other systems such as Encore [27], Orion [8], Goose <ref> [7, 11] </ref>, CLOSQL [15] and Rose [14]. Typically, these other systems so not use the view approach, rather they utilize more traditional versioning concepts. <p> By adopting the view mechanism as foundation for our approach, the object instances are shared by all views, independently from the order in which these view schemas were created. This removes the inconsistency caused by not allowing back propagation in the schema version approach. Kim et al. <ref> [7, 11] </ref> propose the versioning of individual classes instead of the entire schema. A complete schema is constructed in Goose by selecting a version from each class.
Reference: [8] <author> W. Kim and H. Chou, </author> <title> "Versions of Schema For Object-Oriented Databases," </title> <booktitle> in Proc. 14th VLDB, </booktitle> <pages> pp. 148-159, </pages> <year> 1988. </year>
Reference-contexts: In summary, schema evolution is a pervasive problem in many large systems, and there certainly is a need for the capability of managing the evolution of a schema without any service interruption [25]. There is active research on schema evolution <ref> [4, 2, 10, 14, 11, 15, 29, 8, 31, 32] </ref>. Most work focuses on the modification of a database schema and the corresponding migration of database instances from the old to the modified schema. <p> Thus, our approach keeps the old versions of a schema instead of modifying them; achieving schema versioning using a view system. Note that in our approach, unlike in other systems <ref> [8, 7, 11] </ref>, the scope of a schema version is not confined to the objects which have been created under this particular schema version. <p> We are now embarking on the development of the TSE Translator. 6 Algorithms for Realizing Schema Changes in the TSE System One of the first object-oriented schema change approaches has been proposed by Banerjee et al. <ref> [8] </ref> for the ORION data model. Note that this taxonomy, adopted in most other schema evolution research for OODBs such as Encore [27], Goose [7, 11], CLOSQL [15], Rose [14], OTGen [10] and COCOON [30], still corresponds to the most frequently used set of schema changes. <p> The updatability and view preservation is automatically guaranteed because the macro only consists of our primitive operators. 7 Version Merging Using Views Differing from other schema version systems <ref> [8, 7, 11] </ref>, which keep track of constituting classes for each schema version, the version system of TSE is simple to implement having only to keep track of view names that correspond to schema versions. <p> Sometimes, the user may want to merge two versions into one version schema in order to take advantage of improvements made in both schema versions. This merging process is likely to be very complicated in other schema version systems such as Orion <ref> [8] </ref>, Goose [11] and Encore [27]. First, if instances have been copied for each version, all instance versions (duplicates) with the same object identity should be merged into a single instance. Second, the two separate schemas must be combined into one consistent schema, integrating also their generalization and aggregation hierarchies. <p> The user can of course rename them within the context of VS.3, if desired. 8 Related Research The continued support of old programs when performing schema evolution has been recognized as a key issue in the literature <ref> [27, 8, 7, 14] </ref>. <p> To the best of our knowledge, other schema evolution database systems have not addressed this issue. Table 2 shows the comparisons of our TSE system with other systems such as Encore [27], Orion <ref> [8] </ref>, Goose [7, 11], CLOSQL [15] and Rose [14]. Typically, these other systems so not use the view approach, rather they utilize more traditional versioning concepts. <p> This approach forces the user to manage the virtual versions of schemas by keeping track of which versions of types belong to which virtual versions of the schema. The schema version mechanism proposed for Orion by Kim and Chou <ref> [8] </ref> keeps versions of the whole schema hierarchy instead of the individual classes or types. Every instance object of an old version schema can be copied and converted to become an instance of the new version schema.
Reference: [9] <author> H. A. Kuno and E. A. Rundensteiner, </author> <title> "Developing an Object Oriented View Management System," </title> <booktitle> in CAS-CON, </booktitle> <month> November </month> <year> 1993. </year>
Reference-contexts: Other advantages of relational views are data independence, access control and security. Perceiving the importance of views, many researchers have begun to investigate their counterpart in the object-oriented world <ref> [1, 6, 9, 24, 22, 19, 21] </ref>. The diverse view mechanisms proposed typically provide the functionality to restructure a base schema by hiding classes, by adding classes, by customizing the behavior or extent of classes, and by rearranging the generalization hierarchy.
Reference: [10] <author> B. S. Lerner and A. N. Habermann, </author> <title> "Beyond Schema Evolution to Database Reorganization," </title> <booktitle> in OOPSLA, </booktitle> <pages> pp. 67-76, </pages> <year> 1990. </year>
Reference-contexts: In summary, schema evolution is a pervasive problem in many large systems, and there certainly is a need for the capability of managing the evolution of a schema without any service interruption [25]. There is active research on schema evolution <ref> [4, 2, 10, 14, 11, 15, 29, 8, 31, 32] </ref>. Most work focuses on the modification of a database schema and the corresponding migration of database instances from the old to the modified schema. <p> Note that this taxonomy, adopted in most other schema evolution research for OODBs such as Encore [27], Goose [7, 11], CLOSQL [15], Rose [14], OTGen <ref> [10] </ref> and COCOON [30], still corresponds to the most frequently used set of schema changes. In fact, most commercial OODB systems such as O 2 [31] and GemStone [16] only support a subset of this taxonomy. <p> The TSE object model has been successfully implemented on top of Gemstone, providing the necessary features of multiple classification and dynamic data restructuring to the TSE system. We have demonstrated our approach on a comprehensive set of schema evolution operators, i.e., those typically supported by OODBs <ref> [27, 11, 15, 14, 10, 31, 16] </ref>. As a result, we have also shown that object-preserving algebra operators, as provided by MultiView, are sufficient for supporting a comprehensive set of schema changes.
Reference: [11] <author> M. Magdi, A. Morsi, Navathe, and H. Kim, </author> <title> "Object Oriented Approach in Information System", </title> <publisher> Elsevier Science Publishers B.V.(North-Holland), </publisher> <year> 1991. </year>
Reference-contexts: In summary, schema evolution is a pervasive problem in many large systems, and there certainly is a need for the capability of managing the evolution of a schema without any service interruption [25]. There is active research on schema evolution <ref> [4, 2, 10, 14, 11, 15, 29, 8, 31, 32] </ref>. Most work focuses on the modification of a database schema and the corresponding migration of database instances from the old to the modified schema. <p> Thus, our approach keeps the old versions of a schema instead of modifying them; achieving schema versioning using a view system. Note that in our approach, unlike in other systems <ref> [8, 7, 11] </ref>, the scope of a schema version is not confined to the objects which have been created under this particular schema version. <p> Note that this taxonomy, adopted in most other schema evolution research for OODBs such as Encore [27], Goose <ref> [7, 11] </ref>, CLOSQL [15], Rose [14], OTGen [10] and COCOON [30], still corresponds to the most frequently used set of schema changes. In fact, most commercial OODB systems such as O 2 [31] and GemStone [16] only support a subset of this taxonomy. <p> The updatability and view preservation is automatically guaranteed because the macro only consists of our primitive operators. 7 Version Merging Using Views Differing from other schema version systems <ref> [8, 7, 11] </ref>, which keep track of constituting classes for each schema version, the version system of TSE is simple to implement having only to keep track of view names that correspond to schema versions. <p> Sometimes, the user may want to merge two versions into one version schema in order to take advantage of improvements made in both schema versions. This merging process is likely to be very complicated in other schema version systems such as Orion [8], Goose <ref> [11] </ref> and Encore [27]. First, if instances have been copied for each version, all instance versions (duplicates) with the same object identity should be merged into a single instance. Second, the two separate schemas must be combined into one consistent schema, integrating also their generalization and aggregation hierarchies. <p> To the best of our knowledge, other schema evolution database systems have not addressed this issue. Table 2 shows the comparisons of our TSE system with other systems such as Encore [27], Orion [8], Goose <ref> [7, 11] </ref>, CLOSQL [15] and Rose [14]. Typically, these other systems so not use the view approach, rather they utilize more traditional versioning concepts. <p> By adopting the view mechanism as foundation for our approach, the object instances are shared by all views, independently from the order in which these view schemas were created. This removes the inconsistency caused by not allowing back propagation in the schema version approach. Kim et al. <ref> [7, 11] </ref> propose the versioning of individual classes instead of the entire schema. A complete schema is constructed in Goose by selecting a version from each class. <p> The TSE object model has been successfully implemented on top of Gemstone, providing the necessary features of multiple classification and dynamic data restructuring to the TSE system. We have demonstrated our approach on a comprehensive set of schema evolution operators, i.e., those typically supported by OODBs <ref> [27, 11, 15, 14, 10, 31, 16] </ref>. As a result, we have also shown that object-preserving algebra operators, as provided by MultiView, are sufficient for supporting a comprehensive set of schema changes.
Reference: [12] <author> S. Marche, </author> <title> "Measuring the Stability of Data Models," </title> <journal> European Journal of Information Systems, </journal> <volume> vol. 2, no. 1, </volume> <pages> pp. 37-47, </pages> <year> 1993. </year>
Reference-contexts: It shows that the number of relations in one study increased by 139%, the number of attributes by 274% and that every relation has been changed. This measurement confirms the need for tools and techniques for managing schema changes to a database. Similarly, another report <ref> [12] </ref> confirms that data models are typically not stable as we expect based on the observation of seven typical database applications such as project tracking, real estate inventory, accounting and sales management, etc.. These project observation showsthat about 59% of attributes are changed on the average.
Reference: [13] <author> J. Martin and J. J. Odell, </author> <title> Object-Oriented Analysis and Design, volume 1, </title> <publisher> Prentice Hall, A Simon & Schuster Company, </publisher> <address> Englewood Cliffs, NJ 07632, first edition, </address> <year> 1992. </year>
Reference-contexts: They assume the invariant that an object belongs to exactly one class only | and indirectly also to all the class's superclasses. We identify two general approaches for implementing multiple classification in OODBs: (1) the intersection-class approach and (2) the object-slicing approach <ref> [13] </ref>. These approaches are best explained via an example. Assume that given the schema in Figure 5 (a), we want to create a new car object o1 that is both of type J eep and of type Imported. <p> Detailed comparison studies are needed to fully analyze the trade-off in performance for different types of access. * Changing an object from being an instance of one class (C1) to being an instance of another class (C2) is called dynamic classification <ref> [13] </ref>. In the object-slicing approach, when the object is dynamically classified as the instance of the class C2 rather than that of class C1, the object instance takes an implementation object of the class C2 and discards that of the class C1.
Reference: [14] <author> A. Mehta, D. L. Spooner, and M. Hardwick, </author> <title> "Resolution of Type Mismatches in an Engineering Persistent Object System," </title> <institution> in Technical Report,Rensselaer Design Research Center and Computer Science Dept. in Rens-selaer Polytechnic Institute, </institution> <year> 1993. </year> <month> 34 </month>
Reference-contexts: In summary, schema evolution is a pervasive problem in many large systems, and there certainly is a need for the capability of managing the evolution of a schema without any service interruption [25]. There is active research on schema evolution <ref> [4, 2, 10, 14, 11, 15, 29, 8, 31, 32] </ref>. Most work focuses on the modification of a database schema and the corresponding migration of database instances from the old to the modified schema. <p> Note that this taxonomy, adopted in most other schema evolution research for OODBs such as Encore [27], Goose [7, 11], CLOSQL [15], Rose <ref> [14] </ref>, OTGen [10] and COCOON [30], still corresponds to the most frequently used set of schema changes. In fact, most commercial OODB systems such as O 2 [31] and GemStone [16] only support a subset of this taxonomy. <p> The user can of course rename them within the context of VS.3, if desired. 8 Related Research The continued support of old programs when performing schema evolution has been recognized as a key issue in the literature <ref> [27, 8, 7, 14] </ref>. <p> To the best of our knowledge, other schema evolution database systems have not addressed this issue. Table 2 shows the comparisons of our TSE system with other systems such as Encore [27], Orion [8], Goose [7, 11], CLOSQL [15] and Rose <ref> [14] </ref>. Typically, these other systems so not use the view approach, rather they utilize more traditional versioning concepts. They typically construct new versions of the schema as well as of the object instances, with instances being assigned to the schema version under which they have been created. <p> The TSE object model has been successfully implemented on top of Gemstone, providing the necessary features of multiple classification and dynamic data restructuring to the TSE system. We have demonstrated our approach on a comprehensive set of schema evolution operators, i.e., those typically supported by OODBs <ref> [27, 11, 15, 14, 10, 31, 16] </ref>. As a result, we have also shown that object-preserving algebra operators, as provided by MultiView, are sufficient for supporting a comprehensive set of schema changes.
Reference: [15] <author> S. Monk and I. Sommerville, </author> " <title> Schema Evolution in OODBs Using Class Versioning," </title> <booktitle> in SIGMOD RECORD, </booktitle> <volume> VOL. 22, NO.3, </volume> <month> September </month> <year> 1993. </year>
Reference-contexts: In summary, schema evolution is a pervasive problem in many large systems, and there certainly is a need for the capability of managing the evolution of a schema without any service interruption [25]. There is active research on schema evolution <ref> [4, 2, 10, 14, 11, 15, 29, 8, 31, 32] </ref>. Most work focuses on the modification of a database schema and the corresponding migration of database instances from the old to the modified schema. <p> Note that this taxonomy, adopted in most other schema evolution research for OODBs such as Encore [27], Goose [7, 11], CLOSQL <ref> [15] </ref>, Rose [14], OTGen [10] and COCOON [30], still corresponds to the most frequently used set of schema changes. In fact, most commercial OODB systems such as O 2 [31] and GemStone [16] only support a subset of this taxonomy. <p> To the best of our knowledge, other schema evolution database systems have not addressed this issue. Table 2 shows the comparisons of our TSE system with other systems such as Encore [27], Orion [8], Goose [7, 11], CLOSQL <ref> [15] </ref> and Rose [14]. Typically, these other systems so not use the view approach, rather they utilize more traditional versioning concepts. They typically construct new versions of the schema as well as of the object instances, with instances being assigned to the schema version under which they have been created. <p> A complete schema is constructed in Goose by selecting a version from each class. This gives flexibility to the user in constructing many possible schemas, but it also results in the overhead of figuring out whether a given schema is consistent. Another class versioning approach CLOSQL, proposed by Monk <ref> [15] </ref>, provides update/backdate functions for each attribute which convert the instances from the format in which the instance is stored to the format that an application program expects. In such a system, the user's responsibility would be great even if the system provides the default conversion functions. <p> The TSE object model has been successfully implemented on top of Gemstone, providing the necessary features of multiple classification and dynamic data restructuring to the TSE system. We have demonstrated our approach on a comprehensive set of schema evolution operators, i.e., those typically supported by OODBs <ref> [27, 11, 15, 14, 10, 31, 16] </ref>. As a result, we have also shown that object-preserving algebra operators, as provided by MultiView, are sufficient for supporting a comprehensive set of schema changes.
Reference: [16] <author> D. Penney and J. Stein, </author> <title> "Class Modification in the GemStone Object-Oriented DBMS," </title> <booktitle> in Proc. 2nd OOPSLA, </booktitle> <pages> pp. 111-117, </pages> <year> 1987. </year>
Reference-contexts: In fact, most commercial OODB systems such as O 2 [31] and GemStone <ref> [16] </ref> only support a subset of this taxonomy. To demonstrate the feasibility of the TSE approach, it is thus important to show that our approach can realize all the schema change operations supported by Orion. <p> The TSE object model has been successfully implemented on top of Gemstone, providing the necessary features of multiple classification and dynamic data restructuring to the TSE system. We have demonstrated our approach on a comprehensive set of schema evolution operators, i.e., those typically supported by OODBs <ref> [27, 11, 15, 14, 10, 31, 16] </ref>. As a result, we have also shown that object-preserving algebra operators, as provided by MultiView, are sufficient for supporting a comprehensive set of schema changes.
Reference: [17] <author> E. A. Rundensteiner, </author> <title> "A Classification Algorithm For Supporting Consistent Object Views," </title> <institution> in Information and Computer Science Department, Univ. of California, Irvine, </institution> <type> Technical Report, </type> <pages> 92-50, </pages> <month> June </month> <year> 1992. </year>
Reference-contexts: Second, the two virtual classes are integrated 2 The capacity augmenting change is defined to be the schema restructuring to enhance the information contents of the schema 3 into the global schema by the classification algorithm as shown in Figure 3 (c) <ref> [17] </ref>. Third, the system selects the classes Person, Student' and TA' for the new view. It then renames the Student' and TA' classes to Student and TA within the context of the view, respectively. <p> For the first subtask, MultiView provides the user with an object algebra for class derivation [19]. The second subtask is automated in MultiView by the classification algorithm <ref> [17] </ref>. The integration of virtual classes into one global schema provides many benefits, including detecting identical and thus redundant classes, sharing methods without code duplication by different views, and enabling efficient view schema generation. <p> hierarchy for each view schema and removes the potential inconsistencies of the view generalization hierarchy due to the mistakes of the user. 3.2 Extending Object Algebra for Capacity-Augmenting Views Since our view schema evolution approach is built using the MultiView system, we utilize MultiView's view definition language, an object algebra <ref> [19, 22, 23, 21, 20, 17, 18] </ref>, as foundation of our TSE system. While a complete description of the algebra can be found elsewhere [19], below we briefly introduce the operators. We also discuss the necessary extension of some of these operators required for schema change support. <p> Thus, the merging of object instances is by design a non-issue in our system. The integration of two schemas into one is also automatically achieved in our system, since the classification algorithm integrates all virtual classes into one consistent global schema graph <ref> [17] </ref>. In our system, it is easy to determine based on the global schema whether the same named classes are really identical. Similarly, differently named classes of separate schemas are said to be identical if they are identical in the global schema. VS.0 in Figure 16 (a).
Reference: [18] <author> E. A. Rundensteiner, </author> <title> "Design Views for Synthesis: Provide Both Uniform Data Integration and Diverse Data Customization," </title> <institution> in EECS, Univ. of Michigan, </institution> <type> Tech. Rep. </type> <institution> CSE-TR-148-92, </institution> <month> November </month> <year> 1992. </year>
Reference-contexts: hierarchy for each view schema and removes the potential inconsistencies of the view generalization hierarchy due to the mistakes of the user. 3.2 Extending Object Algebra for Capacity-Augmenting Views Since our view schema evolution approach is built using the MultiView system, we utilize MultiView's view definition language, an object algebra <ref> [19, 22, 23, 21, 20, 17, 18] </ref>, as foundation of our TSE system. While a complete description of the algebra can be found elsewhere [19], below we briefly introduce the operators. We also discuss the necessary extension of some of these operators required for schema change support.
Reference: [19] <author> E. A. Rundensteiner, </author> <title> "MultiView: A Methodology for Supporting Multiple View Schemata in Object-Oriented Databases," </title> <booktitle> in 18th VLDB, </booktitle> <pages> pp. 187-198, </pages> <month> August </month> <year> 1992. </year>
Reference-contexts: Other advantages of relational views are data independence, access control and security. Perceiving the importance of views, many researchers have begun to investigate their counterpart in the object-oriented world <ref> [1, 6, 9, 24, 22, 19, 21] </ref>. The diverse view mechanisms proposed typically provide the functionality to restructure a base schema by hiding classes, by adding classes, by customizing the behavior or extent of classes, and by rearranging the generalization hierarchy. <p> terms of OO data models and views are found in the appendix. 3.1 MultiView: The Underlying Object-Oriented View Support System Since our view schema evolution approach is based on object-oriented view concepts, we describe below the view system we have developed towards the specification and maintenance of views, called MultiView <ref> [19] </ref>. Unlike other object-oriented view mechanisms, MultiView creates a complete view schema rather than just deriving individual virtual classes. Furthermore, views in MultiView allow for the insertion of new classes or the modification of existing classes in the middle of class hierarchy. <p> In addition, MultiView offers the following features that made it suitable as foundation for our schema change approach. First, it generates updatable views <ref> [19] </ref>. Second, several of the view specification subtasks are already automated, and can be reused in our system. Lastly, a prototype of MultiView has been implemented at the University of Michigan, and thus can be utilized as platform for constructing the TSE system. <p> For the first subtask, MultiView provides the user with an object algebra for class derivation <ref> [19] </ref>. The second subtask is automated in MultiView by the classification algorithm [17]. The integration of virtual classes into one global schema provides many benefits, including detecting identical and thus redundant classes, sharing methods without code duplication by different views, and enabling efficient view schema generation. <p> hierarchy for each view schema and removes the potential inconsistencies of the view generalization hierarchy due to the mistakes of the user. 3.2 Extending Object Algebra for Capacity-Augmenting Views Since our view schema evolution approach is built using the MultiView system, we utilize MultiView's view definition language, an object algebra <ref> [19, 22, 23, 21, 20, 17, 18] </ref>, as foundation of our TSE system. While a complete description of the algebra can be found elsewhere [19], below we briefly introduce the operators. We also discuss the necessary extension of some of these operators required for schema change support. <p> While a complete description of the algebra can be found elsewhere <ref> [19] </ref>, below we briefly introduce the operators. We also discuss the necessary extension of some of these operators required for schema change support. The object algebra is set-oriented in that the inputs and outputs are sets of objects. <p> Proposition B: Existing view schemas are not affected by this schema change. The global schema is restructured for this schema change operator in order to add some new refining virtual classes. However, as shown elsewhere as the view independence property <ref> [19] </ref>, existing views are not affected by such global schema restructuring. 6.1.5 Updatability For this view, virtual classes are created only by the object-preserving refine operator. <p> Again, if we apply the conflict resolution rule that gives higher priority to the property which had been locally defined, the source classes are changed by neither type nor extent. In general, no other views are affected by this schema change by the view indenpendency property shown elsewhere <ref> [19] </ref>. 6.5.4 Updatability The union operator could possibly be problematic because there are two source classes associated with each unioned virtual class. In Figure 9 (c), the class SupportStaff 0 has two source classes SupportStaf f and T A 0 . <p> In fact, it doesn't affect any other class in its view except that it is dropped from the view schema. An operator with these semantics is already provided by a command of the view specification language, removeFromView aClass, of MultiView <ref> [19] </ref>. More complex version of this delete-class operator with the same semantics as the delete-class in Orion [3] can be achieved by composing several simpler change operators in our system. <p> First, the user could explicitly select the two student classes, Student 0 and Student 00 , from the global schema shown in Figure 16 (b) using the view specification language and construct the desired integrated schema from the selected classes using the view schema generation algorithm provided by MultiView <ref> [19] </ref>. Second, the user can explicitly request a merge of the two versions VS.1 and VS.2 as depicted in Figure 16 (a). Then, the system collects all classes of VS.1 and VS.2 and integrates them into a single view schema VS.3. <p> To support the view technology required for our approach, MultiView <ref> [19] </ref> is chosen because it generates updatable views and complete view schemas rather than just individual view classes. In this paper, we have made several extensions to MultiView to successfully support view evolution, in particular, we added capacity-augmenting capabilities.
Reference: [20] <author> E. A. Rundensteiner, </author> <title> "Research Initiation Award: An Object-Oriented Extensive View System for Computer-Aided Design Application," in NSF proposal, </title> <year> 1993. </year>
Reference-contexts: hierarchy for each view schema and removes the potential inconsistencies of the view generalization hierarchy due to the mistakes of the user. 3.2 Extending Object Algebra for Capacity-Augmenting Views Since our view schema evolution approach is built using the MultiView system, we utilize MultiView's view definition language, an object algebra <ref> [19, 22, 23, 21, 20, 17, 18] </ref>, as foundation of our TSE system. While a complete description of the algebra can be found elsewhere [19], below we briefly introduce the operators. We also discuss the necessary extension of some of these operators required for schema change support.
Reference: [21] <author> E. A. Rundensteiner, </author> <title> "Tools for View Generation Object-Oriented Database," </title> <booktitle> in CIKM, </booktitle> <pages> pp. 635-644, </pages> <month> Novem-ber </month> <year> 1993. </year>
Reference-contexts: Other advantages of relational views are data independence, access control and security. Perceiving the importance of views, many researchers have begun to investigate their counterpart in the object-oriented world <ref> [1, 6, 9, 24, 22, 19, 21] </ref>. The diverse view mechanisms proposed typically provide the functionality to restructure a base schema by hiding classes, by adding classes, by customizing the behavior or extent of classes, and by rearranging the generalization hierarchy. <p> It then renames the Student' and TA' classes to Student and TA within the context of the view, respectively. Fourth, a new view schema VS2 is generated from the selected classes by running the schema generation algorithm <ref> [21] </ref>. At last, the system replaces the old view with the newly generated view. Because all the above procedures are transparent to the schema change specifier, she will have the perception that she has actually modified her original schema. <p> The third subtask requires the use of a view specification language for class selection, and a view schema generation algorithm for the construction of the view generalization hierarchy <ref> [21] </ref>. Automatic view generation [21] relieves the user 5 of constructing the is-a hierarchy for each view schema and removes the potential inconsistencies of the view generalization hierarchy due to the mistakes of the user. 3.2 Extending Object Algebra for Capacity-Augmenting Views Since our view schema evolution approach is built using <p> The third subtask requires the use of a view specification language for class selection, and a view schema generation algorithm for the construction of the view generalization hierarchy <ref> [21] </ref>. Automatic view generation [21] relieves the user 5 of constructing the is-a hierarchy for each view schema and removes the potential inconsistencies of the view generalization hierarchy due to the mistakes of the user. 3.2 Extending Object Algebra for Capacity-Augmenting Views Since our view schema evolution approach is built using the MultiView system, we <p> hierarchy for each view schema and removes the potential inconsistencies of the view generalization hierarchy due to the mistakes of the user. 3.2 Extending Object Algebra for Capacity-Augmenting Views Since our view schema evolution approach is built using the MultiView system, we utilize MultiView's view definition language, an object algebra <ref> [19, 22, 23, 21, 20, 17, 18] </ref>, as foundation of our TSE system. While a complete description of the algebra can be found elsewhere [19], below we briefly introduce the operators. We also discuss the necessary extension of some of these operators required for schema change support. <p> It then renames the Student' and TA' classes to Student and TA within the context of VS2, respectively. Finally, generalization edges are generated by View Schema Generator for the classes selected for VS2 <ref> [21] </ref>. At last, the system replaces the old 11 The algorithm names each virtual class by appending a prime to the name of their corresponding original class. 14 view VS1 with the newly generated view VS2. <p> Because this schema change does not modify the is-a relationships between classes, we know E = E 0 . The view schema generation algorithm of TSE, which is already found in <ref> [21] </ref>, will generate the same is-a relationships as in E, and thus E 00 = E. This implies that E 00 = E 0 = E. <p> Because this schema change does not change the is-a relationships between classes, we have E = E 0 . Besides, the view schema generation algorithm will generate the same is-a relationships as in E <ref> [21] </ref>, and then E 00 = E. In short, it means that E 00 = E 0 = E. <p> Besides, the view schema generation algorithm will generate the is-a relationships of E augmented by the edge C sup C sub for the new schema E", and thus E 00 = E [ f&lt; C sup ; C sub &gt;g <ref> [21] </ref>. Then, we can see that E 00 = E 0 . Because V 0 = V 00 and E 0 = E 00 , we can say that S 00 = S 0 and that the semantics of the schema change have been correctly simulated. <p> The view schema generation algorithm will generate the is-a relationships of E decreased by the edge C sup C sub , and then E 00 = E f&lt; C sup ; C sub &gt;g <ref> [21] </ref>. Then, we can see that E 00 = E 0 . Because V 0 = V 00 and E 0 = E 00 , we can know that S 00 = S 0 and that the semantics of the schema change have been correctly simulated. <p> Another advantage is that TSE system does not permit duplicate classes. When a duplicate class is created, it is detected by the classification algorithm <ref> [21] </ref>, even if it has a different name. The existing class will replace the newly created duplicate one. Sometimes, the user may want to merge two versions into one version schema in order to take advantage of improvements made in both schema versions.
Reference: [22] <author> E. A. Rundensteiner and L. Bic, </author> <title> "Set Operation in Object-Based Data Models," </title> <journal> IEEE Trans. on Data and Knowledge Engineering, </journal> <pages> pp. 382-398, </pages> <month> June </month> <year> 1992. </year>
Reference-contexts: Other advantages of relational views are data independence, access control and security. Perceiving the importance of views, many researchers have begun to investigate their counterpart in the object-oriented world <ref> [1, 6, 9, 24, 22, 19, 21] </ref>. The diverse view mechanisms proposed typically provide the functionality to restructure a base schema by hiding classes, by adding classes, by customizing the behavior or extent of classes, and by rearranging the generalization hierarchy. <p> In this paper, we detail a view change approach that successfully addresses all of these issues. 3 Extending MultiView System for Transparent Schema Changes In this paper, we assume a typical OO data model, such as COCOON's [28], MultiView's <ref> [22] </ref> and Orion's [4]. <p> hierarchy for each view schema and removes the potential inconsistencies of the view generalization hierarchy due to the mistakes of the user. 3.2 Extending Object Algebra for Capacity-Augmenting Views Since our view schema evolution approach is built using the MultiView system, we utilize MultiView's view definition language, an object algebra <ref> [19, 22, 23, 21, 20, 17, 18] </ref>, as foundation of our TSE system. While a complete description of the algebra can be found elsewhere [19], below we briefly introduce the operators. We also discuss the necessary extension of some of these operators required for schema change support. <p> All objects of the input set are also the members of the output set. * Set operations. As the extent of classes are sets of objects, we can perform set operations as usual <ref> [22] </ref>. The criterion of duplicate elimination is object identity equality, not value equality as assumed in the relational model. We need no restriction on the operand types of set operations (ultimately, they are all objects). <p> In addition, only the direct extent of class C is now hidden from the superclasses of C. So, the semantics of 20 The operation of removing a class from a view is supported by the view specification language in MultiView <ref> [22] </ref>. 29 this operation is achieved.
Reference: [23] <author> E. Rundensteiner, </author> <title> "Object-Oriented Views: An Approach to Tool Integration in Design Environments," in Diss., </title> <type> Info. </type> & <institution> Comp. Sci. Dept. Univ. of Cal., Irvine, </institution> <month> Fall, </month> <year> 1992. </year>
Reference-contexts: hierarchy for each view schema and removes the potential inconsistencies of the view generalization hierarchy due to the mistakes of the user. 3.2 Extending Object Algebra for Capacity-Augmenting Views Since our view schema evolution approach is built using the MultiView system, we utilize MultiView's view definition language, an object algebra <ref> [19, 22, 23, 21, 20, 17, 18] </ref>, as foundation of our TSE system. While a complete description of the algebra can be found elsewhere [19], below we briefly introduce the operators. We also discuss the necessary extension of some of these operators required for schema change support.
Reference: [24] <author> M. Scholl and C. Laasch, </author> <title> "Updatable views in object-oriented databases," </title> <booktitle> in Proceedings of the Second DOOD Conference, </booktitle> <pages> pp. 1-19, </pages> <month> December </month> <year> 1991. </year>
Reference-contexts: Other advantages of relational views are data independence, access control and security. Perceiving the importance of views, many researchers have begun to investigate their counterpart in the object-oriented world <ref> [1, 6, 9, 24, 22, 19, 21] </ref>. The diverse view mechanisms proposed typically provide the functionality to restructure a base schema by hiding classes, by adding classes, by customizing the behavior or extent of classes, and by rearranging the generalization hierarchy. <p> In addition, the age attribute is hidden from the instances of AgelessPerson. 3.3 Generic Update Operators In OODBs, updates are generally performed using type-specific update methods. We, however, want to provide a set of generic update operations to extend type-specific updates, similar as proposed in other view systems <ref> [24] </ref>. Such generic update operations can either be used directly or, if desired, overridden by type implementors to define type-specific methods. The generic update operations include create and delete to create and destroy objects and set to set attributes to new values. <p> It has been shown that virtual classes created by object-preserving algebra are updatable due to the one-to-one correspondence between base and virtual object instances <ref> [24] </ref>. In fact, all update operators have the same effect as if they were applied to the base class, because the virtual classes' extents are depending on the extents of base classes. 1. A select virtual class creates a subclass containing all objects satisfying the selection predicate. <p> Because it has been shown that virtual classes defined by object preserving object algebra are updatable <ref> [24] </ref>, all classes of the view are updatable. 15 16 6.2 Implementing the Delete-Attribute Schema Change in TSE 6.2.1 Semantics of the Delete-Attribute Operator The schema change operator defined by "delete attribute attribute (x) from C" removes the attribute `x' from the types of the class C and its subclasses.
Reference: [25] <author> M. E. Segal, </author> <title> "Personal Discussion about software interface evolution ," in Member of Technical Staff, </title> <institution> Applied Research, Bellcore, </institution> <year> 1994. </year>
Reference-contexts: These project observation showsthat about 59% of attributes are changed on the average. In summary, schema evolution is a pervasive problem in many large systems, and there certainly is a need for the capability of managing the evolution of a schema without any service interruption <ref> [25] </ref>. There is active research on schema evolution [4, 2, 10, 14, 11, 15, 29, 8, 31, 32]. Most work focuses on the modification of a database schema and the corresponding migration of database instances from the old to the modified schema.
Reference: [26] <author> D. Sjtberg, </author> " <title> Quantifying Schema Evolution," </title> <journal> Information and Software Technology, </journal> <volume> vol. 35, no. 1, </volume> <pages> pp. 35-54, </pages> <month> January </month> <year> 1993. </year>
Reference-contexts: To measure the frequency of schema evolution, a health management system was observed over a 18 month period <ref> [26] </ref>. It shows that the number of relations in one study increased by 139%, the number of attributes by 274% and that every relation has been changed. This measurement confirms the need for tools and techniques for managing schema changes to a database.
Reference: [27] <author> A. H. Skarra and S. B. Zdonik, </author> <title> "The Management of Changing Types in an Object-Oriented Database," </title> <booktitle> in Proc. 1st OOPSLA, </booktitle> <pages> pp. 483-494, </pages> <year> 1986. </year>
Reference-contexts: Note that this taxonomy, adopted in most other schema evolution research for OODBs such as Encore <ref> [27] </ref>, Goose [7, 11], CLOSQL [15], Rose [14], OTGen [10] and COCOON [30], still corresponds to the most frequently used set of schema changes. In fact, most commercial OODB systems such as O 2 [31] and GemStone [16] only support a subset of this taxonomy. <p> Sometimes, the user may want to merge two versions into one version schema in order to take advantage of improvements made in both schema versions. This merging process is likely to be very complicated in other schema version systems such as Orion [8], Goose [11] and Encore <ref> [27] </ref>. First, if instances have been copied for each version, all instance versions (duplicates) with the same object identity should be merged into a single instance. Second, the two separate schemas must be combined into one consistent schema, integrating also their generalization and aggregation hierarchies. <p> The user can of course rename them within the context of VS.3, if desired. 8 Related Research The continued support of old programs when performing schema evolution has been recognized as a key issue in the literature <ref> [27, 8, 7, 14] </ref>. <p> Some systems require the user to provide the exception handlers to resolve the type mismatches between the underlying object instance representation and the schema to access it <ref> [27] </ref>. Others require the user to keep track of class versions for each valid schema [7]. * flexibility to build a new schema from class versions: It refers to the capability of composing various schemas by combining class versions. <p> To the best of our knowledge, other schema evolution database systems have not addressed this issue. Table 2 shows the comparisons of our TSE system with other systems such as Encore <ref> [27] </ref>, Orion [8], Goose [7, 11], CLOSQL [15] and Rose [14]. Typically, these other systems so not use the view approach, rather they utilize more traditional versioning concepts. <p> Furthermore, they do not show how to achieve conventional schema evolution operations that are more graph-manipulation oriented, such as adding/deleting an is-a relationship and adding/deleting a class. Zdonik et al.'s approach towards type changes in the Encore System <ref> [27] </ref> is to keep different versions of each type, and to bind objects to a specific version of the type. Objects of different versions can be accessed by providing exception handlers for the properties that the types of the object instances do not contain. <p> The TSE object model has been successfully implemented on top of Gemstone, providing the necessary features of multiple classification and dynamic data restructuring to the TSE system. We have demonstrated our approach on a comprehensive set of schema evolution operators, i.e., those typically supported by OODBs <ref> [27, 11, 15, 14, 10, 31, 16] </ref>. As a result, we have also shown that object-preserving algebra operators, as provided by MultiView, are sufficient for supporting a comprehensive set of schema changes.
Reference: [28] <author> M. Tresch and M. Scholl, </author> <title> "Implementing an Object Model on top of Commercial Database Systems," </title> <booktitle> in Proc. 3rd GI Workshop on Foundation of Database Systems, </booktitle> <month> May </month> <year> 1991. </year>
Reference-contexts: In this paper, we detail a view change approach that successfully addresses all of these issues. 3 Extending MultiView System for Transparent Schema Changes In this paper, we assume a typical OO data model, such as COCOON's <ref> [28] </ref>, MultiView's [22] and Orion's [4].
Reference: [29] <author> M. Tresch and M. H. Scholl, </author> <title> "Schema Transformation without Database Reorganization," </title> <booktitle> in SIGMOD RECORD, </booktitle> <pages> pp. 21-27, </pages> <year> 1993. </year>
Reference-contexts: In summary, schema evolution is a pervasive problem in many large systems, and there certainly is a need for the capability of managing the evolution of a schema without any service interruption [25]. There is active research on schema evolution <ref> [4, 2, 10, 14, 11, 15, 29, 8, 31, 32] </ref>. Most work focuses on the modification of a database schema and the corresponding migration of database instances from the old to the modified schema. <p> We solve this problem by specifying the schema change directly on a view rather than on the global schema. 32 In a recent SIGMOD record article by Tresch and Scholl <ref> [29] </ref>, the authors also advocate views as a suitable mech-anism for simulating schema evolution. They state that schema evolution can be simulated using views if they are not capacity augmenting.
Reference: [30] <author> M. Tresch and M. H. Scholl, </author> " <title> Meta Object Management and its Applications to Database Evolution," </title> <booktitle> in EDBT, </booktitle> <month> October </month> <year> 1992. </year>
Reference-contexts: Note that this taxonomy, adopted in most other schema evolution research for OODBs such as Encore [27], Goose [7, 11], CLOSQL [15], Rose [14], OTGen [10] and COCOON <ref> [30] </ref>, still corresponds to the most frequently used set of schema changes. In fact, most commercial OODB systems such as O 2 [31] and GemStone [16] only support a subset of this taxonomy.
Reference: [31] <author> R. Zicari, </author> <title> "A Framework for O 2 Schema Updates," </title> <booktitle> in 7th IEEE International Conf. on Data Engineering, </booktitle> <pages> pp. 146-182, </pages> <month> April </month> <year> 1991. </year>
Reference-contexts: In summary, schema evolution is a pervasive problem in many large systems, and there certainly is a need for the capability of managing the evolution of a schema without any service interruption [25]. There is active research on schema evolution <ref> [4, 2, 10, 14, 11, 15, 29, 8, 31, 32] </ref>. Most work focuses on the modification of a database schema and the corresponding migration of database instances from the old to the modified schema. <p> In fact, most commercial OODB systems such as O 2 <ref> [31] </ref> and GemStone [16] only support a subset of this taxonomy. To demonstrate the feasibility of the TSE approach, it is thus important to show that our approach can realize all the schema change operations supported by Orion. Zicari [31] shows that the schema evolution operations of Orion can be reduced <p> In fact, most commercial OODB systems such as O 2 <ref> [31] </ref> and GemStone [16] only support a subset of this taxonomy. To demonstrate the feasibility of the TSE approach, it is thus important to show that our approach can realize all the schema change operations supported by Orion. Zicari [31] shows that the schema evolution operations of Orion can be reduced to a small set of primitive schema change operators, which can be combined to achieve the semantics of more complex operators. <p> This section shows how some of the popular schema operations can be achieved by a combination of our primitive schema change operators. This idea of combining primitive operators to achieve complex schema evolution has also been discussed by Zicari <ref> [31] </ref>. <p> The TSE object model has been successfully implemented on top of Gemstone, providing the necessary features of multiple classification and dynamic data restructuring to the TSE system. We have demonstrated our approach on a comprehensive set of schema evolution operators, i.e., those typically supported by OODBs <ref> [27, 11, 15, 14, 10, 31, 16] </ref>. As a result, we have also shown that object-preserving algebra operators, as provided by MultiView, are sufficient for supporting a comprehensive set of schema changes.
Reference: [32] <author> R. Zicari, </author> <title> "Primitives for schema updates in an Object-Oriented Database System: A proposal," </title> <booktitle> in Computer Standards & Interfaces, </booktitle> <pages> pp. 271-283, </pages> <year> 1991. </year>
Reference-contexts: In summary, schema evolution is a pervasive problem in many large systems, and there certainly is a need for the capability of managing the evolution of a schema without any service interruption [25]. There is active research on schema evolution <ref> [4, 2, 10, 14, 11, 15, 29, 8, 31, 32] </ref>. Most work focuses on the modification of a database schema and the corresponding migration of database instances from the old to the modified schema.
References-found: 32

