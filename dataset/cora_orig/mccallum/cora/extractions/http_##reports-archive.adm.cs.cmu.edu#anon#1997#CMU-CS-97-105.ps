URL: http://reports-archive.adm.cs.cmu.edu/anon/1997/CMU-CS-97-105.ps
Refering-URL: http://www.cs.cmu.edu/~berez/publications.html
Root-URL: 
Title: A Compositional Proof System for the Modal -calculus and CCS  
Author: Sergey Berezin and Dilian Gurov 
Note: This research was sponsored by the National Science Foundation under grant no. CCR-9217549. The views and conclusions contained in this document are those of the authors and should not be interpreted as representing the official policies, either expressed or implied, of the NSF or the U.S. government.  
Address: Pittsburgh, PA 15213  CMU,  of  
Affiliation: School of Computer Science Carnegie Mellon University  Dept. of CS,  Dept. of CS, University  
Pubnum: CMU-CS-97-105  
Email: berez+@cs.cmu.edu  Victoria,dgurov@csr.uvic.ca  
Phone: 1  2  
Date: January 15, 1997  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> Henrik R. Andersen. </author> <title> On model checking infinite-state systems. </title> <editor> In Nerode and Matiya-sevich, editors, LFCS'94: </editor> <booktitle> Logic at St. Petersburg. Symposium on Logical Foundations of Computer Science, </booktitle> <address> St. Petersburg, Russia, </address> <month> July 11-14, </month> <booktitle> volume 813 of Lecture Notes in Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1994. </year>
Reference-contexts: For details on the proof system for p ` , where p is a sequential CCS term, the reader is referred to [8]. In our proof system we handle fixed points by assigning tags <ref> [16, 1] </ref> to the fixed point operators. Intuitively (although simplified), tags store the information that some particular sequents have already occurred below in the proof tree, assuming that the tree grows up from the goal to axioms. <p> A standard way to prove the local soundness of the fixed point rules is to use the reduction Lemma 4 <ref> [16, 1] </ref> (see the next section). <p> Then k ` fl fi =) k j= fl fi: Before sketching the proof we state the following lemma. Lemma 4. (The reduction lemma <ref> [16, 1] </ref>). Let D be a set and f : 2 D ! 2 D be monotone with respect to . Denote operators of the least and the greatest fixed points of f as x:f (x) and -x:f (x) respectively.
Reference: [2] <author> Henrik R. Andersen. </author> <title> Partial model checking (extended abstract). </title> <type> Technical Report ID-TR: 1994-148, </type> <institution> Department of Computer Science, Technical University of Denmark, </institution> <month> October </month> <year> 1994. </year> <note> Accepted for LICS'95. </note>
Reference-contexts: After the implementation it is enough to verify each component separately. Moreover, one can change the actual implementation of some components without having to repeat the verification of the entire system as soon as the new implementation meets its local requirements. Our compositional approach differs from many others <ref> [2, 3, 5, 7] </ref> in that it can handle the parallel composition operator in a purely compositional way and at the same time remains general for the full CCS and the full modal -calculus. <p> Our compositional approach differs from many others [2, 3, 5, 7] in that it can handle the parallel composition operator in a purely compositional way and at the same time remains general for the full CCS and the full modal -calculus. In <ref> [2, 3, 5] </ref> the parallel composition operator was eliminated basically by encoding one of the subprocesses into the formula. In the worst case this results in an exponential blow-up in the size of the formula, and the total complexity remains the same as for non-compositional model checking [6]. <p> Our parallel composition operator also has a more general form in comparison with CCS: p k q can be considered roughly as (p )j (q ) in the original CCS, where and are sets of action symbols. This operator is taken from <ref> [2] </ref>.
Reference: [3] <author> Henrik R. Andersen, Colin Stirling, and Glynn Winskel. </author> <title> A compositional proof system for the modal -calculus. </title> <booktitle> In Proceedings, Ninth Annual IEEE Symposium on Logic in Computer Science, </booktitle> <pages> pages 144-153, </pages> <address> Paris, France, </address> <month> 4-7 July </month> <year> 1994. </year> <note> IEEE Computer Society Press. Also as BRICS Report RS-94-34. </note>
Reference-contexts: After the implementation it is enough to verify each component separately. Moreover, one can change the actual implementation of some components without having to repeat the verification of the entire system as soon as the new implementation meets its local requirements. Our compositional approach differs from many others <ref> [2, 3, 5, 7] </ref> in that it can handle the parallel composition operator in a purely compositional way and at the same time remains general for the full CCS and the full modal -calculus. <p> Our compositional approach differs from many others [2, 3, 5, 7] in that it can handle the parallel composition operator in a purely compositional way and at the same time remains general for the full CCS and the full modal -calculus. In <ref> [2, 3, 5] </ref> the parallel composition operator was eliminated basically by encoding one of the subprocesses into the formula. In the worst case this results in an exponential blow-up in the size of the formula, and the total complexity remains the same as for non-compositional model checking [6].
Reference: [4] <author> K.A. Bartlet, R.A. Scantlebury, and P.T. Wilkinson. </author> <title> A note on reliable full-duplex transmission over half-duplex links. </title> <journal> Commun. ACM, </journal> <volume> 12(5) </volume> <pages> 260-261, </pages> <year> 1969. </year>
Reference-contexts: So, both steps of the verification of finite-state systems, i.e. model checking the components and deriving the global property, can be done in PVS. We verified two examples using the system: (1) Alternating Bit Protocol (ABP) <ref> [4, 6] </ref> and (2) Milner's Scheduler [12]. The ABP example consists of three parallel processes Send, Medium and Receive, combined together by two parallel composition operators: ABP ((Send S k M Medium) k R Receive) fl 11 with appropriate restriction sets.
Reference: [5] <author> S.A. Berezine. </author> <title> Model checking in -calculus for distributed systems. In Specification, verification, and net models of concurrent systems. </title> <institution> Institute of Informatics Systems, Novosi-birsk, Russia, </institution> <year> 1994. </year>
Reference-contexts: After the implementation it is enough to verify each component separately. Moreover, one can change the actual implementation of some components without having to repeat the verification of the entire system as soon as the new implementation meets its local requirements. Our compositional approach differs from many others <ref> [2, 3, 5, 7] </ref> in that it can handle the parallel composition operator in a purely compositional way and at the same time remains general for the full CCS and the full modal -calculus. <p> Our compositional approach differs from many others [2, 3, 5, 7] in that it can handle the parallel composition operator in a purely compositional way and at the same time remains general for the full CCS and the full modal -calculus. In <ref> [2, 3, 5] </ref> the parallel composition operator was eliminated basically by encoding one of the subprocesses into the formula. In the worst case this results in an exponential blow-up in the size of the formula, and the total complexity remains the same as for non-compositional model checking [6].
Reference: [6] <author> E. M. Clarke, E. A. Emerson, and A. P. Sistla. </author> <title> Automatic verification of finite-state concurrent systems using temporal logic specifications. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 8(2) </volume> <pages> 244-263, </pages> <month> April </month> <year> 1986. </year>
Reference-contexts: In [2, 3, 5] the parallel composition operator was eliminated basically by encoding one of the subprocesses into the formula. In the worst case this results in an exponential blow-up in the size of the formula, and the total complexity remains the same as for non-compositional model checking <ref> [6] </ref>. The proof system of C. Stirling [14] is, probably, the most compositional in a sense that it clearly reduces the verification problem to the verification of components. In fact, our system has originated from it. <p> So, both steps of the verification of finite-state systems, i.e. model checking the components and deriving the global property, can be done in PVS. We verified two examples using the system: (1) Alternating Bit Protocol (ABP) <ref> [4, 6] </ref> and (2) Milner's Scheduler [12]. The ABP example consists of three parallel processes Send, Medium and Receive, combined together by two parallel composition operators: ABP ((Send S k M Medium) k R Receive) fl 11 with appropriate restriction sets. <p> This way of compositional reasoning significantly reduces the state explosion problem arising in the direct model checking method <ref> [6] </ref>. In general, it is much easier to model check two properties of two components and prove a sequent k ` fl fi, than to model check the same property fi for the result of the parallel composition directly.
Reference: [7] <author> M. Dam. </author> <title> Compositional proof systems for model checking infinite state processes. </title> <booktitle> In Proceedings of CONCUR'95, volume 962 of Lecture Notes in Computer Science, </booktitle> <pages> pages 12-26. </pages> <publisher> Springer-Verlag, </publisher> <year> 1995. </year>
Reference-contexts: After the implementation it is enough to verify each component separately. Moreover, one can change the actual implementation of some components without having to repeat the verification of the entire system as soon as the new implementation meets its local requirements. Our compositional approach differs from many others <ref> [2, 3, 5, 7] </ref> in that it can handle the parallel composition operator in a purely compositional way and at the same time remains general for the full CCS and the full modal -calculus. <p> In fact, our system has originated from it. But Stirling considers the Hennessy-Milner logic, which is too weak to be of much interest in practice. The proof system of M. Dam <ref> [7] </ref> is also very close in spirit to ours, and is complete 1 for finite-state processes.
Reference: [8] <author> Dilian Gurov, Sergey Berezin, and Bruce M. Kapron. </author> <title> A modal mu-calculus and a proof system for value passing processes. </title> <booktitle> In Proceedings of INFINITY International Workshop on Verification of Infinite State Systems, Pisa (Italy), </booktitle> <pages> pages 149-163, </pages> <month> August </month> <year> 1996. </year> <note> Published by University of Passau as MIP-9614 July 1996. </note>
Reference-contexts: Following Stirling [14], our proof system consists of two subsystems. The first one deals with model checking CCS processes without the parallel composition operator, i.e. it contains proof rules for sequents of the form p ` ("process p satisfies a formula "), and is described in detail in <ref> [8] </ref> for the more general process algebra of Value Passing CCS and a first order -calculus. <p> In order to be consistent with the intuitive semantics of CCS and <ref> [8] </ref>, we will also assume that the set S is closed under the rules of figure 1 (i.e. transition closed). Otherwise we may have a situation where, say, the process a:0 can not perform the action a in the model, if 0 62 S. <p> Stirling in [14]. In this paper we elaborate on the proof system for sequents of type k ` fl fi. For details on the proof system for p ` , where p is a sequential CCS term, the reader is referred to <ref> [8] </ref>. In our proof system we handle fixed points by assigning tags [16, 1] to the fixed point operators. Intuitively (although simplified), tags store the information that some particular sequents have already occurred below in the proof tree, assuming that the tree grows up from the goal to axioms.
Reference: [9] <author> D. Kozen. </author> <title> Results on the propositional mu-calculus. </title> <journal> Theoretical Computer Science, </journal> <volume> 27 </volume> <pages> 333-354, </pages> <month> December </month> <year> 1983. </year> <month> 14 </month>
Reference-contexts: Also, PVS provides a powerful mechanism of writing proof strategies for automated proof search in our system. The paper is organized as follows. Section 2 describes our version of CCS. Section 3 introduces the modal -calculus <ref> [9] </ref> (syntax and semantics), and provides some examples of useful properties. Section 4 describes the Compositional Proof System and shows an example of a proof in the proof system. <p> The process R is combined from the two processes P and Q, that perform asynchronous actions a and c and are forced to synchronize by b? and b!, since b?; b! 62 fl. 3 The Modal -Calculus. 3.1 Syntax. Definition 1. The language of the modal -calculus <ref> [9] </ref> consists of the following alphabet: * P; Q; : : : 2 Prop, are propositional constant symbols; in particular, we assume the exis tence of two constants true and false; * X; Y; : : : 2 Var, are propositional variables; * fl; ffi; : : : 2 Act are
Reference: [10] <author> K. L. McMillan. </author> <title> Symbolic Model Checking: An Approach to the State Explosion Problem. </title> <type> PhD thesis, </type> <institution> Carnegie Mellon University, </institution> <year> 1992. </year>
Reference-contexts: Each individual process including the intermediate (Send S k M Medium) has its own specification. The specifications for the `atomic' processes, i.e. Send, Medium and Receive, were directly model checked using SMV <ref> [10] </ref>. The specifications of compound processes (i.e. obtained by parallel composition) were derived from the components in the proof system. The example of the Milner's scheduler is more involved and includes induction on the number of parallel processes.
Reference: [11] <author> R. Milner. </author> <title> Calculi for synchrony and asynchrony. </title> <journal> Theoretical Computer Science, </journal> <volume> 25(3) </volume> <pages> 267-310, </pages> <year> 1983. </year>
Reference-contexts: 1 Introduction. In this paper we present a Compositional Proof System for the modal -calculus and CCS <ref> [11, 12] </ref>. We use a (slightly modified version of) CCS as a model of concurrency. Many systems of parallel processes can be expressed as CCS processes, and then checked against specifications in the modal -calculus. Following Stirling [14], our proof system consists of two subsystems. <p> In Section 6 we discuss the issue of implementation in PVS and two examples that we verified. We conclude in Section 7. 2 The Process Algebra. We use the standard CCS of R. Milner <ref> [11, 12] </ref>, except that we change the parallel composition operator and the means of synchronization. The importance of this change will become clear in section 4, where we need it to simplify the compositional inference rules. <p> This operator is taken from [2]. Thus, the abstract grammar of our CCS is the following: p ::= 0 j P j fl:p j p 0 + p 1 j p 0 k p 1 j p fl j pfffig: Here 0 is the nil process (called inaction in <ref> [11] </ref>), that can not perform any action, P is a process identifier, fl:p is a prefix operator, p+q is a non-deterministic choice, fl and fffig are restriction and relabelling.
Reference: [12] <author> Robin Milner. </author> <title> Communication and Concurrency. </title> <publisher> Prentice-Hall, </publisher> <year> 1989. </year>
Reference-contexts: 1 Introduction. In this paper we present a Compositional Proof System for the modal -calculus and CCS <ref> [11, 12] </ref>. We use a (slightly modified version of) CCS as a model of concurrency. Many systems of parallel processes can be expressed as CCS processes, and then checked against specifications in the modal -calculus. Following Stirling [14], our proof system consists of two subsystems. <p> In Section 6 we discuss the issue of implementation in PVS and two examples that we verified. We conclude in Section 7. 2 The Process Algebra. We use the standard CCS of R. Milner <ref> [11, 12] </ref>, except that we change the parallel composition operator and the means of synchronization. The importance of this change will become clear in section 4, where we need it to simplify the compositional inference rules. <p> So, both steps of the verification of finite-state systems, i.e. model checking the components and deriving the global property, can be done in PVS. We verified two examples using the system: (1) Alternating Bit Protocol (ABP) [4, 6] and (2) Milner's Scheduler <ref> [12] </ref>. The ABP example consists of three parallel processes Send, Medium and Receive, combined together by two parallel composition operators: ABP ((Send S k M Medium) k R Receive) fl 11 with appropriate restriction sets. Each individual process including the intermediate (Send S k M Medium) has its own specification.
Reference: [13] <author> S. Owre, N. Shankar, and J. M. Rushby. </author> <title> User Guide for the PVS Specification and Verification System. </title> <institution> Computer Science Laboratory, SRI International, </institution> <address> Menlo Park, CA, </address> <month> February </month> <year> 1993. </year> <note> A new edition for PVS Version 2 is expected in late 1996. </note>
Reference-contexts: Therefore, one can only have a finite set of actions, whereas our system can handle infinite sets of actions as well. The proof system is implemented in PVS theorem prover <ref> [13] </ref>. The PVS specification language is used as a metalanguage to specify and prove the soundness of all the inference rules and axioms. The proof system is encoded as a set of theorems, which can be used as rewrite rules while a proof is in progress. <p> and the following relations: L L 0 =) [[ _ L]] e [[ _ L 0 ]] e and [[ ^ L]] e [[ ^ L 0 ]] e for a monotone f as in Lemma 4. 2 The proof of soundness was completely checked using the theorem prover PVS <ref> [13] </ref>. All the inference rules are encoded as theorems and can be used as rewrite rules when a proof is in progress. The completeness of the system is still an open problem. 6 Implementation in PVS. The Compositional Proof System is implemented in PVS theorem prover [13]. <p> the theorem prover PVS <ref> [13] </ref>. All the inference rules are encoded as theorems and can be used as rewrite rules when a proof is in progress. The completeness of the system is still an open problem. 6 Implementation in PVS. The Compositional Proof System is implemented in PVS theorem prover [13]. The main objectives of this implementation were to check the soundness of the system and to try out some relatively small proofs in the system. The PVS was chosen as an implementation framework because it has a built-in model checker.
Reference: [14] <author> C. Stirling. </author> <title> Modal logics for communicating systems. </title> <journal> Theoretical Computer Science, </journal> <volume> 49 </volume> <pages> 311-348, </pages> <month> July </month> <year> 1987. </year>
Reference-contexts: We use a (slightly modified version of) CCS as a model of concurrency. Many systems of parallel processes can be expressed as CCS processes, and then checked against specifications in the modal -calculus. Following Stirling <ref> [14] </ref>, our proof system consists of two subsystems. <p> These two proof systems with an additional inference rule from <ref> [14] </ref>: p ` k ` fi q ` (k) result in a compositional proof system for CCS (now with parallel composition operator) and the modal -calculus. Both subprocesses in each parallel composition operator have associated formulas specifying their properties. <p> In the worst case this results in an exponential blow-up in the size of the formula, and the total complexity remains the same as for non-compositional model checking [6]. The proof system of C. Stirling <ref> [14] </ref> is, probably, the most compositional in a sense that it clearly reduces the verification problem to the verification of components. In fact, our system has originated from it. But Stirling considers the Hennessy-Milner logic, which is too weak to be of much interest in practice. <p> In other words, we can introduce an inference rule: p ` k ` fl fi q ` (k) This inference rule was inspired by a similar rule of C. Stirling in <ref> [14] </ref>. In this paper we elaborate on the proof system for sequents of type k ` fl fi. For details on the proof system for p ` , where p is a sequential CCS term, the reader is referred to [8].
Reference: [15] <author> A. Tarski. </author> <title> A lattice-theoretic fixpoint theorem and its applications. </title> <journal> Pacific Journal of Mathematics, </journal> <volume> 5 </volume> <pages> 285-309, </pages> <year> 1955. </year>
Reference-contexts: [[X:]] L e = fS 0 S j S 0 [[]] L e [X := S 0 ]g Here the updated environment e [X := S 0 ] coincides with e on all variables, except maybe X, and The semantics of the fixed points is well-defined by Tarski's Fixed-point Theorem <ref> [15] </ref>, since all formulas are negation free. Thus, the semantic function is monotone on the interpretation of all free variables. We will write p j= M for p 2 [[]] L e, and will often omit the subscript M when this is unambiguous.
Reference: [16] <author> Glynn Winskel. </author> <title> A note on model checking the modal nu-calculus. </title> <editor> In G. Ausiello, M. Dezani-Ciancaglini, and S. Ronchi Della Rocca, editors, </editor> <booktitle> Proceedings of ICALP, volume 372 of Lecture Notes in Computer Science, </booktitle> <pages> pages 761-772. </pages> <publisher> Springer-Verlag, </publisher> <year> 1989. </year> <month> 15 </month>
Reference-contexts: For details on the proof system for p ` , where p is a sequential CCS term, the reader is referred to [8]. In our proof system we handle fixed points by assigning tags <ref> [16, 1] </ref> to the fixed point operators. Intuitively (although simplified), tags store the information that some particular sequents have already occurred below in the proof tree, assuming that the tree grows up from the goal to axioms. <p> A standard way to prove the local soundness of the fixed point rules is to use the reduction Lemma 4 <ref> [16, 1] </ref> (see the next section). <p> Then k ` fl fi =) k j= fl fi: Before sketching the proof we state the following lemma. Lemma 4. (The reduction lemma <ref> [16, 1] </ref>). Let D be a set and f : 2 D ! 2 D be monotone with respect to . Denote operators of the least and the greatest fixed points of f as x:f (x) and -x:f (x) respectively.
References-found: 16

