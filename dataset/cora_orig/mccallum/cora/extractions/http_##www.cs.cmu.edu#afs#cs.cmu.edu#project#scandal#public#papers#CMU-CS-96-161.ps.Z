URL: http://www.cs.cmu.edu/afs/cs.cmu.edu/project/scandal/public/papers/CMU-CS-96-161.ps.Z
Refering-URL: http://www.cs.cmu.edu/afs/cs.cmu.edu/user/jch/www/publications/CMU-CS-96-161.html
Root-URL: 
Title: Java as an Intermediate Language  
Author: Jonathan C. Hardwick and Jay Sipelstein 
Note: 1  
Address: Pittsburgh, PA 15213  
Affiliation: School of Computer Science Carnegie Mellon University  
Pubnum: CMU-CS-96-161  
Email: jch@cs.cmu.edu  sipelstein@cs.cmu.edu  
Phone: 2  
Date: August 12, 1996  
Abstract: We present our experiences in using Java as an intermediate language for the high-level programming language Nesl. First, we describe the design and implementation of a system for translating Vcode|the current intermediate language used by Nesl|into Java. Second, we evaluate this translation by comparing the performance of the original Vcode implementation with several variants of the Java implementation. The translator was easy to build, and the generated Java code achieves reasonable performance when using a just-in-time compiler. We conclude that Java is attractive both as a compilation target for rapid prototyping of new programming languages and as a means of improving the portability of existing programming languages. This research is sponsored by the Wright Laboratory, Aeronautical Systems Center, Air Force Materiel Command, USAF, and the Advanced Research Projects Agency (ARPA) under grant F33615-93-1-1330. The U.S. Government is authorized to reproduce and distribute reprints for Government purposes, notwithstanding any copyright notation thereon. Views and conclusions contained in this document are those of the author and should not be interpreted as representing the official policies, either expressed or implied, of ARPA or the U.S. Government. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> A. Adl-Tabatabai, G. Langdale, S. Lucco, and R. Wahbe. </author> <title> Efficient and language-independent mobile programs. </title> <type> Technical Report CMU-CS-95-204, </type> <institution> School of Computer Science, Carnegie Mellon University, </institution> <month> October </month> <year> 1995. </year>
Reference-contexts: The JIT compiler must therefore generate extra conditionals in the inner loop of vector code. There are techniques for guaranteeing valid indices without requiring these extra conditionals, such as performing loop-bounds analysis or exploiting virtual memory mechanisms for protection purposes <ref> [1] </ref>, but to our knowledge these optimizations are not performed by any current JIT compiler. Note that we were unable to measure any extra compilation overhead incurred by the JIT compiler; this null result can probably be attributed entirely to the poor resolution of the PC clock.
Reference: [2] <author> Guy E. Blelloch. </author> <title> Vector Models for Data-Parallel Computing. </title> <publisher> MIT Press, </publisher> <year> 1990. </year>
Reference-contexts: compiler are implementing high-level aspects of the Nesl language (such as type checking and the removal of higher-order code) and converting operations on 2 Sadly, "buzzword-compliant" is now missing from http://java.sun.com/, although the full definition remains intact at several mirror sites. 2 arbitrarily nested sequences into operations on segmented vectors <ref> [2] </ref>. Although Nesl was designed primarily to support efficient data-parallel programming, the high-level algorithmic nature of the language also makes it ideal for teaching and prototyping algorithms [4]. The middle layer of the system consists of the intermediate language Vcode and its interpreter. <p> For full protection, we could extend the method to throw an exception immediately if the two lengths are not equal. Vcode implements Nesl's nesting of data structures efficiently by using segmented vectors <ref> [2] </ref>. Segmented vectors use two kinds of vectors to represent arbitrary sequence nesting: a normal non-nested vector to hold the data, and a series of specialized vectors (called segment descriptors) to describe how the data is subdivided.
Reference: [3] <author> Guy E. Blelloch. NESL: </author> <title> A nested data-parallel language (version 3.1). </title> <type> Technical Report CMU-CS-95-170, </type> <institution> School of Computer Science, Carnegie Mellon University, </institution> <month> July </month> <year> 1995. </year>
Reference-contexts: Finally, Section 7 summarizes the work and our conclusions. 2 The Nesl System Java [14] has been defined as "a simple, object-oriented, distributed, interpreted, robust, secure, architecture-neutral, portable, high-performance, multithreaded, dynamic, buzzword-compliant, general-purpose programming language". 2 In the same spirit of buzzword-compliance, Nesl <ref> [3] </ref> is an interactive, high-level, strongly-typed, applicative, sequence-based, portable, nested data-parallel language. The primary data structure in Nesl is the sequence, each element of which can itself be a sequence. Parallelism is expressed in Nesl through an apply-to-each form over elements of sequences and through parallel operations on sequences. <p> No JIT compiler was available for the SPARCstation. We compiled the Nesl source code into Vcode using version 3.1 of the Nesl compiler <ref> [3] </ref>, combined with an additional optimization phase that inlines Vcode functions and removes unnecessary stack operations. All benchmarks were performed on idle machines to minimize outside effects. This was particularly important for the Java benchmarks, because Java provides only a time-of-day clock (java.lang.System.currentTimeMillis ()), rather than a per-process timer.
Reference: [4] <author> Guy E. Blelloch. </author> <title> Programming parallel algorithms. </title> <journal> Communications of the ACM, </journal> <volume> 39(3) </volume> <pages> 85-97, </pages> <month> March </month> <year> 1996. </year>
Reference-contexts: Does Java provide sufficient functionality to model the features of the source language? * Can the resulting programs be efficiently executed by a Java virtual machine? To try to answer these questions, we built a system that translates Vcode [5] (a specialized intermediate language for the high-level parallel language Nesl <ref> [4] </ref>) into Java, and performed a series of benchmarks to compare this new implementation with the original. 1 Java is a trademark of Sun Microsystems, Inc. All other trademarks in this paper are the property of their respective owners. 1 The rest of this paper is organized as follows. <p> Although Nesl was designed primarily to support efficient data-parallel programming, the high-level algorithmic nature of the language also makes it ideal for teaching and prototyping algorithms <ref> [4] </ref>. The middle layer of the system consists of the intermediate language Vcode and its interpreter. A Vcode program manipulates a stack of strongly-typed vectors. Each vector contains an arbitrary number of atomic values of a single type; Vcode vectors cannot be nested, unlike the Nesl sequences they represent.
Reference: [5] <author> Guy E. Blelloch and Siddhartha Chatterjee. </author> <title> VCODE: A data-parallel intermediate language. </title> <booktitle> In Proceedings Frontiers of Massively Parallel Computation, </booktitle> <pages> pages 471-480, </pages> <month> October </month> <year> 1990. </year>
Reference-contexts: Java easy to use in a new or existing system? * Does Java provide sufficient functionality to model the features of the source language? * Can the resulting programs be efficiently executed by a Java virtual machine? To try to answer these questions, we built a system that translates Vcode <ref> [5] </ref> (a specialized intermediate language for the high-level parallel language Nesl [4]) into Java, and performed a series of benchmarks to compare this new implementation with the original. 1 Java is a trademark of Sun Microsystems, Inc. <p> The front end of the system is an interactive compiler that lets users enter Nesl expressions and programs. Every Neslexpression is first compiled into an intermediate language called Vcode <ref> [5] </ref>. The compiler then invokes a Vcode interpreter (either locally or on a remote machine), passes it the Vcode via rcp or a distributed filesystem, and reads back the results.
Reference: [6] <author> Guy E. Blelloch, Siddhartha Chatterjee, Jonathan C. Hardwick, Margaret Reid-Miller, Jay Sipelstein, and Marco Zagha. CVL: </author> <title> A C vector library. </title> <type> Technical Report CMU-CS-93-114, </type> <institution> School of Computer Science, Carnegie Mellon University, </institution> <month> February </month> <year> 1993. </year>
Reference-contexts: Note that Vcode shares several properties with Java bytecode [10]: portability, strong typing, a stack-based execution model, and a design allowing for easy interpretation. At the bottom of the system is Cvl (C Vector Library), a machine-specific library that implements an abstract vector machine <ref> [6] </ref>. An example of a Cvl function is add_wuz, which adds the corresponding elements of two integer vectors together and returns the results in a third vector.
Reference: [7] <author> Guy E. Blelloch, Siddhartha Chatterjee, Jonathan C. Hardwick, Jay Sipelstein, and Marco Zagha. </author> <title> Implementation of a portable nested data-parallel language. </title> <booktitle> In Proceedings 4th ACM SIGPLAN Symposium on Principles and Practice of Parallel Programming, </booktitle> <pages> pages 102-111, </pages> <address> San Diego, </address> <month> May </month> <year> 1993. </year>
Reference-contexts: Parallelism is expressed in Nesl through an apply-to-each form over elements of sequences and through parallel operations on sequences. The current Nesl system consists of three layers, as shown in Figure 1 (see <ref> [7] </ref> for full details of the system). The front end of the system is an interactive compiler that lets users enter Nesl expressions and programs. Every Neslexpression is first compiled into an intermediate language called Vcode [5]. <p> This function multiplies a sparse matrix stored in com pressed row format by a dense vector, using a nested data-parallel algorithm. We give the source code and test data for the benchmarks in Appendix A. Timings for supercomputer platforms have previously been reported <ref> [7, 11] </ref>.
Reference: [8] <author> Per Bothner and R. Alexander Milowsk. </author> <title> The Kawa Scheme interpreter project. </title> <address> http://www.winternet.com/~sgml/kawa/. </address>
Reference-contexts: More directly, Intermetrics Inc. have adapted their Ada 95 compiler [16] to generate Java bytecode, dispensing with the intermediate step of using a Java compiler such as Sun's javac. The Kawa Scheme-in-Java compiler <ref> [8] </ref> also generates Java bytecode, enabling the compiler to perform tail-recursion elimination using the GOTO bytecode instruction (there is no corresponding goto statement in the Java language).
Reference: [9] <author> Mike Cowlishaw. </author> <note> NetRexx. http://www.ibm.com/Technology/NetRexx/. </note>
Reference-contexts: Perhaps the highest level is Libero [12], which compiles a program expressed in the form of a finite state machine into one of a variety of target languages, including Java. NetRexx <ref> [9] </ref> is a dialect of the Rexx language that also compiles to Java. Both of these projects take an approach similar to that described in this paper, in that Java source code is generated.
Reference: [10] <author> James Gosling. </author> <title> Java intermediate bytecodes. </title> <journal> SIGPLAN Notices, </journal> <month> March </month> <year> 1995. </year> <booktitle> Originally appeared at ACM SIGPLAN Workshop on Intermediate Representations (IR'95). </booktitle>
Reference-contexts: The extra overhead of interpreting Vcode instructions, rather than executing a compiled version of them, is amortized over the length of the vectors on which they operate. Note that Vcode shares several properties with Java bytecode <ref> [10] </ref>: portability, strong typing, a stack-based execution model, and a design allowing for easy interpretation. At the bottom of the system is Cvl (C Vector Library), a machine-specific library that implements an abstract vector machine [6].
Reference: [11] <author> Jonathan C. Hardwick. </author> <title> Porting a vector library: a comparison of MPI, Paris, CMMD and PVM. </title> <booktitle> In Proceedings of the 1994 Scalable Parallel Libraries Conference, </booktitle> <pages> pages 68-77, </pages> <month> October </month> <year> 1994. </year> <title> [12] iMatix. Libero|the thinking programmer's tool. </title> <address> http://www.imatix.com/html/libero/. </address>
Reference-contexts: An example of a Cvl function is add_wuz, which adds the corresponding elements of two integer vectors together and returns the results in a third vector. Cvl is the only part of the system that must be rewritten for a new architecture <ref> [11] </ref>. 3 Implementing Vcode in Java To use Java as an intermediate language in an existing compiler, the current intermediate language (assuming that one exists) either can be totally replaced by Java or it can be translated into Java by an additional stage of the compilation process. <p> This function multiplies a sparse matrix stored in com pressed row format by a dense vector, using a nested data-parallel algorithm. We give the source code and test data for the benchmarks in Appendix A. Timings for supercomputer platforms have previously been reported <ref> [7, 11] </ref>.
Reference: [13] <author> Mike Lehman. HotTEA. </author> <note> http://www.mbay.net/~cereus7/HotTEA.html. </note>
Reference-contexts: The Kawa Scheme-in-Java compiler [8] also generates Java bytecode, enabling the compiler to perform tail-recursion elimination using the GOTO bytecode instruction (there is no corresponding goto statement in the Java language). Finally, HotTEA <ref> [13] </ref> implements a simple Basic interpreter on top of the Java interpreter, without requiring any compilation at all. 7 Conclusions Ideally, an intermediate language should be simple, portable, efficient, and (when possible) maintained by somebody else. In this paper we have investigated whether Java makes a good intermediate language.
Reference: [14] <author> Sun Microsystems. </author> <title> The Java Language: An Overview, </title> <note> 1995. http://java.sun.com/doc/Overviews/java/. 15 </note>
Reference-contexts: Moreover, it should isolate low-level issues such as error checking and memory management. This paper was inspired by the observation that the recently developed Java 1 programming language <ref> [14] </ref> appears to possess all of these characteristics. We wanted to know whether Java would make a good intermediate language for current and future compilers. Java has several attractions as an intermediate language. The first is the design of the language itself. <p> Section 4 discusses our experiences in building the system and outlines additional optimizations that we incorporated into the final version. Section 5 presents benchmark results, and Section 6 describes related projects. Finally, Section 7 summarizes the work and our conclusions. 2 The Nesl System Java <ref> [14] </ref> has been defined as "a simple, object-oriented, distributed, interpreted, robust, secure, architecture-neutral, portable, high-performance, multithreaded, dynamic, buzzword-compliant, general-purpose programming language". 2 In the same spirit of buzzword-compliance, Nesl [3] is an interactive, high-level, strongly-typed, applicative, sequence-based, portable, nested data-parallel language.
Reference: [15] <author> Sun Microsystems. </author> <title> The Java Virtual Machine Specification, </title> <month> August </month> <year> 1995. </year> <note> http://java.sun.com/doc/language vm specification.html. </note>
Reference-contexts: Another attraction of Java is that it is a portable, network-aware language. The details of machine architecture, operating system, and display environment are all handled transparently by the Java virtual machine <ref> [15] </ref>. The same Java program can run on a Unix workstation, a PC, and a Macintosh, while retaining the same "look and feel" on each platform. Using Java as an intermediate language also allows programs to be distributed in an executable form (Java bytecode) over the Internet.
Reference: [16] <author> S. Tucker Taft. </author> <title> Programming the Internet in Ada 95. </title> <note> Submitted to Ada Europe '96. Also available at http://www.inmet.com/~stt/adajava paper/. Copies of [3], [4], [5], [6], [7], and [11] are also available from the Scandal project web site at http://www.cs.cmu.edu/~scandal/papers.html. </note>
Reference-contexts: NetRexx [9] is a dialect of the Rexx language that also compiles to Java. Both of these projects take an approach similar to that described in this paper, in that Java source code is generated. More directly, Intermetrics Inc. have adapted their Ada 95 compiler <ref> [16] </ref> to generate Java bytecode, dispensing with the intermediate step of using a Java compiler such as Sun's javac. The Kawa Scheme-in-Java compiler [8] also generates Java bytecode, enabling the compiler to perform tail-recursion elimination using the GOTO bytecode instruction (there is no corresponding goto statement in the Java language).
References-found: 15

