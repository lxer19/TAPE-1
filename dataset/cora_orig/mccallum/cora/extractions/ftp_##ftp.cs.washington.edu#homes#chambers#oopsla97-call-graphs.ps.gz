URL: ftp://ftp.cs.washington.edu/homes/chambers/oopsla97-call-graphs.ps.gz
Refering-URL: http://www.cs.washington.edu/research/projects/cecil/www/Papers/call-graph.html
Root-URL: 
Note: Appears in OOPSLA 97 Conference Proceedings.  
Abstract: Interprocedural analyses enable optimizing compilers to more precisely model the effects of non-inlined procedure calls, potentially resulting in substantial increases in application performance. Applying interprocedural analysis to programs written in object-oriented or functional languages is complicated by the difficulty of constructing an accurate program call graph. This paper presents a parameterized algorithmic framework for call graph construction in the presence of message sends and/or first-class functions. We use this framework to describe and to implement a number of well-known and new algorithms. We then empirically assess these algorithms by applying them to a suite of medium-sized programs written in Cecil and Java, reporting on the relative cost of the analyses, the relative precision of the constructed call graphs, and the impact of this precision on the effectiveness of a number of interprocedural optimizations. 
Abstract-found: 1
Intro-found: 1
Reference: [Agesen 94] <author> Ole Agesen. </author> <title> Constraint-Based Type Inference and Parametric Polymorphism. </title> <booktitle> In First International Static Analysis Symposium, </booktitle> <month> September </month> <year> 1994. </year>
Reference-contexts: Additionally, the framework of Stefanescu and Zhou appears to be limited to only using various avors of dynamic call chain information as contour keys. Agesen used templates as an informal explanatory device in his description of constraint-graph-based instantiations of 0-CFA, k-CFA, and Plevyaks algorithm <ref> [Agesen 94] </ref>. Templates are similar to contours in that they serve to group and summarize all of the local constraints introduced by a procedure. Agesen does not formally define templates and only considers context-sensitivity in the ProcKey domain.
Reference: [Agesen 95] <author> Ole Agesen. </author> <title> The Cartesian Product Algorithm: Simple and Precise Type Inference of Parametric Polymorphism. </title> <booktitle> In Proceedings ECOOP 95, </booktitle> <address> Aarhus, Denmark, </address> <month> August </month> <year> 1995. </year> <note> Springer-Verlag. </note>
Reference-contexts: Similarly, several algorithms for interprocedural class analysis use information about the classes of actual parameters to drive their contour selection functions: k 0= Contour keys in Agesens Cartesian Product Algorithm (CPA) <ref> [Agesen 95] </ref> are drawn from the domain , i.e., each key is a tuple of single class contours, one per formal parameter. <p> This is the starting point used by the majority of the algorithms, including 0-CFA and k-CFA [Shivers 88, Shivers 91a], the Cartesian Product Algorithm (CPA) <ref> [Agesen 95] </ref>, Plevyaks iterative algorithm [Plevyak & Chien 94], and many others. G T is a good initial call graph for algorithms that apply Monotonic Refinement since it ensures reaching the best possible fixed-point solution for that algorithm.
Reference: [Agesen 96] <author> Ole Agesen. </author> <title> Concrete Type Inference: Delivering Object-Oriented Applications. </title> <type> PhD thesis, </type> <institution> Stanford, </institution> <month> January </month> <year> 1996. </year> <note> SLMI TR 96-52. </note>
Reference-contexts: In the presence of closures, this can lead to an infinitely tall call graph lattice; Agesen terms this problem recursive customization and describes several methods for detecting it and applying a widening operation <ref> [Agesen 96] </ref>. The two components of a call graph are instance variable contours and procedure contours. Instance variable contours enable the analysis of dataow through instance variable loads and stores.
Reference: [Alt & Martin 95] <author> Martin Alt and Florian Martin. </author> <title> Generation of efficient interprocedural analyzers with PAG. </title> <booktitle> In Proceedings of the Second International Symposium on Static Analysis, </booktitle> <pages> pages 3350. </pages> <publisher> Springer-Verlag, </publisher> <month> September </month> <year> 1995. </year>
Reference-contexts: Alt and Martin have developed an even more aggressive call graph construction algorithm, used in their PAG system, that first unrolls k levels of recursion <ref> [Alt & Martin 95] </ref>. Steensgaard developed an unbounded-call-chain algorithm that handles nested lexical environments by applying a widening operation to class sets of formal parameters at entries to recursive cycles in the call graph [Steensgaard 94].
Reference: [Bacon & Sweeney 96] <author> David F. Bacon and Peter F. Sweeney. </author> <title> Fast Static Analysis of C++ Virtual Function Calls. </title> <booktitle> In OOPSLA96 Conference Proceedings, </booktitle> <address> San Jose, CA, </address> <month> October </month> <year> 1996. </year>
Reference-contexts: G RTA : improves on G static by performing Bacon and Sweeneys Rapid Type Analysis (RTA), a linear-time optimistic reachability analysis, to eliminate classes that cannot be created and methods that cannot be invoked <ref> [Bacon & Sweeney 96] </ref>. RTA can be applied to dynamically typed languages as well to build a version of G RTA from G selector .
Reference: [Bracha & Griswold 93] <author> Gilad Bracha and David Griswold. Strong-talk: </author> <title> Typechecking Smalltalk in a Production Environment. </title> <booktitle> In Proceedings OOPSLA 93, </booktitle> <pages> pages 215230, </pages> <month> October </month> <year> 1993. </year> <journal> Published as ACM SIGPLAN Notices, </journal> <volume> volume 28, number 10. </volume>
Reference-contexts: A bounded variant, b-SCS, could be defined to limit the number of contours created per procedure by falling back on a context-insensitive summary when the procedures contour creation budget is exceeded. In languages like Cecil [Chambers 93] and Strongtalk <ref> [Bracha & Griswold 93] </ref> which have expressive, but optional, parameterized static type declarations, using some abstraction of the static types of the actual type parameters to provide hints to the contour selection function may be very effective.
Reference: [Callahan et al. 90] <author> David Callahan, Alan Carle, Mary W. Hall, and Ken Kennedy. </author> <title> Constructing the Procedure Call Multigraph. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 16(4):483487, </volume> <year> 1990. </year>
Reference-contexts: Finally, a number of algorithms based on unbounded but finite values for k have been proposed: Ryders call graph construction algorithm for Fortran 77 [Ryder 79], Callahans extension to Ryders work to support recursion <ref> [Callahan et al. 90] </ref>, and Emamis alias analysis algorithm for C [Emami et al. 94] all treat each non-recursive path through the call graph as creating a new context.
Reference: [Chambers & Ungar 89] <author> Craig Chambers and David Ungar. </author> <title> Customization: Optimizing Compiler Technology for Self, A Dynamically-Typed Object-Oriented Programming Language. </title> <journal> SIGPLAN Notices, </journal> <volume> 24(7):146160, </volume> <month> July </month> <year> 1989. </year> <booktitle> In Proceedings of the ACM SIGPLAN 89 Conference on Programming Language Design and Implementation. </booktitle>
Reference-contexts: The base configuration represents an aggressive combination of intraprocedural and limited interprocedural optimizations which include: intraprocedural class analysis [Johnson 88, Chambers & Ungar 90], hard-wired class prediction for common messages (Cecil programs only) <ref> [Deutsch & Schiffman 84, Chambers & Ungar 89] </ref>, splitting [Chambers & Ungar 89], class hierarchy analysis [Dean et al. 95], cross-module inlining, static class prediction [Dean 96], closure optimizations (Cecil only), and a suite of traditional intraprocedural optimizations such as common subexpression elimination, constant propagation and folding, dead assignment elimination, and <p> The base configuration represents an aggressive combination of intraprocedural and limited interprocedural optimizations which include: intraprocedural class analysis [Johnson 88, Chambers & Ungar 90], hard-wired class prediction for common messages (Cecil programs only) [Deutsch & Schiffman 84, Chambers & Ungar 89], splitting <ref> [Chambers & Ungar 89] </ref>, class hierarchy analysis [Dean et al. 95], cross-module inlining, static class prediction [Dean 96], closure optimizations (Cecil only), and a suite of traditional intraprocedural optimizations such as common subexpression elimination, constant propagation and folding, dead assignment elimination, and redundant load and store elimination.
Reference: [Chambers & Ungar 90] <author> Craig Chambers and David Ungar. </author> <title> Iterative Type Analysis and Extended Message Splitting: Optimizing Dynamically-Typed Object-Oriented Programs. </title> <journal> SIGPLAN Notices, </journal> <volume> 25(6):150164, </volume> <month> June </month> <year> 1990. </year> <booktitle> In Proceedings of the ACM SIGPLAN 90 Conference on Programming Language Design and Implementation. </booktitle>
Reference-contexts: The base configuration represents an aggressive combination of intraprocedural and limited interprocedural optimizations which include: intraprocedural class analysis <ref> [Johnson 88, Chambers & Ungar 90] </ref>, hard-wired class prediction for common messages (Cecil programs only) [Deutsch & Schiffman 84, Chambers & Ungar 89], splitting [Chambers & Ungar 89], class hierarchy analysis [Dean et al. 95], cross-module inlining, static class prediction [Dean 96], closure optimizations (Cecil only), and a suite of traditional
Reference: [Chambers 93] <author> Craig Chambers. </author> <title> The Cecil Language: Specification and Rationale. </title> <type> Technical Report TR-93-03-05, </type> <institution> Department of Computer Science and Engineering. University of Washing-ton, </institution> <month> March </month> <year> 1993. </year>
Reference-contexts: Finally, the call graph model and algorithmic framework helped us to identify several new and interesting points in the design space of call graph construction algorithms. In section 4, we empirically assess the precision and cost of the implemented algorithms, applying them to a suite of Cecil <ref> [Chambers 93] </ref> and Java [Gosling et al. 96] programs. Our benchmark applications are an order of magnitude larger than those used to evaluate previous work, enabling us to assess how well each algorithm scales to larger programs. <p> A bounded variant, b-SCS, could be defined to limit the number of contours created per procedure by falling back on a context-insensitive summary when the procedures contour creation budget is exceeded. In languages like Cecil <ref> [Chambers 93] </ref> and Strongtalk [Bracha & Griswold 93] which have expressive, but optional, parameterized static type declarations, using some abstraction of the static types of the actual type parameters to provide hints to the contour selection function may be very effective.
Reference: [Cooper et al. 92] <author> Keith D. Cooper, Mary W. Hall, and Ken Kennedy. </author> <title> Procedure Cloning. </title> <booktitle> In Proceedings of 1992 IEEE International Conference on Computer Languages, </booktitle> <pages> pages 96105, </pages> <address> Oak-land, CA, </address> <month> April </month> <year> 1992. </year>
Reference-contexts: Although reporting these statistics at the granularity of contours can be useful for comparing various context-sensitive algorithms, it does not reect the effective precision of the call graph unless multiple versions of each procedure are compiled, one for each of its analysis-time contours. Some previous systems <ref> [Cooper et al. 92, Plevyak & Chien 95] </ref> have used the contours created during interprocedural analysis to a. Shaded cells correspond to configurations that either did not complete in 24 hours or exhausted available virtual memory (450MB).
Reference: [Cousot & Cousot 77] <author> Patrick Cousot and Radhia Cousot. </author> <title> Abstract Interpretation: A Unified Lattice Model for Static Analysis of Programs by Construction or Approximation of Fixpoints. </title> <booktitle> In Conference Record of the Fourth ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 238252, </pages> <address> Los Ange-les, California, </address> <month> January </month> <year> 1977. </year>
Reference-contexts: We formalize the possible outputs of the contour selection functions, giving some formal structure to them that will help in comparing algorithms. call graph lattice. As is traditional in dataow analysis [Kildall 73, Kam & Ullman 76] (but opposite to the conventions used in abstract interpretation <ref> [Cousot & Cousot 77] </ref>), the top lattice element represents the best possible (most optimistic) call graph, while the bottom element represents the worst possible (most conservative) call graph. * A lattice is a set of elements S D and an associated partial ordering of those elements such that for every pair <p> Some of the context-sensitive algorithms introduce additional mutually recursive definitions that cause their CallGraph domains to be infinitely tall. To guarantee termination, at least one of their contour selection functions must incorporate a widening operation <ref> [Cousot & Cousot 77] </ref>. For example, Agesens Cartesian Product Algorithm uses elements of the ClassContour domain as a component of its ProcKey domain elements.
Reference: [Dean 96] <author> Jeffrey Dean. </author> <title> Whole Program Optimization of Object-Oriented Languages. </title> <type> PhD thesis, </type> <institution> University of Washing-ton, </institution> <month> November </month> <year> 1996. </year> <month> TR-96-11-05. </month>
Reference-contexts: intraprocedural and limited interprocedural optimizations which include: intraprocedural class analysis [Johnson 88, Chambers & Ungar 90], hard-wired class prediction for common messages (Cecil programs only) [Deutsch & Schiffman 84, Chambers & Ungar 89], splitting [Chambers & Ungar 89], class hierarchy analysis [Dean et al. 95], cross-module inlining, static class prediction <ref> [Dean 96] </ref>, closure optimizations (Cecil only), and a suite of traditional intraprocedural optimizations such as common subexpression elimination, constant propagation and folding, dead assignment elimination, and redundant load and store elimination.
Reference: [Dean et al. 95] <author> Jeffrey Dean, David Grove, and Craig Chambers. </author> <title> Optimization of Object-Oriented Programs Using Static Class Hierarchy Analysis. </title> <booktitle> In Proceedings ECOOP 95, </booktitle> <address> Aarhus, Denmark, </address> <month> August </month> <year> 1995. </year> <note> Springer-Verlag. </note>
Reference-contexts: This approximation reduces the size of the union (Vortex supports a compact cone representation for the class set corresponding to a class and all of its subclasses <ref> [Dean et al. 95] </ref>) and may reduce the number of times its contents change (by eagerly performing several subsequent class add operations). <p> The base configuration represents an aggressive combination of intraprocedural and limited interprocedural optimizations which include: intraprocedural class analysis [Johnson 88, Chambers & Ungar 90], hard-wired class prediction for common messages (Cecil programs only) [Deutsch & Schiffman 84, Chambers & Ungar 89], splitting [Chambers & Ungar 89], class hierarchy analysis <ref> [Dean et al. 95] </ref>, cross-module inlining, static class prediction [Dean 96], closure optimizations (Cecil only), and a suite of traditional intraprocedural optimizations such as common subexpression elimination, constant propagation and folding, dead assignment elimination, and redundant load and store elimination.
Reference: [Dean et al. 96] <author> Jeffrey Dean, Greg DeFouw, Dave Grove, Vassily Litvinov, and Craig Chambers. </author> <title> Vortex: An Optimizing Compiler for Object-Oriented Languages. </title> <booktitle> In OOPSLA96 Conference Proceedings, </booktitle> <address> San Jose, CA, </address> <month> October </month> <year> 1996. </year> <month> 16 </month>
Reference-contexts: Our model leads to a natural parameterized implementation framework, and we have implemented this framework and a number of call graph construction algorithms in the Vortex optimizing compiler system <ref> [Dean et al. 96] </ref>. Finally, the call graph model and algorithmic framework helped us to identify several new and interesting points in the design space of call graph construction algorithms. <p> G ^ G RTA (static) G unif (static) G 0-CFA G 1-0-CFA G 3-0-CFA G 2-1-CFA G 3-2-CFA G 4-1-CFA G 5-0-CFA G 5-1-CFA G 4-2-CFA G b-CPA G prof3 G T Optimistic Sound G prof2 G prof1 G prof4 G prof5 interprocedural analysis in the Vortex optimizing compiler infrastructure <ref> [Dean et al. 96] </ref> includes contour and contour_key abstract classes and related data structures, and a body of centralized code for executing the generalized algorithm and monotonic refinement. We are currently working on adding support for non-monotonic improvement. <p> base configuration; for comparison * , the base configuration is on average 7.6 times faster than Suns JDK1.0.2 interpreter, 3.8 times faster than Suns JDK1.0.2 just-in-time dynamic compiler, 2.0 times faster than Toba 1.0.5, an unoptimizing translator from Java to C, and 1.5 times faster than our own Vortex implementation <ref> [Dean et al. 96] </ref> without any optimizations other than those due to our gcc -O2 back-end. The treeshaking optimization shrank executable sizes for all the interprocedural analysis configurations.
Reference: [DeFouw et al. 97] <author> Greg DeFouw, David Grove, and Craig Chambers. </author> <title> Fast Interprocedural Class Analysis. </title> <type> Technical Report TR-97-07-02, </type> <institution> Department of Computer Science and Engineering. University of Washington, </institution> <month> July </month> <year> 1997. </year>
Reference-contexts: G unif : improves on G RTA by performing a near-linear-time unification-based algorithm to identify disjoint components of the programs dataow graph and associate a set of reachable classes and methods with each disjoint component <ref> [DeFouw et al. 97] </ref> (RTA pessimistically assumes that the dataow graph only contains a single disjoint component, and thus computes a single set of reachable classes and methods for the entire program).
Reference: [Deutsch & Schiffman 84] <author> L. Peter Deutsch and Allan M. Schiffman. </author> <title> Efficient Implementation of the Smalltalk-80 System. </title> <booktitle> In Conference Record of the Eleventh Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 297302, </pages> <address> Salt Lake City, Utah, </address> <month> January </month> <year> 1984. </year>
Reference-contexts: The base configuration represents an aggressive combination of intraprocedural and limited interprocedural optimizations which include: intraprocedural class analysis [Johnson 88, Chambers & Ungar 90], hard-wired class prediction for common messages (Cecil programs only) <ref> [Deutsch & Schiffman 84, Chambers & Ungar 89] </ref>, splitting [Chambers & Ungar 89], class hierarchy analysis [Dean et al. 95], cross-module inlining, static class prediction [Dean 96], closure optimizations (Cecil only), and a suite of traditional intraprocedural optimizations such as common subexpression elimination, constant propagation and folding, dead assignment elimination, and
Reference: [Diwan et al. 96] <author> Amer Diwan, Eliot Moss, and Kathryn McKinley. </author> <title> Simple and Effective Analysis of Statically-typed Object-Oriented Programs. </title> <booktitle> In OOPSLA96 Conference Proceedings, </booktitle> <address> San Jose, CA, </address> <month> October </month> <year> 1996. </year>
Reference-contexts: G intra : improves on either G selector or G static (depending on whether or not the language is statically typed) by performing intraprocedural analysis of each procedure to compute more precise approximations to the class sets of local variables and outgoing call arcs, as in Diwans Modula-3 optimizer <ref> [Diwan et al. 96] </ref>. G RTA : improves on G static by performing Bacon and Sweeneys Rapid Type Analysis (RTA), a linear-time optimistic reachability analysis, to eliminate classes that cannot be created and methods that cannot be invoked [Bacon & Sweeney 96].
Reference: [Emami et al. 94] <author> Maryam Emami, Rakesh Ghiya, and Laurie J. Hen-dren. </author> <title> Context-Sensitive Interprocedural Points-to Analysis in the Presence of Function Pointers. </title> <journal> SIGPLAN Notices, </journal> <volume> 29(6):242256, </volume> <month> June </month> <year> 1994. </year> <booktitle> In Proceedings of the ACM SIG-PLAN 94 Conference on Programming Language Design and Implementation. </booktitle>
Reference-contexts: Finally, a number of algorithms based on unbounded but finite values for k have been proposed: Ryders call graph construction algorithm for Fortran 77 [Ryder 79], Callahans extension to Ryders work to support recursion [Callahan et al. 90], and Emamis alias analysis algorithm for C <ref> [Emami et al. 94] </ref> all treat each non-recursive path through the call graph as creating a new context. Alt and Martin have developed an even more aggressive call graph construction algorithm, used in their PAG system, that first unrolls k levels of recursion [Alt & Martin 95].
Reference: [Gosling et al. 96] <author> James Gosling, Bill Joy, and Guy Steele. </author> <title> The Java Language Specification. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, MA, </address> <year> 1996. </year>
Reference-contexts: In section 4, we empirically assess the precision and cost of the implemented algorithms, applying them to a suite of Cecil [Chambers 93] and Java <ref> [Gosling et al. 96] </ref> programs. Our benchmark applications are an order of magnitude larger than those used to evaluate previous work, enabling us to assess how well each algorithm scales to larger programs.
Reference: [Grove et al. 95] <author> David Grove, Jeffrey Dean, Charles Garrett, and Craig Chambers. </author> <title> Profile-Guided Receiver Class Prediction. </title> <booktitle> In OOPSLA95 Conference Proceedings, </booktitle> <pages> pages 108123, </pages> <address> Austin, TX, </address> <month> October </month> <year> 1995. </year>
Reference-contexts: Seeding the call graph with (context-insensitive) profile-derived call arcs and sets of classes can enable context-insensitive algorithms to reach the final sound solution more rapidly than if starting with G T , but without sacrificing precision. Profile data with call chain context <ref> [Grove et al. 95] </ref> can be used to seed some context-sensitive algorithms without degrading the final solution. 3.3 Monotonic Refinement Monotonic Refinement removes an unsound contour from the worklist and processes it, monotonically extending it (moving it lower in the contour domain) to make it locally sound. <p> We applied these optimizations through our Vortex compiler to produce C code, which we then compiled with gcc -O2 to produce executable code. The base+profile configuration augments base with profile-guided class prediction <ref> [Hlzle & Ungar 94, Grove et al. 95] </ref>.
Reference: [Hall & Kennedy 92] <author> Mary W. Hall and Ken Kennedy. </author> <title> Efficient Call Graph Analysis. </title> <journal> ACM Letters on Programming Languages and Systems, </journal> <volume> 1(3):227242, </volume> <month> September </month> <year> 1992. </year>
Reference-contexts: Algorithms such as 0-CFA [Shivers 88, Shivers 91a], Palsberg and Schwartzbachs basic algorithm [Palsberg & Schwartzbach 91], Hall and Kennedys 6 call graph construction algorithm for Fortran <ref> [Hall & Kennedy 92] </ref>, and Lakhotias algorithm for building a call graph in languages with higher-order functions [Lakhotia 93] are all examples of this instantiation of the framework.
Reference: [Hlzle & Agesen 96] <author> Urs Hlzle and Ole Agesen. </author> <title> Dynamic vs. Static Optimization Techniques for Object-Oriented Languages. </title> <journal> Theory and Practice of Object Systems, </journal> <volume> 1(3), </volume> <year> 1996. </year>
Reference-contexts: Agesen does not formally define templates and only considers context-sensitivity in the ProcKey domain. Hlzle and Agesen compared the effectiveness of interprocedural class analysis based on the Cartesian Product Algorithm and profile-guided class prediction for the optimization of Self programs <ref> [Hlzle & Agesen 96] </ref>. They found that there was very little performance difference (less than 15%) between three optimizing configurations: one using only profile-guided class prediction, one using only interprocedural class analysis, and one 15 using both techniques.
Reference: [Hlzle & Ungar 94] <author> Urs Hlzle and David Ungar. </author> <title> Optimizing Dynamically-Dispatched Calls with Run-Time Type Feedback. </title> <journal> SIGPLAN Notices, </journal> <volume> 29(6):326336, </volume> <month> June </month> <year> 1994. </year> <booktitle> In Proceedings of the ACM SIGPLAN 94 Conference on Programming Language Design and Implementation. </booktitle>
Reference-contexts: We applied these optimizations through our Vortex compiler to produce C code, which we then compiled with gcc -O2 to produce executable code. The base+profile configuration augments base with profile-guided class prediction <ref> [Hlzle & Ungar 94, Grove et al. 95] </ref>.
Reference: [Jagannathan & Weeks 95] <author> Suresh Jagannathan and Stephen Weeks. </author> <title> A Unified Framework of Flow Analysis in HIgher-Order Languages. </title> <booktitle> In Conference Record of POPL 95: 22nd ACM SIG-PLAN-SIGACT Symposium on Principles of Programming Languages, </booktitle> <pages> pages 393407, </pages> <month> January </month> <year> 1995. </year>
Reference: [Johnson 88] <author> Ralph Johnson. </author> <title> TS: AN Optimizing Compiler for Smalltalk. </title> <booktitle> In Proceedings OOPSLA 88, </booktitle> <pages> pages 1826, </pages> <month> No-vember </month> <year> 1988. </year> <journal> Published as ACM SIGPLAN Notices, </journal> <volume> volume 23, number 11. </volume>
Reference-contexts: The base configuration represents an aggressive combination of intraprocedural and limited interprocedural optimizations which include: intraprocedural class analysis <ref> [Johnson 88, Chambers & Ungar 90] </ref>, hard-wired class prediction for common messages (Cecil programs only) [Deutsch & Schiffman 84, Chambers & Ungar 89], splitting [Chambers & Ungar 89], class hierarchy analysis [Dean et al. 95], cross-module inlining, static class prediction [Dean 96], closure optimizations (Cecil only), and a suite of traditional
Reference: [Kam & Ullman 76] <author> John B. Kam and Jeffrey D. Ullman. </author> <title> Global data flow analysis and iterative algorithms. </title> <journal> Journal of the ACM, </journal> <volume> 23(1):158171, </volume> <month> January </month> <year> 1976. </year>
Reference-contexts: We formalize the possible outputs of the contour selection functions, giving some formal structure to them that will help in comparing algorithms. call graph lattice. As is traditional in dataow analysis <ref> [Kildall 73, Kam & Ullman 76] </ref> (but opposite to the conventions used in abstract interpretation [Cousot & Cousot 77]), the top lattice element represents the best possible (most optimistic) call graph, while the bottom element represents the worst possible (most conservative) call graph. * A lattice is a set of elements
Reference: [Kildall 73] <author> Gary A. Kildall. </author> <title> A Unified Approach to Global Program Optimization. </title> <booktitle> In Conference Record of the ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 194 206, </pages> <address> Boston, Massachusetts, </address> <month> October </month> <year> 1973. </year>
Reference-contexts: We formalize the possible outputs of the contour selection functions, giving some formal structure to them that will help in comparing algorithms. call graph lattice. As is traditional in dataow analysis <ref> [Kildall 73, Kam & Ullman 76] </ref> (but opposite to the conventions used in abstract interpretation [Cousot & Cousot 77]), the top lattice element represents the best possible (most optimistic) call graph, while the bottom element represents the worst possible (most conservative) call graph. * A lattice is a set of elements
Reference: [Kranz 88] <author> David Kranz. </author> <title> ORBIT: An Optimizing Compiler for Scheme. </title> <type> PhD thesis, </type> <institution> Yale University, </institution> <month> February </month> <year> 1988. </year> <institution> Department of Computer Science, </institution> <note> Research Report 632. </note>
Reference-contexts: Escape analysis: Interprocedural escape analysis identifies first-class functions which are guaranteed not to out-live their lexically enclosing environment, thus enabling the function objects and their environments to be stack-allocated <ref> [Kranz 88] </ref>. This optimization applied only to the Cecil benchmarks. Treeshaking: As a side-effect of constructing the call graph, the compiler identifies those procedures which are unreachable during any program execution.
Reference: [Lakhotia 93] <author> Arun Lakhotia. </author> <title> Constructing Call Multigraphs Using Dependence Graphs. </title> <booktitle> In Conference Record of the Twentieth Annual ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages, </booktitle> <pages> pages 273284, </pages> <address> Charleston, South Carolina, </address> <month> January </month> <year> 1993. </year>
Reference-contexts: Algorithms such as 0-CFA [Shivers 88, Shivers 91a], Palsberg and Schwartzbachs basic algorithm [Palsberg & Schwartzbach 91], Hall and Kennedys 6 call graph construction algorithm for Fortran [Hall & Kennedy 92], and Lakhotias algorithm for building a call graph in languages with higher-order functions <ref> [Lakhotia 93] </ref> are all examples of this instantiation of the framework.
Reference: [Landi et al. 93] <author> William Landi, Barbara G. Ryder, and Sean Zhang. </author> <title> Interprocedural Side Effect Analysis With Pointer Aliasing. </title> <journal> SIGPLAN Notices, </journal> <volume> 28(6):5667, </volume> <month> June </month> <year> 1993. </year> <booktitle> In Proceedings of the ACM SIGPLAN 93 Conference on Programming Language Design and Implementation. </booktitle>
Reference-contexts: For example, some abstraction of the alias relationships among actual parameters has been used as the basis for context-sensitivity in algorithms for interprocedural alias analysis <ref> [Landi et al. 93, Wilson & Lam 95] </ref>. <p> single-point lattice SCS AllTuples (ClassContourSet) single-point lattice single-point lattice b-CPA AllTuples (ClassContour) single-point lattice single-point lattice k-0-CFA where k&gt;0 AllTuples (ProcContour) single-point lattice single-point lattice k-l-CFA where k l &gt; 0 AllTuples (ProcContour) ClassContour AllTuples (ProcContour) O N ( ) AllTuples ClassContourSet ( ) 7 Landis alias analysis for C <ref> [Landi et al. 93] </ref> and uses an extension of Landis conditional points-to information as a basis for context-sensitivity.
Reference: [Nielson & Nielson 97] <author> Flemming Nielson and Hanne Riis Nielson. </author> <title> Infinitary Control Flow Analysis: a Collecting Semantics for Closure Analysis. </title> <booktitle> In Conference Record of POPL 97: 24th ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages, </booktitle> <pages> pages 332345, </pages> <address> Paris, France, </address> <month> January </month> <year> 1997. </year>
Reference-contexts: This extension would allow us to model the flexible analysis of lexical environments supported by infinitary control flow analysis <ref> [Nielson & Nielson 97] </ref>.
Reference: [Odersky & Wadler 97] <author> Martin Odersky and Philip Wadler. </author> <title> Pizza into Java: Translating theory into practice. </title> <booktitle> In Conference Record of POPL 97: 24th ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages, </booktitle> <pages> pages 146159, </pages> <address> Paris, France, </address> <month> January </month> <year> 1997. </year>
Reference-contexts: This extension would allow us to model the flexible analysis of lexical environments supported by infinitary control flow analysis [Nielson & Nielson 97]. A similar strategy is used by the Pizza implementation to translate closures into Java <ref> [Odersky & Wadler 97] </ref>. 3 which returns the set of appropriate instance variable contours for a particular instance variable load or store operation, given class set information about the object being loaded or stored from. Some analyses are even more precise in their analysis of classes and instance variable contents.
Reference: [Oxhj et al. 92] <author> Nicholas Oxhj, Jens Palsberg, and Michael I. Schwartzbach. </author> <title> Making Type Inference Practical. </title> <editor> In O. Lehrmann Madsen, editor, </editor> <booktitle> Proceedings ECOOP 92, </booktitle> <volume> LNCS 615, </volume> <pages> pages 329349, </pages> <address> Utrecht, The Netherlands, June 1992. </address> <publisher> Springer-Verlag. </publisher>
Reference-contexts: An algorithm may use a fixed value of k throughout the program, as in Shiverss k-CFA family of algorithms [Shivers 88, Shivers 91a] or Oxhjs 1-CFA extension to Palsberg and Schwartzbachs algorithm <ref> [Oxhj et al. 92] </ref>. Adaptive algorithms may use different levels of k in different regions of the call graph to more exibly manage the trade-off between analysis time and precision.
Reference: [Palsberg & Schwartzbach 91] <author> Jens Palsberg and Michael I. Schwartz-bach. </author> <title> Object-Oriented Type Inference. </title> <booktitle> In Proceedings OOP-SLA 91, </booktitle> <pages> pages 146161, </pages> <month> November </month> <year> 1991. </year> <journal> Published as ACM SIGPLAN Notices, </journal> <volume> volume 26, number 11. </volume>
Reference-contexts: Algorithms such as 0-CFA [Shivers 88, Shivers 91a], Palsberg and Schwartzbachs basic algorithm <ref> [Palsberg & Schwartzbach 91] </ref>, Hall and Kennedys 6 call graph construction algorithm for Fortran [Hall & Kennedy 92], and Lakhotias algorithm for building a call graph in languages with higher-order functions [Lakhotia 93] are all examples of this instantiation of the framework.
Reference: [Plevyak & Chien 94] <author> John Plevyak and Andrew A. Chien. </author> <title> Precise Concrete Type Inference for Object-Oriented Languages. </title> <booktitle> In Proceedings OOPSLA 94, </booktitle> <pages> pages 324340, </pages> <address> Portland, OR, </address> <month> Oc-tober </month> <year> 1994. </year>
Reference-contexts: This is the starting point used by the majority of the algorithms, including 0-CFA and k-CFA [Shivers 88, Shivers 91a], the Cartesian Product Algorithm (CPA) [Agesen 95], Plevyaks iterative algorithm <ref> [Plevyak & Chien 94] </ref>, and many others. G T is a good initial call graph for algorithms that apply Monotonic Refinement since it ensures reaching the best possible fixed-point solution for that algorithm. <p> The only implemented algorithm of which we are aware that includes global non-monotonic improvement is Plevyaks iterative algorithm <ref> [Plevyak & Chien 94] </ref>. The algorithm considers any message send with more than one possibly invoked method an undesirable property of the call graph and attempts to resolve it via non-monotonic improvement.
Reference: [Plevyak & Chien 95] <author> John Plevyak and Andrew A. Chien. </author> <title> Type Directed Cloning for Object-Oriented Programs. </title> <booktitle> In Proceedings of the Workshop for Languages and Compilers for Parallel Computing, </booktitle> <pages> pages 566580, </pages> <year> 1995. </year>
Reference-contexts: Although reporting these statistics at the granularity of contours can be useful for comparing various context-sensitive algorithms, it does not reect the effective precision of the call graph unless multiple versions of each procedure are compiled, one for each of its analysis-time contours. Some previous systems <ref> [Cooper et al. 92, Plevyak & Chien 95] </ref> have used the contours created during interprocedural analysis to a. Shaded cells correspond to configurations that either did not complete in 24 hours or exhausted available virtual memory (450MB).
Reference: [Plevyak 96] <author> John Plevyak. </author> <title> Optimization of Object-Oriented and Concurrent Programs. </title> <type> PhD thesis, </type> <institution> University of Illinois at Urbana-Champaign, </institution> <year> 1996. </year>
Reference-contexts: At a call site, its contour selection function computes the cartesian product of the actual parameter class sets; a contour is selected/created for each element of the cartesian product. The eager splitting used as a component of each phase of Plevyaks iterative refinement algorithm <ref> [Plevyak 96] </ref> is equivalent to this straightforward form of CPA. In the worst case, CPA may require contours to analyze a call site, where a is the number of arguments at the call site. <p> domains, using the possible class (es) of the object whose instance variable is being accessed to select the right instance variable contour, tracking the contents of instance variables for different inheriting subclasses separately. arbitrary: Plevyaks invokes graph encodes an arbitrary mapping from each contours call sites to its callee contours <ref> [Plevyak 96] </ref>. It is clearly the most exible of the mechanisms, but its lack of structure makes it difficult to easily explain or understand algorithms that rely upon it.
Reference: [Ryder 79] <author> Barbara Ryder. </author> <title> Constructing the Call Graph of a Program. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 5(3):216 225, </volume> <year> 1979. </year>
Reference-contexts: Finally, a number of algorithms based on unbounded but finite values for k have been proposed: Ryders call graph construction algorithm for Fortran 77 <ref> [Ryder 79] </ref>, Callahans extension to Ryders work to support recursion [Callahan et al. 90], and Emamis alias analysis algorithm for C [Emami et al. 94] all treat each non-recursive path through the call graph as creating a new context.
Reference: [Shivers 88] <author> Olin Shivers. </author> <title> Control-Flow Analysis in Scheme. </title> <journal> SIGPLAN Notices, </journal> <volume> 23(7):164174, </volume> <month> July </month> <year> 1988. </year> <booktitle> In Proceedings of the ACM SIGPLAN 88 Conference on Programming Language Design and Implementation. </booktitle>
Reference-contexts: Typical values for these domains fall into several general categories: single-point lattice: Selecting the single-point lattice (the lattice with only a ^ value) for ProcKey, InstVarKey, and ClassKey results in the degenerate case of a context-insensitive analysis. Algorithms such as 0-CFA <ref> [Shivers 88, Shivers 91a] </ref>, Palsberg and Schwartzbachs basic algorithm [Palsberg & Schwartzbach 91], Hall and Kennedys 6 call graph construction algorithm for Fortran [Hall & Kennedy 92], and Lakhotias algorithm for building a call graph in languages with higher-order functions [Lakhotia 93] are all examples of this instantiation of the framework. <p> An algorithm may use a fixed value of k throughout the program, as in Shiverss k-CFA family of algorithms <ref> [Shivers 88, Shivers 91a] </ref> or Oxhjs 1-CFA extension to Palsberg and Schwartzbachs algorithm [Oxhj et al. 92]. Adaptive algorithms may use different levels of k in different regions of the call graph to more exibly manage the trade-off between analysis time and precision. <p> This is the starting point used by the majority of the algorithms, including 0-CFA and k-CFA <ref> [Shivers 88, Shivers 91a] </ref>, the Cartesian Product Algorithm (CPA) [Agesen 95], Plevyaks iterative algorithm [Plevyak & Chien 94], and many others. G T is a good initial call graph for algorithms that apply Monotonic Refinement since it ensures reaching the best possible fixed-point solution for that algorithm.
Reference: [Shivers 91a] <author> Olin Shivers. </author> <title> Control-Flow Analysis of Higher-Order Languages. </title> <type> PhD thesis, </type> <institution> Carnegie Mellon University, </institution> <month> May </month> <year> 1991. </year> <month> CMU-CS-91-145. </month>
Reference-contexts: Typical values for these domains fall into several general categories: single-point lattice: Selecting the single-point lattice (the lattice with only a ^ value) for ProcKey, InstVarKey, and ClassKey results in the degenerate case of a context-insensitive analysis. Algorithms such as 0-CFA <ref> [Shivers 88, Shivers 91a] </ref>, Palsberg and Schwartzbachs basic algorithm [Palsberg & Schwartzbach 91], Hall and Kennedys 6 call graph construction algorithm for Fortran [Hall & Kennedy 92], and Lakhotias algorithm for building a call graph in languages with higher-order functions [Lakhotia 93] are all examples of this instantiation of the framework. <p> An algorithm may use a fixed value of k throughout the program, as in Shiverss k-CFA family of algorithms <ref> [Shivers 88, Shivers 91a] </ref> or Oxhjs 1-CFA extension to Palsberg and Schwartzbachs algorithm [Oxhj et al. 92]. Adaptive algorithms may use different levels of k in different regions of the call graph to more exibly manage the trade-off between analysis time and precision. <p> This is the starting point used by the majority of the algorithms, including 0-CFA and k-CFA <ref> [Shivers 88, Shivers 91a] </ref>, the Cartesian Product Algorithm (CPA) [Agesen 95], Plevyaks iterative algorithm [Plevyak & Chien 94], and many others. G T is a good initial call graph for algorithms that apply Monotonic Refinement since it ensures reaching the best possible fixed-point solution for that algorithm. <p> Global Non-Monotonic Improvement is derived from Shiverss proposal for reow analysis <ref> [Shivers 91a] </ref>. Unlike local non-monotonic improvement it may examine large regions of the call graph during a single improvement step and may introduce new contours to the call graph.
Reference: [Shivers 91b] <author> Olin Shivers. </author> <title> Data Flow Analysis and Type Recovery in Scheme. </title> <booktitle> In Topics in Advanced Language Implementation. </booktitle> <publisher> MIT Press, </publisher> <year> 1991. </year> <title> Edited by Peter Lee. </title>
Reference-contexts: Figure 1 (b) shows the context-insensitive call graph corresponding to the example program in figure 1 (a). In a context-sensitive analysis, a procedure may be analyzed separately for different calling contexts; each of these context-sensitive versions of a procedure is called a contour <ref> [Shivers 91b] </ref>. We model context-sensitive analyses in our call graph by having nodes in the call graph correspond to contours; thus, a call edge from a call site in one contour connects to the appropriate contour (s) of the callee procedure (s).
Reference: [Steensgaard 94] <author> Bjarne Steensgaard. </author> <title> A Polyvariant Closure Analysis with Dynamic Abstraction. </title> <type> Unpublished manuscript, </type> <year> 1994. </year>
Reference-contexts: Steensgaard developed an unbounded-call-chain algorithm that handles nested lexical environments by applying a widening operation to class sets of formal parameters at entries to recursive cycles in the call graph <ref> [Steensgaard 94] </ref>.
Reference: [Steensgaard 96] <author> Bjarne Steensgaard. </author> <title> Points-to Analysis in Almost Linear Time. </title> <booktitle> In Conference Record of POPL 96: 23rd ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages, </booktitle> <pages> pages 3241, </pages> <address> St. Petersburg, Florida, </address> <month> Janu-ary </month> <year> 1996. </year>
Reference-contexts: Our algorithm for constructing G unif is an adaptation of Steensgaards algorithm for near-linear time points-to analysis of C programs <ref> [Steensgaard 96] </ref>.
Reference: [Stefanescu & Zhou 94] <author> Dan Stefanescu and Yuli Zhou. </author> <title> An Equational Framework for the Flow Analysis of Higher-Order Functional Programs. </title> <booktitle> In Proceedings of the ACM Symposium on Lisp and Functional Programming, </booktitle> <pages> pages 190198, </pages> <month> June </month> <year> 1994. </year>
Reference: [Wilson & Lam 95] <author> Robert P. Wilson and Monica S. Lam. </author> <title> Efficient Context-Sensitive Pointer Analysis for C Programs. </title> <journal> SIG-PLAN Notices, </journal> <pages> pages 112, </pages> <month> June </month> <year> 1995. </year> <booktitle> In Proceedings of the ACM SIGPLAN 95 Conference on Programming Language Design and Implementation. </booktitle> <pages> 17 </pages>
Reference-contexts: For example, some abstraction of the alias relationships among actual parameters has been used as the basis for context-sensitivity in algorithms for interprocedural alias analysis <ref> [Landi et al. 93, Wilson & Lam 95] </ref>.
References-found: 46

