URL: http://www.cs.cornell.edu/Info/People/mhr/papers/average.ps
Refering-URL: http://www.cs.cornell.edu/Info/People/mhr/project.html
Root-URL: 
Title: Average Case Analysis of Dynamic Graph Algorithms  
Author: David Alberts Monika Rauch Henzinger 
Keyword: P l p  
Abstract: We present a model for edge updates with restricted randomness in dynamic graph algorithms and a general technique for analyzing the expected running time of an update operation. This model is able to capture the average case in many applications, since (1) it allows restrictions on the set of edges which can be used for insertions and (2) the type (insertion or deletion) of each update operation is arbitrary, i.e., not random. We use our technique to analyze existing and new dynamic algorithms for the following problems: maximum cardinality matching, minimum spanning forest, connectivity, 2-edge connectivity, k-edge connectivity, k-vertex connectivity, and bipartiteness. Given a random graph G with m 0 edges and n vertices and a sequence of l update operations such that the graph contains m i edges after operation i, the expected time for performing the updates for any l is O(l log n + n m i ) in the case of minimum spanning forests, connectivity, 2-edge connectivity, and bipartiteness. The expected time per update operation is O(n) in the case of maximum matching. We also give improved bounds for k-edge and k-vertex connectivity. Additionally we give an insertions-only algorithm for maximum cardinality matching with worst-case O(n) amortized time per insertion.
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> D. Alberts and M. Rauch Henzinger. </author> <title> Average case analysis of dynamic graph algorithms. </title> <booktitle> In Proc. 6th Symp. on Discrete Algorithms, </booktitle> <pages> pages 312 - 321, </pages> <year> 1995. </year>
Reference-contexts: In Section 4, 5, 6, 7, 8, 9 we apply this technique to analyze the expected running time of dynamic algorithms for maximum matching, minimum spanning forest, connectivity, bipartiteness, 2-edge connectivity, and k-edge and k-vertex connectivity, respectively. A preliminary version of this paper appeared in <ref> [1] </ref>. 2 A Model for Random Update Sequences To model the average case it is common practice to consider the expected performance with respect to a "random" input. So we have to define a probability distribution on possible updates.
Reference: [2] <author> H. Alt, K. Mehlhorn, H. Wagener, and E. Welzl. </author> <title> Congruence, similarity and symmetries of geometric objects. </title> <journal> Discrete Comp. Geom., </journal> <volume> 3:237 - 256, </volume> <year> 1988. </year>
Reference-contexts: Note that a dynamic algorithm which executes one phase of the static algorithm by Tarjan [30] for each update operation achieves an update time O (m). This was used for example in <ref> [2] </ref>.
Reference: [3] <author> B. Bollobas. </author> <title> Random Graphs. </title> <publisher> Academic Press, </publisher> <address> London, </address> <year> 1985. </year>
Reference-contexts: This graph is with equal probability any of the possible m-edge subgraphs of G = (V; E). If E is equal to V , then G is a random graph in the well-known G n;m model <ref> [3] </ref>. Note that there are two ways to control the graphs in the rr-model to suit the needs of a particular application. First, we can prescribe E. In consequence we can impose some structure, e.g., bipartiteness on the graphs which occur.
Reference: [4] <author> J. Cheriyan, M. Y. Kao, and R. Thurimella. </author> <title> Algorithms for parallel k-vertex connectivity and sparse certificates. </title> <journal> SIAM J. Comput., </journal> <volume> 22:157 - 174, </volume> <year> 1993. </year>
Reference-contexts: Average Case Analysis of Dynamic Graph Algorithms 23 We discuss next how to test dynamically if the graph is k-vertex connected. Lemma 9.1 also holds for k-vertex connectivity provided that T i is chosen to be a scan-first search forest of G n U i1 <ref> [4, 23] </ref>. To quickly test for the good case we define a suitable subgraph S as follows: we number all vertices during a preprocessing phase with a unique label between 1 and n in an arbitrary, but fixed way.
Reference: [5] <author> L. P. Chew. </author> <title> Building voronoi diagrams for convex polygons in linear expected time. </title> <type> CS Tech Report TR90-147, </type> <institution> Dartmouth College, </institution> <year> 1986. </year>
Reference-contexts: There we have a worst case input graph and the algorithm works by maintaining a current solution while inserting the edges one by one in random order. In fact, backwards analysis first was used in computational geometry for exactly this purpose by Chew <ref> [5] </ref>.
Reference: [6] <author> K. L. Clarkson, K. Mehlhorn, and R. Seidel. </author> <title> Four results on randomized incremental constructions. </title> <journal> Comp. Geom.: Theory and Appl., </journal> <volume> 3:185 - 212, </volume> <year> 1993. </year>
Reference-contexts: The rr-model is a variation of a model for random update sequences used before in computational geometry (see, e.g., <ref> [6, 8, 22, 27] </ref>). Eppstein [8] considers the dynamic (geometric) maximum spanning tree problem and related problems for points in the plane. Exploiting their geometry, he gives data structures with polylogarithmic expected update times for these problems. <p> In contrast, we do not make any assumptions on the distribution of types of update operations. Thus, our analysis also applies if an adversary provides the (worst case) types of update operations. We adopt a generic model for random update sequences from computational geometry (see, e.g., <ref> [6, 8, 22, 27] </ref>). The dynamically changing object is a set E which is a random subset of a fixed set E, the universe.
Reference: [7] <author> J. Edmonds. </author> <title> Paths, trees, and flowers. </title> <journal> Canad. J. Math., </journal> <volume> 17:449 - 467, </volume> <year> 1965. </year>
Reference-contexts: If v is reachable, but only using odd alternating paths, then it is an odd vertex. Free vertices are also even. The sets of even and odd vertices are unique, i.e., they are independent of the particular choice of a maximum matching. Edmonds also proved this in <ref> [7] </ref>. A non-reachable vertex is called out-of-forest vertex. 4.2 The algorithm The data structure we maintain consists of a sparse blossom forest, parity informations (even, odd, or out-of-forest) for the vertices, and a list consisting of the edges in a current maximum matching. <p> Thus, it is trivial to answer a query. Additionally, we store at each node in the blossom forest a pointer to the tree that it belongs to. A blossom forest is a well-known data structure used in static maximum cardinality matching algorithms, see, e.g., <ref> [7, 20, 30] </ref>.
Reference: [8] <author> D. Eppstein. </author> <title> Average case analysis of dynamic geometric optimization. </title> <booktitle> In Proc. 5th Symp. on Discrete Algorithms, </booktitle> <pages> pages 77 - 86, </pages> <year> 1994. </year>
Reference-contexts: The rr-model is a variation of a model for random update sequences used before in computational geometry (see, e.g., <ref> [6, 8, 22, 27] </ref>). Eppstein [8] considers the dynamic (geometric) maximum spanning tree problem and related problems for points in the plane. Exploiting their geometry, he gives data structures with polylogarithmic expected update times for these problems. <p> The rr-model is a variation of a model for random update sequences used before in computational geometry (see, e.g., [6, 8, 22, 27]). Eppstein <ref> [8] </ref> considers the dynamic (geometric) maximum spanning tree problem and related problems for points in the plane. Exploiting their geometry, he gives data structures with polylogarithmic expected update times for these problems. <p> In contrast, we do not make any assumptions on the distribution of types of update operations. Thus, our analysis also applies if an adversary provides the (worst case) types of update operations. We adopt a generic model for random update sequences from computational geometry (see, e.g., <ref> [6, 8, 22, 27] </ref>). The dynamically changing object is a set E which is a random subset of a fixed set E, the universe.
Reference: [9] <author> D. Eppstein. </author> <type> Personal communication, </type> <year> 1995. </year>
Reference-contexts: It is an interesting open question whether the data structure can be improved by distributing the costs of rebuilds over previous updates in a way that gives an expected time bound of O (n= p m + log n) per update. Eppstein <ref> [9] </ref> suggested that a good average case behavior for some of the above problems can also be shown for node insertions and deletions. Acknowledgments The authors would like to thank Emo Welzl for helpful discussions. 24 David Alberts, Monika Rauch Henzinger
Reference: [10] <author> D. Eppstein, Z. Galil, and G. F. </author> <title> Italiano. Improved sparsification. </title> <type> Technical Report 93-20, </type> <institution> Dept. of Inf. and Comp. Sc., Univ. of Calif., </institution> <address> Irvine, CA 92717, </address> <year> 1993. </year>
Reference-contexts: In the case of maximum matching a query outputs a current maximum matching. Alternatively, a query could also be: "Is the edge e in the current graph in the current maximum matching?" Recently, a lot of work has been done on dynamic algorithms for various connectivity properties <ref> [10, 11, 12, 13, 16, 24, 25, 26] </ref>. The current best deterministic bound for maintaining connected or 2-edge connected components of a graph is O ( p n) [10]. The best randomized algorithm achieves O (log 3 n), resp. O (log 4 n) per update [17]. <p> The current best deterministic bound for maintaining connected or 2-edge connected components of a graph is O ( p n) <ref> [10] </ref>. The best randomized algorithm achieves O (log 3 n), resp. O (log 4 n) per update [17]. It is an open problem if the connected or 2-edge connected components of a graph can be maintained deterministically faster than O ( p n). <p> They can be updated within the same bounds for space and time. In the worst case the best deterministic bound is O ( p n) <ref> [10] </ref> and the best randomized algorithms take polylogarithmic time per update [17]. <p> The worst case update time of the topology tree data structure is O ( p m). By using improved sparsification <ref> [10] </ref> this can be reduced to O ( p n). <p> We cannot use the sparsification technique of <ref> [10, 11] </ref> since in their data structure a constant fraction of the edges causes expensive updates. 5.1 Basic Definitions We first review the data structure by Frederickson and make some changes needed to speed up the good case. We always keep the graph connected by dummy edges of weight 1. <p> of size m 0 for any m 0 , where m i is the number of edges in G after operation i. 14 David Alberts, Monika Rauch Henzinger 7 Bipartiteness In this section we analyze the average case performance of an algorithm for dynamic bipartiteness due to Eppstein et al. <ref> [10, 11] </ref>. As before we give each edge cost 1 and connect different connected components by dummy edges of cost 2. The algorithm uses again the topology tree data structure (see Section 5).
Reference: [11] <author> D. Eppstein, Z. Galil, G. F. Italiano, and A. Nissenzweig. </author> <title> Sparsification a technique for speeding up dynamic graph algorithms. </title> <booktitle> In Proc. 33rd Symp. on Foundations of Computer Science, </booktitle> <pages> pages 60 - 69, </pages> <year> 1992. </year>
Reference-contexts: In the case of maximum matching a query outputs a current maximum matching. Alternatively, a query could also be: "Is the edge e in the current graph in the current maximum matching?" Recently, a lot of work has been done on dynamic algorithms for various connectivity properties <ref> [10, 11, 12, 13, 16, 24, 25, 26] </ref>. The current best deterministic bound for maintaining connected or 2-edge connected components of a graph is O ( p n) [10]. The best randomized algorithm achieves O (log 3 n), resp. O (log 4 n) per update [17]. <p> In the worst case the best deterministic bound is O ( p n) [10] and the best randomized algorithms take polylogarithmic time per update [17]. In the case of k-edge and k-vertex connectivity we slightly improve the known bounds: * Eppstein et al. <ref> [11] </ref> describe an algorithm for dynamic k-edge connectivity with worst case update time O (k 2 n log (n=k)) using a minimum edge cut algorithm by Gabow [14]. <p> We cannot use the sparsification technique of <ref> [10, 11] </ref> since in their data structure a constant fraction of the edges causes expensive updates. 5.1 Basic Definitions We first review the data structure by Frederickson and make some changes needed to speed up the good case. We always keep the graph connected by dummy edges of weight 1. <p> of size m 0 for any m 0 , where m i is the number of edges in G after operation i. 14 David Alberts, Monika Rauch Henzinger 7 Bipartiteness In this section we analyze the average case performance of an algorithm for dynamic bipartiteness due to Eppstein et al. <ref> [10, 11] </ref>. As before we give each edge cost 1 and connect different connected components by dummy edges of cost 2. The algorithm uses again the topology tree data structure (see Section 5). <p> A boundary vertex of a cluster is an endpoint of a tree edge connecting the cluster with a different cluster at the same level of the topology tree. The following lemma is shown in <ref> [11] </ref>. Lemma 7.1 Let V j and V r be any two clusters at the same level of the topology tree, and let f 1 and f 2 be any two non-tree edges between V j and V r . <p> This leads to a data structure which is a slight modification of the data structure given in <ref> [11] </ref> consisting of 1. a MST T , 2. a dynamic tree data structure [29] of T (for determining distances between nodes in T ) giving dashed edges length 0 and non-dashed edges length 1, 3. a topology tree T T for T where we store at each node V j <p> Note that at each node of T T and 2T T we store only a constant amount of distance information because every cluster has tree degree at most three. In contrast to <ref> [11] </ref> we do not need to maintain selected edges of minimum weight. However, we could do this by replacing the lists in 4.(a) by priority queues. <p> Thus, G is not bipartite. If exactly one selected edge is stored at V fi V , we determine after each update the length of the cycle induced by this selected edge. This takes logarithmic time using the dynamic tree data structure of T . As shown in <ref> [11] </ref> the worst-case update time for this data structure is O ( p m). We show next that the insertion or deletion of a non-tree edge e = (u; v) that does not modify the dynamic restricted partition takes time O (log n). <p> The operation itself consists of a constant number of dynamic path operations which take time O (log jP j) giving a total of time O (d + log jP j). This shows the claimed bounds on the running times. 9 k-Edge Connectivity and k-Vertex Connectivity Eppstein et al. <ref> [11] </ref> give a dynamic algorithm for k-edge connectivity with worst case update time O (k 2 n log (n=k)), which we slightly modify in order to speed up the good case. It uses an algorithm by Gabow [14] for the static problem and the following lemma.
Reference: [12] <author> G. N. Frederickson. </author> <title> Data structures for on-line updating of minimum spanning trees, with applications. </title> <journal> SIAM J. Comput., </journal> <volume> 14:781 - 798, </volume> <year> 1985. </year>
Reference-contexts: In the case of maximum matching a query outputs a current maximum matching. Alternatively, a query could also be: "Is the edge e in the current graph in the current maximum matching?" Recently, a lot of work has been done on dynamic algorithms for various connectivity properties <ref> [10, 11, 12, 13, 16, 24, 25, 26] </ref>. The current best deterministic bound for maintaining connected or 2-edge connected components of a graph is O ( p n) [10]. The best randomized algorithm achieves O (log 3 n), resp. O (log 4 n) per update [17]. <p> Additionally we give an insertions only algorithm for maximum cardinality matching with O (n) amortized time per insertion. * Assuming that the weight of an edge is arbitrary, but fixed, we show that a modified version of Frederickson's topology tree data structure <ref> [12] </ref> for dynamic minimum spanning forests has an average case update time of O (log n + n= p m) plus amortized constant time. The data structure needs linear space and linear expected preprocessing time. <p> By doing so, each edge is charged only for a constant amount of work per phase. Since there are at most n=2 phases, an insertion can be done in O (n) amortized time. 5 Minimum Spanning Forests Frederickson <ref> [12] </ref> introduced the topology tree data structure to maintain a minimum spanning forest dynamically. In this section we modify the topology tree data structure to give a dynamic minimum spanning forest algorithm with good average and the same worst-case performance as the algorithm in [12]. <p> time. 5 Minimum Spanning Forests Frederickson <ref> [12] </ref> introduced the topology tree data structure to maintain a minimum spanning forest dynamically. In this section we modify the topology tree data structure to give a dynamic minimum spanning forest algorithm with good average and the same worst-case performance as the algorithm in [12]. The new variant of topology trees is the key data structure for a number of other dynamic graph algorithms, like different kinds of connectivity and bipartiteness, presented in the following sections. The worst case update time of the topology tree data structure is O ( p m). <p> The vertex y is handled symmetrically. 2. If the cardinality of a cluster is larger than 2 p m (thus violating Condition (2)), the cluster is split using the splitting procedure of <ref> [12] </ref> which splits a cluster into two clusters of size at most 4=3 p m and at least 2=3 p 3. <p> In the case of an insertion we use an additional dynamic tree data structure [29] (described below) to decide in time O (log n) which case occurs. The algorithm in <ref> [12] </ref> updates T T and 2T T in time O ( p m) after an arbitrary edge insertion or deletion. Building and maintaining the priority queues at the leaves of 2T T increases this time only by a constant factor. <p> Afterwards we compute bottom-up the new min value of every ancestor of C fi D. Using the min value of its children this takes constant time per ancestor. Since 2T T has depth O (log n) <ref> [12] </ref>, updating all ancestors takes time O (log n) as well. Thus, updating 2T T takes time O (log n) if we know that (u; v) is not a tree edge. <p> To maintain connectivity dynamically Frederickson <ref> [12] </ref> assigns cost 1 to edges in the current graphs and connects different connected component by cost 2 (dummy) edges. Then he augments the topology tree data structure in order to answer connectivity queries in constant time.
Reference: [13] <author> G. N. Frederickson. </author> <title> Ambivalent data structures for dynamic 2-edge-connectivity and k smallest spanning trees. </title> <booktitle> In Proc. 32nd Symp. on Foundations of Computer Science, </booktitle> <pages> pages 632 - 641, </pages> <year> 1991. </year>
Reference-contexts: In the case of maximum matching a query outputs a current maximum matching. Alternatively, a query could also be: "Is the edge e in the current graph in the current maximum matching?" Recently, a lot of work has been done on dynamic algorithms for various connectivity properties <ref> [10, 11, 12, 13, 16, 24, 25, 26] </ref>. The current best deterministic bound for maintaining connected or 2-edge connected components of a graph is O ( p n) [10]. The best randomized algorithm achieves O (log 3 n), resp. O (log 4 n) per update [17]. <p> To achieve fast updates for non-tree edges we modify the definitions of clusters given in <ref> [13] </ref>. A basic cluster is a set of vertices that induces a subgraph of T that is connected. An edge is incident to a cluster if exactly one of its endpoints is in the cluster and it is internal to a cluster if both endpoints are in the cluster. <p> with a random subgraph of G of size m 0 for any m 0 , where m i is the number of edges in G after operation i. 8 2-Edge Connectivity Frederickson gives a data structure, called ambivalent data structure, that answers 2-edge connectivity queries in time O (log n) <ref> [13] </ref>. It can be updated in time O ( p m). This data structure is also based on the topology tree data structure. We can modify the ambivalent data structure and the update algorithm in order to speed up the good case. <p> The basic idea for testing 2-edge connectivity is the concept of covering. A tree edge e is covered if there exists a non-tree edge (x; y) such that e lies on the tree path between x and y. As shown in <ref> [13] </ref>, two nodes u and v are 2-edge connected iff all edges in the tree path between u and v are covered. Thus, to answer 2-edge connectivity queries the ambivalent data structure maintains for every tree edge a bit indicating if it is covered. <p> To do this efficiently we partition T into chains, called complete paths, as in <ref> [13] </ref>. <p> For two level-i clusters C and D with i &gt; 0 and every tree edge e incident to C the value maxcover (C; D; e) can be computed in constant time from the maxcover values of the children of C fi D in 2T T <ref> [13] </ref>. For each level-i cluster C we keep at its node C fi C of 2T T the following data structure: 1. If C is a basic cluster, we keep a dynamic tree data structure of the spanning tree of C. <p> To speed up the good case we added the heaps max (C; D; e), the dynamic tree data structures, the heaps that maintain the max (C) to the data structure of <ref> [13] </ref>, and we replaced the data structure for partial and complete paths. The algorithm of [13] uses the maxcover values and the maximum elements stored in the max heaps to maintain the invariant (I) as follows. <p> To speed up the good case we added the heaps max (C; D; e), the dynamic tree data structures, the heaps that maintain the max (C) to the data structure of <ref> [13] </ref>, and we replaced the data structure for partial and complete paths. The algorithm of [13] uses the maxcover values and the maximum elements stored in the max heaps to maintain the invariant (I) as follows. Let C 1 and C 2 be children of a cluster C and let e be the tree edge connecting them. <p> If the tree degree of C 2 is 3, the maximum element of max (C) is used to cover the complete path of C. Average Case Analysis of Dynamic Graph Algorithms 19 We employ the query algorithm <ref> [13] </ref> which uses the length and toptobr values of the partial and complete paths and some information at basic clusters. (The remaining data structures are actually only needed to maintain these values efficiently.) 8.3 Updates The ambivalent data structure can be updated in time O ( p m) after every edge <p> length and toptobr values of the partial and complete paths and some information at basic clusters. (The remaining data structures are actually only needed to maintain these values efficiently.) 8.3 Updates The ambivalent data structure can be updated in time O ( p m) after every edge insertion or deletion <ref> [13] </ref>. Our modifications increase the worst case running time only by a constant factor. As shown in Section 5 rebuilding the dynamic partition creates only O (1) amortized cost per non-tree update, so we do not consider rebuilds in the following.
Reference: [14] <author> H. N. Gabow. </author> <title> A matroid approach to finding edge connectivity and packing arborescences. </title> <booktitle> In Proc. 23rd Symp. on Theory of Computing, </booktitle> <pages> pages 112 - 122, </pages> <year> 1991. </year>
Reference-contexts: In the case of k-edge and k-vertex connectivity we slightly improve the known bounds: * Eppstein et al. [11] describe an algorithm for dynamic k-edge connectivity with worst case update time O (k 2 n log (n=k)) using a minimum edge cut algorithm by Gabow <ref> [14] </ref>. We show that (with a slight modification) its average case update time is O (min (1; kn=m)k 2 n log (n=k)) plus O (k) amortized time. This gives time O (min (1; n=m)n log n) plus amortized constant time for constant k. <p> It uses an algorithm by Gabow <ref> [14] </ref> for the static problem and the following lemma. Lemma 9.1 [23, 31] Let G be a graph and T 1 = U 1 a spanning forest of G.
Reference: [15] <author> Z. Galil. </author> <title> Finding the vertex connectivity of graphs. </title> <journal> SIAM J. Comput., </journal> <volume> 9:197 - 199, </volume> <year> 1980. </year>
Reference-contexts: structure needs O (m + kn) space and preprocessing time. * We create a dynamic k-vertex connectivity algorithm, using the algorithm by Nagamochi and Ibaraki for finding sparse k-vertex certificates [23] and the O (k 3 n 1:5 + k 2 n 2 ) minimum vertex cut algorithm by Galil <ref> [15] </ref>. A query takes constant time. The average update time is O (min (1; kn=m)(k 3 n 1:5 +k 2 n 2 )), which is O (min (n 2 ; n 3 =m)) for constant k. The preprocessing time and the space requirement is linear. <p> In the good case we are done. In the bad case we additionally might have to check whether the new suitable subgraph S 0 is k-vertex connected. For this purpose we use the (static) O (k 3 n 1:5 +k 2 n 2 ) time k-vertex algorithm by Galil <ref> [15] </ref>. This provides the following result.
Reference: [16] <author> M. Rauch Henzinger. </author> <title> Fully dynamic cycle equivalence in graphs. </title> <booktitle> In Proc. 35th Symp. on Foundations of Computer Science, </booktitle> <pages> pages 744 - 755, </pages> <year> 1994. </year>
Reference-contexts: In the case of maximum matching a query outputs a current maximum matching. Alternatively, a query could also be: "Is the edge e in the current graph in the current maximum matching?" Recently, a lot of work has been done on dynamic algorithms for various connectivity properties <ref> [10, 11, 12, 13, 16, 24, 25, 26] </ref>. The current best deterministic bound for maintaining connected or 2-edge connected components of a graph is O ( p n) [10]. The best randomized algorithm achieves O (log 3 n), resp. O (log 4 n) per update [17].
Reference: [17] <author> M. Rauch Henzinger and V. King. </author> <title> Randomized dynamic algorithms with polylogarithmic time per operation. </title> <booktitle> To appear in Proc. 27th Symp. on Theory of Computing, </booktitle> <year> 1995. </year>
Reference-contexts: The current best deterministic bound for maintaining connected or 2-edge connected components of a graph is O ( p n) [10]. The best randomized algorithm achieves O (log 3 n), resp. O (log 4 n) per update <ref> [17] </ref>. It is an open problem if the connected or 2-edge connected components of a graph can be maintained deterministically faster than O ( p n). A second interesting question is if a maximum matching can be maintained in time o (m) per update. <p> They can be updated within the same bounds for space and time. In the worst case the best deterministic bound is O ( p n) [10] and the best randomized algorithms take polylogarithmic time per update <ref> [17] </ref>. In the case of k-edge and k-vertex connectivity we slightly improve the known bounds: * Eppstein et al. [11] describe an algorithm for dynamic k-edge connectivity with worst case update time O (k 2 n log (n=k)) using a minimum edge cut algorithm by Gabow [14].
Reference: [18] <author> R. M. Karp. </author> <title> personal communications. Average Case Analysis of Dynamic Graph Algorithms 25 </title>
Reference-contexts: The rr-model is especially suited to capture the average case in many applications, since (1) it allows restrictions on the set of edges which can be used for insertions and (2) the type (insertion or deletion) of each update operation is arbitrary, i.e., not random. Related Work Karp <ref> [18] </ref> gave a deletions-only connectivity algorithm. If the initial graph is random and random edges are deleted, the total expected time for a sequence of deletions is O (n 2 log n).
Reference: [19] <author> P. N. Klein and R. E. Tarjan. </author> <title> A linear-time algorithm for minimum spanning tree. </title> <booktitle> In Proc. 26th Symp. on Theory of Computing, </booktitle> <pages> pages 9 - 15, </pages> <year> 1994. </year>
Reference-contexts: Testing this and updating the dynamic tree takes time O (log n) per operation. The space requirement for the data structure is linear. Using the linear expected time algorithm for minimum spanning trees <ref> [19] </ref> during preprocessing gives the following lemma. Lemma 5.5 There exists a data structure that maintains a minimum spanning forest of a graph with any real-valued cost-function on the edges.
Reference: [20] <author> L. Lovasz and M. D. Plummer. </author> <title> Matching Theory, </title> <booktitle> volume 29 of Annals of Discrete Mathematics. </booktitle> <publisher> North-Holland, </publisher> <address> Amsterdam, </address> <year> 1986. </year>
Reference-contexts: One vertex is a trivial blossom. The easiest nontrivial case is just an odd cycle where all vertices but one are matched. Note that the definition of a blossom is not unique in the literature, we define it similar to <ref> [20] </ref>. A blossom which is not properly contained in another one is a maximal blossom. <p> Thus, it is trivial to answer a query. Additionally, we store at each node in the blossom forest a pointer to the tree that it belongs to. A blossom forest is a well-known data structure used in static maximum cardinality matching algorithms, see, e.g., <ref> [7, 20, 30] </ref>. <p> It returns a current maximum matching or answers the question whether a particular edge is in the current maximum matching in optimal time. Even, odd, and out-of-forest vertices correspond to the Gallai-Edmonds-Decomposition of a graph. For a definition and properties of this decomposition see <ref> [20] </ref>. Since our algorithm maintains the partition of the vertices into even, odd, and out-of-forest vertices, it also maintains the Gallai-Edmonds-Decomposition of the graph.
Reference: [21] <author> S. Micali and V. Vazirani. </author> <title> An O(V 1=2 E) algorithm for finding maximum matching in general graphs. </title> <booktitle> In Proc. 21st Symp. on Foundations of Computer Science, </booktitle> <pages> pages 17 - 27, </pages> <year> 1980. </year>
Reference-contexts: These bad cases take O (n + m) time. All good cases can be handled in constant time, since we just update the adjacency structure of the graph. For preprocessing we use the static O ( p nm) algorithm of Micali and Vazirani <ref> [21, 32] </ref> to construct a maximum matching in the initial random graph and one phase of Tarjan's algorithm to construct a sparse blossom forest with respect to the initial maximum matching. Using Theorem 3.1 we get the following result.
Reference: [22] <author> K. Mulmuley. </author> <title> Randomized, multidimensional search trees: dynamic sampling. </title> <booktitle> In Proc. 7th Symp. on Computational Geometry, </booktitle> <pages> pages 121 - 131, </pages> <year> 1991. </year>
Reference-contexts: The rr-model is a variation of a model for random update sequences used before in computational geometry (see, e.g., <ref> [6, 8, 22, 27] </ref>). Eppstein [8] considers the dynamic (geometric) maximum spanning tree problem and related problems for points in the plane. Exploiting their geometry, he gives data structures with polylogarithmic expected update times for these problems. <p> In contrast, we do not make any assumptions on the distribution of types of update operations. Thus, our analysis also applies if an adversary provides the (worst case) types of update operations. We adopt a generic model for random update sequences from computational geometry (see, e.g., <ref> [6, 8, 22, 27] </ref>). The dynamically changing object is a set E which is a random subset of a fixed set E, the universe.
Reference: [23] <author> H. Nagamochi and T. Ibaraki. </author> <title> Linear time algorithms for finding a sparse k-connected spanning subgraph of a k-connected graph. </title> <journal> Algorithmica, </journal> <volume> 7:583 - 596, </volume> <year> 1992. </year>
Reference-contexts: The data structure needs O (m + kn) space and preprocessing time. * We create a dynamic k-vertex connectivity algorithm, using the algorithm by Nagamochi and Ibaraki for finding sparse k-vertex certificates <ref> [23] </ref> and the O (k 3 n 1:5 + k 2 n 2 ) minimum vertex cut algorithm by Galil [15]. A query takes constant time. <p> It uses an algorithm by Gabow [14] for the static problem and the following lemma. Lemma 9.1 <ref> [23, 31] </ref> Let G be a graph and T 1 = U 1 a spanning forest of G. Let T i be a spanning forest of G n U i1 and let U i be U i1 [ T i . <p> Average Case Analysis of Dynamic Graph Algorithms 23 We discuss next how to test dynamically if the graph is k-vertex connected. Lemma 9.1 also holds for k-vertex connectivity provided that T i is chosen to be a scan-first search forest of G n U i1 <ref> [4, 23] </ref>. To quickly test for the good case we define a suitable subgraph S as follows: we number all vertices during a preprocessing phase with a unique label between 1 and n in an arbitrary, but fixed way. <p> To quickly test for the good case we define a suitable subgraph S as follows: we number all vertices during a preprocessing phase with a unique label between 1 and n in an arbitrary, but fixed way. Then, we use the linear-time algorithm of <ref> [23] </ref> to find U k . This algorithm sometimes makes arbitrary choices which vertex to select next. We make S unique by requiring that if more than one vertices can be selected, the algorithm has to use the one with the minimum label.
Reference: [24] <author> M. H. Rauch. </author> <title> Fully dynamic biconnectivity in graphs. </title> <booktitle> In Proc. 33rd Symp. on Foundations of Computer Science, </booktitle> <pages> pages 50 - 59, </pages> <year> 1992. </year>
Reference-contexts: In the case of maximum matching a query outputs a current maximum matching. Alternatively, a query could also be: "Is the edge e in the current graph in the current maximum matching?" Recently, a lot of work has been done on dynamic algorithms for various connectivity properties <ref> [10, 11, 12, 13, 16, 24, 25, 26] </ref>. The current best deterministic bound for maintaining connected or 2-edge connected components of a graph is O ( p n) [10]. The best randomized algorithm achieves O (log 3 n), resp. O (log 4 n) per update [17].
Reference: [25] <author> M. H. Rauch. </author> <title> Improved data structures for fully dynamic biconnectivity. </title> <booktitle> In Proc. 26th Symp. on Theory of Computing, </booktitle> <pages> pages 686 - 695, </pages> <year> 1994. </year>
Reference-contexts: In the case of maximum matching a query outputs a current maximum matching. Alternatively, a query could also be: "Is the edge e in the current graph in the current maximum matching?" Recently, a lot of work has been done on dynamic algorithms for various connectivity properties <ref> [10, 11, 12, 13, 16, 24, 25, 26] </ref>. The current best deterministic bound for maintaining connected or 2-edge connected components of a graph is O ( p n) [10]. The best randomized algorithm achieves O (log 3 n), resp. O (log 4 n) per update [17].
Reference: [26] <author> J. H. Reif, P. G. Spirakis, and M. Yung. </author> <title> Re-randomization and average case analysis of fully dynamic graph algorithms. </title> <type> Alcom Technical Report TR 93.01.3. </type>
Reference-contexts: In the case of maximum matching a query outputs a current maximum matching. Alternatively, a query could also be: "Is the edge e in the current graph in the current maximum matching?" Recently, a lot of work has been done on dynamic algorithms for various connectivity properties <ref> [10, 11, 12, 13, 16, 24, 25, 26] </ref>. The current best deterministic bound for maintaining connected or 2-edge connected components of a graph is O ( p n) [10]. The best randomized algorithm achieves O (log 3 n), resp. O (log 4 n) per update [17]. <p> Related Work Karp [18] gave a deletions-only connectivity algorithm. If the initial graph is random and random edges are deleted, the total expected time for a sequence of deletions is O (n 2 log n). In <ref> [26] </ref> a different random input model for dynamic graph algorithms is presented, called fair stochastic graph process (fsgp). It assumes that the type of the next operation as well as its parameter are chosen uniformly at random. <p> Since the rr-model does not make any assumptions about the distribution of the types of update operations, it is more general than a fsgp, which assumes that insertions (deletions) occur with probability 1=2. The algorithm, presented in <ref> [26] </ref> takes expected time O (lk log 3 n) maintaining the k-vertex connected components (k constant) for a sequence of l n 2 log n update operations. <p> For the average case analysis at least the edge to be inserted or deleted should be given with some probability distribution. Now two cases are possible: either the type of the update operation is random or not. Reif, Spirakis, and Yung <ref> [26] </ref> studied a model in which the probability of an insertion (deletion) is 1=2. In contrast, we do not make any assumptions on the distribution of types of update operations. Thus, our analysis also applies if an adversary provides the (worst case) types of update operations.
Reference: [27] <author> O. Schwarzkopf. </author> <title> Dynamic Maintenance of Convex Polytopes and Related Structures. </title> <type> PhD thesis, </type> <institution> Freie Universitat Berlin, </institution> <year> 1992. </year>
Reference-contexts: The rr-model is a variation of a model for random update sequences used before in computational geometry (see, e.g., <ref> [6, 8, 22, 27] </ref>). Eppstein [8] considers the dynamic (geometric) maximum spanning tree problem and related problems for points in the plane. Exploiting their geometry, he gives data structures with polylogarithmic expected update times for these problems. <p> In contrast, we do not make any assumptions on the distribution of types of update operations. Thus, our analysis also applies if an adversary provides the (worst case) types of update operations. We adopt a generic model for random update sequences from computational geometry (see, e.g., <ref> [6, 8, 22, 27] </ref>). The dynamically changing object is a set E which is a random subset of a fixed set E, the universe.
Reference: [28] <author> R. Seidel. </author> <title> Backwards analysis of randomized geometric algorithms. </title> <editor> In J. Pach, editor, </editor> <booktitle> New Trends in Discrete and Computational Geometry, </booktitle> <pages> pages 37 - 67. </pages> <publisher> Springer Verlag, </publisher> <address> Berlin, </address> <year> 1993. </year>
Reference-contexts: In the case of dense graphs these improvements are exponential for some of the problems. After presenting the rr-model in Section 2 we give a general technique for analyzing the expected running time of an update operation using backwards analysis <ref> [28] </ref> in Section 3. As far as we know, this is the first application of backwards analysis to dynamic graph problems. <p> We use a technique called backwards analysis, which already lead to a variety of elegant proofs for randomized incremental geometric algorithms, see <ref> [28] </ref> and its references. If all updates are performed in approximately the same time bound, there is no need for an average case analysis.
Reference: [29] <author> D. D. Sleator and R. E. Tarjan. </author> <title> A data structure for dynamic trees. </title> <journal> J. Comput. Sys. Sci., </journal> <volume> 26:362 - 391, </volume> <year> 1983. </year>
Reference-contexts: In the case of a deletion, this is easy to decide, since we know for each edge in G if it is in T . In the case of an insertion we use an additional dynamic tree data structure <ref> [29] </ref> (described below) to decide in time O (log n) which case occurs. The algorithm in [12] updates T T and 2T T in time O ( p m) after an arbitrary edge insertion or deletion. <p> This leads to a data structure which is a slight modification of the data structure given in [11] consisting of 1. a MST T , 2. a dynamic tree data structure <ref> [29] </ref> of T (for determining distances between nodes in T ) giving dashed edges length 0 and non-dashed edges length 1, 3. a topology tree T T for T where we store at each node V j the distances between every pair of boundary vertices of V j , 4. the <p> Every node of T T except for the root or a leaf with tree-degree 3 has a non-empty partial path. Thus, every cluster that is incident to a non-tree edge has a non-empty partial path. We extend the dynamic path data structure of <ref> [29] </ref> to the following extended dynamic path data structure. It represents a set of paths such that two paths are either vertex-disjoint or one path is contained in the other one. <p> It is based on the dynamic paths data structure which Sleator and Tarjan used for their dynamic trees <ref> [29] </ref>. We consider the following problem. We are given a set of paths such that two paths are either vertex-disjoint or one path is contained in the other one. <p> In their paper on dynamic trees <ref> [29] </ref> Sleator and Tarjan introduce a data structure for the dynamic maintenance of a collection of vertex-disjoint edge weighted paths. Each path p has a head and a tail. The data structure supports 11 kinds of operations. A subset of them is quoted below from [29]. <p> their paper on dynamic trees <ref> [29] </ref> Sleator and Tarjan introduce a data structure for the dynamic maintenance of a collection of vertex-disjoint edge weighted paths. Each path p has a head and a tail. The data structure supports 11 kinds of operations. A subset of them is quoted below from [29]. <p> A Link or U nlink operation takes constant time since, as shown in <ref> [29] </ref>, the local information can be updated in constant time. Any of the other operations is enclosed in a sequence at most 2d U nlink and Link operations.
Reference: [30] <author> R. E. Tarjan. </author> <title> Data Structures and Network Algorithms, </title> <booktitle> volume 44 of CBMS-NSF Regional Conference Series in Applied Mathematics. Society for Industrial and Applied Mathematics, </booktitle> <address> Philadelphia, Pennsylvania, </address> <year> 1983. </year>
Reference-contexts: A second interesting question is if a maximum matching can be maintained in time o (m) per update. Note that a dynamic algorithm which executes one phase of the static algorithm by Tarjan <ref> [30] </ref> for each update operation achieves an update time O (m). This was used for example in [2]. <p> Thus, it is trivial to answer a query. Additionally, we store at each node in the blossom forest a pointer to the tree that it belongs to. A blossom forest is a well-known data structure used in static maximum cardinality matching algorithms, see, e.g., <ref> [7, 20, 30] </ref>. <p> Conceptually, the data structure is a sparse subgraph of the current graph G, which has the same matching number and the same parities as G. Tarjan <ref> [30] </ref> describes a static algorithm for computing a maximum matching in general graphs. It proceeds in phases. <p> Let E 0 = E [ feg. We have to update the blossom forest or the matching only if one of the following three conditions applies. By using the information stored at the nodes we can test in constant time if one of these conditions applies <ref> [30] </ref>. (1) The insertion of e increases the matching number. In this case we find an augmenting path when e is inserted, we augment the matching and have to rebuild the blossom forest. <p> Average Case Analysis of Dynamic Graph Algorithms 9 4.3 Insertions only We sketch below an insertions-only maximum cardinality matching algorithm with O (n) amortized time per insertion of an arbitrary (not random) edge if the initial edge set is empty. A close look at Tarjan's algorithm <ref> [30] </ref> shows that each phase is essentially a semi-dynamic algorithm. It is guided by the edges reachable via even alternating paths in the growing blossom forest. It does not depend on a particular order on these edges.
Reference: [31] <author> R. Thurimella. </author> <title> Techniques for the Design of Parallel Graph Algorithms. </title> <type> PhD thesis, </type> <institution> University of Texas, Austin, </institution> <year> 1989. </year>
Reference-contexts: It uses an algorithm by Gabow [14] for the static problem and the following lemma. Lemma 9.1 <ref> [23, 31] </ref> Let G be a graph and T 1 = U 1 a spanning forest of G. Let T i be a spanning forest of G n U i1 and let U i be U i1 [ T i .
Reference: [32] <author> V. V. Vazirani. </author> <title> A theory of alternating paths and blossoms for proving correctness of the O( V E) general graph maximum matching algorithm. </title> <journal> Combinatorica, </journal> <volume> 14(1):71 - 109, </volume> <year> 1994. </year>
Reference-contexts: These bad cases take O (n + m) time. All good cases can be handled in constant time, since we just update the adjacency structure of the graph. For preprocessing we use the static O ( p nm) algorithm of Micali and Vazirani <ref> [21, 32] </ref> to construct a maximum matching in the initial random graph and one phase of Tarjan's algorithm to construct a sparse blossom forest with respect to the initial maximum matching. Using Theorem 3.1 we get the following result.
References-found: 32

