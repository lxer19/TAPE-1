URL: http://www.cs.washington.edu/homes/alon/site/files/vldb93.ps
Refering-URL: http://www.cs.washington.edu/homes/alon/site/PaperAbstractPresentation_bib15.html
Root-URL: 
Email: levy@cs.stanford.edu  sagiv@cs.huji.ac.il  
Title: Queries Independent of Updates  
Author: Alon Y. Levy Yehoshua Sagiv 
Note: The work of this author was supported by NASA Grant NCC2-537. Part of the work of this author was done while visiting Stanford University, where it was supported by ARO grant DAAL03-91-G-0177, NSF grants IRI-90-16358 and IRI-91-16646, and a grant  Proceedings of the 19th VLDB Conference, Dublin, Ireland, 1993.  
Address: Stanford, California, 94305  Jerusalem, Israel  
Affiliation: Department of Computer Science Stanford University  Department of Computer Science Hebrew University  of Mitsubishi Corp.  
Abstract: This paper considers the problem of detecting independence of a queries expressed by datalog programs from updates. We provide new insight into the independence problem by reducing it to the equivalence problem for dat-alog programs (both for the case of insertion and deletion updates). Equivalence, as well as independence, is undecidable in general. However, algorithms for detecting subclasses of equivalence provide sufficient (and sometimes also necessary) conditions for independence. We consider two such subclasses. The first, query-reachability, generalizes previous work on independence [BCL89, El90], which dealt with nonrecursive programs with a single occurrence of the updated predicate. Using recent results on query-reachability [LS92, LMSS93], we generalize these earlier independence tests to arbitrary recursive datalog queries with dense-order constraints and negated EDB subgoals. The second subclass is uniform equivalence (introduced in [Sa88]). We extend the results of [Sa88] to datalog programs that include dense-order constraints and stratified negation. Based on these extensions, we present new cases in which independence is decidable and give algorithms that are sound for the general case. Aside for their use in detecting independence, the algorithms for detecting uniform equivalence are also important for optimizing datalog programs. Permission to copy without fee all or part of this material is granted provided that the copies are not made or distributed for direct commercial advantage, the VLDB copyright notice and the title of the publication and its date appear, and notice is given that copying is by permission of the Very Large Data Base Endowment. To copy otherwise, or to republish, requires a fee and/or special permission from the Endowment. 
Abstract-found: 1
Intro-found: 1
Reference: [BCL89] <author> Blakeley, J. A., N. Coburn, Larson, P. A.: </author> <title> Updating derived relations: detecting irrelevant and autonomously computable updates. </title> <journal> Transactions of Database Systems, </journal> <volume> Vol 14, No. 3, </volume> <pages> pp. 369-400, </pages> <year> 1989 </year>
Reference-contexts: Equivalence, as well as independence, is undecidable in general. However, algorithms for equivalence provide sufficient (and sometimes also necessary) conditions for independence. We consider two such conditions, query reachability [LS92] and uniform equivalence [Sa88]. Earlier work by Blakeley et al. <ref> [BCL89] </ref> and Elkan [El90] focussed on cases for which independence is the same as query reachability. Essentially, these are the cases where the updated predicate has a single occurrence in the query. Blakeley et al. [BCL89] considered only conjunctive queries. <p> Earlier work by Blakeley et al. <ref> [BCL89] </ref> and Elkan [El90] focussed on cases for which independence is the same as query reachability. Essentially, these are the cases where the updated predicate has a single occurrence in the query. Blakeley et al. [BCL89] considered only conjunctive queries. Elkan [El90] considered a more general framework, but gave an algorithm only for nonrecursive rules without negation; that algorithm is complete only for the case of a single occurrence of the updated predicate. <p> Let the query predicate be adultDriver and note that adultDriver (X) is equivalent to the following conjunction, denoted as C. inCar (X; Y; A) ^ driver (X) ^ inCar (Z; Y; B) ^ A 18 ^ B 18 An algorithm for detecting independence based on satisfiability (e.g., <ref> [El90, BCL89] </ref>) checks whether an updated fact may appear in any derivation of the query. <p> Thus, the above lemma provides a considerable generalization of previous algorithms for detecting independence. It should be realized that the independence tests of Elkan [El90] and of Blakely et al. <ref> [BCL89] </ref> are just query reachability tests. Both essentially characterized special cases in which independence is equivalent to query reachability. The result of Blakely et al. [BCL89] applies just to conjunctive queries with no repeated predicates. <p> It should be realized that the independence tests of Elkan [El90] and of Blakely et al. <ref> [BCL89] </ref> are just query reachability tests. Both essentially characterized special cases in which independence is equivalent to query reachability. The result of Blakely et al. [BCL89] applies just to conjunctive queries with no repeated predicates. The work of Elkan [El90] entails that, in the case of recursive rules, independence is equivalent to query reachability provided that the updated predicate has a single occurrence; he also required that an insertion update be monotonic. <p> More powerful transformations can be obtained by considering, for example, only minimal derivations [LS92]. In this paper, we have considered the problem of detecting independence assuming we have no knowledge of the EDB relations. An important problem, investigated in <ref> [BCL89] </ref> and [GW93] is detecting independence when some of the EDB relations are known and can be inspected efficiently.
Reference: [El90] <author> Elkan, C.: </author> <title> Independence of Logic Database Queries and Updates. </title> <booktitle> Proc. 9th ACM Symp. on Principles of Database Systems, </booktitle> <year> 1990, </year> <pages> pp. 154-160. </pages>
Reference-contexts: Equivalence, as well as independence, is undecidable in general. However, algorithms for equivalence provide sufficient (and sometimes also necessary) conditions for independence. We consider two such conditions, query reachability [LS92] and uniform equivalence [Sa88]. Earlier work by Blakeley et al. [BCL89] and Elkan <ref> [El90] </ref> focussed on cases for which independence is the same as query reachability. Essentially, these are the cases where the updated predicate has a single occurrence in the query. Blakeley et al. [BCL89] considered only conjunctive queries. Elkan [El90] considered a more general framework, but gave an algorithm only for nonrecursive <p> Earlier work by Blakeley et al. [BCL89] and Elkan <ref> [El90] </ref> focussed on cases for which independence is the same as query reachability. Essentially, these are the cases where the updated predicate has a single occurrence in the query. Blakeley et al. [BCL89] considered only conjunctive queries. Elkan [El90] considered a more general framework, but gave an algorithm only for nonrecursive rules without negation; that algorithm is complete only for the case of a single occurrence of the updated predicate. Elkan also gave a proof method for recursive rules, but its power is limited. <p> Similarly, In (P; P u ) means that program P is independent of the deletion specified by the update program P u . Several properties of independence are shown by Elkan <ref> [El90] </ref>. In particular, he showed the following. Lemma 2.4 : Consider a query program P and an update program P u . <p> Let the query predicate be adultDriver and note that adultDriver (X) is equivalent to the following conjunction, denoted as C. inCar (X; Y; A) ^ driver (X) ^ inCar (Z; Y; B) ^ A 18 ^ B 18 An algorithm for detecting independence based on satisfiability (e.g., <ref> [El90, BCL89] </ref>) checks whether an updated fact may appear in any derivation of the query. <p> If negation is also applied to IDB predicates, then a generalization of the algorithm of [LMSS93] is a sufficient test for query reachability. Thus, the above lemma provides a considerable generalization of previous algorithms for detecting independence. It should be realized that the independence tests of Elkan <ref> [El90] </ref> and of Blakely et al. [BCL89] are just query reachability tests. Both essentially characterized special cases in which independence is equivalent to query reachability. The result of Blakely et al. [BCL89] applies just to conjunctive queries with no repeated predicates. The work of Elkan [El90] entails that, in the case <p> the independence tests of Elkan <ref> [El90] </ref> and of Blakely et al. [BCL89] are just query reachability tests. Both essentially characterized special cases in which independence is equivalent to query reachability. The result of Blakely et al. [BCL89] applies just to conjunctive queries with no repeated predicates. The work of Elkan [El90] entails that, in the case of recursive rules, independence is equivalent to query reachability provided that the updated predicate has a single occurrence; he also required that an insertion update be monotonic. For testing independence, Elkan [El90] gave a query-reachability algorithm for the case of nonrecursive, negation-free rules, and suggested <p> The work of Elkan <ref> [El90] </ref> entails that, in the case of recursive rules, independence is equivalent to query reachability provided that the updated predicate has a single occurrence; he also required that an insertion update be monotonic. For testing independence, Elkan [El90] gave a query-reachability algorithm for the case of nonrecursive, negation-free rules, and suggested a proof method for the recursive case; there is no characterization of the power of that proof method, but it should be noted that it cannot capture all cases detected by the algorithms of [LS92, LMSS93]. <p> Our framework and algorithms can also be extended to incorporate integrity constraints, as in Elkan <ref> [El90] </ref>. Posing the problem of independence as a problem of equivalence suggests that further algorithms for independence can be found by trying to identify additional sufficient conditions for equivalence.
Reference: [GW93] <author> Gupta A., Widom J.: </author> <title> Local Verification of Global Integrity Constraints in Distributed Databases. </title> <booktitle> Proceedings of the ACM SIGMOD International Conference on Management of Data, </booktitle> <year> 1993, </year> <pages> pp. 49-58. </pages>
Reference-contexts: More powerful transformations can be obtained by considering, for example, only minimal derivations [LS92]. In this paper, we have considered the problem of detecting independence assuming we have no knowledge of the EDB relations. An important problem, investigated in [BCL89] and <ref> [GW93] </ref> is detecting independence when some of the EDB relations are known and can be inspected efficiently.
Reference: [KKR90] <author> Kanellakis, P.C., Kuper, G.M., and Revesz, P.Z.: </author> <title> Constraint query languages. </title> <booktitle> Proc. 9th ACM Symp. on Principles of Database Systems, </booktitle> <year> 1990, </year> <pages> pp. 299-313. </pages>
Reference-contexts: Our bottom-up evaluation of a program with a database containing facts tha are pairs is reminiscent of the procedure used by Kanellakis et al. <ref> [KKR90] </ref>. In their procedure, an EDB fact may be a generalized tuple specified in the form of a constraint on the arguments of its predicate. However, there is a key difference between the two methods. In [KKR90], every tuple is a constraint only on the arguments of the predicate involved. <p> facts tha are pairs is reminiscent of the procedure used by Kanellakis et al. <ref> [KKR90] </ref>. In their procedure, an EDB fact may be a generalized tuple specified in the form of a constraint on the arguments of its predicate. However, there is a key difference between the two methods. In [KKR90], every tuple is a constraint only on the arguments of the predicate involved. <p> If we use the procedure of <ref> [KKR90] </ref>, the result is the pair (p (x 0 ; y 0 ); T rue), which has no recording of the fact that its derivation required that u 0 v 0 . Consequently, we will conclude erroneously that M (P) M (r) holds.
Reference: [Kl88] <author> Klug, A.: </author> <title> On conjunctive queries containing inequalities. </title> <journal> JACM, </journal> <volume> Vol. 35, No. 1, </volume> <year> 1988, </year> <pages> pp. 146-160. </pages>
Reference-contexts: An interesting special case is containment of conjunctive queries with built-in predicates. Klug <ref> [Kl88] </ref> showed that if all constraints are left-semiinterval or all constraints are right-semiinterval, then containment of conjunctive queries can be decided by finding a homomorphism from one query to the other.
Reference: [Levy93] <author> Levy, A.: </author> <title> Irrelevance reasoning in knowledge based systems. </title> <type> Forthcoming Ph.D thesis, </type> <institution> Stanford University, </institution> <year> 1993. </year>
Reference-contexts: In the worst case, it may be exponential in the number of variables of r. A key component in the efficiency of the algorithm is the complexity of checking whether c r j= c 1 _: : :_c m holds. In <ref> [Levy93] </ref> we describe how to reduce this problem to a linear programming problem. <p> The rest of the algorithm is the same as earlier. Thus, we get the following result; for the full details of the proof and for a more efficient algorithm than the one described above see <ref> [Levy93] </ref>. Theorem 4.9 : Uniform equivalence for datalog programs with safe, stratified negation and built-in predicates is decidable. 5 Concluding Remarks We have presented an analysis of the notion of independence and described algorithms for detecting independence of queries from updates.
Reference: [LS92] <author> Levy, A. and Sagiv, Y.: </author> <title> Constraints and redundancy in datalog. </title> <booktitle> Proc. 11th ACM Symp. on Principles of Database Systems, </booktitle> <year> 1992, </year> <pages> pp. 67-80. </pages>
Reference-contexts: Equivalence, as well as independence, is undecidable in general. However, algorithms for equivalence provide sufficient (and sometimes also necessary) conditions for independence. We consider two such conditions, query reachability <ref> [LS92] </ref> and uniform equivalence [Sa88]. Earlier work by Blakeley et al. [BCL89] and Elkan [El90] focussed on cases for which independence is the same as query reachability. Essentially, these are the cases where the updated predicate has a single occurrence in the query. <p> Elkan also gave a proof method for recursive rules, but its power is limited. Query reachability has recently been shown decidable even for recursive datalog programs with dense-order constraints and negated EDB subgoals <ref> [LS92, LMSS93] </ref>. We show how query-reachability algorithms generalize the previous results on independence. In order to use uniform equivalence for detecting independence, we extend the algorithm given in [Sa88] to datalog programs with built-in predicates and stratified negation. <p> The predicate p is query reachable with respect to P if there is a derivation d of a fact for the query predicate from some EDB D, such that predicate p is used in d. Algorithms for deciding query reachability are discussed in <ref> [LS92, LMSS93] </ref> for cases that include built-in predicates and negation. 2.3 Updates Given a Datalog program P, which we call the query program, we consider updates to the EDB predicates of P, denoted e 1 ; : : : ; e m . <p> If predicate u is not query reachable in P + , then both In + (P; P u ) and In (P; P u ) are true. Query reachability is decidable for all datalog programs with built-in predicates and negation applied to EDB (and base) predicates <ref> [LS92, LMSS93] </ref>. If negation is also applied to IDB predicates, then a generalization of the algorithm of [LMSS93] is a sufficient test for query reachability. Thus, the above lemma provides a considerable generalization of previous algorithms for detecting independence. <p> independence, Elkan [El90] gave a query-reachability algorithm for the case of nonrecursive, negation-free rules, and suggested a proof method for the recursive case; there is no characterization of the power of that proof method, but it should be noted that it cannot capture all cases detected by the algorithms of <ref> [LS92, LMSS93] </ref>. Example 3.7 : The following example shows how query reachability can be used for detecting independence in the case of a recursive datalog program. <p> One way of doing it is by propagating constraints from one rule to another. The query tree of <ref> [LS92] </ref> is a tool for doing just that; for the type of constraints considered in this paper the propagation is complete, i.e., each rule ends up having the tightest possible constraint among its variables. <p> Consequently, these transformations increase the possibility of detecting equivalence by an algorithm for uniform equivalence. More powerful transformations can be obtained by considering, for example, only minimal derivations <ref> [LS92] </ref>. In this paper, we have considered the problem of detecting independence assuming we have no knowledge of the EDB relations. An important problem, investigated in [BCL89] and [GW93] is detecting independence when some of the EDB relations are known and can be inspected efficiently.
Reference: [LMSS93] <author> Levy, A.Y., Mumick, I.S, Sagiv, Y. and Shmueli, O.: </author> <title> Query-Reachability and Satisfiability in Datalog. </title> <booktitle> To appear in Proc. 12th ACM Symp. on Principles of Database Systems,, </booktitle> <year> 1993. </year>
Reference-contexts: Elkan also gave a proof method for recursive rules, but its power is limited. Query reachability has recently been shown decidable even for recursive datalog programs with dense-order constraints and negated EDB subgoals <ref> [LS92, LMSS93] </ref>. We show how query-reachability algorithms generalize the previous results on independence. In order to use uniform equivalence for detecting independence, we extend the algorithm given in [Sa88] to datalog programs with built-in predicates and stratified negation. <p> The predicate p is query reachable with respect to P if there is a derivation d of a fact for the query predicate from some EDB D, such that predicate p is used in d. Algorithms for deciding query reachability are discussed in <ref> [LS92, LMSS93] </ref> for cases that include built-in predicates and negation. 2.3 Updates Given a Datalog program P, which we call the query program, we consider updates to the EDB predicates of P, denoted e 1 ; : : : ; e m . <p> If predicate u is not query reachable in P + , then both In + (P; P u ) and In (P; P u ) are true. Query reachability is decidable for all datalog programs with built-in predicates and negation applied to EDB (and base) predicates <ref> [LS92, LMSS93] </ref>. If negation is also applied to IDB predicates, then a generalization of the algorithm of [LMSS93] is a sufficient test for query reachability. Thus, the above lemma provides a considerable generalization of previous algorithms for detecting independence. <p> Query reachability is decidable for all datalog programs with built-in predicates and negation applied to EDB (and base) predicates [LS92, LMSS93]. If negation is also applied to IDB predicates, then a generalization of the algorithm of <ref> [LMSS93] </ref> is a sufficient test for query reachability. Thus, the above lemma provides a considerable generalization of previous algorithms for detecting independence. It should be realized that the independence tests of Elkan [El90] and of Blakely et al. [BCL89] are just query reachability tests. <p> independence, Elkan [El90] gave a query-reachability algorithm for the case of nonrecursive, negation-free rules, and suggested a proof method for the recursive case; there is no characterization of the power of that proof method, but it should be noted that it cannot capture all cases detected by the algorithms of <ref> [LS92, LMSS93] </ref>. Example 3.7 : The following example shows how query reachability can be used for detecting independence in the case of a recursive datalog program.
Reference: [Sa88] <author> Sagiv, Y.: </author> <title> Optimizing datalog programs. In Foundations of Deductive Databases and Logic Programming, </title> <editor> (J. Minker, ed.), </editor> <publisher> Morgan Kaufmann Publishers, </publisher> <year> 1988, </year> <pages> pp. 659-698. </pages>
Reference-contexts: Equivalence, as well as independence, is undecidable in general. However, algorithms for equivalence provide sufficient (and sometimes also necessary) conditions for independence. We consider two such conditions, query reachability [LS92] and uniform equivalence <ref> [Sa88] </ref>. Earlier work by Blakeley et al. [BCL89] and Elkan [El90] focussed on cases for which independence is the same as query reachability. Essentially, these are the cases where the updated predicate has a single occurrence in the query. Blakeley et al. [BCL89] considered only conjunctive queries. <p> Query reachability has recently been shown decidable even for recursive datalog programs with dense-order constraints and negated EDB subgoals [LS92, LMSS93]. We show how query-reachability algorithms generalize the previous results on independence. In order to use uniform equivalence for detecting independence, we extend the algorithm given in <ref> [Sa88] </ref> to datalog programs with built-in predicates and stratified negation. <p> Containment of datalog programs is undecidable [Sh87], even for programs without built-in predicates or negation. A sufficient condition for containment is uniform containment, which was introduced and shown to be decidable in <ref> [Sa88] </ref> for programs without built-in predicates or negation. <p> 0 1 ; : : : ; I 0 P 2 (E 1 ; : : : ; E m ; I 0 n ) P 1 (E 1 ; : : : ; E m ; I 0 n ): Uniform containment can also be explained in model-theoretic terms <ref> [Sa88] </ref>. For programs without negations, the uniform containment P 2 u P 1 holds if and only if M (P 1 ) M (P 2 ), where M (P i ) denotes the set of all models of P i . <p> Consequently, the query goodP ath will be independent of removing or adding facts of that form. 4 Uniform Equivalence In this section, we describe algorithms for deciding uniform equivalence of programs that have built-in predicates and stratified negation. This extends a previous algorithm <ref> [Sa88] </ref> that dealt with datalog programs without built-in predicates or negations. As shown in [Sa88], uniform containment (and equivalence) can be given model-theoretic characterization, namely, the uniform containment P 2 u P 1 holds if and only if M (P 1 ) M (P 2 ), where M (P i ) <p> This extends a previous algorithm <ref> [Sa88] </ref> that dealt with datalog programs without built-in predicates or negations. As shown in [Sa88], uniform containment (and equivalence) can be given model-theoretic characterization, namely, the uniform containment P 2 u P 1 holds if and only if M (P 1 ) M (P 2 ), where M (P i ) denotes the set of all models of P i . <p> We first discuss programs with only built-in predicates. 4.1 Uniform Containment with Built-in Predicates When the programs have no interpreted predicates, the following algorithm (from <ref> [Sa88] </ref>) will decide whether a given rule r is uniformly contained in a program P. <p> We then apply the program P to the atoms q 1 ; : : : ; q n . In <ref> [Sa88] </ref> it is shown that the program P generates p from q 1 ; : : : ; q n if and only if M (P) M (r). However, there is a problem in applying this algorithm to programs with interpreted predicates.
Reference: [Sh87] <author> Shmueli, O.: </author> <title> Decidability and expressiveness aspects of logic queries. </title> <booktitle> Proc. 6th ACM Symp. on Principles of Database Systems, </booktitle> <year> 1987, </year> <pages> pp. 237-249. </pages>
Reference-contexts: Two programs P 1 and P 2 are equivalent, written P 1 P 2 , if P 2 P 1 and P 1 P 2 . Containment of datalog programs is undecidable <ref> [Sh87] </ref>, even for programs without built-in predicates or negation. A sufficient condition for containment is uniform containment, which was introduced and shown to be decidable in [Sa88] for programs without built-in predicates or negation.
Reference: [Ull88] <author> Ullman, J. D.: </author> <booktitle> Principles of Database and Knowledge-Base Systems, </booktitle> <volume> Volume 1. </volume> <publisher> Computer Science Press, </publisher> <year> 1988. </year> <editor> [vdM92] van der Meyden R.: </editor> <title> The Complexity of Querying Indefinite Data about Linearly Ordered Domains. </title> <booktitle> Proc. 11th ACM Symp. on Principles of Database Systems, </booktitle> <year> 1992, </year> <pages> pp. 331-345. </pages>
Reference-contexts: We allow the built-in predicates 1 &lt;, &gt;, =, 6=, , and that represent a dense order. Programs may also have stratified negation. Both negation and built-in predicates must be used safely (cf. <ref> [Ull88] </ref>). We distinguish between two sets of predicates in a given program: the extensional predicates (EDB predicates), which are those that appear only in bodies of rules, and the intensional predicates (IDB predicates), which are the predicates appearing in heads of rules. <p> Note that applying a stratified program to a database that may also have IDB facts is done stratum by stratum, as in the usual case; in other words, P (D) is the perfect model of the program P and the database D (cf. <ref> [Ull88] </ref>). Suppose that that P 1 and P 2 are not uniformly equivalent. Hence, there is a database D 0 such that P 1 (D 0 ) 6= P 2 (D 0 ); D 0 is called a counterexample. <p> By the definition of D, if g is a ground fact having only constants from D, then g 2 D if and only if g 2 D; moreover, for every negative subgoal s, the constants appearing in st are all from D, since rules are safe (cf. <ref> [Ull88] </ref>). Therefore, items (1)-(3) hold even if we replace D with D, and so it follows that D is not a model of r|a contradiction, since D is a model of P i+1 2 and r is a rule of P i+1 2 .
References-found: 11

