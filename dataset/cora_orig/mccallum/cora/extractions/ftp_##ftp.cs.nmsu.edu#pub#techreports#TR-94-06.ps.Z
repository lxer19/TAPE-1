URL: ftp://ftp.cs.nmsu.edu/pub/techreports/TR-94-06.ps.Z
Refering-URL: http://www.cs.nmsu.edu/~mikau/
Root-URL: http://www.cs.nmsu.edu
Email: mikau@nmsu.edu  petfr@ida.liu.se  
Title: PARFORMAN an Assertion Language for Specifying Behavior when Debugging Parallel Applications general notion of composite
Author: Mikhail Auguston, Peter Fritzson, Linkping 
Keyword: profiles and performance measurements. Keywords: Annotation language, Assertions, Concurrent programming, Occam, Testing, Debugging, Parallelism  
Note: The  can also be used to specify  
Address: 1  2  
Affiliation: New Mexico State University  University  
Abstract: PARFORMAN (PARallel FORMal ANnotation language) is a high-level specification language for expressing intended behavior or known types of error conditions when debugging or testing parallel programs. Models of intended or faulty target program behavior can be succinctly specified in PARFORMAN. These models are then compared with the actual behavior in terms of execution traces of events, in order to localize possible bugs. PARFORMAN can also be used as a general language for expressing computations over target program execution histories. PARFORMAN is based on a precise axiomatic model of target program behavior. This model, called H-space (History-space), is formally defined through a set of general axioms about three basic relations, which may or may not hold between two arbitrary events: they may be sequentially ordered (SEQ), they may be parallel (PAR), or one of them might be included in another composite event (IN). 
Abstract-found: 1
Intro-found: 1
Reference: [Allen 83] <author> James F. Allen: </author> <title> Maintaining Knowledge about Temporal Intervals. </title> <journal> Communications of the ACM, </journal> <volume> 26:11, </volume> <pages> pp 832-843, </pages> <month> Nov </month> <year> 1983. </year>
Reference-contexts: This work is presented in [Goldszmidt,et.al 89] where four types of events are introduced - assignment to variables, reaching a label, interprocess communication and process instantiation or termination. Composite events cannot be defined. However, a temporal logic with the inclusion relation is described in <ref> [Allen 83] </ref>. An integrated view of testing and debugging is essential. As is stated in [Baiardi.et.al 86]: "... since the behavior of a parallel program is not generally reproducible, the debugger should be able not only to locate but also to detect the presence of errors.
Reference: [Auguston 91] <author> Mikhail Auguston: </author> <title> FORMAN - A Program Formal Annotation Language, </title> <booktitle> In Proceedings of the 5:th Israel conference on Computer Systems and Software Engineering, </booktitle> <address> Gerclia, May 1991, </address> <publisher> IEEE Computer Society Press, </publisher> <address> pp.149-154, </address> <year> 1991. </year>
Reference-contexts: This was first implemented on an IBM PC and reported in <ref> [Auguston 91] </ref>.
Reference: [Bacon,Goldstein 91] <author> David F. Bacon, Seth C. Goldstein: </author> <title> Hardware-Assisted Replay of Multiprocessor Programs, </title> <booktitle> In Proc. of the ACM/ONR Workshop on Parallel and Distributed Debugging, </booktitle> <month> May </month> <year> 1991. </year> <journal> In SIGPLAN Notices 26:12, </journal> <month> Dec </month> <year> 1991. </year>
Reference-contexts: In some cases, the source code of the target program is not available, or the slow-down caused by interpretation or code instrumentation is not acceptable. The only method for tracing which guarantees no slowdown is hardware support <ref> [Bacon,Goldstein 91] </ref>, e.g. collect traces of low-level events from the computer bus, such as storage to memory locations, I/O, and elementary synchronization operations. Another possibility is to dynamically link new tracing code between the application and the run-time system to trace events such as send, receive, I/O, memory allocation, etc.
Reference: [Baiardi,et.al 86] <author> F.Baiardi, N. De Francesco, G. Vaglini: </author> <title> Development of a Debugger for a Concurrent Language, </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> vol. SE-12, No 4, pp.547-553, </volume> <month> April </month> <year> 1986. </year> <month> 24 </month>
Reference-contexts: Patterns can be written which involve parameter values of Task entry calls. Assertions are written in Ada itself, using a number of special pre-defined predicates. Assertion-checking is dynamic at run-time, and does not need post-mortem analysis. In <ref> [Baiardi,et.al 86] </ref> events are introduced to describe process communication, termination, and connection and detachment of processes to channels. A language of Behavior Expressions (BE) is provided to write assertions about sequences of process interactions.
Reference: [Bates 89] <author> Peter C. Bates: </author> <title> Debugging Heterogeneous Distributed Systems Using Event-Based Models of Behavior: </title> <journal> SIGPLAN Notices vol. </journal> <volume> 24, No 1, pp.11-22, </volume> <year> 1989. </year>
Reference-contexts: This is similar to the problem of disassembling and reverse engineering high level language source code from the machine code level. Only in this third approach, pattern matching is needed to detect high-level events, as for example in <ref> [Bates 89] </ref>. This means more work at trace evaluation time, but less work at trace generation time compared to the two previous approaches where also high-level events are traced at trace-generation time. Additional considerations may however reduce the amount of needed tracing: Tracing by need. <p> Recent conferences are [Pardebug 88], [Pardebug 91], and [Pardebug 93]. A good survey paper is [McDowell,Helmbold 89]. Similar to PARFORMAN, the Event Based Behavioral Abstraction (EBBA) method suggested in [Bates,Wileden 83], <ref> [Bates 89] </ref> characterizes the behavior of the whole program in terms of both primitive and composite events. Context conditions involving event attribute values can be used to distinguish events.
Reference: [Bates,Wileden 83] <author> Peter C. Bates, J.C. Wileden: </author> <title> High-Level Debugging of Distributed Systems: The Behavioral Abstraction Approach, </title> <journal> The Journal of Systems and Software 3, </journal> <pages> pp. 255-264, </pages> <year> 1983. </year>
Reference-contexts: This research area is currently quite active -- a literature survey as of January 1991 contains 378 references [Pancake,Utter 91]. Recent conferences are [Pardebug 88], [Pardebug 91], and [Pardebug 93]. A good survey paper is [McDowell,Helmbold 89]. Similar to PARFORMAN, the Event Based Behavioral Abstraction (EBBA) method suggested in <ref> [Bates,Wileden 83] </ref>, [Bates 89] characterizes the behavior of the whole program in terms of both primitive and composite events. Context conditions involving event attribute values can be used to distinguish events.
Reference: [Bruegge,Hibbard 83] <author> B.Bruegge, P.Hibbard: </author> <title> Generalized Path Expressions: A High-Level Debugging Mechanism, </title> <journal> The Journal of Systems and Software 3, </journal> <pages> pp. 265-276, </pages> <year> 1983. </year>
Reference-contexts: It is useful to give such a description in an explicit and precise form. The path expression technique introduced for specifying parallel programs in [Campbell, Habermann 74] is one such formalism. It has been used in several projects as a background for high-level debugging tools, e.g. in <ref> [Bruegge,Hibbard 83] </ref>, where path rules are suggested as a kind of debugger commands. Trace specifications also are used in [McLean 84] for software specification. Path expressions or history expressions have also been used for the concurrent system formal specification 22 purposes in the Aleph project [Winograd 88], [Osterby 89].
Reference: [Campbell,Habermann 74] <author> R.H. Campbell, </author> <title> A.N. Habermann: The specification of process synchronization by path expressions, </title> <booktitle> Lecture Notes in Computer Science, </booktitle> <volume> vol. 16, </volume> <pages> pp. 89-102, </pages> <year> 1974. </year>
Reference: [Elshoff 89] <author> I.J.P. Elshoff: </author> <title> A Distributed Debugger for Amoeba, </title> <journal> SIGPLAN Notices vol.24, </journal> <volume> No 1, pp.1-10, </volume> <year> 1989. </year>
Reference-contexts: Event types are process communication and interactions such as send, receive, terminate, connect and detach. Evaluation of assertions are done at run-time. No composite events are provided. The distributed debugger for the Amoeba operating system <ref> [Elshoff 89] </ref> is another example of an event-based view of program execution. Event patterns and regular expressions on patterns are used to define run-time checks and debugging actions, e.g. to stop the target program and print a message to the user.
Reference: [Fidge 89] <author> C.J. Fidge: </author> <title> Partial Orders for Parallel Debugging, </title> <journal> SIGPLAN Notices, vol.24, </journal> <volume> No.1, </volume> <year> 1989 </year>
Reference: [Fritzson,et.al 92] <author> Peter Fritzson, Nahid Shahmehri, Mariam Kamkar, Tibor Gyimothy: </author> <title> Generalized Algorithmic Debugging and Testing. </title> <journal> In ACM LOPLAS - Letters of Programming Languages and Systems. </journal> <volume> Vol 1, No 4, </volume> <month> Dec </month> <year> 1992. </year>
Reference: [Fritzson,et.al 94] <author> Peter Fritzson, Mikhail Auguston, Nahid Shahmehri: </author> <title> Using Assertions in Declarative and Operational Models for Automated Debugging. </title> <note> To appear in the Journal of Systems and Software 1994. </note>
Reference: [Garcia-Molina,et.al 84] <author> H.Garcia-Molina, F.Germano, W.H.Kohler, </author> <title> Debugging a Distributed Computing System, </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> vol. SE-10, No 2, </volume> <pages> pp. 210-219, </pages> <month> March </month> <year> 1984. </year>
Reference-contexts: A number of different formalisms have been developed to express intended behavior. Since observed results are hard to reproduce in parallel and distributed debugging, tracing plays a prominent role (see e.g. <ref> [Garcia-Molina,et.al 84] </ref>). Post-mortem analysis of saved program execution traces using event data bases and possibly program replay are common techniques. Thus, most methods for comparing intended and actual behavior are based on tracing events in execution histories.
Reference: [Goldszmidt,et.al.89] <author> G.Goldszmidt, S.Katz, S.Yemini: </author> <title> Interactive Blackbox Debugging for Concurrent Languages, </title> <journal> SIGPLAN Notices vol .24, </journal> <volume> No 1, </volume> <pages> pp. 271-282, </pages> <year> 1989. </year>
Reference: [Hoare 85] <editor> Communicating Sequential Processes, </editor> <publisher> Prentice -Hall, </publisher> <year> 1985. </year>
Reference-contexts: This is a message-passing parallel language based on the Hoares model of parallelism <ref> [Hoare 85] </ref>, [Occam 88]. See Appendix A for a short survey of this Occam subset. Each event in the H-space of an Occam program belongs to one of the possible event types.
Reference: [Hough,Cuny 89] <author> A.A.Hough, J.E.Cuny: </author> <title> Initial Experiences with a Pattern-Oriented Parallel Debugger, </title> <journal> SIGPLAN Notices vol.24, </journal> <volume> No 1, </volume> <pages> pp. 195-205, </pages> <year> 1989. </year>
Reference: [Lamport 78] <author> L.Lamport: </author> <title> Time, Clocks, and the Ordering of Events in a distributed System, </title> <journal> Communications of the ACM, vol.21, </journal> <volume> No.7,pp.558-565, </volume> <month> July </month> <year> 1978. </year>
Reference-contexts: This can be illustrated by the examples in the Figure 1. 4) Irreflexivity not ( a || a ) Irreflexivity for &lt;< and IN follows from 2). Note that &lt;< is an irreflexive partial ordering similar to the <ref> [Lamport 78] </ref> model. 5) Distributivity (a IN b) and (b &lt;< c) =&gt; (a << c) (FOREACH a IN b ( FOREACH c IN d ( a &lt;< c) )) =&gt; ( b << d ) (a || b) and (c IN b) =&gt; not ( a &lt;< c) and not <p> Detection of events which are local to some processor is relatively simple. Collecting a view on the global state is more complicated. In collecting information for the Snapshot event, Lamports algorithm <ref> [Lamport 78] </ref> on detecting partial ordering of events can be used to determine which events may have "happened at the same time", and thus should be included in the Snapshot. Figure 4 illustrates the detection of Snapshot events and computation of one class of assertions involving Snapshots.
Reference: [LeBlanc, Mellor-Crummey 87] <author> T.J.LeBlanc, J.M.Mellor-Crummey: </author> <title> Debugging Parallel Programs with Instant Replay, </title> <journal> IEEE Transactions on Computers, </journal> <volume> vol. C-36, No 4, pp.471-482, </volume> <month> April </month> <year> 1987. </year> <note> [Lichtenstein,Shapiro 89]Y. </note> <author> Lichtenstein, E. Shapiro: </author> <title> Concurrent Algorithmic Debugging. </title> <booktitle> In Proc. of the Workshop on Parallel and Distributed Debugging, SIGPLAN Notices 24:1, </booktitle> <month> January </month> <year> 1989. </year>
Reference: [Luckham,et.al. 84] <author> David C. Luckham, F.W.von Henke, B.Krieg-Brueckner, O.Owe, ANNA: </author> <title> A Language for Annotating Ada Programs. </title> <institution> Computer Systems Laboratory Technical Report 84-261, Stanford University, </institution> <month> July, </month> <year> 1984, </year> <pages> pp. 1-22. </pages>
Reference: [Luckham,et.al.90] <author> David C. Luckham, D.Bryan, W.Mann, S.Meldal, D.P.Helmbold, </author> <title> An Introduction to Task Sequencing Language, </title> <note> TSL version 1.5 (Preliminary version), </note> <institution> Stanford University, </institution> <month> February 1, </month> <year> 1990, </year> <pages> pp. 1-68. </pages>
Reference: [Luckham,et.al 91] <author> David C. Luckham, Sriram Sankar, Shuzo Takahashi: </author> <title> Two-Dimensional Pinpointing: Debugging with Formal Specifications. </title> <journal> IEEE Software, </journal> <note> January 1991, pp.74-84. 25 </note>
Reference: [McDowell,Helmbold 89] <author> C.E.McDowell, D.P.Helmbold, </author> <title> Debugging Concurrent Programs, </title> <journal> ACM Computing Surveys, Vo. </journal> <volume> 21, No 4, </volume> <pages> pp. 593-622, </pages> <month> December </month> <year> 1989. </year>
Reference-contexts: This research area is currently quite active -- a literature survey as of January 1991 contains 378 references [Pancake,Utter 91]. Recent conferences are [Pardebug 88], [Pardebug 91], and [Pardebug 93]. A good survey paper is <ref> [McDowell,Helmbold 89] </ref>. Similar to PARFORMAN, the Event Based Behavioral Abstraction (EBBA) method suggested in [Bates,Wileden 83], [Bates 89] characterizes the behavior of the whole program in terms of both primitive and composite events. Context conditions involving event attribute values can be used to distinguish events.
Reference: [McLean 84] <author> J.McLean, </author> <title> A Formal Method for the Abstract Specification of Software, </title> <journal> Journal of the Association of Computing Machinery, vol.31, </journal> <volume> #3, </volume> <month> July </month> <year> 1984, </year> <month> pp.600-627. </month>
Reference-contexts: It has been used in several projects as a background for high-level debugging tools, e.g. in [Bruegge,Hibbard 83], where path rules are suggested as a kind of debugger commands. Trace specifications also are used in <ref> [McLean 84] </ref> for software specification. Path expressions or history expressions have also been used for the concurrent system formal specification 22 purposes in the Aleph project [Winograd 88], [Osterby 89].
Reference: [Occam 88] <author> INMOS Limited, </author> <title> Occam 2 Reference Manual, </title> <publisher> Prentice Hall, </publisher> <address> pp.133, </address> <year> 1988. </year>
Reference-contexts: Possible application areas include program testing and debugging, performance measurement and modeling, program profiling, program animation, program maintenance and program documentation. In this paper, a large subset of the Occam programming language <ref> [Occam 88] </ref> is used as a target language, in order to present examples of consistency checking and bug detection in concurrent programming. <p> This is a message-passing parallel language based on the Hoares model of parallelism [Hoare 85], <ref> [Occam 88] </ref>. See Appendix A for a short survey of this Occam subset. Each event in the H-space of an Occam program belongs to one of the possible event types. <p> Example. A dynamic constraint to ensure that each channel connects only two parallel processes, and to ensure that the connection of channels is unidirectional. See the Occam Reference Manual <ref> [Occam 88] </ref>, page 75. Occam compilers can usually check this statically and prevent attempts to compile Occam code for which execution could lead to such collision. Here for demonstration purposes we suppose that such situations have to be checked dynamically. <p> A dynamic constraint: data race condition. See the Occam Reference Manual <ref> [Occam 88] </ref>, page 75 and [Occam 91], page 112. The same memory location may not be assigned values in parallel by different processors. This can be checked statically by Occam compilers in most cases, but not when assigning to array elements.
Reference: [Occam 91] <editor> Occam2 Toolset SUN4 User Manual, </editor> <volume> Part 1, </volume> <month> March </month> <year> 1991, </year> <title> INMOS Limited, </title> <type> 72 TDS 275 02. </type>
Reference-contexts: A dynamic constraint: data race condition. See the Occam Reference Manual [Occam 88], page 75 and <ref> [Occam 91] </ref>, page 112. The same memory location may not be assigned values in parallel by different processors. This can be checked statically by Occam compilers in most cases, but not when assigning to array elements.
Reference: [Olender,Osterweil 86] <author> K.M.Olender, Leon J. Osterweil: </author> <title> Specification and static evaluation of sequencing constraints in software, </title> <booktitle> In Proceedings of the Workshop on Software Testing, </booktitle> <pages> pp. 2 - 9, </pages> <month> July </month> <year> 1986. </year>
Reference: [Olender,Osterweil 89] <author> K.M.Olender, Leon J. Osterweil, </author> <title> Cesar: A static sequencing constraint analyzer, </title> <booktitle> In Proceedings of ACM SIGSOFT'89: Third Symposium on Software Testing, Analysis, and Verification (TAV3), </booktitle> <address> pp.66-74, </address> <year> 1989. </year>
Reference-contexts: A powerful language for defining constraints on the sequencing of events in the program execution process is described in [Olender, Osterweil 86]. This language (Cecil) is based on the path expression formalism. Cesar is a system <ref> [Olender,Osterweil 89] </ref> for carrying out static analysis of Fortran program based on the path expression assertions in the Cecil notation.
Reference: [Osterby 89] <author> K.Osterby, </author> <title> Implementation Support for the Specification Language Aleph, </title> <institution> University of Aalborg, </institution> <type> Report 89-18, </type> <month> August </month> <year> 1989. </year>
Reference-contexts: Trace specifications also are used in [McLean 84] for software specification. Path expressions or history expressions have also been used for the concurrent system formal specification 22 purposes in the Aleph project [Winograd 88], <ref> [Osterby 89] </ref>. A powerful language for defining constraints on the sequencing of events in the program execution process is described in [Olender, Osterweil 86]. This language (Cecil) is based on the path expression formalism.
Reference: [Pancake,Utter 91] <author> Cherri .M. Pancake, S. Utter, </author> <title> A Bibliography of Parallel Debuggers, 1990 Edition, </title> <journal> ACM SIGPLAN Notices, </journal> <volume> Vol 26, No.1, </volume> <month> January </month> <year> 1991. </year>
Reference-contexts: Composite events can also be defined, which represent non-zero length time intervals and can be decomposed into collections of more primitive events. This research area is currently quite active -- a literature survey as of January 1991 contains 378 references <ref> [Pancake,Utter 91] </ref>. Recent conferences are [Pardebug 88], [Pardebug 91], and [Pardebug 93]. A good survey paper is [McDowell,Helmbold 89]. Similar to PARFORMAN, the Event Based Behavioral Abstraction (EBBA) method suggested in [Bates,Wileden 83], [Bates 89] characterizes the behavior of the whole program in terms of both primitive and composite events.
Reference: [Pardebug 88] <institution> Proceedings of the Workshop on Parallel and Distributed Debugging, </institution> <month> May 5-6, </month> <year> 1988, </year> <title> Madison, Wisconsin, </title> <journal> SIGPLAN Notices, </journal> <volume> Vol 24, No 1, </volume> <month> January </month> <year> 1989. </year>
Reference-contexts: Composite events can also be defined, which represent non-zero length time intervals and can be decomposed into collections of more primitive events. This research area is currently quite active -- a literature survey as of January 1991 contains 378 references [Pancake,Utter 91]. Recent conferences are <ref> [Pardebug 88] </ref>, [Pardebug 91], and [Pardebug 93]. A good survey paper is [McDowell,Helmbold 89]. Similar to PARFORMAN, the Event Based Behavioral Abstraction (EBBA) method suggested in [Bates,Wileden 83], [Bates 89] characterizes the behavior of the whole program in terms of both primitive and composite events.
Reference: [Pardebug 91] <institution> Proceedings of the ACM/ONR Workshop on Parallel and Distributed Debugging, </institution> <month> May 20-21, </month> <year> 1991, </year> <title> Santa Cruz, California, </title> <journal> SIGPLAN Notices, </journal> <volume> Vol 26, No 12, </volume> <month> December </month> <year> 1991. </year>
Reference-contexts: Composite events can also be defined, which represent non-zero length time intervals and can be decomposed into collections of more primitive events. This research area is currently quite active -- a literature survey as of January 1991 contains 378 references [Pancake,Utter 91]. Recent conferences are [Pardebug 88], <ref> [Pardebug 91] </ref>, and [Pardebug 93]. A good survey paper is [McDowell,Helmbold 89]. Similar to PARFORMAN, the Event Based Behavioral Abstraction (EBBA) method suggested in [Bates,Wileden 83], [Bates 89] characterizes the behavior of the whole program in terms of both primitive and composite events.
Reference: [Pardebug 93] <institution> Proceedings of the ACM/ONR Workshop on Parallel and Distributed Debugging, </institution> <month> May 17-18, </month> <year> 1993, </year> <title> San Diego, California, </title> <journal> SIGPLAN Notices, </journal> <volume> Vol 28, No 12, </volume> <month> December </month> <year> 1993. </year>
Reference-contexts: This research area is currently quite active -- a literature survey as of January 1991 contains 378 references [Pancake,Utter 91]. Recent conferences are [Pardebug 88], [Pardebug 91], and <ref> [Pardebug 93] </ref>. A good survey paper is [McDowell,Helmbold 89]. Similar to PARFORMAN, the Event Based Behavioral Abstraction (EBBA) method suggested in [Bates,Wileden 83], [Bates 89] characterizes the behavior of the whole program in terms of both primitive and composite events.
Reference: [Rosenblum 91] <author> D.S.Rosenblum, </author> <title> Specifying Concurrent Systems with TSL, </title> <journal> IEEE Software, </journal> <month> May </month> <year> 1991, </year> <month> pp.52-61 </month>
Reference-contexts: In the TSL [Luckham,et.al.-90] annotation language for Ada the notion of event is introduced in order to describe the behavior of tasks. The following event types are available: start of an accept, start of task entry, call, begin rendezvous, end rendezvous, task activation, and task termination <ref> [Rosenblum 91] </ref>. Patterns can be written which involve parameter values of Task entry calls. Assertions are written in Ada itself, using a number of special pre-defined predicates. Assertion-checking is dynamic at run-time, and does not need post-mortem analysis.
Reference: [Shahmehri 91] <author> N.Shahmehri, </author> <title> Generalized Algorithmic Debugging. </title> <type> Ph.D. Thesis No 260, </type> <institution> Dept. of Computer and Information Science, Linkping University, S-581 83 Linkping, Sweden. </institution>
Reference: [Shapiro-82] <author> E.Shapiro. </author> <title> Algorithmic Program Debugging. </title> <publisher> MIT Press, </publisher> <month> May </month> <year> 1982. </year>
Reference: [Smith,et.al 85] <author> Douglas R. Smith, Gordon B. Kotik and Stehpen J. Westfold: </author> <title> Research on Knowledge-Based Software Environments at Kestrel Institute, </title> <journal> IEEE Trans. on Software Engineering, </journal> <volume> Vol SE-11, No 11, </volume> <month> Nov </month> <year> 1985. </year>
Reference: [Winograd 88] <author> T.Winograd: </author> <title> Aleph: a system specification language. 1988, </title> <publisher> Stanford University, CSLI. </publisher> <pages> 26 </pages>
Reference-contexts: Trace specifications also are used in [McLean 84] for software specification. Path expressions or history expressions have also been used for the concurrent system formal specification 22 purposes in the Aleph project <ref> [Winograd 88] </ref>, [Osterby 89]. A powerful language for defining constraints on the sequencing of events in the program execution process is described in [Olender, Osterweil 86]. This language (Cecil) is based on the path expression formalism.
References-found: 37

