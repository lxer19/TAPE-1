URL: http://www.cs.indiana.edu/database/Ode/doc/att-db-91-1.ps.Z
Refering-URL: http://www.cs.indiana.edu/database/Ode/doc/
Root-URL: http://www.cs.indiana.edu
Title: Object Versioning in Ode  
Author: R. Agrawal S. J. Buroff N. H. Gehani D. Shasha 
Address: San Jose, California 95120  Summit, New Jersey 07901  Murray Hill, New Jersey 07974  New York, NY 10012  
Affiliation: IBM Almaden Research Center  AT&T Bell Labs  AT&T Bell Labs  New York University  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> H. D. Afsarmanesh, D. McLeod, D. Knapp and A. Parker, </author> <title> ``An Extensible Object-Oriented Approach to Databases for VLSI/CAD'', </title> <booktitle> Proc. of the 11th Int'l Conf. on Very Large Databases, </booktitle> <address> Stockholm, Sweden, </address> <month> Aug. </month> <year> 1985. </year>
Reference-contexts: It may also be said that these applications are the primary force driving the current interest in the object-oriented database systems. At present, there is little agreement on one uniform model for design databases, although some recent papers have articulated major needs <ref> [1, 5, 7-9, 13-17, 19-21, 24, 25, 28, 29, 32-34] </ref>. Consequently, O++ does not come with a ``hardwired'' design database model; instead, it provides facilities with which users can develop customized models that match their needs. In designing O++, we have distinguished between primitives and policies. <p> Similarly, we decided against a built-in change notification facility [13] because users can implement such a facility using O++ triggers. A critical requirement of CAD applications that is addressed by O++ is support for object versioning. Our design, although inspired by many of the earlier proposals <ref> [1, 5, 7-9, 13-17, 19-21, 24, 25, 28, 29, 32-34] </ref>, differs significantly from them in that we focus on introducing a minimum number of concepts with precise semantics and integrating them seamlessly in a programming language. <p> By overloading the definitions of the -&gt; and * operators we were able to define class VersionPtr in such a way that its objects could be manipulated just like normal pointers. 7. RELATED WORK The literature abounds with models for version management <ref> [1, 5, 7-9, 13-17, 19-21, 24, 25, 28, 29, 32-34] </ref>. O++ culls out kernel features from these proposals and provides primitives within the framework of an object-oriented language for implementing a variety of versioning models and application-specific systems.
Reference: [2] <author> R. Agrawal and N. H. Gehani, </author> <title> ``Rationale for the Design of Persistence and Query Processing Facilities in the Database Programming Language O++'', </title> <booktitle> 2nd Int'l Workshop on Database Programming Languages, </booktitle> <address> Portland, OR, </address> <month> June </month> <year> 1989. </year>
Reference-contexts: We felt that the temporal and derived-from relationships are common enough to be automatically maintained by the system. The persistence model of O++ <ref> [2] </ref> does not require explicit insertion of persistent objects in a database; such objects automatically persist across program invocations. A comprehensive versioning model for public/private distributed architecture of CAD systems has been developed as part of the ORION project [13].
Reference: [3] <author> R. Agrawal and N. H. Gehani, </author> <title> ``Ode (Object Database and Environment): The Language and the Data Model'', </title> <booktitle> Proc. ACM-SIGMOD 1989 Int'l Conf. Management of Data, </booktitle> <address> Portland, Oregon, </address> <month> May-June </month> <year> 1989, </year> <pages> 36-45. </pages>
Reference: [4] <author> R. Agrawal, N. H. Gehani and J. Srinivasan, </author> <title> ``OdeView: The Graphical Interface to Ode'', </title> <booktitle> Proc. ACM-SIGMOD 1990 Int'l Conf. on Management of Data, </booktitle> <year> 1990, </year> <pages> 34-43. </pages>
Reference: [5] <author> T. M. Atwood, </author> <title> ``An Object-Oriented DBMS for Design Support Applications'', </title> <booktitle> Proc. IEEE 1st Int'l Conf. Computer-Aided Technologies, </booktitle> <address> Montreal, Canada, </address> <month> Sept. </month> <year> 1985, </year> <pages> 299-307. </pages>
Reference-contexts: It may also be said that these applications are the primary force driving the current interest in the object-oriented database systems. At present, there is little agreement on one uniform model for design databases, although some recent papers have articulated major needs <ref> [1, 5, 7-9, 13-17, 19-21, 24, 25, 28, 29, 32-34] </ref>. Consequently, O++ does not come with a ``hardwired'' design database model; instead, it provides facilities with which users can develop customized models that match their needs. In designing O++, we have distinguished between primitives and policies. <p> Similarly, we decided against a built-in change notification facility [13] because users can implement such a facility using O++ triggers. A critical requirement of CAD applications that is addressed by O++ is support for object versioning. Our design, although inspired by many of the earlier proposals <ref> [1, 5, 7-9, 13-17, 19-21, 24, 25, 28, 29, 32-34] </ref>, differs significantly from them in that we focus on introducing a minimum number of concepts with precise semantics and integrating them seamlessly in a programming language. <p> Small changes should have small impact: Small operations should not cause major changes in the database. Thus, we do not provide version percolation <ref> [5, 13, 34] </ref> because creating a new version can lead to the automatic creation of a large number of versions of other objects. Users may implement version percolation as a policy by using other O++ facilities. - 3 - 3. <p> Each representation can be thought of as a configuration [8, 9, 13, 16, 21, 33]. This example amply illustrates how configurations can be created using the facilities provided in O++. In a similar manner, contexts <ref> [5, 8, 13, 16, 21] </ref> may also be created to specify default versions. 6. IMPLEMENTATION We are implementing an O++ compiler which translates O++ programs to C++. The resulting C++ code uses a persistence library [10], which contains classes to support, amongst other things, persistent objects and object versions. <p> By overloading the definitions of the -&gt; and * operators we were able to define class VersionPtr in such a way that its objects could be manipulated just like normal pointers. 7. RELATED WORK The literature abounds with models for version management <ref> [1, 5, 7-9, 13-17, 19-21, 24, 25, 28, 29, 32-34] </ref>. O++ culls out kernel features from these proposals and provides primitives within the framework of an object-oriented language for implementing a variety of versioning models and application-specific systems.
Reference: [6] <author> J. Banerjee, H. T. Chou, J. F. Garza, W. Kim, D. Woelk and N. Ballou, </author> <title> ``Data Model Issues for Object-Oriented Applications'', </title> <journal> ACM Trans. Office Information Systems 5, </journal> <month> 1 (Jan. </month> <year> 1987), </year> <pages> 3-26. </pages>
Reference-contexts: In IRIS [8], a previously unversioned object can be versioned, but it has to go through a transformation procedure. Generic and specific references: Depending upon the application, one should be able to access the latest version or a specific version of an object <ref> [6, 8, 16, 21] </ref>. For example, an address-book object that keeps track of current addresses requires references to the latest versions of person objects to access their latest addresses (generic, dynamic or late binding). <p> In addition, derived-from relationships reflecting the derivation history of the versions of an object should also be maintained to meet the requirements of the design environments in which several versions of a new design may be derived from the same design by making different changes to it <ref> [6, 21, 24] </ref>. The derived-from relationship can be used to store versions by storing their ``differences'' (called deltas [28, 32]). Some current versioning proposals (GemStone [14] and POSTGRES [29], for example) constrain the version relationship of an object to be linear, which is inadequate for design databases. <p> O++ CONSTRUCTS We now discuss how the abstract model presented in the previous section has been incorporated in O++. O++ supports both object ids and version ids. However, an object id does not refer to a generic object header as in <ref> [6, 8] </ref>; rather, it logically refers to the latest version of the object. 3 Therefore, the latest version of an object can be accessed by simply using the object id. <p> If an arrow points directly to a circle, then it refers to a specific version. Dotted arrows between object versions represent the temporal relationship between versions, whereas the solid arrows represent the derived-from relationship. Note that v 1 can be thought of as a revision <ref> [6, 21, 24] </ref> of v 0 . Also, observe that when creating a version, no changes were required in the type definition of this object. <p> 2 based on v 0 , as shown below: p v 1 . . . . . . . . . . . v 0 . . . . . . . . - 7 - v 1 and v 2 can be thought of as a variants or alternatives <ref> [6, 21, 24] </ref>, both derived from v 0 . Finally, we create another version of v 1 with the call newversion (vp1) where vp1 contains the id of version v 1 . <p> Dprevious is used to traverse from a version to the version it was derived from, and Tprevious is used to traverse from a version to the version that temporally precedes the specified version. In a design environment, parallel versions derived from the same ancestor are called alternatives <ref> [6, 21, 24] </ref>, and each path from the root of the derived-from tree to a leaf represents evolution of an alternative design. Each leaf of the tree represents the most up-to-date version of an alternative design. <p> We will first create an initial design state and then change this state by adding new versions. We will design an ALU chip that has several representations <ref> [6, 21, 24] </ref> of which we will only consider three in this example: schematic, fault and timing. Each representation consists of a set of data objects. The schematic representation only consists of the schematic data. <p> The timing representation consists of the schematic data (same as the one in the schematic representation), vectors (same as the one in the fault representation), and timing commands. Thus, the ALU and its representations are complex objects <ref> [6, 21, 24] </ref> that can be modeled using C++ class definition facility.
Reference: [7] <author> D. Batory and W. Kim, </author> <title> ``Modeling Concepts for VLSI CAD Objects'', </title> <journal> ACM Trans. Database Syst. </journal> <volume> 10, </volume> <month> 3 (Sept. </month> <year> 1985), </year> . 
Reference: [8] <author> D. Beech and B. Mahbod, </author> <title> ``Generalized Version Control in an Object-Oriented Database'', </title> <booktitle> Proc. IEEE 4th Int'l Conf. Data Engineering, </booktitle> <address> Los Angeles, California, </address> <month> Feb. </month> <year> 1988, </year> <pages> 14-22. </pages>
Reference-contexts: However, most of the current versioning models do not provide version orthogonality. For example, in ORION [13], only objects of types declared to be versionable can be versioned. In IRIS <ref> [8] </ref>, a previously unversioned object can be versioned, but it has to go through a transformation procedure. Generic and specific references: Depending upon the application, one should be able to access the latest version or a specific version of an object [6, 8, 16, 21]. <p> In IRIS [8], a previously unversioned object can be versioned, but it has to go through a transformation procedure. Generic and specific references: Depending upon the application, one should be able to access the latest version or a specific version of an object <ref> [6, 8, 16, 21] </ref>. For example, an address-book object that keeps track of current addresses requires references to the latest versions of person objects to access their latest addresses (generic, dynamic or late binding). <p> O++ CONSTRUCTS We now discuss how the abstract model presented in the previous section has been incorporated in O++. O++ supports both object ids and version ids. However, an object id does not refer to a generic object header as in <ref> [6, 8] </ref>; rather, it logically refers to the latest version of the object. 3 Therefore, the latest version of an object can be accessed by simply using the object id. <p> Note that the macros can be defined, using the existing C++ macro definition facility, to simplify the task of accessing a specific version in a version history. Each representation can be thought of as a configuration <ref> [8, 9, 13, 16, 21, 33] </ref>. This example amply illustrates how configurations can be created using the facilities provided in O++. In a similar manner, contexts [5, 8, 13, 16, 21] may also be created to specify default versions. 6. <p> Each representation can be thought of as a configuration [8, 9, 13, 16, 21, 33]. This example amply illustrates how configurations can be created using the facilities provided in O++. In a similar manner, contexts <ref> [5, 8, 13, 16, 21] </ref> may also be created to specify default versions. 6. IMPLEMENTATION We are implementing an O++ compiler which translates O++ programs to C++. The resulting C++ code uses a persistence library [10], which contains classes to support, amongst other things, persistent objects and object versions. <p> The other features of the model include version change notification and version percolation. Some of the features of this model are directly supported in O++, and others can be built using the facilities provided in O++. The IRIS version model <ref> [8] </ref> shares many of the features of the ORION version model. In addition, versioning is orthogonal to type, and a previously unversioned object can be versioned, but it has to go through a transformation procedure, which is not required in O++.
Reference: [9] <author> P. A. Bernstein, </author> <title> ``Database Support for Software Engineering'', </title> <booktitle> Proc. 9th IEEE Int'l Conf. </booktitle> <institution> Software Eng., </institution> <month> March </month> <year> 1987, </year> <pages> 166-178. </pages>
Reference-contexts: Note that the macros can be defined, using the existing C++ macro definition facility, to simplify the task of accessing a specific version in a version history. Each representation can be thought of as a configuration <ref> [8, 9, 13, 16, 21, 33] </ref>. This example amply illustrates how configurations can be created using the facilities provided in O++. In a similar manner, contexts [5, 8, 13, 16, 21] may also be created to specify default versions. 6.
Reference: [10] <author> S. J. Buroff and D. Shasha, </author> <title> ``A Persistence Library for C++'', </title> <institution> AT&T Bell Laboratories, </institution> <address> Murray Hill, New Jersey, </address> <year> 1989. </year>
Reference-contexts: In a similar manner, contexts [5, 8, 13, 16, 21] may also be created to specify default versions. 6. IMPLEMENTATION We are implementing an O++ compiler which translates O++ programs to C++. The resulting C++ code uses a persistence library <ref> [10] </ref>, which contains classes to support, amongst other things, persistent objects and object versions. C++ supports inheritance, including multiple inheritance [31], which is used for object specialization. The specialized object types inherit the properties of the ``base'' object type, i.e., the data and functions, of the base object type.
Reference: [11] <author> M. J. Carey, D. J. DeWitt, J. E. Richardson and E. J. Shekita, </author> <title> ``Object and File Management in the EXODUS Extensible Database System'', </title> <booktitle> Proc. 12th Int'l Conf. Very Large Data Bases, </booktitle> <address> Kyoto, Japan, </address> <month> Aug. </month> <year> 1986, </year> <pages> 91-100. </pages>
Reference-contexts: Version-Set is used to collect all of the versions of an object. It provides an insert operation that allows new versions to be added at the end of a version sequence or as an alternative to an existing version. - 15 - The EXODUS storage manager <ref> [11] </ref> provides a general mechanism for implementing a variety of versioning schemes. When an object is updated with the versioning option on, a new version is created. Versions of large objects share common pages.
Reference: [12] <author> M. J. Carey, D. J. DeWitt and S. L. Vandenberg, </author> <title> ``A Data Model and Query Language for EXODUS'', </title> <booktitle> Proc. ACM-SIGMOD 1988 Int'l Conf. on Management of Data, </booktitle> <address> Chicago, Illinois, </address> <month> June </month> <year> 1988, </year> <pages> 413-423. </pages>
Reference-contexts: If some functionality could be realized using existing language facilities, we did not add new language primitives. For example, we consciously decided not to introduce new pointer types (such as own ref in <ref> [12] </ref>) to model composite objects [23] with ``local objects'' which are deleted when the composite object is deleted because this can be simulated using C++ destructors. Similarly, we decided against a built-in change notification facility [13] because users can implement such a facility using O++ triggers.
Reference: [13] <author> H. T. Chou and W. Kim, </author> <title> ``A Unifying Framework for Version Control in a CAD Environment'', </title> <booktitle> Proc. 12th Int'l Conf. on Very Large Databases, </booktitle> <address> Kyoto, Japan, </address> <month> Aug. </month> <year> 1986, </year> <pages> 336-344. </pages>
Reference-contexts: Similarly, we decided against a built-in change notification facility <ref> [13] </ref> because users can implement such a facility using O++ triggers. A critical requirement of CAD applications that is addressed by O++ is support for object versioning. <p> Version orthogonality allows the decision to create a version of an object can be taken on as needed basis, rather at the time of initial database design. However, most of the current versioning models do not provide version orthogonality. For example, in ORION <ref> [13] </ref>, only objects of types declared to be versionable can be versioned. In IRIS [8], a previously unversioned object can be versioned, but it has to go through a transformation procedure. <p> Small changes should have small impact: Small operations should not cause major changes in the database. Thus, we do not provide version percolation <ref> [5, 13, 34] </ref> because creating a new version can lead to the automatic creation of a large number of versions of other objects. Users may implement version percolation as a policy by using other O++ facilities. - 3 - 3. <p> Note that v 3 , v 1 , and v 0 constitute a version history <ref> [13, 21] </ref>. 4.4 Deleting Versions Given an object id, operator pdelete deletes the object and all its versions. Given a version id, pdelete deletes the specified version. <p> Note that the macros can be defined, using the existing C++ macro definition facility, to simplify the task of accessing a specific version in a version history. Each representation can be thought of as a configuration <ref> [8, 9, 13, 16, 21, 33] </ref>. This example amply illustrates how configurations can be created using the facilities provided in O++. In a similar manner, contexts [5, 8, 13, 16, 21] may also be created to specify default versions. 6. <p> Each representation can be thought of as a configuration [8, 9, 13, 16, 21, 33]. This example amply illustrates how configurations can be created using the facilities provided in O++. In a similar manner, contexts <ref> [5, 8, 13, 16, 21] </ref> may also be created to specify default versions. 6. IMPLEMENTATION We are implementing an O++ compiler which translates O++ programs to C++. The resulting C++ code uses a persistence library [10], which contains classes to support, amongst other things, persistent objects and object versions. <p> The persistence model of O++ [2] does not require explicit insertion of persistent objects in a database; such objects automatically persist across program invocations. A comprehensive versioning model for public/private distributed architecture of CAD systems has been developed as part of the ORION project <ref> [13] </ref>. Versions can be transient, working, or released depending upon their location in public, project, or private databases. Versions can be created by checkout and checkin, derivation, and promotion. Only objects of classes declared to be versionable can be versioned.
Reference: [14] <author> G. Copeland and D. Maier, </author> <title> ``Making Smalltalk a Database System'', </title> <booktitle> Proceedings of the 1984 ACM SIGMOD Intl. Conf. on Management of Data, </booktitle> <address> Boston, Massachusetts, </address> <month> June </month> <year> 1984, </year> <pages> 316-325. </pages>
Reference-contexts: Temporal and derived-from relationships: Versions of an object should be ordered temporally according to their creation time, which is important for historical databases, such as those used in accounting, legal, and financial applications, that must access the past states of the database <ref> [14, 29] </ref>, and for supporting time in databases [30]. <p> The derived-from relationship can be used to store versions by storing their ``differences'' (called deltas [28, 32]). Some current versioning proposals (GemStone <ref> [14] </ref> and POSTGRES [29], for example) constrain the version relationship of an object to be linear, which is inadequate for design databases. Small changes should have small impact: Small operations should not cause major changes in the database. <p> The IRIS version model [8] shares many of the features of the ORION version model. In addition, versioning is orthogonal to type, and a previously unversioned object can be versioned, but it has to go through a transformation procedure, which is not required in O++. GemStone <ref> [14] </ref> and POSTGRES [29] allow versioning of objects to capture the history of database states. The version relationship of an object is constrained to be linear. The dynamic binding of version references and the automatic maintenance of temporal relationship between object versions make O++ suitable for developing historical databases.
Reference: [15] <author> J. Diederich and J. Milton, ``ODDESSY: </author> <title> An Object-Oriented Database Design System'', </title> <booktitle> Proc. IEEE 3rd Int'l Conf. Data Engineering, </booktitle> <address> Los Angeles, California, </address> <month> Feb. </month> <year> 1987, </year> <pages> 235-244. </pages>
Reference: [16] <author> K. Dittrich and R. Lorie, </author> <title> ``Version Support for Engineering Database Systems'', </title> <type> Rep. </type> <institution> RJ4769, IBM Research Lab., </institution> <address> San Jose, California, </address> <month> July </month> <year> 1985. </year>
Reference-contexts: In IRIS [8], a previously unversioned object can be versioned, but it has to go through a transformation procedure. Generic and specific references: Depending upon the application, one should be able to access the latest version or a specific version of an object <ref> [6, 8, 16, 21] </ref>. For example, an address-book object that keeps track of current addresses requires references to the latest versions of person objects to access their latest addresses (generic, dynamic or late binding). <p> Note that the macros can be defined, using the existing C++ macro definition facility, to simplify the task of accessing a specific version in a version history. Each representation can be thought of as a configuration <ref> [8, 9, 13, 16, 21, 33] </ref>. This example amply illustrates how configurations can be created using the facilities provided in O++. In a similar manner, contexts [5, 8, 13, 16, 21] may also be created to specify default versions. 6. <p> Each representation can be thought of as a configuration [8, 9, 13, 16, 21, 33]. This example amply illustrates how configurations can be created using the facilities provided in O++. In a similar manner, contexts <ref> [5, 8, 13, 16, 21] </ref> may also be created to specify default versions. 6. IMPLEMENTATION We are implementing an O++ compiler which translates O++ programs to C++. The resulting C++ code uses a persistence library [10], which contains classes to support, amongst other things, persistent objects and object versions.
Reference: [17] <author> K. R. Dittrich, W. Gotthard and P. C. Lockemann, </author> <title> ``DAMOKLES - A Database System for Software Engineering Environments'', </title> <publisher> LNCS 244, </publisher> <year> 1987. </year>
Reference: [18] <author> M. A. Ellis and B. Stroustrup, </author> <title> The Annotated C++ Reference Manual, </title> <publisher> Addison-Wesley, </publisher> <year> 1990. </year>
Reference-contexts: These problems will hopefully go away when C++ is extended with the ``template'' generic facility as has been proposed <ref> [18] </ref>. We also found operator overloading, which is allowed by C++, to be very convenient. By overloading the definitions of the -&gt; and * operators we were able to define class VersionPtr in such a way that its objects could be manipulated just like normal pointers. 7.
Reference: [19] <author> M. F. Hornick and S. B. Zdonik, </author> <title> ``A Shared Segmented Memory System for an Object-Oriented Database'', </title> <journal> ACM Trans. Office Information Systems 5, </journal> <month> 1 (Jan. </month> <year> 1987), </year> <pages> 70-95. </pages>
Reference-contexts: The version relationship of an object is constrained to be linear. The dynamic binding of version references and the automatic maintenance of temporal relationship between object versions make O++ suitable for developing historical databases. Version control in ENCORE <ref> [19] </ref> is realized by introducing two new types: History-Bearing-Entity (HBE) and Version-Set. To create a versioned object, its corresponding type must inherit the properties defined by these two types. Properties defined by HBE include next-version and previous-version.
Reference: [20] <author> S. E. Hudson and R. King, </author> <title> ``Object-Oriented Database Support for Software Environments'', </title> <booktitle> Proc. ACM-SIGMOD 1987 Int'l Conf. on Management of Data, </booktitle> <address> San Fransisco, California, </address> <month> May </month> <year> 1987, </year> <pages> 491-503. </pages>
Reference: [21] <author> R. Katz, E. Chang and E. Bhateja, </author> <title> ``Version Modeling Concepts for Computer-Aided Design Databases'', </title> <booktitle> Proc. ACM-SIGMOD 1986 Int'l Conf. on Management of Data, </booktitle> <address> Washington D.C., </address> <month> May </month> <year> 1986. </year>
Reference-contexts: In IRIS [8], a previously unversioned object can be versioned, but it has to go through a transformation procedure. Generic and specific references: Depending upon the application, one should be able to access the latest version or a specific version of an object <ref> [6, 8, 16, 21] </ref>. For example, an address-book object that keeps track of current addresses requires references to the latest versions of person objects to access their latest addresses (generic, dynamic or late binding). <p> In addition, derived-from relationships reflecting the derivation history of the versions of an object should also be maintained to meet the requirements of the design environments in which several versions of a new design may be derived from the same design by making different changes to it <ref> [6, 21, 24] </ref>. The derived-from relationship can be used to store versions by storing their ``differences'' (called deltas [28, 32]). Some current versioning proposals (GemStone [14] and POSTGRES [29], for example) constrain the version relationship of an object to be linear, which is inadequate for design databases. <p> If an arrow points directly to a circle, then it refers to a specific version. Dotted arrows between object versions represent the temporal relationship between versions, whereas the solid arrows represent the derived-from relationship. Note that v 1 can be thought of as a revision <ref> [6, 21, 24] </ref> of v 0 . Also, observe that when creating a version, no changes were required in the type definition of this object. <p> 2 based on v 0 , as shown below: p v 1 . . . . . . . . . . . v 0 . . . . . . . . - 7 - v 1 and v 2 can be thought of as a variants or alternatives <ref> [6, 21, 24] </ref>, both derived from v 0 . Finally, we create another version of v 1 with the call newversion (vp1) where vp1 contains the id of version v 1 . <p> Note that v 3 , v 1 , and v 0 constitute a version history <ref> [13, 21] </ref>. 4.4 Deleting Versions Given an object id, operator pdelete deletes the object and all its versions. Given a version id, pdelete deletes the specified version. <p> Dprevious is used to traverse from a version to the version it was derived from, and Tprevious is used to traverse from a version to the version that temporally precedes the specified version. In a design environment, parallel versions derived from the same ancestor are called alternatives <ref> [6, 21, 24] </ref>, and each path from the root of the derived-from tree to a leaf represents evolution of an alternative design. Each leaf of the tree represents the most up-to-date version of an alternative design. <p> We will first create an initial design state and then change this state by adding new versions. We will design an ALU chip that has several representations <ref> [6, 21, 24] </ref> of which we will only consider three in this example: schematic, fault and timing. Each representation consists of a set of data objects. The schematic representation only consists of the schematic data. <p> The timing representation consists of the schematic data (same as the one in the schematic representation), vectors (same as the one in the fault representation), and timing commands. Thus, the ALU and its representations are complex objects <ref> [6, 21, 24] </ref> that can be modeled using C++ class definition facility. <p> Note that the macros can be defined, using the existing C++ macro definition facility, to simplify the task of accessing a specific version in a version history. Each representation can be thought of as a configuration <ref> [8, 9, 13, 16, 21, 33] </ref>. This example amply illustrates how configurations can be created using the facilities provided in O++. In a similar manner, contexts [5, 8, 13, 16, 21] may also be created to specify default versions. 6. <p> Each representation can be thought of as a configuration [8, 9, 13, 16, 21, 33]. This example amply illustrates how configurations can be created using the facilities provided in O++. In a similar manner, contexts <ref> [5, 8, 13, 16, 21] </ref> may also be created to specify default versions. 6. IMPLEMENTATION We are implementing an O++ compiler which translates O++ programs to C++. The resulting C++ code uses a persistence library [10], which contains classes to support, amongst other things, persistent objects and object versions. <p> Version histories (instances over time), configurations (compositions of specific versions of component objects of a complex object), and equivalences (different views of an object) have been proposed in <ref> [21] </ref> as a framework for organizing design databases that evolve over time. Version histories are organized as trees. Versions in a configuration can be bound statically or dynamically. This framework can easily be implemented by using the facilities provided in O++ as illustrated by the design example in Section 5.
Reference: [22] <author> S. N. Khoshafian and G. P. Copeland, </author> <title> ``Object Identity'', </title> <booktitle> Proc. OOPSLA '86, </booktitle> <address> Portland, Oregon, </address> <month> Sept. </month> <year> 1986, </year> <pages> 406-416. </pages>
Reference-contexts: Volatile objects are allocated in volatile memory and are the same as those created in ordinary programs. Persistent objects are allocated in persistent store and they continue to exist after the program that created them has terminated. Each persistent object is identified by a unique object identity <ref> [22] </ref>. The object identity is referred to as a pointer to a persistent object. A persistent object can be created using the persistent storage operator pnew. Here is an example: __________________ 3. We do not discuss concurrency control issues in this paper.
Reference: [23] <author> W. Kim, E. Bertino and J. Garza, </author> <title> ``Composite Objects Revisited'', </title> <booktitle> Proc. ACM-SIGMOD 1989 Int'l Conf. Management of Data, </booktitle> <address> Portland, Oregon, </address> <month> May-June </month> <year> 1989. </year>
Reference-contexts: If some functionality could be realized using existing language facilities, we did not add new language primitives. For example, we consciously decided not to introduce new pointer types (such as own ref in [12]) to model composite objects <ref> [23] </ref> with ``local objects'' which are deleted when the composite object is deleted because this can be simulated using C++ destructors. Similarly, we decided against a built-in change notification facility [13] because users can implement such a facility using O++ triggers.
Reference: [24] <author> P. Klahold, G. Schlageter and W. Wilkes, </author> <title> ``A General Model for Version Management in Databases'', </title> <booktitle> Proc. 12th Int'l Conf. Very Large Data Bases, </booktitle> <address> Kyoto, Japan, </address> <month> Aug. </month> <year> 1986, </year> <pages> 319-327. </pages>
Reference-contexts: It may also be said that these applications are the primary force driving the current interest in the object-oriented database systems. At present, there is little agreement on one uniform model for design databases, although some recent papers have articulated major needs <ref> [1, 5, 7-9, 13-17, 19-21, 24, 25, 28, 29, 32-34] </ref>. Consequently, O++ does not come with a ``hardwired'' design database model; instead, it provides facilities with which users can develop customized models that match their needs. In designing O++, we have distinguished between primitives and policies. <p> Similarly, we decided against a built-in change notification facility [13] because users can implement such a facility using O++ triggers. A critical requirement of CAD applications that is addressed by O++ is support for object versioning. Our design, although inspired by many of the earlier proposals <ref> [1, 5, 7-9, 13-17, 19-21, 24, 25, 28, 29, 32-34] </ref>, differs significantly from them in that we focus on introducing a minimum number of concepts with precise semantics and integrating them seamlessly in a programming language. <p> In addition, derived-from relationships reflecting the derivation history of the versions of an object should also be maintained to meet the requirements of the design environments in which several versions of a new design may be derived from the same design by making different changes to it <ref> [6, 21, 24] </ref>. The derived-from relationship can be used to store versions by storing their ``differences'' (called deltas [28, 32]). Some current versioning proposals (GemStone [14] and POSTGRES [29], for example) constrain the version relationship of an object to be linear, which is inadequate for design databases. <p> If an arrow points directly to a circle, then it refers to a specific version. Dotted arrows between object versions represent the temporal relationship between versions, whereas the solid arrows represent the derived-from relationship. Note that v 1 can be thought of as a revision <ref> [6, 21, 24] </ref> of v 0 . Also, observe that when creating a version, no changes were required in the type definition of this object. <p> 2 based on v 0 , as shown below: p v 1 . . . . . . . . . . . v 0 . . . . . . . . - 7 - v 1 and v 2 can be thought of as a variants or alternatives <ref> [6, 21, 24] </ref>, both derived from v 0 . Finally, we create another version of v 1 with the call newversion (vp1) where vp1 contains the id of version v 1 . <p> Dprevious is used to traverse from a version to the version it was derived from, and Tprevious is used to traverse from a version to the version that temporally precedes the specified version. In a design environment, parallel versions derived from the same ancestor are called alternatives <ref> [6, 21, 24] </ref>, and each path from the root of the derived-from tree to a leaf represents evolution of an alternative design. Each leaf of the tree represents the most up-to-date version of an alternative design. <p> We will first create an initial design state and then change this state by adding new versions. We will design an ALU chip that has several representations <ref> [6, 21, 24] </ref> of which we will only consider three in this example: schematic, fault and timing. Each representation consists of a set of data objects. The schematic representation only consists of the schematic data. <p> The timing representation consists of the schematic data (same as the one in the schematic representation), vectors (same as the one in the fault representation), and timing commands. Thus, the ALU and its representations are complex objects <ref> [6, 21, 24] </ref> that can be modeled using C++ class definition facility. <p> By overloading the definitions of the -&gt; and * operators we were able to define class VersionPtr in such a way that its objects could be manipulated just like normal pointers. 7. RELATED WORK The literature abounds with models for version management <ref> [1, 5, 7-9, 13-17, 19-21, 24, 25, 28, 29, 32-34] </ref>. O++ culls out kernel features from these proposals and provides primitives within the framework of an object-oriented language for implementing a variety of versioning models and application-specific systems. <p> Versions in a configuration can be bound statically or dynamically. This framework can easily be implemented by using the facilities provided in O++ as illustrated by the design example in Section 5. A version management model based on the concept of version environments has been proposed in <ref> [24] </ref>. A version environment offers mechanisms for ordering versions by various relationships (time, derived-from, etc.) and partitioning versions according to specific properties (valid, invalid, in-progress, alternative, effective, etc.).
Reference: [25] <author> D. McLeod, K. Narayanaswamy and K. B. Rao, </author> <title> ``An Approach to Information Management for CAD/VLSI Applications'', </title> <booktitle> Proc. Databases for Engineering Applications, ACM-SIGMOD Database Week 1983, </booktitle> <address> San Jose, California, </address> <month> May </month> <year> 1983, </year> <pages> 115-121. </pages>
Reference-contexts: It may also be said that these applications are the primary force driving the current interest in the object-oriented database systems. At present, there is little agreement on one uniform model for design databases, although some recent papers have articulated major needs <ref> [1, 5, 7-9, 13-17, 19-21, 24, 25, 28, 29, 32-34] </ref>. Consequently, O++ does not come with a ``hardwired'' design database model; instead, it provides facilities with which users can develop customized models that match their needs. In designing O++, we have distinguished between primitives and policies. <p> Similarly, we decided against a built-in change notification facility [13] because users can implement such a facility using O++ triggers. A critical requirement of CAD applications that is addressed by O++ is support for object versioning. Our design, although inspired by many of the earlier proposals <ref> [1, 5, 7-9, 13-17, 19-21, 24, 25, 28, 29, 32-34] </ref>, differs significantly from them in that we focus on introducing a minimum number of concepts with precise semantics and integrating them seamlessly in a programming language. <p> By overloading the definitions of the -&gt; and * operators we were able to define class VersionPtr in such a way that its objects could be manipulated just like normal pointers. 7. RELATED WORK The literature abounds with models for version management <ref> [1, 5, 7-9, 13-17, 19-21, 24, 25, 28, 29, 32-34] </ref>. O++ culls out kernel features from these proposals and provides primitives within the framework of an object-oriented language for implementing a variety of versioning models and application-specific systems.
Reference: [26] <author> Z. Mehmood, D. Singer, A. Singhal and K. W. Wu, </author> <title> ``A Data Management System for CAD'', </title> <booktitle> Proc. of ICCAD Conference, </booktitle> <year> 1987. </year>
Reference-contexts: DMS: A CAD DATABASE EXAMPLE To illustrate the use of O++ versioning facilities, we will model a CAD design evolution. This example is an abbreviated version of our simulation of the DMS design database system <ref> [26] </ref> being used in our VLSI design laboratory. We will first create an initial design state and then change this state by adding new versions.
Reference: [27] <author> J. E. Richardson and M. J. Carey, </author> <title> ``Persistence in the E Language: Issues and Implementation'', </title> <note> SoftwarePractice & Experience 19, 12 (Dec. </note> <year> 1989), </year> <pages> 1115-1150. </pages>
Reference-contexts: When an object is updated with the versioning option on, a new version is created. Versions of large objects share common pages. However, at present E programmers <ref> [27] </ref> cannot make use of the versioning capability provided by the storage manager. 8.
Reference: [28] <author> M. Rochkind, </author> <title> ``The Source Code Control System'', </title> <journal> IEEE Trans. Software Eng. </journal> <volume> SE-1, </volume> <month> 4 (Dec. </month> <year> 1975), </year> <pages> 364-370. </pages>
Reference-contexts: It may also be said that these applications are the primary force driving the current interest in the object-oriented database systems. At present, there is little agreement on one uniform model for design databases, although some recent papers have articulated major needs <ref> [1, 5, 7-9, 13-17, 19-21, 24, 25, 28, 29, 32-34] </ref>. Consequently, O++ does not come with a ``hardwired'' design database model; instead, it provides facilities with which users can develop customized models that match their needs. In designing O++, we have distinguished between primitives and policies. <p> Similarly, we decided against a built-in change notification facility [13] because users can implement such a facility using O++ triggers. A critical requirement of CAD applications that is addressed by O++ is support for object versioning. Our design, although inspired by many of the earlier proposals <ref> [1, 5, 7-9, 13-17, 19-21, 24, 25, 28, 29, 32-34] </ref>, differs significantly from them in that we focus on introducing a minimum number of concepts with precise semantics and integrating them seamlessly in a programming language. <p> The derived-from relationship can be used to store versions by storing their ``differences'' (called deltas <ref> [28, 32] </ref>). Some current versioning proposals (GemStone [14] and POSTGRES [29], for example) constrain the version relationship of an object to be linear, which is inadequate for design databases. Small changes should have small impact: Small operations should not cause major changes in the database. <p> By overloading the definitions of the -&gt; and * operators we were able to define class VersionPtr in such a way that its objects could be manipulated just like normal pointers. 7. RELATED WORK The literature abounds with models for version management <ref> [1, 5, 7-9, 13-17, 19-21, 24, 25, 28, 29, 32-34] </ref>. O++ culls out kernel features from these proposals and provides primitives within the framework of an object-oriented language for implementing a variety of versioning models and application-specific systems.
Reference: [29] <author> L. A. Rowe and M. R. Stonebraker, </author> <title> ``The POSTGRES Data Model'', </title> <booktitle> Proc. 13th Int'l Conf. Very Large Data Bases, </booktitle> <address> Brighton, England, </address> <month> Sept. </month> <year> 1987, </year> <pages> 83-96. </pages>
Reference-contexts: It may also be said that these applications are the primary force driving the current interest in the object-oriented database systems. At present, there is little agreement on one uniform model for design databases, although some recent papers have articulated major needs <ref> [1, 5, 7-9, 13-17, 19-21, 24, 25, 28, 29, 32-34] </ref>. Consequently, O++ does not come with a ``hardwired'' design database model; instead, it provides facilities with which users can develop customized models that match their needs. In designing O++, we have distinguished between primitives and policies. <p> Similarly, we decided against a built-in change notification facility [13] because users can implement such a facility using O++ triggers. A critical requirement of CAD applications that is addressed by O++ is support for object versioning. Our design, although inspired by many of the earlier proposals <ref> [1, 5, 7-9, 13-17, 19-21, 24, 25, 28, 29, 32-34] </ref>, differs significantly from them in that we focus on introducing a minimum number of concepts with precise semantics and integrating them seamlessly in a programming language. <p> Temporal and derived-from relationships: Versions of an object should be ordered temporally according to their creation time, which is important for historical databases, such as those used in accounting, legal, and financial applications, that must access the past states of the database <ref> [14, 29] </ref>, and for supporting time in databases [30]. <p> The derived-from relationship can be used to store versions by storing their ``differences'' (called deltas [28, 32]). Some current versioning proposals (GemStone [14] and POSTGRES <ref> [29] </ref>, for example) constrain the version relationship of an object to be linear, which is inadequate for design databases. Small changes should have small impact: Small operations should not cause major changes in the database. <p> By overloading the definitions of the -&gt; and * operators we were able to define class VersionPtr in such a way that its objects could be manipulated just like normal pointers. 7. RELATED WORK The literature abounds with models for version management <ref> [1, 5, 7-9, 13-17, 19-21, 24, 25, 28, 29, 32-34] </ref>. O++ culls out kernel features from these proposals and provides primitives within the framework of an object-oriented language for implementing a variety of versioning models and application-specific systems. <p> The IRIS version model [8] shares many of the features of the ORION version model. In addition, versioning is orthogonal to type, and a previously unversioned object can be versioned, but it has to go through a transformation procedure, which is not required in O++. GemStone [14] and POSTGRES <ref> [29] </ref> allow versioning of objects to capture the history of database states. The version relationship of an object is constrained to be linear. The dynamic binding of version references and the automatic maintenance of temporal relationship between object versions make O++ suitable for developing historical databases.
Reference: [30] <author> R. Snodgrass and I. Ahn, </author> <title> ``A Taxonomy of Time in Databases'', </title> <booktitle> Proc. ACM-SIGMOD 1985 Int'l Conf. on Management of Data, </booktitle> <address> Austin, Texas, </address> <month> May </month> <year> 1985. </year>
Reference-contexts: Temporal and derived-from relationships: Versions of an object should be ordered temporally according to their creation time, which is important for historical databases, such as those used in accounting, legal, and financial applications, that must access the past states of the database [14, 29], and for supporting time in databases <ref> [30] </ref>.
Reference: [31] <author> B. Stroustrup, </author> <title> ``Multiple Inheritance for C++'', </title> <booktitle> Proc. European UNIX User's Group, </booktitle> <address> Helsinki, </address> <month> May </month> <year> 1987, </year> <pages> 189-208. </pages>
Reference-contexts: IMPLEMENTATION We are implementing an O++ compiler which translates O++ programs to C++. The resulting C++ code uses a persistence library [10], which contains classes to support, amongst other things, persistent objects and object versions. C++ supports inheritance, including multiple inheritance <ref> [31] </ref>, which is used for object specialization. The specialized object types inherit the properties of the ``base'' object type, i.e., the data and functions, of the base object type. We use the inheritance property in the implementation of versions.
Reference: [32] <author> W. Tichy, ``RCS: </author> <title> A System for Version Control'', </title> <journal> Software Practice and Experience 15, </journal> <month> 7 (July </month> <year> 1986), </year> <pages> 637-654. </pages>
Reference-contexts: The derived-from relationship can be used to store versions by storing their ``differences'' (called deltas <ref> [28, 32] </ref>). Some current versioning proposals (GemStone [14] and POSTGRES [29], for example) constrain the version relationship of an object to be linear, which is inadequate for design databases. Small changes should have small impact: Small operations should not cause major changes in the database.
Reference: [33] <author> W. Tichy, </author> <title> ``Tools for Software Configuration Management'', Int'l Workshop Software Version and Configuration Control, </title> <address> Grassau, FRG, </address> <month> Jan. </month> <year> 1988. </year>
Reference-contexts: Note that the macros can be defined, using the existing C++ macro definition facility, to simplify the task of accessing a specific version in a version history. Each representation can be thought of as a configuration <ref> [8, 9, 13, 16, 21, 33] </ref>. This example amply illustrates how configurations can be created using the facilities provided in O++. In a similar manner, contexts [5, 8, 13, 16, 21] may also be created to specify default versions. 6.
Reference: [34] <author> S. B. Zdonik, </author> <title> ``Version Management in an Object-Oriented Database'', </title> <booktitle> Proc. Int'l Workshop on Advanced Programming Environments, </booktitle> <address> Trondheim, Norway, </address> <month> June </month> <year> 1986. </year>
Reference-contexts: Small changes should have small impact: Small operations should not cause major changes in the database. Thus, we do not provide version percolation <ref> [5, 13, 34] </ref> because creating a new version can lead to the automatic creation of a large number of versions of other objects. Users may implement version percolation as a policy by using other O++ facilities. - 3 - 3.
References-found: 34

