URL: ftp://ftp.pmg.lcs.mit.edu/pub/castro/typesafe.ps.gz
Refering-URL: http://www.pmg.lcs.mit.edu/~castro/pubs.html
Root-URL: 
Title: Type-Safe Heterogeneous Sharing can be Fast  
Author: B. Liskov, A. Adya, M. Castro, Q. Zondervan 
Address: Cambridge, MA 02139  
Affiliation: Laboratory for Computer Science, MIT,  
Abstract: Safe sharing is a desirable feature of an object oriented database because it protects valuable database objects from program errors in application code. It is especially desirable in a heterogeneous environment in which applications are written in various programming languages, many of which have unsafe features. However, safe sharing is not without its potential performance costs. This paper explores these costs. It describes a number of techniques that improve performance without sacrificing safety, and presents results of experiments that evaluate their effectiveness. The results show that some of these techniques are very promising, allowing safe sharing to be achieved with essentially no performance penalty. Keywords: Object-oriented databases, object-oriented languages, type-safe languages, heterogeneity, performance. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> A. Adya, R. Gruber, B. Liskov, and U. Maheshwari. </author> <title> Efficient optimistic concurrency control using loosely synchronized clocks. </title> <booktitle> In ACM SIGMOD Int. Conf. on Management of Data, </booktitle> <pages> pages 23-34, </pages> <address> San Jose, CA, </address> <month> May </month> <year> 1995. </year>
Reference-contexts: If the commit succeeds, we guarantee that the transaction is serialized with respect to all other transactions, and that all its modifications to the persistent universe are recorded reliably <ref> [1] </ref>. Method calls return either values or handles. A value is an integer, boolean, character, or real. A handle is a short-lived pointer to a Thor object.
Reference: [2] <author> Phillip Bogle and Barbara Liskov. </author> <title> Reducing cross-domain call overhead using batched futures. </title> <booktitle> In OOPSLA '94, </booktitle> <year> 1994. </year>
Reference-contexts: More information about Theta can be found in [9, 15]. All type definitions and implementations are stored in Thor. The type definitions constitute a schema library that can be used for browsing, for compilation of Theta programs, and for producing programming language veneers as discussed next. A veneer <ref> [2] </ref> is a small extension to a programming language that makes it easy for programs written in that language to use Thor. <p> Experience shows that defining a new veneer is not very difficult. It is not necessary to modify the language compiler. Also veneers can be easily provided regardless of whether the application language provides support for objects. More information about veneers can be found in <ref> [2, 14] </ref>. 3 Safe Sharing Techniques The simplest way of achieving safe sharing is by keeping the application and the database in separate protection domains, which might run on the same or on different machines; we will refer to this as the all-outside approach. <p> Rather than having a crossing for each call, it groups calls into batches, and sends the entire batch to the database in one crossing. Thus, X is divided by the average batch size. Earlier work <ref> [2] </ref> investigated one way of doing batching, called batched futures.
Reference: [3] <author> M. Carey et al. </author> <title> The EXODUS extensible DBMS project: An overview. </title> <booktitle> In Readings in Object-Oriented Database Systems, </booktitle> <pages> pages 474-499. </pages> <publisher> Morgan Kaufmann, </publisher> <year> 1990. </year>
Reference-contexts: Support for safe sharing is not without its potential performance costs, and other systems have chosen to forgo safety for improved performance. Many systems, e.g., <ref> [4, 12, 3] </ref> allow the application code to directly manipulate database objects; ODMG [7] also follows this approach because it allows methods of shared objects to be written in various unsafe programming languages.
Reference: [4] <author> Michael J. Carey, David J. DeWitt, Michael J. Franklin, Nancy E. Hall, Mark L. McAuliffe, Jeffrey F. Naughton, Daniel T. Schuh, Mar-vin H. Solomon, C. K. Tan, Odysseas G. Tsatalos, Seth J. White, and Michael J. Zwilling. </author> <title> Shoring up persistent applications. </title> <booktitle> In ACM SIGMOD Int. Conf. on Management of Data, </booktitle> <address> Minneapolis, MN, </address> <month> May </month> <year> 1994. </year>
Reference-contexts: Support for safe sharing is not without its potential performance costs, and other systems have chosen to forgo safety for improved performance. Many systems, e.g., <ref> [4, 12, 3] </ref> allow the application code to directly manipulate database objects; ODMG [7] also follows this approach because it allows methods of shared objects to be written in various unsafe programming languages.
Reference: [5] <author> Michael J. Carey, David J. DeWitt, and Jeffrey F. Naughton. </author> <title> The OO7 benchmark. </title> <booktitle> In Proceedings of the 1993 ACM SIGMOD International Conference on Management of Data, </booktitle> <pages> pages 12-21, </pages> <address> Washington, DC, </address> <month> May </month> <year> 1993. </year>
Reference-contexts: A batch is sent to the database when the application makes a call that requires an immediate response, such as a call that returns a value. Although this approach does improve performance (over an approach that has one domain crossing per call), experiments with OO7 <ref> [5] </ref> showed that the average batch size was low (3.27), and this limited the amount of speed up. This led us to investigate a second approach, batched control structures [18], in which batches corresponding to entire loops can be constructed. <p> The cost of ping-ponging an integer between the client and the FE is 31s. The experiments ran the single-user OO7 benchmark <ref> [5] </ref>. The OO7 database contains a tree of assembly objects, with a height of 7; each non-leaf assembly has three children. The leaves point to three composite parts chosen randomly from among 500 such objects.
Reference: [6] <author> Michael J. Carey, David J. DeWitt, and Jeffrey F. Naughton. </author> <title> The OO7 benchmark. </title> <type> Technical Report; Revised Version dated 7/21/1994 1140, </type> <institution> University of Wisconsin-Madison, </institution> <year> 1994. </year> <note> WWW users: see URL ftp://ftp.cs.wisc.edu/OO7. </note>
Reference-contexts: Each composite part contains a graph of atomic parts linked by connection objects; each atomic part has 3 outgoing connections. The (small) database has 20 atomic parts per composite part and a total size of 7 MB. We implemented the database in Theta, following the specification of OO7 <ref> [6] </ref> closely. We report results for traversal T1, which performs a depth-first, read-only traversal of the assembly tree and executes an operation on the composite parts referenced by the leaves of this tree. This operation is a depth-first, read-only traversal of the entire graph of a composite part. <p> Table 2 presents a breakdown of the execution time for the all-outside experiment; it shows that context switching is the dominant overhead in this case. The table allows us to 1 This is in fact the way that the OO7 traversal is supposed to run according to <ref> [6] </ref>. 6 sharing techniques. Experiment N all-outside 450886 batching 450886 same-process 450886 part-inside 9112 all-inside 1 Table 1: Number of cross domain calls. compute the parameters of the analytic model presented in EQN, obtaining C = 49s, S = 13:5s, and R = 0:7s.
Reference: [7] <author> R. G. Cattell, </author> <title> editor. The Object Database Standard: ODMG-93. </title> <publisher> Morgan Kaufmann Publishers, Inc., </publisher> <address> San Mateo, CA, </address> <year> 1994. </year>
Reference-contexts: Support for safe sharing is not without its potential performance costs, and other systems have chosen to forgo safety for improved performance. Many systems, e.g., [4, 12, 3] allow the application code to directly manipulate database objects; ODMG <ref> [7] </ref> also follows this approach because it allows methods of shared objects to be written in various unsafe programming languages. O2 [10] and GemStone [16] store methods in the database, which means that it is possible to guarantee that the right code runs in response to application calls.
Reference: [8] <institution> Digital Equipment Company. </institution> <note> OSF/1 Manual Page. </note>
Reference-contexts: We found that the performance of our experiments was very sensitive to the layout of code in memory (we observed differences as large as 30%). Therefore, in order to reduce the noise due to misses in the code cache, we used cord and ftoc <ref> [8] </ref>, two utilities that reorder procedures in an executable by decreasing density (i.e. ratio of cycles spent executing the procedure to its static size). We used cord to obtain different executables optimized for each particular experiment.
Reference: [9] <author> Mark Day, Robert Gruber, Barbara Liskov, and An-drew C. Myers. </author> <title> Abstraction mechanisms in Theta. Junk. Do not cite. </title> <note> See where-clauses instead. </note>
Reference-contexts: Code is implemented using a new programming language called Theta <ref> [9, 15] </ref>. Applications are implemented in a programming language augmented by a veneer 2 that makes it easy for the application to interact with Thor. Theta is a strongly-typed language that guarantees that objects can be used only by calling their methods. <p> It provides support for both parametric and subtype polymorphism, and it separates code inheritance from the subtyping mechanism. More information about Theta can be found in <ref> [9, 15] </ref>. All type definitions and implementations are stored in Thor. The type definitions constitute a schema library that can be used for browsing, for compilation of Theta programs, and for producing programming language veneers as discussed next.
Reference: [10] <author> O. </author> <title> Deux et al. </title> <journal> The story of O 2 . IEEE Transactions on Knowledge and Data Engineering, </journal> <volume> 2(1) </volume> <pages> 91-108, </pages> <month> March </month> <year> 1990. </year>
Reference-contexts: Many systems, e.g., [4, 12, 3] allow the application code to directly manipulate database objects; ODMG [7] also follows this approach because it allows methods of shared objects to be written in various unsafe programming languages. O2 <ref> [10] </ref> and GemStone [16] store methods in the database, which means that it is possible to guarantee that the right code runs in response to application calls. However, the languages provided by O2 for method definition are not safe (for example, one of these languages is an extension of C).
Reference: [11] <author> B. Liskov et al. </author> <title> The language-independent interface of the Thor persistent object system. </title> <booktitle> In Object-Oriented Multi-Database Systems, </booktitle> <pages> pages 570-588. </pages> <publisher> Prentice Hall, </publisher> <year> 1996. </year>
Reference-contexts: Section 4 presents the results of our performance experiments. We conclude in Section 5 with a summary of what we have accomplished. 2 The Thor System Interface Thor is a new object-oriented database system intended for use in heterogeneous distributed systems <ref> [11] </ref>. It provides highly-reliable and highly available storage so that persistent objects are likely to be accessible when needed in spite of failures. It supports heterogeneity at the machine, network, operating system, and especially programming language levels.
Reference: [12] <author> Charles Lamb, Gordon Landis, Jack Orenstein, and Dan Wei nreb. </author> <title> The ObjectStore database system. </title> <journal> Communications of the ACM, </journal> <volume> 34(10) </volume> <pages> 50-63, </pages> <month> October </month> <year> 1991. </year>
Reference-contexts: Support for safe sharing is not without its potential performance costs, and other systems have chosen to forgo safety for improved performance. Many systems, e.g., <ref> [4, 12, 3] </ref> allow the application code to directly manipulate database objects; ODMG [7] also follows this approach because it allows methods of shared objects to be written in various unsafe programming languages.
Reference: [13] <author> Tim Lindholm and Frank Yellin. </author> <title> The Java Virtual Machine. </title> <publisher> Addison-Wesley, </publisher> <address> Englewood Cliffs, NJ, </address> <month> May </month> <year> 1996. </year>
Reference-contexts: This approach has the disadvantage of requiring safe subsets of various application languages to be defined; a more serious disadvantage is that a compiler is needed for each application lan guage. 3. Translate the application code to Java <ref> [13] </ref> bytecodes. As in the previous approach, we assume that a procedure without free variables is being translated.
Reference: [14] <author> Barbara Liskov, Atul Adya, Miguel Castro, Mark Day, Sanjay Ghemawat, Robert Gruber, Umesh Mahesh-wari, Andrew C. Myers, and Liuba Shrira. </author> <title> Safe and efficient sharing of persistent objects in thor. </title> <booktitle> In Proceedings of SIGMOD '96, </booktitle> <year> 1996. </year>
Reference-contexts: Experience shows that defining a new veneer is not very difficult. It is not necessary to modify the language compiler. Also veneers can be easily provided regardless of whether the application language provides support for objects. More information about veneers can be found in <ref> [2, 14] </ref>. 3 Safe Sharing Techniques The simplest way of achieving safe sharing is by keeping the application and the database in separate protection domains, which might run on the same or on different machines; we will refer to this as the all-outside approach.
Reference: [15] <author> Barbara Liskov, Dorothy Curtis, Mark Day, Sanjay Ghemawat, Robert Gruber, Paul Johnson, and Andrew C. Myers. </author> <title> Theta Reference Manual. Programming Methodology Group Memo 88, </title> <institution> MIT Laboratory for Computer Science, </institution> <address> Cambridge, MA, </address> <month> February </month> <year> 1994. </year> <note> Available at http://www.pmg.lcs.mit.edu/papers/thetaref/. </note>
Reference-contexts: Code is implemented using a new programming language called Theta <ref> [9, 15] </ref>. Applications are implemented in a programming language augmented by a veneer 2 that makes it easy for the application to interact with Thor. Theta is a strongly-typed language that guarantees that objects can be used only by calling their methods. <p> It provides support for both parametric and subtype polymorphism, and it separates code inheritance from the subtyping mechanism. More information about Theta can be found in <ref> [9, 15] </ref>. All type definitions and implementations are stored in Thor. The type definitions constitute a schema library that can be used for browsing, for compilation of Theta programs, and for producing programming language veneers as discussed next.
Reference: [16] <author> D. Maier and J. Stein. </author> <title> Development and implementation of an object-oriented DBMS. </title> <editor> In B. Shriver and P. Wegner, editors, </editor> <booktitle> Research Directions in Object-Oriented Programming. </booktitle> <publisher> MIT Press, </publisher> <year> 1987. </year>
Reference-contexts: Many systems, e.g., [4, 12, 3] allow the application code to directly manipulate database objects; ODMG [7] also follows this approach because it allows methods of shared objects to be written in various unsafe programming languages. O2 [10] and GemStone <ref> [16] </ref> store methods in the database, which means that it is possible to guarantee that the right code runs in response to application calls. However, the languages provided by O2 for method definition are not safe (for example, one of these languages is an extension of C).
Reference: [17] <author> Robert Wahbe, Steven Lucco, Thomas E. Anderson, and Susan L. Graham. </author> <title> Efficient software-based fault isolation. </title> <booktitle> In 14th ACM Symp. on Operating System Principles, </booktitle> <pages> pages 203-216, </pages> <address> Asheville, NC, </address> <month> December </month> <year> 1993. </year>
Reference-contexts: In the third case the byte-code verifier does most of the type checking, although a few checks are left for runtime. 3.3 Sandboxing The final technique for reducing the cost of safe sharing is to transfer object code into the database and use a sandboxing technique <ref> [17] </ref> to provide safety. This technique basically involves putting (unsafe) application code/data in a restricted range of virtual memory addresses and then allowing the application code to access only these addresses. <p> However, the cost of a domain crossing (C) is greatly reduced. Sandboxing (like the code transfer techniques) requires both validation and checking. Sandboxed code is validated using an object code verifier <ref> [17] </ref>. Checking must be done on every call made from the sandboxed code to the database; thus each call still incurs a cost S. <p> The traversal still makes N = 450886 calls to database object methods; each of these requires a fault domain crossing, but we have assumed that these crossings have zero cost (C = 0). We also neglect the overheads of running sandboxed client code; according to <ref> [17] </ref> sandboxed client code runs approximately 20% slower. Therefore we are only left with the cost S for making and type checking the calls.
Reference: [18] <author> Quinton Y. Zondervan. </author> <title> Increasing cross-domain call batching using promises and batched control structures. </title> <type> Technical Report MIT/LCS/TR-658, </type> <institution> Laboratory for Computer Science, MIT, </institution> <address> Cambridge, MA, </address> <month> June </month> <year> 1995. </year> <type> Master's thesis. 9 </type>
Reference-contexts: Although this approach does improve performance (over an approach that has one domain crossing per call), experiments with OO7 [5] showed that the average batch size was low (3.27), and this limited the amount of speed up. This led us to investigate a second approach, batched control structures <ref> [18] </ref>, in which batches corresponding to entire loops can be constructed. This approach gives much higher batching factors, and thus reduces X substantially. It also reduces S. A batch describes a loop by containing a description of each call in a single iteration of the loop.
References-found: 18

