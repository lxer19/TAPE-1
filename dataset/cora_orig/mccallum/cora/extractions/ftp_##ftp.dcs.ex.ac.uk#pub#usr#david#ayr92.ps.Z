URL: ftp://ftp.dcs.ex.ac.uk/pub/usr/david/ayr92.ps.Z
Refering-URL: http://www.dcs.ex.ac.uk/~david/research/york.html
Root-URL: http://www.dcs.ex.ac.uk
Title: Heap Profiling of a Lazy Functional Compiler  
Author: Colin Runciman and David Wakeling 
Affiliation: University of York  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> L. Augustsson and T. Johnsson. </author> <title> The Chalmers Lazy-ML Compiler. </title> <journal> Computer Journal, </journal> <volume> 32(2) </volume> <pages> 127-141, </pages> <month> April </month> <year> 1989. </year>
Reference-contexts: However, the information from our prototype tool related to individual definitions and constructor functions, and it was not clear whether a similar technique would work for larger and more complex programs. This paper reports on the experimental application of heap profiling to Augustsson and Johnsson's Lazy ML (LML) compiler <ref> [1] </ref>. Since our implementation of heap profiling is itself based on the LML compiler, this amounts to a boot-strapping exercise. The LML compiler extends to some 16,500 lines of code in almost 200 modules, and is by any standard a large and sophisticated piece of software. <p> In this paper, all profile graphs share a common scale, shading and ordering. CONS - UNUSED head tail - - - "library" "listfuns" "map" "List" "(.)" (group) (module) (producer) (type) (construction) 3 An Overview of the LML Compiler The LML compiler <ref> [1] </ref> consists of two programs which communicate via a text file. The parser is written in C with the aid of the Yacc parser generator. It checks the program syntax and outputs a prefix form of the parse tree. The translator is written in LML.
Reference: [2] <author> S. Clayman, D. Parrot, and C. Clack. </author> <title> A Profiling Technique for Lazy, Higher-Order Functional Programs. </title> <type> Technical report, </type> <institution> Department of Computing Science, University College London, </institution> <month> November </month> <year> 1991. </year>
Reference-contexts: However, we know of at least two other profiling systems that have been constructed recently <ref> [2, 6] </ref>.
Reference: [3] <author> T-M. Kuo and Mishra. </author> <title> Strictness Analysis: A New Perspective Based on Type Inference. </title> <booktitle> In Proceedings of the 1989 Conference on Functional Programming Languages and Computer Architecture, </booktitle> <pages> pages 260-272. </pages> <publisher> ACM Press, </publisher> <month> September </month> <year> 1989. </year>
Reference-contexts: Similar support for type declarations has been available, and widely valued, for some time. The comparison is pertinent not only because both forms of declaration can characterise useful properties of defined functions, but also because strictness analysis can be approached as a type inference problem <ref> [3] </ref>. Packed representations of character lists can bring about substantial savings in comparison with the usual "cons-cell" chains, even in the context of lazy evaluation, as Stoye [7] observed several years ago.
Reference: [4] <author> C. Runciman and H. W. Thimbleby. </author> <title> Equal Opportunity Interactive Systems. </title> <journal> International Journal of Man-Machine Studies, </journal> <volume> 25 </volume> <pages> 439-451, </pages> <year> 1986. </year>
Reference-contexts: We suggest that if a compiler is capable of using a special representation in some circumstances, the programmer should have the opportunity to specify its use in other circumstances | a form of equal opportunity <ref> [4] </ref>.
Reference: [5] <author> C. Runciman and D. Wakeling. </author> <title> Heap Profiling of Lazy Functional Programs. </title> <type> Technical Report 172, </type> <institution> Department of Computer Science, University of York, </institution> <month> April </month> <year> 1992. </year>
Reference-contexts: Hence profiling tools, by which programmers can obtain information about memory use in terms of the source program, are potentially of great value. In a previous paper <ref> [5] </ref> we described the design, implementation and use of a prototype heap profiling tool for lazy functional programs. As an example application, we used clausify, an existing 130 line program to normalise logical formulae.
Reference: [6] <author> P. M. Sansom and S. L. Peyton Jones. </author> <title> Profiling Lazy Functional Programs. </title> <editor> In J. Launchbury and P. M. Sansom, editors, </editor> <booktitle> Functional Programming, </booktitle> <address> Glasgow 1992. </address> <publisher> Springer-Verlag, Workshps in Computing, </publisher> <year> 1992. </year>
Reference-contexts: However, we know of at least two other profiling systems that have been constructed recently <ref> [2, 6] </ref>.
Reference: [7] <author> W. Stoye. </author> <title> The Implementation of Functional Languages Using Custom Hardware. </title> <type> PhD thesis, </type> <institution> University of Cambridge Computer Laboratory, </institution> <month> December </month> <year> 1986. </year> <note> Technical Report No. 81. </note>
Reference-contexts: Packed representations of character lists can bring about substantial savings in comparison with the usual "cons-cell" chains, even in the context of lazy evaluation, as Stoye <ref> [7] </ref> observed several years ago. The use of this technique to reduce the size of region `B' might easily be dismissed as a specific low-level optimisation, not linked to any general principle.
Reference: [8] <author> D. A. Turner. </author> <title> A new implementation technique for applicative languages. </title> <journal> SOFTWARE | Practice and Experience, </journal> <volume> 9(1) </volume> <pages> 31-50, </pages> <month> January </month> <year> 1979. </year>
Reference-contexts: Recall also that we chose to rewrite some string operations in M-code to avoid the unpacking machinery: an alternative approach repacks strings during garbage collection | a special case of Turner's idea <ref> [8] </ref> that expressions should revert to an earlier, smaller form when space is short. 6 Related and Future Work Although there have been many implementations of lazy functional languages, it seems there has been comparatively little work on profiling.
Reference: [9] <author> C. von Dorrien. </author> <title> Stingy Evaluation. </title> <institution> Licentiate Dissertation, Chalmers University of Technology, S-412 96 Goteborg, </institution> <year> 1989. </year>
Reference-contexts: Wadler [10] has described such a scheme for the common case of selection from a tuple of multiple results, and this scheme is generalised in von Dorrien's stingy evaluator <ref> [9] </ref>. Indeed, a stingy evaluator is distributed with the LML compiler | but it is not used for the bootstrap compilation! The fault of region `A' was caused by a definition that was not lazy enough, being over-strict in a (large) argument value.
Reference: [10] <author> P. Wadler. </author> <title> Fixing Some Space Leaks with a Garbage Collector. </title> <journal> Software | Practice and Experience, </journal> <volume> 17(9) </volume> <pages> 595-608, </pages> <month> September </month> <year> 1987. </year>
Reference-contexts: But it is not always as easy as it was in this case to determine an appropriate source level reformulation. Many problems of this kind can be avoided at the implementation level, by introducing quasi-parallel reduction rules into the garbage collector. Wadler <ref> [10] </ref> has described such a scheme for the common case of selection from a tuple of multiple results, and this scheme is generalised in von Dorrien's stingy evaluator [9].
References-found: 10

