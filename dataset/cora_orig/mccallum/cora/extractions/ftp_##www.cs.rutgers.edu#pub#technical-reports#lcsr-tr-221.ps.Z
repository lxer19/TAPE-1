URL: ftp://www.cs.rutgers.edu/pub/technical-reports/lcsr-tr-221.ps.Z
Refering-URL: http://www.cs.rutgers.edu/pub/technical-reports/
Root-URL: 
Email: minsky@cs.rutgers.edu  leichter@cs.rutgers.edu  
Title: Law-Governed Linda Communication Model  
Author: Naftaly H. Minsky Jerrold Leichter 
Date: March 14, 1994  
Address: New Brunswick, NJ, 08903 USA  
Affiliation: Department of Computer Science Rutgers University  
Abstract: to arrange for a definite rendezvous. Along with the considerable advantages of this high level of abstraction, Linda carries some serious liabilities: it is very unsafe, and is difficult to optimize. We propose to remove the first of these difficulties, and alleviate the second | while preserving the advantages of Linda | by means of the concept of law-governed architecture previously applied to centralized and message passing systems. We define a model for Law-Governed Linda (LGL) communication, and we demonstrate its efficacy by means of several illustrative examples.
Abstract-found: 1
Intro-found: 1
Reference: [BA90] <author> M. Ben-Ari. </author> <title> Principles of Concurrent and Distributed programming. </title> <publisher> Pren-tice Hall, </publisher> <year> 1990. </year>
Reference-contexts: 1 Introduction There is much which is attractive about the Linda communication model [Gel85], under which processes communicate by placing tuples in a shared and wide open tuple space, and by retrieving tuples from this space. The model uncouples communicating processes in both time and space <ref> [BA90] </ref> by allowing them to communicate without knowing each others's identities and without having to arrange for a definite rendezvous; it uses a single mechanism for both communication and synchronization; and it lends itself to various styles of communications, including message passing and broadcasting.
Reference: [Bjo92] <author> Robert Bjornson. </author> <title> Linda on distributed memory multiprocessors. </title> <type> Technical Report RR-931, </type> <institution> Yale University Department of Computer Science, </institution> <month> November </month> <year> 1992. </year> <note> Also a 1993 Yale University PhD thesis. </note>
Reference-contexts: It may be possible to optimize the placement of such message-tuples by analyzing the code that drive all processes of the system and concluding that only process t actually reads this tuple. An implementation can also combine global compile-time analysis with run-time monitoring <ref> [Lei89, Bjo92] </ref>. But for large, evolving systems such global optimization is quite impractical, as has been pointed out by Kahn and Miller [KM89]. Similar criticism has been leveled against Linda by other writers, who proposed various partial solutions.
Reference: [CG86] <author> Nicholas Carriero and David Gelernter. </author> <title> The S/Net's Linda kernel. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 4(2), </volume> <month> May </month> <year> 1986. </year> <month> 21 </month>
Reference-contexts: The match and removal are an atomic operation on the tuple space. For a detailed discussion of the advantages of this model and its use for communication and synchronization the reader is referred to <ref> [Gel85, CG86, WL88, CG88] </ref>.
Reference: [CG88] <author> Nicholas Carriero and David Gelernter. </author> <title> Applications experience with Linda. </title> <journal> ACM SIGPLAN Notices, </journal> <volume> 23(9), </volume> <month> September </month> <year> 1988. </year> <booktitle> Proceedings of ACM/SIGPLAN PPEALS 1988. </booktitle>
Reference-contexts: The match and removal are an atomic operation on the tuple space. For a detailed discussion of the advantages of this model and its use for communication and synchronization the reader is referred to <ref> [Gel85, CG86, WL88, CG88] </ref>.
Reference: [CM81] <author> W.F. Clocksin and C.S. Mellish. </author> <title> Programming in Prolog. </title> <publisher> Springer-Verlag, </publisher> <year> 1981. </year>
Reference-contexts: description of this architecture: We employ the Prolog language for the formulation of the law. 4 This is not quite the case for laws that incorporate obligations, as discussed in [ML85, LM]. 5 Consequently, the reader is expected to have a passing familiarity with Prolog and with its Edinborough syntax <ref> [CM81] </ref>.
Reference: [DG72] <author> P.J. Denning and G. S. Graham. </author> <title> Protection principles and practice. </title> <booktitle> In AFIPS 1972 Spring Joint Computer Conf., </booktitle> <pages> pages 417-429. </pages> <publisher> AFIPS, </publisher> <year> 1972. </year>
Reference-contexts: ruling is simply empty, the process will be blocked forever unless we extend the definition of Linda to allow for "suppressed" operations. 11 4 Examples 4.1 Capability-Based Control Over Message Passing Elaborating on our previous example, we now consider the law defined in Figure 2, which establishes a capability-based control <ref> [DG72] </ref> over the exchange of messages between processes. As mentioned earlier, Pinakis [Pin92] proposed a modification of Linda that uses encryption to support capabilities. Here we show how, under Law-Governed Linda, a similar discipline can be established simply by a law.
Reference: [Gel85] <author> David H. Gelernter. </author> <title> Generative communication in Linda. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 7(1), </volume> <month> January </month> <year> 1985. </year>
Reference-contexts: 1 Introduction There is much which is attractive about the Linda communication model <ref> [Gel85] </ref>, under which processes communicate by placing tuples in a shared and wide open tuple space, and by retrieving tuples from this space. <p> A much longer example is presented in Section 5, where we introduce a law that ensures the confidentiality of servers with respect to information they get from their clients. 2 Linda and Its Weaknesses The Linda model <ref> [Gel85] </ref> provides communication and synchronization between parallel processes by controlled access to a shared data structure called tuple space. A tuple space is a collection (bag) of tuples, each of which is a linear list of typed values called fields. <p> The match and removal are an atomic operation on the tuple space. For a detailed discussion of the advantages of this model and its use for communication and synchronization the reader is referred to <ref> [Gel85, CG86, WL88, CG88] </ref>.
Reference: [KM89] <author> K.M. Kahn and M.S. Miller. </author> <title> A letter about the article 'Linda in Context' by Carrierro and Gelernter. </title> <journal> Communications of the ACM, </journal> <volume> 32(10) </volume> <pages> 1253-1255, </pages> <month> Oct. </month> <year> 1989. </year>
Reference-contexts: An implementation can also combine global compile-time analysis with run-time monitoring [Lei89, Bjo92]. But for large, evolving systems such global optimization is quite impractical, as has been pointed out by Kahn and Miller <ref> [KM89] </ref>. Similar criticism has been leveled against Linda by other writers, who proposed various partial solutions. Kahn and Miller [KM89] proposed to enhance the safety of communication in Linda by means of the concept of multiple tuple spaces. <p> But for large, evolving systems such global optimization is quite impractical, as has been pointed out by Kahn and Miller <ref> [KM89] </ref>. Similar criticism has been leveled against Linda by other writers, who proposed various partial solutions. Kahn and Miller [KM89] proposed to enhance the safety of communication in Linda by means of the concept of multiple tuple spaces. And Pinakis [Pin92], who was worried specifically about safe message passing, proposed to use encryption technique to support such communication in Linda. <p> Also by this rule, a process that in's a capability tuple is granted the capability specified in it. 4.2 Establishing Multiple Tuple Spaces The concept of multiple tuple spaces has been frequently proposed <ref> [KM89] </ref> as a a means for enhancing the usefulness of Linda. Here we show how such a facility can be established under LGL by means of a very simple law.
Reference: [Lam76] <author> B.W. Lampson. </author> <title> A note on the confinement problem. </title> <journal> Communications of the ACM, </journal> <volume> 16(10) </volume> <pages> 613-615, </pages> <month> Oct. </month> <year> 1976. </year>
Reference-contexts: An analogous solution for computer systems, where a server might be a program employed to compute the income tax of some client, for example, has been studied as the "confinement problem" <ref> [Lam76] </ref>. The inhumanity of the ancient king is not a problem here, but the confinement of a programmed server may be technically difficult. <p> solution is not quite complete, in the following sense: We deal here only with the interaction of processes with the tuple space, ignoring possible communication between individual processes and the outside world, either by means of simple output, or through the very subtle, even if narrow, channels discussed by Lampson <ref> [Lam76] </ref>. The former kind of channels can, in principle, be blocked by extending the class of controlled events; the later ones generally cannot be. 16 p r Process q here is serving p, and process r in unengaged.
Reference: [Lei89] <author> Jerrold S. Leichter. </author> <title> Shared tuple memories, shared memories, buses and LAN's | Linda implementations across the spectrum of connectivity. </title> <type> Technical Report TR-714, </type> <institution> Yale University Department of Computer Science, </institution> <month> July </month> <year> 1989. </year> <note> Also a 1989 Yale University PhD thesis. </note>
Reference-contexts: It may be possible to optimize the placement of such message-tuples by analyzing the code that drive all processes of the system and concluding that only process t actually reads this tuple. An implementation can also combine global compile-time analysis with run-time monitoring <ref> [Lei89, Bjo92] </ref>. But for large, evolving systems such global optimization is quite impractical, as has been pointed out by Kahn and Miller [KM89]. Similar criticism has been leveled against Linda by other writers, who proposed various partial solutions.
Reference: [LM] <author> Jerrold Leichter and Naftaly H. Minsky. </author> <title> Obligations in law governed distributed systems. </title> <note> In preparation. </note>
Reference-contexts: A final observation is in order before we turn to the detailed description of this architecture: We employ the Prolog language for the formulation of the law. 4 This is not quite the case for laws that incorporate obligations, as discussed in <ref> [ML85, LM] </ref>. 5 Consequently, the reader is expected to have a passing familiarity with Prolog and with its Edinborough syntax [CM81]. <p> But it is sometimes necessary to control events that occur asynchronously with respect to the home-process. These include various kinds of interrupts that may happen around a process, and the event of an obligation coming due, which is used to support the concept of enforceable obligations presented in <ref> [ML85, LM] </ref>.
Reference: [Min91] <author> N.H. Minsky. </author> <title> The imposition of protocols over open distributed systems. </title> <journal> IEEE Transactions on Software Engineering, </journal> <month> February </month> <year> 1991. </year>
Reference-contexts: CCR-8807803 and No. CCR-9308773 1 We propose to remove the first of these difficulties, and alleviate the second | while preserving the advantages of Linda | by means of the concept of law-governed architecture (LGA) <ref> [Min91] </ref>. Under this architecture the interaction of each process with the tuple space would be governed by the same set of rules, called the "law" of the distributed system. <p> We start with a brief introduction to the Linda communication model, and with a discussion of its liabilities. In Section 3 we introduce our model for Law-Governed Linda (LGL), which is an adaptation of the model for distributed law-governed architecture introduced in <ref> [Min91] </ref>, illustrating it by showing how secure and efficient message passing can be established by means of a law.
Reference: [ML85] <author> N.H. Minsky and A. Lockman. </author> <title> Ensuring integrity by adding obligations to privileges. </title> <booktitle> In Proceedings of the 8th International Conference on Software Engineering, </booktitle> <pages> pages 92-102, </pages> <month> August </month> <year> 1985. </year>
Reference-contexts: A final observation is in order before we turn to the detailed description of this architecture: We employ the Prolog language for the formulation of the law. 4 This is not quite the case for laws that incorporate obligations, as discussed in <ref> [ML85, LM] </ref>. 5 Consequently, the reader is expected to have a passing familiarity with Prolog and with its Edinborough syntax [CM81]. <p> But it is sometimes necessary to control events that occur asynchronously with respect to the home-process. These include various kinds of interrupts that may happen around a process, and the event of an obligation coming due, which is used to support the concept of enforceable obligations presented in <ref> [ML85, LM] </ref>.
Reference: [Pin92] <author> J. Pinakis. </author> <title> Providing directed communication in linda. </title> <booktitle> In Proceedings of the 15th Australian Computer Science Conf., </booktitle> <pages> pages 731-743, </pages> <year> 1992. </year>
Reference-contexts: Similar criticism has been leveled against Linda by other writers, who proposed various partial solutions. Kahn and Miller [KM89] proposed to enhance the safety of communication in Linda by means of the concept of multiple tuple spaces. And Pinakis <ref> [Pin92] </ref>, who was worried specifically about safe message passing, proposed to use encryption technique to support such communication in Linda. Our solution by means of law-governed architecture, is more radical, and far more general then these. <p> As mentioned earlier, Pinakis <ref> [Pin92] </ref> proposed a modification of Linda that uses encryption to support capabilities. Here we show how, under Law-Governed Linda, a similar discipline can be established simply by a law.
Reference: [WL88] <author> Robert A. Whiteside and Jerrold S. Leichter. </author> <title> Using Linda for supercomputing on a local area network. </title> <booktitle> In Proceedings, Supercomputing '88, </booktitle> <month> November </month> <year> 1988. </year> <institution> Also Yale University Department of Computer Science Technical Report TR-638 and Sandia National Laboratories Report SAND88-8818, </institution> <note> both June 1988. 22 </note>
Reference-contexts: The match and removal are an atomic operation on the tuple space. For a detailed discussion of the advantages of this model and its use for communication and synchronization the reader is referred to <ref> [Gel85, CG86, WL88, CG88] </ref>.
References-found: 15

