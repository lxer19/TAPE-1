URL: http://www.cs.arizona.edu/alto/papers/liveness.ps
Refering-URL: http://www.cs.arizona.edu/alto/
Root-URL: http://www.cs.arizona.edu
Email: muth@cs.arizona.edu  
Title: Register Liveness Analysis of Executable Code  
Author: Robert Muth 
Note: Draft  
Address: Tucson, AZ 85721, U.S.A.  
Affiliation: Department of Computer Science University of Arizona  
Abstract: Liveness analysis of variables is a well-understood technique employed by most compilers to guide optimizations such as useless code elimination and register allocation. Liveness analysis can also be performed on object code if we let registers take the place of variables. The increasing interest in systems that modify object code or executables has generated a need for a fast and accurate register liveness analysis. This paper shows how to accurately compute register liveness information in a time and space efficient manner and how to cope with irregular control flow not encountered in high level languages. Tradeoffs between the precision of the analysis and its computation time and space are discussed. In particular, context sensitive and context insensitive register liveness analysis are compared. Experimental results on precision, time and space usage are provided as well as the impact of liveness analysis on optimizations.
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Robert Cohn, David Goodwin, P. Geoffrey Lowney, and Norman Rubin. Spike: </author> <title> An optimizer for Alpha/NT executables. </title> <booktitle> In The USENIX Windows NT Workshop, </booktitle> <address> Seattle, Washington,USA, </address> <month> August </month> <year> 1997. </year>
Reference-contexts: The increasing interest in systems that modify object code or executables has generated a need for a fast and accurate register liveness analysis. On the one hand we have optimizing systems such as Alto [10], EEL [7], Etch [12], OM [14], Spike <ref> [1] </ref> which make use of the liveness information in a more classical way, ie. to reduce number of (executed) instructions.
Reference: [2] <author> David W. Goodwin. </author> <title> Interprocedural dataflow analysis in an executable optimizer. </title> <booktitle> In ACM '97 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 122133, </pages> <address> Las Vegas, Nevada, USA, </address> <month> June </month> <year> 1997. </year>
Reference-contexts: Related Work: Work most closely related to our own is done by Srivastava and Wall on the OM optimizer [14] and by Goodwin on the Spike optimizer <ref> [2] </ref>. We improve on their liveness analysis in three ways. Firstly, we have changed the underlying flow equations resulting in three sets of almost identical equations, which simplifies implementation and reasoning about correctness. <p> Consequently, we have a certain freedom for its choice. Srivastava et al. [14] choose ByPass [ f ] to be MustDead [ f ]. The problem with this approach that it introduces a mutual dependency between ByPass information and MayU se information which complicates the flow equations. Goodwin <ref> [2] </ref> chooses ByPass [ f ] to be MustDe f [ f ] which does not have this problem and is therefore preferable. <p> ] := / 0 f 2 F unctions Note that contrary to the intraprocedural liveness analysis or the context insensitive analysis the choice of the starting values is crucial for the analysis to yield precise results, eg. initializing byPassOut [ f ] of non exit nodes to R as in <ref> [2] </ref> yields safe but imprecise results [3]. <p> This will be exploited in 5.2. Section 5.1 shows how some registers which a precise analysis correctly identified as live can nevertheless be regarded as dead in some contexts. 10 5.1 Callee Save Registers As described by Goodwin in <ref> [2] </ref>, information about callee save registers can be exploited to reduce the number of live registers. Let Saved [ f ] denoted the registers which are saved and restored by f and which are otherwise not used before defined in f .
Reference: [3] <author> David W. Goodwin. </author> <type> Personal communication, </type> <year> 1997. </year>
Reference-contexts: F unctions Note that contrary to the intraprocedural liveness analysis or the context insensitive analysis the choice of the starting values is crucial for the analysis to yield precise results, eg. initializing byPassOut [ f ] of non exit nodes to R as in [2] yields safe but imprecise results <ref> [3] </ref>.

Reference: [5] <author> James R. Larus. </author> <title> Efficient program tracing. </title> <booktitle> Computer, </booktitle> <address> 26(5):5261, </address> <month> May </month> <year> 1993. </year>
Reference-contexts: Instrumentation systems such as Atom [13], Pixie [15] and qp (t) <ref> [5] </ref> on the other hand, add new instructions to the executable in order to collect information about the executable at run time. Scratch registers needed by those new instructions are obtained by temporarily spilling registers to memory or by changing the compiler to not use certain registers in executables.
Reference: [6] <author> James R. Larus and Thomas Ball. </author> <title> Rewriting executable files to measure program behavior. </title> <journal> Software Practice and Experience, </journal> <volume> 24(2):197218, </volume> <month> February </month> <year> 1994. </year>
Reference-contexts: Scratch registers needed by those new instructions are obtained by temporarily spilling registers to memory or by changing the compiler to not use certain registers in executables. The first approach slows down the instrumented executable significantly. In fact, the cost of spilling frequently exceeds the instrumentation cost itself <ref> [6] </ref>. The second approach yields suboptimal uninstrumented executables. As we will see, register liveness analysis is likely to provide the necessary registers at no cost. Compared to traditional interprocedural variable liveness analysis, interprocedural register liveness analysis in executable code is both easier and harder. <p> Furthermore, we explore ways to improve the accuracy of liveness analysis. For a known technique involving callee-save registers we point out a possible generalization. Larus and Ball <ref> [6] </ref> describe a more ad hoc scheme to scavange registers for instrumentation purposes.
Reference: [7] <author> James R. Larus and Eric Schnarr. EEL: </author> <title> machine-independent executable editing. </title> <booktitle> In ACM '95 Conference on Programming Language Design and Implementation, </booktitle> <address> New York, NY, USA, </address> <month> June </month> <year> 1995. </year>
Reference-contexts: The increasing interest in systems that modify object code or executables has generated a need for a fast and accurate register liveness analysis. On the one hand we have optimizing systems such as Alto [10], EEL <ref> [7] </ref>, Etch [12], OM [14], Spike [1] which make use of the liveness information in a more classical way, ie. to reduce number of (executed) instructions.
Reference: [8] <author> Thomas J. Marlowe, Barbara Ryder, and Michael Burke. </author> <title> Defining flow sensitivity for data flow problems. </title> <type> Technical Report LCSR-TR-249, </type> <institution> Rutgers University, </institution> <month> July </month> <year> 1995. </year>
Reference-contexts: See [4] for a more rigorous definition. A precise interprocedural data flow analysis considers only realizable paths in the ICFG. Solutions obtained by this approach are called meet-over-all-realizable-path solutions. The meet-over-all-path approach is usually referred to as context insensitive, the meet-over-all-realizable-path as context sensitive <ref> [8] </ref>. 3 Interprocedural Liveness Analysis 3.1 Context Insensitive Analysis As described in the previous section, the context insensitive liveness analysis uses the standard intraprocedural analysis [9] and applies it to a program's ICFG treating call and return edges as ordinary edges. 3 The analysis iteratively computes the fixpoint of the equations <p> This is achieved by considering intraprocedural paths only and modeling function calls using summary information for the called function <ref> [8] </ref>. Conceptually, all call and return edges are removed from the ICFG and an edge between a call node n c and its corresponding return node n r is introduced. Data flow through that edge is subject to modifications described by the summary information for the called function.
Reference: [9] <author> Steven S. Muchnick. </author> <title> Advanced Compiler Design and Implementation. </title> <publisher> Morgan Kaufmann Publishers, </publisher> <year> 1997. </year>
Reference-contexts: 1 Introduction Liveness analysis of variables is a well-understood technique employed by most compilers to guide optimizations such as useless code elimination and register allocation <ref> [9] </ref>. Liveness analysis can also be performed on object code if we let registers take the place of variables. The increasing interest in systems that modify object code or executables has generated a need for a fast and accurate register liveness analysis. <p> Solutions obtained by this approach are called meet-over-all-realizable-path solutions. The meet-over-all-path approach is usually referred to as context insensitive, the meet-over-all-realizable-path as context sensitive [8]. 3 Interprocedural Liveness Analysis 3.1 Context Insensitive Analysis As described in the previous section, the context insensitive liveness analysis uses the standard intraprocedural analysis <ref> [9] </ref> and applies it to a program's ICFG treating call and return edges as ordinary edges. 3 The analysis iteratively computes the fixpoint of the equations below LiveIn [n] = use [n] [ (LiveOut [n] de f [n]) n 2 Nodes LiveOut [n] = S s 2 Succ [n] : LiveIn
Reference: [10] <author> Robert Muth, Saumya Debray, Scott Watterson, and Koen De Bosschere. </author> <title> Alto: A link-time optimizer for the dec alpha. </title> <institution> Technical Report ,http://www.cs.arizona.edu/people/debray/papers/alto.ps, Department of Computer Science,The University of Arizona, </institution> <month> September </month> <year> 1998. </year>
Reference-contexts: The increasing interest in systems that modify object code or executables has generated a need for a fast and accurate register liveness analysis. On the one hand we have optimizing systems such as Alto <ref> [10] </ref>, EEL [7], Etch [12], OM [14], Spike [1] which make use of the liveness information in a more classical way, ie. to reduce number of (executed) instructions. <p> The enhancement is also applicable to ordinary interprocedural liveness analyses of variables. 3.4 Implementation and Performance of the Liveness Analyses We have implemented the context sensitive and context insensitive liveness analysis algorithms as part of Alto <ref> [10] </ref>, an optimizer for DEC UNIX/Alpha executables. Besides the speed of the analysis, space consumption was of primary concern to us. We found that it is usually better to recompute a data item than to store it. Recomputation also avoids potential inconsistencies.
Reference: [11] <author> Eugene W. Myers. </author> <title> A precise interprocedural data flow algorithm. </title> <booktitle> In ACM '81 Symposium on Principles of Programming Languages, </booktitle> <pages> pages 219230, </pages> <month> January </month> <year> 1981. </year>
Reference-contexts: The construction of such a control flow graph for ordinary programming languages is standard <ref> [4, 11] </ref>. For executables it is slightly more difficult but similar. An ICFG consists of the (intraprocedural) control flow graphs (CFG) of the functions within the program, together with additional edges and nodes to account for interprocedural control flow. <p> Traditional ICFGs <ref> [11, 4] </ref> do not consider edges corresponding to those branches. The only allowable interprocedural edges are call and and return edges. Escaping edges occur frequently in handtuned assembly code, the UNIX system library of DEC UNIX is a good example.
Reference: [12] <author> Ted Romer, Geoff Voelker, Dennis Lee, Alec Wolman, Wayne Wong, Hank Levy, Brian Bershad, and J. Bradley Chen. </author> <title> Instrumentation and optimization of Win32/Intel executables using etch. </title> <booktitle> In The USENIX Windows NT Workshop 1997, </booktitle> <address> Seattle, WA, USA, </address> <month> August </month> <year> 1997. </year>
Reference-contexts: The increasing interest in systems that modify object code or executables has generated a need for a fast and accurate register liveness analysis. On the one hand we have optimizing systems such as Alto [10], EEL [7], Etch <ref> [12] </ref>, OM [14], Spike [1] which make use of the liveness information in a more classical way, ie. to reduce number of (executed) instructions.
Reference: [13] <author> Amitabh Srivastava and Alan Eustace. </author> <title> ATOM: A system for building customized program analysis tools. </title> <booktitle> In ACM '94 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 196205, </pages> <month> June </month> <year> 1994. </year>
Reference-contexts: On the one hand we have optimizing systems such as Alto [10], EEL [7], Etch [12], OM [14], Spike [1] which make use of the liveness information in a more classical way, ie. to reduce number of (executed) instructions. Instrumentation systems such as Atom <ref> [13] </ref>, Pixie [15] and qp (t) [5] on the other hand, add new instructions to the executable in order to collect information about the executable at run time.
Reference: [14] <author> Amitabh Srivastava and David W. Wall. </author> <title> A practical system for intermodule code optimization at link-time. </title> <journal> Journal of Programming Languages, </journal> <volume> 1(1):118, </volume> <month> December </month> <year> 1992. </year>
Reference-contexts: The increasing interest in systems that modify object code or executables has generated a need for a fast and accurate register liveness analysis. On the one hand we have optimizing systems such as Alto [10], EEL [7], Etch [12], OM <ref> [14] </ref>, Spike [1] which make use of the liveness information in a more classical way, ie. to reduce number of (executed) instructions. <p> Related Work: Work most closely related to our own is done by Srivastava and Wall on the OM optimizer <ref> [14] </ref> and by Goodwin on the Spike optimizer [2]. We improve on their liveness analysis in three ways. Firstly, we have changed the underlying flow equations resulting in three sets of almost identical equations, which simplifies implementation and reasoning about correctness. <p> Clearly, MustDead [ f ] = MustDe f [ f ] MayU se [ f ] Note, that ByPass [ f ] is not uniquely defined. Consequently, we have a certain freedom for its choice. Srivastava et al. <ref> [14] </ref> choose ByPass [ f ] to be MustDead [ f ]. The problem with this approach that it introduces a mutual dependency between ByPass information and MayU se information which complicates the flow equations. <p> Conversely, we are sometimes unable to identify all the callsites for a given function. The following standard technique <ref> [14] </ref> is used to cope with unknown control flow. It is safe but very crude. A special node hellnode 2 Nodes and a special function hell f un 2 F unctions are added to the ICFG.
Reference: [15] <institution> MIPS Computer Systems. Riscompiler and c programmer's guide, </institution> <year> 1989. </year>
Reference-contexts: On the one hand we have optimizing systems such as Alto [10], EEL [7], Etch [12], OM [14], Spike [1] which make use of the liveness information in a more classical way, ie. to reduce number of (executed) instructions. Instrumentation systems such as Atom [13], Pixie <ref> [15] </ref> and qp (t) [5] on the other hand, add new instructions to the executable in order to collect information about the executable at run time.
Reference: [16] <author> David W. Wall. </author> <title> Systems for late code modification. </title> <type> Technical Report 92/3, </type> <institution> Digital Equipment Corporation, Western Research Lab, </institution> <month> May </month> <year> 1992. </year> <month> 14 </month>
Reference-contexts: We also show how to adapt liveness analysis in an environment where (assembly) code maybe handwritten and hence may not satisfy the clean control flow behaviour of compiler generated code. Our approach, using so called compensation edges, is automatic while earlier proposals <ref> [16] </ref> special cased all the badly behaved functions in the standard libraries and hence could not cope with other misbehaved functions. Furthermore, we explore ways to improve the accuracy of liveness analysis. For a known technique involving callee-save registers we point out a possible generalization.
References-found: 15

