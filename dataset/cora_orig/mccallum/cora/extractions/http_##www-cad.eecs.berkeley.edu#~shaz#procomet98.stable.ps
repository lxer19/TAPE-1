URL: http://www-cad.eecs.berkeley.edu/~shaz/procomet98.stable.ps
Refering-URL: http://www-cad.eecs.berkeley.edu/~shaz/recent.html
Root-URL: 
Email: Email: shaz@eecs.berkeley.edu  Email: shankar@csl.sri.com  
Phone: Phone: (510) 642-1490  Phone: (650) 859-5272  
Title: Verifying a Self-Stabilizing Mutual Exclusion Algorithm  
Author: S. Qadeer N. Shankar 
Keyword: Self-stabilization, mutual exclusion, theorem proving, PVS.  
Address: Berkeley CA 94720 U.S.A.  Menlo Park CA 94025 U.S.A.  
Affiliation: University of California at Berkeley Department of EECS,  SRI International Computer Science Laboratory,  
Abstract: We present a detailed description of a machine-assisted verification of an algorithm for self-stabilizing mutual exclusion that is due to Dijkstra [Dij74]. This verification was constructed using PVS. We compare the mechanical verification to the informal proof sketch on which it is based. This comparison yields several observations regarding the challenges of formalizing and mechanically verifying distributed algorithms in general. 
Abstract-found: 1
Intro-found: 1
Reference: [AG93] <author> A. Arora and M. Gouda. </author> <title> Closure and convergence: A foundation of fault-tolerant computing. </title> <journal> IEEE Transactions on Software Engineering, </journal> 19(11) 1015-1027, November 1993. 
Reference-contexts: The study of self-stabilizing algorithms was dormant for a while following Dijkstra's work but there has been a recent flurry of activity in the subject. Schneider [Sch93] presents a survey of the issues in the design of self-stabilizing algorithms. Arora and Gouda <ref> [AG93] </ref> describe a uniform formal framework for verifying fault-tolerance and self-stability. Varghese [Var92] presents various systematic techniques for designing fault-tolerant algorithms including one based on the algorithm studied in this paper.
Reference: [BM84] <author> R. S. Boyer and J. S. Moore. </author> <title> Proof checking the RSA public key encryption algorithm. </title> <journal> American Mathematical Monthly, </journal> <volume> 91(3) </volume> <pages> 181-189, </pages> <year> 1984. </year>
Reference-contexts: Lemma 4.13 The nonzero processes do not contain all the possible counter values. The formal statement of the theorem is 9x : x &lt; M ^ x =2 S (v). 5 The PVS proof should be compared with a similar proof carried out by Boyer and Moore <ref> [BM84] </ref> using the Boyer-Moore theorem prover. In the latter proof, the injection is represented as a list with some complicated conditions that constrain it to behave as an injection. 12 Verifying a Self-Stabilizing Mutual Exclusion Algorithm Proof.
Reference: [CGL94] <author> E. M. Clarke, O. Grumberg, and D. E. </author> <title> Long. Model checking and abstraction. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 16(5) </volume> <pages> 1512-1542, </pages> <month> September </month> <year> 1994. </year>
Reference-contexts: PVS has support for model checking but we were unable to reduce the problem here to one that could be model checked. While there are some finite-state techniques for verifying parametric systems of the form shown here <ref> [CGL94, WL89] </ref>, they do not appear to be useful for this example. We were also unable to reduce the other two protocols presented by Dijkstra [Dij74] to model checkable form even though these are systems composed only of finite-state processes.
Reference: [CM88] <author> K. M. Chandy and J. Misra. </author> <title> Parallel Program Design: A Foundation. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, MA, </address> <year> 1988. </year>
Reference-contexts: He also provides an informal proof sketch for the correctness of this algorithm that is loosely similar to the one described here. Prasetya [Pra97] verifies a self-stabilizing minimum-cost routing algorithm in a variant of the UNITY logic <ref> [CM88] </ref> that is formalized in the HOL proof checking system [GM93]. He presents an elegant development of the theory needed to verify this algorithm but reports a prohibitively high level of verification effort. <p> There were only four truly temporal proofs and even some of these involved a fair amount of combinatorial reasoning. Would a special-purpose temporal formalism have helped? Although we initially felt that this proof would not have derived a significant benefit from a special-purpose temporal formalism <ref> [MP92, CM88] </ref> because large parts of the proof involved conventional mathematical reasoning, we did find some situations where a temporal framework would have been handy.
Reference: [dB80] <author> N. G. de Bruijn. </author> <title> A survey of the project AUTOMATH. </title> <editor> In J. P. Seldin and J. R. Hindley, editors, </editor> <booktitle> Essays on Combinatory Logic, Lambda Calculus and Formalism, </booktitle> <pages> pages 589-606. </pages> <publisher> Academic Press, </publisher> <address> New York, NY, </address> <year> 1980. </year>
Reference-contexts: In making these leaps, the mechanization helps construct explanations why some of these leaps are problematic and how they can be refined. The main conclusion, one that has been observed earlier by de Bruijn <ref> [dB80] </ref> and others, is that the machine-checked proofs are of manageable size and Discussion 17 linearly track the informal argument, and with modern automation, the expansion factor can actually be made quite small. The challenge of mechanical verification. There is a widespread belief that mechanized deductive verification is too hard.
Reference: [Dij74] <author> E. W. Dijkstra. </author> <title> Self-stabilizing systems in spite of distributed control. </title> <journal> Communications of the ACM, </journal> <volume> 17(11) </volume> <pages> 643-644, </pages> <month> November </month> <year> 1974. </year>
Reference-contexts: 1 INTRODUCTION A self-stabilizing algorithm is one that ensures that the system behavior eventually stabilizes to a safe subset of states regardless of the initial state. In Dijkstra's original paper <ref> [Dij74] </ref> introducing distributed self-stabilization, he gave three self-stabilizing mutual exclusion algorithms and left their proofs as exercises for the reader. Subsequently, Dijkstra [Dij86] proffered a proof of self-stabilization of one of his algorithms while conceding that the proofs were in fact nontrivial. <p> The study of self-stabilizing algorithms was initiated by Dijkstra in 1974 <ref> [Dij74] </ref>. He presented three algorithms for distributed N - process mutual exclusion arranged in a ring. These algorithms ensured that the system converged to stable behavior with at most one privileged or active process in any state. <p> While there are some finite-state techniques for verifying parametric systems of the form shown here [CGL94, WL89], they do not appear to be useful for this example. We were also unable to reduce the other two protocols presented by Dijkstra <ref> [Dij74] </ref> to model checkable form even though these are systems composed only of finite-state processes.
Reference: [Dij86] <author> E. W. Dijkstra. </author> <title> A belated proof of self-stabilization. </title> <journal> Distributed Computing, </journal> <volume> 1 </volume> <pages> 5-6, </pages> <year> 1986. </year>
Reference-contexts: In Dijkstra's original paper [Dij74] introducing distributed self-stabilization, he gave three self-stabilizing mutual exclusion algorithms and left their proofs as exercises for the reader. Subsequently, Dijkstra <ref> [Dij86] </ref> proffered a proof of self-stabilization of one of his algorithms while conceding that the proofs were in fact nontrivial. In this paper, we take on the challenge of mechanically verifying the self-stability of one of Dijkstra's other algorithms.
Reference: [GM93] <author> M. J. C. Gordon and T. F. Melham, </author> <title> editors. Introduction to HOL: A Theorem Proving Environment for Higher-Order Logic. </title> <publisher> Cambridge University Press, </publisher> <address> Cambridge, UK, </address> <year> 1993. </year>
Reference-contexts: He also provides an informal proof sketch for the correctness of this algorithm that is loosely similar to the one described here. Prasetya [Pra97] verifies a self-stabilizing minimum-cost routing algorithm in a variant of the UNITY logic [CM88] that is formalized in the HOL proof checking system <ref> [GM93] </ref>. He presents an elegant development of the theory needed to verify this algorithm but reports a prohibitively high level of verification effort.
Reference: [MP92] <author> Z. Manna and A. Pnueli. </author> <title> The Temporal Logic of Reactive and Concurrent Systems, Volume 1: Specification. </title> <publisher> Springer-Verlag, </publisher> <address> New York, NY, </address> <year> 1992. </year>
Reference-contexts: There were only four truly temporal proofs and even some of these involved a fair amount of combinatorial reasoning. Would a special-purpose temporal formalism have helped? Although we initially felt that this proof would not have derived a significant benefit from a special-purpose temporal formalism <ref> [MP92, CM88] </ref> because large parts of the proof involved conventional mathematical reasoning, we did find some situations where a temporal framework would have been handy.
Reference: [ORS92] <author> S. Owre, J. M. Rushby, and N. Shankar. PVS: </author> <title> A prototype verification system. </title> <editor> In Deepak Kapur, editor, </editor> <booktitle> 11th International Conference on Automated Deduction (CADE), volume 607 of Lecture Notes in Artificial Intelligence, </booktitle> <pages> pages 748-752, </pages> <address> Saratoga, NY, June 1992. </address> <publisher> Springer-Verlag. </publisher>
Reference-contexts: As with any distributed algorithm, the verification requires careful attention to details that are easily overlooked in an informal sketch. Our verification was conducted using PVS but our explanation of the verified proof will be presented in a conventional style thus requiring no prior knowledge of PVS <ref> [ORS92] </ref>. 2 We only consider the first of Dijkstra's three algorithms for self-stabilizing mutual exclusion. In this algorithm, there are N processes for N &gt; 1 numbered 0 to N 1 arranged in a unidirectional ring where each process can observe its own state and that of its predecessor.
Reference: [Pra97] <author> I. S. W. B. Prasetya. </author> <title> Mechanically verified self-stabilizing hierarchical algorithms. </title> <editor> In Ed Brinksma, editor, </editor> <booktitle> Tools and Algorithms for the Construction and Analysis of Systems (TACAS '97), volume 1217 of Lecture Notes in Computer Science, </booktitle> <pages> pages 399-415, </pages> <address> Enschede, The Netherlands, April 1997. </address> <publisher> Springer-Verlag. </publisher>
Reference-contexts: Varghese [Var92] presents various systematic techniques for designing fault-tolerant algorithms including one based on the algorithm studied in this paper. He also provides an informal proof sketch for the correctness of this algorithm that is loosely similar to the one described here. Prasetya <ref> [Pra97] </ref> verifies a self-stabilizing minimum-cost routing algorithm in a variant of the UNITY logic [CM88] that is formalized in the HOL proof checking system [GM93]. He presents an elegant development of the theory needed to verify this algorithm but reports a prohibitively high level of verification effort. <p> Current automated tools are already being used quite effectively by a large body of users. The progress so far in understanding the tradeoffs between automation and interaction has been quite encouraging. Is self-stability hard to verify? Prasetya <ref> [Pra97] </ref> claims the verification of self-stability to be especially hard. We can only speak of this particular experience. The main challenge for us was in coming up with a clean and crisp informal proof sketch.
Reference: [Sch93] <author> M. Schneider. </author> <title> Self stabilization. </title> <journal> ACM Computing Surveys, </journal> <volume> 25(1) </volume> <pages> 45-67, </pages> <month> March </month> <year> 1993. </year>
Reference-contexts: These algorithms ensured that the system converged to stable behavior with at most one privileged or active process in any state. The study of self-stabilizing algorithms was dormant for a while following Dijkstra's work but there has been a recent flurry of activity in the subject. Schneider <ref> [Sch93] </ref> presents a survey of the issues in the design of self-stabilizing algorithms. Arora and Gouda [AG93] describe a uniform formal framework for verifying fault-tolerance and self-stability. Varghese [Var92] presents various systematic techniques for designing fault-tolerant algorithms including one based on the algorithm studied in this paper.
Reference: [Var92] <author> G. Varghese. </author> <title> Self-Stabilization by Local Checking and Correction. </title> <type> PhD thesis, </type> <institution> MIT, </institution> <year> 1992. </year>
Reference-contexts: The informal proof of this algorithm is itself quite interesting. A survey of the literature revealed only one attempt at a proof by Varghese <ref> [Var92] </ref> 1 who presents an informal sketch of an argument that is similar to the one used in this paper. As with any distributed algorithm, the verification requires careful attention to details that are easily overlooked in an informal sketch. <p> Schneider [Sch93] presents a survey of the issues in the design of self-stabilizing algorithms. Arora and Gouda [AG93] describe a uniform formal framework for verifying fault-tolerance and self-stability. Varghese <ref> [Var92] </ref> presents various systematic techniques for designing fault-tolerant algorithms including one based on the algorithm studied in this paper. He also provides an informal proof sketch for the correctness of this algorithm that is loosely similar to the one described here.

References-found: 13

