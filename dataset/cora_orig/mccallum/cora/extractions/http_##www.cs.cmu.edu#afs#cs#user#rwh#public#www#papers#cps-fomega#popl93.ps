URL: http://www.cs.cmu.edu/afs/cs/user/rwh/public/www/papers/cps-fomega/popl93.ps
Refering-URL: http://www.cs.cmu.edu/afs/cs/user/rwh/public/www/papers.html
Root-URL: 
Title: Explicit Polymorphism and CPS Conversion  
Author: Robert Harper Mark Lillibridge 
Note: This work was sponsored by the Defense Advanced Research Projects Agency, CSTO, under the title The Fox Project: Advanced Development of Systems Software, ARPA Order No. 8313, issued by ESD/AVS under Contract No. F1962891C0168. Electronic mail address: rwh@cs.cmu.edu. Supported by a National Science Foundation Graduate Fellowship. Electronic mail address: mdl@cs.cmu.edu.  
Address: Pittsburgh, PA 15213  
Affiliation: School of Computer Science Carnegie Mellon University  
Abstract: We study the typing properties of CPS conversion for an extension of F ! with control operators. Two classes of evaluation strategies are considered, each with call-by-name and call-by-value variants. Under the standard strategies, constructor abstractions are values, and constructor applications can lead to non-trivial control effects. In contrast, the ML-like strategies evaluate beneath constructor abstractions, reflecting the usual interpretation of programs in languages based on implicit polymorphism. Three continuation passing style sub-languages are considered, one on which the standard strategies coincide, one on which the ML-like strategies coincide, and one on which all the strategies coincide. Compositional, type-preserving CPS transformation algorithms are given for the standard strategies, resulting in terms on which all evaluation strategies coincide. This has as a corollary the soundness and termination of well-typed programs under the standard evaluation strategies. A similar result is obtained for the ML-like call-by-name strategy. In contrast, such results are obtained for the call-by value ML-like strategy only for a restricted sub-language in which constructor abstractions are limited to values. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Martn Abadi, Luca Cardelli, Benjamin Pierce, and Gordon Plotkin. </author> <title> Dynamic typing in a statically-typed language. </title> <booktitle> In Proceedings of the Sixteenth Annual ACM Symposium on Principles of Programming Languages, </booktitle> <address> Austin. </address> <publisher> ACM, </publisher> <month> Jan-uary </month> <year> 1989. </year>
Reference-contexts: The standard strategies treat constructor abstractions as values and constructor applications as significant computation steps. Standard strategies in this sense are used in Quest [4] and LEAP [35], and are directly compatible with extensions that make significant uses of types at run time (for example, dynamic types <ref> [1, 4] </ref>). Since polymorphic expressions are kept distinct from their instances, the anomalies that arise in implicitly polymorphic languages in the presence of references [45] and control operators [18] do not occur. The ML-like strategies are inspired by the operational semantics of ML [29].
Reference: [2] <author> Andrew W. Appel. </author> <title> Compiling with Continuations. </title> <publisher> Cambridge University Press, </publisher> <year> 1992. </year>
Reference-contexts: Important control constructs such as co-routines [21] and user-level threads [5, 37] can be defined using primitives for reifying continuations. Conversion into continuation-passing style (CPS) is a useful compilation technique for higher-order functional languages <ref> [3, 2, 23, 41] </ref>. Continuations are central to eliciting the computational content of proofs in classical logic [16, 17, 32] and provide a computational interpretation of classical linear logic [12]. The addition of continuation primitives to polymorphic languages has not, however, been an unalloyed success.
Reference: [3] <author> Andrew W. Appel and Trevor Jim. </author> <title> Continuation-passing, closure-passing style. </title> <booktitle> In Sixteenth ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 293302, </pages> <address> Austin, TX, </address> <month> January </month> <year> 1989. </year>
Reference-contexts: Important control constructs such as co-routines [21] and user-level threads [5, 37] can be defined using primitives for reifying continuations. Conversion into continuation-passing style (CPS) is a useful compilation technique for higher-order functional languages <ref> [3, 2, 23, 41] </ref>. Continuations are central to eliciting the computational content of proofs in classical logic [16, 17, 32] and provide a computational interpretation of classical linear logic [12]. The addition of continuation primitives to polymorphic languages has not, however, been an unalloyed success.
Reference: [4] <author> Luca Cardelli. </author> <title> Typeful programming. </title> <type> Technical Report 45, </type> <institution> DEC SRC, </institution> <year> 1989. </year>
Reference-contexts: Numerous extensions of these ideas have been explored in the literature ([7, 25, 31, 45], to name just a few). Although implicit polymorphism is appealingly simple and natural, it does not scale well to more sophisticated language features such as modularity and abstract types [20]. Recent languages, notably Quest <ref> [4] </ref> and LEAP [35], are based instead on the notion of explicit polymorphism introduced by Girard and Reynolds [39]. In these languages, types are an intrinsic part of the programming notation; in particular, polymorphic abstraction and application are expression-forming operations. <p> Some of the convenience of implicit polymorphism may be restored by allowing the omission of certain forms of type information, provided that it can be unambiguously recovered by a type reconstruction algorithm <ref> [4, 26, 34] </ref>. A type discipline is primarily a means of enforcing levels of abstraction [40], and as such is primarily concerned with the static structure and properties of programs. Matters of control are elegantly addressed using the method of continuations. <p> In this paper, we conduct a systematic investigation of the typing properties of CPS conversion for F ! +control, the higher-order polymorphic -calculus of Girard and Reynolds [14, 39] extended with the control primitives callcc and abort. Extensions and variations of F ! lie at the core of Quest <ref> [4] </ref> and LEAP [35], and it is the underlying programming language of the Calculus of Constructions [6, 33]. <p> The standard strategies treat constructor abstractions as values and constructor applications as significant computation steps. Standard strategies in this sense are used in Quest <ref> [4] </ref> and LEAP [35], and are directly compatible with extensions that make significant uses of types at run time (for example, dynamic types [1, 4]). <p> The standard strategies treat constructor abstractions as values and constructor applications as significant computation steps. Standard strategies in this sense are used in Quest [4] and LEAP [35], and are directly compatible with extensions that make significant uses of types at run time (for example, dynamic types <ref> [1, 4] </ref>). Since polymorphic expressions are kept distinct from their instances, the anomalies that arise in implicitly polymorphic languages in the presence of references [45] and control operators [18] do not occur. The ML-like strategies are inspired by the operational semantics of ML [29].
Reference: [5] <author> Eric C. Cooper and J. Gregory Morrisett. </author> <title> Adding threads to Standard ML. </title> <type> Technical Report CMU-CS-90-186, </type> <institution> School of Computer Science, Carnegie Mellon University, </institution> <month> December </month> <year> 1990. </year>
Reference-contexts: Matters of control are elegantly addressed using the method of continuations. The semantics of control operations may be concisely expressed using continuations [9, 36, 38, 42, 43]. Important control constructs such as co-routines [21] and user-level threads <ref> [5, 37] </ref> can be defined using primitives for reifying continuations. Conversion into continuation-passing style (CPS) is a useful compilation technique for higher-order functional languages [3, 2, 23, 41].
Reference: [6] <author> Thierry Coquand and Gerard Huet. </author> <title> The Calculus of Constructions. Information and Computation, </title> <address> 76(2/3):95120, </address> <month> Febru-ary/March </month> <year> 1988. </year>
Reference-contexts: Extensions and variations of F ! lie at the core of Quest [4] and LEAP [35], and it is the underlying programming language of the Calculus of Constructions <ref> [6, 33] </ref>. We extend F ! with control primitives in order to illustrate the role of impure programming language features in the analysis of typing properties of realistic programming languages. (Similar issues and trade-offs arise with mutable data structures (see Tofte [44]) and exceptions [46].
Reference: [7] <author> Luis Manuel Martins Damas. </author> <title> Type Assignment in Programming Languages. </title> <type> PhD thesis, </type> <institution> Edinburgh University, </institution> <year> 1985. </year>
Reference: [8] <author> Bruce Duba, Robert Harper, and David MacQueen. </author> <title> Typing first-class continuations in ML. </title> <booktitle> In Eighteenth ACM Symposium on Principles of Programming Languages, </booktitle> <month> January </month> <year> 1991. </year>
Reference-contexts: Work in this area was initiated by Meyer and Wand for a call-by-value interpretation of the simply-typed -calculus [27], and extended to continuation-passing primitives by Griffin [16] and Duba, et. al. <ref> [8] </ref>. In earlier work, the authors extended these analyses to implicit poly-morphism, and established some limitative results [19]. <p> The focus of our study is on the typing properties of CPS conversion of F ! +control, following the seminal work of Plotkin [36] (extended by Felleisen, et. al. [10, 9]) and Meyer and Wand [27] (extended by Griffin [16] and Duba, et. al. <ref> [8, 18] </ref>). First, we isolate several continuation-passing style sub-languages of F ! . <p> by using the following definitions: abort = flu::x:ff: abort u (x) callcc = flu::x:((8v::u!v)!u): callcc u (x) Note that due to the greater expressiveness of the F ! type system, it is not necessary to introduce a throw operator or a special type of continuations as it is in ML <ref> [8] </ref>. The typing rules for F ! +control appear in the appendix. 3 Operational Semantics for F ! +control In this section, we introduce the two main evaluation strategies for F ! +control, each with a call-by-value and a call-by-name variant. <p> The subject reduction property cannot be extended to full F ! +control, for essentially the same reasons that type soundness fails for the extension of ML with callcc <ref> [8, 18] </ref>.
Reference: [9] <author> Matthias Felleisen. </author> <title> The Calculi of v -CS Conversion: A Syntactic Theory of Control and State in Imperative Higher-Order Programming Languages. </title> <type> PhD thesis, </type> <institution> Indiana University, Bloomington, IN, </institution> <year> 1987. </year>
Reference-contexts: A type discipline is primarily a means of enforcing levels of abstraction [40], and as such is primarily concerned with the static structure and properties of programs. Matters of control are elegantly addressed using the method of continuations. The semantics of control operations may be concisely expressed using continuations <ref> [9, 36, 38, 42, 43] </ref>. Important control constructs such as co-routines [21] and user-level threads [5, 37] can be defined using primitives for reifying continuations. Conversion into continuation-passing style (CPS) is a useful compilation technique for higher-order functional languages [3, 2, 23, 41]. <p> The focus of our study is on the typing properties of CPS conversion of F ! +control, following the seminal work of Plotkin [36] (extended by Felleisen, et. al. <ref> [10, 9] </ref>) and Meyer and Wand [27] (extended by Griffin [16] and Duba, et. al. [8, 18]). First, we isolate several continuation-passing style sub-languages of F ! .
Reference: [10] <author> Matthias Felleisen and Daniel Friedman. </author> <title> Control operators, the SECD machine, and the -calculus. In Formal Description of Programming Concepts III. </title> <publisher> North-Holland, </publisher> <year> 1986. </year>
Reference-contexts: The focus of our study is on the typing properties of CPS conversion of F ! +control, following the seminal work of Plotkin [36] (extended by Felleisen, et. al. <ref> [10, 9] </ref>) and Meyer and Wand [27] (extended by Griffin [16] and Duba, et. al. [8, 18]). First, we isolate several continuation-passing style sub-languages of F ! .
Reference: [11] <author> Matthias Felleisen, Daniel Friedman, Eugene Kohlbecker, and Bruce Duba. </author> <title> Reasoning with continuations. </title> <booktitle> In First Symposium on Logic in Computer Science. IEEE, </booktitle> <month> June </month> <year> 1986. </year>
Reference-contexts: by evaluating beneath type abstractions comes at considerable cost since it is incompatible with extensions such as mutable data structures and control operators [45, 18, 19]. 3.1 Notation The definitions of these strategies make use of Plotkin's notion of a syntactic value [36] and Felleisen's notion of an evaluation context <ref> [11] </ref>, chosen suitably for each situation. To specify a strategy using this method, we first give a grammar which defines three syntactic categories: V , a set of values, R, a set of redices, and E, a set of evaluation contexts.
Reference: [12] <author> Andrzej Filinski. </author> <title> Linear continuations. </title> <booktitle> In Nineteenth ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 2738, </pages> <address> Albuquerque, NM, </address> <month> January </month> <year> 1992. </year> <note> ACM SIG-PLAN/SIGACT. </note>
Reference-contexts: Conversion into continuation-passing style (CPS) is a useful compilation technique for higher-order functional languages [3, 2, 23, 41]. Continuations are central to eliciting the computational content of proofs in classical logic [16, 17, 32] and provide a computational interpretation of classical linear logic <ref> [12] </ref>. The addition of continuation primitives to polymorphic languages has not, however, been an unalloyed success. In particular, a very natural typing discipline for first-class continuations in Standard ML has proved to be unsound [18, 19].
Reference: [13] <author> Jean Gallier. </author> <title> On girard's candidats de reductibilite. </title> <editor> In P. Odifreddi, editor, </editor> <booktitle> Logic and Computation, volume 31 of The APIC Series, </booktitle> <pages> pages 123203. </pages> <publisher> Academic Press, </publisher> <year> 1990. </year>
Reference-contexts: The restriction of CBV evaluation to pure programs is a particular fi-reduction strategy. It follows from the strong normalization property of F ! <ref> [14, 13] </ref> that CBV evaluation of pure programs terminates. Termination of CBV evaluation for full F ! +control will be established in Section 5. The following property of CBV evaluation will be important to that argument.
Reference: [14] <author> Jean-Yves Girard. </author> <title> Interpretation Fonctionelle et Elimination des Coupures dans l'Arithmetique d'Ordre Superieure. </title> <type> PhD thesis, </type> <institution> Universite Paris VII, </institution> <year> 1972. </year>
Reference-contexts: 1 Introduction Among the many advances in the theory and practice of programming language design, the concepts of polymor-phism <ref> [14, 28, 39] </ref> and continuation-passing [38, 41, 43] are of particular interest. The use of polymorphism in a practical programming language was first explored in ML [15, 28, 29]. <p> In earlier work, the authors extended these analyses to implicit poly-morphism, and established some limitative results [19]. In this paper, we conduct a systematic investigation of the typing properties of CPS conversion for F ! +control, the higher-order polymorphic -calculus of Girard and Reynolds <ref> [14, 39] </ref> extended with the control primitives callcc and abort. Extensions and variations of F ! lie at the core of Quest [4] and LEAP [35], and it is the underlying programming language of the Calculus of Constructions [6, 33]. <p> The restriction of CBV evaluation to pure programs is a particular fi-reduction strategy. It follows from the strong normalization property of F ! <ref> [14, 13] </ref> that CBV evaluation of pure programs terminates. Termination of CBV evaluation for full F ! +control will be established in Section 5. The following property of CBV evaluation will be important to that argument.
Reference: [15] <author> Michael Gordon, Robin Milner, and Christopher Wadsworth. </author> <title> Edinburgh LCF: A Mechanized Logic of Computation, </title> <booktitle> volume 78 of Lecture Notes in Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1979. </year>
Reference-contexts: 1 Introduction Among the many advances in the theory and practice of programming language design, the concepts of polymor-phism [14, 28, 39] and continuation-passing [38, 41, 43] are of particular interest. The use of polymorphism in a practical programming language was first explored in ML <ref> [15, 28, 29] </ref>. This style of polymorphism, called implicit polymorphism, is based on the idea that programs are type-free, with types interpreted as predicates expressing properties of programs under evaluation. Numerous extensions of these ideas have been explored in the literature ([7, 25, 31, 45], to name just a few).
Reference: [16] <author> Timothy Griffin. </author> <title> A formulae-as-types notion of control. </title> <booktitle> In Seventeenth ACM Symposium on Principles of Programming Languages, </booktitle> <address> San Francisco, CA, </address> <month> January </month> <year> 1990. </year> <note> ACM, ACM. </note>
Reference-contexts: Conversion into continuation-passing style (CPS) is a useful compilation technique for higher-order functional languages [3, 2, 23, 41]. Continuations are central to eliciting the computational content of proofs in classical logic <ref> [16, 17, 32] </ref> and provide a computational interpretation of classical linear logic [12]. The addition of continuation primitives to polymorphic languages has not, however, been an unalloyed success. In particular, a very natural typing discipline for first-class continuations in Standard ML has proved to be unsound [18, 19]. <p> Work in this area was initiated by Meyer and Wand for a call-by-value interpretation of the simply-typed -calculus [27], and extended to continuation-passing primitives by Griffin <ref> [16] </ref> and Duba, et. al. [8]. In earlier work, the authors extended these analyses to implicit poly-morphism, and established some limitative results [19]. <p> The focus of our study is on the typing properties of CPS conversion of F ! +control, following the seminal work of Plotkin [36] (extended by Felleisen, et. al. [10, 9]) and Meyer and Wand [27] (extended by Griffin <ref> [16] </ref> and Duba, et. al. [8, 18]). First, we isolate several continuation-passing style sub-languages of F ! .
Reference: [17] <author> Timothy G. Griffin. </author> <title> Logical interpretations and computational simulations. </title> <type> Tech. memo., </type> <institution> AT&T Bell Laboratories, </institution> <year> 1992. </year> <note> in preparation. </note>
Reference-contexts: Conversion into continuation-passing style (CPS) is a useful compilation technique for higher-order functional languages [3, 2, 23, 41]. Continuations are central to eliciting the computational content of proofs in classical logic <ref> [16, 17, 32] </ref> and provide a computational interpretation of classical linear logic [12]. The addition of continuation primitives to polymorphic languages has not, however, been an unalloyed success. In particular, a very natural typing discipline for first-class continuations in Standard ML has proved to be unsound [18, 19].
Reference: [18] <author> Robert Harper, Bruce Duba, and David MacQueen. </author> <title> Typing first-class continuations in ML. </title> <note> Revised and expanded version of [8]. To appear, Journal of Functional Programming. </note>
Reference-contexts: The addition of continuation primitives to polymorphic languages has not, however, been an unalloyed success. In particular, a very natural typing discipline for first-class continuations in Standard ML has proved to be unsound <ref> [18, 19] </ref>. Since the semantics of first-class continuations may be expressed by conversion into continuation-passing style, it is natural to investigate their typing properties by considering the relation between the type of a term and the type of its CPS transform. <p> The focus of our study is on the typing properties of CPS conversion of F ! +control, following the seminal work of Plotkin [36] (extended by Felleisen, et. al. [10, 9]) and Meyer and Wand [27] (extended by Griffin [16] and Duba, et. al. <ref> [8, 18] </ref>). First, we isolate several continuation-passing style sub-languages of F ! . <p> Since polymorphic expressions are kept distinct from their instances, the anomalies that arise in implicitly polymorphic languages in the presence of references [45] and control operators <ref> [18] </ref> do not occur. The ML-like strategies are inspired by the operational semantics of ML [29]. Evaluation proceeds beneath constructor abstractions, leading to a once-for-all-instances evaluation of polymorphic terms. <p> The superficial efficiency improvement gained by evaluating beneath type abstractions comes at considerable cost since it is incompatible with extensions such as mutable data structures and control operators <ref> [45, 18, 19] </ref>. 3.1 Notation The definitions of these strategies make use of Plotkin's notion of a syntactic value [36] and Felleisen's notion of an evaluation context [11], chosen suitably for each situation. <p> The subject reduction property cannot be extended to full F ! +control, for essentially the same reasons that type soundness fails for the extension of ML with callcc <ref> [8, 18] </ref>.
Reference: [19] <author> Robert Harper and Mark Lillibridge. </author> <title> Polymorphic type assignment and cps conversion. </title> <editor> In Olivier Danvy and Carolyn Talcott, editors, </editor> <booktitle> Proceedings of the ACM SIGPLAN Workshop on Continuations CW92, </booktitle> <pages> pages 1322, </pages> <address> Stanford, CA 94305, </address> <month> June </month> <year> 1992. </year> <institution> Department of Computer Science, Stanford University. </institution> <note> Published as technical report STANCS921426. </note>
Reference-contexts: The addition of continuation primitives to polymorphic languages has not, however, been an unalloyed success. In particular, a very natural typing discipline for first-class continuations in Standard ML has proved to be unsound <ref> [18, 19] </ref>. Since the semantics of first-class continuations may be expressed by conversion into continuation-passing style, it is natural to investigate their typing properties by considering the relation between the type of a term and the type of its CPS transform. <p> Work in this area was initiated by Meyer and Wand for a call-by-value interpretation of the simply-typed -calculus [27], and extended to continuation-passing primitives by Griffin [16] and Duba, et. al. [8]. In earlier work, the authors extended these analyses to implicit poly-morphism, and established some limitative results <ref> [19] </ref>. In this paper, we conduct a systematic investigation of the typing properties of CPS conversion for F ! +control, the higher-order polymorphic -calculus of Girard and Reynolds [14, 39] extended with the control primitives callcc and abort. <p> The superficial efficiency improvement gained by evaluating beneath type abstractions comes at considerable cost since it is incompatible with extensions such as mutable data structures and control operators <ref> [45, 18, 19] </ref>. 3.1 Notation The definitions of these strategies make use of Plotkin's notion of a syntactic value [36] and Felleisen's notion of an evaluation context [11], chosen suitably for each situation. <p> But this is strictly stronger than the condition on E given by the decomposition theorem, as remarked above. This observation may be turned into a counterexample to subject reduction by a simple adaptation of the argument given elsewhere by the authors <ref> [19] </ref>, taking advantage of the call-by-value strategy to simulate the sequential semantics of the ML let construct. A simple way to avoid the counterexample is to rule out programs with non-trivial evaluation steps lying within the scope of a constructor abstraction. <p> However, it does not seem possible to give a CPS transform for the pure language under ML-CBV <ref> [19] </ref>. <p> Such a transformation is possible for the fragment F ! +control in which constructor abstractions are limited to values, which is consistent with a similar restriction in the untyped case <ref> [19] </ref>. The ML-like call-by-name strategy (ML-CBN 0 ) is unproblematic but uninteresting because it is (almost) identical to the standard call-by-name strategy. It only differs on j; .
Reference: [20] <author> Robert Harper and John C. Mitchell. </author> <title> On the type structure of Standard ML. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> ?(?):??, ? <note> 1992? (To appear. See also [30].). </note>
Reference-contexts: Numerous extensions of these ideas have been explored in the literature ([7, 25, 31, 45], to name just a few). Although implicit polymorphism is appealingly simple and natural, it does not scale well to more sophisticated language features such as modularity and abstract types <ref> [20] </ref>. Recent languages, notably Quest [4] and LEAP [35], are based instead on the notion of explicit polymorphism introduced by Girard and Reynolds [39]. In these languages, types are an intrinsic part of the programming notation; in particular, polymorphic abstraction and application are expression-forming operations.
Reference: [21] <author> Christopher T. Haynes, Daniel P. Friedman, and Mitchell Wand. </author> <title> Obtaining coroutines from continuations. </title> <journal> Journal of Computer Languages, </journal> <volume> 11:143153, </volume> <year> 1986. </year>
Reference-contexts: Matters of control are elegantly addressed using the method of continuations. The semantics of control operations may be concisely expressed using continuations [9, 36, 38, 42, 43]. Important control constructs such as co-routines <ref> [21] </ref> and user-level threads [5, 37] can be defined using primitives for reifying continuations. Conversion into continuation-passing style (CPS) is a useful compilation technique for higher-order functional languages [3, 2, 23, 41].
Reference: [22] <editor> Gerard Huet, editor. </editor> <booktitle> Logical Foundations of Functional Programming. University of Texas at Austin Year of Programming Series. </booktitle> <publisher> Addison-Wesley, </publisher> <year> 1990. </year>
Reference: [23] <author> D. Kranz, R. Kelsey, J. Rees, P. Hudak, J.Philbin, and N. Adams. </author> <title> Orbit: An optimizing compiler for Scheme. </title> <booktitle> In Proc. SIGPLAN Symposium on Compiler Construction, pages 219233. ACM SIGPLAN, </booktitle> <year> 1986. </year>
Reference-contexts: Important control constructs such as co-routines [21] and user-level threads [5, 37] can be defined using primitives for reifying continuations. Conversion into continuation-passing style (CPS) is a useful compilation technique for higher-order functional languages <ref> [3, 2, 23, 41] </ref>. Continuations are central to eliciting the computational content of proofs in classical logic [16, 17, 32] and provide a computational interpretation of classical linear logic [12]. The addition of continuation primitives to polymorphic languages has not, however, been an unalloyed success.
Reference: [24] <author> Xavier leroy. </author> <title> Polymorphism by name. </title> <booktitle> In Twentieth ACM Symposium on Principles of Programming Languages, </booktitle> <month> Jan-uary </month> <year> 1993. </year>
Reference-contexts: We extend F ! with control primitives in order to illustrate the role of impure programming language features in the analysis of typing properties of realistic programming languages. (Similar issues and trade-offs arise with mutable data structures (see Tofte [44]) and exceptions [46]. See Leroy <ref> [24] </ref> for related discussion.) We consider two classes of evaluation strategies for F ! +control, each with a call-by-value and a call-by-name variant. Under the standard strategies, type abstractions are values and type applications are significant evaluation steps.
Reference: [25] <author> Xavier Leroy and Pierre Weis. </author> <title> Polymorphic type inference and assignment. </title> <booktitle> In Eighteenth ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 291302, </pages> <address> Orlando, FL, </address> <month> January </month> <year> 1991. </year> <note> ACM SIGACT/SIGPLAN. </note>
Reference: [26] <author> Zhaolui Luo, Robert Pollack, and Paul Taylor. </author> <title> How to use lego: A preliminary user's manual. </title> <type> Technical Report LFCS-TN-27, </type> <institution> Laboratory for the Foundations of Computer Science, Edinburgh University, </institution> <month> October </month> <year> 1989. </year>
Reference-contexts: Some of the convenience of implicit polymorphism may be restored by allowing the omission of certain forms of type information, provided that it can be unambiguously recovered by a type reconstruction algorithm <ref> [4, 26, 34] </ref>. A type discipline is primarily a means of enforcing levels of abstraction [40], and as such is primarily concerned with the static structure and properties of programs. Matters of control are elegantly addressed using the method of continuations.
Reference: [27] <author> Albert R. Meyer and Mitchell Wand. </author> <title> Continuation semantics in typed lambda calculi (summary). </title> <editor> In Rohit Parikh, editor, </editor> <booktitle> Logics of Programs, volume 224 of Lecture Notes in Computer Science, </booktitle> <pages> pages 219224. </pages> <publisher> Springer-Verlag, </publisher> <year> 1985. </year>
Reference-contexts: Work in this area was initiated by Meyer and Wand for a call-by-value interpretation of the simply-typed -calculus <ref> [27] </ref>, and extended to continuation-passing primitives by Griffin [16] and Duba, et. al. [8]. In earlier work, the authors extended these analyses to implicit poly-morphism, and established some limitative results [19]. <p> The focus of our study is on the typing properties of CPS conversion of F ! +control, following the seminal work of Plotkin [36] (extended by Felleisen, et. al. [10, 9]) and Meyer and Wand <ref> [27] </ref> (extended by Griffin [16] and Duba, et. al. [8, 18]). First, we isolate several continuation-passing style sub-languages of F ! .
Reference: [28] <author> Robin Milner. </author> <title> A theory of type polymorphism in programming languages. </title> <journal> Journal of Computer and System Sciences, </journal> <volume> 17:348375, </volume> <year> 1978. </year>
Reference-contexts: 1 Introduction Among the many advances in the theory and practice of programming language design, the concepts of polymor-phism <ref> [14, 28, 39] </ref> and continuation-passing [38, 41, 43] are of particular interest. The use of polymorphism in a practical programming language was first explored in ML [15, 28, 29]. <p> 1 Introduction Among the many advances in the theory and practice of programming language design, the concepts of polymor-phism [14, 28, 39] and continuation-passing [38, 41, 43] are of particular interest. The use of polymorphism in a practical programming language was first explored in ML <ref> [15, 28, 29] </ref>. This style of polymorphism, called implicit polymorphism, is based on the idea that programs are type-free, with types interpreted as predicates expressing properties of programs under evaluation. Numerous extensions of these ideas have been explored in the literature ([7, 25, 31, 45], to name just a few).
Reference: [29] <author> Robin Milner, Mads Tofte, and Robert Harper. </author> <title> The Definition of Standard ML. </title> <publisher> MIT Press, </publisher> <year> 1990. </year>
Reference-contexts: 1 Introduction Among the many advances in the theory and practice of programming language design, the concepts of polymor-phism [14, 28, 39] and continuation-passing [38, 41, 43] are of particular interest. The use of polymorphism in a practical programming language was first explored in ML <ref> [15, 28, 29] </ref>. This style of polymorphism, called implicit polymorphism, is based on the idea that programs are type-free, with types interpreted as predicates expressing properties of programs under evaluation. Numerous extensions of these ideas have been explored in the literature ([7, 25, 31, 45], to name just a few). <p> Since polymorphic expressions are kept distinct from their instances, the anomalies that arise in implicitly polymorphic languages in the presence of references [45] and control operators [18] do not occur. The ML-like strategies are inspired by the operational semantics of ML <ref> [29] </ref>. Evaluation proceeds beneath constructor abstractions, leading to a once-for-all-instances evaluation of polymorphic terms. Constructor application is retained as a computation step, but its force is significantly attenuated by the fact that type expressions may have free type variables in them, precluding primitives that inductively analyze their type arguments.
Reference: [30] <author> John Mitchell and Robert Harper. </author> <title> The essence of ML. </title> <booktitle> In Fifteenth ACM Symposium on Principles of Programming Languages, </booktitle> <address> San Diego, California, </address> <month> January </month> <year> 1988. </year>
Reference: [31] <author> John C. Mitchell. </author> <title> Polymorphic type inference and containment. </title> <journal> Information and Computation, </journal> <note> 76(2/3):211249, 1988. (Reprinted in [22], pp. 153194.). </note>
Reference: [32] <author> Chetan Murthy. </author> <title> Extracting Constructive Content from Classical Proofs. </title> <type> PhD thesis, </type> <institution> Cornell University, </institution> <address> Ithaca, NY, </address> <month> August </month> <year> 1990. </year>
Reference-contexts: Conversion into continuation-passing style (CPS) is a useful compilation technique for higher-order functional languages [3, 2, 23, 41]. Continuations are central to eliciting the computational content of proofs in classical logic <ref> [16, 17, 32] </ref> and provide a computational interpretation of classical linear logic [12]. The addition of continuation primitives to polymorphic languages has not, however, been an unalloyed success. In particular, a very natural typing discipline for first-class continuations in Standard ML has proved to be unsound [18, 19].
Reference: [33] <author> Christine Paulin-Mohring. </author> <title> Extracting F ! 's programs from proofs in the calculus of constructions. </title> <booktitle> In Sixteenth ACM Symposium on Principles of Programming Languages, </booktitle> <year> 1989. </year>
Reference-contexts: Extensions and variations of F ! lie at the core of Quest [4] and LEAP [35], and it is the underlying programming language of the Calculus of Constructions <ref> [6, 33] </ref>. We extend F ! with control primitives in order to illustrate the role of impure programming language features in the analysis of typing properties of realistic programming languages. (Similar issues and trade-offs arise with mutable data structures (see Tofte [44]) and exceptions [46].
Reference: [34] <author> Frank Pfenning. </author> <title> On the undecidability of partial polymorphic type reconstruction. </title> <note> Fundamenta Informaticae, 199? To appear. Preliminary version available as Technical Report CMUCS92105, </note> <institution> School of Computer Science, Carnegie Mellon University, Pittsburgh, Pennsylvania, </institution> <month> January </month> <year> 1992. </year>
Reference-contexts: Some of the convenience of implicit polymorphism may be restored by allowing the omission of certain forms of type information, provided that it can be unambiguously recovered by a type reconstruction algorithm <ref> [4, 26, 34] </ref>. A type discipline is primarily a means of enforcing levels of abstraction [40], and as such is primarily concerned with the static structure and properties of programs. Matters of control are elegantly addressed using the method of continuations.
Reference: [35] <author> Frank Pfenning and Peter Lee. </author> <title> LEAP: A language with eval and polymorphism. </title> <booktitle> In TAPSOFT '89, Proceedings of the International Joint Conference on Theory and Practice in Software Development, Barcelona, Spain, </booktitle> <pages> pages 345359. </pages> <publisher> Springer-Verlag LNCS 352, </publisher> <month> March </month> <year> 1989. </year>
Reference-contexts: Although implicit polymorphism is appealingly simple and natural, it does not scale well to more sophisticated language features such as modularity and abstract types [20]. Recent languages, notably Quest [4] and LEAP <ref> [35] </ref>, are based instead on the notion of explicit polymorphism introduced by Girard and Reynolds [39]. In these languages, types are an intrinsic part of the programming notation; in particular, polymorphic abstraction and application are expression-forming operations. <p> Extensions and variations of F ! lie at the core of Quest [4] and LEAP <ref> [35] </ref>, and it is the underlying programming language of the Calculus of Constructions [6, 33]. <p> The standard strategies treat constructor abstractions as values and constructor applications as significant computation steps. Standard strategies in this sense are used in Quest [4] and LEAP <ref> [35] </ref>, and are directly compatible with extensions that make significant uses of types at run time (for example, dynamic types [1, 4]).
Reference: [36] <author> Gordon Plotkin. </author> <title> Call-by-name, call-by-value, and the lambda calculus. </title> <booktitle> Theoretical Computer Science, </booktitle> <address> 1:125159, </address> <year> 1975. </year>
Reference-contexts: A type discipline is primarily a means of enforcing levels of abstraction [40], and as such is primarily concerned with the static structure and properties of programs. Matters of control are elegantly addressed using the method of continuations. The semantics of control operations may be concisely expressed using continuations <ref> [9, 36, 38, 42, 43] </ref>. Important control constructs such as co-routines [21] and user-level threads [5, 37] can be defined using primitives for reifying continuations. Conversion into continuation-passing style (CPS) is a useful compilation technique for higher-order functional languages [3, 2, 23, 41]. <p> The focus of our study is on the typing properties of CPS conversion of F ! +control, following the seminal work of Plotkin <ref> [36] </ref> (extended by Felleisen, et. al. [10, 9]) and Meyer and Wand [27] (extended by Griffin [16] and Duba, et. al. [8, 18]). First, we isolate several continuation-passing style sub-languages of F ! . <p> The superficial efficiency improvement gained by evaluating beneath type abstractions comes at considerable cost since it is incompatible with extensions such as mutable data structures and control operators [45, 18, 19]. 3.1 Notation The definitions of these strategies make use of Plotkin's notion of a syntactic value <ref> [36] </ref> and Felleisen's notion of an evaluation context [11], chosen suitably for each situation. To specify a strategy using this method, we first give a grammar which defines three syntactic categories: V , a set of values, R, a set of redices, and E, a set of evaluation contexts. <p> M fl : A fl . In the following theorem we write jP j V for the call-by-value CPS transform of P applied to the continuation V with so-called administrative redices (in the sense of Plotkin <ref> [36] </ref>) eliminated. 2 Theorem 5.6 (CBV Simulation) If P is a program and P ,! cbv Q, then jP j x:ff:x ,! fl fi jQj x:ff:x . Moreover, each fi-step induces at least one fi-step on the converted form. Theorem 5.7 For any program P , 1.
Reference: [37] <author> John Reppy. </author> <title> First-class synchronous operations in standard ML. </title> <type> Technical Report TR 89-1068, </type> <institution> Computer Science Department, Cornell University, </institution> <address> Ithaca, NY, </address> <month> December </month> <year> 1989. </year>
Reference-contexts: Matters of control are elegantly addressed using the method of continuations. The semantics of control operations may be concisely expressed using continuations [9, 36, 38, 42, 43]. Important control constructs such as co-routines [21] and user-level threads <ref> [5, 37] </ref> can be defined using primitives for reifying continuations. Conversion into continuation-passing style (CPS) is a useful compilation technique for higher-order functional languages [3, 2, 23, 41].
Reference: [38] <author> John C. Reynolds. </author> <title> Definitional interpreters for higher-order programming languages. </title> <booktitle> In Conference Record of the 25th National ACM Conference, </booktitle> <pages> pages 717740, </pages> <address> Boston, </address> <month> August </month> <year> 1972. </year> <note> ACM. </note>
Reference-contexts: 1 Introduction Among the many advances in the theory and practice of programming language design, the concepts of polymor-phism [14, 28, 39] and continuation-passing <ref> [38, 41, 43] </ref> are of particular interest. The use of polymorphism in a practical programming language was first explored in ML [15, 28, 29]. <p> A type discipline is primarily a means of enforcing levels of abstraction [40], and as such is primarily concerned with the static structure and properties of programs. Matters of control are elegantly addressed using the method of continuations. The semantics of control operations may be concisely expressed using continuations <ref> [9, 36, 38, 42, 43] </ref>. Important control constructs such as co-routines [21] and user-level threads [5, 37] can be defined using primitives for reifying continuations. Conversion into continuation-passing style (CPS) is a useful compilation technique for higher-order functional languages [3, 2, 23, 41]. <p> 0 where V 0 is such that V fl ,! fl fi V 0 . 5.4 Alternative ML-like CPS Transforms The constructor transforms for the standard strategies are based on the definition (8u:K:A) fl = 8u:K:jAj, expressing the idea that constructor applications are serious computations (in the sense of Reynolds <ref> [38] </ref>), and hence require a continuation. However, for terms of F ! +control there are no such non-trivial computations (the continuation is always immediately invoked with a value), and hence we may contemplate eliminating the continuation argument entirely.
Reference: [39] <author> John C. Reynolds. </author> <title> Towards a theory of type structure. </title> <booktitle> In Colloq. sur la Programmation, volume 19 of Lecture Notes in Computer Science, </booktitle> <pages> pages 408423. </pages> <publisher> Springer-Verlag, </publisher> <year> 1974. </year>
Reference-contexts: 1 Introduction Among the many advances in the theory and practice of programming language design, the concepts of polymor-phism <ref> [14, 28, 39] </ref> and continuation-passing [38, 41, 43] are of particular interest. The use of polymorphism in a practical programming language was first explored in ML [15, 28, 29]. <p> Although implicit polymorphism is appealingly simple and natural, it does not scale well to more sophisticated language features such as modularity and abstract types [20]. Recent languages, notably Quest [4] and LEAP [35], are based instead on the notion of explicit polymorphism introduced by Girard and Reynolds <ref> [39] </ref>. In these languages, types are an intrinsic part of the programming notation; in particular, polymorphic abstraction and application are expression-forming operations. <p> In earlier work, the authors extended these analyses to implicit poly-morphism, and established some limitative results [19]. In this paper, we conduct a systematic investigation of the typing properties of CPS conversion for F ! +control, the higher-order polymorphic -calculus of Girard and Reynolds <ref> [14, 39] </ref> extended with the control primitives callcc and abort. Extensions and variations of F ! lie at the core of Quest [4] and LEAP [35], and it is the underlying programming language of the Calculus of Constructions [6, 33].
Reference: [40] <author> John C. Reynolds. </author> <title> Types, abstraction, and parametric poly-morphism. </title> <editor> In R. E. A. Mason, editor, </editor> <booktitle> Information Processing '83, </booktitle> <pages> pages 513523. </pages> <publisher> Elsevier Science Publishers B. V., </publisher> <year> 1983. </year>
Reference-contexts: Some of the convenience of implicit polymorphism may be restored by allowing the omission of certain forms of type information, provided that it can be unambiguously recovered by a type reconstruction algorithm [4, 26, 34]. A type discipline is primarily a means of enforcing levels of abstraction <ref> [40] </ref>, and as such is primarily concerned with the static structure and properties of programs. Matters of control are elegantly addressed using the method of continuations. The semantics of control operations may be concisely expressed using continuations [9, 36, 38, 42, 43].
Reference: [41] <author> Guy L. Steele, Jr. RABBIT: </author> <title> A compiler for SCHEME. </title> <type> Technical Report Memo 474, </type> <institution> MIT AI Laboratory, </institution> <year> 1978. </year>
Reference-contexts: 1 Introduction Among the many advances in the theory and practice of programming language design, the concepts of polymor-phism [14, 28, 39] and continuation-passing <ref> [38, 41, 43] </ref> are of particular interest. The use of polymorphism in a practical programming language was first explored in ML [15, 28, 29]. <p> Important control constructs such as co-routines [21] and user-level threads [5, 37] can be defined using primitives for reifying continuations. Conversion into continuation-passing style (CPS) is a useful compilation technique for higher-order functional languages <ref> [3, 2, 23, 41] </ref>. Continuations are central to eliciting the computational content of proofs in classical logic [16, 17, 32] and provide a computational interpretation of classical linear logic [12]. The addition of continuation primitives to polymorphic languages has not, however, been an unalloyed success.
Reference: [42] <author> Joseph Stoy. </author> <title> Denotational Semantics: The Scott-Strachey Approach to Programming Language Theory. </title> <publisher> MIT Press, </publisher> <year> 1977. </year>
Reference-contexts: A type discipline is primarily a means of enforcing levels of abstraction [40], and as such is primarily concerned with the static structure and properties of programs. Matters of control are elegantly addressed using the method of continuations. The semantics of control operations may be concisely expressed using continuations <ref> [9, 36, 38, 42, 43] </ref>. Important control constructs such as co-routines [21] and user-level threads [5, 37] can be defined using primitives for reifying continuations. Conversion into continuation-passing style (CPS) is a useful compilation technique for higher-order functional languages [3, 2, 23, 41].
Reference: [43] <author> Christopher Strachey and Christopher Wadsworth. </author> <title> A mathematical semantics for handling full jumps. </title> <type> Technical Report Technical Monograph PRG11, </type> <institution> Oxford University Computing Laboratory, </institution> <year> 1974. </year>
Reference-contexts: 1 Introduction Among the many advances in the theory and practice of programming language design, the concepts of polymor-phism [14, 28, 39] and continuation-passing <ref> [38, 41, 43] </ref> are of particular interest. The use of polymorphism in a practical programming language was first explored in ML [15, 28, 29]. <p> A type discipline is primarily a means of enforcing levels of abstraction [40], and as such is primarily concerned with the static structure and properties of programs. Matters of control are elegantly addressed using the method of continuations. The semantics of control operations may be concisely expressed using continuations <ref> [9, 36, 38, 42, 43] </ref>. Important control constructs such as co-routines [21] and user-level threads [5, 37] can be defined using primitives for reifying continuations. Conversion into continuation-passing style (CPS) is a useful compilation technique for higher-order functional languages [3, 2, 23, 41].
Reference: [44] <author> Mads Tofte. </author> <title> Operational Semantics and Polymorphic Type Inference. </title> <type> PhD thesis, </type> <institution> Edinburgh University, </institution> <year> 1988. </year> <note> Available as Edinburgh University Laboratory for Foundations of Computer Science Technical Report ECSLFCS8854. </note>
Reference-contexts: We extend F ! with control primitives in order to illustrate the role of impure programming language features in the analysis of typing properties of realistic programming languages. (Similar issues and trade-offs arise with mutable data structures (see Tofte <ref> [44] </ref>) and exceptions [46]. See Leroy [24] for related discussion.) We consider two classes of evaluation strategies for F ! +control, each with a call-by-value and a call-by-name variant. Under the standard strategies, type abstractions are values and type applications are significant evaluation steps.
Reference: [45] <author> Mads Tofte. </author> <title> Type inference for polymorphic references. Information and Computation, </title> <address> 89:134, </address> <month> November </month> <year> 1990. </year>
Reference-contexts: Since polymorphic expressions are kept distinct from their instances, the anomalies that arise in implicitly polymorphic languages in the presence of references <ref> [45] </ref> and control operators [18] do not occur. The ML-like strategies are inspired by the operational semantics of ML [29]. Evaluation proceeds beneath constructor abstractions, leading to a once-for-all-instances evaluation of polymorphic terms. <p> The superficial efficiency improvement gained by evaluating beneath type abstractions comes at considerable cost since it is incompatible with extensions such as mutable data structures and control operators <ref> [45, 18, 19] </ref>. 3.1 Notation The definitions of these strategies make use of Plotkin's notion of a syntactic value [36] and Felleisen's notion of an evaluation context [11], chosen suitably for each situation.
Reference: [46] <author> Andrew K. Wright and Matthias Felleisen. </author> <title> A syntactic approach to type soundness. </title> <type> Technical Report TR91160, </type> <institution> Department of Computer Science, Rice University, </institution> <month> July </month> <year> 1991. </year> <note> To appear, Information and Computation. </note>
Reference-contexts: We extend F ! with control primitives in order to illustrate the role of impure programming language features in the analysis of typing properties of realistic programming languages. (Similar issues and trade-offs arise with mutable data structures (see Tofte [44]) and exceptions <ref> [46] </ref>. See Leroy [24] for related discussion.) We consider two classes of evaluation strategies for F ! +control, each with a call-by-value and a call-by-name variant. Under the standard strategies, type abstractions are values and type applications are significant evaluation steps.
References-found: 46

