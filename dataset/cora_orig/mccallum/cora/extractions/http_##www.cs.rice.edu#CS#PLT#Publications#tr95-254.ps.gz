URL: http://www.cs.rice.edu/CS/PLT/Publications/tr95-254.ps.gz
Refering-URL: http://www.cs.rice.edu/CS/PLT/Publications/
Root-URL: 
Title: Set-Based Analysis for Full Scheme and Its Use in Soft-Typing  
Author: Cormac Flanagan Matthias Felleisen 
Date: October 1995  
Address: COMP TR95-254  P.O. Box 1892 Houston, TX 77251-1892  
Affiliation: Rice  Department of Computer Science Rice University  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> Aiken, A., Wimmers, E. L., and Lakshman, T. K. </author> <title> Soft typing with conditional types. </title> <booktitle> In Proceedings of the ACM Sigplan Conference on Principles of Programming Languages (1994), </booktitle> <pages> pp. </pages> <month> 163-173. </month> <title> Set-Based Analysis for Full Scheme and Its Use in Soft-Typing 29 </title>
Reference-contexts: Examples include partial evaluation [15], escape analysis [18], redundant test elimination [11], closure analysis [21], touch-optimization [8, 7], dead-code elimination, constant-folding and code hoisting. Here, we illustrate how set-based analysis applies to soft typing <ref> [4, 28, 1, 12, 14] </ref>. 6.1 Soft Typing The programming language Scheme [2] is a dynamically-typed language, which imposes no restrictions on the values that variables or expressions in a program may assume. <p> The extended language is called fl !+c a . We define the semantics of the extended language fl !+c a by extending the CS-machine with the additional transition rules described in Figure 5. The evaluator for the extended 6 Unlike other approaches to soft-typing <ref> [4, 28, 1] </ref>, we are not concerned with inferring types for program Set-Based Analysis for Full Scheme and Its Use in Soft-Typing 21 h H; E [ (let (x (car l y )) M ) ] i 8 : h H [ fl x = H (l z 1 )g; E <p> This Set-Based Analysis for Full Scheme and Its Use in Soft-Typing 23 extensibility is essential for analyzing programs in languages with higher-order functions as well as imperative features. In this section, we compare our derivation with a number of comparable program analyzes, including an advanced type inference algorithm <ref> [1] </ref> and two recent variants [23, 13] of Shivers' 0CFA [22] Aiken et al. [1] develop a type inference algorithm for a purely functional language. They reduce the type inference problem to a system of type inclusion constraints, which are similar to our set constraints. <p> In this section, we compare our derivation with a number of comparable program analyzes, including an advanced type inference algorithm <ref> [1] </ref> and two recent variants [23, 13] of Shivers' 0CFA [22] Aiken et al. [1] develop a type inference algorithm for a purely functional language. They reduce the type inference problem to a system of type inclusion constraints, which are similar to our set constraints.
Reference: [2] <author> Clinger, W., and Jonathan Rees, e. </author> <title> The revised 4 report on the algorithmic language scheme. </title> <booktitle> ACM Lisp Pointers 4, </booktitle> <month> 3 (July </month> <year> 1991). </year>
Reference-contexts: 1 Introduction Advanced compiler optimizations heavily rely on static information about the values that program variables may assume. Computing such information for higher-order languages such as Scheme <ref> [2] </ref> and ML [16] is particularly complex, since a static control-flow graph of a program is not readily available at compile time [19, 22]. Heintze [10, 11] pioneered a set-based approach to program analysis that controls this complexity in two ways. <p> Examples include partial evaluation [15], escape analysis [18], redundant test elimination [11], closure analysis [21], touch-optimization [8, 7], dead-code elimination, constant-folding and code hoisting. Here, we illustrate how set-based analysis applies to soft typing [4, 28, 1, 12, 14]. 6.1 Soft Typing The programming language Scheme <ref> [2] </ref> is a dynamically-typed language, which imposes no restrictions on the values that variables or expressions in a program may assume.
Reference: [3] <author> Damas, L. M. M. </author> <title> Type Assignment in Programming Languages. </title> <type> PhD thesis, </type> <institution> University of Edinburgh, </institution> <year> 1985. </year>
Reference-contexts: It is well-known that extending type soundness proofs based on denotational semantics to a language with imperative features is complex and error-prone, even for a simple Hindley-Milner type system: see Tofte's [24] discussion of Damas's <ref> [3] </ref> faulty proof of a type soundness theorem. Extending the derivation and soundness proofs of Aiken et al.'s rich type system would be even more difficult and complex. Stefanescu and Zhou [23] present an analysis for an intermediate closure-converted language.
Reference: [4] <author> Fagan, M. </author> <title> Soft Typing. </title> <type> PhD thesis, </type> <institution> Rice University, </institution> <year> 1990. </year>
Reference-contexts: Examples include partial evaluation [15], escape analysis [18], redundant test elimination [11], closure analysis [21], touch-optimization [8, 7], dead-code elimination, constant-folding and code hoisting. Here, we illustrate how set-based analysis applies to soft typing <ref> [4, 28, 1, 12, 14] </ref>. 6.1 Soft Typing The programming language Scheme [2] is a dynamically-typed language, which imposes no restrictions on the values that variables or expressions in a program may assume. <p> The extended language is called fl !+c a . We define the semantics of the extended language fl !+c a by extending the CS-machine with the additional transition rules described in Figure 5. The evaluator for the extended 6 Unlike other approaches to soft-typing <ref> [4, 28, 1] </ref>, we are not concerned with inferring types for program Set-Based Analysis for Full Scheme and Its Use in Soft-Typing 21 h H; E [ (let (x (car l y )) M ) ] i 8 : h H [ fl x = H (l z 1 )g; E
Reference: [5] <author> Felleisen, M., and Friedman, D. P. </author> <title> A calculus for assignments in higher-order languages. </title> <booktitle> In Conference Record of the 14th Annual ACM Symposium on Principles of Programming Languages (Munich, </booktitle> <address> West Germany, </address> <month> Jan. </month> <year> 1987), </year> <pages> pp. 314-345. </pages>
Reference-contexts: We present a simpler derivation of set-based analysis than Heintze's. It avoids the complexities and limitations outlined above, and explains the underlying notion of approximation in a clear manner. Our approach is based on a reduction semantics that explicitly models the allocation of objects in a global heap <ref> [5] </ref>. 1 We avoid Heintze's intermediate steps by deriving our set constraints and proving their correctness directly from the reduction semantics. Our semantics also records sufficient information to associate each run-time value with the corresponding syntactic value in the source program. <p> 2 Hval ::= (x: M ) j (cons v v) j c (Heap Values) c 2 Const = fnil; : : :g (Basic Constants) 2.2 Semantics We define the semantics of programs via an abstract machine (see Figure 2) that explicitly models the allocation of objects into a global heap <ref> [17, 5] </ref>. A heap is a set of bindings from locations to heap values. The set Loc of locations contains an infinite subset Loc x reserved for each variable x. <p> A more general approach requires modifying our semantics to expose additional details. Specifically, it involves extracting the environment and continuation components of the control string, and expressing them as separate components of each intermediate state. The resulting semantics is essentially a CESK-machine <ref> [6, 5] </ref> specialized to A-normal forms.
Reference: [6] <author> Felleisen, M. </author> <title> The Calculi of Lambda-v-CS-Conversion: A Syntactic Theory of Control and State in Imperative Higher-Order Programming Languages. </title> <type> PhD thesis, </type> <institution> Indi-ana University, </institution> <year> 1987. </year>
Reference-contexts: A more general approach requires modifying our semantics to expose additional details. Specifically, it involves extracting the environment and continuation components of the control string, and expressing them as separate components of each intermediate state. The resulting semantics is essentially a CESK-machine <ref> [6, 5] </ref> specialized to A-normal forms.
Reference: [7] <author> Flanagan, C., and Felleisen, M. </author> <title> Well-founded touch optimization for futures. </title> <institution> Rice University Computer Science TR94-239. </institution>
Reference-contexts: Although suitable set constraints for these imperative features can be produced in an ad-hoc manner, there is no semantic foundation for these constraints. Thus existing implementations of set-based analysis for languages like Scheme and ML <ref> [10, 11, 8, 7] </ref>, which include assignments and non-local control operators, are not semantically well-founded. We present a simpler derivation of set-based analysis than Heintze's. It avoids the complexities and limitations outlined above, and explains the underlying notion of approximation in a clear manner. <p> Set-Based Analysis for Full Scheme and Its Use in Soft-Typing 20 6 Application: Soft Typing from Set-Based Analysis The information produced by set-based analysis facilitates a variety of optimizations. Examples include partial evaluation [15], escape analysis [18], redundant test elimination [11], closure analysis [21], touch-optimization <ref> [8, 7] </ref>, dead-code elimination, constant-folding and code hoisting. <p> This optimization algorithm is provably-correct with respect to the extended evaluator eval . Any implementation that realizes eval correctly can therefore make use of this optimization. 7 Related Work The main contribution of our paper is an elegant and flexible derivation of set-based analysis. It substantially simplifies previous formulations <ref> [10, 11, 8, 7] </ref>, and explains the underlying notion of approximation in a clear manner. Unlike the derivation and formalization of other approaches to program analysis, our derivation is not restricted to purely functional languages. <p> The function SBA traverses an expression to derive the set constraints for that expression. Certain set constraints cannot be satisfied immediately. Consider, for example, the expression (let (x (set! y z)) M ). The constraint C P set! requires that all values in E (z) 8 See <ref> [8, 7] </ref> for a derivation of set-based analysis from a parallel CEK-machine.
Reference: [8] <author> Flanagan, C., and Felleisen, M. </author> <title> The semantics of future and its use in program optimizations. </title> <booktitle> In Proceedings of the ACM Sigplan Conference on Principles of Programming Languages (1995), </booktitle> <pages> pp. 209-220. </pages>
Reference-contexts: Although suitable set constraints for these imperative features can be produced in an ad-hoc manner, there is no semantic foundation for these constraints. Thus existing implementations of set-based analysis for languages like Scheme and ML <ref> [10, 11, 8, 7] </ref>, which include assignments and non-local control operators, are not semantically well-founded. We present a simpler derivation of set-based analysis than Heintze's. It avoids the complexities and limitations outlined above, and explains the underlying notion of approximation in a clear manner. <p> Set-Based Analysis for Full Scheme and Its Use in Soft-Typing 20 6 Application: Soft Typing from Set-Based Analysis The information produced by set-based analysis facilitates a variety of optimizations. Examples include partial evaluation [15], escape analysis [18], redundant test elimination [11], closure analysis [21], touch-optimization <ref> [8, 7] </ref>, dead-code elimination, constant-folding and code hoisting. <p> This optimization algorithm is provably-correct with respect to the extended evaluator eval . Any implementation that realizes eval correctly can therefore make use of this optimization. 7 Related Work The main contribution of our paper is an elegant and flexible derivation of set-based analysis. It substantially simplifies previous formulations <ref> [10, 11, 8, 7] </ref>, and explains the underlying notion of approximation in a clear manner. Unlike the derivation and formalization of other approaches to program analysis, our derivation is not restricted to purely functional languages. <p> The function SBA traverses an expression to derive the set constraints for that expression. Certain set constraints cannot be satisfied immediately. Consider, for example, the expression (let (x (set! y z)) M ). The constraint C P set! requires that all values in E (z) 8 See <ref> [8, 7] </ref> for a derivation of set-based analysis from a parallel CEK-machine.
Reference: [9] <author> Flanagan, C., Sabry, A., Duba, B. F., and Felleisen, M. </author> <title> The essence of compiling with continuations. </title> <booktitle> In Proceedings of the ACM Sigplan Conference on Programming Language Design and Implementation (1993), </booktitle> <pages> pp. 237-247. </pages>
Reference-contexts: Compilers typically convert source programs into a simple intermediate representation, and then proceed to analyze and optimize the intermediate representation of the program. Therefore, we formulate the analysis for an intermediate representation of an idealized functional language. Specifically, we use the subset of A-normal forms <ref> [9] </ref> of a -calculus-like language with a let construct and conditional expressions: 2 see Figure 1. The language also includes the primitives cons, car, and cdr for list manipulation, which will serve to illustrate the treatment of primitive operations, and a basic constant nil denoting the empty list. <p> Our choice of an intermediate A-normal form representation avoids both of these complexities. Because the order of execution in our language follows the lexical nesting of let-expressions <ref> [9] </ref>, control transfer is accomplished in a simple manner. Also, since every intermediate value in our language is named, we only need to record variable-value associations, and avoid the additional complexity of labeling each expression in the program [20]. <p> This combination of complexity and inflexibility is a major obstacle to exploiting these analyses in realistic compilers. Our derivation of set-based analysis avoids these complexities and limitations. We formulate our derivation for the language of A-normal forms, since this language constitutes an ideal intermediate representation for compilers <ref> [9] </ref>.
Reference: [10] <author> Heintze, N. </author> <title> Set Based Program Analysis. </title> <type> PhD thesis, </type> <institution> Carnegie Mellon University, </institution> <year> 1992. </year>
Reference-contexts: Computing such information for higher-order languages such as Scheme [2] and ML [16] is particularly complex, since a static control-flow graph of a program is not readily available at compile time [19, 22]. Heintze <ref> [10, 11] </ref> pioneered a set-based approach to program analysis that controls this complexity in two ways. First, the approach is based on a single notion of approximation that treats program variables as sets of values. <p> Although suitable set constraints for these imperative features can be produced in an ad-hoc manner, there is no semantic foundation for these constraints. Thus existing implementations of set-based analysis for languages like Scheme and ML <ref> [10, 11, 8, 7] </ref>, which include assignments and non-local control operators, are not semantically well-founded. We present a simpler derivation of set-based analysis than Heintze's. It avoids the complexities and limitations outlined above, and explains the underlying notion of approximation in a clear manner. <p> This optimization algorithm is provably-correct with respect to the extended evaluator eval . Any implementation that realizes eval correctly can therefore make use of this optimization. 7 Related Work The main contribution of our paper is an elegant and flexible derivation of set-based analysis. It substantially simplifies previous formulations <ref> [10, 11, 8, 7] </ref>, and explains the underlying notion of approximation in a clear manner. Unlike the derivation and formalization of other approaches to program analysis, our derivation is not restricted to purely functional languages.
Reference: [11] <author> Heintze, N. </author> <title> Set-based analysis of ML programs. </title> <booktitle> In Proceedings of the 1990 ACM Conference on Lisp and Functional Programming (1994), </booktitle> <pages> pp. 306-317. </pages>
Reference-contexts: Computing such information for higher-order languages such as Scheme [2] and ML [16] is particularly complex, since a static control-flow graph of a program is not readily available at compile time [19, 22]. Heintze <ref> [10, 11] </ref> pioneered a set-based approach to program analysis that controls this complexity in two ways. First, the approach is based on a single notion of approximation that treats program variables as sets of values. <p> Although suitable set constraints for these imperative features can be produced in an ad-hoc manner, there is no semantic foundation for these constraints. Thus existing implementations of set-based analysis for languages like Scheme and ML <ref> [10, 11, 8, 7] </ref>, which include assignments and non-local control operators, are not semantically well-founded. We present a simpler derivation of set-based analysis than Heintze's. It avoids the complexities and limitations outlined above, and explains the underlying notion of approximation in a clear manner. <p> Set-Based Analysis for Full Scheme and Its Use in Soft-Typing 20 6 Application: Soft Typing from Set-Based Analysis The information produced by set-based analysis facilitates a variety of optimizations. Examples include partial evaluation [15], escape analysis [18], redundant test elimination <ref> [11] </ref>, closure analysis [21], touch-optimization [8, 7], dead-code elimination, constant-folding and code hoisting. <p> This optimization algorithm is provably-correct with respect to the extended evaluator eval . Any implementation that realizes eval correctly can therefore make use of this optimization. 7 Related Work The main contribution of our paper is an elegant and flexible derivation of set-based analysis. It substantially simplifies previous formulations <ref> [10, 11, 8, 7] </ref>, and explains the underlying notion of approximation in a clear manner. Unlike the derivation and formalization of other approaches to program analysis, our derivation is not restricted to purely functional languages. <p> Our derivation can also be modified to produce a more accurate (but more expensive) analysis. One possible approach is to apply Heintze's technique of polyvariance <ref> [11] </ref>, which is equivalent to creating different "versions" of certain functions in the source program by preceding the analysis by a series of fi v "expansion" steps. A more general approach requires modifying our semantics to expose additional details.
Reference: [12] <author> Henglein, F. </author> <title> Dynamic typing: syntax and proof theory. </title> <booktitle> Science of Computer Programming 22 (1994), </booktitle> <pages> 197-230. </pages>
Reference-contexts: Examples include partial evaluation [15], escape analysis [18], redundant test elimination [11], closure analysis [21], touch-optimization [8, 7], dead-code elimination, constant-folding and code hoisting. Here, we illustrate how set-based analysis applies to soft typing <ref> [4, 28, 1, 12, 14] </ref>. 6.1 Soft Typing The programming language Scheme [2] is a dynamically-typed language, which imposes no restrictions on the values that variables or expressions in a program may assume.
Reference: [13] <author> Jagannathan, S., and Weeks, S. </author> <title> A unified treatment of flow analysis in higher-order languages. </title> <booktitle> In 22nd ACM Symposium on Principles of Programming Languages (1995), </booktitle> <pages> pp. 393-407. </pages>
Reference-contexts: In this section, we compare our derivation with a number of comparable program analyzes, including an advanced type inference algorithm [1] and two recent variants <ref> [23, 13] </ref> of Shivers' 0CFA [22] Aiken et al. [1] develop a type inference algorithm for a purely functional language. They reduce the type inference problem to a system of type inclusion constraints, which are similar to our set constraints. <p> The addition of destructive assignments is further complicated by the requirement of their indeterminate semantics that all transitions can only increase the set of bindings in a state, and cannot modify existing bindings. Jagannathan and Weeks <ref> [13] </ref> develop an analysis for a higher-order language, starting from an unusual operational semantics that records a flow graph in which nodes represent location-value bindings and edges represent the flow of values between locations in a program. <p> Based on this semantics we can follow our derivation to develop a number of different constraint-based analyses, with different cost-performance tradeoffs. 8 It is also possible to develop a general analysis framework that is parameterized in a fashion similar to Jagan-nathan and Weeks's framework <ref> [13] </ref>. A particular instance of this framework is created by specifying relations that describe which locations created during program execution should be merged. Instances of this framework include set-based analysis, as well as a number of more precise analyses.
Reference: [14] <author> Jagannathan, S., and Wright, A. </author> <title> Effective flow analysis for avoiding run-time checks. </title> , <year> 1995. </year>
Reference-contexts: Examples include partial evaluation [15], escape analysis [18], redundant test elimination [11], closure analysis [21], touch-optimization [8, 7], dead-code elimination, constant-folding and code hoisting. Here, we illustrate how set-based analysis applies to soft typing <ref> [4, 28, 1, 12, 14] </ref>. 6.1 Soft Typing The programming language Scheme [2] is a dynamically-typed language, which imposes no restrictions on the values that variables or expressions in a program may assume.
Reference: [15] <author> Malmkjaer, K., Heintze, N., and Danvy, O. </author> <title> ML partial evaluation using set-based analysis. </title> <type> Tech. Rep. </type> <institution> CMU-CS-94-129, Carnegie Mellon University, </institution> <year> 1994. </year>
Reference-contexts: The rest of the verification of set-based analysis is again straightforward. Set-Based Analysis for Full Scheme and Its Use in Soft-Typing 20 6 Application: Soft Typing from Set-Based Analysis The information produced by set-based analysis facilitates a variety of optimizations. Examples include partial evaluation <ref> [15] </ref>, escape analysis [18], redundant test elimination [11], closure analysis [21], touch-optimization [8, 7], dead-code elimination, constant-folding and code hoisting.
Reference: [16] <author> Milner, R., Tofte, M., and Harper, R. </author> <title> The Definition of Standard ML. </title> <publisher> MIT Press, </publisher> <year> 1990. </year>
Reference-contexts: 1 Introduction Advanced compiler optimizations heavily rely on static information about the values that program variables may assume. Computing such information for higher-order languages such as Scheme [2] and ML <ref> [16] </ref> is particularly complex, since a static control-flow graph of a program is not readily available at compile time [19, 22]. Heintze [10, 11] pioneered a set-based approach to program analysis that controls this complexity in two ways.
Reference: [17] <author> Morrisett, G., Felleisen, M., and Harper, R. </author> <title> Abstract models of memory management. In Functional Programming and Computer Architecture (1995). To appear. Set-Based Analysis for Full Scheme and Its Use in Soft-Typing 30 </title>
Reference-contexts: Since our heap-based semantics represents values as general "graphs", it is straightforward to extend both the semantics and the analysis to a language with assignments. Similarly, because the complete control state is available for each step of the evaluation, 1 Also see <ref> [17] </ref> for an application of this idea to model and verify garbage collection algorithms. Set-Based Analysis for Full Scheme and Its Use in Soft-Typing 2 the extension to a language with non-local control constructs is also straightforward. <p> 2 Hval ::= (x: M ) j (cons v v) j c (Heap Values) c 2 Const = fnil; : : :g (Basic Constants) 2.2 Semantics We define the semantics of programs via an abstract machine (see Figure 2) that explicitly models the allocation of objects into a global heap <ref> [17, 5] </ref>. A heap is a set of bindings from locations to heap values. The set Loc of locations contains an infinite subset Loc x reserved for each variable x.
Reference: [18] <author> Park, Y. G., and Goldberg, B. </author> <title> Escape analysis on lists. </title> <booktitle> In Proceedings of the ACM Sigplan Conference on Programming Language Design and Implementation (June 1992), </booktitle> <pages> pp. 116-127. </pages>
Reference-contexts: The rest of the verification of set-based analysis is again straightforward. Set-Based Analysis for Full Scheme and Its Use in Soft-Typing 20 6 Application: Soft Typing from Set-Based Analysis The information produced by set-based analysis facilitates a variety of optimizations. Examples include partial evaluation [15], escape analysis <ref> [18] </ref>, redundant test elimination [11], closure analysis [21], touch-optimization [8, 7], dead-code elimination, constant-folding and code hoisting.
Reference: [19] <author> Rozas, G. J. </author> <title> Liar, an Algol-like compiler for scheme. </title> <type> Master's thesis, </type> <institution> Massachusetts Institute of Technology, </institution> <month> January </month> <year> 1984. </year>
Reference-contexts: 1 Introduction Advanced compiler optimizations heavily rely on static information about the values that program variables may assume. Computing such information for higher-order languages such as Scheme [2] and ML [16] is particularly complex, since a static control-flow graph of a program is not readily available at compile time <ref> [19, 22] </ref>. Heintze [10, 11] pioneered a set-based approach to program analysis that controls this complexity in two ways. First, the approach is based on a single notion of approximation that treats program variables as sets of values.
Reference: [20] <author> Sabry, A., and Felleisen, M. </author> <title> Is continuation-passing useful for data flow analysis. </title> <booktitle> In Proceedings of the ACM Sigplan Conference on Programming Language Design and Implementation (1994), </booktitle> <pages> pp. 1-12. </pages>
Reference-contexts: The use of A-normal forms thus simplifies the formulation of the semantics and facilitates the compile-time analysis of programs since every intermediate value is named <ref> [20] </ref>. Values are either simple values or heap-allocated values. Simple values are either variables or locations. Locations do not occur in source programs; they are only created during program evaluation. Heap-allocated values include procedures (x: M ), pairs of values (cons v v) and basic constants. <p> Also, since every intermediate value in our language is named, we only need to record variable-value associations, and avoid the additional complexity of labeling each expression in the program <ref> [20] </ref>. Jagannathan and Weeks further complicate their rewriting semantics using labels of expressions within their state representation instead of the actual expressions themselves. Therefore, a state does not completely represent an intermediate stage of a computation and cannot be further evaluated without knowledge of the original source program.
Reference: [21] <author> Shao, Z., and Appel, A. </author> <title> Space-efficient closure representations. </title> <booktitle> In Proceedings of the ACM Symposium on Lisp and Functional Programming (1994), </booktitle> <pages> pp. 150-161. </pages>
Reference-contexts: Set-Based Analysis for Full Scheme and Its Use in Soft-Typing 20 6 Application: Soft Typing from Set-Based Analysis The information produced by set-based analysis facilitates a variety of optimizations. Examples include partial evaluation [15], escape analysis [18], redundant test elimination [11], closure analysis <ref> [21] </ref>, touch-optimization [8, 7], dead-code elimination, constant-folding and code hoisting.
Reference: [22] <author> Shivers, O. </author> <title> Control-flow Analysis of Higher-Order Languages or Taming Lambda. </title> <type> PhD thesis, </type> <institution> Carnegie-Mellon University, </institution> <year> 1991. </year>
Reference-contexts: 1 Introduction Advanced compiler optimizations heavily rely on static information about the values that program variables may assume. Computing such information for higher-order languages such as Scheme [2] and ML [16] is particularly complex, since a static control-flow graph of a program is not readily available at compile time <ref> [19, 22] </ref>. Heintze [10, 11] pioneered a set-based approach to program analysis that controls this complexity in two ways. First, the approach is based on a single notion of approximation that treats program variables as sets of values. <p> In this section, we compare our derivation with a number of comparable program analyzes, including an advanced type inference algorithm [1] and two recent variants [23, 13] of Shivers' 0CFA <ref> [22] </ref> Aiken et al. [1] develop a type inference algorithm for a purely functional language. They reduce the type inference problem to a system of type inclusion constraints, which are similar to our set constraints.
Reference: [23] <author> Strfanescu, D., and Zhou, Y. </author> <title> An equational framework for the flow analysis of higher order functional programs. </title> <booktitle> In LFP (1994), </booktitle> <pages> pp. 318-327. </pages>
Reference-contexts: In this section, we compare our derivation with a number of comparable program analyzes, including an advanced type inference algorithm [1] and two recent variants <ref> [23, 13] </ref> of Shivers' 0CFA [22] Aiken et al. [1] develop a type inference algorithm for a purely functional language. They reduce the type inference problem to a system of type inclusion constraints, which are similar to our set constraints. <p> Extending the derivation and soundness proofs of Aiken et al.'s rich type system would be even more difficult and complex. Stefanescu and Zhou <ref> [23] </ref> present an analysis for an intermediate closure-converted language. They start from an operational semantics in which each state is a set of bindings from locations to either values or expressions. A state transition arbitrarily chooses a location-expression binding and reduces that expression.
Reference: [24] <author> Tofte, M. </author> <title> Operational Semantics and Polymorphic Type Inference. </title> <type> PhD thesis, </type> <institution> University of Edinburgh, </institution> <year> 1987. </year>
Reference-contexts: It is well-known that extending type soundness proofs based on denotational semantics to a language with imperative features is complex and error-prone, even for a simple Hindley-Milner type system: see Tofte's <ref> [24] </ref> discussion of Damas's [3] faulty proof of a type soundness theorem. Extending the derivation and soundness proofs of Aiken et al.'s rich type system would be even more difficult and complex. Stefanescu and Zhou [23] present an analysis for an intermediate closure-converted language.
Reference: [25] <author> Wright, A. </author> <title> Practical Soft Typing for Scheme. </title> <type> PhD thesis, </type> <institution> Rice University, </institution> <year> 1994. </year>
Reference: [26] <author> Wright, A., and Felleisen, M. </author> <title> A syntactic approach to type soundness. </title> <type> Tech. Rep. 160, </type> <institution> Rice University, </institution> <year> 1991. </year>
Reference-contexts: A final disadvantage of Jagannathan and Weeks derivation is that their analysis is defined via a complex abstract transition function. This monolithic definition does not provide the insight and understanding that the specification of set-based analysis in terms of set constraints provides. Wright and Felleisen <ref> [26] </ref> describe a simple and flexible strategy for proving the type soundness of Hindley-Milner-style polymorphic type systems. Their approach is based on a reduction semantics that easily extends to encompass imperative constructs, and adapts subject reduction theorems from combinatory logic to programming languages.
Reference: [27] <author> Wright, A. K., and Duba, B. F. </author> <title> Pattern matching for Scheme. </title> <type> Unpublished manuscript, </type> <year> 1993. </year> <note> Available at "ftp://cs.rice.edu/public/wright/match.ps.Z". </note>
Reference-contexts: A Set-Based Analysis Algorithm A complete set-based analysis algorithm for a Scheme-like language containing both assignments and first-class continuations is included in Figures 7 through 9. The algorithm is written in Scheme extended with a special form match for pattern matching <ref> [27] </ref>. The function SBA traverses an expression to derive the set constraints for that expression. Certain set constraints cannot be satisfied immediately. Consider, for example, the expression (let (x (set! y z)) M ).
Reference: [28] <author> Wright, A. and R. Cartwright. </author> <title> A practical soft type system for scheme. </title> <booktitle> In Proceedings of the 1990 ACM Conference on Lisp and Functional Programming (1994), </booktitle> <pages> pp. 250-262. </pages>
Reference-contexts: Examples include partial evaluation [15], escape analysis [18], redundant test elimination [11], closure analysis [21], touch-optimization [8, 7], dead-code elimination, constant-folding and code hoisting. Here, we illustrate how set-based analysis applies to soft typing <ref> [4, 28, 1, 12, 14] </ref>. 6.1 Soft Typing The programming language Scheme [2] is a dynamically-typed language, which imposes no restrictions on the values that variables or expressions in a program may assume. <p> The extended language is called fl !+c a . We define the semantics of the extended language fl !+c a by extending the CS-machine with the additional transition rules described in Figure 5. The evaluator for the extended 6 Unlike other approaches to soft-typing <ref> [4, 28, 1] </ref>, we are not concerned with inferring types for program Set-Based Analysis for Full Scheme and Its Use in Soft-Typing 21 h H; E [ (let (x (car l y )) M ) ] i 8 : h H [ fl x = H (l z 1 )g; E
References-found: 28

