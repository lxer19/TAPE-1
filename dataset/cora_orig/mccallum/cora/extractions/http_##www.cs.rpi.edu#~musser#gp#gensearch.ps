URL: http://www.cs.rpi.edu/~musser/gp/gensearch.ps
Refering-URL: http://www.cs.rpi.edu/~musser/gp/index_1.html
Root-URL: http://www.cs.rpi.edu
Email: fmusser,gorikg@cs.rpi.edu  
Title: A Fast Generic Sequence Matching Algorithm  
Author: David R. Musser Gor V. Nishanov 
Keyword: key words String search String matching Pattern matching Sequence matching Generic algorithms Knuth-Morris-Pratt algorithm Boyer-Moore algorithm DNA pattern matching C Standard Template Library STL Ada Literate programming  
Date: March 10, 1998  
Address: Troy, NY 12180  
Affiliation: Computer Science Department Rensselaer Polytechnic Institute,  
Abstract:  
Abstract-found: 1
Intro-found: 1
Reference: [BM77] <author> R. Boyer and S. Moore. </author> <title> A fast string matching algorithm. </title> <journal> CACM, 20(1977),762-772. </journal>
Reference-contexts: 1 Introduction The traditional string matching problem is to find an occurrence of a pattern (a string) in a text (another string), or to decide that none exists. Two of the best known algorithms for the problem of string matching are the Knuth-Morris-Pratt [KMP77] and Boyer-Moore <ref> [BM77] </ref> algorithms (for short, we will refer to these as KMP and BM). <p> On the other hand, despite the fact that BM has a higher worst-case bound on the number of comparisons ( 3n [Cole96]), it has excellent sublinear behavior in the average case. This fact often makes BM the algorithm of choice in practical applications. In <ref> [BM77] </ref>, Boyer and Moore described both a basic version of their algorithm and an optimized version based on use of a "skip loop." We will refer to the latter algorithm as Accelerated Boyer-Moore, or ABM for short. Unfortunately, this version remained unnoticed by most researchers despite its much better performance. <p> maps any character of the alphabet to the range [0; m a] and is defined as follows: skip (x) = ae m 1 i otherwise, where i = maxfj : a j &lt; m ^ p j = xg This is the same function as Boyer and Moore's ffi 1 <ref> [BM77] </ref>. <p> The skip loop as described above performs two tests for exit during each iteration. As suggested in <ref> [BM77] </ref>, we can eliminate one of the tests by initializing skip (pattern (m - 1)) to some value large, chosen large enough to force an exit based on the size of the index. <p> We benchmarked five algorithms with English text searches: a C ++ version of SF used in the Hewlett-Packard STL implementation; L and AL in their C ++ versions as given later in the paper and appendices; and the C versions of ABM <ref> [BM77] </ref> and TBM as given by Hume and Sunday [HS91]. (The version of AL actually used is the hashed version, HAL, discussed in the next section, but using the identity function as the hash function.) We searched for patterns of size ranging from 2 to 18 in Lewis Carroll's Through the
Reference: [Briggs] <author> P. Briggs, Nuweb, </author> <title> a simple literate programming tool, </title> <note> Version 0.87, </note> <year> 1989. </year>
Reference-contexts: This form of presentation is supported by Briggs' Nuweb tool <ref> [Briggs] </ref> (slightly modified, as discussed in a later section), with which we also generate all code files directly from the paper's source file. 2 hHandle pattern size = 1 as a special case 3ai j if pattern_size = 1 then while k /= n and then text (k) /= pattern (a) <p> By downloading the Nuweb source file, gensearch.w, and using Briggs' Nuweb tool <ref> [Briggs] </ref>, 6 readers can also easily generate all of the source code described in the paper and appendices. 9 Conclusion When we began this research, our main goal was to develop a generic sequence search algorithm with a linear worst-case time bound and with better average case performance than KMP and
Reference: [Cole96] <author> R. Cole. </author> <title> Tight bounds on the complexity of the Boyer-Moore string matching algorithm, </title> <journal> SIAM Journal on Computing 5 (1994): </journal> <pages> 1075-1091. </pages>
Reference-contexts: On the other hand, despite the fact that BM has a higher worst-case bound on the number of comparisons ( 3n <ref> [Cole96] </ref>), it has excellent sublinear behavior in the average case. This fact often makes BM the algorithm of choice in practical applications.
Reference: [CGG90] <author> L. Colussi, Z. Galil, R. Giancarlo. </author> <title> On the Exact Complexity of String Matching. </title> <booktitle> Proceedings of the Thirty First Annual IEEE Symposium on the Foundations of Computer Science, </booktitle> <year> 1990, </year> <pages> 135-143. </pages>
Reference: [DNAsource] <author> H.S. Bilofsky, C. Burks, </author> <title> The GenBank(r) genetic sequence data bank. Nucl. </title> <journal> Acids Res. </journal> <volume> 16 (1988), </volume> <pages> 1861-1864. </pages>
Reference-contexts: The other contestants were SF, L, ABM and the Giancarlo-Boyer-Moore algorithm (GBM), which was described in [HS91] and was considered to be the fastest for DNA pattern matching. We searched for patterns of size ranging from 20 to 200 in a text of DNA strings obtained from <ref> [DNAsource] </ref>. The text is composed of 997,642 characters, and the test set included up to 80 different patterns for each pattern size|40 strings chosen at evenly spaced positions in the target text and up to 40 patterns chosen from another file from [DNAsource] (for longer pattern sizes there were fewer than <p> in a text of DNA strings obtained from <ref> [DNAsource] </ref>. The text is composed of 997,642 characters, and the test set included up to 80 different patterns for each pattern size|40 strings chosen at evenly spaced positions in the target text and up to 40 patterns chosen from another file from [DNAsource] (for longer pattern sizes there were fewer than 40 patterns). Table 2 shows search speeds of the five algorithms with code compiled and executed on the same three systems as in the English text experiments (the systems described preceding Table 1).
Reference: [Ga79] <author> Z. Galil. </author> <title> On Improving the worst case running time of the Boyer-Moore string matching algorithm. </title> <booktitle> CACM 22 (1979), </booktitle> <pages> 505-508. </pages>
Reference: [GS83] <author> Z. Galil, J. Seiferas. </author> <title> Time space optimal string matching. </title> <booktitle> JCSS 26 (1983), </booktitle> <pages> 280-294. </pages>
Reference: [DraftCPP] <institution> Accredited Standards Committee X3 (American National Standards Institute), </institution> <note> Information Processing Systems, Working paper for draft proposed international standard for information systems|programming language C ++ . Doc No. X3J16/95-0185, WG21/N0785.[[Check for most recent version.]] </note>
Reference-contexts: Thus the generic search algorithm requirements were written with a O (mn) time bound, to allow its implementation by SF. 4 Thus in the Draft C ++ Standard dated December 1996 <ref> [DraftCPP] </ref>, two sequence search functions are required, with the specifications: 3 The original STL requirements included the following statement (which has been dropped in more recent versions of the Draft C ++ Standard): ". . . The Knuth-Morris-Pratt algorithm is not used here.
Reference: [GO77] <author> L.J. Guibas, A.M. Odlyzko, </author> <title> A new proof of the linearity of the Boyer-Moore string searching algorithm. </title> <booktitle> Proc. 18th Ann. IEEE Symp. Foundations of Comp. Sci., </booktitle> <year> 1977, </year> <pages> 189-195 </pages>
Reference: [Horspool88] <author> R.N. Horspool. </author> <title> Practical fast searching in strings Soft.-Prac. and Exp., </title> <month> 10 (March </month> <year> 1980), </year> <pages> 501-506 </pages>
Reference-contexts: Unfortunately, this version remained unnoticed by most researchers despite its much better performance. For example, ABM outperforms the Quick Search [Su90] and Boyer-Moore-Horspool <ref> [Horspool88] </ref> improvements of the basic BM algorithm. This state of affairs was highlighted by Hume and Sunday in 1991 in [HS91], in which they introduced two algorithms, LC (least cost) and TBM (Tuned BM) [HS91], that perform faster than ABM in the average case.
Reference: [Hume88] <author> A. Hume. </author> <title> A tale of two greps. </title> <journal> Soft.-Prac. and Exp. </journal> <month> 18 (November </month> <year> 1988), </year> <pages> 1063-1072. </pages>
Reference: [HS91] <author> A. Hume, S. Sunday. </author> <title> Fast string searching. </title> <journal> Soft.-Prac. and Exp. </journal> <month> 21 (November </month> <year> 1991), </year> <pages> 1221-1248. </pages>
Reference-contexts: Unfortunately, this version remained unnoticed by most researchers despite its much better performance. For example, ABM outperforms the Quick Search [Su90] and Boyer-Moore-Horspool [Horspool88] improvements of the basic BM algorithm. This state of affairs was highlighted by Hume and Sunday in 1991 in <ref> [HS91] </ref>, in which they introduced two algorithms, LC (least cost) and TBM (Tuned BM) [HS91], that perform faster than ABM in the average case. <p> For example, ABM outperforms the Quick Search [Su90] and Boyer-Moore-Horspool [Horspool88] improvements of the basic BM algorithm. This state of affairs was highlighted by Hume and Sunday in 1991 in <ref> [HS91] </ref>, in which they introduced two algorithms, LC (least cost) and TBM (Tuned BM) [HS91], that perform faster than ABM in the average case. These two algorithms use the skip loop of ABM combined with variants of the straightforward algorithm that use information on character frequency distribution in the target text. <p> benchmarked five algorithms with English text searches: a C ++ version of SF used in the Hewlett-Packard STL implementation; L and AL in their C ++ versions as given later in the paper and appendices; and the C versions of ABM [BM77] and TBM as given by Hume and Sunday <ref> [HS91] </ref>. (The version of AL actually used is the hashed version, HAL, discussed in the next section, but using the identity function as the hash function.) We searched for patterns of size ranging from 2 to 18 in Lewis Carroll's Through the Looking Glass. <p> The other contestants were SF, L, ABM and the Giancarlo-Boyer-Moore algorithm (GBM), which was described in <ref> [HS91] </ref> and was considered to be the fastest for DNA pattern matching. We searched for patterns of size ranging from 20 to 200 in a text of DNA strings obtained from [DNAsource]. <p> For ABM and TBM, not all operations were counted because the algorithms are from Hume and Sunday's original C code and therefore could not be specialized with the counting components. For these algorithms a manually instrumented version (supplied as part of the code distribution <ref> [HS91] </ref>) kept count of data comparisons and accesses. The table shows that HAL, like ABM and TBM, does remarkably few equality comparison operations on sequence elements|only about 1 per 100 elements for the longer patterns, no more than twice that for the shorter ones. <p> In this case, element comparisons were word comparisons, which could be significantly more costly than iterator or distance operations. HAL was again substantially faster than the other contestants, SF and L. The ABM and TBM algorithms from <ref> [HS91] </ref> were not considered because they are only applicable to string matching, but it was easy to specialize the three generic algorithms to this case of sequence matching, just by plugging in the appropriate types and, in the case of HAL, defining a suitable hash function. (We used a function that
Reference: [Knuth84] <author> D.E. Knuth, </author> <title> Literate programming. </title> <journal> Computer Journal 27 (1984), </journal> <pages> 97-111. </pages>
Reference-contexts: The generic library components developed later in the paper are written in C ++ . Throughout the paper we present expository and production code in a variant of Knuth's literate programming style <ref> [Knuth84] </ref>, in which code is presented in "parts" numbered according to the page number on which they appear (with parts on the same page distinguished by appending a letter to the number).
Reference: [KMP77] <author> D.E. Knuth, J. Morris, V. Pratt. </author> <title> Fast pattern matching in strings. </title> <journal> SIAM Journal on Computing 6 (1977), </journal> <pages> 323-350. </pages>
Reference-contexts: 1 Introduction The traditional string matching problem is to find an occurrence of a pattern (a string) in a text (another string), or to decide that none exists. Two of the best known algorithms for the problem of string matching are the Knuth-Morris-Pratt <ref> [KMP77] </ref> and Boyer-Moore [BM77] algorithms (for short, we will refer to these as KMP and BM). <p> = max i&lt;j fijp a : : : p i1 = p a+ji : : : p j1 ^ p i 6= p j g (We let next (j) = a 1 if there is no i satisfying the conditions.) Here is the basic KMP algorithm as it appeared in <ref> [KMP77] </ref>, except that we use more general index ranges: 1 hBasic KMP 2ai j pattern_size := m a; j := a; k := b; while j &lt; m and then k &lt; n loop while j &gt;= a and then text (k) /= pattern (j) loop j := next (j); end
Reference: [Mu96] <author> D.R. Musser. </author> <title> Measuring Computing Times and Operation Counts, </title> <address> http://www.cs.rpi.edu/musser/gp/timing.html. </address>
Reference-contexts: The full details, including complete source code, are shown in an appendix. The code is available from http://www.cs.rpi.edu/~musser/gp. The code supplied includes a set of operation counting components <ref> [Mu96] </ref> that permit easy gathering of statistics on many different kinds of operations, including data element accesses and comparisons, iterator operations, and "distance operations," which are arithmetic operations on integer results of iterator subtractions.
Reference: [MS96] <author> D.R. Musser, A. Saini. </author> <title> STL Tutorial and Reference Guide: C ++ Programming with Standard Template Library. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, MA, </address> <year> 1996. </year>
Reference-contexts: These qualities make it a good candidate for abstraction to searching in sequences over an arbitrary type T , for inclusion in generic software libraries such as the C ++ Standard Template Library (STL) <ref> [StepanovLee, MS96] </ref>. By some definitions of genericity, HAL is already a generic algorithm, since the hash function can be made a parameter and thus the algorithm can be adapted to work with any type T .
Reference: [SGI96] <institution> Silicon Graphics Standard Template Library Programming Guide, </institution> <note> online guide, http://www.sgi.com/Technology/STL/. </note>
Reference: [Sm82] <author> G.V. Smit. </author> <title> A comparison of three string matching algorithms. </title> <journal> Soft.-Prac. and Exp. </journal> <volume> 12, </volume> <month> 1 (Jan </month> <year> 1982), </year> <pages> 57-66. </pages>
Reference-contexts: Although KMP has a low worst-case bound on number of comparisons (2n, where n is the length of the text), it is often considered impractical, since the number of comparisons it performs in the average case is not significantly smaller than that of the straightforward (SF) algorithm <ref> [Sm82] </ref>, and the overhead for initialization is higher. On the other hand, despite the fact that BM has a higher worst-case bound on the number of comparisons ( 3n [Cole96]), it has excellent sublinear behavior in the average case.
Reference: [StepanovLee] <author> A.A. Stepanov, M. Lee, </author> <title> The Standard Template Library, </title> <type> Tech. Report HPL-94-34, </type> <month> April </month> <year> 1994, </year> <note> revised October 31, </note> <year> 1995. </year>
Reference-contexts: These qualities make it a good candidate for abstraction to searching in sequences over an arbitrary type T , for inclusion in generic software libraries such as the C ++ Standard Template Library (STL) <ref> [StepanovLee, MS96] </ref>. By some definitions of genericity, HAL is already a generic algorithm, since the hash function can be made a parameter and thus the algorithm can be adapted to work with any type T . <p> In the case of sequence search algorithms, the concrete algorithms considered for generalization to include in STL were various string-search algorithms, including BM, KMP, and SF. Although KMP has the lowest worst-case bound, it was stated in the original STL report <ref> [StepanovLee] </ref> that SF was superior in the average case. 3 And although BM has excellent average time behavior, it was evidently ruled out as a generic algorithm because of its alphabet size dependency.
Reference: [Su90] <author> D.M. Sunday. </author> <title> A very fast substring search algorithm. </title> <journal> CACM 33 (August 1990), </journal> <pages> 132-142. </pages>
Reference-contexts: Unfortunately, this version remained unnoticed by most researchers despite its much better performance. For example, ABM outperforms the Quick Search <ref> [Su90] </ref> and Boyer-Moore-Horspool [Horspool88] improvements of the basic BM algorithm. This state of affairs was highlighted by Hume and Sunday in 1991 in [HS91], in which they introduced two algorithms, LC (least cost) and TBM (Tuned BM) [HS91], that perform faster than ABM in the average case.
References-found: 20

