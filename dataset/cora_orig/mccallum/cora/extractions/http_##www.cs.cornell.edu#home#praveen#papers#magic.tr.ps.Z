URL: http://www.cs.cornell.edu/home/praveen/papers/magic.tr.ps.Z
Refering-URL: 
Root-URL: 
Email: praveen,joey,raghu@cs.wisc.edu  
Title: Filter Joins: Cost-Based Optimization for Magic Sets  
Author: Praveen Seshadri Joseph M. Hellerstein Raghu Ramakrishnan 
Date: June 8, 1995  
Address: U.Wisconsin, Madison WI  
Affiliation: Computer Sciences Department  
Abstract: Complex decision-support queries often involve table expressions and views. The current state-of-the-art optimization technique for such queries is the magic sets rewriting. Unfortunately, this rewriting is typically applied as a heuristic query transformation, rather than as part of a cost-based query optimizer. There are some cases in which the rewriting can improve query execution time, and other cases in which it can degrade performance. Further, there are a large number of variants of magic sets rewriting that may be applied to a single query. The optimal choice of how and when to apply magic sets rewriting has remained an open research problem. In this paper we take a new approach, treating magic sets rewriting as a particular case of a new join algorithm that we call the Filter Join. Adding the Filter Join algorithm to a traditional cost-based query optimizer is difficult, because it can cause an unacceptable increase in the complexity of optimization. We demonstrate how this problem arises, and how it can be addressed by placing reasonable limits on the search space. Using the cost formulas that we derive, an optimizer can examine the Filter Join as a join algorithm option, without adversely affecting the complexity of optimization. This allows magic sets rewriting and similar techniques to be fully integrated with a cost-based query optimizer. The Filter Join allows the DBMS to find better evaluation algorithms for complex queries. It is also applicable to remote relations in distributed databases, and to relations defined by user functions. We treat all such relations uniformly as "virtual" relations. Any join expression involving virtual relations benefits from the cost-based exploration of a Filter Join. This is especially important for heterogeneous queries involving remote views. 
Abstract-found: 1
Intro-found: 1
Reference: [BGWRR81] <author> Philip A. Bernstein, Nathan Goodman, Eugene Wong, Christopher L. Reeve and James B. Rothnie. </author> <title> Query Processing in a System for Distributed Databases (SDD-1) ACM Transactions on Database Systems, </title> <journal> Vol. </journal> <volume> 6, No. 4, </volume> <pages> pages 602-625, </pages> <month> December </month> <year> 1981. </year>
Reference-contexts: This restricted set of B tuples is then joined with the relation A (using any other available join algorithm). A is called the outer relation and B is called the inner relation in the Filter join. 4 This definition looks similar to the well-known semi-join <ref> [BGWRR81] </ref> operation, and it has indeed been observed in the past that magic rewriting and semi-joins are similar in spirit. The important distinction that has remained is that magic sets is viewed as a high-level query transformation that can deal with views and table expressions. <p> Heuristically, it is expected to improve performance. Let us consider an example of a join between relations A at Site A and B at Site B in a distributed DBMS (well-known examples of such systems are System R* [LMH+85] and SDD-1 <ref> [BGWRR81] </ref>). Assume that the join needs to be performed at the site of the outer relation, i.e. Site A . <p> Further, issues like the choice of SIPS were not considered, usually because communication costs were assumed to outweigh local processing costs (consequently, the chosen semi-join was always as restrictive as possible). Instead, optimization focused on the correct order in which to execute the semi-joins <ref> [BGWRR81] </ref>. The literature on heterogeneous databases has not yet dealt with issues like remote views in a complex query. However, such issues are becoming increasingly important, and our work should be applicable to this domain.
Reference: [BR91] <author> Catriel Beeri and Raghu Ramakrishnan. </author> <title> On the Power of Magic. </title> <journal> Journal of Logic Programming, </journal> <volume> 10:255, </volume> <year> 1991. </year>
Reference-contexts: were added as a join method [HCL+90]; however, the purpose was to prove the extensibility of the optimizer, not to study the optimization issues involved in adding a Filter join method. 6 Related Work Magic sets rewriting was originally used in the area of recursive query processing in deductive databases <ref> [BR91] </ref>. The impact of different choices if SIPS has been discussed in [BR91], and the idea of using approximations of the magic set has been explored in [Sag90, SS88]. <p> prove the extensibility of the optimizer, not to study the optimization issues involved in adding a Filter join method. 6 Related Work Magic sets rewriting was originally used in the area of recursive query processing in deductive databases <ref> [BR91] </ref>. The impact of different choices if SIPS has been discussed in [BR91], and the idea of using approximations of the magic set has been explored in [Sag90, SS88]. Magic sets was shown to be applicable to complex SQL queries [MFPR90, SPL94], and was implemented in the Starburst database system [MP94].
Reference: [GHK92] <author> Sumit Ganguly, Waqar Hasan and Ravi Krishnamurthy. </author> <title> Query Optimization for Parallel Execution. </title> <booktitle> In Proceedings of ACM SIGMOD '92 International Conference on Management of Data, </booktitle> <address> San Diego, CA, </address> <year> 1992. </year>
Reference-contexts: An exhaustive search algorithm would be exponentially expensive, because each of the O ((2 (N 1))!=(N 1)!) options would have to be considered (see <ref> [GHK92] </ref> for a derivation of the complexity of exhaustive join optimization). This is a prohibitive cost for even a small value of N . 3.1 System R Optimizer Many optimizers restrict themselves to plans that are shaped like a left deep tree or comb.
Reference: [HCL+90] <author> L. Haas, W. Chang, G.M. Lohman, J. McPherson, P.F. Wilms, G. Lapis, B. Lindsay, H. Pirahesh, M. Carey, and E. Shekita. </author> <title> Starburst Mid-Flight: As the dust clears. </title> <journal> IEEE Transactions on Knowledge and Data Engineering, </journal> <month> March </month> <year> 1990. </year>
Reference-contexts: So in certain situations, the join can be performed with two scans of the outer and one scan of the inner, which may be much cheaper than any of the other join methods. In fact, in Starburst, semi-joins were added as a join method <ref> [HCL+90] </ref>; however, the purpose was to prove the extensibility of the optimizer, not to study the optimization issues involved in adding a Filter join method. 6 Related Work Magic sets rewriting was originally used in the area of recursive query processing in deductive databases [BR91].
Reference: [HOT88] <author> Wen-Chi Hou, Gultekin Ozsoyoglu and Baldeao K. Taneja. </author> <title> Statistical Estimators for Relational Algebra Expressions. </title> <booktitle> In Proceedings of the Seventh Symposium on Principles of Database Systems (PODS) pages 276-287, </booktitle> <year> 1988 </year>
Reference-contexts: If Bloom-filters are used to implement the filter set, the size of the filter set is fixed. If the filter set is stored as a relation, however, its size needs to be estimated. While we note that it is notoriously difficult to estimate the cardinality of projections <ref> [HOT88, LNSS93] </ref>, the optimizer can make a estimate based on the cardinality of the production set P , and assumptions about the distributions of values in the various columns [Yao77]. Traditional optimizers already use some approximate technique to estimate projection cardinality; any such available technique can be used.
Reference: [HS93] <author> Joseph M. Hellerstein and Michael Stonebraker. </author> <title> Predicate Migration: Optimizing Queries With Expensive Predicates. </title> <booktitle> In Proceedings of ACM SIGMOD '93 International Conference on Management of Data, Wash-ington, DC, </booktitle> <pages> pages 267-276, </pages> <year> 1993. </year>
Reference-contexts: The functions are typically invoked repeatedly with different argument values. Optimization research has focused on choosing the position 12 within the plan at which these repeated invocations should occur <ref> [HS93] </ref>. The function results can also be cached to avoid duplicate invocations [HS93]. In this domain, it certainly is possible to investigate Filter Join as a join method. This will result in a number of function invocations being executed consecutively, resulting in possible benefits of locality inside the function computation. <p> The functions are typically invoked repeatedly with different argument values. Optimization research has focused on choosing the position 12 within the plan at which these repeated invocations should occur <ref> [HS93] </ref>. The function results can also be cached to avoid duplicate invocations [HS93]. In this domain, it certainly is possible to investigate Filter Join as a join method. This will result in a number of function invocations being executed consecutively, resulting in possible benefits of locality inside the function computation.
Reference: [IK84] <author> Toshihide Ibaraki and Tiko Kameda. </author> <title> Optimal Nesting for Computing N-relational Joins. </title> <journal> In ACM Transactions on Database Systems, Vol.9, </journal> <volume> No.3, </volume> <pages> pages 482-502, </pages> <month> October </month> <year> 1984. </year>
Reference-contexts: Other algorithms have been suggested that assume certain properties about the join cost formulas and the acyclicity of the join predicates, and actually perform the optimization in polynomial time <ref> [IK84, KBZ86] </ref>. However, the basic approach of using left deep trees remains the same. 6 3.2 Problems in Costing a Filter Join Assume that a join involving N relations is being optimized by a System R optimizer augmented to consider Filter joins.
Reference: [INSS91] <author> Y. Ioannidis and R. Ng and K. Shim and T. K. Sellis. </author> <title> Parametric Query Optimization. </title> <booktitle> In Proceedings of the International Conference on Very Large Databases (VLDB), </booktitle> <pages> pages 103-114, </pages> <year> 1992. </year>
Reference-contexts: The specific plan instance would provide the cost of the restriction, as well as the cardinality of the result. Parameterized query optimization has been the topic of recent research interest, and there have been encouraging initial results <ref> [INSS91] </ref>.
Reference: [KBZ86] <author> Ravi Krishnamurthy, Haran Boral, and Carlo Zaniolo. </author> <title> Optimization of Nonrecursive Queries. </title> <booktitle> In Proceedings of the Seventeenth International Conference on Very Large Databases (VLDB), </booktitle> <pages> pages 128-137, </pages> <year> 1986. </year>
Reference-contexts: Other algorithms have been suggested that assume certain properties about the join cost formulas and the acyclicity of the join predicates, and actually perform the optimization in polynomial time <ref> [IK84, KBZ86] </ref>. However, the basic approach of using left deep trees remains the same. 6 3.2 Problems in Costing a Filter Join Assume that a join involving N relations is being optimized by a System R optimizer augmented to consider Filter joins.
Reference: [Kim82] <author> W. Kim. </author> <title> On Optimizing an SQL-like Nested Query. </title> <journal> ACM Transactions on Database Systems, Vol.7, </journal> <volume> No.3, </volume> <month> September </month> <year> 1982. </year> <month> 14 </month>
Reference: [LMH+85] <author> Guy M. Lohman, C. Mohan, Laura M. Haas, Dean Daniels, Bruce G. Lindsay, Patricia G. Selinger and Paul F. Wilms. </author> <title> Query Processing in R*. In Query Processing in Database Systems, </title> <editor> (W. Kim, D.S. Reiner, and D.S. Batory, eds.), </editor> <publisher> Springer-Verlag, </publisher> <pages> pages 30-47, </pages> <year> 1985. </year>
Reference-contexts: Heuristically, it is expected to improve performance. Let us consider an example of a join between relations A at Site A and B at Site B in a distributed DBMS (well-known examples of such systems are System R* <ref> [LMH+85] </ref> and SDD-1 [BGWRR81]). Assume that the join needs to be performed at the site of the outer relation, i.e. Site A .
Reference: [LNSS93] <author> Richard J. Lipton, Jeffrey F. Naughton, Donovan A. Schneider and S. Seshadri. </author> <title> Efficient Sampling Strategies for Relational Database Operations. </title> <booktitle> Theoretical Computer Science, No.116, </booktitle> <pages> pages 195-226, </pages> <year> 1993. </year>
Reference-contexts: If Bloom-filters are used to implement the filter set, the size of the filter set is fixed. If the filter set is stored as a relation, however, its size needs to be estimated. While we note that it is notoriously difficult to estimate the cardinality of projections <ref> [HOT88, LNSS93] </ref>, the optimizer can make a estimate based on the cardinality of the production set P , and assumptions about the distributions of values in the various columns [Yao77]. Traditional optimizers already use some approximate technique to estimate projection cardinality; any such available technique can be used.
Reference: [MFPR90] <author> Inderpal Singh Mumick, Sheldon Finkelstein, Hamid Pirahesh, and Raghu Ramakrishnan. </author> <title> Magic is Relevant. </title> <booktitle> In Proceedings of ACM SIGMOD '90 International Conference on Management of Data, </booktitle> <address> Atlantic City, NJ, </address> <year> 1990. </year>
Reference-contexts: Magic sets rewriting is a heuristic technique which has been suggested as a means of optimizing complex queries involving views and table expressions. In some cases, it has been shown to result in orders of magnitude improvement in execution efficiency <ref> [MFPR90] </ref>. We now demonstrate the result of applying the magic sets rewriting to the original query specification of Figure 1. The purpose of the rewriting is to optimize the join with the view DepAvgSal. <p> The impact of different choices if SIPS has been discussed in [BR91], and the idea of using approximations of the magic set has been explored in [Sag90, SS88]. Magic sets was shown to be applicable to complex SQL queries <ref> [MFPR90, SPL94] </ref>, and was implemented in the Starburst database system [MP94]. In all implementations, magic sets has been treated as a query rewrite.
Reference: [ML85] <author> L.F. Mackert and G.M. Lohman. </author> <title> R* Optimizer Evaluation. </title> <booktitle> In Proceedings of ACM SIGMOD '85 International Conference on Management of Data, </booktitle> <address> Atlantic City, NJ, </address> <year> 1985. </year>
Reference-contexts: Critics of semi-joins argue that this technique requires that the outer relation be accessed twice, once to generate the filter set, and once to compute the final join <ref> [ML85] </ref>; this adds to the local processing costs. Therefore, in the System R* optimizer, semi-joins were not considered, based on the assumption that they added too much to local processing costs.
Reference: [MP94] <author> Inderpal Singh Mumick and Hamid Pirahesh. </author> <title> Implementation of Magic-Sets in Starburst. </title> <booktitle> In Proceedings of ACM SIGMOD '94 International Conference on Management of Data, </booktitle> <address> Minneapolis, </address> <year> 1994. </year>
Reference-contexts: For magic rewriting, choose a SIPS based on some heuristic. This approach is used in Starburst <ref> [MP94] </ref>. The SIPS chosen corresponds to the join order that arises from optimizing the original query without magic rewriting. <p> The impact of different choices if SIPS has been discussed in [BR91], and the idea of using approximations of the magic set has been explored in [Sag90, SS88]. Magic sets was shown to be applicable to complex SQL queries [MFPR90, SPL94], and was implemented in the Starburst database system <ref> [MP94] </ref>. In all implementations, magic sets has been treated as a query rewrite. Our interpretation of magic sets as an instance of a Filter join method distinguishes our current work from this earlier work, and allows us to integrate magic sets with a cost-based optimizer.
Reference: [PHH92] <author> Hamid Pirahesh, Joseph Hellerstein, and Waqar Hasan. </author> <title> Extensible/Rule Based Query Rewrite Optimization in Starburst. </title> <booktitle> In Proceedings of ACM SIGMOD '92 International Conference on Management of Data, </booktitle> <address> San Diego, CA, </address> <year> 1992. </year>
Reference: [RSSS93] <author> Raghu Ramakrishnan, Divesh Srivastava, S. Sudarshan and Praveen Seshadri. </author> <title> Implementation of the CORAL deductive database system. </title> <booktitle> In Proceedings of ACM SIGMOD '93 International Conference on Management of Data, </booktitle> <address> San Diego, CA, </address> <year> 1993. </year>
Reference-contexts: If magic sets is performed, the user needs to define the SIPS. This approach is used in CORAL <ref> [RSSS93] </ref> and is effectively an admission that the problem is too difficult to be tackled by a query optimizer. * Independently optimize the query with and without magic rewriting and choose the cheaper plan. For magic rewriting, choose a SIPS based on some heuristic.
Reference: [SI90] <author> Arun Swami and Balakrishna R. Iyer. </author> <title> A Polynomial Time Algorithm for Optimizing Join Queries. </title> <type> Research Report RJ 8812, </type> <institution> IBM Almaden Research Center, </institution> <month> June </month> <year> 1992. </year>
Reference: [SACLP79] <author> Patricia G. Selinger, M. Astrahan, D. Chamberlin, Raymond Lorie, and T. Price. </author> <title> Access Path Selection in a Relational Database Management System. </title> <booktitle> In Proceedings of ACM SIGMOD '79 International Conference on Management of Data, </booktitle> <pages> pages 23-34, </pages> <year> 1979. </year>
Reference-contexts: This restricts the search space (and the complexity of a brute force exhaustive search) to O (N !). In order to find the optimal left deep plan, the System R optimizer <ref> [SACLP79] </ref> uses a dynamic programming algorithm, which further reduces the complexity. It starts by considering each of the N relations as the outermost relation in the join plan. For each of them, it tries all possible joins with some other relation.
Reference: [Sag90] <author> Y. Sagiv. </author> <booktitle> Is there anything better than magic? In Proceedings of the North American Conference on Logic Programming, </booktitle> <pages> pages 235-254, </pages> <address> Austin, Texas, </address> <year> 1990. </year>
Reference-contexts: The impact of different choices if SIPS has been discussed in [BR91], and the idea of using approximations of the magic set has been explored in <ref> [Sag90, SS88] </ref>. Magic sets was shown to be applicable to complex SQL queries [MFPR90, SPL94], and was implemented in the Starburst database system [MP94]. In all implementations, magic sets has been treated as a query rewrite.
Reference: [SPL94] <author> Praveen Seshadri, Hamid Pirahesh, and T.Y.Cliff Leung. </author> <title> Decorrelating Complex Queries. </title> <type> Research Report RJ 9846, </type> <institution> IBM Almaden Research Center, </institution> <year> 1994. </year>
Reference-contexts: The impact of different choices if SIPS has been discussed in [BR91], and the idea of using approximations of the magic set has been explored in [Sag90, SS88]. Magic sets was shown to be applicable to complex SQL queries <ref> [MFPR90, SPL94] </ref>, and was implemented in the Starburst database system [MP94]. In all implementations, magic sets has been treated as a query rewrite.
Reference: [SS88] <author> Seppo Sippu and Eljas Soisalon-Soinen. </author> <title> An optimization strategy for recursive queries in logic databases. </title> <booktitle> In Proceedings of the Fourth International Conference on Data Engineering, </booktitle> <address> Los Angeles, California, </address> <year> 1988. </year>
Reference-contexts: The impact of different choices if SIPS has been discussed in [BR91], and the idea of using approximations of the magic set has been explored in <ref> [Sag90, SS88] </ref>. Magic sets was shown to be applicable to complex SQL queries [MFPR90, SPL94], and was implemented in the Starburst database system [MP94]. In all implementations, magic sets has been treated as a query rewrite.
Reference: [SSS95] <author> Divesh Srivastava, Peter J. Stuckey and S. Sudarshan. </author> <title> The Magic of Generalized Semijoins. </title> <type> Preliminary draft, </type> <institution> ATT Bell Labs, </institution> <address> Murray Hill, NJ, </address> <month> March </month> <year> 1995. </year>
Reference-contexts: On the other hand, semi-joins are viewed as a lower level join optimization. Our observation is that both techniques (as well as others: see Section 5) are really instances of the Filter join method. A similar observation has recently been made independently by <ref> [SSS95] </ref>. Our approach treats magic sets rewriting as a query planning choice that includes a Filter join, with the view being the inner relation. The choice of SIPS then becomes similar to a choice of join order. <p> In all implementations, magic sets has been treated as a query rewrite. Our interpretation of magic sets as an instance of a Filter join method distinguishes our current work from this earlier work, and allows us to integrate magic sets with a cost-based optimizer. In <ref> [SSS95] </ref> which was developed independently at the same time as our work, magic sets rewriting is described as being a "generalized semi-join". The idea is similar to ours in that magic sets has effectively been reduced to an algebraic operator.
Reference: [SSW94] <author> Konstantinos Sagonas, Terrance Swift and David S. Warren. </author> <title> XSB as an Efficient Deductive Database Engine. </title> <booktitle> In Proceedings of ACM SIGMOD '94 International Conference on Management of Data, </booktitle> <pages> pages 442-453, </pages> <year> 1994. </year>
Reference: [Val90] <author> Patrick Valduriez. </author> <title> Join Indices. </title> <journal> In ACM Transactions on Database Systems, Vol.12, No.2, </journal> <pages> pages 219-246, </pages> <month> June </month> <year> 1987. </year>
Reference: [Yao77] <author> S.B. Yao. </author> <title> Approximating the Number of Accesses in Database Organizations. </title> <booktitle> In Communications of the ACM 20,4, </booktitle> <pages> pages 260-261, </pages> <month> April </month> <year> 1977. </year>
Reference-contexts: While we note that it is notoriously difficult to estimate the cardinality of projections [HOT88, LNSS93], the optimizer can make a estimate based on the cardinality of the production set P , and assumptions about the distributions of values in the various columns <ref> [Yao77] </ref>. Traditional optimizers already use some approximate technique to estimate projection cardinality; any such available technique can be used. F ilterCost R k : This is the cost of restricting R k using the filter set F .
References-found: 26

