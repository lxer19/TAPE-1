URL: http://csel.cs.colorado.edu/~ssims/Public/linux/ACE-concurrency.ps.gz
Refering-URL: http://csel.cs.colorado.edu/~ssims/Public/linux/
Root-URL: http://www.cs.colorado.edu
Email: schmidt@cs.wustl.edu  
Title: An OO Encapsulation of Lightweight OS Concurrency Mechanisms in the ACE Toolkit  
Author: Douglas C. Schmidt 
Address: St. Louis, MO 63130, (314) 935-7538  
Affiliation: Department of Computer Science Washington University  
Web: http://www.cs.wustl.edu/~schmidt/  
Abstract: This document is available as technical report number WUCS-95-31, from techrep@cs.wustl.edu at Washington University, St. Louis. Abstract This paper describes the design of the ACE object-oriented thread encapsulation C++ class library. This library shields programmers from differences between Solaris threads, POSIX pthreads, and Win32 threads. The architecture of this class library is presented from an end-user and internal design perspective and key design and implementation issues are discussed. Readers will gain an understanding of the overall design approach, as well as the tradeoffs between various software quality factors such as performance, portability, and extensibility. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> D. C. Schmidt, </author> <title> ACE: an Object-Oriented Framework for Developing Distributed Applications, </title> <booktitle> in Proceedings of the 6 th USENIX C++ Technical Conference, </booktitle> <address> (Cambridge, Mas-sachusetts), </address> <publisher> USENIX Association, </publisher> <month> April </month> <year> 1994. </year>
Reference-contexts: This paper describes a C++ class library contained in the ADAPTIVE Communications Environment (ACE) <ref> [1] </ref>. ACE encapsulates and enhances the lightweight concurrency mechanisms provided both by Solaris 2.x threads [2], POSIX Pthreads [3], and Win32 threads [4]. The material presented in this paper is intended for a technical audience interested in understanding the strategies and tactics of object-oriented (OO) concurrent programming using threads. <p> for (int i = 0; i &lt; iterations; i++) ++request_count; // Count # of requests return (void *) iterations; - typedef void *(*THR_FUNC)(void *); // Main driver function for the // multi-threaded server. int main (int argc, char *argv []) - int n_threads = argc &gt; 1 ? atoi (argv <ref> [1] </ref>) : 4; int n_iterations = argc &gt; 2 ? atoi (argv [2]) : 1000000; thread_t t_id; // Divide iterations evenly among threads. int iterations = n_iterations / n_threads; // Spawn off N threads to run in parallel. for (int i = 0; i &lt; n_threads; i++) thr_create (0, 0, THR_FUNC <p> This section focuses on the steps involved in generalizing from existing code by using templates and overloading to transparently parameterize synchronization mechanisms into a concurrent application. The infrastructure code is based on components in the ADAPTIVE Communication Environment (ACE) framework described in <ref> [1, 26, 20] </ref>. This example examines several C++ language features that solve the serialization problem presented in Section 3.5.1 more elegantly. As described in that section, the original solution was inelegant, non-portable, error-prone, and required obtrusive changes to the source code. <p> Conversely, the put method may enqueue the message and defer handling to its svc method that is executing in a separate thread of control (i.e., the asynchronous processing approach illustrated in Figure 4 (2)). As discussed in <ref> [1] </ref>, the particular processing approach that is selected has a significant impact on performance and ease of programming. 22 * Message Queueing Mechanisms In addition to the open, close, put, and svc pure virtual method interfaces, each Task also contains a Message Queue. <p> // The destructor of Thread_Control removes the // exiting thread from the Thread_Manager // automatically. return 0; - // Default port number. static const int default_port = 5000; int main (int argc, char *argv []) - // Port number of server. u_short port = argc &gt; 1 ? atoi (argv <ref> [1] </ref>) : default_port; // Internet address of server. INET_Addr addr (port); // Passive-mode listener object.
Reference: [2] <author> J. Eykholt, S. Kleiman, S. Barton, R. Faulkner, A. Shivalin-giah, M. Smith, D. Stein, J. Voll, M. Weeks, and D. Williams, </author> <title> Beyond Multiprocessing... Multithreading the SunOS Kernel, </title> <booktitle> in Proceedings of the Summer USENIX Conference, </booktitle> <address> (San Antonio, Texas), </address> <month> June </month> <year> 1992. </year> <month> 30 </month>
Reference-contexts: This paper describes a C++ class library contained in the ADAPTIVE Communications Environment (ACE) [1]. ACE encapsulates and enhances the lightweight concurrency mechanisms provided both by Solaris 2.x threads <ref> [2] </ref>, POSIX Pthreads [3], and Win32 threads [4]. The material presented in this paper is intended for a technical audience interested in understanding the strategies and tactics of object-oriented (OO) concurrent programming using threads. <p> These ACE components provide a portable and extensible interface for concurrent programming. This interface simplifies thread management and synchronization mechanisms used to develop clients and servers. This interface has been ported to many drafts of the POSIX pthreads standard [3], Solaris threads <ref> [2] </ref>, Microsoft WIN32 threads [4], and VxWorks tasks. 2.1.1 Overall Requirements In conjunction with the goal of encapsulating and simplifying the concurrency substrate of OS threading mechanisms, the ACE OO thread encapsulation class library is being developed in response to the following common application requirements. * Simplify program design by allowing <p> There is less experience, however, with emerging multi-threading and synchronization mechanisms for UNIX (such as Solaris threads <ref> [2] </ref>, POSIX pthreads [3], or Win32 threads [4]). This section presents an overview of background material relevant to concurrent programming and Solaris threads. <p> This section presents an overview of background material relevant to concurrent programming and Solaris threads. More detailed discussions of concurrent programming, and Solaris/POSIX/Win32 threads appear in <ref> [2, 18, 19, 3, 4] </ref>. 3.1 Processes and Threads A process is a collection of resources that enable the execution of program instructions. These resources include virtual memory, I/O descriptors, a run-time stack, signal handlers, user and group ids, and access control tokens. <p> In addition to an instruction pointer, a thread consists of other resources such as a run-time stack of function activation records, a set of general-purpose registers, and thread-specific data. Conventional workstation operating systems (such as variants of UNIX <ref> [2, 21, 22] </ref> and Windows NT [4]) support the concurrent execution of multiple processes, each of which may contain 1 or more threads. A process serves as the unit of protection and resource allocation within a separate hardware protected address space. <p> # of requests return (void *) iterations; - typedef void *(*THR_FUNC)(void *); // Main driver function for the // multi-threaded server. int main (int argc, char *argv []) - int n_threads = argc &gt; 1 ? atoi (argv [1]) : 4; int n_iterations = argc &gt; 2 ? atoi (argv <ref> [2] </ref>) : 1000000; thread_t t_id; // Divide iterations evenly among threads. int iterations = n_iterations / n_threads; // Spawn off N threads to run in parallel. for (int i = 0; i &lt; n_threads; i++) thr_create (0, 0, THR_FUNC (&run_svc), (void *) iterations, THR_BOUND | THR_SUSPENDED, &t_id); // Resume all suspended <p> A spin-lock is a simple and efficient synchronization mechanism for certain types of short-lived resource contention, like auto-incrementing the global request count variable illustrated in Example 1 above. An adaptive spin-lock polls a designated memory location using the atomic hardware instruction until one of the following conditions occur <ref> [2] </ref>: Mutexes provide an efficient form of mutual exclusion. They define a critical section where only a single thread may execute at a time. * The value at this location is changed by the thread that currently owns the lock.
Reference: [3] <author> IEEE, </author> <title> Threads Extension for Portable Operating Systems (Draft 10), </title> <month> February </month> <year> 1996. </year>
Reference-contexts: This paper describes a C++ class library contained in the ADAPTIVE Communications Environment (ACE) [1]. ACE encapsulates and enhances the lightweight concurrency mechanisms provided both by Solaris 2.x threads [2], POSIX Pthreads <ref> [3] </ref>, and Win32 threads [4]. The material presented in this paper is intended for a technical audience interested in understanding the strategies and tactics of object-oriented (OO) concurrent programming using threads. <p> These ACE components provide a portable and extensible interface for concurrent programming. This interface simplifies thread management and synchronization mechanisms used to develop clients and servers. This interface has been ported to many drafts of the POSIX pthreads standard <ref> [3] </ref>, Solaris threads [2], Microsoft WIN32 threads [4], and VxWorks tasks. 2.1.1 Overall Requirements In conjunction with the goal of encapsulating and simplifying the concurrency substrate of OS threading mechanisms, the ACE OO thread encapsulation class library is being developed in response to the following common application requirements. * Simplify program <p> There is less experience, however, with emerging multi-threading and synchronization mechanisms for UNIX (such as Solaris threads [2], POSIX pthreads <ref> [3] </ref>, or Win32 threads [4]). This section presents an overview of background material relevant to concurrent programming and Solaris threads. <p> This section presents an overview of background material relevant to concurrent programming and Solaris threads. More detailed discussions of concurrent programming, and Solaris/POSIX/Win32 threads appear in <ref> [2, 18, 19, 3, 4] </ref>. 3.1 Processes and Threads A process is a collection of resources that enable the execution of program instructions. These resources include virtual memory, I/O descriptors, a run-time stack, signal handlers, user and group ids, and access control tokens. <p> In contrast, the native Solaris and pthreads cond t cond wait interface requires a mutex to be passed as a parameter on every call to wait. Solaris 2.x and Win32 provide a built-in implementation of counting semaphores (see the discussion in Section 3.5.3). However, the POSIX Pthreads <ref> [3] </ref> threads library does not include a semaphore.
Reference: [4] <author> H. Custer, </author> <title> Inside Windows NT. </title> <address> Redmond, Washington: </address> <publisher> Mi-crosoft Press, </publisher> <year> 1993. </year>
Reference-contexts: This paper describes a C++ class library contained in the ADAPTIVE Communications Environment (ACE) [1]. ACE encapsulates and enhances the lightweight concurrency mechanisms provided both by Solaris 2.x threads [2], POSIX Pthreads [3], and Win32 threads <ref> [4] </ref>. The material presented in this paper is intended for a technical audience interested in understanding the strategies and tactics of object-oriented (OO) concurrent programming using threads. <p> These ACE components provide a portable and extensible interface for concurrent programming. This interface simplifies thread management and synchronization mechanisms used to develop clients and servers. This interface has been ported to many drafts of the POSIX pthreads standard [3], Solaris threads [2], Microsoft WIN32 threads <ref> [4] </ref>, and VxWorks tasks. 2.1.1 Overall Requirements In conjunction with the goal of encapsulating and simplifying the concurrency substrate of OS threading mechanisms, the ACE OO thread encapsulation class library is being developed in response to the following common application requirements. * Simplify program design by allowing multiple application tasks to <p> There is less experience, however, with emerging multi-threading and synchronization mechanisms for UNIX (such as Solaris threads [2], POSIX pthreads [3], or Win32 threads <ref> [4] </ref>). This section presents an overview of background material relevant to concurrent programming and Solaris threads. More detailed discussions of concurrent programming, and Solaris/POSIX/Win32 threads appear in [2, 18, 19, 3, 4]. 3.1 Processes and Threads A process is a collection of resources that enable the execution of program instructions. <p> This section presents an overview of background material relevant to concurrent programming and Solaris threads. More detailed discussions of concurrent programming, and Solaris/POSIX/Win32 threads appear in <ref> [2, 18, 19, 3, 4] </ref>. 3.1 Processes and Threads A process is a collection of resources that enable the execution of program instructions. These resources include virtual memory, I/O descriptors, a run-time stack, signal handlers, user and group ids, and access control tokens. <p> In addition to an instruction pointer, a thread consists of other resources such as a run-time stack of function activation records, a set of general-purpose registers, and thread-specific data. Conventional workstation operating systems (such as variants of UNIX [2, 21, 22] and Windows NT <ref> [4] </ref>) support the concurrent execution of multiple processes, each of which may contain 1 or more threads. A process serves as the unit of protection and resource allocation within a separate hardware protected address space. <p> This style is for exposition purposes only and should not be used when developing applications. 11 more portable across OS platforms. For example, the fol- lowing is an implementation of the Thread Mutex class interface based on mechanisms in the Windows NT WIN32 API <ref> [4] </ref>: 6 class Thread_Mutex - public: Thread_Mutex (void) - InitializeCriticalSection (&lock_); - Thread_Mutex (void) - DeleteCriticalSection (&lock_); - int acquire (void) - EnterCriticalSection (&lock_); return 0; - int release (void) - LeaveCriticalSection (&lock_); return 0; - private: // Win32 serialization mechanism.
Reference: [5] <author> E. Gamma, R. Helm, R. Johnson, and J. Vlissides, </author> <title> Design Patterns: Elements of Reusable Object-Oriented Software. </title> <address> Reading, MA: </address> <publisher> Addison-Wesley, </publisher> <year> 1995. </year>
Reference-contexts: The material presented in this paper is intended for a technical audience interested in understanding the strategies and tactics of object-oriented (OO) concurrent programming using threads. It is assumed that the reader is familiar with general OO design and programming techniques (such as design patterns <ref> [5] </ref>, application frameworks [6], modularity, information hiding, and object modeling [7]), OO notations (such as OMT [8]), fundamental C++ programming language features (such as classes, inheritance, dynamic binding, and parameterized types [9]), basic UNIX systems programming concepts (such as process management, virtual memory, and interprocess communication [10]), and networking terminology (such
Reference: [6] <author> R. Johnson and B. Foote, </author> <title> Designing Reusable Classes, </title> <journal> Journal of Object-Oriented Programming, </journal> <volume> vol. 1, </volume> <pages> pp. 2235, </pages> <month> June/July </month> <year> 1988. </year>
Reference-contexts: The material presented in this paper is intended for a technical audience interested in understanding the strategies and tactics of object-oriented (OO) concurrent programming using threads. It is assumed that the reader is familiar with general OO design and programming techniques (such as design patterns [5], application frameworks <ref> [6] </ref>, modularity, information hiding, and object modeling [7]), OO notations (such as OMT [8]), fundamental C++ programming language features (such as classes, inheritance, dynamic binding, and parameterized types [9]), basic UNIX systems programming concepts (such as process management, virtual memory, and interprocess communication [10]), and networking terminology (such as client/server architectures
Reference: [7] <author> G. Booch, </author> <title> Object Oriented Analysis and Design with Applications (2 nd Edition). </title> <address> Redwood City, California: Ben-jamin/Cummings, </address> <year> 1993. </year>
Reference-contexts: It is assumed that the reader is familiar with general OO design and programming techniques (such as design patterns [5], application frameworks [6], modularity, information hiding, and object modeling <ref> [7] </ref>), OO notations (such as OMT [8]), fundamental C++ programming language features (such as classes, inheritance, dynamic binding, and parameterized types [9]), basic UNIX systems programming concepts (such as process management, virtual memory, and interprocess communication [10]), and networking terminology (such as client/server architectures [11], RPC [12], CORBA [13], and TCP/IP <p> It employs a C++ idiom idiom commonly known as constructor as resource acquisition destructor as resource release <ref> [9, 27, 7] </ref>. As shown in the code above, the constructor of a Guard class acquires the lock on the Thread Mutex object auto matically when an object of the class is created.
Reference: [8] <author> J. Rumbaugh, M. Blaha, W. Premerlani, F. Eddy, and W. Lorensen, </author> <title> Object-Oriented Modeling and Design. </title> <address> Engle-wood Cliffs, NJ: </address> <publisher> Prentice Hall, </publisher> <year> 1991. </year>
Reference-contexts: It is assumed that the reader is familiar with general OO design and programming techniques (such as design patterns [5], application frameworks [6], modularity, information hiding, and object modeling [7]), OO notations (such as OMT <ref> [8] </ref>), fundamental C++ programming language features (such as classes, inheritance, dynamic binding, and parameterized types [9]), basic UNIX systems programming concepts (such as process management, virtual memory, and interprocess communication [10]), and networking terminology (such as client/server architectures [11], RPC [12], CORBA [13], and TCP/IP [14, 15]).
Reference: [9] <author> Bjarne Stroustrup, </author> <title> The C++ Programming Language, 2 nd Edition. </title> <publisher> Addison-Wesley, </publisher> <year> 1991. </year>
Reference-contexts: It is assumed that the reader is familiar with general OO design and programming techniques (such as design patterns [5], application frameworks [6], modularity, information hiding, and object modeling [7]), OO notations (such as OMT [8]), fundamental C++ programming language features (such as classes, inheritance, dynamic binding, and parameterized types <ref> [9] </ref>), basic UNIX systems programming concepts (such as process management, virtual memory, and interprocess communication [10]), and networking terminology (such as client/server architectures [11], RPC [12], CORBA [13], and TCP/IP [14, 15]). <p> It employs a C++ idiom idiom commonly known as constructor as resource acquisition destructor as resource release <ref> [9, 27, 7] </ref>. As shown in the code above, the constructor of a Guard class acquires the lock on the Thread Mutex object auto matically when an object of the class is created.
Reference: [10] <author> W. R. Stevens, </author> <title> Advanced Programming in the UNIX Environment. </title> <address> Reading, Massachusetts: </address> <publisher> Addison Wesley, </publisher> <year> 1992. </year>
Reference-contexts: (such as design patterns [5], application frameworks [6], modularity, information hiding, and object modeling [7]), OO notations (such as OMT [8]), fundamental C++ programming language features (such as classes, inheritance, dynamic binding, and parameterized types [9]), basic UNIX systems programming concepts (such as process management, virtual memory, and interprocess communication <ref> [10] </ref>), and networking terminology (such as client/server architectures [11], RPC [12], CORBA [13], and TCP/IP [14, 15]). This paper does not assume in-depth knowledge of concurrency, in general, or Solaris/POSIX/Win32 multi-threading and synchronization mechanisms, in particular. An overview of concurrent programming and multi-threading is presented in Section 3.
Reference: [11] <author> D. E. Comer and D. L. Stevens, </author> <title> Internetworking with TCP/IP Vol III: Client Server Programming and Applications. </title> <address> En-glewood Cliffs, NJ: </address> <publisher> Prentice Hall, </publisher> <year> 1992. </year>
Reference-contexts: modularity, information hiding, and object modeling [7]), OO notations (such as OMT [8]), fundamental C++ programming language features (such as classes, inheritance, dynamic binding, and parameterized types [9]), basic UNIX systems programming concepts (such as process management, virtual memory, and interprocess communication [10]), and networking terminology (such as client/server architectures <ref> [11] </ref>, RPC [12], CORBA [13], and TCP/IP [14, 15]). This paper does not assume in-depth knowledge of concurrency, in general, or Solaris/POSIX/Win32 multi-threading and synchronization mechanisms, in particular. An overview of concurrent programming and multi-threading is presented in Section 3.
Reference: [12] <author> Sun Microsystems, </author> <title> Open Network Computing: Transport Independent RPC, </title> <month> June </month> <year> 1995. </year>
Reference-contexts: hiding, and object modeling [7]), OO notations (such as OMT [8]), fundamental C++ programming language features (such as classes, inheritance, dynamic binding, and parameterized types [9]), basic UNIX systems programming concepts (such as process management, virtual memory, and interprocess communication [10]), and networking terminology (such as client/server architectures [11], RPC <ref> [12] </ref>, CORBA [13], and TCP/IP [14, 15]). This paper does not assume in-depth knowledge of concurrency, in general, or Solaris/POSIX/Win32 multi-threading and synchronization mechanisms, in particular. An overview of concurrent programming and multi-threading is presented in Section 3.
Reference: [13] <author> Object Management Group, </author> <title> The Common Object Request Broker: Architecture and Specification, </title> <editor> 1.2 ed., </editor> <year> 1993. </year>
Reference-contexts: object modeling [7]), OO notations (such as OMT [8]), fundamental C++ programming language features (such as classes, inheritance, dynamic binding, and parameterized types [9]), basic UNIX systems programming concepts (such as process management, virtual memory, and interprocess communication [10]), and networking terminology (such as client/server architectures [11], RPC [12], CORBA <ref> [13] </ref>, and TCP/IP [14, 15]). This paper does not assume in-depth knowledge of concurrency, in general, or Solaris/POSIX/Win32 multi-threading and synchronization mechanisms, in particular. An overview of concurrent programming and multi-threading is presented in Section 3.
Reference: [14] <author> W. R. Stevens, </author> <title> UNIX Network Programming, First Edition. </title> <address> Englewood Cliffs, NJ: </address> <publisher> Prentice Hall, </publisher> <year> 1990. </year>
Reference-contexts: OO notations (such as OMT [8]), fundamental C++ programming language features (such as classes, inheritance, dynamic binding, and parameterized types [9]), basic UNIX systems programming concepts (such as process management, virtual memory, and interprocess communication [10]), and networking terminology (such as client/server architectures [11], RPC [12], CORBA [13], and TCP/IP <ref> [14, 15] </ref>). This paper does not assume in-depth knowledge of concurrency, in general, or Solaris/POSIX/Win32 multi-threading and synchronization mechanisms, in particular. An overview of concurrent programming and multi-threading is presented in Section 3.
Reference: [15] <author> W. R. Stevens, </author> <title> TCP/IP Illustrated, </title> <booktitle> Volume 1. </booktitle> <address> Reading, Mas-sachusetts: </address> <publisher> Addison Wesley, </publisher> <year> 1993. </year>
Reference-contexts: OO notations (such as OMT [8]), fundamental C++ programming language features (such as classes, inheritance, dynamic binding, and parameterized types [9]), basic UNIX systems programming concepts (such as process management, virtual memory, and interprocess communication [10]), and networking terminology (such as client/server architectures [11], RPC [12], CORBA [13], and TCP/IP <ref> [14, 15] </ref>). This paper does not assume in-depth knowledge of concurrency, in general, or Solaris/POSIX/Win32 multi-threading and synchronization mechanisms, in particular. An overview of concurrent programming and multi-threading is presented in Section 3.
Reference: [16] <author> R. G. Lavender and D. C. Schmidt, </author> <title> Active Object: an Object Behavioral Pattern for Concurrent Programming, </title> <booktitle> in Proceedings of the 2 nd Annual Conference on the Pattern Languages of Programs, </booktitle> <address> (Monticello, </address> <publisher> Illinois), </publisher> <pages> pp. 17, </pages> <month> September </month> <year> 1995. </year>
Reference-contexts: This class is described in Section 5.4.2. 2.2.5 The ACE Active Objects Class Category * Task: The Task class is the central mechanism in ACE for defining active objects <ref> [16, 17] </ref>. These active objects queue messages for input and output and perform user-defined message processing services in separate threads of control. <p> -; Note how this classes inherits from the ACE Acceptor class, which is a generic factory for passively connecting clients and creating service handlers [30]. 5.5 The ACE Active Objects Class Category 5.5.1 The Task Class The Task class is the central mechanism in ACE for creating user-defined active objects <ref> [16] </ref> and passive objects that process application messages.
Reference: [17] <author> D. C. Schmidt and C. D. Cranor, Half-Sync/Half-Async: </author> <title> an Architectural Pattern for Efficient and Well-structured Concurrent I/O, </title> <booktitle> in Proceedings of the 2 nd Annual Conference on the Pattern Languages of Programs, </booktitle> <address> (Monticello, </address> <publisher> Illinois), </publisher> <pages> pp. 110, </pages> <month> September </month> <year> 1995. </year>
Reference-contexts: This class is described in Section 5.4.2. 2.2.5 The ACE Active Objects Class Category * Task: The Task class is the central mechanism in ACE for defining active objects <ref> [16, 17] </ref>. These active objects queue messages for input and output and perform user-defined message processing services in separate threads of control.
Reference: [18] <author> A. D. Birrell, </author> <title> An Introduction to Programming with Threads, </title> <type> Tech. Rep. </type> <institution> SRC-035, Digital Equipment Corporation, </institution> <month> January </month> <year> 1989. </year>
Reference-contexts: This section presents an overview of background material relevant to concurrent programming and Solaris threads. More detailed discussions of concurrent programming, and Solaris/POSIX/Win32 threads appear in <ref> [2, 18, 19, 3, 4] </ref>. 3.1 Processes and Threads A process is a collection of resources that enable the execution of program instructions. These resources include virtual memory, I/O descriptors, a run-time stack, signal handlers, user and group ids, and access control tokens.
Reference: [19] <author> Sun Microsystems, Inc., </author> <title> Mountain View, CA, SunOS 5.3 Guide to Multi-Thread Programming, Part number: </title> <editor> 801-3176-10 ed., </editor> <month> May </month> <year> 1993. </year>
Reference-contexts: This section presents an overview of background material relevant to concurrent programming and Solaris threads. More detailed discussions of concurrent programming, and Solaris/POSIX/Win32 threads appear in <ref> [2, 18, 19, 3, 4] </ref>. 3.1 Processes and Threads A process is a collection of resources that enable the execution of program instructions. These resources include virtual memory, I/O descriptors, a run-time stack, signal handlers, user and group ids, and access control tokens. <p> In many circumstances, however, multi-threading does not improve performance. For example, compute-bound applications on a uni-processor <ref> [19] </ref> will not benefit from multi-threading since computation will not overlap communication. In addition, fine-grained locking causes high levels of synchronization overhead [23, 24]. This prevents applications from fully exploiting the benefits of parallel processing. There are some circumstances where multi-threading may improve performance significantly. <p> Solaris 2.x provides several synchronization mechanisms. This paper describes C++ wrappers for the four primary synchronization mechanisms provided by Solaris 2.x: mutexes, readers/writer locks, counting semaphores, and condition variables <ref> [19] </ref>. ACE contains C++ wrappers (Mutex, RW Lock, Semaphore, and Condition) that encapsulate these four Solaris 2.x synchronization mechanisms (mutex t, rwlock t, sema t, and cond t, respectively). In the remainder of Section 3 we outline the behavior of the Solaris synchronization mechanisms. <p> In this case, there is no need to maintain event history. Thus, condition variables do not record when they are signalled. If not used correctly, this can lead to lost wakeup problems <ref> [19] </ref>. Solaris 2.x and POSIX pthreads support condition variables via the cond t type. The native Win32 API does not support condition variables.
Reference: [20] <author> D. C. Schmidt, </author> <title> Reactor: An Object Behavioral Pattern for Concurrent Event Demultiplexing and Event Handler Dispatching, in Pattern Languages of Program Design (J. </title> <editor> O. Coplien and D. C. Schmidt, </editor> <booktitle> eds.), </booktitle> <pages> pp. 529545, </pages> <address> Reading, MA: </address> <publisher> Addison-Wesley, </publisher> <year> 1995. </year>
Reference-contexts: There are several common workarounds to avoid blocking in single-threaded servers: * Event demultiplexers/dispatcher one approach is to develop an event demultiplexer/dispatcher (such as the object-oriented Reactor framework <ref> [20] </ref>). This technique is widely used to manage multiple input devices in single-threaded user-interface frameworks. The main event demultiplexer/dispatcher detects an incoming event, demultiplexes the event to the appropriate event handler, and then dispatches an application-specific callback method associated with the event handler. <p> This section focuses on the steps involved in generalizing from existing code by using templates and overloading to transparently parameterize synchronization mechanisms into a concurrent application. The infrastructure code is based on components in the ADAPTIVE Communication Environment (ACE) framework described in <ref> [1, 26, 20] </ref>. This example examines several C++ language features that solve the serialization problem presented in Section 3.5.1 more elegantly. As described in that section, the original solution was inelegant, non-portable, error-prone, and required obtrusive changes to the source code. <p> It works with the Thread Mutex class. By default, Solaris provides non-recursive mutexes. These semantics are too restrictive in certain circumstances. There fore, ACE provides support for recursive locks via the Recursive Thread Mutex class. Recursive locks are particularly useful for callback-driven C++ frameworks <ref> [28, 20] </ref>, where the framework event-loop performs a callback to user-defined code. Since the user-defined code may subse quently re-enter framework code via a method entry point, recursive locks are useful to prevent deadlock from occur ring on locks held within the framework during the callback.
Reference: [21] <author> A. Garg, </author> <title> Parallel STREAMS: a Multi-Process Implementation, </title> <booktitle> in Proceedings of the Winter USENIX Conference, </booktitle> <address> (Washington, D.C.), </address> <month> Jan. </month> <year> 1990. </year>
Reference-contexts: In addition to an instruction pointer, a thread consists of other resources such as a run-time stack of function activation records, a set of general-purpose registers, and thread-specific data. Conventional workstation operating systems (such as variants of UNIX <ref> [2, 21, 22] </ref> and Windows NT [4]) support the concurrent execution of multiple processes, each of which may contain 1 or more threads. A process serves as the unit of protection and resource allocation within a separate hardware protected address space.
Reference: [22] <author> S. Saxena, J. K. Peacock, F. Yang, V. Verma, and M. Krish-nan, </author> <title> Pitfalls in Multithreading SVR4 STREAMS and other Weightless Processes, </title> <booktitle> in Proceedings of the Winter USENIX Conference, </booktitle> <address> (San Diego, CA), </address> <pages> pp. 85106, </pages> <month> Jan. </month> <year> 1993. </year>
Reference-contexts: In addition to an instruction pointer, a thread consists of other resources such as a run-time stack of function activation records, a set of general-purpose registers, and thread-specific data. Conventional workstation operating systems (such as variants of UNIX <ref> [2, 21, 22] </ref> and Windows NT [4]) support the concurrent execution of multiple processes, each of which may contain 1 or more threads. A process serves as the unit of protection and resource allocation within a separate hardware protected address space.
Reference: [23] <author> D. C. Schmidt and T. Suda, </author> <title> Measuring the Performance of Parallel Message-based Process Architectures, </title> <booktitle> in Proceedings of the Conference on Computer Communications (INFO-COM), </booktitle> <address> (Boston, MA), </address> <pages> pp. 624633, </pages> <publisher> IEEE, </publisher> <month> April </month> <year> 1995. </year>
Reference-contexts: In many circumstances, however, multi-threading does not improve performance. For example, compute-bound applications on a uni-processor [19] will not benefit from multi-threading since computation will not overlap communication. In addition, fine-grained locking causes high levels of synchronization overhead <ref> [23, 24] </ref>. This prevents applications from fully exploiting the benefits of parallel processing. There are some circumstances where multi-threading may improve performance significantly. For example, a multi-threading connection-oriented application gateway may benefit by being run on a multi-processor platform.
Reference: [24] <author> Mats Bjorkman and Per Gunningberg, </author> <title> Locking Strategies in Multiprocessor Implementations of Protocols, </title> <booktitle> in Proceedings of the Symposium on Communications Architectures and Protocols (SIGCOMM), </booktitle> <address> (San Francisco, California), </address> <publisher> ACM, </publisher> <year> 1993. </year>
Reference-contexts: In many circumstances, however, multi-threading does not improve performance. For example, compute-bound applications on a uni-processor [19] will not benefit from multi-threading since computation will not overlap communication. In addition, fine-grained locking causes high levels of synchronization overhead <ref> [23, 24] </ref>. This prevents applications from fully exploiting the benefits of parallel processing. There are some circumstances where multi-threading may improve performance significantly. For example, a multi-threading connection-oriented application gateway may benefit by being run on a multi-processor platform.
Reference: [25] <author> D. C. Schmidt, </author> <title> A Family of Design Patterns for Application-level Gateways, </title> <journal> The Theory and Practice of Object Systems (Special Issue on Patterns and Pattern Languages), </journal> <volume> vol. 2, no. 1, </volume> <year> 1996. </year>
Reference-contexts: This use case depicts a representative scenario that is based upon a production system <ref> [25] </ref>. Additional examples of the ACE OO thread encapsulation class library appear in Section 6, following the presentation the library interfaces in Section 5. Many useful C++ classes have evolved incrementally by generalizing from solutions to practical problems that arise during system development.
Reference: [26] <author> D. C. Schmidt and P. Stephenson, </author> <title> An Object-Oriented Framework for Developing Network Server Daemons, </title> <booktitle> in Proceedings of the 2 nd C++ World Conference, </booktitle> <address> (Dallas, Texas), SIGS, </address> <month> Oct. </month> <year> 1993. </year>
Reference-contexts: This section focuses on the steps involved in generalizing from existing code by using templates and overloading to transparently parameterize synchronization mechanisms into a concurrent application. The infrastructure code is based on components in the ADAPTIVE Communication Environment (ACE) framework described in <ref> [1, 26, 20] </ref>. This example examines several C++ language features that solve the serialization problem presented in Section 3.5.1 more elegantly. As described in that section, the original solution was inelegant, non-portable, error-prone, and required obtrusive changes to the source code.
Reference: [27] <author> G. Booch and M. Vilot, </author> <title> Simplifying the Booch Components, </title> <journal> C++ Report, </journal> <volume> vol. 5, </volume> <month> June </month> <year> 1993. </year>
Reference-contexts: It employs a C++ idiom idiom commonly known as constructor as resource acquisition destructor as resource release <ref> [9, 27, 7] </ref>. As shown in the code above, the constructor of a Guard class acquires the lock on the Thread Mutex object auto matically when an object of the class is created.
Reference: [28] <author> M. A. Linton and P. R. Calder, </author> <booktitle> The Design and Implementation of InterViews, in Proceedings of the USENIX C++ Workshop, </booktitle> <month> November </month> <year> 1987. </year>
Reference-contexts: It works with the Thread Mutex class. By default, Solaris provides non-recursive mutexes. These semantics are too restrictive in certain circumstances. There fore, ACE provides support for recursive locks via the Recursive Thread Mutex class. Recursive locks are particularly useful for callback-driven C++ frameworks <ref> [28, 20] </ref>, where the framework event-loop performs a callback to user-defined code. Since the user-defined code may subse quently re-enter framework code via a method entry point, recursive locks are useful to prevent deadlock from occur ring on locks held within the framework during the callback.
Reference: [29] <author> T. Harrison and D. C. Schmidt, </author> <title> Thread-Specific Storage: A Pattern for Reducing Locking Overhead in Concurrent Programs, </title> <booktitle> in OOPSLA Workshop on Design Patterns for Concurrent, Parallel, and Distributed Systems, ACM, </booktitle> <month> October </month> <year> 1995. </year>
Reference-contexts: A program executing factorial in multiple threads would produce unpredictable results since recursion depth is a global various that would be modified serially by multiple threads of control! A more appropriate (and less expensive) locking strategy in this case would use the Thread-Specific Storage pattern <ref> [29] </ref> described in Section 5.6.4. 5.1.5 The Null Mutex Class The Null Mutex class provides a zero-overhead implementation of the general locking interface shared by the other C++ wrappers for threading and synchronization. <p> The underlying thread specific storage pattern this class is based upon is described in <ref> [29] </ref>. The following is the public interface of the ACE TSS class: template &lt;class TYPE&gt; class TSS - public: // If caller passes a non-NULL ts_obj * // this is used to initialize the // thread-specific value. Thus, calls // to operator-&gt;() will return this value.
Reference: [30] <author> D. C. Schmidt, </author> <title> Acceptor and Connector: Design Patterns for Actively and Passively Initializing Network Services, </title> <booktitle> in Workshop on Pattern Languages of Object-Oriented Programs at ECOOP '95, </booktitle> <address> (Aarhus, Denmark), </address> <month> August </month> <year> 1995. </year>
Reference-contexts: SVC_HANDLER *make_svc_handler (void); // Factory method that creates an appropriate // SVC_HANDLER *. virtual int thr_flags (void); // Returns the flags used to spawn a thread. -; Note how this classes inherits from the ACE Acceptor class, which is a generic factory for passively connecting clients and creating service handlers <ref> [30] </ref>. 5.5 The ACE Active Objects Class Category 5.5.1 The Task Class The Task class is the central mechanism in ACE for creating user-defined active objects [16] and passive objects that process application messages.
Reference: [31] <author> N. C. Hutchinson and L. L. Peterson, </author> <title> The x-kernel: An Architecture for Implementing Network Protocols, </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> vol. 17, </volume> <pages> pp. 6476, </pages> <month> January </month> <year> 1991. </year>
Reference-contexts: The put method runs synchronously with respect to its caller, i.e., it borrows the thread of control from the Task that originally invoked its put method. This thread of control typically originate either upstream from an application process, downstream from a pool of threads that handle I/O device interrupts <ref> [31] </ref>, or internal to the Stream from an event dispatching mechanism (such as a timer-driven callout queue used to trigger retransmissions in a connection-oriented transport protocol Module).
Reference: [32] <author> D. C. Schmidt, </author> <title> The ADAPTIVE Communication Environment: Object-Oriented Network Programming Components for Developing Client/Server Applications, </title> <booktitle> in Proceedings of the 12 th Annual Sun Users Group Conference, </booktitle> <address> (San Fran-cisco, CA), </address> <pages> pp. 214225, </pages> <address> SUG, </address> <month> June </month> <year> 1994. </year>
Reference-contexts: The following example illustrates the interface and implementation of a map manager component in the general ACE toolkit <ref> [32] </ref>. This component is typically used in a network server to map external identifiers (such as port numbers or connection ids) onto internal identifiers (such as pointers to queues where messages are stored when outgo ing links to a satellite become flow controlled).
Reference: [33] <author> UNIX Software Operations, </author> <title> UNIX System V Release 4 Programmer's Guide: STREAMS. </title> <publisher> Prentice Hall, </publisher> <year> 1990. </year>
Reference-contexts: Message Queue is modeled after the message queueing and buffer management facilities provided by System V STREAMS <ref> [33] </ref> and BSD UNIX [34]. An ACE Message Queue is composed of one or more Message Blocks that are linked together by prev and next pointers. In addition, a Message Block may also be linked to a chain of other Message Blocks.
Reference: [34] <author> W. R. Stevens, </author> <title> TCP/IP Illustrated, </title> <booktitle> Volume 2. </booktitle> <address> Reading, Mas-sachusetts: </address> <publisher> Addison Wesley, </publisher> <year> 1993. </year>
Reference-contexts: Message Queue is modeled after the message queueing and buffer management facilities provided by System V STREAMS [33] and BSD UNIX <ref> [34] </ref>. An ACE Message Queue is composed of one or more Message Blocks that are linked together by prev and next pointers. In addition, a Message Block may also be linked to a chain of other Message Blocks.
Reference: [35] <author> D. C. Schmidt, T. H. Harrison, and E. Al-Shaer, </author> <title> Object-Oriented Components for High-speed Network Programming, </title> <booktitle> in Proceedings of the 1 st Conference on Object-Oriented Technologies and Systems, </booktitle> <address> (Monterey, CA), </address> <publisher> USENIX, </publisher> <month> June </month> <year> 1995. </year> <month> 31 </month>
Reference-contexts: Each client request to the server is run in parallel. This ex ample illustrates the use of the Thread Manager and the Thread Control classes. In addition, it also illustrates the use of the ACE C++ wrapper classes for sockets <ref> [35] </ref>. The code shown below is intentionally simplified for this example and does not represent how a highly robust and ef ficient implementation would be developed. For example, a production implementation would place an upper-bound on the number of spawned bound threads to avoid consuming large amounts of kernel resources.
References-found: 35

