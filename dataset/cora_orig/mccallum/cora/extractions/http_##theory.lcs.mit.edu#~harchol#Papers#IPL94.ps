URL: http://theory.lcs.mit.edu/~harchol/Papers/IPL94.ps
Refering-URL: http://theory.lcs.mit.edu/~harchol/Papers/papers.html
Root-URL: 
Title: Tight Bounds on Expected Time to Add Correctly and Add Mostly Correctly log n) time,
Author: Peter Gemmell Mor Harchol 
Note: 2 log n O(  
Date: October 7, 1993  
Abstract: We consider the problem of adding two n-bit numbers which are chosen independently and uniformly at random where the adder is a circuit of AND, OR, and NOT gates of fan-in two. The fastest currently known worst-case adder has running time log n + O( p We first present a circuit which adds at least 1 * fraction of pairs of numbers correctly and has running time log log ( n * ) + O( log log ( n We then prove that this running time is optimal. Next we present a circuit which always produces the correct answer. We show this circuit adds two n-bit numbers from the uniform distribution in expected 1 We prove that this expected running time is optimal. fl Computer Science Division, UC Berkeley, CA 94720. Supported by NSF grant number CCR-9201092. y Computer Science Division, UC Berkeley, CA 94720. Supported by National Physical Science Consortium (NPSC) Fellowship. Also supported by NSF grant number CCR-9201092 0 
Abstract-found: 1
Intro-found: 1
Reference: [Blum] <author> M. Blum. </author> <title> Designing Programs to Check their Work. </title> <note> Submitted to the CACM for publication. </note>
Reference-contexts: refer to a propagate pair we mean a pair of bits (a i ; b i ) such that either a i = 1 and b i = 0, or a i = 0 and b i = 1. 1 Note that our Checker is not a checker in the <ref> [Blum] </ref>, [Blum,Kannan] sense, but really operates more like a mask for certain "problem inputs". (See Section 4.1). 1 Theorem 2 For all * &gt; 0, there exists a Near Adder that has depth log log ( n * )+O ( log log ( n and that is correct on all but <p> the Fast Adder such that the running time of the Checker is low, and such that the probability of error in the Near Adder is very low. 4.1 The Design of a Checker for our Near Adder Our Checker is very different from the class of checkers described in [Blum,Kannan], <ref> [Blum] </ref>. It merely checks if the input is of a particular nice form, and it's output does not depend on the Near Adder's result at all. The Checker will always output FAIL if the input is of a form that will cause the Near Adder to add incorrectly.
Reference: [Blum,Kannan] <author> M. Blum, S. Kannan. </author> <title> Unbounded Programs that Check their Work. </title> <booktitle> 21st Symposium on the Theory of Computation, </booktitle> <address> Seattle, </address> <year> 1989. </year>
Reference-contexts: to a propagate pair we mean a pair of bits (a i ; b i ) such that either a i = 1 and b i = 0, or a i = 0 and b i = 1. 1 Note that our Checker is not a checker in the [Blum], <ref> [Blum,Kannan] </ref> sense, but really operates more like a mask for certain "problem inputs". (See Section 4.1). 1 Theorem 2 For all * &gt; 0, there exists a Near Adder that has depth log log ( n * )+O ( log log ( n and that is correct on all but * <p> in the Fast Adder such that the running time of the Checker is low, and such that the probability of error in the Near Adder is very low. 4.1 The Design of a Checker for our Near Adder Our Checker is very different from the class of checkers described in <ref> [Blum,Kannan] </ref>, [Blum]. It merely checks if the input is of a particular nice form, and it's output does not depend on the Near Adder's result at all. The Checker will always output FAIL if the input is of a form that will cause the Near Adder to add incorrectly.

References-found: 2

