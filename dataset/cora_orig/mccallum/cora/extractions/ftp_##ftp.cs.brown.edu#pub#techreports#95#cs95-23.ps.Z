URL: ftp://ftp.cs.brown.edu/pub/techreports/95/cs95-23.ps.Z
Refering-URL: http://www.cs.brown.edu/publications/techreports/reports/CS-95-23.html
Root-URL: http://www.cs.brown.edu/
Abstract-found: 0
Intro-found: 1
Reference: [1] <institution> Atria Software, Inc., ClearCase Architecture and Database, Atria Software, Inc., Massachusetts, USA, </institution> <month> August </month> <year> 1993. </year>
Reference-contexts: Early version control systems like SCCS [20] and RCS [24] handle the versions of files only. CVS [3] enhances RCS by letting programmers handle versions of directories. DSEE [14] allows version selection in terms of threads that refers to files or other threads. ClearCase <ref> [1] </ref> enhances the functionality of DSEE and runs on several platforms without special supports from the underlying operating system. Version control in terms of objects is studied in the area of software development environments as well as in the area of computer aided design (CAD). <p> CaseWare [6] stores the information about how to build a particular type of object on the object type definition itself, and places the build context information on objects. But the compositions of configurations are still described by separate collections called assemblies. In Ada <ref> [1] </ref>, since packages and subprograms are units of source code as well as units for compilation, the gap between handling system building and managing source code is smaller than in other languages.
Reference: [2] <author> J. G. P. Barnes, </author> <title> An Overview of Ada, </title> <journal> in Software Practice and Experience, </journal> <volume> vol. 10, </volume> <pages> pp. 851-887, </pages> <year> 1980. </year>
Reference: [3] <author> Brian Berliner, CVS II: </author> <title> Parallelizing Software 11 Development, </title> <publisher> Prisma, Inc., </publisher> <address> 5465 Mark Dabling Blvd, Colorado Springs, CO 80918. </address>
Reference-contexts: The parameters for system building are stored on software units instead of passed as arguments to functions. Early version control systems like SCCS [20] and RCS [24] handle the versions of files only. CVS <ref> [3] </ref> enhances RCS by letting programmers handle versions of directories. DSEE [14] allows version selection in terms of threads that refers to files or other threads. ClearCase [1] enhances the functionality of DSEE and runs on several platforms without special supports from the underlying operating system.
Reference: [4] <author> Gerard Boudier, Ferdinando Gallo, Regis Minot, and Ian Thomas, </author> <title> An Overview of PCTE and PCTE+, </title> <booktitle> in Proceedings of the ACM SIGSOFT/SIGPLAN Software Engineering Symposium on Practical Software Development Environments, </booktitle> <publisher> (Peter Hend-erson, ed.), </publisher> <pages> pp. 248-257, </pages> <month> November </month> <year> 1988. </year> <booktitle> Published as ACM SIGSOFT Software Engineering Notes, </booktitle> <volume> Vol 13, No 5, </volume> <month> November </month> <year> 1988, </year> <journal> and ACM SIGPLAN Notices, </journal> <volume> Vol 24, No 2, </volume> <month> February </month> <year> 1989. </year>
Reference-contexts: Version control in terms of objects is studied in the area of software development environments as well as in the area of computer aided design (CAD). Zdonik describes an object-oriented database system that includes a built-in version control mechanism [25]. PCTE+ <ref> [4] </ref> supports operations to manage versions of composite objects. Katz surveyed version modeling in engineering databases, and proposed a unified framework [12]. Several other systems also aim to free programmers from the management of derived objects. Cedar [23] and DSEE [14] use source oriented system models.
Reference: [5] <author> John N. Buxton and larry E. Druffel, </author> <title> Requirements for An Ada Programming Support Environment: Rationale for STONEMAN, </title> <booktitle> in Proceedings of COMPSAC 80, </booktitle> <pages> pp. 66-72, </pages> <year> 1980. </year>
Reference-contexts: Besides, an Ada environment is responsible to decide which units need to be re-compiled based on the logical relations between them <ref> [5] </ref>. However, Ada organizes compiled packages in libraries, which have at structures and thus cannot directly capture the relationship between packages and subprograms. Ada also needs additional mechanisms to handle a mapping between versions of libraries and their elements. CMVC [18] presented one of such mechanisms.
Reference: [6] <author> Martin R. Cagan, </author> <title> Software Configuration Management Redefined, </title> <publisher> CaseWare, Inc., </publisher> <address> 108 Pacifica, Irv-ine, CA 92718, </address> <month> March </month> <year> 1992. </year>
Reference-contexts: VESTA hides the management of derived objects by passing them as the results of building functions. Most existing configuration management systems use separate documents to describe the system building process. CaseWare <ref> [6] </ref> stores the information about how to build a particular type of object on the object type definition itself, and places the build context information on objects. But the compositions of configurations are still described by separate collections called assemblies.
Reference: [7] <author> W. Courington, </author> <title> The Network Software Environment, </title> <type> Technical Report Sun FE197-0, </type> <institution> Sun Micro-systems Inc., </institution> <month> February </month> <year> 1989. </year>
Reference: [8] <author> Jacky Estublier, </author> <title> A Configuration Manager: The Adele data base of programs, </title> <booktitle> in Workshop on software engineering environments for programming-in-the-large, </booktitle> <month> June </month> <year> 1985 </year>
Reference-contexts: Ada also needs additional mechanisms to handle a mapping between versions of libraries and their elements. CMVC [18] presented one of such mechanisms. Gandalf [11] uses a module concept where a set of versions implement a single interface. Adele <ref> [8] </ref> extends this model so that interfaces themselves may have versions. It also describes the relation between interfaces and implementations as an AND/OR graph. Compared with our framework, Adele is more exible to handle variants of versions, but it is also more complicated.
Reference: [9] <author> Stuart I. Feldman, </author> <title> Make - a Program for Maintaining Computer Programs, </title> <journal> in Software Practice & Experience, </journal> <volume> 9(4), </volume> <pages> pp. 255-265, </pages> <month> April </month> <year> 1979. </year>
Reference-contexts: The major problem with handling system building in terms of files is that the dependencies between files seldom match the decomposition structures of functions and classes. Understanding and maintaining the mapping between these two structures is usually difficult and tedious. Since MAKE <ref> [9] </ref> and its descendents are the most popular system building tools in existing environments, let us take it as an example. <p> Considering the rich functionality POEM supplies, the implementation is rather easy. This is possible because our model is rather simple, and because we utilize many existing tools. 6. Related Work MAKE <ref> [9] </ref> is the most commonly used system building tool, but it has rather weak support for the mod-ulization of makefiles. There is no formal channel of communication between makefiles.
Reference: [10] <author> Ferdinando Gallo, Regis Minot, and Ian Thomas, </author> <title> The Object Management System of PCTE as a Software Engineering Database Management System, </title> <booktitle> in Proceedings of the ACM SIGSOFT/SIG-PLAN Software Engineering Symposium on Practical Software Development Environments, </booktitle> <editor> (Peter Henderson, </editor> <publisher> ed.), </publisher> <pages> pp. 12-15, </pages> <month> December </month> <year> 1986. </year>
Reference: [11] <author> A. Nico Habermann and David Notkin, </author> <title> Gandalf: Software Development Environments, </title> <journal> in IEEE Transactions on Software Engineering, </journal> <volume> Vol 12, No 12, pp.1117-1127, </volume> <month> December </month> <year> 1986. </year>
Reference-contexts: However, Ada organizes compiled packages in libraries, which have at structures and thus cannot directly capture the relationship between packages and subprograms. Ada also needs additional mechanisms to handle a mapping between versions of libraries and their elements. CMVC [18] presented one of such mechanisms. Gandalf <ref> [11] </ref> uses a module concept where a set of versions implement a single interface. Adele [8] extends this model so that interfaces themselves may have versions. It also describes the relation between interfaces and implementations as an AND/OR graph.
Reference: [12] <author> Randy H. Katz, </author> <title> Toward a Unified Framework for Version Modeling in Engineering Databases, </title> <journal> ACM Computing Surveys, </journal> <volume> Vol 22, No 4, </volume> <pages> pp. 375-408, </pages> <month> December </month> <year> 1990. </year>
Reference-contexts: Zdonik describes an object-oriented database system that includes a built-in version control mechanism [25]. PCTE+ [4] supports operations to manage versions of composite objects. Katz surveyed version modeling in engineering databases, and proposed a unified framework <ref> [12] </ref>. Several other systems also aim to free programmers from the management of derived objects. Cedar [23] and DSEE [14] use source oriented system models. Derived objects are not directly managed by programmers, but programmers still have to address them indirectly by some functions.
Reference: [13] <author> Charles Lamb, Gordon Landis, Jack Orenstein, and Dan Weinred, </author> <title> The ObjectStore Database System, </title> <journal> in Communications of the ACM, </journal> <volume> Vol. 34, No. 10, </volume> <pages> pp. 50-63, </pages> <month> October </month> <year> 1991. </year>
Reference-contexts: Implementation As illustrated in Figure 10, the architecture of POEM is composed of a user interface layer and an object layer on top of the file system. The object layer is where the software units are stored. Currently we are using an object-oriented database system called Object-Store <ref> [13] </ref> to implement this layer. ObjectStore is basically an extension of the C++ language that supports persistent objects. It allows multiple clients to work on the same database simultaneously in a distributed environment, and it supports transaction facilities to serialize the operations on objects.
Reference: [14] <author> David B. Leblang and Robert P. Chase, Jr., </author> <title> Computer-Aided Software Engineering in a Distributed Workstation Environment, </title> <journal> in SIGPLAN Notices, </journal> <volume> vol. 19, No. 5, </volume> <pages> pp. 104-113, </pages> <month> April </month> <year> 1984. </year>
Reference-contexts: An advantage of using workareas instead of work-spaces is that we can handle the sharing of software artifacts between programmers more naturally. If two programmers use the same version of a subsystem, then they will automatically shared all the source objects and derived objects of that subsystem. In DSEE <ref> [14] </ref> and SHAPE [17], the sharing of derived objects is handled by more complicated mechanisms. Different kinds of software units need different data attributes and different implementation of their operations. For example, some software units used in a C program may contain YACC code instead of plain C code. <p> The parameters for system building are stored on software units instead of passed as arguments to functions. Early version control systems like SCCS [20] and RCS [24] handle the versions of files only. CVS [3] enhances RCS by letting programmers handle versions of directories. DSEE <ref> [14] </ref> allows version selection in terms of threads that refers to files or other threads. ClearCase [1] enhances the functionality of DSEE and runs on several platforms without special supports from the underlying operating system. <p> PCTE+ [4] supports operations to manage versions of composite objects. Katz surveyed version modeling in engineering databases, and proposed a unified framework [12]. Several other systems also aim to free programmers from the management of derived objects. Cedar [23] and DSEE <ref> [14] </ref> use source oriented system models. Derived objects are not directly managed by programmers, but programmers still have to address them indirectly by some functions. VESTA hides the management of derived objects by passing them as the results of building functions.
Reference: [15] <author> Roy Levin and Paul R. McJones, </author> <title> The Vesta Approach to Precise Configuration of Large Software Systems, </title> <note> DEC System Research Center Research Report No. 105, </note> <month> June </month> <year> 1993. </year>
Reference-contexts: There is no formal channel of communication between makefiles. If we want to use multiple makefiles in a large project, then the passing of arguments has to rely on implicit protocols. The lack of formal arguments also makes the reuse of makefiles more difficult. The VESTA configuration management system <ref> [15] </ref> aims to solve these problems by the moduli-zation and parameterization of system models. It uses a functional language to describe system models, and emphasizes the modulization and parameterization of system models.
Reference: [16] <author> Yi-Jing Lin and Steven P. Reiss, </author> <title> Configuration Management in terms of Modules, </title> <booktitle> in Proceedings of the Fifth International Workshop on Software Configuration Management, </booktitle> <month> April </month> <year> 1995. </year>
Reference-contexts: We have to know the internal structure of a function or a class when we are handling its versions and configurations. 3. Configuration Management in POEM To solve the problems listed in the previous section, we are developing a programming environment called POEM (Programmable Object-centered EnvironMent) <ref> [16] </ref>. POEM manage system building and version control directly in terms of the functions and classes in the source code.
Reference: [17] <author> Axel Mahler and Andreas Lampen, </author> <title> An Integrated Toolset for Engineering Software Configurations, </title> <booktitle> in Proceedings of the ACM SIGSOFT/SIGPLAN Software Engineering Symposium on Practical Software Development Environments, </booktitle> <publisher> (Peter Hend-erson, ed.), </publisher> <pages> pp. 191-200, </pages> <month> November </month> <year> 1988. </year> <booktitle> Published as ACM SIGSOFT Software Engineering Notes, </booktitle> <volume> Vol 13, No 5, </volume> <month> November </month> <year> 1988, </year> <journal> and ACM SIGPLAN Notices, </journal> <volume> Vol 24, No 2, </volume> <month> February </month> <year> 1989. </year>
Reference-contexts: If two programmers use the same version of a subsystem, then they will automatically shared all the source objects and derived objects of that subsystem. In DSEE [14] and SHAPE <ref> [17] </ref>, the sharing of derived objects is handled by more complicated mechanisms. Different kinds of software units need different data attributes and different implementation of their operations. For example, some software units used in a C program may contain YACC code instead of plain C code.
Reference: [18] <author> Thomas M. Morgan, </author> <title> Configuration Management and Version Control in the Rational Programming Environment, </title> <booktitle> in Ada in Industry - Proceedings of the Ada-Europe International Conference, </booktitle> <pages> pp. 17-28, </pages> <month> June, </month> <year> 1988. </year>
Reference-contexts: However, Ada organizes compiled packages in libraries, which have at structures and thus cannot directly capture the relationship between packages and subprograms. Ada also needs additional mechanisms to handle a mapping between versions of libraries and their elements. CMVC <ref> [18] </ref> presented one of such mechanisms. Gandalf [11] uses a module concept where a set of versions implement a single interface. Adele [8] extends this model so that interfaces themselves may have versions. It also describes the relation between interfaces and implementations as an AND/OR graph.
Reference: [19] <author> Leon Osterweil, </author> <title> Software Process are Software Too, </title> <booktitle> in Proceedings of the 9th International Conference on Software Engineering, </booktitle> <pages> pp. 2-13, </pages> <address> Monterey CA, </address> <month> March-April </month> <year> 1987. </year>
Reference-contexts: Second, our approach applies the principles of modulization and encapsulation to configuration management. It is well known that modulization and encapsulation are very useful in managing source programs. Similarly, they can help greatly in handling configuration management. As pointed out by Osterweil <ref> [19] </ref>, software processes can be considered as special programs that are enacted by both human and computers. The data used by these special programs are software artifacts like source code, derived objects, system models, documentation, version history files, etc.
Reference: [20] <author> Marc J. Rochkind, </author> <title> The Source Code Control System, </title> <journal> in IEEE Transactions on Software Engineering, pp. </journal> <volume> 364-370, Vol 1 No 4, </volume> <month> December </month> <year> 1975. </year>
Reference-contexts: Our framework shares the same goals with VESTA in system building, but uses an object-oriented approach instead of a functional approach. The parameters for system building are stored on software units instead of passed as arguments to functions. Early version control systems like SCCS <ref> [20] </ref> and RCS [24] handle the versions of files only. CVS [3] enhances RCS by letting programmers handle versions of directories. DSEE [14] allows version selection in terms of threads that refers to files or other threads.
Reference: [21] <author> James Rumbaugh, </author> <title> Controlling Propagation of Operations using Attributes on Relations, </title> <booktitle> ACM OOPSLA 88 Proceedings, </booktitle> <pages> pp. 285-296, </pages> <month> September </month> <year> 1988. </year>
Reference-contexts: Adele [8] extends this model so that interfaces themselves may have versions. It also describes the relation between interfaces and implementations as an AND/OR graph. Compared with our framework, Adele is more exible to handle variants of versions, but it is also more complicated. Rumbaugh <ref> [21] </ref> proposed a framework to control the propagation of operations between objects. The propagation policy is based on attributes associated with relations. Our framework also relies on the propagation of operations to handle composite objects.
Reference: [22] <author> SunPro, </author> <title> SPARCworks/TeamWare Solution Guide, Sun Microsystems, </title> <publisher> Inc., </publisher> <address> California, USA, </address> <year> 1994. </year>
Reference: [23] <author> Warren Teitelman, </author> <title> A tour through Cedar, </title> <booktitle> in IEEE Software, </booktitle> <pages> pp. 44-73, </pages> <month> Apr </month> <year> 1984. </year>
Reference-contexts: PCTE+ [4] supports operations to manage versions of composite objects. Katz surveyed version modeling in engineering databases, and proposed a unified framework [12]. Several other systems also aim to free programmers from the management of derived objects. Cedar <ref> [23] </ref> and DSEE [14] use source oriented system models. Derived objects are not directly managed by programmers, but programmers still have to address them indirectly by some functions. VESTA hides the management of derived objects by passing them as the results of building functions.
Reference: [24] <author> Walter F. Tichy, </author> <title> RCS - A System for Version Control, </title> <journal> in Software Practice & Experience, </journal> <volume> Vol. 15, No. 7, </volume> <pages> pp. 637-654, </pages> <month> July </month> <year> 1985. </year>
Reference-contexts: If we click on a fixed software unit, POEM will bring up its interface, implementation, and documentation in the editors. Other software units can also use a fixed software unit by pointing links to it. There is no need for check-in or check-out operations. POEM internally use RCS <ref> [24] </ref> to save space on fixed software units, but most of those actions are hidden from users. POEM allows multiple versions of a software unit to reside in the same workarea. There is no need to create a separate directory or workspace for each version of a project. <p> Our framework shares the same goals with VESTA in system building, but uses an object-oriented approach instead of a functional approach. The parameters for system building are stored on software units instead of passed as arguments to functions. Early version control systems like SCCS [20] and RCS <ref> [24] </ref> handle the versions of files only. CVS [3] enhances RCS by letting programmers handle versions of directories. DSEE [14] allows version selection in terms of threads that refers to files or other threads.
Reference: [25] <author> Stanley B. Zdonik, </author> <title> Version Management in an Object-Oriented database, in Advanced Programming Environments, </title> <editor> (R. Conradi, T. M. Didriksen, and D. H. Wanvik, </editor> <publisher> ed.), </publisher> <pages> pp. 405-422, </pages> <year> 1986. </year>
Reference-contexts: Version control in terms of objects is studied in the area of software development environments as well as in the area of computer aided design (CAD). Zdonik describes an object-oriented database system that includes a built-in version control mechanism <ref> [25] </ref>. PCTE+ [4] supports operations to manage versions of composite objects. Katz surveyed version modeling in engineering databases, and proposed a unified framework [12]. Several other systems also aim to free programmers from the management of derived objects. Cedar [23] and DSEE [14] use source oriented system models.
References-found: 25

