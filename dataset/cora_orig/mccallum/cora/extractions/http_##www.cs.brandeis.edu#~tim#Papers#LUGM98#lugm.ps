URL: http://www.cs.brandeis.edu/~tim/Papers/LUGM98/lugm.ps
Refering-URL: http://www.cs.brandeis.edu/~tim/Papers/LUGM98/
Root-URL: http://www.cs.brandeis.edu
Title: LISP a Language for Internet Scripting and Programming  
Author: Timothy J. Hickey Peter Norvig Kenneth R. Anderson 
Abstract: In this paper we argue that LISP can provide a powerful tool for web programmers, at both the novice and expert level, and that LISP has the potential to become a language of choice for writing both client-side and server-side internet programs. The syntactic and semantic simplicity of LISP enables non-experts to quickly master a basic level of LISP programming. Its higher order functions enable the implementation of a simple and elegant LISP interface to Java methods, fields, and constructors. With this interface, LISP provides full and simple access to the versatile and omnipresent Java class libraries. The conciseness of some dialects of LISP (e.g., Scheme) makes it relatively easy to implement compact LISP interpreters in Java and LISP-to-Java compilers. LISP can then be called from Java programs and Java-enabled browsers. The declarative nature of LISP allows one to design and implement simple, declarative interfaces to the Java class libraries, which allow one to create applets and client-server software which is much more concise and comprehensible than the same programs written in imperative languages such as Java or Javascript (for applet programming) or Java, Perl, C++, or C for client-server programs. Two additional fertile applications for LISP on the internet are debugging and scripting of Java code. In this paper, we provide small examples of all of these applications, describe our LISP implementation (SILK Scheme In 50 KB), and ponder the future of LISP as a language for internet scripting and programming. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Kent Beck and Erich Gamma, Test-infected: </author> <title> Programmers love writing tests, </title> <booktitle> Java Report, </booktitle> <volume> Vol 3, No. 7, p.51 - 56, </volume> <year> 1998. </year> <note> http://members.pingnet.ch/gamma/junit-10.zip </note>
Reference-contexts: Typically such test code is not interactive. An interactive test loop can require a significant amount of code that can be unique for each class. While a testing tool, such as JUnit <ref> [1] </ref> may make writing test cases easier, it may not be interactive enough to fully diagnose a problem. Below we give an example of a session in which the user has tested some of the methods and constructors from a Java program.
Reference: [2] <author> Per Bothner, </author> <title> Kawa, the Java-based Scheme System http://www.cygnus.com/ bothner/kawa.html </title>
Reference: [3] <author> Tim Hickey (Project Leader) JLIB: </author> <title> A Declarative GUI-building library for SILK http://www.cs.brandeis.edu/ tim/Packages/jlib/jlib.html </title>
Reference-contexts: We have selected Scheme as the LISP dialect, primarily due to its simplicity and its small size (which translates into short download time for a Scheme interpreter), and we have developed a web-based dialect of Scheme, called SILK [8]; and a declarative interface to the Java libraries, called JLIB <ref> [3] </ref>. 1.1 Design Goals To gain wide acceptance, the entire process of creating applets in LISP, debugging them, and adding them to a web page must be as simple as possible and must, in addition, result in applets that are at least as fast as Java applets. 1. Easy access.
Reference: [4] <institution> Aubrey Jaffer R4RS Scheme test ftp://ftp-swiss.ai.mit.edu/pub/scm/r4rstest.scm </institution>
Reference-contexts: SILK expanded to about 50KB of Java code over the next few months as it was extended to pass all of the tests in Aubrey Jaffer's online r4rstest.scm test suite <ref> [4] </ref> which tests Scheme compliance with the R4RS standard. The class structure for SILK 1.0 is shown in Figure 3. The SchemeUtils class contains the basic LISP procedures (e.g., car, cdr, cons) as static methods.
Reference: [5] <editor> Richard Kelsey, William Clinger, and Jonathan Rees (Editors). </editor> <title> Revised(5) Report on the Algorithmic Language Scheme. </title> <note> 1998. www.math.grin.edu/courses/Scheme/r5rs-html/r5rs toc.html </note>
Reference-contexts: The Scheme primitives are stored in their own class so that it would be easy to switch from R4RS to R5RS <ref> [5] </ref> Scheme primitives. Once these class design issues are out of the way, the rest is pretty easy. In order to build a Scheme interpreter, you basically need six things: 1. Read and write. The reader goes in the InputPort class.
Reference: [6] <author> Richard A. Kelsey, and Jonathan A. Rees, </author> <title> A Tractable Scheme Implementation, </title> <journal> Lisp and Symbolic Computation, </journal> <volume> 7, 4, </volume> <pages> p. 315-336, </pages> <year> 1994. </year>
Reference-contexts: These facts have lead to many Scheme implementations with a broad range of sizes and performance characteristics. For example, Kelsey and Rees found seven Scheme implementations all less than 14,000 lines, and 3 implementations that ranged from 25,000 to 120,000 lines <ref> [6] </ref> Each language that Scheme is implemented in provides both opportunities and chal-langes. For example, when implementing Scheme in C, one must work hard to provide garbage collection and tail recursion. (call-with-current-continuation) is often the hardest thing to implement in any base language.
Reference: [7] <institution> Peter Norvig Paradigms of Artificial Intelligence Programming: Case Studies in Common Lisp Morgan Kaufmann, </institution> <year> 1992. </year>
Reference-contexts: The class Scheme is the interpreter class and it has been designed so that one could easily swap several interpreters in; perhaps a simple SchemeUtils Scheme Environment Pair InputPort Procedure Primitive JavaConstructor JavaMethod Continuation Closure Macro interpreter, a tail-recursive interpreter, and an interpreter that supports full call/cc, as in PAIP <ref> [7] </ref>. The Scheme primitives are stored in their own class so that it would be easy to switch from R4RS to R5RS [5] Scheme primitives. Once these class design issues are out of the way, the rest is pretty easy.
Reference: [8] <author> Peter Norvig (Project Leader) SILK: </author> <title> Scheme in Fifty K http://www.norvig.com/SILK </title>
Reference-contexts: We have selected Scheme as the LISP dialect, primarily due to its simplicity and its small size (which translates into short download time for a Scheme interpreter), and we have developed a web-based dialect of Scheme, called SILK <ref> [8] </ref>; and a declarative interface to the Java libraries, called JLIB [3]. 1.1 Design Goals To gain wide acceptance, the entire process of creating applets in LISP, debugging them, and adding them to a web page must be as simple as possible and must, in addition, result in applets that are
Reference: [9] <author> Michael Travers Skij, </author> <note> IBM alphaWorks archive http://www.alphaworks.ibm.com/formula/Skij </note>
Reference: [10] <author> Christian Queinnec JaJa: </author> <title> Scheme in Java http://www-spi.lip6.fr/ queinnec/WWW/Jaja.html </title>
Reference: [11] <editor> Christian Queinnec Lisp in Small Pieces, </editor> <address> Cambridge University, Cambridge, </address> <year> 1996. </year>
References-found: 11

