URL: ftp://ftp.cs.toronto.edu/pub/bonner/papers/hypotheticals/jlp96a.ps
Refering-URL: http://www.cs.toronto.edu/~bonner/papers.html
Root-URL: http://www.cs.toronto.edu
Email: Email: bonner@db.toronto.edu  
Title: A LOGICAL SEMANTICS FOR HYPOTHETICAL RULEBASES WITH DELETION  
Author: ANTHONY J. BONNER 
Address: Ontario, Canada M5S 3G4.  655 Avenue of the Americas, New York, NY 10010  
Affiliation: University of Toronto, Department of Computer Science, Toronto,  
Date: 1997, 32(2):119-170 119  
Note: J. LOGIC PROGRAMMING  Address correspondence to  THE JOURNAL OF LOGIC PROGRAMMING c Elsevier Science Inc., 1997  
Abstract: This paper addresses a limitationof most deductive database systems: they cannot reason hypothetically. Although they reason effectively about the world as it is, they are poor at tasks such as planning and design, where one must explore the consequences of hypothetical actions and possibilities. To address this limitation, we have developed a logic-programming language in which users can create hypotheses and draw inferences from them. Most previous work in this area has focussed on the hypothetical insertion of facts into a database, since insertion is accounted for by a well-established logic: intuitionistic logic. In contrast, our language includes hypothetical deletion as well as insertion. In earlier work, we established the data complexity and expressibility of this language. In this paper, we develop its logical semantics, and take a closer look at its expressibility. The paper makes three main contributions. First, we show that hypothetical queries lead naturally to a new notion of expressibility. In this new light, we show that classical logic is poor at hypothetical reasoning, since it cannot express some simple hypothetical queries. Second, we develop a logical semantics for hypothetical insertions and deletions, including a proof theory, model theory, and fixpoint theory. We also give numerous examples showing the utility of the logic and the subtle effect that deletion has on its expressive power. Finally, we augment the logic with negation-as-failure, so that non-monotonic queries can be expressed. We then develop the proof theory and model theory for the logic with negation. The proof theory is inspired by the stratified semantics of Apt, Blair and Walker, and the model theory is inspired by the perfect model semantics of Przymusinski. / 
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> S. Abiteboul and V. Vianu. </author> <title> Procedural languages for database queries and updates. </title> <journal> Journal of Computer and System Sciences (JCSS), </journal> <volume> 41 </volume> <pages> 181-229, </pages> <year> 1990. </year> <month> 168 </month>
Reference-contexts: The expressibility of a query language is therefore the set of mappings that the language represents. Many expressibility results based on this idea have appeared in the literature <ref> [3, 21, 22, 40, 2, 1, 39] </ref>, and we have established numerous results of this kind using Hypothetical Datalog as a query language [10, 9, 7, 18, 11, 12]. However, hypothetical queries lead naturally to a generalized notion of expressibility, one that is appropriate for deductive databases and rule-based systems. <p> In this sense, our work is orthogonal to work on the logical semantics of elementary updates. This idea has been adopted in the development of Transaction Logic [14, 13, 16, 15]. The second class of work includes <ref> [2, 1, 24, 23, 54] </ref>. Like Hypothetical Datalog, these systems are primarily concerned with relational databases, and with combining elementary updates into complex updates. However, these systems deal with committed updates, not with hypothetical queries.
Reference: 2. <author> S. Abiteboul and V. Vianu. </author> <title> Datalog extensions for database queries and updates. </title> <journal> Journal of Computer and System Sciences (JCSS), </journal> <volume> 43 </volume> <pages> 62-124, </pages> <year> 1991. </year>
Reference-contexts: The expressibility of a query language is therefore the set of mappings that the language represents. Many expressibility results based on this idea have appeared in the literature <ref> [3, 21, 22, 40, 2, 1, 39] </ref>, and we have established numerous results of this kind using Hypothetical Datalog as a query language [10, 9, 7, 18, 11, 12]. However, hypothetical queries lead naturally to a generalized notion of expressibility, one that is appropriate for deductive databases and rule-based systems. <p> In this sense, our work is orthogonal to work on the logical semantics of elementary updates. This idea has been adopted in the development of Transaction Logic [14, 13, 16, 15]. The second class of work includes <ref> [2, 1, 24, 23, 54] </ref>. Like Hypothetical Datalog, these systems are primarily concerned with relational databases, and with combining elementary updates into complex updates. However, these systems deal with committed updates, not with hypothetical queries. <p> The result is that although these systems have an operational semantics, they typically lack a model theory and a logical inference system. Other differences are reflected in the semantics of negation and in computational complexity. For instance, languages presented in <ref> [2] </ref> have an inflationary semantics and a PSPACE complexity, whereas Hypothetical Datalog has a perfect-model semantics and an EXPTIME complexity. The third class of work is perhaps the most similar to our own. However, it is concerned exclusively with hypothetical insertion.
Reference: 3. <author> A.V. Aho and J.D. Ullman. </author> <title> Universality of Data Retrieval Languages. </title> <booktitle> In Proceedings of the ACM Symposium on the Principles of Programming Languages (POPL), </booktitle> <pages> pages 110-120, </pages> <address> San Antonio, TX, </address> <month> Jan. </month> <year> 1979. </year>
Reference-contexts: The expressibility of a query language is therefore the set of mappings that the language represents. Many expressibility results based on this idea have appeared in the literature <ref> [3, 21, 22, 40, 2, 1, 39] </ref>, and we have established numerous results of this kind using Hypothetical Datalog as a query language [10, 9, 7, 18, 11, 12]. However, hypothetical queries lead naturally to a generalized notion of expressibility, one that is appropriate for deductive databases and rule-based systems.
Reference: 4. <author> K.R. Apt, H.A. Blair, and A. Walker. </author> <title> Towards a Theory of Declarative Knowledge. </title> <editor> In Jack Minker, editor, </editor> <booktitle> Foundations of Deductive Databases and Logic Programming, chapter 2, </booktitle> <pages> pages 89-148. </pages> <publisher> Morgan Kaufmann, </publisher> <year> 1988. </year>
Reference-contexts: To augment our logic with negation-as-failure, we first generalize the notion of stratification from Horn rulebases to hypothetical rulebases. We then develop the proof theory and model theory for the augmented logic. The proof theory is inspired by the stratified semantics of Apt, Blair and Walker <ref> [4] </ref>, and the model theory is inspired by the perfect model semantics of Przymusinski [55]. As is the classical case, we show that every stratified hypothetical rulebase has a single perfect model. <p> Numerous approaches to this problem have been proposed. One approach has been to identify classes of Horn rulebases for which such problems do not arise. Perhaps the best known of these classes is the stratified rulebases <ref> [4] </ref>. These rulebases are layered, and within each layer, a negated premise refers only to rules found in the layers below. In this way, recursion never occurs through a negated premise and the semantics of negation is always well-defined. Another approach has been to allow limited recursion through negation. <p> This section provides these missing pieces. We first generalize the notion of stratification from Horn rulebases to hypothetical rulebases. We then develop the proof theory and model theory for stratified rulebases. The proof theory is based on the stratified semantics of Apt, Blair and Walker <ref> [4] </ref>, and the model theory is based on the perfect model semantics of Przymusinski [55]. By combining and extending these two traditions, we achieve a semantics that does not depend on any finiteness assumptions. <p> A Special Case In the case of stratified Horn rules, the semantics developed above reduce to the semantics of Apt, Blair and Walker <ref> [4] </ref> and of Przymusinski [55]. It is worth noting, however, that these semantics differ from the semantics of Prolog in a special case: for rules of the form A B (X). Because of the possibility of floundering, Prolog gives such rules a special interpretation. <p> In this respect, our semantics treats Horn rules with negation in the same way that classical logic programming does. However, our semantics, like those of <ref> [4] </ref> and [55], differ from the semantics of Prolog in one respect: in Prolog, rules such as A C (Y ) are given a special interpretation. <p> Conceptually, then, the proof-theoretic semantics described in Section 5.2 provides a uniform interpretation of stratified rulebases. In the special case of stratified Horn rulebases, this semantics is equivalent to others in the literature <ref> [4, 55] </ref>. In the very special case of unguarded Horn rules, this semantics can be translated into the semantics of Prolog in a straightforward way. 5.4. Examples With negation-as-failure and hypothetical updates, it is possible to write simple rulebases that solve complex problems, as the examples of this section illustrate. <p> In [17], Bonner and McCarty develop a semantics of stratified intuitionistic rule-bases, including a model theory and a sound-and-complete proof theory. In the special case in which all the rules are Horn, this semantics is equivalent to that of stratified Horn rulebases <ref> [4] </ref>. The present paper extends and simplifies the results in [17] to include hypothetical deletion as well as insertion. Results on the computational complexity and expressibility of this semantics are presented in [10, 9, 7, 18, 11, 12]. <p> Unlike the semantics presented in this paper, these proposals often provide a semantics of finite failure. Thus, in the special case of Horn rulebases, these works provide an alternative to much of the existing work on the semantics of negation <ref> [4, 55, 35, 34, 64] </ref>. One exception is the work of Dung [26], which proposes a stable model semantics for hypothetical insertion. Although no proof theory is presented, Dung's proposal allows arbitrary rulebases, stratified or unstratified.
Reference: 5. <author> K.R. Apt and M.H. Van Emden. </author> <title> Contributions to the Theory of Logic Programming. </title> <journal> Journal of the ACM, </journal> <volume> 29(3) </volume> <pages> 841-862, </pages> <year> 1982. </year>
Reference-contexts: In this case, the inference system of Section 3.1 is classical, and we can appeal to the classical model theory of Horn rules <ref> [5, 63] </ref>. According to this theory, a Horn rulebase R and a database DB have a unique minimal model, or least fixpoint, which we denote lfp (R + DB ). Furthermore R; DB ` B if and only if B 2 lfp (R + DB ). <p> We show that every rulebase has a unique minimal model, which can be constructed in a bottom-up fashion by repeated application of a T operator. The development follows the approach originally introduced by Apt, Van Emden and Kowalski <ref> [63, 5] </ref>, which is now standard in logic programming. First, we define a lattice of structures. Then, we define an operator on this lattice, and show that it is monotonic and continuous. Finally, we invoke the Tarski fixpoint theorem. <p> Proof. Follows immediately from Lemma 4.7. 2 Since T R is a monotonic operator on a complete lattice, the meet of any of its fixpoints is also a fixpoint. This result, which generalizes the model intersection property of Horn clause logic <ref> [63, 5] </ref>, follows immediately by the Tarski fixpoint theorem [62]. As a special case, the meet of all the fixpoints of T R is itself a fixpoint of T R , the least fixpoint. We thus have the following result. 149 Theorem 4.10 Least Fixpoint.
Reference: 6. <author> F. Bancilhon and N. Spyratos. </author> <title> Update semantics of relational views. </title> <journal> ACM Transactions on Database Systems (TODS), </journal> <volume> 6 </volume> <pages> 557-575, </pages> <year> 1981. </year>
Reference-contexts: Update operators act only on the stored data. That is, [add : C] adds the atom C to the stored data, and [del : C] deletes C from the stored data. Since derived data is never updated directly, we avoid the difficult view-update problem <ref> [27, 28, 25, 6, 31, 43] </ref>. Like classical and intuitionistic logics, Hypothetical Datalog does not distinguish between different sorts of predicates, such as base and derived predicates. Of course, predicates can always be divided into sorts, as an option, but it is not imposed by the theory.
Reference: 7. <author> A.J. Bonner. </author> <title> Intuitionistic deductive databases and the polynomial time hierarchy. </title> <note> Submitted for publication. </note>
Reference-contexts: We showed, for instance, that its data complexity is complete for EXPTIME. By augmenting the logic with negation-as-failure, and by considering stratified rulebases, the logic expresses all database queries in EXPTIME [10] in the sense defined by Chandra and Harel [20]. In <ref> [10, 9, 7, 11, 12] </ref>, we extended these results to lower complexity classes|PSPACE, PHIER, P k and NP|for various fragments of the logic. It is interesting that all these complexity classes can be characterized by a single language with a natural series of syntactic restrictions. <p> We discuss these works in greater detail in Section 7. The problems encountered all reflect the difficulty of dealing with recursion through negation. Fortunately, none of our complexity and expressibility results depend on recursion through negation. For instance, in <ref> [10, 9, 7, 18, 12, 11] </ref>, we show that stratified hypothetical rules are expressively complete for many well-known complexity classes. In [9, 7], we show that each stratum can raise the complexity of inference by one level in the polynomial time hierarchy. <p> Fortunately, none of our complexity and expressibility results depend on recursion through negation. For instance, in [10, 9, 7, 18, 12, 11], we show that stratified hypothetical rules are expressively complete for many well-known complexity classes. In <ref> [9, 7] </ref>, we show that each stratum can raise the complexity of inference by one level in the polynomial time hierarchy. <p> Many expressibility results based on this idea have appeared in the literature [3, 21, 22, 40, 2, 1, 39], and we have established numerous results of this kind using Hypothetical Datalog as a query language <ref> [10, 9, 7, 18, 11, 12] </ref>. However, hypothetical queries lead naturally to a generalized notion of expressibility, one that is appropriate for deductive databases and rule-based systems. <p> Example 2.5 shows that classical logic can express some simple hypothetical queries in a rulebase independent way. However, classical logic is poor at expressing more-complex hypothetical queries, as we shall see. To express hypothetical insertions, intuitionistic logic is much more suitable <ref> [12, 18, 7, 11] </ref>. From a logic-programming standpoint, intuitionistic logic can be viewed as an extension of classical logic. It uses the same syntax as classical logic, and is equivalent to classical logic for Horn rulebases and atomic queries. <p> We use it here to avoid similar problems with hypothetical updates. 8 In the examples in this paper, all rulebases in Hypothetical Datalog are guarded or can easily be transformed to be so. The same is true of the rulebases used to prove the complexity and expressibility results in <ref> [10, 9, 7, 18, 11, 12] </ref>. We emphasize, however, that guardedness is a matter of practice, and none of the theory developed in this paper depends on it. <p> This idea is developed in detail in <ref> [10, 7, 12, 9, 18, 11] </ref>. <p> In contrast, adding negation-as-failure to intuitionistic logic is problematic, as pointed out in [32] and [17]. Finally, it is worth pointing out, that like the models of this section, the canonical intuitionistic model developed in <ref> [11, 7] </ref> is essentially a mapping from databases to databases. In a similar fashion, the specialized intuitionistic models developed in [50] and [18] are mappings from rulebases to databases. This section builds upon and extends this tradition. The development here builds especially upon ideas introduced in [10]. <p> This section focuses on stratified rulebases, extending the theory of stratified negation from Horn rules to hypothetical rules. By focussing on stratified rules, we factor out the many problems resulting from recursion through negation. Moreover, stratification is precisely the restriction needed to prove the complexity and expressibility results in <ref> [10, 9, 7, 18, 11, 12] </ref>. <p> This dual role for the predicate MARK is crucial to the example. A similar observation applies to the rulebase encodings of Turing machines used in proving the expressibility results in <ref> [10, 9, 7, 18, 11, 12] </ref>. It does not appear that these rulebases would be handled correctly by Harland's semantics. Note, however, that the rules in Example 5.1 cause no such problems. This suggests that it may 160 be useful to develop distinct semantic theories for distinct species of negation. <p> Both EKS and Dynamic Prolog emphasize committed updates as well as hypothetical updates, while work on Hypothetical Datalog includes a logical semantics for negation-as-failure and an extensive analysis of computational complexity and expressibility <ref> [10, 9, 7, 18, 11, 12] </ref>. Much of the remaining work on logic and updates can be divided into three classes: (i) elementary updates to arbitrary logical theories, (ii) complex updates 166 to relational databases, and (iii) intuitionistic logic programming. We shall look at each class in turn. <p> The present paper extends and simplifies the results in [17] to include hypothetical deletion as well as insertion. Results on the computational complexity and expressibility of this semantics are presented in <ref> [10, 9, 7, 18, 11, 12] </ref>. There have also been proposals for a semantics of non-stratified intuitionistic rules [38, 52, 36, 26]. Following [50], these proposals each define a model as a mapping from a set of logic programs to a set of values. <p> In [38], Harland develops a semantics in which predicates are labeled as "completely defined" or "incompletely defined" [38]. Unfortunately, restrictions on the labeling preclude many stratified programs, such as the rulebase in Example 5.5, and the rulebases used to achieve the expressibility results of <ref> [10, 9, 7, 18, 11, 12] </ref>, as discussed in Section 5.4. The rules in Example 5.1 cause no such problems however. This suggests that it may be useful to develop distinct semantic theories for distinct species of negation. Acknowledgements.
Reference: 8. <author> A.J. Bonner. </author> <title> A Logic for Hypothetical Reasoning. </title> <booktitle> In Proceedings of the Seventh National Conference on Artificial Intelligence, </booktitle> <pages> pages 480-484, </pages> <address> Saint Paul, MN, </address> <month> August 21-26 </month> <year> 1988. </year> <booktitle> American Association for Artificial Intelligence (AAAI). </booktitle>
Reference-contexts: Just as a database query maps relational databases to relations, a rulebase query maps deductive databases to relations. The notion of rulebase queries finds it motivation in expert systems, and is based on a principle that we call rulebase independence. Originally introduced in <ref> [8, 11] </ref>, rulebase independence is a condition that we place on queries to a deductive database. Intuitively, a user should be able to formulate queries without having a detailed knowledge of the rulebase. <p> We are interested in a promising young student, Tomasz, who has taken many courses in mathematics and in physics. We suspect that Tomasz might qualify for a physics degree by taking the senior physics course, 6 A summary of this material appears in <ref> [8] </ref>. 131 phy450, or he might qualify for a math degree by taking the senior math course, math452. We want to know if Tomasz is in one of these two situations. <p> Hypothetical Deletion So far, we have only looked at hypothetical insertion. This was enough to show that classical logic is inadequate for hypothetical reasoning. As mentioned above, intuitionistic logic is the correct way to formalize hypothetical insertion <ref> [32, 47, 50, 8, 18, 12] </ref>. However, even intuitionistic logic does not model hypothetical deletion. In fact, we shall see in this subsection that no reasonable first-order logic can do this. We then consider some alternatives. <p> Section 2 gave numerous examples of rulebase queries expressed in Hypothetical Datalog. In these examples, R may contain both Horn and hypothetical rules. 3.3. Examples This section gives simple examples of hypothetical inference, adapted from [10] and <ref> [8] </ref>. More-complex examples are given in Sections 3.4 and 3.5. The examples all show how to combine simple hypothetical updates into complex hypothetical queries.
Reference: 9. <author> A.J. Bonner. </author> <title> Hypothetical Datalog: Negation and Linear Recursion. </title> <booktitle> In Proceedings of the ACM Symposium on the Principles of Database Systems (PODS), </booktitle> <pages> pages 286-300, </pages> <address> Philadelphia, PA, </address> <month> March 29-31 </month> <year> 1989. </year>
Reference-contexts: We showed, for instance, that its data complexity is complete for EXPTIME. By augmenting the logic with negation-as-failure, and by considering stratified rulebases, the logic expresses all database queries in EXPTIME [10] in the sense defined by Chandra and Harel [20]. In <ref> [10, 9, 7, 11, 12] </ref>, we extended these results to lower complexity classes|PSPACE, PHIER, P k and NP|for various fragments of the logic. It is interesting that all these complexity classes can be characterized by a single language with a natural series of syntactic restrictions. <p> We discuss these works in greater detail in Section 7. The problems encountered all reflect the difficulty of dealing with recursion through negation. Fortunately, none of our complexity and expressibility results depend on recursion through negation. For instance, in <ref> [10, 9, 7, 18, 12, 11] </ref>, we show that stratified hypothetical rules are expressively complete for many well-known complexity classes. In [9, 7], we show that each stratum can raise the complexity of inference by one level in the polynomial time hierarchy. <p> Fortunately, none of our complexity and expressibility results depend on recursion through negation. For instance, in [10, 9, 7, 18, 12, 11], we show that stratified hypothetical rules are expressively complete for many well-known complexity classes. In <ref> [9, 7] </ref>, we show that each stratum can raise the complexity of inference by one level in the polynomial time hierarchy. <p> Many expressibility results based on this idea have appeared in the literature [3, 21, 22, 40, 2, 1, 39], and we have established numerous results of this kind using Hypothetical Datalog as a query language <ref> [10, 9, 7, 18, 11, 12] </ref>. However, hypothetical queries lead naturally to a generalized notion of expressibility, one that is appropriate for deductive databases and rule-based systems. <p> We use it here to avoid similar problems with hypothetical updates. 8 In the examples in this paper, all rulebases in Hypothetical Datalog are guarded or can easily be transformed to be so. The same is true of the rulebases used to prove the complexity and expressibility results in <ref> [10, 9, 7, 18, 11, 12] </ref>. We emphasize, however, that guardedness is a matter of practice, and none of the theory developed in this paper depends on it. <p> This idea is developed in detail in <ref> [10, 7, 12, 9, 18, 11] </ref>. <p> This section focuses on stratified rulebases, extending the theory of stratified negation from Horn rules to hypothetical rules. By focussing on stratified rules, we factor out the many problems resulting from recursion through negation. Moreover, stratification is precisely the restriction needed to prove the complexity and expressibility results in <ref> [10, 9, 7, 18, 11, 12] </ref>. <p> This dual role for the predicate MARK is crucial to the example. A similar observation applies to the rulebase encodings of Turing machines used in proving the expressibility results in <ref> [10, 9, 7, 18, 11, 12] </ref>. It does not appear that these rulebases would be handled correctly by Harland's semantics. Note, however, that the rules in Example 5.1 cause no such problems. This suggests that it may 160 be useful to develop distinct semantic theories for distinct species of negation. <p> Both EKS and Dynamic Prolog emphasize committed updates as well as hypothetical updates, while work on Hypothetical Datalog includes a logical semantics for negation-as-failure and an extensive analysis of computational complexity and expressibility <ref> [10, 9, 7, 18, 11, 12] </ref>. Much of the remaining work on logic and updates can be divided into three classes: (i) elementary updates to arbitrary logical theories, (ii) complex updates 166 to relational databases, and (iii) intuitionistic logic programming. We shall look at each class in turn. <p> The present paper extends and simplifies the results in [17] to include hypothetical deletion as well as insertion. Results on the computational complexity and expressibility of this semantics are presented in <ref> [10, 9, 7, 18, 11, 12] </ref>. There have also been proposals for a semantics of non-stratified intuitionistic rules [38, 52, 36, 26]. Following [50], these proposals each define a model as a mapping from a set of logic programs to a set of values. <p> In [38], Harland develops a semantics in which predicates are labeled as "completely defined" or "incompletely defined" [38]. Unfortunately, restrictions on the labeling preclude many stratified programs, such as the rulebase in Example 5.5, and the rulebases used to achieve the expressibility results of <ref> [10, 9, 7, 18, 11, 12] </ref>, as discussed in Section 5.4. The rules in Example 5.1 cause no such problems however. This suggests that it may be useful to develop distinct semantic theories for distinct species of negation. Acknowledgements.
Reference: 10. <author> A.J. Bonner. </author> <title> Hypothetical Datalog: Complexity and Expressibility. </title> <journal> Theoretical Computer Science (TCS), </journal> <volume> 76 </volume> <pages> 3-51, </pages> <year> 1990. </year> <note> Special issue on the 2 nd International Conference on Database Theory (ICDT'88). </note>
Reference-contexts: Working independently, McCarty and Miller extended this result to operations that create new constant symbols during inference, and they developed fixpoint semantics based on intuitionistic logic [47, 50]. Earlier, Statman showed that inference in intuitionistic logic is PSPACE-complete in the propositional case [59]. In <ref> [10, 11] </ref>, we show that the complexity of answering queries with hypothetical insertions is PSPACE-complete in the function-free predicate case (i:e:, the case of greatest interest to databases systems). In [10], we introduced a logic called Hypothetical Datalog that performs hypothetical deletion as well as insertion. <p> Earlier, Statman showed that inference in intuitionistic logic is PSPACE-complete in the propositional case [59]. In [10, 11], we show that the complexity of answering queries with hypothetical insertions is PSPACE-complete in the function-free predicate case (i:e:, the case of greatest interest to databases systems). In <ref> [10] </ref>, we introduced a logic called Hypothetical Datalog that performs hypothetical deletion as well as insertion. In that work, we established theoretical results on the complexity and expressibility of the logic. We showed, for instance, that its data complexity is complete for EXPTIME. <p> In that work, we established theoretical results on the complexity and expressibility of the logic. We showed, for instance, that its data complexity is complete for EXPTIME. By augmenting the logic with negation-as-failure, and by considering stratified rulebases, the logic expresses all database queries in EXPTIME <ref> [10] </ref> in the sense defined by Chandra and Harel [20]. In [10, 9, 7, 11, 12], we extended these results to lower complexity classes|PSPACE, PHIER, P k and NP|for various fragments of the logic. <p> We showed, for instance, that its data complexity is complete for EXPTIME. By augmenting the logic with negation-as-failure, and by considering stratified rulebases, the logic expresses all database queries in EXPTIME [10] in the sense defined by Chandra and Harel [20]. In <ref> [10, 9, 7, 11, 12] </ref>, we extended these results to lower complexity classes|PSPACE, PHIER, P k and NP|for various fragments of the logic. It is interesting that all these complexity classes can be characterized by a single language with a natural series of syntactic restrictions. <p> In contrast, with insertion alone, recursion can go only to polynomial depth. This provides an intuitive explanation of why inference with insertion alone is PSPACE-complete, while with both insertion and deletion, it is EXPTIME-complete <ref> [10, 11] </ref>. Like classical and intuitionistic logics, Hypothetical Datalog is monotonic. Thus, increasing the set of base facts can only increase (not decrease) the set of inferred facts. However, because it is monotonic, it cannot express non-monotonic queries. Thus, one cannot ask for the difference of two database relations. <p> To express such queries, we augment the logic with a well-known non-monotonic operator: negation-as-failure. This is a natural extension, one that is just as useful for hypothetical rules as for Horn rules, as we show through numerous examples. Furthermore, as shown in <ref> [10, 11] </ref>, Hypothetical Datalog with negation-as-failure is expressively complete for EXPTIME. That is, it expresses all database queries in EXPTIME, both monotonic and non-monotonic. There has been considerable work in recent years on the semantics of negation-as-failure. <p> We discuss these works in greater detail in Section 7. The problems encountered all reflect the difficulty of dealing with recursion through negation. Fortunately, none of our complexity and expressibility results depend on recursion through negation. For instance, in <ref> [10, 9, 7, 18, 12, 11] </ref>, we show that stratified hypothetical rules are expressively complete for many well-known complexity classes. In [9, 7], we show that each stratum can raise the complexity of inference by one level in the polynomial time hierarchy. <p> The notation R; DB ` means that formula can be inferred from rulebase R and database DB . In this paper, R is a set of logical rules, and DB is a set of ground atomic formulas. Examples illustrating this notation are given in <ref> [10] </ref>. For convenience, we present a selection of these examples below. 1 Additional examples can be found in [11]. Our first set of examples involve hypothetical insertion only. This is enough to introduce the idea of rulebase independence. We shall consider hypothetical deletion shortly. 2.1. <p> Many expressibility results based on this idea have appeared in the literature [3, 21, 22, 40, 2, 1, 39], and we have established numerous results of this kind using Hypothetical Datalog as a query language <ref> [10, 9, 7, 18, 11, 12] </ref>. However, hypothetical queries lead naturally to a generalized notion of expressibility, one that is appropriate for deductive databases and rule-based systems. <p> More sophisticated methodologies are possible, but it is extremely unlikely that any such approach can simulate deletion completely, simply because of a complexity mismatch. In <ref> [10, 11] </ref>, we show that the data complexity of hypothetical deletion is complete for EXPTIME, and that for insertion with negation-as-failure, it is in PSPACE. Thus, insertion plus negation cannot simulate deletion, unless PSPACE=EXPTIME. <p> However, with hypothetical insertion, it expresses all the database queries in PSPACE, and with both insertion and deletion, it expresses all the database queries in EXPTIME <ref> [10, 11] </ref>. 135 3. SYNTAX AND PROOF THEORY Hypothetical Datalog was introduced in [10]. This section reviews the syntax and proof theory of the logic, and presents new examples illustrating its expressive power. <p> However, with hypothetical insertion, it expresses all the database queries in PSPACE, and with both insertion and deletion, it expresses all the database queries in EXPTIME [10, 11]. 135 3. SYNTAX AND PROOF THEORY Hypothetical Datalog was introduced in <ref> [10] </ref>. This section reviews the syntax and proof theory of the logic, and presents new examples illustrating its expressive power. The rest of the paper then develops the model theory and fixpoint theory of the logic, and extends it with negation-as-failure. <p> The following elementary example shows how inference can be performed in a "top-down" manner by inverting these rules. Additional examples are given in <ref> [10, 11] </ref>. Many of the examples in this paper are best understood from a top-down point of view. Example 3.1. [Hypothetical Inference] Suppose that R consists of the following three rules: B C C D A B [add : D] Then R; DB ` A for any database DB. <p> We use it here to avoid similar problems with hypothetical updates. 8 In the examples in this paper, all rulebases in Hypothetical Datalog are guarded or can easily be transformed to be so. The same is true of the rulebases used to prove the complexity and expressibility results in <ref> [10, 9, 7, 18, 11, 12] </ref>. We emphasize, however, that guardedness is a matter of practice, and none of the theory developed in this paper depends on it. <p> This idea is developed in detail in <ref> [10, 7, 12, 9, 18, 11] </ref>. <p> Section 2 gave numerous examples of rulebase queries expressed in Hypothetical Datalog. In these examples, R may contain both Horn and hypothetical rules. 3.3. Examples This section gives simple examples of hypothetical inference, adapted from <ref> [10] </ref> and [8]. More-complex examples are given in Sections 3.4 and 3.5. The examples all show how to combine simple hypothetical updates into complex hypothetical queries. <p> The next subsection exploits this capability to construct a rulebase whose data complexity is coNP complete. 140 3.4. The Power of Hypothetical Inference In <ref> [10, 11] </ref>, we show that hypothetical inference is more powerful than well-known database query languages, such as relational algebra and Datalog. These languages can only express queries that are computable in polynomial time (polynomial in the size of the data domain). <p> Thus, only polynomially many atoms can be inserted into a database before reaching saturation, i:e:, before every possible atom has been inserted. This is why the data complexity of hypothetical insertion is only PSPACE-complete, while for insertion and deletion together, it is EXPTIME-complete <ref> [10, 11] </ref>. This difference in complexity is reflected in the difference in maximum recursion depths. 4. MODEL THEORY Section 3 presented the proof theory for hypothetical rulebases. This section develops the model theory, and shows that the proof theory is sound and complete. <p> In a similar fashion, the specialized intuitionistic models developed in [50] and [18] are mappings from rulebases to databases. This section builds upon and extends this tradition. The development here builds especially upon ideas introduced in <ref> [10] </ref>. For instance, the idea of interpreting a rulebase as a mapping, and the definition of a hypothetical T-operator were both used in [10]. However, as explained in [10], the treatment there is entirely proof-theoretic, is narrowly aimed at establishing complexity results, and only those concepts needed to achieve that end <p> This section builds upon and extends this tradition. The development here builds especially upon ideas introduced in <ref> [10] </ref>. For instance, the idea of interpreting a rulebase as a mapping, and the definition of a hypothetical T-operator were both used in [10]. However, as explained in [10], the treatment there is entirely proof-theoretic, is narrowly aimed at establishing complexity results, and only those concepts needed to achieve that end were developed. In particular, a full-blown model theory and fixpoint theory were intentionally avoided. For instance, the development in [10] includes no notion <p> This section builds upon and extends this tradition. The development here builds especially upon ideas introduced in <ref> [10] </ref>. For instance, the idea of interpreting a rulebase as a mapping, and the definition of a hypothetical T-operator were both used in [10]. However, as explained in [10], the treatment there is entirely proof-theoretic, is narrowly aimed at establishing complexity results, and only those concepts needed to achieve that end were developed. In particular, a full-blown model theory and fixpoint theory were intentionally avoided. For instance, the development in [10] includes no notion of a model of a <p> both used in <ref> [10] </ref>. However, as explained in [10], the treatment there is entirely proof-theoretic, is narrowly aimed at establishing complexity results, and only those concepts needed to achieve that end were developed. In particular, a full-blown model theory and fixpoint theory were intentionally avoided. For instance, the development in [10] includes no notion of a model of a 145 rulebase, nor of logical entailment, nor of soundness and completeness. The development of the T-operator is equally Spartan. <p> For instance, it is not treated as a lattice operator, nor is it shown to be monotonic and continuous, nor is it shown to have a unique minimal fixpoint. In fact, the very idea of a fixpoint is not even mentioned. In short, the development in <ref> [10] </ref> does not provide the substance of a logical semantics. This section does, thus completing the logical development of Hypothetical Datalog in the negation-free case. 4.1. <p> This result follows from the monotonicity and continuity of the operator T R , as originally shown by Tarski [62]. Theorem 4.16. lfp (T R ) = T fl R (I). 5. NEGATION AS FAILURE In <ref> [10, 11] </ref>, it is shown that the inference system of Definition 3.3 has a data complexity that is EXPTIME-complete. This means that the inference system has great computational power, including the power to solve any NP-complete problem. <p> This is a natural extension to the logic since any practical logic-programming language has to incorporate negation-as-failure in some form. Furthermore, this operator allows the logic to express all the database queries in EXPTIME, both monotonic and non-monotonic <ref> [10, 11] </ref>. In this sense, the logic extended with negation is expressively complete. In the extended logic, hypothetical rules may have negated premises. Thus, rules of the form A B [del : C] are allowed. <p> This section focuses on stratified rulebases, extending the theory of stratified negation from Horn rules to hypothetical rules. By focussing on stratified rules, we factor out the many problems resulting from recursion through negation. Moreover, stratification is precisely the restriction needed to prove the complexity and expressibility results in <ref> [10, 9, 7, 18, 11, 12] </ref>. <p> It is also worth noting that as in Horn logic, stratified rulebases act as a kind of benchmark in the semantics of negation: without a clear semantics for the stratified case, it would be hard to judge whether a semantics for arbitrary rulebases is correct. In <ref> [10] </ref>, we defined an operational semantics for stratified hypothetical rulebases. This semantics was sufficient for proving complexity results. However, a model theory and a logical proof theory were not presented. This section provides these missing pieces. We first generalize the notion of stratification from Horn rulebases to hypothetical rulebases. <p> We then revisit the circuit-validity problem of Section 3.4, and show how with negation-as-failure, the linear order on input lines can be eliminated. In each example, the predicate SOMELEFT acts as an "intermediate predicate" as described in Section 5.3. Additional examples can be found in <ref> [10, 11] </ref>. Example 5.4. [Hamiltonian Path, I] Suppose that DB is a database representing a directed graph. <p> In <ref> [10, 11] </ref>, we showed that stratified hypothetical rules could express all database queries in EXPTIME. Unlike comparable expressibility results in the literature, hypothetical rules do not need the artificial assumption of a linearly ordered data domain. The next example illustrates why this is possible. <p> This dual role for the predicate MARK is crucial to the example. A similar observation applies to the rulebase encodings of Turing machines used in proving the expressibility results in <ref> [10, 9, 7, 18, 11, 12] </ref>. It does not appear that these rulebases would be handled correctly by Harland's semantics. Note, however, that the rules in Example 5.1 cause no such problems. This suggests that it may 160 be useful to develop distinct semantic theories for distinct species of negation. <p> Both EKS and Dynamic Prolog emphasize committed updates as well as hypothetical updates, while work on Hypothetical Datalog includes a logical semantics for negation-as-failure and an extensive analysis of computational complexity and expressibility <ref> [10, 9, 7, 18, 11, 12] </ref>. Much of the remaining work on logic and updates can be divided into three classes: (i) elementary updates to arbitrary logical theories, (ii) complex updates 166 to relational databases, and (iii) intuitionistic logic programming. We shall look at each class in turn. <p> Working independently, McCarty and Miller extended this result to operations that create new constant symbols during inference, and they developed fixpoint semantics based on intuitionistic logic [47, 50]. Earlier, Statman showed that inference in intuitionistic logic is PSPACE-complete in the propositional case [59]. In <ref> [10, 11] </ref>, we showed that the complexity of answering queries with hypothetical insertions is PSPACE-complete in the function-free predicate case (i:e:, the databases case). Researchers have also investigated the semantics of negation-as-failure for in-tuitionistic logic programming. <p> The present paper extends and simplifies the results in [17] to include hypothetical deletion as well as insertion. Results on the computational complexity and expressibility of this semantics are presented in <ref> [10, 9, 7, 18, 11, 12] </ref>. There have also been proposals for a semantics of non-stratified intuitionistic rules [38, 52, 36, 26]. Following [50], these proposals each define a model as a mapping from a set of logic programs to a set of values. <p> In [38], Harland develops a semantics in which predicates are labeled as "completely defined" or "incompletely defined" [38]. Unfortunately, restrictions on the labeling preclude many stratified programs, such as the rulebase in Example 5.5, and the rulebases used to achieve the expressibility results of <ref> [10, 9, 7, 18, 11, 12] </ref>, as discussed in Section 5.4. The rules in Example 5.1 cause no such problems however. This suggests that it may be useful to develop distinct semantic theories for distinct species of negation. Acknowledgements.
Reference: 11. <author> A.J. Bonner. </author> <title> Hypothetical Reasoning in Deductive Databases. </title> <type> PhD thesis, </type> <institution> Department of Computer Science, Rutgers University, </institution> <address> New Brunswick, NJ 08903, USA, </address> <month> October </month> <year> 1991. </year> <note> Published as Rutgers Technical Report DCS-TR-283. </note>
Reference-contexts: Working independently, McCarty and Miller extended this result to operations that create new constant symbols during inference, and they developed fixpoint semantics based on intuitionistic logic [47, 50]. Earlier, Statman showed that inference in intuitionistic logic is PSPACE-complete in the propositional case [59]. In <ref> [10, 11] </ref>, we show that the complexity of answering queries with hypothetical insertions is PSPACE-complete in the function-free predicate case (i:e:, the case of greatest interest to databases systems). In [10], we introduced a logic called Hypothetical Datalog that performs hypothetical deletion as well as insertion. <p> We showed, for instance, that its data complexity is complete for EXPTIME. By augmenting the logic with negation-as-failure, and by considering stratified rulebases, the logic expresses all database queries in EXPTIME [10] in the sense defined by Chandra and Harel [20]. In <ref> [10, 9, 7, 11, 12] </ref>, we extended these results to lower complexity classes|PSPACE, PHIER, P k and NP|for various fragments of the logic. It is interesting that all these complexity classes can be characterized by a single language with a natural series of syntactic restrictions. <p> Just as a database query maps relational databases to relations, a rulebase query maps deductive databases to relations. The notion of rulebase queries finds it motivation in expert systems, and is based on a principle that we call rulebase independence. Originally introduced in <ref> [8, 11] </ref>, rulebase independence is a condition that we place on queries to a deductive database. Intuitively, a user should be able to formulate queries without having a detailed knowledge of the rulebase. <p> In contrast, with insertion alone, recursion can go only to polynomial depth. This provides an intuitive explanation of why inference with insertion alone is PSPACE-complete, while with both insertion and deletion, it is EXPTIME-complete <ref> [10, 11] </ref>. Like classical and intuitionistic logics, Hypothetical Datalog is monotonic. Thus, increasing the set of base facts can only increase (not decrease) the set of inferred facts. However, because it is monotonic, it cannot express non-monotonic queries. Thus, one cannot ask for the difference of two database relations. <p> To express such queries, we augment the logic with a well-known non-monotonic operator: negation-as-failure. This is a natural extension, one that is just as useful for hypothetical rules as for Horn rules, as we show through numerous examples. Furthermore, as shown in <ref> [10, 11] </ref>, Hypothetical Datalog with negation-as-failure is expressively complete for EXPTIME. That is, it expresses all database queries in EXPTIME, both monotonic and non-monotonic. There has been considerable work in recent years on the semantics of negation-as-failure. <p> We discuss these works in greater detail in Section 7. The problems encountered all reflect the difficulty of dealing with recursion through negation. Fortunately, none of our complexity and expressibility results depend on recursion through negation. For instance, in <ref> [10, 9, 7, 18, 12, 11] </ref>, we show that stratified hypothetical rules are expressively complete for many well-known complexity classes. In [9, 7], we show that each stratum can raise the complexity of inference by one level in the polynomial time hierarchy. <p> In this paper, R is a set of logical rules, and DB is a set of ground atomic formulas. Examples illustrating this notation are given in [10]. For convenience, we present a selection of these examples below. 1 Additional examples can be found in <ref> [11] </ref>. Our first set of examples involve hypothetical insertion only. This is enough to introduce the idea of rulebase independence. We shall consider hypothetical deletion shortly. 2.1. Introductory Examples The examples in this section are based on a deductive database for a university. <p> Many expressibility results based on this idea have appeared in the literature [3, 21, 22, 40, 2, 1, 39], and we have established numerous results of this kind using Hypothetical Datalog as a query language <ref> [10, 9, 7, 18, 11, 12] </ref>. However, hypothetical queries lead naturally to a generalized notion of expressibility, one that is appropriate for deductive databases and rule-based systems. <p> Example 2.5 shows that classical logic can express some simple hypothetical queries in a rulebase independent way. However, classical logic is poor at expressing more-complex hypothetical queries, as we shall see. To express hypothetical insertions, intuitionistic logic is much more suitable <ref> [12, 18, 7, 11] </ref>. From a logic-programming standpoint, intuitionistic logic can be viewed as an extension of classical logic. It uses the same syntax as classical logic, and is equivalent to classical logic for Horn rulebases and atomic queries. <p> More sophisticated methodologies are possible, but it is extremely unlikely that any such approach can simulate deletion completely, simply because of a complexity mismatch. In <ref> [10, 11] </ref>, we show that the data complexity of hypothetical deletion is complete for EXPTIME, and that for insertion with negation-as-failure, it is in PSPACE. Thus, insertion plus negation cannot simulate deletion, unless PSPACE=EXPTIME. <p> However, with hypothetical insertion, it expresses all the database queries in PSPACE, and with both insertion and deletion, it expresses all the database queries in EXPTIME <ref> [10, 11] </ref>. 135 3. SYNTAX AND PROOF THEORY Hypothetical Datalog was introduced in [10]. This section reviews the syntax and proof theory of the logic, and presents new examples illustrating its expressive power. <p> The following elementary example shows how inference can be performed in a "top-down" manner by inverting these rules. Additional examples are given in <ref> [10, 11] </ref>. Many of the examples in this paper are best understood from a top-down point of view. Example 3.1. [Hypothetical Inference] Suppose that R consists of the following three rules: B C C D A B [add : D] Then R; DB ` A for any database DB. <p> We use it here to avoid similar problems with hypothetical updates. 8 In the examples in this paper, all rulebases in Hypothetical Datalog are guarded or can easily be transformed to be so. The same is true of the rulebases used to prove the complexity and expressibility results in <ref> [10, 9, 7, 18, 11, 12] </ref>. We emphasize, however, that guardedness is a matter of practice, and none of the theory developed in this paper depends on it. <p> This idea is developed in detail in <ref> [10, 7, 12, 9, 18, 11] </ref>. <p> The next subsection exploits this capability to construct a rulebase whose data complexity is coNP complete. 140 3.4. The Power of Hypothetical Inference In <ref> [10, 11] </ref>, we show that hypothetical inference is more powerful than well-known database query languages, such as relational algebra and Datalog. These languages can only express queries that are computable in polynomial time (polynomial in the size of the data domain). <p> Thus, only polynomially many atoms can be inserted into a database before reaching saturation, i:e:, before every possible atom has been inserted. This is why the data complexity of hypothetical insertion is only PSPACE-complete, while for insertion and deletion together, it is EXPTIME-complete <ref> [10, 11] </ref>. This difference in complexity is reflected in the difference in maximum recursion depths. 4. MODEL THEORY Section 3 presented the proof theory for hypothetical rulebases. This section develops the model theory, and shows that the proof theory is sound and complete. <p> The rest of this section formalizes this idea and shows that the inference system of Definition 3.3 is sound and complete with respect to this semantics. Before developing this semantics, it is worth noting the relationship between the mappings of this section and the Kripke-like structures of intuitionistic logic <ref> [29, 11, 18] </ref>. An essential component of any intuitionistic structure is a mapping, , from a set of states to a set of databases. The mappings developed in this section are both a restriction and a generalization of these intuitionistic mappings. <p> In contrast, adding negation-as-failure to intuitionistic logic is problematic, as pointed out in [32] and [17]. Finally, it is worth pointing out, that like the models of this section, the canonical intuitionistic model developed in <ref> [11, 7] </ref> is essentially a mapping from databases to databases. In a similar fashion, the specialized intuitionistic models developed in [50] and [18] are mappings from rulebases to databases. This section builds upon and extends this tradition. The development here builds especially upon ideas introduced in [10]. <p> This result follows from the monotonicity and continuity of the operator T R , as originally shown by Tarski [62]. Theorem 4.16. lfp (T R ) = T fl R (I). 5. NEGATION AS FAILURE In <ref> [10, 11] </ref>, it is shown that the inference system of Definition 3.3 has a data complexity that is EXPTIME-complete. This means that the inference system has great computational power, including the power to solve any NP-complete problem. <p> This is a natural extension to the logic since any practical logic-programming language has to incorporate negation-as-failure in some form. Furthermore, this operator allows the logic to express all the database queries in EXPTIME, both monotonic and non-monotonic <ref> [10, 11] </ref>. In this sense, the logic extended with negation is expressively complete. In the extended logic, hypothetical rules may have negated premises. Thus, rules of the form A B [del : C] are allowed. <p> This section focuses on stratified rulebases, extending the theory of stratified negation from Horn rules to hypothetical rules. By focussing on stratified rules, we factor out the many problems resulting from recursion through negation. Moreover, stratification is precisely the restriction needed to prove the complexity and expressibility results in <ref> [10, 9, 7, 18, 11, 12] </ref>. <p> We then revisit the circuit-validity problem of Section 3.4, and show how with negation-as-failure, the linear order on input lines can be eliminated. In each example, the predicate SOMELEFT acts as an "intermediate predicate" as described in Section 5.3. Additional examples can be found in <ref> [10, 11] </ref>. Example 5.4. [Hamiltonian Path, I] Suppose that DB is a database representing a directed graph. <p> In <ref> [10, 11] </ref>, we showed that stratified hypothetical rules could express all database queries in EXPTIME. Unlike comparable expressibility results in the literature, hypothetical rules do not need the artificial assumption of a linearly ordered data domain. The next example illustrates why this is possible. <p> This dual role for the predicate MARK is crucial to the example. A similar observation applies to the rulebase encodings of Turing machines used in proving the expressibility results in <ref> [10, 9, 7, 18, 11, 12] </ref>. It does not appear that these rulebases would be handled correctly by Harland's semantics. Note, however, that the rules in Example 5.1 cause no such problems. This suggests that it may 160 be useful to develop distinct semantic theories for distinct species of negation. <p> Both EKS and Dynamic Prolog emphasize committed updates as well as hypothetical updates, while work on Hypothetical Datalog includes a logical semantics for negation-as-failure and an extensive analysis of computational complexity and expressibility <ref> [10, 9, 7, 18, 11, 12] </ref>. Much of the remaining work on logic and updates can be divided into three classes: (i) elementary updates to arbitrary logical theories, (ii) complex updates 166 to relational databases, and (iii) intuitionistic logic programming. We shall look at each class in turn. <p> Working independently, McCarty and Miller extended this result to operations that create new constant symbols during inference, and they developed fixpoint semantics based on intuitionistic logic [47, 50]. Earlier, Statman showed that inference in intuitionistic logic is PSPACE-complete in the propositional case [59]. In <ref> [10, 11] </ref>, we showed that the complexity of answering queries with hypothetical insertions is PSPACE-complete in the function-free predicate case (i:e:, the databases case). Researchers have also investigated the semantics of negation-as-failure for in-tuitionistic logic programming. <p> The present paper extends and simplifies the results in [17] to include hypothetical deletion as well as insertion. Results on the computational complexity and expressibility of this semantics are presented in <ref> [10, 9, 7, 18, 11, 12] </ref>. There have also been proposals for a semantics of non-stratified intuitionistic rules [38, 52, 36, 26]. Following [50], these proposals each define a model as a mapping from a set of logic programs to a set of values. <p> In [38], Harland develops a semantics in which predicates are labeled as "completely defined" or "incompletely defined" [38]. Unfortunately, restrictions on the labeling preclude many stratified programs, such as the rulebase in Example 5.5, and the rulebases used to achieve the expressibility results of <ref> [10, 9, 7, 18, 11, 12] </ref>, as discussed in Section 5.4. The rules in Example 5.1 cause no such problems however. This suggests that it may be useful to develop distinct semantic theories for distinct species of negation. Acknowledgements.
Reference: 12. <author> A.J. Bonner. </author> <title> Hypothetical Reasoning with Intuitionistic Logic. </title> <editor> In R. Demolombe and T. Imielinski, editors, </editor> <title> Non-Standard Queries and Answers, </title> <journal> Studies on Logic and Computation, </journal> <volume> chapter 8, </volume> <pages> pages 187-219. </pages> <publisher> Oxford University Press, </publisher> <month> October </month> <year> 1994. </year>
Reference-contexts: We showed, for instance, that its data complexity is complete for EXPTIME. By augmenting the logic with negation-as-failure, and by considering stratified rulebases, the logic expresses all database queries in EXPTIME [10] in the sense defined by Chandra and Harel [20]. In <ref> [10, 9, 7, 11, 12] </ref>, we extended these results to lower complexity classes|PSPACE, PHIER, P k and NP|for various fragments of the logic. It is interesting that all these complexity classes can be characterized by a single language with a natural series of syntactic restrictions. <p> We discuss these works in greater detail in Section 7. The problems encountered all reflect the difficulty of dealing with recursion through negation. Fortunately, none of our complexity and expressibility results depend on recursion through negation. For instance, in <ref> [10, 9, 7, 18, 12, 11] </ref>, we show that stratified hypothetical rules are expressively complete for many well-known complexity classes. In [9, 7], we show that each stratum can raise the complexity of inference by one level in the polynomial time hierarchy. <p> Many expressibility results based on this idea have appeared in the literature [3, 21, 22, 40, 2, 1, 39], and we have established numerous results of this kind using Hypothetical Datalog as a query language <ref> [10, 9, 7, 18, 11, 12] </ref>. However, hypothetical queries lead naturally to a generalized notion of expressibility, one that is appropriate for deductive databases and rule-based systems. <p> Example 2.5 shows that classical logic can express some simple hypothetical queries in a rulebase independent way. However, classical logic is poor at expressing more-complex hypothetical queries, as we shall see. To express hypothetical insertions, intuitionistic logic is much more suitable <ref> [12, 18, 7, 11] </ref>. From a logic-programming standpoint, intuitionistic logic can be viewed as an extension of classical logic. It uses the same syntax as classical logic, and is equivalent to classical logic for Horn rulebases and atomic queries. <p> Hypothetical Deletion So far, we have only looked at hypothetical insertion. This was enough to show that classical logic is inadequate for hypothetical reasoning. As mentioned above, intuitionistic logic is the correct way to formalize hypothetical insertion <ref> [32, 47, 50, 8, 18, 12] </ref>. However, even intuitionistic logic does not model hypothetical deletion. In fact, we shall see in this subsection that no reasonable first-order logic can do this. We then consider some alternatives. <p> We use it here to avoid similar problems with hypothetical updates. 8 In the examples in this paper, all rulebases in Hypothetical Datalog are guarded or can easily be transformed to be so. The same is true of the rulebases used to prove the complexity and expressibility results in <ref> [10, 9, 7, 18, 11, 12] </ref>. We emphasize, however, that guardedness is a matter of practice, and none of the theory developed in this paper depends on it. <p> This idea is developed in detail in <ref> [10, 7, 12, 9, 18, 11] </ref>. <p> This section focuses on stratified rulebases, extending the theory of stratified negation from Horn rules to hypothetical rules. By focussing on stratified rules, we factor out the many problems resulting from recursion through negation. Moreover, stratification is precisely the restriction needed to prove the complexity and expressibility results in <ref> [10, 9, 7, 18, 11, 12] </ref>. <p> This dual role for the predicate MARK is crucial to the example. A similar observation applies to the rulebase encodings of Turing machines used in proving the expressibility results in <ref> [10, 9, 7, 18, 11, 12] </ref>. It does not appear that these rulebases would be handled correctly by Harland's semantics. Note, however, that the rules in Example 5.1 cause no such problems. This suggests that it may 160 be useful to develop distinct semantic theories for distinct species of negation. <p> Both EKS and Dynamic Prolog emphasize committed updates as well as hypothetical updates, while work on Hypothetical Datalog includes a logical semantics for negation-as-failure and an extensive analysis of computational complexity and expressibility <ref> [10, 9, 7, 18, 11, 12] </ref>. Much of the remaining work on logic and updates can be divided into three classes: (i) elementary updates to arbitrary logical theories, (ii) complex updates 166 to relational databases, and (iii) intuitionistic logic programming. We shall look at each class in turn. <p> The present paper extends and simplifies the results in [17] to include hypothetical deletion as well as insertion. Results on the computational complexity and expressibility of this semantics are presented in <ref> [10, 9, 7, 18, 11, 12] </ref>. There have also been proposals for a semantics of non-stratified intuitionistic rules [38, 52, 36, 26]. Following [50], these proposals each define a model as a mapping from a set of logic programs to a set of values. <p> In [38], Harland develops a semantics in which predicates are labeled as "completely defined" or "incompletely defined" [38]. Unfortunately, restrictions on the labeling preclude many stratified programs, such as the rulebase in Example 5.5, and the rulebases used to achieve the expressibility results of <ref> [10, 9, 7, 18, 11, 12] </ref>, as discussed in Section 5.4. The rules in Example 5.1 cause no such problems however. This suggests that it may be useful to develop distinct semantic theories for distinct species of negation. Acknowledgements.
Reference: 13. <author> A.J. Bonner and M. Kifer. </author> <title> Transaction Logic Programming. </title> <booktitle> In Proceedings of the International Conference on Logic Programming (ICLP), </booktitle> <pages> pages 257-279, </pages> <address> Budapest, Hungary, June 21-24 1993. </address> <publisher> MIT Press. </publisher>
Reference-contexts: In this sense, our work is orthogonal to work on the logical semantics of elementary updates. This idea has been adopted in the development of Transaction Logic <ref> [14, 13, 16, 15] </ref>. The second class of work includes [2, 1, 24, 23, 54]. Like Hypothetical Datalog, these systems are primarily concerned with relational databases, and with combining elementary updates into complex updates. However, these systems deal with committed updates, not with hypothetical queries.
Reference: 14. <author> A.J. Bonner and M. Kifer. </author> <title> An Overview of Transaction Logic. </title> <journal> Theoretical Computer Science (TCS), </journal> <volume> 133, </volume> <month> October </month> <year> 1994. </year>
Reference-contexts: In this sense, our work is orthogonal to work on the logical semantics of elementary updates. This idea has been adopted in the development of Transaction Logic <ref> [14, 13, 16, 15] </ref>. The second class of work includes [2, 1, 24, 23, 54]. Like Hypothetical Datalog, these systems are primarily concerned with relational databases, and with combining elementary updates into complex updates. However, these systems deal with committed updates, not with hypothetical queries.
Reference: 15. <author> A.J. Bonner and M. Kifer. </author> <title> Concurrency and communication in transaction logic. </title> <booktitle> In Proceedings of the Joint International Conference and Symposium on Logic Programming (JICSLP), </booktitle> <address> Bonn, Germany, </address> <month> September </month> <year> 1996. </year> <note> To appear. </note>
Reference-contexts: In this sense, our work is orthogonal to work on the logical semantics of elementary updates. This idea has been adopted in the development of Transaction Logic <ref> [14, 13, 16, 15] </ref>. The second class of work includes [2, 1, 24, 23, 54]. Like Hypothetical Datalog, these systems are primarily concerned with relational databases, and with combining elementary updates into complex updates. However, these systems deal with committed updates, not with hypothetical queries.
Reference: 16. <author> A.J. Bonner, M. Kifer, and M. Consens. </author> <title> Database programming in transaction logic. </title> <booktitle> In Proceedings of the International Workshop on Database Programming Languages (DBPL), Workshops in Computing, </booktitle> <pages> pages 309-337. </pages> <publisher> Springer Verlag, </publisher> <month> 30 Aug-1 Sept </month> <year> 1993. </year>
Reference-contexts: In this sense, our work is orthogonal to work on the logical semantics of elementary updates. This idea has been adopted in the development of Transaction Logic <ref> [14, 13, 16, 15] </ref>. The second class of work includes [2, 1, 24, 23, 54]. Like Hypothetical Datalog, these systems are primarily concerned with relational databases, and with combining elementary updates into complex updates. However, these systems deal with committed updates, not with hypothetical queries.
Reference: 17. <author> A.J. Bonner and L.T. McCarty. </author> <title> Adding Negation-as-Failure to Intuitionistic Logic Programming. </title> <booktitle> In Proceedings of the North American Conference on Logic Programming (NACLP), </booktitle> <pages> pages 681-703, </pages> <address> Austin, Texas, Oct 29-Nov 1 1990. </address> <publisher> MIT Press. </publisher>
Reference-contexts: Because of this non-monotonicity, the semantics developed in this section can be extended in a straightforward way to a semantics for hypothetical reasoning with negation-as-failure (Section 5). In contrast, adding negation-as-failure to intuitionistic logic is problematic, as pointed out in [32] and <ref> [17] </ref>. Finally, it is worth pointing out, that like the models of this section, the canonical intuitionistic model developed in [11, 7] is essentially a mapping from databases to databases. In a similar fashion, the specialized intuitionistic models developed in [50] and [18] are mappings from rulebases to databases. <p> By combining and extending these two traditions, we achieve a semantics that does not depend on any finiteness assumptions. Thus, all quantities may be infinite: the database, the rulebase, the set of constant symbols, and even the number of strata. The following example is adapted from <ref> [17] </ref>. Example 5.1. [Negation-as-failure] The rules below are part of a stratified hypothetical rulebase that defines a student's eligibility for financial aid. Intuitively, a student s is eligible for a stipend if he is a near-graduate but not a graduate. <p> Researchers have also investigated the semantics of negation-as-failure for in-tuitionistic logic programming. Gabbay was the first to point out that negation-as-failure leads to logical paradoxes in an intuitionistic setting [32]. To overcome these paradoxes, some researchers distinguish two types of implication, denoted and ( <ref> [17, 52, 36] </ref>. The former corresponds to our own use of implication, and the latter corresponds to our operator of hypothetical insertion. In fact, the rule A (B ( C) is functionally identical to A B [add : C]. <p> But this effect can also be achieved by the two rules A B [add : E] and 167 C D; E. The first rule inserts the atom E into the database, which effectively "enables" the rule C D. In <ref> [17] </ref>, Bonner and McCarty develop a semantics of stratified intuitionistic rule-bases, including a model theory and a sound-and-complete proof theory. In the special case in which all the rules are Horn, this semantics is equivalent to that of stratified Horn rulebases [4]. <p> In the special case in which all the rules are Horn, this semantics is equivalent to that of stratified Horn rulebases [4]. The present paper extends and simplifies the results in <ref> [17] </ref> to include hypothetical deletion as well as insertion. Results on the computational complexity and expressibility of this semantics are presented in [10, 9, 7, 18, 11, 12]. There have also been proposals for a semantics of non-stratified intuitionistic rules [38, 52, 36, 26]. <p> Under a syntactic restriction called allowedness, this procedure is sound and avoids floundering. Unfortunately, this restriction is rather conservative, and it disallows many programs that are not really problematic, including many non-recursive programs. A detailed comparison of their work and our semantics of stratified intuitionistic rules <ref> [17] </ref> can be found in [36]. In [38], Harland develops a semantics in which predicates are labeled as "completely defined" or "incompletely defined" [38]. <p> Some of the work presented here builds on ideas originally developed in collaboration with Thorne McCarty. This is mostly true of the work on negation-as-failure, which is an extension and simplification of our earlier work on the semantics of negation-as-failure in intuitionistic logic programming <ref> [17] </ref>.
Reference: 18. <author> A.J. Bonner, L.T. McCarty, and K. Vadaparty. </author> <title> Expressing Database Queries with Intuitionistic Logic. </title> <booktitle> In Proceedings of the North American Conference on Logic Programming (NACLP), </booktitle> <pages> pages 831-850, </pages> <address> Cleveland, Ohio, October 16-20 1989. </address> <publisher> MIT Press. </publisher>
Reference-contexts: We discuss these works in greater detail in Section 7. The problems encountered all reflect the difficulty of dealing with recursion through negation. Fortunately, none of our complexity and expressibility results depend on recursion through negation. For instance, in <ref> [10, 9, 7, 18, 12, 11] </ref>, we show that stratified hypothetical rules are expressively complete for many well-known complexity classes. In [9, 7], we show that each stratum can raise the complexity of inference by one level in the polynomial time hierarchy. <p> Many expressibility results based on this idea have appeared in the literature [3, 21, 22, 40, 2, 1, 39], and we have established numerous results of this kind using Hypothetical Datalog as a query language <ref> [10, 9, 7, 18, 11, 12] </ref>. However, hypothetical queries lead naturally to a generalized notion of expressibility, one that is appropriate for deductive databases and rule-based systems. <p> Example 2.5 shows that classical logic can express some simple hypothetical queries in a rulebase independent way. However, classical logic is poor at expressing more-complex hypothetical queries, as we shall see. To express hypothetical insertions, intuitionistic logic is much more suitable <ref> [12, 18, 7, 11] </ref>. From a logic-programming standpoint, intuitionistic logic can be viewed as an extension of classical logic. It uses the same syntax as classical logic, and is equivalent to classical logic for Horn rulebases and atomic queries. <p> Hypothetical Deletion So far, we have only looked at hypothetical insertion. This was enough to show that classical logic is inadequate for hypothetical reasoning. As mentioned above, intuitionistic logic is the correct way to formalize hypothetical insertion <ref> [32, 47, 50, 8, 18, 12] </ref>. However, even intuitionistic logic does not model hypothetical deletion. In fact, we shall see in this subsection that no reasonable first-order logic can do this. We then consider some alternatives. <p> We use it here to avoid similar problems with hypothetical updates. 8 In the examples in this paper, all rulebases in Hypothetical Datalog are guarded or can easily be transformed to be so. The same is true of the rulebases used to prove the complexity and expressibility results in <ref> [10, 9, 7, 18, 11, 12] </ref>. We emphasize, however, that guardedness is a matter of practice, and none of the theory developed in this paper depends on it. <p> This idea is developed in detail in <ref> [10, 7, 12, 9, 18, 11] </ref>. <p> The rest of this section formalizes this idea and shows that the inference system of Definition 3.3 is sound and complete with respect to this semantics. Before developing this semantics, it is worth noting the relationship between the mappings of this section and the Kripke-like structures of intuitionistic logic <ref> [29, 11, 18] </ref>. An essential component of any intuitionistic structure is a mapping, , from a set of states to a set of databases. The mappings developed in this section are both a restriction and a generalization of these intuitionistic mappings. <p> Finally, it is worth pointing out, that like the models of this section, the canonical intuitionistic model developed in [11, 7] is essentially a mapping from databases to databases. In a similar fashion, the specialized intuitionistic models developed in [50] and <ref> [18] </ref> are mappings from rulebases to databases. This section builds upon and extends this tradition. The development here builds especially upon ideas introduced in [10]. For instance, the idea of interpreting a rulebase as a mapping, and the definition of a hypothetical T-operator were both used in [10]. <p> This section focuses on stratified rulebases, extending the theory of stratified negation from Horn rules to hypothetical rules. By focussing on stratified rules, we factor out the many problems resulting from recursion through negation. Moreover, stratification is precisely the restriction needed to prove the complexity and expressibility results in <ref> [10, 9, 7, 18, 11, 12] </ref>. <p> This dual role for the predicate MARK is crucial to the example. A similar observation applies to the rulebase encodings of Turing machines used in proving the expressibility results in <ref> [10, 9, 7, 18, 11, 12] </ref>. It does not appear that these rulebases would be handled correctly by Harland's semantics. Note, however, that the rules in Example 5.1 cause no such problems. This suggests that it may 160 be useful to develop distinct semantic theories for distinct species of negation. <p> Both EKS and Dynamic Prolog emphasize committed updates as well as hypothetical updates, while work on Hypothetical Datalog includes a logical semantics for negation-as-failure and an extensive analysis of computational complexity and expressibility <ref> [10, 9, 7, 18, 11, 12] </ref>. Much of the remaining work on logic and updates can be divided into three classes: (i) elementary updates to arbitrary logical theories, (ii) complex updates 166 to relational databases, and (iii) intuitionistic logic programming. We shall look at each class in turn. <p> The present paper extends and simplifies the results in [17] to include hypothetical deletion as well as insertion. Results on the computational complexity and expressibility of this semantics are presented in <ref> [10, 9, 7, 18, 11, 12] </ref>. There have also been proposals for a semantics of non-stratified intuitionistic rules [38, 52, 36, 26]. Following [50], these proposals each define a model as a mapping from a set of logic programs to a set of values. <p> In [38], Harland develops a semantics in which predicates are labeled as "completely defined" or "incompletely defined" [38]. Unfortunately, restrictions on the labeling preclude many stratified programs, such as the rulebase in Example 5.5, and the rulebases used to achieve the expressibility results of <ref> [10, 9, 7, 18, 11, 12] </ref>, as discussed in Section 5.4. The rules in Example 5.1 cause no such problems however. This suggests that it may be useful to develop distinct semantic theories for distinct species of negation. Acknowledgements.
Reference: 19. <author> A.K. Chandra. </author> <title> Theory of Database Queries. </title> <booktitle> In Proceedings of the ACM Symposium on the Principles of Database Systems (PODS), </booktitle> <pages> pages 1-9, </pages> <address> Austin, Texas, </address> <month> March </month> <year> 1988. </year>
Reference-contexts: Note that the premise of the first rule is a hypothetical query similar to the query in Example 2.2. 2.2. Rulebase Queries A database query is often treated as a mapping that takes a relational database as input and returns a relation as output <ref> [20, 19] </ref>. The expressibility of a query language is therefore the set of mappings that the language represents.
Reference: 20. <author> A.K. Chandra and D. Harel. </author> <title> Computable Queries for Relational Databases. </title> <journal> Journal 169 of Computer and System Sciences (JCSS), </journal> <volume> 21(2) </volume> <pages> 156-178, </pages> <year> 1980. </year>
Reference-contexts: We showed, for instance, that its data complexity is complete for EXPTIME. By augmenting the logic with negation-as-failure, and by considering stratified rulebases, the logic expresses all database queries in EXPTIME [10] in the sense defined by Chandra and Harel <ref> [20] </ref>. In [10, 9, 7, 11, 12], we extended these results to lower complexity classes|PSPACE, PHIER, P k and NP|for various fragments of the logic. It is interesting that all these complexity classes can be characterized by a single language with a natural series of syntactic restrictions. <p> Note that the premise of the first rule is a hypothetical query similar to the query in Example 2.2. 2.2. Rulebase Queries A database query is often treated as a mapping that takes a relational database as input and returns a relation as output <ref> [20, 19] </ref>. The expressibility of a query language is therefore the set of mappings that the language represents. <p> It is important that tc is a query predicate, since otherwise some databases would contain atoms of the form tc (a; b), so statement (2.3) would not be true. To generalize from this example, we need a precise definition of database query. Following Chandra and Harel <ref> [20] </ref>, we define a database query to be a mapping from relational databases to relations. 3 Thus, if Q is a database query, and DB is a relational database, then Q (DB ) is a relation. <p> Thus, if Q is a rulebase query, and [R; DB ] is a deductive database, then Q (R; DB ) is a relation. 4 For example, R could be a collection of rules defining the 3 In the definition of <ref> [20] </ref>, the mapping must satisfy certain conditions, such as computability and genericity. However, these conditions are not relevant to the present discussion. 4 As with database queries, we might want to impose conditions on the mapping Q.
Reference: 21. <author> A.K. Chandra and D. Harel. </author> <title> Structure and Complexity of Relational Queries. </title> <journal> Journal of Computer and System Sciences (JCSS), </journal> <volume> 25(1) </volume> <pages> 99-128, </pages> <year> 1982. </year>
Reference-contexts: The expressibility of a query language is therefore the set of mappings that the language represents. Many expressibility results based on this idea have appeared in the literature <ref> [3, 21, 22, 40, 2, 1, 39] </ref>, and we have established numerous results of this kind using Hypothetical Datalog as a query language [10, 9, 7, 18, 11, 12]. However, hypothetical queries lead naturally to a generalized notion of expressibility, one that is appropriate for deductive databases and rule-based systems. <p> (a 2 ; a 3 ); :::; NEXT (a n ; a n+1 ); FIRST (a 1 ); LAST (a n+1 ): 9 Informally, the data complexity of an inference system is the complexity of inference when the rulebase and query are fixed and the database varies (acts as input) <ref> [21, 65] </ref>. 141 where a n+1 is an extra constant symbol, introduced to simplify the construction of the rulebase. (In Section 5.4, we shall see that negation-as-failure permits us to do away with this linear order.) Let DB be a database that encodes the circuit and orders the inputs in this
Reference: 22. <author> A.K. Chandra and D. Harel. </author> <title> Horn Clause Queries and Generalizations. </title> <journal> Journal of Logic Programming (JLP), </journal> <volume> 2(1) </volume> <pages> 1-15, </pages> <year> 1985. </year>
Reference-contexts: The expressibility of a query language is therefore the set of mappings that the language represents. Many expressibility results based on this idea have appeared in the literature <ref> [3, 21, 22, 40, 2, 1, 39] </ref>, and we have established numerous results of this kind using Hypothetical Datalog as a query language [10, 9, 7, 18, 11, 12]. However, hypothetical queries lead naturally to a generalized notion of expressibility, one that is appropriate for deductive databases and rule-based systems.
Reference: 23. <author> W. Chen. </author> <title> Declarative specification and evaluation of database updates. </title> <booktitle> In Proceedings of the International Conference on Deductive and Object-Oriented Databases (DOOD), volume 566 of Lecture Notes in Computer Science, </booktitle> <pages> pages 147-166. </pages> <publisher> Springer Verlag, </publisher> <month> December </month> <year> 1991. </year>
Reference-contexts: In this sense, our work is orthogonal to work on the logical semantics of elementary updates. This idea has been adopted in the development of Transaction Logic [14, 13, 16, 15]. The second class of work includes <ref> [2, 1, 24, 23, 54] </ref>. Like Hypothetical Datalog, these systems are primarily concerned with relational databases, and with combining elementary updates into complex updates. However, these systems deal with committed updates, not with hypothetical queries.
Reference: 24. <author> W. Chen. </author> <title> Declarative updates of relational databases. </title> <journal> ACM Transactions on Database Systems (TODS), </journal> <volume> 20(1) </volume> <pages> 42-70, </pages> <year> 1995. </year>
Reference-contexts: In this sense, our work is orthogonal to work on the logical semantics of elementary updates. This idea has been adopted in the development of Transaction Logic [14, 13, 16, 15]. The second class of work includes <ref> [2, 1, 24, 23, 54] </ref>. Like Hypothetical Datalog, these systems are primarily concerned with relational databases, and with combining elementary updates into complex updates. However, these systems deal with committed updates, not with hypothetical queries.
Reference: 25. <author> U. Dayal and P.A. Bernstein. </author> <title> Translation of update operations on relational views. </title> <journal> ACM Transactions on Database Systems (TODS), </journal> <volume> 8 </volume> <pages> 381-416, </pages> <year> 1982. </year>
Reference-contexts: Update operators act only on the stored data. That is, [add : C] adds the atom C to the stored data, and [del : C] deletes C from the stored data. Since derived data is never updated directly, we avoid the difficult view-update problem <ref> [27, 28, 25, 6, 31, 43] </ref>. Like classical and intuitionistic logics, Hypothetical Datalog does not distinguish between different sorts of predicates, such as base and derived predicates. Of course, predicates can always be divided into sorts, as an option, but it is not imposed by the theory.
Reference: 26. <author> P.M. Dung. </author> <title> Declarative Semantics of Hypothetical Logic Programming with Negation as Failure. </title> <booktitle> In Proceedings of the Third International Workshop on Extensions of Logic Programming, </booktitle> <pages> pages 45-58, </pages> <address> Bologna, Italy, </address> <month> February </month> <year> 1992. </year> <note> Springer-Verlag. Published as volume 660 of Lecture Notes in Artificial Intelligence, </note> <year> 1993. </year>
Reference-contexts: There has been considerable work in recent years on the semantics of negation-as-failure. Most of this work has focussed on Horn rulebases and the myriad problems created by recursion through negation [55, 35, 34, 64]. More recently, some researchers have focussed on the semantics of intuitionistic rulebases with negation <ref> [38, 52, 36, 26] </ref>. These works all focus on arbitrary (i:e:, non-stratified) rule-bases. Unfortunately, none of these semantics is suited to our needs, for several 123 reasons. Foremost, intuitionistic logic models hypothetical insertion, not deletion. Moreover, most of these works focus on finite failure, whereas our logic uses infinite failure. <p> The present paper extends and simplifies the results in [17] to include hypothetical deletion as well as insertion. Results on the computational complexity and expressibility of this semantics are presented in [10, 9, 7, 18, 11, 12]. There have also been proposals for a semantics of non-stratified intuitionistic rules <ref> [38, 52, 36, 26] </ref>. Following [50], these proposals each define a model as a mapping from a set of logic programs to a set of values. Unlike the semantics presented in this paper, these proposals often provide a semantics of finite failure. <p> Thus, in the special case of Horn rulebases, these works provide an alternative to much of the existing work on the semantics of negation [4, 55, 35, 34, 64]. One exception is the work of Dung <ref> [26] </ref>, which proposes a stable model semantics for hypothetical insertion. Although no proof theory is presented, Dung's proposal allows arbitrary rulebases, stratified or unstratified. In the special case of Horn rulebases, it is equivalent to the stable model semantics developed in [35].
Reference: 27. <author> R. Fagin, G.M. Kuper, J.D. Ullman, and M.Y. Vardi. </author> <title> Updating logical databases. In P.C. </title> <editor> Kanellakis, editor, </editor> <booktitle> Advances in Computing Research, </booktitle> <volume> volume 3, </volume> <pages> pages 1-18. </pages> <publisher> Plenum Press, </publisher> <year> 1986. </year>
Reference-contexts: Update operators act only on the stored data. That is, [add : C] adds the atom C to the stored data, and [del : C] deletes C from the stored data. Since derived data is never updated directly, we avoid the difficult view-update problem <ref> [27, 28, 25, 6, 31, 43] </ref>. Like classical and intuitionistic logics, Hypothetical Datalog does not distinguish between different sorts of predicates, such as base and derived predicates. Of course, predicates can always be divided into sorts, as an option, but it is not imposed by the theory. <p> Much of the remaining work on logic and updates can be divided into three classes: (i) elementary updates to arbitrary logical theories, (ii) complex updates 166 to relational databases, and (iii) intuitionistic logic programming. We shall look at each class in turn. The first class of work includes <ref> [69, 42, 28, 27, 56] </ref>. This work focuses on the semantics of elementary updates to complex theories. Our work is distinct from this class in two ways. First, we are concerned with combining elementary updates into complex hypothetical queries.
Reference: 28. <author> R. Fagin, J.D. Ullman, and M.Y. Vardi. </author> <title> On the semantics of updates in databases. </title> <booktitle> In Proceedings of the ACM Symposium on the Principles of Database Systems (PODS), </booktitle> <pages> pages 352-365, </pages> <year> 1983. </year>
Reference-contexts: Update operators act only on the stored data. That is, [add : C] adds the atom C to the stored data, and [del : C] deletes C from the stored data. Since derived data is never updated directly, we avoid the difficult view-update problem <ref> [27, 28, 25, 6, 31, 43] </ref>. Like classical and intuitionistic logics, Hypothetical Datalog does not distinguish between different sorts of predicates, such as base and derived predicates. Of course, predicates can always be divided into sorts, as an option, but it is not imposed by the theory. <p> Much of the remaining work on logic and updates can be divided into three classes: (i) elementary updates to arbitrary logical theories, (ii) complex updates 166 to relational databases, and (iii) intuitionistic logic programming. We shall look at each class in turn. The first class of work includes <ref> [69, 42, 28, 27, 56] </ref>. This work focuses on the semantics of elementary updates to complex theories. Our work is distinct from this class in two ways. First, we are concerned with combining elementary updates into complex hypothetical queries.
Reference: 29. <author> M.C. </author> <title> Fitting. Intuitionistic Logic, Model Theory and Forcing. </title> <publisher> North-Holland, </publisher> <year> 1969. </year>
Reference-contexts: Theoretical work on hypothetical inference has also been carried out, largely by the logic-programming community. Most of this work focuses on the hypothetical insertion of atoms into a database. One reason for this focus is that hypothetical insertion fits neatly into a well-known logical system: intuitionistic logic <ref> [29] </ref>. Gab-bay was the first to show that intuitionistic logic models hypothetical insertion [32]. Working independently, McCarty and Miller extended this result to operations that create new constant symbols during inference, and they developed fixpoint semantics based on intuitionistic logic [47, 50]. <p> That is, if ` i denotes entailment in first-order intuitionistic logic, then R ` i A iff R ` c A (2.4) for any Horn rulebase R, and any ground atomic formula A. However, intuitionistic and classical logic have different semantics and different theorems <ref> [29] </ref>. For example, in intuitionistic logic, implication is not defined in terms of disjunction and negation, but has an independent semantic definition. Thus, the formula ff fi is not equivalent to ff_ fi intuitionistically. <p> In general, classical logic has more equivalences than intuitionistic logic, since every theorem of intuitionistic logic is also a theorem of classical logic, but not vice versa <ref> [29] </ref>. Intuitively, this means that intuitionistic logic makes finer distinctions between formulas. This seems to be why intuitionistic logic is better than classical logic at expressing hypothetical queries. 2.4. <p> The rest of this section formalizes this idea and shows that the inference system of Definition 3.3 is sound and complete with respect to this semantics. Before developing this semantics, it is worth noting the relationship between the mappings of this section and the Kripke-like structures of intuitionistic logic <ref> [29, 11, 18] </ref>. An essential component of any intuitionistic structure is a mapping, , from a set of states to a set of databases. The mappings developed in this section are both a restriction and a generalization of these intuitionistic mappings. <p> The third class of work is perhaps the most similar to our own. However, it is concerned exclusively with hypothetical insertion. This is because hypothetical insertion fits neatly into a well-known logical system: intuitionistic logic <ref> [29] </ref>. Gab-bay was the first to show that intuitionistic logic models hypothetical insertion [32]. Working independently, McCarty and Miller extended this result to operations that create new constant symbols during inference, and they developed fixpoint semantics based on intuitionistic logic [47, 50].
Reference: 30. <author> The Committee for Advanced DBMS function. </author> <title> Third-Generation Database System Manifesto. </title> <booktitle> SIGMOD Record, </booktitle> <volume> 19(3) </volume> <pages> 31-44, </pages> <month> September </month> <year> 1990. </year> <note> Also published as Memorandum No. </note> <institution> UCB/ERL M90/28, Electronics Research Laboratory, College of Engineering, University of California, Berkeley. </institution>
Reference-contexts: Or he might want a table of deficit predictions for a number of hypothetical salary increases [66, 67]. Similar problems occur in computer aided design (CAD). Here, one must evaluate the effect on the overall design of local design alternatives and of various external factors <ref> [30, 58] </ref>. For example, an engineer may need to know how much the price of an automobile would increase if supplier X raised his prices by Y percent [30]. The number of hypothetical scenarios multiplies quickly when several factors are varied simultaneously, such as prices, interest rates, tax rates, etc. <p> Here, one must evaluate the effect on the overall design of local design alternatives and of various external factors [30, 58]. For example, an engineer may need to know how much the price of an automobile would increase if supplier X raised his prices by Y percent <ref> [30] </ref>. The number of hypothetical scenarios multiplies quickly when several factors are varied simultaneously, such as prices, interest rates, tax rates, etc. One may also need to consider variations in more complex factors, such as government regulations, company policy, tax laws, etc.
Reference: 31. <author> A.L. Furtado and K.C. Sevcik. </author> <title> Permitting updates through views of databases. </title> <journal> Information Systems, </journal> <volume> 4 </volume> <pages> 269-283, </pages> <year> 1979. </year>
Reference-contexts: Update operators act only on the stored data. That is, [add : C] adds the atom C to the stored data, and [del : C] deletes C from the stored data. Since derived data is never updated directly, we avoid the difficult view-update problem <ref> [27, 28, 25, 6, 31, 43] </ref>. Like classical and intuitionistic logics, Hypothetical Datalog does not distinguish between different sorts of predicates, such as base and derived predicates. Of course, predicates can always be divided into sorts, as an option, but it is not imposed by the theory.
Reference: 32. <author> D.M. Gabbay. N-Prolog: </author> <title> an Extension of Prolog with Hypothetical Implications. II. Logical Foundations and Negation as Failure. </title> <journal> Journal of Logic Programming (JLP), </journal> <volume> 2(4) </volume> <pages> 251-283, </pages> <year> 1985. </year>
Reference-contexts: Most of this work focuses on the hypothetical insertion of atoms into a database. One reason for this focus is that hypothetical insertion fits neatly into a well-known logical system: intuitionistic logic [29]. Gab-bay was the first to show that intuitionistic logic models hypothetical insertion <ref> [32] </ref>. Working independently, McCarty and Miller extended this result to operations that create new constant symbols during inference, and they developed fixpoint semantics based on intuitionistic logic [47, 50]. Earlier, Statman showed that inference in intuitionistic logic is PSPACE-complete in the propositional case [59]. <p> Hypothetical Deletion So far, we have only looked at hypothetical insertion. This was enough to show that classical logic is inadequate for hypothetical reasoning. As mentioned above, intuitionistic logic is the correct way to formalize hypothetical insertion <ref> [32, 47, 50, 8, 18, 12] </ref>. However, even intuitionistic logic does not model hypothetical deletion. In fact, we shall see in this subsection that no reasonable first-order logic can do this. We then consider some alternatives. <p> Because of this non-monotonicity, the semantics developed in this section can be extended in a straightforward way to a semantics for hypothetical reasoning with negation-as-failure (Section 5). In contrast, adding negation-as-failure to intuitionistic logic is problematic, as pointed out in <ref> [32] </ref> and [17]. Finally, it is worth pointing out, that like the models of this section, the canonical intuitionistic model developed in [11, 7] is essentially a mapping from databases to databases. <p> The third class of work is perhaps the most similar to our own. However, it is concerned exclusively with hypothetical insertion. This is because hypothetical insertion fits neatly into a well-known logical system: intuitionistic logic [29]. Gab-bay was the first to show that intuitionistic logic models hypothetical insertion <ref> [32] </ref>. Working independently, McCarty and Miller extended this result to operations that create new constant symbols during inference, and they developed fixpoint semantics based on intuitionistic logic [47, 50]. Earlier, Statman showed that inference in intuitionistic logic is PSPACE-complete in the propositional case [59]. <p> Researchers have also investigated the semantics of negation-as-failure for in-tuitionistic logic programming. Gabbay was the first to point out that negation-as-failure leads to logical paradoxes in an intuitionistic setting <ref> [32] </ref>. To overcome these paradoxes, some researchers distinguish two types of implication, denoted and ( [17, 52, 36]. The former corresponds to our own use of implication, and the latter corresponds to our operator of hypothetical insertion.
Reference: 33. <editor> D.M. Gabbay and U. Reyle. N-Prolog: </editor> <title> an Extension of Prolog with Hypothetical Implications. I. </title> <journal> Journal of Logic Programming (JLP), </journal> <volume> 1(4) </volume> <pages> 319-355, </pages> <year> 1984. </year>
Reference-contexts: Gabbay and Reyle, for instance, have reported a need to augment Prolog with hypothetical rules in order to encode the British Nationality Act, because the act contains rules such as, You are eligible for citizenship if your father would be eligible if he were still alive <ref> [33] </ref>. And McCarty, also motivated by legal applications, has developed a wide class of hypothetical rules for computer-based consultation systems, especially 121 systems for reasoning about corporate tax law and estate tax law [47, 49, 57].
Reference: 34. <author> A. Van Gelder, K.A. Ross, and J.S. Schlipf. </author> <title> The Well-Founded Semantics for General Logic Programs. </title> <journal> Journal of the ACM, </journal> <volume> 38(3) </volume> <pages> 620-650, </pages> <year> 1991. </year>
Reference-contexts: That is, it expresses all database queries in EXPTIME, both monotonic and non-monotonic. There has been considerable work in recent years on the semantics of negation-as-failure. Most of this work has focussed on Horn rulebases and the myriad problems created by recursion through negation <ref> [55, 35, 34, 64] </ref>. More recently, some researchers have focussed on the semantics of intuitionistic rulebases with negation [38, 52, 36, 26]. These works all focus on arbitrary (i:e:, non-stratified) rule-bases. Unfortunately, none of these semantics is suited to our needs, for several 123 reasons. <p> Locally stratified rulebases are perhaps the largest class of logic programs for which the semantics of negation is not controversial. Another approach to negation-as-failure attempts to define semantics for arbitrary Horn programs with negation. There have been numerous attempts here too. Perhaps the best known are the well-founded semantics <ref> [34, 64] </ref> and the stable model semantics [35]. Although these semantics offer different interpretations of recursion through negation, they are equivalent when rulebases are stratified or locally stratified. This section focuses on stratified rulebases, extending the theory of stratified negation from Horn rules to hypothetical rules. <p> Unlike the semantics presented in this paper, these proposals often provide a semantics of finite failure. Thus, in the special case of Horn rulebases, these works provide an alternative to much of the existing work on the semantics of negation <ref> [4, 55, 35, 34, 64] </ref>. One exception is the work of Dung [26], which proposes a stable model semantics for hypothetical insertion. Although no proof theory is presented, Dung's proposal allows arbitrary rulebases, stratified or unstratified.
Reference: 35. <author> M. Gelfond and V. Lifschitz. </author> <title> The Stable Model Semantics for Logic Programming. </title> <booktitle> In Proceedings of the Fifth Logic Programming Symposium, </booktitle> <pages> pages 1070-1080. </pages> <publisher> MIT Press, </publisher> <year> 1988. </year>
Reference-contexts: That is, it expresses all database queries in EXPTIME, both monotonic and non-monotonic. There has been considerable work in recent years on the semantics of negation-as-failure. Most of this work has focussed on Horn rulebases and the myriad problems created by recursion through negation <ref> [55, 35, 34, 64] </ref>. More recently, some researchers have focussed on the semantics of intuitionistic rulebases with negation [38, 52, 36, 26]. These works all focus on arbitrary (i:e:, non-stratified) rule-bases. Unfortunately, none of these semantics is suited to our needs, for several 123 reasons. <p> Another approach to negation-as-failure attempts to define semantics for arbitrary Horn programs with negation. There have been numerous attempts here too. Perhaps the best known are the well-founded semantics [34, 64] and the stable model semantics <ref> [35] </ref>. Although these semantics offer different interpretations of recursion through negation, they are equivalent when rulebases are stratified or locally stratified. This section focuses on stratified rulebases, extending the theory of stratified negation from Horn rules to hypothetical rules. <p> Unlike the semantics presented in this paper, these proposals often provide a semantics of finite failure. Thus, in the special case of Horn rulebases, these works provide an alternative to much of the existing work on the semantics of negation <ref> [4, 55, 35, 34, 64] </ref>. One exception is the work of Dung [26], which proposes a stable model semantics for hypothetical insertion. Although no proof theory is presented, Dung's proposal allows arbitrary rulebases, stratified or unstratified. <p> One exception is the work of Dung [26], which proposes a stable model semantics for hypothetical insertion. Although no proof theory is presented, Dung's proposal allows arbitrary rulebases, stratified or unstratified. In the special case of Horn rulebases, it is equivalent to the stable model semantics developed in <ref> [35] </ref>. In [52], Olivetti and Terracini present a three-valued modal semantics for the propositional case, and in [36], Giordano and Olivetti develop a three-valued fixpoint semantics for the predicate case. In both cases, the semantics is of finite failure in arbitrary rulebases. [36] also develops a practical SLD-style proof procedure.
Reference: 36. <author> L. Giordano and N. Olivetti. </author> <title> Negation as Failure in Intuitionistic Logic Programming. </title> <booktitle> In Proceedings of the Joint International Conference and Symposium on Logic Programming (JICSLP), </booktitle> <pages> pages 431-445, </pages> <address> Washington, D.C., 1992. </address> <publisher> MIT Press. </publisher>
Reference-contexts: There has been considerable work in recent years on the semantics of negation-as-failure. Most of this work has focussed on Horn rulebases and the myriad problems created by recursion through negation [55, 35, 34, 64]. More recently, some researchers have focussed on the semantics of intuitionistic rulebases with negation <ref> [38, 52, 36, 26] </ref>. These works all focus on arbitrary (i:e:, non-stratified) rule-bases. Unfortunately, none of these semantics is suited to our needs, for several 123 reasons. Foremost, intuitionistic logic models hypothetical insertion, not deletion. Moreover, most of these works focus on finite failure, whereas our logic uses infinite failure. <p> Researchers have also investigated the semantics of negation-as-failure for in-tuitionistic logic programming. Gabbay was the first to point out that negation-as-failure leads to logical paradoxes in an intuitionistic setting [32]. To overcome these paradoxes, some researchers distinguish two types of implication, denoted and ( <ref> [17, 52, 36] </ref>. The former corresponds to our own use of implication, and the latter corresponds to our operator of hypothetical insertion. In fact, the rule A (B ( C) is functionally identical to A B [add : C]. <p> The present paper extends and simplifies the results in [17] to include hypothetical deletion as well as insertion. Results on the computational complexity and expressibility of this semantics are presented in [10, 9, 7, 18, 11, 12]. There have also been proposals for a semantics of non-stratified intuitionistic rules <ref> [38, 52, 36, 26] </ref>. Following [50], these proposals each define a model as a mapping from a set of logic programs to a set of values. Unlike the semantics presented in this paper, these proposals often provide a semantics of finite failure. <p> Although no proof theory is presented, Dung's proposal allows arbitrary rulebases, stratified or unstratified. In the special case of Horn rulebases, it is equivalent to the stable model semantics developed in [35]. In [52], Olivetti and Terracini present a three-valued modal semantics for the propositional case, and in <ref> [36] </ref>, Giordano and Olivetti develop a three-valued fixpoint semantics for the predicate case. In both cases, the semantics is of finite failure in arbitrary rulebases. [36] also develops a practical SLD-style proof procedure. Under a syntactic restriction called allowedness, this procedure is sound and avoids floundering. <p> In [52], Olivetti and Terracini present a three-valued modal semantics for the propositional case, and in <ref> [36] </ref>, Giordano and Olivetti develop a three-valued fixpoint semantics for the predicate case. In both cases, the semantics is of finite failure in arbitrary rulebases. [36] also develops a practical SLD-style proof procedure. Under a syntactic restriction called allowedness, this procedure is sound and avoids floundering. Unfortunately, this restriction is rather conservative, and it disallows many programs that are not really problematic, including many non-recursive programs. <p> Unfortunately, this restriction is rather conservative, and it disallows many programs that are not really problematic, including many non-recursive programs. A detailed comparison of their work and our semantics of stratified intuitionistic rules [17] can be found in <ref> [36] </ref>. In [38], Harland develops a semantics in which predicates are labeled as "completely defined" or "incompletely defined" [38].
Reference: 37. <author> D. Harel. </author> <title> First-Order Dynamic Logic, </title> <booktitle> volume 68 of Lecture Notes in Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1979. </year>
Reference-contexts: Nevertheless, the three systems are very different. In EKS, the semantics is purely operational. The emphasis here has been on implementation, not on logical foundations. In Dynamic Prolog, the semantics is based on Dynamic Logic <ref> [37] </ref>. Unlike Hypothetical Datalog, in which all predicates and rules have equal status, Dynamic Prolog distinguishes many types of predicates and rules.
Reference: 38. <author> J. Harland. </author> <title> A Kripke-like model for negation as failure. </title> <booktitle> In Proceedings of the North American Conference on Logic Programming (NACLP), </booktitle> <pages> pages 626-642, </pages> <address> Cleveland, Ohio, October 1989. </address> <publisher> MIT Press. </publisher>
Reference-contexts: There has been considerable work in recent years on the semantics of negation-as-failure. Most of this work has focussed on Horn rulebases and the myriad problems created by recursion through negation [55, 35, 34, 64]. More recently, some researchers have focussed on the semantics of intuitionistic rulebases with negation <ref> [38, 52, 36, 26] </ref>. These works all focus on arbitrary (i:e:, non-stratified) rule-bases. Unfortunately, none of these semantics is suited to our needs, for several 123 reasons. Foremost, intuitionistic logic models hypothetical insertion, not deletion. Moreover, most of these works focus on finite failure, whereas our logic uses infinite failure. <p> In general, these proposals are not restricted to stratified rulebases, although other syntactic restrictions are often imposed, either in the model theory or in the proof theory. Unfortunately, these restrictions often preclude many stratified rulebases, including many of the examples in this section. For example, in <ref> [38] </ref>, Harland develops a semantics for hypothetical insertions with negation-as-failure. Example 5.5 above highlights the differences between Harland's treatment and our own. Har-land's approach does not depend on stratification, and assigns a meaning even to the rule: A A. <p> The present paper extends and simplifies the results in [17] to include hypothetical deletion as well as insertion. Results on the computational complexity and expressibility of this semantics are presented in [10, 9, 7, 18, 11, 12]. There have also been proposals for a semantics of non-stratified intuitionistic rules <ref> [38, 52, 36, 26] </ref>. Following [50], these proposals each define a model as a mapping from a set of logic programs to a set of values. Unlike the semantics presented in this paper, these proposals often provide a semantics of finite failure. <p> Unfortunately, this restriction is rather conservative, and it disallows many programs that are not really problematic, including many non-recursive programs. A detailed comparison of their work and our semantics of stratified intuitionistic rules [17] can be found in [36]. In <ref> [38] </ref>, Harland develops a semantics in which predicates are labeled as "completely defined" or "incompletely defined" [38]. <p> A detailed comparison of their work and our semantics of stratified intuitionistic rules [17] can be found in [36]. In <ref> [38] </ref>, Harland develops a semantics in which predicates are labeled as "completely defined" or "incompletely defined" [38]. Unfortunately, restrictions on the labeling preclude many stratified programs, such as the rulebase in Example 5.5, and the rulebases used to achieve the expressibility results of [10, 9, 7, 18, 11, 12], as discussed in Section 5.4. The rules in Example 5.1 cause no such problems however.
Reference: 39. <author> Richard Hull and Jianwen Su. </author> <title> On the Expressive Power of Database Queries with Intermediate Types. </title> <booktitle> In Proceedings of the ACM Symposium on the Principles of Database Systems (PODS), </booktitle> <pages> pages 39-51, </pages> <address> Austin, Texas, </address> <month> March </month> <year> 1988. </year>
Reference-contexts: The expressibility of a query language is therefore the set of mappings that the language represents. Many expressibility results based on this idea have appeared in the literature <ref> [3, 21, 22, 40, 2, 1, 39] </ref>, and we have established numerous results of this kind using Hypothetical Datalog as a query language [10, 9, 7, 18, 11, 12]. However, hypothetical queries lead naturally to a generalized notion of expressibility, one that is appropriate for deductive databases and rule-based systems.
Reference: 40. <author> N. Immerman. </author> <title> Relational Queries Computable in Polynomial Time. </title> <booktitle> In Proceedings 170 of the ACM Symposium on Theory of Computing (STOC), </booktitle> <pages> pages 147-152, </pages> <year> 1982. </year>
Reference-contexts: The expressibility of a query language is therefore the set of mappings that the language represents. Many expressibility results based on this idea have appeared in the literature <ref> [3, 21, 22, 40, 2, 1, 39] </ref>, and we have established numerous results of this kind using Hypothetical Datalog as a query language [10, 9, 7, 18, 11, 12]. However, hypothetical queries lead naturally to a generalized notion of expressibility, one that is appropriate for deductive databases and rule-based systems.
Reference: 41. <editor> R.H. Sprague Jr. and H.J. Watson, editors. </editor> <title> Decisions Support Systems: Putting Theory into Practice. </title> <publisher> Prentice Hall, </publisher> <address> Englewood Cliffs, NJ, </address> <year> 1989. </year>
Reference-contexts: 1. INTRODUCTION Researchers from several areas have recognized the need for computer systems that reason hypothetically. Decision support systems (DSS) are a good example, especially in domains like financial planning where many "what if" scenarios must be considered <ref> [41, 53] </ref>. A typical example is an analyst who must predict a company's deficit for the upcoming year assuming that employee salaries are increased by a given percentage. Or he might want a table of deficit predictions for a number of hypothetical salary increases [66, 67].
Reference: 42. <author> H. Katsuno and A.O. Mendelzon. </author> <title> On the difference between updating a knowledge database and revising it. </title> <booktitle> In Proceedings of the International Conference on Knowledge Representation and Reasoning (KR), </booktitle> <pages> pages 387-394, </pages> <address> Boston, Mass., </address> <month> April </month> <year> 1991. </year>
Reference-contexts: Much of the remaining work on logic and updates can be divided into three classes: (i) elementary updates to arbitrary logical theories, (ii) complex updates 166 to relational databases, and (iii) intuitionistic logic programming. We shall look at each class in turn. The first class of work includes <ref> [69, 42, 28, 27, 56] </ref>. This work focuses on the semantics of elementary updates to complex theories. Our work is distinct from this class in two ways. First, we are concerned with combining elementary updates into complex hypothetical queries.
Reference: 43. <author> A.M. Keller. </author> <title> Updates to relational databases through views involving joins. </title> <editor> In P. Scheuermann, editor, </editor> <booktitle> Improving Database Usability and Responsiveness, </booktitle> <pages> pages 363-384. </pages> <publisher> Academic Press, </publisher> <year> 1982. </year>
Reference-contexts: Update operators act only on the stored data. That is, [add : C] adds the atom C to the stored data, and [del : C] deletes C from the stored data. Since derived data is never updated directly, we avoid the difficult view-update problem <ref> [27, 28, 25, 6, 31, 43] </ref>. Like classical and intuitionistic logics, Hypothetical Datalog does not distinguish between different sorts of predicates, such as base and derived predicates. Of course, predicates can always be divided into sorts, as an option, but it is not imposed by the theory.
Reference: 44. <author> S. Manchanda and D.S. Warren. </author> <title> A Logic-based Language for Database Updates. </title> <editor> In Jack Minker, editor, </editor> <booktitle> Foundations of Deductive Databases and Logic Programming, chapter 10, </booktitle> <pages> pages 363-394. </pages> <publisher> Morgan Kaufmann, </publisher> <year> 1988. </year>
Reference-contexts: Vieille, et al, for instance, have developed a deductive database along these lines [66, 67], and Warren and Manchanda have used hypothetical rules to reason about database updates <ref> [68, 44] </ref>. In [50], Miller shows that hypothetical insertions can structure the runtime environment of logic programs, resulting in programs that are more elegant, more efficient, and easier to maintain. In [51], he develops a theory of lexical scoping based on the hypothetical creation of constant symbols during inference. <p> The result then follows by Lemma 6.2. 2 7. RELATED WORK There has been considerable work in the area of logic and updates. The logical systems that are the closest to Hypothetical Datalog are Dynamic Prolog, developed by Manchanda and Warren <ref> [45, 44, 68] </ref>, and EKS, developed by Vieille, et al [66, 67]. All three systems deal with both insertion and deletion, and in all three, updates take place on base facts, not derived facts. Nevertheless, the three systems are very different. In EKS, the semantics is purely operational.
Reference: 45. <author> Sanjay Manchanda. </author> <title> A Dynamic Logic Programming Language for Relational Updates. </title> <type> PhD thesis, </type> <institution> Department of Computer Science, State University of New York at Stony Brook, Stony Brook, </institution> <address> New York, </address> <month> December </month> <year> 1987. </year> <note> Also published as Technical Report TR 88-2, </note> <institution> Department of Computer Science, The University of Arizona, Tuscon, Arizona 85721, </institution> <month> January, </month> <year> 1988. </year>
Reference-contexts: The result then follows by Lemma 6.2. 2 7. RELATED WORK There has been considerable work in the area of logic and updates. The logical systems that are the closest to Hypothetical Datalog are Dynamic Prolog, developed by Manchanda and Warren <ref> [45, 44, 68] </ref>, and EKS, developed by Vieille, et al [66, 67]. All three systems deal with both insertion and deletion, and in all three, updates take place on base facts, not derived facts. Nevertheless, the three systems are very different. In EKS, the semantics is purely operational.
Reference: 46. <author> J.M. McCarthy and P.J. Hayes. </author> <title> Some philosophical problems from the standpoint of artificial intelligence. </title> <editor> In B. Meltzer and D. Michie, editors, </editor> <booktitle> Machine Intelligence, </booktitle> <volume> volume 4, </volume> <pages> pages 463-502. </pages> <publisher> Edinburgh University Press, </publisher> <year> 1969. </year> <note> Reprinted in Readings in Artificial Intelligence, </note> <year> 1981, </year> <title> Tioga Publ. </title> <publisher> Co. </publisher>
Reference-contexts: Second, we are concerned with relational databases (sets of ground atomic formulas). In this context, elementary updates pose no conceptual problems, as can be seen from Definitions 3.3 and 4.3. In particular, the infamous frame problem of Artificial Intelligence does not arise <ref> [46, 56] </ref>. It should be possible to extend Hypothetical Datalog to include any set of elementary updates, not just insertion and deletion, and any set of databases, not just relational. In this sense, our work is orthogonal to work on the logical semantics of elementary updates.
Reference: 47. <author> L.T. McCarty. </author> <title> Clausal Intuitionistic Logic. I. Fixed-Point Semantics. </title> <journal> Journal of Logic Programming (JLP), </journal> <volume> 5(1) </volume> <pages> 1-31, </pages> <year> 1988. </year>
Reference-contexts: And McCarty, also motivated by legal applications, has developed a wide class of hypothetical rules for computer-based consultation systems, especially 121 systems for reasoning about corporate tax law and estate tax law <ref> [47, 49, 57] </ref>. Theoretical work on hypothetical inference has also been carried out, largely by the logic-programming community. Most of this work focuses on the hypothetical insertion of atoms into a database. <p> Gab-bay was the first to show that intuitionistic logic models hypothetical insertion [32]. Working independently, McCarty and Miller extended this result to operations that create new constant symbols during inference, and they developed fixpoint semantics based on intuitionistic logic <ref> [47, 50] </ref>. Earlier, Statman showed that inference in intuitionistic logic is PSPACE-complete in the propositional case [59]. In [10, 11], we show that the complexity of answering queries with hypothetical insertions is PSPACE-complete in the function-free predicate case (i:e:, the case of greatest interest to databases systems). <p> Hypothetical Deletion So far, we have only looked at hypothetical insertion. This was enough to show that classical logic is inadequate for hypothetical reasoning. As mentioned above, intuitionistic logic is the correct way to formalize hypothetical insertion <ref> [32, 47, 50, 8, 18, 12] </ref>. However, even intuitionistic logic does not model hypothetical deletion. In fact, we shall see in this subsection that no reasonable first-order logic can do this. We then consider some alternatives. <p> Gab-bay was the first to show that intuitionistic logic models hypothetical insertion [32]. Working independently, McCarty and Miller extended this result to operations that create new constant symbols during inference, and they developed fixpoint semantics based on intuitionistic logic <ref> [47, 50] </ref>. Earlier, Statman showed that inference in intuitionistic logic is PSPACE-complete in the propositional case [59]. In [10, 11], we showed that the complexity of answering queries with hypothetical insertions is PSPACE-complete in the function-free predicate case (i:e:, the databases case).
Reference: 48. <author> L.T. McCarty. </author> <title> Clausal Intuitionistic Logic. II. Tableau Proof Procedures. </title> <journal> Journal of Logic Programming (JLP), </journal> <volume> 5(2) </volume> <pages> 93-132, </pages> <year> 1988. </year>
Reference-contexts: premise true?, i:e:, which instantiation of C (X) should we delete from the database? Must we test all possible instantiations? This problem has been partially solved by McCarty, who has developed an SLD-style proof procedure for hypothetical insertions, a proof procedure based on top-down inference and unification, as in Prolog <ref> [48] </ref>. For hypothetical deletions, a simple syntactic restriction suffices. The idea is to ensure that all variables are bound to values in the database during inference. This can be done in several ways.
Reference: 49. <author> L.T. McCarty. </author> <title> A Language for Legal Discourse. I. Basic Features. </title> <booktitle> In Proceedings of the Second International Conference on Artificial Intelligence and Law, </booktitle> <pages> pages 180-189. </pages> <publisher> ACM Press, </publisher> <month> June </month> <year> 1989. </year>
Reference-contexts: And McCarty, also motivated by legal applications, has developed a wide class of hypothetical rules for computer-based consultation systems, especially 121 systems for reasoning about corporate tax law and estate tax law <ref> [47, 49, 57] </ref>. Theoretical work on hypothetical inference has also been carried out, largely by the logic-programming community. Most of this work focuses on the hypothetical insertion of atoms into a database.
Reference: 50. <author> D. Miller. </author> <title> A Logical Analysis of Modules in Logic Programming. </title> <journal> Journal of Logic Programming (JLP), </journal> <volume> 6 </volume> <pages> 79-108, </pages> <year> 1989. </year>
Reference-contexts: Vieille, et al, for instance, have developed a deductive database along these lines [66, 67], and Warren and Manchanda have used hypothetical rules to reason about database updates [68, 44]. In <ref> [50] </ref>, Miller shows that hypothetical insertions can structure the runtime environment of logic programs, resulting in programs that are more elegant, more efficient, and easier to maintain. In [51], he develops a theory of lexical scoping based on the hypothetical creation of constant symbols during inference. <p> Gab-bay was the first to show that intuitionistic logic models hypothetical insertion [32]. Working independently, McCarty and Miller extended this result to operations that create new constant symbols during inference, and they developed fixpoint semantics based on intuitionistic logic <ref> [47, 50] </ref>. Earlier, Statman showed that inference in intuitionistic logic is PSPACE-complete in the propositional case [59]. In [10, 11], we show that the complexity of answering queries with hypothetical insertions is PSPACE-complete in the function-free predicate case (i:e:, the case of greatest interest to databases systems). <p> Hypothetical Deletion So far, we have only looked at hypothetical insertion. This was enough to show that classical logic is inadequate for hypothetical reasoning. As mentioned above, intuitionistic logic is the correct way to formalize hypothetical insertion <ref> [32, 47, 50, 8, 18, 12] </ref>. However, even intuitionistic logic does not model hypothetical deletion. In fact, we shall see in this subsection that no reasonable first-order logic can do this. We then consider some alternatives. <p> Finally, it is worth pointing out, that like the models of this section, the canonical intuitionistic model developed in [11, 7] is essentially a mapping from databases to databases. In a similar fashion, the specialized intuitionistic models developed in <ref> [50] </ref> and [18] are mappings from rulebases to databases. This section builds upon and extends this tradition. The development here builds especially upon ideas introduced in [10]. For instance, the idea of interpreting a rulebase as a mapping, and the definition of a hypothetical T-operator were both used in [10]. <p> Gab-bay was the first to show that intuitionistic logic models hypothetical insertion [32]. Working independently, McCarty and Miller extended this result to operations that create new constant symbols during inference, and they developed fixpoint semantics based on intuitionistic logic <ref> [47, 50] </ref>. Earlier, Statman showed that inference in intuitionistic logic is PSPACE-complete in the propositional case [59]. In [10, 11], we showed that the complexity of answering queries with hypothetical insertions is PSPACE-complete in the function-free predicate case (i:e:, the databases case). <p> Results on the computational complexity and expressibility of this semantics are presented in [10, 9, 7, 18, 11, 12]. There have also been proposals for a semantics of non-stratified intuitionistic rules [38, 52, 36, 26]. Following <ref> [50] </ref>, these proposals each define a model as a mapping from a set of logic programs to a set of values. Unlike the semantics presented in this paper, these proposals often provide a semantics of finite failure.
Reference: 51. <author> D. Miller. </author> <title> Lexical scoping as universal quantification. </title> <editor> In G. Levi and M. Martelli, editors, </editor> <booktitle> Logic Programming: Proceedings of the Sixth International Conference, </booktitle> <pages> pages 268-283, </pages> <address> Cambridge, MA, 1989. </address> <publisher> MIT Press. </publisher>
Reference-contexts: In [50], Miller shows that hypothetical insertions can structure the runtime environment of logic programs, resulting in programs that are more elegant, more efficient, and easier to maintain. In <ref> [51] </ref>, he develops a theory of lexical scoping based on the hypothetical creation of constant symbols during inference. These logical systems are well suited to solving problems in Artificial Intelligence, especially problems that involve reasoning about alternative courses of action.
Reference: 52. <author> N. Olivetti and L. Terracini. </author> <title> N-Prolog and Equivalence of Logic Programs (Part 1). </title> <journal> Journal Of Logic, Language and Information, </journal> <volume> 1(4) </volume> <pages> 253-340, </pages> <year> 1992. </year>
Reference-contexts: There has been considerable work in recent years on the semantics of negation-as-failure. Most of this work has focussed on Horn rulebases and the myriad problems created by recursion through negation [55, 35, 34, 64]. More recently, some researchers have focussed on the semantics of intuitionistic rulebases with negation <ref> [38, 52, 36, 26] </ref>. These works all focus on arbitrary (i:e:, non-stratified) rule-bases. Unfortunately, none of these semantics is suited to our needs, for several 123 reasons. Foremost, intuitionistic logic models hypothetical insertion, not deletion. Moreover, most of these works focus on finite failure, whereas our logic uses infinite failure. <p> Researchers have also investigated the semantics of negation-as-failure for in-tuitionistic logic programming. Gabbay was the first to point out that negation-as-failure leads to logical paradoxes in an intuitionistic setting [32]. To overcome these paradoxes, some researchers distinguish two types of implication, denoted and ( <ref> [17, 52, 36] </ref>. The former corresponds to our own use of implication, and the latter corresponds to our operator of hypothetical insertion. In fact, the rule A (B ( C) is functionally identical to A B [add : C]. <p> The present paper extends and simplifies the results in [17] to include hypothetical deletion as well as insertion. Results on the computational complexity and expressibility of this semantics are presented in [10, 9, 7, 18, 11, 12]. There have also been proposals for a semantics of non-stratified intuitionistic rules <ref> [38, 52, 36, 26] </ref>. Following [50], these proposals each define a model as a mapping from a set of logic programs to a set of values. Unlike the semantics presented in this paper, these proposals often provide a semantics of finite failure. <p> Although no proof theory is presented, Dung's proposal allows arbitrary rulebases, stratified or unstratified. In the special case of Horn rulebases, it is equivalent to the stable model semantics developed in [35]. In <ref> [52] </ref>, Olivetti and Terracini present a three-valued modal semantics for the propositional case, and in [36], Giordano and Olivetti develop a three-valued fixpoint semantics for the predicate case. In both cases, the semantics is of finite failure in arbitrary rulebases. [36] also develops a practical SLD-style proof procedure.
Reference: 53. <author> R.L. Olson and R.H. Sprague Jr. </author> <title> Financial Planning in Action. </title> <editor> In R.H. Sprague Jr. and H.J. Watson, editors, </editor> <booktitle> Decisions Support Systems: Putting Theory into Practice, </booktitle> <pages> pages 373-381. </pages> <publisher> Prentice Hall, </publisher> <address> Englewood Cliffs, NJ, </address> <year> 1989. </year>
Reference-contexts: 1. INTRODUCTION Researchers from several areas have recognized the need for computer systems that reason hypothetically. Decision support systems (DSS) are a good example, especially in domains like financial planning where many "what if" scenarios must be considered <ref> [41, 53] </ref>. A typical example is an analyst who must predict a company's deficit for the upcoming year assuming that employee salaries are increased by a given percentage. Or he might want a table of deficit predictions for a number of hypothetical salary increases [66, 67].
Reference: 54. <author> G. Phipps, M.A. Derr, and K.A. Ross. </author> <title> Glue-Nail: A deductive database system. </title> <booktitle> In Proceedings of the ACM SIGMOD International Conference on Management of Data, </booktitle> <pages> pages 308-317, </pages> <year> 1991. </year>
Reference-contexts: In this sense, our work is orthogonal to work on the logical semantics of elementary updates. This idea has been adopted in the development of Transaction Logic [14, 13, 16, 15]. The second class of work includes <ref> [2, 1, 24, 23, 54] </ref>. Like Hypothetical Datalog, these systems are primarily concerned with relational databases, and with combining elementary updates into complex updates. However, these systems deal with committed updates, not with hypothetical queries.
Reference: 55. <author> T. Przymusinski. </author> <title> On the Declarative Semantics of Deductive Databases and Logic Programs. </title> <editor> In Jack Minker, editor, </editor> <booktitle> Foundations of Deductive Databases and Logic Programming, chapter 5, </booktitle> <pages> pages 193-216. </pages> <publisher> Morgan Kaufmann, </publisher> <year> 1988. </year>
Reference-contexts: That is, it expresses all database queries in EXPTIME, both monotonic and non-monotonic. There has been considerable work in recent years on the semantics of negation-as-failure. Most of this work has focussed on Horn rulebases and the myriad problems created by recursion through negation <ref> [55, 35, 34, 64] </ref>. More recently, some researchers have focussed on the semantics of intuitionistic rulebases with negation [38, 52, 36, 26]. These works all focus on arbitrary (i:e:, non-stratified) rule-bases. Unfortunately, none of these semantics is suited to our needs, for several 123 reasons. <p> We then develop the proof theory and model theory for the augmented logic. The proof theory is inspired by the stratified semantics of Apt, Blair and Walker [4], and the model theory is inspired by the perfect model semantics of Przymusinski <ref> [55] </ref>. As is the classical case, we show that every stratified hypothetical rulebase has a single perfect model. Nothing in the development depends on any finiteness assumptions, so all quantities may be infinite: the database, the rulebase, the set of constant symbols, and even the number of strata. 2. <p> In this way, recursion never occurs through a negated premise and the semantics of negation is always well-defined. Another approach has been to allow limited recursion through negation. This approach generalizes the notion of stratification to local stratification <ref> [55] </ref>. Intuitively, 152 a rulebase is locally stratified if its ground instantiation is stratified (with possibly infinitely-many strata). Locally stratified rulebases are perhaps the largest class of logic programs for which the semantics of negation is not controversial. <p> We then develop the proof theory and model theory for stratified rulebases. The proof theory is based on the stratified semantics of Apt, Blair and Walker [4], and the model theory is based on the perfect model semantics of Przymusinski <ref> [55] </ref>. By combining and extending these two traditions, we achieve a semantics that does not depend on any finiteness assumptions. Thus, all quantities may be infinite: the database, the rulebase, the set of constant symbols, and even the number of strata. The following example is adapted from [17]. <p> A Special Case In the case of stratified Horn rules, the semantics developed above reduce to the semantics of Apt, Blair and Walker [4] and of Przymusinski <ref> [55] </ref>. It is worth noting, however, that these semantics differ from the semantics of Prolog in a special case: for rules of the form A B (X). Because of the possibility of floundering, Prolog gives such rules a special interpretation. <p> In this respect, our semantics treats Horn rules with negation in the same way that classical logic programming does. However, our semantics, like those of [4] and <ref> [55] </ref>, differ from the semantics of Prolog in one respect: in Prolog, rules such as A C (Y ) are given a special interpretation. <p> Conceptually, then, the proof-theoretic semantics described in Section 5.2 provides a uniform interpretation of stratified rulebases. In the special case of stratified Horn rulebases, this semantics is equivalent to others in the literature <ref> [4, 55] </ref>. In the very special case of unguarded Horn rules, this semantics can be translated into the semantics of Prolog in a straightforward way. 5.4. Examples With negation-as-failure and hypothetical updates, it is possible to write simple rulebases that solve complex problems, as the examples of this section illustrate. <p> When negation is introduced, new devices are needed to account for the non-monotonicity of the resulting system. A common approach, due to Przymusinski, is to introduce a preference relation on the classical models of a rulebase, and then to focus on the most preferred, or perfect, models <ref> [55] </ref>. We extend this idea to hypothetical rulebases and hypothetical structures. The first step is to define what it means for a hypothetical structure to be a model of a rule with negated premises. It is a simple matter to extend the definitions of Section 4.1 to include such rules. <p> Unlike the semantics presented in this paper, these proposals often provide a semantics of finite failure. Thus, in the special case of Horn rulebases, these works provide an alternative to much of the existing work on the semantics of negation <ref> [4, 55, 35, 34, 64] </ref>. One exception is the work of Dung [26], which proposes a stable model semantics for hypothetical insertion. Although no proof theory is presented, Dung's proposal allows arbitrary rulebases, stratified or unstratified.
Reference: 56. <author> R. Reiter. </author> <title> On formalizing database updates: Preliminary report. </title> <booktitle> In Proceedings of the International Conference on Extending Database Technology (EDBT), </booktitle> <month> March </month> <year> 1992. </year>
Reference-contexts: Much of the remaining work on logic and updates can be divided into three classes: (i) elementary updates to arbitrary logical theories, (ii) complex updates 166 to relational databases, and (iii) intuitionistic logic programming. We shall look at each class in turn. The first class of work includes <ref> [69, 42, 28, 27, 56] </ref>. This work focuses on the semantics of elementary updates to complex theories. Our work is distinct from this class in two ways. First, we are concerned with combining elementary updates into complex hypothetical queries. <p> Second, we are concerned with relational databases (sets of ground atomic formulas). In this context, elementary updates pose no conceptual problems, as can be seen from Definitions 3.3 and 4.3. In particular, the infamous frame problem of Artificial Intelligence does not arise <ref> [46, 56] </ref>. It should be possible to extend Hypothetical Datalog to include any set of elementary updates, not just insertion and deletion, and any set of databases, not just relational. In this sense, our work is orthogonal to work on the logical semantics of elementary updates.
Reference: 57. <author> D.A. Schlobohm and L.T. McCarty. EPS-II: </author> <title> Estate planning with prototypes. </title> <booktitle> In Proceedings of the Second International Conference on Artificial Intelligence and Law, </booktitle> <pages> pages 1-10. </pages> <publisher> ACM Press, </publisher> <month> June </month> <year> 1989. </year>
Reference-contexts: And McCarty, also motivated by legal applications, has developed a wide class of hypothetical rules for computer-based consultation systems, especially 121 systems for reasoning about corporate tax law and estate tax law <ref> [47, 49, 57] </ref>. Theoretical work on hypothetical inference has also been carried out, largely by the logic-programming community. Most of this work focuses on the hypothetical insertion of atoms into a database.
Reference: 58. <editor> Editor: A.P. Sheth. </editor> <booktitle> Database Research at Bellcore. SIGMOD Record, </booktitle> <volume> 19(3) </volume> <pages> 45-52, </pages> <month> September </month> <year> 1990. </year> <month> 171 </month>
Reference-contexts: Or he might want a table of deficit predictions for a number of hypothetical salary increases [66, 67]. Similar problems occur in computer aided design (CAD). Here, one must evaluate the effect on the overall design of local design alternatives and of various external factors <ref> [30, 58] </ref>. For example, an engineer may need to know how much the price of an automobile would increase if supplier X raised his prices by Y percent [30]. The number of hypothetical scenarios multiplies quickly when several factors are varied simultaneously, such as prices, interest rates, tax rates, etc.
Reference: 59. <author> R. Statman. </author> <title> Intuitionistic Propositional Logic is Polynomial-Space Complete. </title> <journal> Theoretical Computer Science (TCS), </journal> <volume> 9(1) </volume> <pages> 67-72, </pages> <year> 1979. </year>
Reference-contexts: Working independently, McCarty and Miller extended this result to operations that create new constant symbols during inference, and they developed fixpoint semantics based on intuitionistic logic [47, 50]. Earlier, Statman showed that inference in intuitionistic logic is PSPACE-complete in the propositional case <ref> [59] </ref>. In [10, 11], we show that the complexity of answering queries with hypothetical insertions is PSPACE-complete in the function-free predicate case (i:e:, the case of greatest interest to databases systems). In [10], we introduced a logic called Hypothetical Datalog that performs hypothetical deletion as well as insertion. <p> Working independently, McCarty and Miller extended this result to operations that create new constant symbols during inference, and they developed fixpoint semantics based on intuitionistic logic [47, 50]. Earlier, Statman showed that inference in intuitionistic logic is PSPACE-complete in the propositional case <ref> [59] </ref>. In [10, 11], we showed that the complexity of answering queries with hypothetical insertions is PSPACE-complete in the function-free predicate case (i:e:, the databases case). Researchers have also investigated the semantics of negation-as-failure for in-tuitionistic logic programming.
Reference: 60. <author> M. Stonebraker. </author> <title> Hypothetical databases as views. </title> <booktitle> In Proceedings of the ACM SIGMOD International Conference on Management of Data, </booktitle> <pages> pages 224-229, </pages> <year> 1981. </year>
Reference-contexts: Hypothetical databases are derived from a real database by a series of hypothetical assumptions, or updates. Early work in this area was done by Stone-braker, who showed that hypothetical databases can be efficiently implemented by slight extensions to conventional database mechanisms <ref> [61, 60] </ref>. He pointed out that hypothetical databases are useful for debugging purposes, for generating test data, and for carrying out a variety of simulations. He also argued that "there are advantages to making hypothetical databases central to the operation of a database management system" [60]. <p> He pointed out that hypothetical databases are useful for debugging purposes, for generating test data, and for carrying out a variety of simulations. He also argued that "there are advantages to making hypothetical databases central to the operation of a database management system" <ref> [60] </ref>. The logic-programming community has taken these ideas one step further, integrating hypothetical updates not just with query processing, but with logical inference as well.
Reference: 61. <author> M. Stonebraker and K. Keller. </author> <title> Embedding expert knowledge and hypothetical databases into a data base system. </title> <booktitle> In Proceedings of the ACM SIGMOD International Conference on Management of Data, </booktitle> <pages> pages 58-66, </pages> <address> Santa Monica, CA, </address> <year> 1980. </year>
Reference-contexts: Hypothetical databases are derived from a real database by a series of hypothetical assumptions, or updates. Early work in this area was done by Stone-braker, who showed that hypothetical databases can be efficiently implemented by slight extensions to conventional database mechanisms <ref> [61, 60] </ref>. He pointed out that hypothetical databases are useful for debugging purposes, for generating test data, and for carrying out a variety of simulations. He also argued that "there are advantages to making hypothetical databases central to the operation of a database management system" [60].
Reference: 62. <author> A. Tarski. </author> <title> A Lattice-Theoretical Fixpoint Theorem and its Applications. </title> <journal> Pacific Journal of Mathematics, </journal> <volume> 5 </volume> <pages> 285-309, </pages> <year> 1955. </year>
Reference-contexts: Follows immediately from Lemma 4.7. 2 Since T R is a monotonic operator on a complete lattice, the meet of any of its fixpoints is also a fixpoint. This result, which generalizes the model intersection property of Horn clause logic [63, 5], follows immediately by the Tarski fixpoint theorem <ref> [62] </ref>. As a special case, the meet of all the fixpoints of T R is itself a fixpoint of T R , the least fixpoint. We thus have the following result. 149 Theorem 4.10 Least Fixpoint. The operator T R has a least fixpoint lfp (T R ). <p> The main result of this section is that this sequence converges to the least fixpoint of T R , as stated in the next theorem. This result follows from the monotonicity and continuity of the operator T R , as originally shown by Tarski <ref> [62] </ref>. Theorem 4.16. lfp (T R ) = T fl R (I). 5. NEGATION AS FAILURE In [10, 11], it is shown that the inference system of Definition 3.3 has a data complexity that is EXPTIME-complete.
Reference: 63. <author> M.H. Van Emden and R.A. Kowalski. </author> <title> The Semantics of Predicate Logic as a Programming Language. </title> <journal> Journal of the ACM, </journal> <volume> 23(4) </volume> <pages> 733-742, </pages> <year> 1976. </year>
Reference-contexts: In this case, the inference system of Section 3.1 is classical, and we can appeal to the classical model theory of Horn rules <ref> [5, 63] </ref>. According to this theory, a Horn rulebase R and a database DB have a unique minimal model, or least fixpoint, which we denote lfp (R + DB ). Furthermore R; DB ` B if and only if B 2 lfp (R + DB ). <p> We show that every rulebase has a unique minimal model, which can be constructed in a bottom-up fashion by repeated application of a T operator. The development follows the approach originally introduced by Apt, Van Emden and Kowalski <ref> [63, 5] </ref>, which is now standard in logic programming. First, we define a lattice of structures. Then, we define an operator on this lattice, and show that it is monotonic and continuous. Finally, we invoke the Tarski fixpoint theorem. <p> Proof. Follows immediately from Lemma 4.7. 2 Since T R is a monotonic operator on a complete lattice, the meet of any of its fixpoints is also a fixpoint. This result, which generalizes the model intersection property of Horn clause logic <ref> [63, 5] </ref>, follows immediately by the Tarski fixpoint theorem [62]. As a special case, the meet of all the fixpoints of T R is itself a fixpoint of T R , the least fixpoint. We thus have the following result. 149 Theorem 4.10 Least Fixpoint.
Reference: 64. <author> A. Van Gelder, K.A. Ross, and J.S. Schlipf. </author> <title> Unfounded sets and well-founded semantics for general logic programs. </title> <booktitle> In Proceedings of the ACM Symposium on the Principles of Database Systems (PODS), </booktitle> <pages> pages 221-230, </pages> <month> March </month> <year> 1988. </year>
Reference-contexts: That is, it expresses all database queries in EXPTIME, both monotonic and non-monotonic. There has been considerable work in recent years on the semantics of negation-as-failure. Most of this work has focussed on Horn rulebases and the myriad problems created by recursion through negation <ref> [55, 35, 34, 64] </ref>. More recently, some researchers have focussed on the semantics of intuitionistic rulebases with negation [38, 52, 36, 26]. These works all focus on arbitrary (i:e:, non-stratified) rule-bases. Unfortunately, none of these semantics is suited to our needs, for several 123 reasons. <p> Locally stratified rulebases are perhaps the largest class of logic programs for which the semantics of negation is not controversial. Another approach to negation-as-failure attempts to define semantics for arbitrary Horn programs with negation. There have been numerous attempts here too. Perhaps the best known are the well-founded semantics <ref> [34, 64] </ref> and the stable model semantics [35]. Although these semantics offer different interpretations of recursion through negation, they are equivalent when rulebases are stratified or locally stratified. This section focuses on stratified rulebases, extending the theory of stratified negation from Horn rules to hypothetical rules. <p> Unlike the semantics presented in this paper, these proposals often provide a semantics of finite failure. Thus, in the special case of Horn rulebases, these works provide an alternative to much of the existing work on the semantics of negation <ref> [4, 55, 35, 34, 64] </ref>. One exception is the work of Dung [26], which proposes a stable model semantics for hypothetical insertion. Although no proof theory is presented, Dung's proposal allows arbitrary rulebases, stratified or unstratified.
Reference: 65. <author> M. Vardi. </author> <title> The Complexity of Relational Query Languages. </title> <booktitle> In Proceedings of the ACM Symposium on Theory of Computing (STOC), </booktitle> <pages> pages 137-146, </pages> <year> 1982. </year>
Reference-contexts: (a 2 ; a 3 ); :::; NEXT (a n ; a n+1 ); FIRST (a 1 ); LAST (a n+1 ): 9 Informally, the data complexity of an inference system is the complexity of inference when the rulebase and query are fixed and the database varies (acts as input) <ref> [21, 65] </ref>. 141 where a n+1 is an extra constant symbol, introduced to simplify the construction of the rulebase. (In Section 5.4, we shall see that negation-as-failure permits us to do away with this linear order.) Let DB be a database that encodes the circuit and orders the inputs in this
Reference: 66. <author> L. Vieille, P. Bayer, V. Kuchenhoff, and A. Lefebvre. EKS-V1, </author> <title> A Short Overview. </title> <booktitle> Presented at the AAAI-90 Workshop on Knowledge Base Management Systems, </booktitle> <address> July 1990, Boston, USA. </address>
Reference-contexts: A typical example is an analyst who must predict a company's deficit for the upcoming year assuming that employee salaries are increased by a given percentage. Or he might want a table of deficit predictions for a number of hypothetical salary increases <ref> [66, 67] </ref>. Similar problems occur in computer aided design (CAD). Here, one must evaluate the effect on the overall design of local design alternatives and of various external factors [30, 58]. <p> Since the premise of a logical rule is just a query, several researchers have developed hypothetical rules, in which the premise can query not only a real database, but hypothetical databases as well. Vieille, et al, for instance, have developed a deductive database along these lines <ref> [66, 67] </ref>, and Warren and Manchanda have used hypothetical rules to reason about database updates [68, 44]. In [50], Miller shows that hypothetical insertions can structure the runtime environment of logic programs, resulting in programs that are more elegant, more efficient, and easier to maintain. <p> RELATED WORK There has been considerable work in the area of logic and updates. The logical systems that are the closest to Hypothetical Datalog are Dynamic Prolog, developed by Manchanda and Warren [45, 44, 68], and EKS, developed by Vieille, et al <ref> [66, 67] </ref>. All three systems deal with both insertion and deletion, and in all three, updates take place on base facts, not derived facts. Nevertheless, the three systems are very different. In EKS, the semantics is purely operational. The emphasis here has been on implementation, not on logical foundations.
Reference: 67. <author> L. Vieille, P. Bayer, V. Kuchenhoff, A. Lefebvre, and R. Manthey. </author> <title> The EKS-V1 system. </title> <booktitle> In Proceedings of the International Conference on Logic Programming and Automated Reasoning (LPAR'92), number 624 in Lecture Notes in Computer Science, </booktitle> <pages> pages 504-506. </pages> <publisher> Springer-Verlag, </publisher> <year> 1992. </year>
Reference-contexts: A typical example is an analyst who must predict a company's deficit for the upcoming year assuming that employee salaries are increased by a given percentage. Or he might want a table of deficit predictions for a number of hypothetical salary increases <ref> [66, 67] </ref>. Similar problems occur in computer aided design (CAD). Here, one must evaluate the effect on the overall design of local design alternatives and of various external factors [30, 58]. <p> Since the premise of a logical rule is just a query, several researchers have developed hypothetical rules, in which the premise can query not only a real database, but hypothetical databases as well. Vieille, et al, for instance, have developed a deductive database along these lines <ref> [66, 67] </ref>, and Warren and Manchanda have used hypothetical rules to reason about database updates [68, 44]. In [50], Miller shows that hypothetical insertions can structure the runtime environment of logic programs, resulting in programs that are more elegant, more efficient, and easier to maintain. <p> RELATED WORK There has been considerable work in the area of logic and updates. The logical systems that are the closest to Hypothetical Datalog are Dynamic Prolog, developed by Manchanda and Warren [45, 44, 68], and EKS, developed by Vieille, et al <ref> [66, 67] </ref>. All three systems deal with both insertion and deletion, and in all three, updates take place on base facts, not derived facts. Nevertheless, the three systems are very different. In EKS, the semantics is purely operational. The emphasis here has been on implementation, not on logical foundations.
Reference: 68. <author> D.S. Warren. </author> <title> Database Updates in Pure Prolog. </title> <booktitle> In Proceedings of the International Conference on Fifth Generation Computer Systems, </booktitle> <pages> pages 244-253, </pages> <year> 1984. </year>
Reference-contexts: Vieille, et al, for instance, have developed a deductive database along these lines [66, 67], and Warren and Manchanda have used hypothetical rules to reason about database updates <ref> [68, 44] </ref>. In [50], Miller shows that hypothetical insertions can structure the runtime environment of logic programs, resulting in programs that are more elegant, more efficient, and easier to maintain. In [51], he develops a theory of lexical scoping based on the hypothetical creation of constant symbols during inference. <p> The result then follows by Lemma 6.2. 2 7. RELATED WORK There has been considerable work in the area of logic and updates. The logical systems that are the closest to Hypothetical Datalog are Dynamic Prolog, developed by Manchanda and Warren <ref> [45, 44, 68] </ref>, and EKS, developed by Vieille, et al [66, 67]. All three systems deal with both insertion and deletion, and in all three, updates take place on base facts, not derived facts. Nevertheless, the three systems are very different. In EKS, the semantics is purely operational.
Reference: 69. <author> M. Winslett. </author> <title> A model based approach to updating databases with incomplete information. </title> <journal> ACM Transactions on Database Systems (TODS), </journal> <volume> 13(2) </volume> <pages> 167-196, </pages> <year> 1988. </year>
Reference-contexts: Much of the remaining work on logic and updates can be divided into three classes: (i) elementary updates to arbitrary logical theories, (ii) complex updates 166 to relational databases, and (iii) intuitionistic logic programming. We shall look at each class in turn. The first class of work includes <ref> [69, 42, 28, 27, 56] </ref>. This work focuses on the semantics of elementary updates to complex theories. Our work is distinct from this class in two ways. First, we are concerned with combining elementary updates into complex hypothetical queries.
References-found: 69

