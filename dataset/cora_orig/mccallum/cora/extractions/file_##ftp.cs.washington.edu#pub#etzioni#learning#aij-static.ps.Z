URL: file://ftp.cs.washington.edu/pub/etzioni/learning/aij-static.ps.Z
Refering-URL: http://www.cs.washington.edu/research/projects/softbots/www/bib.html
Root-URL: 
Title: Acquiring Search-Control Knowledge via Static Analysis  
Author: Oren Etzioni 
Address: Seattle, WA 98195  
Affiliation: Department of Computer Science and Engineering, FR-35 University of Washington  
Abstract: between Partial Evaluation (PE) and EBL. However, EBL utilizes training examples whereas PE does not. It is natural to inquire, therefore, whether PE can be used to acquire search-control knowledge, and if so at what cost? This paper answers these questions by means of a case study comparing prodigy/ebl, a state-of-the-art EBL system, and static, a PE-based analyzer of problem-space definitions. When tested in prodigy/ebl's benchmark problem spaces, static generated search-control knowledge that was up to three times as effective as the knowledge learned by prodigy/ebl, and did so from twenty-six to seventy-seven times faster. The paper describes static's algorithms, compares its performance to prodigy/ebl's, noting when static's superior performance will scale up and when it will not. The paper concludes with several lessons for the design of EBL systems, suggesting hybrid PE/EBL systems as a promising direction for future research. fl static is available by sending mail to the author at etzioni@cs.washington.edu. The prodigy system, and the information necessary to replicate the experiments in this paper, is available by sending mail to prodigy@cs.cmu.edu. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> A. V. Aho, R. Sethi, and J. D. Ullman. </author> <booktitle> Compilers Principles Techniques and Tools. </booktitle> <publisher> Adison Wesley, </publisher> <year> 1987. </year>
Reference-contexts: This perspective places static and EBL in the broader context of program optimization. Much of the classical work on optimizing compilers (see <ref> [1] </ref>) focuses on optimizing arithmetic operations in programs written in imperative languages and is not relevant for this reason.
Reference: [2] <author> N. Bhatnagar and J. Mostow. </author> <title> Adaptive search by explanation-based learning of heuristic censors. </title> <booktitle> In Proceedings of the Eighth National Conference on Artificial Intelligence, </booktitle> <year> 1990. </year>
Reference-contexts: In fact, the problem spaces were chosen by Minton to test prodigy/ebl's effectiveness [30], and have been used as benchmarks in a number of experi ments both inside and outside the prodigy group <ref> [2, 18, 24] </ref>. Thus, static has been tested as rigorously as prodigy/ebl, and other speedup learning programs. Naturally, additional experiments in more realistic problem spaces are needed to further test the entire gamut of speedup learning programs.
Reference: [3] <author> J. Blythe, O. Etzioni, Y. Gil, R. Joseph, D. Kahn, C. Knoblock, S. Minton, A. Perez, S. Reilly, M. Veloso, and X. Wang. </author> <title> Prodigy 4.0: The manual and tutorial. </title> <type> Technical Report CMU-CS-92-150, </type> <institution> Carnegie Mellon University, </institution> <year> 1992. </year>
Reference-contexts: Thus, unless the planner anticipates goal interactions on its own, it will find static's analysis of goal interactions helpful. Work is currently underway to apply static-style PSG analysis to the UCPOP partial-order planner [43] and to a new subgoal-interleaving variant of prodigy <ref> [3] </ref>. 5 Comparing STATIC and PRODIGY/EBL This section answers the fundamental questions posed in the introduction by comparing static and prodigy/ebl along two dimensions: * Impact: the ability to speed up prodigy. * Cost: the time required to generate control knowledge.
Reference: [4] <author> D. Chapman. </author> <title> Planning for conjunctive goals. </title> <journal> Artificial Intelligence, </journal> <volume> 32(3) </volume> <pages> 333-378, </pages> <year> 1987. </year>
Reference-contexts: Since the algorithms use problem-specific information, they are often able to make strong complexity and completeness guarantees presenting a tradeoff between problem-space analysis and problem-specific analysis. This tradeoff has not been studied systematically. Chapman's tweak <ref> [4] </ref> utilizes an algorithm for determining the necessary/possible effects of a partially specified plan. The input to the algorithm is an initial state and the plan.
Reference: [5] <author> J. Cheng and K. B. Irani. </author> <title> Ordering problem subgoals. </title> <booktitle> In Proceedings of the Eleventh International Joint Conference on Artificial Intelligence, </booktitle> <pages> pages 931-936, </pages> <address> Detroit, Michi-gan, 1989. </address> <publisher> Morgan Kaufmann. </publisher>
Reference-contexts: The output of the algorithm is a list of the plan's necessary (occurring in all completions of the plan) and possible (occurring in some completion of the plan) effects. The algorithm runs in time that is polynomial in the number of steps in the plan. Cheng and Irani <ref> [5] </ref> describe an algorithm that, given an initial state and a goal conjunction, computes a partial order on the subgoals in the goal conjunction, which obviates backtracking across subgoals. The algorithm runs in O (n 3 ) time where n is the number of subgoals.
Reference: [6] <author> P. Cheng and J. G. Carbonell. </author> <title> The FERMI system: Inducing iterative macro-operators from experience. </title> <booktitle> In Proceedings of the Fifth National Conference on Artificial Intelligence, </booktitle> <pages> pages 490-495, </pages> <year> 1986. </year>
Reference-contexts: As a result, when learning from suc cess, prodigy/ebl forms distinct rules for the two-block tower, the three-block tower, and so on. Each rule is specific to towers of a given height. This is an instance of the infamous generalization-to-N problem <ref> [6, 45, 53] </ref>. As the state size increases, and increasingly taller towers are possible, more rules are necessary for guiding prodigy to choose unstack. static avoids the generalization-to-N problem by generating control rules based on nonre-cursive proofs.
Reference: [7] <author> J. Christensen. </author> <title> A hierarchical planner that creates its own hieararchies. </title> <booktitle> In Proceedings of Eighth National Conference on Artificial Intelligence, </booktitle> <address> Boston, MA, </address> <year> 1990. </year>
Reference-contexts: Finally, static anticipates goal clobbering and prerequisite violation whereas standard PE systems do not. In AI work, PE has been used to generate abstraction hierarchies for planning <ref> [7] </ref> and to reduce the match cost of rules learned via EBL [47, 29]. Concurrently with static, Letovsky [28] developed the prope system which generates macro-clauses by partially-evaluating pure PROLOG programs.
Reference: [8] <author> A. P. Danyluk. </author> <title> The use of explanations for similarity-based learning. </title> <booktitle> In Proceedings of the Tenth International Joint Conference on Artificial Intelligence, </booktitle> <address> Milan, Italy, </address> <month> Aug. </month> <year> 1987. </year>
Reference-contexts: Section 6 contrasts static with standard partial evaluators and other static analyzers, and Section 7 concludes by considering design lessons for EBL systems based on the static case study. 1 EBL is also used to revise or repair "imperfect" theories (e.g. <ref> [8, 20, 40, 42, 48] </ref>). 2 BACKGROUND 2 2 Background This section is organized as follows. Section 2.1 describes the prodigy problem solver, which is the substrate for prodigy/ebl. Section 2.2 introduces standard EBL terminology, and sketches prodigy/ebl.
Reference: [9] <author> J. Darlington. </author> <title> An experimental program transformation and synthesis system. </title> <journal> AI, </journal> <volume> 16(1) </volume> <pages> 1-46, </pages> <month> March </month> <year> 1981. </year>
Reference-contexts: In 9 See [41, 57] for extensive surveys. 6 RELATED WORK 29 contrast, much of the research on partial evaluation is concerned with effective policies for unfolding recursions (e.g. [58]). * Is the optimizer fully automatic? static is automatic but many optimizers are not (e.g. <ref> [9] </ref>). * What program transformations does the optimizer employ? static employs unfolding and reordering transformations. In contrast to most Prolog implementations of EBL (e.g., [21, 52, 56]), which only reorder Horn Clauses, static (and prodigy/ebl) reorder both Horn clauses and conjuncts.
Reference: [10] <author> C. Dawson and L. Siklossy. </author> <title> The role of preprocessing in problem-solving systems. </title> <booktitle> In Proceedings of the Fifth International Joint Conference on Artificial Intelligence, </booktitle> <year> 1977. </year> <note> REFERENCES 42 </note>
Reference-contexts: The program transformations used to avoid goal interactions are the reordering transformations used to optimize monotonic inference programs, but the motivation for applying these transformations is different. REFLECT Dawson and Siklossy <ref> [10] </ref> describe reflect, an early system that engaged in static problem space analysis. reflect ran in two phases: a preprocessing phase in which conjunctive goals were analyzed and macro-operators were built, and a problem-solving phase in which reflect engaged in a form of backward-chaining.
Reference: [11] <author> G. F. Dejong and R. J. Mooney. </author> <title> Explanation-based learning: An alternative view. </title> <journal> Machine Learning, </journal> <volume> 1(1), </volume> <year> 1986. </year>
Reference-contexts: 1 Introduction Explanation-Based Learning (EBL) <ref> [11, 36] </ref> has emerged as a standard technique for acquiring search-control knowledge (e.g. [27, 33, 37, 35, 47, 52]). 1 Recently, Prieditis [46], van Harmelen and Bundy [59] pointed to the similarity between Partial Evaluation (PE), a well-known program optimization technique [25, 58], and EBL, suggesting that an EBL-style analysis could <p> EBL can be regarded as incrementally converting the target-concept definition into a DNF expression where each disjunct is a sufficient condition learned from a training example. "Pure" EBL, as described in <ref> [11, 36] </ref>, does not attempt to logically simplify the sufficient conditions it generates, a process that typically requires combining multiple sufficient conditions or disjuncts. For this reason, pure EBL frequently derives overly-specific control knowledge [15, 28, 29]. Consider a simple schematic example taken from [16].
Reference: [12] <author> E. W. Dijkstra. </author> <title> A Discipline of Programming. </title> <publisher> Prentice Hall, </publisher> <address> Englewood Cliffs, N.J., </address> <year> 1976. </year>
Reference-contexts: The operationality criterion is intended to ensure that the sufficient condition can be used to recognize instances of the concept efficiently. EBL proves (or explains) that the training example is an instance of the target concept and outputs the weakest preconditions <ref> [12] </ref> of the proof. 2.2.1 PRODIGY/EBL A terse description of prodigy/ebl, using EBG terminology, follows.
Reference: [13] <author> O. Etzioni. </author> <title> A Structural Theory of Explanation-Based Learning. </title> <type> PhD thesis, </type> <institution> Carnegie Mellon University, </institution> <year> 1990. </year> <note> Available as technical report CMU-CS-90-185. </note>
Reference-contexts: Blocksworld 86 Stripsworld 186 Schedworld 87 ABworld 249 Table 6: Total number of PSG nodes in the problem spaces studied, which include prodigy/ebl's benchmark problem spaces and the ABworld, a highly-recursive variant of the Blocksworld constructed to foil prodigy/ebl <ref> [13, 14] </ref>. 3.3 Labeling the PSG Each PSG node, below the root, is annotated with a label and a logical expression referred to as its "failure condition." The label asserts what prodigy's behavior will be when an instance of the node is encountered during problem solving. <p> Table 8 outlines the recursive procedure used to compute PSG failure conditions. A pseudo-code description of the algorithm and a trace of its execution appear in <ref> [13, chapter 6] </ref>. <p> A detailed specification of static's criteria for generating control rules, and minor extensions to the algorithms presented above (e.g. forming node rejection rules, avoiding redundant rules) are described in <ref> [13] </ref>. 4 STATIC ANALYSIS OF GOAL INTERACTIONS 14 (REJECT-PICK-UP (if (and (current-node Node) (current-goal Node (holding Block-X)) (candidate-op Node pick-up) (known Node (not (on-table Block-X))))) (then (reject operator pickup))) (REJECT-UNSTACK (if (and (current-node Node) (current-goal Node (holding Block-X)) (candidate-op Node unstack) (known Node (not (on Block-X Block-Y))))) (then (reject operator unstack))) <p> The comparisons use CPU-time (on a Sun Sparcstation) as a performance measure. A more detailed comparison that considers the number of nodes, average match cost, and number of rules learned by each of the systems appears in <ref> [13, chapter 8] </ref> 5.1 Impact static speeds up prodigy considerably in the problem spaces studied (Table 16). In fact, static's control knowledge is up to three times as effective as that learned by prodigy/ebl. <p> It is interesting to note that utility evaluation is quite costly. 8 Both prodigy/ebl and static utilize domain-specific axioms to generate control rules. A detailed comparison shows that the two systems are given roughly the same knowledge but in somewhat different forms <ref> [13, chapter 8] </ref>. 5 COMPARING STATIC AND PRODIGY/EBL 26 Training problems Proofs Utility Blocksworld 127 313 322 Stripsworld 305 671 81 Schedworld 454 832 88 ABworld 2493 8067 673 Table 18: prodigy/ebl's learning time decomposed into components: time to solve training problems, time to construct proofs based on the problem-solving trace, <p> To its credit, static will do so quickly, whereas EBL systems will often generate ineffective control knowledge in such spaces, and take a long time to do so <ref> [13, 19, 23] </ref>. As EBL lore would have it, PE is bound to be intractable when applied to sufficiently large and complex theories.
Reference: [14] <author> O. Etzioni. </author> <title> Why Prodigy/EBL works. </title> <booktitle> In Proceedings of the Eighth National Conference on Artificial Intelligence, </booktitle> <year> 1990. </year>
Reference-contexts: Blocksworld 86 Stripsworld 186 Schedworld 87 ABworld 249 Table 6: Total number of PSG nodes in the problem spaces studied, which include prodigy/ebl's benchmark problem spaces and the ABworld, a highly-recursive variant of the Blocksworld constructed to foil prodigy/ebl <ref> [13, 14] </ref>. 3.3 Labeling the PSG Each PSG node, below the root, is annotated with a label and a logical expression referred to as its "failure condition." The label asserts what prodigy's behavior will be when an instance of the node is encountered during problem solving.
Reference: [15] <author> O. Etzioni. </author> <title> A structural theory of explanation-based learning. </title> <journal> Artificial Intelligence, </journal> <note> 1993. To appear. Also available as University of Washington technical report 91-09-02. </note>
Reference-contexts: static solves this problem by combining (its own versions of) prodigy/ebl's multiple target concepts with a simple termination criterion: unfold only nonrecursive calls. 2 As shown in Section 3.2.2, static provably terminates, yet it is still able to outperform prodigy/ebl (Section 5). 2 Theoretical motivation for this criterion appears in <ref> [15] </ref>. 3 STATIC ANALYSIS OF FAILURE AND SUCCESS 6 3 Static Analysis of Failure and Success This section describes static's algorithms for analyzing failure and success. The algorithms in this section could be used to optimize pure Prolog programs. Section 4 presents static's analysis of goal interactions. <p> should be determined separately [44]. * A partial meta-level theory encoding sufficient (or necessary) conditions for EBL's target concepts is often preferable to a stronger theory, specifying necessary and sufficient conditions for the concepts, but resulting in more complex explanations [16]. * Nonrecursive explanations are often preferable to recursive ones <ref> [15] </ref>. * Typically, EBL's proofs correspond to and trees but, often, a case analysis involving several examples (corresponding to an and/or tree), is required to identify the most general sufficient condition for the target concept [16]. * The Problem Space Graph (PSG) is a compact representation that facilitates the implementation of <p> enforces the following criterion: learn only from the target concepts that yield non-recursive proofs. 11 This design choice is motivated, in part, by the structural theory of EBL which shows that learning from recursive explanations is problematic due to the recursion-depth-specificity and worst-case exponential match cost of "recursive control rules" <ref> [15] </ref> and, in part, by the difficulty of deciding when to terminate the unfolding of recursion during partial evaluation (Section 2.3). In the presence of multiple target concepts such as success and failure, static's selective learning criterion turns out to be particularly effective. <p> Motivated by static, Gratch and DeJong [19] modified prodigy/ebl to learn only nonrecursive rules and to omit utility evaluation. This variant of prodigy/ebl (called nonrec) performed quite poorly in their experiments, demonstrating that it is quite possible for an EBL system to learn an 11 See <ref> [15] </ref> for a precise definition of the term "nonrecursive proof." 7 DESIGN LESSONS FOR EBL SYSTEMS 37 ineffective set of nonrecursive rules. 12 Gratch and DeJong's experiment demonstrates the value of the other design ideas, beyond learning from nonrecursive explanations, which are incorporated into static. 7.4 Logical Simplification One important advantage <p> For this reason, pure EBL frequently derives overly-specific control knowledge <ref> [15, 28, 29] </ref>. Consider a simple schematic example taken from [16]. <p> With this caveat in place, the results support the structural thesis, formulated and argued for in <ref> [15] </ref>. The thesis states that there is a correspondence between the PSG representation and the proofs used by EBL systems to generate search-control knowledge. As a result, automatic PSG analysis can be used to compute the weakest preconditions of the proofs and to discriminate between recursive and nonrecursive proofs.
Reference: [16] <author> O. Etzioni and S. Minton. </author> <title> Why EBL produces overly-specific knowledge: A critique of the PRODIGY approaches. </title> <booktitle> In Proceedings of the Ninth International Conference on Machine Learning. </booktitle> <publisher> Morgan Kaufmann, </publisher> <month> July </month> <year> 1992. </year>
Reference-contexts: Static analysis has three advantages over standard EBL methods. First, while EBL is sensitive to incomplete or badly-ordered sequences of training examples, static analysis is not. Second, EBL often acquires overly-specific control knowledge by retaining extraneous features of its training examples <ref> [16, 44] </ref>. Finally, in contrast to EBL, a static analyzer need not invoke the problem solver to solve training problems|a costly process. However, because training problems "transmit" useful information about the task environment, it is not obvious that static analysis can actually generate effective control knowledge and do so tractably. <p> Since EBL merely computes the weakest preconditions associated with a particular proof, it is by no means guaranteed to find the most general, or logically weakest, sufficient condition. As a result, EBL frequently derives overly-specific control knowledge <ref> [16] </ref>. A solution to this problem, embodied by both prodigy/ebl and static, is to increase the range of proofs, or analyses, available to the learning module by providing it with a meta-level theory containing multiple target concepts such as failure, success and goal interaction [29]. <p> EBL systems, what EBL explains and how it is explained should be determined separately [44]. * A partial meta-level theory encoding sufficient (or necessary) conditions for EBL's target concepts is often preferable to a stronger theory, specifying necessary and sufficient conditions for the concepts, but resulting in more complex explanations <ref> [16] </ref>. * Nonrecursive explanations are often preferable to recursive ones [15]. * Typically, EBL's proofs correspond to and trees but, often, a case analysis involving several examples (corresponding to an and/or tree), is required to identify the most general sufficient condition for the target concept [16]. * The Problem Space Graph <p> resulting in more complex explanations <ref> [16] </ref>. * Nonrecursive explanations are often preferable to recursive ones [15]. * Typically, EBL's proofs correspond to and trees but, often, a case analysis involving several examples (corresponding to an and/or tree), is required to identify the most general sufficient condition for the target concept [16]. * The Problem Space Graph (PSG) is a compact representation that facilitates the implementation of the above ideas. In particular, the PSG facilitates the kind of logical simplification necessary to increase the generality and reduce the match cost of EBL style control knowledge. <p> in Table 21. 7.2 Meta-Level Theory Design Whether training examples are used or not, the generality of acquired control knowledge depends on the precise encoding of EBL's theory. 10 The theory used by prodigy/ebl to 10 This section is based on joint work with Steve Minton, which is described in <ref> [16] </ref>. 7 DESIGN LESSONS FOR EBL SYSTEMS 35 construct explanations has two components: the domain theory and the meta-level theory. The domain theory consists of the operators and inference rules provided by the user. <p> For this reason, pure EBL frequently derives overly-specific control knowledge [15, 28, 29]. Consider a simple schematic example taken from <ref> [16] </ref>. Suppose EBL learns two conditions of the form: C if (P ^ Q) That is, there is a proof of the target concept whose weakest preconditions are (P ^ Q), and a proof whose weakest preconditions are (P ^ Q)).
Reference: [17] <author> R. Fikes, P. Hart, and N. Nilsson. </author> <title> Learning and executing generalized robot plans. </title> <journal> Artificial Intelligence, </journal> <volume> 3(4), </volume> <year> 1972. </year>
Reference-contexts: A sample prodigy operator appears in Table 1. prodigy's sole problem-solving method is a form of means-ends analysis [39]. Like strips <ref> [17] </ref>, prodigy employs operator preconditions as its differences.
Reference: [18] <author> J. Gratch and G. Dejong. </author> <title> A hybrid approach to guaranteed effective control strategies. </title> <booktitle> In Proceedings of the Eighth International Workshop on Machine Learning. </booktitle> <publisher> Morgan Kaufmann, </publisher> <year> 1991. </year>
Reference-contexts: In fact, the problem spaces were chosen by Minton to test prodigy/ebl's effectiveness [30], and have been used as benchmarks in a number of experi ments both inside and outside the prodigy group <ref> [2, 18, 24] </ref>. Thus, static has been tested as rigorously as prodigy/ebl, and other speedup learning programs. Naturally, additional experiments in more realistic problem spaces are needed to further test the entire gamut of speedup learning programs.
Reference: [19] <author> J. Gratch and G. Dejong. COMPOSER: </author> <title> A probabilistic solution to the utility problem in speed-up learning. </title> <booktitle> In Proceedings of AAAI-92. </booktitle> <publisher> AAAI Press, </publisher> <year> 1992. </year>
Reference-contexts: Second, static will fail when the analysis required to curtail problem solving falls outside its scope. In addition, when proving both failure and success is recursive as in the Tower of Hanoi, ABworld, or recursive Bin-world <ref> [19] </ref> problem spaces, static will form trivial PSGs and refuse to generate much if any control knowledge. To its credit, static will do so quickly, whereas EBL systems will often generate ineffective control knowledge in such spaces, and take a long time to do so [13, 19, 23]. <p> To its credit, static will do so quickly, whereas EBL systems will often generate ineffective control knowledge in such spaces, and take a long time to do so <ref> [13, 19, 23] </ref>. As EBL lore would have it, PE is bound to be intractable when applied to sufficiently large and complex theories. <p> The nonrecursive proofs yield rules that are compact, general, and cheap-to-match. Nonrecursive proofs are not guaranteed to yield effective rules. Motivated by static, Gratch and DeJong <ref> [19] </ref> modified prodigy/ebl to learn only nonrecursive rules and to omit utility evaluation.
Reference: [20] <author> H. Hirsh. </author> <title> Combining empirical and analytical learning with version spaces. </title> <booktitle> In Proceedings of the Sixth International Workshop on Machine Learning, </booktitle> <pages> pages 29-33, </pages> <address> Ithaca, New York, </address> <year> 1989. </year>
Reference-contexts: Section 6 contrasts static with standard partial evaluators and other static analyzers, and Section 7 concludes by considering design lessons for EBL systems based on the static case study. 1 EBL is also used to revise or repair "imperfect" theories (e.g. <ref> [8, 20, 40, 42, 48] </ref>). 2 BACKGROUND 2 2 Background This section is organized as follows. Section 2.1 describes the prodigy problem solver, which is the substrate for prodigy/ebl. Section 2.2 introduces standard EBL terminology, and sketches prodigy/ebl.
Reference: [21] <author> S. Kedar-Cabelli and L. T. McCarty. </author> <title> Explanation-based generalization as resolution theorem proving. </title> <editor> In P. Langley, editor, </editor> <booktitle> Proceedings of the Fourth International Workshop on Machine Learning, </booktitle> <year> 1987. </year>
Reference-contexts: In contrast to most Prolog implementations of EBL (e.g., <ref> [21, 52, 56] </ref>), which only reorder Horn Clauses, static (and prodigy/ebl) reorder both Horn clauses and conjuncts. Conjunct ordering has been studied extensively in the database community (e.g. [60]) and by Smith [54].
Reference: [22] <author> S. Kleene. </author> <title> Introduction to Metamathematics. </title> <publisher> Van Nostrand, </publisher> <year> 1952. </year>
Reference-contexts: First, prodigy/ebl utilizes multiple target concepts. Second, prodigy/ebl derives control rules based on the sufficient conditions it computes. Third, prodigy/ebl performs post-processing of the control rules in an effort to increase their effectiveness. 2.3 Partial Evaluation Partial evaluation is a program optimization technique inspired by Kleene's S-M-N theorem <ref> [22, 59] </ref>.
Reference: [23] <author> C. Knoblock, S. Minton, and O. Etzioni. </author> <title> Integrating abstraction and explanation-based learning in Prodigy. </title> <booktitle> In Proceedings of the Ninth National Conference on Artificial Intelligence., </booktitle> <year> 1991. </year>
Reference-contexts: To its credit, static will do so quickly, whereas EBL systems will often generate ineffective control knowledge in such spaces, and take a long time to do so <ref> [13, 19, 23] </ref>. As EBL lore would have it, PE is bound to be intractable when applied to sufficiently large and complex theories.
Reference: [24] <author> C. A. Knoblock. </author> <title> Automatically Generating Abstractions for Problem Solving. </title> <type> PhD thesis, </type> <institution> School of Computer Science, Carnegie Mellon University, </institution> <year> 1991. </year> <note> Available as technical report CMU-CS-91-120. REFERENCES 43 </note>
Reference-contexts: Table 10). static anticipates goal interactions that will necessarily occur. That is, static reports that two goals interact, under certain constraints, only if the goals interact in every state that obeys these constraints. An alternative optimization strategy (taken by Knoblock's alpine <ref> [24] </ref>) is to anticipate all goal interactions that can possibly occur. <p> Second, in order to eliminate "temporary effects" from consideration static would have to determine the possible side-effects of achieving each subgoal. While this can be done in a straight-forward manner, using an algorithm such as Knoblock's <ref> [24] </ref>, I did not pursue this in static. 4.2.1 Computing Necessary Effects I conjecture that computing the set of necessary effects E is hard in general, but I will not attempt to prove this. static computes a subset of E denoted by ^ E, and anticipates 4 STATIC ANALYSIS OF GOAL <p> In fact, the problem spaces were chosen by Minton to test prodigy/ebl's effectiveness [30], and have been used as benchmarks in a number of experi ments both inside and outside the prodigy group <ref> [2, 18, 24] </ref>. Thus, static has been tested as rigorously as prodigy/ebl, and other speedup learning programs. Naturally, additional experiments in more realistic problem spaces are needed to further test the entire gamut of speedup learning programs. <p> Another advance is the formal specification and computation of necessary effects and prerequisites to facilitate goal reordering (Section 4). Finally, unlike static, reflect does not reorder subgoals to avoid goal interactions. ALPINE Knoblock's alpine <ref> [24] </ref> generates hierarchies of abstract problem spaces by stat ically analyzing goal interactions. alpine maps the problem space definition to a graph representation in which a node is a literal, and an edge from one literal to another means that the first literal can potentially interact with the former. alpine's algorithm
Reference: [25] <author> H. Komorowski. </author> <title> Partial evaluation as a means for inferencing data structures in an applicative language: a theory and implementation in the case of PROLOG. </title> <booktitle> In Proceedings of The Ninth Conference on the Principles of Programming Languages (POPL), </booktitle> <pages> pages 255-267, </pages> <address> Albuquerque, NM, </address> <year> 1982. </year>
Reference-contexts: 1 Introduction Explanation-Based Learning (EBL) [11, 36] has emerged as a standard technique for acquiring search-control knowledge (e.g. [27, 33, 37, 35, 47, 52]). 1 Recently, Prieditis [46], van Harmelen and Bundy [59] pointed to the similarity between Partial Evaluation (PE), a well-known program optimization technique <ref> [25, 58] </ref>, and EBL, suggesting that an EBL-style analysis could be performed statically, without utilizing training examples. This suggestion is controversial because EBL is perceived as a dynamic technique that depends on examples to focus the learning process.
Reference: [26] <author> R. A. Kowalski. </author> <title> A proof procedure using connection graphs. </title> <journal> Journal of the ACM, </journal> <volume> 22 </volume> <pages> 572-595, </pages> <year> 1974. </year>
Reference-contexts: Although the PSG was developed independently, it is quite 3 A literal is a possibly negated atomic formula. 3 STATIC ANALYSIS OF FAILURE AND SUCCESS 7 similar to the rule/goal graph [57], and related graph representations of logic programs (e.g., <ref> [26] </ref>). <p> Unlike prodigy/ebl and static, the database systems do not perform conjunct reordering in concert with unfolding. * What representation of the program does the optimizer use? static uses Problem Space Graphs (PSGs). Many optimizers use similar graph representations of programs. Connection graphs <ref> [26] </ref>, rule/goal graphs [57], and flow graphs [38] are some examples. * What is the complexity of the optimization? static's time and space complexity are close to linear in the size of its PSGs. <p> The complexities of different optimizers vary widely. * Are the optimizations carried out for specific inputs? static is run once per problem space. Many approaches, particularly ones cast as improved proof procedures (e.g., <ref> [26] </ref>) are problem specific. <p> Connection graph proof procedures, for example, rely on graphs whose nodes represent rules or facts and whose edges represent the most general unifiers between the adjacent nodes <ref> [26] </ref>. Although some of the optimizations implemented by connection graph proof procedures are akin to static's, the proof procedures are query-specific, yielding very different graph-traversal algorithms.
Reference: [27] <author> J. E. Laird, P. S. Rosenbloom, and N. A. </author> <title> Chunking in Soar: The anatomy of a general learning mechanism. </title> <journal> Machine Learning, </journal> <volume> 1(1) </volume> <pages> 11-46, </pages> <year> 1986. </year>
Reference-contexts: 1 Introduction Explanation-Based Learning (EBL) [11, 36] has emerged as a standard technique for acquiring search-control knowledge (e.g. <ref> [27, 33, 37, 35, 47, 52] </ref>). 1 Recently, Prieditis [46], van Harmelen and Bundy [59] pointed to the similarity between Partial Evaluation (PE), a well-known program optimization technique [25, 58], and EBL, suggesting that an EBL-style analysis could be performed statically, without utilizing training examples. <p> Each principle is illustrated by specific examples below. 7 DESIGN LESSONS FOR EBL SYSTEMS 33 7.1 The Pitfalls of Training Examples Most existing EBL systems generate explanations by directly translating a trace of the problem solver's behavior, when solving a training problem, into a logical proof <ref> [27, 33, 35, 47, 52, 56] </ref>. As a result, the problem solver's behavior on a training problem determines not only what EBL will explain but also how the explanation is constructed, yielding overly-specific control knowledge in many cases.
Reference: [28] <author> S. Letovsky. </author> <title> Operationality criteria for recursive predicates. </title> <booktitle> In Proceedings of the Eighth National Conference on Artificial Intelligence, </booktitle> <year> 1990. </year>
Reference-contexts: Finally, static anticipates goal clobbering and prerequisite violation whereas standard PE systems do not. In AI work, PE has been used to generate abstraction hierarchies for planning [7] and to reduce the match cost of rules learned via EBL [47, 29]. Concurrently with static, Letovsky <ref> [28] </ref> developed the prope system which generates macro-clauses by partially-evaluating pure PROLOG programs. <p> For this reason, it is reasonable to engineer the meta-level theory in order to improve EBL's performance. Although it may sound obvious, engineering the meta-level theory so that the "right" explanations are produced is one of the least-appreciated, but most critical, aspects of building an EBL system <ref> [32, 31, 28] </ref>. The following informal design principle can be used to guide this process: design a theory that "proves as little as possible." The more compact the proof, the less likely it is that irrelevant conditions will "creep" into its weakest preconditions. This principle has two corollaries. <p> For this reason, pure EBL frequently derives overly-specific control knowledge <ref> [15, 28, 29] </ref>. Consider a simple schematic example taken from [16].
Reference: [29] <author> S. Minton. </author> <title> Learning Effective Search Control Knolwedge: An Explanation-Based Approach. </title> <type> PhD thesis, </type> <institution> Carnegie Mellon University, </institution> <year> 1988. </year> <note> Available as technical report CMU-CS-88-133. </note>
Reference-contexts: Section 2.1 describes the prodigy problem solver, which is the substrate for prodigy/ebl. Section 2.2 introduces standard EBL terminology, and sketches prodigy/ebl. Finally, Section 2.3 defines partial evaluation. 2.1 The PRODIGY Problem Solver Detailed descriptions of prodigy appear in <ref> [29, 33, 34] </ref>. The bare essentials follow. prodigy is a domain-independent problem solver. Given an initial state and a goal expression, prodigy searches for a sequence of operators that will transform the initial state into a state that matches the goal expression. <p> EBL proves (or explains) that the training example is an instance of the target concept and outputs the weakest preconditions [12] of the proof. 2.2.1 PRODIGY/EBL A terse description of prodigy/ebl, using EBG terminology, follows. A complete description of prodigy/ebl appears in <ref> [29] </ref>. prodigy/ebl's primary target concepts are success, failure and goal interaction. prodigy/ebl analyzes a trace of prodigy's search on a training problem, and extracts training examples from this trace. prodigy/ebl's domain theory has two components: the architectural theory, which describes prodigy's problem-solving 2 BACKGROUND 4 Given: * Target Concept Definition: A <p> Finally, static anticipates goal clobbering and prerequisite violation whereas standard PE systems do not. In AI work, PE has been used to generate abstraction hierarchies for planning [7] and to reduce the match cost of rules learned via EBL <ref> [47, 29] </ref>. Concurrently with static, Letovsky [28] developed the prope system which generates macro-clauses by partially-evaluating pure PROLOG programs. <p> A solution to this problem, embodied by both prodigy/ebl and static, is to increase the range of proofs, or analyses, available to the learning module by providing it with a meta-level theory containing multiple target concepts such as failure, success and goal interaction <ref> [29] </ref>. Increasing the range of proofs available to the learning module highlights the problem of choosing an appropriate analysis of the problem solver's behavior. prodigy/ebl makes this choice by generating a large number of control rules and heuristically evaluating their "utility" on a set of training problems. <p> For this reason, pure EBL frequently derives overly-specific control knowledge <ref> [15, 28, 29] </ref>. Consider a simple schematic example taken from [16]. <p> Namely: C if P However, pure EBL will not identify this condition. To address this and related problems, EBL systems such as prodigy/ebl include heuristic simplification methods that attempt to improve the generality of EBL's conditions via truth-preserving transformations <ref> [29, 47] </ref>. Unfortunately, these methods can only work if EBL encounters the appropriate training problems. In the above example, if EBL never learns the second sufficient condition, it is "stuck" with an overly-specific condition.
Reference: [30] <author> S. Minton. </author> <title> Quantitative results concerning the utility of explanation-based learning. </title> <booktitle> In Proceedings of the Seventh National Conference on Artificial Intelligence. </booktitle> <publisher> Morgan Kaufmann, </publisher> <year> 1988. </year>
Reference-contexts: Variable names are capitalized. prodigy's default search strategy is depth-first search. The search is carried out by repeating the following decision cycle <ref> [30] </ref>: 1. Choose a node in the search tree. A node consists of a set of goals and a world state. 2. Choose one of the goals at that node. 3. Choose an operator that can potentially achieve the goal. 4. Choose bindings for the variables in the operator. <p> In either case, a new node is created. 2 BACKGROUND 3 Search-control knowledge in prodigy is encoded via control rules, which override prodigy's default behavior by specifying that particular candidates (nodes, goals, operators, or bindings) should be selected, rejected, or preferred over other candidates <ref> [30] </ref>. Alternatives that are selected are the only ones tried; alternatives that are rejected are removed from the selected set. Finally, all other things being equal, preferred alternatives are tried before other ones. prodigy matches control rules against its current state. <p> However, 5 COMPARING STATIC AND PRODIGY/EBL 27 with the exception of the ABworld, the problem spaces studied were not selected to highlight static's performance. In fact, the problem spaces were chosen by Minton to test prodigy/ebl's effectiveness <ref> [30] </ref>, and have been used as benchmarks in a number of experi ments both inside and outside the prodigy group [2, 18, 24]. Thus, static has been tested as rigorously as prodigy/ebl, and other speedup learning programs.
Reference: [31] <author> S. Minton. </author> <title> Quantitative results concerning the utility of explanation-based learning. </title> <booktitle> Artificial Intelligence, </booktitle> <pages> 42(2-3), </pages> <month> March </month> <year> 1990. </year>
Reference-contexts: Since a state-of-the-art EBL system, prodigy/ebl, has already been implemented and tested, our task has been to design a PE-based static analyzer and compare its performance with that of prodigy/ebl. prodigy/ebl was tested on sets of one-hundred randomly generated problems in three benchmark problem spaces <ref> [31] </ref>. The performance of the static analyzer (called static) was compared to that of prodigy/ebl, using the same sets of test problems, in each of the benchmark problem spaces. <p> The above example demonstrates the benefits of a looser coupling between explanations and training examples (cf. <ref> [31] </ref>). Whereas prodigy/ebl's explanations are determined by its training examples, static's explanations are based on a global analysis of the partially evaluated problem-space definition, which often yields better control rules. <p> For this reason, it is reasonable to engineer the meta-level theory in order to improve EBL's performance. Although it may sound obvious, engineering the meta-level theory so that the "right" explanations are produced is one of the least-appreciated, but most critical, aspects of building an EBL system <ref> [32, 31, 28] </ref>. The following informal design principle can be used to guide this process: design a theory that "proves as little as possible." The more compact the proof, the less likely it is that irrelevant conditions will "creep" into its weakest preconditions. This principle has two corollaries.
Reference: [32] <author> S. Minton, J. G. Carbonell, O. Etzioni, C. A. Knoblock, and D. R. Kuokka. </author> <title> Acquiring effective search control rules: Explanation-based learning in the Prodigy system. </title> <booktitle> In Proceedings of the Fourth International Workshop on Machine Learning, </booktitle> <year> 1987. </year>
Reference-contexts: For this reason, it is reasonable to engineer the meta-level theory in order to improve EBL's performance. Although it may sound obvious, engineering the meta-level theory so that the "right" explanations are produced is one of the least-appreciated, but most critical, aspects of building an EBL system <ref> [32, 31, 28] </ref>. The following informal design principle can be used to guide this process: design a theory that "proves as little as possible." The more compact the proof, the less likely it is that irrelevant conditions will "creep" into its weakest preconditions. This principle has two corollaries.
Reference: [33] <author> S. Minton, J. G. Carbonell, C. A. Knoblock, D. R. Kuokka, O. Etzioni, and Y. Gil. </author> <title> Explanation-based learning: A problem-solving perspective. </title> <journal> Artificial Intelligence, </journal> <volume> 40 </volume> <pages> 63-118, </pages> <year> 1989. </year> <note> Available as technical report CMU-CS-89-103. </note>
Reference-contexts: 1 Introduction Explanation-Based Learning (EBL) [11, 36] has emerged as a standard technique for acquiring search-control knowledge (e.g. <ref> [27, 33, 37, 35, 47, 52] </ref>). 1 Recently, Prieditis [46], van Harmelen and Bundy [59] pointed to the similarity between Partial Evaluation (PE), a well-known program optimization technique [25, 58], and EBL, suggesting that an EBL-style analysis could be performed statically, without utilizing training examples. <p> Thus, we arrive at two fundamental questions: * Can static analysis produce effective search-control knowledge? * Can it do so in reasonable time? This paper presents a case study, using the prodigy system <ref> [33] </ref>, which answers these questions. <p> Section 2.1 describes the prodigy problem solver, which is the substrate for prodigy/ebl. Section 2.2 introduces standard EBL terminology, and sketches prodigy/ebl. Finally, Section 2.3 defines partial evaluation. 2.1 The PRODIGY Problem Solver Detailed descriptions of prodigy appear in <ref> [29, 33, 34] </ref>. The bare essentials follow. prodigy is a domain-independent problem solver. Given an initial state and a goal expression, prodigy searches for a sequence of operators that will transform the initial state into a state that matches the goal expression. <p> Each principle is illustrated by specific examples below. 7 DESIGN LESSONS FOR EBL SYSTEMS 33 7.1 The Pitfalls of Training Examples Most existing EBL systems generate explanations by directly translating a trace of the problem solver's behavior, when solving a training problem, into a logical proof <ref> [27, 33, 35, 47, 52, 56] </ref>. As a result, the problem solver's behavior on a training problem determines not only what EBL will explain but also how the explanation is constructed, yielding overly-specific control knowledge in many cases.
Reference: [34] <author> S. Minton, C. A. Knoblock, D. R. Kuokka, Y. Gil, R. L. Joseph, and J. G. Carbonell. </author> <title> Prodigy 2.0: The manual and tutorial. </title> <type> Technical Report CMU-CS-89-146, </type> <institution> Carnegie Mellon University, </institution> <year> 1989. </year>
Reference-contexts: Section 2.1 describes the prodigy problem solver, which is the substrate for prodigy/ebl. Section 2.2 introduces standard EBL terminology, and sketches prodigy/ebl. Finally, Section 2.3 defines partial evaluation. 2.1 The PRODIGY Problem Solver Detailed descriptions of prodigy appear in <ref> [29, 33, 34] </ref>. The bare essentials follow. prodigy is a domain-independent problem solver. Given an initial state and a goal expression, prodigy searches for a sequence of operators that will transform the initial state into a state that matches the goal expression.
Reference: [35] <author> T. M. Mitchell, J. Allen, P. Chalasani, J. Cheng, O. Etzioni, M. Ringuette, and J. C. Schlimmer. Theo: </author> <title> A framework for self-improving systems. </title> <editor> In K. VanLehn, editor, </editor> <booktitle> Architectures for Intelligence. </booktitle> <publisher> Erlbaum, </publisher> <year> 1991. </year>
Reference-contexts: 1 Introduction Explanation-Based Learning (EBL) [11, 36] has emerged as a standard technique for acquiring search-control knowledge (e.g. <ref> [27, 33, 37, 35, 47, 52] </ref>). 1 Recently, Prieditis [46], van Harmelen and Bundy [59] pointed to the similarity between Partial Evaluation (PE), a well-known program optimization technique [25, 58], and EBL, suggesting that an EBL-style analysis could be performed statically, without utilizing training examples. <p> Each principle is illustrated by specific examples below. 7 DESIGN LESSONS FOR EBL SYSTEMS 33 7.1 The Pitfalls of Training Examples Most existing EBL systems generate explanations by directly translating a trace of the problem solver's behavior, when solving a training problem, into a logical proof <ref> [27, 33, 35, 47, 52, 56] </ref>. As a result, the problem solver's behavior on a training problem determines not only what EBL will explain but also how the explanation is constructed, yielding overly-specific control knowledge in many cases.
Reference: [36] <author> T. M. Mitchell, R. Keller, and S. Kedar-Cabelli. </author> <title> Explanation-based generalization: A unifying view. </title> <journal> Machine Learning, </journal> <volume> 1(1), </volume> <year> 1986. </year>
Reference-contexts: 1 Introduction Explanation-Based Learning (EBL) <ref> [11, 36] </ref> has emerged as a standard technique for acquiring search-control knowledge (e.g. [27, 33, 37, 35, 47, 52]). 1 Recently, Prieditis [46], van Harmelen and Bundy [59] pointed to the similarity between Partial Evaluation (PE), a well-known program optimization technique [25, 58], and EBL, suggesting that an EBL-style analysis could <p> on any other block. (REJECT-UNSTACK (if (and (current-node Node) (current-goal Node (holding Block-X)) (candidate-operator Node unstack) (known Node (not (on Block-X Block-Y))))) (then (reject operator unstack))) Table 2: A control rule from prodigy's Blocksworld. 2.2 Explanation-Based Learning Mitchell, Keller and Kedar-Cabelli describe a model of EBL, called Explanation-Based Generalization (EBG) <ref> [36] </ref>, which articulates many of the aspects common to various EBL systems. Two of the major contributions of the EBG model are the identification of explanations with proofs, giving a precise meaning to the term "explanation," and the clear specification of the input and output of EBL (Table 3). <p> EBL can be regarded as incrementally converting the target-concept definition into a DNF expression where each disjunct is a sufficient condition learned from a training example. "Pure" EBL, as described in <ref> [11, 36] </ref>, does not attempt to logically simplify the sufficient conditions it generates, a process that typically requires combining multiple sufficient conditions or disjuncts. For this reason, pure EBL frequently derives overly-specific control knowledge [15, 28, 29]. Consider a simple schematic example taken from [16].
Reference: [37] <author> T. M. Mitchell, P. E. Utgoff, and R. B. Banerji. </author> <title> Learning by experimentation: Acquiring and refining problem-solving heuristics. </title> <editor> In S. Michalski, Ryszard, G. Carbonell, Jaime, REFERENCES 44 and T. M. Mitchell, editors, </editor> <booktitle> Machine Learning An Artificial Intelligence Approach (volume I). </booktitle> <publisher> Morgan Kaufmann, </publisher> <year> 1983. </year>
Reference-contexts: 1 Introduction Explanation-Based Learning (EBL) [11, 36] has emerged as a standard technique for acquiring search-control knowledge (e.g. <ref> [27, 33, 37, 35, 47, 52] </ref>). 1 Recently, Prieditis [46], van Harmelen and Bundy [59] pointed to the similarity between Partial Evaluation (PE), a well-known program optimization technique [25, 58], and EBL, suggesting that an EBL-style analysis could be performed statically, without utilizing training examples.
Reference: [38] <author> S. S. Muchnick and N. D. Jones. </author> <title> Program Flow Analysis Theory and Applications. </title> <publisher> Prentice Hall, </publisher> <year> 1981. </year>
Reference-contexts: Its nodes are not states and its edges are not fully-instantiated operators. If we think of operators as functions being unfolded, the PSG can be viewed as a "call graph" for prodigy <ref> [38] </ref>. Although the PSG was developed independently, it is quite 3 A literal is a possibly negated atomic formula. 3 STATIC ANALYSIS OF FAILURE AND SUCCESS 7 similar to the rule/goal graph [57], and related graph representations of logic programs (e.g., [26]). <p> Unlike prodigy/ebl and static, the database systems do not perform conjunct reordering in concert with unfolding. * What representation of the program does the optimizer use? static uses Problem Space Graphs (PSGs). Many optimizers use similar graph representations of programs. Connection graphs [26], rule/goal graphs [57], and flow graphs <ref> [38] </ref> are some examples. * What is the complexity of the optimization? static's time and space complexity are close to linear in the size of its PSGs. The complexities of different optimizers vary widely. * Are the optimizations carried out for specific inputs? static is run once per problem space.
Reference: [39] <author> A. Newell and H. A. Simon. </author> <title> Human Problem Solving. </title> <publisher> Prentice Hall, </publisher> <year> 1972. </year>
Reference-contexts: Given an initial state and a goal expression, prodigy searches for a sequence of operators that will transform the initial state into a state that matches the goal expression. A sample prodigy operator appears in Table 1. prodigy's sole problem-solving method is a form of means-ends analysis <ref> [39] </ref>. Like strips [17], prodigy employs operator preconditions as its differences.
Reference: [40] <author> D. Ourston and R. J. Mooney. </author> <title> Changing the rules: a comprehensive approach to theroy refinement. </title> <booktitle> In Proceedings of the Eighth National Conference on Artificial Intelligence., </booktitle> <year> 1990. </year>
Reference-contexts: Section 6 contrasts static with standard partial evaluators and other static analyzers, and Section 7 concludes by considering design lessons for EBL systems based on the static case study. 1 EBL is also used to revise or repair "imperfect" theories (e.g. <ref> [8, 20, 40, 42, 48] </ref>). 2 BACKGROUND 2 2 Background This section is organized as follows. Section 2.1 describes the prodigy problem solver, which is the substrate for prodigy/ebl. Section 2.2 introduces standard EBL terminology, and sketches prodigy/ebl.
Reference: [41] <author> H. Partsch and R. Steinbruggen. </author> <title> Program transformation systems. </title> <journal> Computing Surveys, </journal> <volume> 15(3), </volume> <month> September </month> <year> 1983. </year>
Reference-contexts: I formulate the dimensions of the space as questions: * How does the optimizer handle recursion? static engages in partial problem space analysis, terminating the expansion of the PSG whenever recursion is encountered . In 9 See <ref> [41, 57] </ref> for extensive surveys. 6 RELATED WORK 29 contrast, much of the research on partial evaluation is concerned with effective policies for unfolding recursions (e.g. [58]). * Is the optimizer fully automatic? static is automatic but many optimizers are not (e.g. [9]). * What program transformations does the optimizer employ?
Reference: [42] <author> M. Pazzani. </author> <title> Learning Causal Relationships: An Integration of Empirical and Explanation-Based Learning Methods. </title> <type> PhD thesis, </type> <institution> University of California, Los An-geles, </institution> <year> 1988. </year>
Reference-contexts: Section 6 contrasts static with standard partial evaluators and other static analyzers, and Section 7 concludes by considering design lessons for EBL systems based on the static case study. 1 EBL is also used to revise or repair "imperfect" theories (e.g. <ref> [8, 20, 40, 42, 48] </ref>). 2 BACKGROUND 2 2 Background This section is organized as follows. Section 2.1 describes the prodigy problem solver, which is the substrate for prodigy/ebl. Section 2.2 introduces standard EBL terminology, and sketches prodigy/ebl.
Reference: [43] <author> J. Penberthy and D. Weld. UCPOP: </author> <title> A Sound, Complete, Partial Order Planner for ADL. </title> <note> In To appear in Proceedings of KR-92, </note> <month> October </month> <year> 1992. </year>
Reference-contexts: Thus, unless the planner anticipates goal interactions on its own, it will find static's analysis of goal interactions helpful. Work is currently underway to apply static-style PSG analysis to the UCPOP partial-order planner <ref> [43] </ref> and to a new subgoal-interleaving variant of prodigy [3]. 5 Comparing STATIC and PRODIGY/EBL This section answers the fundamental questions posed in the introduction by comparing static and prodigy/ebl along two dimensions: * Impact: the ability to speed up prodigy. * Cost: the time required to generate control knowledge.
Reference: [44] <author> M. A. Perez and O. Etzioni. </author> <title> DYNAMIC: a new role for training problems in EBL. </title> <booktitle> In Proceedings of the Ninth International Conference on Machine Learning. </booktitle> <publisher> Morgan Kaufmann, </publisher> <month> July </month> <year> 1992. </year> <note> An expanded version available as technical report CMU-CS-92-124. </note>
Reference-contexts: Static analysis has three advantages over standard EBL methods. First, while EBL is sensitive to incomplete or badly-ordered sequences of training examples, static analysis is not. Second, EBL often acquires overly-specific control knowledge by retaining extraneous features of its training examples <ref> [16, 44] </ref>. Finally, in contrast to EBL, a static analyzer need not invoke the problem solver to solve training problems|a costly process. However, because training problems "transmit" useful information about the task environment, it is not obvious that static analysis can actually generate effective control knowledge and do so tractably. <p> These principles suggest general lessons for the design of EBL systems: * Training examples can pinpoint learning opportunities, but should not determine EBL's explanations. In contrast to existing EBL systems, what EBL explains and how it is explained should be determined separately <ref> [44] </ref>. * A partial meta-level theory encoding sufficient (or necessary) conditions for EBL's target concepts is often preferable to a stronger theory, specifying necessary and sufficient conditions for the concepts, but resulting in more complex explanations [16]. * Nonrecursive explanations are often preferable to recursive ones [15]. * Typically, EBL's proofs <p> The dynamic system, which is based on this design principle, utilizes both training problems and problem-space analysis to generate prodigy control rules <ref> [44] </ref>. Like prodigy/ebl, dynamic utilizes training problems to pinpoint learning opportunities but, like static, dynamic generates control rules via PSG analysis. Thus, dynamic combines the focus and distribution-sensitivity of EBL with the global analysis performed by static. <p> Furthermore, the static case study demonstrates the effectiveness of PSG analysis as a method of generating search-control knowledge for general problem solvers. Finally, note that PSG analysis need not be completely static. As dynamic <ref> [44] </ref> demonstrates, training problems can be used to focus the analysis. Indeed, dynamic is just one example of the gamut of hybrid PE/EBL systems. Such systems can tailor their analysis to the problem distribution encountered, but still benefit from the PSG representation and associated analysis techniques.
Reference: [45] <author> A. E. </author> <title> Prieditis. Discovery of algorithms from weak methods. </title> <booktitle> In Proceedings of the international meeting on advances in learning, </booktitle> <pages> pages 37-52, </pages> <year> 1986. </year>
Reference-contexts: As a result, when learning from suc cess, prodigy/ebl forms distinct rules for the two-block tower, the three-block tower, and so on. Each rule is specific to towers of a given height. This is an instance of the infamous generalization-to-N problem <ref> [6, 45, 53] </ref>. As the state size increases, and increasingly taller towers are possible, more rules are necessary for guiding prodigy to choose unstack. static avoids the generalization-to-N problem by generating control rules based on nonre-cursive proofs.
Reference: [46] <author> A. E. </author> <title> Prieditis. Environment-guided program transformation. </title> <booktitle> In Proceedings of the AAAI Spring Symposium on Explanation-Based Learning, </booktitle> <year> 1988. </year>
Reference-contexts: 1 Introduction Explanation-Based Learning (EBL) [11, 36] has emerged as a standard technique for acquiring search-control knowledge (e.g. [27, 33, 37, 35, 47, 52]). 1 Recently, Prieditis <ref> [46] </ref>, van Harmelen and Bundy [59] pointed to the similarity between Partial Evaluation (PE), a well-known program optimization technique [25, 58], and EBL, suggesting that an EBL-style analysis could be performed statically, without utilizing training examples.
Reference: [47] <author> A. E. Prieditis and J. Mostow. Prolearn: </author> <title> towards a Prolog interpreter that learns. </title> <booktitle> In Proceedings of the National Conference on Artificial Intelligence. </booktitle> <publisher> Morgan Kaufmann, </publisher> <year> 1987. </year>
Reference-contexts: 1 Introduction Explanation-Based Learning (EBL) [11, 36] has emerged as a standard technique for acquiring search-control knowledge (e.g. <ref> [27, 33, 37, 35, 47, 52] </ref>). 1 Recently, Prieditis [46], van Harmelen and Bundy [59] pointed to the similarity between Partial Evaluation (PE), a well-known program optimization technique [25, 58], and EBL, suggesting that an EBL-style analysis could be performed statically, without utilizing training examples. <p> Finally, static anticipates goal clobbering and prerequisite violation whereas standard PE systems do not. In AI work, PE has been used to generate abstraction hierarchies for planning [7] and to reduce the match cost of rules learned via EBL <ref> [47, 29] </ref>. Concurrently with static, Letovsky [28] developed the prope system which generates macro-clauses by partially-evaluating pure PROLOG programs. <p> Each principle is illustrated by specific examples below. 7 DESIGN LESSONS FOR EBL SYSTEMS 33 7.1 The Pitfalls of Training Examples Most existing EBL systems generate explanations by directly translating a trace of the problem solver's behavior, when solving a training problem, into a logical proof <ref> [27, 33, 35, 47, 52, 56] </ref>. As a result, the problem solver's behavior on a training problem determines not only what EBL will explain but also how the explanation is constructed, yielding overly-specific control knowledge in many cases. <p> Namely: C if P However, pure EBL will not identify this condition. To address this and related problems, EBL systems such as prodigy/ebl include heuristic simplification methods that attempt to improve the generality of EBL's conditions via truth-preserving transformations <ref> [29, 47] </ref>. Unfortunately, these methods can only work if EBL encounters the appropriate training problems. In the above example, if EBL never learns the second sufficient condition, it is "stuck" with an overly-specific condition.
Reference: [48] <author> S. Rajamoney and G. DeJong. </author> <title> the classification, detection and handling of imperfect theory problems. </title> <booktitle> In Proceedings of the Tenth International Joint Conference on Artificial Intelligence, </booktitle> <address> Milan, Italy, </address> <month> Aug. </month> <year> 1987. </year>
Reference-contexts: Section 6 contrasts static with standard partial evaluators and other static analyzers, and Section 7 concludes by considering design lessons for EBL systems based on the static case study. 1 EBL is also used to revise or repair "imperfect" theories (e.g. <ref> [8, 20, 40, 42, 48] </ref>). 2 BACKGROUND 2 2 Background This section is organized as follows. Section 2.1 describes the prodigy problem solver, which is the substrate for prodigy/ebl. Section 2.2 introduces standard EBL terminology, and sketches prodigy/ebl.
Reference: [49] <author> K. R. Ryu and K. B. Irani. </author> <title> Learning from goal interactions in planning: goal stack analysis and generalization. </title> <booktitle> In Proceedings of AAAI-92. </booktitle> <publisher> AAAI Press, </publisher> <year> 1992. </year>
Reference-contexts: If a clobbering is found, and the two goals do not negate each other under , static forms a goal ordering rule in order to avoid the clobbering. A sample goal ordering rule appears in Table 10. As Ryu and Irani <ref> [49] </ref> demonstrate, introducing the appropriate co-designation on the variables in p and g can be rather subtle. Consider Ryu and Irani's Stripsworld example where p is (dr-closed D-X) and g is (inroom robot R-Y). <p> The algorithm runs in O (n 3 ) time where n is the number of subgoals. Ryu and Irani <ref> [49] </ref> describe an algorithm that relies on training examples to analyze goal interactions. The algorithm was tested in prodigy's benchmark problem spaces and shown to generate goal-ordering rules that are at least as effective as static's rules.
Reference: [50] <author> M. J. Schoppers. </author> <title> Representation and Automatic Synthesis of Reaction Plans. </title> <type> PhD thesis, </type> <institution> University of Illinois at Urbana-Champaign, </institution> <year> 1989. </year> <note> Available as technical report UIUCDCS-R-89-1546. REFERENCES 45 </note>
Reference-contexts: Knoblock's guarantees on the algorithm's behavior are analogous to my own: I compute a subset of the necessary goal interactions, and Knoblock computes a superset of the possible goal interactions. Universal Plans Schoppers <ref> [50] </ref> derives "universal plans" from problem-space descriptions. Universal plans are, essentially, sets of rules that tell an agent what to do in any given state. Schoppers partially evaluates problem-space definitions to derive universal plans. Like static, Schoppers only considers pairwise goal interactions.
Reference: [51] <author> P. Sestfot. </author> <title> Automatic call unfolding in a partial evaluator. </title> <editor> In D. Bjorner, A. P. Ershov, and N. D. Jones, editors, </editor> <title> Partial Evaluation and Mixed Computation. </title> <publisher> Elsevier Science Publishers, </publisher> <year> 1988. </year> <booktitle> Workshop Proceedings. </booktitle>
Reference-contexts: If the termination criterion is too conservative (e.g. never unfold calls) no optimization will be achieved, but if the criterion is too liberal (e.g. unfold all calls) the partial evaluator will fail to halt when unfolding recursive calls <ref> [51] </ref>. As van Harmelen and Bundy demonstrate, EBL algorithms unfold the domain theory guided by their training example and operationality criterion. This elaboration of PE is important because it provides EBL with a termination criterion. The theory is unfolded in accord with the choices made in the training example. <p> First and foremost, static utilizes (its own versions of) prodigy/ebl's multiple target concepts. The concepts facilitate a novel solution to a major open problem for PE: deciding when to terminate the unfolding of recursive calls <ref> [51, 58] </ref>. static avoids unfolding recursive calls altogether, relying on its "nonstandard" target concepts to yield effective control knowledge despite its strong termination criterion.
Reference: [52] <author> J. W. Shavlik. </author> <title> Acquiring recursive concepts and iterative concepts with explanation-based learning. </title> <journal> Machine Learning, </journal> <volume> 5(1), </volume> <year> 1990. </year>
Reference-contexts: 1 Introduction Explanation-Based Learning (EBL) [11, 36] has emerged as a standard technique for acquiring search-control knowledge (e.g. <ref> [27, 33, 37, 35, 47, 52] </ref>). 1 Recently, Prieditis [46], van Harmelen and Bundy [59] pointed to the similarity between Partial Evaluation (PE), a well-known program optimization technique [25, 58], and EBL, suggesting that an EBL-style analysis could be performed statically, without utilizing training examples. <p> In contrast to most Prolog implementations of EBL (e.g., <ref> [21, 52, 56] </ref>), which only reorder Horn Clauses, static (and prodigy/ebl) reorder both Horn clauses and conjuncts. Conjunct ordering has been studied extensively in the database community (e.g. [60]) and by Smith [54]. <p> Each principle is illustrated by specific examples below. 7 DESIGN LESSONS FOR EBL SYSTEMS 33 7.1 The Pitfalls of Training Examples Most existing EBL systems generate explanations by directly translating a trace of the problem solver's behavior, when solving a training problem, into a logical proof <ref> [27, 33, 35, 47, 52, 56] </ref>. As a result, the problem solver's behavior on a training problem determines not only what EBL will explain but also how the explanation is constructed, yielding overly-specific control knowledge in many cases.
Reference: [53] <author> J. W. Shavlik and G. F. DeJong. </author> <title> Building a computer model of classical mechanics. </title> <booktitle> In Proceedings of the Seventh Annual Conference of the Cognitive Science Society, </booktitle> <pages> pages 351-355, </pages> <year> 1985. </year>
Reference-contexts: As a result, when learning from suc cess, prodigy/ebl forms distinct rules for the two-block tower, the three-block tower, and so on. Each rule is specific to towers of a given height. This is an instance of the infamous generalization-to-N problem <ref> [6, 45, 53] </ref>. As the state size increases, and increasingly taller towers are possible, more rules are necessary for guiding prodigy to choose unstack. static avoids the generalization-to-N problem by generating control rules based on nonre-cursive proofs.
Reference: [54] <author> D. Smith and M. Genesereth. </author> <title> Ordering conjunctive queries. </title> <journal> artificial intelligence, </journal> <volume> 26(2) </volume> <pages> 171-215, </pages> <month> May </month> <year> 1985. </year> <note> Also Stanford HPP Report HP-82-9. </note>
Reference-contexts: In contrast to most Prolog implementations of EBL (e.g., [21, 52, 56]), which only reorder Horn Clauses, static (and prodigy/ebl) reorder both Horn clauses and conjuncts. Conjunct ordering has been studied extensively in the database community (e.g. [60]) and by Smith <ref> [54] </ref>. By and large, the database work focuses on heuristics that order conjunctive subgoals based on factors such as domain size and number of instantiated arguments. Additional heuristics are used to decompose queries into subqueries that can be processed independently.
Reference: [55] <author> D. E. Smith. </author> <title> Controlling Inference. </title> <type> PhD thesis, </type> <institution> Stanford, </institution> <year> 1986. </year> <note> Available as technical report STAN-CS-86-1107. </note>
Reference-contexts: Much of the classical work on optimizing compilers (see [1]) focuses on optimizing arithmetic operations in programs written in imperative languages and is not relevant for this reason. Similarly, much of the work on optimizing database queries is specific to relational algebra, and as Smith points out <ref> [55] </ref>, many of the optimizations of relational algebra queries are obtained automatically as a side effect of the partial instantiation of conjunctive expressions that is performed by search "engines" such as Prolog and prodigy.
Reference: [56] <author> D. Subramanian and R. Feldman. </author> <title> The utility of EBL in recursive domain theories. </title> <booktitle> In Proceedings of the Eighth National Conference on Artificial Intelligence, </booktitle> <year> 1990. </year>
Reference-contexts: In contrast to most Prolog implementations of EBL (e.g., <ref> [21, 52, 56] </ref>), which only reorder Horn Clauses, static (and prodigy/ebl) reorder both Horn clauses and conjuncts. Conjunct ordering has been studied extensively in the database community (e.g. [60]) and by Smith [54]. <p> Each principle is illustrated by specific examples below. 7 DESIGN LESSONS FOR EBL SYSTEMS 33 7.1 The Pitfalls of Training Examples Most existing EBL systems generate explanations by directly translating a trace of the problem solver's behavior, when solving a training problem, into a logical proof <ref> [27, 33, 35, 47, 52, 56] </ref>. As a result, the problem solver's behavior on a training problem determines not only what EBL will explain but also how the explanation is constructed, yielding overly-specific control knowledge in many cases.
Reference: [57] <author> J. D. Ullman. </author> <title> Database and Knowledge-base systems, volume II. </title> <publisher> Computer Science Press, </publisher> <year> 1989. </year>
Reference-contexts: Although the PSG was developed independently, it is quite 3 A literal is a possibly negated atomic formula. 3 STATIC ANALYSIS OF FAILURE AND SUCCESS 7 similar to the rule/goal graph <ref> [57] </ref>, and related graph representations of logic programs (e.g., [26]). <p> Binding analysis of this sort is a widely-used technique in program optimization <ref> [57, chapter 12] </ref>. <p> I formulate the dimensions of the space as questions: * How does the optimizer handle recursion? static engages in partial problem space analysis, terminating the expansion of the PSG whenever recursion is encountered . In 9 See <ref> [41, 57] </ref> for extensive surveys. 6 RELATED WORK 29 contrast, much of the research on partial evaluation is concerned with effective policies for unfolding recursions (e.g. [58]). * Is the optimizer fully automatic? static is automatic but many optimizers are not (e.g. [9]). * What program transformations does the optimizer employ? <p> Unlike prodigy/ebl and static, the database systems do not perform conjunct reordering in concert with unfolding. * What representation of the program does the optimizer use? static uses Problem Space Graphs (PSGs). Many optimizers use similar graph representations of programs. Connection graphs [26], rule/goal graphs <ref> [57] </ref>, and flow graphs [38] are some examples. * What is the complexity of the optimization? static's time and space complexity are close to linear in the size of its PSGs.
Reference: [58] <author> F. van Harmelen. </author> <title> The limitations of partial evaluation. </title> <booktitle> In Logic-Based Knowledge Representation, </booktitle> <pages> pages 87-112. </pages> <publisher> MIT Press, </publisher> <address> Cambridge, MA, </address> <year> 1989. </year>
Reference-contexts: 1 Introduction Explanation-Based Learning (EBL) [11, 36] has emerged as a standard technique for acquiring search-control knowledge (e.g. [27, 33, 37, 35, 47, 52]). 1 Recently, Prieditis [46], van Harmelen and Bundy [59] pointed to the similarity between Partial Evaluation (PE), a well-known program optimization technique <ref> [25, 58] </ref>, and EBL, suggesting that an EBL-style analysis could be performed statically, without utilizing training examples. This suggestion is controversial because EBL is perceived as a dynamic technique that depends on examples to focus the learning process. <p> In 9 See [41, 57] for extensive surveys. 6 RELATED WORK 29 contrast, much of the research on partial evaluation is concerned with effective policies for unfolding recursions (e.g. <ref> [58] </ref>). * Is the optimizer fully automatic? static is automatic but many optimizers are not (e.g. [9]). * What program transformations does the optimizer employ? static employs unfolding and reordering transformations. <p> First and foremost, static utilizes (its own versions of) prodigy/ebl's multiple target concepts. The concepts facilitate a novel solution to a major open problem for PE: deciding when to terminate the unfolding of recursive calls <ref> [51, 58] </ref>. static avoids unfolding recursive calls altogether, relying on its "nonstandard" target concepts to yield effective control knowledge despite its strong termination criterion.
Reference: [59] <author> F. van Harmelen and A. Bundy. </author> <title> Explanation-based generalisation = partial evaluation. </title> <journal> Artificial Intelligence, </journal> <volume> 36, </volume> <year> 1988. </year> <note> Research Note. </note>
Reference-contexts: 1 Introduction Explanation-Based Learning (EBL) [11, 36] has emerged as a standard technique for acquiring search-control knowledge (e.g. [27, 33, 37, 35, 47, 52]). 1 Recently, Prieditis [46], van Harmelen and Bundy <ref> [59] </ref> pointed to the similarity between Partial Evaluation (PE), a well-known program optimization technique [25, 58], and EBL, suggesting that an EBL-style analysis could be performed statically, without utilizing training examples. <p> First, prodigy/ebl utilizes multiple target concepts. Second, prodigy/ebl derives control rules based on the sufficient conditions it computes. Third, prodigy/ebl performs post-processing of the control rules in an effort to increase their effectiveness. 2.3 Partial Evaluation Partial evaluation is a program optimization technique inspired by Kleene's S-M-N theorem <ref> [22, 59] </ref>. <p> This elaboration of PE is important because it provides EBL with a termination criterion. The theory is unfolded in accord with the choices made in the training example. A partial evaluator will only match EBL's performance if it is given an appropriate termination criterion. In <ref> [59] </ref>, van Harmelen and Bundy describe a simple partial evaluator that is able to emulate EBL, but they do not specify an appropriate termination criterion. static solves this problem by combining (its own versions of) prodigy/ebl's multiple target concepts with a simple termination criterion: unfold only nonrecursive calls. 2 As shown
Reference: [60] <author> D. Warren. </author> <title> Efficient processing of interactive relational database queries expressed in logic. </title> <booktitle> In Proceedings of the Seventh VLDB conference, </booktitle> <pages> pages 272-281, </pages> <year> 1981. </year> <note> IEEE. </note>
Reference-contexts: In contrast to most Prolog implementations of EBL (e.g., [21, 52, 56]), which only reorder Horn Clauses, static (and prodigy/ebl) reorder both Horn clauses and conjuncts. Conjunct ordering has been studied extensively in the database community (e.g. <ref> [60] </ref>) and by Smith [54]. By and large, the database work focuses on heuristics that order conjunctive subgoals based on factors such as domain size and number of instantiated arguments. Additional heuristics are used to decompose queries into subqueries that can be processed independently.
References-found: 60

