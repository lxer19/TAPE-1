URL: ftp://ftp.csd.uu.se/pub/papers/reports/0078/7-demoen+maris.ps.gz
Refering-URL: http://www.informatik.uni-trier.de/~ley/db/conf/iclp/iclp94-w6.html
Root-URL: http://www.aic.nrl.navy.mil/~aha/people.html
Email: -bimbart, greet-@cs.kuleuven.ac.be  
Title: A comparison of some schemes for translating logic to C.  
Author: Bart Demoen Greet Maris 
Address: Celestijnenlaan 200 A B-3001 Leuven Belgium  
Affiliation: Department of Computer Science, K.U.Leuven  
Note: 1 of 13  
Abstract: The general improvement of C compilers, and some new non standard features of gcc have made it more attractive to compile (logic) to C: it is no longer unthinkable that the speed of a native code optimizer can be matched and even beaten by a scheme that compiles to C and lets most of the hard work be done by the C compiler. The new features, especially gcc's treatment of labels as first class types, are a clear invitation to abandon native code generators. Also, the possibility to assign hardware registers to global variables looks attractive at first sight. Three schemes for exploiting a C compiler in the compilation of different languages, are examined and their effectiveness is measured. The conclusion is that it is probably better not to make use of all the features gcc offers. We also show that if C compilers were a bit smarter about compiling the C switch statement, compliance to standard C would become even more attractive. The measurements were done on different risc platforms and the conclusions seem to hold generally. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> S. Janson and S. Haridi, </author> <title> Programming Paradigms of the Andorra Kernel Language, </title> <booktitle> in Proceedings of The International Logic Programming Symposium, </booktitle> <editor> ed. V. Saraswat, </editor> <publisher> The MIT Press, </publisher> <address> Cambridge, Massachusetts, </address> <year> 1991. </year>
Reference-contexts: Even implementations that do not adhere directly to the WAM instruction set, should often be classified as belonging to the WAM family, like [11, 12] and many implementations of languages that differ substantially from Prolog, are based on WAM <ref> [1] </ref>. So, the choice of Prolog as the red thread through the paper is by no means an unfortunate accident or a serious limitation, as the implementation of Prolog has modelled the implementation of many other languages.
Reference: [2] <author> B. Hausman. </author> <title> Turbo Erlang: approaching the Speed of C, in Implementations of Logic Programming Systems, </title> <note> ed. Evan Tick, Kluwer 1994 (to appear) </note>
Reference-contexts: Moreover, global data is used to represent bindings, terms and pass arguments to procedures. In the recent past, three languages have been implemented by compiling them to C first: Janus [3], Erlang <ref> [2] </ref> and KL1 [4]. They all three belong to the class of logic languages - 2 of 13 although Erlang could as well be thought of as a functional language, but it does share some characteristics with logic. <p> The full C code for some of the benchmarks as used for the timings, can be found in the appendices. The complete benchmark 3 of 13 set is obtainable from the authors. We will not go into the details of the languages Janus [3], Erlang <ref> [2] </ref> and KL1 [4]: the reader is referred to the appropriate literature. 2. 1. <p> The switch statement has disappeared. The two versions of this scheme without and with jump labels on the goal stack - will be referred to as jc and jclab. Note however that the use of jump labels in jclab, concerns local labels. 2. 2. Erlang Erlang <ref> [2] </ref> uses both global labels and global registers.
Reference: [3] <author> D. Gudeman, K. De Bosschere and S. Debray, </author> <title> jc: An Efficient and Portable Sequential Implementation of Janus, </title> <booktitle> in Proceedings of the Joint International Conference on and Symposium on Logic Programming 1992, </booktitle> <pages> pp 399 - 413, </pages> <publisher> MIT Press, </publisher> <year> 1992. </year>
Reference-contexts: Moreover, global data is used to represent bindings, terms and pass arguments to procedures. In the recent past, three languages have been implemented by compiling them to C first: Janus <ref> [3] </ref>, Erlang [2] and KL1 [4]. They all three belong to the class of logic languages - 2 of 13 although Erlang could as well be thought of as a functional language, but it does share some characteristics with logic. <p> The full C code for some of the benchmarks as used for the timings, can be found in the appendices. The complete benchmark 3 of 13 set is obtainable from the authors. We will not go into the details of the languages Janus <ref> [3] </ref>, Erlang [2] and KL1 [4]: the reader is referred to the appropriate literature. 2. 1. Janus The basic approach in Janus [3] is to compile a complete program to one C function which is essentially one switch statement of which the case labels represent entries of predicates and to which <p> The complete benchmark 3 of 13 set is obtainable from the authors. We will not go into the details of the languages Janus <ref> [3] </ref>, Erlang [2] and KL1 [4]: the reader is referred to the appropriate literature. 2. 1. Janus The basic approach in Janus [3] is to compile a complete program to one C function which is essentially one switch statement of which the case labels represent entries of predicates and to which jump labels are added so that the call to the first goal in a body, doesnt have to pass by the switch:
Reference: [4] <author> T. Chikayama, T. Fujise and D. Sekita, </author> <title> A Portable and Efficient Implementation of KL1, </title> <booktitle> in ICOT/NSF Workshop on Parallell Logic Programming and its Programming Environments, </booktitle> <institution> CIS-TR-94-04, Department of Computer and Information Science, University of Oregon, </institution> <month> March </month> <year> 1994. </year>
Reference-contexts: Moreover, global data is used to represent bindings, terms and pass arguments to procedures. In the recent past, three languages have been implemented by compiling them to C first: Janus [3], Erlang [2] and KL1 <ref> [4] </ref>. They all three belong to the class of logic languages - 2 of 13 although Erlang could as well be thought of as a functional language, but it does share some characteristics with logic. <p> The full C code for some of the benchmarks as used for the timings, can be found in the appendices. The complete benchmark 3 of 13 set is obtainable from the authors. We will not go into the details of the languages Janus [3], Erlang [2] and KL1 <ref> [4] </ref>: the reader is referred to the appropriate literature. 2. 1. <p> We refer to these two versions as erl and erlreg. Neither is ANSI C. 2. 3. KLIC The C implementation of KL1 <ref> [4] </ref> is called KLIC: a single module is compiled to a C function exactly like in the Janus scheme. Switching between modules requires the help of a driver which dispatches between modules.
Reference: [5] <author> R. Moolenaar and B. Demoen, </author> <title> A parallell implementation for AKL, </title> <booktitle> in Programming Language Implementation and Logic Programming: PLILP 93, </booktitle> <address> Tallinn, Estonia, </address> <year> 1993. </year> <note> 10 of 13 </note>
Reference-contexts: We started this comparison because we were at the point of implementing AKL <ref> [5] </ref> using the compilation to C technique: since the three schemes presented here existed already, we wanted to make a conscious choice. We have also deliberately chosen goal stacking, because we believe that this offers more implementation freedom when implementing a parallel system.
Reference: [6] <author> R. M. Stallman, </author> <title> Using and Porting GNU CC, manual. </title>
Reference-contexts: So, the choice of Prolog as the red thread through the paper is by no means an unfortunate accident or a serious limitation, as the implementation of Prolog has modelled the implementation of many other languages. In gcc <ref> [6] </ref> there are two features that are of particular interest to compiler writers, but which have the disadvantage (at the moment) of being non-standard [7]: in gcc, there is a label type and a goto statement can refer to a variable of the label type; secondly, a register declaration can be
Reference: [7] <author> B.W. Kernighan and D.M. Ritchie, </author> <title> The C Programming Language -2nd Edition, </title> <publisher> Prentice Hall, </publisher> <year> 1988, </year> <note> ISBN 0-13-110632-8. </note>
Reference-contexts: In gcc [6] there are two features that are of particular interest to compiler writers, but which have the disadvantage (at the moment) of being non-standard <ref> [7] </ref>: in gcc, there is a label type and a goto statement can refer to a variable of the label type; secondly, a register declaration can be given for global variables, i.e. variables that are visible over function boundaries. For the compiler writer to C, both look attractive.
Reference: [8] <author> K. De Bosschere and P. Tarau, </author> <title> A continuation based Prolog-to-C mapping, </title> <booktitle> in Proceedings of the ACM Symposium on Applied Computing (SAC '94), </booktitle> <address> Phoenix, Arizona, </address> <month> March, </month> <year> 1994 </year>
Reference-contexts: Since C compilers will certainly become better, the optimizations might be included in the future, so that the preference for the (ANSI C) Janus compilation scheme, becomes stronger. 6. Other schemes There have been other attempts to compile Prolog to C; we mention only the recent <ref> [8] </ref> which differs mainly from jc in that it starts from a binarized program (see [11]). In [9], the Prolog to C compiler is built on top of a traditional WAM compiler. The WAM instructions are expanded in-line or they become function calls.
Reference: [9] <author> M.R. Levy and R.N. Horspool, </author> <title> Translating Prolog to C: a WAM-based approach, </title> <booktitle> in Proceedings of the Second Compulog Network Area Meeting on Programming Languages, and the workshop on Logic Languages in Pisa, </booktitle> <address> Italy, </address> <month> May </month> <year> 1993. </year>
Reference-contexts: Other schemes There have been other attempts to compile Prolog to C; we mention only the recent [8] which differs mainly from jc in that it starts from a binarized program (see [11]). In <ref> [9] </ref>, the Prolog to C compiler is built on top of a traditional WAM compiler. The WAM instructions are expanded in-line or they become function calls. The call sequence of the predicates is controlled by a dispatching loop.
Reference: [10] <author> D. H. D. Warren, </author> <title> An abstract Prolog instruction set, </title> <type> Technical Report no 309, </type> <institution> p.30, SRI International, </institution> <address> Menlo Park, </address> <year> 1983. </year>
Reference-contexts: Since 1983, Prolog has often been implemented starting from the WAM <ref> [10] </ref> for which either an emulator, threaded code interpreter or a native code generator has been written.
Reference: [11] <author> P. Tarau and M. Boyer, </author> <title> Elementary Logic Programs, </title> <booktitle> in Proceedings of PLILP90, </booktitle> <pages> pp. 159-173, </pages> <editor> (eds) P. Deransart & J. Maluszynski, </editor> <publisher> Springer-Verlag 1990 </publisher>
Reference-contexts: Even implementations that do not adhere directly to the WAM instruction set, should often be classified as belonging to the WAM family, like <ref> [11, 12] </ref> and many implementations of languages that differ substantially from Prolog, are based on WAM [1]. <p> Other schemes There have been other attempts to compile Prolog to C; we mention only the recent [8] which differs mainly from jc in that it starts from a binarized program (see <ref> [11] </ref>). In [9], the Prolog to C compiler is built on top of a traditional WAM compiler. The WAM instructions are expanded in-line or they become function calls. The call sequence of the predicates is controlled by a dispatching loop.
Reference: [12] <author> P. Van Roy, </author> <title> Can Logic Programming Execute as Fast as Imperative Programming ? Report No. </title> <address> UCB/CSD 90/600 Dec 1990, Berkeley, California 94720 </address>
Reference-contexts: Even implementations that do not adhere directly to the WAM instruction set, should often be classified as belonging to the WAM family, like <ref> [11, 12] </ref> and many implementations of languages that differ substantially from Prolog, are based on WAM [1]. <p> stack is not a proper stack as soon as backtracking comes into the picture: this imposes some painful and inefficient work arounds it is difficult for a garbage collector to find active environment variables in older register windows most important however: the penalty of window overflows is very high; in <ref> [12] </ref>, it is reported that Aquarius is faster for the tak benchmark than C; this is due to the fact that in Aquarius no register window overflows occur during execution of the benchmark: Aquarius does indeed not map the environments to the C stack So without provisions to avoid register window
References-found: 12

