URL: http://www.research.microsoft.com/~ruf/files/popl97-preprint.ps
Refering-URL: http://www.research.microsoft.com/~ruf/preprint.htm
Root-URL: http://www.research.microsoft.com
Email: erikruf@microsoft.com  
Title: Partitioning Dataflow Analyses Using Types  
Author: Erik Ruf 
Address: One Microsoft Way, Redmond, WA 98052-6399 USA  
Affiliation: Microsoft Research  
Abstract: We present a simple method for partitioning a dataflow analysis problem into a series of related subproblems. We use type information (either declared by the programmer, or computed via nonstandard type inference) to conservatively approximate analysis-time data dependences between program quantities. This dependence information frees us from the need to model all program quantities simultaneously in a single, monolithic analysis. Instead, we can model quantities in any order, or even in parallel, so long as we respect the dependences. Our approach is independent of the means used to solve the subproblems, and enables the wider application of existing sparse approaches previously restricted to "separable" dataflow problems. Preliminary experiments applying our technique to flow-sensitive points-to analysis of C programs have achieved storage savings of 1.3-7.2x over existing methods. 
Abstract-found: 1
Intro-found: 1
Reference: [CC77] <author> P. Cousot and R. Cousot. </author> <title> Abstract interpretation: A unified lattice model for static analysis of programs by construction or approximation of fixpoints. </title> <booktitle> In Proceedings of the Fourth Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 238-252, </pages> <address> Los Angeles, </address> <month> January </month> <year> 1977. </year>
Reference-contexts: Our initial experiments, which focus on reducing the peak memory usage of pointer alias 9 This stands to reason, given that abstract-interpretation-based <ref> [CC77] </ref> dataflow analyses are themselves provably conservative abstractions of runtime program behavior. analysis, achieved memory savings both alone and in conjunction with sparse evaluation graph techniques.
Reference: [CCF91] <author> J.-D. Choi, R. Cytron, and J. Ferrante. </author> <title> Automatic construction of sparse data flow evaluation graphs. </title> <booktitle> In Proceedings of the Eighteenth Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 55-66. </pages> <publisher> ACM Press, </publisher> <month> January </month> <year> 1991. </year>
Reference-contexts: Efficiency improvements for separable problems have been obtained using specialized program representations such as sparse evaluation graphs <ref> [CCF91] </ref> and sparse scheduling techniques such as the slotwise [DRZ92] and tabulation methods [RHS95]. Unfortunately, many interesting dataflow problems, such as constant propagation and pointer alias analysis, are not separable; existing techniques are forced to model all relevant quantities simultaneously. <p> We believe that virtually any reduction in the intermediate memory consumption of such dataflow analyses are likely to have positive effects on speed in practice. Because partitioning enables the application of sparse representation techniques such as <ref> [CCF91] </ref> to the individual subproblems, we can also hope to gain speed by such means. <p> Program representations that directly model producer-consumer dependences, such as static single assignment (SSA) form [CFR + 91] and its many relatives represent each quantity only at statically-determined definition and meet points, but assure that each use point can locate the appropriate model in constant time. These are general representations; <ref> [CCF91, Ruf95b] </ref> build similar graphs for analysis-specific purposes. Similar effects are achieved by systems that directly simplify the dataflow equations at each program point [DGS94], or use a hierarchical control representation to avoid modeling quantities in regions where their values are not changed [JPP94]. <p> Still other schemes leave the program representation intact, and dynamically represent an analysis-specific producer-consumer relation in an efficient auxiliary data structure [CWZ90, WL95]. The sparse store model used in the estimates of Section 5 is similar to the static dependence graphs constructed by SEG construction <ref> [CCF91] </ref> and store splitting [Ste95] and the dominator-based store models of [CWZ90, WL95].
Reference: [CFR + 91] <author> R. Cytron, J. Ferrante, B. K. Rosen, M. N. Wegman, and F. K. Zadeck. </author> <title> Efficiently computing static single assignment form and the control dependence graph. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 13(4) </volume> <pages> 451-490, </pages> <month> October </month> <year> 1991. </year>
Reference-contexts: Quantity-based partitioning targets this factor by reducing the number of program quantities modeled simultaneously. A large body of work on sparse representations targets factor (3). Program representations that directly model producer-consumer dependences, such as static single assignment (SSA) form <ref> [CFR + 91] </ref> and its many relatives represent each quantity only at statically-determined definition and meet points, but assure that each use point can locate the appropriate model in constant time. These are general representations; [CCF91, Ruf95b] build similar graphs for analysis-specific purposes.
Reference: [CWZ90] <author> D. R. Chase, M. Wegman, and F. K. Zadeck. </author> <title> Analysis of pointers and structures. </title> <booktitle> In Proceedings of the SIGPLAN '90 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 296-310, </pages> <address> White Plains, NY, </address> <month> June 20-22, </month> <year> 1990. </year>
Reference-contexts: Still other schemes leave the program representation intact, and dynamically represent an analysis-specific producer-consumer relation in an efficient auxiliary data structure <ref> [CWZ90, WL95] </ref>. The sparse store model used in the estimates of Section 5 is similar to the static dependence graphs constructed by SEG construction [CCF91] and store splitting [Ste95] and the dominator-based store models of [CWZ90, WL95]. <p> representation intact, and dynamically represent an analysis-specific producer-consumer relation in an efficient auxiliary data structure <ref> [CWZ90, WL95] </ref>. The sparse store model used in the estimates of Section 5 is similar to the static dependence graphs constructed by SEG construction [CCF91] and store splitting [Ste95] and the dominator-based store models of [CWZ90, WL95]. Previous publications on this topic have not provided empirical data; our results (shown in factor of 85 in space usage at analysis time. 8 Conclusion Partitioning of dataflow analyses is useful for reducing memory consumption, enabling parallel analysis, and simplifying the representations of dataflow values.
Reference: [Deu94] <author> A. Deutsch. </author> <title> Interprocedural may-alias analysis for pointers: Beyond k-limiting. </title> <booktitle> In Proceedings of the SIGPLAN '94 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 230-239. </pages> <publisher> ACM Press, </publisher> <year> 1994. </year>
Reference-contexts: Often, types are used as the base for a more complex analysis; e.g., Deutsch <ref> [Deu94] </ref> uses (trusted) type information to determine the structure of the analysis domains used to represent alias relationships among structured heap data. Alternatively, explicit specification types such as those of ADDS [HH92] can be used to restrict the dataflow solution, improving its precision.
Reference: [DGS94] <author> E. Duesterwald, R. Gupta, and M. L. Soffa. </author> <title> Reducing the cost of data flow analysis by congruence partitioning. </title> <booktitle> In CC '94: Fifth International Conference on Compiler Construction, </booktitle> <pages> pages 357-373, </pages> <month> April </month> <year> 1994. </year>
Reference-contexts: These are general representations; [CCF91, Ruf95b] build similar graphs for analysis-specific purposes. Similar effects are achieved by systems that directly simplify the dataflow equations at each program point <ref> [DGS94] </ref>, or use a hierarchical control representation to avoid modeling quantities in regions where their values are not changed [JPP94]. Still other schemes leave the program representation intact, and dynamically represent an analysis-specific producer-consumer relation in an efficient auxiliary data structure [CWZ90, WL95].
Reference: [DRZ92] <author> D. M. Dhamdhere, B. K. Rosen, and F. K. Zadeck. </author> <title> How to analyze large programs efficiently and informatively. </title> <booktitle> In Proceedings of the SIGPLAN '92 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 212-223. </pages> <publisher> ACM Press, </publisher> <month> June </month> <year> 1992. </year>
Reference-contexts: Efficiency improvements for separable problems have been obtained using specialized program representations such as sparse evaluation graphs [CCF91] and sparse scheduling techniques such as the slotwise <ref> [DRZ92] </ref> and tabulation methods [RHS95]. Unfortunately, many interesting dataflow problems, such as constant propagation and pointer alias analysis, are not separable; existing techniques are forced to model all relevant quantities simultaneously. This paper describes a way to extend quantity-based partitioning to non-separable problems.
Reference: [Hen91] <author> F. Henglein. </author> <title> Efficient type inference for higher-order binding-time analysis. </title> <booktitle> In Functional Programming and Computer Architecture, </booktitle> <pages> pages 448-472, </pages> <year> 1991. </year>
Reference-contexts: In most cases, however, the declared type information is either untrustworthy or overly coarse. For this and other reasons, several researchers have developed dataflow analyses that operate by inferring nonstandard types. Henglein was the first to use type inference to perform binding time analysis in almost linear time <ref> [Hen91] </ref>, and later applied a similar approach to optimization problems such as unboxing [Hen92]. Henglein's algorithm inspired Steensgaard's type-based almost-linear points-to analyses for C [Ste96b, Ste96a], which we used in Section 5.
Reference: [Hen92] <author> F. Henglein. </author> <title> Global tagging optimization by type inference. </title> <booktitle> In Proceedings of The Conference on LISP and Functional Programming, </booktitle> <pages> pages 205-215, </pages> <year> 1992. </year> <month> 11 </month>
Reference-contexts: For this and other reasons, several researchers have developed dataflow analyses that operate by inferring nonstandard types. Henglein was the first to use type inference to perform binding time analysis in almost linear time [Hen91], and later applied a similar approach to optimization problems such as unboxing <ref> [Hen92] </ref>. Henglein's algorithm inspired Steensgaard's type-based almost-linear points-to analyses for C [Ste96b, Ste96a], which we used in Section 5. Zhang et. al's flow-insensitive alias analysis [ZRL96a] infers equivalence classes of object names which can be considered as types.
Reference: [HH92] <author> L. J. Hendren and J. Hummel. </author> <title> Abstractions for recursive pointer data structures: Improving the analysis and transformation of imperative programs. </title> <booktitle> In Proceedings of the SIGPLAN '92 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 249-260. </pages> <publisher> ACM Press, </publisher> <month> June </month> <year> 1992. </year>
Reference-contexts: Often, types are used as the base for a more complex analysis; e.g., Deutsch [Deu94] uses (trusted) type information to determine the structure of the analysis domains used to represent alias relationships among structured heap data. Alternatively, explicit specification types such as those of ADDS <ref> [HH92] </ref> can be used to restrict the dataflow solution, improving its precision. In most cases, however, the declared type information is either untrustworthy or overly coarse. For this and other reasons, several researchers have developed dataflow analyses that operate by inferring nonstandard types.
Reference: [JP90] <author> M. Jourdan and D. Parigot. </author> <title> Techniques for improving grammar flow analysis. </title> <booktitle> In 3rd European Symposium on Programming, number 432 in Lecture Notes in Computer Science, </booktitle> <pages> pages 240-255. </pages> <address> Berlin: </address> <publisher> Springer-Verlag, </publisher> <year> 1990. </year>
Reference-contexts: Grammar flow analysis is an analogue of dataflow analysis that propagates information on context-free grammars rather than control-flow graphs. Such systems <ref> [JP90] </ref> use a variety of partitioning and sorting techniques that appear very similar to our topological sort and size heuristics. 7.2 Dataflow Analysis Using Types In some cases, programmer-declared type information is sufficient to serve as a dataflow solution; for example, in a type-safe language, values of incomparable types cannot be
Reference: [JPP94] <author> R. Johnson, D. Pearson, and K. Pingali. </author> <title> The program structure tree: Computing control regions in linear time. </title> <booktitle> In Proceedings of the SIGPLAN '94 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 171-185, </pages> <address> Orlando, Florida, June 20-24, 1994. </address> <publisher> ACM Press. </publisher>
Reference-contexts: These are general representations; [CCF91, Ruf95b] build similar graphs for analysis-specific purposes. Similar effects are achieved by systems that directly simplify the dataflow equations at each program point [DGS94], or use a hierarchical control representation to avoid modeling quantities in regions where their values are not changed <ref> [JPP94] </ref>. Still other schemes leave the program representation intact, and dynamically represent an analysis-specific producer-consumer relation in an efficient auxiliary data structure [CWZ90, WL95].
Reference: [LR91] <author> W. Landi and B. G. Ryder. </author> <title> Pointer-induced aliasing: A problem classification. </title> <booktitle> In Proceedings of the Eighteenth Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 93-103. </pages> <publisher> ACM Press, </publisher> <month> January </month> <year> 1991. </year>
Reference-contexts: Our approach, being quantity-based rather than point-based, is orthogonal to elimination-based techniques, and thus might achieve finer-grained parallelism in combination with them. 6.3 Simplifying dataflow representations This work was partially inspired by Landi and Ryder's work <ref> [LR91, LR92] </ref> on alias analyses for languages having only single-level pointers (e.g., pointers denoting only scalar values). Such languages are convenient to analyze because every alias induced by a procedure can be attributed to a single alias holding on entry to that procedure.
Reference: [LR92] <author> W. Landi and B. G. Ryder. </author> <title> A safe approximate algorithm for interprocedural pointer aliasing. </title> <booktitle> In Proceedings of the SIGPLAN '92 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 235-248. </pages> <publisher> ACM Press, </publisher> <month> June </month> <year> 1992. </year>
Reference-contexts: Our approach, being quantity-based rather than point-based, is orthogonal to elimination-based techniques, and thus might achieve finer-grained parallelism in combination with them. 6.3 Simplifying dataflow representations This work was partially inspired by Landi and Ryder's work <ref> [LR91, LR92] </ref> on alias analyses for languages having only single-level pointers (e.g., pointers denoting only scalar values). Such languages are convenient to analyze because every alias induced by a procedure can be attributed to a single alias holding on entry to that procedure.
Reference: [LRF94] <author> Y.-f. Lee, B. G. Ryder, and M. E. Fiuczynski. </author> <title> Region analysis: A parallel elimination method for data flow analysis. </title> <booktitle> In International Conference on Computer Languages, </booktitle> <pages> pages 31-42. </pages> <publisher> IEEE Computer Society, </publisher> <month> May </month> <year> 1994. </year>
Reference-contexts: We could just as easily evaluate unrelated partitions in parallel on a multiprocessor or distributed system. Previous approaches to parallelization of dataflow analyses <ref> [LRF94] </ref> have focused on elimination analyses, where the per-processor tasks consist of summarizing and propagating solutions for distinct regions of the control flow graph.
Reference: [OJ95] <author> R. O'Callahan and D. Jackson. </author> <title> Detecting shared representations using type inference. </title> <type> Technical Report CMU-CS-95-202, </type> <institution> School of Computer Science, Carnegie-Mellon University, </institution> <month> September </month> <year> 1995. </year>
Reference-contexts: symbol tables, we are able to partition the analysis of Sym * quantities into 3 We must be careful to ensure that the type inference's notion of dependence is a conservative approximation of any dependence that might occur at analysis time; for this example, the system of O'Callahan and Jackson <ref> [OJ95, OJ96] </ref> can infer the integral types we need. 3 two independent phases. 3 Partitioning Using Declared Types 3.1 Basic Algorithm Given a dataflow problem to be solved over a program p, we wish to produce * a set of subproblems fq 0 ; q 1 ; : : : ; <p> For example, the systems of Steensgaard [Ste96b, Ste96a] and O'Callahan and Jackson <ref> [OJ95, OJ96] </ref> both compute type information that can be used by our partitioning algorithm. <p> Given a polymorphic type inferencer, we can handle this case as we did before, by allowing a polymorphic type to participate in multiple members of the final partition. Indeed, a polymorphic inferencer can often infer 6 polymorphic types in monomorphic programs (for example, <ref> [OJ95] </ref> finds polymorphic representation types in C programs), allowing for additional levels of partitioning. * Coercion. We no longer need to worry about type casts explicitly; the inference system must deal with them when assigning types. <p> Henglein's algorithm inspired Steensgaard's type-based almost-linear points-to analyses for C [Ste96b, Ste96a], which we used in Section 5. Zhang et. al's flow-insensitive alias analysis [ZRL96a] infers equivalence classes of object names which can be considered as types. O'Callahan and Jackson <ref> [OJ95, OJ96] </ref> subject C programs to forms of polymorphic type inference that capture various notions of equivalence of data representation. 7.3 Sparse Dataflow Analysis The costs of a flow-sensitive dataflow analysis are proportional to three factors: 1. the cost of modeling a single program quantity at a program point, 2. the
Reference: [OJ96] <author> R. O'Callahan and D. Jackson. </author> <title> Practical program understanding with type inference. </title> <type> Technical Report CMU-CS-96-130, </type> <institution> School of Computer Science, Carnegie-Mellon University, </institution> <month> May </month> <year> 1996. </year>
Reference-contexts: symbol tables, we are able to partition the analysis of Sym * quantities into 3 We must be careful to ensure that the type inference's notion of dependence is a conservative approximation of any dependence that might occur at analysis time; for this example, the system of O'Callahan and Jackson <ref> [OJ95, OJ96] </ref> can infer the integral types we need. 3 two independent phases. 3 Partitioning Using Declared Types 3.1 Basic Algorithm Given a dataflow problem to be solved over a program p, we wish to produce * a set of subproblems fq 0 ; q 1 ; : : : ; <p> This is an analysis-specific computation: in the case of points-to analysis, we use the "pointed-to-by" relation described above. Other analyses may require other relations such as structural inclusion, coercion, or O'Callahan and Jackson's "compatibility" relation <ref> [OJ96] </ref>. Given the types and the dependence relation, we are faced with the problem of computing the total ordering, or schedule. <p> For example, the systems of Steensgaard [Ste96b, Ste96a] and O'Callahan and Jackson <ref> [OJ95, OJ96] </ref> both compute type information that can be used by our partitioning algorithm. <p> Henglein's algorithm inspired Steensgaard's type-based almost-linear points-to analyses for C [Ste96b, Ste96a], which we used in Section 5. Zhang et. al's flow-insensitive alias analysis [ZRL96a] infers equivalence classes of object names which can be considered as types. O'Callahan and Jackson <ref> [OJ95, OJ96] </ref> subject C programs to forms of polymorphic type inference that capture various notions of equivalence of data representation. 7.3 Sparse Dataflow Analysis The costs of a flow-sensitive dataflow analysis are proportional to three factors: 1. the cost of modeling a single program quantity at a program point, 2. the
Reference: [RHS95] <author> T. Reps, S. Horwitz, and M. Sagiv. </author> <title> Precise interpro-cedural dataflow analysis via graph reachability. </title> <booktitle> In Proceedings 22nd ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages, </booktitle> <pages> pages 49-61, </pages> <month> January </month> <year> 1995. </year>
Reference-contexts: Efficiency improvements for separable problems have been obtained using specialized program representations such as sparse evaluation graphs [CCF91] and sparse scheduling techniques such as the slotwise [DRZ92] and tabulation methods <ref> [RHS95] </ref>. Unfortunately, many interesting dataflow problems, such as constant propagation and pointer alias analysis, are not separable; existing techniques are forced to model all relevant quantities simultaneously. This paper describes a way to extend quantity-based partitioning to non-separable problems.
Reference: [Ruf95a] <author> E. Ruf. </author> <title> Context-insensitive alias analysis reconsidered. </title> <booktitle> In Proceedings of the SIGPLAN '95 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 13-22, </pages> <month> June </month> <year> 1995. </year>
Reference-contexts: The analysis of each schedule element need only model the relevant instances (slots). We estimated the benefits of partitioning by analyzing the points-to relations computed by our existing context-insensitive interprocedural points-to analysis <ref> [Ruf95a] </ref>. <p> Such languages are convenient to analyze because every alias induced by a procedure can be attributed to a single alias holding on entry to that procedure. A precise treatment of multi-level pointers is significantly more complex due to the need to represent multiple layers of dependences <ref> [Ruf95a, WL95] </ref>. Our partitioning scheme effectively converts a multilevel problem into a sequence of predominantly single-level subproblems (multi-level modeling of recursive data types cannot be avoided). Of the 3960 subproblems we constructed using nonstandard type inference, 3901 (98.5%) were single-level in nature.
Reference: [Ruf95b] <author> E. Ruf. </author> <title> Optimizing sparse representations for dataflow analysis. </title> <booktitle> In ACM SIGPLAN Workshop on Intermediate Representations (IR'95), </booktitle> <pages> pages 50-61, </pages> <month> January </month> <year> 1995. </year> <note> Proceedings published as ACM SIG-PLAN Notices 30(3), </note> <month> March </month> <year> 1995. </year>
Reference-contexts: We used these types to compute partitions for a small suite of pointer-intensive benchmark programs. The programs were represented as arity-raised value dependence graphs <ref> [Ruf95b, WCES94] </ref>; the program quantities of interest were pointer-valued expressions ("ports" in VDG parlance). For purposes of this discussion, it is sufficient to think of the program quantities as pointer-valued variables in an SSA-form representation. <p> Column 2 differs from the port count in <ref> [Ruf95b] </ref> because quantities of type "store" are not included. <p> the costs of constructing the partitions and their sparse representations remain sufficiently small. 8 Because our initial experiments are based on a post-analysis of an existing monolithic analysis, we have no empirical evidence for speedup at present. 8 This is clearly not always the case; e.g., the sparse representation in <ref> [Ruf95b] </ref> achieved breakeven only on the largest of the benchmarks used in this paper. 9 6.2 Parallelism In the penultimate phase of our partitioning algorithm, we use a topological sort to serialize the evaluation of our partitions, which are related only via a partial ordering. <p> Program representations that directly model producer-consumer dependences, such as static single assignment (SSA) form [CFR + 91] and its many relatives represent each quantity only at statically-determined definition and meet points, but assure that each use point can locate the appropriate model in constant time. These are general representations; <ref> [CCF91, Ruf95b] </ref> build similar graphs for analysis-specific purposes. Similar effects are achieved by systems that directly simplify the dataflow equations at each program point [DGS94], or use a hierarchical control representation to avoid modeling quantities in regions where their values are not changed [JPP94].
Reference: [Ste95] <author> B. Steensgaard. </author> <title> Sparse functional stores for imperative programs. </title> <booktitle> In ACM SIGPLAN Workshop on Intermediate Representations (IR'95), </booktitle> <pages> pages 62-70, </pages> <month> January </month> <year> 1995. </year> <note> Proceedings published as ACM SIG-PLAN Notices 30(3), </note> <month> March </month> <year> 1995. </year>
Reference-contexts: Still other schemes leave the program representation intact, and dynamically represent an analysis-specific producer-consumer relation in an efficient auxiliary data structure [CWZ90, WL95]. The sparse store model used in the estimates of Section 5 is similar to the static dependence graphs constructed by SEG construction [CCF91] and store splitting <ref> [Ste95] </ref> and the dominator-based store models of [CWZ90, WL95].
Reference: [Ste96a] <author> B. Steensgaard. </author> <title> Points-to analysis by type inference of programs with structures and unions. </title> <booktitle> In International Conference on Compiler Construction, number 1060 in Lecture Notes in Computer Science, </booktitle> <pages> pages 136-150, </pages> <month> April </month> <year> 1996. </year>
Reference-contexts: For example, the systems of Steensgaard <ref> [Ste96b, Ste96a] </ref> and O'Callahan and Jackson [OJ95, OJ96] both compute type information that can be used by our partitioning algorithm. <p> While the approach of Section 3 needlessly forces all 574 quantities to be modeled simultaneously, the analysis of <ref> [Ste96a] </ref> infers 177 distinct types for unrelated char * expressions, allowing their analysis to be broken into that many distinct phases. Second, inferred types help address the complications we encountered with user-declared types: * Polymorphism. <p> Different type inference systems have complexities varying from almost-linear through exponential; the experiments described in the next section used Steensgaard's structure/union analysis <ref> [Ste96a] </ref>, which has worst-case space complexity linear, and time complexity quadratic, in the total size of program variables. 5 Empirical Results We implemented an instance of our partitioning strategy targeted to points-to analysis of C programs. The basic relationships between program quantities in points-to analysis are: 1. <p> Henglein was the first to use type inference to perform binding time analysis in almost linear time [Hen91], and later applied a similar approach to optimization problems such as unboxing [Hen92]. Henglein's algorithm inspired Steensgaard's type-based almost-linear points-to analyses for C <ref> [Ste96b, Ste96a] </ref>, which we used in Section 5. Zhang et. al's flow-insensitive alias analysis [ZRL96a] infers equivalence classes of object names which can be considered as types.
Reference: [Ste96b] <author> B. Steensgaard. </author> <title> Points-to analysis in almost linear time. </title> <booktitle> In Proceedings 23rd ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages, </booktitle> <pages> pages 32-41, </pages> <month> January </month> <year> 1996. </year>
Reference-contexts: For example, the systems of Steensgaard <ref> [Ste96b, Ste96a] </ref> and O'Callahan and Jackson [OJ95, OJ96] both compute type information that can be used by our partitioning algorithm. <p> Henglein was the first to use type inference to perform binding time analysis in almost linear time [Hen91], and later applied a similar approach to optimization problems such as unboxing [Hen92]. Henglein's algorithm inspired Steensgaard's type-based almost-linear points-to analyses for C <ref> [Ste96b, Ste96a] </ref>, which we used in Section 5. Zhang et. al's flow-insensitive alias analysis [ZRL96a] infers equivalence classes of object names which can be considered as types.
Reference: [WCES94] <author> D. Weise, R. F. Crew, M. Ernst, and B. Steensgaard. </author> <title> Value dependence graphs: Representation without taxation. </title> <type> Technical Report MSR-TR-94-03, </type> <institution> Microsoft Research, </institution> <address> Redmond, WA, </address> <month> April 13, </month> <year> 1994. </year>
Reference-contexts: We used these types to compute partitions for a small suite of pointer-intensive benchmark programs. The programs were represented as arity-raised value dependence graphs <ref> [Ruf95b, WCES94] </ref>; the program quantities of interest were pointer-valued expressions ("ports" in VDG parlance). For purposes of this discussion, it is sufficient to think of the program quantities as pointer-valued variables in an SSA-form representation.
Reference: [WL95] <author> R. P. Wilson and M. S. Lam. </author> <title> Efficient context-sensitive pointer analysis for C programs. </title> <booktitle> In Proceedings of the SIGPLAN '95 Conference on Programming Language Design and Implementation. </booktitle> <publisher> ACM Press, </publisher> <month> June </month> <year> 1995. </year>
Reference-contexts: Such languages are convenient to analyze because every alias induced by a procedure can be attributed to a single alias holding on entry to that procedure. A precise treatment of multi-level pointers is significantly more complex due to the need to represent multiple layers of dependences <ref> [Ruf95a, WL95] </ref>. Our partitioning scheme effectively converts a multilevel problem into a sequence of predominantly single-level subproblems (multi-level modeling of recursive data types cannot be avoided). Of the 3960 subproblems we constructed using nonstandard type inference, 3901 (98.5%) were single-level in nature. <p> Still other schemes leave the program representation intact, and dynamically represent an analysis-specific producer-consumer relation in an efficient auxiliary data structure <ref> [CWZ90, WL95] </ref>. The sparse store model used in the estimates of Section 5 is similar to the static dependence graphs constructed by SEG construction [CCF91] and store splitting [Ste95] and the dominator-based store models of [CWZ90, WL95]. <p> representation intact, and dynamically represent an analysis-specific producer-consumer relation in an efficient auxiliary data structure <ref> [CWZ90, WL95] </ref>. The sparse store model used in the estimates of Section 5 is similar to the static dependence graphs constructed by SEG construction [CCF91] and store splitting [Ste95] and the dominator-based store models of [CWZ90, WL95]. Previous publications on this topic have not provided empirical data; our results (shown in factor of 85 in space usage at analysis time. 8 Conclusion Partitioning of dataflow analyses is useful for reducing memory consumption, enabling parallel analysis, and simplifying the representations of dataflow values.
Reference: [ZRL96a] <author> S. Zhang, B. G. Ryder, and W. Landi. </author> <title> Program decomposition for pointer aliasing: A step towards practical analyses. </title> <booktitle> In Fourth Symposium on the Foundations of Software Engineering (FSE4), </booktitle> <month> October </month> <year> 1996. </year>
Reference-contexts: Of the 3960 subproblems we constructed using nonstandard type inference, 3901 (98.5%) were single-level in nature. We envision using single-level techniques on the single-level subproblems, and reserving the more expensive, exponential analysis machinery for the remaining subproblems. 7 Related Work 7.1 Partitioning of Analyses Zhang et. al <ref> [ZRL96a, ZRL96b] </ref> used automatically inferred dependence information (a flow-insensitive points-to analysis) to decompose an alias analysis problem into a set of completely independent subproblems (essentially our scheme, but using only weakly connected components instead of our collapse-and-schedule heuristic). <p> Henglein's algorithm inspired Steensgaard's type-based almost-linear points-to analyses for C [Ste96b, Ste96a], which we used in Section 5. Zhang et. al's flow-insensitive alias analysis <ref> [ZRL96a] </ref> infers equivalence classes of object names which can be considered as types.
Reference: [ZRL96b] <author> S. Zhang, B. G. Ryder, and W. Landi. </author> <title> Program decomposition for pointer-induced aliasing analysis. </title> <type> Technical Report LCSR-TR-259, </type> <institution> Laboratory for Computer Science, Rutgers University, </institution> <month> March </month> <year> 1996. </year> <month> 12 </month>
Reference-contexts: Of the 3960 subproblems we constructed using nonstandard type inference, 3901 (98.5%) were single-level in nature. We envision using single-level techniques on the single-level subproblems, and reserving the more expensive, exponential analysis machinery for the remaining subproblems. 7 Related Work 7.1 Partitioning of Analyses Zhang et. al <ref> [ZRL96a, ZRL96b] </ref> used automatically inferred dependence information (a flow-insensitive points-to analysis) to decompose an alias analysis problem into a set of completely independent subproblems (essentially our scheme, but using only weakly connected components instead of our collapse-and-schedule heuristic).
References-found: 27

