URL: http://www.cs.rice.edu:80/CS/PLT/Publications/plilp97-fffkf.ps.gz
Refering-URL: http://www.cs.rice.edu:80/~robby/publications/
Root-URL: 
Title: DrScheme: A Pedagogic Programming Environment for Scheme  
Author: Robert Bruce Findler, Cormac Flanagan, Matthew Flatt, Shriram Krishnamurthi, and Matthias Felleisen 
Keyword: Programming Environments, Scheme, Programming, Pedagogy, Algebraic Evaluation, Static Debugging. Teaching programming  
Note: to beginning students.  
Address: Houston, Texas 77005-1892  
Affiliation: Department of Computer Science Rice University  
Abstract: Teaching introductory computing courses with Scheme elevates the intellectual level of the course and thus makes the subject more appealing to students with scientific interests. Unfortunately, the poor quality of the available programming environments negates many of the pedagogic advantages. To overcome this problem, we have developed DrScheme, a comprehensive programming environment for Scheme. It fully integrates a graphics-enriched editor, a multi-lingual parser that can process a hierarchy of syntactically restrictive variants of Scheme, a functional read-eval-print loop, and an algebraically sensible printer. The environment catches the typical syntactic mistakes of beginners and pinpoints the exact source location of run-time exceptions. DrScheme also provides an algebraic stepper, a syntax checker and a static debugger. The first reduces Scheme programs, including programs with assignment and control effects, to values (and effects). The tool is useful for explaining the semantics of linguistic facilities and for studying the behavior of small programs. The syntax checker annotates programs with font and color changes based on the syntactic structure of the program. It also draws arrows on demand that point from bound to binding occurrences of identifiers. The static debugger, roughly speaking, provides a type inference system with explanatory capabilities. Preliminary experience with the environment shows that Rice University students find it helpful and that they greatly prefer it to shell- or Emacs-based systems. 
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> Abelson, H., G. J. Sussman and J. Sussman. </author> <title> Structure and Interpretation of Computer Programs. </title> <publisher> MIT Press, </publisher> <year> 1985. </year>
Reference-contexts: A United States-wide count in 1995 put Scheme in fourth place with 11%, behind Pascal (35%), Ada (17%), and C/C++ (17%) (when grouped together) [32, 34]. SML [31] is the only other functional language listed, at 2%. Scheme's success is primarily due to Abel-son and Sussman's seminal book <ref> [1] </ref> on their introductory course at MIT. Their course proved that introductory programming courses can expose students to the interesting concepts of computer science instead of listing the syntactic conventions of currently fashionable programming languages.
Reference: 2. <institution> AT&T Bell Labratories. Standard ML of New Jersey, </institution> <year> 1993. </year>
Reference-contexts: Specifically, SML/NJ provides a repl similar to the one described here for the module language of SML [3, 19]. Unfortunately this is useless for beginners, who mostly work with the core language. Also, CAML [28], ML-Works [18], and SML/NJ <ref> [2] </ref> have good source reporting for run-time errors but, due to the unification-based type inference process, report type errors of programs at incorrect places and often display incomprehensible messages.
Reference: 3. <author> Blume, M. </author> <title> Standard ML of New Jersey compilation manager. </title> <booktitle> Manual accompa-nying SML/NJ software, </booktitle> <year> 1995. </year>
Reference-contexts: Other functional language environments provide some of the functionality of DrScheme. Specifically, SML/NJ provides a repl similar to the one described here for the module language of SML <ref> [3, 19] </ref>. Unfortunately this is useless for beginners, who mostly work with the core language.
Reference: 4. <author> Borland. Borland C++, </author> <year> 1987, 1994. </year>
Reference-contexts: Also, CAML [28], ML-Works [18], and SML/NJ [2] have good source reporting for run-time errors but, due to the unification-based type inference process, report type errors of programs at incorrect places and often display incomprehensible messages. Commercial programming environments <ref> [4, 29, 30] </ref> for imperative programming languages like C++ incorporate a good portion of the functionality found in DrScheme.
Reference: 5. <author> Bourdoncle, F. </author> <title> Abstract debugging of higher-order imperative languages. </title> <booktitle> In ACM SIGPLAN Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 46-55, </pages> <year> 1993. </year>
Reference-contexts: If a student checks a syntactically incorrect program, the first incorrect portion of the text is highlighted, and an error message is printed. 4.3 Static Debugging The most advanced DrScheme tool is MrSpidey, a static debugger <ref> [5, 14] </ref>, which subsumes the syntax checker, but is computationally far more expensive. It analyzes the current program, using a new form of set-based analysis [13, 20], for potential safety violations.
Reference: 6. <author> Cadence Research Systems. </author> <title> Chez Scheme Reference Manual, </title> <year> 1994. </year>
Reference-contexts: Their course proved that introductory programming courses can expose students to the interesting concepts of computer science instead of listing the syntactic conventions of currently fashionable programming languages. When Rice University implemented an MIT-style course, the instructors encountered four significant problems with Scheme and its implementations <ref> [6, 17, 33, 36] </ref>: 1. Since the syntax of standard Scheme is extremely liberal, simple notational mistakes produce inexplicable results or incomprehensible error messages. 2. The available implementations do not pinpoint the source location of run time errors. 3.
Reference: 7. <editor> Clinger, W. and J. Rees. </editor> <title> The revised 4 report on the algorithmic language Scheme. </title> <journal> ACM Lisp Pointers, </journal> <volume> 4(3), </volume> <month> July </month> <year> 1991. </year>
Reference-contexts: 1 Problems with Teaching Scheme Over the past ten years, Scheme <ref> [7] </ref> has become the most widely used functional programming language in introductory courses. A United States-wide count in 1995 put Scheme in fourth place with 11%, behind Pascal (35%), Ada (17%), and C/C++ (17%) (when grouped together) [32, 34]. SML [31] is the only other functional language listed, at 2%. <p> Intermediate extends Beginner with structure definitions and the local binding constructs: local, let, letfl, and letrec. Advanced adds support for variable assignments, data mutations, as well as implicit and explicit sequencing. Quasi-R 4 RS subsumes the Scheme language <ref> [7, 12, 15] </ref>. The first three blocks of the table in figure 4 specify the exact syntactic content of the various language levels. The last block describes other properties of the four language levels. <p> Because it mirrors the input syntax for values, constructor style output is useful for general programs and mandatory for pedagogic programming (see section 4.1). In contrast, quasiquote style is a compromise between the constructor style output and the standard Scheme output style <ref> [7] </ref>. Like the former, the quasiquote-style output matches quasiquote input syntax.
Reference: 8. <author> Dybvig, R. K., R. Hieb and C. Bruggeman. </author> <title> Syntactic abstraction in Scheme. </title> <journal> Lisp and Symbolic Computation, </journal> <volume> 5(4) </volume> <pages> 295-326, </pages> <month> December </month> <year> 1993. </year>
Reference-contexts: DrScheme, with a run-time error highlighted (X Motif version) solution, however, does not truly integrate the repl and its editing environment, so that the graphical capabilities of modern displays remain unexploited. Second, Scheme's macro facility [22, 23] tremendously complicates the mapping from a run-time error to its source location <ref> [8] </ref>. Since Scheme's macro language allows arbitrary mappings on program text during compilation, preserving the original source locations for pieces of program text is difficult. For example, Scheme's letfl macro expands to a sequence of nested let expressions, and those let expressions then expand into lambda expressions.
Reference: 9. <author> Felleisen, M. </author> <title> An extended -calculus for Scheme. </title> <booktitle> In ACM Symposium on Lisp and Functional Programming, </booktitle> <pages> pages 72-84, </pages> <year> 1988. </year>
Reference-contexts: The final extension covers variable assignment and data mutation. With each extension of the language, the course also introduces a set of appropriate design recipes and rewriting rules that explain the new language features <ref> [9, 10, 11] </ref>. At the end of the segment on program design, students understand how to construct programs as (collections of) functions and as (object-oriented) history-sensitive procedures. <p> More importantly, DrScheme also includes a tool that enables students to reduce a program to a value step by step. This symbolic stepper is based on Felleisen and other's work on reduction semantics for Scheme- and ML-like languages <ref> [9, 10, 11] </ref> and can deal with all the features used in Rice University's course, including the entire functional sub-language, structure definitions, variable assignment, data structure mutation, exceptions, and other control mechanisms.
Reference: 10. <author> Felleisen, M. </author> <title> On the expressive power of programming languages. </title> <booktitle> Science of Computer Programming, </booktitle> <volume> 17 </volume> <pages> 35-75, </pages> <year> 1991. </year>
Reference-contexts: The final extension covers variable assignment and data mutation. With each extension of the language, the course also introduces a set of appropriate design recipes and rewriting rules that explain the new language features <ref> [9, 10, 11] </ref>. At the end of the segment on program design, students understand how to construct programs as (collections of) functions and as (object-oriented) history-sensitive procedures. <p> More importantly, DrScheme also includes a tool that enables students to reduce a program to a value step by step. This symbolic stepper is based on Felleisen and other's work on reduction semantics for Scheme- and ML-like languages <ref> [9, 10, 11] </ref> and can deal with all the features used in Rice University's course, including the entire functional sub-language, structure definitions, variable assignment, data structure mutation, exceptions, and other control mechanisms.
Reference: 11. <author> Felleisen, M. and R. Hieb. </author> <title> The revised report on the syntactic theories of sequential control and state. </title> <booktitle> In Proceedings of Theoretical Computer Science, </booktitle> <pages> pages 235-271, </pages> <year> 1992. </year>
Reference-contexts: The final extension covers variable assignment and data mutation. With each extension of the language, the course also introduces a set of appropriate design recipes and rewriting rules that explain the new language features <ref> [9, 10, 11] </ref>. At the end of the segment on program design, students understand how to construct programs as (collections of) functions and as (object-oriented) history-sensitive procedures. <p> More importantly, DrScheme also includes a tool that enables students to reduce a program to a value step by step. This symbolic stepper is based on Felleisen and other's work on reduction semantics for Scheme- and ML-like languages <ref> [9, 10, 11] </ref> and can deal with all the features used in Rice University's course, including the entire functional sub-language, structure definitions, variable assignment, data structure mutation, exceptions, and other control mechanisms.
Reference: 12. <author> Findler, R. B. and M. Flatt. PLT MrEd: </author> <title> Graphical toolbox manual. </title> <type> Technical Report TR97-279, </type> <institution> Rice University, </institution> <year> 1997. </year>
Reference-contexts: Intermediate extends Beginner with structure definitions and the local binding constructs: local, let, letfl, and letrec. Advanced adds support for variable assignments, data mutations, as well as implicit and explicit sequencing. Quasi-R 4 RS subsumes the Scheme language <ref> [7, 12, 15] </ref>. The first three blocks of the table in figure 4 specify the exact syntactic content of the various language levels. The last block describes other properties of the four language levels.
Reference: 13. <author> Flanagan, C. and M. Felleisen. </author> <title> Componential set-based analysis. </title> <booktitle> In ACM SIG-PLAN Conference on Programming Language Design and Implementation, </booktitle> <year> 1997. </year>
Reference-contexts: It analyzes the current program, using a new form of set-based analysis <ref> [13, 20] </ref>, for potential safety violations. That is, the tool infers constraints on the potential value flow in the Scheme program, similar to the equational constraints of a Hindley-Milner type checker, and builds a value flow graph for the program.
Reference: 14. <author> Flanagan, C., M. Flatt, S. Krishnamurthi, S. Weirich and M. Felleisen. </author> <title> Catching bugs in the web of program invariants. </title> <booktitle> In ACM SIGPLAN Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 23-32, </pages> <month> May </month> <year> 1996. </year>
Reference-contexts: If a student checks a syntactically incorrect program, the first incorrect portion of the text is highlighted, and an error message is printed. 4.3 Static Debugging The most advanced DrScheme tool is MrSpidey, a static debugger <ref> [5, 14] </ref>, which subsumes the syntax checker, but is computationally far more expensive. It analyzes the current program, using a new form of set-based analysis [13, 20], for potential safety violations.
Reference: 15. <author> Flatt, M. PLT MzScheme: </author> <title> Language manual. </title> <type> Technical Report TR97-280, </type> <institution> Rice University, </institution> <year> 1997. </year>
Reference-contexts: Intermediate extends Beginner with structure definitions and the local binding constructs: local, let, letfl, and letrec. Advanced adds support for variable assignments, data mutations, as well as implicit and explicit sequencing. Quasi-R 4 RS subsumes the Scheme language <ref> [7, 12, 15] </ref>. The first three blocks of the table in figure 4 specify the exact syntactic content of the various language levels. The last block describes other properties of the four language levels.
Reference: 16. <author> Francez, N., S. Goldenberg, R. Y. Pinter, M. Tiomkin and S. Tsur. </author> <title> An environment for logic programming. </title> <journal> SIGPLAN Notices, </journal> <volume> 20(7) </volume> <pages> 179-190, </pages> <month> July </month> <year> 1985. </year>
Reference: 17. <author> Hanson, C., </author> <title> The MIT Scheme Team and A Cast of Thousands. MIT Scheme Reference, </title> <year> 1993. </year>
Reference-contexts: Their course proved that introductory programming courses can expose students to the interesting concepts of computer science instead of listing the syntactic conventions of currently fashionable programming languages. When Rice University implemented an MIT-style course, the instructors encountered four significant problems with Scheme and its implementations <ref> [6, 17, 33, 36] </ref>: 1. Since the syntax of standard Scheme is extremely liberal, simple notational mistakes produce inexplicable results or incomprehensible error messages. 2. The available implementations do not pinpoint the source location of run time errors. 3.
Reference: 18. <author> Harlequin Inc. MLWorks, </author> <year> 1996. </year>
Reference-contexts: Other functional language environments provide some of the functionality of DrScheme. Specifically, SML/NJ provides a repl similar to the one described here for the module language of SML [3, 19]. Unfortunately this is useless for beginners, who mostly work with the core language. Also, CAML [28], ML-Works <ref> [18] </ref>, and SML/NJ [2] have good source reporting for run-time errors but, due to the unification-based type inference process, report type errors of programs at incorrect places and often display incomprehensible messages.
Reference: 19. <author> Harper, R., P. Lee, F. Pfenning and E. Rollins. </author> <title> Incremental recompilation for Standard ML of New Jersey. </title> <type> Technical Report CMU-CS-94-116, </type> <institution> Carnegie Mel-lon University, </institution> <year> 1994. </year>
Reference-contexts: Other functional language environments provide some of the functionality of DrScheme. Specifically, SML/NJ provides a repl similar to the one described here for the module language of SML <ref> [3, 19] </ref>. Unfortunately this is useless for beginners, who mostly work with the core language.
Reference: 20. <author> Heintze, N. </author> <title> Set based analysis of ML programs. </title> <booktitle> In ACM Symposium on Lisp and Functional Programming, </booktitle> <year> 1994. </year>
Reference-contexts: It analyzes the current program, using a new form of set-based analysis <ref> [13, 20] </ref>, for potential safety violations. That is, the tool infers constraints on the potential value flow in the Scheme program, similar to the equational constraints of a Hindley-Milner type checker, and builds a value flow graph for the program.
Reference: 21. <author> Hsiang, J. and M. Srivas. </author> <title> A Prolog environment. </title> <type> Technical Report 84-074, </type> <institution> State University of New York at Stony Brook, Stony Brook, </institution> <address> New York, </address> <month> July </month> <year> 1984. </year>
Reference: 22. <author> Kohlbecker, E. E., D. P. Friedman, M. Felleisen and B. F. Duba. </author> <title> Hygienic macro expansion. </title> <booktitle> In ACM Symposium on Lisp and Functional Programming, </booktitle> <pages> pages 151-161, </pages> <year> 1986. </year>
Reference-contexts: This Fig. 5. DrScheme, with a run-time error highlighted (X Motif version) solution, however, does not truly integrate the repl and its editing environment, so that the graphical capabilities of modern displays remain unexploited. Second, Scheme's macro facility <ref> [22, 23] </ref> tremendously complicates the mapping from a run-time error to its source location [8]. Since Scheme's macro language allows arbitrary mappings on program text during compilation, preserving the original source locations for pieces of program text is difficult.
Reference: 23. <author> Kohlbecker Jr, E. E. </author> <title> Syntactic Extensions in the Programming Language Lisp. </title> <type> PhD thesis, </type> <institution> Indiana University, </institution> <month> August </month> <year> 1986. </year>
Reference-contexts: This Fig. 5. DrScheme, with a run-time error highlighted (X Motif version) solution, however, does not truly integrate the repl and its editing environment, so that the graphical capabilities of modern displays remain unexploited. Second, Scheme's macro facility <ref> [22, 23] </ref> tremendously complicates the mapping from a run-time error to its source location [8]. Since Scheme's macro language allows arbitrary mappings on program text during compilation, preserving the original source locations for pieces of program text is difficult.
Reference: 24. <author> Komorowski, H. J. and S. Omori. </author> <title> A model and an implementation of a logic programming environment. </title> <journal> SIGPLAN Notices, </journal> <volume> 20(7) </volume> <pages> 191-198, </pages> <month> July </month> <year> 1985. </year>
Reference: 25. <author> Koschmann, T. and M. W. Evens. </author> <title> Bridging the gap between object-oriented and logic programming. </title> <journal> IEEE Software, </journal> <volume> 5 </volume> <pages> 36-42, </pages> <month> July </month> <year> 1988. </year>
Reference: 26. <author> Krishnamurthi, S. Zodiac: </author> <title> A framework for building interactive programming tools. </title> <type> Technical Report TR96-262, </type> <institution> Rice University, </institution> <year> 1996. </year>
Reference-contexts: In short, a pedagogic programming environment must be able to grow along with the students through a course. DrScheme implements this stratification with four language levels <ref> [26] </ref>. The student can choose the appropriate language level via the LanguagejConfigure Language... menu item. Choosing LanguagejConfigure Language... opens a window with a choice dialog item that displays the current language level. The choice dialog item mirrors the student's language level. <p> Other macros duplicate or delete portions of source text. DrScheme overcomes all three problems. The underlying Scheme implementation is safe and completely integrated into the editing environment. Furthermore, the front-end of the Scheme implementation maintains a correlation between the original program text and its macro-expanded version <ref> [26] </ref>. This correlation allows DrScheme to report the source location of run-time errors. Consider the example in figure 5. The student has written an erroneous version of length. When it is applied to (list 1 2 3 4 5), it recurs down the list, and is applied to null.
Reference: 27. <author> Lane, A. </author> <title> Turbo Prolog revisited. </title> <journal> BYTE, </journal> <volume> 13(10) </volume> <pages> 209-212, </pages> <month> October </month> <year> 1988. </year>
Reference: 28. <author> Leroy, X. </author> <title> The Objective Caml system, documentation and user's guide, </title> <year> 1997. </year>
Reference-contexts: Other functional language environments provide some of the functionality of DrScheme. Specifically, SML/NJ provides a repl similar to the one described here for the module language of SML [3, 19]. Unfortunately this is useless for beginners, who mostly work with the core language. Also, CAML <ref> [28] </ref>, ML-Works [18], and SML/NJ [2] have good source reporting for run-time errors but, due to the unification-based type inference process, report type errors of programs at incorrect places and often display incomprehensible messages.
Reference: 29. <author> Metrowerks. CodeWarrior, </author> <year> 1993-1996. </year>
Reference-contexts: Also, CAML [28], ML-Works [18], and SML/NJ [2] have good source reporting for run-time errors but, due to the unification-based type inference process, report type errors of programs at incorrect places and often display incomprehensible messages. Commercial programming environments <ref> [4, 29, 30] </ref> for imperative programming languages like C++ incorporate a good portion of the functionality found in DrScheme.
Reference: 30. <institution> Microsoft. Microsoft Developer Studio, </institution> <year> 1995. </year>
Reference-contexts: Also, CAML [28], ML-Works [18], and SML/NJ [2] have good source reporting for run-time errors but, due to the unification-based type inference process, report type errors of programs at incorrect places and often display incomprehensible messages. Commercial programming environments <ref> [4, 29, 30] </ref> for imperative programming languages like C++ incorporate a good portion of the functionality found in DrScheme.
Reference: 31. <author> Milner, R., M. Tofte and R. Harper. </author> <title> The Definition of Standard ML. </title> <publisher> MIT Press, </publisher> <year> 1990. </year>
Reference-contexts: A United States-wide count in 1995 put Scheme in fourth place with 11%, behind Pascal (35%), Ada (17%), and C/C++ (17%) (when grouped together) [32, 34]. SML <ref> [31] </ref> is the only other functional language listed, at 2%. Scheme's success is primarily due to Abel-son and Sussman's seminal book [1] on their introductory course at MIT.
Reference: 32. <author> Reid, R. J. </author> <note> First-course language for computer science majors. Posting to comp.edu, </note> <month> October </month> <year> 1995. </year>
Reference-contexts: 1 Problems with Teaching Scheme Over the past ten years, Scheme [7] has become the most widely used functional programming language in introductory courses. A United States-wide count in 1995 put Scheme in fourth place with 11%, behind Pascal (35%), Ada (17%), and C/C++ (17%) (when grouped together) <ref> [32, 34] </ref>. SML [31] is the only other functional language listed, at 2%. Scheme's success is primarily due to Abel-son and Sussman's seminal book [1] on their introductory course at MIT.
Reference: 33. <author> EdScheme: </author> <title> A Modern Lisp, </title> <year> 1991. </year>
Reference-contexts: Their course proved that introductory programming courses can expose students to the interesting concepts of computer science instead of listing the syntactic conventions of currently fashionable programming languages. When Rice University implemented an MIT-style course, the instructors encountered four significant problems with Scheme and its implementations <ref> [6, 17, 33, 36] </ref>: 1. Since the syntax of standard Scheme is extremely liberal, simple notational mistakes produce inexplicable results or incomprehensible error messages. 2. The available implementations do not pinpoint the source location of run time errors. 3. <p> The explanations must include the run-time values that caused the errors as well as the source location of the misapplied primitives. Traditional Scheme programming environments fail in this regard for two reasons. First, with the exception of EdScheme <ref> [33] </ref>, Scheme compilers and interpreters only implement a simplistic read-eval-print loop. If this repl is executed in a plain command shell, it is impossible to relate errors to source locations in general. The historical solution is to execute the repl in an Emacs buffer. This Fig. 5.
Reference: 34. <author> Schemer's Inc. and Terry Kaufman. </author> <title> Scheme in colleges and high schools. </title> <note> Available on the web. URL: http://www.schemers.com/schools.html. </note>
Reference-contexts: 1 Problems with Teaching Scheme Over the past ten years, Scheme [7] has become the most widely used functional programming language in introductory courses. A United States-wide count in 1995 put Scheme in fourth place with 11%, behind Pascal (35%), Ada (17%), and C/C++ (17%) (when grouped together) <ref> [32, 34] </ref>. SML [31] is the only other functional language listed, at 2%. Scheme's success is primarily due to Abel-son and Sussman's seminal book [1] on their introductory course at MIT.
Reference: 35. <author> Stallman, R. </author> <title> GNU Emacs Manual. Free Software Foundation Inc., </title> <address> 675 Mass. Ave., Cambridge, MA 02139, </address> <year> 1987. </year>
Reference-contexts: The Break button stops the current computation, and the Help button summons the on-line help facility for DrScheme. The definitions and interactions windows contain editors that are compatible with typical editors on the various platforms. Under X, the editor has many of the Emacs <ref> [35] </ref> key bindings. The Windows and MacOS versions have the standard key bindings and menu items for those platforms. The remainder of this section motivates and describes the new aspects of the core programming environment.
Reference: 36. <author> Texas Instruments. </author> <title> PC Scheme User's Guide & Language Reference Manual| Student Edition, </title> <year> 1988. </year>
Reference-contexts: Their course proved that introductory programming courses can expose students to the interesting concepts of computer science instead of listing the syntactic conventions of currently fashionable programming languages. When Rice University implemented an MIT-style course, the instructors encountered four significant problems with Scheme and its implementations <ref> [6, 17, 33, 36] </ref>: 1. Since the syntax of standard Scheme is extremely liberal, simple notational mistakes produce inexplicable results or incomprehensible error messages. 2. The available implementations do not pinpoint the source location of run time errors. 3.
Reference: 37. <author> Wadler, P. </author> <title> A critique of Abelson and Sussman, or, why calculating is better than scheming. </title> <journal> SIGPLAN Notices, </journal> <volume> 22(3), </volume> <month> March </month> <year> 1987. </year> <title> This article was processed using the L A T E X macro package with LLNCS style </title>
Reference-contexts: Students learn that program evaluation consists of a sequence of reductions that transform an expression to a value in a context of definitions. Unfortunately, traditional Scheme implementations do not reinforce that connection <ref> [37] </ref>. They typically use one syntax for values as input and a different syntax for values as output.
References-found: 37

