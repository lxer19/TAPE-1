URL: ftp://ftp.eecs.umich.edu/groups/gasm/evade.ps.gz
Refering-URL: http://www.eecs.umich.edu/gasm/papers.html
Root-URL: http://www.eecs.umich.edu
Title: Evolving Algebras  
Author: J.M.W. Visser 
Affiliation: Delft University of Technology Faculty of Technical Mathematics and Informatics Department of Technical Informatics Master's Thesis  
Date: August 6, 1996  
Abstract-found: 0
Intro-found: 1
Reference: [Bar84] <author> H.P. Barendregt. </author> <title> The Lambda Calculus. Its Syntax and Semantics. </title> <booktitle> Studies in Logic and the Foundations of Mathematics. </booktitle> <publisher> North-Holland, </publisher> <address> revised edition, </address> <year> 1984. </year>
Reference-contexts: A more detailed account of the lambda calculus can be found in Barendregt <ref> [Bar84] </ref>. Lambda reduction is the process of rewriting lambda expressions to simpler ones. We will only consider expressions in the pure lambda calculus, which have the following syntax: hexpi ! hvar ijhvar i:hexpijhexpihexpij (hexpi) hvar i ! xjyjzj : : : 59 60 Chapter 4. <p> A redex is called outermost if it is not a subexpression of some other redex. The qualification "outermost" is actually redundant. All leftmost outermost redexes are leftmost redexes and vice versa. Consequently, normal-order reduction is sometimes called leftmost reduction <ref> [Bar84, 180] </ref>. Whether the reduction sequence that is constructed terminates or not may depend on which reduction strategy is adopted. The set of lambda expressions whose reduction terminates is more extensive for normal-order reduction than for applicative-order reduction. <p> In the next section, the evolving algebra for graph reduction of lambda expressions will be presented, which makes use of the graph representation explained in this section. 2 A proof that normal-order reduction is normalizing can be found in Barendregt <ref> [Bar84, 326ff] </ref>. 62 Chapter 4.
Reference: [BP95] <author> Bernhard Beckert and Joachim Posegga. </author> <title> leanEA: A poor man's evolving algebra compiler. </title> <type> Interner Bericht 25/95, </type> <institution> Universitat Karlsruhe, Fakultat fur Informatik, </institution> <year> 1995. </year>
Reference-contexts: After all, the bodies of modules are complete evolving algebras, which makes it rather laborious to assess which local function updates will be performed by it. 3.8 Modularized evolving algebras in the literature 3.8.1 Modularization in leanEA In <ref> [BP95] </ref> Beckert and Posegga describe an evolving algebra tool called leanEA. This tool accepts an evolving algebra language which includes modules. The non-modular core of this evolving algebra language is considerably less rich than the core theory described in chapter 2. <p> A compiler has been implemented in Pro-log that compiles DASL-specifications to ALMA-instructions. Hence, the combination of this DASL-to-ALMA compiler and the ALMA machine forms a DASL-to-Prolog compiler. In the sequel, we will in short refer to this compiler as the DASL-compiler. * leanEA. In <ref> [BP95] </ref> Beckert and Posegga describe an extremely small Prolog program which turns the Prolog interpreter itself into a virtual machine on which evolving algebras can be run. Hence, the Prolog interpreter extended with this Prolog program constitutes an evolving algebra interpreter. This interpreter is called leanEA.
Reference: [BR94] <author> Egon Borger and Dean Rosenzweig. </author> <title> A mathematical definition of full prolog. </title> <note> In Science of Computer Programming. (to appear), </note> <year> 1994. </year>
Reference-contexts: Also, the section on evolving algebras in the article A Mathematical Definition of Full Prolog <ref> [BR94, x1] </ref> by Egon Borger and Dean Rosenzweig has been consulted. The main source, however, is Hans Tonino's report by the title A formalization of many-sorted evolving algebras [Ton93]. The several treatments of evolving algebras in these four sources diverge in a number of respects.
Reference: [Die95a] <author> Stephan Diehl. </author> <title> Transformations of evolving algebras. Technischer Bericht A 02/95, </title> <institution> Universitat des Saarlandes, Computer Science Department, </institution> <year> 1995. </year>
Reference-contexts: For instance, tools could be constructed for proving that a given evolving algebra is consistent, or that it is deterministic, or that it terminates for arbitrary input. At the moment, no such dedicated provers exist. 78 Chapter 5. Inventory of evolving algebra support 5.4 Evolving algebra transformers In <ref> [Die95a] </ref> Diehl defines a number of transformations on evolving algebras. Among these transformations are macro expansion and transition rule flattening. All these transformations are optimizing techniques with which a given evolving algebra can be transformed to an operationally equivalent evolving algebra that is more efficient.
Reference: [Die95b] <author> Dag Diesen. </author> <title> Specifying algorithms using evolving algebras. implementation of functional programming languages. </title> <type> Research report 199, </type> <institution> Department of Informatics, University of Oslo, </institution> <month> March </month> <year> 1995. </year>
Reference-contexts: Thirdly, the functional modules are not invoked directly in an evolving algebra, 3.9. Modules and parallelism 53 but by mediation of a Prolog predicate. There is no concept of procedural modules in leanEA. 3.8.2 Modularization in Diesen In <ref> [Die95b] </ref> Diesen presents a modularization of evolving algebras which deviates radically from the modularization proposed in this chapter. Diesen's modules are not parameterized abstractions, but rather collections of rules operating in a single name space. This name space is partially visible to each module. <p> Two evolving algebra run analyzers have been realized. * In [HM] Huggins and Mani describe an evolving algebra run analyzer which is implemented and embedded in the programming language C. We will refer to this tool as the C run analyzer. * In <ref> [Die95b] </ref> Diesen describes an evolving algebra run analyzer which is implemented and embedded in the programming language Scheme. We will call it the Scheme run analyzer. 5.3 Interactive theorem provers An evolving algebra run analyzer is useful for testing, investigating and debugging evolving algebras.
Reference: [FH88] <author> Anthony J. Field and Peter G. Harrison. </author> <title> Functional Programming. </title> <publisher> Addison-Wesley, </publisher> <year> 1988. </year>
Reference-contexts: In <ref> [FH88] </ref> an informal description of such an algorithm can be found. In outline, the algorithm operates as follows. Starting from an initial lambda expression, a reduction sequence is produced by performing single fi-reductions in succession, until an expression in weak head-normal form is obtained.
Reference: [Gur91] <author> Yuri Gurevich. </author> <title> Evolving algebras, a tutorial introduction. </title> <journal> Bulletin of the Eu-ropean Association for Theoretical Computer Science, </journal> <volume> 43:264 - 284, </volume> <month> February </month> <year> 1991. </year>
Reference-contexts: In this chapter, we will give a formal exposition of the core theory of evolving algebras. This account is based on two introductory articles written by Yuri Gurevich Evolving Algebras: A Tutorial Introduction <ref> [Gur91] </ref> and Evolving Algebras 1993: Lipari 18 2.1. Introduction 19 run transition graph program state transition ? * fi * fi * fi * fi i i i i i i) ffi fl P P P P P Pq j Q Qs j Q Qs Guide [Gur95].
Reference: [Gur95] <author> Yuri Gurevich. </author> <title> Evolving algebras 1993; lipari guide. </title> <editor> In Egon Borger, editor, </editor> <title> Specification and Validation Methods. </title> <publisher> Oxford University Press, </publisher> <year> 1995. </year>
Reference-contexts: Introduction 19 run transition graph program state transition ? * fi * fi * fi * fi i i i i i i) ffi fl P P P P P Pq j Q Qs j Q Qs Guide <ref> [Gur95] </ref>. Also, the section on evolving algebras in the article A Mathematical Definition of Full Prolog [BR94, x1] by Egon Borger and Dean Rosenzweig has been consulted. The main source, however, is Hans Tonino's report by the title A formalization of many-sorted evolving algebras [Ton93]. <p> The purely functional nature of functional modules insures that evolving algebras running in parallel will never interfere with each other. 3.9.4 Parallel and distributed evolving algebras in the litera ture Massive parallelism Gurevich <ref> [Gur95] </ref> has shown how the introduction of variable declarations into evolving algebra programs makes the specification of massive parallel computational processes possible. For instance, an update 3 of the following form: var v ranges over s with U 3 Gurevich does not strictly separate updates from rules. <p> Distributed evolving algebras synchronization and communication protocols are explicitly needed This section has been concerned with parallel processes, not with distributed processes. Several proposals have been made to introduce distributedness into the evolving algebra theory. The most comprehensive proposal is given by Gurevich in <ref> [Gur95] </ref>. Gurevich introduces distributed evolving algebras by having not just a single program, but a finite collection of programs. If we imagine a program being executed by an agent, this generalization amounts to the introduction of multiple agents in stead of a single agent. <p> The vocabularies of the various programs are partially overlapping. The agents identify themselves using a special zero-argument function called self . To allow cooperative actions, the agents are organized into teams, which are agents themselves. Multi-agent evolving algebras have been used to model communication protocols for distributed systems <ref> [Gur95] </ref>. 3.10 Modules and structured evolving algebra de sign The introduction of modules into the theory of evolving algebras makes adequate treatment of large evolving algebras possible. Modules allow computations to be subdivided into relatively independent subcomputations. These subcomputations can be specified in isolation in separate modules.
Reference: [HJe92] <editor> P. Hudak, S. Peyton Jones, and P. Wadler (editors). </editor> <title> Report on the programming language haskell, a non-strict purely functional language (version 1.2). </title> <journal> ACM SIGPLAN Notices, </journal> <volume> 27(5), </volume> <month> May </month> <year> 1992. </year>
Reference-contexts: Gofer is a lazy functional programming language. It is strongly typed, it supports type polymorphism, and its functions are curried. Gofer has a powerful system of type classes, qualified types and overloaded functions. Gofer was originally developed as an extended subset of the programming language Haskell <ref> [HJe92] </ref>, and is similar to Haskell in many respects. For the benefit of the reader familiar with Haskell, we list the most important improvements of Gofer over Haskell: * Gofer type classes can take multiple parameters. 99 100 Chapter 8.
Reference: [HM] <author> Jim Huggins and Raghu Mani. </author> <title> The evolving algebra interpreter version 2.0. </title>
Reference-contexts: Hence, a run analyzer is needed, which allows one to run an evolving algebra step by step, and to inspect its intermediate states. Two evolving algebra run analyzers have been realized. * In <ref> [HM] </ref> Huggins and Mani describe an evolving algebra run analyzer which is implemented and embedded in the programming language C.
Reference: [Hug95] <author> James K. Huggins. </author> <title> An o*ine partial evaluator for evolving algebras. </title> <type> Technical Report CSE-TR-229-95, </type> <institution> University of Michigan, EECS Department, </institution> <year> 1995. </year>
Reference-contexts: Partial evaluation is especially useful in case of evolving algebras which specify programming language compilers. Specialization of such an evolving algebra for a specific source program yields an evolving algebra specification for this program. Partial evaluation has been defined by Huggins in <ref> [Hug95] </ref>. A partial evaluator has been implemented in C. We have listed four kinds of evolving algebra tools: compilers, run analyzers, theorem provers, and transformers. Implementations of some of these kinds of tools have already been realized. Unfortunately, all these implementations have some shortcomings.
Reference: [Jon] <author> Mark P. Jones. </author> <title> An introduction to gofer. </title> <note> Available from http://www.cs.yale.edu/. </note>
Reference-contexts: The programming language used in the implementation is Gofer. We will give an overview of this language, which is not exhaustive. A complete presentation of Gofer can be found in the user manual of the Gofer system <ref> [Jon] </ref>, on which this section is based. The following remarks constitute an extremely concise characterization of the language. Gofer is a lazy functional programming language. It is strongly typed, it supports type polymorphism, and its functions are curried.
Reference: [Kap93] <author> Angelica Maria Kappel. </author> <title> Executable specifications based on dynamic algebras. </title> <editor> In A. Voronkov, editor, </editor> <booktitle> Logic Programming and Automated Reasoning, volume 689 of LNAI. </booktitle> <publisher> Springer, </publisher> <year> 1993. </year> <note> 182 BIBLIOGRAPHY 183 </note>
Reference-contexts: The task of evolving algebra compilers is to transform an evolving algebra specification to executable code. Two evolving algebra interpreters have been developed. 76 5.2. Evolving algebra run analyzers 77 * The DASL-ALMA compiler. In <ref> [Kap93] </ref> Kappel defines an evolving algebra specification language, called DASL, and designs an abstract machine, called ALMA, which is a Prolog program. A compiler has been implemented in Pro-log that compiles DASL-specifications to ALMA-instructions. Hence, the combination of this DASL-to-ALMA compiler and the ALMA machine forms a DASL-to-Prolog compiler.
Reference: [LHJ95] <author> Sheng Liang, Paul Hudak, and Mark Jones. </author> <title> Monad transformers and modular interpreters. </title> <booktitle> In Conference Record of POPL'95: 22nd ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages, </booktitle> <month> January </month> <year> 1995. </year>
Reference-contexts: A good introduction to monadic programming is given by Wadler in [Wad92]. A somewhat more formal account of monads can be found in [Wad90]. Monad extensions and monad transformers were proposed as programming techniques by Liang, Hudak and Jones <ref> [LHJ95] </ref>. In the present chapter, the various concepts present in these sources have been accommodated into a single coherent presentation. Also, a number of new concepts have been added. <p> Some of the monad extensions given here are mentioned in passing in <ref> [LHJ95] </ref>. The zero extension We can define a zero function on monads. <p> Finally, we will show how monad extensions are 122 Chapter 9. Programming with monads defined for transformed monads, and we will demonstrate the use of extended transformed monads by example. Monad transformers are proposed as a programming technique in <ref> [LHJ95] </ref>. Some of the monad transformers to be presented in section 9.3.4 were mentioned in that article. 9.3.1 Definition of monad transformers What are monad transformers? A monad transformer is a unary type constructor, which takes a monad as argument and is monad-valued.
Reference: [PH94] <author> Arnd Poetzsch-Heffter. </author> <title> Deriving partial correctness logics from evolving algebras. </title> <editor> In B. Pehrson and I. Simon, editors, </editor> <booktitle> IFIP 13th World Computer Congress, </booktitle> <volume> volume Volume I: Technology/Foundations, </volume> <pages> pages 434 - 439. </pages> <address> El-sevier, </address> <year> 1994. </year>
Reference-contexts: Prerequisite to the development of a theorem prover is the formulation of a proof theory for evolving algebras. For simplified one-sorted evolving algebras an attempt at formulating such a proof theory has been made by Poetzsch-Heffner in <ref> [PH94] </ref>. But for general evolving algebras no proof theory is currently available, and no interactive theorem provers have been built. Somewhat less ambitiously, theorem provers could be developed that are dedicated to specific theorems.
Reference: [Ton93] <author> Hans Tonino. </author> <title> A formalization of many-sorted evolving algebras. </title> <type> Report 93-115, </type> <institution> Delft University of Technology, Faculty of Technical Mathematics and Informatics, </institution> <year> 1993. </year>
Reference-contexts: Also, the section on evolving algebras in the article A Mathematical Definition of Full Prolog [BR94, x1] by Egon Borger and Dean Rosenzweig has been consulted. The main source, however, is Hans Tonino's report by the title A formalization of many-sorted evolving algebras <ref> [Ton93] </ref>. The several treatments of evolving algebras in these four sources diverge in a number of respects. In the first place, there is a divergence in terminology. For some concepts different names are employed, and some names are employed for different concepts.
Reference: [Wad90] <author> Philip Wadler. </author> <title> Comprehending monads. </title> <booktitle> In Proceedings of the 1990 ACM Conference on Lisp and Functional Programming, </booktitle> <month> June </month> <year> 1990. </year>
Reference-contexts: Monads and monad transformers are notions that stem from category theory. However, no knowledge of category theory is needed to understand and apply monadic programming methods. A good introduction to monadic programming is given by Wadler in [Wad92]. A somewhat more formal account of monads can be found in <ref> [Wad90] </ref>. Monad extensions and monad transformers were proposed as programming techniques by Liang, Hudak and Jones [LHJ95]. In the present chapter, the various concepts present in these sources have been accommodated into a single coherent presentation. Also, a number of new concepts have been added.
Reference: [Wad92] <editor> Philip Wadler. </editor> <booktitle> The essence of functional programming. In Conference Record of the Nineteenth Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 1-14, </pages> <month> January </month> <year> 1992. </year>
Reference-contexts: Monads and monad transformers are notions that stem from category theory. However, no knowledge of category theory is needed to understand and apply monadic programming methods. A good introduction to monadic programming is given by Wadler in <ref> [Wad92] </ref>. A somewhat more formal account of monads can be found in [Wad90]. Monad extensions and monad transformers were proposed as programming techniques by Liang, Hudak and Jones [LHJ95]. In the present chapter, the various concepts present in these sources have been accommodated into a single coherent presentation.
Reference: [Wat90] <author> David A. Watt. </author> <title> Programming Language Concepts and Paradigms. </title> <booktitle> International Series in Computer Science. </booktitle> <publisher> Prentice Hall, </publisher> <year> 1990. </year>
Reference-contexts: Value parameters can be used to pass information into an abstraction only. result parameters At the moment of return, the value of the formal parameter is transferred to the actual parameter. Return parameters can be used to pass information out of an abstraction only. 2 In Watt <ref> [Wat90] </ref> the term "syntactic class" is used in stead of category of expressions. 3.3. Modules as parameterized abstractions 39 value-result parameters The value-result parameter is a combination of the other two.
References-found: 19

