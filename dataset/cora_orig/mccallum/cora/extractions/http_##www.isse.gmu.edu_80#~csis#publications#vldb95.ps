URL: http://www.isse.gmu.edu:80/~csis/publications/vldb95.ps
Refering-URL: http://www.isse.gmu.edu:80/~csis/publication.html
Root-URL: 
Title: Using Formal Methods To Reason About Semantics-Based Decompositions Of Transactions  
Author: Paul Ammann Sushil Jajodia Indrakshi Ray 
Address: Fairfax, VA 22030-4444  
Affiliation: Center for Secure Information Systems and Department of Information and Software Systems Engineering George Mason University  
Abstract: Many researchers have investigated the process of decomposing transactions into smaller pieces to increase concurrency. The focus of the research is typically on implementing a decomposition supplied by the database application developer, with relatively little attention to what constitutes a desirable decomposition and how the developer should obtain such a decomposition. In this paper, we argue that the decomposition process itself is worthy of attention. A decomposition generates a set of proof obligations that must be satisfied to show that a particular decomposition correctly models the original collection of transactions. We introduce the notion of semantic histories to formulate and prove the necessary properties. Since the decomposition impacts not only the atomicity of transactions, but isolation and consistency properties as well, we present a technique based on formal methods that allows these properties to be surrendered in a carefully controlled manner. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> D. Agrawal, A. El Abbadi, and Ambuj K. Singh. Consis tency and orderability: </author> <title> Semantics-based correctness criteria for databases. </title> <journal> ACM Transactions on Database Systems, </journal> <volume> 18(3) </volume> <pages> 460-486, </pages> <month> September </month> <year> 1993. </year>
Reference-contexts: We are interested in achieving more concurrency by expanding the set of correct execution histories such that some transactions need not be atomic. The second line is a set of papers on breaking transactions into steps [17], and in particular papers on semantic database concurrency control <ref> [1, 4, 16, 2, 5, 6, 10] </ref>. Researchers have introduced the notions of transaction steps, countersteps, allowed vs. prohibited in-terleavings of steps, and implementations in locking environments.
Reference: [2] <author> B. R. Badrinath and Krithi Ramamritham. </author> <title> Semantics-based concurrency control: Beyond commutativity. </title> <journal> ACM Transactions on Database Systems, </journal> <volume> 17(1) </volume> <pages> 163-199, </pages> <month> March </month> <year> 1992. </year>
Reference-contexts: We are interested in achieving more concurrency by expanding the set of correct execution histories such that some transactions need not be atomic. The second line is a set of papers on breaking transactions into steps [17], and in particular papers on semantic database concurrency control <ref> [1, 4, 16, 2, 5, 6, 10] </ref>. Researchers have introduced the notions of transaction steps, countersteps, allowed vs. prohibited in-terleavings of steps, and implementations in locking environments.
Reference: [3] <author> Philip A. Bernstein, Vassos Hadzilacos, and Nathan Good man. </author> <title> Concurrency Control and Recovery in Database Systems. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, MA, </address> <year> 1987. </year>
Reference-contexts: Specification and analysis conventions peculiar to Z will be explained as the need arises. 2 Related Work Most transaction-oriented models enforce a very low level, syntactic notion of consistency, namely serializ-ability with respect to read/write conflicts <ref> [3] </ref>. Two separate lines of work have expanded on this notion. The first line is the work on atomic transactions [8, 9, 13, 14, 20, 21]. This line of work is based on ADTs. <p> Report ; R2; R3 &gt; is a history. 2 To emphasize the fact that we view the database as an abstract data type and transactions as operations on this abstract data type, we define the term semantic history to distinguish it from the term history used in database literature (e.g., <ref> [3] </ref>). Definition 3 [Semantic History] A semantic history H is a history that is bound to 1. an initial state, and 2. the states resulting from the execution of each step in H . From now on, we will deal with semantic histories only.
Reference: [4] <author> W. Du and A.K. Elmagarmid. </author> <title> Quasi serializability: a cor rectness criterion for global concurrency control in interbase. </title> <booktitle> In Proceedings of the Fifteenth International Conference on Very Large Databases, </booktitle> <pages> pages 347-355, </pages> <year> 1990. </year>
Reference-contexts: We are interested in achieving more concurrency by expanding the set of correct execution histories such that some transactions need not be atomic. The second line is a set of papers on breaking transactions into steps [17], and in particular papers on semantic database concurrency control <ref> [1, 4, 16, 2, 5, 6, 10] </ref>. Researchers have introduced the notions of transaction steps, countersteps, allowed vs. prohibited in-terleavings of steps, and implementations in locking environments.
Reference: [5] <author> A. A. Farrag and M. T. Ozsu. </author> <title> Using semantic knowledge of transactions to increase concurrency. </title> <journal> ACM Transactions on Database Systems, </journal> <volume> 14(4) </volume> <pages> 503-525, </pages> <month> December </month> <year> 1989. </year> <month> 10 </month>
Reference-contexts: We are interested in achieving more concurrency by expanding the set of correct execution histories such that some transactions need not be atomic. The second line is a set of papers on breaking transactions into steps [17], and in particular papers on semantic database concurrency control <ref> [1, 4, 16, 2, 5, 6, 10] </ref>. Researchers have introduced the notions of transaction steps, countersteps, allowed vs. prohibited in-terleavings of steps, and implementations in locking environments. <p> To avoid implementing auxiliary variables and to avoid checking additional preconditions, we propose two mechanisms: a queuing mechanism to ensure that steps of a transaction execute in order and a successor set mechanism somewhat similar to the notion of compatibility sets in [6] and breakpoint sets in <ref> [5] </ref>. The specification of a queuing mechanism is straightforward, and is therefore omitted. Implementation concerns for the queuing mechanism are considered later in the paper. Here we concentrate on the successor set mechanism. <p> Implementation concerns for the queuing mechanism are considered later in the paper. Here we concentrate on the successor set mechanism. We note that the semantics of successor sets differ substantially from that of the analogous notions in [6] and in <ref> [5] </ref>. Also, via specific decomposition steps and corresponding proof obligations, we assist the specifier in verifying the correctness of successor sets with respect to the original specification; in [6] and in [5], the burden of arguing correctness rests entirely with the application developer. <p> note that the semantics of successor sets differ substantially from that of the analogous notions in [6] and in <ref> [5] </ref>. Also, via specific decomposition steps and corresponding proof obligations, we assist the specifier in verifying the correctness of successor sets with respect to the original specification; in [6] and in [5], the burden of arguing correctness rests entirely with the application developer. <p> The notions of interleaving described in [6] and <ref> [5] </ref> are both implemented in a locking environment. Since our interleaving mechanism differs from those of [6, 5], we sketch a two-phase locking implementation of our mechanism. Other implementations are possible, as are various optimizations. <p> The notions of interleaving described in [6] and [5] are both implemented in a locking environment. Since our interleaving mechanism differs from those of <ref> [6, 5] </ref>, we sketch a two-phase locking implementation of our mechanism. Other implementations are possible, as are various optimizations. By treating steps as complete transactions, two-phase locking can guarantee that any history is stepwise conflict serializable (i.e., conflict serializable with steps as primitive operations). <p> As we have indicated, the syntactic aspect of the implementation given in section 5.2 (i.e., stepwise conflict-serializability via two-phase locking), is preliminary. We anticipate developing a more efficient implementation, as was done in [6] and <ref> [5] </ref>. We also must address the problem of reliably transmitting parameters between steps of a transaction, a problem that is considered in [7, 19]. However, the semantic aspects of our implementation have been thoroughly addressed.
Reference: [6] <author> Hector Garcia-Molina. </author> <title> Using semantic knowledge for transac tion processing in a distributed database. </title> <journal> ACM Transactions on Database Systems, </journal> <volume> 8(2) </volume> <pages> 186-213, </pages> <month> June </month> <year> 1983. </year>
Reference-contexts: We are interested in achieving more concurrency by expanding the set of correct execution histories such that some transactions need not be atomic. The second line is a set of papers on breaking transactions into steps [17], and in particular papers on semantic database concurrency control <ref> [1, 4, 16, 2, 5, 6, 10] </ref>. Researchers have introduced the notions of transaction steps, countersteps, allowed vs. prohibited in-terleavings of steps, and implementations in locking environments. <p> Auxiliary variables are a standard method of reasoning about concurrent executions [15], and, in particular, have been applied to the problem of semantic database concurrency control <ref> [6] </ref>. Our work focuses more on the decomposition process than does [6], and so we emphasize the role of auxiliary variables more strongly. <p> Auxiliary variables are a standard method of reasoning about concurrent executions [15], and, in particular, have been applied to the problem of semantic database concurrency control <ref> [6] </ref>. Our work focuses more on the decomposition process than does [6], and so we emphasize the role of auxiliary variables more strongly. <p> But some transactions may output data to users; these transactions are referred to as sensitive transactions in <ref> [6] </ref>. We require 5 sensitive transactions to appear to have generated outputs from a consistent state. <p> To avoid implementing auxiliary variables and to avoid checking additional preconditions, we propose two mechanisms: a queuing mechanism to ensure that steps of a transaction execute in order and a successor set mechanism somewhat similar to the notion of compatibility sets in <ref> [6] </ref> and breakpoint sets in [5]. The specification of a queuing mechanism is straightforward, and is therefore omitted. Implementation concerns for the queuing mechanism are considered later in the paper. Here we concentrate on the successor set mechanism. <p> The specification of a queuing mechanism is straightforward, and is therefore omitted. Implementation concerns for the queuing mechanism are considered later in the paper. Here we concentrate on the successor set mechanism. We note that the semantics of successor sets differ substantially from that of the analogous notions in <ref> [6] </ref> and in [5]. Also, via specific decomposition steps and corresponding proof obligations, we assist the specifier in verifying the correctness of successor sets with respect to the original specification; in [6] and in [5], the burden of arguing correctness rests entirely with the application developer. <p> We note that the semantics of successor sets differ substantially from that of the analogous notions in <ref> [6] </ref> and in [5]. Also, via specific decomposition steps and corresponding proof obligations, we assist the specifier in verifying the correctness of successor sets with respect to the original specification; in [6] and in [5], the burden of arguing correctness rests entirely with the application developer. <p> The notions of interleaving described in <ref> [6] </ref> and [5] are both implemented in a locking environment. Since our interleaving mechanism differs from those of [6, 5], we sketch a two-phase locking implementation of our mechanism. Other implementations are possible, as are various optimizations. <p> The notions of interleaving described in [6] and [5] are both implemented in a locking environment. Since our interleaving mechanism differs from those of <ref> [6, 5] </ref>, we sketch a two-phase locking implementation of our mechanism. Other implementations are possible, as are various optimizations. By treating steps as complete transactions, two-phase locking can guarantee that any history is stepwise conflict serializable (i.e., conflict serializable with steps as primitive operations). <p> As we have indicated, the syntactic aspect of the implementation given in section 5.2 (i.e., stepwise conflict-serializability via two-phase locking), is preliminary. We anticipate developing a more efficient implementation, as was done in <ref> [6] </ref> and [5]. We also must address the problem of reliably transmitting parameters between steps of a transaction, a problem that is considered in [7, 19]. However, the semantic aspects of our implementation have been thoroughly addressed.
Reference: [7] <author> Hector Garcia-Molina and Kenneth Salem. </author> <title> Services for a work flow management system. </title> <journal> Bulletin of the IEEE Computer Society Technical Committee on Data Engineering, </journal> <volume> 17(1) </volume> <pages> 40-44, </pages> <month> March </month> <year> 1994. </year>
Reference-contexts: We anticipate developing a more efficient implementation, as was done in [6] and [5]. We also must address the problem of reliably transmitting parameters between steps of a transaction, a problem that is considered in <ref> [7, 19] </ref>. However, the semantic aspects of our implementation have been thoroughly addressed. We can easily permit ad hoc transactions to be dynamically added in our model, although they will require some special intervention.
Reference: [8] <author> Maurice Herlihy. </author> <title> Extending multiversion time-stamping proto cols to exploit type information. </title> <journal> IEEE Transactions on Computers, </journal> <volume> 36(4) </volume> <pages> 443-448, </pages> <month> April </month> <year> 1987. </year>
Reference-contexts: Two separate lines of work have expanded on this notion. The first line is the work on atomic transactions <ref> [8, 9, 13, 14, 20, 21] </ref>. This line of work is based on ADTs. We also adopt the theory of ADTs to define correctness, but there is a crucial difference in focus.
Reference: [9] <author> Maurice P. Herlihy and William E. Weihl. </author> <title> Hybrid concurrency control for abstract data types. </title> <journal> Journal of Computer and System Sciences, </journal> <volume> 43(1) </volume> <pages> 25-61, </pages> <month> August </month> <year> 1991. </year>
Reference-contexts: Two separate lines of work have expanded on this notion. The first line is the work on atomic transactions <ref> [8, 9, 13, 14, 20, 21] </ref>. This line of work is based on ADTs. We also adopt the theory of ADTs to define correctness, but there is a crucial difference in focus.
Reference: [10] <author> Sushil Jajodia and Catherine Meadows. </author> <title> Managing a replicated file in an unreliable network. </title> <booktitle> In Proceedings of 3rd IEEE International Conference on Data Engineering, </booktitle> <pages> pages 396-404, </pages> <address> Los Angeles, CA, </address> <month> February </month> <year> 1987. </year>
Reference-contexts: We are interested in achieving more concurrency by expanding the set of correct execution histories such that some transactions need not be atomic. The second line is a set of papers on breaking transactions into steps [17], and in particular papers on semantic database concurrency control <ref> [1, 4, 16, 2, 5, 6, 10] </ref>. Researchers have introduced the notions of transaction steps, countersteps, allowed vs. prohibited in-terleavings of steps, and implementations in locking environments.
Reference: [11] <author> H. F. Korth and G. Speegle. </author> <title> Formal aspects of concurrency control in long-duration transaction systems using the nt/pv model. </title> <journal> ACM Transactions on Database Systems, </journal> <volume> 19(3) </volume> <pages> 492-535, </pages> <month> September </month> <year> 1994. </year>
Reference-contexts: Only then do we consider the problem of implementing our decomposition in a two-phase locking environment. The idea of specifying transactions by its preconditions and post conditions has been illustrated in <ref> [12, 11] </ref>. The authors propose the NT/PV transaction model based on nested transactions, multiple versions and explicit predicates. <p> An execution of an interleaved set of transactions is NT/PV correct if every transaction in the set executes correctly. In <ref> [12, 11] </ref>, the burden of correctly specifying the preconditions, postconditions of the transactions, and determining the partial order of the subtransactions in a transaction lies with the application developer.
Reference: [12] <author> H. F. Korth and G. D. Speegle. </author> <title> Formal model of correctness without serializability. </title> <booktitle> In Proceedings of ACM-SIGMOD International Conference on Management of Data, </booktitle> <pages> pages 379-386, </pages> <month> June </month> <year> 1988. </year>
Reference-contexts: Only then do we consider the problem of implementing our decomposition in a two-phase locking environment. The idea of specifying transactions by its preconditions and post conditions has been illustrated in <ref> [12, 11] </ref>. The authors propose the NT/PV transaction model based on nested transactions, multiple versions and explicit predicates. <p> An execution of an interleaved set of transactions is NT/PV correct if every transaction in the set executes correctly. In <ref> [12, 11] </ref>, the burden of correctly specifying the preconditions, postconditions of the transactions, and determining the partial order of the subtransactions in a transaction lies with the application developer.
Reference: [13] <author> Nancy Lynch, Michael Merritt, William Weihl, and Alan Fekete. </author> <title> Atomic Transactions. </title> <publisher> Morgan Kaufmann Publishers, </publisher> <address> San Mateo, CA, </address> <year> 1994. </year>
Reference-contexts: Two separate lines of work have expanded on this notion. The first line is the work on atomic transactions <ref> [8, 9, 13, 14, 20, 21] </ref>. This line of work is based on ADTs. We also adopt the theory of ADTs to define correctness, but there is a crucial difference in focus.
Reference: [14] <author> Nancy A. Lynch. </author> <title> Multilevel atomicity|A new correctness cri terion for database concurrency control. </title> <journal> ACM Transactions on Database Systems, </journal> <volume> 8(4) </volume> <pages> 484-502, </pages> <month> December </month> <year> 1983. </year>
Reference-contexts: Two separate lines of work have expanded on this notion. The first line is the work on atomic transactions <ref> [8, 9, 13, 14, 20, 21] </ref>. This line of work is based on ADTs. We also adopt the theory of ADTs to define correctness, but there is a crucial difference in focus.
Reference: [15] <author> Susan Owicki and David Gries. </author> <title> Verifying properties of parallel programs: An axiomatic approach. </title> <journal> Communications of the ACM, </journal> <volume> 19(5) </volume> <pages> 279-285, </pages> <month> May </month> <year> 1976. </year>
Reference-contexts: To reason about the correctness of decomposing transactions into steps, and avoid the problems of a naive decomposition, we use auxiliary variables to generalize the invariants. Auxiliary variables are a standard method of reasoning about concurrent executions <ref> [15] </ref>, and, in particular, have been applied to the problem of semantic database concurrency control [6]. Our work focuses more on the decomposition process than does [6], and so we emphasize the role of auxiliary variables more strongly.
Reference: [16] <author> L. Sha, J. P. Lehoczky, and E.D. Jensen. </author> <title> Modular concurrency control and failure recovery. </title> <journal> IEEE Transactions on Computer, </journal> <volume> 37(2) </volume> <pages> 146-159, </pages> <month> February </month> <year> 1988. </year>
Reference-contexts: We are interested in achieving more concurrency by expanding the set of correct execution histories such that some transactions need not be atomic. The second line is a set of papers on breaking transactions into steps [17], and in particular papers on semantic database concurrency control <ref> [1, 4, 16, 2, 5, 6, 10] </ref>. Researchers have introduced the notions of transaction steps, countersteps, allowed vs. prohibited in-terleavings of steps, and implementations in locking environments.
Reference: [17] <author> Dennis Shasha, Eric Simon, and Patrick Valduriez. </author> <title> Simple rational guidance for chopping up transactions. </title> <booktitle> In Proceedings ACM SIGMOD International Conference on Management of Data, </booktitle> <pages> pages 298-307, </pages> <address> San Diego, CA, </address> <month> June </month> <year> 1992. </year>
Reference-contexts: We are interested in achieving more concurrency by expanding the set of correct execution histories such that some transactions need not be atomic. The second line is a set of papers on breaking transactions into steps <ref> [17] </ref>, and in particular papers on semantic database concurrency control [1, 4, 16, 2, 5, 6, 10]. Researchers have introduced the notions of transaction steps, countersteps, allowed vs. prohibited in-terleavings of steps, and implementations in locking environments.
Reference: [18] <author> J.M. Spivey. </author> <title> The Z Notation: A Reference Manual. </title> <publisher> Prentice Hall, </publisher> <address> New York, </address> <year> 1989. </year>
Reference-contexts: The rest of the paper is organized as follows. Section 2 briefly reviews related research. Section 3 presents a motivating example. Section 4 contains the model with refinements to the motivating example. Section 5 discusses an implementation. Section 6 concludes the paper. We adopt the Z specification language <ref> [18] </ref> for expressing model-based specifications of abstract data types or ADTs. Z is based on set theory, first order predicate logic, and a schema calculus to organize large specifications. Knowledge of Z is helpful, but not required, for reading this paper, since we narrate the formal specification in English.
Reference: [19] <author> Helmut Wachter and Andreas Reuter. </author> <title> The contract model. </title> <editor> In Ahmed K. Elmagarmid, editor, </editor> <booktitle> Database Transaction Models for Advanced Applications, </booktitle> <pages> pages 219-263. </pages> <publisher> Morgan Kauffman, </publisher> <year> 1992. </year>
Reference-contexts: We anticipate developing a more efficient implementation, as was done in [6] and [5]. We also must address the problem of reliably transmitting parameters between steps of a transaction, a problem that is considered in <ref> [7, 19] </ref>. However, the semantic aspects of our implementation have been thoroughly addressed. We can easily permit ad hoc transactions to be dynamically added in our model, although they will require some special intervention.
Reference: [20] <author> William E. Weihl. </author> <title> Specification and Implementation of Atomic Data Types. </title> <type> PhD thesis, </type> <institution> Massachusetts Institute of Technology, </institution> <address> Cambridge, MA, </address> <year> 1984. </year>
Reference-contexts: Two separate lines of work have expanded on this notion. The first line is the work on atomic transactions <ref> [8, 9, 13, 14, 20, 21] </ref>. This line of work is based on ADTs. We also adopt the theory of ADTs to define correctness, but there is a crucial difference in focus.
Reference: [21] <author> William E. Weihl. </author> <title> Commutativity-based concurrency control for abstract data types. </title> <journal> IEEE Transactions on Computers, </journal> <volume> 37(12) </volume> <pages> 1488-1505, </pages> <month> December </month> <year> 1988. </year> <month> 11 </month>
Reference-contexts: Two separate lines of work have expanded on this notion. The first line is the work on atomic transactions <ref> [8, 9, 13, 14, 20, 21] </ref>. This line of work is based on ADTs. We also adopt the theory of ADTs to define correctness, but there is a crucial difference in focus.
References-found: 21

