URL: http://www.mcs.anl.gov/~gropp/papers/sowing/paper.ps.Z
Refering-URL: http://www.mcs.anl.gov/~gropp/papers.html
Root-URL: http://www.mcs.anl.gov
Title: SOWING MPICH: A CASE STUDY IN THE DISSEMINATION OF A PORTABLE ENVIRONMENT FOR PARALLEL SCIENTIFIC COMPUTING  
Author: WILLIAM GROPP AND EWING LUSK 
Abstract: MPICH is an implementation of the MPI specification for a standard message-passing library interface. In this article we focus on the lessons learned from preparing MPICH for diverse parallel computing environments. These lessons include how to prepare software for configuration in unknown environments; how to structure software to absorb contributions by others; how to automate the preparation of man pages, Web pages, and other documentation; how to automate prerelease testing for both correctness and performance; and how to manage the inevitable problem reports with a minimum of resources for support. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <editor> GNU manuals. </editor> <address> http://www.delorie.com/gnu/docs. </address>
Reference-contexts: This is useful for finding files left in the locked state acciden tally. 3 We are now beginning to experiment with CVS <ref> [1] </ref>, which provides more support for multi-site work by allowing checkout of whole subsystems at a time. 4. Managing Portability. <p> We also considered using xmkmf but found it more cumbersome to use than autoconf, as well as being tied to the X distribution and local installation. We found GNU autoconf <ref> [1] </ref> to provide an excellent solution. GNU autoconf is a set of m4 macro definitions from the Free Software Foundation that makes it easy a developer to create a configure script for delivery with a software package.
Reference: [2] <institution> PETSc 2.0 for MPI. </institution> <note> http://www.mcs.anl.gov/petsc/petsc.html. </note>
Reference-contexts: MPICH augments the standard with additional documentation, the preparation of which was facilitated by a number of automated tools. 6 5.1. Man Pages. MPICH inherited from PETSc <ref> [2] </ref> a tool for turning structured comments in the source code into man pages. The tool is called doctext [7].
Reference: [3] <author> Ralph Butler and Ewing Lusk. </author> <title> Monitors, messages, and clusters: The p4 parallel programming system. </title> <journal> Parallel Computing, </journal> <volume> 20 </volume> <pages> 547-564, </pages> <month> April </month> <year> 1994. </year>
Reference-contexts: Within a week, major parts of the initial draft were implemented, and MPICH continued to track the development through to completion. What made us able to implement the initial draft so quickly was considerable experience with the portable parallel message-passing systems Chameleon [15] and p4 <ref> [3] </ref>. As a result of those experiences, we decided to pursue an aggressive probram of relying on automated tools|both existing ones and those we would write-to help us design, write, test, distribute, and maintain MPICH.
Reference: [4] <author> Remy Evard. </author> <title> Managing the ever-growing to do list. </title> <booktitle> In USENIX Proceedings of the Eighth Large Installation Systems Administration Conference, </booktitle> <pages> pages 111-116, </pages> <year> 1994. </year>
Reference-contexts: After considering a number of alternatives, we chose req <ref> [4] </ref>. This system works entirely by observing, modifying, and responding to the Subject: line in ordinary e-mail. Users usually are not even aware that they are interacting with a problem-tracking system. The req system has a companion GUI version based on Tcl/Tk; we find both versions useful.
Reference: [5] <author> The MPI Forum. </author> <title> MPI message passing interface standard, </title> <note> version 1.1. http://www.mcs.anl.gov/mpi/mpi-report-1.1/mpi-report.html. </note>
Reference-contexts: Managing Documentation. A hallmark of high-quality software is its documentation. The specification for MPICH is given by the MPI standard itself, and we maintain an HTML version of the standard for online reference <ref> [5] </ref>. MPICH augments the standard with additional documentation, the preparation of which was facilitated by a number of automated tools. 6 5.1. Man Pages. MPICH inherited from PETSc [2] a tool for turning structured comments in the source code into man pages. The tool is called doctext [7].
Reference: [6] <author> William Gropp. </author> <title> Users manual for bfort: Producing Fortran interfaces to C source code. </title> <type> Technical Report ANL/MCS-TM-208, </type> <institution> Argonne National Laboratory, </institution> <month> March </month> <year> 1995. </year>
Reference-contexts: Automated production of the wrapper functions was especially useful during the period when the MPI standard was changing every six weeks and the language bindings were in flux. We used the highly configurable bfort program, described in <ref> [6] </ref>.
Reference: [7] <author> William Gropp. </author> <title> Users manual for doctext: Producing documentation from C source code. </title> <type> Technical Report ANL/MCS-TM-206, </type> <institution> Mathematics and Computer Science Division, Ar-gonne National Laboratory, </institution> <month> March </month> <year> 1995. </year>
Reference-contexts: MPICH augments the standard with additional documentation, the preparation of which was facilitated by a number of automated tools. 6 5.1. Man Pages. MPICH inherited from PETSc [2] a tool for turning structured comments in the source code into man pages. The tool is called doctext <ref> [7] </ref>.
Reference: [8] <author> William Gropp. </author> <title> Users manual for tohtml: Producing true hypertext documents from LaTeX. </title> <type> Technical Report ANL/MCS-TM-207, </type> <institution> Argonne National Laboratory, </institution> <month> March </month> <year> 1995. </year>
Reference-contexts: In particular, the user's manual assumes that MPICH has already been installed and instead focuses directly on how to build and run user applications. The L A T E X-to-HTML converter tohtml <ref> [8] </ref> enabled us to put the MPICH User's Guide and the MPICH Installation Guide on the Web for easy reference and was critical for creating a Web version of the MPI standard itself.
Reference: [9] <author> William Gropp and Ewing Lusk. </author> <title> An abstract device definition to support the implementation of a high-level point-to-point message-passing interface. </title> <type> Preprint MCS-P342-1193, </type> <institution> Mathematics and Computer Science Division, Argonne National Laboratory, </institution> <year> 1994. </year>
Reference-contexts: of the device code is shared among multiple devices); * accept new device implementations from vendors and others, smoothly absorbing them into MPICH (in particular, the T3D, Meiko, NX, Convex SPP, and Nexus devices were written outside our group and plugged into MPICH via the Abstract Device Interface, described in <ref> [9] </ref> with a minimum of diffi culty; and * experiment with new devices wthout impacting the stability of existing code (a recent example was a new version of the generic shared-memory device that avoided most uses of locks [12]).
Reference: [10] <author> William Gropp and Ewing Lusk. </author> <title> Installation guide for mpich, a portable implementation of MPI. </title> <type> Technical Report ANL-96/5, </type> <institution> Argonne National Laboratory, </institution> <year> 1994. </year>
Reference-contexts: It is easy to maintain the man pages automatically because their contents are embedded in the source code itself. (The .N notations include text that is constant from one man page to another.) 5.2. Manuals. We decided to separate the end user manual [11] from the installation manual <ref> [10] </ref>, so that each type of user would have only what was needed. In particular, the user's manual assumes that MPICH has already been installed and instead focuses directly on how to build and run user applications.
Reference: [11] <author> William Gropp and Ewing Lusk. </author> <title> User's guide for mpich, a portable implementation of MPI. </title> <type> Technical Report ANL-96/6, </type> <institution> Argonne National Laboratory, </institution> <year> 1994. </year>
Reference-contexts: It is easy to maintain the man pages automatically because their contents are embedded in the source code itself. (The .N notations include text that is constant from one man page to another.) 5.2. Manuals. We decided to separate the end user manual <ref> [11] </ref> from the installation manual [10], so that each type of user would have only what was needed. In particular, the user's manual assumes that MPICH has already been installed and instead focuses directly on how to build and run user applications.
Reference: [12] <author> William Gropp and Ewing Lusk. </author> <title> A high-performance MPI implementation on a shared-memory vector supercomputer. </title> <type> Technical report, </type> <institution> Argonne National Laboratory, </institution> <month> June </month> <year> 1996. </year> <month> 11 </month>
Reference-contexts: group and plugged into MPICH via the Abstract Device Interface, described in [9] with a minimum of diffi culty; and * experiment with new devices wthout impacting the stability of existing code (a recent example was a new version of the generic shared-memory device that avoided most uses of locks <ref> [12] </ref>). Our second decision regarding the source code management concerned the Fortran-callable versions of the MPI library routines. The Fortran interface consists of a set of wrapper functions that transform their arguments into the correct form for the C versions and then call the standard C versions of the functions.
Reference: [13] <author> William Gropp, Ewing Lusk, Nathan Doss, and Anthony Skjellum. </author> <title> A high-performance, portable implementation of the MPI message-passing interface standard. </title> <booktitle> Parallel Computing, </booktitle> <year> 1996. </year> <note> (to appear). </note>
Reference-contexts: The archeitecture of MPICH, as well as the tradeoffs made between portabilitya dn performance, has been described in <ref> [13] </ref>. Here, we focus on the project goals that were independent of the particular system being implemented. Such goals presumably shared with the developers of other portable parallel environments. Goals for the code. We had the normal goals for our code|robustness and performance| plus the extra one of extreme portability. <p> We decided to maintain a single directory tree containing all components. The MPICH distribution is extracted from this tree when a release is made (see Section 7). Three particular decisions served us well. The first was to divide the implementation into layers, as described in <ref> [13] </ref>. <p> not only will configure and build MPICH, but also will prepare a report (in L A T E X format) describing what configure learned about the environment, how long it took to install, what problems were encountered during installation, and graphical performance results based on running the mpptest benchmark (see <ref> [13] </ref>). Such reports provide a snapshot of the MPICH status at any time on any machine. A full set of these reports is maintained on our Web site so that remote users can compare their experiences with ours. 5.4. Examples. <p> Testing for Performance. Since high performance is an important goal of MPICH, performance bugs must be identified and repaired along with correctness bugs. The test suite distributed with MPICH contains a relatively sophisticated performance test program (mpptest, described in <ref> [13] </ref>) that can be used for tuning high-performance device implementations and ensuring that correctness bug fixes do not (unnecessarily) impact performance. 7. Managing Distribution. It is often difficult to tell just exactly the right time for a public release of a new version.
Reference: [14] <author> William Gropp, Ewing Lusk, and Anthony Skjellum. </author> <title> Using MPI: Portable Parallel Programming with the Message-Passing Interface. </title> <publisher> MIT Press, </publisher> <year> 1994. </year>
Reference-contexts: The most basic examples are minimal MPI pro 7 grams. The test suite (described in Section 6.1) contains examples of the use of every MPI function. More elaborate demonstration programs, discussed in the book Using MPI <ref> [14] </ref>, are furnished; and more exotic programs, using the mpe parallel graphics library that comes with MPICH, provide examples of how more complex applications might be assembled. 6. Managing Testing. One goal in distributing software is that users encounter no bugs.
Reference: [15] <author> William D. Gropp and Barry Smith. </author> <title> Chameleon parallel programming tools users manual. </title> <type> Technical Report ANL-93/23, </type> <institution> Argonne National Laboratory, </institution> <month> March </month> <year> 1993. </year> <month> 12 </month>
Reference-contexts: Within a week, major parts of the initial draft were implemented, and MPICH continued to track the development through to completion. What made us able to implement the initial draft so quickly was considerable experience with the portable parallel message-passing systems Chameleon <ref> [15] </ref> and p4 [3]. As a result of those experiences, we decided to pursue an aggressive probram of relying on automated tools|both existing ones and those we would write-to help us design, write, test, distribute, and maintain MPICH.
References-found: 15

