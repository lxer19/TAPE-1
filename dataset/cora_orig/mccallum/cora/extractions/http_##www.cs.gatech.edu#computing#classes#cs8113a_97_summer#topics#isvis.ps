URL: http://www.cs.gatech.edu/computing/classes/cs8113a_97_summer/topics/isvis.ps
Refering-URL: http://www.cs.gatech.edu/computing/classes/cs8113a_97_summer/
Root-URL: 
Title: Abstract Understanding the architecture of a program requires determining both the major components into which
Keyword: software architecture extraction, program visualization, dynamic analysis, program understanding  
Note: this understanding. This paper describes  should be inserted.  1. Understanding Software Architectures  
Abstract-found: 0
Intro-found: 0
Reference: [1] <author> Gregory Abowd, Christian Ertmann-Christiansen, Ashok Goel, Dean F. Jerding, Michael McCracken, Melody Moore, J. William Murdock, Colin Potts, Spencer Rugaber, and Linda Wills. </author> <title> MORALE / Mission Oriented Architectural Legacy Evolution. </title> <booktitle> To appear in the Proceedings of the International Conference on Software Maintenance97, </booktitle> <address> Bari, Italy, </address> <month> September 29-October 3, </month> <year> 1997. </year>
Reference-contexts: Also, it is possible to save the current Program Model and event traces that have been read in for later analyses. 4. Architectural Localization Case Study Our case study arose as part of a larger effort to support the evolution of legacy systems (the MORALE project) <ref> [1] </ref>. Given an existing system and a new set of requirements, the MORALE process identifies what the current version of the system can do and what needs to change in order to support the new requirements. It then suggests how the system should be changed to accomplish its new mission.
Reference: [2] <author> Wayne Citrin, Alistair Cockburn, Jurg von Kanel, and Rainer Hauser. </author> <title> Using Formalized Temporal Message-Flow Diagrams. </title> <journal> Soft-warePractice and Experience, </journal> <volume> 25(12): </volume> <pages> 1367-1401, </pages> <month> December </month> <year> 1995. </year>
Reference-contexts: Figure 4 shows a Scenario View from the case study described in Section 4. The Scenario View is in fact a Temporal Message Flow Diagram (TMFD) <ref> [2] </ref>, sometimes called an interaction diagram or event-trace diagram. Actors in the view are assigned columns, and interactions are drawn as lines from source to destination actor in descending time order. <p> Some of the more recent efforts in these areas are mentioned here and related to our work. As mentioned previously, Citrin et al. have attempted to formalize the notations used to describe communication between entities in systems, using the notion of a temporal message-ow diagram (TMFD) <ref> [2] </ref>. They have built tools to display and edit TMFDs, to generate TMFDs from event traces, and to simulate the operation of a system using TMFDs. Their work is much more general than ours, handling systems in which messages can be sent and received in an interleaved, nondeterministic sequence.
Reference: [3] <author> Jonathan E. Cook and Alexander L. Wolf. </author> <title> Automating Process Discovery through Event-Data Analysis. </title> <booktitle> Proceedings of the 17th International Conference on Software Engineering, </booktitle> <address> Seattle, Washington, </address> <month> April </month> <year> 1995. </year>
Reference-contexts: But the abundance of event data from log files makes determining commonality difficult. Internally, ISVis supports several straightforward heuristics to detect patterns. However, other tools are available that may do a more sophisticated job at this task. In particular, we are looking at the Balboa tool <ref> [3] </ref>. Balboa is capable of applying several machine-learning techniques to the problem of describing complex event traces. Balboa produces as output a finite state machine that is capable of generating the event sequence.
Reference: [4] <author> James O. Coplien and Douglas C. Schmidt. </author> <title> Pattern Languages of Program Design. </title> <publisher> Addison-Wesley, </publisher> <year> 1995. </year>
Reference: [5] <author> R. Fiutem, P. Tonella, G. Antoniol, and E. Merlo. </author> <title> A Cliche-Based Environment to Support Architectural Reverse Engineering. </title> <booktitle> International Conference on Software Engineering, </booktitle> <address> Monterey, California, </address> <month> November 4-8, </month> <year> 1996, </year> <pages> 319-328. </pages>
Reference-contexts: Extracting an architectural model from a program traditionally means treating subprograms as components and subprogram invocations as connectors. Extraction at this level is straightforward but may generate too much detail. Among the few successes that go further are Harris et al. [8] and Fiutem et al. <ref> [5] </ref>, both of whom rely on lexical cues to detect specific system-library invocations. For example, Harris et al. equates components with Unix processes and specifically looks for instances of the term fork to identify them.
Reference: [6] <author> Erich Gamma, Richard Helm, Ralph Johnson, and John Vlissides. </author> <title> Design Patterns: Abstraction and Reuse of Object-Oriented Software. </title> <publisher> Addison-Wesley, </publisher> <year> 1995. </year>
Reference: [7] <author> D. Garlan, B. Monroe, and D. Wile. ACME: </author> <title> An interchange language for software architecture, 2nd edition. </title> <type> Technical report, </type> <institution> Car-negie Mellon University, </institution> <year> 1997. </year>
Reference-contexts: SAAMTool supports this process by, among other things, providing a graphical display tool for architectures. SAAMTool itself does not generate an architectural models, so it is natural to use ISVis for that purpose. We are currently looking at ACME <ref> [7] </ref> as an interoperability mechanism for the architectural models that need to be communicated between ISVis and SAAMTool. 6. Related Work Several different areas overlap with our work, including software visualization, program understanding, and reverse engineering.
Reference: [8] <author> David R. Harris, Alex S. Yeh, and Howard B. Reubenstein. </author> <title> Extracting Architectural Features from Source Code. </title> <journal> Automated Software Engineering, </journal> 3(1/2):109-138, June 1996. 
Reference-contexts: Extracting an architectural model from a program traditionally means treating subprograms as components and subprogram invocations as connectors. Extraction at this level is straightforward but may generate too much detail. Among the few successes that go further are Harris et al. <ref> [8] </ref> and Fiutem et al. [5], both of whom rely on lexical cues to detect specific system-library invocations. For example, Harris et al. equates components with Unix processes and specifically looks for instances of the term fork to identify them.
Reference: [9] <author> Dean F. Jerding and John T. Stasko. </author> <title> The Information Mural: A Technique for Displaying and Navigating Large Information Spaces. </title> <booktitle> Proceedings of the IEEE Visualization `95 Symposium on Information Visualization, </booktitle> <address> Atlanta, Georgia, </address> <month> October </month> <year> 1995, </year> <pages> pp. 43-50. </pages>
Reference-contexts: Features of ISVis include the following. analysis of program event traces numbering over 1,000,000 events simultaneous analysis of multiple traces for the same program views include actor and interaction lists and relationships, scenarios, and source code (via XEmacs) use of Information Mural <ref> [9] </ref> visualization techniques to portray global overviews of scenarios abstraction of actors through containment hierarchies and analyst-defined components selective filtering of individual or multiple occurrences of a particular interaction definition of higher-level scenarios comprising repeated sub-scenarios identification of scenarios to be used as patterns for locating the same or similar scenarios <p> The key area allows users to assign colors to actors or interactions that have been selected using the left mouse button. The bottom portion of the view is a shell for textual information inputoutput. Note that each of the scrollable lists of actors and interactions uses an Information Mural <ref> [9] </ref> to display a graphical overview of the selected and colored items in the list. The Main View includes a menu bar for entering commands, including the ability to open a Scenario View for each scenario in the model.
Reference: [10] <author> Dean F. Jerding, John T. Stasko, and Thomas Ball. </author> <title> Visualizing Interactions in Program Executions. </title> <booktitle> To appear in the Proceedings of the International Conference on Software Engineering, </booktitle> <year> 1997. </year>
Reference-contexts: process and a tool within which a programs behavior can be visualized, filtered, and abstracted and with which the analyst can build and save views of the behavior appropriate for the particular program understanding task. 2.2 Abstraction Through the use of visualization prototypes built during the course of this research <ref> [10] </ref>, it has been observed that program executions are made up of recurring patterns of interaction, manifested as repeated sequences of program events such as function calls. Instances of these interaction patterns occur at various levels of abstraction.
Reference: [11] <author> R. Kazman, L. Bass, G. Abowd, and S. M. Webb. SAAM: </author> <title> A Method for Analyzing the Properties of Software Architectures. </title> <booktitle> Proceedings of the International Conference on Software Engineering 16, </booktitle> <address> Sorrento, Italy, </address> <month> May </month> <year> 1994, </year> <pages> 81-90. </pages>
Reference-contexts: We intend to hook Balboa to the ISVis pattern matcher and see how this enhancement extends the power of ISVis analyses. The second form of interaction we intend to investigate is with an architectural analysis tool called SAAMTool. SAAM <ref> [11] </ref> is an architectural analysis method that uses scenarios to guide analysts in making decisions about the desirability of a proposed enhancement to a software system. SAAMTool supports this process by, among other things, providing a graphical display tool for architectures.
Reference: [12] <author> Danny B. Lange and Yuichi Nakamura. </author> <title> Interactive Visualization of Design Patterns Can Help in Framework Understanding. </title> <booktitle> Proceedings of ACM OOPSLA '95, </booktitle> <year> 1995, </year> <pages> pp. 342-357. </pages>
Reference-contexts: Their approach has helped with design reengineering and conformance tasks. This work is directed more toward static, architectural models, while our work is focused on sequential, behavioral models. The Program Explorer is a C++ program understanding tool that is focused on class and object centered views <ref> [12] </ref>. The authors have developed a system for tracking function invocation, object instantiation, and attribute access. The views show class and instance relationships (usually focused on a particular instance or class), and short method-invocation histories.
Reference: [13] <author> P. K. Linos and V. Courois. </author> <title> A Tool for Understanding Object-Oriented Program Dependencies. </title> <booktitle> Proceedings of the Workshop on Program Comprehension, </booktitle> <year> 1994, </year> <pages> pp. 20-27. </pages>
Reference-contexts: Examples of using the system to uncover design patterns in real-world sized systems are given. The OO!CARE tool is the C++ version of the CARE environment for C program understanding <ref> [13] </ref>. The idea of the OO!CARE system is to extract and visualize dependencies between classes, objects, and methods in the program, as well as the control and data ow. The system includes a code analyzer, a dependencies database, and a display manager.
Reference: [14] <author> G. C. Murphy, D. Notkin, and K. Sullivan. </author> <title> Software Reexion Models: Bridging the Gap Between Source and High-Level Models. </title> <booktitle> Proceedings of the Foundations of Software Engineering, </booktitle> <year> 1995. </year>
Reference-contexts: Murphy, et al. have developed an approach that allows software engineers to specify high-level models of a system and how the source code maps into that model <ref> [14] </ref>. Then a reexion model is computed, which uses call graph and data referencing information to determine where the model agrees and disagrees with the actual implementation. A box-and-arrow diagram is used to depict the specified models and their differences. Their approach has helped with design reengineering and conformance tasks.
Reference: [15] <institution> National Center for Supercomputing Applications. NCSA Mosaic Home Page. </institution> <address> http://www.ncsa.uiuc.edu/SDG/Software/Mosaic/ NCSAMosaicHome.html. </address>
Reference-contexts: The ISVis tool helps the analyst construct an accurate model of the systems behavior and validate hypothesized models of the system. 4.1 Adding user-configurable viewers to Mosaic The subject system for this case study is the NCSA Mosaic web browser, version 2.4 <ref> [15] </ref>. This version uses MIME [16] types to denote internal and external viewers for different types of web pages. The enhancement task is the extension of version 2.4 to support user-configurable external viewers, whereby Mosaic provides users interactive control over which viewers are used for specific types of web pages.
Reference: [16] <author> Marshall T. Rose. </author> <title> The Internet Message: closing the book with electronic mail. </title> <publisher> Prentice-Hall, </publisher> <address> ISBN 0-13-092941-7. </address>
Reference-contexts: The ISVis tool helps the analyst construct an accurate model of the systems behavior and validate hypothesized models of the system. 4.1 Adding user-configurable viewers to Mosaic The subject system for this case study is the NCSA Mosaic web browser, version 2.4 [15]. This version uses MIME <ref> [16] </ref> types to denote internal and external viewers for different types of web pages. The enhancement task is the extension of version 2.4 to support user-configurable external viewers, whereby Mosaic provides users interactive control over which viewers are used for specific types of web pages.
Reference: [17] <author> Mohlalefi Sefika, Aamod Sane, and Roy H. Campbell. </author> <title> Architecture-Oriented Visualization. </title> <booktitle> Proceedings of ACM OOPSLA 96, </booktitle> <year> 1996, </year> <pages> pp. 389-405. </pages>
Reference-contexts: However, they have not done any work to identify patterns in the event traces. Sefika, Sane, and Campbell have done work in architectural visualization of systems with goals similar to ours <ref> [17] </ref>. Their views seek to portray the operation of a system from various architectural levels, and they have developed an unobtrusive instrumentation system to efficiently gather event trace data.
References-found: 17

