URL: ftp://ftp.cs.colorado.edu/users/alw/papers/CU-CS-845-97.ps.Z
Refering-URL: http://www.cs.colorado.edu/users/alw/AvailablePubs.html
Root-URL: http://www.cs.colorado.edu
Email: fjudys,alwg@cs.colorado.edu djr@ics.uci.edu  
Title: Chaining: A Software Architecture Dependence Analysis Technique  
Author: Judith A. Stafford Debra J. Richardson and Alexander L. Wolf 
Address: Boulder, CO 80309 USA Irvine, CA 92697 USA  
Affiliation: Department of Computer Science Dept. of Information and Computer Science University of Colorado University of California  
Abstract: University of Colorado Department of Computer Science Technical Report CU-CS-845-97 September, 1997 ABSTRACT The emergence of formal architecture description languages provides an opportunity to perform analyses at high levels of abstraction. Research has primarily focused on developing techniques such as algebraic and transition-system analysis to detect component mismatches or global behavioral incorrectness. In this paper, we describe chaining, a technique similar in concept and application to program slicing, in which the goal is to reduce the portions of an architecture that must be examined by an architect for some purpose, such as testing or debugging. In chaining, links represent the dependence relationships that exist in an architectural specification. Links connect elements of the specification that are directly related, producing a chain of dependencies that can be followed during analysis. We illustrate the utility of chaining by showing how the technique can be used to answer various questions one might pose of a Rapide architecture specification. This work was supported in part by the National Science Foundation under grant CCR-97-10078 and by the Air Force Material Command, Rome Laboratory, and the Defense Advanced Research Projects Agency under Contract Number F30602-94-C-0253. The content of the information does not necessarily reflect the position or the policy of the U.S. Government and no official endorsement should be inferred. c fl 1997 Judith A. Stafford, Debra J. Richardson, and Alexander L. Wolf
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> H. Agrawal, R. A. DeMillo, and E. H. Spafford. </author> <title> An Execution-Backtracking Approach to Debugging. </title> <journal> IEEE Software, </journal> <pages> pages 21-26, </pages> <month> May </month> <year> 1991. </year>
Reference-contexts: Links connect elements of the specification that are directly related, producing a chain of dependencies that can be followed during analysis. The traditional view of dependence analysis is based on control and data flow relationships associated with functions and variables <ref> [1, 4, 5, 12, 15, 16] </ref>. We take a broader view of dependence relationships that is more appropriate to the concerns of architectures and their attention to component interactions.
Reference: [2] <author> R. Allen and D. Garlan. </author> <title> Formalizing Architectural Connection. </title> <booktitle> In Proceedings of the 16th International Conference on Software Engineering, </booktitle> <pages> pages 71-80. </pages> <publisher> IEEE Computer Society, </publisher> <month> May </month> <year> 1994. </year>
Reference-contexts: Formal software architecture description languages allow one to reason about the correctness of software systems at a correspondingly high level of abstraction. Techniques have been developed for architecture analysis that can reveal such problems as potential deadlock and component mismatches <ref> [2, 7, 9, 13] </ref>. In general, there are many kinds of questions one might want to ask at an architectural level for purposes as varied as reuse, reengineering, fault localization, impact analysis, regression testing, and even workspace management. <p> In particular, we look at both the structural and the behavioral relationships among components expressed in current-day formal architecture description languages, such as Rapide [8] and Wright <ref> [2] </ref>. We begin with a brief review of relevant questions that might reasonably be asked at the architectural level as a way to further motivate our investigation of static dependence analysis. We then describe the concept of chaining and the architectural relationships that underlie the concept. <p> Thus, we intend to incorporate more features of the Rapide language, to extend our definition of chaining to other languages (including CHAM [6], C2 [11], Darwin [9], and Wright <ref> [2] </ref>), and to test our approach against more complex architectures. We are interested in investigating heuristics for reducing the conservativeness of chaining through patterns.
Reference: [3] <author> J. Chang and D. J. Richardson. </author> <title> Static and Dynamic Specification Slicing. </title> <booktitle> In Proceedings of the Fourth Irvine Software Symposium, </booktitle> <address> Irvine, CA, </address> <month> April </month> <year> 1994. </year>
Reference-contexts: We agree with the spirit of this work and, in some sense, are pursuing a similar goal, but in the particular context of software architectures. Oda and Araki [14] first introduced the concept of static specification slicing for specifications written in Z. Chang and Richardson <ref> [3] </ref> extend this work with the introduction of techniques for creating dynamic slices.
Reference: [4] <author> J. Cheng. </author> <title> Slicing Concurrent Programs | A Graph-Theoretical Approach. </title> <booktitle> Lecture Notes in Computer Science, Automated and Algorithmic Debugging, </booktitle> <pages> pages 223-240, </pages> <year> 1993. </year>
Reference-contexts: Links connect elements of the specification that are directly related, producing a chain of dependencies that can be followed during analysis. The traditional view of dependence analysis is based on control and data flow relationships associated with functions and variables <ref> [1, 4, 5, 12, 15, 16] </ref>. We take a broader view of dependence relationships that is more appropriate to the concerns of architectures and their attention to component interactions.
Reference: [5] <author> S. Horwitz, T. Reps, and D. Binkley. </author> <title> Interprocedural Slicing Using Dependence Graphs. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 22(1) </volume> <pages> 26-60, </pages> <month> January </month> <year> 1990. </year>
Reference-contexts: Links connect elements of the specification that are directly related, producing a chain of dependencies that can be followed during analysis. The traditional view of dependence analysis is based on control and data flow relationships associated with functions and variables <ref> [1, 4, 5, 12, 15, 16] </ref>. We take a broader view of dependence relationships that is more appropriate to the concerns of architectures and their attention to component interactions.
Reference: [6] <author> P. Inverardi and A.L. Wolf. </author> <title> Formal Specification and Analysis of Software Architectures using the Chemical Abstract Machine Model. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 21(4) </volume> <pages> 373-386, </pages> <month> April </month> <year> 1995. </year>
Reference-contexts: The particular kinds of dependencies and chains that can be established among components are heavily influenced by the primitive features of the architecture description language. For instance, in CHAM <ref> [6] </ref> and Wright, only behavioral relationships are modeled, and those relationships are based on synchronous input and output ports 1 through which data flow. Darwin [9] and Rapide specifications can involve both structural and behavioral relationships. The structural relationships in these languages derive from concepts of import, export, and inheritance. <p> Thus, we intend to incorporate more features of the Rapide language, to extend our definition of chaining to other languages (including CHAM <ref> [6] </ref>, C2 [11], Darwin [9], and Wright [2]), and to test our approach against more complex architectures. We are interested in investigating heuristics for reducing the conservativeness of chaining through patterns.
Reference: [7] <author> P. Inverardi, A.L. Wolf, and D. Yankelevich. </author> <title> Checking Assumptions in Component Dynamics at the Architectural Level. </title> <booktitle> In Proceedings of the Second International Conference on Coordination Models and Languages. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1997. </year> <note> To appear. </note>
Reference-contexts: Formal software architecture description languages allow one to reason about the correctness of software systems at a correspondingly high level of abstraction. Techniques have been developed for architecture analysis that can reveal such problems as potential deadlock and component mismatches <ref> [2, 7, 9, 13] </ref>. In general, there are many kinds of questions one might want to ask at an architectural level for purposes as varied as reuse, reengineering, fault localization, impact analysis, regression testing, and even workspace management.
Reference: [8] <author> D.C. Luckham, J.J. Kenney, L.M. Augustin, J. Vera, D. Bryan, and W. Mann. </author> <title> Specification and Analysis of System Architecture Using Rapide. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 21(4) </volume> <pages> 336-355, </pages> <month> April </month> <year> 1995. </year>
Reference-contexts: We take a broader view of dependence relationships that is more appropriate to the concerns of architectures and their attention to component interactions. In particular, we look at both the structural and the behavioral relationships among components expressed in current-day formal architecture description languages, such as Rapide <ref> [8] </ref> and Wright [2]. We begin with a brief review of relevant questions that might reasonably be asked at the architectural level as a way to further motivate our investigation of static dependence analysis. We then describe the concept of chaining and the architectural relationships that underlie the concept.
Reference: [9] <author> J. Magee, N. Dulay, S. Eisenbach, and J. Kramer. </author> <title> Distributed Software Architectures. </title> <booktitle> In Proceedings of the Fifth European Software Engineering Conference, number 989 in Lecture Notes in Computer Science, </booktitle> <pages> pages 137-153. </pages> <publisher> Springer-Verlag, </publisher> <month> September </month> <year> 1995. </year>
Reference-contexts: Formal software architecture description languages allow one to reason about the correctness of software systems at a correspondingly high level of abstraction. Techniques have been developed for architecture analysis that can reveal such problems as potential deadlock and component mismatches <ref> [2, 7, 9, 13] </ref>. In general, there are many kinds of questions one might want to ask at an architectural level for purposes as varied as reuse, reengineering, fault localization, impact analysis, regression testing, and even workspace management. <p> For instance, in CHAM [6] and Wright, only behavioral relationships are modeled, and those relationships are based on synchronous input and output ports 1 through which data flow. Darwin <ref> [9] </ref> and Rapide specifications can involve both structural and behavioral relationships. The structural relationships in these languages derive from concepts of import, export, and inheritance. <p> Thus, we intend to incorporate more features of the Rapide language, to extend our definition of chaining to other languages (including CHAM [6], C2 [11], Darwin <ref> [9] </ref>, and Wright [2]), and to test our approach against more complex architectures. We are interested in investigating heuristics for reducing the conservativeness of chaining through patterns.
Reference: [10] <author> W. Mann, F. C. Belz, and P. Corneil. </author> <title> A Rapide-1.0 Definition of the ADAGE Avionics System. </title> <type> Technical Report CSL-TR-93-585, </type> <institution> Stanford University, </institution> <year> 1993. </year>
Reference-contexts: We develop a matrix representation for architectures and apply a straightforward algorithm to the matrix in order to discover chains of related component elements. We have used chaining to discover an intentionally introduced fault in the ADAGE avionics architecture, which is written in Rapide <ref> [10] </ref>. The ADAGE example is a two-level nested architecture consisting of an outer-level architecture plus four sub-architectures. The four sub-architectures together contain 30 components communicating through nearly 100 ports. It is, therefore, too large to be presented here.
Reference: [11] <author> N. Medvidovic, R. N. Taylor, and Jr. E. J. Whitehead. </author> <title> Formal Modeling of Software Architectures at Multiple Levels of Abstraction. </title> <booktitle> In Proceedings of the California Software Symposium 1996, </booktitle> <pages> pages 28-40, </pages> <address> Los Angeles, CA, </address> <month> April </month> <year> 1996. </year>
Reference-contexts: Thus, we intend to incorporate more features of the Rapide language, to extend our definition of chaining to other languages (including CHAM [6], C2 <ref> [11] </ref>, Darwin [9], and Wright [2]), and to test our approach against more complex architectures. We are interested in investigating heuristics for reducing the conservativeness of chaining through patterns.
Reference: [12] <author> C.T. Moore, </author> <note> T.O. O'Malley, D.J. </note> <author> Richardson, S.H.L. Aha, and D.A. Brodbeck. ProDAG: </author> <title> A Program Dependence Graph System. </title> <type> Technical report, </type> <institution> Department of Information and Computer Science, University of California at Irvine, </institution> <year> 1990. </year>
Reference-contexts: Links connect elements of the specification that are directly related, producing a chain of dependencies that can be followed during analysis. The traditional view of dependence analysis is based on control and data flow relationships associated with functions and variables <ref> [1, 4, 5, 12, 15, 16] </ref>. We take a broader view of dependence relationships that is more appropriate to the concerns of architectures and their attention to component interactions.
Reference: [13] <author> G. Naumovich, G.S. Avrunin, L.A. Clarke, and L.J. Osterweil. </author> <title> Applying Static Analysis to Software Architectures. </title> <booktitle> In Proceedings of the Sixth European Software Engineering Conference. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1997. </year> <note> To appear. </note>
Reference-contexts: Formal software architecture description languages allow one to reason about the correctness of software systems at a correspondingly high level of abstraction. Techniques have been developed for architecture analysis that can reveal such problems as potential deadlock and component mismatches <ref> [2, 7, 9, 13] </ref>. In general, there are many kinds of questions one might want to ask at an architectural level for purposes as varied as reuse, reengineering, fault localization, impact analysis, regression testing, and even workspace management. <p> This is similar to our recognition that there are new types of dependence relationships to consider in analyzing architecture descriptions. However, they restrict slicing to the statement level, using the limited criteria of variable and method call return values. 12 Naumovich et al. <ref> [13] </ref> apply INCA and FLAVERS, two static concurrency analysis tools used for proving behavioral properties of concurrent programs, to an Ada translation of the Wright description of the gas station problem.
Reference: [14] <author> T. Oda and K. Araki. </author> <title> Specification Slicing in Formal Methods of Software Development. </title> <booktitle> In Proceedings of the Seventeenth Annual International Computer Software and Applications Conference, </booktitle> <pages> pages 313-319. </pages> <publisher> IEEE Computer Society Press, </publisher> <month> November </month> <year> 1993. </year>
Reference-contexts: They demonstrate this by describing several tools that could be built to aid in the understanding of formal compiler specifications. We agree with the spirit of this work and, in some sense, are pursuing a similar goal, but in the particular context of software architectures. Oda and Araki <ref> [14] </ref> first introduced the concept of static specification slicing for specifications written in Z. Chang and Richardson [3] extend this work with the introduction of techniques for creating dynamic slices.
Reference: [15] <author> H. Pande, W. Landi, and B. Ryder. </author> <title> Interprocedural Def-Use Associations for C Systems with Single Level Pointers. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 20(5) </volume> <pages> 385-403, </pages> <month> May </month> <year> 1994. </year>
Reference-contexts: Links connect elements of the specification that are directly related, producing a chain of dependencies that can be followed during analysis. The traditional view of dependence analysis is based on control and data flow relationships associated with functions and variables <ref> [1, 4, 5, 12, 15, 16] </ref>. We take a broader view of dependence relationships that is more appropriate to the concerns of architectures and their attention to component interactions.
Reference: [16] <author> A. Podgurski and L.A. Clarke. </author> <title> A Formal Model of Program Dependencies and its Implications for Software Testing, Debugging, and Maintenance. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 16(9) </volume> <pages> 965-979, </pages> <month> September </month> <year> 1990. </year> <month> 15 </month>
Reference-contexts: Links connect elements of the specification that are directly related, producing a chain of dependencies that can be followed during analysis. The traditional view of dependence analysis is based on control and data flow relationships associated with functions and variables <ref> [1, 4, 5, 12, 15, 16] </ref>. We take a broader view of dependence relationships that is more appropriate to the concerns of architectures and their attention to component interactions. <p> Our approach applies this concept to architecture description languages and combines the information with behavioral dependencies. ProDAG [18] is a program dependence analysis toolset that performs statement-level dependence analysis. ProDAG allows one to create and access various predefined relationships originally identified by Podgurski and Clarke <ref> [16] </ref>. The technique of chaining raises these ideas to the architectural level, as well as incorporating the notion of structural dependence. Sloane and Holdsworth [19] suggest advanced applications for Weiser's concept of program slicing [22], in which the basis for analysis includes aspects other than traditional data and control flow.
Reference: [17] <author> D.J. Richardson. TAOS: </author> <title> Testing with Analysis and Oracle Support. </title> <booktitle> In Proceedings of the 1994 Inter--national Symposium on Software Testing and Analysis (ISSTA '94), </booktitle> <pages> pages 138-153. </pages> <booktitle> ACM SIGSOFT, </booktitle> <month> August </month> <year> 1994. </year>
Reference-contexts: Historically, testing has concentrated on the implementation of the system, which has meant that it is considered fairly late in the development process. Eventually, we intend to incorporate chaining into a complete life cycle software analysis and testing environment, such as the TAOS environment <ref> [17] </ref>. TAOS includes dependence analysis and testing at the implementation level, but also has support for using specifications in the testing process for test generation and result checking. Integrating architecuture analysis techniques, such as chaining and related techniques, would round out the life cycle support for analysis and testing.
Reference: [18] <author> D.J. Richardson, </author> <title> T.O. O'Malley, C.T. Moore, and S.L. Aha. Developing and Integrating ProDAG in the Arcadia Environment. </title> <booktitle> In SIGSOFT '92: Proceedings of the Fifth Symposium on Software Development Environments, </booktitle> <pages> pages 109-119. </pages> <booktitle> ACM SIGSOFT, </booktitle> <month> December </month> <year> 1992. </year>
Reference-contexts: An example is the tool makedepend, which examines code to automatically derive the file dependencies (e.g., #include in the C environment) used in Make files. Our approach applies this concept to architecture description languages and combines the information with behavioral dependencies. ProDAG <ref> [18] </ref> is a program dependence analysis toolset that performs statement-level dependence analysis. ProDAG allows one to create and access various predefined relationships originally identified by Podgurski and Clarke [16]. The technique of chaining raises these ideas to the architectural level, as well as incorporating the notion of structural dependence.
Reference: [19] <author> A.M. Sloane and J. Holdsworth. </author> <title> Beyond Traditional Program Slicing. </title> <booktitle> In Proceedings of the 1996 International Symposium on Software Testing and Analysis (ISSTA '96), </booktitle> <pages> pages 180-186. </pages> <booktitle> ACM SIGSOFT, </booktitle> <month> January </month> <year> 1996. </year>
Reference-contexts: The idea of collecting together related portions of a system, in an effort to reduce the amount of information that must be examined for some purpose, recalls the notion of program slicing introduced by Weiser [22]. Sloane and Holdsworth <ref> [19] </ref> suggest generalizing the concept of program slicing and show the potential in slicing non-imperative programs. Our notion of chaining is intended to support a range of analysis applications, including what would amount to an architectural slice. <p> ProDAG allows one to create and access various predefined relationships originally identified by Podgurski and Clarke [16]. The technique of chaining raises these ideas to the architectural level, as well as incorporating the notion of structural dependence. Sloane and Holdsworth <ref> [19] </ref> suggest advanced applications for Weiser's concept of program slicing [22], in which the basis for analysis includes aspects other than traditional data and control flow. They describe a generalized slicing tool that treats slicing as tree-marking manipulations of program syntax trees.
Reference: [20] <author> RAPIDE Design Team. </author> <title> Draft: Guide to the Rapide 1.0 Language Reference Manuals. </title> <month> July </month> <year> 1997. </year>
Reference-contexts: A full description of the language is available in the Rapide Language Manuals <ref> [20] </ref>. The architecture description for the gas station is provided in the July 1997 release of the Rapide Toolset. There are seven versions of the example included in the release. We are using the second version.
Reference: [21] <author> RAPIDE Design Team. </author> <title> Draft: Rapide 1.0 Pattern Language Reference Manual. </title> <month> July </month> <year> 1997. </year>
Reference-contexts: For our purposes, we are interested in the behavioral view that is provided at the architecture level. Computations are defined in a pattern language <ref> [21] </ref>. Patterns are sets of events together with their partial ordering. The representation for the partial orders are called posets. Posets can be used to evaluate the correctness of the architecture. Rapide uses four symbols to represent connections in connection rules.
Reference: [22] <author> M. Weiser. </author> <title> Program Slicing. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 10(4) </volume> <pages> 352-357, </pages> <month> July </month> <year> 1984. </year>
Reference-contexts: The idea of collecting together related portions of a system, in an effort to reduce the amount of information that must be examined for some purpose, recalls the notion of program slicing introduced by Weiser <ref> [22] </ref>. Sloane and Holdsworth [19] suggest generalizing the concept of program slicing and show the potential in slicing non-imperative programs. Our notion of chaining is intended to support a range of analysis applications, including what would amount to an architectural slice. <p> The technique of chaining raises these ideas to the architectural level, as well as incorporating the notion of structural dependence. Sloane and Holdsworth [19] suggest advanced applications for Weiser's concept of program slicing <ref> [22] </ref>, in which the basis for analysis includes aspects other than traditional data and control flow. They describe a generalized slicing tool that treats slicing as tree-marking manipulations of program syntax trees. Their concept of syntactically based generalized slicing allows them to contemplate the slicing of non-imperative programs.
Reference: [23] <author> J. Zhao, J. Cheng, and K. Ushijima. </author> <title> Static Slicing of Concurrent Object-Oriented Programs. </title> <booktitle> In IEEE-CS 20th Annual International Computer Software and Applications Conference, </booktitle> <pages> pages 312-320, </pages> <year> 1996. </year> <month> 16 </month>
Reference-contexts: In both of these efforts, the value of a variable in a particular predicate is used as the slicing criteria, whereas we are exploring relationships at the architectural level, where the concept of a variable does not exist. Zhao, Cheng, and Ushijima <ref> [23] </ref> propose the system dependence net (SDN) as a representation of concurrent object-oriented programs. The SDN is used to find slices of CC++ (Concurrent C++) programs, using the value of a variable or return value of a method call at a particular statement as the slicing criteria.
References-found: 23

