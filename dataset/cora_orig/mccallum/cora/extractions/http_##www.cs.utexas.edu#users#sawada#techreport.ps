URL: http://www.cs.utexas.edu/users/sawada/techreport.ps
Refering-URL: http://www.cs.utexas.edu/users/sawada/
Root-URL: 
Email: email: sawada@cs.utexas.edu  
Title: Formal Verification of Pipelined Machines with Out-of-order Execution  
Author: Jun Sawada 
Affiliation: University of Texas at Austin, Computer Science Dept.  
Abstract: This paper discusses the technical details of the design verification of a pipelined processor with out-of-order execution. We have developed new techniques to verify pipelined processors with complex control logic. Our principal technique is modeling the stream of instructions using a table representation, which allows us to directly express many machine-relevant properties. Using this representation, we have verified pipeline properties incrementally, and eventually verified a complete pipelined machine design, whose correctness is defined using the idea of pipeline flushing. The proof has been mechanically checked by ACL2 theorem prover.
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> R. S. Boyer and J S. Moore. </author> <title> A Computational Logic Handbook. </title> <publisher> Academic 15 Press, </publisher> <address> Boston, </address> <year> 1988. </year>
Reference-contexts: The behavioral description of the sequential and pipelined machines are given by executable ACL2 functions. ACL2 [13] is both an executable specification language and a theorem-proving system, and it can be considered a "next generation" Boyer-Moore theorem prover <ref> [1] </ref>. The ACL2 logic is a subset of Common Lisp. In the body of this paper, we do not use the Common Lisp style syntax, although the appendices include real definitions and theorems in ACL2. We define p-step () as the state transition function for the pipelined machine.
Reference: [2] <author> B. Brock, W. A. Hunt, Jr., M Kaufmann, </author> <title> The FM9001 Microprocessor Proof. </title> <type> Technical Report 86, </type> <institution> Computational Logic, </institution> <month> December, </month> <year> 1994. </year>
Reference-contexts: 1 Introduction Since the principles of formal hardware verification were established in the 80's [4, 8, 10], there have been many attempts to apply these techniques to larger and larger examples <ref> [2, 9] </ref>. Although some measure of success has been achieved, formal hardware verification is not yet widely applied to general-purpose microprocessor design.
Reference: [3] <author> J. R. Burch, D. L. Dill: </author> <title> Automatic Verification of Pipelined Microprocessor Control, </title> <editor> In D. Dill Editor, </editor> <booktitle> Computer Aided Verification, Lecture Notes in Computer Science 818, </booktitle> <publisher> Springer Verlag, </publisher> <year> 1994, </year> <pages> page 68-80. </pages>
Reference-contexts: Instead, we have to find an alternative method to represent the correctness which is applicable to the pipelined machines in general. 4 A more general approach for comparing a pipelined design with a sequential specification was proposed by Burch and Dill <ref> [3] </ref>. Figure 3 shows the basic idea of such a comparison. We map a pipelined machine state to a sequential machine state by flushing instructions out of the pipeline without fetching any new instructions, and then projecting the synchronized pipeline state to a sequential machine state.
Reference: [4] <author> A. Cohn., </author> <title> A Proof of the VIPER Microprocessor: The First Level; In: </title> <editor> G. Birtwistle and P. A. Subrahmanyam Editors, </editor> <title> VLSI Specification, Verification and Synthesis, </title> <publisher> page 27-72 Kluwer Academic Publishers, </publisher> <address> Boston, MA, </address> <year> 1988. </year>
Reference-contexts: 1 Introduction Since the principles of formal hardware verification were established in the 80's <ref> [4, 8, 10] </ref>, there have been many attempts to apply these techniques to larger and larger examples [2, 9]. Although some measure of success has been achieved, formal hardware verification is not yet widely applied to general-purpose microprocessor design.
Reference: [5] <author> H. G. Cragon, </author> <title> Memory Systems and Pipelined Processors, </title> <publisher> Jones and Bartlett Publishers, Inc., </publisher> <year> 1996. </year>
Reference-contexts: A serious impediment to applying such techniques is the failure of current proof approaches to address the verification of today's processors which adopt radical performance optimizations, including superscalar super-pipelining, out-of-order execution, and speculative execution <ref> [5, 7, 11] </ref>. Pipelining is a key feature of today's microprocessor designs. There have been several earlier successes to formally verify pipelined machines [6, 14, 15, 16]; however, these machines have a short and simple pipeline structure.
Reference: [6] <author> D. Cyrluk. </author> <title> Microprocessor verification in PVS: A methodology and simple example, </title> <type> Technical Report SRI-CSL-93-12, </type> <institution> SRI Computer Science Laboratory, </institution> <month> Dec. </month> <year> 1993 </year>
Reference-contexts: Pipelining is a key feature of today's microprocessor designs. There have been several earlier successes to formally verify pipelined machines <ref> [6, 14, 15, 16] </ref>; however, these machines have a short and simple pipeline structure. The lack of complex control logic, which is one of the hardest parts to verify, is something our approach addresses. <p> However, a simple time abstraction cannot relate sequential and pipelined machines, as we typically do not have a pipelined machine state that we can directly compare to the sequential specification state. Some earlier pipeline verification research <ref> [6, 15] </ref> used abstraction mappings combining different machine components at different times. For instance, an abstraction mapping of a pipelined machine may combine the program counter at time t and the register file and the memory at time t + 2 to form the corresponding specification state.
Reference: [7] <author> J. Hennessey, D. Patterson, </author> <title> Computer Architecture a Quantitative Approach, </title> <publisher> Morgan Kaufmann Publishers, Inc., </publisher> <year> 1996. </year>
Reference-contexts: A serious impediment to applying such techniques is the failure of current proof approaches to address the verification of today's processors which adopt radical performance optimizations, including superscalar super-pipelining, out-of-order execution, and speculative execution <ref> [5, 7, 11] </ref>. Pipelining is a key feature of today's microprocessor designs. There have been several earlier successes to formally verify pipelined machines [6, 14, 15, 16]; however, these machines have a short and simple pipeline structure. <p> First, the instruction-fetch unit reads the instruction from the memory and sends it to the decode unit. Then the issuing logic dispatches the decoded instruction to the appropriate execution unit. Our design can issue one instruction per clock cycle, and the issue is in-order. The issuing logic checks RAW-dependencies <ref> [7] </ref> between the issued instruction and instructions issued earlier. If there is such an RAW-dependency, the issue is suspended until the appropriate data is ready. Bypassing logic helps to reduce the number of stall cycles. It also checks WAW-dependencies between instructions.
Reference: [8] <author> W. A. Hunt, Jr.: </author> <title> Microprocessor Design Verification; Journal of Automated Reasoning, </title> <type> 5(4), </type> <month> December </month> <year> 1989, </year> <pages> page 429-460. </pages>
Reference-contexts: 1 Introduction Since the principles of formal hardware verification were established in the 80's <ref> [4, 8, 10] </ref>, there have been many attempts to apply these techniques to larger and larger examples [2, 9]. Although some measure of success has been achieved, formal hardware verification is not yet widely applied to general-purpose microprocessor design.
Reference: [9] <author> W. A. Hunt, Jr., B. Brock, </author> <title> A Formal HDL and Its Use in the FM9001 Verification. In C.A.R. </title> <editor> Hoare and M.J.C. Gordon, editors, </editor> <title> Mechanized Reasoning and Hardware Design, page 35-48. </title> <booktitle> Prentice-Hall International Series in Computer Science, </booktitle> <address> Engle wood Cliffs, N.J., </address> <year> 1992 </year>
Reference-contexts: 1 Introduction Since the principles of formal hardware verification were established in the 80's [4, 8, 10], there have been many attempts to apply these techniques to larger and larger examples <ref> [2, 9] </ref>. Although some measure of success has been achieved, formal hardware verification is not yet widely applied to general-purpose microprocessor design.
Reference: [10] <author> W. A. Hunt, Jr., FM8501: </author> <title> A Verified Microprocessor. </title> <booktitle> Lecture Notes in Computer Science 795, </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1994. </year>
Reference-contexts: 1 Introduction Since the principles of formal hardware verification were established in the 80's <ref> [4, 8, 10] </ref>, there have been many attempts to apply these techniques to larger and larger examples [2, 9]. Although some measure of success has been achieved, formal hardware verification is not yet widely applied to general-purpose microprocessor design.
Reference: [11] <author> M. Johnson, </author> <title> Superscalar Microprocessor Design, </title> <publisher> Prentice Hall, </publisher> <address> Englewood Cliffs, NJ, </address> <year> 1991. </year>
Reference-contexts: A serious impediment to applying such techniques is the failure of current proof approaches to address the verification of today's processors which adopt radical performance optimizations, including superscalar super-pipelining, out-of-order execution, and speculative execution <ref> [5, 7, 11] </ref>. Pipelining is a key feature of today's microprocessor designs. There have been several earlier successes to formally verify pipelined machines [6, 14, 15, 16]; however, these machines have a short and simple pipeline structure.
Reference: [12] <author> R. B. Jones, D. L. Dill, J. R. Burch, </author> <title> Efficient Validity Checking for Processor Verification, </title> <booktitle> 1995 IEEE/ACM International Conference on Computer-Aided Design, </booktitle> <pages> pages 2-6. </pages>
Reference-contexts: Because the pipeline correctness diagram involves flushing which takes many machine cycles, slight increase in complexity of the pipeline causes an explosion in the number of examined cases. We can improve the efficiency of the verification process using heuristics and other techniques <ref> [12] </ref>, but it does not solve the problem of case explosion. It is our belief that a naive application of the symbolic execution method cannot verify a pipelined machine with complex pipeline-control logic with an acceptable computational cost.
Reference: [13] <author> M. Kaufmann, J S. Moore, ACL2: </author> <title> An Industrial Strength Version of Nqthm, </title> <booktitle> Proceedings of the Eleventh Annual Conference on Computer Assurance (COMPASS-96), </booktitle> <publisher> pages 23-34 , IEEE Computer Society Press, </publisher> <month> June </month> <year> 1996. </year>
Reference-contexts: Since a non-pipelined machine completes an instruction 3 before starting another, it is easier to specify the effect of a single instruction with a sequential machine model than with a pipelined machine. The behavioral description of the sequential and pipelined machines are given by executable ACL2 functions. ACL2 <ref> [13] </ref> is both an executable specification language and a theorem-proving system, and it can be considered a "next generation" Boyer-Moore theorem prover [1]. The ACL2 logic is a subset of Common Lisp.
Reference: [14] <author> M. Srivas, M. Bickford, </author> <title> Formal Verification of a Pipelined Microprocessor, </title> <journal> IEEE Software, </journal> <month> September </month> <year> 1990, </year> <pages> page 52-64. 16 </pages>
Reference-contexts: Pipelining is a key feature of today's microprocessor designs. There have been several earlier successes to formally verify pipelined machines <ref> [6, 14, 15, 16] </ref>; however, these machines have a short and simple pipeline structure. The lack of complex control logic, which is one of the hardest parts to verify, is something our approach addresses.
Reference: [15] <author> M. K. Srivas, S. P. Miller, </author> <title> Formal Verification of a Commercial Microproces--sor, </title> <type> Technical Report SRI-CSL-95-12, </type> <institution> SRI Computer Science Laboratory, </institution> <month> July </month> <year> 1995. </year>
Reference-contexts: Pipelining is a key feature of today's microprocessor designs. There have been several earlier successes to formally verify pipelined machines <ref> [6, 14, 15, 16] </ref>; however, these machines have a short and simple pipeline structure. The lack of complex control logic, which is one of the hardest parts to verify, is something our approach addresses. <p> However, a simple time abstraction cannot relate sequential and pipelined machines, as we typically do not have a pipelined machine state that we can directly compare to the sequential specification state. Some earlier pipeline verification research <ref> [6, 15] </ref> used abstraction mappings combining different machine components at different times. For instance, an abstraction mapping of a pipelined machine may combine the program counter at time t and the register file and the memory at time t + 2 to form the corresponding specification state.
Reference: [16] <author> S. Tahar, R. Kumar, </author> <title> Formal Verification of Pipeline Conflicts in RISC Processors, </title> <booktitle> Proc. European Design Automation Conference (EURO-DAC94), </booktitle> <address> Grenoble, France, September 1994, </address> <publisher> IEEE Computer Society Press. </publisher> <pages> page 285-289. </pages>
Reference-contexts: Pipelining is a key feature of today's microprocessor designs. There have been several earlier successes to formally verify pipelined machines <ref> [6, 14, 15, 16] </ref>; however, these machines have a short and simple pipeline structure. The lack of complex control logic, which is one of the hardest parts to verify, is something our approach addresses.
References-found: 16

