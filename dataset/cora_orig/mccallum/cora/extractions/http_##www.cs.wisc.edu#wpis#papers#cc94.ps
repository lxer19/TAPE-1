URL: http://www.cs.wisc.edu/wpis/papers/cc94.ps
Refering-URL: http://www.cs.wisc.edu/~reps/
Root-URL: 
Title: Solving Demand Versions of Interprocedural Analysis Problems  
Author: Thomas Reps 
Address: Universitetsparken 1 DK-2100 Copenhagen East Denmark  
Affiliation: Datalogisk Institut, University of Copenhagen  
Abstract: This paper concerns the solution of demand versions of interprocedural analysis problems. In a demand version of a program-analysis problem, some piece of summary information (e.g., the dataow facts holding at a given point) is to be reported only for a single program element of interest (or a small number of elements of interest). Because the summary information at one program point typically depends on summary information from other points, an important issue is to minimize the number of other points for which (transient) summary information is computed and/or the amount of information computed at those points. The paper describes how algorithms for demand versions of program-analysis problems can be obtained from their exhaustive counterparts essentially for free, by applying the so-called magic-sets transformation that was developed in the logic-programming and deductive-database communities. 
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> Allen, </author> <title> F.E., Interprocedural data ow analysis, pp. </title> <booktitle> 398-408 in Information Processing 74: Proceedings of the IFIP Congress 74, </booktitle> <editor> ed. J.L. Rosenfield, </editor> <publisher> North-Holland, </publisher> <address> Amsterdam (1974). </address>
Reference: 2. <author> Babich, W.A. and Jazayeri, M., </author> <title> The method of attributes for data ow analysis: Part II. Demand analysis, </title> <note> Acta Informatica 10(3) pp. </note> <month> 265-272 (October </month> <year> 1978). </year>
Reference: 3. <author> Bancilhon, F., Maier, D., Sagiv, Y., and Ullman, J., </author> <title> Magic sets and other strange ways to implement logic programs, </title> <booktitle> in Proceedings of the Fifth ACM Symposium on Principles of Database Systems, </booktitle> <year> (1986). </year>
Reference-contexts: The presence of this rule will cause magic facts other than the original one to be generated during evaluation. Note that the members of relation magic_same_generation_bf will be exactly the ancestors of a (the so-called cone of a <ref> [3] </ref>). During bottom-up evaluation of the transformed rules, the effect of the magic_same_generation_bf predicate is that attention is restricted to just same-generation cousins of ancestors of a. End of Example.
Reference: 4. <author> Bancilhon, F. and Ramakrishnan, R., </author> <title> Performance evaluation of data intensive logic programs, p p. 439-517 in Foundations of Deductive Databases and Logic Programming, </title> <editor> ed. J. Minker, </editor> <publisher> Morgan-Kaufmann (1988). </publisher>
Reference-contexts: Note that in a bottom-up evaluation, the transformed program (the demand algorithm) will never perform more work than the untransformed program (the exhaustive algorithm) wouldmodulo a small amount of overhead for computing magic facts, which are reported to be only a small fraction of the generated facts <ref> [4] </ref>. In practice, the demand algorithm usually performs far less work than the exhaustive algorithm.
Reference: 5. <author> Banning, J.P., </author> <title> An efficient way to find the side effects of procedure calls and the aliases of variables, pp. </title> <booktitle> 29-41 in Conference Record of the Sixth ACM Symposium on Principles of Programming Languages, </booktitle> <address> (San Antonio, TX, </address> <month> Jan. </month> <pages> 29-31, </pages> <address> 1979), </address> <publisher> ACM, </publisher> <address> New York, NY (1979). </address>
Reference: 6. <author> Barth, J.M., </author> <title> A practical interprocedural data ow analysis algorithm, </title> <journal> Commun. of the ACM 21(9) pp. </journal> <month> 724-736 (September </month> <year> 1978). </year>
Reference: 7. <author> Beeri, C. and Ramakrishnan, R., </author> <title> On the power of magic, pp. </title> <booktitle> 269-293 in Proceedings of the Sixth ACM Symposium on Principles of Database Systems, </booktitle> <address> (San Diego, CA, </address> <month> March </month> <year> 1987), (1987). </year>
Reference-contexts: For a giv en sip, any evaluator that uses the same sip must generate at least as many facts as are generated during a bottom-up evaluation of the magic-sets-transformed version <ref> [7] </ref>. In our context, this result relates to the question of minimizing the number of program points for which transient dataow-analysis information is computed and/or the amount of information computed at those points when a given demand is placed for dataow information.
Reference: 8. <author> Callahan, D., </author> <title> The program summary graph and ow-sensitive interprocedural data ow a nalysis, </title> <booktitle> Proceedings of the ACM SIGPLAN 88 Conference on Programming Language Design and Implementation, </booktitle> <address> (Atlanta, GA, </address> <month> June 22-24, </month> <year> 1988), </year> <journal> ACM SIGPLAN Notices 23(7) pp. </journal> <month> 47-56 (July </month> <year> 1988). </year>
Reference: 9. <author> Callahan, D., Carle, A., Hall, M.W., and Kennedy, K., </author> <title> Constructing the procedure call multigraph, </title> <journal> IEEE Transactions on Software Engineering SE-16(4) pp. </journal> <month> 483-487 (April </month> <year> 1990). </year>
Reference-contexts: Finally, G. Rosay and the author have been able to develop a method for constructing call multigraphs in the presence of procedure-valued variables that is compatible with the dataow-analysis method described in the paper; this work combines and extends the methods described by Lakhotia [16] and Calla-han et al. <ref> [9] </ref>. (Because of space limitations, it is not possible to discuss these issues in more detail.) In the logic programs given in the paper, we follow the standard naming convention used in Prolog: identifiers that begin with lower-case letters denote ground atoms; those that begin with upper-case letters denote variables.
Reference: 10. <author> Cooper, K.D. and Kennedy, K., </author> <title> Interprocedural side-effect analysis in linear time, </title> <booktitle> Proceedings of the ACM SIGPLAN 88 Conference on Programming Language Design and Implementation, </booktitle> <address> (Atlanta, GA, </address> <month> June 22-24, </month> <year> 1988), </year> <journal> ACM SIGPLAN Notices 23(7) pp. </journal> <month> 57-66 (July </month> <year> 1988). </year>
Reference: 11. <author> Cooper, K.D. and Kennedy, K., </author> <title> Fast interprocedural alias analysis, pp. </title> <booktitle> 49-59 in Conference Record of the Sixteenth ACM Symposium on Principles of Programming Languages, </booktitle> <address> (Austin, TX, </address> <month> Jan. </month> <pages> 11-13, </pages> <address> 1989), </address> <publisher> ACM, </publisher> <address> New York, NY (1989). </address>
Reference: 12. <author> Duesterwald, E., Gupta, R., and Soffa, </author> <title> M.L., Demand-driven program analysis, </title> <type> Technical Report TR-93-15, </type> <institution> Department of Computer Science, University of Pittsburgh, </institution> <address> Pittsburgh, PA (October 1993). </address>
Reference-contexts: A recent paper by Duesterwald, Gupta, and Soffa discusses a very different approach to obtaining demand versions of (intraprocedural) dataow analysis algorithms <ref> [12] </ref>. For each query of the form Is fact f in the solution set at vertex v?, a set of dataow equations are set up on the ow graph (but as if all edges were reversed).
Reference: 13. <author> Horwitz, S. and Teitelbaum, T., </author> <title> Generating editing environments based on relations and attributes, </title> <journal> ACM Trans. Program. Lang. Syst. </journal> <pages> 8(4) pp. </pages> <month> 577-608 (October </month> <year> 1986). </year>
Reference: 14. <author> Horwitz, S., Reps, T., and Binkley, D., </author> <title> Interprocedural slicing using dependence graphs, </title> <journal> ACM Trans. Program. Lang. Syst. </journal> <pages> 12(1) pp. </pages> <month> 26-60 (January </month> <year> 1990). </year>
Reference: 15. <author> Knoop, J. and Steffen, B., </author> <title> The interprocedural coincidence theorem, pp. </title> <booktitle> 125-140 in Proceedings of the Fourth International Conference on Compiler Construction, (Paderborn, </booktitle> <address> FRG, </address> <month> October 5-7, </month> <year> 1992), </year> <booktitle> Lecture Notes in Computer Science, </booktitle> <volume> Vol. 641, </volume> <editor> ed. U. Kastens and P. Pfahler, </editor> <publisher> Springer-Verlag, </publisher> <address> New York, NY (1992). </address>
Reference-contexts: A few words about each is in order: Simplifications (i) and (ii) prevent the Sharir-Pnueli framework from being able to handle local variables and formal parameters of procedures in the presence of recursion; however, Knoop and Steffen have presented a generalization of the Sharir-Pnueli framework that lifts this restriction <ref> [15] </ref>. It is possible to generalize the approach described in Section 4 to implement the more general Knoop-Steffen framework.
Reference: 16. <author> Lakhotia, A., </author> <title> Constructing call multigraphs using dependence graphs, pp. </title> <booktitle> 273-284 in Conference Record of the Twentieth ACM Symposium on Principles of Programming Languages,(Charleston, </booktitle> <address> SC, </address> <month> Jan. </month> <pages> 11-13, </pages> <address> 1993), </address> <publisher> ACM, </publisher> <address> New York, NY (1993). </address>
Reference-contexts: Finally, G. Rosay and the author have been able to develop a method for constructing call multigraphs in the presence of procedure-valued variables that is compatible with the dataow-analysis method described in the paper; this work combines and extends the methods described by Lakhotia <ref> [16] </ref> and Calla-han et al. [9]. (Because of space limitations, it is not possible to discuss these issues in more detail.) In the logic programs given in the paper, we follow the standard naming convention used in Prolog: identifiers that begin with lower-case letters denote ground atoms; those that begin with
Reference: 17. <author> Landi, W. and Ryder, B .G., </author> <title> Pointer-induced aliasing: A problem classification, pp. </title> <booktitle> 93-103 in Conference Record of the Eighteenth ACM Symposium on Principles of Programming Languages, </booktitle> <address> (Orlando, FL, </address> <month> January </month> <year> 1991), </year> <booktitle> ACM, </booktitle> <address> New York, NY (1991). </address>
Reference: 18. <author> Linton, M.A., </author> <title> Implementing relational views of programs, </title> <booktitle> Proceedings of the ACM SIG-SOFT/SIGPLAN Software Engineering Symposium on Practical Software Development Environments, </booktitle> <address> (Pittsburgh, PA, </address> <month> Apr. </month> <pages> 23-25, </pages> <year> 1984), </year> <journal> ACM SIGPLAN Notices 19(5) pp. </journal> <month> 132-140 (May </month> <year> 1984). </year>
Reference: 19. <author> Masinter, L.M., </author> <title> Global program analysis in an interactive environment, </title> <type> Tech. Rep. </type> <institution> SSL-80-1, Xerox Palo Alto Research Center, Palo Alto, </institution> <note> CA (January 1980). </note>
Reference: 20. <author> Myers, E., </author> <title> A precise inter-procedural data ow algorithm, pp. </title> <booktitle> 219-230 in Conference Record of the Eighth ACM Symposium on Principles of Programming Languages, </booktitle> <address> (Williamsburg, VA, </address> <month> January 26-28, </month> <year> 1981), </year> <booktitle> ACM, </booktitle> <address> New York, NY (1981). </address>
Reference: 21. <author> Ramakrishnan, R., Seshadri, P., Srivastava, D., and Sudarshan, S., Coral pre-Release 1.0, </author> <title> Software system, </title> <institution> Computer Sciences Department, University of Wisconsin, Madison, WI (1993). </institution> <note> (Available via ftp from ftp.cs.wisc.edu.) </note>
Reference-contexts: Such tools are particularly useful when debugging, when trying to understand complicated code, or when trying to transform a pro gram to execute efficiently on a parallel machine. When interprocedural-analysis problems are encoded in Coral <ref> [21] </ref> (or some other logic-programming language with a bottom-up evaluation strategy), demand algorithms can be obtained totally automatically. In principle, however, the approach described in the paper is not just restricted to interprocedural-analysis problems encoded in logic-programming languages.
Reference: 22. <author> Rohmer, R., Lescoeur, R., and Kersit, J.-M., </author> <title> The Alexander method, a technique for the processing of recursive axioms in deductive databases, </title> <journal> New Generation Computing 4(3) pp. </journal> <month> 273-285 </month> <year> (1986). </year>
Reference-contexts: for obtaining algorithms that solve the demand versions of interproce-dural analysis problems has two phases: (1) encode the algorithm for the exhaustive version of the problem as a logic program; (2) convert the algorithm for the exhaustive version to a demand algorithm by applying a transformationknown as the Alexander method <ref> [22] </ref> or the magic-sets transformation [3,7]that was developed in the logic-programming and deductive-database communities for optimizing the evaluation of recursive queries in deductive databases.
Reference: 23. <author> Sharir, M. and Pnueli, A., </author> <title> Two approaches to interprocedural data ow analysis, pp. 189-233 in Program Flow Analysis: Theory and Applications, </title> <editor> ed. S.S. Muchnick and N.D. Jones, </editor> <publisher> Prentice-Hall, </publisher> <address> Englewood Cliffs, NJ (1981). </address>
Reference-contexts: To streamline the presentation, the dataow a nalysis problems discussed in Section 4 have been simplified in certain ways. In particular, f ollowing Sharir and Pnueli <ref> [23] </ref> we assume that (i) all variables are global variables, (ii) procedures are parameterless, (iii) the programs being analyzed do not contain aliasing, and (iv) the programs being analyzed do not use procedure-valued variables. <p> The basis for the exhaustive algorithm is Sharir and Pnueli's functional approach to interprocedural dataow analysis, which, for distributive dataow f unctions, yields the meet-over-all-valid-paths solution to certain classes of ow-sensitive interprocedural dataow analysis problems <ref> [23] </ref>. We assume that (L , `` ) is a meet semilattice of dataow facts with a smallest element ^ and a largest element `` . <p> We also assume that dataow functions are members of a space of monotonic (or distributive) functions F L fi L and that F contains the identity function. Sharir and Pnueli make use of two different graph representations of programs, which are defined below. Definition 4.1. (Sharir and Pnueli <ref> [23] </ref>). Define G = - G p | p is a procedure in the program -, where, for each p, G p = (N p , E p , r p ). <p> The second graph representation, in which the ow graphs of the different procedures are connected together, is used to define the notion of interpro cedurally valid paths. Definition 4.2. (Sharir and Pnueli <ref> [23] </ref>). Define G * * * , r main ), where N * p and E = E 2 , where E 0 p 0 p is the collection of all ordinary control-ow edges, and an edge (m, n) E 2 represents either a call or return edge. <p> The notion of interprocedurally valid paths captures the idea that not all paths through G represent potentially valid execution paths: Definition 4.3. (Sharir and Pnueli <ref> [23] </ref>). For each n N , we define IVP (r main , n) as the set of all interprocedurally valid paths in G * that lead from r main to n. <p> Definition 4.4. (Sharir and Pnueli <ref> [23] </ref>). If q is a path in G * , let f q denote the (path) function obtained by composing the functions associated with q's edges (in the order that they appear in path q). <p> p ) for each procedure p and n (N p - r p -) Sharir and Pnueli showed that if the edge functions are distributive, the greatest solution to the above set of equations is equal to the meet-over-all-valid-paths solution (i.e., for all n, x n = y n ) <ref> [23] </ref>. 4.1.
Reference: 24. <author> Warren, </author> <title> D.S., Memoing for logic programs, </title> <journal> Commun. of the ACM 35(3) pp. </journal> <month> 93-111 (March </month> <year> 1992). </year>
Reference-contexts: After the work reported in this paper was completed, the work by D.S. Warren and others concerning the use of tabulation techniques in top-down evaluation of logic programs <ref> [24] </ref> was brought to my attention. These techniques provide an alternative method for obtaining demand algorithms for program-analysis problems.
Reference: 25. <author> Warren, </author> <title> D.S., XSB Logic Programming System, Software system, </title> <institution> Computer Science Department, State University of New York, Stony Brook, </institution> <address> NY (1993). </address> <note> (Available via ftp from sbcs.sunysb.edu.) </note>
Reference-contexts: Thus, another way to obtain an implementation of a demand algorithm for the interprocedural gen-kill dataow-analysis problems would be to use the program from Section 4 in con junction with the SUNY-Stony Brook XSB system <ref> [25] </ref>. Acknowledgements Alan Demers, Fritz Henglein, Susan Horwitz, Neil Jones, Bernard Lang, Raghu Ramakrishnan, Genevieve Rosay, M ooly Sagiv, Marvin Solomon, Divesh Srivastava, a nd Tim Teitelbaum pro vided comments and helpful suggestions about the work.
Reference: 26. <author> Weiser, M., </author> <title> Program slicing, </title> <journal> IEEE Transactions on Software Engineering SE-10(4) pp. </journal> <month> 352-357 (July </month> <year> 1984). </year>
Reference: 27. <author> Zadeck, F.K., </author> <title> Incremental data ow analysis in a structured program editor, </title> <booktitle> Proceedings of the SIG-PLAN 84 Symposium on Compiler Construction, </booktitle> <address> (Montreal, Can., </address> <month> June 20-22, </month> <year> 1984), </year> <journal> ACM SIGPLAN Notices 19(6) pp. </journal> <month> 132-143 (June </month> <year> 1984). </year>
References-found: 27

