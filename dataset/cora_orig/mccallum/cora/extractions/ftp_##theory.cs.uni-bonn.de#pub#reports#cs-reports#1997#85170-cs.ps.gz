URL: ftp://theory.cs.uni-bonn.de/pub/reports/cs-reports/1997/85170-cs.ps.gz
Refering-URL: http://cs.uni-bonn.de/info5/publications/CS-1997-en.html
Root-URL: http://cs.uni-bonn.de
Email: email: carsten@cs.uni-bonn.de  email: wirtgen@cs.uni-bonn.de  
Title: Approximate Counting of Given Length Cycles  
Author: Carsten Dorgerloh Jurgen Wirtgen 
Address: Bonn, Romerstr. 164, D-53117 Bonn, Germany,  Bonn, Romerstr. 164, D-53117 Bonn, Germany,  
Affiliation: Institut fur Informatik, Universitat  -Institut fur Informatik, Universitat  
Abstract: We present a method for approximate counting simple cycles of a given length in graphs. The main result of this paper is an (*; ffi)-approximation to the number of simple cycles of length k which runs in O(M (n) log n=* 2 log(1=ffi)) time, where O(M (n)) is the complexity of matrix multiplication. 
Abstract-found: 1
Intro-found: 1
Reference: [AYZ 94] <author> Alon, N., Yuster, R., Zwick, U., </author> <title> Finding and counting given length cyles, </title> <booktitle> Proc. 2 nd European Symposium on Algorithms (1994), </booktitle> <pages> pp. 354-364. </pages>
Reference-contexts: However, there are only a few fast algorithms for counting the number of simple cycles of a given fixed length. <ref> [AYZ 94] </ref> showed that for any k 7 the number of simple cycles of length k in a graph can be counted in O (M (n)) time, where M (n) &lt; n 2:376 is the complexity of matrix multiplication [CW 87]. <p> For counting small simple cycles, i.e. of size k 7, one can use the algorithm of <ref> [AYZ 94] </ref> to exactly count the number of such cycles in O (M (n)) time. Can the number of simple cycles of length k &gt; 7 be counted exactly within ~ O (M (n)) time? Maybe there are faster algorithms for special graph classes like e.g. dense graphs.
Reference: [AYZ 95] <author> Alon, N., Yuster, R., Zwick, U., Color-coding, </author> <booktitle> Proc. 42 nd Journal of the ACM (1995), </booktitle> <pages> pp. 844-856. </pages>
Reference-contexts: We present an (*; ffi)-approximation to this number that works for any fixed k and which runs in O (M (n) log n=* 2 log (1=ffi)) time. Our algorithm for that problem, while using a result from <ref> [AYZ 95] </ref>, takes advantage of the covering method introduced by [KLM 89]. [KLM 89] make use of this method to approximate the number of distinct satisfying assignments of a given boolean formula in disjunctive normal form (DNF). The paper is organized as follows. <p> To achieve this running time we will make heavily use of the following lemma which is implicitly in <ref> [AYZ 95] </ref>.
Reference: [CW 87] <author> Coppersmith, D., Winograd, S., </author> <title> Matrix multiplication via arithmetic progressions, </title> <booktitle> Proc. 19 th ACM STOC (1987), </booktitle> <pages> pp. 1-6. </pages>
Reference-contexts: counting the number of simple cycles of a given fixed length. [AYZ 94] showed that for any k 7 the number of simple cycles of length k in a graph can be counted in O (M (n)) time, where M (n) &lt; n 2:376 is the complexity of matrix multiplication <ref> [CW 87] </ref>. We present an (*; ffi)-approximation to this number that works for any fixed k and which runs in O (M (n) log n=* 2 log (1=ffi)) time.
Reference: [Do 96] <author> Dorgerloh, C. F., </author> <title> A Fast Randomized Parallel Algorithm for Finding Simple Cycles in Planar Graphs, </title> <institution> Research Report 85150-CS, Institut fur Informatik der Universitat Bonn, </institution> <year> 1996. </year>
Reference-contexts: 1 Introduction The literature on detection and finding simple cycles of a given length has a long and varied history (see e.g. [Mo 85], [RL 85], [Ri 86], [YZ 94], <ref> [Do 96] </ref>, [DW 96], [DW 97a], [DW 97b]).
Reference: [DW 96] <author> Dorgerloh, C. F., Wirtgen, J., </author> <title> A note on improving the running time of a class of parallel algorithms using randomization, </title> <institution> Research Report 85159-CS, Institut fur Informatik der Universitat Bonn, </institution> <year> 1996. </year>
Reference-contexts: 1 Introduction The literature on detection and finding simple cycles of a given length has a long and varied history (see e.g. [Mo 85], [RL 85], [Ri 86], [YZ 94], [Do 96], <ref> [DW 96] </ref>, [DW 97a], [DW 97b]).
Reference: [DW 97b] <author> Dorgerloh, C. F., Wirtgen, J., </author> <title> Once again: Finding simple cycles, </title> <institution> Research Report 85165-CS, Institut fur Informatik der Universitat Bonn, </institution> <year> 1997. </year>
Reference-contexts: 1 Introduction The literature on detection and finding simple cycles of a given length has a long and varied history (see e.g. [Mo 85], [RL 85], [Ri 86], [YZ 94], [Do 96], [DW 96], [DW 97a], <ref> [DW 97b] </ref>).
Reference: [DW 97a] <author> Dorgerloh, C., Wirtgen, J., </author> <title> Faster Finding of Simple Cycles in Planar Graphs on a randomized EREW-PRAM, </title> <booktitle> Proc. 2 nd Workshop on Randomized Parallel Computing (1997), held in conjunction with IPPS'97. </booktitle>
Reference-contexts: 1 Introduction The literature on detection and finding simple cycles of a given length has a long and varied history (see e.g. [Mo 85], [RL 85], [Ri 86], [YZ 94], [Do 96], [DW 96], <ref> [DW 97a] </ref>, [DW 97b]).
Reference: [Ev 79] <author> Even, S., </author> <title> Graph Algorithms, </title> <publisher> Computer Science Press, </publisher> <year> 1979. </year>
Reference-contexts: In Section 3 we present the (*; ffi)-approximation algorithm for counting simple cycles of a given length in graphs. Finally, we conclude in Section 4 with open problems. 2 Notations and Definitions The graph terminology used in this paper follows that of Even <ref> [Ev 79] </ref>. Let G = (V; E) be a graph.
Reference: [KLM 89] <author> Karp, R. M., Luby, M., Madras, N., </author> <title> Monte-Carlo Approximation Algorithms for Enumeration Problems, </title> <booktitle> Journal of Algorithms 10 (1989), </booktitle> <pages> pp. 429-448. </pages>
Reference-contexts: We present an (*; ffi)-approximation to this number that works for any fixed k and which runs in O (M (n) log n=* 2 log (1=ffi)) time. Our algorithm for that problem, while using a result from [AYZ 95], takes advantage of the covering method introduced by <ref> [KLM 89] </ref>. [KLM 89] make use of this method to approximate the number of distinct satisfying assignments of a given boolean formula in disjunctive normal form (DNF). The paper is organized as follows. Section 2 contains some definitions and notations used throughout the paper. <p> We present an (*; ffi)-approximation to this number that works for any fixed k and which runs in O (M (n) log n=* 2 log (1=ffi)) time. Our algorithm for that problem, while using a result from [AYZ 95], takes advantage of the covering method introduced by <ref> [KLM 89] </ref>. [KLM 89] make use of this method to approximate the number of distinct satisfying assignments of a given boolean formula in disjunctive normal form (DNF). The paper is organized as follows. Section 2 contains some definitions and notations used throughout the paper. <p> To obtain the desired (*; ffi)-approximation we use the covering-method of <ref> [KLM 89] </ref> to find an estimate for jCj. In order to use this method we need a superset (the universe) U of C. The algorithm involves N independent trials, where each of this trials consists of the following steps: 1. <p> In order to solve this problem we will make use the covering-method of <ref> [KLM 89] </ref>. Let U i be the set of directed simple cycles in G i , then S i U i = C, if we replace each directed cycle in U i by its undirected version. The goal is to estimate the size of this union.
Reference: [Mo 85] <author> Monien, B., </author> <title> How to find long paths efficiently, </title> <booktitle> Annals of Discrete Mathematics 25 (1985), </booktitle> <pages> pp. 239-254. </pages>
Reference-contexts: 1 Introduction The literature on detection and finding simple cycles of a given length has a long and varied history (see e.g. <ref> [Mo 85] </ref>, [RL 85], [Ri 86], [YZ 94], [Do 96], [DW 96], [DW 97a], [DW 97b]).
Reference: [MR 95] <author> Motwani, R., Raghavan, P., </author> <title> Randomized Algorithms, </title> <publisher> Cambridge University Press, </publisher> <year> 1995. </year>
Reference-contexts: Set ( 0 otherwise. The expected value of Z = jU j P N i=1 Y i =N will be jCj. To ensure that this estimate is with high probability an *-approximation the following lemma is used. A proof can be found e.g. in <ref> [MR 95] </ref>. Lemma 4 (Bernstein) Let = jCj=jU j. Then the above described method yields an (*; ffi)-approximation to jCj provided N * 2 Now we construct a suitable universe U .
Reference: [Ri 86] <author> Richards, D., </author> <title> Finding short cycles in a planar graph using seperators, </title> <booktitle> Journal of Algorithms 7 (1986), </booktitle> <pages> pp. 382-394. </pages>
Reference-contexts: 1 Introduction The literature on detection and finding simple cycles of a given length has a long and varied history (see e.g. [Mo 85], [RL 85], <ref> [Ri 86] </ref>, [YZ 94], [Do 96], [DW 96], [DW 97a], [DW 97b]).
Reference: [RL 85] <author> Richards, D., Liestman, A. L., </author> <title> Finding cycles of a given length, </title> <booktitle> Annals of Discrete Mathematics 27 (1985), </booktitle> <pages> pp. 249-256. </pages>
Reference-contexts: 1 Introduction The literature on detection and finding simple cycles of a given length has a long and varied history (see e.g. [Mo 85], <ref> [RL 85] </ref>, [Ri 86], [YZ 94], [Do 96], [DW 96], [DW 97a], [DW 97b]).
Reference: [YZ 94] <author> Yuster, R., Zwick, U., </author> <title> Finding even cycles even faster, </title> <booktitle> Proc. 21 st International Colloquium on Automata, Languages and Programming (1994), </booktitle> <pages> pp. 532-543. 6 </pages>
Reference-contexts: 1 Introduction The literature on detection and finding simple cycles of a given length has a long and varied history (see e.g. [Mo 85], [RL 85], [Ri 86], <ref> [YZ 94] </ref>, [Do 96], [DW 96], [DW 97a], [DW 97b]).
References-found: 14

