URL: http://cs.utep.edu/gelfond/papers/tolerance.ps
Refering-URL: http://cs.utep.edu/gelfond/gelfond.html
Root-URL: http://www.aic.nrl.navy.mil/~aha/people.html
Email: mgelfond@cs.utep.edu  halina@cs.ucr.edu  
Title: Towards a Theory of Elaboration Tolerance: Logic Programming Approach  
Author: Michael Gelfond Halina Przymusinska 
Address: Paso  
Affiliation: University of Texas at El  California State Polytechnic University  
Abstract: This paper is an attempt at mathematical investigation of software development process in the context of declarative logic programming. We introduce notions of specification and specification constructor which are developed from natural language description of a problem. Generalizations of logic programs, called lp-functions are introduced to represent these specifications. We argue that the process of constructing lp-function representing a specification S should be supported by certain types of mathematical results which we call representation the orems. We present two such theorems to illustrate the idea. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> J. Alferes and L. Pereira. </author> <title> On logic program semantics with two kinds of negation. </title> <editor> In K. Apt, editor, </editor> <booktitle> Proc. of the Joint International Conference and Symposium on Logic Programming, </booktitle> <address> Washington DC, </address> <pages> pages 574-588. </pages> <publisher> MIT Press, </publisher> <month> Nov </month> <year> 1992. </year> <month> 30 </month>
Reference-contexts: The Prolog programming language and its recent dialects can be used for rapid prototyping. It is worth mentioning that some of these dialects (see, for instance <ref> [24, 1] </ref>) are more declarative and have better terminating properties than Prolog. As a semantic basis for the language we use the answer sets semantics of [12]. This selection is based on the simplicity of the semantics and the existence of a substantial body of knowledge related to it.
Reference: [2] <author> K. Apt, H. Blair, and A. Walker. </author> <title> Towards a theory of declarative knowl-edge. </title> <editor> In J. Minker, editor, </editor> <booktitle> Foundations of Deductive Databases and Logic Programming, </booktitle> <pages> pages 89-148. </pages> <publisher> Morgan Kaufmann, </publisher> <address> San Mateo, CA., </address> <year> 1988. </year>
Reference-contexts: The following theorem describes an important property of stratified programs. Proposition 3. <ref> [2, 10] </ref> Any stratified general logic program is categorical. It is easy to see that the program from Example 11 is stratified and therefore has only one stable model while program from Example 14 is not stratified. For stratified logic programs SLDNF resolution [7] provides a sound compu tational mechanism.
Reference: [3] <author> C. Bell, A. Nerode, R. Ng, </author> <title> and V.S. Subrahmanian. Computation and implementation of non-monotonic deductive databases. </title> <type> Technical Report CS-TR-2801, </type> <institution> University of Maryland, </institution> <note> 1991 (a revised version is to appear in JACM 94. </note>
Reference-contexts: To answer queries with respect to general logic programs with a multiple number of answer sets, several approaches have been suggested. For an interesting method that uses linear programming see <ref> [3] </ref>. Let us now show that extended logic programs can be reduced to general logic programs. We will need the following notation: 29 For any predicate p occurring in , let p 0 be a new predicate of the same arity.
Reference: [4] <author> Chitta Baral and Michael Gelfond. </author> <title> Logic programming and knowledge representation. </title> <journal> Journal of Logic Programming, </journal> <volume> 12 </volume> <pages> 1-80, </pages> <year> 1994. </year>
Reference-contexts: The next few lines however give a hint on the reasons for our decision: A discussion of methodology of expressing normative and epistemic state ments in the language of declarative logic programming together with related mathematical results can be found, for instance, in <ref> [4] </ref>. The Prolog programming language and its recent dialects can be used for rapid prototyping. It is worth mentioning that some of these dialects (see, for instance [24, 1]) are more declarative and have better terminating properties than Prolog. <p> Applicability of the language specified above and of its extensions to knowledge representation has been extensively studied by various researchers (for a survey see <ref> [4] </ref>). To reflect the functional character of the specifications that we are planning to represent we adopt the approach suggested in [5] which associates logic programs with functions from sets of literals to sets of literals.
Reference: [5] <author> Chitta Baral, Michael Gelfond, and Olga Kosheleva. </author> <title> Approximating general logic programs. </title> <booktitle> In Proc. of ILPS93, </booktitle> <pages> pages 181-198, </pages> <year> 1993. </year>
Reference-contexts: Another example, dealing with a constructor which takes as an input a specification S containing the closed world assumption for its predicates and returns a new specification obtained from S by removing this assumption, can be found in <ref> [5] </ref>. In the process of his work the representer will, of course, require frequent communication with the specifier. The existence of extensions of Prolog capable of answering queries about knowledge represented by lp-functions allows rapid prototyping and facilitates this communication. <p> Applicability of the language specified above and of its extensions to knowledge representation has been extensively studied by various researchers (for a survey see [4]). To reflect the functional character of the specifications that we are planning to represent we adopt the approach suggested in <ref> [5] </ref> which associates logic programs with functions from sets of literals to sets of literals. The approach is similar to that used in Datalog, with some additional care taken to account for the existence of inconsistent programs, possible multiplicity of answer sets, and the absence of the closed world assumption. <p> There are of course other important modifi cations of functional specifications. One such modification removing the closed world assumption [21] from the input predicates of specification S - was studied in <ref> [5] </ref> from the position similar to the one advocated here. In general, adding and removing assumptions about the domain of specification S, such as the closed world assumption, the unique name assumption, etc., seem to frequently occur in practice.
Reference: [6] <author> A. Colmerauer, H. Kanoui, R. Pasero, and P. Roussel. </author> <title> Un Systeme de Communication Homme-Machine en Francais. </title> <type> Technical report, </type> <institution> Groupe de Intelligence Artificielle Universitae de Aix-Marseille II, Marseille, </institution> <year> 1973. </year>
Reference-contexts: The paradigm, which first appeared in artificial intelligence, had substantial impact on other areas of computing science, such as databases, programming languages and software engineering, and led to the development of programming language Prolog and its dialects (see <ref> [6, 16] </ref>). In declarative logic programming the software development process starts with a natural language description of the domain. The description is analyzed and represented in a formal logical language with precisely defined entailment relation.
Reference: [7] <author> Keith Clark. </author> <title> Negation as failure. </title> <editor> In Herve Gallaire and Jack Minker, editors, </editor> <booktitle> Logic and Data Bases, </booktitle> <pages> pages 293-322. </pages> <publisher> Plenum Press, </publisher> <address> New York, </address> <year> 1978. </year>
Reference-contexts: Proposition 3. [2, 10] Any stratified general logic program is categorical. It is easy to see that the program from Example 11 is stratified and therefore has only one stable model while program from Example 14 is not stratified. For stratified logic programs SLDNF resolution <ref> [7] </ref> provides a sound compu tational mechanism. This implies that PROLOG which is based on SLDNF resolution can be viewed as a practical query answering mechanism for a broad class of programs i.e. stratified programs which satisfy safety and termination conditions. Example 15. Consider general logic program from Example 11.
Reference: [8] <author> Jurgen Dix. </author> <title> Classifying semantics of disjunctive logic programs. </title> <editor> In Krzysztof Apt, editor, </editor> <booktitle> Proc JICSLP'92, </booktitle> <pages> pages 798-812, </pages> <year> 1992. </year>
Reference-contexts: This conservative extension property (called "the weak principle of stratification" by Schlipf [23] and "relevance" by Dix <ref> [8] </ref>) is not valid even for general logic programs under stable model semantics without additional restrictions. Consider, for instance, a program = fp not q; q not p; g and the definition D = fr not r ; q; r pg of r.
Reference: [9] <author> H. Ehrig and Mahr B. </author> <title> Fundamentals of Algebraic Specifications. </title> <publisher> Springler Verlag, </publisher> <year> 1985. </year>
Reference-contexts: In partic ular we should be able to represent: 1 This view is substantially different from general notions of specifications <ref> [9, 20, 25] </ref> tailored to imperative paradigm of programming as well as from traditional logic programming approach where a program, understood as a first-order theory, played a role of specification.
Reference: [10] <author> M. Gelfond and V. Lifschitz. </author> <title> The stable model semantics for logic programming. </title> <editor> In R. Kowalski and K. Bowen, editors, </editor> <booktitle> Logic Programming: Proc. of the Fifth Int'l Conf. and Symp., </booktitle> <pages> pages 1070-1080, </pages> <year> 1988. </year>
Reference-contexts: The following theorem describes an important property of stratified programs. Proposition 3. <ref> [2, 10] </ref> Any stratified general logic program is categorical. It is easy to see that the program from Example 11 is stratified and therefore has only one stable model while program from Example 14 is not stratified. For stratified logic programs SLDNF resolution [7] provides a sound compu tational mechanism.
Reference: [11] <author> Michael Gelfond and Vladimir Lifschitz. </author> <title> Logic programs with classical negation. </title> <editor> In David Warren and Peter Szeredi, editors, </editor> <booktitle> Logic Programming: Proc. of the Seventh Int'l Conf., </booktitle> <pages> pages 579-597, </pages> <year> 1990. </year>
Reference-contexts: Rules with variables are viewed as schemata representing the sets of their ground instantiations. The entailment relation between extended logic programs and ground literals of L is based on the answer set semantics of <ref> [11] </ref>, according to which j= l iff l belongs to all answer sets of . (For a definition of answer sets see the Appendix). <p> For any set S lit (), S + stands for the set of the positive forms of the elements of S. Proposition 4. <ref> [11] </ref> A consistent set S Lit is an answer set of if and only if S + is an answer set of + . This Proposition suggests the following simple way of evaluating queries in extended logic programs.
Reference: [12] <author> Michael Gelfond and Vladimir Lifschitz. </author> <title> Classical negation in logic programs and disjunctive databases. </title> <journal> New Generation Computing, </journal> <pages> pages 365-387, </pages> <year> 1991. </year>
Reference-contexts: It is worth mentioning that some of these dialects (see, for instance [24, 1]) are more declarative and have better terminating properties than Prolog. As a semantic basis for the language we use the answer sets semantics of <ref> [12] </ref>. This selection is based on the simplicity of the semantics and the existence of a substantial body of knowledge related to it. There are several other interesting semantics of declarative logic programming, which give slightly different interpretations to logic programming connectives. <p> The language is based on the notion of an extended logic program from <ref> [12] </ref>. Let us recall the necessary definitions. More information can be found in the Appendix. Let L be a first-order language over an alphabet .
Reference: [13] <author> Michael Gelfond and Halina Przymusinska. </author> <title> Definitions in epistemic specifications. </title> <editor> In Anil Nerod, Victor Marek, and Subramanian V. S., editors, </editor> <booktitle> Logic Programming and Non-monotonic Reasoning: Proc. of the First Int'l Workshop, </booktitle> <pages> pages 245-259, </pages> <year> 1991. </year>
Reference-contexts: It is easy to see that [ D entails p while does not. The question of discovering conditions under which the conservative extension property holds was addressed in <ref> [13] </ref>. Some of these results were generalized in [15]. To prove Theorem 1 we give here another (stronger) sufficient condition of conservativeness. 4 Recall that head () stands for the set of all literals that belong to conclusions of the rules from .
Reference: [14] <author> R.A. Kowalski. </author> <title> Logic for Problem Solving. </title> <publisher> North-Holland, </publisher> <year> 1979. </year>
Reference-contexts: 1 Introduction This paper is written in the framework of declarative logic programming paradigm (see, for instance, <ref> [17, 14] </ref>) which strives to reduce a substantial part of a programming process to the description of objects comprising the domain of interest and relations between these objects.
Reference: [15] <author> Vladimir Lifschitz and Hudson Turner. </author> <title> Splitting a logic program. </title> <editor> In Pascal Van Hentenryck, editor, </editor> <booktitle> Proc. of the Eleventh Int'l Conf. on Logic Programming, </booktitle> <pages> pages 23-38, </pages> <year> 1994. </year>
Reference-contexts: It is easy to see that [ D entails p while does not. The question of discovering conditions under which the conservative extension property holds was addressed in [13]. Some of these results were generalized in <ref> [15] </ref>. To prove Theorem 1 we give here another (stronger) sufficient condition of conservativeness. 4 Recall that head () stands for the set of all literals that belong to conclusions of the rules from . <p> Corollary 1. Under the same conditions as in Theorem 3 program D [ is a conservative extension of the program . Before proving Theorem 3 we will recall an important property of logic pro grams called Splitting Set Theorem <ref> [15] </ref>. A splitting set for a logic program is any set U of literals such that, for every rule r 2 , if head (r) " U 6= ; then lit (r) U . <p> Theorem 4. (Splitting Set Theorem <ref> [15] </ref>). Let U be a splitting set for a program . <p> Corollary 2. ( <ref> [15] </ref>). Let be a logic program and let X be a set of literals such that X " head () = ;. <p> This shows that red (D; A 1 ) is consistent and completes the proof of the Theorem. Proposition 1. The sufficient condition for the conservative extension property given in Corollary 1 is a generalization of the condition provided by Proposition 1 in <ref> [15] </ref>. <p> The next example together with Proposition 1 shows that Corollary 1 is stronger than Proposition 1 from <ref> [15] </ref>. Example 10. Let be a program consisting of rules r5; r6; : : : of the program B 1 from Example 3 and let D = B 1 n.
Reference: [16] <author> J. Lloyd. </author> <title> Foundations of Logic Programming. </title> <publisher> Springer-Verlag, </publisher> <address> second edition, </address> <year> 1987. </year>
Reference-contexts: The paradigm, which first appeared in artificial intelligence, had substantial impact on other areas of computing science, such as databases, programming languages and software engineering, and led to the development of programming language Prolog and its dialects (see <ref> [6, 16] </ref>). In declarative logic programming the software development process starts with a natural language description of the domain. The description is analyzed and represented in a formal logical language with precisely defined entailment relation.
Reference: [17] <author> J. McCarthy. </author> <title> Programs with common sense. </title> <booktitle> In Proc. of the Teddington Conference on the Mechanization of Thought Processes, </booktitle> <pages> pages 75-91, </pages> <address> London, </address> <year> 1959. </year> <institution> Her Majesty's Stationery Office. </institution>
Reference-contexts: 1 Introduction This paper is written in the framework of declarative logic programming paradigm (see, for instance, <ref> [17, 14] </ref>) which strives to reduce a substantial part of a programming process to the description of objects comprising the domain of interest and relations between these objects.
Reference: [18] <author> J. McCarthy. </author> <title> Circumscription|a form of non-monotonic reasoning. </title> <journal> Artificial Intelligence, </journal> <volume> 13(1, </volume> 2):27-39,171-172, 1980. 
Reference-contexts: Commonsense reasoning is nonmonotonic: new information constantly forces us to withdraw previous conclusions. This observation has led to the development and investigation of new logical formalisms, nonmonotonic logics (see <ref> [18, 22, 19] </ref>). This paper is an attempt at mathematical investigation of software development process in the context of declarative logic programming. In particular we are interested in investigating an important property of formal representations called elaboration tolerance.
Reference: [19] <author> R. Moore. </author> <title> Semantical Considerations on Nonmonotonic Logic. </title> <journal> Artificial Intelligence, </journal> <volume> 25(1) </volume> <pages> 75-94, </pages> <year> 1985. </year>
Reference-contexts: Commonsense reasoning is nonmonotonic: new information constantly forces us to withdraw previous conclusions. This observation has led to the development and investigation of new logical formalisms, nonmonotonic logics (see <ref> [18, 22, 19] </ref>). This paper is an attempt at mathematical investigation of software development process in the context of declarative logic programming. In particular we are interested in investigating an important property of formal representations called elaboration tolerance.
Reference: [20] <author> Carroll Morgan. </author> <title> Programming from Specifications. </title> <publisher> Prentice Hall, </publisher> <year> 1990. </year>
Reference-contexts: In partic ular we should be able to represent: 1 This view is substantially different from general notions of specifications <ref> [9, 20, 25] </ref> tailored to imperative paradigm of programming as well as from traditional logic programming approach where a program, understood as a first-order theory, played a role of specification.
Reference: [21] <author> Raymond Reiter. </author> <title> On closed world data bases. </title> <editor> In Herve Gallaire and Jack Minker, editors, </editor> <booktitle> Logic and Data Bases, </booktitle> <pages> pages 119-140. </pages> <publisher> Plenum Press, </publisher> <address> New York, </address> <year> 1978. </year>
Reference-contexts: There are of course other important modifi cations of functional specifications. One such modification removing the closed world assumption <ref> [21] </ref> from the input predicates of specification S - was studied in [5] from the position similar to the one advocated here.
Reference: [22] <author> R. Reiter. </author> <title> A logic for default reasoning. </title> <journal> Artificial Intelligence, </journal> <volume> 13(1,2):81-132, </volume> <year> 1980. </year>
Reference-contexts: Commonsense reasoning is nonmonotonic: new information constantly forces us to withdraw previous conclusions. This observation has led to the development and investigation of new logical formalisms, nonmonotonic logics (see <ref> [18, 22, 19] </ref>). This paper is an attempt at mathematical investigation of software development process in the context of declarative logic programming. In particular we are interested in investigating an important property of formal representations called elaboration tolerance.
Reference: [23] <author> John Schlipf. </author> <title> Complexity and undecidability results in logic programming. </title> <booktitle> In Workshop on Structural Complexity and Recursion-theoretic methods in Logic Programming, </booktitle> <year> 1992. </year>
Reference-contexts: This conservative extension property (called "the weak principle of stratification" by Schlipf <ref> [23] </ref> and "relevance" by Dix [8]) is not valid even for general logic programs under stable model semantics without additional restrictions. Consider, for instance, a program = fp not q; q not p; g and the definition D = fr not r ; q; r pg of r.
Reference: [24] <author> D. S. Warren and W. Chen. </author> <title> Query evaluation under well-founded semantics. </title> <booktitle> In Proc. of PODS 93, </booktitle> <year> 1993. </year>
Reference-contexts: The Prolog programming language and its recent dialects can be used for rapid prototyping. It is worth mentioning that some of these dialects (see, for instance <ref> [24, 1] </ref>) are more declarative and have better terminating properties than Prolog. As a semantic basis for the language we use the answer sets semantics of [12]. This selection is based on the simplicity of the semantics and the existence of a substantial body of knowledge related to it.
Reference: [25] <author> J. B. Wordsworth. </author> <title> Software Development with Z. </title> <publisher> Addison-Wesley, </publisher> <year> 1992. </year> <month> 32 </month>
Reference-contexts: In partic ular we should be able to represent: 1 This view is substantially different from general notions of specifications <ref> [9, 20, 25] </ref> tailored to imperative paradigm of programming as well as from traditional logic programming approach where a program, understood as a first-order theory, played a role of specification.
References-found: 25

