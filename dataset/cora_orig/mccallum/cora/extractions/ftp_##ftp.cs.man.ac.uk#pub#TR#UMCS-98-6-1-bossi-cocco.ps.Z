URL: ftp://ftp.cs.man.ac.uk/pub/TR/UMCS-98-6-1-bossi-cocco.ps.Z
Refering-URL: ftp://ftp.cs.man.ac.uk/pub/TR/UMCS-98-6-1.html
Root-URL: http://www.cs.man.ac.uk
Email: bossi, cocco@dsi.unive.it  
Title: Successes in Logic Programs  
Author: Annalisa Bossi, Nicoletta Cocco 
Address: Venezia-Ca' Foscari Italy  
Affiliation: Dip. di Matematica Applicata e Informatica Universita di  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> K. R. Apt. </author> <title> Introduction to Logic Programming. </title> <editor> In J. van Leeuwen, editor, </editor> <booktitle> Handbook of Theoretical Computer Science, volume B: Formal Models and Semantics. </booktitle> <publisher> Elsevier, Amsterdam and The MIT Press, </publisher> <address> Cambridge, </address> <year> 1990. </year>
Reference-contexts: We can prove that a universally terminating noFD query, defined by successful predicates, has at least one successful LD-derivation. In section 4 we describe a methodology for verifying that a predicate is successful. 2 2 Basic Notions The notation is more or less standard and essentially follows <ref> [17, 1] </ref>. We make use of the notion of modes and types introduced in [13, 5, 2]. We consider a combination of modes and types and adopt the following assumption: every considered relation has a fixed mode and a fixed type associated with it. <p> The input (output) terms of Q, denoted by In (Q)(Out (Q)), are the terms in input (output) positions in Q. Q is output-free iff output positions are filled in with distinct variables which do not appear leftmost, namely 8j 2 <ref> [1; m] </ref>, Out (B j ) = V ar (Out (B j )); if X 1 ; : : :; X k are the output terms in B j , then X i 6= X h , for i 6= h, i; h 2 [1; k]; and Out (B j ) <p> not appear leftmost, namely 8j 2 [1; m], Out (B j ) = V ar (Out (B j )); if X 1 ; : : :; X k are the output terms in B j , then X i 6= X h , for i 6= h, i; h 2 <ref> [1; k] </ref>; and Out (B j ) " (V ar (B 1 ; : : :; B j1 ) [ V ar (In (B j ))) = ;. 2 Definition 2.2 [input-correct and output-free instance] Let A be an output-free atom and ff a substitution. <p> iff 1. c is simply moded (namely the sequence of atoms in the body, A 1 ; : : :; A n , is output-free and V ar (In (H)) " V ar (Out (A 1 ; : : :; A n )) = ;); 2. for all i 2 <ref> [1; n] </ref> and for any input-correct and output-free instance A i ff of A i , there exists a clause in P whose head unifies with A i ff. <p> Q is without failures (noFD query) in a program P iff 1. the query Q is simply moded (namely it is output-free); 2. for j 2 <ref> [1; m] </ref> and for any input-correct and output-free instance B j ff of B j , there exists a clause in P whose head unifies with B j ff. 2 In [8] we also proved the "persistency" of the noFD property through LD-derivation and the main result on absence of FDs. <p> We call it the class of successful programs. Definition 3.1 [exaustive tests] Let P be a well-typed program wrt the directional types T and let p be a predicate defined in P by the clauses p (t i ) T i ; B i :, with i 2 <ref> [1; m] </ref>. T 1 ; : : :; T m are exaustive tests for p wrt input types in T iff for any well-typed input substitution for p, , namely such that p (X) is an input-correct and output-free instance of p (X), there exists i, i 2 [1; m], such <p> i 2 <ref> [1; m] </ref>. T 1 ; : : :; T m are exaustive tests for p wrt input types in T iff for any well-typed input substitution for p, , namely such that p (X) is an input-correct and output-free instance of p (X), there exists i, i 2 [1; m], such that oe = mgu (p (X); p (t i )) and T i oe has at least one successful LD-derivation. 2 Example 3.2 Let us consider the following trivial program p (X, Y, Z) X = Y, r (1, Z). p (b, a, Z) r (3, Z). any <p> Definition 3.3 [successful predicate] Let P be a well-typed program wrt the directional types T . Let p (t i ) T i ; B i :, with i 2 <ref> [1; m] </ref>, be the clauses defining a predicate p in P . A predicate p in P is successful wrt the input types in T iff 1. <p> A predicate p in P is successful wrt the input types in T iff 1. T 1 ; : : :; T m are exaustive tests for p wrt input types in T ; 2. (noFD conditions) for i 2 <ref> [1; m] </ref> * the sequence B i is output-free; * V ar (Out (B i ) " (V ar (In (p (t i ))) [ V ar (T i )) = ;; * for all D 2 B i and for any input-correct and output-free instance Dff of D, there exists <p> Definition 4.1 [actual input types] Let P be a well-typed program and p a predicate defined in P by the clauses p (t i1 ; : : :; t in ; s i1 ; : : :; s ir ) B i :, with i 2 <ref> [1; m] </ref>, where t ik , k 2 [1; n], are input terms and s ih , h 2 [1; r], output terms. Let T k , for k 2 [1; n], be the types associated to the input positions in the directional type of p. <p> types] Let P be a well-typed program and p a predicate defined in P by the clauses p (t i1 ; : : :; t in ; s i1 ; : : :; s ir ) B i :, with i 2 [1; m], where t ik , k 2 <ref> [1; n] </ref>, are input terms and s ih , h 2 [1; r], output terms. Let T k , for k 2 [1; n], be the types associated to the input positions in the directional type of p. <p> defined in P by the clauses p (t i1 ; : : :; t in ; s i1 ; : : :; s ir ) B i :, with i 2 [1; m], where t ik , k 2 [1; n], are input terms and s ih , h 2 <ref> [1; r] </ref>, output terms. Let T k , for k 2 [1; n], be the types associated to the input positions in the directional type of p. <p> : :; t in ; s i1 ; : : :; s ir ) B i :, with i 2 [1; m], where t ik , k 2 <ref> [1; n] </ref>, are input terms and s ih , h 2 [1; r], output terms. Let T k , for k 2 [1; n], be the types associated to the input positions in the directional type of p. The actual input types of p, AT k , for k 2 [1; n], are given by the sets of all the instances of terms in the k-th input positions of the heads of the <p> <ref> [1; n] </ref>, are input terms and s ih , h 2 [1; r], output terms. Let T k , for k 2 [1; n], be the types associated to the input positions in the directional type of p. The actual input types of p, AT k , for k 2 [1; n], are given by the sets of all the instances of terms in the k-th input positions of the heads of the definitions of p which belongs to T k : AT k = ([ fi ft 1k fi; : : :; t mk fig) " T k . 2 <p> Definition 4.3 [input-normalized definition] Let P be a well-typed program and p (i 1 ; : : :; i n ; o 1 ; : : :; o r ) a predicate defined in P , where i k , with k 2 <ref> [1; n] </ref>, are the input positions and o h , with h 2 [1; r] the output positions in p. <p> be a well-typed program and p (i 1 ; : : :; i n ; o 1 ; : : :; o r ) a predicate defined in P , where i k , with k 2 [1; n], are the input positions and o h , with h 2 <ref> [1; r] </ref> the output positions in p. Let V = fX 1 ; : : :; X n g be a set of new variables wrt p, namely variables which do not appear in the definition of p. <p> V is the set of normalized input variables for p N . X k = t k , for k 2 <ref> [1; n] </ref>, are the input equalities in each clause in the definition of p N , with directional type = (+ : T k ; : T k ), where T k is the type associated to the k-th input position. 2 Input normalization preserves well-typing and produces a program which <p> Let p N be its input-normalized definition p (X 1 ; : : :; X n ; s i ) T i ; B i :, with i 2 <ref> [1; m] </ref>, and V = fX 1 ; : : :; X n g be the set of normalized input variables for p N . <p> T 1 ; : : :; T m are exaustive tests for p N wrt AT iff for all well-typed input substitutions wrt AT, namely such that Dom () = V and X k 2 AT k , for k 2 <ref> [1; n] </ref>, there exists i, i 2 [1; m], such that T i has at least one successful LD-derivation. 2 Definition 4.6 [successful predicate (extended)] Let P be a well-typed program and p a predicate in P with actual input types AT . <p> T 1 ; : : :; T m are exaustive tests for p N wrt AT iff for all well-typed input substitutions wrt AT, namely such that Dom () = V and X k 2 AT k , for k 2 [1; n], there exists i, i 2 <ref> [1; m] </ref>, such that T i has at least one successful LD-derivation. 2 Definition 4.6 [successful predicate (extended)] Let P be a well-typed program and p a predicate in P with actual input types AT . <p> <ref> [1; m] </ref>, such that T i has at least one successful LD-derivation. 2 Definition 4.6 [successful predicate (extended)] Let P be a well-typed program and p a predicate in P with actual input types AT . Let p (t i ) T i ; B i :, with i 2 [1; m], be the clauses defining p N in P . p in P is successful wrt its actual input types iff 1. T 1 ; : : :; T m are exaustive tests for p N wrt AT ; 2. (noFD conditions) for i 2 [1; m] * the sequence <p> :, with i 2 <ref> [1; m] </ref>, be the clauses defining p N in P . p in P is successful wrt its actual input types iff 1. T 1 ; : : :; T m are exaustive tests for p N wrt AT ; 2. (noFD conditions) for i 2 [1; m] * the sequence B i is output-free; * V ar (Out (B i )) " (V ar (In (p (t i ))) [ V ar (T i )) = ;; * for all D 2 B i and for any input-correct wrt AT and output-free instance Dff of D,
Reference: [2] <author> K. R. Apt. </author> <title> Declarative programming in Prolog. </title> <editor> In D. Miller, editor, </editor> <booktitle> Proceedings of the 1993 International Symposium on Logic Programming, </booktitle> <pages> pages 12-35. </pages> <publisher> The MIT Press, </publisher> <year> 1993. </year>
Reference-contexts: In section 4 we describe a methodology for verifying that a predicate is successful. 2 2 Basic Notions The notation is more or less standard and essentially follows [17, 1]. We make use of the notion of modes and types introduced in <ref> [13, 5, 2] </ref>. We consider a combination of modes and types and adopt the following assumption: every considered relation has a fixed mode and a fixed type associated with it. This assumption allows us to talk about types of input positions and of output positions of an atom. <p> A similar denotation is called a directional type in [12]. From <ref> [5, 2] </ref> we take also the notion of well-typed query and program and from [4] the notion of simply moded clause and query. A complete treatment of these topics can be found in [3]. Besides we need the following definitions.
Reference: [3] <author> K. R. Apt. </author> <title> From Logic Programming to Prolog. </title> <publisher> Prentice Hall International Series in Computer Science, </publisher> <year> 1997. </year>
Reference-contexts: 1 Introduction When developing a logic program we, more or less explicitly, have to analize it with respect to correctness, termination properties and the existence of successful computations. On correctness and termination verification there have been rather many proposals such as <ref> [15, 7, 3, 11, 6, 18] </ref>. While for distinguishing failing and successful computations or for ensuring the presence of successes in a computation, very little is available, both in terms of methodology and tools. <p> A similar denotation is called a directional type in [12]. From [5, 2] we take also the notion of well-typed query and program and from [4] the notion of simply moded clause and query. A complete treatment of these topics can be found in <ref> [3] </ref>. Besides we need the following definitions. Definition 2.1 [output-free sequence] Let P be a well-typed program and Q = B 1 ; : : :; B m a well-typed query in P .
Reference: [4] <author> K. R. Apt and S. Etalle. </author> <title> On the unification free Prolog programs. </title> <editor> In A. Borzyszkowski and S. Sokolowski, editors, </editor> <booktitle> Proceedings of the Conference on Mathematical Foundations of Computer Science (MFCS 93), Lecture Notes in Computer Science, </booktitle> <pages> pages 1-19, </pages> <address> Berlin, 1993. </address> <publisher> Springer-Verlag. </publisher>
Reference-contexts: A similar denotation is called a directional type in [12]. From [5, 2] we take also the notion of well-typed query and program and from <ref> [4] </ref> the notion of simply moded clause and query. A complete treatment of these topics can be found in [3]. Besides we need the following definitions.
Reference: [5] <author> K. R. Apt and E. Marchiori. </author> <title> Reasoning about Prolog programs: from modes through types to assertions. </title> <journal> Formal Aspects of Computing, </journal> <volume> 6(6A):743-765, </volume> <year> 1994. </year>
Reference-contexts: In section 4 we describe a methodology for verifying that a predicate is successful. 2 2 Basic Notions The notation is more or less standard and essentially follows [17, 1]. We make use of the notion of modes and types introduced in <ref> [13, 5, 2] </ref>. We consider a combination of modes and types and adopt the following assumption: every considered relation has a fixed mode and a fixed type associated with it. This assumption allows us to talk about types of input positions and of output positions of an atom. <p> A similar denotation is called a directional type in [12]. From <ref> [5, 2] </ref> we take also the notion of well-typed query and program and from [4] the notion of simply moded clause and query. A complete treatment of these topics can be found in [3]. Besides we need the following definitions.
Reference: [6] <author> K. R. Apt and D. Pedreschi. </author> <title> Studies in Pure Prolog: termination. </title> <editor> In J.W. Lloyd, editor, </editor> <booktitle> Proceedings of the Simposium in Computational Logic, </booktitle> <pages> pages 150-176, </pages> <address> Berlin, 1990. </address> <publisher> Springer-Verlag. </publisher>
Reference-contexts: 1 Introduction When developing a logic program we, more or less explicitly, have to analize it with respect to correctness, termination properties and the existence of successful computations. On correctness and termination verification there have been rather many proposals such as <ref> [15, 7, 3, 11, 6, 18] </ref>. While for distinguishing failing and successful computations or for ensuring the presence of successes in a computation, very little is available, both in terms of methodology and tools. <p> Also in the field of program transformations being successful can be useful in particular for switching atoms in the clause bodies. In [10] we consider left-terminating programs <ref> [6] </ref> and we define a sufficient condition for switching atoms while preserving left-termination.
Reference: [7] <author> A. Bossi and N. Cocco. </author> <title> Verifying correctness of logic programs. </title> <editor> In J. Diaz and F. Orejas, editors, </editor> <booktitle> TAPSOFT '89, </booktitle> <address> Barcelona, Spain, </address> <month> March </month> <year> 1989, </year> <booktitle> (Lecture Notes in Computer Science, </booktitle> <volume> vol. 352), </volume> <pages> pages 96-110. </pages> <publisher> Springer-Verlag, </publisher> <year> 1989. </year>
Reference-contexts: 1 Introduction When developing a logic program we, more or less explicitly, have to analize it with respect to correctness, termination properties and the existence of successful computations. On correctness and termination verification there have been rather many proposals such as <ref> [15, 7, 3, 11, 6, 18] </ref>. While for distinguishing failing and successful computations or for ensuring the presence of successes in a computation, very little is available, both in terms of methodology and tools.
Reference: [8] <author> A. Bossi and N. Cocco. </author> <title> Programs without Failures. </title> <editor> In N. Fuchs, editor, </editor> <booktitle> Proceedings LOPSTR'97, Lecture Notes in Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1997. </year>
Reference-contexts: This well-known program shows the simplest case of a programs which can be queried without producing finitely failing derivations (FDs). In a previous work <ref> [8] </ref> we have given a sufficient condition for ensuring that a given program and query are without failures, namely they cannot have finitely failing derivations (noFD). <p> It is undecidable in general if some tests "cover" a type, but for unification or arithmetic tests a sofisticated algorithm is supplied, which makes use of Abstract Interpretation techniques. A report on its implementation is also given. In the present work we try to extend the results in <ref> [8, 14] </ref> with a methodological attitude. We study a sufficient condition for ensuring that a universally terminating query has at least one successful derivation in a given program. <p> In our classification noFD plus successful predicates correspond to "det" plus "multi" modes in Mercury, but we distinguish predicates also depending on the presence of FDs, since this can be relevant in program transformations, as shown in <ref> [8] </ref>. 4) split ([], Set2, [], []). split (Set1, [], Set1, []). split ([X jXs], Set2, [X jComplement], Intersection) not member (X, Set2), split (Xs, Set2, Complement, Intersection). split ([X jXs], Set2, Complement, [X jIntersection]) member (X, Set2), split (Xs, Set2, Complement, Intersection). member (X, [X jXs]). member (X, [Y jYs]) <p> We say that Aff is an input-correct and output-free instance of A iff Aff is correctly typed in input and Out (Aff) is a new variant of Out (A). 2 In <ref> [8] </ref> we have defined a class of programs and queries which cannot have finitely failing derivations. Definition 2.3 [noFD program] Let P be a well-typed program. <p> a program P iff 1. the query Q is simply moded (namely it is output-free); 2. for j 2 [1; m] and for any input-correct and output-free instance B j ff of B j , there exists a clause in P whose head unifies with B j ff. 2 In <ref> [8] </ref> we also proved the "persistency" of the noFD property through LD-derivation and the main result on absence of FDs. Lemma 2.5 Let P be a noFD program and Q a noFD query in P . <p> The query Q 0 is also noFD. 2 Theorem 2.6 Let P be a noFD program and Q a noFD query in P . Then Q cannot have finitely failing derivations. 2 3 3 Successful Programs In <ref> [8] </ref> we have seen how using tests in a program prevents it to be noFD. Tests predicates sometimes produce inefficiency, as in generate-and-test programs, and then it is better to avoid them. But more often they are necessary, as in a sorting algorithm.
Reference: [9] <author> A. Bossi and N. Cocco. </author> <title> Successful Logic Programs. </title> <type> Technical Report CS298, </type> <institution> CS Dept. - Venice University, </institution> <month> February </month> <year> 1998. </year>
Reference-contexts: For this reason also (1) in the introduction is a successful predicate. For successful predicates we can prove that any noFD query which universally terminates has at least one successful derivation. The proof is in <ref> [9] </ref>. Theorem 3.4 Let Q be a noFD query in P .
Reference: [10] <author> A. Bossi, N. Cocco, and S. Etalle. </author> <title> Transformation of Left Terminating Programs: The Reordering Problem. </title> <editor> In M. Proietti, editor, </editor> <booktitle> Proceedings LOPSTR'95, volume 1048 of Lecture Notes in Computer Science, </booktitle> <pages> pages 33-45. </pages> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1996. </year>
Reference-contexts: Also in the field of program transformations being successful can be useful in particular for switching atoms in the clause bodies. In <ref> [10] </ref> we consider left-terminating programs [6] and we define a sufficient condition for switching atoms while preserving left-termination. <p> But if we prove that the query A is universally terminating and noFD and the predicate in A is successful, then the non-failing condition is guaranteed. Example 4.8 Let us consider an example of transformation given in <ref> [10] </ref>. <p> The directional types are path (+ : Const; : List); goodlist (+ : List); goodpath (+ : Const; : List), arc (+ : Const; : Const), good (+ : Const). The predicates good and arc are test predicates defined in the program. In <ref> [10] </ref> we consider a transformation which repeatedly unfold the body atoms in d until we get to: 7 d1:goodpath (X, [X]) good (X). d2:goodpath (X, [X jXs]) arc (X, Y), path (Y, Xs), good (X), goodlist (Xs).
Reference: [11] <author> A. Bossi, N. Cocco, and M. Fabris. </author> <title> Norms on terms and their use in proving universal termination of a logic program. </title> <journal> Theoretical Computer Science, </journal> <volume> 124 </volume> <pages> 297-328, </pages> <year> 1994. </year>
Reference-contexts: 1 Introduction When developing a logic program we, more or less explicitly, have to analize it with respect to correctness, termination properties and the existence of successful computations. On correctness and termination verification there have been rather many proposals such as <ref> [15, 7, 3, 11, 6, 18] </ref>. While for distinguishing failing and successful computations or for ensuring the presence of successes in a computation, very little is available, both in terms of methodology and tools.
Reference: [12] <author> J. Boye and J. Maluszynski. </author> <title> Two Aspects of Directional Types. </title> <editor> In Sterling, editor, </editor> <booktitle> Proc. Int'l Conf. on Logic Programming, </booktitle> <pages> pages 747-761. </pages> <publisher> MIT Press, </publisher> <year> 1995. </year>
Reference-contexts: For example, app (+ : List; + : List; : List) denotes a ternary relation app with the first two positions moded as input and typed as List and the third position moded as output and typed as List. A similar denotation is called a directional type in <ref> [12] </ref>. From [5, 2] we take also the notion of well-typed query and program and from [4] the notion of simply moded clause and query. A complete treatment of these topics can be found in [3]. Besides we need the following definitions.
Reference: [13] <author> F. Bronsard, T. K. Lakshman, and U. S. Reddy. </author> <title> A framework of directionalities for proving termination of logic programs. </title> <editor> In K. R. Apt, editor, </editor> <booktitle> Proceedings of the Joint International Conference and Symposium on Logic Programming, </booktitle> <pages> pages 321-335. </pages> <publisher> The MIT Press, </publisher> <year> 1992. </year> <month> 8 </month>
Reference-contexts: In section 4 we describe a methodology for verifying that a predicate is successful. 2 2 Basic Notions The notation is more or less standard and essentially follows [17, 1]. We make use of the notion of modes and types introduced in <ref> [13, 5, 2] </ref>. We consider a combination of modes and types and adopt the following assumption: every considered relation has a fixed mode and a fixed type associated with it. This assumption allows us to talk about types of input positions and of output positions of an atom.
Reference: [14] <author> S. Debray, P. Lopez-Garcia, and M.Hermenegildo. </author> <title> Non-Failure Analysis for Logic Programs. </title> <booktitle> In Proceedings of the International Symposium on Logic Programming, </booktitle> <pages> pages 48-62, </pages> <year> 1997. </year>
Reference-contexts: Also this program can have FDs since it contains arithmetic tests, namely X &lt; Z and X &gt;= Y . But they are also exaustive on the input types; then, as in the previous example, it can be queried with at least one successful derivation. In <ref> [14] </ref> a non-failure analysis is presented which captures these cases. It is undecidable in general if some tests "cover" a type, but for unification or arithmetic tests a sofisticated algorithm is supplied, which makes use of Abstract Interpretation techniques. A report on its implementation is also given. <p> It is undecidable in general if some tests "cover" a type, but for unification or arithmetic tests a sofisticated algorithm is supplied, which makes use of Abstract Interpretation techniques. A report on its implementation is also given. In the present work we try to extend the results in <ref> [8, 14] </ref> with a methodological attitude. We study a sufficient condition for ensuring that a universally terminating query has at least one successful derivation in a given program. <p> The property of having exaustive tests is a semantic condition and not decidable in general, as shown in <ref> [14] </ref>, but in most practical cases the conditions in Definition 4.6 can be easily verified. In order to make easier to prove the property of being exaustive tests for a predicate, it is often useful to "simplify" the set of clauses we consider.
Reference: [15] <author> W. Drabent and J. Maluszynski. </author> <title> Inductive assertion method for logic programs. </title> <journal> Theoretical Computer Science, </journal> <volume> 59 </volume> <pages> 133-155, </pages> <year> 1988. </year>
Reference-contexts: 1 Introduction When developing a logic program we, more or less explicitly, have to analize it with respect to correctness, termination properties and the existence of successful computations. On correctness and termination verification there have been rather many proposals such as <ref> [15, 7, 3, 11, 6, 18] </ref>. While for distinguishing failing and successful computations or for ensuring the presence of successes in a computation, very little is available, both in terms of methodology and tools.
Reference: [16] <author> F. Henderson, T. Conway, Z.Somogyi, and D. Jeffery. </author> <title> The Mercury language reference manual. </title> <type> Technical Report TR 96/10, </type> <institution> Dep. of Computer Science, University of Melbourne, </institution> <year> 1996. </year>
Reference-contexts: Technical Report Series, Department of Computer Science, University of Manchester, ISSN 1361-6161. Report number UMCS-98-6-1. http://www.cs.man.ac.uk/cstechrep/titles98.html 1 successful programs. In the Mercury language <ref> [16] </ref> a nondeterminism analysis is implemented which has some analogies with our work.
Reference: [17] <author> J. W. Lloyd. </author> <title> Foundations of Logic Programming. </title> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1987. </year> <note> Second edition. </note>
Reference-contexts: We can prove that a universally terminating noFD query, defined by successful predicates, has at least one successful LD-derivation. In section 4 we describe a methodology for verifying that a predicate is successful. 2 2 Basic Notions The notation is more or less standard and essentially follows <ref> [17, 1] </ref>. We make use of the notion of modes and types introduced in [13, 5, 2]. We consider a combination of modes and types and adopt the following assumption: every considered relation has a fixed mode and a fixed type associated with it.
Reference: [18] <author> D. De Schreye and S. Decorte. </author> <title> Termination of Logic Programs: the never-ending story. </title> <journal> Journal of Logic Programming, </journal> <volume> 19-20:199-260, </volume> <year> 1994. </year> <month> 9 </month>
Reference-contexts: 1 Introduction When developing a logic program we, more or less explicitly, have to analize it with respect to correctness, termination properties and the existence of successful computations. On correctness and termination verification there have been rather many proposals such as <ref> [15, 7, 3, 11, 6, 18] </ref>. While for distinguishing failing and successful computations or for ensuring the presence of successes in a computation, very little is available, both in terms of methodology and tools.
References-found: 18

