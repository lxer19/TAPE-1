URL: ftp://ftp.sics.se/pub/SICS-reports/Reports/SICS-R--91-10--SE.ps.Z
Refering-URL: http://www.sics.se/libindex.html
Root-URL: 
Note: Abstract 1 1 Introduction 2 2 Definitions and GCLA 2 2 1 Inductive definitions 2 2 2 Partial inductive definitions (PID) 4 2 3 GCLA (Generalized horn Clause LAnguage) 7 2 4 An example: A toy expert system 9 3 Functional definitions 10 3 1 The definition 11 3 2 Ordering the rules 11 3 3 Some queries 12 3 4 Making the definition complete 13 4 Mixing functional definitions and relational programming 14 4 1 Example 1: Qsort 14 4 2 Example 2: Functional If-Then-Else 16 5 Conclusion 17 6 References 18  
Abstract-found: 0
Intro-found: 1
Reference: [Aro89] <author> Martin Aronsson; GAM, </author> <title> An Abstract Machine for GCLA, </title> <institution> Research Report SICS R89002, Swedish Institute of Computer Science, </institution> <year> 1989 </year>
Reference-contexts: We hope that the control structure presented in [Kre91] will be able to deal with this kind of behaviour. 10 We have found this technique very useful, and among other things implemented a version of the planning system STRIPS [G&N], <ref> [Aro89] </ref>, where an action is seen as a function from one state to another. <p> All examples given in this paper have been executed by our GCLA system, at the moment an interpreter written in Prolog. We have also implemented an earlier version of GCLA on top of an experimental abstract machine <ref> [Aro89] </ref>, which was based on the WAM, and that implementation suggested that ordinary Prolog queries could be executed in GCLA in about 50 % of a traditional WAM implementation of Prolog.
Reference: [Aro90a] <author> Martin Aronsson, Lars-Henrik Eriksson, Anette Gredal, Lars Hallns, </author> <title> Peter Olin; The programming Language GCLA: A Definitional Approach to Logic Programming, </title> <booktitle> New Generation Computing 7(4), </booktitle> <pages> pp 381 - 404, </pages> <year> 1990 </year> <month> 13 </month>
Reference-contexts: The theory of partial inductive definitions is a generalization of the theory of inductive definitions, to which the ability to make assumptions has been added. We give a short introduction to these ideas, as well as the language GCLA <ref> [Aro90a, Aro90b] </ref>, which is based on the theory of partial inductive definitions. We will refer to programs based on SLD resolution as relational programs, since the term logic programs refers to a larger set of languages, including GCLA. <p> Definitions and GCLA Section 2.1 and 2.2 borrow from the ideas put forth in a research report [EH88] written by Lars-Henrik Eriksson and Lars Hallns. We will keep this description informal and short. The interested reader is referred to <ref> [HS-H88, Aro90a, Hal87] </ref> for more detailed explanations. 2 . 1 . Inductive definitions An inductive definition specifies the members of a set in terms of other members of the same set. A typical example of an inductive definition is fl is a list. <p> Program example 1: A toy knowledge base 6 As an example, consider the definition below, which implements a small expert system (This example can also be found in <ref> [Aro90a] </ref>). Note that the definition itself does not contain any trivial rules, only rules for drawing conclusions from certain given data. disease (cold) &lt;= symptom (cough),temp (normal). disease (pneumonia) &lt;= symptom (persistent_cough),symptom (chill),temp (high).
Reference: [Aro90b] <author> Martin Aronsson, Lars-Henrik Eriksson, Lars Hallns, </author> <title> Per Kreuger; A Survey of GCLA: A Definitional Approach to Logic Programming, </title> <booktitle> Extensions of Logic Programming: Proceedings of a workshop held at the SNS, </booktitle> <address> Universitt Tbingen, </address> <month> 8-9 December, </month> <year> 1989. </year> <booktitle> Springer Lecture Notes in Artificial Intelligence </booktitle>
Reference-contexts: The theory of partial inductive definitions is a generalization of the theory of inductive definitions, to which the ability to make assumptions has been added. We give a short introduction to these ideas, as well as the language GCLA <ref> [Aro90a, Aro90b] </ref>, which is based on the theory of partial inductive definitions. We will refer to programs based on SLD resolution as relational programs, since the term logic programs refers to a larger set of languages, including GCLA. <p> For each rule in the theory of partial inductive definitions, there is a corresponding rule in GCLA, which together with a given search strategy forms a system for proving statements. For a complete description of GCLA, the reader is referred to <ref> [Aro90b, HS-H88] </ref>. One big difference between GCLA and partial inductive definitions is that GCLA has the notion of variables. <p> This is accomplished by a general scheme implementing a control structure, which makes it possible to guide the execution. It is beyond the scope of this paper to describe this control structure, the interested reader is referred to <ref> [Aro90b] </ref> or [Kre91]. We will describe where necessary what effect the structure impose on the execution. It should however be stressed that the general control structure we are talking about here has a clear and well defined semantics [Kre91].
Reference: [DG-L86] <author> D. DeGroot, G. </author> <title> Lindstrom; Logic Programming, Functions Relations and Equations, </title> <publisher> Prentice-Hall, </publisher> <year> 1986 </year>
Reference-contexts: 1. Introduction Traditionally, logic programming and functional programming are two separated branches of computer science. The effort spent on merging these two often tend to simply incorporate one branch into the other. For some examples see <ref> [DG-L86] </ref>. As another approach, we use the notion of partial inductive definitions [Hal87] to represent both relations and functions in the same framework. The theory of partial inductive definitions is a generalization of the theory of inductive definitions, to which the ability to make assumptions has been added.
Reference: [EH-88] <author> Lars-Henrik Eriksson, </author> <title> Lars Hallns; A Programming Calculus Based on Partial Inductive Definitions, </title> <institution> Research Report SICS R88013, Swedish Institute of Computer Science, </institution> <year> 1988 </year>
Reference: [Fre90] <editor> Daniel Fredholm; On Function Definitions. </editor> <title> Basic notions and primitive recursive function definitions I, </title> <type> Ph L thesis, </type> <institution> Programming Methodology Group, Chalmers University of Technology, Gteborg </institution>
Reference-contexts: Functional definitions We will now consider how functional definitions can be written in GCLA. A more thorough description of functional definitions and their theoretic properties can be found in <ref> [Fre90] </ref>. We will here concentrate on how these definitions can be utilized and executed. The description will be informal.
Reference: [HS-H88] <author> Lars Hallns, </author> <title> Peter Schroeder-Heister; A Proof-Theoretic Approach to Logic Programming, </title> <journal> Journal of Logic and Computation, </journal> <year> 1990 </year>
Reference-contexts: Definitions and GCLA Section 2.1 and 2.2 borrow from the ideas put forth in a research report [EH88] written by Lars-Henrik Eriksson and Lars Hallns. We will keep this description informal and short. The interested reader is referred to <ref> [HS-H88, Aro90a, Hal87] </ref> for more detailed explanations. 2 . 1 . Inductive definitions An inductive definition specifies the members of a set in terms of other members of the same set. A typical example of an inductive definition is fl is a list. <p> For each rule in the theory of partial inductive definitions, there is a corresponding rule in GCLA, which together with a given search strategy forms a system for proving statements. For a complete description of GCLA, the reader is referred to <ref> [Aro90b, HS-H88] </ref>. One big difference between GCLA and partial inductive definitions is that GCLA has the notion of variables.
Reference: [Hal87] <editor> Lars Hallns; Partial inductive definitions, in A. Avron et. al., editor, </editor> <title> Workshop on General Logic, </title> <type> Report ECS-LFCS-88-52. </type> <institution> Department of Computer Science, University of Edinburgh, </institution> <year> 1987. </year> <note> Also published as Research Report SICS R86005C by the Swedish Institute of Computer Science, 1988. A revised version to appear in Theoretical Computer Science. </note>
Reference-contexts: 1. Introduction Traditionally, logic programming and functional programming are two separated branches of computer science. The effort spent on merging these two often tend to simply incorporate one branch into the other. For some examples see [DG-L86]. As another approach, we use the notion of partial inductive definitions <ref> [Hal87] </ref> to represent both relations and functions in the same framework. The theory of partial inductive definitions is a generalization of the theory of inductive definitions, to which the ability to make assumptions has been added. <p> Definitions and GCLA Section 2.1 and 2.2 borrow from the ideas put forth in a research report [EH88] written by Lars-Henrik Eriksson and Lars Hallns. We will keep this description informal and short. The interested reader is referred to <ref> [HS-H88, Aro90a, Hal87] </ref> for more detailed explanations. 2 . 1 . Inductive definitions An inductive definition specifies the members of a set in terms of other members of the same set. A typical example of an inductive definition is fl is a list. <p> For brevity, we will often say that "e is derivable" when we really mean that "- e" is derivable. 2 . 2 . Partial inductive definitions (PID) We will now generalize the concept of an inductive definition to that of a "partial inductive definition" <ref> [Hal87] </ref>. A clause e E expresses the fact that e holds under the assumption that all e' E hold. So far we have only been permitted to state such facts.
Reference: [Hen89] <editor> Pascal Van Hentenryck; Constraint Satisfaction in Logic Programming, </editor> <publisher> MIT Press, MIT, </publisher> <address> Cambridge, USA </address>
Reference-contexts: Typically, guards contain a restriction that various variables should differ from various templates. The variables are constrained for the rest of the execution with the restrictions, c.f. constraint programming and domain variables <ref> [Hen89] </ref>. The inference rules can be tried in various orders, which can be determined by the user, and for certain goals various rules can be applied.
Reference: [Kre91] <author> Per Kreuger, GCLAII: </author> <title> A Definitional Approach to Control, </title> <note> SICS Research Report in preparation </note>
Reference-contexts: This is accomplished by a general scheme implementing a control structure, which makes it possible to guide the execution. It is beyond the scope of this paper to describe this control structure, the interested reader is referred to [Aro90b] or <ref> [Kre91] </ref>. We will describe where necessary what effect the structure impose on the execution. It should however be stressed that the general control structure we are talking about here has a clear and well defined semantics [Kre91]. <p> paper to describe this control structure, the interested reader is referred to [Aro90b] or <ref> [Kre91] </ref>. We will describe where necessary what effect the structure impose on the execution. It should however be stressed that the general control structure we are talking about here has a clear and well defined semantics [Kre91]. A control mechanism that needs to be mentioned is the ability to restrict terms from being applicable by the D-rules. <p> Typically, the query add (X,0) "- s (0) will, after the answer X = s (0), go into an infinite loop where the system tries X = s (s (0)), X = s (s (s (0))), etc. We hope that the control structure presented in <ref> [Kre91] </ref> will be able to deal with this kind of behaviour. 10 We have found this technique very useful, and among other things implemented a version of the planning system STRIPS [G&N], [Aro89], where an action is seen as a function from one state to another. <p> Conclusion We have presented what a functional definition is, and how it can be used for both eager and lazy evaluation. It is possible to define other computation strategies as well, although we have not presented that here (see <ref> [Kre91] </ref> for a detailed description). We have also demonstrated how simple equation solving can be performed, and how a functions inverse can be defined in terms of the function itself. GCLA is expressive enough to express both functional and relational programs within the same framework.
References-found: 10

