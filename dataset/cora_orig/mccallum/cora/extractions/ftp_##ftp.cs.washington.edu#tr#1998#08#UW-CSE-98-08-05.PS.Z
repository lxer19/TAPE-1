URL: ftp://ftp.cs.washington.edu/tr/1998/08/UW-CSE-98-08-05.PS.Z
Refering-URL: http://www.cs.washington.edu/research/tr/tr-by-date.html
Root-URL: http://www.cs.washington.edu
Email: famir,notking@cs.washington.edu  
Title: Assessing Software Libraries by Browsing Similar Classes, Functions, and Relationships  
Author: Amir Michail and David Notkin 
Keyword: Software libraries, reuse, assessment, information retrieval  
Address: Box 352350 Seattle, WA 98195-2350, USA  
Affiliation: Dept. of Computer Science and Engineering University of Washington,  
Pubnum: Technical Report UW-CSE-98-08-05  
Abstract: Comparing and contrasting a set of software libraries is useful for reuse related activities such as selecting a library from among several candidates or porting an application from one library to another. The current state of the art in assessing libraries relies on qualitative methods. In particular, the developer manually inspects each library, reads the documentation, examines the architecture, considers subjective scenarios, and other available information. To reduce costs and/or assess a large collection of libraries, automation is necessary. Although there are tools that help a developer examine an individual library in terms of architecture, style, etc., we know of no tools that help the developer directly compare several libraries. With existing tools, the user must manually integrate the knowledge learned about each library. Automation to help developers directly compare and contrast libraries requires matching of similar components (such as classes and functions) across libraries and various relationships (such as inheritance and invocation) between them. This is different than the traditional component retrieval problem in which components are returned that best match a user's query. Rather, we need to find those components and relationships that are similar across the libraries under consideration. In this paper, we show how this kind of matching can be done. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> T. J. Biggerstaff. </author> <title> Design Recovery for Maintenance and Reuse. </title> <journal> Computer, </journal> <volume> 22(7) </volume> <pages> 36-49, </pages> <year> 1989. </year>
Reference-contexts: To reduce costs and/or assess a large collection of libraries, automation is necessary. Although there are tools that help a developer examine an individual library in terms of architecture, style, etc. <ref> [1, 10, 13, 18] </ref>, we know of no tools that help the developer directly compare several libraries. With existing tools, the user must manually integrate the knowledge learned about each library. <p> Section 8 summarizes the work, concluding with a number of open questions. 2 RELATED WORK As mentioned earlier, we know of no tools that help a developer directly compare several libraries. With existing tools <ref> [1, 10, 13, 18] </ref>, the developer must manually integrate the knowledge learned about each library. Yet, the problem of finding similar components across libraries appears equivalent to the traditional component retrieval problem in which components are returned that best match a user's query. This is only partially true.
Reference: [2] <author> P. Chen, R. Hennicker, and M. Jarke. </author> <title> On the Retrieval of Reusable Software Components. </title> <booktitle> In 2nd International Workshop on Software Reusability), </booktitle> <pages> pages 99-108. </pages> <publisher> IEEE, </publisher> <year> 1993. </year>
Reference-contexts: But name matching alone is not enough. It is still possible that some important concept is represented by components with completely different names in the libraries. For this reason, we consider well-known component retrieval techniques such as free-text indexing [5], facets [14], and formal specifications <ref> [2] </ref>. However, since we are interested in automated techniques that do not require domain analysis or formal specifications in the code, we exclude facets and formal specifications from our discussion.
Reference: [3] <author> W. B. Croft and D. J. Harper. </author> <title> Using Probabilistic Models of Document Retrieval Without Relevance Information. </title> <journal> Documentation, </journal> <volume> 35(4) </volume> <pages> 285-295, </pages> <year> 1979. </year>
Reference-contexts: Let N denote the total number of components in the library, and let df (t) denote the number of components containing 5 term t. We use the following definition for idf (t), which is decreasing in df (t), as proposed in <ref> [3] </ref>: idf (t) = log 2 N 1 : Within-Document Weight The within-document weight wdw i (t) indicates how important term t is in a particular component.
Reference: [4] <author> W. B. Frakes and R. S. Baeza-Yates, </author> <title> editors. Information Retrieval: Data Structures and Algorithms. </title> <publisher> Pren-tice Hall, </publisher> <year> 1992. </year>
Reference-contexts: The free-text indexing method simply uses the text in the libraries (and not just the component names) for indexing using standard information retrieval techniques <ref> [4] </ref>. No manual domain analysis is required. However, researchers have observed that this method works well with libraries that include extensive documentation with the components, such as Unix man pages [6, 11]. <p> And as mentioned earlier, we simply say class and function to mean class family and function family, respectively. We define a similarity measure that indicates how closely two components are related. The ideas in this section borrow heavily from the field of information retrieval <ref> [4] </ref>, where similarity measures are used to rank documents returned by a query in order of relevance. In our case, there is no query per se, but we view components as documents D i and compute the similarity between components in one library with components in another.
Reference: [5] <author> W. B. Frakes and B. A. Nejmeh. </author> <title> Software Reuse through Information Retrieval. </title> <booktitle> In 20th Hawaii International Conference on System Sciences, </booktitle> <pages> pages 530-535. </pages> <publisher> IEEE, </publisher> <year> 1987. </year>
Reference-contexts: The name matching method matches those components that have the same standardized name in each library. The similarity matching method uses more conventional information retrieval techniques and is similar to that used in component retrieval tools based on free-text indexing <ref> [5, 8, 11] </ref>. In this paper we shall be concerned with components that are classes or functions. To simplify the exposition, we will just say component whenever the discussion applies to both classes and functions. <p> But name matching alone is not enough. It is still possible that some important concept is represented by components with completely different names in the libraries. For this reason, we consider well-known component retrieval techniques such as free-text indexing <ref> [5] </ref>, facets [14], and formal specifications [2]. However, since we are interested in automated techniques that do not require domain analysis or formal specifications in the code, we exclude facets and formal specifications from our discussion.
Reference: [6] <author> W. B. Frakes and T. </author> <title> Pole. An Empirical Study of Representation Methods for Reusable Software Components. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 20(8) </volume> <pages> 617-630, </pages> <year> 1994. </year>
Reference-contexts: No manual domain analysis is required. However, researchers have observed that this method works well with libraries that include extensive documentation with the components, such as Unix man pages <ref> [6, 11] </ref>. Only then can one rely on regularities in the text such as relative word frequencies or lexical affinities [11]. However, it has also been suggested that one can combine library documentation with structural information that can be extracted from the source such as inheritance relationships [8].
Reference: [7] <author> E. Gamma, R. Helm, R. Johnson, and J. Vlissides. </author> <title> Design Patterns: Elements of Reusable Object-Oriented Software. </title> <publisher> Addison-Wesley, </publisher> <year> 1995. </year>
Reference-contexts: We extract these relationships from the source not only for the purpose of matching across libraries but also because they are used in computing the similarity measure for similarity matching. Inheritance and Composition The two most common techniques for reuse in object-oriented libraries are class inheritance and composition <ref> [7, p. 18] </ref>. When using inheritance, a class A inherits from some class B.
Reference: [8] <author> R. Helm and Y. S. Maarek. </author> <title> Integrating Information Retrieval and Domain Specific Approaches for Browsing and Retrieval in Object-Oriented Class Libraries. </title> <booktitle> In OOPSLA, </booktitle> <pages> pages 47-61, </pages> <year> 1991. </year>
Reference-contexts: The name matching method matches those components that have the same standardized name in each library. The similarity matching method uses more conventional information retrieval techniques and is similar to that used in component retrieval tools based on free-text indexing <ref> [5, 8, 11] </ref>. In this paper we shall be concerned with components that are classes or functions. To simplify the exposition, we will just say component whenever the discussion applies to both classes and functions. <p> Only then can one rely on regularities in the text such as relative word frequencies or lexical affinities [11]. However, it has also been suggested that one can combine library documentation with structural information that can be extracted from the source such as inheritance relationships <ref> [8] </ref>. Rather than restrict the kinds of libraries that can be com pared and contrasted, we have decided not to rely on component documentation. <p> Consequently, we do not look for regularities in the text; rather, we define a similarity measure that makes heavy use of structural information (and in a more extensive manner than <ref> [8] </ref>). We describe our similarity measure in Section 5. 3 INFORMATION EXTRACTION In this section, we describe the components and relationships that we extract from the library source code.
Reference: [9] <author> R. Kazman, L. Bass, G. Abowd, and M. Webb. </author> <month> SAAM: </month>
Reference-contexts: This may take the form of informal tips for selecting frameworks [16] or a complete analysis method, such as SAAM <ref> [9] </ref>. Either way, the developer manually inspects each library, reads the documentation, examines the architecture, considers subjective scenarios, and other available information. To reduce costs and/or assess a large collection of libraries, automation is necessary.
References-found: 9

