URL: ftp://theory.lcs.mit.edu/pub/classes/6.892/handouts/22-spbags.ps.gz
Refering-URL: http://theory.lcs.mit.edu/classes/6.892/handouts.html
Root-URL: 
Email: fengmd@theory.lcs.mit.edu  
Title: Efficient Detection of Determinacy Races in Cilk Programs (Draft)  
Author: Mingdong Feng Charles E. Leiserson 
Note: This research was supported in part by the Defense AdvancedResearchProjects Agencyunder Grant N00014-94-1-0985. Ming-dong Feng did this work as a Postdoctoral Fellow in the MIT Laboratory for Computer Science. Parallel computing facilities were provided by the MIT Xolas Project through a generous donation by Sun Microsystems, Inc.  
Date: January 17, 1997  
Address: 10 Lower Kent Ridge Road Republic of Singapore 119260  545 Technology Square Cambridge, MA 02139 USA  
Affiliation: Department of ISCS National University of Singapore  MIT Laboratory for Computer Science  
Abstract: A parallel multithreaded program that is ostensibly deterministic may nevertheless behave nonde-terministically due to bugs in the code. These bugs are called determinacy races, and they result when one thread updates a location in shared memory while another thread is concurrently accessing the location. We have implemented a provably efficient determinacy-race detector for Cilk, an algorithmic mul-tithreaded programming language. If a Cilk program run on a given input data set has a determinacy race, our debugging tool, which we call the Nondeterminator, guarantees to detect and localize the race. The core of the Nondeterminator is an asymptotically efficient serial algorithm (inspired by Tarjan's nearly linear-time least-common-ancestors algorithm) for detecting determinacy races in series-parallel dags (directed acyclic graphs). For a Cilk program that runs in T time on one processor and uses v shared-memory locations, the Nondeterminator runs in O(T ff(v; v)) time, where ff is Tarjan's functional inverse of Ackermann's function, a very slowly growing function which, for all practical purposes, is bounded above by 4. The Nondeterminator uses at most a constant factor more space than does the original program. On a variety of Cilk program benchmarks, the Nondeterminator exhibits a slowdown of less than 12 compared with the serial execution time of the original optimized code, which we contend is an ac ceptable slowdown for debugging purposes. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> A. V. Aho, J. E. Hopcroft, and J. D. Ullman. </author> <title> On finding lowest common ancestor in trees. </title> <journal> SIAM Journal on Computing, </journal> <volume> 5(1) </volume> <pages> 115-132, </pages> <month> March </month> <year> 1976. </year>
Reference-contexts: The attraction of Tarjan's algorithm, as opposed to existing linear-time algorithms and the seminal algorithm given by Aho, Hopcroft, and Ullman <ref> [1] </ref>, is that it operates, in Mellor-Crummey's words [12], on the fly. That is, the least common ancestors can be queried during a simple tree walk without ever requiring the entire tree to be expanded at any time.
Reference: [2] <author> T. R. Allen and D. A. Padua. </author> <title> Debugging Fortran on a shared memory machine. </title> <booktitle> In Proceedings of the 1987 International Conference on Parallel Processing, </booktitle> <pages> pages 721-727, </pages> <month> August </month> <year> 1987. </year>
Reference-contexts: Static analysis of parallel programs to uncover nondeterminacy has been studied extensively, for example, in [9, 13]. Various systems have been developed for determinacy-race detection that do not allow nested parallelism, as for example <ref> [2] </ref>. We now review related work on determinacy-race detection for programs with nested parallelism.
Reference: [3] <author> A. J. Bernstein. </author> <title> Analysis of programs for parallel processing. </title> <journal> IEEE Transactions on Electronic Computers, </journal> <volume> EC-15(5):757-763, </volume> <month> October </month> <year> 1966. </year>
Reference-contexts: The total number of actions (spawns, syncs, returns, shared reads, and shared writes) is given, along with the average overhead of the Nondetermi-nator for each action and the fraction of accesses that hit the Nondeterminator's software cache. Bernstein <ref> [3] </ref> identifies determinacy races as a cause of nondeterministic behavior. Netzer and Miller [15] present a formal model for understanding race conditions in parallel programs, distinguishing determinacy races from atomicity races. They reference several algorithms for atomicity-race detection, but we do not discuss this type of race detection here.
Reference: [4] <author> Robert D. Blumofe, Matteo Frigo, Chrisopher F. Joerg, Charles E. Leiserson, and Keith H. Randall. </author> <title> An analysis of dag-consistent distributed shared-memory algorithms. </title> <booktitle> In Proceedings of the Eighth Annual ACM Symposium on Parallel Algorithms and Architectures (SPAA), </booktitle> <pages> pages 297-308, </pages> <address> Padua, Italy, </address> <month> June </month> <year> 1996. </year>
Reference-contexts: We have started investigating a parallel scheme in which each of several processors executing the program uses the SP-bags algorithm locally, but when a remote child procedure returns, it reconciles its shadow spaces in a manner similar to the BACKER algorithm <ref> [4] </ref> for maintaining dag consistency. Such a result may be mostly of theoretical interest, however, since debugging is usually done in the development phase of a program using small data sets, and thus typically, the performance of the debugger is not a crucial concern.
Reference: [5] <author> Robert D. Blumofe, Christopher F. Joerg, Bradley C. Kuszmaul, Charles E. Leiserson, Keith H. Randall, and Yuli Zhou. Cilk: </author> <title> An efficient multithreaded runtime system. </title> <booktitle> In Proceedings of the Fifth ACM SIGPLAN Symposium on Principles and Practice of Parallel Programming (PPoPP), </booktitle> <pages> pages 207-216, </pages> <address> Santa Barbara, California, </address> <month> July </month> <year> 1995. </year>
Reference-contexts: 1 Introduction Cilk <ref> [5, 20] </ref> is an algorithmic multithreaded programming language whose threads can concurrently access (read or write) shared memory without blocking. Many Cilk programs are intended to be deterministic, in that a given program produces the same behavior no matter how its threads are scheduled.
Reference: [6] <author> Thomas H. Cormen, Charles E. Leiserson, and Ronald L. Rivest. </author> <title> Introduction to Algorithms. </title> <publisher> The MIT Press and McGraw-Hill Book Company, </publisher> <year> 1990. </year>
Reference-contexts: Like Tarjan's algorithm, the SP-bags algorithm uses an efficient data structure <ref> [6, Chapter 22] </ref> to manage disjoint sets of elements. Figure 6 compares the asymptotic time and space for the SP-bags algorithm with other race-detection algorithms in the literature. The remainder of this paper is organized as follows. Section 2 presents the SP-bags algorithm that underlies the Nondeterminator's runtime system. <p> The SP-bags algorithm updates the shadow spaces as it executes. The SP-bags algorithm uses the fast disjoint-set data structure <ref> [6, Chapter 22] </ref> analyzed by Tarjan [21]. The data structure maintains a dynamic collection of disjoint sets and provides three elementary operations: Make-Set (x): [ ffxgg. Union (X; Y ): fX; Y g [ fX [ Y g. The sets X and Y are destroyed. <p> Each e corresponds to a thread of the Cilk procedure, and each F corresponds to a spawned subprocedure. program. Specifically, an ordinary depth-first tree walk (see <ref> [6, p. 245] </ref>) of the parse tree visits the threads of the computation in the same order as the threads are encountered when the Cilk program is executed in a depth-first (C-like) fashion on a single processor. 4 Correctness of the SP-bags algorithm In this section, we prove the correctness of
Reference: [7] <author> Anne Dinning and Edith Schonberg. </author> <title> An empirical comparison of monitoring algorithms for access anomaly detection. </title> <booktitle> In Proceedings of the Second ACM SIGPLAN Symposium on Principles & Practice of Parallel Programming (PPoPP), </booktitle> <pages> pages 1-10. </pages> <publisher> ACM Press, </publisher> <year> 1990. </year>
Reference-contexts: This paper describes a system we call the Nondeterminator to detect determinacy races in Cilk programs. Determinacy races have been given many different names in the literature. For example, they are sometimes called access anomalies <ref> [7] </ref>, data races [12], race conditions [19], or harmful shared-memory accesses [16]. <p> mean procedure instance, that is, the runtime state of the procedure. 6 Feng and Leiserson Time Algorithm Thread creation Per access Space and termination SP-bags O (ff (v; v)) O (ff (v; v)) O (v) English-Hebrew labeling [16] O (p) O (pt) O (vt + min (np; vtp)) Task recycling <ref> [7] </ref> O (t) O (t) O (vt + t 2 ) Offset-span labeling [12] O (p) O (p) O (v + min (np; vp)) v = number of shared locations being monitored p = maximum depth of nested parallelism t = maximum number of logical concurrent threads n = number of <p> To determine whether two threads operate logically in parallel, a comparison of the labels of two threads suffices. Dinning and Schonberg <ref> [7] </ref> improve the performance of the English-Hebrew labeling algorithm by task recycling, but at the cost of failing to detect some determinacy races. Each thread (task) has a unique task identifier, and a version number.
Reference: [8] <author> R. J. Duffin. </author> <title> Topology of series-parallel networks. </title> <journal> Journal of Mathematical Analysis and Applications, </journal> <volume> 10 </volume> <pages> 303-318, </pages> <year> 1965. </year>
Reference-contexts: Also, the worst-case bounds can be easily improved if they are expressed using more detailed parameters than T and v. 3 Series-parallel dags Series-parallel dags [23] are a straightforward extension of the notion of series-parallel graphs <ref> [8, 11, 17] </ref>. In this section, we review basic properties of series-parallel dags and show how a Cilk program execution corresponds to a series-parallel dag. These properties will be used in Section 4 to prove the correctness of the SP-bags algorithm. We first define various relationships among Cilk threads.
Reference: [9] <author> Perry A. Emrath and Davis A. Padua. </author> <title> Automatic detection of nondeterminacy in parallel programs. </title> <booktitle> In Proceedings of the Workshop on Parallel and Distributed Debugging, </booktitle> <pages> pages 89-99, </pages> <address> Madison, Wiscon-sin, </address> <month> May </month> <year> 1988. </year>
Reference-contexts: Emrath and Padua <ref> [9] </ref> call a deterministic program internally deterministic if the program execution on the given input exhibits no deter-minacy race and externally deterministic if the program has determinacy races but its output is deterministic because of the communicative and associative operations performed on the shared locations. <p> They reference several algorithms for atomicity-race detection, but we do not discuss this type of race detection here. Static analysis of parallel programs to uncover nondeterminacy has been studied extensively, for example, in <ref> [9, 13] </ref>. Various systems have been developed for determinacy-race detection that do not allow nested parallelism, as for example [2]. We now review related work on determinacy-race detection for programs with nested parallelism.
Reference: [10] <author> Dov Harel and Robert Endre Tarjan. </author> <title> Fast algorithms for finding nearest common ancestors. </title> <journal> SIAM Journal on Computing, </journal> <volume> 13(2) </volume> <pages> 338-355, </pages> <month> May </month> <year> 1984. </year>
Reference-contexts: Such a result may be mostly of theoretical interest, however, since debugging is usually done in the development phase of a program using small data sets, and thus typically, the performance of the debugger is not a crucial concern. Linear-time algorithms for the least-common-ancestors algorithm exist in the literature <ref> [10, 18] </ref>, and it is natural to wonder whether a determinacy-race detector exists that operates in linear time, instead of the almost-linear-time performance of the SP-bags algorithm.
Reference: [11] <author> P. A. MacMahon. </author> <title> The combination of resistances. </title> <booktitle> The Electrician, </booktitle> <month> April 1892. </month>
Reference-contexts: Also, the worst-case bounds can be easily improved if they are expressed using more detailed parameters than T and v. 3 Series-parallel dags Series-parallel dags [23] are a straightforward extension of the notion of series-parallel graphs <ref> [8, 11, 17] </ref>. In this section, we review basic properties of series-parallel dags and show how a Cilk program execution corresponds to a series-parallel dag. These properties will be used in Section 4 to prove the correctness of the SP-bags algorithm. We first define various relationships among Cilk threads.
Reference: [12] <author> John Mellor-Crummey. </author> <title> On-the-fly detection of data races for programs with nested fork-join parallelism. </title> <booktitle> In Proceedings of Supercomputing'91, </booktitle> <pages> pages 24-33. </pages> <publisher> IEEE Computer Society Press, </publisher> <year> 1991. </year>
Reference-contexts: This paper describes a system we call the Nondeterminator to detect determinacy races in Cilk programs. Determinacy races have been given many different names in the literature. For example, they are sometimes called access anomalies [7], data races <ref> [12] </ref>, race conditions [19], or harmful shared-memory accesses [16]. <p> and Leiserson Time Algorithm Thread creation Per access Space and termination SP-bags O (ff (v; v)) O (ff (v; v)) O (v) English-Hebrew labeling [16] O (p) O (pt) O (vt + min (np; vtp)) Task recycling [7] O (t) O (t) O (vt + t 2 ) Offset-span labeling <ref> [12] </ref> O (p) O (p) O (v + min (np; vp)) v = number of shared locations being monitored p = maximum depth of nested parallelism t = maximum number of logical concurrent threads n = number of threads in an execution Ackermann's function introduced by Tarjan in his analysis of <p> Dinning and Schonberg give performance data indicating a slowdown of between 3 and 11 to check between 50 and 80 percent of potential determinacy races. Mellor-Crummey <ref> [12] </ref> proposes a scheme called offset-span labeling in programs with nested fork-join parallelism, a model that exhibits only series-parallel dependences. The idea of his scheme is to store a list of labels for each executing thread. <p> The attraction of Tarjan's algorithm, as opposed to existing linear-time algorithms and the seminal algorithm given by Aho, Hopcroft, and Ullman [1], is that it operates, in Mellor-Crummey's words <ref> [12] </ref>, on the fly. That is, the least common ancestors can be queried during a simple tree walk without ever requiring the entire tree to be expanded at any time. We expect that the discovery of a linear-time on-the-fly least-common-ancestors algorithm would have direct application to determinacy-race detection.
Reference: [13] <author> John Mellor-Crummey. </author> <title> Compile-time support for efficient data race detection in shared-memory parallel programs. </title> <booktitle> In Proceedings of the ACM/ONR Workshop on Parallel and Distributed Debugging, </booktitle> <pages> pages 129-139, </pages> <address> San Diego, California, May 1993. </address> <publisher> ACM Press. </publisher>
Reference-contexts: They reference several algorithms for atomicity-race detection, but we do not discuss this type of race detection here. Static analysis of parallel programs to uncover nondeterminacy has been studied extensively, for example, in <ref> [9, 13] </ref>. Various systems have been developed for determinacy-race detection that do not allow nested parallelism, as for example [2]. We now review related work on determinacy-race detection for programs with nested parallelism.
Reference: [14] <author> Sang Lyul Min and Jong-Deok Choi. </author> <title> An efficient cache-based access anomaly detection scheme. </title> <booktitle> In Proceedings of the Fourth International Conference on Architectural Support for Programming Languages and Operating Systems (ASPLOS), </booktitle> <pages> pages 235-244, </pages> <address> Palo Alto, California, </address> <month> April </month> <year> 1991. </year>
Reference-contexts: This strategy avoids a problem in the English-Hebrew labeling algorithm whereby the length of a label might grow in proportion to the number of spawn operations encountered in the execution path. 18 Feng and Leiserson Min and Choi <ref> [14] </ref> propose a determinacy-race detection algorithm that piggybacks on a protocol for distributed shared-memory. The idea is that a determinacy race occurs when a processor accesses memory that was previously accessed by another processor.
Reference: [15] <author> Robert H. B. Netzer and Barton P. Miller. </author> <title> What are race conditions? ACM Letters on Programming Languages and Systems, </title> <booktitle> 1(1) </booktitle> <pages> 74-88, </pages> <month> March </month> <year> 1992. </year>
Reference-contexts: Determinacy races have been given many different names in the literature. For example, they are sometimes called access anomalies [7], data races [12], race conditions [19], or harmful shared-memory accesses [16]. Netzer and Miller <ref> [15] </ref> clarify different types of races and define a general race or determinacy race to be a race that causes a supposedly deterministic program to behave deterministically. (They also define a data race or atomicity race to be a race in a nondeterministic program involving nonatomic accesses to critical regions.) We <p> Bernstein [3] identifies determinacy races as a cause of nondeterministic behavior. Netzer and Miller <ref> [15] </ref> present a formal model for understanding race conditions in parallel programs, distinguishing determinacy races from atomicity races. They reference several algorithms for atomicity-race detection, but we do not discuss this type of race detection here.
Reference: [16] <author> Itzhak Nudler and Larry Rudolph. </author> <title> Tools for the efficient development of efficient parallel programs. </title> <booktitle> In Proceedings of the First Israeli Conference on Computer Systems Engineering, </booktitle> <month> May </month> <year> 1986. </year> <title> Efficient Detection of Determinacy Races in Cilk Programs 21 </title>
Reference-contexts: This paper describes a system we call the Nondeterminator to detect determinacy races in Cilk programs. Determinacy races have been given many different names in the literature. For example, they are sometimes called access anomalies [7], data races [12], race conditions [19], or harmful shared-memory accesses <ref> [16] </ref>. <p> X 2 such that x 2 X . 2 Technically, by procedure we mean procedure instance, that is, the runtime state of the procedure. 6 Feng and Leiserson Time Algorithm Thread creation Per access Space and termination SP-bags O (ff (v; v)) O (ff (v; v)) O (v) English-Hebrew labeling <ref> [16] </ref> O (p) O (pt) O (vt + min (np; vtp)) Task recycling [7] O (t) O (t) O (vt + t 2 ) Offset-span labeling [12] O (p) O (p) O (v + min (np; vp)) v = number of shared locations being monitored p = maximum depth of nested <p> Various systems have been developed for determinacy-race detection that do not allow nested parallelism, as for example [2]. We now review related work on determinacy-race detection for programs with nested parallelism. Nudler and Rudolph <ref> [16] </ref> give an English-Hebrew labeling algorithm that detects determinacy races in programs with series-parallel dependences, but their model also allows messages between threads, which produces a richer and more difficult class of programs to check.
Reference: [17] <author> John Riordan and C. E. Shannon. </author> <title> The number of two-terminal series-parallel networks. </title> <journal> Journal of Mathematics and Physics, </journal> <volume> 21 </volume> <pages> 83-93, </pages> <year> 1942. </year>
Reference-contexts: Also, the worst-case bounds can be easily improved if they are expressed using more detailed parameters than T and v. 3 Series-parallel dags Series-parallel dags [23] are a straightforward extension of the notion of series-parallel graphs <ref> [8, 11, 17] </ref>. In this section, we review basic properties of series-parallel dags and show how a Cilk program execution corresponds to a series-parallel dag. These properties will be used in Section 4 to prove the correctness of the SP-bags algorithm. We first define various relationships among Cilk threads.
Reference: [18] <author> Baruch Schieber and Uzi Vishkin. </author> <title> On finding lowest common ancestors: Simplification and paralleliza-tion. </title> <journal> SIAM Journal on Computing, </journal> <volume> 17(6) </volume> <pages> 1253-1262, </pages> <month> December </month> <year> 1988. </year>
Reference-contexts: Such a result may be mostly of theoretical interest, however, since debugging is usually done in the development phase of a program using small data sets, and thus typically, the performance of the debugger is not a crucial concern. Linear-time algorithms for the least-common-ancestors algorithm exist in the literature <ref> [10, 18] </ref>, and it is natural to wonder whether a determinacy-race detector exists that operates in linear time, instead of the almost-linear-time performance of the SP-bags algorithm.
Reference: [19] <author> Guy L. Steele Jr. </author> <title> Making asynchronous parallelism safe for the world. </title> <booktitle> In Proceedings of the Seventeenth Annual ACM Symposium on Principles of Programming Languages (POPL), </booktitle> <pages> pages 218-231. </pages> <publisher> ACM Press, </publisher> <year> 1990. </year>
Reference-contexts: This paper describes a system we call the Nondeterminator to detect determinacy races in Cilk programs. Determinacy races have been given many different names in the literature. For example, they are sometimes called access anomalies [7], data races [12], race conditions <ref> [19] </ref>, or harmful shared-memory accesses [16]. <p> This reduced overhead is achieved at the cost of additionally storing the history of accesses of each shared location, however. Moreover, the length of the history is proportional to the depth of nested parallelism. Steele <ref> [19] </ref> proposes a scheme to detect determinacy races in a programming model with asynchronous threads of control. His scheme requires that each location maintains state information recording the sequence of threads that have accessed the location as well as the type of access performed. <p> A disadvantage of this strategy, however, is that turning off the monitoring of one location may hide inadvertent nondeterminism in other locations. Thus, it is not clear what is guaranteed when such a program passes the Nondeterminator test. We are intrigued by Steele's idea <ref> [19] </ref> of handling commutative atomic updates on data objects. His idea would allow us to expand the set of deterministic programs to include those that operate locally in a nondeterministic fashion but yield deterministic results.
Reference: [20] <institution> Supercomputing Technology Group, Massachusetts Institute of Technology, 545 Technology Square, </institution> <address> Cambridge, Massachusetts 02139. </address> <note> Cilk-4.1 (Beta 1) Reference Manual, September 1996. Available on the World Wide Web at URL http://theory.lcs.mit.edu/cilk. </note>
Reference-contexts: 1 Introduction Cilk <ref> [5, 20] </ref> is an algorithmic multithreaded programming language whose threads can concurrently access (read or write) shared memory without blocking. Many Cilk programs are intended to be deterministic, in that a given program produces the same behavior no matter how its threads are scheduled. <p> For a complete specification of the Cilk language, see <ref> [20] </ref>. <p> We are considering how such nondeterminism might be encapsulated linguistically in Cilk so that the Nondeterminator can properly check only those illegal determinacy races that actually change the course of the computation. In Cilk, we already have a linguistic mechanism called an inlet <ref> [20] </ref> that introduces legal nondeterministic operations on locations. The current implementation of the Nondeterminator does not check operations within inlets properly, unless the user can guarantee that during the time that these inlets operate on a given location, the same commutative operation is always applied.
Reference: [21] <author> Robert Endre Tarjan. </author> <title> Efficiency of a good but not linear set union algorithm. </title> <journal> Journal of the Association for Computing Machinery, </journal> <volume> 22(2) </volume> <pages> 215-225, </pages> <month> April </month> <year> 1975. </year>
Reference-contexts: Finally, we prove that the running time of the algorithm is O (T ff (v; v)) when run on a Cilk program that takes time T on one processor and uses v shared-memory locations, where ff is Tarjan's functional inverse of Ackermann's function <ref> [21] </ref>. The SP-bags algorithm is a serial algorithm. It uses the fact that any Cilk program can be executed on one processor in a depth-first fashion (like an ordinary C execution) and conforms to the semantics of the C program that results when all spawn and sync keywords are removed. <p> The SP-bags algorithm updates the shadow spaces as it executes. The SP-bags algorithm uses the fast disjoint-set data structure [6, Chapter 22] analyzed by Tarjan <ref> [21] </ref>. The data structure maintains a dynamic collection of disjoint sets and provides three elementary operations: Make-Set (x): [ ffxgg. Union (X; Y ): fX; Y g [ fX [ Y g. The sets X and Y are destroyed.
Reference: [22] <author> Robert Endre Tarjan. </author> <title> Applications of path compression on balanced trees. </title> <journal> Journal of the Association for Computing Machinery, </journal> <volume> 26(4) </volume> <pages> 690-715, </pages> <month> October </month> <year> 1979. </year>
Reference-contexts: x x is 2 x is 1 and printed by thread e 3 can differ depending on how the instructions in the two instances F 1 and F 2 of the foo () procedure are scheduled. we call the SP-bags algorithm, which was inspired by Tarjan's nearly linear-time least-common-ancestors algorithm <ref> [22] </ref>. Like Tarjan's algorithm, the SP-bags algorithm uses an efficient data structure [6, Chapter 22] to manage disjoint sets of elements. Figure 6 compares the asymptotic time and space for the SP-bags algorithm with other race-detection algorithms in the literature. The remainder of this paper is organized as follows. <p> We first review the disjoint-set data structure used in the algorithm, and then we present the algorithm itself, which is inspired by Tar-jan's least-common-ancestors algorithm <ref> [22] </ref>. Finally, we prove that the running time of the algorithm is O (T ff (v; v)) when run on a Cilk program that takes time T on one processor and uses v shared-memory locations, where ff is Tarjan's functional inverse of Ackermann's function [21].
Reference: [23] <author> Jacobo Valdes. </author> <title> Parsing Flowcharts and Series-Parallel Graphs. </title> <type> PhD thesis, </type> <institution> Stanford University, </institution> <month> De-cember </month> <year> 1978. </year> <month> STAN-CS-78-682. </month>
Reference-contexts: Also, the worst-case bounds can be easily improved if they are expressed using more detailed parameters than T and v. 3 Series-parallel dags Series-parallel dags <ref> [23] </ref> are a straightforward extension of the notion of series-parallel graphs [8, 11, 17]. In this section, we review basic properties of series-parallel dags and show how a Cilk program execution corresponds to a series-parallel dag.
References-found: 23

