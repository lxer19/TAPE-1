URL: http://www-ee.technion.ac.il/~deanh/fmcad.ps.gz
Refering-URL: http://www-ee.technion.ac.il/~deanh/
Root-URL: http://www.aic.nrl.navy.mil/~aha/people.html
Title: A Methodology for Processor Implementation Verification  
Abstract: We address the problem of verification of implementations of complex processors using architectural level automatic test program generators. A number of automatic test program generators exist, and are widely used for verification of the compliance of complex processors with their architectures. We define a four stage verification process: (1) describing the processor implementation control as a Finite State Machine (2) deriving transition coverage on the FSM using methods from formal verification (3) translation of the covering tours to constraints on test programs (4) generation of test programs for each set of constraints. This process combines a high quality and well defined theoretical method along with tools used in industrial practice. There are a number of advantages of our Method: (a) The last three stages are automated (b) Implementing the FSM model involves relatively little expert designers time (c) The method is feasible for modern superscalar processors and was studied on an enhanced PowerPC processor. We describe a formal framework for the new process, identify the obstacles that are encountered in the modeling phase, and show how to overcome them. 
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> A. Aharon, A. Bar-David, B. Dorfman, E. Gofman, M. Leibowitz, V. </author> <title> Shwartzbund Verification of the IBM RISC System/6000 by a Dynamic Biased Pseudo-Random Test Program Generator, </title> <journal> In IBM Systems Journal, </journal> <month> April </month> <year> 1991 </year>
Reference-contexts: 1 Introduction Functional verification comprises a large portion of the effort in designing a processor <ref> [1] </ref>. The investment in experts time, and computer resources is huge, and so is the cost of delivering faulty products [2]. In current industrial practice, random architectural test program generators and simulation methods are used to implement large portions of the verification plans [1][3][4][5][6].
Reference: 2. <author> B. Beizer, </author> <title> The Pentium Bug, an Industry Watershed, Testing Techniques Newsletter On-Line Edition, </title> <month> September </month> <year> 1995 </year>
Reference-contexts: 1 Introduction Functional verification comprises a large portion of the effort in designing a processor [1]. The investment in experts time, and computer resources is huge, and so is the cost of delivering faulty products <ref> [2] </ref>. In current industrial practice, random architectural test program generators and simulation methods are used to implement large portions of the verification plans [1][3][4][5][6]. Massive amounts of test programs are generated and run through an architecture simulation model and through the design simulation model, and the results are compared.
Reference: 3. <author> A. Aharon, D. Goodman, M. Levinger, Y Lichtenstein, Y. Malka, C. Metzger, M. Molco, G. </author> <title> Shurek Test Program Generation for Functional Verification of PowerPC Processors in IBM, </title> <booktitle> In proceeding of ACM/ IEEE Design Automation Conference 1995 </booktitle>
Reference-contexts: This is done by translating event sequences into restrictions on a sequence of instructions. The TDL can be read by an architectural test program generator. Test Code Generation and Validation - The previously produced templates (in TDL form) are fed to an architectural test program generator such as <ref> [3] </ref>. The test program generator automatically produces a set of architectural test programs for each template. These tests are run through the design simulation model, and the results are verified. <p> We show how to integrate the new methodology described in [17] into current verification practice by using it to generate verification tasks automatically and applying existing industrial tools (e.g. <ref> [3] </ref>) to generate architectural tests from these tasks. The third stage in the process of [17] (automatic translation of the covering tours to test vectors) is replaced with translation of tours on the model into verification tasks.
Reference: 4. <author> Y. Lichtenstein, Y. Malka, A. </author> <title> Aharon Model Based Test Generation for Processor Design Verification, </title> <booktitle> In Innovative Applications of Artificial Intelligence (IAAI) AAAI Press 1994 </booktitle>
Reference: 5. <author> Ahi A. M., Burroughs G.D., </author> <title> Gore A.B., LaMar S.W., Lin C.R., Wieman A.L Design Verification of the HP9000 Series 7000 pa-risc Workstations, </title> <journal> Hewlett-Packard-Journal num. </journal> <volume> 8 vol. </volume> <month> 14 August </month> <year> 1992 </year>
Reference: 6. <author> A. Chandra, V. Iyengar, D. Jameson, R. Jawalker, I. Nair, B. Rosen, M. Mullen, J. Yoor, R. Armoni, D. Geist, Y. </author> <title> Wolfstal AVPGEN - A Test Case Generator for Architecture Verification, </title> <journal> IEEE Transactions on VLSI Systems 6(6) June 1995 </journal>
Reference: 7. <author> D. Geist, M. Farkas, A. Landver, Y. Lichtenstein, S. Ur, Y. </author> <title> Wolfsthal Coverage Directed Generation Using Symbolic Techniques, </title> <address> FMCAD 96 </address>
Reference-contexts: Thus, inputs to the model are easily translatable into inputs for a real implementation. The major difference between protocol verification and processor verification is the size of the implementation. In <ref> [7] </ref> a CFSM model is used to drive test generation to check a PowerPC system controller and a PowerPC multi-processor exclusive access mechanism (semaphores). Building an FSM that models a complete processor, as is done for protocols, is infeasible due to the state explosion problem. <p> Now that we have established a theoretical framework for the last stages, we present some practical details involved. 2.3 Tour Generator - CCTG The CCTG tool (D. Geist, M. Farkas, A. Landver, Y. Lichtenstein, S. Ur, Y. Wolfsthal <ref> [7] </ref>) automatically generates the set of covering tours of a CFSM. In practice, the number of transitions in the model may be large and likewise the size of may be huge.
Reference: 8. <author> E. J. Weyuker, B. </author> <title> Jeng Analyzing Partition Testing Strategies, </title> <journal> IEEE Transactions on Software Engineering vol. </journal> <volume> 17 no. </volume> <month> 7 July </month> <year> 1991 </year>
Reference-contexts: A test is not architectural if it depends on the design simulation environment to execute. An example of non-architectural tests are those produced in [17]. The Global Test Domain for a processor is the set of all Architectural Test Programs for the processor. Partition testing for software <ref> [8] </ref>, is a testing methodology where the global test domain is divided into subdomains and a single test from each subdomain is generated and simulated. <p> The implementation partition divides the domain into sets that are treated in the same way by the implementation. The final partitioning is defined by intersecting these two partitions. Verification is considered complete if a test program from each subdomain has been simulated on the design. In <ref> [8] </ref> it is shown that partition testing is most effective when the implementation partition is based on models of bugs that are likely to occur in the design. <p> The cover of is an implementation partition as the edges of the FSM represent transitions in the control of the processor (see section 3). Along the same lines of the heuristic for creating an effective partition presented in <ref> [8] </ref> and [9] for software testing, we would like to intersect with a partition based on architectural considerations. In the case of test programs, this architectural partition is very difficult to describe as each implementation subdomain induces its own architectural dimension. In addition, the true architectural partition is huge.

References-found: 8

