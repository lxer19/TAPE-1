URL: http://www.research.digital.com/SRC/tla/all-gerth2.ps.Z
Refering-URL: http://www.research.digital.com/SRC/tla/papers.html
Root-URL: http://www.research.digital.com
Title: Lazy Caching in TLA  
Author: Peter Ladkin Leslie Lamport Bryan Olivier Denis Roegel 
Date: 18 January 1996  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> Martn Abadi and Leslie Lamport. </author> <title> The existence of refinement mappings. </title> <journal> Theoretical Computer Science, </journal> <volume> 82(2) </volume> <pages> 253-284, </pages> <month> May </month> <year> 1991. </year>
Reference-contexts: Discipline can be used to eliminate careless mistakes when checking a long series of trivial steps; discipline cannot help 1 detect subtle errors in interesting steps. In assertional reasoning, insight is typically required to find an invariant and construct a refinement mapping <ref> [1] </ref>. The proof itself is a tedious matter of checking the details. For the lazy caching algorithm, we give the invariant and refinement mapping, and we describe the high-level structure of the proof. The complete proof is much too long and boring to include here. <p> is the set f1; : : : ; ng of natural numbers, so hv 1 ; : : : ; v n i [i ] (the function h v 1 ; : : : ; v n i applied to 9 mem 6 6 6 6 ? 6 ? in <ref> [1] </ref> out [1] ch [1] Processor 1 Processor N in [N ] out [N ] ch [N ] c [i ] is a cache, out [i ] is a queue of hdata; addressi pairs for writes by processor i that have not yet been performed to memory, and in [i ] <p> set f1; : : : ; ng of natural numbers, so hv 1 ; : : : ; v n i [i ] (the function h v 1 ; : : : ; v n i applied to 9 mem 6 6 6 6 ? 6 ? in <ref> [1] </ref> out [1] ch [1] Processor 1 Processor N in [N ] out [N ] ch [N ] c [i ] is a cache, out [i ] is a queue of hdata; addressi pairs for writes by processor i that have not yet been performed to memory, and in [i ] is a <p> : : : ; ng of natural numbers, so hv 1 ; : : : ; v n i [i ] (the function h v 1 ; : : : ; v n i applied to 9 mem 6 6 6 6 ? 6 ? in <ref> [1] </ref> out [1] ch [1] Processor 1 Processor N in [N ] out [N ] ch [N ] c [i ] is a cache, out [i ] is a queue of hdata; addressi pairs for writes by processor i that have not yet been performed to memory, and in [i ] is a queue of <p> The set Op plays the role of the parameter of the same name in module SerialDB . 3.2.2 Sequential Consistency Intuitively, sequential consistency means that there is some interleaving of the operations sent on channels ch <ref> [1] </ref>, : : : , ch [N ] that forms a correct sequence of operations for a serial database. The idea behind our specification is illustrated by Figure 11. <p> However, at some time after the read operation reaches the head of q [i ], the value of mem [a] must equal d . That value could have been written by an operation on another channel ch [j ] that occurred after the read. In the terminology of <ref> [1] </ref>, our specification is not machine closed. Conventional state-machine specifications are always machine closed. Machine closure is a necessary condition for a specification to be executable in practice. <p> We sketch the proof of the more interesting of these two theorems, CCimpliesDB 1. The temporal existential quantifiers in the definition of DB 1:Spec mean that the proof requires a refinement mapping <ref> [1] </ref>. To define the refinement mapping, we add to the complete cache three auxiliary variables, vcq, vrq, and vdch. The complete cache with auxiliary variables is specified by formula ASpec of module ACCache, which appears in Section 4.3. The CacheCorrectness module includes this module and then asserts two theorems. <p> The algorithm is pictured as a state machine in Figure 17. To simplify the proof, we replace the queues 6 6 ? 6 ? cin <ref> [1] </ref> cout [1] cc [1] Processor 1 Processor N cin [N ] cout [N ] cc [N ] r r r hprocessor ; operation; data; addressi tuples. 28 out [i ] and in [i ] of the lazy caching algorithm with queues cout [i ] and cin [i ] containing complete <p> The algorithm is pictured as a state machine in Figure 17. To simplify the proof, we replace the queues 6 6 ? 6 ? cin <ref> [1] </ref> cout [1] cc [1] Processor 1 Processor N cin [N ] cout [N ] cc [N ] r r r hprocessor ; operation; data; addressi tuples. 28 out [i ] and in [i ] of the lazy caching algorithm with queues cout [i ] and cin [i ] containing complete operations hi <p> The algorithm is pictured as a state machine in Figure 17. To simplify the proof, we replace the queues 6 6 ? 6 ? cin <ref> [1] </ref> cout [1] cc [1] Processor 1 Processor N cin [N ] cout [N ] cc [N ] r r r hprocessor ; operation; data; addressi tuples. 28 out [i ] and in [i ] of the lazy caching algorithm with queues cout [i ] and cin [i ] containing complete operations hi ; op; <p> For temporal existential quantification, the instantiations are called a refinement mapping <ref> [1] </ref>. <p> It does not contain the information needed to define dch because the write operation that changes mem, which must appear in dch, is immediately forgotten. To finish constructing our refinement mapping, we must add auxiliary variables <ref> [1] </ref> to the complete cache. Adding an auxiliary variable a to a specification S means finding a formula S a such that 999 999 a : S a is equivalent to S . In our example, we need two types of auxiliary variables: history variables and stuttering variables. <p> Len (cin [pMax ])) ^ cc [i ] = ApplyOps [SubSeq (cin [pMax ]; 1; Len (cin [pMax ]) Len (cin [i ])); cc [pMax ] ] 3.^ WriteSel (vcq) = cin [pMax ] 4.^ let s = vrq ffi vcq (s [n][2] = "Rd") ) (s [n][3] = ApplyOps <ref> [WriteSel (SubSeq (s; 1; n 1)); cc [pMax ] </ref> ] [s [n][4]] ) 5.^ 8 i 2 Proc : 8 j 2 InsertPos [Len (cin [pMax ]) Len (cin [i ]); vcq] : : Len (vcq) : (vcq [j ][1] = i ) ) (vcq [j ][2] = "Wr") 39 tors:
Reference: [2] <author> Martn Abadi, Leslie Lamport, and Stephan Merz. </author> <title> Refining specifications. </title> <note> To appear. </note>
Reference-contexts: TLA formulas are written in terms of 21 module ChannelInterface import Sequences, Naturals ChanOp (c; v) = c 0 = hv; if c <ref> [2] </ref> = "a" then "b" else "a"i ChanHist (c; h) ^ 2 [ h 0 = if c 0 6= c then h ffi hc 0 [1]i else h ] hh;ci variables that describe the current state. <p> ^ (h 0 = h ffi hv i)] hh;c i (h = h i) ^ 2 ^ 8 v : ChanOp (c; v ) ) (h 0 = h ffi hv i) ^ (c 0 = c) ) (h 0 = h) hh;c i 10 In TLA + , c <ref> [2] </ref> is some value|even if 2 is not in the domain of c. <p> two specifications 26 module CacheCorrectness import MemParams parameters c; in; out; mem : variable include LazyCache as LC POp = [i 2 Proc 7! fi g fi f"Rd"; "Wr"g fi Data fi Addr ] OKOp (o; old ; new ) ^ o [3] = old [o [4]] _ ^ o <ref> [2] </ref> = "Wr" ^ new = [old except ![o [4]] = o [3] ] InitDB = [Addr ! InitData] include SeqDB1 as DB1 theorem LCimpliesDB 1 = LC :Spec ) DB 1:Spec include CCache as CC (cc; cin; cout) theorems LCimpliesCC = LC :Spec ) ( 999 999 cc; cin; cout <p> _ VRead avars = hvars; vcq; vrq; vdch i AFair = ^ 8 i 2 Proc : WF vars (CacheUpdate (i )) ^ WF vars (MemWrite (i )) ^ WF avars (VRead ) ASpec = AInit ^ 2 [ANext] avars ^ AFair ables; they can be derived from simpler results <ref> [2] </ref>. Theorem CCequivACC is proved by adding to the complete cache the history variable vcq, then the stuttering variable vrq, and then the history variable vdch.
Reference: [3] <author> Yehuda Afek, Geoffrey Brown, and Michael Merritt. </author> <title> Lazy caching. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 15(1) </volume> <pages> 182-205, </pages> <month> January </month> <year> 1993. </year>
Reference-contexts: The class of problems we consider are the specification and verification of safety and liveness properties of concurrent systems. We demonstrate our approach on a problem suggested by Gerth [8]: verifying that a simplified version of the lazy caching algorithm of Afek, Brown, and Merritt <ref> [3] </ref> is sequentially consistent [11]. Although our exposition is self-contained, it is about specification and verification, not about lazy caching. We formally specify the algorithm, but a formal specification is no substitute for an intuitive explanation. Readers looking for such an explanation are referred to [3]. <p> of Afek, Brown, and Merritt <ref> [3] </ref> is sequentially consistent [11]. Although our exposition is self-contained, it is about specification and verification, not about lazy caching. We formally specify the algorithm, but a formal specification is no substitute for an intuitive explanation. Readers looking for such an explanation are referred to [3]. Published "proofs" of incorrect concurrent algorithms have taught us the need for rigor. We achieve rigor by using formal mathematics. TLA is a formal logic, with precise proof rules; and TLA + has a formal semantics. <p> The equivalence of the two specifications 26 module CacheCorrectness import MemParams parameters c; in; out; mem : variable include LazyCache as LC POp = [i 2 Proc 7! fi g fi f"Rd"; "Wr"g fi Data fi Addr ] OKOp (o; old ; new ) ^ o <ref> [3] </ref> = old [o [4]] _ ^ o [2] = "Wr" ^ new = [old except ![o [4]] = o [3] ] InitDB = [Addr ! InitData] include SeqDB1 as DB1 theorem LCimpliesDB 1 = LC :Spec ) DB 1:Spec include CCache as CC (cc; cin; cout) theorems LCimpliesCC = LC <p> : variable include LazyCache as LC POp = [i 2 Proc 7! fi g fi f"Rd"; "Wr"g fi Data fi Addr ] OKOp (o; old ; new ) ^ o <ref> [3] </ref> = old [o [4]] _ ^ o [2] = "Wr" ^ new = [old except ![o [4]] = o [3] ] InitDB = [Addr ! InitData] include SeqDB1 as DB1 theorem LCimpliesDB 1 = LC :Spec ) DB 1:Spec include CCache as CC (cc; cin; cout) theorems LCimpliesCC = LC :Spec ) ( 999 999 cc; cin; cout : CC (cc; cin; cout):Spec) CCimpliesDB 1 = 888 888 cc; cin;
Reference: [4] <author> E. A. Ashcroft. </author> <title> Proving assertions about parallel programs. </title> <journal> Journal of Computer and System Sciences, </journal> <volume> 10 </volume> <pages> 110-135, </pages> <month> February </month> <year> 1975. </year>
Reference-contexts: 1 Introduction Assertional verification of concurrent algorithms began in 1975 with Ash-croft's seminal paper <ref> [4] </ref>. By the late 1980's, assertional methods had been developed for specifying concurrent systems and proving that a lower-level specification implements a higher-level one. Our goal is to transform asser-tional specification and verification from a scientific theory into an engineering discipline. Engineering is the practical application of scientific principles. <p> The equivalence of the two specifications 26 module CacheCorrectness import MemParams parameters c; in; out; mem : variable include LazyCache as LC POp = [i 2 Proc 7! fi g fi f"Rd"; "Wr"g fi Data fi Addr ] OKOp (o; old ; new ) ^ o [3] = old [o <ref> [4] </ref>] _ ^ o [2] = "Wr" ^ new = [old except ![o [4]] = o [3] ] InitDB = [Addr ! InitData] include SeqDB1 as DB1 theorem LCimpliesDB 1 = LC :Spec ) DB 1:Spec include CCache as CC (cc; cin; cout) theorems LCimpliesCC = LC :Spec ) ( 999 <p> in; out; mem : variable include LazyCache as LC POp = [i 2 Proc 7! fi g fi f"Rd"; "Wr"g fi Data fi Addr ] OKOp (o; old ; new ) ^ o [3] = old [o <ref> [4] </ref>] _ ^ o [2] = "Wr" ^ new = [old except ![o [4]] = o [3] ] InitDB = [Addr ! InitData] include SeqDB1 as DB1 theorem LCimpliesDB 1 = LC :Spec ) DB 1:Spec include CCache as CC (cc; cin; cout) theorems LCimpliesCC = LC :Spec ) ( 999 999 cc; cin; cout : CC (cc; cin; cout):Spec) CCimpliesDB 1 = 888
Reference: [5] <author> K. Mani Chandy and Jayadev Misra. </author> <title> Parallel Program Design. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, Massachusetts, </address> <year> 1988. </year>
Reference-contexts: There are a number of restrictions in TLA + that are needed to maintain its simplicity. Surprising complications can arise from features that appear innocuous|for example, boolean-valued functions (also called arrays of booleans) [15, pages 78-79]. These complications are often not apparent in semi-formal expositions such as <ref> [5] </ref> and [21]. 2.2 The Lazy Caching Algorithm We introduce TLA and TLA + by first specifying Gerth's version of the lazy caching algorithm.
Reference: [6] <author> Richard A. De Millo, Richard J. Lipton, and Alan J. Perlis. </author> <title> Social processes and proofs of theorems and programs. </title> <journal> Communications of the ACM, </journal> <volume> 22(5) </volume> <pages> 271-280, </pages> <month> May </month> <year> 1979. </year>
Reference-contexts: Conventional mathematical proofs try to be interesting and to avoid boring details; as a result, a significant fraction of the theorems published in mathematical journals are wrong <ref> [6, 14] </ref>. Discipline can be used to eliminate careless mistakes when checking a long series of trivial steps; discipline cannot help 1 detect subtle errors in interesting steps. In assertional reasoning, insight is typically required to find an invariant and construct a refinement mapping [1].
Reference: [7] <author> Urban Engberg, Peter Grtnning, and Leslie Lamport. </author> <title> Mechanical verification of concurrent systems with TLA. </title> <editor> In G. v. Bochmann and D. K. Probst, editors, </editor> <booktitle> Proceedings of the Fourth International Conference on Computer Aided Verification, volume 663 of Lecture Notes in Computer Science, </booktitle> <pages> pages 44-55, </pages> <address> Berlin, </address> <month> June </month> <year> 1992. </year> <title> Springer-Verlag. </title> <booktitle> Proceedings of the Fourth International Conference, </booktitle> <address> CAV'92. </address>
Reference-contexts: Greater reliability is obtained by carrying out the proofs to lower levels of detail. Ultimately, one reaches a point where prose can be eliminated and the proof checked by computer <ref> [7] </ref>. However, reasonably reliable proofs can be obtained without mechanical assistance. We believe that proofs should be long and boring. They should be long because many details must be checked to ensure correctness. <p> However, before that level of detail were reached, we could replace the prose by instructions to a mechanical theorem prover <ref> [7] </ref>. Steps 1-3 prove a safety property of the complete cache. They consist of action reasoning, with essentially no temporal logic. These steps are the TLA version of the standard invariance and step-simulation proofs of methods based on toy programming languages [22] and automata [10, 19].
Reference: [8] <author> Rob Gerth. </author> <title> Introduction to sequential consistency and the lazy caching algorithm. </title> <booktitle> Distributed Computing, </booktitle> <year> 1995. </year>
Reference-contexts: The class of problems we consider are the specification and verification of safety and liveness properties of concurrent systems. We demonstrate our approach on a problem suggested by Gerth <ref> [8] </ref>: verifying that a simplified version of the lazy caching algorithm of Afek, Brown, and Merritt [3] is sequentially consistent [11]. Although our exposition is self-contained, it is about specification and verification, not about lazy caching. <p> In Section 2, we introduce TLA and TLA + by writing a formal specification of Gerth's version of the lazy caching algorithm. Section 3 presents two specifications of sequential consistency|the one we use, and an equivalent one in the spirit of the original definition [11], as adapted by Gerth <ref> [8] </ref>.
Reference: [9] <author> Peter Ladkin, Leslie Lamport, Bryan Olivier, and Denis Roegel. </author> <title> A lazy caching proof in tla. At URL http://www.research.digital. com/SRC/tla/lazy.html on the World Wide Web. It can also be found by searching the Web for the 31-letter string formed by concatenating uid and ladlamoliroelazycachingproof. </title> <type> 48 </type>
Reference-contexts: The complete proof is much too long and boring to include here. Moreover, it is too long to be read conveniently as a conventional paper document. We hope to provide a hypertext version of the proof on the World Wide Web <ref> [9] </ref>. To be useful, an engineering discipline should be applicable to a reasonably broad class of problems. There would be little point developing a complete specification and proof method just for caching algorithms. <p> Rigorous proofs are long, detailed, and tedious. They are difficult to present on paper and are best suited to hypertext. We will therefore give the complete proof elsewhere <ref> [9] </ref>; here, we just describe how the proof is obtained. Section 4.1 states our result formally and describes the outline of the proof. <p> Proving this for a Gerth-like definition of sequential consistency requires also proving the implication DB 1:Spec ) DB 2:Spec of Thm in module DB 1equivDB 2 (Figure 15). Complete proofs of these four results will be given elsewhere <ref> [9] </ref>. <p> ) formulas BSpec and CSpec such that Spec 999 999 vcq : CSpec by Proposition 1 999 999 vcq : 999 999 vrq : BSpec by Proposition 2 999 999 vcq : 999 999 vrq : 999 999 vdch : ASpec by Proposition 1 The complete proof will appear in <ref> [9] </ref>. We next describe the proof of ACCimpliesDB 1. 35 4.4 The Proof of Theorem ACCimpliesDB1 It is argued elsewhere that the way to avoid mistakes in proofs is to structure them hierarchically [14]. <p> Results that are used in several steps must either be moved to a higher level in the proof, or else 47 proved in separate lemmas. We prefer to restructure a proof rather than adding an array of external lemmas, so the structure of the detailed proof in <ref> [9] </ref> will differ from that of the proof presented here.
Reference: [10] <author> Simon S. Lam and A. Udaya Shankar. </author> <title> Protocol verification via projec-tions. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> SE-10(4):325-342, </volume> <month> July </month> <year> 1984. </year>
Reference-contexts: Steps 3.1.2.1-3.1.2.5 make the analogous assertions for the serial database machine. These steps correspond to the step simulation part of a traditional proof that one state machine simulates another <ref> [10, 19] </ref>. As usual, some of the proofs are trivial and some give further insight into the algorithm. An example of the latter is step 3.1.1.1, which asserts that an ARead event simulates a queue machine Enq event. <p> Steps 1-3 prove a safety property of the complete cache. They consist of action reasoning, with essentially no temporal logic. These steps are the TLA version of the standard invariance and step-simulation proofs of methods based on toy programming languages [22] and automata <ref> [10, 19] </ref>. However, our proofs are completely formal. The proof of fairness in step 4 uses nontrivial temporal logic reasoning. We know of no better formalism than temporal logic for writing rigorous proofs of fairness properties.
Reference: [11] <author> Leslie Lamport. </author> <title> How to make a multiprocessor computer that correctly executes multiprocess programs. </title> <journal> IEEE Transactions on Computers, </journal> <volume> C-28(9):690-691, </volume> <month> September </month> <year> 1979. </year>
Reference-contexts: The class of problems we consider are the specification and verification of safety and liveness properties of concurrent systems. We demonstrate our approach on a problem suggested by Gerth [8]: verifying that a simplified version of the lazy caching algorithm of Afek, Brown, and Merritt [3] is sequentially consistent <ref> [11] </ref>. Although our exposition is self-contained, it is about specification and verification, not about lazy caching. We formally specify the algorithm, but a formal specification is no substitute for an intuitive explanation. Readers looking for such an explanation are referred to [3]. <p> In Section 2, we introduce TLA and TLA + by writing a formal specification of Gerth's version of the lazy caching algorithm. Section 3 presents two specifications of sequential consistency|the one we use, and an equivalent one in the spirit of the original definition <ref> [11] </ref>, as adapted by Gerth [8].
Reference: [12] <author> Leslie Lamport. </author> <title> What good is temporal logic? In R. </title> <editor> E. A. Mason, editor, </editor> <booktitle> Information Processing 83: Proceedings of the IFIP 9th World Congress, </booktitle> <pages> pages 657-668, </pages> <address> Paris, </address> <month> September </month> <year> 1983. </year> <title> IFIP, </title> <publisher> North-Holland. </publisher>
Reference-contexts: A behavior satisfies this formula iff I holds in the initial state, every successive pair of states is a step that either satisfies N or else leaves v unchanged, and the fairness condition L is satisfied. (The reason for allowing "stuttering steps" that do not change v is explained in <ref> [12] </ref>.) For the lazy caching algorithm, I is the initial predicate Init . We next describe the next-state action N , which describes all possible events of the state machine|that is all steps that change v .
Reference: [13] <author> Leslie Lamport. </author> <title> A simple approach to specifying concurrent systems. </title> <journal> Communications of the ACM, </journal> <volume> 32(1) </volume> <pages> 32-45, </pages> <month> January </month> <year> 1989. </year>
Reference-contexts: We therefore obtain our proof by a straightforward application of our method. The most novel part of the proof is the specification of sequential consistency, and it is a direct application of an idea introduced in <ref> [13] </ref> for specifying serializability. As with any engineering discipline, it takes practice to learn to write formal specifications and proofs with TLA and TLA + . But, writing a specification and proof of a Byzantine agreement algorithm teaches the skills needed to verify a caching algorithm.
Reference: [14] <author> Leslie Lamport. </author> <title> How to write a proof. </title> <journal> American Mathematical Monthly, </journal> <volume> 102(7) </volume> <pages> 600-608, </pages> <month> August-September </month> <year> 1993. </year>
Reference-contexts: An engineering discipline comprises a well-defined collection of intellectual tools that can be applied to a class of problems. The tools of our approach are the logic TLA (the Temporal Logic of Actions) [17], the specification language TLA + [15], and a hierarchical proof style for writing rigorous proofs <ref> [14] </ref>. The class of problems we consider are the specification and verification of safety and liveness properties of concurrent systems. <p> Conventional mathematical proofs try to be interesting and to avoid boring details; as a result, a significant fraction of the theorems published in mathematical journals are wrong <ref> [6, 14] </ref>. Discipline can be used to eliminate careless mistakes when checking a long series of trivial steps; discipline cannot help 1 detect subtle errors in interesting steps. In assertional reasoning, insight is typically required to find an invariant and construct a refinement mapping [1]. <p> We next describe the proof of ACCimpliesDB 1. 35 4.4 The Proof of Theorem ACCimpliesDB1 It is argued elsewhere that the way to avoid mistakes in proofs is to structure them hierarchically <ref> [14] </ref>. This is especially true for correctness proofs of computer systems, where the social process for detecting errors is largely missing. A hierarchical proof is a sequence of statements and their proofs, each of which is either a sequence of statements or else an ordinary paragraph-style proof. <p> For example, a closer examination of our informal proof of step 4.1.2.1 reveals that it implicitly uses step 3.1.1.5. Our hierarchical proof style allows the proof of 4.1.2.1 to invoke step 3, but not any of its substeps <ref> [14] </ref>. Results that are used in several steps must either be moved to a higher level in the proof, or else 47 proved in separate lemmas.
Reference: [15] <editor> Leslie Lamport. Hybrid systems in TLA + . In Robert L. Grossman, Anil Nerode, Anders P. Ravn, and Hans Rischel, editors, </editor> <booktitle> Hybrid Systems, volume 736 of Lecture Notes in Computer Science, </booktitle> <pages> pages 77-102, </pages> <address> Berlin, Heidelberg, 1993. </address> <publisher> Springer-Verlag. </publisher>
Reference-contexts: Engineering is the practical application of scientific principles. An engineering discipline comprises a well-defined collection of intellectual tools that can be applied to a class of problems. The tools of our approach are the logic TLA (the Temporal Logic of Actions) [17], the specification language TLA + <ref> [15] </ref>, and a hierarchical proof style for writing rigorous proofs [14]. The class of problems we consider are the specification and verification of safety and liveness properties of concurrent systems. <p> To be useful, an engineering discipline should be applicable to a reasonably broad class of problems. There would be little point developing a complete specification and proof method just for caching algorithms. TLA and TLA + have been applied to a number of diverse domains, including hybrid systems <ref> [15] </ref> and distributed fault-tolerant algorithms [18]. Nothing new has been introduced for the lazy caching example. 1 We are not interested in finding the simplest or most elegant possible proof of the lazy caching algorithm. Some formalisms might be better suited for reasoning about caching algorithms. <p> Also, why we don't write certain things may be puzzling. There are a number of restrictions in TLA + that are needed to maintain its simplicity. Surprising complications can arise from features that appear innocuous|for example, boolean-valued functions (also called arrays of booleans) <ref> [15, pages 78-79] </ref>. These complications are often not apparent in semi-formal expositions such as [5] and [21]. 2.2 The Lazy Caching Algorithm We introduce TLA and TLA + by first specifying Gerth's version of the lazy caching algorithm.
Reference: [16] <author> Leslie Lamport. </author> <title> How to write a long formula. </title> <journal> Formal Aspects of Computing, </journal> <volume> 6 </volume> <pages> 580-584, </pages> <year> 1994. </year> <note> First appeared as Research Report 119, </note> <institution> Digital Equipment Corporation, Systems Research Center. </institution>
Reference-contexts: The fifth and sixth conjuncts assert what doesn't change. The formula unchanged e means e 0 = e, so the fifth conjunct asserts that the step does not change any other channel|hence nothing is sent on the other to eliminate parentheses <ref> [16] </ref>. (We also continue to use ^ and _ as infix operators.) 5 There is no notion of a sender or a receiver, so it might be better to say that the step represents a v event on channel x . 12 channels.
Reference: [17] <author> Leslie Lamport. </author> <title> The temporal logic of actions. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 16(3) </volume> <pages> 872-923, </pages> <month> May </month> <year> 1994. </year>
Reference-contexts: Engineering is the practical application of scientific principles. An engineering discipline comprises a well-defined collection of intellectual tools that can be applied to a class of problems. The tools of our approach are the logic TLA (the Temporal Logic of Actions) <ref> [17] </ref>, the specification language TLA + [15], and a hierarchical proof style for writing rigorous proofs [14]. The class of problems we consider are the specification and verification of safety and liveness properties of concurrent systems. <p> When we write "S implies T ", we usually mean that S ) T is valid. The syntax and semantics of TLA are described in <ref> [17] </ref>. TLA + is a formal language based on TLA and Zermelo-Fraenkel set theory. We will explain its features as they are used. Most of the operators and constructs of TLA + , including all the ones we use, are summarized in Figures 1 and 2. <p> Hence, a specification need not specify any initial value for the channel. 22 Using the TLA proof rules <ref> [17, Figure 5] </ref>, it is easy to show that the formula 2 [9 v : ChanOp (c; v )] c , which asserts that every change to c is a ChanOp event, implies that all three definitions are equivalent. <p> AInit ^ 2 [ANext] avars ) 2Inv 1.1. AInit ) Inv 1.2. Inv ^ [ANext] avars ) Inv 0 1.3. Q.E.D. Proof: 1.1, 1.2, and rule INV1 of <ref> [17] </ref>. 2. AInit ) Init 3. 2Inv ^ 2 [ANext] avars ) 2 [Next] v 3.1. [Inv ^ Inv 0 ^ ANext] avars ) [Next] v 3.2. Q.E.D. Proof: Rules TLA2 and INV2 of [17]. 4. 2Inv ^ 2 [ANext] avars ^ AFair ) L 5. Q.E.D. <p> Q.E.D. Proof: 1.1, 1.2, and rule INV1 of <ref> [17] </ref>. 2. AInit ) Init 3. 2Inv ^ 2 [ANext] avars ) 2 [Next] v 3.1. [Inv ^ Inv 0 ^ ANext] avars ) [Next] v 3.2. Q.E.D. Proof: Rules TLA2 and INV2 of [17]. 4. 2Inv ^ 2 [ANext] avars ^ AFair ) L 5. Q.E.D. Proof: 1-4 and propositional logic. <p> Q.E.D. Proof: Rules TLA2 and INV2 of <ref> [17] </ref>. 4. 2Inv ^ 2 [ANext] avars ^ AFair ) 8 i 2 Proc : WF hch;dch;q i (Deq (i ; dch; q)) 5. Q.E.D. Proof: 1-4 and propositional logic. <p> This suggests using rule WF2 of <ref> [17] </ref>. With that rule, one infers WF w (B ) from WF v (A), where A is the action that implements B . However, as we saw in the proof of 3.1.1, Deq (i ; dch; q) is implemented by the two separate actions ACacheUpdate (i ) and VRead .
Reference: [18] <author> Leslie Lamport and Stephan Merz. </author> <title> Specifying and verifying fault-tolerant systems. </title> <editor> In H. Langmaack, W.-P. de Roever, and J. Vy-topil, editors, </editor> <booktitle> Formal Techniques in Real-Time and Fault-Tolerant Systems, volume 863 of Lecture Notes in Computer Science, </booktitle> <pages> pages 41-76. </pages> <publisher> Springer-Verlag, </publisher> <month> September </month> <year> 1994. </year>
Reference-contexts: There would be little point developing a complete specification and proof method just for caching algorithms. TLA and TLA + have been applied to a number of diverse domains, including hybrid systems [15] and distributed fault-tolerant algorithms <ref> [18] </ref>. Nothing new has been introduced for the lazy caching example. 1 We are not interested in finding the simplest or most elegant possible proof of the lazy caching algorithm. Some formalisms might be better suited for reasoning about caching algorithms.
Reference: [19] <author> Nancy A. Lynch. </author> <title> Distributed Algorithms. </title> <publisher> Morgan Kaufmann, </publisher> <address> San Mateo, California, </address> <year> 1995. </year>
Reference-contexts: Steps 3.1.2.1-3.1.2.5 make the analogous assertions for the serial database machine. These steps correspond to the step simulation part of a traditional proof that one state machine simulates another <ref> [10, 19] </ref>. As usual, some of the proofs are trivial and some give further insight into the algorithm. An example of the latter is step 3.1.1.1, which asserts that an ARead event simulates a queue machine Enq event. <p> Steps 1-3 prove a safety property of the complete cache. They consist of action reasoning, with essentially no temporal logic. These steps are the TLA version of the standard invariance and step-simulation proofs of methods based on toy programming languages [22] and automata <ref> [10, 19] </ref>. However, our proofs are completely formal. The proof of fairness in step 4 uses nontrivial temporal logic reasoning. We know of no better formalism than temporal logic for writing rigorous proofs of fairness properties.
Reference: [20] <author> Zohar Manna and Amir Pnueli. </author> <title> Completing the temporal picture. </title> <journal> Theoretical Computer Science, </journal> <volume> 83(1) </volume> <pages> 97-130, </pages> <year> 1991. </year> <month> 49 </month>
Reference-contexts: Had we done the proof in more detail, we would have relied heavily on the TLA rules WF1 and WF2, which use action reasoning to derive temporal logic formulas. (Rule WF1 is the TLA version of Manna and Pnueli's "single-step" rule for "just" transitions <ref> [20] </ref>. Because their method is not hierarchical, Manna and Pnueli have no analog of rule WF2.) Even for fairness properties, action reasoning forms the bulk of a detailed TLA proof.
Reference: [21] <author> Zohar Manna and Amir Pnueli. </author> <title> The Temporal Logic of Reactive and Concurrent Systems. </title> <publisher> Springer-Verlag, </publisher> <address> New York, </address> <year> 1991. </year>
Reference-contexts: There are a number of restrictions in TLA + that are needed to maintain its simplicity. Surprising complications can arise from features that appear innocuous|for example, boolean-valued functions (also called arrays of booleans) [15, pages 78-79]. These complications are often not apparent in semi-formal expositions such as [5] and <ref> [21] </ref>. 2.2 The Lazy Caching Algorithm We introduce TLA and TLA + by first specifying Gerth's version of the lazy caching algorithm. <p> the following theorem, which asserts that the variables c, in, out , and mem are always elements of the proper set. (Module Sequences defines Seq (S ) to be the set of all finite sequences of elements in S , and 2 is the usual "always" operator of temporal logic <ref> [21] </ref>.) Spec ) 2 ( ^ mem 2 [Addr ! Data] ^ c 2 [Proc ! [Addr ! Data [ f?g]] ^ in 2 [Proc ! Seq ((Data fi Addr ) [ (Data fi Addr fi f"fl"g))] ^ out 2 [Proc ! Seq (Data fi Addr )] ) This theorem is <p> This assertion can be written 8 os : 2 ((hch = os) ) 3 (os = Proj (i ; hdch))) where Proj (i ; ) is the subsequence of operations in sent by processor i , and 3 is the usual temporal operator meaning eventually <ref> [21] </ref>. The complete specification appears as formula Spec of module SeqDB 2 in Figure 14.
Reference: [22] <author> S. Owicki and D. Gries. </author> <title> An axiomatic proof technique for parallel programs I. </title> <journal> Acta Informatica, </journal> <volume> 6(4) </volume> <pages> 319-340, </pages> <year> 1976. </year> <month> 50 </month>
Reference-contexts: The quadratic number of steps|the number of disjuncts in the next-state relation times the number of conjuncts of the invariant|is characteristic of approaches based on invariance, such as the Owicki-Gries method <ref> [22] </ref>. Some of the 25 remaining steps in the proof of 1.2 are trivial|for example, 1.2.3.2 holds because AWrite (i ; d ; a) leaves vcq and cin unchanged, which implies that pMax is unchanged, and thus Inv :3 remains true. <p> Steps 1-3 prove a safety property of the complete cache. They consist of action reasoning, with essentially no temporal logic. These steps are the TLA version of the standard invariance and step-simulation proofs of methods based on toy programming languages <ref> [22] </ref> and automata [10, 19]. However, our proofs are completely formal. The proof of fairness in step 4 uses nontrivial temporal logic reasoning. We know of no better formalism than temporal logic for writing rigorous proofs of fairness properties.
References-found: 22

