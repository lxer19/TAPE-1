URL: ftp://ftp.cs.brown.edu/pub/techreports/95/cs95-27.ps.Z
Refering-URL: http://www.cs.brown.edu/publications/techreports/reports/CS-95-27.html
Root-URL: http://www.cs.brown.edu/
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> P. K. Agarwal and M. Sharir. </author> <title> Applications of a new partition scheme. </title> <journal> Discrete Comput. Geom., </journal> <volume> 9 </volume> <pages> 11-38, </pages> <year> 1993. </year>
Reference-contexts: For a survey of dynamic point-location techniques and other dynamic algorithms in computational geometry, see Chiang and Tamassia [27]. Algorithmic research on shortest-path and ray-shooting queries has also experienced steady progress, resulting in time-optimal techniques for the static setting <ref> [1, 21, 22, 63, 76] </ref>. In particular, the linear-space data structures of Chazelle-Guibas [21] and of Guibas-Hershberger [63] support in O (log n) time ray-shooting and shortest-path queries, respectively, in a simple polygon with n vertices. <p> No polylog-time method was previously known in a dynamic setting, although a polylog-time ray-shooting technique by Reif and Sen [99], designed for monotone polygons, may be extensible to the general case. Sublinear-time techniques are known only for ray-shooting queries <ref> [1, 22] </ref>, with 4 O ( n polylog (n)) query/update time; they support ray-shooting in a set of possibly intersecting segments without taking advantage of the structure of planar maps. A property that appears to greatly facilitate the development of dynamic point-location techniques is monotonicity ([28, 57, 94]). <p> In the final phase, for each i = 3; ::; log (t+1) N 1, we re-color the nodes with color i by assigning them a new color in the range <ref> [0; 1; 2] </ref>. This is done as follows: (a) Determine the predecessor and successor of each node with color i. <p> This step is carried out sorting by ID the nodes in L 1 and L 2 with color i, and uses O (sort (N i )) I/Os. (b) Re-color each node of color i with the smallest color in the range <ref> [0; 1; 2] </ref> that is not currently assigned to its predecessor or successor.
Reference: [2] <author> Alok Aggarwal and Jeffrey S. Vitter. </author> <title> The input/output complexity of sorting and related problems. </title> <journal> Communications of the ACM, </journal> <volume> 31(9) </volume> <pages> 1116-1127, </pages> <year> 1988. </year>
Reference-contexts: of I/Os needed to read x items, and sort (x) = x log M=B B which is proportional to the optimal number of I/Os needed to sort x items [87]. 4.1.2 Previous Work Early work on external-memory algorithms concentrated largely on fundamental problems such as sorting, matrix multiplication, and FFT <ref> [2, 87, 122] </ref>. The main focus of this early work was therefore directed at problems that involved permutation at a basic level. Indeed, just the problem of implementing various classes of permutation has been a central theme in external-memory I/O research [2, 36, 37, 38, 122]. <p> The main focus of this early work was therefore directed at problems that involved permutation at a basic level. Indeed, just the problem of implementing various classes of permutation has been a central theme in external-memory I/O research <ref> [2, 36, 37, 38, 122] </ref>. More recently, external-memory research has moved towards solving geometric and graph problems. For geometric problems, Goodrich et al. [60] study a number of problems in computational geometry and develop several paradigms for I/O-optimal geometric computations. <p> In external memory, however, it is not generally possible to perform arbitrary permutations in a linear number (O (scan (N ))) of I/Os. Instead, it is well-known that fi (perm (N )) I/Os are required in the worst case <ref> [2, 122] </ref> where perm (N ) = min D ; sort (N ) When M or B is extremely small, N=D = O (B scan (N )) may be smaller than sort (N ). <p> In the final phase, for each i = 3; ::; log (t+1) N 1, we re-color the nodes with color i by assigning them a new color in the range <ref> [0; 1; 2] </ref>. This is done as follows: (a) Determine the predecessor and successor of each node with color i. <p> This step is carried out sorting by ID the nodes in L 1 and L 2 with color i, and uses O (sort (N i )) I/Os. (b) Re-color each node of color i with the smallest color in the range <ref> [0; 1; 2] </ref> that is not currently assigned to its predecessor or successor. <p> Distribution sweep theoretically has optimal I/O cost [60]. Plane sweep is a well-known and powerful technique in computational geometry, and is optimal for this particular problem in terms of internal computation [93]. The three variations of plane sweep differ by the sorting methods (external merge sort <ref> [2] </ref> vs. internal merge sort) used in the preprocessing phase and the dynamic data structures (B tree [9, 34, 35] vs. 2-3-4 tree [35]) used in the sweeping phase. <p> Using any dynamic balanced tree, plane sweep takes optimal O (N log N ) time in terms of internal computation. Our three variations of plane sweep differ by the sorting methods and the dynamic data structures used. The first variation, B-Tree, uses external merge sort <ref> [2] </ref> and a B tree [9, 34, 35]; this is a direct way to implement plane sweep in secondary memory. The number of I/O operations performed in the first phase is optimal O ( N B log M N B ) [2], and in the second phase is O (N log <p> The first variation, B-Tree, uses external merge sort <ref> [2] </ref> and a B tree [9, 34, 35]; this is a direct way to implement plane sweep in secondary memory. The number of I/O operations performed in the first phase is optimal O ( N B log M N B ) [2], and in the second phase is O (N log B N B ). <p> Viewing the internal memory as virtually having an infinite size is conceptually the simplest, and is actually the most commonly used strategy today in practice. 5.2.2 Distribution Sweep Distribution sweep [60] is an external-memory version of plane sweep based on the subdivision technique used in the "distribution sort" algorithms of <ref> [2, 86, 122] </ref>. When applied to the orthogonal segment intersection problem, it works as follows. In the preprocessing phase, we sort the endpoints of all segments into two lists, one by x and the other by y. Again we use external merge sort.
Reference: [3] <author> Nancy M. Amato. </author> <title> An optimal algorithm for finding the separation of simple polygons. </title> <booktitle> In Proc. 3rd Workshop Algorithms Data Struct., volume 709 of Lecture Notes in Computer Science, </booktitle> <pages> pages 48-59. </pages> <publisher> Springer-Verlag, </publisher> <year> 1993. </year>
Reference-contexts: If both R 1 and R 2 are convex their separation can be computed in O (log h) time [31, 48, 20, 45]; if only one of them is convex an O (h)-time algorithm is given in [31]; if neither is convex, an optimal algorithm is recently given by Amato <ref> [3] </ref>, who improves the previous result of Kirkpatrick [71] from O (h log h) to O (h).
Reference: [4] <author> R. J. Anderson and G. L. Miller. </author> <title> A simple randomized parallel algorithm for list-ranking. </title> <journal> Info. Proc. Letters, </journal> <volume> 33(5) </volume> <pages> 269-273, </pages> <year> 1990. </year>
Reference-contexts: We present algorithms that use an optimal fi (sort (N )) I/O operations. The lower bound for the problem comes from Corollary 4.1. 66 4.4.1 An Algorithmic Framework for List Ranking Our algorithmic framework is adapted from the work of Anderson and Miller <ref> [4] </ref>. It has also been used by Cole and Vishkin [33], who developed a deterministic version of Anderson and Miller's randomized algorithm. Initially, we assign rank (v) = 1 for each node v in list L. This can be done in O (scan (N )) I/Os. We then proceed recursively. <p> The details of how this independent set is produced are what separate our algorithms from each other. Once we have a large independent set S, we use O (1) sorts and scans to bridge each node v in the set, as described in <ref> [4] </ref>. We then recursively solve the problem on the remaining nodes. Finally, we use O (1) sorts and scans to re-integrate the nodes in S into the final solution. <p> that remains is to demonstrate how an independent set of size fi (N ) can be produced in O (sort (N )) I/Os. 4.4.2 Randomized Independent Set Construction The simplest way to produce a large independent set is a randomized approach based on that first proposed by Anderson and Miller <ref> [4] </ref>. We scan along the input, flipping a fair coin for each vertex v. We then make two copies of the input, sorting one by vertex and the other by successor.
Reference: [5] <author> L. Arge. </author> <title> The buffer tree: A new technique for optimal I/O-algorithms. </title> <booktitle> In Proc. Workshop on Algorithms and Data Structures (to appear), </booktitle> <year> 1995. </year>
Reference-contexts: Further results in this area have been obtained in [51, 125]. Also, Kanellakis et al. [65] and Ramaswamy and Sub-ramanian [98, 106] give efficient data structures for performing range searching in external memory. Very recently, a new data structure called buffer tree and its applications are given in <ref> [5, 6] </ref>, and an external-memory version of the directed topology tree ([52]) called topology B-tree is given in [17]. There has also been some work on selected graph problems, including the investigations by Ullman and Yannakakis [117] on transitive closure computations. <p> The two pointers move sequentially through the list of nodes, so all of the nodes in the tree can be computed with O (scan (N )) additional I/Os. Our alternative algorithm makes use of the external-memory priority queue based on the buffer tree <ref> [5] </ref>, where Insert and DeleteMin operations can each be performed using amortized O ( 1 N B ) I/Os [5]. <p> Our alternative algorithm makes use of the external-memory priority queue based on the buffer tree <ref> [5] </ref>, where Insert and DeleteMin operations can each be performed using amortized O ( 1 N B ) I/Os [5]. We first compute the depth d (v) of each node v by Euler Tour and list ranking, and then sort all nodes into a list L first by nonincreasing depths and then by node IDs. The nodes in L are computed sequentially.
Reference: [6] <author> L. Arge, D. E. Vengroff, and J. S. Vitter. </author> <title> External-memory algorithms for processing line segments in geographic information systems. </title> <note> In Proc. European Symp. Algorithms (to appear), </note> <year> 1995. </year>
Reference-contexts: Further results in this area have been obtained in [51, 125]. Also, Kanellakis et al. [65] and Ramaswamy and Sub-ramanian [98, 106] give efficient data structures for performing range searching in external memory. Very recently, a new data structure called buffer tree and its applications are given in <ref> [5, 6] </ref>, and an external-memory version of the directed topology tree ([52]) called topology B-tree is given in [17]. There has also been some work on selected graph problems, including the investigations by Ullman and Yannakakis [117] on transitive closure computations.
Reference: [7] <author> E. M. Arkin, J. S. B. Mitchell, and S. Suri. </author> <title> Optimal link path queries in a simple polygon. </title> <booktitle> In Proc. 3rd ACM-SIAM Sympos. Discrete Algorithms, </booktitle> <pages> pages 269-279, </pages> <year> 1992. </year>
Reference-contexts: In [109], a scheme based on window partition can answer link distance queries from a fixed source in O (log n) time, after O (n) time preprocessing. The best known results are due to Arkin, Mitchell and Suri <ref> [7] </ref>. Their data structure uses O (n 3 ) space and preprocessing time, and supports minimum-link-path queries between two points and between two segments in optimal O (log n) time (plus O (k) if the k links are reported). <p> The previous best result <ref> [7] </ref> has query time O (log h log n) (and the same space and preprocessing time as ours). * We provide the first fully dynamic data structure for shortest-path queries between two convex polygons in the same region of a connected planar map M. <p> Static Min-Link Paths Query Type Query Space Preprocessing Suri [109] one fixed point and one query point log n fl n fl n fl Arkin-Mitchell- two query points/segments log n fl n 3 n 3 Suri <ref> [7] </ref> two query convex polygons log h log n n 3 n 3 This chapter two query convex polygons log h + log n fl n 3 n 3 fl optimal Table 3.3 Results for static minimum-link-path queries. We briefly outline our techniques. <p> A straightforward method is to compute H G directly. As shown in <ref> [7] </ref>, we can compute the geodesic external tangents between R 1 and R 2 (and hence H G ) by a binary search mimicking the algorithm [90] for finding ordinary common tangents, where in each iteration we compute the shortest path between two chosen points rather than the segment joining them. <p> The data structure given by Arkin, Mitchell and Suri <ref> [7] </ref> supports minimum-link-path queries between two points and between two segments inside P in optimal O (log n) time, and between two convex polygons R 1 and R 2 in time O (log h log n) (plus O (k) if the k links are reported), using O (n 3 ) space <p> Let H G be the geodesic hourglass of R 1 and R 2 , with geodesic tangent points a 1 ; b 1 2 R 1 and a 2 ; b 2 2 R 2 . As shown in <ref> [7] </ref>, a minimum-link path between the two segments s 1 = (a 1 ; b 1 ) and s 2 = (a 2 ; b 2 ) gives a desired minimum-link path between R 1 and R 2 , i.e., L (s 1 ; s 2 ) = L (R 1 <p> Otherwise (H G is closed), extend 1 and 2 to intersect R 1 and R 2 respectively at p and q via binary searches on R 1 and R 2 . Compute L (p; q) (and thus also d L (p; q)) by the algorithm of <ref> [7] </ref>. Report L (R 1 ; R 2 ) = L (p; q), d L (R 1 ; R 2 ) = d L (p; q) and stop. <p> Then e 1 ; ; e j partition G (p; q) into subchains that are always left-turning or always right-turning, namely, into inward convex subchains (see Fig. 3.16). It is shown that every inflection edge e 2 G (p; q) must be contained in L (p; q) <ref> [7, 18, 55] </ref>.
Reference: [8] <author> H. Baumgarten, H. Jung, and K. Mehlhorn. </author> <title> Dynamic point location in general subdivisions. </title> <booktitle> In Proc. 3rd ACM-SIAM Sympos. Discrete Algorithms, </booktitle> <pages> pages 250-258, </pages> <year> 1992. </year>
Reference-contexts: Such methods, however, refer to the static case where no alteration of the map is allowed during its use. Due to the obvious importance of the dynamic setting, in recent years considerable attention has been devoted to the development of dynamic point-location algorithms <ref> [8, 23, 28, 54, 57, 89, 94, 95, 112] </ref>. All the known dynamic point location results are for connected maps, since maintaining region names in a disconnected map would require solving half-planar range searching in a dynamic environment, for which no polylog-time algorithm is known. <p> The best results to-date for dynamic point-location in an n-vertex connected map are due to Cheng-Janardan [23] and Baumgarten-Jung-Mehlhorn <ref> [8] </ref>. The technique of [23] achieves O (log 2 n) query time, O (log n) update time, and O (n) space. The data structure of [8] has query and insertion time O (log n log log n), deletion time O (log 2 n), using O (n) space, where the time bounds <p> The best results to-date for dynamic point-location in an n-vertex connected map are due to Cheng-Janardan [23] and Baumgarten-Jung-Mehlhorn <ref> [8] </ref>. The technique of [23] achieves O (log 2 n) query time, O (log n) update time, and O (n) space. The data structure of [8] has query and insertion time O (log n log log n), deletion time O (log 2 n), using O (n) space, where the time bounds are amortized for the updates.
Reference: [9] <author> R. Bayer and E. McCreight. </author> <title> Organization of large ordered indexes. </title> <journal> Acta Inform., </journal> <volume> 1 </volume> <pages> 173-189, </pages> <year> 1972. </year>
Reference-contexts: The three variations of plane sweep differ by the sorting methods (external merge sort [2] vs. internal merge sort) used in the preprocessing phase and the dynamic data structures (B tree <ref> [9, 34, 35] </ref> vs. 2-3-4 tree [35]) used in the sweeping phase. We generate the test data by three programs that use a random number generator while producing some interesting properties that are predicted by our theoretical analysis. <p> Our three variations of plane sweep differ by the sorting methods and the dynamic data structures used. The first variation, B-Tree, uses external merge sort [2] and a B tree <ref> [9, 34, 35] </ref>; this is a direct way to implement plane sweep in secondary memory. The number of I/O operations performed in the first phase is optimal O ( N B log M N B ) [2], and in the second phase is O (N log B N B ).
Reference: [10] <author> S. W. Bent, D. D. Sleator, and R. E. Tarjan. </author> <title> Biased search trees. </title> <journal> SIAM J. Comput., </journal> <volume> 14 </volume> <pages> 545-568, </pages> <year> 1985. </year>
Reference-contexts: In particular, a simple rotation can be viewed as a sequence of four elementary splits and joins. Three special types of data structures will be used in this chapter: biased binary trees <ref> [10] </ref>, BB [ff]-trees [81], and dynamic trees [104]. A biased binary tree [10] is a binary search tree whose leaves store weighted items. Let w be the sum of all weights. <p> In particular, a simple rotation can be viewed as a sequence of four elementary splits and joins. Three special types of data structures will be used in this chapter: biased binary trees <ref> [10] </ref>, BB [ff]-trees [81], and dynamic trees [104]. A biased binary tree [10] is a binary search tree whose leaves store weighted items. Let w be the sum of all weights. <p> the depth of a leaf with weight w i is at most log (w=w i ) + 2, and each of the following update operations can be done in O (log w) time: change of the weight of an item, insertion/deletion of an item, and split/splice of two biased trees <ref> [10] </ref>. <p> Each arc of the trees is classified as solid or dashed, so that each tree is partitioned into a collection of solid paths, connected by dashed arcs. A solid path is maintained by a data structure called a path tree. Using biased binary trees <ref> [10] </ref> as the standard implementation of path trees, each of the above operations takes O (log n) time, where n is the size of the tree (s) in the forest involved. 2.3 The Dynamics of Trapezoidal Decompositions Given a connected map M, our objective is first to systematically transform (normalize) it <p> Each solid path is associated with a path tree, implemented as a 25 in part (a). biased search tree <ref> [10] </ref>. Note that the sequence of nodes of a solid path of T identifies a sequence of nested trapezoids. <p> By this process, we will finally reach a leaf of a path tree with no exit (representing a leaf of T ), which identifies an edge of the region containing q. Using biased search trees <ref> [10] </ref> as the standard implementation of path trees, we have Lemma 2.13 The time complexity for a point location query is O (log n).
Reference: [11] <author> J. L. Bentley. </author> <title> Experiments on traveling salesman heuristics. </title> <booktitle> In Proc. 1st ACM-SIAM Sympos. Discrete Algorithms, </booktitle> <pages> pages 91-99, </pages> <year> 1990. </year>
Reference-contexts: In Chapter 4, we have presented a collection of new techniques for designing and analyzing I/O-efficient graph algorithms, and apply these techniques to a wide variety of specific problems. Other related theoretical results are reviewed in Section 4.1.2. For excellent examples of experimental work in computational geometry, see Bentley <ref> [11, 12, 13, 14] </ref>. As for experimental work on I/O-efficient computation, very recently Vengroff has built an environment called TPIE for programming external-memory algorithms as he proposed earlier in [120], and also Vengroff and Vitter [119] have reported some benchmarks of TPIE on sorting and matrix multiplication.
Reference: [12] <author> J. L. Bentley. </author> <title> K-d trees for semidynamic point sets. </title> <booktitle> In Proc. 6th Annu. ACM Sympos. Comput. Geom., </booktitle> <pages> pages 187-197, </pages> <year> 1990. </year>
Reference-contexts: In Chapter 4, we have presented a collection of new techniques for designing and analyzing I/O-efficient graph algorithms, and apply these techniques to a wide variety of specific problems. Other related theoretical results are reviewed in Section 4.1.2. For excellent examples of experimental work in computational geometry, see Bentley <ref> [11, 12, 13, 14] </ref>. As for experimental work on I/O-efficient computation, very recently Vengroff has built an environment called TPIE for programming external-memory algorithms as he proposed earlier in [120], and also Vengroff and Vitter [119] have reported some benchmarks of TPIE on sorting and matrix multiplication.
Reference: [13] <author> J. L. Bentley. </author> <title> Tools for experiments on algorithms. </title> <booktitle> In Proc. CMU 25th Anniversary Symp., </booktitle> <year> 1990. </year>
Reference-contexts: In Chapter 4, we have presented a collection of new techniques for designing and analyzing I/O-efficient graph algorithms, and apply these techniques to a wide variety of specific problems. Other related theoretical results are reviewed in Section 4.1.2. For excellent examples of experimental work in computational geometry, see Bentley <ref> [11, 12, 13, 14] </ref>. As for experimental work on I/O-efficient computation, very recently Vengroff has built an environment called TPIE for programming external-memory algorithms as he proposed earlier in [120], and also Vengroff and Vitter [119] have reported some benchmarks of TPIE on sorting and matrix multiplication.
Reference: [14] <author> J. L. Bentley. </author> <title> Fast algorithms for geometric traveling salesman problems. </title> <journal> ORSA J. Comput., </journal> <volume> 4(4) </volume> <pages> 387-411, </pages> <year> 1992. </year>
Reference-contexts: In Chapter 4, we have presented a collection of new techniques for designing and analyzing I/O-efficient graph algorithms, and apply these techniques to a wide variety of specific problems. Other related theoretical results are reviewed in Section 4.1.2. For excellent examples of experimental work in computational geometry, see Bentley <ref> [11, 12, 13, 14] </ref>. As for experimental work on I/O-efficient computation, very recently Vengroff has built an environment called TPIE for programming external-memory algorithms as he proposed earlier in [120], and also Vengroff and Vitter [119] have reported some benchmarks of TPIE on sorting and matrix multiplication.
Reference: [15] <author> O. Berkman and U. Vishkin. </author> <title> Recursive star-tree parallel data structure. </title> <type> Technical report, </type> <institution> Institue for Advanced Computer Studies, Univ. of Maryland, College Park, </institution> <year> 1990. </year>
Reference-contexts: Proof: The problem can be reduced to the range minima problem using Euler Tour and list ranking <ref> [15] </ref>. We construct a search tree S with O (N=B) leaves, each a block storing B data items. Tree S is a complete (M=B)-ary tree with O (log M=B (N=B)) levels, where each internal node v of S corresponds to the items in the subtree S v rooted at v.
Reference: [16] <author> G. Bilardi and F. P. Preparata. </author> <title> Probabilistic analysis of a new geometric searching technique. </title> <type> unpublished manuscript, </type> <year> 1981. </year> <month> 88 </month>
Reference-contexts: In this chapter we combine the feature just stated with the underpinnings of the trapezoid method, whose search efficiency both in theory <ref> [16, 92] </ref> and practice [47] is well-established. This leads to the adoption of horizontal normalizing diagonals, called lids. The method rests on three major components: 1.
Reference: [17] <author> P. Callahan, M. T. Goodrich, and K. Ramaiyer. </author> <title> Topology B-trees and their applications. </title> <booktitle> In Proc. Workshop on Algorithms and Data Structures (to appear), </booktitle> <year> 1995. </year>
Reference-contexts: Very recently, a new data structure called buffer tree and its applications are given in [5, 6], and an external-memory version of the directed topology tree ([52]) called topology B-tree is given in <ref> [17] </ref>. There has also been some work on selected graph problems, including the investigations by Ullman and Yannakakis [117] on transitive closure computations. This work, however, restricts its attention to problem instances where the set of vertices fits into main memory but the set of edges does not.
Reference: [18] <author> V. Chandru, S. K. Ghosh, A. Maheshwari, V. T. Rajan, and S. Saluja. </author> <title> N C-algorithms for minimum link path and related problems. </title> <type> Technical Report CS-90/3, </type> <institution> TATA inst., Bombay, India, </institution> <year> 1990. </year>
Reference-contexts: Their technique can also perform minimum-link-path queries between two convex polygons, however, in non-optimal O (log h log n) time. Also, efficient parallel algorithms are given in <ref> [18] </ref>. There are other results on the variations of the minimum-link-path problem. Efficient algorithms for link diameter and link center are given in [44, 56, 78, 67, 85, 84, 108]. A minimum-link path between two fixed points in a multiply connected polygon can be computed efficiently [83]. <p> Then e 1 ; ; e j partition G (p; q) into subchains that are always left-turning or always right-turning, namely, into inward convex subchains (see Fig. 3.16). It is shown that every inflection edge e 2 G (p; q) must be contained in L (p; q) <ref> [7, 18, 55] </ref>.
Reference: [19] <author> B. Chazelle. </author> <title> Triangulating a simple polygon in linear time. </title> <journal> Discrete Comput. Geom., </journal> <volume> 6 </volume> <pages> 485-524, </pages> <year> 1991. </year>
Reference-contexts: Point-location queries can also be performed in O (log n) time. The data structure uses O (n) space and can be built in O (n) time after triangulating P (again in O (n) time by Chazelle's linear-time triangulation algorithm <ref> [19] </ref>). We modify this data structure so that associated with the implicit representation of a shortest path G , there are two balanced binary trees respectively maintaining the inflection edges and the cusps on G in their path order.
Reference: [20] <author> B. Chazelle and D. P. Dobkin. </author> <title> Intersection of convex objects in two and three dimensions. </title> <journal> J. ACM, </journal> <volume> 34 </volume> <pages> 1-27, </pages> <year> 1987. </year>
Reference-contexts: If both R 1 and R 2 are convex their separation can be computed in O (log h) time <ref> [31, 48, 20, 45] </ref>; if only one of them is convex an O (h)-time algorithm is given in [31]; if neither is convex, an optimal algorithm is recently given by Amato [3], who improves the previous result of Kirkpatrick [71] from O (h log h) to O (h). <p> C R1 , from R 2 and C L2 , and from R 2 and C R2 , respectively). (a) Check whether R 1 intersects C L1 (viewing C L1 = G (l 1 ; x) as a convex polygon with edge (l 1 ; x) added) using the algorithm <ref> [20] </ref>, which runs in logarithmic time and also reports a common point g inside both R 1 and C L1 if they intersect. <p> We compute two shortest-path queries and extract four bounding convex chains in step 4. Step 5a invloves O (1) calls to algorithm <ref> [20] </ref>, and O (1) tangent computations and binary searches. Step 5 (a)i can be done in O (1) time, and step 5 (a)ii performs O (1) path extractions and tangent computations. Step 5b applies the computation of Lemma 3.3, which is a binary search. <p> The observed K values of data-long are indeed 1 8 N (see Fig. 5.1), and the observed values of the average number of vertical overlaps are also 1 8 N (see Fig. 5.3). In program gen-rect, we generate horizontal and vertical segments with lengths uniformly distributed over <ref> [20; 60] </ref> and over [0; 2N ], respectively.
Reference: [21] <author> B. Chazelle and L. J. Guibas. </author> <title> Visibility and intersection problems in plane geometry. </title> <journal> Discrete Comput. Geom., </journal> <volume> 4 </volume> <pages> 551-581, </pages> <year> 1989. </year>
Reference-contexts: For a survey of dynamic point-location techniques and other dynamic algorithms in computational geometry, see Chiang and Tamassia [27]. Algorithmic research on shortest-path and ray-shooting queries has also experienced steady progress, resulting in time-optimal techniques for the static setting <ref> [1, 21, 22, 63, 76] </ref>. In particular, the linear-space data structures of Chazelle-Guibas [21] and of Guibas-Hershberger [63] support in O (log n) time ray-shooting and shortest-path queries, respectively, in a simple polygon with n vertices. <p> Algorithmic research on shortest-path and ray-shooting queries has also experienced steady progress, resulting in time-optimal techniques for the static setting [1, 21, 22, 63, 76]. In particular, the linear-space data structures of Chazelle-Guibas <ref> [21] </ref> and of Guibas-Hershberger [63] support in O (log n) time ray-shooting and shortest-path queries, respectively, in a simple polygon with n vertices.
Reference: [22] <author> S. W. Cheng and R. Janardan. </author> <title> Space-efficient ray shooting and intersection searching: algorithms, </title> <booktitle> dynamization and applications. In Proc. 2nd ACM-SIAM Sympos. Discrete Algorithms, </booktitle> <pages> pages 7-16, </pages> <year> 1991. </year>
Reference-contexts: For a survey of dynamic point-location techniques and other dynamic algorithms in computational geometry, see Chiang and Tamassia [27]. Algorithmic research on shortest-path and ray-shooting queries has also experienced steady progress, resulting in time-optimal techniques for the static setting <ref> [1, 21, 22, 63, 76] </ref>. In particular, the linear-space data structures of Chazelle-Guibas [21] and of Guibas-Hershberger [63] support in O (log n) time ray-shooting and shortest-path queries, respectively, in a simple polygon with n vertices. <p> No polylog-time method was previously known in a dynamic setting, although a polylog-time ray-shooting technique by Reif and Sen [99], designed for monotone polygons, may be extensible to the general case. Sublinear-time techniques are known only for ray-shooting queries <ref> [1, 22] </ref>, with 4 O ( n polylog (n)) query/update time; they support ray-shooting in a set of possibly intersecting segments without taking advantage of the structure of planar maps. A property that appears to greatly facilitate the development of dynamic point-location techniques is monotonicity ([28, 57, 94]).
Reference: [23] <author> S. W. Cheng and R. Janardan. </author> <title> New results on dynamic planar point location. </title> <journal> SIAM J. Comput., </journal> <volume> 21 </volume> <pages> 972-999, </pages> <year> 1992. </year>
Reference-contexts: Such methods, however, refer to the static case where no alteration of the map is allowed during its use. Due to the obvious importance of the dynamic setting, in recent years considerable attention has been devoted to the development of dynamic point-location algorithms <ref> [8, 23, 28, 54, 57, 89, 94, 95, 112] </ref>. All the known dynamic point location results are for connected maps, since maintaining region names in a disconnected map would require solving half-planar range searching in a dynamic environment, for which no polylog-time algorithm is known. <p> The best results to-date for dynamic point-location in an n-vertex connected map are due to Cheng-Janardan <ref> [23] </ref> and Baumgarten-Jung-Mehlhorn [8]. The technique of [23] achieves O (log 2 n) query time, O (log n) update time, and O (n) space. <p> The best results to-date for dynamic point-location in an n-vertex connected map are due to Cheng-Janardan <ref> [23] </ref> and Baumgarten-Jung-Mehlhorn [8]. The technique of [23] achieves O (log 2 n) query time, O (log n) update time, and O (n) space.
Reference: [24] <author> Y.-J. Chiang. </author> <title> Experiments on the practical I/O efficiency of geometric algorithms: Distribution sweep vs. plane sweep. </title> <booktitle> In Proc. Workshop on Algorithms and Data Structures (to appear), </booktitle> <year> 1995. </year>
Reference-contexts: Remark. Most of the results presented in this dissertation have been published by the Author in journals and/or proceedings of conferences: Chapters 2 and 3 are based on [26] and [29], and summaries of the results in Chapters 4 and 5 have respectively appeared in [25] and <ref> [24] </ref>. 3 Chapter 2 Dynamic Point Location, Ray Shooting and Shortest Paths 2.1 Introduction A number of operations within the context of planar maps (or subdivisions, as determined by a planar graph embedded in the plane) have long been regarded as important primitives in computational geometry.
Reference: [25] <author> Y.-J. Chiang, M. T. Goodrich, E. F. Grove, R. Tamassia, D. E. Vengroff, and J. S. Vitter. </author> <title> External-memory graph algorithms. </title> <booktitle> In Proc. 6th ACM-SIAM Symp. on Discrete Algorithms, </booktitle> <pages> pages 139-149, </pages> <year> 1995. </year>
Reference-contexts: Remark. Most of the results presented in this dissertation have been published by the Author in journals and/or proceedings of conferences: Chapters 2 and 3 are based on [26] and [29], and summaries of the results in Chapters 4 and 5 have respectively appeared in <ref> [25] </ref> and [24]. 3 Chapter 2 Dynamic Point Location, Ray Shooting and Shortest Paths 2.1 Introduction A number of operations within the context of planar maps (or subdivisions, as determined by a planar graph embedded in the plane) have long been regarded as important primitives in computational geometry. <p> The lower bound (perm (N )) holds even in some important cases when we are not required to perform all N ! possible permutations. In [118] (also appearing in <ref> [25] </ref>) a problem called proximate neighbors, which is a significantly-restricted form of permutation, is used to derive a number of non-trivial lower bounds. The proximate neighbors problem is defined as follows: Initially, we have N items in external memory, each with a key that is a positive integer k N=2. <p> Theorem 4.5 An N -node general expression tree can be evaluated with optimal O (sort (N )) I/Os. Proof: We give two algorithms; the first one is based on [62] (also appearing in the conference version <ref> [25] </ref> of this chapter) and the second one is new. The first algorithm works as follows. By using Euler Tour and list ranking twice, we compute the depth and also the preorder numbering of each node. <p> The verification step in [66, 74] to check whether an edge forming a cycle is heavy enough to be removed is carried out by the O ((E=V )sort (V ))-I/O minimum spanning tree verification method of [61] (also appearing in <ref> [25] </ref>) which is based on that of King [70]. This gives the following theorem.
Reference: [26] <author> Y.-J. Chiang, F. P. Preparata, and R. Tamassia. </author> <title> A unified approach to dynamic point location, ray shooting, and shortest paths in planar maps. </title> <note> SIAM J. Comput., to appear. </note> <author> Prelim. </author> <title> version: </title> <booktitle> In Proc. 4th ACM-SIAM Sympos. Discrete Algorithms, </booktitle> <pages> pages 44-53, </pages> <year> 1993. </year>
Reference-contexts: This is the first experimental work comparing the practical performance between external-memory algorithms and conventional algorithms with large-scale test data. Remark. Most of the results presented in this dissertation have been published by the Author in journals and/or proceedings of conferences: Chapters 2 and 3 are based on <ref> [26] </ref> and [29], and summaries of the results in Chapters 4 and 5 have respectively appeared in [25] and [24]. 3 Chapter 2 Dynamic Point Location, Ray Shooting and Shortest Paths 2.1 Introduction A number of operations within the context of planar maps (or subdivisions, as determined by a planar graph <p> Although there has been a lot of work on the separation problem, the more general shortest-path problem for two objects in the presence of obstacle P has been previously studied only for the simple case when the objects are points, for which there exist efficient static [63] and dynamic <ref> [26, 59] </ref> solutions. The static technique of [63] supports two-point shortest-path queries in optimal O (log n) time (plus O (k) if the k edges of the path are reported), employing a data structure that uses O (n) space and can be built in linear time. <p> The static technique of [63] supports two-point shortest-path queries in optimal O (log n) time (plus O (k) if the k edges of the path are reported), employing a data structure that uses O (n) space and can be built in linear time. The dynamic technique of <ref> [26] </ref>, as already presented in Chapter 2, performs shortest-path queries between two points in the same region of a connected planar map M with n vertices in O (log 3 n) time (plus O (k) to report the k edges of the path), using a data structure with O (n log <p> Dynamic Shortest Paths Query Type Query Space Update Chiang-Preparata-Tamassia <ref> [26] </ref> (Chapter 2) two query points log 3 n n log n log 3 n Goodrich-Tamassia [59] two query points log 2 n n fl log 2 n This chapter two query convex polygons log h + log 2 n n fl log 2 n fl optimal Table 3.2 Results for
Reference: [27] <author> Y.-J. Chiang and R. Tamassia. </author> <title> Dynamic algorithms in computational geometry. </title> <journal> Proc. IEEE, </journal> <volume> 80(9) </volume> <pages> 1412-1434, </pages> <month> September </month> <year> 1992. </year>
Reference-contexts: The only previous technique that supports O (log n)-time queries in a dynamic environment is restricted to monotone maps [28]. For a survey of dynamic point-location techniques and other dynamic algorithms in computational geometry, see Chiang and Tamassia <ref> [27] </ref>. Algorithmic research on shortest-path and ray-shooting queries has also experienced steady progress, resulting in time-optimal techniques for the static setting [1, 21, 22, 63, 76].
Reference: [28] <author> Y.-J. Chiang and R. Tamassia. </author> <title> Dynamization of the trapezoid method for planar point location in monotone subdivisions. </title> <journal> Internat. J. Comput. Geom. Appl., </journal> <volume> 2(3) </volume> <pages> 311-333, </pages> <year> 1992. </year> <title> Prelim. version: </title> <booktitle> In Proc. 7th Annu. ACM Sympos. Comput. Geom., </booktitle> <pages> pages 61-70, </pages> <year> 1991. </year>
Reference-contexts: In my master's work <ref> [28] </ref>, a fully dynamic data structure for point location in a monotone map is presented, based on the trapezoid method. The update operations supported are insertion and deletion of vertices and edges, and horizontal translation of vertices. <p> Such methods, however, refer to the static case where no alteration of the map is allowed during its use. Due to the obvious importance of the dynamic setting, in recent years considerable attention has been devoted to the development of dynamic point-location algorithms <ref> [8, 23, 28, 54, 57, 89, 94, 95, 112] </ref>. All the known dynamic point location results are for connected maps, since maintaining region names in a disconnected map would require solving half-planar range searching in a dynamic environment, for which no polylog-time algorithm is known. <p> In many real-time applications, point-location queries are executed more frequently than updates, so that it is often desirable to achieve optimal O (log n) query time in a dynamic setting. The only previous technique that supports O (log n)-time queries in a dynamic environment is restricted to monotone maps <ref> [28] </ref>. For a survey of dynamic point-location techniques and other dynamic algorithms in computational geometry, see Chiang and Tamassia [27]. Algorithmic research on shortest-path and ray-shooting queries has also experienced steady progress, resulting in time-optimal techniques for the static setting [1, 21, 22, 63, 76]. <p> If q is on an vertex or edge, then return that vertex or edge. Our dynamic point-location data structure is inspired by the static trapezoid method [92] and its dynamic version for monotone maps <ref> [28] </ref>. It uses the normalization and hull structures as the underpinning of update operations. Queries are instead performed in a location structure, a binary tree called trapezoid tree. The trapezoid tree defines a binary partition of the plane obtained by means of vertical and horizontal cuts. <p> Queries are instead performed in a location structure, a binary tree called trapezoid tree. The trapezoid tree defines a binary partition of the plane obtained by means of vertical and horizontal cuts. It differs in many substantial aspects from the trapezoid trees used in <ref> [28, 92] </ref>, the most striking difference being that it is not balanced. The trapezoid tree T for map M is based on the Y-tree Y (see Section 2.4) and on the normalization of M as reflected by the normalization structure (see Section 2.3).
Reference: [29] <author> Y.-J. Chiang and R. Tamassia. </author> <title> Optimal shortest path and minimum-link path queries between two convex polygons inside a simple polygonal obstacle. </title> <journal> Internat. J. Comput. Geom. Appl., </journal> <year> 1995. </year> <title> Prelim. version: </title> <booktitle> In Proc. 2nd Annu. European Sympos. Algorithms (ESA '94), volume 855 of Lecture Notes in Computer Science, </booktitle> <pages> pages 266-277. </pages> <publisher> Springer-Verlag, </publisher> <year> 1994. </year>
Reference-contexts: Remark. Most of the results presented in this dissertation have been published by the Author in journals and/or proceedings of conferences: Chapters 2 and 3 are based on [26] and <ref> [29] </ref>, and summaries of the results in Chapters 4 and 5 have respectively appeared in [25] and [24]. 3 Chapter 2 Dynamic Point Location, Ray Shooting and Shortest Paths 2.1 Introduction A number of operations within the context of planar maps (or subdivisions, as determined by a planar graph embedded in
Reference: [30] <author> N. Chiba, T. Nishizeki, S. Abe, and T. Ozawa. </author> <title> A linear algorithm for embedding planar graphs using PQ-trees. </title> <journal> J. Comput. Syst. Sci., </journal> <volume> 30(1) </volume> <pages> 54-76, </pages> <year> 1985. </year>
Reference-contexts: Planar st-graphs were first introduced by Lempel, Even, and Cederbaum [77] in connection with a planarity testing algorithm, and have subsequently been used in a host of applications, dealing with partial orders [68], planar graph embedding <ref> [30, 42, 111] </ref>, graph planarization [91], 71 graph drawing [41, 43], floor planning [123], planar point location [49, 94], visibility [73, 88, 102, 113, 114, 124], motion planning [101], and VLSI layout compaction [123].
Reference: [31] <author> F. Chin and C. A. Wang. </author> <title> Optimal algorithms for the intersection and the minimum distance problems between planar polygons. </title> <journal> IEEE Trans. Comput., </journal> <volume> C-32(12):1203-1207, </volume> <year> 1983. </year>
Reference-contexts: If both R 1 and R 2 are convex their separation can be computed in O (log h) time <ref> [31, 48, 20, 45] </ref>; if only one of them is convex an O (h)-time algorithm is given in [31]; if neither is convex, an optimal algorithm is recently given by Amato [3], who improves the previous result of Kirkpatrick [71] from O (h log h) to O (h). <p> If both R 1 and R 2 are convex their separation can be computed in O (log h) time [31, 48, 20, 45]; if only one of them is convex an O (h)-time algorithm is given in <ref> [31] </ref>; if neither is convex, an optimal algorithm is recently given by Amato [3], who improves the previous result of Kirkpatrick [71] from O (h log h) to O (h). <p> Ignoring P and using any one of the methods for computing the separation of two convex polygons <ref> [31, 45, 48] </ref>, we can find p 0 2 R 1 and q 0 2 R 2 with length (p 0 ; q 0 ) = (R 1 ; R 2 ) in O (log h) time. Now we compute G (p 0 ; q 0 ). <p> Algorithm Visible-Path 1. Ignore P and compute the separation (R 1 ; R 2 ) of R 1 and R 2 by any one of the methods <ref> [31, 45, 48] </ref>, which gives two points p 0 2 R 1 and q 0 2 R 2 such that length (p 0 ; q 0 ) = (R 1 ; R 2 ). 2. Compute G (p 0 ; q 0 ).
Reference: [32] <author> F. Y. Chin, J. Lam, and I. Chen. </author> <title> Efficient parallel algorithms for some graph problems. </title> <journal> Comm. of the ACM, </journal> <volume> 25(9) </volume> <pages> 659-665, </pages> <year> 1982. </year>
Reference-contexts: Proof: For connected components and minimum spanning forest, our algorithm is based on that of Chin et al. <ref> [32] </ref>. Each iteration performs a constant number of sorts on current edges and one list ranking to reduce the number of vertices by a constant factor. After O (log (V =M )) iterations we fit the remaining M vertices to the main memory and solve the problem easily.
Reference: [33] <author> R. Cole and U. Vishkin. </author> <title> Deterministic coin tossing with applications to optimal list-ranking. </title> <journal> Information and Control, </journal> <volume> 70(1) </volume> <pages> 32-53, </pages> <year> 1986. </year>
Reference-contexts: The lower bound for the problem comes from Corollary 4.1. 66 4.4.1 An Algorithmic Framework for List Ranking Our algorithmic framework is adapted from the work of Anderson and Miller [4]. It has also been used by Cole and Vishkin <ref> [33] </ref>, who developed a deterministic version of Anderson and Miller's randomized algorithm. Initially, we assign rank (v) = 1 for each node v in list L. This can be done in O (scan (N )) I/Os. We then proceed recursively. <p> This step can be done by performing t+1 times an external-memory variation of deterministic coin tossing (obtained by simulating the PRAM algorithm of <ref> [33] </ref>), and takes O ((t + 1) sort (N )) I/Os.
Reference: [34] <author> D. Comer. </author> <title> The ubiquitous B-tree. </title> <journal> ACM Comput. Surv., </journal> <volume> 11 </volume> <pages> 121-137, </pages> <year> 1979. </year>
Reference-contexts: The three variations of plane sweep differ by the sorting methods (external merge sort [2] vs. internal merge sort) used in the preprocessing phase and the dynamic data structures (B tree <ref> [9, 34, 35] </ref> vs. 2-3-4 tree [35]) used in the sweeping phase. We generate the test data by three programs that use a random number generator while producing some interesting properties that are predicted by our theoretical analysis. <p> Our three variations of plane sweep differ by the sorting methods and the dynamic data structures used. The first variation, B-Tree, uses external merge sort [2] and a B tree <ref> [9, 34, 35] </ref>; this is a direct way to implement plane sweep in secondary memory. The number of I/O operations performed in the first phase is optimal O ( N B log M N B ) [2], and in the second phase is O (N log B N B ).
Reference: [35] <author> T. H. Cormen, C. E. Leiserson, and R. L. Rivest. </author> <title> Introduction to Algorithms. </title> <publisher> The MIT Press, </publisher> <address> 89 Cambridge, Mass., </address> <year> 1990. </year>
Reference-contexts: The three variations of plane sweep differ by the sorting methods (external merge sort [2] vs. internal merge sort) used in the preprocessing phase and the dynamic data structures (B tree <ref> [9, 34, 35] </ref> vs. 2-3-4 tree [35]) used in the sweeping phase. We generate the test data by three programs that use a random number generator while producing some interesting properties that are predicted by our theoretical analysis. <p> The three variations of plane sweep differ by the sorting methods (external merge sort [2] vs. internal merge sort) used in the preprocessing phase and the dynamic data structures (B tree [9, 34, 35] vs. 2-3-4 tree <ref> [35] </ref>) used in the sweeping phase. We generate the test data by three programs that use a random number generator while producing some interesting properties that are predicted by our theoretical analysis. The sizes of the test data range from 250 thousand segments to 2.5 million segments. <p> Our three variations of plane sweep differ by the sorting methods and the dynamic data structures used. The first variation, B-Tree, uses external merge sort [2] and a B tree <ref> [9, 34, 35] </ref>; this is a direct way to implement plane sweep in secondary memory. The number of I/O operations performed in the first phase is optimal O ( N B log M N B ) [2], and in the second phase is O (N log B N B ). <p> The number of I/O operations performed in the first phase is optimal O ( N B log M N B ) [2], and in the second phase is O (N log B N B ). The second variation, 234-Tree, uses external merge sort and a 2-3-4 tree <ref> [35] </ref>, viewing the internal memory as having an infinite size and letting the virtual memory feature of the OS handle page faults during the second (sweeping) phase.
Reference: [36] <author> Thomas H. Cormen. </author> <title> Virtual Memory for Data Parallel Computing. </title> <type> PhD thesis, </type> <institution> Department of Electrical Engineering and Computer Science, Massachusetts Institute of Technology, </institution> <year> 1992. </year>
Reference-contexts: The main focus of this early work was therefore directed at problems that involved permutation at a basic level. Indeed, just the problem of implementing various classes of permutation has been a central theme in external-memory I/O research <ref> [2, 36, 37, 38, 122] </ref>. More recently, external-memory research has moved towards solving geometric and graph problems. For geometric problems, Goodrich et al. [60] study a number of problems in computational geometry and develop several paradigms for I/O-optimal geometric computations. <p> We show in subsequent sections how to combine these techniques with more sophisticated strategies to design efficient external-memory algorithms for a number of graph problems. Related work on simulating PRAM computations in external memory is done by Cormen <ref> [36] </ref>. The use of PRAM simulation for prefetching, without the important consideration of blocking, is explored by Vishkin [121]. 4.3.1 Generic Simulation of a PRAM Algorithm We begin by considering how to simulate a PRAM algorithm A.
Reference: [37] <author> Thomas H. Cormen. </author> <title> Fast permuting in disk arrays. </title> <journal> Journal of Parallel and Distributed Computing, 17(1-2):41-57, </journal> <volume> Jan./Feb. </volume> <year> 1993. </year>
Reference-contexts: The main focus of this early work was therefore directed at problems that involved permutation at a basic level. Indeed, just the problem of implementing various classes of permutation has been a central theme in external-memory I/O research <ref> [2, 36, 37, 38, 122] </ref>. More recently, external-memory research has moved towards solving geometric and graph problems. For geometric problems, Goodrich et al. [60] study a number of problems in computational geometry and develop several paradigms for I/O-optimal geometric computations.
Reference: [38] <author> Thomas H. Cormen, Thomas Sundquist, and Leonard F. Wisniewski. </author> <title> Asymptotically tight bounds for performing BMMC permutations on parallel disk systems. </title> <type> Technical Report PCS-TR94-223, </type> <institution> Dartmouth College Dept. of Computer Science, </institution> <month> July </month> <year> 1994. </year>
Reference-contexts: The main focus of this early work was therefore directed at problems that involved permutation at a basic level. Indeed, just the problem of implementing various classes of permutation has been a central theme in external-memory I/O research <ref> [2, 36, 37, 38, 122] </ref>. More recently, external-memory research has moved towards solving geometric and graph problems. For geometric problems, Goodrich et al. [60] study a number of problems in computational geometry and develop several paradigms for I/O-optimal geometric computations.
Reference: [39] <author> M. de Berg. </author> <title> On rectilinear link distance. </title> <journal> Comput. Geom. Theory Appl., </journal> <volume> 1(1) </volume> <pages> 13-34, </pages> <month> July </month> <year> 1991. </year>
Reference-contexts: Efficient algorithms for link diameter and link center are given in [44, 56, 78, 67, 85, 84, 108]. A minimum-link path between two fixed points in a multiply connected polygon can be computed efficiently [83]. Sequential and parallel algorithms for rectilinear link distance are respectively given by de Berg <ref> [39] </ref> and Lingas et al. [79]. De Berg et al. [40] study the problem of finding a shortest rectilinear path among rectilinear obstacles.
Reference: [40] <author> M. de Berg, M. van Kreveld, B. J. Nilsson, and M. H. Overmars. </author> <title> Finding shortest paths in the presence of orthogonal obstacles using a combined L 1 and link metric. </title> <booktitle> In Proc. 2nd Scand. Workshop Algorithm Theory, volume 447 of Lecture Notes in Computer Science, </booktitle> <pages> pages 213-224. </pages> <publisher> Springer-Verlag, </publisher> <year> 1990. </year>
Reference-contexts: A minimum-link path between two fixed points in a multiply connected polygon can be computed efficiently [83]. Sequential and parallel algorithms for rectilinear link distance are respectively given by de Berg [39] and Lingas et al. [79]. De Berg et al. <ref> [40] </ref> study the problem of finding a shortest rectilinear path among rectilinear obstacles. Mitchell et al. [82] consider the problem of finding a shortest path with at most K links between two query points inside a simple polygon, where K is an input parameter.
Reference: [41] <author> G. Di Battista and R. Tamassia. </author> <title> Algorithms for plane representations of acyclic digraphs. </title> <journal> Theoret. Comput. Sci., </journal> <volume> 61 </volume> <pages> 175-198, </pages> <year> 1988. </year>
Reference-contexts: Planar st-graphs were first introduced by Lempel, Even, and Cederbaum [77] in connection with a planarity testing algorithm, and have subsequently been used in a host of applications, dealing with partial orders [68], planar graph embedding [30, 42, 111], graph planarization [91], 71 graph drawing <ref> [41, 43] </ref>, floor planning [123], planar point location [49, 94], visibility [73, 88, 102, 113, 114, 124], motion planning [101], and VLSI layout compaction [123]. In this section, we consider a planar st-digraph G with V vertices, and recall that G has O (V ) edges.
Reference: [42] <author> G. Di Battista and R. Tamassia. </author> <title> Incremental planarity testing. </title> <booktitle> In Proc. 30th Annu. IEEE Sympos. Found. Comput. Sci., </booktitle> <pages> pages 436-441, </pages> <year> 1989. </year>
Reference-contexts: Planar st-graphs were first introduced by Lempel, Even, and Cederbaum [77] in connection with a planarity testing algorithm, and have subsequently been used in a host of applications, dealing with partial orders [68], planar graph embedding <ref> [30, 42, 111] </ref>, graph planarization [91], 71 graph drawing [41, 43], floor planning [123], planar point location [49, 94], visibility [73, 88, 102, 113, 114, 124], motion planning [101], and VLSI layout compaction [123].
Reference: [43] <author> G. Di Battista, R. Tamassia, and I. G. Tollis. </author> <title> Area requirement and symmetry display of planar upward drawings. </title> <journal> Discrete Comput. Geom., </journal> <volume> 7 </volume> <pages> 381-401, </pages> <year> 1992. </year>
Reference-contexts: Planar st-graphs were first introduced by Lempel, Even, and Cederbaum [77] in connection with a planarity testing algorithm, and have subsequently been used in a host of applications, dealing with partial orders [68], planar graph embedding [30, 42, 111], graph planarization [91], 71 graph drawing <ref> [41, 43] </ref>, floor planning [123], planar point location [49, 94], visibility [73, 88, 102, 113, 114, 124], motion planning [101], and VLSI layout compaction [123]. In this section, we consider a planar st-digraph G with V vertices, and recall that G has O (V ) edges.
Reference: [44] <author> H. N. Djidjev, A. Lingas, and J.-R. Sack. </author> <title> An O(n log n) algorithm for computing the link center of a simple polygon. </title> <journal> Discrete Comput. Geom., </journal> <volume> 8 </volume> <pages> 131-152, </pages> <year> 1992. </year>
Reference-contexts: Also, efficient parallel algorithms are given in [18]. There are other results on the variations of the minimum-link-path problem. Efficient algorithms for link diameter and link center are given in <ref> [44, 56, 78, 67, 85, 84, 108] </ref>. A minimum-link path between two fixed points in a multiply connected polygon can be computed efficiently [83]. Sequential and parallel algorithms for rectilinear link distance are respectively given by de Berg [39] and Lingas et al. [79].
Reference: [45] <author> D. P. Dobkin and D. G. Kirkpatrick. </author> <title> Determining the separation of preprocessed polyhedra a unified approach. </title> <booktitle> In Proc. 17th Internat. Colloq. Automata Lang. Program., volume 443 of Lecture Notes in Computer Science, </booktitle> <pages> pages 400-413. </pages> <publisher> Springer-Verlag, </publisher> <year> 1990. </year>
Reference-contexts: The related problem of computing the length of the shortest path between two polygons R 1 and R 2 without obstacle P has been extensively studied; this problem is also known as finding the separation of the two polygons <ref> [45] </ref>, denoted by (R 1 ; R 2 ). <p> If both R 1 and R 2 are convex their separation can be computed in O (log h) time <ref> [31, 48, 20, 45] </ref>; if only one of them is convex an O (h)-time algorithm is given in [31]; if neither is convex, an optimal algorithm is recently given by Amato [3], who improves the previous result of Kirkpatrick [71] from O (h log h) to O (h). <p> Ignoring P and using any one of the methods for computing the separation of two convex polygons <ref> [31, 45, 48] </ref>, we can find p 0 2 R 1 and q 0 2 R 2 with length (p 0 ; q 0 ) = (R 1 ; R 2 ) in O (log h) time. Now we compute G (p 0 ; q 0 ). <p> Algorithm Visible-Path 1. Ignore P and compute the separation (R 1 ; R 2 ) of R 1 and R 2 by any one of the methods <ref> [31, 45, 48] </ref>, which gives two points p 0 2 R 1 and q 0 2 R 2 such that length (p 0 ; q 0 ) = (R 1 ; R 2 ). 2. Compute G (p 0 ; q 0 ).
Reference: [46] <author> D. P. Dobkin and R. J. Lipton. </author> <title> Multidimensional searching problems. </title> <journal> SIAM J. Comput., </journal> <volume> 5 </volume> <pages> 181-186, </pages> <year> 1976. </year>
Reference-contexts: First and foremost among these operations is planar point-location, i.e., the identification of the map region containing a given query point; but also shortest-path and ray-shooting queries have been considered very prominently. Starting with the pioneering work in planar point-location of the seventies <ref> [46, 75] </ref>, over the years several techniques have been developed, culminating in asymptotically time- and space-optimal methods [49, 72, 103] that are also of sufficiently practical flavor. Such methods, however, refer to the static case where no alteration of the map is allowed during its use.
Reference: [47] <author> M. Edahiro, I. Kokubo, and Ta. Asano. </author> <title> A new point-location algorithm and its practical efficiency: comparison with existing algorithms. </title> <journal> ACM Trans. Graph., </journal> <volume> 3 </volume> <pages> 86-109, </pages> <year> 1984. </year>
Reference-contexts: In this chapter we combine the feature just stated with the underpinnings of the trapezoid method, whose search efficiency both in theory [16, 92] and practice <ref> [47] </ref> is well-established. This leads to the adoption of horizontal normalizing diagonals, called lids. The method rests on three major components: 1.
Reference: [48] <author> H. Edelsbrunner. </author> <title> Computing the extreme distances between two convex polygons. </title> <journal> J. Algorithms, </journal> <volume> 6 </volume> <pages> 213-224, </pages> <year> 1985. </year>
Reference-contexts: If both R 1 and R 2 are convex their separation can be computed in O (log h) time <ref> [31, 48, 20, 45] </ref>; if only one of them is convex an O (h)-time algorithm is given in [31]; if neither is convex, an optimal algorithm is recently given by Amato [3], who improves the previous result of Kirkpatrick [71] from O (h log h) to O (h). <p> Ignoring P and using any one of the methods for computing the separation of two convex polygons <ref> [31, 45, 48] </ref>, we can find p 0 2 R 1 and q 0 2 R 2 with length (p 0 ; q 0 ) = (R 1 ; R 2 ) in O (log h) time. Now we compute G (p 0 ; q 0 ). <p> Algorithm Visible-Path 1. Ignore P and compute the separation (R 1 ; R 2 ) of R 1 and R 2 by any one of the methods <ref> [31, 45, 48] </ref>, which gives two points p 0 2 R 1 and q 0 2 R 2 such that length (p 0 ; q 0 ) = (R 1 ; R 2 ). 2. Compute G (p 0 ; q 0 ).
Reference: [49] <author> H. Edelsbrunner, L. J. Guibas, and J. Stolfi. </author> <title> Optimal point location in a monotone subdivision. </title> <journal> SIAM J. Comput., </journal> <volume> 15 </volume> <pages> 317-340, </pages> <year> 1986. </year>
Reference-contexts: Starting with the pioneering work in planar point-location of the seventies [46, 75], over the years several techniques have been developed, culminating in asymptotically time- and space-optimal methods <ref> [49, 72, 103] </ref> that are also of sufficiently practical flavor. Such methods, however, refer to the static case where no alteration of the map is allowed during its use. <p> first introduced by Lempel, Even, and Cederbaum [77] in connection with a planarity testing algorithm, and have subsequently been used in a host of applications, dealing with partial orders [68], planar graph embedding [30, 42, 111], graph planarization [91], 71 graph drawing [41, 43], floor planning [123], planar point location <ref> [49, 94] </ref>, visibility [73, 88, 102, 113, 114, 124], motion planning [101], and VLSI layout compaction [123]. In this section, we consider a planar st-digraph G with V vertices, and recall that G has O (V ) edges. The results in this section are summarized in Table 4.3.
Reference: [50] <author> Esteban Feuerstein and Alberto Marchetti-Spaccamela. </author> <title> Memory paging for connectivity and path problems in graphs. </title> <booktitle> In Proc. Int. Symp. on Algorithms and Comp., </booktitle> <year> 1993. </year>
Reference-contexts: Vishkin [121] uses PRAM simulation to facilitate prefetching for various problems, but without taking blocking issues into account. Also worth noting is recent work [58] on some graph traversal problems; this work primarily addresses the problem of storing graphs, however, not in performing specific computations on them. Related work <ref> [50] </ref> proposes a framework for studying memory management problems for maintaining connectivity information and paths on graphs.
Reference: [51] <author> P. G. Franciosa and M. Talamo. </author> <title> Orders, implicit k-sets representation and fast halfplane searching. </title> <booktitle> In Proc. Workshop on Orders, Algorithms and Applications (ORDAL'94), </booktitle> <pages> pages 117-127, </pages> <year> 1994. </year>
Reference-contexts: More recently, external-memory research has moved towards solving geometric and graph problems. For geometric problems, Goodrich et al. [60] study a number of problems in computational geometry and develop several paradigms for I/O-optimal geometric computations. Further results in this area have been obtained in <ref> [51, 125] </ref>. Also, Kanellakis et al. [65] and Ramaswamy and Sub-ramanian [98, 106] give efficient data structures for performing range searching in external memory.
Reference: [52] <author> G. N. Frederickson. </author> <title> A data structure for dynamically maintaining rooted trees. </title> <booktitle> In Proc. ACM-SIAM Symp. on Discrete Algorithms, </booktitle> <pages> pages 175-184, </pages> <year> 1993. </year>
Reference: [53] <author> O. Fries. </author> <title> Zerlegung einer planaren Unterteilung der Ebene und ihre Anwendungen. M.S. </title> <type> thesis, </type> <institution> Inst. Angew. Math. Inform., Univ. Saarlandes, Saarbrucken, West Germany, </institution> <year> 1985. </year>
Reference-contexts: The same approach, when attempted for the dynamic setting, could lead to onerous updates, such as when the insertion of an edge causes the removal of a very large number of normalizing diagonals. A rather complicated and only partially documented technique due to Fries <ref> [53] </ref>, is reported to assure that only a logarithmic number of normalizing diagonals be involved in any update. In this chapter we combine the feature just stated with the underpinnings of the trapezoid method, whose search efficiency both in theory [16, 92] and practice [47] is well-established.
Reference: [54] <author> O. Fries, K. Mehlhorn, and S. Naher. </author> <title> Dynamization of geometric data structures. </title> <booktitle> In Proc. 90 1st Annu. ACM Sympos. Comput. Geom., </booktitle> <pages> pages 168-176, </pages> <year> 1985. </year>
Reference-contexts: Such methods, however, refer to the static case where no alteration of the map is allowed during its use. Due to the obvious importance of the dynamic setting, in recent years considerable attention has been devoted to the development of dynamic point-location algorithms <ref> [8, 23, 28, 54, 57, 89, 94, 95, 112] </ref>. All the known dynamic point location results are for connected maps, since maintaining region names in a disconnected map would require solving half-planar range searching in a dynamic environment, for which no polylog-time algorithm is known.
Reference: [55] <author> S. K. Ghosh. </author> <title> Computing visibility polygon from a convex set and related problems. </title> <journal> J. Algorithms, </journal> <volume> 12 </volume> <pages> 75-95, </pages> <year> 1991. </year>
Reference-contexts: Then e 1 ; ; e j partition G (p; q) into subchains that are always left-turning or always right-turning, namely, into inward convex subchains (see Fig. 3.16). It is shown that every inflection edge e 2 G (p; q) must be contained in L (p; q) <ref> [7, 18, 55] </ref>.
Reference: [56] <author> S. K. Ghosh and A. Maheshwari. </author> <title> Parallel algorithms for all minimum link paths and link center problems. </title> <booktitle> In Proc. 3rd Scand. Workshop Algorithm Theory, volume 621 of Lecture Notes in Computer Science, </booktitle> <pages> pages 106-117. </pages> <publisher> Springer-Verlag, </publisher> <year> 1992. </year>
Reference-contexts: Also, efficient parallel algorithms are given in [18]. There are other results on the variations of the minimum-link-path problem. Efficient algorithms for link diameter and link center are given in <ref> [44, 56, 78, 67, 85, 84, 108] </ref>. A minimum-link path between two fixed points in a multiply connected polygon can be computed efficiently [83]. Sequential and parallel algorithms for rectilinear link distance are respectively given by de Berg [39] and Lingas et al. [79].
Reference: [57] <author> M. Goodrich and R. Tamassia. </author> <title> Dynamic trees and dynamic point location. </title> <booktitle> In Proc. 23rd Annu. ACM Sympos. Theory Comput., </booktitle> <pages> pages 523-533, </pages> <year> 1991. </year>
Reference-contexts: Such methods, however, refer to the static case where no alteration of the map is allowed during its use. Due to the obvious importance of the dynamic setting, in recent years considerable attention has been devoted to the development of dynamic point-location algorithms <ref> [8, 23, 28, 54, 57, 89, 94, 95, 112] </ref>. All the known dynamic point location results are for connected maps, since maintaining region names in a disconnected map would require solving half-planar range searching in a dynamic environment, for which no polylog-time algorithm is known.
Reference: [58] <author> M. T. Goodrich, M. H. Nodine, and J. S. Vitter. </author> <title> Blocking for external graph searching. </title> <booktitle> In Proc. ACM SIGACT-SIGMOD-SIGART Symp. on Principles of Database Sys., </booktitle> <pages> pages 222-232, </pages> <year> 1993. </year>
Reference-contexts: This work, however, restricts its attention to problem instances where the set of vertices fits into main memory but the set of edges does not. Vishkin [121] uses PRAM simulation to facilitate prefetching for various problems, but without taking blocking issues into account. Also worth noting is recent work <ref> [58] </ref> on some graph traversal problems; this work primarily addresses the problem of storing graphs, however, not in performing specific computations on them. Related work [50] proposes a framework for studying memory management problems for maintaining connectivity information and paths on graphs.
Reference: [59] <author> M. T. Goodrich and R. Tamassia. </author> <title> Dynamic ray shooting and shortest paths via balanced geodesic triangulations. </title> <booktitle> In Proc. 9th Annu. ACM Sympos. Comput. Geom., </booktitle> <pages> pages 318-327, </pages> <year> 1993. </year>
Reference-contexts: Although there has been a lot of work on the separation problem, the more general shortest-path problem for two objects in the presence of obstacle P has been previously studied only for the simple case when the objects are points, for which there exist efficient static [63] and dynamic <ref> [26, 59] </ref> solutions. The static technique of [63] supports two-point shortest-path queries in optimal O (log n) time (plus O (k) if the k edges of the path are reported), employing a data structure that uses O (n) space and can be built in linear time. <p> The very recent result of <ref> [59] </ref> improves the query and update times to O (log 2 n), with space complexity also improved to O (n). The minimum-link path problem between two points has been extensively studied. <p> Dynamic Shortest Paths Query Type Query Space Update Chiang-Preparata-Tamassia [26] (Chapter 2) two query points log 3 n n log n log 3 n Goodrich-Tamassia <ref> [59] </ref> two query points log 2 n n fl log 2 n This chapter two query convex polygons log h + log 2 n n fl log 2 n fl optimal Table 3.2 Results for dynamic shortest-path queries. <p> The above repertory of operations is complete for connected maps. That is, any connected map M can be constructed "from scratch" using only the above operations. We make use of the dynamic data structure of Goodrich and Tamassia <ref> [59] </ref>. Their technique supports two-point shortest-path queries and ray-shooting queries, which consist of finding the first edge or vertex of M hit by a query ray. Their data structure is based on geodesic triangulation of each region of M. <p> A geodesic triangulation of P is a decomposition of P 's interior into geodesic triangles whose boundaries do not cross. The technique <ref> [59] </ref> dynamically maintains such triangulations by viewing their dual trees as balanced trees. <p> The two-point shortest path is obtained by locating the two points and then walking from geodesic triangle to geodesic triangle either following a boundary or taking a shortcut through a common tangent <ref> [59] </ref>. Let n be the current number of vertices in M. Using the data structure of [59], we can perform each of the above update operations as well as ray-shooting and two-point shortest-path queries in O (log 2 n) time, using O (n) space, where in O (log 2 n) time <p> The two-point shortest path is obtained by locating the two points and then walking from geodesic triangle to geodesic triangle either following a boundary or taking a shortcut through a common tangent <ref> [59] </ref>. Let n be the current number of vertices in M. Using the data structure of [59], we can perform each of the above update operations as well as ray-shooting and two-point shortest-path queries in O (log 2 n) time, using O (n) space, where in O (log 2 n) time we get an implicit representation (a balanced binary tree) and the length of the queried shortest <p> in O (log 2 n) time, using O (n) space, where in O (log 2 n) time we get an implicit representation (a balanced binary tree) and the length of the queried shortest path, and using additional O (k) time to retrieve the k links we get the actual path <ref> [59] </ref>. Again we enhance this data structure so that associated with the implicit representation of a shortest path G , there are two balanced binary trees respectively maintaining the inflection edges and the cusps on G in their path order.
Reference: [60] <author> M. T. Goodrich, J.-J. Tsay, D. E. Vengroff, and J. S. Vitter. </author> <title> External-memory computational geometry. </title> <booktitle> In IEEE Foundations of Comp. Sci., </booktitle> <pages> pages 714-723, </pages> <year> 1993. </year>
Reference-contexts: Indeed, just the problem of implementing various classes of permutation has been a central theme in external-memory I/O research [2, 36, 37, 38, 122]. More recently, external-memory research has moved towards solving geometric and graph problems. For geometric problems, Goodrich et al. <ref> [60] </ref> study a number of problems in computational geometry and develop several paradigms for I/O-optimal geometric computations. Further results in this area have been obtained in [51, 125]. Also, Kanellakis et al. [65] and Ramaswamy and Sub-ramanian [98, 106] give efficient data structures for performing range searching in external memory. <p> The problem has important applications in VLSI layout and graphics, which are large-scale in nature. The algorithms under evaluation are distribution sweep of Goodrich et al. <ref> [60] </ref> and three variations of plane sweep [93]. Distribution sweep theoretically has optimal I/O cost [60]. Plane sweep is a well-known and powerful technique in computational geometry, and is optimal for this particular problem in terms of internal computation [93]. <p> The problem has important applications in VLSI layout and graphics, which are large-scale in nature. The algorithms under evaluation are distribution sweep of Goodrich et al. <ref> [60] </ref> and three variations of plane sweep [93]. Distribution sweep theoretically has optimal I/O cost [60]. Plane sweep is a well-known and powerful technique in computational geometry, and is optimal for this particular problem in terms of internal computation [93]. <p> Viewing the internal memory as virtually having an infinite size is conceptually the simplest, and is actually the most commonly used strategy today in practice. 5.2.2 Distribution Sweep Distribution sweep <ref> [60] </ref> is an external-memory version of plane sweep based on the subdivision technique used in the "distribution sort" algorithms of [2, 86, 122]. When applied to the orthogonal segment intersection problem, it works as follows. <p> The observed K values of data-long are indeed 1 8 N (see Fig. 5.1), and the observed values of the average number of vertical overlaps are also 1 8 N (see Fig. 5.3). In program gen-rect, we generate horizontal and vertical segments with lengths uniformly distributed over <ref> [20; 60] </ref> and over [0; 2N ], respectively.
Reference: [61] <author> M. T. Goodrich, D. E. Vengroff, and J. S. Vitter. </author> <type> Personal communication, </type> <year> 1994. </year>
Reference-contexts: The verification step in [66, 74] to check whether an edge forming a cycle is heavy enough to be removed is carried out by the O ((E=V )sort (V ))-I/O minimum spanning tree verification method of <ref> [61] </ref> (also appearing in [25]) which is based on that of King [70]. This gives the following theorem.
Reference: [62] <author> E. F. </author> <title> Grove. </title> <type> Personal communication, </type> <year> 1994. </year>
Reference-contexts: The expression tree evaluation problem is to determine the values at all internal nodes of T . Theorem 4.5 An N -node general expression tree can be evaluated with optimal O (sort (N )) I/Os. Proof: We give two algorithms; the first one is based on <ref> [62] </ref> (also appearing in the conference version [25] of this chapter) and the second one is new. The first algorithm works as follows. By using Euler Tour and list ranking twice, we compute the depth and also the preorder numbering of each node.
Reference: [63] <author> L. J. Guibas and J. Hershberger. </author> <title> Optimal shortest path queries in a simple polygon. </title> <journal> J. Comput. Syst. Sci., </journal> <volume> 39 </volume> <pages> 126-152, </pages> <year> 1989. </year>
Reference-contexts: For a survey of dynamic point-location techniques and other dynamic algorithms in computational geometry, see Chiang and Tamassia [27]. Algorithmic research on shortest-path and ray-shooting queries has also experienced steady progress, resulting in time-optimal techniques for the static setting <ref> [1, 21, 22, 63, 76] </ref>. In particular, the linear-space data structures of Chazelle-Guibas [21] and of Guibas-Hershberger [63] support in O (log n) time ray-shooting and shortest-path queries, respectively, in a simple polygon with n vertices. <p> Algorithmic research on shortest-path and ray-shooting queries has also experienced steady progress, resulting in time-optimal techniques for the static setting [1, 21, 22, 63, 76]. In particular, the linear-space data structures of Chazelle-Guibas [21] and of Guibas-Hershberger <ref> [63] </ref> support in O (log n) time ray-shooting and shortest-path queries, respectively, in a simple polygon with n vertices. No polylog-time method was previously known in a dynamic setting, although a polylog-time ray-shooting technique by Reif and Sen [99], designed for monotone polygons, may be extensible to the general case. <p> The notion of hourglass is central to our current problem. We adopt the terminology proposed by Guibas and Hershberger <ref> [63] </ref>. <p> Let ff be the subchain of r counterclockwise from a 1 to a 2 , and define fi similarly for b 2 and b 1 . The hourglass has one of the following special structures (as analyzed by <ref> [63] </ref>): Open hourglass: If the convex hulls inside r of ff and fi do not intersect, then path (a 1 ; a 2 ; r) is the convex hull of the subchain of ff clockwise from a 1 to a 2 , and similarly for path (b 2 ; b 1 <p> We denote with Q a maximal monotone subpath of a solid path P and specify the implementation of ltree (Q) and rtree (Q). We use pruned trees augmented with chain-trees as secondary structures. Our scheme uses ideas from [90] and <ref> [63] </ref>. * Trees ltree (Q) and rtree (Q) are implemented by means of pruned trees with respect to Y . * Let be a node of ltree (Q) (nodes of rtree (Q) are handled identically) and the parent of . <p> Although there has been a lot of work on the separation problem, the more general shortest-path problem for two objects in the presence of obstacle P has been previously studied only for the simple case when the objects are points, for which there exist efficient static <ref> [63] </ref> and dynamic [26, 59] solutions. The static technique of [63] supports two-point shortest-path queries in optimal O (log n) time (plus O (k) if the k edges of the path are reported), employing a data structure that uses O (n) space and can be built in linear time. <p> of work on the separation problem, the more general shortest-path problem for two objects in the presence of obstacle P has been previously studied only for the simple case when the objects are points, for which there exist efficient static <ref> [63] </ref> and dynamic [26, 59] solutions. The static technique of [63] supports two-point shortest-path queries in optimal O (log n) time (plus O (k) if the k edges of the path are reported), employing a data structure that uses O (n) space and can be built in linear time. <p> No such data structure was known before even for two-point queries. We summarize the comparisions of our results with the previous ones in Tables 3.1-3.4. Static Shortest Paths Query Type Query Space Preprocessing Guibas-Hershberger <ref> [63] </ref> two query points log n fl n fl n fl This chapter two query convex polygons log h + log n fl n fl n fl fl optimal Table 3.1 Results for static shortest-path queries. <p> The data structure of 36 Guibas and Hershberger <ref> [63] </ref> computes the shortest path G (p; q) between any two points p and q inside P in O (log n) time, where in O (log n) time we get an implicit representation (a balanced binary tree) and the length of G (p; q), and using additional O (k) time to
Reference: [64] <author> J. JaJa. </author> <title> An Introduction to Parallel Algorithms. </title> <publisher> Addison Wesley, </publisher> <address> New York, NY, </address> <year> 1992. </year>
Reference-contexts: We also take advantage of the "geometrically decreasing size" property common in many PRAM algorithms to obtain I/O-optimal methods. In addition, since we do not need to simulate inactive processors, the PRAM algorithms we simulate are those described at a higher level (called the work-time presentation framework <ref> [64] </ref>) which ignore the more complicated processor scheduling issues, and thus our resulting I/O algorithms are simple and practical. We show in subsequent sections how to combine these techniques with more sophisticated strategies to design efficient external-memory algorithms for a number of graph problems. <p> Under the work-time presentation framework, the work performed by A is defined to be the total number of operations used <ref> [64] </ref>.
Reference: [65] <author> P. C. Kanellakis, S. Ramaswamy, D. E. Vengroff, and J. S. Vitter. </author> <title> Indexing for data models with constraints and classes. </title> <booktitle> In Proc. ACM Symp. on Principles of Database Sys., </booktitle> <pages> pages 233-243, </pages> <year> 1993. </year>
Reference-contexts: For geometric problems, Goodrich et al. [60] study a number of problems in computational geometry and develop several paradigms for I/O-optimal geometric computations. Further results in this area have been obtained in [51, 125]. Also, Kanellakis et al. <ref> [65] </ref> and Ramaswamy and Sub-ramanian [98, 106] give efficient data structures for performing range searching in external memory. <p> Also worth noting is the work by Ramaswamy and Kanellakis [97], who study the problem of indexing a class hierarchy in Object Oriented Databases. Based on the insight of Kanellakis et al. <ref> [65] </ref> that the problem is a special form of two-dimensional dynamic range searching in external memory, they propose a technique called class-division, and show by experiments that in the average case, class-division performs far less I/Os than the class hierarchy index technique most popular today.
Reference: [66] <author> D. R. Karger. </author> <title> Global min-cuts in RNC and other ramifications of a simple mincut algorithm. </title> <booktitle> In Proc. 4th ACM-SIAM Symp. on Discrete Algorithms, </booktitle> <pages> pages 21-30, </pages> <year> 1993. </year>
Reference-contexts: We can actually do better than that, decreasing the numbers of both edges and vertices by a constant factor in each iteration, by using an external-memory variation of the random sampling technique of <ref> [66, 74] </ref>. The verification step in [66, 74] to check whether an edge forming a cycle is heavy enough to be removed is carried out by the O ((E=V )sort (V ))-I/O minimum spanning tree verification method of [61] (also appearing in [25]) which is based on that of King [70]. <p> We can actually do better than that, decreasing the numbers of both edges and vertices by a constant factor in each iteration, by using an external-memory variation of the random sampling technique of <ref> [66, 74] </ref>. The verification step in [66, 74] to check whether an edge forming a cycle is heavy enough to be removed is carried out by the O ((E=V )sort (V ))-I/O minimum spanning tree verification method of [61] (also appearing in [25]) which is based on that of King [70]. This gives the following theorem.
Reference: [67] <author> Y. Ke. </author> <title> An efficient algorithm for link-distance problems. </title> <booktitle> In Proc. 5th Annu. ACM Sympos. Comput. Geom., </booktitle> <pages> pages 69-78, </pages> <year> 1989. </year>
Reference-contexts: The minimum-link path problem between two points has been extensively studied. In many applications, such as robotics, motion planning, VLSI and computer vision, the link distance often provides a more natural measure of path complexity than the Euclidean distance <ref> [67, 83, 100, 107, 109] </ref>. For example, in a robot system, a straight-line navigation is often much cheaper than 32 rotation, thus it is desirable to minimize the number of turns in path planning [100, 109]. <p> Also, efficient parallel algorithms are given in [18]. There are other results on the variations of the minimum-link-path problem. Efficient algorithms for link diameter and link center are given in <ref> [44, 56, 78, 67, 85, 84, 108] </ref>. A minimum-link path between two fixed points in a multiply connected polygon can be computed efficiently [83]. Sequential and parallel algorithms for rectilinear link distance are respectively given by de Berg [39] and Lingas et al. [79].
Reference: [68] <author> D. Kelly and I. </author> <title> Rival. Planar lattices. </title> <journal> Canad. J. Math., </journal> <volume> 27(3) </volume> <pages> 636-665, </pages> <year> 1975. </year>
Reference-contexts: Planar st-graphs were first introduced by Lempel, Even, and Cederbaum [77] in connection with a planarity testing algorithm, and have subsequently been used in a host of applications, dealing with partial orders <ref> [68] </ref>, planar graph embedding [30, 42, 111], graph planarization [91], 71 graph drawing [41, 43], floor planning [123], planar point location [49, 94], visibility [73, 88, 102, 113, 114, 124], motion planning [101], and VLSI layout compaction [123].
Reference: [69] <author> C. M. Kenyon-Mathieu and J. S. Vitter. </author> <title> The maximum size of dynamic data structures. </title> <journal> SIAM J. Comput., </journal> <volume> 20 </volume> <pages> 807-823, </pages> <year> 1991. </year>
Reference-contexts: The average is taken over all sweeping events. Notice that this average number is exactly the average number of items stored in the data structure when an update/query operation is performed during plane sweep. A related problem has been studied in <ref> [69] </ref>. Intuitively, we would estimate this average number to be proportional to the average length of vertical segments, which is fi ( p N ). A rigorous analysis is given next. Let V be a random variable for the number of vertical segments cut by l for an event.
Reference: [70] <author> V. King. </author> <title> A simpler minimum spanning tree verification algorithm. </title> <booktitle> In Proc. Workshop on Algorithms and Data Structures (to appear), </booktitle> <year> 1995. </year>
Reference-contexts: The verification step in [66, 74] to check whether an edge forming a cycle is heavy enough to be removed is carried out by the O ((E=V )sort (V ))-I/O minimum spanning tree verification method of [61] (also appearing in [25]) which is based on that of King <ref> [70] </ref>. This gives the following theorem.
Reference: [71] <author> D. G. Kirkpatrick. </author> <title> Efficient computation of continuous skeletons. </title> <booktitle> In Proc. 20th Annu. IEEE Sympos. Found. Comput. Sci., </booktitle> <pages> pages 18-27, </pages> <year> 1979. </year>
Reference-contexts: convex their separation can be computed in O (log h) time [31, 48, 20, 45]; if only one of them is convex an O (h)-time algorithm is given in [31]; if neither is convex, an optimal algorithm is recently given by Amato [3], who improves the previous result of Kirkpatrick <ref> [71] </ref> from O (h log h) to O (h).
Reference: [72] <author> D. G. Kirkpatrick. </author> <title> Optimal search in planar subdivisions. </title> <journal> SIAM J. Comput., </journal> <volume> 12 </volume> <pages> 28-35, </pages> <year> 1983. </year>
Reference-contexts: Starting with the pioneering work in planar point-location of the seventies [46, 75], over the years several techniques have been developed, culminating in asymptotically time- and space-optimal methods <ref> [49, 72, 103] </ref> that are also of sufficiently practical flavor. Such methods, however, refer to the static case where no alteration of the map is allowed during its use.
Reference: [73] <author> D. G. Kirkpatrick and S. K. Wismath. </author> <title> Weighted visibility graphs of bars and related flow problems. </title> <booktitle> In Proc. 1st Workshop Algorithms Data Struct., volume 382 of Lecture Notes in Computer Science, </booktitle> <pages> pages 325-334. </pages> <publisher> Springer-Verlag, </publisher> <year> 1989. </year>
Reference-contexts: Lempel, Even, and Cederbaum [77] in connection with a planarity testing algorithm, and have subsequently been used in a host of applications, dealing with partial orders [68], planar graph embedding [30, 42, 111], graph planarization [91], 71 graph drawing [41, 43], floor planning [123], planar point location [49, 94], visibility <ref> [73, 88, 102, 113, 114, 124] </ref>, motion planning [101], and VLSI layout compaction [123]. In this section, we consider a planar st-digraph G with V vertices, and recall that G has O (V ) edges. The results in this section are summarized in Table 4.3.
Reference: [74] <author> P. Klein and R.E. Tarjan. </author> <title> A randomized linear-time algorithm for finding minimum spanning trees. </title> <booktitle> In Proc. ACM Symp. on Theory of Computing, </booktitle> <year> 1994. </year>
Reference-contexts: We can actually do better than that, decreasing the numbers of both edges and vertices by a constant factor in each iteration, by using an external-memory variation of the random sampling technique of <ref> [66, 74] </ref>. The verification step in [66, 74] to check whether an edge forming a cycle is heavy enough to be removed is carried out by the O ((E=V )sort (V ))-I/O minimum spanning tree verification method of [61] (also appearing in [25]) which is based on that of King [70]. <p> We can actually do better than that, decreasing the numbers of both edges and vertices by a constant factor in each iteration, by using an external-memory variation of the random sampling technique of <ref> [66, 74] </ref>. The verification step in [66, 74] to check whether an edge forming a cycle is heavy enough to be removed is carried out by the O ((E=V )sort (V ))-I/O minimum spanning tree verification method of [61] (also appearing in [25]) which is based on that of King [70]. This gives the following theorem.
Reference: [75] <author> D. T. Lee and F. P. Preparata. </author> <title> Location of a point in a planar subdivision and its applications. </title> <journal> SIAM J. Comput., </journal> <volume> 6 </volume> <pages> 594-606, </pages> <year> 1977. </year> <month> 91 </month>
Reference-contexts: First and foremost among these operations is planar point-location, i.e., the identification of the map region containing a given query point; but also shortest-path and ray-shooting queries have been considered very prominently. Starting with the pioneering work in planar point-location of the seventies <ref> [46, 75] </ref>, over the years several techniques have been developed, culminating in asymptotically time- and space-optimal methods [49, 72, 103] that are also of sufficiently practical flavor. Such methods, however, refer to the static case where no alteration of the map is allowed during its use.
Reference: [76] <author> D. T. Lee and F. P. Preparata. </author> <title> Euclidean shortest paths in the presence of rectilinear barriers. </title> <journal> Networks, </journal> <volume> 14 </volume> <pages> 393-410, </pages> <year> 1984. </year>
Reference-contexts: For a survey of dynamic point-location techniques and other dynamic algorithms in computational geometry, see Chiang and Tamassia [27]. Algorithmic research on shortest-path and ray-shooting queries has also experienced steady progress, resulting in time-optimal techniques for the static setting <ref> [1, 21, 22, 63, 76] </ref>. In particular, the linear-space data structures of Chazelle-Guibas [21] and of Guibas-Hershberger [63] support in O (log n) time ray-shooting and shortest-path queries, respectively, in a simple polygon with n vertices. <p> Similar arguments apply to p 2 . The union of path (a i ; p i ; r) and path (b i ; p i ; r) (i = 1 or 2) is called a funnel <ref> [76] </ref>. Vertices p 1 and p 2 are called the apices of the hourglass, and the path between them the string of the hourglass (see Fig. 2.8.b).
Reference: [77] <author> A. Lempel, S. Even, and I. Cederbaum. </author> <title> An algorithm for planarity testing of graphs. In Theory of Graphs, </title> <booktitle> Int. Symp. </booktitle> <address> (Rome, </address> <year> 1966), </year> <pages> pages 215-232. </pages> <publisher> Gordon and Breach, </publisher> <address> New York, </address> <year> 1967. </year>
Reference-contexts: Planar st-graphs were first introduced by Lempel, Even, and Cederbaum <ref> [77] </ref> in connection with a planarity testing algorithm, and have subsequently been used in a host of applications, dealing with partial orders [68], planar graph embedding [30, 42, 111], graph planarization [91], 71 graph drawing [41, 43], floor planning [123], planar point location [49, 94], visibility [73, 88, 102, 113, 114,
Reference: [78] <author> W. Lenhart, R. Pollack, J.-R. Sack, R. Seidel, M. Sharir, S. Suri, G. T. Toussaint, S. White-sides, and C. K. Yap. </author> <title> Computing the link center of a simple polygon. </title> <journal> Discrete Comput. Geom., </journal> <volume> 3 </volume> <pages> 281-293, </pages> <year> 1988. </year>
Reference-contexts: Also, efficient parallel algorithms are given in [18]. There are other results on the variations of the minimum-link-path problem. Efficient algorithms for link diameter and link center are given in <ref> [44, 56, 78, 67, 85, 84, 108] </ref>. A minimum-link path between two fixed points in a multiply connected polygon can be computed efficiently [83]. Sequential and parallel algorithms for rectilinear link distance are respectively given by de Berg [39] and Lingas et al. [79].
Reference: [79] <author> A. Lingas, A. Maheshwari, and J.-R. Sack. </author> <title> Parallel algorithms for rectilinear link distance problems. </title> <booktitle> In Proc. 7th IEEE Internat. Parallel Process. Sympos. IEEE Computer Society, </booktitle> <year> 1993. </year>
Reference-contexts: A minimum-link path between two fixed points in a multiply connected polygon can be computed efficiently [83]. Sequential and parallel algorithms for rectilinear link distance are respectively given by de Berg [39] and Lingas et al. <ref> [79] </ref>. De Berg et al. [40] study the problem of finding a shortest rectilinear path among rectilinear obstacles. Mitchell et al. [82] consider the problem of finding a shortest path with at most K links between two query points inside a simple polygon, where K is an input parameter.
Reference: [80] <author> Y. Maon, B. Schieber, and U. Vishkin. </author> <title> Parallel ear decomposition search and st-numbering in graphs. </title> <journal> Theoretical Computer Science, </journal> <volume> 47(3) </volume> <pages> 277-296, </pages> <year> 1986. </year>
Reference-contexts: For ear decomposition, we modify the PRAM algorithm of Maon et al. <ref> [80] </ref>, which requires generating an arbitrary spanning tree (by our connected component algorithm), performing batched lowest common ancestor queries (by Theorem 4.6), and evaluating a general expression tree (by Theorem 4.5). 2 Observe that all problems in Theorem 4.7 can be solved within the bound of computing minimum spanning forest.
Reference: [81] <author> K. Mehlhorn. </author> <title> Sorting and Searching, volume 1 of Data Structures and Algorithms. </title> <publisher> Springer-Verlag, </publisher> <address> Heidelberg, Germany, </address> <year> 1984. </year>
Reference-contexts: In particular, a simple rotation can be viewed as a sequence of four elementary splits and joins. Three special types of data structures will be used in this chapter: biased binary trees [10], BB [ff]-trees <ref> [81] </ref>, and dynamic trees [104]. A biased binary tree [10] is a binary search tree whose leaves store weighted items. Let w be the sum of all weights. <p> A BB [ff]-tree <ref> [81] </ref> (where ff is a fixed real, with 1 4 &lt; ff 1 2 2 ) is a binary search tree and has the following important properties (among others): * A BB [ff]-tree with n nodes has height O (log n). * Assume that we augment a BB [ff]-tree with secondary
Reference: [82] <author> J. S. B. Mitchell, C. Piatko, and E. M. Arkin. </author> <title> Computing a shortest k-link path in a polygon. </title> <booktitle> In Proc. 33rd Annu. IEEE Sympos. Found. Comput. Sci., </booktitle> <pages> pages 573-582, </pages> <year> 1992. </year>
Reference-contexts: Sequential and parallel algorithms for rectilinear link distance are respectively given by de Berg [39] and Lingas et al. [79]. De Berg et al. [40] study the problem of finding a shortest rectilinear path among rectilinear obstacles. Mitchell et al. <ref> [82] </ref> consider the problem of finding a shortest path with at most K links between two query points inside a simple polygon, where K is an input parameter. Our main results in this chapter are outlined as follows. * Let P be a simple polygon with n vertices.
Reference: [83] <author> J. S. B. Mitchell, G. Rote, and G. Woeginger. </author> <title> Minimum-link paths among obstacles in the plane. </title> <journal> Algorithmica, </journal> <volume> 8 </volume> <pages> 431-459, </pages> <year> 1992. </year>
Reference-contexts: The minimum-link path problem between two points has been extensively studied. In many applications, such as robotics, motion planning, VLSI and computer vision, the link distance often provides a more natural measure of path complexity than the Euclidean distance <ref> [67, 83, 100, 107, 109] </ref>. For example, in a robot system, a straight-line navigation is often much cheaper than 32 rotation, thus it is desirable to minimize the number of turns in path planning [100, 109]. <p> There are other results on the variations of the minimum-link-path problem. Efficient algorithms for link diameter and link center are given in [44, 56, 78, 67, 85, 84, 108]. A minimum-link path between two fixed points in a multiply connected polygon can be computed efficiently <ref> [83] </ref>. Sequential and parallel algorithms for rectilinear link distance are respectively given by de Berg [39] and Lingas et al. [79]. De Berg et al. [40] study the problem of finding a shortest rectilinear path among rectilinear obstacles.
Reference: [84] <author> B. J. Nilsson and S. Schuierer. </author> <title> An optimal algorithm for the rectilinear link center of a rectilinear polygon. </title> <booktitle> In Proc. 2nd Workshop Algorithms Data Struct., volume 519 of Lecture Notes in Computer Science, </booktitle> <pages> pages 249-260. </pages> <publisher> Springer-Verlag, </publisher> <year> 1991. </year>
Reference-contexts: Also, efficient parallel algorithms are given in [18]. There are other results on the variations of the minimum-link-path problem. Efficient algorithms for link diameter and link center are given in <ref> [44, 56, 78, 67, 85, 84, 108] </ref>. A minimum-link path between two fixed points in a multiply connected polygon can be computed efficiently [83]. Sequential and parallel algorithms for rectilinear link distance are respectively given by de Berg [39] and Lingas et al. [79].
Reference: [85] <author> Bengt J. Nilsson and Sven Schuierer. </author> <title> Computing the rectilinear link diameter of a polygon. In Computational Geometry | Methods, </title> <booktitle> Algorithms and Applications: Proc. Internat. Workshop Comput. Geom. CG '91, volume 553 of Lecture Notes in Computer Science, </booktitle> <pages> pages 203-215. </pages> <publisher> Springer-Verlag, </publisher> <year> 1991. </year>
Reference-contexts: Also, efficient parallel algorithms are given in [18]. There are other results on the variations of the minimum-link-path problem. Efficient algorithms for link diameter and link center are given in <ref> [44, 56, 78, 67, 85, 84, 108] </ref>. A minimum-link path between two fixed points in a multiply connected polygon can be computed efficiently [83]. Sequential and parallel algorithms for rectilinear link distance are respectively given by de Berg [39] and Lingas et al. [79].
Reference: [86] <author> M. H. Nodine and J. S. Vitter. </author> <title> Deterministic distribution sort in shared and distributed memory multiprocessors. </title> <booktitle> In Proc. 5th ACM Symp. on Parallel Algorithms and Architectures, </booktitle> <month> June </month> <year> 1993. </year>
Reference-contexts: Furthermore, for simplicity, we restrict the discussion to the D = 1 case of one disk. The load balancing issues that arise with multiple disks are handled with balancing techniques akin to <ref> [86, 122] </ref>. The 3-coloring algorithm consists of three phases. Phase 1 sets up an N -coloring. Each remaining phase reduces the number of colors used. Colors and node IDs are represented by integers. 1. <p> Viewing the internal memory as virtually having an infinite size is conceptually the simplest, and is actually the most commonly used strategy today in practice. 5.2.2 Distribution Sweep Distribution sweep [60] is an external-memory version of plane sweep based on the subdivision technique used in the "distribution sort" algorithms of <ref> [2, 86, 122] </ref>. When applied to the orthogonal segment intersection problem, it works as follows. In the preprocessing phase, we sort the endpoints of all segments into two lists, one by x and the other by y. Again we use external merge sort.
Reference: [87] <author> M. H. Nodine and J. S. Vitter. </author> <title> Paradigms for optimal sorting with multiple disks. </title> <booktitle> In Proc. of the 26th Hawaii Int. Conf. on Systems Sciences, </booktitle> <month> January </month> <year> 1993. </year>
Reference-contexts: shorthand notation to represent the I/O complexity of each of these primitives: scan (x) = x ; which represents the number of I/Os needed to read x items, and sort (x) = x log M=B B which is proportional to the optimal number of I/Os needed to sort x items <ref> [87] </ref>. 4.1.2 Previous Work Early work on external-memory algorithms concentrated largely on fundamental problems such as sorting, matrix multiplication, and FFT [2, 87, 122]. The main focus of this early work was therefore directed at problems that involved permutation at a basic level. <p> of I/Os needed to read x items, and sort (x) = x log M=B B which is proportional to the optimal number of I/Os needed to sort x items [87]. 4.1.2 Previous Work Early work on external-memory algorithms concentrated largely on fundamental problems such as sorting, matrix multiplication, and FFT <ref> [2, 87, 122] </ref>. The main focus of this early work was therefore directed at problems that involved permutation at a basic level. Indeed, just the problem of implementing various classes of permutation has been a central theme in external-memory I/O research [2, 36, 37, 38, 122].
Reference: [88] <author> R. H. J. M. Otten and J. G. van Wijk. </author> <title> Graph representations in interactive layout design. </title> <booktitle> In Proc. IEEE Internat. Sympos. on Circuits and Systems, </booktitle> <pages> pages 914-918, </pages> <year> 1978. </year>
Reference-contexts: Lempel, Even, and Cederbaum [77] in connection with a planarity testing algorithm, and have subsequently been used in a host of applications, dealing with partial orders [68], planar graph embedding [30, 42, 111], graph planarization [91], 71 graph drawing [41, 43], floor planning [123], planar point location [49, 94], visibility <ref> [73, 88, 102, 113, 114, 124] </ref>, motion planning [101], and VLSI layout compaction [123]. In this section, we consider a planar st-digraph G with V vertices, and recall that G has O (V ) edges. The results in this section are summarized in Table 4.3.
Reference: [89] <author> M. H. Overmars. </author> <title> Range searching in a set of line segments. </title> <booktitle> In Proc. 1st Annu. ACM Sympos. Comput. Geom., </booktitle> <pages> pages 177-185, </pages> <year> 1985. </year>
Reference-contexts: Such methods, however, refer to the static case where no alteration of the map is allowed during its use. Due to the obvious importance of the dynamic setting, in recent years considerable attention has been devoted to the development of dynamic point-location algorithms <ref> [8, 23, 28, 54, 57, 89, 94, 95, 112] </ref>. All the known dynamic point location results are for connected maps, since maintaining region names in a disconnected map would require solving half-planar range searching in a dynamic environment, for which no polylog-time algorithm is known.
Reference: [90] <author> M. H. Overmars and J. van Leeuwen. </author> <title> Maintenance of configurations in the plane. </title> <journal> J. Comput. Syst. Sci., </journal> <volume> 23 </volume> <pages> 166-204, </pages> <year> 1981. </year>
Reference-contexts: We denote with Q a maximal monotone subpath of a solid path P and specify the implementation of ltree (Q) and rtree (Q). We use pruned trees augmented with chain-trees as secondary structures. Our scheme uses ideas from <ref> [90] </ref> and [63]. * Trees ltree (Q) and rtree (Q) are implemented by means of pruned trees with respect to Y . * Let be a node of ltree (Q) (nodes of rtree (Q) are handled identically) and the parent of . <p> A straightforward method is to compute H G directly. As shown in [7], we can compute the geodesic external tangents between R 1 and R 2 (and hence H G ) by a binary search mimicking the algorithm <ref> [90] </ref> for finding ordinary common tangents, where in each iteration we compute the shortest path between two chosen points rather than the segment joining them. However, this results in a computation of O (log h log n) time. Also, it seems difficult to compute H G in optimal time. <p> We first describe the algorithm and then justify its correctness. Algorithm Pseudo-Hourglass 1. Ignore P and compute the ordinary external common tangents (a 0 1 ; a 0 1 ; b 0 2 ) between R 1 and R 2 , using the algorithm of Overmars and van Leeuwen <ref> [90] </ref>, where a 0 1 ; b 0 a 0 2 2 R 2 . Let s 0 1 ; b 0 2 = (a 0 2 ). Compute shortest paths 1 = G (a 0 1 ; a 0 2 = G (b 0 2 ). <p> If they are disjoint (i.e., neither has an inflection edge) then the hourglass H 0 = H (s 0 2 ) is open. In this case s 0 1 and s 0 2 are mutually visible, implying that R 1 and R 2 are mutually visible. Use algorithm <ref> [90] </ref> to compute an internal common tangent l between 1 and 2 , report fopen with visibility link lg and stop. 2. Else ( 1 and 2 are not disjoint) H 0 is closed.
Reference: [91] <author> T. Ozawa and H. Takahashi. </author> <title> A graph-planarization algorithm and its applications to random graphs. In Graph Theory and Algorithms, </title> <booktitle> volume 108 of Lecture Notes in Computer Science, </booktitle> <pages> pages 95-107. </pages> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1981. </year>
Reference-contexts: Planar st-graphs were first introduced by Lempel, Even, and Cederbaum [77] in connection with a planarity testing algorithm, and have subsequently been used in a host of applications, dealing with partial orders [68], planar graph embedding [30, 42, 111], graph planarization <ref> [91] </ref>, 71 graph drawing [41, 43], floor planning [123], planar point location [49, 94], visibility [73, 88, 102, 113, 114, 124], motion planning [101], and VLSI layout compaction [123]. In this section, we consider a planar st-digraph G with V vertices, and recall that G has O (V ) edges.
Reference: [92] <author> F. P. Preparata. </author> <title> A new approach to planar point location. </title> <journal> SIAM J. Comput., </journal> <volume> 10 </volume> <pages> 473-482, </pages> <year> 1981. </year>
Reference-contexts: In this chapter we combine the feature just stated with the underpinnings of the trapezoid method, whose search efficiency both in theory <ref> [16, 92] </ref> and practice [47] is well-established. This leads to the adoption of horizontal normalizing diagonals, called lids. The method rests on three major components: 1. <p> If q is on an vertex or edge, then return that vertex or edge. Our dynamic point-location data structure is inspired by the static trapezoid method <ref> [92] </ref> and its dynamic version for monotone maps [28]. It uses the normalization and hull structures as the underpinning of update operations. Queries are instead performed in a location structure, a binary tree called trapezoid tree. <p> Queries are instead performed in a location structure, a binary tree called trapezoid tree. The trapezoid tree defines a binary partition of the plane obtained by means of vertical and horizontal cuts. It differs in many substantial aspects from the trapezoid trees used in <ref> [28, 92] </ref>, the most striking difference being that it is not balanced. The trapezoid tree T for map M is based on the Y-tree Y (see Section 2.4) and on the normalization of M as reflected by the normalization structure (see Section 2.3).
Reference: [93] <author> F. P. Preparata and M. I. Shamos. </author> <title> Computational Geometry: an Introduction. </title> <publisher> Springer-Verlag, </publisher> <address> New York, NY, </address> <year> 1985. </year> <month> 92 </month>
Reference-contexts: The mechanics of the dynamic maintenance of a normalized map are described in Section 2.3, while Sections 2.4, 2.5, and 2.6 are respectively devoted to shortest-path, point-location, and ray-shooting queries. 2.2 Review of Background For the geometric terminology used in this chapter, see <ref> [93] </ref>. A connected planar map M is a subdivision of the plane into polygonal regions whose underlying planar graph is connected. <p> With this representation, it is possible to find the two tangents from a point to a convex chain and the four common tangents between two convex chains in logarithmic time <ref> [93] </ref>. We now give the details of our representation of hourglasses. An open hourglass is represented by storing its two convex chains into chain trees. A closed hourglass is represented by storing into separate substructures the four convex chains forming the funnels, and the string between the apices. <p> The problem has important applications in VLSI layout and graphics, which are large-scale in nature. The algorithms under evaluation are distribution sweep of Goodrich et al. [60] and three variations of plane sweep <ref> [93] </ref>. Distribution sweep theoretically has optimal I/O cost [60]. Plane sweep is a well-known and powerful technique in computational geometry, and is optimal for this particular problem in terms of internal computation [93]. <p> The algorithms under evaluation are distribution sweep of Goodrich et al. [60] and three variations of plane sweep <ref> [93] </ref>. Distribution sweep theoretically has optimal I/O cost [60]. Plane sweep is a well-known and powerful technique in computational geometry, and is optimal for this particular problem in terms of internal computation [93]. The three variations of plane sweep differ by the sorting methods (external merge sort [2] vs. internal merge sort) used in the preprocessing phase and the dynamic data structures (B tree [9, 34, 35] vs. 2-3-4 tree [35]) used in the sweeping phase. <p> Each I/O operation transfers one page of data. 74 5.2.1 Three Variations of Plane Sweep The well-known plane sweep paradigm <ref> [93] </ref> is a powerful technique in computational geometry, and is optimal for the orthogonal segment intersection problem in terms of internal computation. The method consists of preprocessing and sweeping phases. In the preprocessing phase, we sort all endpoints by the y-coordinates in non-decreasing order.
Reference: [94] <author> F. P. Preparata and R. Tamassia. </author> <title> Fully dynamic point location in a monotone subdivision. </title> <journal> SIAM J. Comput., </journal> <volume> 18 </volume> <pages> 811-830, </pages> <year> 1989. </year>
Reference-contexts: Such methods, however, refer to the static case where no alteration of the map is allowed during its use. Due to the obvious importance of the dynamic setting, in recent years considerable attention has been devoted to the development of dynamic point-location algorithms <ref> [8, 23, 28, 54, 57, 89, 94, 95, 112] </ref>. All the known dynamic point location results are for connected maps, since maintaining region names in a disconnected map would require solving half-planar range searching in a dynamic environment, for which no polylog-time algorithm is known. <p> first introduced by Lempel, Even, and Cederbaum [77] in connection with a planarity testing algorithm, and have subsequently been used in a host of applications, dealing with partial orders [68], planar graph embedding [30, 42, 111], graph planarization [91], 71 graph drawing [41, 43], floor planning [123], planar point location <ref> [49, 94] </ref>, visibility [73, 88, 102, 113, 114, 124], motion planning [101], and VLSI layout compaction [123]. In this section, we consider a planar st-digraph G with V vertices, and recall that G has O (V ) edges. The results in this section are summarized in Table 4.3.
Reference: [95] <author> F. P. Preparata and R. Tamassia. </author> <title> Dynamic planar point location with optimal query time. </title> <journal> Theoret. Comput. Sci., </journal> <volume> 74 </volume> <pages> 95-114, </pages> <year> 1990. </year>
Reference-contexts: Such methods, however, refer to the static case where no alteration of the map is allowed during its use. Due to the obvious importance of the dynamic setting, in recent years considerable attention has been devoted to the development of dynamic point-location algorithms <ref> [8, 23, 28, 54, 57, 89, 94, 95, 112] </ref>. All the known dynamic point location results are for connected maps, since maintaining region names in a disconnected map would require solving half-planar range searching in a dynamic environment, for which no polylog-time algorithm is known.
Reference: [96] <author> F. P. Preparata, J. S. Vitter, and M. Yvinec. </author> <title> Computation of the axial view of a set of isothetic parallelepipeds. </title> <journal> ACM Trans. Graph., </journal> <volume> 9 </volume> <pages> 278-300, </pages> <year> 1990. </year>
Reference-contexts: Remark. In a concrete situation where vertices are a priori restricted to a fixed set of ordinates, tree Y is static; if we then implement the trees ltree and rtree by means of contracted binary trees <ref> [96] </ref> of depth &lt; log jY j (whose maintenance requires no rotation), then the update times become O (log 2 n log jY j), in the worst case.
Reference: [97] <author> S. Ramaswamy and P. C. Kanellakis. </author> <title> OODB indexing by class-division. </title> <booktitle> In Proc. ACM SIGMOD Internat. Conf. on Management of Data, </booktitle> <pages> pages 139-150, </pages> <year> 1995. </year>
Reference-contexts: This work, however, is mainly on providing a programming environment and not on performance comparisons between external-memory algorithms and conventional algorithms. Also worth noting is the work by Ramaswamy and Kanellakis <ref> [97] </ref>, who study the problem of indexing a class hierarchy in Object Oriented Databases.
Reference: [98] <author> S. Ramaswamy and S. Subramanian. </author> <title> Path caching: A technique for optimal external searching. </title> <booktitle> In Proc. ACM Symp. on Principles of Database Sys., </booktitle> <pages> pages 25-35, </pages> <year> 1994. </year>
Reference-contexts: For geometric problems, Goodrich et al. [60] study a number of problems in computational geometry and develop several paradigms for I/O-optimal geometric computations. Further results in this area have been obtained in [51, 125]. Also, Kanellakis et al. [65] and Ramaswamy and Sub-ramanian <ref> [98, 106] </ref> give efficient data structures for performing range searching in external memory. Very recently, a new data structure called buffer tree and its applications are given in [5, 6], and an external-memory version of the directed topology tree ([52]) called topology B-tree is given in [17].
Reference: [99] <author> J. H. Reif and S. Sen. </author> <title> An efficient output-sensitive hidden-surface removal algorithms and its parallelization. </title> <booktitle> In Proc. 4th Annu. ACM Sympos. Comput. Geom., </booktitle> <pages> pages 193-200, </pages> <year> 1988. </year>
Reference-contexts: No polylog-time method was previously known in a dynamic setting, although a polylog-time ray-shooting technique by Reif and Sen <ref> [99] </ref>, designed for monotone polygons, may be extensible to the general case. Sublinear-time techniques are known only for ray-shooting queries [1, 22], with 4 O ( n polylog (n)) query/update time; they support ray-shooting in a set of possibly intersecting segments without taking advantage of the structure of planar maps.
Reference: [100] <author> J. H. Reif and J. A. Storer. </author> <title> Minimizing turns for discrete movement in the interior of a polygon. </title> <journal> IEEE J. Robot. </journal> <volume> Autom., </volume> <pages> pages 182-193, </pages> <year> 1987. </year>
Reference-contexts: The minimum-link path problem between two points has been extensively studied. In many applications, such as robotics, motion planning, VLSI and computer vision, the link distance often provides a more natural measure of path complexity than the Euclidean distance <ref> [67, 83, 100, 107, 109] </ref>. For example, in a robot system, a straight-line navigation is often much cheaper than 32 rotation, thus it is desirable to minimize the number of turns in path planning [100, 109]. <p> For example, in a robot system, a straight-line navigation is often much cheaper than 32 rotation, thus it is desirable to minimize the number of turns in path planning <ref> [100, 109] </ref>. Also, in graph drawing, it is often desirable to minimize the number of bends [105, 110]. All previously known techniques for the minimum-link path problem are restricted to the static environment, where updates to the problem instance are not allowed.
Reference: [101] <author> I. Rival and J. Urrutia. </author> <title> Representing orders by translating convex figures in the plane. </title> <booktitle> Order, </booktitle> <volume> 4 </volume> <pages> 319-339, </pages> <year> 1988. </year>
Reference-contexts: a planarity testing algorithm, and have subsequently been used in a host of applications, dealing with partial orders [68], planar graph embedding [30, 42, 111], graph planarization [91], 71 graph drawing [41, 43], floor planning [123], planar point location [49, 94], visibility [73, 88, 102, 113, 114, 124], motion planning <ref> [101] </ref>, and VLSI layout compaction [123]. In this section, we consider a planar st-digraph G with V vertices, and recall that G has O (V ) edges. The results in this section are summarized in Table 4.3. Lower bounds are similar to Corollary 4.1.
Reference: [102] <author> P. Rosenstiehl and R. E. Tarjan. </author> <title> Rectilinear planar layouts and bipolar orientations of planar graphs. </title> <journal> Discrete Comput. Geom., </journal> <volume> 1(4) </volume> <pages> 343-353, </pages> <year> 1986. </year>
Reference-contexts: Lempel, Even, and Cederbaum [77] in connection with a planarity testing algorithm, and have subsequently been used in a host of applications, dealing with partial orders [68], planar graph embedding [30, 42, 111], graph planarization [91], 71 graph drawing [41, 43], floor planning [123], planar point location [49, 94], visibility <ref> [73, 88, 102, 113, 114, 124] </ref>, motion planning [101], and VLSI layout compaction [123]. In this section, we consider a planar st-digraph G with V vertices, and recall that G has O (V ) edges. The results in this section are summarized in Table 4.3.
Reference: [103] <author> N. Sarnak and R. E. Tarjan. </author> <title> Planar point location using persistent search trees. </title> <journal> Commun. ACM, </journal> <volume> 29 </volume> <pages> 669-679, </pages> <year> 1986. </year>
Reference-contexts: Starting with the pioneering work in planar point-location of the seventies [46, 75], over the years several techniques have been developed, culminating in asymptotically time- and space-optimal methods <ref> [49, 72, 103] </ref> that are also of sufficiently practical flavor. Such methods, however, refer to the static case where no alteration of the map is allowed during its use.
Reference: [104] <author> D. D. Sleator and R. E. Tarjan. </author> <title> A data structure for dynamic trees. </title> <journal> J. Comput. Syst. Sci., </journal> <volume> 24 </volume> <pages> 362-381, </pages> <year> 1983. </year>
Reference-contexts: In particular, a simple rotation can be viewed as a sequence of four elementary splits and joins. Three special types of data structures will be used in this chapter: biased binary trees [10], BB [ff]-trees [81], and dynamic trees <ref> [104] </ref>. A biased binary tree [10] is a binary search tree whose leaves store weighted items. Let w be the sum of all weights. <p> Then the amortized time of an update operation in a sequence of n insertions and deletions starting from an initially empty BB [ff]-tree is O (log 2 n). Dynamic trees <ref> [104] </ref> are designed to represent a forest of rooted trees, with each edge directed toward the root of its tree (and called an arc). <p> Each region r of M is handled individually. We refer to a region r, bounded or unbounded. In the following, we denote by m the current number of vertices in r. 7 We imagine to represent ffi (r) as a dynamic tree (r) <ref> [104] </ref> (see Fig. 2.1). We choose an arbitrary node of ffi (r) as the root, which immediately forces a direction on each edge, referred to hereafter as an arc and directed toward the root. <p> Primitive dynamic tree operations We begin by considering some elementary dynamic tree operations expose, conceal and evert introduced in <ref> [104] </ref>, in terms of which the operations of the above repertory can be immediately expressed. In the course of some updates, we may change a solid arc to dashed and vice versa and thus violate the weight invariant; so we need the capability to restore such weight invariant. <p> In the course of some updates, we may change a solid arc to dashed and vice versa and thus violate the weight invariant; so we need the capability to restore such weight invariant. Such actions are effected by the operation expose and conceal introduced in <ref> [104] </ref>. Operation expose (), for some node of (r), transforms the unique path P from node to the root of (r) into a solid path, by changing the dashed arcs in P to solid and the solid arcs incident to P to dashed. <p> So the main issue for performing conceal (P ) is how to find the topmost light arc. Before describing its adaptation to the double-thread data structure, we briefly review the standard implementation of operation conceal as proposed by Sleator and Tarjan <ref> [104] </ref>. Let the dynamic-tree-nodes of solid path P be stored left-to-right as the leaves of a balanced binary tree T (P ), called in [104] a path tree. <p> Before describing its adaptation to the double-thread data structure, we briefly review the standard implementation of operation conceal as proposed by Sleator and Tarjan <ref> [104] </ref>. Let the dynamic-tree-nodes of solid path P be stored left-to-right as the leaves of a balanced binary tree T (P ), called in [104] a path tree. Each leaf of T (P ) stores local weight (), defined as the sum of the local weights of all dashed-arc children (which are the roots of some other path trees) of 15 , if any, plus one (to account for itself ). <p> Indeed, the leaf reached identifies an edge that is first hit by a horizontal ray through q. Since we did not impose any balance requirement on T , the query time could be linear in the worst-case. To speed-up queries, we implement T as a dynamic tree <ref> [104] </ref>, i.e., T is decomposed into solid paths (which should not be confused with the solid paths in the normalization structure), connected by dashed arcs (see Fig. 2.11). Each solid path is associated with a path tree, implemented as a 25 in part (a). biased search tree [10].
Reference: [105] <author> J. A. Storer. </author> <title> On minimal node-cost planar embeddings. </title> <journal> Networks, </journal> <volume> 14 </volume> <pages> 181-212, </pages> <year> 1984. </year>
Reference-contexts: For example, in a robot system, a straight-line navigation is often much cheaper than 32 rotation, thus it is desirable to minimize the number of turns in path planning [100, 109]. Also, in graph drawing, it is often desirable to minimize the number of bends <ref> [105, 110] </ref>. All previously known techniques for the minimum-link path problem are restricted to the static environment, where updates to the problem instance are not allowed. The method of [107] computes a minimum-link path between two fixed points inside a simple polygon in linear time.
Reference: [106] <author> S. Subramanian and S. Ramaswamy. </author> <title> The P-range tree: A new data structure for range searching in secondary memory. </title> <booktitle> In Proc. ACM-SIAM Symp. on Discrete Algorithms, </booktitle> <pages> pages 378-387, </pages> <year> 1995. </year>
Reference-contexts: For geometric problems, Goodrich et al. [60] study a number of problems in computational geometry and develop several paradigms for I/O-optimal geometric computations. Further results in this area have been obtained in [51, 125]. Also, Kanellakis et al. [65] and Ramaswamy and Sub-ramanian <ref> [98, 106] </ref> give efficient data structures for performing range searching in external memory. Very recently, a new data structure called buffer tree and its applications are given in [5, 6], and an external-memory version of the directed topology tree ([52]) called topology B-tree is given in [17].
Reference: [107] <author> S. Suri. </author> <title> A linear time algorithm for minimum link paths inside a simple polygon. Comput. Vision Graph. </title> <journal> Image Process., </journal> <volume> 35 </volume> <pages> 99-110, </pages> <year> 1986. </year>
Reference-contexts: The minimum-link path problem between two points has been extensively studied. In many applications, such as robotics, motion planning, VLSI and computer vision, the link distance often provides a more natural measure of path complexity than the Euclidean distance <ref> [67, 83, 100, 107, 109] </ref>. For example, in a robot system, a straight-line navigation is often much cheaper than 32 rotation, thus it is desirable to minimize the number of turns in path planning [100, 109]. <p> Also, in graph drawing, it is often desirable to minimize the number of bends [105, 110]. All previously known techniques for the minimum-link path problem are restricted to the static environment, where updates to the problem instance are not allowed. The method of <ref> [107] </ref> computes a minimum-link path between two fixed points inside a simple polygon in linear time. In [109], a scheme based on window partition can answer link distance queries from a fixed source in O (log n) time, after O (n) time preprocessing.
Reference: [108] <author> S. Suri. </author> <title> Minimum link paths in polygons and related problems. </title> <type> Ph.D. thesis, </type> <institution> Dept. Comput. Sci., Johns Hopkins Univ., Baltimore, MD, </institution> <year> 1987. </year>
Reference-contexts: Also, efficient parallel algorithms are given in [18]. There are other results on the variations of the minimum-link-path problem. Efficient algorithms for link diameter and link center are given in <ref> [44, 56, 78, 67, 85, 84, 108] </ref>. A minimum-link path between two fixed points in a multiply connected polygon can be computed efficiently [83]. Sequential and parallel algorithms for rectilinear link distance are respectively given by de Berg [39] and Lingas et al. [79].
Reference: [109] <author> S. Suri. </author> <title> On some link distance problems in a simple polygon. </title> <journal> IEEE Trans. Robot. Autom., </journal> <volume> 6 </volume> <pages> 108-113, </pages> <year> 1990. </year>
Reference-contexts: The minimum-link path problem between two points has been extensively studied. In many applications, such as robotics, motion planning, VLSI and computer vision, the link distance often provides a more natural measure of path complexity than the Euclidean distance <ref> [67, 83, 100, 107, 109] </ref>. For example, in a robot system, a straight-line navigation is often much cheaper than 32 rotation, thus it is desirable to minimize the number of turns in path planning [100, 109]. <p> For example, in a robot system, a straight-line navigation is often much cheaper than 32 rotation, thus it is desirable to minimize the number of turns in path planning <ref> [100, 109] </ref>. Also, in graph drawing, it is often desirable to minimize the number of bends [105, 110]. All previously known techniques for the minimum-link path problem are restricted to the static environment, where updates to the problem instance are not allowed. <p> All previously known techniques for the minimum-link path problem are restricted to the static environment, where updates to the problem instance are not allowed. The method of [107] computes a minimum-link path between two fixed points inside a simple polygon in linear time. In <ref> [109] </ref>, a scheme based on window partition can answer link distance queries from a fixed source in O (log n) time, after O (n) time preprocessing. The best known results are due to Arkin, Mitchell and Suri [7]. <p> Static Min-Link Paths Query Type Query Space Preprocessing Suri <ref> [109] </ref> one fixed point and one query point log n fl n fl n fl Arkin-Mitchell- two query points/segments log n fl n 3 n 3 Suri [7] two query convex polygons log h log n n 3 n 3 This chapter two query convex polygons log h + log n <p> A polygon is monotone if and only if it has no cusps. The notion of window partition was introduced in <ref> [109] </ref>. Given a point or a line segment s in region P , let W P (s) denote the partition of P into maximally-connected subregions with the same link distance from s; W P (s) is called the window partition of P with respect to s. <p> On the contrary, a minimum-link path is not unique and may turn at any point inside P . Adopting the terminology of <ref> [109] </ref>, we define the (unique) greedy minimum-link path L (p; q) to be the minimum-link path whose first and last links are respectively the extensions of the first and last links of G (p; q), and whose other links are the extensions of the windows of W P (p).
Reference: [110] <author> R. Tamassia. </author> <title> On embedding a graph in the grid with the minimum number of bends. </title> <journal> SIAM J. Comput., </journal> <volume> 16(3) </volume> <pages> 421-444, </pages> <year> 1987. </year>
Reference-contexts: For example, in a robot system, a straight-line navigation is often much cheaper than 32 rotation, thus it is desirable to minimize the number of turns in path planning [100, 109]. Also, in graph drawing, it is often desirable to minimize the number of bends <ref> [105, 110] </ref>. All previously known techniques for the minimum-link path problem are restricted to the static environment, where updates to the problem instance are not allowed. The method of [107] computes a minimum-link path between two fixed points inside a simple polygon in linear time.
Reference: [111] <author> R. Tamassia. </author> <title> A dynamic data structure for planar graph embedding. </title> <editor> In T. Lepisto and A. Salomaa, editors, </editor> <booktitle> Automata, Languages and Programming (Proc. 15th ICALP), volume 317 of Lecture Notes in Computer Science, </booktitle> <pages> pages 576-590. </pages> <publisher> Springer-Verlag, </publisher> <year> 1988. </year>
Reference-contexts: Planar st-graphs were first introduced by Lempel, Even, and Cederbaum [77] in connection with a planarity testing algorithm, and have subsequently been used in a host of applications, dealing with partial orders [68], planar graph embedding <ref> [30, 42, 111] </ref>, graph planarization [91], 71 graph drawing [41, 43], floor planning [123], planar point location [49, 94], visibility [73, 88, 102, 113, 114, 124], motion planning [101], and VLSI layout compaction [123].
Reference: [112] <author> R. Tamassia. </author> <title> An incremental reconstruction method for dynamic planar point location. </title> <journal> Inform. Process. Lett., </journal> <volume> 37 </volume> <pages> 79-83, </pages> <year> 1991. </year>
Reference-contexts: Such methods, however, refer to the static case where no alteration of the map is allowed during its use. Due to the obvious importance of the dynamic setting, in recent years considerable attention has been devoted to the development of dynamic point-location algorithms <ref> [8, 23, 28, 54, 57, 89, 94, 95, 112] </ref>. All the known dynamic point location results are for connected maps, since maintaining region names in a disconnected map would require solving half-planar range searching in a dynamic environment, for which no polylog-time algorithm is known.
Reference: [113] <author> R. Tamassia and I. G. Tollis. </author> <title> A unified approach to visibility representations of planar graphs. </title> <journal> Discrete Comput. Geom., </journal> <volume> 1(4) </volume> <pages> 321-341, </pages> <year> 1986. </year>
Reference-contexts: Lempel, Even, and Cederbaum [77] in connection with a planarity testing algorithm, and have subsequently been used in a host of applications, dealing with partial orders [68], planar graph embedding [30, 42, 111], graph planarization [91], 71 graph drawing [41, 43], floor planning [123], planar point location [49, 94], visibility <ref> [73, 88, 102, 113, 114, 124] </ref>, motion planning [101], and VLSI layout compaction [123]. In this section, we consider a planar st-digraph G with V vertices, and recall that G has O (V ) edges. The results in this section are summarized in Table 4.3.
Reference: [114] <author> R. Tamassia and I. G. Tollis. </author> <title> Representations of graphs on a cylinder. </title> <journal> SIAM J. Discrete Math., </journal> <volume> 4(1) </volume> <pages> 139-149, </pages> <year> 1991. </year> <month> 93 </month>
Reference-contexts: Lempel, Even, and Cederbaum [77] in connection with a planarity testing algorithm, and have subsequently been used in a host of applications, dealing with partial orders [68], planar graph embedding [30, 42, 111], graph planarization [91], 71 graph drawing [41, 43], floor planning [123], planar point location [49, 94], visibility <ref> [73, 88, 102, 113, 114, 124] </ref>, motion planning [101], and VLSI layout compaction [123]. In this section, we consider a planar st-digraph G with V vertices, and recall that G has O (V ) edges. The results in this section are summarized in Table 4.3.
Reference: [115] <author> R. Tamassia and J. S. Vitter. </author> <title> Parallel transitive closure and point location in planar struc-tures. </title> <journal> SIAM J. Comput., </journal> <volume> 20(4) </volume> <pages> 708-725, </pages> <year> 1991. </year>
Reference-contexts: The results in this section are summarized in Table 4.3. Lower bounds are similar to Corollary 4.1. We obtain the given upper bounds by modifying the PRAM algorithms of Tamassia and Vitter <ref> [115] </ref>, and applying the list ranking and the PRAM simulation techniques.
Reference: [116] <author> R.E. Tarjan and U. Vishkin. </author> <title> Finding biconnected components and computing tree functions in logarithmic parallel time. </title> <journal> SIAM J. Computing, </journal> <volume> 14(4) </volume> <pages> 862-874, </pages> <year> 1985. </year>
Reference-contexts: After O (log (V =M )) iterations we fit the remaining M vertices to the main memory and solve the problem easily. For biconnected components, we adapt the PRAM algorithm of Tarjan and Vishkin <ref> [116] </ref>, which requires generating an arbitrary spanning tree (by our connected component algorithm), evaluating an expression tree (by Theorem 4.5), and computing connected components of a newly created graph.
Reference: [117] <author> J. D. Ullman and M. Yannakakis. </author> <title> The input/output complexity of transitive closure. </title> <journal> Annals of Mathematics and Artificial Intellegence, </journal> <volume> 3 </volume> <pages> 331-360, </pages> <year> 1991. </year>
Reference-contexts: There has also been some work on selected graph problems, including the investigations by Ullman and Yannakakis <ref> [117] </ref> on transitive closure computations. This work, however, restricts its attention to problem instances where the set of vertices fits into main memory but the set of edges does not. Vishkin [121] uses PRAM simulation to facilitate prefetching for various problems, but without taking blocking issues into account.
Reference: [118] <author> D. E. Vengroff. </author> <type> Personal communication, </type> <year> 1994. </year>
Reference-contexts: The lower bound (perm (N )) holds even in some important cases when we are not required to perform all N ! possible permutations. In <ref> [118] </ref> (also appearing in [25]) a problem called proximate neighbors, which is a significantly-restricted form of permutation, is used to derive a number of non-trivial lower bounds. <p> This is a general algorithmic technique commonly used to derive work-efficient PRAM algorithms. As pointed out by <ref> [118] </ref>, this technique is especially useful for us, since our technique of Theorem 4.1 already uses O (sort (N )) rather than O (1) I/Os to simulate a single PRAM step.
Reference: [119] <author> D. E. Vengroff and J. S. Vitter. </author> <title> I/O-efficient scientific computation using TPIE. </title> <type> Manuscript, </type> <year> 1995. </year>
Reference-contexts: For excellent examples of experimental work in computational geometry, see Bentley [11, 12, 13, 14]. As for experimental work on I/O-efficient computation, very recently Vengroff has built an environment called TPIE for programming external-memory algorithms as he proposed earlier in [120], and also Vengroff and Vitter <ref> [119] </ref> have reported some benchmarks of TPIE on sorting and matrix multiplication. This work, however, is mainly on providing a programming environment and not on performance comparisons between external-memory algorithms and conventional algorithms.
Reference: [120] <author> Darren Erik Vengroff. </author> <title> A transparent parallel I/O environment. </title> <booktitle> In Proc. 1994 DAGS Symposium on Parallel Computation, </booktitle> <month> July </month> <year> 1994. </year>
Reference-contexts: Other related theoretical results are reviewed in Section 4.1.2. For excellent examples of experimental work in computational geometry, see Bentley [11, 12, 13, 14]. As for experimental work on I/O-efficient computation, very recently Vengroff has built an environment called TPIE for programming external-memory algorithms as he proposed earlier in <ref> [120] </ref>, and also Vengroff and Vitter [119] have reported some benchmarks of TPIE on sorting and matrix multiplication. This work, however, is mainly on providing a programming environment and not on performance comparisons between external-memory algorithms and conventional algorithms.
Reference: [121] <author> U. </author> <title> Vishkin. </title> <type> Personal communication, </type> <year> 1992. </year>
Reference-contexts: There has also been some work on selected graph problems, including the investigations by Ullman and Yannakakis [117] on transitive closure computations. This work, however, restricts its attention to problem instances where the set of vertices fits into main memory but the set of edges does not. Vishkin <ref> [121] </ref> uses PRAM simulation to facilitate prefetching for various problems, but without taking blocking issues into account. Also worth noting is recent work [58] on some graph traversal problems; this work primarily addresses the problem of storing graphs, however, not in performing specific computations on them. <p> Related work on simulating PRAM computations in external memory is done by Cormen [36]. The use of PRAM simulation for prefetching, without the important consideration of blocking, is explored by Vishkin <ref> [121] </ref>. 4.3.1 Generic Simulation of a PRAM Algorithm We begin by considering how to simulate a PRAM algorithm A. Under the work-time presentation framework, the work performed by A is defined to be the total number of operations used [64].
Reference: [122] <author> Jeffrey Scott Vitter and Elizabeth A. M. Shriver. </author> <title> Algorithms for parallel memory I: Two-level memories. </title> <journal> Algorithmica, </journal> <volume> 12(2), </volume> <year> 1994. </year>
Reference-contexts: Values of D can range up to 10 2 in current systems. Large-scale problem instances can be in the range N = 10 10 to N = 10 12 . Our measure of performance for external-memory algorithms is the standard notion of I/O complexity <ref> [122] </ref>. We define an input/output operation (or simply I/O for short) to be the process of simultaneously reading or writing D blocks of data, to or from each of the disks. The total amount of data transferred in an I/O is thus DB items. <p> of I/Os needed to read x items, and sort (x) = x log M=B B which is proportional to the optimal number of I/Os needed to sort x items [87]. 4.1.2 Previous Work Early work on external-memory algorithms concentrated largely on fundamental problems such as sorting, matrix multiplication, and FFT <ref> [2, 87, 122] </ref>. The main focus of this early work was therefore directed at problems that involved permutation at a basic level. Indeed, just the problem of implementing various classes of permutation has been a central theme in external-memory I/O research [2, 36, 37, 38, 122]. <p> The main focus of this early work was therefore directed at problems that involved permutation at a basic level. Indeed, just the problem of implementing various classes of permutation has been a central theme in external-memory I/O research <ref> [2, 36, 37, 38, 122] </ref>. More recently, external-memory research has moved towards solving geometric and graph problems. For geometric problems, Goodrich et al. [60] study a number of problems in computational geometry and develop several paradigms for I/O-optimal geometric computations. <p> In external memory, however, it is not generally possible to perform arbitrary permutations in a linear number (O (scan (N ))) of I/Os. Instead, it is well-known that fi (perm (N )) I/Os are required in the worst case <ref> [2, 122] </ref> where perm (N ) = min D ; sort (N ) When M or B is extremely small, N=D = O (B scan (N )) may be smaller than sort (N ). <p> Furthermore, for simplicity, we restrict the discussion to the D = 1 case of one disk. The load balancing issues that arise with multiple disks are handled with balancing techniques akin to <ref> [86, 122] </ref>. The 3-coloring algorithm consists of three phases. Phase 1 sets up an N -coloring. Each remaining phase reduces the number of colors used. Colors and node IDs are represented by integers. 1. <p> Viewing the internal memory as virtually having an infinite size is conceptually the simplest, and is actually the most commonly used strategy today in practice. 5.2.2 Distribution Sweep Distribution sweep [60] is an external-memory version of plane sweep based on the subdivision technique used in the "distribution sort" algorithms of <ref> [2, 86, 122] </ref>. When applied to the orthogonal segment intersection problem, it works as follows. In the preprocessing phase, we sort the endpoints of all segments into two lists, one by x and the other by y. Again we use external merge sort.
Reference: [123] <author> S. Wimer, I. Koren, and I. Cederbaum. Floorplans, </author> <title> planar graphs, and layouts. </title> <journal> IEEE Trans. on Circuits and Systems, </journal> <volume> 35(3) </volume> <pages> 267-278, </pages> <year> 1988. </year>
Reference-contexts: Planar st-graphs were first introduced by Lempel, Even, and Cederbaum [77] in connection with a planarity testing algorithm, and have subsequently been used in a host of applications, dealing with partial orders [68], planar graph embedding [30, 42, 111], graph planarization [91], 71 graph drawing [41, 43], floor planning <ref> [123] </ref>, planar point location [49, 94], visibility [73, 88, 102, 113, 114, 124], motion planning [101], and VLSI layout compaction [123]. In this section, we consider a planar st-digraph G with V vertices, and recall that G has O (V ) edges. <p> have subsequently been used in a host of applications, dealing with partial orders [68], planar graph embedding [30, 42, 111], graph planarization [91], 71 graph drawing [41, 43], floor planning <ref> [123] </ref>, planar point location [49, 94], visibility [73, 88, 102, 113, 114, 124], motion planning [101], and VLSI layout compaction [123]. In this section, we consider a planar st-digraph G with V vertices, and recall that G has O (V ) edges. The results in this section are summarized in Table 4.3. Lower bounds are similar to Corollary 4.1.
Reference: [124] <author> S. K. Wismath. </author> <title> Characterizing bar line-of-sight graphs. </title> <booktitle> In Proc. 1st Annu. ACM Sympos. Comput. Geom., </booktitle> <pages> pages 147-152, </pages> <year> 1985. </year>
Reference-contexts: Lempel, Even, and Cederbaum [77] in connection with a planarity testing algorithm, and have subsequently been used in a host of applications, dealing with partial orders [68], planar graph embedding [30, 42, 111], graph planarization [91], 71 graph drawing [41, 43], floor planning [123], planar point location [49, 94], visibility <ref> [73, 88, 102, 113, 114, 124] </ref>, motion planning [101], and VLSI layout compaction [123]. In this section, we consider a planar st-digraph G with V vertices, and recall that G has O (V ) edges. The results in this section are summarized in Table 4.3.
Reference: [125] <author> B. Zhu. </author> <title> Further computational geometry in secondary memory. </title> <booktitle> In Proc. Int. Symp. on Algorithms and Computation, </booktitle> <year> 1994. </year> <month> 94 </month>
Reference-contexts: More recently, external-memory research has moved towards solving geometric and graph problems. For geometric problems, Goodrich et al. [60] study a number of problems in computational geometry and develop several paradigms for I/O-optimal geometric computations. Further results in this area have been obtained in <ref> [51, 125] </ref>. Also, Kanellakis et al. [65] and Ramaswamy and Sub-ramanian [98, 106] give efficient data structures for performing range searching in external memory.
References-found: 125

