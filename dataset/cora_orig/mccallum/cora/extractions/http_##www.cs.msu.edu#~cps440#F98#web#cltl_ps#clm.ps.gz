URL: http://www.cs.msu.edu/~cps440/F98/web/cltl_ps/clm.ps.gz
Refering-URL: http://www.cs.msu.edu/~cps440/F98/web/select.html
Root-URL: http://www.cs.msu.edu
Note: Contents Preface (Second Edition) xi Acknowledgments (Second Edition) xiii Acknowledgments (First Edition) xvii  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> Adobe Systems Incorporated. </author> <title> PostScript Language Reference Manual. </title> <publisher> Addison-Wesley (Reading, </publisher> <address> Massachusetts, </address> <year> 1985). </year>
Reference-contexts: Four annuli (rings) are painted in gradated shades of gray. Ring 1, the inner ring, consists of points whose radial distances from the origin lie in the range [1=4; 1=2]; ring 2 is in the radial range <ref> [3=4; 1] </ref>; ring 3, in the range [=2; 2]; and ring 4, in the range [3; ]. Ring j is divided into 2 j+1 equal sectors, with each sector painted a different shade of gray, darkening as one proceeds counterclockwise from the positive real axis. <p> I believe that the particular form in which the graphs are presented is novel, as well as the fact 340 COMMON LISP that the graphs have been generated as PostScript <ref> [1] </ref> code by Common Lisp code. This PostScript code was then fed directly to the typesetting equipment that set the pages for this book. Samples of this PostScript code follow the figures themselves, after which the code for the entire program is presented. <p> Here is a different view. The entire real axis is mapped to the segment <ref> [1; 1] </ref> of the real axis with infinite multiplicity (period 2). The imaginary axis is mapped to itself as if by sinh considered as a real function. The origin is mapped to itself. <p> The entire real axis is again mapped to the segment <ref> [1; 1] </ref> of the real axis, but each half of the imaginary axis is mapped to the real axis to the right of 1 (as if by cosh considered as a real function). Therefore 1i both map to +1. The origin is mapped to 1. <p> NUMBERS 357 The diagram for tanh is simply that of tan turned on its ear: i tan z = tanh iz . The imaginary axis is mapped onto itself with infinite multiplicity (period 2), and the real axis is mapped onto the segment <ref> [1; +1] </ref>: +1 is mapped to +1, and 1 to 1. Vertical lines to the left or right of the real axis are mapped to circles surrounding 1 or 1, respectively. <p> Q.E.D. 358 COMMON LISP A sleeping peacock of another color: arctanh iz = i arctan z . NUMBERS 359 p Here is a curious graph indeed for so simple a function! The origin is mapped to 1. The real axis segment <ref> [0; 1] </ref> is mapped backwards (and non-linearly) into itself; the segment [1; +1] is mapped non-linearly onto the positive imaginary axis. The negative real axis is mapped to the same points as the positive real axis. <p> NUMBERS 359 p Here is a curious graph indeed for so simple a function! The origin is mapped to 1. The real axis segment [0; 1] is mapped backwards (and non-linearly) into itself; the segment <ref> [1; +1] </ref> is mapped non-linearly onto the positive imaginary axis. The negative real axis is mapped to the same points as the positive real axis. Both halves of the imaginary axis are mapped into [1; +1] on the real axis. <p> The real axis segment [0; 1] is mapped backwards (and non-linearly) into itself; the segment <ref> [1; +1] </ref> is mapped non-linearly onto the positive imaginary axis. The negative real axis is mapped to the same points as the positive real axis. Both halves of the imaginary axis are mapped into [1; +1] on the real axis. Horizontal lines become vaguely vertical, and vertical lines become vaguely horizontal. Circles centered at the origin are transformed into Cassinian (half-)ovals; the unit circle is mapped to a (half-)lemniscate of Bernoulli. <p> This formula is indeed of exactly the same form as cosh iz = cos z . The function p 1 + z 2 maps both halves of the real axis into <ref> [1; +1] </ref> on the real axis. <p> The function p 1 + z 2 maps both halves of the real axis into [1; +1] on the real axis. The segments [0; i ] and [0; i] of the imaginary axis are each mapped backwards onto segment <ref> [0; 1] </ref> of the real axis; [i; +1i] and [; 1i] are each mapped onto the positive imaginary axis (but if minus zero is supported then opposite sides of the imaginary axis map to opposite halves of the imaginary axis|for example, q (+0 + 2i) = p p NUMBERS 361 Here
Reference: [2] <author> Alberga, Cyril N., Bosman-Clark, Chris, Mikelsons, Martin, Van Deusen, Mary S., and Padget, Julian. </author> <title> Experience with an uncommon Lisp. </title> <booktitle> In Proc. 1986 ACM Conference on Lisp and Functional Programming. </booktitle> <publisher> ACM SIGPLAN/SIGACT/SIGART (Cambridge, </publisher> <address> Massachusetts, </address> <month> August </month> <year> 1986), </year> <pages> 39-53. </pages>
Reference-contexts: Four annuli (rings) are painted in gradated shades of gray. Ring 1, the inner ring, consists of points whose radial distances from the origin lie in the range [1=4; 1=2]; ring 2 is in the radial range [3=4; 1]; ring 3, in the range <ref> [=2; 2] </ref>; and ring 4, in the range [3; ]. Ring j is divided into 2 j+1 equal sectors, with each sector painted a different shade of gray, darkening as one proceeds counterclockwise from the positive real axis.
Reference: [3] <institution> American National Standard Programming Language FORTRAN, ANSI X3.9-1978 edition. American National Standards Institute, Inc. </institution> <address> (New York, </address> <year> 1978). </year>
Reference-contexts: Put another way, the indices for the elements of an array are ordered lexicographically. Compatibility note: Both Lisp Machine Lisp, as described in reference [55], and Fortran <ref> [15, 3] </ref> store arrays in column-major order. [Constant ]array-rank-limit The value of array-rank-limit is a positive integer that is the upper exclusive bound on the rank of an array.
Reference: [4] <author> Bates, Raymond L., Dyer, David, and Feber, Mark. </author> <booktitle> Recent developments in ISI-Interlisp. In Proc. 1984 ACM Symposium on Lisp and Functional Programming. ACM SIGPLAN/SIGACT/SIGART (Austin, </booktitle> <address> Texas, </address> <month> August </month> <year> 1984), </year> <pages> 129-139. </pages>
Reference: [5] <author> Bobrow, Daniel G., DiMichiel, Linda G., Gabriel, Richard P., Keene, Sonya E., Kiczales, Gregor, and Moon, David A. </author> <title> Common Lisp Object System Specification: X3J13 Document 88-002R. </title> <journal> SIGPLAN Notices 23 (Septem-ber 1988). </journal>
Reference-contexts: This chapter presents the bulk of the first two chapters of the Common Lisp Object System specification; it is substantially identical to these two specification chapters as previously published elsewhere <ref> [5, 6, 7] </ref>. I have edited the material only very lightly to conform to the overall style of this book and to save a substantial number of pages by using a typographically condensed presentation. I have inserted a small number of bracketed remarks, identified by the initials GLS. <p> The set R = f (pie; apple); (apple; cinnamon); (cinnamon; standard-object); (apple; fruit); (fruit; standard-object); (cinnamon; spice); (spice; standard-object); (fruit; food); (food; standard-object); (spice; food); (standard-object; t)g. [The original CLOS specification <ref> [5, 6] </ref> contained a minor error in this example: the pairs (cinnamon; standard-object), (fruit; standard-object), and (spice; standard-object) were inadvertently omitted from R in the preceding paragraph. <p> Tools for declarative method combination 886 COMMON LISP call-method method-combination-error define-method-combination method-qualifiers invalid-method-error . General Common Lisp support tools class-of print-object documentation symbol-macrolet [Note that describe appeared in this list in the original CLOS proposal <ref> [5, 7] </ref>, but X3J13 voted in March 1989 h63i not to make describe a generic function after all (see describe-object).|GLS] [At this point the original CLOS report contained a description of the [[ ]] and # notation; that description is omitted here. <p> If function-name/ names a non-generic function, a macro, or a special form, an error is signaled. [X3J13 voted in March 1989 h89i to use fdefinition in the previous paragraph, as shown, rather than symbol-function, as it appeared in the 898 COMMON LISP original report on CLOS <ref> [5, 7] </ref>. The vote also changed all occurrences of function-specifier in the original report to function-name; this change is reflected here.|GLS] Each method-description defines a method on the generic function. The lambda-list of each method must be congruent with the lambda-list specified by the lambda-list option. <p> Note that a parameter that specializes on t is not synonymous with an unspecialized parameter in this context. See sections 28.1.6.2, 28.1.6.4, and 28.1.6.3. [At this point the original CLOS report <ref> [5, 7] </ref> contained a specification for describe as a generic function. <p> If (fdefinition function-name) is a non-generic function, a macro, or a special form, an error is signaled. [X3J13 voted in March 1989 h89i to use fdefinition in the previous paragraph, as shown, rather than symbol-function, as it appeared in the original report on CLOS <ref> [5, 7] </ref>. <p> Implementations may optimize slot-value by compiling it in-line. See slot-missing and slot-unbound. [At this point the original CLOS report <ref> [5, 7] </ref> contained a specification for symbol-macrolet. This specification is omitted here.
Reference: [6] <author> Bobrow, Daniel G., DiMichiel, Linda G., Gabriel, Richard P., Keene, Sonya E., Kiczales, Gregor, and Moon, David A. </author> <title> Common Lisp Object System specification: 1. Programmer interface concepts. </title> <booktitle> Lisp and Symbolic Computation 1, </booktitle> <month> 3/4 (January </month> <year> 1989), </year> <pages> 245-298. </pages>
Reference-contexts: This chapter presents the bulk of the first two chapters of the Common Lisp Object System specification; it is substantially identical to these two specification chapters as previously published elsewhere <ref> [5, 6, 7] </ref>. I have edited the material only very lightly to conform to the overall style of this book and to save a substantial number of pages by using a typographically condensed presentation. I have inserted a small number of bracketed remarks, identified by the initials GLS. <p> The set R = f (pie; apple); (apple; cinnamon); (cinnamon; standard-object); (apple; fruit); (fruit; standard-object); (cinnamon; spice); (spice; standard-object); (fruit; food); (food; standard-object); (spice; food); (standard-object; t)g. <ref> [The original CLOS specification [5, 6] </ref> contained a minor error in this example: the pairs (cinnamon; standard-object), (fruit; standard-object), and (spice; standard-object) were inadvertently omitted from R in the preceding paragraph. <p> The set R = f (pie; apple); (apple; cinnamon); (cinnamon; standard-object); (apple; fruit); (fruit; standard-object); (cinnamon; spice); (spice; standard-object); (fruit; food); (food; standard-object); (spice; food); (standard-object; t)g. [The original CLOS specification <ref> [5, 6] </ref> contained a minor error in this example: the pairs (cinnamon; standard-object), (fruit; standard-object), and (spice; standard-object) were inadvertently omitted from R in the preceding paragraph.
Reference: [7] <author> Bobrow, Daniel G., DiMichiel, Linda G., Gabriel, Richard P., Keene, Sonya E., Kiczales, Gregor, and Moon, David A. </author> <title> Common Lisp Object System specification: 2. Functions in the programmer interface. </title> <booktitle> Lisp and Symbolic Computation 1, </booktitle> <month> 3/4 (January </month> <year> 1989), </year> <pages> 299-394. </pages>
Reference-contexts: This chapter presents the bulk of the first two chapters of the Common Lisp Object System specification; it is substantially identical to these two specification chapters as previously published elsewhere <ref> [5, 6, 7] </ref>. I have edited the material only very lightly to conform to the overall style of this book and to save a substantial number of pages by using a typographically condensed presentation. I have inserted a small number of bracketed remarks, identified by the initials GLS. <p> Tools for declarative method combination 886 COMMON LISP call-method method-combination-error define-method-combination method-qualifiers invalid-method-error . General Common Lisp support tools class-of print-object documentation symbol-macrolet [Note that describe appeared in this list in the original CLOS proposal <ref> [5, 7] </ref>, but X3J13 voted in March 1989 h63i not to make describe a generic function after all (see describe-object).|GLS] [At this point the original CLOS report contained a description of the [[ ]] and # notation; that description is omitted here. <p> If function-name/ names a non-generic function, a macro, or a special form, an error is signaled. [X3J13 voted in March 1989 h89i to use fdefinition in the previous paragraph, as shown, rather than symbol-function, as it appeared in the 898 COMMON LISP original report on CLOS <ref> [5, 7] </ref>. The vote also changed all occurrences of function-specifier in the original report to function-name; this change is reflected here.|GLS] Each method-description defines a method on the generic function. The lambda-list of each method must be congruent with the lambda-list specified by the lambda-list option. <p> This means that a compiler warning does not occur if the body of the method does not refer to a specialized parameter. Note that a parameter that specializes on t is not synonymous with an unspecialized parameter in this context. See sections 28.1.6.2, 28.1.6.4, and 28.1.6.3. <ref> [At this point the original CLOS report [5, 7] </ref> contained a specification for describe as a generic function. <p> Note that a parameter that specializes on t is not synonymous with an unspecialized parameter in this context. See sections 28.1.6.2, 28.1.6.4, and 28.1.6.3. [At this point the original CLOS report <ref> [5, 7] </ref> contained a specification for describe as a generic function. <p> If (fdefinition function-name) is a non-generic function, a macro, or a special form, an error is signaled. [X3J13 voted in March 1989 h89i to use fdefinition in the previous paragraph, as shown, rather than symbol-function, as it appeared in the original report on CLOS <ref> [5, 7] </ref>. <p> Implementations may optimize slot-value by compiling it in-line. See slot-missing and slot-unbound. <ref> [At this point the original CLOS report [5, 7] </ref> contained a specification for symbol-macrolet. This specification is omitted here. <p> Implementations may optimize slot-value by compiling it in-line. See slot-missing and slot-unbound. [At this point the original CLOS report <ref> [5, 7] </ref> contained a specification for symbol-macrolet. This specification is omitted here.
Reference: [8] <author> Bobrow, Daniel G., and Kiczales, Gregor. </author> <title> The Common Lisp Object System metaobject kernel: A status report. </title> <booktitle> In Proc. 1988 ACM Conference on Lisp and Functional Programming. ACM SIGPLAN/SIGACT/SIGART (Snowbird, </booktitle> <address> Utah, </address> <month> July </month> <year> 1988), </year> <pages> 309-315. 1053 1054 REFERENCES </pages>
Reference: [9] <author> Brooks, Rodney A., and Gabriel, Richard P. </author> <title> A critique of Common Lisp. </title> <booktitle> In Proc. 1984 ACM Symposium on Lisp and Functional Programming. ACM SIGPLAN/SIGACT/SIGART (Austin, </booktitle> <address> Texas, </address> <month> August </month> <year> 1984), </year> <pages> 1-8. </pages>
Reference: [10] <author> Brooks, Rodney A., Gabriel, Richard P., and Steele, Guy L., Jr. </author> <title> S-1 Common Lisp implementation. </title> <booktitle> In Proc. 1982 ACM Symposium on Lisp and Functional Programming. ACM SIGPLAN/SIGACT/SIGART (Pittsburgh, </booktitle> <address> Pennsylva-nia, </address> <month> August </month> <year> 1982), </year> <pages> 108-113. </pages>
Reference: [11] <author> Brooks, Rodney A., Gabriel, Richard P., and Steele, Guy L., Jr. </author> <title> An optimizing compiler for lexically scoped lisp. </title> <booktitle> In Proc. 1982 Symposium on Compiler Construction. ACM SIGPLAN (Boston, </booktitle> <month> June </month> <year> 1982), </year> <pages> 261-275. </pages> <note> Proceedings published as ACM SIGPLAN Notices 17, </note> <month> 6 (June </month> <year> 1982). </year>
Reference: [12] <editor> Clinger, William (ed.) </editor> <title> The Revised Revised Report on Scheme; or, An Uncommon Lisp. </title> <type> AI Memo 848. </type> <institution> MIT Artificial Intelligence Laboratory (Cam-bridge, Massachusetts, </institution> <month> August </month> <year> 1985). </year>
Reference: [13] <editor> Clinger, William (ed.) </editor> <title> The Revised Revised Report on Scheme; or, An Uncommon Lisp. </title> <institution> Computer Science Department Technical Report 174. Indiana University (Bloomington, Indiana, </institution> <month> June </month> <year> 1985). </year>
Reference: [14] <author> Cody, William J., Jr., and Waite, William. </author> <title> Software Manual for the Elementary Functions. </title> <publisher> Prentice-Hall (Englewood Cliffs, </publisher> <address> New Jersey, </address> <year> 1980). </year>
Reference-contexts: When, possibly after contagious conversion, all of the arguments are of the same floating-point or complex floating-point type, then the result will be of that same type unless otherwise noted. Implementation note: There is a "floating-point cookbook" by Cody and Waite <ref> [14] </ref> that may be a useful aid in implementing the functions defined in this section. 12.5.1.
Reference: [15] <author> Committee, </author> <title> ANSI X3J3. Draft proposed American National Standard Fortran. </title> <journal> ACM SIGPLAN Notices 11, </journal> <month> 3 (March </month> <year> 1976). </year>
Reference-contexts: Put another way, the indices for the elements of an array are ordered lexicographically. Compatibility note: Both Lisp Machine Lisp, as described in reference [55], and Fortran <ref> [15, 3] </ref> store arrays in column-major order. [Constant ]array-rank-limit The value of array-rank-limit is a positive integer that is the upper exclusive bound on the rank of an array.
Reference: [16] <author> Coonen, Jerome T. </author> <title> Errata for "An implementation guide to a proposed standard for floating-point arithmetic." </title> <booktitle> Computer 14, </booktitle> <month> 3 (March </month> <year> 1981), </year> <title> 62. These are errata for [17]. </title>
Reference-contexts: Ideally, short-format floating-point numbers should have an "immediate" representation that does not require heap allocation; single-format floating-point numbers should approximate IEEE proposed standard single-format floating-point numbers; and double-format floating-point numbers should approximate IEEE proposed standard double-format floating-point numbers <ref> [23, 17, 16] </ref>. 24 COMMON LISP 2.1.4. Complex Numbers Complex numbers (type complex) are represented in Cartesian form, with a real part and an imaginary part, each of which is a non-complex number (integer, ratio, or floating-point number).
Reference: [17] <author> Coonen, Jerome T. </author> <title> An implementation guide to a proposed standard for floating-point arithmetic. </title> <booktitle> Computer 13, </booktitle> <month> 1 (January </month> <year> 1980), </year> <pages> 68-79. </pages> <note> Errata for this paper appeared as [16]. </note>
Reference-contexts: Ideally, short-format floating-point numbers should have an "immediate" representation that does not require heap allocation; single-format floating-point numbers should approximate IEEE proposed standard single-format floating-point numbers; and double-format floating-point numbers should approximate IEEE proposed standard double-format floating-point numbers <ref> [23, 17, 16] </ref>. 24 COMMON LISP 2.1.4. Complex Numbers Complex numbers (type complex) are represented in Cartesian form, with a real part and an imaginary part, each of which is a non-complex number (integer, ratio, or floating-point number).
Reference: [18] <author> DiMichiel, Linda G. </author> <title> Overview: The Common Lisp Object System. </title> <booktitle> Lisp and Symbolic Computation 1, </booktitle> <month> 3/4 (January </month> <year> 1989), </year> <pages> 227-244. </pages>
Reference: [19] <author> Fateman, Richard J. </author> <title> Reply to an editorial. </title> <journal> ACM SIGSAM Bulletin 25 (March 1973), </journal> <pages> 9-11. </pages>
Reference: [20] <author> Goldberg, Adele, and Robson, David. </author> <title> Smalltalk-80: The Language and Its Implementation. </title> <publisher> Addison-Wesley (Reading, </publisher> <address> Massachusetts, </address> <year> 1983). </year>
Reference-contexts: Please see the Preface to this book for more information about the genesis of the generators/gatherers approach and its relationship to the work of X3J13. |Guy L. Steele Jr. B.1. Introduction Generators are generalized input streams in the sense of Smalltalk <ref> [20] </ref>. A generator can produce a potentially unbounded number of elements of any type. Individual elements are not computed until requested by next-in. When an element is taken from a generator, it is removed by side effect. Subsequent uses of next-in obtain later elements.
Reference: [21] <author> Griss, Martin L., Benson, Eric, and Hearn, Anthony C. </author> <title> Current status of a portable LISP compiler. </title> <booktitle> In Proc. 1982 Symposium on Compiler Construction. ACM SIGPLAN (Boston, </booktitle> <month> June </month> <year> 1982), </year> <pages> 276-283. </pages> <note> Proceedings published as ACM SIGPLAN Notices 17, </note> <month> 6 (June </month> <year> 1982). </year>
Reference: [22] <author> Harrenstien, Kenneth L. </author> <title> Time Server. Request for Comments (RFC) 738 (NIC 42218). ARPANET Network Working Group (October 1977). Available from the ARPANET Network Information Center. </title>
Reference-contexts: be a leap year. (Note that the "leap seconds" that are sporadically inserted by the world's official timekeepers as an additional correction are ignored; Common Lisp assumes that every day is exactly 86400 seconds long.) Universal Time format is used as a standard time representation within the ARPANET; see reference <ref> [22] </ref>. Because the Common Lisp Universal Time representation uses only non-negative integers, times before the base time of midnight, January 1, 1900 GMT cannot be processed by Common Lisp. Internal Time also represents time as a single integer, but in terms of an implementation-dependent unit.
Reference: [23] <editor> IEEE Computer Society Standard Committee, </editor> <title> Floating-Point Working Group, Microprocessor Standards Subcommittee. A proposed standard for binary floating-point arithmetic. </title> <booktitle> Computer 14, </booktitle> <month> 3 (March </month> <year> 1981), </year> <pages> 51-62. REFERENCES 1055 </pages>
Reference-contexts: Ideally, short-format floating-point numbers should have an "immediate" representation that does not require heap allocation; single-format floating-point numbers should approximate IEEE proposed standard single-format floating-point numbers; and double-format floating-point numbers should approximate IEEE proposed standard double-format floating-point numbers <ref> [23, 17, 16] </ref>. 24 COMMON LISP 2.1.4. Complex Numbers Complex numbers (type complex) are represented in Cartesian form, with a real part and an imaginary part, each of which is a non-complex number (integer, ratio, or floating-point number). <p> NUMBERS 333 Kahan [25] treats these matters in some detail and also suggests specific algorithms for implementing irrational and transcendental functions in IEEE standard floating-point arithmetic <ref> [23] </ref>. <p> . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . present if and only if full IEEE proposed floating-point arithmetic <ref> [23] </ref> is supported. The value of this variable is used by the # -+ and # reader syntax. X3J13 voted in March 1988 h163i to specify that feature names used with # -+ and # are read in the keyword package unless an explicit prefix designating some other package appears.
Reference: [24] <author> ISO. </author> <title> Information Processing|Coded Character Sets for Text Communication, Part 2: Latin Alphabetic and Non-alphabetic Graphic Characters. ISO (1983). </title>
Reference: [25] <author> Kahan, W. </author> <title> Branch cuts for complex elementary functions; or, Much ado about nothing's sign bit. </title> <editor> In Iserles, A., and Powell, M. (eds.), </editor> <title> The State of the Art in Numerical Analysis. </title> <publisher> Clarendon Press (1987), </publisher> <pages> 165-211. </pages>
Reference-contexts: Kahan <ref> [25] </ref> suggests for acos the defining formula Arc cosine 2 log 1+z q 2 i or even the much simpler (=2) arcsin z . Both equations are mathematically equivalent to the formula shown above. Implementation note: These formulae are mathematically correct, assuming completely accurate computation. <p> NUMBERS 333 Kahan <ref> [25] </ref> treats these matters in some detail and also suggests specific algorithms for implementing irrational and transcendental functions in IEEE standard floating-point arithmetic [23]. <p> For all other values of x , 0 x is an error. asin The following definition for arc sine determines the range and branch cuts: arcsin z = i log p This is equivalent to the formula arcsin z = arcsinh iz i recommended by Kahan <ref> [25] </ref>. The branch cut for the arc sine function is in two pieces: one along the negative real axis to the left of 1 (inclusive), continuous with quadrant II, and one along the positive real axis to the right of 1 (inclusive), continuous with quadrant IV. <p> X3J13 voted in January 1989 h28i to replace the formula shown above with the formula arctan z = log (1 + iz ) log (1 iz ) This is equivalent to the formula arctan z = arctanh iz i recommended by Kahan <ref> [25] </ref>. It causes the upper branch cut to be continuous with quadrant I rather than quadrant II, and the lower branch cut to be continuous with quadrant III rather than quadrant IV; otherwise it agrees with the formula of the first edition. <p> and only if its real part is non-positive; a number with imaginary part equal to =2 is in the range if and only if its real part is non-negative. acosh The following definition for the inverse hyperbolic cosine determines the range and branch cuts: arccosh z = log p Kahan <ref> [25] </ref> suggests the formula arccosh z = 2 log p p pointing out that it yields the same principal value but eliminates a gratuitous removable singularity at z = 1. A proposal was submitted to X3J13 in September 1989 to replace the formula acosh with that recommended by Kahan. <p> Thus the range of the inverse hyperbolic tangent function is identical to that of the inverse hyperbolic sine function with the points i =2 and i =2 excluded. A proposal was submitted to X3J13 in September 1989 to replace the formula atanh with that recommended by Kahan <ref> [25] </ref>: arctanh z = (log (1 + z ) log (1 z )) There is a good possibility that it will be adopted. If it is, the complete description of the branch cuts of atanh will then be as follows.
Reference: [26] <author> Keene, Sonya E. </author> <title> Object-Oriented Programming in Common Lisp: A Programmer's Guide to CLOS. </title> <publisher> Addison-Wesley (Reading, </publisher> <address> Massachusetts, </address> <year> 1989). </year>
Reference-contexts: Keene has written a good tutorial introduction to CLOS <ref> [26] </ref>. |Guy L. Steele Jr. 28.1. Programmer Interface Concepts The Common Lisp Object System (CLOS) is an object-oriented extension to Common Lisp. It is based on generic functions, multiple inheritance, declarative method combination, and a meta-object protocol.
Reference: [27] <author> Knuth, Donald E. </author> <title> Seminumerical Algorithms. </title> <booktitle> Volume 2 of The Art of Computer Programming. </booktitle> <publisher> Addison-Wesley (Reading, </publisher> <address> Massachusetts, </address> <year> 1969). </year>
Reference-contexts: See also <ref> [27] </ref>. If one takes M = 2 f , where f is the length of the significand of a floating-point number (and it is in fact common to choose M to be a power of 2), then this method is equivalent to the following assembly-language-level procedure.
Reference: [28] <author> Knuth, Donald E. </author> <title> The TEXbook. Volume A of Computers and Typesetting. </title> <publisher> Addison-Wesley (Reading, </publisher> <address> Massachusetts, </address> <year> 1986). </year>
Reference: [29] <author> Knuth, Donald E. </author> <title> TEX: The Program. Volume B of Computers and Typesetting. </title> <publisher> Addison-Wesley (Reading, </publisher> <address> Massachusetts, </address> <year> 1986). </year>
Reference: [30] <author> Lamport, Leslie. </author> <title> LATEX: A Document Preparation System. </title> <publisher> Addison-Wesley (Reading, </publisher> <address> Massachusetts, </address> <year> 1986). </year>
Reference: [31] <author> Marti, J., Hearn, A. C., Griss, M. L., and Griss, C. </author> <title> Standard Lisp report. </title> <journal> ACM SIGPLAN Notices 14, </journal> <month> 10 (October </month> <year> 1979), </year> <pages> 48-68. </pages>
Reference: [32] <editor> McDonnell, E. E. </editor> <title> The story of ffi. </title> <type> APL Quote Quad 8, </type> <month> 2 (December </month> <year> 1977), </year> <pages> 48-54. </pages>
Reference: [33] <author> Moon, David. </author> <title> MacLISP Reference Manual, </title> <type> Revision 0. </type> <institution> MIT Project MAC (Cambridge, Massachusetts, </institution> <month> April </month> <year> 1974). </year>
Reference: [34] <author> Moon, David; Stallman, Richard; and Weinreb, Daniel. </author> <title> LISP Machine Manual, Fifth Edition. </title> <institution> MIT Artificial Intelligence Laboratory (Cambridge, Mas-sachusetts, </institution> <month> January </month> <year> 1983). </year>
Reference: [35] <editor> Padget, Julian, et al. </editor> <booktitle> Desiderata for the standardisation of Lisp. In Proc. 1986 ACM Conference on Lisp and Functional Programming. </booktitle> <publisher> ACM SIGPLAN/SIGACT/SIGART (Cambridge, </publisher> <address> Massachusetts, </address> <month> August </month> <year> 1986), </year> <pages> 54-66. </pages>
Reference: [36] <author> Penfield, Paul, Jr. </author> <title> Principal values and branch cuts in complex APL. </title> <booktitle> In APL 81 Conference Proceedings. </booktitle> <address> ACM SIGAPL (San Francisco, </address> <month> September </month> <year> 1981), </year> <pages> 248-256. </pages> <note> Proceedings published as APL Quote Quad 12, </note> <month> 1 (September </month> <year> 1981). </year>
Reference-contexts: It is not a matter of incorrect branch cuts; it simply does not compute anything like a hyperbolic arc tangent. This unfortunate error in the first edition was the result of mistranscribing a (correct) APL formula from Penfield's paper <ref> [36] </ref>. The formula should have been transcribed as Hyperbolic arc tangent log p A proposal was submitted to X3J13 in September 1989 to replace the formulae for acosh and atanh. See section 12.5.3 for further discussion. <p> Common Lisp defines the branch cuts, principal values, and boundary conditions for the complex functions following a proposal for complex functions in APL <ref> [36] </ref>. The contents of this section are borrowed largely from that proposal. Compatibility note: The branch cuts defined here differ in a few very minor respects from those advanced by W. <p> It is not a matter of incorrect branch cuts; it simply does not compute anything like a hyperbolic arc tangent. This unfortunate error in the first edition was the result of mistranscribing a (correct) APL formula from Penfield's paper <ref> [36] </ref>.
Reference: [37] <author> Pitman, Kent M. </author> <note> The Revised MacLISP Manual. MIT/LCS/TR 295. </note> <institution> MIT Laboratory for Computer Science (Cambridge, Massachusetts, </institution> <month> May </month> <year> 1983). </year>
Reference: [38] <author> Pitman, Kent M. </author> <title> Exceptional Situations in Lisp. </title> <type> Working paper 268. </type> <institution> MIT Artificial Intelligence Laboratory (Cambridge, Massachusetts). </institution>
Reference: [39] <author> Queinnec, Christian, and Cointe, Pierre. </author> <title> An open-ended data representation model for EU LISP. </title> <booktitle> In Proc. 1988 ACM Conference on Lisp and Functional Programming. ACM SIGPLAN/SIGACT/SIGART (Snowbird, </booktitle> <address> Utah, </address> <month> July </month> <year> 1988), </year> <pages> 298-308. </pages>
Reference: [40] <editor> Rees, Jonathan, Clinger, William, et al. </editor> <title> Revised 3 report on the algorithmic language Scheme. </title> <journal> ACM SIGPLAN Notices 21, </journal> <month> 12 (December </month> <year> 1986), </year> <pages> 37-79. </pages>
Reference: [41] <author> Reiser, John F. </author> <title> Analysis of Additive Random Number Generators. </title> <type> Technical Report STAN-CS-77-601. </type> <institution> Stanford University Computer Science Department (Palo Alto, California, </institution> <month> March </month> <year> 1977). </year> <note> 1056 REFERENCES </note>
Reference-contexts: Again, if the low-order bits are not random enough, then the instruction ROTL # -7,T should be performed first. Implementors may wish to consult reference <ref> [41] </ref> for a discussion of some efficient methods of generating pseudo-random numbers. [Variable]*random-state* This variable holds a data structure, an object of type random-state, that encodes the internal state of the random-number generator that random uses by default. The nature of this data structure is implementation-dependent.
Reference: [42] <author> Roylance, Gerald. </author> <title> Expressing mathematical subroutines constructively. </title> <booktitle> In Proc. 1988 ACM Conference on Lisp and Functional Programming. ACM SIGPLAN/SIGACT/SIGART (Snowbird, </booktitle> <address> Utah, </address> <month> July </month> <year> 1988), </year> <pages> 8-13. </pages>
Reference: [43] <author> Steele, Guy L., Jr. </author> <title> An overview of Common Lisp. </title> <booktitle> In Proc. 1982 ACM Symposium on Lisp and Functional Programming. </booktitle> <institution> ACM SIGPLAN/SIGACT/ SIGART (Pittsburgh, Pennsylvania, </institution> <month> August </month> <year> 1982), </year> <pages> 98-107. </pages>
Reference: [44] <author> Steele, Guy L., Jr., and Hillis, W. Daniel. </author> <title> Connection Machine Lisp: Fine-grained parallel symbolic processing. </title> <booktitle> In Proc. 1986 ACM Conference on Lisp and Functional Programming. ACM SIGPLAN/SIGACT/SIGART (Cam-bridge, </booktitle> <address> Massachusetts, </address> <month> August </month> <year> 1986), </year> <pages> 279-297. </pages>
Reference-contexts: Common Lisp has nothing equivalent to the Interlisp ALONE macro-character option. Here is an example of a more elaborate set of read-macro characters that I used in the implementation of the original simulator for Connection Machine Lisp <ref> [44, 57] </ref>, a parallel dialect of Common Lisp. This simulator was used to gain experience with the language before freezing its design for full-scale implementation on a Connection Machine computer system. <p> See section 27.4 for details. The hairiest format control string I have ever seen in shown in table 22-8. It started innocently enough as part of the simulator for Connection Machine Lisp <ref> [44, 57] </ref>; the xapping data type, defined by defstruct, needed a :print-function option so that xappings would print properly. As this data type became more complicated, step by step, so did the format control string. See the description of set-macro-character for a discussion of xappings and the defstruct definition.
Reference: [45] <author> Steele, Guy Lewis, Jr. RABBIT: </author> <title> A Compiler for SCHEME (A Study in Compiler Optimization). </title> <type> Technical Report 474. </type> <institution> MIT Artificial Intelligence Laboratory (Cambridge, Massachusetts, </institution> <month> May </month> <year> 1978). </year>
Reference-contexts: First, the compiler must support an optimization Curtis calls "let eversion" in addition to the optimization methods presented in <ref> [45] </ref>. If a closure is created and used entirely within a limited lexical scope, the scopes of any bound variables nested in the closure can be enlarged (everted) to enclose all the uses of the closure. This allows the variables to be allocated on the stack rather than the heap. <p> The implementation discussed in [52] includes a portable Common Lisp implementation of generators and gatherers. Although the implementation does not support optimizations of the kind discussed in <ref> [45] </ref>, it fully optimizes uses of gathering. Appendix C Backquote Here is the code for an implementation of backquote syntax (see section 22.1.3) that I have found quite useful in explaining to myself the behavior of nested backquotes.
Reference: [46] <author> Steele, Guy Lewis, Jr., and Sussman, Gerald Jay. </author> <title> The Revised Report on SCHEME: A Dialect of LISP. </title> <type> AI Memo 452. </type> <institution> MIT Artificial Intelligence Laboratory (Cambridge, Massachusetts, </institution> <month> January </month> <year> 1978). </year>
Reference: [47] <author> Suzuki, Norihisa. </author> <title> Analysis of pointer "rotation". </title> <journal> Communications of the ACM 25, </journal> <month> 5 (May </month> <year> 1982), </year> <pages> 330-335. </pages>
Reference-contexts: The two-argument versions have been found to be very useful, but the names were easily confused. The generalization to many argument forms and the change of names were both inspired by the work of Suzuki <ref> [47] </ref>, which indicates that use of these primitives can make certain complex pointer-manipulation programs clearer and easier to prove correct. [Macro]rotatef fplaceg fl Each place form may be any form acceptable as a generalized variable to setf.
Reference: [48] <author> Swanson, Mark, Kessler, Robert, and Lindstrom, Gary. </author> <title> An implementation of Portable Standard Lisp on the BBN Butterfly. </title> <booktitle> In Proc. 1988 ACM Conference on Lisp and Functional Programming. ACM SIGPLAN/SIGACT/ SIGART (Snowbird, </booktitle> <address> Utah, </address> <month> July </month> <year> 1988), </year> <pages> 132-142. </pages>
Reference: [49] <author> Symbolics, Inc. </author> <title> Signalling and Handling Conditions. </title> <address> (Cambridge, Mas-sachusetts, </address> <year> 1983). </year>
Reference: [50] <author> Teitelman, Warren, et al. </author> <title> InterLISP Reference Manual. </title> <institution> Xerox Palo Alto Research Center (Palo Alto, California, </institution> <year> 1978). </year> <title> Third revision. </title>
Reference: [51] <author> The Utah Symbolic Computation Group. </author> <title> The Portable Standard LISP Users Manual. </title> <type> Technical Report TR-10. </type> <institution> Department of Computer Science, University of Utah (Salt Lake City, Utah, </institution> <month> January </month> <year> 1982). </year>
Reference: [52] <author> Waters, Richard C. </author> <title> Optimization of Series Expressions, Part I: User's Manual for the Series Macro Package. </title> <type> AI Memo 1082. </type> <institution> MIT Artificial Intelligence Laboratory (Cambridge, Massachusetts, </institution> <month> January </month> <year> 1989). </year>
Reference-contexts: When problems come up, they can be ignored (since they cannot lead to the computation of incorrect results) or dealt with on an individual basis. Implementation note: The series functions and the theory underlying them are described in greater detail in <ref> [52, 53] </ref>. These reports also discuss the algorithms required to transform series expressions into loops and explain how to obtain a portable implementation. A.2. Series Functions Throughout this chapter the notation S j is used to denote the j th element of the series S. <p> All of the examples above satisfy these restrictions. For instance, once the uses of gathering and iterate have been optimized, the body of examp is as efficient as any loop performing the same computation. The implementation discussed in <ref> [52] </ref> includes a portable Common Lisp implementation of generators and gatherers. Although the implementation does not support optimizations of the kind discussed in [45], it fully optimizes uses of gathering.
Reference: [53] <author> Waters, Richard C. </author> <title> Optimization of Series Expressions, Part II: Overview of the Theory and Implementation. </title> <type> AI Memo 1083. </type> <institution> MIT Artificial Intelligence Laboratory (Cambridge, Massachusetts, </institution> <month> January </month> <year> 1989). </year>
Reference-contexts: When problems come up, they can be ignored (since they cannot lead to the computation of incorrect results) or dealt with on an individual basis. Implementation note: The series functions and the theory underlying them are described in greater detail in <ref> [52, 53] </ref>. These reports also discuss the algorithms required to transform series expressions into loops and explain how to obtain a portable implementation. A.2. Series Functions Throughout this chapter the notation S j is used to denote the j th element of the series S.
Reference: [54] <author> Waters, Richard C. </author> <title> XP: A Common Lisp Pretty Printing System. </title> <type> AI Memo 1102. </type> <institution> MIT Artificial Intelligence Laboratory (Cambridge, Mas-sachusetts, </institution> <month> March </month> <year> 1989). </year>
Reference-contexts: XP is described fully in <ref> [54] </ref>, which also explains how to obtain a portable implementation. XP uses a highly efficient linear-time algorithm. When properly integrated into a Common Lisp, this algorithm supports pretty printing that is only fractionally slower than ordinary printing. 27.2.
Reference: [55] <author> Weinreb, Daniel, and Moon, David. </author> <title> LISP Machine Manual, Fourth Edition. </title> <institution> MIT Artificial Intelligence Laboratory (Cambridge, Massachusetts, </institution> <month> July </month> <year> 1981). </year>
Reference-contexts: In large Lisp systems, with modules written by many different programmers, accidental name collisions become a serious problem. Common Lisp addresses this problem through the package system, derived from an earlier package system developed for Lisp Machine Lisp <ref> [55] </ref>. In addition to preventing name-space conflicts, the package system makes the modular structure of large Lisp systems more explicit. A package is a data structure that establishes a mapping from print names (strings) to symbols. The package thus replaces the "oblist" or "obarray" machinery of earlier Lisp systems. <p> Put another way, the indices for the elements of an array are ordered lexicographically. Compatibility note: Both Lisp Machine Lisp, as described in reference <ref> [55] </ref>, and Fortran [15, 3] store arrays in column-major order. [Constant ]array-rank-limit The value of array-rank-limit is a positive integer that is the upper exclusive bound on the rank of an array.
Reference: [56] <author> Wholey, Skef, and Fahlman, Scott E. </author> <title> The design of an instruction set for Common Lisp. </title> <booktitle> In Proc. 1984 ACM Symposium on Lisp and Functional Programming. ACM SIGPLAN/SIGACT/SIGART (Austin, </booktitle> <address> Texas, </address> <month> August </month> <year> 1984), </year> <pages> 150-158. REFERENCES 1057 </pages>

References-found: 56

