URL: http://www.cs.ucsd.edu/~wgg/Abstracts/infotrans.ps.gz
Refering-URL: http://www.cs.ucsd.edu/~wgg/Abstracts/infotrans.html
Root-URL: http://www.cs.ucsd.edu
Email: wgg@cs.ucsd.edu  
Title: Coping With Software Change Using Information Transparency  
Author: William G. Griswold 
Keyword: Modularity, design, maintenance, evolution, software tools.  
Address: La Jolla, CA 92093-0114  
Affiliation: Department of Computer Science and Engineering University of California, San Diego  
Abstract: Designers are often unsuccessful in designing for change using traditional modularity techniques. A complementary modularity technique called information transparency can improve a designer's ability to simplify changes by exposing the interdependence of dispersed program elements that must be changed together for correctness. Information transparency represents modules via similarity and architecture, rather than locality and abstraction. With these, a programmer can create locality with a software tool, easing change in much the same way as traditional modularity. When combined with information hiding, then, more complex module structures can be represented. Information transparency techniques include naming conventions, formatting style, and ordering of code in a file. Transparency can be increased by better matching tool capabilities and programming style. We discuss applications of information transparency and introduce design principles for software designers and tool designers. 
Abstract-found: 1
Intro-found: 1
Reference: [BG94] <author> R. W. Bowdidge and W. G. Griswold. </author> <title> Automated support for encapsulating abstract data types. </title> <booktitle> In ACM SIGSOFT '94 Symposium on the Foundations of Software Engineering, </booktitle> <pages> pp 97110, </pages> <month> December </month> <year> 1994. </year>
Reference-contexts: The star diagram addresses this problem by providing a hierarchical, graphical visualization of the computations on a data structure (Figure 3). First designed as the user interface to a transformation-based meaning-preserving restructuring tool <ref> [BG94] </ref>, the star diagram has been adapted for use in a tool for program understanding and planning global changes like restructuring [GCBM96].
Reference: [BM98] <author> E. Baniassad and G. C. Murphy. </author> <title> Conceptual module querying for software reengineering. </title> <booktitle> In Proceedings of the 20th International Conference on Software Engineering, </booktitle> <pages> pp 6473. </pages> <publisher> IEEE, </publisher> <month> April </month> <year> 1998. </year>
Reference-contexts: Conceptual Module Querying extends this approach by supporting program queries relative to the components identified by the mapping <ref> [BM98] </ref>. Identifying abstract components in a concrete implementation with these tools can be eased by exploiting information transparency. Searching tools. Unlike most inference tools, searching tools permit a programmer to provide a pattern describing what the programmer wants to find.
Reference: [BMW93] <author> T. J. Biggerstaff, B. G. Mitbander, and D. Webster. </author> <title> The concept assignment problem in program understanding. </title> <booktitle> In Proceedings of Working Conference on Reverse Engineering, </booktitle> <pages> pp 2743, </pages> <month> May </month> <year> 1993. </year>
Reference-contexts: This work implicitly depends on information transparency. The Desire system, for example, provides a number of inferential techniques so that code related to a change can be better identified <ref> [BMW93] </ref>. Schwanke uses clustering techniques based on references to data types [Sch91]. RMTool is unique in that it permits a programmer to suggest an architecture and how it is mapped to the source.
Reference: [Bro75] <author> F. P. Brooks. </author> <title> The Mythical Man Month: </title> <booktitle> Essays on Software Engineering. </booktitle> <publisher> Addison-Wesley, </publisher> <address> Reading, MA, </address> <year> 1975. </year>
Reference-contexts: Every part must even use the same techniques in syntax and analogous notions in semantics in order to simplify the use and modification of a software system <ref> [Bro75, p. 44] </ref>. Aiding comprehension with naming conventions is one use of consistency. Code Complete, a codification of the experiences of many Microsoft projects, dedicates a chapter to The Power of Data Names [McC93].
Reference: [Cre97] <author> R. E. Crew. ASTLOG: </author> <title> A language for examining abstract syntax trees. </title> <booktitle> In Proceedings of the USENIX Conference on Domain-Specific Languages, </booktitle> <pages> pp 22942, </pages> <month> October </month> <year> 1997. </year>
Reference-contexts: Consequently, computations of byte counts and character counts must be selectively converted. Microsoft Research developed a tool called Unicorn to help perform such conversions by identifying required change points. Unicorn uses a combination of syntax tree matching technology <ref> [Cre97] </ref> and matching on Hungarian notation to distinguish the different uses and interpretations of buffer sizes, i.e., when the size of a buffer in bytes is required, and when the size in characters is required.
Reference: [GCBM96] <author> W. G. Griswold, M. I. Chen, R. W. Bowdidge, and J. D. Morgenthaler. </author> <title> Tool support for planning the restructuring of data abstractions in large systems. </title> <booktitle> In ACM SIGSOFT '96 Symposium on the Foundations of Software Engineering, </booktitle> <pages> pp 3345, </pages> <month> October </month> <year> 1996. </year>
Reference-contexts: First designed as the user interface to a transformation-based meaning-preserving restructuring tool [BG94], the star diagram has been adapted for use in a tool for program understanding and planning global changes like restructuring <ref> [GCBM96] </ref>. A diagram's root, at the far left, represents all the instances of the variables to be encapsulated, the variable rooms in 8 variable or all variables of a given type. The children of the root represent the operations and declarations in the program that directly reference the variable.
Reference: [GN95] <author> W. G. Griswold and D. Notkin. </author> <title> Architectural tradeoffs for a meaning-preserving program restructuring tool. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 21(4):275287, </volume> <month> April </month> <year> 1995. </year>
Reference-contexts: Dotted horizontal lines are layer boundaries, solid boxes are submodules, dotted boxes are submodules reexported from a lower layer, and arrows are calls or event announcements. Columns represent modules. We faced this problem in the design of a meaning-preserving restructuring tool <ref> [GN95] </ref>. This system's design consists of three major modules: language syntax, language semantics, and their integration (e.g., when and how to generate a control flow graph from the abstract tree). However, these components are too large and multi-faceted to represent so simply.
Reference: [Gra97] <author> A. J. Gray. </author> <title> Development of an unanticipated member of a program family. </title> <type> Masters Thesis, </type> <institution> University of California, San Diego, Department of Computer Science and Engineering, </institution> <month> October </month> <year> 1997. </year> <note> Technical Report CS97-560. </note>
Reference-contexts: Retargeting a Programming Tool A key experience occurred in retargeting a classically designed programming environment toolour 37,000 line star diagram planning tool CStar [GCBM96]from C to Ada <ref> [Gra97] </ref>. We anticipated restructuring the tool's code to hide design decisions relating to differences between Ada and C, facilitating reuse between the two versions. <p> Replacing a Library The GNU C++ libraries, once widely used, have been largely supplanted by the Standard Template Library (STL) [Vil94]. We failed to defensively design for this change <ref> [Gra97] </ref>, in part because we believed the GNU libraries were becoming a de facto standard. Feeling that the GNU library interfaces were well-designed, we first attempted to use a traditional modularization to localize the port to STL by wrapping STL with thin GNU library interfaces.
Reference: [JJ96] <author> D. Jackson and M. Jackson. </author> <title> Problem decomposition for reuse. </title> <journal> Software Engineering Journal, </journal> <volume> 11(1):1930, </volume> <month> January </month> <year> 1996. </year>
Reference-contexts: These extensions have been only partially successful. Jack--son observes that pure modularity is untenable because the drive for economical implementation requires one component to serve many functions, each with design constraints that may change independently <ref> [JJ96] </ref>. Parnas observed that his hierarchical modularity techniques were not applicable to the redesign of the A-7 flight program software because of a peculiar hardware architecture and stringent performance requirements [Par96].
Reference: [KLL + 97] <author> G. Kiczales, J. Lamping, C. V. Lopes, C. Maeda, A. Mendhekar, and G. Murphy. </author> <title> Open implementation guidelines. </title> <booktitle> In Proceedings of the 19th International Conference on Software Engineering, </booktitle> <pages> pp 481490, </pages> <month> May </month> <year> 1997. </year>
Reference-contexts: We experienced this problem first hand in the obsolescence of a library package (Section 2). Moreover, traditional modularity mechanisms are often inadequate for factoring a program's changeable design decisions into separate modules <ref> [KLL + 97, PCW84, VN96] </ref>. For example, most languages do not generally allow grouping changeable aspects of a system that are not describable in units of behavior such as sets of procedures (e.g., classes) [KLM + 97]. Such cross-cutting aspects include performance, error handling, and synchronization constraints. <p> Parnas described the application of hierarchical modularity techniques as a principled way to compromise modularity in complex systems [PCW84]. Guidelines for open implementation have been described to help programmers balance the needs of modularity and performance <ref> [KLL + 97] </ref>. More recently, novel applications of subclassing and templates were introduced to better separate design concerns design [VN96]. Aspect-Oriented Programming (AOP) provides special languages that can describe cross-cutting aspects, typically through a declarative or computationally reflective mechanism [KLM + 97].
Reference: [KLM + 97] <author> G. Kiczales, J. Lamping, A. Mendhekar, C. Maeda, C. Lopes, J. M. Loingtier, and J. Irwin. </author> <booktitle> Aspect-oriented programming. In 11th European Conference on Object-Oriented Programming, </booktitle> <pages> pp 220242. </pages> <publisher> Springer-Verlag, </publisher> <month> June </month> <year> 1997. </year>
Reference-contexts: For example, most languages do not generally allow grouping changeable aspects of a system that are not describable in units of behavior such as sets of procedures (e.g., classes) <ref> [KLM + 97] </ref>. Such cross-cutting aspects include performance, error handling, and synchronization constraints. In part to address these problems, the concept and application of modularity has undergone considerable revision since Parnas first described his principles for modular design. <p> More recently, novel applications of subclassing and templates were introduced to better separate design concerns design [VN96]. Aspect-Oriented Programming (AOP) provides special languages that can describe cross-cutting aspects, typically through a declarative or computationally reflective mechanism <ref> [KLM + 97] </ref>. For instance, an aspect language for an image manipulation program might allow describing space and time optimizations of image operator compositions.
Reference: [Mac87] <author> B. J. MacLennan. </author> <booktitle> Principles of Programming Languages: Design, Evaluation, and Implementation. </booktitle> <publisher> Holt, Rine-hart, and Winston, </publisher> <address> New York, 2nd edition, </address> <year> 1987. </year>
Reference-contexts: Related Ideas Similarity, in the guise of consistency, is already an important concept in software design. For example, the consistency principle advocates Things that look similar should be similar; things that are different should look different <ref> [Mac87, p. 323] </ref>. Cognitive issues are emphasized, such as reducing the effort to recognize that two system elements are definitely related. Brooks goes a step further with the conceptual integrity principle, saying that, every part must reflect the same design philosophies and the same balancing of desiderata.
Reference: [McC93] <author> S. McConnell. </author> <title> Code Complete: A Practical Guide of Software Construction. </title> <publisher> Microsoft Press, </publisher> <address> Redmond, Washing-ton, </address> <year> 1993. </year>
Reference-contexts: Aiding comprehension with naming conventions is one use of consistency. Code Complete, a codification of the experiences of many Microsoft projects, dedicates a chapter to The Power of Data Names <ref> [McC93] </ref>. One reason cited for using naming conventions is that they emphasize the relationships amongst related items....You make up for the weakness of the language by creating pseudostructured data [p. 197]. No mention is made of exploiting naming conventions with tools. Information transparency adds value in two ways.
Reference: [MN95] <author> G. C. Murphy and D. Notkin. </author> <title> Lightweight source model extraction. </title> <booktitle> In ACM SIGSOFT '95 Symposium on the Foundations of Software Engineering, </booktitle> <pages> pp 116127, </pages> <month> October </month> <year> 1995. </year>
Reference-contexts: The tool lsme (lightweight source model extractor) addresses many information transparency concerns. It uses regular expression pattern matching in a program source's token stream to extract models of the source <ref> [MN95] </ref>. By providing matching at the token level rather than the character level and allowing patterns to be conditionally enabled, lsme supports simple specification of complicated patterns, giving some of the benefits of parsing without being language-dependent per se.
Reference: [MNS95] <author> G. C. Murphy, D. Notkin, and K. Sullivan. </author> <title> Software re-flexion models: bridging the gap between source and high-level models. </title> <booktitle> In ACM SIGSOFT '95 Symposium on the Foundations of Software Engineering, </booktitle> <pages> pp 1828, </pages> <month> October </month> <year> 1995. </year>
Reference-contexts: Using these conventions and other facts conveyed by the designer RMTool, a reflexion modeling tool, analyzed the dependence structure of this 40,000 line system <ref> [MNS95] </ref> (See Section 4). Layering and module violations were identified, enabling maintenance of the system's design. Microsoft Unicode Port Microsoft's software continually evolves to meet various needs. <p> RM-Tool takes a programmer's proposed mapping of a program's low-level constructs to a higher level conceptual architecture, and provides a qualitative, graphical report of the congruence between the suggested architecture and the one mapped to the source code <ref> [MNS95] </ref>. Consequently, if an RMTool user has a sense of the program's information transparency coding conventions, convergence to a useful architecture and its mapping to source code can be accelerated, reducing the need for bottom-up inference.
Reference: [Par72] <author> D. L. Parnas. </author> <title> On the criteria to be used in decomposing systems into modules. </title> <journal> Communications of the ACM, </journal> <volume> 15(12):10531058, </volume> <month> December </month> <year> 1972. </year>
Reference-contexts: 1 INTRODUCTION Designing for changea major tenet of software design has been cast as a problem of designing software so that it can be extended, replaced in small pieces, or locally changed rather than globally changed <ref> [Par72, PHW76] </ref>. Locality of change through the application of information hiding is pursued because global changes are hard to reason about and can require the coordination of all the developers who have expertise with the software involved.
Reference: [Par96] <author> D. L. Parnas. </author> <title> Why software jewels are rare. </title> <journal> IEEE Computer, </journal> <volume> 29(2):5760, </volume> <month> February </month> <year> 1996. </year>
Reference-contexts: The Problem Software designers are frequently unsuccessful in designing for change using modularity and related techniques <ref> [Par96] </ref>. It is not difficult to anticipate that technology will advance, new industry standards will arise, and competitors will in fl This research is supported in part by NSF grant CCR-9508745 and Cal-ifornia MICRO proposal 97-061 with Raytheon Systems Company. <p> Parnas observed that his hierarchical modularity techniques were not applicable to the redesign of the A-7 flight program software because of a peculiar hardware architecture and stringent performance requirements <ref> [Par96] </ref>. Although AOP handles cross-cutting module structures, it augments the programming task to include writing programs (aspects) that reason about and modify other programs. Moreover, these techniques help little when the designer has not properly anticipated the change.
Reference: [PCW84] <author> D. L. Parnas, P. C. Clements, and D. M. Weiss. </author> <title> The modular structure of complex systems. </title> <booktitle> In Proceedings of the 7th International Conference on Software Engineering, </booktitle> <pages> pp 408417, </pages> <month> March </month> <year> 1984. </year>
Reference-contexts: We experienced this problem first hand in the obsolescence of a library package (Section 2). Moreover, traditional modularity mechanisms are often inadequate for factoring a program's changeable design decisions into separate modules <ref> [KLL + 97, PCW84, VN96] </ref>. For example, most languages do not generally allow grouping changeable aspects of a system that are not describable in units of behavior such as sets of procedures (e.g., classes) [KLM + 97]. Such cross-cutting aspects include performance, error handling, and synchronization constraints. <p> Object-oriented languages provide mechanisms for sharing design decisions between a class and its subclasses as well as incrementally adding new subclasses. Parnas described the application of hierarchical modularity techniques as a principled way to compromise modularity in complex systems <ref> [PCW84] </ref>. Guidelines for open implementation have been described to help programmers balance the needs of modularity and performance [KLL + 97]. More recently, novel applications of subclassing and templates were introduced to better separate design concerns design [VN96]. <p> Fortunately, virtually all Pix objects were used only in the scope they were initialized. This example highlights a relationship to Parnas module guides <ref> [PCW84] </ref>. To cope with the problem that not every design decision can be hidden in a small module, Parnas introduced the concept of designing with nested modules that are documented by a tree-structured module guide.
Reference: [PHW76] <author> D. L. Parnas, G. Handzel, and H. Wurges. </author> <title> Design and specification of the minimal subset of an operating system family. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 2(4):301 307, </volume> <month> December </month> <year> 1976. </year>
Reference-contexts: 1 INTRODUCTION Designing for changea major tenet of software design has been cast as a problem of designing software so that it can be extended, replaced in small pieces, or locally changed rather than globally changed <ref> [Par72, PHW76] </ref>. Locality of change through the application of information hiding is pursued because global changes are hard to reason about and can require the coordination of all the developers who have expertise with the software involved. <p> This embedding facilitates extraction by tools and need not be tree-structured. The Design of a Hybrid ModularLayered System Parnas advocates assembling systems in units of minimal extensions, building on a minimal subset <ref> [PHW76] </ref>. An extension (basically a feature addition) is usually small and does not comprise an entire layer. However an extension often extends several modules (e.g., abstract data types). From this perspective, there are two obvious kinds of changes: those to modules and those to features.
Reference: [Sch91] <author> R. W. Schwanke. </author> <title> An intelligent tool for re-engineering software modularity. </title> <booktitle> In Proceedings of the 13th International Conference on Software Engineering, </booktitle> <pages> pp 8392, </pages> <month> May </month> <year> 1991. </year>
Reference-contexts: This work implicitly depends on information transparency. The Desire system, for example, provides a number of inferential techniques so that code related to a change can be better identified [BMW93]. Schwanke uses clustering techniques based on references to data types <ref> [Sch91] </ref>. RMTool is unique in that it permits a programmer to suggest an architecture and how it is mapped to the source.
Reference: [Vil94] <author> M. J. Vilot. </author> <title> An introduction to the Standard Template Library. C++ Report, </title> <journal> 6(8):2229, </journal> <volume> 35, </volume> <month> October </month> <year> 1994. </year>
Reference-contexts: Replacing a Library The GNU C++ libraries, once widely used, have been largely supplanted by the Standard Template Library (STL) <ref> [Vil94] </ref>. We failed to defensively design for this change [Gra97], in part because we believed the GNU libraries were becoming a de facto standard.
Reference: [VN96] <author> M. VanHilst and D. Notkin. </author> <title> Decoupling change from design. </title> <booktitle> In ACM SIGSOFT '96 Symposium on the Foundations of Software Engineering, </booktitle> <pages> pp 5869, </pages> <month> October </month> <year> 1996. </year>
Reference-contexts: We experienced this problem first hand in the obsolescence of a library package (Section 2). Moreover, traditional modularity mechanisms are often inadequate for factoring a program's changeable design decisions into separate modules <ref> [KLL + 97, PCW84, VN96] </ref>. For example, most languages do not generally allow grouping changeable aspects of a system that are not describable in units of behavior such as sets of procedures (e.g., classes) [KLM + 97]. Such cross-cutting aspects include performance, error handling, and synchronization constraints. <p> Guidelines for open implementation have been described to help programmers balance the needs of modularity and performance [KLL + 97]. More recently, novel applications of subclassing and templates were introduced to better separate design concerns design <ref> [VN96] </ref>. Aspect-Oriented Programming (AOP) provides special languages that can describe cross-cutting aspects, typically through a declarative or computationally reflective mechanism [KLM + 97]. For instance, an aspect language for an image manipulation program might allow describing space and time optimizations of image operator compositions.
Reference: [WM91] <author> S. Wu and U. Manber. </author> <title> agrepa fast approximate pattern-matching tool. </title> <booktitle> In Proceedings of the Winter 1992 USENIX Conference, </booktitle> <pages> pp 153162, </pages> <year> 1991. </year> <month> 10 </month>
Reference-contexts: Finally, grep has a fixed definition of a successful match. In many cases it would be helpful if grep let programmers know that there were some near matches that could be of interest. In fact, agrep <ref> [WM91] </ref> partially addresses the first and last concerns by allowing for spelling errors. However, programmers really abbreviate, which is only obliquely captured by the error concept. A special case supported by agrep is the recognition of acronyms.
References-found: 23

