URL: ftp://www.cs.rutgers.edu/pub/technical-reports/lcsr-tr-275.ps.Z
Refering-URL: http://www.cs.rutgers.edu/pub/technical-reports/
Root-URL: http://www.aic.nrl.navy.mil/~aha/people.html
Title: DARWIN-E: AN ENVIRONMENT FOR IMPOSING REGULARITY ON OBJECT-ORIENTED SOFTWARE  Written under the direction of  
Author: BY PARTHA PRATIM PAL Naftaly H. Minsky 
Degree: A dissertation submitted to the Graduate School|New Brunswick  in partial fulfillment of the requirements for the degree of Doctor of Philosophy  and approved by  
Date: October, 1996  
Note: Graduate Program in Computer Science  
Address: New Jersey  Brunswick, New Jersey  
Affiliation: Rutgers, The State University of  New  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> Chowdhury Anir and Scott Meyers. </author> <title> Facilitating software maintenance by automated detection of constraint violation. </title> <booktitle> In IEEE conference on Software Maintenance, </booktitle> <month> September </month> <year> 1993. </year>
Reference-contexts: however, the semantics of their specification language TYPOL does not seem to interpret global properties such as the notion of clusters, nor express constraints based on these properties. 13.3 CCEL An independent effort to constrain the structure of object-oriented programs can be found in the C++ Constraint Expression Language (CCEL) <ref> [1, 38, 13] </ref> and its host system. In essence, the CCEL system is a tool that can formulate a certain class of regularities and check for violations of these regularities in C++ [68] programs.
Reference: [2] <author> Naser S. Barghouti. </author> <title> Supporting cooperation in the MARVEL process-centered sde. </title> <booktitle> Software Engineering Notes, Special Issue on Fifth ACM SIGSOFT Symposium on Software Development Environments, </booktitle> <volume> 17(5) </volume> <pages> 21-31, </pages> <month> December </month> <year> 1992. </year>
Reference-contexts: In this dissertation, we will describe the Darwin-E environment and use it as a test-bed for various useful regularities. Although Darwin-E provides some control over the activities of human participants in the software project, it is different from the traditional process centered environments like Marvel <ref> [2, 3, 24] </ref>, Merlin [23] or Adele/TEMPO [4]. <p> The Demeter methodology depends crucially on several design principles such as the Demeter's Laws. We have already shown that such laws can be formulated as our regularity. 13.8 Marvel Marvel <ref> [2, 3, 5, 24] </ref> is a multi-user process-centered environment. Its main objective is to define a process (software project) by means of its rule-based process modeling language (PML) and support process enactment and process evolution (changes made to itself during its execution).
Reference: [3] <author> Naser S. Barghouti and Gail E. Kaiser. </author> <title> Scaling up rule-based development environments. </title> <journal> International Journal on Software Engineering & Knowledge Engineering, </journal> <volume> 2(1) </volume> <pages> 59-78, </pages> <month> March </month> <year> 1992. </year>
Reference-contexts: In this dissertation, we will describe the Darwin-E environment and use it as a test-bed for various useful regularities. Although Darwin-E provides some control over the activities of human participants in the software project, it is different from the traditional process centered environments like Marvel <ref> [2, 3, 24] </ref>, Merlin [23] or Adele/TEMPO [4]. <p> We will describe a few such systems, where similar attempts has been made, but as we shall see, very few systems are capable to capture the essence of our regularities. There are a bunch of (process-centered) environments such as Marvel <ref> [3] </ref>, Adele/Tempo [4], Merlin [23] etc. in which enforcing some kinds of constraints, either prescription or proscription, on the software process is an important objective. The modality and scope of the constraints vary in different environments. <p> The Demeter methodology depends crucially on several design principles such as the Demeter's Laws. We have already shown that such laws can be formulated as our regularity. 13.8 Marvel Marvel <ref> [2, 3, 5, 24] </ref> is a multi-user process-centered environment. Its main objective is to define a process (software project) by means of its rule-based process modeling language (PML) and support process enactment and process evolution (changes made to itself during its execution).
Reference: [4] <author> N. Belkhtair, J. Estublier, and W. Melo. Adele-tempo: </author> <title> An environment for process modeling and enaction. </title> <editor> In A. Finkelstein, J. Kramer, and B. Nuseibeh, editors, </editor> <booktitle> Software Process Modeling and Technology. </booktitle> <publisher> John Wiley and Sons, </publisher> <year> 1994. </year>
Reference-contexts: Although Darwin-E provides some control over the activities of human participants in the software project, it is different from the traditional process centered environments like Marvel [2, 3, 24], Merlin [23] or Adele/TEMPO <ref> [4] </ref>. The main goal of these process centered environments is to enact and automate a software process defined in some formal language, which is not pursued by Darwin-E; in contrast regularity of the product is our primary focus, which is often not considered in the process centered environments. <p> A software development environment is expected to address both the issues. Various version and configuration management schemes are already in use <ref> [4, 60, 71] </ref>. In this chapter we describe the configuration and version management facilities of Darwin-E. Let us mention at the very beginning, that we do not have a full fledged version control and configuration management system in the prototype. <p> Thus it can represent a two dimensional line of development. Selection of the appropriate realization of an interface of a module is by allocating a default, which can be changed dynamically. Adele <ref> [4] </ref> further extends the notion of a module by allowing a set of views to define an interface, which can be realized by different variants, and each variant has different revisions. Selection criteria of Adele configuration manager uses properties much like we utilize properties in Darwin-E. <p> We will describe a few such systems, where similar attempts has been made, but as we shall see, very few systems are capable to capture the essence of our regularities. There are a bunch of (process-centered) environments such as Marvel [3], Adele/Tempo <ref> [4] </ref>, Merlin [23] etc. in which enforcing some kinds of constraints, either prescription or proscription, on the software process is an important objective. The modality and scope of the constraints vary in different environments. <p> This is so because Darwin-E is not meant to be a process centered environment and process modeling and management is not our goal. Imposing regularity on the product is an important objective of Darwin-E, which is not so in Marvel. 13.9 Adele/Tempo The Adele/Tempo <ref> [4] </ref> environment uses a kernel based on an entity-relationship database, complemented by object-oriented concepts and an activity manager based on triggers. In this environment, objects play different roles in different work environments, a connection with the work environment establishes the dynamic and context sensitive behavior of the objects.
Reference: [5] <author> Israel Z. Ben-Shaul, Gail E. Kaiser, and George T. Heineman. </author> <title> An architecture for multi-user software development environments. </title> <journal> Computing Systems, The Journal of the USENIX Association, </journal> <volume> 6(2) </volume> <pages> 65-103, </pages> <month> Spring </month> <year> 1993. </year> <month> (CUCS-012-92, April </month> <year> 1992). </year>
Reference-contexts: Therefore, monitoring can seamlessly blend into the structured control over builder activities based on command categories. 9.1.4 Related Work Almost all software development environments incorporate some means to trace user activity. In the Marvel <ref> [5] </ref> software development environment, forward chaining of rules that model the software process can trigger tracing and notification. There are dedicated event-driven announcement tools such as YEAST [27], which monitors the occurrence of events in order to trigger various notification activities. <p> The Demeter methodology depends crucially on several design principles such as the Demeter's Laws. We have already shown that such laws can be formulated as our regularity. 13.8 Marvel Marvel <ref> [2, 3, 5, 24] </ref> is a multi-user process-centered environment. Its main objective is to define a process (software project) by means of its rule-based process modeling language (PML) and support process enactment and process evolution (changes made to itself during its execution).
Reference: [6] <author> G. Birtwistle, O. Dahl, B. Myhrtag, and K. Mygaard. </author> <title> Simula Begin. </title> <publisher> Auerbach Press, </publisher> <year> 1973. </year>
Reference-contexts: Prohibition of assignments to private attributes of class C by any other class. R112. cannot call ( ,C1,F,C) :- private (F)@C, C1=/C. Prohibition of calls to private attributes of class C from any other class. This useful notion is supported by both Simula 67 <ref> [6] </ref> and C++ [35], but unfortunately not by Eiffel, in which features of a class are automatically visible in all the descendant of this class. This limitation of Eiffel can be easily rectified under Darwin-E.
Reference: [7] <author> Frederick P. Jr Brooks. </author> <title> No silver bullet the essence and accidents of software engineering. </title> <booktitle> IEEE computer, </booktitle> <pages> pages 10-19, </pages> <month> April </month> <year> 1987. </year>
Reference-contexts: However, there are several problems that are unique to software systems, and do not arise in other engineering disciplines. Brooks identified complexity and invisibility as the principal ones amongst them <ref> [7] </ref>. He noted that complexity is an inherent and irreducible property of large software. He also noted that as opposed to any other kind of product, the details and intricacies of a large software product by nature are invisible. <p> Of-course, we do not intend to claim that regularity is the silver bullet. Regularity alone cannot make all large systems simple, nor can all kinds of useful software engineering constraints be formulated and enforced as regularities. Brooks <ref> [7] </ref> and other researchers [19] have already established that there is no such cure-all solution.
Reference: [8] <author> J. Chomicki and N.H. Minsky. </author> <title> Towards a programming environment for large prolog programs. </title> <booktitle> In Proceedings of the 2nd International Symposium on Logic Programming, </booktitle> <pages> pages 230-241, </pages> <address> Boston, Massachusetts, </address> <month> July </month> <year> 1985. </year>
Reference-contexts: The initial ideas of law and Law-Governed Systems were formed during the work in relation to large Prolog programs <ref> [8] </ref>. This lead to the development of the initial version of the Darwin system [46, 47]. The concept of Law-Governed Systems were consolidated in [41, 50]. The law-governed approach was applied to formulate different object-oriented structures [51, 52, 61, 62].
Reference: [9] <author> W.F. Clocksin and C.S. Mellish. </author> <title> Programming in Prolog. </title> <publisher> Springer-Verlag, </publisher> <year> 1981. </year>
Reference-contexts: It stores various properties (also called attributes) associated with the object. In general, the properties are Prolog <ref> [9] </ref> terms of the form functor (arg1, arg2,..), where arguments arg1, arg2,.. can be literals, Prolog terms or variables. <p> Such interactions are best thought of as messages between the two objects that are all sent, in no particular order, at the moment when they are assembled into an executable system. Syntactically, messages in Darwin have the form of a Prolog-like <ref> [9] </ref> term. Variables, denoted by capitalized symbols can be used in a message as a place-holder for returning results to the sender. 2.1.3 LGA Primitive Operations LGA specifies a fixed set of primitive operations for manipulating the objects in the object-base, that must be provided by the underlying environment.
Reference: [10] <author> P. Coad. </author> <title> Object-Oriented Patterns. </title> <journal> Communications of The ACM, </journal> <year> 1992. </year>
Reference-contexts: There are also cases where the constraint cannot be expressed as a regularity that we can enforce. We will discuss these in terms of several examples. 132 11.3.1 The Changeable Role Pattern Our first example is the changeable role pattern of Coad <ref> [10] </ref>. The basic idea of this pattern is that a player plays different roles and assumes a role as if by wearing a hat. For example, consider a polymorphic iterator which can act as a name-iterator or an address-iterator depending on the set it handles.
Reference: [11] <author> F. DeRemer and H. H. Kron. </author> <title> Programming-in-the-large vs Programming in the small. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> SE-2(2):80-86, </volume> <month> June </month> <year> 1976. </year>
Reference-contexts: Under Darwin-E, various design models can be constructed by identifying the underlying principles and architectural patterns and formulating them as regularities. 13.6 Module Interconnection Since the introduction of the concept of module interconnection <ref> [11] </ref>, there has been several successful attempt at specifying constraints over the interconnection between the various modules of a system. Three prominent ones are the PIC formalism of Wolf et al. [72], the Inscape system of Perry [58] and the work on connectors by Garlan and Shaw [18, 66].
Reference: [12] <author> T. Despeyroux. </author> <title> Executable specifaction of static semantics. In Semantics of Data Types, </title> <booktitle> Lecture Notes in Computer Science, </booktitle> <volume> volume 173. </volume> <publisher> Springer-Verlag, </publisher> <month> June </month> <year> 1984. </year>
Reference-contexts: For instance, the constraint that modules owned by trainee programmers cannot access hardware directly, is hard to formulate by means of a pragma or by using ANA annotations. 154 13.2 CENTAUR In an earlier system named CENTAUR <ref> [12] </ref>, the syntactic and semantic specification of a programming language was used to derive a language specific environment.
Reference: [13] <author> Carolyn K. Duby, Scott Meyers, and Steven P. Reiss. CCEL: </author> <title> A Metalanguage for C++. </title> <booktitle> In USENIX C++ Conference, </booktitle> <month> August </month> <year> 1992. </year>
Reference-contexts: however, the semantics of their specification language TYPOL does not seem to interpret global properties such as the notion of clusters, nor express constraints based on these properties. 13.3 CCEL An independent effort to constrain the structure of object-oriented programs can be found in the C++ Constraint Expression Language (CCEL) <ref> [1, 38, 13] </ref> and its host system. In essence, the CCEL system is a tool that can formulate a certain class of regularities and check for violations of these regularities in C++ [68] programs.
Reference: [14] <author> Gamma E., Helm R., Johnson R., and J. Vlissides. </author> <title> Design patterns: Abstraction and reuse of object-oriented design. </title> <booktitle> In Proceedings of ECOOP-93, </booktitle> <year> 1993. </year> <month> 174 </month>
Reference-contexts: The second constraint, spanning over multiple classes however is better enforced than programmed in either case. 11.3.2 The Abstract Factory Design Pattern The abstract factory pattern of Gamma et.al. <ref> [14, 16] </ref> is our next example. <p> This rule prevents export of any creation method by any specificProduct to classes that are not concrete factories. 11.3.3 The Wrapper Pattern Our final example is the wrapper pattern of Gamma et. al. <ref> [14] </ref>. The participants in these pattern are called the component and the wrapper. The wrapper object encapsulates and enhances the component object by defining an interface that conforms to that of the component and maintaining a reference to the component.
Reference: [15] <author> S. I. Feldman. </author> <title> Make a program for maintaining computer programs. </title> <journal> Software Practice and Experience, </journal> <volume> 9, </volume> <month> April </month> <year> 1979. </year>
Reference-contexts: RCS or SCCS does not support configuration binding and compilation management, so they are normally used in conjunction with systems like Make <ref> [15] </ref>. Make [15] (and its subsequent extensions) is one of the earliest and most successful systems for compilation management. It does not provide any selection mechanism at all. A similar compilation management system (ISE Eiffel 3 compilation manager) is used by Darwin-E, when a bound configuration is being compiled. <p> RCS or SCCS does not support configuration binding and compilation management, so they are normally used in conjunction with systems like Make <ref> [15] </ref>. Make [15] (and its subsequent extensions) is one of the earliest and most successful systems for compilation management. It does not provide any selection mechanism at all. A similar compilation management system (ISE Eiffel 3 compilation manager) is used by Darwin-E, when a bound configuration is being compiled.
Reference: [16] <author> E. Gamma, R. Helm, R. Johnson, and J. Vlissides. </author> <title> Design Patterns: Michroarchi-tectures for Reusable Object-Oriented Software. </title> <publisher> Addison-Wesley, </publisher> <year> 1994. </year>
Reference-contexts: We examined well-known architectures for large systems such as layered or kernlized design and show how to formulate and enforce the principles underlying them. We established that the recently popularized design patterns <ref> [16, 59] </ref> which lack the enforcement support, have inherent implicit constraints that can be formulated as our regularities and hence, can be enforced. <p> We would like to pose Darwin-E and our approach to impose regularity on software product as a demonstration of the potential of product-centered methodologies and environments in software engineering research and practice. The merit of such approach is corroborated by the recent surge of product-centric research as documented in <ref> [16, 17, 34, 54, 65] </ref>. 8 Chapter 2 Background: A Brief Discourse On Law-Governed Architecture Law-Governed Architecture (LGA) serves as the basis on which support for regularities are implemented. <p> It should be obvious by now, that under Darwin-E it is not a problem: a tight control over such properties can be established by the law of the project. 11.3 Supplementing Design Patterns Design patterns <ref> [16, 59] </ref> are idiomatic object-oriented structures that promote good design. A design pattern is essentially an architectural template that can be realized in different contexts. It consists of a small set of classes that are designated to play well-defined roles. <p> The second constraint, spanning over multiple classes however is better enforced than programmed in either case. 11.3.2 The Abstract Factory Design Pattern The abstract factory pattern of Gamma et.al. <ref> [14, 16] </ref> is our next example. <p> For example, class WINDOW or class SCROLL BAR describes the ab stract interface of the corresponding graphical entities. 2 We will be using the terminology used by Gamma et. al. in <ref> [16] </ref> 134 * specificProduct: A specificProduct class defines a concrete product, which must conform to the corresponding genericProduct. For example, MOTIF WINDOW is a specificProduct class, defining concrete product objects namely motif windows.
Reference: [17] <author> D. Garlan, R. Allen, and J. Ockerbloom. </author> <title> Architectural mismatch: Why reuse is so hard. </title> <booktitle> IEE Software, </booktitle> <month> November </month> <year> 1995. </year>
Reference-contexts: We would like to pose Darwin-E and our approach to impose regularity on software product as a demonstration of the potential of product-centered methodologies and environments in software engineering research and practice. The merit of such approach is corroborated by the recent surge of product-centric research as documented in <ref> [16, 17, 34, 54, 65] </ref>. 8 Chapter 2 Background: A Brief Discourse On Law-Governed Architecture Law-Governed Architecture (LGA) serves as the basis on which support for regularities are implemented. <p> Rules embody the regularities that we can enforce and guidelines are the tasks the users are supposed to perform. We believe this is one way to tackle the problem of architectural mismatch as documented by Garlan et al. in <ref> [17] </ref>, in the context of reusable component oriented software construction. Use of law-governed obligation has been demonstrated elsewhere [39]. But we have not investigated obligation in terms of Darwin-E and regularities in object-oriented software at all. This area remains open for further research.
Reference: [18] <author> D. Garlan and M. Shaw. </author> <title> An introduction to software architecture. </title> <booktitle> In Advances in Software Engineering and Knowledge Engineering. World Scientific, </booktitle> <year> 1993. </year>
Reference-contexts: Three prominent ones are the PIC formalism of Wolf et al. [72], the Inscape system of Perry [58] and the work on connectors by Garlan and Shaw <ref> [18, 66] </ref>. Although they represent very powerful techniques for specifying interfaces between modules, and in many ways they can do what we cannot do in Darwin-E, they usually are not concerned with regularity, i.e., statements involving universal quantifications.
Reference: [19] <author> C. Ghezzi, M. Jazayeri, and D. Mandrioli. </author> <title> Fundamentals of Software Engineering. </title> <publisher> Prentice Hall, </publisher> <year> 1991. </year>
Reference-contexts: Of-course, we do not intend to claim that regularity is the silver bullet. Regularity alone cannot make all large systems simple, nor can all kinds of useful software engineering constraints be formulated and enforced as regularities. Brooks [7] and other researchers <ref> [19] </ref> have already established that there is no such cure-all solution. What we provide is an engineering solution: the designers of a large system are to come up with a set of regularities in a conscious effort to fight some of the problems of large software systems.
Reference: [20] <author> A. N. Haberman and D. Notkin. </author> <title> Gandalf: Software development environments. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> SE-12(12), </volume> <month> December </month> <year> 1986. </year>
Reference-contexts: Modules are identified by unique names and versions are identified by the date of creation. The selection of versions can only be guided by their date of creation. It works for cedar language only and is capable to represent one line of development. Gandalf <ref> [20] </ref> extends the Cedar notion of a module by allowing each version to consist of a set of revisions. Thus it can represent a two dimensional line of development. Selection of the appropriate realization of an interface of a module is by allocating a default, which can be changed dynamically.
Reference: [21] <author> Y. Huang and C. Kintala. </author> <title> Software implemented fault-tolerance: Technologies and experience. </title> <booktitle> In Proceedings of the 23rd International Symposium on Fault-Tolerant Computing, </booktitle> <pages> pages 2-9. </pages> <publisher> IEEE CS Press, </publisher> <year> 1993. </year>
Reference-contexts: This is similar to our approach in some sense, but the pre-processor transforms ANA annotations, that are voluntarily included in ADA programs. Use of a special purpose entity like our spy, can be found in <ref> [21] </ref>, where the main objective of monitoring a system is to detect failures and roll-back to a previously check-pointed state in the event of one. Their watchd expects I am alive messages from the monitored processes.
Reference: [22] <author> W.L. H 'ursch, L.M Seiter, and C. Xiao. </author> <title> In any case: Demeter. </title> <journal> The American Programmer, </journal> <month> September </month> <year> 1991. </year>
Reference-contexts: LoD is used by the Demeter system <ref> [22] </ref> in generating and transforming C++ code. It is not incorporated in any programming language. Conventional environments do not impose the law either. Use of this principle outside the Demeter system is therefore limited to posing it as a guideline on class design and implementation.
Reference: [23] <author> G. Junkermann, B. Peuschel, W. Schfaer, and S. Wolf. Merlin: </author> <title> Software development through a knowledge-based environment. </title> <booktitle> In Software Process Modeling and technology, </booktitle> <pages> pages 103-130. </pages> <publisher> Research Studies Press. John Wiley and Sons, </publisher> <address> England, </address> <year> 1994. </year>
Reference-contexts: In this dissertation, we will describe the Darwin-E environment and use it as a test-bed for various useful regularities. Although Darwin-E provides some control over the activities of human participants in the software project, it is different from the traditional process centered environments like Marvel [2, 3, 24], Merlin <ref> [23] </ref> or Adele/TEMPO [4]. <p> We will describe a few such systems, where similar attempts has been made, but as we shall see, very few systems are capable to capture the essence of our regularities. There are a bunch of (process-centered) environments such as Marvel [3], Adele/Tempo [4], Merlin <ref> [23] </ref> etc. in which enforcing some kinds of constraints, either prescription or proscription, on the software process is an important objective. The modality and scope of the constraints vary in different environments.
Reference: [24] <author> Gail E. Kaiser, Naser S. Barghouti, and Michael H. Sokolsky. </author> <title> Experience with process modeling in the MARVEL software development environment kernel. </title> <booktitle> In Proceedings of the 23rd Annual Hawaii International Conference on System Sciences , number 2, </booktitle> <pages> pages 131-140, </pages> <month> January </month> <year> 1990. </year>
Reference-contexts: In this dissertation, we will describe the Darwin-E environment and use it as a test-bed for various useful regularities. Although Darwin-E provides some control over the activities of human participants in the software project, it is different from the traditional process centered environments like Marvel <ref> [2, 3, 24] </ref>, Merlin [23] or Adele/TEMPO [4]. <p> The Demeter methodology depends crucially on several design principles such as the Demeter's Laws. We have already shown that such laws can be formulated as our regularity. 13.8 Marvel Marvel <ref> [2, 3, 5, 24] </ref> is a multi-user process-centered environment. Its main objective is to define a process (software project) by means of its rule-based process modeling language (PML) and support process enactment and process evolution (changes made to itself during its execution).
Reference: [25] <author> G. Kiczales, J.D. Rivieres, and D. G. Bobrow. </author> <title> The Art of Metaobject Protocol. </title> <publisher> MIT Press, </publisher> <year> 1991. </year>
Reference-contexts: For example, is there any commonality among these situations that can be generalized to a simple framework? Can this technique be used to impose meta-object protocols in a manner similar to other compiler-based approaches such as <ref> [25] </ref>? The desired regularities in a project are currently formulated in the project and the rules that express them are created in the project. But this view is not compatible with the recent trend of reuse, and component based software construction technologies.
Reference: [26] <author> B. Krishnamurthy and Naser S. Barghouti. Provence: </author> <title> A Process Visualization and Enactment Environment. </title> <booktitle> In Fourth European Software Engineering Conference (ESEC 93), Lecture Notes in Computer Science, </booktitle> <volume> No. 717, number 717. </volume> <publisher> Springer-Verlag, </publisher> <month> September </month> <year> 1993. </year>
Reference-contexts: There are dedicated event-driven announcement tools such as YEAST [27], which monitors the occurrence of events in order to trigger various notification activities. An example of using tools like YEAST in a process-oriented environment can be found in Provence <ref> [26] </ref>.
Reference: [27] <author> B. Krishnamurthy and D. S. Rosenblum. Yeast: </author> <title> A general purpose event-action system. </title> <year> 1993. </year>
Reference-contexts: In the Marvel [5] software development environment, forward chaining of rules that model the software process can trigger tracing and notification. There are dedicated event-driven announcement tools such as YEAST <ref> [27] </ref>, which monitors the occurrence of events in order to trigger various notification activities. An example of using tools like YEAST in a process-oriented environment can be found in Provence [26].
Reference: [28] <institution> CleareCase Concepts. Atria Software Inc., Natic, Massachussets, </institution> <year> 1993. </year>
Reference-contexts: Selection criteria of Adele configuration manager uses properties much like we utilize properties in Darwin-E. Systems like ClearCase <ref> [28] </ref> attempt to address an additional set of issues involving version control and configuration management, namely distributed and concurrent build, which we do not address at all.
Reference: [29] <author> D. Leblang and R Chase. </author> <title> Computer aided software engineering in a distributed workstation environment. </title> <booktitle> In Proceedings of the ACM SIGSOFT/SIGPLAN Software Engineering symposium on practical software development environments, </booktitle> <month> April </month> <year> 1984. </year> <month> 175 </month>
Reference-contexts: Make [15] (and its subsequent extensions) is one of the earliest and most successful systems for compilation management. It does not provide any selection mechanism at all. A similar compilation management system (ISE Eiffel 3 compilation manager) is used by Darwin-E, when a bound configuration is being compiled. DSEE <ref> [29, 30] </ref> is another file based tool, like RCS,SCS or Make, but it has a richer functionality than any of these. DSEE can represent descent lines and variant branches like RCS/SCCS, and in addition it provides a limited selection mechanism.
Reference: [30] <author> D. Leblang and R Chase. </author> <title> Configuration management for large scale software development efforts. </title> <booktitle> In Workshop on Software Engineering Environments for Programming in the Large, </booktitle> <address> Harwichport, Massachussets, </address> <month> June </month> <year> 1985. </year>
Reference-contexts: Make [15] (and its subsequent extensions) is one of the earliest and most successful systems for compilation management. It does not provide any selection mechanism at all. A similar compilation management system (ISE Eiffel 3 compilation manager) is used by Darwin-E, when a bound configuration is being compiled. DSEE <ref> [29, 30] </ref> is another file based tool, like RCS,SCS or Make, but it has a richer functionality than any of these. DSEE can represent descent lines and variant branches like RCS/SCCS, and in addition it provides a limited selection mechanism.
Reference: [31] <author> K. Lieberherr and I. Holland. </author> <title> Formulations and benifits of the Law of Demeter. </title> <journal> SIGPLAN NOTICES, </journal> <volume> 24(3) </volume> <pages> 67-78, </pages> <month> March </month> <year> 1989. </year>
Reference-contexts: We also show that well-known thumb-rules that are often used in object-oriented design and implementation such as The Law of Demeter <ref> [31] </ref> can also be enforced in a project-specific manner as a regularity. Darwin-E supports LGA , which is the basis of our regularities. Among the other benefits derived from the law-governed framework in Darwin-E, are its configuration management and monitoring facilities. <p> In this particular case, we will use permission based control to make the representation simpler, which means the rules presented in this section cannot be readily plugged into other law-fragments. 141 11.4.1 The Law Of Demeter The law of Demeter <ref> [31] </ref> is a design principle that rejects certain operations from inside the methods of a class. <p> following code fragment which is a translation of the C++ code fragment in page 15 of [32] into Eiffel: class BOOK feature ... end; -- class Book class MICROFICHEFILES feature search (book: BOOK):BOOLEAN is ... end; end; -- class MicroFicheFiles 3 Different formulations, with minor differences can be found in <ref> [33, 31, 32] </ref>. <p> Therefore, adapting to such changes becomes easier. Similarly, if the composition of c1 changes (however the public interface stays invariant), LoD ensures that only c1 and its children are affected. In <ref> [31, 32, 33] </ref> these and other benefits of LoD are discussed in great detail. LoD helps in systematizing reuse as well: when class c is being reused in a different context only this small subset of "closely related" classes are needed to be brought in. <p> Although this bears certain similarity to our approach to impose layered design, it is not general enough to impose structures other than layers. 13.7 Demeter and Adaptive Programming The basic idea behind Demeter methodology <ref> [31, 32] </ref>(also called adaptive programming) is as follows. Small and loosely coupled methods (in classes) are considered good software engineering practice because they are simple, they enhance reusability and are easier to maintain.
Reference: [32] <author> K. Lieberherr and I. Holland. </author> <title> Preventive maintenance of object-oriented software. </title> ?, <year> 1992. </year>
Reference-contexts: As an illustration, consider the following code fragment which is a translation of the C++ code fragment in page 15 of <ref> [32] </ref> into Eiffel: class BOOK feature ... end; -- class Book class MICROFICHEFILES feature search (book: BOOK):BOOLEAN is ... end; end; -- class MicroFicheFiles 3 Different formulations, with minor differences can be found in [33, 31, 32]. <p> following code fragment which is a translation of the C++ code fragment in page 15 of [32] into Eiffel: class BOOK feature ... end; -- class Book class MICROFICHEFILES feature search (book: BOOK):BOOLEAN is ... end; end; -- class MicroFicheFiles 3 Different formulations, with minor differences can be found in <ref> [33, 31, 32] </ref>. <p> Therefore, adapting to such changes becomes easier. Similarly, if the composition of c1 changes (however the public interface stays invariant), LoD ensures that only c1 and its children are affected. In <ref> [31, 32, 33] </ref> these and other benefits of LoD are discussed in great detail. LoD helps in systematizing reuse as well: when class c is being reused in a different context only this small subset of "closely related" classes are needed to be brought in. <p> Then for each class in this subset one can recursively compute which other classes need to be brought in as well. However, the notion of "closely related" classes postulated as the preferred suppliers in LoD is not arbitrary; it has been shown in <ref> [32] </ref> that the calls permitted by LoD are necessary in the sense that if we disallow any of these calls in an attempt to reduce the dependency on other classes any further, we will not be able to write useful programs. <p> This rule exempts the calls made by a class to another class in the same cluster from LoD. 147 The Case of Acquaintance Classes The notion of acquaintance classes of a method was proposed in <ref> [32] </ref>. A class c1 may have an unusually close relationship with a class c2, although in a routine r of c1, calls to c2 do not satisfy LoD. In this case it makes sense to allow such calls. <p> Although this bears certain similarity to our approach to impose layered design, it is not general enough to impose structures other than layers. 13.7 Demeter and Adaptive Programming The basic idea behind Demeter methodology <ref> [31, 32] </ref>(also called adaptive programming) is as follows. Small and loosely coupled methods (in classes) are considered good software engineering practice because they are simple, they enhance reusability and are easier to maintain.
Reference: [33] <author> K. Lieberherr, I. Holland, and A. Riel. </author> <title> Object oriented programming an objective sense of style. </title> <journal> SIGPLAN NOTICES :special issue on OOPSLA 88, </journal> <volume> 23(11) </volume> <pages> 323-334, </pages> <month> November </month> <year> 1988. </year>
Reference-contexts: following code fragment which is a translation of the C++ code fragment in page 15 of [32] into Eiffel: class BOOK feature ... end; -- class Book class MICROFICHEFILES feature search (book: BOOK):BOOLEAN is ... end; end; -- class MicroFicheFiles 3 Different formulations, with minor differences can be found in <ref> [33, 31, 32] </ref>. <p> Therefore, adapting to such changes becomes easier. Similarly, if the composition of c1 changes (however the public interface stays invariant), LoD ensures that only c1 and its children are affected. In <ref> [31, 32, 33] </ref> these and other benefits of LoD are discussed in great detail. LoD helps in systematizing reuse as well: when class c is being reused in a different context only this small subset of "closely related" classes are needed to be brought in.
Reference: [34] <author> Karl J. Lieberherr. </author> <title> Adaptive Object-Oriented Software: The Demeter Method with Propagation Patterns. </title> <publisher> PWS Publishing Company, </publisher> <address> Boston, </address> <year> 1996. </year> <note> ISBN 0-534-94602-X. </note>
Reference-contexts: However, some recently proposed software development tools and environments such as the Reflexion Model [54], pattern-lint [65] or the Demeter tools <ref> [34] </ref> do focus on the design and architectural model of the software product much like Darwin-E. Darwin-E itself is a fairly big and complicated system under LGA, that was built incrementally. <p> We would like to pose Darwin-E and our approach to impose regularity on software product as a demonstration of the potential of product-centered methodologies and environments in software engineering research and practice. The merit of such approach is corroborated by the recent surge of product-centric research as documented in <ref> [16, 17, 34, 54, 65] </ref>. 8 Chapter 2 Background: A Brief Discourse On Law-Governed Architecture Law-Governed Architecture (LGA) serves as the basis on which support for regularities are implemented.
Reference: [35] <author> S. B. Lippman. </author> <title> C++ Primer. </title> <publisher> Addison-Wesley, </publisher> <year> 1990. </year>
Reference-contexts: Prohibition of assignments to private attributes of class C by any other class. R112. cannot call ( ,C1,F,C) :- private (F)@C, C1=/C. Prohibition of calls to private attributes of class C from any other class. This useful notion is supported by both Simula 67 [6] and C++ <ref> [35] </ref>, but unfortunately not by Eiffel, in which features of a class are automatically visible in all the descendant of this class. This limitation of Eiffel can be easily rectified under Darwin-E.
Reference: [36] <author> D Luckham, F. von Henke, B. Krief-Bruckner, and O. Owe. Anna, </author> <title> a Language for Annotating Ada Programs: Reference Manual. </title> <booktitle> In Lecture Notes in Computer Science, </booktitle> <volume> volume 260. </volume> <publisher> Springer-Verlag, </publisher> <year> 1987. </year>
Reference-contexts: We will also consider two representative samples to contrast with Darwin-E. 13.1 ADA9X Attempts to support software engineering constraints can be observed in ADA9X [69] language, by means of various pragmas that are interpreted and enforced by the com piler and in Ana, a language for annotating ADA programs <ref> [36] </ref>. As an example, by utilizing the built-in pure pragma, ADA functions can be rendered side effect free, as we do with our SEF routines.
Reference: [37] <author> B. Meyer. </author> <title> Eiffel: The Language. </title> <publisher> Prentice Hall, </publisher> <year> 1992. </year>
Reference-contexts: For example, there are good reason to keep the encryption key of a class encryption completely hidden. Second, a decrease in the visibility of f1 would make compile-time type checking impossible, giving rise to a phenomenon called in Eiffel system-level validity failure <ref> [37] </ref>. To provide some control over this capability of Eiffel we introduce the following interaction: Definition 5 (changeExp interaction) Let c1 be a class, f1 be one of the features defined in c1, and c2 be a descendant of c1. <p> This, however, is a rarely used operation whose use can be tightly regulated separately by means of cannot call rule. 59 6.2.7 Reverse Assignment Reverse assignment is a type-safe means provided by Eiffel <ref> [37] </ref> to "resurrect" a pointer stored in variable of more general type then the object being pointed to, making this object usable for what it really is.
Reference: [38] <author> Scott Meyers, Carolyn K. Duby, and Steven P. Reiss. </author> <title> Constraining the structure and style of object-oriented programs. </title> <type> Technical report, </type> <month> April </month> <year> 1993. </year> <booktitle> Presented in Workshop on Principles and Practice of Constraint Programming. </booktitle>
Reference-contexts: however, the semantics of their specification language TYPOL does not seem to interpret global properties such as the notion of clusters, nor express constraints based on these properties. 13.3 CCEL An independent effort to constrain the structure of object-oriented programs can be found in the C++ Constraint Expression Language (CCEL) <ref> [1, 38, 13] </ref> and its host system. In essence, the CCEL system is a tool that can formulate a certain class of regularities and check for violations of these regularities in C++ [68] programs.
Reference: [39] <author> N. H. Minsky and A. D. Lockman. </author> <title> Ensuring integrity by adding obligations to privileges. </title> <booktitle> In Procedings from the 8th International Conference on Software Engineering, </booktitle> <year> 1985. </year>
Reference-contexts: The concept of Law-Governed Systems were consolidated in [41, 50]. The law-governed approach was applied to formulate different object-oriented structures [51, 52, 61, 62]. The law-governed approach has been applied to other problems, such as imposing protocols on distributed systems [42], or ensuring integrity by adding obligations to privileges <ref> [39] </ref>. The notion of LGA, as a software architecture, was formalized in [43]. 14 In the meantime, our work with software engineering of object-oriented systems began. Compile-time enforcement of the law was developed [57] and the concept of regularities emerged [44, 45, 49]. <p> We believe this is one way to tackle the problem of architectural mismatch as documented by Garlan et al. in [17], in the context of reusable component oriented software construction. Use of law-governed obligation has been demonstrated elsewhere <ref> [39] </ref>. But we have not investigated obligation in terms of Darwin-E and regularities in object-oriented software at all. This area remains open for further research. In particular, the process aspect of Darwin-E can benefit significantly from obligations.
Reference: [40] <author> Naftaly H. Minsky. </author> <title> Independent on-line monitoring of evolving systems. </title> <booktitle> In International Conference on Software Engineering, </booktitle> <month> March </month> <year> 1996. </year>
Reference-contexts: On 93 the other hand, we have trivialized many version control issues: storage, representation and management of changes, visibility of change, answering queries regarding versions and configurations etc. 94 Chapter 9 Monitoring Facilities of Darwin-E In <ref> [40] </ref>, Minsky introduced the notion of an auditable software project. Such a project calls for monitoring the activities of the builders, and independent on-line monitoring of the systems they build. <p> This kind of independent 108 monitoring is used in financial institutions as a means to build public confidence in their operations and it has been argued in <ref> [40] </ref> that analogous means should be used as a trust building measure for todays computer systems as well. 109 Chapter 10 An Example Project Under Darwin-E We would like to demonstrate how the various facilities of Darwin-E can be used in a project. <p> We will then describe the initial state of the project, including the law, and finally, we will describe how such a project will work. 10.1 Informal Description The goal of this example project is to build an on-line auditable financial system, first introduced in <ref> [40] </ref> and described below. The project consists of two divisions namely, the base division and the audit division. Each division consists of programmers, and the artifacts (classes, configurations etc.) they build.
Reference: [41] <author> N.H. Minsky. </author> <title> Law-governed systems. </title> <type> Technical Report LCSR-TR-101, </type> <institution> Department of Computer Science, Rutgers University, </institution> <month> February </month> <year> 1987. </year>
Reference-contexts: The initial ideas of law and Law-Governed Systems were formed during the work in relation to large Prolog programs [8]. This lead to the development of the initial version of the Darwin system [46, 47]. The concept of Law-Governed Systems were consolidated in <ref> [41, 50] </ref>. The law-governed approach was applied to formulate different object-oriented structures [51, 52, 61, 62]. The law-governed approach has been applied to other problems, such as imposing protocols on distributed systems [42], or ensuring integrity by adding obligations to privileges [39].
Reference: [42] <author> N.H. Minsky. </author> <title> The imposition of protocols over open distributed systems. </title> <journal> IEEE Transactions on Software Engineering, </journal> <month> February </month> <year> 1991. </year>
Reference-contexts: The concept of Law-Governed Systems were consolidated in [41, 50]. The law-governed approach was applied to formulate different object-oriented structures [51, 52, 61, 62]. The law-governed approach has been applied to other problems, such as imposing protocols on distributed systems <ref> [42] </ref>, or ensuring integrity by adding obligations to privileges [39]. The notion of LGA, as a software architecture, was formalized in [43]. 14 In the meantime, our work with software engineering of object-oriented systems began.
Reference: [43] <author> N.H. Minsky. </author> <title> Law-governed systems. </title> <journal> The IEE Software Engineering Journal, </journal> <month> September </month> <year> 1991. </year> <note> (This is a revision of a similarly entitled 1987 technical report). </note>
Reference-contexts: It follows that the infrastructure for our regularities should be something other than programming 5 languages. 1.5 Regularity And LGA The Law-governed Architecture (henceforth referred to as LGA) <ref> [43] </ref> provides a framework for formulating and enforcing artificial laws about software systems in a manner similar to the laws of a society that govern our societal behavior. It associates with every software development project an explicit set of rules, which is enforced by the environment that manages the project. <p> A brief discourse on LGA, is therefore necessary not only to provide the background required for understanding this dissertation, but also to make it self-contained. This chapter is a composition of materials extracted from various LGA papers, such as <ref> [43, 44, 45] </ref>. 2.1 Law-Governed Architecture and Its Realization in Darwin LGA provides an integrated framework for formulating and enforcing rules about the software being developed and its development process. <p> The law-governed approach has been applied to other problems, such as imposing protocols on distributed systems [42], or ensuring integrity by adding obligations to privileges [39]. The notion of LGA, as a software architecture, was formalized in <ref> [43] </ref>. 14 In the meantime, our work with software engineering of object-oriented systems began. Compile-time enforcement of the law was developed [57] and the concept of regularities emerged [44, 45, 49]. In this research, we used LGA as the underlying architecture for imposing regularities.
Reference: [44] <author> N.H. Minsky. </author> <title> Law-governed regularities in object systems; part 1: Principles. </title> <type> Technical report, </type> <institution> Rutgers University, LCSR, </institution> <month> December </month> <year> 1994. </year> <note> (Accepted for publication in Theory and Practice of Object Systems (TAPOS)). </note>
Reference-contexts: A brief discourse on LGA, is therefore necessary not only to provide the background required for understanding this dissertation, but also to make it self-contained. This chapter is a composition of materials extracted from various LGA papers, such as <ref> [43, 44, 45] </ref>. 2.1 Law-Governed Architecture and Its Realization in Darwin LGA provides an integrated framework for formulating and enforcing rules about the software being developed and its development process. <p> The notion of LGA, as a software architecture, was formalized in [43]. 14 In the meantime, our work with software engineering of object-oriented systems began. Compile-time enforcement of the law was developed [57] and the concept of regularities emerged <ref> [44, 45, 49] </ref>. In this research, we used LGA as the underlying architecture for imposing regularities.
Reference: [45] <author> N.H. Minsky. </author> <title> Regularities in software systems. </title> <editor> In D. Lamb, editor, </editor> <booktitle> Studies of Software Design. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1994. </year> <note> (To be published). 176 </note>
Reference-contexts: The same is true for software systems. In <ref> [45] </ref>, Minsky observed that large systems are inherently incomprehensible if they do not posses some regularity. At the same time, regularity can bring out some of the hidden aspects of the software system, reducing the inherent invisibility. <p> A brief discourse on LGA, is therefore necessary not only to provide the background required for understanding this dissertation, but also to make it self-contained. This chapter is a composition of materials extracted from various LGA papers, such as <ref> [43, 44, 45] </ref>. 2.1 Law-Governed Architecture and Its Realization in Darwin LGA provides an integrated framework for formulating and enforcing rules about the software being developed and its development process. <p> The notion of LGA, as a software architecture, was formalized in [43]. 14 In the meantime, our work with software engineering of object-oriented systems began. Compile-time enforcement of the law was developed [57] and the concept of regularities emerged <ref> [44, 45, 49] </ref>. In this research, we used LGA as the underlying architecture for imposing regularities.
Reference: [46] <author> N.H. Minsky and A. Borgida. </author> <title> The darwin programming environment. </title> <type> Technical Report LCSR-TR-54, </type> <institution> Rutgers University, </institution> <month> November </month> <year> 1984. </year>
Reference-contexts: The initial ideas of law and Law-Governed Systems were formed during the work in relation to large Prolog programs [8]. This lead to the development of the initial version of the Darwin system <ref> [46, 47] </ref>. The concept of Law-Governed Systems were consolidated in [41, 50]. The law-governed approach was applied to formulate different object-oriented structures [51, 52, 61, 62].
Reference: [47] <author> N.H. Minsky and A. Borgida. </author> <title> The darwin software-evolution environment. </title> <booktitle> In Proceedings of the ACM Software Engineering Symposium on Practical Software Development Environments, </booktitle> <pages> pages 89-95, </pages> <month> April </month> <year> 1984. </year>
Reference-contexts: The initial ideas of law and Law-Governed Systems were formed during the work in relation to large Prolog programs [8]. This lead to the development of the initial version of the Darwin system <ref> [46, 47] </ref>. The concept of Law-Governed Systems were consolidated in [41, 50]. The law-governed approach was applied to formulate different object-oriented structures [51, 52, 61, 62].
Reference: [48] <author> N.H. Minsky and P Pal. </author> <title> Establishing regularity in object-oriented (eiffel) systems. </title> <type> Technical Report LCSR-TR-227, </type> <institution> Rutgers University, LCSR, </institution> <month> June </month> <year> 1994. </year> <booktitle> (Presented at the ECOOP Workshop on Patterns on OO programming,Bologna, </booktitle> <month> July </month> <year> 1994). </year>
Reference: [49] <author> N.H. Minsky and P Pal. </author> <title> Law-governed regularities in object systems; part 2: the eiffel case. </title> <type> Technical Report LCSR-TR-228, </type> <institution> Rutgers University, LCSR, </institution> <note> Decem-ber 1994. (Accepted for publication in Theory and Practice of Object Systems (TAPOS)). </note>
Reference-contexts: The notion of LGA, as a software architecture, was formalized in [43]. 14 In the meantime, our work with software engineering of object-oriented systems began. Compile-time enforcement of the law was developed [57] and the concept of regularities emerged <ref> [44, 45, 49] </ref>. In this research, we used LGA as the underlying architecture for imposing regularities.
Reference: [50] <author> N.H. Minsky and D. Rozenshtein. </author> <title> Law-governed systems: Research perspective. </title> <type> Technical Report CAIP-TR-030, </type> <institution> CAIP Center, Rutgers University, </institution> <month> December </month> <year> 1986. </year>
Reference-contexts: The initial ideas of law and Law-Governed Systems were formed during the work in relation to large Prolog programs [8]. This lead to the development of the initial version of the Darwin system [46, 47]. The concept of Law-Governed Systems were consolidated in <ref> [41, 50] </ref>. The law-governed approach was applied to formulate different object-oriented structures [51, 52, 61, 62]. The law-governed approach has been applied to other problems, such as imposing protocols on distributed systems [42], or ensuring integrity by adding obligations to privileges [39].
Reference: [51] <author> N.H. Minsky and D. Rozenshtein. </author> <title> Law-based approach to object-oriented programming. </title> <booktitle> In Proceedings of OOPSLA' 87, </booktitle> <pages> pages 482-493, </pages> <year> 1987. </year>
Reference-contexts: This lead to the development of the initial version of the Darwin system [46, 47]. The concept of Law-Governed Systems were consolidated in [41, 50]. The law-governed approach was applied to formulate different object-oriented structures <ref> [51, 52, 61, 62] </ref>. The law-governed approach has been applied to other problems, such as imposing protocols on distributed systems [42], or ensuring integrity by adding obligations to privileges [39].
Reference: [52] <author> N.H. Minsky and D. Rozenshtein. </author> <title> Controllable delegation: An exercise in law-governed systems. </title> <booktitle> In OOPSLA' 89, </booktitle> <pages> pages 371-380, </pages> <year> 1989. </year>
Reference-contexts: This lead to the development of the initial version of the Darwin system [46, 47]. The concept of Law-Governed Systems were consolidated in [41, 50]. The law-governed approach was applied to formulate different object-oriented structures <ref> [51, 52, 61, 62] </ref>. The law-governed approach has been applied to other problems, such as imposing protocols on distributed systems [42], or ensuring integrity by adding obligations to privileges [39].
Reference: [53] <author> N.H. Minsky and D. Rozenshtein. </author> <title> Configuration management by consensus: An application of law governed systems. </title> <booktitle> In ACM Symposium on Software Development Environments, </booktitle> <year> 1990. </year>
Reference-contexts: this particular three-party-consensus is just one example framework that we have chosen for Darwin-E (because of its simplicity and the natural mapping of the three players (configuration builder, class developer and management) involved in binding), the law-governed paradigm can be used to construct many such frameworks as discussed earlier in <ref> [53] </ref>. Concerns of The Configuration Builder A configuration builder usually has certain criteria by which he prefers one version over another, to bind to a group he inducted in his configuration. <p> linda was the owner of o4 rather than john, the binding would fail, despite the successful binding of previous groups (i.e. g1 with o2). 8.3 Comparision With Other Approaches What we just described is a framework as implemented in Darwin-E, necessary for the consensus based configuration binding mechanism described in <ref> [53] </ref>. To establish the novelty of our work, we will now contrast our approach with several others. Unlike RCS [71] or SCCS [60] we do not provide any change management. Rather, we assume that designating a version or revision, or organizing multiple incarnations of a class is done by users.
Reference: [54] <author> G.C Murphy, D. Notkin, and K. Sullivan. </author> <title> Software reflexion models: Bridging the gap between source and high level models. </title> <booktitle> In Proceedings of the 3rd ACM Symposium on Foundations of Software Engineering, </booktitle> <pages> pages 18-28, </pages> <address> Washington, D.C., </address> <month> October </month> <year> 1995. </year>
Reference-contexts: However, some recently proposed software development tools and environments such as the Reflexion Model <ref> [54] </ref>, pattern-lint [65] or the Demeter tools [34] do focus on the design and architectural model of the software product much like Darwin-E. Darwin-E itself is a fairly big and complicated system under LGA, that was built incrementally. <p> We would like to pose Darwin-E and our approach to impose regularity on software product as a demonstration of the potential of product-centered methodologies and environments in software engineering research and practice. The merit of such approach is corroborated by the recent surge of product-centric research as documented in <ref> [16, 17, 34, 54, 65] </ref>. 8 Chapter 2 Background: A Brief Discourse On Law-Governed Architecture Law-Governed Architecture (LGA) serves as the basis on which support for regularities are implemented. <p> In <ref> [54] </ref>, analyzing the source code to construct a reflexion model is proposed, in order to check whether a system conforms to a high-level model. A reflex-ion model and associated tools can be used in understanding and reverse engineering existing systems.
Reference: [55] <author> H. L. Ossher. </author> <title> Grids: A newprogram structuring mechanism based on layered graphs. </title> <booktitle> In Proceedings of the ACM POPL, </booktitle> <month> January </month> <year> 1984. </year>
Reference-contexts: For instance, none of these techniques can specify and guarantee that a given system is layered, the way we showed in Chapter 11. Incidentally, in <ref> [55, 56] </ref>, a mechanism for imposing a layered module interconnection structure on a given system was described.
Reference: [56] <author> H. L. Ossher. </author> <title> A mechsnism for specifying the structure of large layered systems. </title> <booktitle> In Research Directions in Object-Oriented Programing. </booktitle> <publisher> MIT Press, </publisher> <year> 1987. </year>
Reference-contexts: For instance, none of these techniques can specify and guarantee that a given system is layered, the way we showed in Chapter 11. Incidentally, in <ref> [55, 56] </ref>, a mechanism for imposing a layered module interconnection structure on a given system was described.
Reference: [57] <author> P. P Pal. </author> <title> Towards compile time enforcement in lgs. </title> <note> Masters Essay submitted to the Department of Computer Science, </note> <institution> Rutgers University, </institution> <address> New Brunswick, New Jersy, </address> <year> 1990. </year>
Reference-contexts: The notion of LGA, as a software architecture, was formalized in [43]. 14 In the meantime, our work with software engineering of object-oriented systems began. Compile-time enforcement of the law was developed <ref> [57] </ref> and the concept of regularities emerged [44, 45, 49]. In this research, we used LGA as the underlying architecture for imposing regularities. <p> A re-enforcement is not imposed, on the other hand, if the law changes. The technique for enforcing rules about regulated Eiffel interactions is known as enforcement by compilation, and was developed in <ref> [57] </ref>. The following is a brief description of how this is done in Darwin-E. 6.1 Compile-Time Enforcement of Rules on Regulated Eiffel Interac tions For each class (module-object) c included in a configuration, a set of binary interactions are extracted by static analysis 2 .
Reference: [58] <author> D.E. Perry. </author> <title> The Inscape environment+. </title> <booktitle> In Proceedings of the 11th International Conference on Software Engineering (ICSE), </booktitle> <month> May </month> <year> 1989. </year>
Reference-contexts: Three prominent ones are the PIC formalism of Wolf et al. [72], the Inscape system of Perry <ref> [58] </ref> and the work on connectors by Garlan and Shaw [18, 66]. Although they represent very powerful techniques for specifying interfaces between modules, and in many ways they can do what we cannot do in Darwin-E, they usually are not concerned with regularity, i.e., statements involving universal quantifications.
Reference: [59] <author> Wolfgang Pree. </author> <title> Design Patterns for Object-Oriented Software Development. </title> <publisher> Addison-Wesley, </publisher> <year> 1994. </year>
Reference-contexts: We examined well-known architectures for large systems such as layered or kernlized design and show how to formulate and enforce the principles underlying them. We established that the recently popularized design patterns <ref> [16, 59] </ref> which lack the enforcement support, have inherent implicit constraints that can be formulated as our regularities and hence, can be enforced. <p> It should be obvious by now, that under Darwin-E it is not a problem: a tight control over such properties can be established by the law of the project. 11.3 Supplementing Design Patterns Design patterns <ref> [16, 59] </ref> are idiomatic object-oriented structures that promote good design. A design pattern is essentially an architectural template that can be realized in different contexts. It consists of a small set of classes that are designated to play well-defined roles.
Reference: [60] <author> M. Rochkind. </author> <title> The source-code control system. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> SE-1:364-370, </volume> <month> December </month> <year> 1975. </year> <month> 177 </month>
Reference-contexts: A software development environment is expected to address both the issues. Various version and configuration management schemes are already in use <ref> [4, 60, 71] </ref>. In this chapter we describe the configuration and version management facilities of Darwin-E. Let us mention at the very beginning, that we do not have a full fledged version control and configuration management system in the prototype. <p> This code can either be developed from scratch or can be copied from an existing version 1 of the same class and modifying it. Note that unlike RCS [71] or SCCS <ref> [60] </ref>, Darwin-E does not store and manipulates deltas (changes) by itself: versions are stored in its entirety and are to be done explicitly by users. <p> To establish the novelty of our work, we will now contrast our approach with several others. Unlike RCS [71] or SCCS <ref> [60] </ref> we do not provide any change management. Rather, we assume that designating a version or revision, or organizing multiple incarnations of a class is done by users. However, such actions are regulated by law.
Reference: [61] <author> D. Rozenshtein and N.H. Minsky. </author> <title> Constraining interactions between objects in the presence of class inheritance. </title> <booktitle> In Proceedings of the 2nd International Workshop on Computer-Aided Software Engineering, </booktitle> <month> July </month> <year> 1988. </year>
Reference-contexts: This lead to the development of the initial version of the Darwin system [46, 47]. The concept of Law-Governed Systems were consolidated in [41, 50]. The law-governed approach was applied to formulate different object-oriented structures <ref> [51, 52, 61, 62] </ref>. The law-governed approach has been applied to other problems, such as imposing protocols on distributed systems [42], or ensuring integrity by adding obligations to privileges [39].
Reference: [62] <author> D. Rozenshtein and N.H. Minsky. </author> <title> Law-governed object-oriented system. </title> <journal> Journal of Object-Oriented Programming, </journal> <volume> 1(6) </volume> <pages> 14-29, </pages> <month> March/April </month> <year> 1989. </year>
Reference-contexts: This lead to the development of the initial version of the Darwin system [46, 47]. The concept of Law-Governed Systems were consolidated in [41, 50]. The law-governed approach was applied to formulate different object-oriented structures <ref> [51, 52, 61, 62] </ref>. The law-governed approach has been applied to other problems, such as imposing protocols on distributed systems [42], or ensuring integrity by adding obligations to privileges [39].
Reference: [63] <author> S. Sankar and M. Mandal. </author> <title> Concurrent runtime monitoring of formally specified programs. </title> <booktitle> IEEE Computer, </booktitle> <month> March </month> <year> 1993. </year>
Reference-contexts: Consider for instance, the case of setting spy points or traces: one needs to compile the program in a special way so that this could be arranged by the debugger. However, source code instrumentation like ours is not uncommon. For instance, in <ref> [63] </ref>, source-code transformation by a pre-processor is used to arrange for monitoring. This is similar to our approach in some sense, but the pre-processor transforms ANA annotations, that are voluntarily included in ADA programs.
Reference: [64] <author> Beth A. Schroeder. </author> <title> On-line monitoring: A tutorial. </title> <booktitle> IEEE Computer, </booktitle> <month> June </month> <year> 1995. </year>
Reference-contexts: On-line monitoring techniques have been used for various tasks ranging from debugging and testing, to performance analysis and fault-tolerance <ref> [64] </ref>. In an object-oriented computation, objects interact among themselves via feature calls, so our primary focus in monitoring an object-oriented system is the call interaction. <p> This is taken care of by the legislative facilities of Darwin-E. 9.2.3 Related Work The fundamental idea of putting sensors in the code to arrange reporting of events is not new. Refer to <ref> [64] </ref>, for a survey of on-line monitoring. Code instrumentation is a common technique to embed such sensors. In many cases the instrumentation is done on the object-code.
Reference: [65] <author> M. Sefika, A. Sane, and R. H. Campbell. </author> <title> Monitoring compliance of a software system with its high-level design models. </title> <booktitle> In Proceedings of the 18th International Conference on Software Engineering, </booktitle> <address> Berlin, Germany, </address> <year> 1996. </year>
Reference-contexts: However, some recently proposed software development tools and environments such as the Reflexion Model [54], pattern-lint <ref> [65] </ref> or the Demeter tools [34] do focus on the design and architectural model of the software product much like Darwin-E. Darwin-E itself is a fairly big and complicated system under LGA, that was built incrementally. <p> We would like to pose Darwin-E and our approach to impose regularity on software product as a demonstration of the potential of product-centered methodologies and environments in software engineering research and practice. The merit of such approach is corroborated by the recent surge of product-centric research as documented in <ref> [16, 17, 34, 54, 65] </ref>. 8 Chapter 2 Background: A Brief Discourse On Law-Governed Architecture Law-Governed Architecture (LGA) serves as the basis on which support for regularities are implemented. <p> A reflex-ion model and associated tools can be used in understanding and reverse engineering existing systems. If desired, Darwin-E can similarly be used as a reverse engineering tool to check whether a given system does possess a given set of regularity. 155 13.5 Pattern-Lint In pattern-lint <ref> [65] </ref>, static analysis and dynamic visualization is used to monitor whether a software system complies with its high-level design model: a database of implementation level relations are created from the given program entities, which is then matched against the rules of a given design model to produces relations that demonstrate consistency
Reference: [66] <author> M. Shaw. </author> <title> Procedure calls are the assemply language of software interconnection. </title> <booktitle> In Proceedings of Workshop on Studies of Software Design, </booktitle> <month> May </month> <year> 1993. </year>
Reference-contexts: Three prominent ones are the PIC formalism of Wolf et al. [72], the Inscape system of Perry [58] and the work on connectors by Garlan and Shaw <ref> [18, 66] </ref>. Although they represent very powerful techniques for specifying interfaces between modules, and in many ways they can do what we cannot do in Darwin-E, they usually are not concerned with regularity, i.e., statements involving universal quantifications.
Reference: [67] <author> A. Snyder. </author> <title> Encapsulation and inheritance in object-oriented programming languages. </title> <booktitle> In Proceedings of the OOPSLA'86 Conference, </booktitle> <pages> pages 38-45, </pages> <month> September-October </month> <year> 1986. </year>
Reference-contexts: The potentially negative implications of these aspects of inheritance to encapsulation have been pointed out by Snyder <ref> [67] </ref>. The conflict between inheritance and selective export in Eiffel is due to the fact that anything exported to a class is automatically accessible to all its descendants. To explain why this may be undesirable, consider a class account with features deposit and withdraw. <p> While this may simplify the code in the heir class, it compromises the encapsulation provided by the parent classes, in the general manner discussed in <ref> [67] </ref>. We can fortify encapsulation in Eiffel, without giving up much of the ease of access provided by it, by allowing a heir only read access to the attributes it inherits.
Reference: [68] <author> B. Stroustrap. </author> <title> The C++ Programming Language. </title> <address> Addision-Wesly, </address> <year> 1994. </year>
Reference-contexts: In essence, the CCEL system is a tool that can formulate a certain class of regularities and check for violations of these regularities in C++ <ref> [68] </ref> programs.
Reference: [69] <author> The Ada 9X Mapping/Revision Team. </author> <title> The Ada 9X Reference Manual (ISO/IEC CD 8652/ISO/IEC JTC1/SC22 N 1451 and ISO/IEC JTC1/SC22 WG9 N 191). </title> <publisher> Intermetics Inc, </publisher> <year> 1994. </year>
Reference-contexts: Most of these existing process-centered software development environments deal with C or C++ and stress more on process modeling, process enactment, intelligent assistance and guidance. We will also consider two representative samples to contrast with Darwin-E. 13.1 ADA9X Attempts to support software engineering constraints can be observed in ADA9X <ref> [69] </ref> language, by means of various pragmas that are interpreted and enforced by the com piler and in Ana, a language for annotating ADA programs [36]. As an example, by utilizing the built-in pure pragma, ADA functions can be rendered side effect free, as we do with our SEF routines.
Reference: [70] <author> W. Teitelman. </author> <title> A tour through Cedar. </title> <journal> IEEE Software, </journal> <volume> 1, </volume> <month> April </month> <year> 1984. </year>
Reference-contexts: The next set of systems attempt to avoid the dependency on files as the units they manage and uses the higher order notion of modules. In Cedar <ref> [70] </ref>, a module is an interface-implementation pair, each implementation can have different versions. Modules are identified by unique names and versions are identified by the date of creation. The selection of versions can only be guided by their date of creation.
Reference: [71] <author> W. Tichy. </author> <title> Design, implementation and evaluation of a revision control system. </title> <booktitle> In Proceedings of the 6th International Conference on Software Engineering (ICSE), </booktitle> <month> September </month> <year> 1982. </year>
Reference-contexts: A software development environment is expected to address both the issues. Various version and configuration management schemes are already in use <ref> [4, 60, 71] </ref>. In this chapter we describe the configuration and version management facilities of Darwin-E. Let us mention at the very beginning, that we do not have a full fledged version control and configuration management system in the prototype. <p> Various aspects relevant for version control and configuration management are either not considered at all, or supported in a simplistic manner. For instance, representation and extraction of changes in version a la RCS <ref> [71] </ref> is not implemented, locks and transactions are implemented only minimally. 75 8.1 Version and Groups In Darwin-E, a group-object collectively represents different versions of a class. <p> This code can either be developed from scratch or can be copied from an existing version 1 of the same class and modifying it. Note that unlike RCS <ref> [71] </ref> or SCCS [60], Darwin-E does not store and manipulates deltas (changes) by itself: versions are stored in its entirety and are to be done explicitly by users. <p> To establish the novelty of our work, we will now contrast our approach with several others. Unlike RCS <ref> [71] </ref> or SCCS [60] we do not provide any change management. Rather, we assume that designating a version or revision, or organizing multiple incarnations of a class is done by users. However, such actions are regulated by law.
Reference: [72] <author> A. L. Wolf, L. A. Clarke, and J.C. Wileden. </author> <title> Interface control and incremental development in the PIC environment. </title> <booktitle> In Proceedings of the 8th International Conference on Software Engineering (ICSE), </booktitle> <month> August </month> <year> 1985. </year> <month> 178 </month>
Reference-contexts: Three prominent ones are the PIC formalism of Wolf et al. <ref> [72] </ref>, the Inscape system of Perry [58] and the work on connectors by Garlan and Shaw [18, 66].
References-found: 72

