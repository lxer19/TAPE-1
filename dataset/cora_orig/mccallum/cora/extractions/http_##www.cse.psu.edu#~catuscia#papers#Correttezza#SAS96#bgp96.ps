URL: http://www.cse.psu.edu/~catuscia/papers/Correttezza/SAS96/bgp96.ps
Refering-URL: http://www.cse.psu.edu/~catuscia/publications.html
Root-URL: http://www.cse.psu.edu
Title: Proving Correctness of Constraint Logic Programs with Dynamic Scheduling  
Author: F.S. de Boer M. Gabbrielli C. Palamidessi M. Gabbrielli 
Keyword: Dynamic scheduling, concurrent constraint programming, partial correctness, strongest postcondition.  
Note: Corresponding author:  This work was supported by the HCM Project "EXPRESS".  
Address: Genova  Corso Italia 40, 56125 Pisa, Italy  
Affiliation: Universiteit Utrecht  Universita di Pisa  Universita di  Dipartimento di Informatica Universita di Pisa  
Email: gabbri@di.unipi.it  
Phone: Tel: +39-50-887264  
Abstract: A general framework based on Hoare logic is introduced for specifying and reasoning about Constraint Logic Programs with dynamic scheduling. The framework consists of a mixed formalism of programs in a ccp-like language, on the one hand, and correctness properties of the Hoare logic, on the other hand. In this formalism delay conditions are viewed as a specific class of correctness properties. In the construction of the proof-system we follow the lines of a previous proof-system we developed for concurrent constraint programming, which was sound, but not complete (for ccp). Due to the different kind of choice used in CLP, on the contrary, the system considered here is both sound and complete. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> K. R. Apt. </author> <title> Declarative Programming in Prolog. </title> <editor> In D. Miller, editor, </editor> <booktitle> Proceedings of the Int'l Symposium on Logic Programming, </booktitle> <publisher> The MIT Press, </publisher> <address> pages 11-35x, </address> <year> 1993. </year>
Reference-contexts: Thus, considering for instance logic programs, one can reason about program correctness by simply using the least Herbrand model <ref> [1] </ref>.
Reference: [2] <author> K. R. Apt and I. Luitjes. </author> <title> Verification of logic programs with delay declarations. </title> <editor> In A. Borzyszkowski and S. Sokolowski, editors, </editor> <booktitle> Proceedings of the Fourth International Conference on Algebraic Methodology and Software Technology, (AMAST'95), Lecture Notes in Computer Science, </booktitle> <pages> pages 1-19, </pages> <address> Berlin, 1995. </address> <publisher> Springer-Verlag. </publisher>
Reference-contexts: The operational semantics of logic programs with dynamic scheduling has been discussed by Naish [20] while their denotational semantics has been investigated by Marriott et al. [18, 17]. Recently also the issue of correctness has received some attention. Apt and Luitjes <ref> [2] </ref> have investigated deadlock freedom, occur check freedom, termination and absence of builtins' errors in presence of delay declarations. Termination has also been studied by Marchiori and Teusink [16] and by Luttringhaus [15].
Reference: [3] <author> F.S. de Boer, A. Di Pierro, and C. Palamidessi. </author> <title> An algebraic perspective of constraint logic programming. </title> <journal> Journal of Logic and Computation. </journal> <note> To appear. </note>
Reference-contexts: In this way we are more general since the standard CLP view can be obtained as a particular instance of the abstract formalization. In the following we introduce the basic definition of cylindric constraint system. We refer to <ref> [22, 23, 3] </ref> for more details concerning its construction and properties. Definition 2.1 A constraint system is a complete algebraic lattice hC; ; t; true; falsei where t is the lub operation, and true, false are the least and the greatest elements of C, respectively.
Reference: [4] <author> F.S. de Boer, M. Gabbrielli, E. Marchiori, and C. Palamidessi. </author> <title> Proving Concurrent Constraint Programs Correct. </title> <booktitle> In Proc. of Twentyfirst POPL, </booktitle> <publisher> ACM Press, </publisher> <year> 1994. </year>
Reference-contexts: The proof-system is parametric wrt a theory of properties based on the elements of the constraint system, a class of user-defined properties (including the delay conditions), and the connectives of the propositional calculus. Differently from the system developed in <ref> [4] </ref>, here we can use classical logic to reason about properties. This is mainly due to the fact that we deal with the local variables of CLP just by variable-renaming, hence we don't need to impose a cylindrification operator on properties. <p> We prove that our proof-system is sound and complete by using the denotational semantics. Thanks to its simplicity, this proof turns out to be (relatively) easy. It is worth noticing that, on the contrary, the proof-system defined in <ref> [4] </ref> for ccp is sound but incomplete. This is because ccp has global choice, whereas the kind of nonderminism of CLP can be modeled by local choice, even if we add the delay declarations. <p> The set SP (D:A) actually describes the strongest postcondition of the process D:A with respect to the precondition true, since every constraint satisfies the property true. 5 A proof-system for ffi-ccp In this section we develop a proof-system for ffi-ccp following the lines of the one defined in <ref> [4] </ref> for ccp. To this aim, it is convenient to give first a compositional characterization of the semantics SP (D:A). It comes out that we can use nearly the same denotational construction as the one introduced by Jagadeesan et al. in [14] for local ccp. <p> Therefore we can denote the semantics of a process D:A simply by [[D:A]]. Using the lifting described above we now obtain the following result. Proposition 5.3 For any process D:A we have SP (D:A) = [[D:A]]. As discussed in <ref> [4] </ref>, the denotational semantics allows us to obtain the proof-system by simply "mirroring" the equations. In fact the operators of the language are modeled in these equations by standard set theoretic notions which in the specification logic get replaced by the corresponding logical notions. <p> This would have the intuitive meaning that if the computation of D:A starts in a store which satisfies the property and terminates in a state d, then d satisfies the property OE. As observed in <ref> [4] </ref>, if preconditions are described by upward closed properties (i.e. they are expressed by formulas involving constraints, conjunctions and disjunctions only) then triples are not more expressive than the assertions considered in previous sections.
Reference: [5] <author> F.S. de Boer and C. Palamidessi. </author> <title> A Fully Abstract Model for Concurrent Constraint Programming. </title> <editor> In S. Abramsky and T.S.E. Maibaum, editors, </editor> <booktitle> Proc. of TAPSOFT/CAAP, </booktitle> <volume> LNCS 493, </volume> <pages> pages 296-319. </pages> <publisher> Springer-Verlag, </publisher> <year> 1991. </year>
Reference-contexts: We assume also the presence of a renaming mechanism that takes care of using fresh variables each time a clause is considered (in R5). For the sake of simplicity we do not describe this renaming mechanism in the transition system. The interested reader can find in [22] and <ref> [5] </ref> various formal approaches to this problem. Using the transition system in Table 1 we can now define the standard notion of observables as the results of finite computations. As in the case of CLP observables, we do not consider the values of local variables in the results.
Reference: [6] <author> M. Carlsson. </author> <title> SICStus Prolog User's Manual. </title> <address> Po Box 1263, S-16313 Spanga, Sweden, </address> <month> February </month> <year> 1988. </year>
Reference-contexts: The practical relevance of delay declarations is demonstrated by the fact that they are implemented in such languages as Sicstus Prolog <ref> [6] </ref>, Eclipse [26], Godel [10] and in many CLP systems [13]. From the semantic viewpoint, the fact that an atom can be delayed until certain conditions are satisfied introduces some complications similar to those arising in concurrent languages.
Reference: [7] <author> S.A. Cook. </author> <title> Soundness and completeness of an axiom system for program verification. </title> <journal> SIAM J. Computation, </journal> <volume> 7(1) </volume> <pages> 70-90, </pages> <year> 1978. </year>
Reference: [8] <author> M. Falaschi, M. Gabbrielli, K. Marriott, and C. Palamidessi. </author> <title> Compositional Analysis for Concurrent Constraint Programming. </title> <booktitle> In Proc. Eighth IEEE Symp. on Logic In Computer Science, </booktitle> <pages> pages 210-221. </pages> <publisher> IEEE Computer Society Press, Los Alamitos, </publisher> <address> California, </address> <year> 1993. </year>
Reference: [9] <author> M. Falaschi, M. Gabbrielli, K. Marriott, and C. Palamidessi. </author> <title> Confluence and Concurrent Constraint Programming. </title> <booktitle> Proc. of the Fourth International Conference on Algebraic Methodology and Software Technology (AMAST). Volume 936 of Lecture Notes in Computer Science, </booktitle> <pages> pages 531-545. </pages> <publisher> Springer-Verlag, </publisher> <year> 1995. </year>
Reference-contexts: The delay declarations provide additionally a sort of entailment check. These two mechanisms together allow to simulate a restricted form of the ccp global choice: the mutually exclusive choice <ref> [9] </ref>.
Reference: [10] <author> P. M. Hill and J. W. Lloyd. </author> <title> The Godel programming language. </title> <publisher> The MIT Press, </publisher> <year> 1994. </year>
Reference-contexts: The practical relevance of delay declarations is demonstrated by the fact that they are implemented in such languages as Sicstus Prolog [6], Eclipse [26], Godel <ref> [10] </ref> and in many CLP systems [13]. From the semantic viewpoint, the fact that an atom can be delayed until certain conditions are satisfied introduces some complications similar to those arising in concurrent languages.
Reference: [11] <editor> L. Henkin, J.D. Monk, and A. Tarski. Cylindric Algebras (Part I). </editor> <publisher> North-Holland, </publisher> <year> 1971. </year>
Reference-contexts: In order to treat the hiding operator of the language a general notion of existential quantifier is introduced which is formalized in terms of cylindric algebras <ref> [11] </ref>. Moreover, in order to model renaming of variables, diagonal elements [11] are added to the primitive constraints. This leads to the concept of cylindric constraint system. In the following, we assume given a (denumerable) set of variables Var with typical elements x; y; z; : : :. <p> In order to treat the hiding operator of the language a general notion of existential quantifier is introduced which is formalized in terms of cylindric algebras <ref> [11] </ref>. Moreover, in order to model renaming of variables, diagonal elements [11] are added to the primitive constraints. This leads to the concept of cylindric constraint system. In the following, we assume given a (denumerable) set of variables Var with typical elements x; y; z; : : :. Definition 2.2 Let hC; ; t; true; falsei be a constraint system.
Reference: [12] <author> J. Jaffar and J.-L. Lassez. </author> <title> Constraint Logic Programming. </title> <booktitle> In Proc. Fourteenth Annual ACM Symp. on Principles of Programming Languages, </booktitle> <pages> pages 111-119. </pages> <publisher> ACM, </publisher> <year> 1987. </year>
Reference-contexts: In the following we briefly introduce the terminology and the basic notions for these languages. For CLP we refer to the original paper <ref> [12] </ref> by Jaffar and Lassez and to the survey [13] by Jaffar and Maher. We let vars (e) to denote the set of variables which appear in the syntactic expression e and we denote by x a tuple of distinct variables.
Reference: [13] <author> Joxan Jaffar and Michael J. Maher. </author> <title> Constraint logic programming: A survey. </title> <journal> Journal of Logic Programming, </journal> 19/20:503-581, 1994. 
Reference-contexts: The practical relevance of delay declarations is demonstrated by the fact that they are implemented in such languages as Sicstus Prolog [6], Eclipse [26], Godel [10] and in many CLP systems <ref> [13] </ref>. From the semantic viewpoint, the fact that an atom can be delayed until certain conditions are satisfied introduces some complications similar to those arising in concurrent languages. <p> In the following we briefly introduce the terminology and the basic notions for these languages. For CLP we refer to the original paper [12] by Jaffar and Lassez and to the survey <ref> [13] </ref> by Jaffar and Maher. We let vars (e) to denote the set of variables which appear in the syntactic expression e and we denote by x a tuple of distinct variables.
Reference: [14] <author> R. Jagadeesan, V.A. Saraswat, and V. Shanbhogue. </author> <title> Angelic non-determinism in concurrent constraint programming. </title> <type> Technical report, </type> <institution> Xerox Park, </institution> <year> 1991. </year>
Reference-contexts: To this end we translate CLP into a sort of concurrent constraint programming language (ccp for short), which we call ffi-ccp, and which is basically an extension of ccp with local choice <ref> [14] </ref>. The extension consists in allowing the presence of delay conditions in the "ask" construct. Such an extension enhances the expressive power, but preserves the nice properties of local ccp, in particular the denotational semantics can still be defined in a simple way by using closure operators, following [14]. <p> local choice <ref> [14] </ref>. The extension consists in allowing the presence of delay conditions in the "ask" construct. Such an extension enhances the expressive power, but preserves the nice properties of local ccp, in particular the denotational semantics can still be defined in a simple way by using closure operators, following [14]. We use the denotational semantics as a guideline for the development of a compositional proof-system, where "compositional" means that the correctness (or specification) of a composite program can be derived directly from the correctness (or specifications) of its immediate constituents. <p> In fact in the global case the external environment can affect the choice, since only those branches whose guards are enabled can be selected. On the other hand, as shown in <ref> [14] </ref>, local ccp has a very simple denotational model based on closure operators. Since CLP with dynamic scheduling has only local non-determinism, we use here this restricted form of non-determinism. In this way we have a simple semantic basis for our calculus. <p> To this aim, it is convenient to give first a compositional characterization of the semantics SP (D:A). It comes out that we can use nearly the same denotational construction as the one introduced by Jagadeesan et al. in <ref> [14] </ref> for local ccp.
Reference: [15] <author> S. Luttringhaus-Kappel. </author> <title> Control generation for logic programs. </title> <editor> In D.S. Warren, editor, </editor> <booktitle> Proc. Tenth Int'l Conf. on Logic Programming, </booktitle> <pages> pages 478-495. </pages> <publisher> MIT Press, </publisher> <year> 1993. </year>
Reference-contexts: Recently also the issue of correctness has received some attention. Apt and Luitjes [2] have investigated deadlock freedom, occur check freedom, termination and absence of builtins' errors in presence of delay declarations. Termination has also been studied by Marchiori and Teusink [16] and by Luttringhaus <ref> [15] </ref>. In particular, the latter paper describes an algorithm which, given a program, generates automatically delay declarations which ensure termination.
Reference: [16] <author> E. Marchiori and F. Teusink. </author> <title> Proving termination of logic programs with delay declarations. </title> <editor> In J. Lloyd, editor, </editor> <booktitle> Proc. Twelfth International Logic Programming Symposium. </booktitle> <publisher> MIT Press, </publisher> <year> 1995. </year> <month> 16 </month>
Reference-contexts: Recently also the issue of correctness has received some attention. Apt and Luitjes [2] have investigated deadlock freedom, occur check freedom, termination and absence of builtins' errors in presence of delay declarations. Termination has also been studied by Marchiori and Teusink <ref> [16] </ref> and by Luttringhaus [15]. In particular, the latter paper describes an algorithm which, given a program, generates automatically delay declarations which ensure termination.
Reference: [17] <author> K. Marriott, M. Falaschi, M. Gabbrielli and C. Palamidessi. </author> <title> A simple semantics for logic programming languages with delay. </title> <editor> In R. Kotagiri, editor, </editor> <booktitle> Proc. Eighteenth Australian Computer Science Conf., Australian Computer Science Comm. </booktitle> <volume> 17 (1): </volume> <pages> 356-363, </pages> <year> 1995. </year>
Reference-contexts: The operational semantics of logic programs with dynamic scheduling has been discussed by Naish [20] while their denotational semantics has been investigated by Marriott et al. <ref> [18, 17] </ref>. Recently also the issue of correctness has received some attention. Apt and Luitjes [2] have investigated deadlock freedom, occur check freedom, termination and absence of builtins' errors in presence of delay declarations. Termination has also been studied by Marchiori and Teusink [16] and by Luttringhaus [15].
Reference: [18] <author> K. Marriott, M. Garcia de la Banda and M. Hermenegildo. </author> <title> Analyzing Logic Programs with Dynamic Scheduling. </title> <booktitle> Proc. 21st ACM Symp. Principles of Programming Languages, </booktitle> <pages> pages 240-253. </pages> <publisher> ACM Press, </publisher> <year> 1994. </year>
Reference-contexts: The operational semantics of logic programs with dynamic scheduling has been discussed by Naish [20] while their denotational semantics has been investigated by Marriott et al. <ref> [18, 17] </ref>. Recently also the issue of correctness has received some attention. Apt and Luitjes [2] have investigated deadlock freedom, occur check freedom, termination and absence of builtins' errors in presence of delay declarations. Termination has also been studied by Marchiori and Teusink [16] and by Luttringhaus [15].
Reference: [19] <author> L. Naish. </author> <title> An introduction to mu-prolog. </title> <type> Technical Report 82/2, </type> <institution> The University of Melbourne, </institution> <year> 1982. </year>
Reference-contexts: This dynamic scheduling is obtained by adding so-called delay declarations to program clauses. Delay declarations (introduced by Naish in <ref> [19] </ref>) allow to run the calls more efficiently, to prevent run-time errors and to enforce termination. In Constraint Logic Programming (CLP for short) they are used also to postpone the evaluation of constraints which are "too hard" for the solver. <p> We do not make any assumption on the selection rule which is used to select the atom to be rewritten, since this allows us to model also parallel executions. Naish <ref> [19] </ref> first introduced delay declarations in logic languages by using when constructs in MU-Prolog. Here we follow loosely the syntax used in the language Godel and consider declarations of the form DELAY p (X) UNTIL Condition (X) where Condition (X) is a formula in some assertion language.
Reference: [20] <author> L. Naish. </author> <title> Negation and Control in Prolog, </title> <publisher> LNCS 238, Springer-Verlag, </publisher> <year> 1985. </year>
Reference-contexts: From the semantic viewpoint, the fact that an atom can be delayed until certain conditions are satisfied introduces some complications similar to those arising in concurrent languages. The operational semantics of logic programs with dynamic scheduling has been discussed by Naish <ref> [20] </ref> while their denotational semantics has been investigated by Marriott et al. [18, 17]. Recently also the issue of correctness has received some attention. Apt and Luitjes [2] have investigated deadlock freedom, occur check freedom, termination and absence of builtins' errors in presence of delay declarations.
Reference: [21] <author> E.-R. Olderog. </author> <title> Nets, Terms and Formulas. </title> <booktitle> Cambridge Tracts in Theoretical Computer Science 23, </booktitle> <publisher> Cambridge Univ. Press, </publisher> <year> 1991. </year>
Reference: [22] <author> V.A. Saraswat and M. Rinard. </author> <title> Concurrent constraint programming. </title> <booktitle> In Proc. of POPL, </booktitle> <pages> pages 232-245, </pages> <year> 1990. </year>
Reference-contexts: In the standard CLP setting constraints are essentially first order formulas built up by using predicate symbols which have a predefined interpretation (e.g. equations on the term algebra or inequalities over the reals). A more abstract view is followed in <ref> [22] </ref> by formalizing the notion of constraint system along the guidelines of Scott's treatment of information systems [24]. Here we follow this second approach and assume that both CLP and ccp use the abstract notion of constraint system defined below. <p> In this way we are more general since the standard CLP view can be obtained as a particular instance of the abstract formalization. In the following we introduce the basic definition of cylindric constraint system. We refer to <ref> [22, 23, 3] </ref> for more details concerning its construction and properties. Definition 2.1 A constraint system is a complete algebraic lattice hC; ; t; true; falsei where t is the lub operation, and true, false are the least and the greatest elements of C, respectively. <p> We assume also the presence of a renaming mechanism that takes care of using fresh variables each time a clause is considered (in R5). For the sake of simplicity we do not describe this renaming mechanism in the transition system. The interested reader can find in <ref> [22] </ref> and [5] various formal approaches to this problem. Using the transition system in Table 1 we can now define the standard notion of observables as the results of finite computations. As in the case of CLP observables, we do not consider the values of local variables in the results.
Reference: [23] <author> V.A. Saraswat, M. Rinard, and P. Panangaden. </author> <title> Semantics foundations of Concurrent Constraint Programming. </title> <booktitle> In Proc. of POPL, </booktitle> <year> 1991. </year>
Reference-contexts: In this way we are more general since the standard CLP view can be obtained as a particular instance of the abstract formalization. In the following we introduce the basic definition of cylindric constraint system. We refer to <ref> [22, 23, 3] </ref> for more details concerning its construction and properties. Definition 2.1 A constraint system is a complete algebraic lattice hC; ; t; true; falsei where t is the lub operation, and true, false are the least and the greatest elements of C, respectively.
Reference: [24] <author> D. Scott. </author> <title> Domains for denotational semantics. </title> <booktitle> In Proc. of ICALP, </booktitle> <year> 1982. </year>
Reference-contexts: A more abstract view is followed in [22] by formalizing the notion of constraint system along the guidelines of Scott's treatment of information systems <ref> [24] </ref>. Here we follow this second approach and assume that both CLP and ccp use the abstract notion of constraint system defined below. In this way we are more general since the standard CLP view can be obtained as a particular instance of the abstract formalization.
Reference: [25] <author> D. Scott and J.W. de Bakker. </author> <title> A theory of programs. </title> <type> Technical Report Unpublished, </type> <institution> Notes of the IBM Vienna Seminar, </institution> <year> 1969. </year>
Reference-contexts: It is also worth noticing that they provide a logical meaning for the operators of the language: action prefixing (!) corresponds to implication (still denoted by !), parallel composition to conjunction and choice to disjunction. Reasoning about recursion is formalized in terms of the meta-rule C6 (Scott-induction <ref> [25] </ref>) which allows to conclude that the agent p (x) satisfies a property OE whenever the body of p (x) satisfies the same property assuming the conclusion of the rule.
Reference: [26] <author> Mark Wallace and Andre Veron. </author> <title> Two problems two solutions: One system ECLiPSe. </title> <booktitle> In Proceedings IEE Colloquium on Advanced Software Technologies for Scheduling, </booktitle> <address> London, </address> <month> April </month> <year> 1993. </year> <month> 17 </month>
Reference-contexts: The practical relevance of delay declarations is demonstrated by the fact that they are implemented in such languages as Sicstus Prolog [6], Eclipse <ref> [26] </ref>, Godel [10] and in many CLP systems [13]. From the semantic viewpoint, the fact that an atom can be delayed until certain conditions are satisfied introduces some complications similar to those arising in concurrent languages.
References-found: 26

