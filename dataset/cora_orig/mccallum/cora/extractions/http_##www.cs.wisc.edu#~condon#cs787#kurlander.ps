URL: http://www.cs.wisc.edu/~condon/cs787/kurlander.ps
Refering-URL: 
Root-URL: 
Title: Minimum Cost Interprocedural Register Allocation  
Author: Steven M. Kurlander Charles N. Fischer 
Address: Wisconsin|Madison  
Affiliation: University of  
Abstract: Past register allocators have applied heuristics to allocate registers at the local, global, and interprocedural levels. This paper presents a polynomial time interprocedural register allocator that models the cost of allocating registers to procedures and spilling registers across calls. To find the minimum cost allocation, our allocator maps solutions from a dual network flow problem that can be solved in polynomial time. Experiments show that our interprocedural register allocator can yield significant improvements in execution time. 
Abstract-found: 1
Intro-found: 1
Reference: [BCKT89] <author> Preston Briggs, Keith D. Cooper, Ken Kennedy, and Linda Torczon. </author> <title> Coloring heuristics for register allocation. </title> <booktitle> In Proceedings of the ACM SIG-PLAN '89 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 275-284, </pages> <month> July </month> <year> 1989. </year>
Reference: [BL92] <author> Thomas Ball and James R. Larus. </author> <title> Optimally profiling and tracing programs. </title> <booktitle> In Proceedings of the Nineteenth Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 59-70, </pages> <month> January </month> <year> 1992. </year>
Reference-contexts: We use profile information to compute the number of calls between each procedure and the number of instructions executed in each procedure. Profile information is gathered using qpt <ref> [BL92] </ref>. When profiling, benchmarks are run on input yielding short execution times, except for benchmark nasa7 , in which we have only one input file.
Reference: [Cam85] <author> Kathie Cameron. </author> <title> Antichain sequences. </title> <booktitle> Order, </booktitle> <volume> 2(3) </volume> <pages> 249-255, </pages> <year> 1985. </year>
Reference-contexts: Register spilling allows registers to be reassigned along a path in the call graph when profitable. To generate a save-free interprocedural register allocation of a call graph, we use Cameron's algorithm for finding a maximum weight k-antichain in a partially ordered set <ref> [Cam85] </ref>. To find a maximum weight k-antichain, Cameron maps solutions from a dual minimum cost flow problem 1 . A dual minimum cost flow problem can be transformed into a minimum cost flow problem and solved in polynomial time. <p> Our solution is based on Cameron's algorithm for finding a maximum weight k-antichain in a partially ordered set <ref> [Cam85] </ref>. In Section 4, we generalize our allocation model to compute a minimum cost allocation that may include register spilling across calls in (possibly cyclic) call graphs. For each procedure, we assume an intraprocedural register allocator has already grouped locals that can be assigned the same register. <p> Define a comparability digraph D (T ) as having an edge from u to v when u is less than v in the partial order <ref> [Cam85] </ref>. If S is the set of candidates of a call graph G and the partial order is (v), then D (S) is the interference graph for a save-free interprocedural register allocation of G. <p> For example, in Figure 2 (c), fp; tg, fp; vg, and fq; vg are antichains, as the candidates in each set are not joined by an edge in the comparability digraph. A k-antichain is the union of at most k antichains <ref> [Cam85] </ref>. Both fp; t; q; vg and fp; t; vg are 2-antichains. Let S be the set of candidates of a call graph G and assume partial order (v) on S. <p> A k-antichain sequence A = (A 1 ; : : : ; A k ), where A i S, and if c i 2 A p , c j 2 A q , and c i &lt; c j , then p &lt; q <ref> [Cam85] </ref>. Each A i , 1 i k, corresponds to an antichain|if c i &lt; c j , then c i and c j cannot be members of the same antichain. <p> This register ordering models the sequence in which antichains are assigned to candidates. To find a maximum weight k-antichain sequence in a partially ordered set, we solve the following dual minimum cost flow problem <ref> [Cam85] </ref>. Dual Variables x j ; y j for c j 2 S Constraints A.1 for c j 2 S, 0 x j ; y j k. A.2 if c i ; c j 2 S and c i &lt; c j , then x i + y j k. <p> In solutions to the dual minimum cost flow problem, one can prove that for c j 2 S, x j + y j = k + 1 or x j + y j = k <ref> [Cam85] </ref>. If x j + y j = k + 1, then we map c j to the antichain whose number in the sequence equals the value of x j . Otherwise, if x j + y j = k, c j is not mapped to an antichain.
Reference: [Cha82] <author> Gregory J. Chaitin. </author> <title> Register allocation and spilling via graph coloring. </title> <booktitle> In Proceedings of the ACM SIGPLAN '82 Symposium on Compiler Construction, </booktitle> <pages> pages 98-105, </pages> <year> 1982. </year>
Reference-contexts: Candidates c u and c v cannot be assigned the same register. Since a partial order defines the interference relation between candidates in a save-free interprocedural register allocation, the interference graph is transitive. The interference graph for intraprocedural register allocation, however, can the call graph. be non-transitive <ref> [Cha82] </ref>. In an intraprocedural register allocation, two live ranges that interfere are assigned different registers. Assume live ranges l a and l b interfere and live ranges l b and l c interfere. Live range l a does not necessarily interfere with l c .
Reference: [CHKW86] <author> F. Chow, M. Himmelstein, E. Killian, and L. Weber. </author> <title> Engineering a RISC compiler system. </title> <booktitle> In Proceedings COMPCON, </booktitle> <pages> pages 132-137, </pages> <month> March </month> <year> 1986. </year>
Reference-contexts: 1 Introduction Effectively using registers can significantly decrease the execution time of a program. Common policy in current compilers using only intraprocedural register allocation is to spill at call sites registers that might be used by both the caller and callee <ref> [CHKW86] </ref>. The goal of inter procedural register allocation is to minimize execution time given the register requirements of individual procedures in a program. Based on these requirements, an interprocedural register allocator selects which registers are available to each procedure and, correspondingly, around which calls registers are spilled. <p> between candidates m and n and edge e, we can assign u and v in P 2 the same registers as m and n, without spilling registers across the call. 7 Library Routines We assume that library routines have been pre-compiled using a caller-save/callee-save convention for spilling registers across calls <ref> [CHKW86] </ref>. Any caller-save register live across a call to a library routine must be spilled across the call. To allow for pre-compiled library routines, we create a pseudo library routine that allocates the abstract registers that we will map to the pre-defined caller-save registers.
Reference: [CK91] <author> David Callahan and Brian Koblenz. </author> <title> Register allocation via hierarchical graph coloring. </title> <booktitle> In Proceedings of the ACM SIGPLAN '91 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 192-203, </pages> <month> June </month> <year> 1991. </year>
Reference: [Kur95] <author> Steven M. Kurlander. </author> <title> Interprocedural Register Allocation. </title> <type> PhD thesis, </type> <institution> University of Wisconsin-Madison, </institution> <year> 1995. </year> <note> In preparation. </note>
Reference-contexts: For a call graph G on which we define partial order (v), and given k registers, let P fl (k; G) be solutions to the dual minimum cost flow problem of Figure 7. Let Q fl (k; G) be solutions to interprocedural register allocation with spilling. In <ref> [Kur95] </ref>, we prove that there exists a bijection z (I), from I 2 Q fl (k; G) onto z 2 P fl (k; G), and an inverse function I (z) for z 2 P fl (k; G).
Reference: [Orl93] <author> James B. Orlin. </author> <title> A faster strongly polynomial minimum cost flow algorithm. </title> <journal> Operations Research, </journal> <volume> 41(2) </volume> <pages> 377-387, </pages> <year> 1993. </year>
Reference-contexts: Letting n be the number of nodes and m be the number of arcs, an unconstrained minimum cost flow problem can be solved in O (n log n (m+n log n) <ref> [Orl93] </ref>, which is independent of k, w j , and s j in our dual minimum cost flow problem.
Reference: [PF92] <author> Todd A. Proebsting and Charles N. Fischer. </author> <title> Probabilistic register allocation. </title> <booktitle> In Proceedings of the ACM SIGPLAN '92 Conference on Programming Language Design and Implementation, </booktitle> <month> June </month> <year> 1992. </year>
Reference: [SH89] <author> Peter A. Steenkiste and John L. Hennessy. </author> <title> A simple interprocedural register allocation algorithm and its effectiveness for LISP. </title> <journal> Transactions on Programming Languages and Systems, </journal> <pages> pages 1-30, </pages> <month> January </month> <year> 1989. </year>
Reference-contexts: Groups are then allocated registers based on the total frequency in which their members are referenced. Walls' allocator may not find the best allocation with respect to his model, since he allows locals infrequently referenced to be grouped together with locals frequently referenced. Steenkiste and Hennessy <ref> [SH89] </ref> design an interprocedu-ral register allocator for LISP programs. Their approach allocates registers to locals in a bottom-up fashion over the call graph. Since they find that LISP programs tend to spend their time in the leaf procedures of a call graph, their method first allocates registers in the leaves. <p> the cost of spilling a register on entry to and exit from a procedure is less than the benefit of allocating a register to a candidate, these candidates are always allocated a register. adding our minimum cost interprocedural register allocator with spills with Steenkiste and Hennessy's bottom-up inter-procedural register allocator <ref> [SH89] </ref> to gcc. The benchmarks are compiled at optimization level O2 with loop-unrolling enabled. Results from a sample of SPEC92 benchmarks are presented. Both interprocedural register allocators find a significant improvement on benchmark doduc, as this benchmark has procedures with many registers live across calls. <p> Benchmark xlisp has many routines at the bottom of the call graph called less frequently than routines higher in the call graph. With a bottom-up allocation, registers are spilled across the more frequently executed calls. Steenkiste and Hennessy <ref> [SH89] </ref> note that a better in-terprocedural register allocation can be generated by adding register spills in infrequently executed procedures in the bottom of the call graph and then performing a bottom-up allocation assuming these routines are allocated zero registers. benchmark procedures candidates % of compilation time floating-point integer floating-point integer compress
Reference: [SO90] <author> Vatsa Santhanam and Daryl Odnert. </author> <title> Register allocation across procedure and module boundaries. </title> <booktitle> In Proceedings of SIGPLAN '90 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 28-39, </pages> <month> June </month> <year> 1990. </year>
Reference-contexts: When the registers are exhausted, they switch to an intraprocedu-ral allocation. This approach may introduce register spilling around calls in frequently executed procedures near the top of a call graph. The approach we propose avoids register spilling across frequently executed calls. Santhanam and Odnert <ref> [SO90] </ref> perform interprocedural register allocation over clusters of frequently executed procedures. Their heuristic aims to move spill code to the root node of a cluster.
Reference: [Sta93] <author> Richard M. Stallman. </author> <title> Using and Porting GNU CC. Free Software Foundation, </title> <month> October </month> <year> 1993. </year>
Reference-contexts: To accurately determine the number of references to registers that can be live across a call, we modified gcc <ref> [Sta93] </ref> to return the number of register references assuming the non-work registers are callee-save. We let the general-purpose registers that are non-work registers represent candidates in our interprocedural register allocation algorithm, and their number of register references scaled using profile information represents the candidates' weight.
Reference: [Wal86] <author> David W. Wall. </author> <title> Global register allocation at link-time. </title> <booktitle> In Proceedings of SIGPLAN '86 Symposium on Compiler Construction, </booktitle> <pages> pages 264-275, </pages> <month> July </month> <year> 1986. </year>
Reference-contexts: This allows the allocator to pass additional parameters in registers as well as to choose which registers to use (the registers selected need not always be caller-save). 2 Related Work Past interprocedural register allocators have relied on heuristics. Wall <ref> [Wal86] </ref> observes that two procedures that are not simultaneously active can share the same registers for their locals. With this in mind, Wall groups locals that can be 1 Cameron refers to the dual minimum cost flow problem as a dual transportation system of linear inequalities.
Reference: [Zak95] <author> Armand Zakarian. </author> <type> Private communication. </type> <institution> University of Wisconsin|Madison, </institution> <month> February </month> <year> 1995. </year>
Reference-contexts: To solve the dual minimum cost flow problem for in-terprocedural register allocation with spills, the problem is transformed into a minimum cost flow problem. Solutions to the minimum cost flow problem are found using the primal network simplex method <ref> [Zak95] </ref>. Though the primal network simplex method is exponential in the worst case, we found it faster in practice than a polynomial time dual network simplex algorithm available to us.
References-found: 14

