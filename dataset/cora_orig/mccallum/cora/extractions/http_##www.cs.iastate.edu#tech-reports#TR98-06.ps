URL: http://www.cs.iastate.edu/tech-reports/TR98-06.ps
Refering-URL: http://www.cs.iastate.edu/tech-reports/catalog.html
Root-URL: http://www.cs.iastate.edu
Title: Preliminary Design of JML: A Behavioral Interface Specification Language for Java languages, theory, Larch, Eiffel,
Author: Gary T. Leavens, Albert L. Baker and Clyde Ruby Gary T. Leavens, Albert L. Baker and Clyde Ruby. 
Keyword: Behavioral interface specification, Java, JML, Eiffel, Larch, model-based specification, precondition, postcondition, frame.  
Address: 226 Atanasoff Hall  Ames, Iowa 50011-1040, USA  
Affiliation: Department of Computer Science  Iowa State University  
Note: TR #98-06 June 1998  1996 CR Categories: D.2.1 [Software Engineering] Requirements/Specifications  Copyright c 1998 by  
Abstract-found: 0
Intro-found: 1
Reference: [AG98] <author> Ken Arnold and James Gosling. </author> <title> The Java Programming Language. The Java Series. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, MA, </address> <note> second edition, </note> <year> 1998. </year>
Reference-contexts: 1 Introduction JML stands for "Java Modeling Language." JML is a behavioral interface specification language (BISL) [Win87] designed to specify Java <ref> [AG98, GJS96] </ref> modules. Java modules are classes and interfaces. The main goal of the research presented in this paper is to better understand how to make BISLs (and BISL tools) that are practical and effective for Rockwell and similar production software environments.
Reference: [BMR95] <author> Alex Borgida, John Mylopoulos, and Rayomnd Reiter. </author> <title> On the frame problem in procedure specifications. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 21(10) </volume> <pages> 785-798, </pages> <month> October </month> <year> 1995. </year>
Reference-contexts: Following the initially clauses are the expected specifications of the pop, push, and top methods. The use of the modifiable clauses in the behavioral specifications of pop and push is interesting (and another difference from Eiffel). These give frame conditions <ref> [BMR95] </ref>, which say that no objects, other than those mentioned (and those on which these objects depend, as explained below) may have their values changed. 2 When the modifiable clause is omitted, as it is in the specification of top, this means that no objects can have their state modified by
Reference: [DL96] <author> Krishna Kishore Dhara and Gary T. Leavens. </author> <title> Forcing behavioral subtyping through specification inheritance. </title> <booktitle> In Proceedings of the 18th International Conference on Software Engineering, </booktitle> <address> Berlin, Germany, </address> <pages> pages 258-267. </pages> <publisher> IEEE Computer Society Press, </publisher> <month> March </month> <year> 1996. </year>
Reference-contexts: Note the recursive ensures clause for ReachSet, which builds up the entire set of reachable nodes by, for each recursive reference, adding the nodes that can be reached directly (via a single arc) from the nodes in nodeSet. 2.7 Subtyping Following Dhara and Leavens <ref> [DL96, Lea97] </ref>, a subtype inherits the specifications of its supertype's public and protected member functions, as well as invariants and history constraints.
Reference: [DL97] <author> Krishna Kishore Dhara and Gary T. Leavens. </author> <title> Forcing behavioral subtyp-ing through specification inheritance. </title> <type> Technical Report 95-20c, </type> <institution> Department of Computer Science, Iowa State University, Ames, Iowa, </institution> <month> 50011, December </month> <year> 1997. </year> <booktitle> Also in Proceedings of the 18th International Conference on Software Engineering, </booktitle> <address> Berlin, Germany, </address> <year> 1996, </year> <pages> pp. 258-267. </pages> <note> Available by anonymous ftp from ftp.cs.iastate.edu, and by e-mail from almanac@cs.iastate.edu. </note>
Reference-contexts: In the normal case, returns is true, whereas when an exception is thrown throws (BoundedStackException) is true. A specification with several cases is shorthand for one in which the cases are combined <ref> [DL97, Lea97, Win83, Wil94] </ref>. In Figure 6 we show the expanded specification of pop from that is a conjunction of implications, one for each case. The impliciation for a case in the expanded postcondition says that when the precondition for that case holds, the case's postcondition must also hold..
Reference: [Fin96] <author> Kate Finney. </author> <title> Mathematical notation in formal specification: </title> <journal> Too difficult for the masses? IEEE Transactions on Software Engineering, </journal> <volume> 22(2) </volume> <pages> 158-159, </pages> <month> February </month> <year> 1996. </year>
Reference-contexts: A preliminary study by Finney <ref> [Fin96] </ref> indicates that graphic mathematical notations, such as those found in Z [Hay93, Spi92] may make such specifications hard to read, even for programmers trained in the notation. This accords with our experience in teaching formal specification notations to programmers.
Reference: [GHG + 93] <author> John V. Guttag, James J. Horning, S.J. Garland, K.D. Jones, A. Modet, and J.M. Wing. </author> <title> Larch: Languages and Tools for Formal Specification. </title> <publisher> Springer-Verlag, </publisher> <address> New York, N.Y., </address> <year> 1993. </year>
Reference-contexts: We also have in mind a long rang goal of a specification compiler, that would produce prototypes from specifications, if they are constructive. As a general strategy for achieving these goals, we have tried to blend the Eiffel [Mey92a, Mey92b, Mey97] and Larch <ref> [Win87, Win90, GHG + 93, Lea98] </ref> approaches to specification. From Eiffel we have taken the idea that assertions can be written in a language that is based on Java expressions.
Reference: [GJS96] <author> James Gosling, Bill Joy, and Guy Steele. </author> <title> The Java Language Specification. The Java Series. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, MA, </address> <year> 1996. </year>
Reference-contexts: 1 Introduction JML stands for "Java Modeling Language." JML is a behavioral interface specification language (BISL) [Win87] designed to specify Java <ref> [AG98, GJS96] </ref> modules. Java modules are classes and interfaces. The main goal of the research presented in this paper is to better understand how to make BISLs (and BISL tools) that are practical and effective for Rockwell and similar production software environments.
Reference: [GL86] <author> David K. Gifford and John M. Lucassen. </author> <title> Integrating functional and imperative programming. </title> <booktitle> In ACM Conference on LISP and Functional Programming, </booktitle> <pages> pages 28-38. </pages> <publisher> ACM, </publisher> <month> August </month> <year> 1986. </year>
Reference-contexts: However, we hope to make more progress in this area. Since we are using Java expressions for predicates, there are some additional problems in mathematical modeling. We are excluding the possibility of side-effects by limiting the syntax of predicates, and by using type checking <ref> [GL86, Luc87, LG88, NNA97, TJ94, Wri92] </ref> to make sure that only pure methods may be called in predicates. Exceptions in expressions are particularly important, since they may arise in type casts.
Reference: [Hay93] <author> I. Hayes, </author> <title> editor. Specification Case Studies. </title> <booktitle> International Series in Computer Science. </booktitle> <publisher> Prentice-Hall, Inc., </publisher> <address> second edition, </address> <year> 1993. </year>
Reference-contexts: A preliminary study by Finney [Fin96] indicates that graphic mathematical notations, such as those found in Z <ref> [Hay93, Spi92] </ref> may make such specifications hard to read, even for programmers trained in the notation. This accords with our experience in teaching formal specification notations to programmers.
Reference: [Hoa69] <author> C. A. R. Hoare. </author> <title> An axiomatic basis for computer programming. </title> <journal> Communications of the ACM, </journal> <volume> 12(10) </volume> <pages> 576-583, </pages> <month> October </month> <year> 1969. </year>
Reference-contexts: The precondition says what must be true about the arguments (and other parts of the state); if the precondition is true, then the method must terminate in a state that satisfies the postcondition. This is a contract between the caller of the method and the implementor <ref> [Hoa69, Mey92a] </ref>. The caller is obligated to make the precondition true, and gets the benefit of having the postcondition then be satisfied. The implementor gets the benefit of being able to assume the precondition, and is obligated to make the postcondition true in that case.
Reference: [Hoa72] <author> C. A. R. Hoare. </author> <title> Proof of correctness of data representations. </title> <journal> Acta Informat-ica, </journal> <volume> 1(4) </volume> <pages> 271-281, </pages> <year> 1972. </year>
Reference-contexts: represents clause gives additional facts that can be used in reasoning about the specification; in essence it tells how to extract the value of size from the value of theStack. 4 It serves the same purpose as an abstraction function in various proof methods for abstract data types (such as <ref> [Hoa72] </ref>). The invariant that follows the represents clause in Figure 5 is our first example of checkable redundancy in a specification [LB97, Tan94, Tan95]. This concept is signaled in JML by the use of the keyword redundantly. <p> allow one to abbreviate long expressions, or, to make rhetorical points by naming constants, as is done with epsilon. 2.4 Implementation of Class and Interface Specifications The key to proofs that an implementation of a class or interface specification is correct lies in the use of depends and represents clauses <ref> [Hoa72, Lei95b] </ref>. Consider, for example, the abstract class MoneyAC given in Figure 11. It declares a concrete instance variable numCents, which is related to the specification-only instance variable pennies by the represents clause.
Reference: [Jon90] <author> Cliff B. Jones. </author> <title> Systematic Software Development Using VDM. </title> <booktitle> International Series in Computer Science. </booktitle> <publisher> Prentice Hall, </publisher> <address> Englewood Cliffs, N.J., </address> <note> second edition, 1990. 30 </note>
Reference-contexts: We also use the old notation from Eiffel, as described below, instead of the Larch style annotation of names with state functions. However, Eiffel specifications, as written by Meyer, are typically not as detailed as model-based specifications written, for example, in Larch BISLs or VDM <ref> [Jon90] </ref>. Hence, we have combined these approaches, by using syntactic ideas from Eiffel and semantic ideas from model-based specification languages. JML also has some other differences from Eiffel. The most important is the concept of specification-only declarations.
Reference: [LB97] <author> Gary T. Leavens and Albert L. Baker. </author> <title> Enhancing the pre- and postcondition technique for more expressive specifications. </title> <type> Technical Report 97-19, </type> <institution> Iowa State University, Department of Computer Science, </institution> <month> September </month> <year> 1997. </year>
Reference-contexts: The invariant that follows the represents clause in Figure 5 is our first example of checkable redundancy in a specification <ref> [LB97, Tan94, Tan95] </ref>. This concept is signaled in JML by the use of the keyword redundantly. It says both that the stated property is specified to hold and that this property is believed to follow from the other properties of the specification. <p> This interface has a history constraint, which says that the number of pennies in an object cannot change. 6 The interesting aspect of the operations is another kind of redundancy, given by the example clauses <ref> [Lea96, LB97] </ref>. Any number of examples can be given for a specification case. Here there are two examples in the specification of dollars and one in the specification of cents.
Reference: [Lea96] <author> Gary T. Leavens. </author> <title> An overview of Larch/C++: Behavioral specifications for C++ modules. </title> <editor> In Haim Kilov and William Harvey, editors, </editor> <booktitle> Specification of Behavioral Semantics in Object-Oriented Information Modeling, chapter 8, </booktitle> <pages> pages 121-142. </pages> <publisher> Kluwer Academic Publishers, </publisher> <address> Boston, </address> <year> 1996. </year> <note> An extended version is TR #96-01d, </note> <institution> Department of Computer Science, Iowa State University, Ames, Iowa, </institution> <month> 50011. </month>
Reference-contexts: This interface has a history constraint, which says that the number of pennies in an object cannot change. 6 The interesting aspect of the operations is another kind of redundancy, given by the example clauses <ref> [Lea96, LB97] </ref>. Any number of examples can be given for a specification case. Here there are two examples in the specification of dollars and one in the specification of cents. <p> This interface is given in Figure 8. It says that objects should have equals and clone methods. The specification of JMLType is noteworthy in its use of informal predicates <ref> [Lea96] </ref>. In this instance, the informal predicates are used as an escape from formality. The use of informal predicates avoids the delicate issues of saying what observable aliasing means, and what equality of values means. As specified in Figure 7, the type Money lacks some useful operations. <p> The second constructor in Figure 13 is noteworthy in that there is a redundant ensures clauses that uses an informal predicate <ref> [Lea96] </ref>. In this instance, the informal predicate is used as a comment (which could also be used).
Reference: [Lea97] <author> Gary T. Leavens. </author> <note> Larch/C++ Reference Manual. Version 5.14. Available in ftp://ftp.cs.iastate.edu/pub/larchc++/lcpp.ps.gz or on the World Wide Web at the URL http://www.cs.iastate.edu/~leavens/larchc++.html, Octo-ber 1997. </note>
Reference-contexts: Because they describe interface details for clients written in a specific programming language, BISLs are inherently language-specific [Win87]. For example, a BISL tailored to C++, such as Larch/C++ <ref> [Lea97] </ref>, would describe how to use a module in a C++ program. A Larch/C++ specification cannot be implemented correctly in Java, and a JML specification cannot be correctly implemented in C++ (except for functions that are specified as native code). <p> In the normal case, returns is true, whereas when an exception is thrown throws (BoundedStackException) is true. A specification with several cases is shorthand for one in which the cases are combined <ref> [DL97, Lea97, Win83, Wil94] </ref>. In Figure 6 we show the expanded specification of pop from that is a conjunction of implications, one for each case. The impliciation for a case in the expanded postcondition says that when the precondition for that case holds, the case's postcondition must also hold.. <p> Note the recursive ensures clause for ReachSet, which builds up the entire set of reachable nodes by, for each recursive reference, adding the nodes that can be reached directly (via a single arc) from the nodes in nodeSet. 2.7 Subtyping Following Dhara and Leavens <ref> [DL96, Lea97] </ref>, a subtype inherits the specifications of its supertype's public and protected member functions, as well as invariants and history constraints.
Reference: [Lea98] <author> Gary T. Leavens. </author> <title> Larch frequently asked questions. </title> <note> Version 1.89. Available in http://www.cs.iastate.edu/~leavens/larch-faq.html, January 1998. </note>
Reference-contexts: We also have in mind a long rang goal of a specification compiler, that would produce prototypes from specifications, if they are constructive. As a general strategy for achieving these goals, we have tried to blend the Eiffel [Mey92a, Mey92b, Mey97] and Larch <ref> [Win87, Win90, GHG + 93, Lea98] </ref> approaches to specification. From Eiffel we have taken the idea that assertions can be written in a language that is based on Java expressions.
Reference: [Lei95a] <author> K. Rustan M. Leino. </author> <title> A myth in the modular specification of programs. </title> <type> Technical Report KRML 63, </type> <institution> Digital Equipment Corporation, Systems Research Center, </institution> <address> 130 Lytton Avenue Palo Alto, CA 94301, </address> <month> November </month> <year> 1995. </year> <title> Obtain from the author, </title> <note> at rustan@pa.dec.com. </note>
Reference-contexts: Our interpretation of this is very strict, even benevolent side effects are disallowed if the modifiable clause is omitted <ref> [Lei95b, Lei95a] </ref>. When a method can modify some objects, these objects have different values in the pre-state and post-state of that method. Often the post-condition must refer to both of them. This is where Eiffel's old notation is used, to refer to the pre-state value of a variable. <p> The depends clause is important in "loosening up" the modifiable clause, for example to permit the fields of an object that implement the abstract model to be changed <ref> [Lei95b, Lei95a] </ref>. This "loosening up" also applies to model variables that have dependencies declared. For example, since size depends on theStack, i.e., size is in some sense represented by theStack, if size is mentioned in a modifiable clause, then theStack is implicitly allowed to be modified.
Reference: [Lei95b] <author> K. Rustan M. Leino. </author> <title> Toward Reliable Modular Programs. </title> <type> PhD thesis, </type> <institution> Cali-fornia Institute of Technology, </institution> <year> 1995. </year> <note> Available as Technical Report Caltech-CS-TR-95-03. </note>
Reference-contexts: Our interpretation of this is very strict, even benevolent side effects are disallowed if the modifiable clause is omitted <ref> [Lei95b, Lei95a] </ref>. When a method can modify some objects, these objects have different values in the pre-state and post-state of that method. Often the post-condition must refer to both of them. This is where Eiffel's old notation is used, to refer to the pre-state value of a variable. <p> The depends clause is important in "loosening up" the modifiable clause, for example to permit the fields of an object that implement the abstract model to be changed <ref> [Lei95b, Lei95a] </ref>. This "loosening up" also applies to model variables that have dependencies declared. For example, since size depends on theStack, i.e., size is in some sense represented by theStack, if size is mentioned in a modifiable clause, then theStack is implicitly allowed to be modified. <p> allow one to abbreviate long expressions, or, to make rhetorical points by naming constants, as is done with epsilon. 2.4 Implementation of Class and Interface Specifications The key to proofs that an implementation of a class or interface specification is correct lies in the use of depends and represents clauses <ref> [Hoa72, Lei95b] </ref>. Consider, for example, the abstract class MoneyAC given in Figure 11. It declares a concrete instance variable numCents, which is related to the specification-only instance variable pennies by the represents clause.
Reference: [Ler91] <author> Richard Allen Lerner. </author> <title> Specifying objects of concurrent systems. </title> <type> Ph.D. Thesis CMU-CS-91-131, </type> <institution> School of Computer Science, Carnegie Mellon University, </institution> <month> May </month> <year> 1991. </year>
Reference-contexts: This means that they can be ignored during mathematical modeling. When executing predicates, errors will also be ignored, but will cause run time errors. 4 Concurrency For concurrency our plan is to use when clauses that say when a method may proceed to execute, after it is called <ref> [Ler91, Siv95] </ref>. This permits the specification of when the caller is delayed to obtain a lock, for example. While syntax for this exists in the JML parser, our exploration of this topic is still in an early stage.
Reference: [LG88] <author> John M. Lucassen and David K. Gifford. </author> <title> Polymorphic effect systems. </title> <booktitle> In Conference Record of the Fifteenth Annual ACM Symposium on Principles of Programming Languages, </booktitle> <address> San Diego, Calif., </address> <pages> pages 47-57. </pages> <publisher> ACM, </publisher> <month> January </month> <year> 1988. </year>
Reference-contexts: However, we hope to make more progress in this area. Since we are using Java expressions for predicates, there are some additional problems in mathematical modeling. We are excluding the possibility of side-effects by limiting the syntax of predicates, and by using type checking <ref> [GL86, Luc87, LG88, NNA97, TJ94, Wri92] </ref> to make sure that only pure methods may be called in predicates. Exceptions in expressions are particularly important, since they may arise in type casts.
Reference: [LH94] <author> K. Lano and H. Haughton, </author> <title> editors. Object-Oriented Specification Case Studies. The Object-Oriented Series. </title> <publisher> Prentice Hall, </publisher> <address> New York, N.Y., </address> <year> 1994. </year>
Reference: [Luc87] <author> John M. Lucassen. </author> <title> Types and effects: Towards the integration of functional and imperative programming. </title> <type> Technical Report TR-408, </type> <institution> Massachusetts Institute of Technology, Laboratory for Computer Science, </institution> <month> August </month> <year> 1987. </year>
Reference-contexts: However, we hope to make more progress in this area. Since we are using Java expressions for predicates, there are some additional problems in mathematical modeling. We are excluding the possibility of side-effects by limiting the syntax of predicates, and by using type checking <ref> [GL86, Luc87, LG88, NNA97, TJ94, Wri92] </ref> to make sure that only pure methods may be called in predicates. Exceptions in expressions are particularly important, since they may arise in type casts.
Reference: [LvHKBO87] <author> David Luckham, Friedrich W. von Henke, Bernd Krieg-Bruckner, and Olaf Owe. </author> <title> ANNA A Language for Annotating Ada Programs, </title> <booktitle> volume 260 of Lecture Notes in Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <address> New York, N.Y., </address> <year> 1987. </year>
Reference-contexts: A Larch/C++ specification cannot be implemented correctly in Java, and a JML specification cannot be correctly implemented in C++ (except for functions that are specified as native code). Specifications written in JML are designed to be annotations in Java code files <ref> [Tan94, Tan95, LvHKBO87] </ref>. To a Java compiler, such annotations are comments that are ignored, This allows JML specifications, such as the specification in Figure 1, to be embedded in Java code files.
Reference: [LW94] <author> Barbara Liskov and Jeannette Wing. </author> <title> A behavioral notion of subtyping. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 16(6) </volume> <pages> 1811-1841, </pages> <month> November </month> <year> 1994. </year> <month> 31 </month>
Reference-contexts: The figure's invariant says that in every visible state, the MAX SIZE variable has to be positive, and that every reachable object that is a BoundedThing must have a size field that has a value less than or equal to MAX SIZE. Following the invariant is a history constraint <ref> [LW94] </ref>. A history constraint is used to say how values can change between earlier and later states, such as a method's pre-state and its post-state. This prohibits subtypes from making certain state changes, even if they implement more methods than are specified in a given class.
Reference: [LW97] <author> Gary T. Leavens and Jeannette M. Wing. </author> <title> Protective interface specifica-tions. </title> <editor> In Michel Bidoit and Max Dauchet, editors, </editor> <booktitle> TAPSOFT '97: Theory and Practice of Software Development, 7th International Joint Conference CAAP/FASE, Lille, France, volume 1214 of Lecture Notes in Computer Science, </booktitle> <pages> pages 520-534. </pages> <publisher> Springer-Verlag, </publisher> <address> New York, N.Y., </address> <year> 1997. </year>
Reference-contexts: Note the use of the cast in the postcondition of clone, which is necessary, since the type of result is Object. (This also adheres to our goal of using Java syntax and semantics to the extent possible.) Note also that the conjunct result instanceof BoundedThing "protects" the next conjunct <ref> [LW97] </ref> since if it is false the meaning of the cast does not matter.
Reference: [Mey92a] <author> Bertrand Meyer. </author> <title> Applying "design by contract". </title> <journal> Computer, </journal> <volume> 25(10) </volume> <pages> 40-51, </pages> <month> October </month> <year> 1992. </year>
Reference-contexts: The precondition says what must be true about the arguments (and other parts of the state); if the precondition is true, then the method must terminate in a state that satisfies the postcondition. This is a contract between the caller of the method and the implementor <ref> [Hoa69, Mey92a] </ref>. The caller is obligated to make the precondition true, and gets the benefit of having the postcondition then be satisfied. The implementor gets the benefit of being able to assume the precondition, and is obligated to make the postcondition true in that case. <p> We also have in mind a long rang goal of a specification compiler, that would produce prototypes from specifications, if they are constructive. As a general strategy for achieving these goals, we have tried to blend the Eiffel <ref> [Mey92a, Mey92b, Mey97] </ref> and Larch [Win87, Win90, GHG + 93, Lea98] approaches to specification. From Eiffel we have taken the idea that assertions can be written in a language that is based on Java expressions.
Reference: [Mey92b] <author> Bertrand Meyer. </author> <title> Eiffel: The Language. Object-Oriented Series. </title> <publisher> Prentice Hall, </publisher> <address> New York, N.Y., </address> <year> 1992. </year>
Reference-contexts: We also have in mind a long rang goal of a specification compiler, that would produce prototypes from specifications, if they are constructive. As a general strategy for achieving these goals, we have tried to blend the Eiffel <ref> [Mey92a, Mey92b, Mey97] </ref> and Larch [Win87, Win90, GHG + 93, Lea98] approaches to specification. From Eiffel we have taken the idea that assertions can be written in a language that is based on Java expressions.
Reference: [Mey97] <author> Bertrand Meyer. </author> <title> Object-oriented Software Construction. </title> <publisher> Prentice Hall, </publisher> <address> New York, N.Y., </address> <note> second edition, </note> <year> 1997. </year>
Reference-contexts: We also have in mind a long rang goal of a specification compiler, that would produce prototypes from specifications, if they are constructive. As a general strategy for achieving these goals, we have tried to blend the Eiffel <ref> [Mey92a, Mey92b, Mey97] </ref> and Larch [Win87, Win90, GHG + 93, Lea98] approaches to specification. From Eiffel we have taken the idea that assertions can be written in a language that is based on Java expressions. <p> For a redundant ensures clause, what one checks is that the conjunction of the precondition, the meaning of the modifiable clause, and the (non-redundant) postcondition itself imply the redundant postcondition. It is interesting to note that the specifications for stacks written in Eiffel <ref> [Mey97, page 339] </ref> expresses not much more than what we specify in the redundant postconditions of pop and push. <p> Meyer's second specification and implementation of stacks <ref> [Mey97, page 349] </ref> is no better in this respect, although, of course, the implementation does keep track of the elements properly. 12 The extension mechanism uses the modifier pure, as in Figure 7.
Reference: [NNA97] <author> H. R. Nielson, F. Nielson, and T. Amtoft. </author> <title> Polymorphic subtyping for effect analysis: The static semantics. </title> <editor> In M. Dam, editor, </editor> <booktitle> Proceedings of the Fifth LOMAPS Workshop, number 1192 in Lecture Notes in Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1997. </year>
Reference-contexts: However, we hope to make more progress in this area. Since we are using Java expressions for predicates, there are some additional problems in mathematical modeling. We are excluding the possibility of side-effects by limiting the syntax of predicates, and by using type checking <ref> [GL86, Luc87, LG88, NNA97, TJ94, Wri92] </ref> to make sure that only pure methods may be called in predicates. Exceptions in expressions are particularly important, since they may arise in type casts.
Reference: [OSWZ94] <author> William F. Ogden, Murali Sitaraman, Bruce W. Weide, and Stuart H. </author> <title> Zweben. Part I: The RESOLVE framework and discipline | a research synopsis. </title> <booktitle> ACM SIGSOFT Software Engineering Notes, </booktitle> <volume> 19(4) </volume> <pages> 23-28, </pages> <month> Oct </month> <year> 1994. </year>
Reference-contexts: (x)); //@ - public abstract Object top ( ); //@ behavior - //@ requires !theStack.isEmpty (); //@ ensures result == theStack.first (); //@ - 6 Following the declaration of the model variable, above the specification of pop in Fig--ure 3, is an initially clause. (Such clauses are adapted from Resolve <ref> [OSWZ94] </ref>.) This clause is declared public, since it refers to a public model variable. An initially clause permits data type induction ([Hoa72, Win83]) for abstract classes and interfaces, by supplying a property that must appear to be true of the starting states of objects.
Reference: [PH97] <author> Arnd Poetzsch-Heffter. </author> <title> Specification and Verification of Object-Oriented Programs. </title> <type> PhD thesis, </type> <institution> Technische Universitat Munchen, </institution> <year> 1997. </year> <month> (Habilitationss-chrift). </month>
Reference-contexts: We avoid this problem, following Poetzsch-Heffter <ref> [PH97] </ref> by releasing implementations from their obligations to fulfill the postcondition when Java runs out of storage.
Reference: [Siv95] <author> Gowri Sivaprasad. Larch/CORBA: </author> <title> Specifying the behavior of CORBA-IDL interfaces. </title> <type> Technical Report 95-27a, </type> <institution> Department of Computer Science, Iowa State University, Ames, Iowa, </institution> <month> 50011, December </month> <year> 1995. </year>
Reference-contexts: This means that they can be ignored during mathematical modeling. When executing predicates, errors will also be ignored, but will cause run time errors. 4 Concurrency For concurrency our plan is to use when clauses that say when a method may proceed to execute, after it is called <ref> [Ler91, Siv95] </ref>. This permits the specification of when the caller is delayed to obtain a lock, for example. While syntax for this exists in the JML parser, our exploration of this topic is still in an early stage.
Reference: [Spi92] <author> J. Michael Spivey. </author> <title> The Z Notation: A Reference Manual. </title> <booktitle> International Series in Computer Science. </booktitle> <publisher> Prentice-Hall, </publisher> <address> New York, N.Y., </address> <note> second edition, </note> <year> 1992. </year>
Reference-contexts: A preliminary study by Finney [Fin96] indicates that graphic mathematical notations, such as those found in Z <ref> [Hay93, Spi92] </ref> may make such specifications hard to read, even for programmers trained in the notation. This accords with our experience in teaching formal specification notations to programmers.
Reference: [Tan94] <author> Yang Meng Tan. </author> <title> Interface language for supporting programming styles. </title> <journal> ACM SIGPLAN Notices, </journal> <volume> 29(8) </volume> <pages> 74-83, </pages> <month> August </month> <year> 1994. </year> <booktitle> Proceedings of the Workshop on Interface Definition Languages. </booktitle>
Reference-contexts: A Larch/C++ specification cannot be implemented correctly in Java, and a JML specification cannot be correctly implemented in C++ (except for functions that are specified as native code). Specifications written in JML are designed to be annotations in Java code files <ref> [Tan94, Tan95, LvHKBO87] </ref>. To a Java compiler, such annotations are comments that are ignored, This allows JML specifications, such as the specification in Figure 1, to be embedded in Java code files. <p> The invariant that follows the represents clause in Figure 5 is our first example of checkable redundancy in a specification <ref> [LB97, Tan94, Tan95] </ref>. This concept is signaled in JML by the use of the keyword redundantly. It says both that the stated property is specified to hold and that this property is believed to follow from the other properties of the specification.
Reference: [Tan95] <author> Yang Meng Tan. </author> <title> Formal Specification Techniques for Engineering Modular C Programs, </title> <booktitle> volume 1 of Kluwer International Series in Software Engineering. </booktitle> <publisher> Kluwer Academic Publishers, </publisher> <address> Boston, </address> <year> 1995. </year>
Reference-contexts: A Larch/C++ specification cannot be implemented correctly in Java, and a JML specification cannot be correctly implemented in C++ (except for functions that are specified as native code). Specifications written in JML are designed to be annotations in Java code files <ref> [Tan94, Tan95, LvHKBO87] </ref>. To a Java compiler, such annotations are comments that are ignored, This allows JML specifications, such as the specification in Figure 1, to be embedded in Java code files. <p> The invariant that follows the represents clause in Figure 5 is our first example of checkable redundancy in a specification <ref> [LB97, Tan94, Tan95] </ref>. This concept is signaled in JML by the use of the keyword redundantly. It says both that the stated property is specified to hold and that this property is believed to follow from the other properties of the specification.
Reference: [TJ94] <author> Jean-Pierre Talpin and Pierre Jouvelot. </author> <title> The type and effect discipline. </title> <journal> Information and Computation, </journal> <volume> 111(2) </volume> <pages> 245-296, </pages> <month> June </month> <year> 1994. </year>
Reference-contexts: However, we hope to make more progress in this area. Since we are using Java expressions for predicates, there are some additional problems in mathematical modeling. We are excluding the possibility of side-effects by limiting the syntax of predicates, and by using type checking <ref> [GL86, Luc87, LG88, NNA97, TJ94, Wri92] </ref> to make sure that only pure methods may be called in predicates. Exceptions in expressions are particularly important, since they may arise in type casts.
Reference: [Wil94] <author> Alan Wills. </author> <booktitle> Refinement in Fresco. In Lano and Houghton [LH94], chapter 9, </booktitle> <pages> pages 184-201. </pages>
Reference-contexts: In the normal case, returns is true, whereas when an exception is thrown throws (BoundedStackException) is true. A specification with several cases is shorthand for one in which the cases are combined <ref> [DL97, Lea97, Win83, Wil94] </ref>. In Figure 6 we show the expanded specification of pop from that is a conjunction of implications, one for each case. The impliciation for a case in the expanded postcondition says that when the precondition for that case holds, the case's postcondition must also hold..
Reference: [Win83] <author> Jeannette Marie Wing. </author> <title> A two-tiered approach to specifying programs. </title> <type> Technical Report TR-299, </type> <institution> Massachusetts Institute of Technology, Laboratory for Computer Science, </institution> <year> 1983. </year> <month> 32 </month>
Reference-contexts: In the normal case, returns is true, whereas when an exception is thrown throws (BoundedStackException) is true. A specification with several cases is shorthand for one in which the cases are combined <ref> [DL97, Lea97, Win83, Wil94] </ref>. In Figure 6 we show the expanded specification of pop from that is a conjunction of implications, one for each case. The impliciation for a case in the expanded postcondition says that when the precondition for that case holds, the case's postcondition must also hold..
Reference: [Win87] <author> Jeannette M. Wing. </author> <title> Writing Larch interface language specifications. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 9(1) </volume> <pages> 1-24, </pages> <month> January </month> <year> 1987. </year>
Reference-contexts: 1 Introduction JML stands for "Java Modeling Language." JML is a behavioral interface specification language (BISL) <ref> [Win87] </ref> designed to specify Java [AG98, GJS96] modules. Java modules are classes and interfaces. The main goal of the research presented in this paper is to better understand how to make BISLs (and BISL tools) that are practical and effective for Rockwell and similar production software environments. <p> Because they describe interface details for clients written in a specific programming language, BISLs are inherently language-specific <ref> [Win87] </ref>. For example, a BISL tailored to C++, such as Larch/C++ [Lea97], would describe how to use a module in a C++ program. <p> We also have in mind a long rang goal of a specification compiler, that would produce prototypes from specifications, if they are constructive. As a general strategy for achieving these goals, we have tried to blend the Eiffel [Mey92a, Mey92b, Mey97] and Larch <ref> [Win87, Win90, GHG + 93, Lea98] </ref> approaches to specification. From Eiffel we have taken the idea that assertions can be written in a language that is based on Java expressions. <p> We hope that this similarity will make the specification language easier to understand. (This kind of model also has technical advantages that will be described below.) In the Larch approach to behavioral interface specification <ref> [Win87] </ref>, the mathematical notation used in assertions is presented directly to the user. This allows the same mathematical notation to be used in many different specification languages.
Reference: [Win90] <author> Jeannette M. Wing. </author> <title> A specifier's introduction to formal methods. </title> <journal> Computer, </journal> <volume> 23(9) </volume> <pages> 8-24, </pages> <month> September </month> <year> 1990. </year>
Reference-contexts: We also have in mind a long rang goal of a specification compiler, that would produce prototypes from specifications, if they are constructive. As a general strategy for achieving these goals, we have tried to blend the Eiffel [Mey92a, Mey92b, Mey97] and Larch <ref> [Win87, Win90, GHG + 93, Lea98] </ref> approaches to specification. From Eiffel we have taken the idea that assertions can be written in a language that is based on Java expressions.
Reference: [Wri92] <author> Andrew K. Wright. </author> <title> Typing references by effect inference. </title> <editor> In Bernd Krieg-Bruckner, editor, </editor> <booktitle> ESOP '92, 4th European Symposium on Programming, Rennes, </booktitle> <address> France, </address> <month> February </month> <year> 1992, </year> <booktitle> Proceedings, volume 582 of Lecture Notes in Computer Science, </booktitle> <pages> pages 473-491. </pages> <publisher> Springer-Verlag, </publisher> <address> New York, N.Y., </address> <year> 1992. </year>
Reference-contexts: However, we hope to make more progress in this area. Since we are using Java expressions for predicates, there are some additional problems in mathematical modeling. We are excluding the possibility of side-effects by limiting the syntax of predicates, and by using type checking <ref> [GL86, Luc87, LG88, NNA97, TJ94, Wri92] </ref> to make sure that only pure methods may be called in predicates. Exceptions in expressions are particularly important, since they may arise in type casts.
References-found: 41

