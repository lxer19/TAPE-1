URL: http://www.research.digital.com/SRC/personal/Martin_Abadi/Papers/fullpaper-revised.ps
Refering-URL: http://www.research.digital.com/SRC/personal/Martin_Abadi/allpapers.html
Root-URL: http://www.research.digital.com
Email: lamping@parc.xerox.com  ma@src.dec.com  
Phone: 2  
Title: Methods as Assertions  
Author: John Lamping Martin Abadi 
Address: 3333 Coyote Hill Road, Palo Alto CA 94304, USA  130 Lytton Avenue, Palo Alto, CA 94301, USA  
Affiliation: 1 Xerox PARC  Digital Equipment Corporation Systems Research Center  
Abstract: A method definition can be viewed as a logical assertion. Whenever we declare a method as the implementation of an operation, we assert that if the operation is invoked on objects of the appropriate types then the method body will satisfy the specification of the operation. This view of methods as assertions is simple but general. Among its applications are: methods defined on interfaces as well as on classes; an elementary type system for objects that handles multi-methods; and a mechanism for method dispatch based on the desired output type as well as on the types of arguments. Further, these applications are compatible with traditional execution models and implementation techniques. Logical reasoning about methods plays a role at compile time, then gets out of the way. 
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> Agrawal, R., DeMichiel, L. G., and Lindsay, B. G. </author> <title> Static type checking of multi-methods. </title> <booktitle> In Proceedings of the Conference on Object-Oriented Programming Systems, Languages, and Applications (1991), ACM. Also published in SIGPLAN Notices, 16(11) (1991), </booktitle> <pages> pp. 113-128. </pages>
Reference-contexts: In contrast, various logic programming approaches to objects [2, 13, 16] have focused on using logical inference at the basis of program execution. In contrast, also, Agrawal et al. <ref> [1] </ref> discuss reasoning about method applicability but do not use the reasoning for deciding applicability. 5 The idea of treating method declarations as assertions can be seen as an instance, in the domain of objects, of the open-semantics ideas proposed by Dixon [11], who treats procedure declarations as assertions.
Reference: 2. <author> Andreoli, J.-M., and Pareschi, R. </author> <title> Linear objects: logical processes with built-in inheritance. </title> <booktitle> In Proceedings of the Seventh International Conference on Logic Programming (1990), </booktitle> <editor> D. H. D. Warren and P. Szeredi, Eds., </editor> <publisher> MIT Press, </publisher> <pages> pp. 495-510. </pages>
Reference-contexts: In fact, a pre-processor could examine required interfaces, determine what methods are applicable for various classes, and add explicit method declarations to those classes. In contrast, various logic programming approaches to objects <ref> [2, 13, 16] </ref> have focused on using logical inference at the basis of program execution.
Reference: 3. <author> Bobrow, D. G., DeMichiel, L. G., Gabriel, R. P., Keene, S. E., Kiczales, G., and Moon, D. A. </author> <title> Common Lisp object system specification. </title> <journal> Sigplan Notices 23, </journal> <note> Special Issue (1988). </note>
Reference-contexts: Multiple dispatch is supported rather naturally: the classes of several arguments can be used as indices to select among the operation's methods. This "operation view" meshes with the implementation techniques of programming languages like CLOS <ref> [3] </ref> and Cecil [9], and with the account of object oriented programming in terms of the &-calculus [8]. Each view takes either operations or classes as primitive, and the other as defined in terms of the primitive concept. Dispatch on the primitive concept yields an efficient execution model.
Reference: 4. <author> Bobrow, D. G., Gabriel, R. P., and White, J. L. </author> <title> CLOS in context: the shape of the design space. In Object Oriented Programming: The CLOS Perspective, </title> <editor> A. Paepcke, Ed. </editor> <publisher> MIT Press, </publisher> <year> 1993, </year> <pages> pp. 29-61. </pages>
Reference-contexts: For example, predicate classes [10] allow method applicability to depend on dynamic properties of objects; in the DROL language [18], method applicability may depend on how much time remains to complete a task. Bobrow et al. <ref> [4] </ref> sketch a number of such extensions, including the idea of letting method applicability depend on interfaces. The assertional view does not limit a priori what can affect method applicability, and hence it can encompass all these kinds of extensions.
Reference: 5. <author> Canning, P., Cook, W., Hill, W., Mitchell, J., and Olthoff, W. </author> <title> F-bounded quantification for object-oriented programming. </title> <booktitle> In Functional Programming and Computer Architecture (1989). </booktitle>
Reference-contexts: This "record view" of object oriented programming describes both the common implementation techniques of many languages, such as C++, and most efforts to explain objects in terms of formal systems (e.g., <ref> [5, 6, 7, 15] </ref>). An alternative view takes methods as belonging to operations, rather than to objects. An operation comes with a collection of methods, each of which implements the operation for different classes of argument.
Reference: 6. <author> Cardelli, L. </author> <title> A semantics of multiple inheritance. </title> <booktitle> Information and Computation, </booktitle> <month> 76 </month> <year> (1988). </year>
Reference-contexts: This "record view" of object oriented programming describes both the common implementation techniques of many languages, such as C++, and most efforts to explain objects in terms of formal systems (e.g., <ref> [5, 6, 7, 15] </ref>). An alternative view takes methods as belonging to operations, rather than to objects. An operation comes with a collection of methods, each of which implements the operation for different classes of argument.
Reference: 7. <author> Cardelli, L., and Wegner, P. </author> <title> On understanding types, data abstraction and polymorphism. </title> <journal> Computing Surveys 17, </journal> <month> 4 </month> <year> (1985). </year>
Reference-contexts: This "record view" of object oriented programming describes both the common implementation techniques of many languages, such as C++, and most efforts to explain objects in terms of formal systems (e.g., <ref> [5, 6, 7, 15] </ref>). An alternative view takes methods as belonging to operations, rather than to objects. An operation comes with a collection of methods, each of which implements the operation for different classes of argument.
Reference: 8. <author> Castagna, G., Ghelli, G., and Longo, G. </author> <title> A calculus for overloaded functions with subtyping. In ACM Conference on LISP and Functional Programming (1992). </title> <note> Full paper to appear in Information and Computation. </note>
Reference-contexts: This "operation view" meshes with the implementation techniques of programming languages like CLOS [3] and Cecil [9], and with the account of object oriented programming in terms of the &-calculus <ref> [8] </ref>. Each view takes either operations or classes as primitive, and the other as defined in terms of the primitive concept. Dispatch on the primitive concept yields an efficient execution model. The first view takes operations as primitive: they are just selectors with no further structure.
Reference: 9. <author> Chambers, C. </author> <title> The Cecil language: Specification and rationale. </title> <type> Tech. Rep. </type> <institution> 93-03-05, Department of Computer Science, University of Washington, </institution> <year> 1993. </year>
Reference-contexts: Multiple dispatch is supported rather naturally: the classes of several arguments can be used as indices to select among the operation's methods. This "operation view" meshes with the implementation techniques of programming languages like CLOS [3] and Cecil <ref> [9] </ref>, and with the account of object oriented programming in terms of the &-calculus [8]. Each view takes either operations or classes as primitive, and the other as defined in terms of the primitive concept. Dispatch on the primitive concept yields an efficient execution model.
Reference: 10. <author> Chambers, C. </author> <title> Predicate classes. </title> <booktitle> In Proceedings of the European Conference on Object-Oriented Programming (1993). </booktitle>
Reference-contexts: Traditional object oriented programming makes that link more flexible by allowing for several different methods that can implement an operation, each applicable to different classes of arguments. Several proposed extensions to object oriented programming allow additional features to affect method applicability. For example, predicate classes <ref> [10] </ref> allow method applicability to depend on dynamic properties of objects; in the DROL language [18], method applicability may depend on how much time remains to complete a task. Bobrow et al. [4] sketch a number of such extensions, including the idea of letting method applicability depend on interfaces.
Reference: 11. <author> Dixon, M. </author> <title> Embedded Computation and the Semantics of Programs. </title> <type> PhD thesis, </type> <institution> Stanford University, </institution> <year> 1991. </year> <note> Also published as Xerox PARC technical report SSL-91-1. </note>
Reference-contexts: In contrast, also, Agrawal et al. [1] discuss reasoning about method applicability but do not use the reasoning for deciding applicability. 5 The idea of treating method declarations as assertions can be seen as an instance, in the domain of objects, of the open-semantics ideas proposed by Dixon <ref> [11] </ref>, who treats procedure declarations as assertions. This approach recognizes that the programmer has an intended meaning for each operation.
Reference: 12. <author> Goldberg, A., and Robson, D. </author> <title> Smalltalk-80: The Language and its Implementation. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, MA, </address> <year> 1983. </year>
Reference-contexts: 1 Introduction An object is commonly characterized as a collection of data together with associated procedures, called methods. Each method implements an operation on the object; an operation may have other implementations for other objects. (Operations are called "messages" in Smalltalk <ref> [12] </ref> and "member functions" in C++ [17].) When an operation is invoked on an object, the corresponding method is executed. The method is found by using the name of the operation as an index to select among the object's methods.
Reference: 13. <author> Hodas, J. S., and Miller, D. </author> <title> Representing objects in a logic programming language with scoping constructs. </title> <booktitle> In Proceedings of the Seventh International Conference on Logic Programming (1990), </booktitle> <editor> D. H. D. Warren and P. Szeredi, Eds., </editor> <publisher> MIT Press, </publisher> <pages> pp. 511-526. </pages>
Reference-contexts: In fact, a pre-processor could examine required interfaces, determine what methods are applicable for various classes, and add explicit method declarations to those classes. In contrast, various logic programming approaches to objects <ref> [2, 13, 16] </ref> have focused on using logical inference at the basis of program execution.
Reference: 14. <author> Kiczales, G. </author> <title> Traces (a cut at the "make isn't generic" problem). </title> <booktitle> In Proceedings of International Symposium on Object Technologies for Advanced Software (1993), 26 S. </booktitle> <editor> Nishio and A. Yonezawa, Eds., JSST, </editor> <publisher> Springer-Verlag, </publisher> <pages> pp. 27-43. </pages> <note> Lecture Notes in Computer Science 742. </note>
Reference-contexts: However, it yields a point-impl, because the method calls new (point-impl) in the body. The output type, thus, will in general differ from the input type. This is a manifestation of what Kiczales has called the "make isn't generic problem" <ref> [14] </ref>. While the result of add is not of type p, it does support the get-x, get-y, set-x, set-y, and add operations, as a result of being a point-impl, so it does satisfy the interface expected of points.
Reference: 15. <author> Pierce, B. C., and Turner, D. </author> <title> Object oriented programming without recursive types. </title> <booktitle> In ACM Symposium on Principles of Programming Languages (1993). </booktitle>
Reference-contexts: This "record view" of object oriented programming describes both the common implementation techniques of many languages, such as C++, and most efforts to explain objects in terms of formal systems (e.g., <ref> [5, 6, 7, 15] </ref>). An alternative view takes methods as belonging to operations, rather than to objects. An operation comes with a collection of methods, each of which implements the operation for different classes of argument.
Reference: 16. <author> Shapiro, E., and Takeuchi, A. </author> <title> Object oriented programming in Concurrent Prolog. </title> <booktitle> New Generation Computing 1 (1983), </booktitle> <pages> 25-48. </pages>
Reference-contexts: In fact, a pre-processor could examine required interfaces, determine what methods are applicable for various classes, and add explicit method declarations to those classes. In contrast, various logic programming approaches to objects <ref> [2, 13, 16] </ref> have focused on using logical inference at the basis of program execution.
Reference: 17. <author> Stroustrup, B. </author> <title> The C++ Programming Language, Second Edition. </title> <publisher> Addison-Wesley, </publisher> <year> 1991. </year>
Reference-contexts: 1 Introduction An object is commonly characterized as a collection of data together with associated procedures, called methods. Each method implements an operation on the object; an operation may have other implementations for other objects. (Operations are called "messages" in Smalltalk [12] and "member functions" in C++ <ref> [17] </ref>.) When an operation is invoked on an object, the corresponding method is executed. The method is found by using the name of the operation as an index to select among the object's methods.
Reference: 18. <author> Takashio, K., and Tokoro, M. DROL: </author> <title> An object-oriented programming language for distributed real-time systems. </title> <booktitle> In Proceedings of the Conference on Object-Oriented Programming: Systems, Languages, and Applications (1992), </booktitle> <pages> pp. </pages> <month> 276-294. </month> <title> This article was processed using the L a T E X macro package with LLNCS style 27 </title>
Reference-contexts: Several proposed extensions to object oriented programming allow additional features to affect method applicability. For example, predicate classes [10] allow method applicability to depend on dynamic properties of objects; in the DROL language <ref> [18] </ref>, method applicability may depend on how much time remains to complete a task. Bobrow et al. [4] sketch a number of such extensions, including the idea of letting method applicability depend on interfaces.
References-found: 18

