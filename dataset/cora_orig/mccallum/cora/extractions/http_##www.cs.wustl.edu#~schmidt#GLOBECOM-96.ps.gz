URL: http://www.cs.wustl.edu/~schmidt/GLOBECOM-96.ps.gz
Refering-URL: http://www.cs.wustl.edu/~schmidt/events_tutorial.html
Root-URL: 
Email: gokhale@cs.wustl.edu and schmidt@cs.wustl.edu  
Phone: Phone: (314) 935-6160 Fax: (314) 935-7302  
Title: The Performance of the CORBA Dynamic Invocation Interface and Dynamic Skeleton Interface over High-Speed ATM Networks  
Author: Aniruddha Gokhale and Douglas C. Schmidt 
Address: Box 1045  St. Louis, MO 63130-4899, USA  
Affiliation: Department of Computer Science,  Washington University  
Abstract: An subset of this paper appeared in the GLOBECOM Con- ference, London, November 18 22 nd 1996. Abstract The Common Object Request Broker Architecture (CORBA) is intended to simplify the task of developing distributed applications. Although it is well-suited for conventional RPC- style applications, several limitations become evident when CORBA is used for a broader range of performance-sensitive applications running in heterogeneous environments over high-speed networks. This paper illustrates the performance limitations of existing CORBA implementations in terms of their support for the dynamic invocation interface and the dynamic skeleton interface. The results described below indicate that ORB implementors must optimize both the DII and DSI significantly before CORBA will be suitable for performance-sensitive applications on high-speed networks. In addition, the CORBA 2.0 DII specification must be clarified in order to ensure application portability and optimal performance. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> David D. Clark and David L. Tennenhouse. </author> <title> Architectural Considerations for a New Generation of Protocols. </title> <booktitle> In Proceedings of the Symposium on Communications Architectures and Protocols (SIGCOMM), </booktitle> <pages> pages 200-208, </pages> <address> Philadelphia, PA, </address> <month> September </month> <year> 1990. </year> <note> ACM. </note>
Reference-contexts: As discussed earlier, this overhead arises from the amount of time the CORBA implementations spend performing presentation layer conversions and data copying. * Presentation layer and data copying: The presentation layer is a major bottleneck in high-performance communication subsystems <ref> [1] </ref>. This layer transforms typed data objects from higher-level representations to lower-level representations (marshalling) and vice versa (demarshalling). In both RPC toolkits and CORBA, this transformation process is performed by client-side stubs and server-side skeletons that are generated by interface definition language (IDL) compilers.
Reference: [2] <author> Sudheer Dharnikota, Kurt Maly, and C. M. Overstreet. </author> <title> Performance Evaluation of TCP(UDP)/IP over ATM net-works. </title> <institution> Department of Computer Science, </institution> <type> Technical Report CSTR 94 23, </type> <institution> Old Dominion University, </institution> <month> September </month> <year> 1994. </year>
Reference-contexts: The CORBA implementation transferred the data types using IDL sequences, which are dynamically-sized arrays. These definitions are shown in the Appendix. 3.3 Parameter Settings Existing studies <ref> [4, 7, 2, 13, 12] </ref> of transport protocol performance over ATM demonstrate the impact of parameters 3 Orbix 2.0 does not yet support DSI, so we could not perform the DSI tests for Orbix. 4 We observed many requests were not reaching the ORBeline DSI server since the requests were oneway. <p> Less attention has been paid to integrating the following topics related to communication middleware like CORBA: * Transport Protocol Performance over ATM networks: <ref> [4, 7, 2] </ref> present results on performance of TCP/IP (and UDP/IP [2]) on ATM networks by varying a number of parameters (such as TCP window size, socket queue size, and user data size). <p> Less attention has been paid to integrating the following topics related to communication middleware like CORBA: * Transport Protocol Performance over ATM networks: [4, 7, 2] present results on performance of TCP/IP (and UDP/IP <ref> [2] </ref>) on ATM networks by varying a number of parameters (such as TCP window size, socket queue size, and user data size). <p> This work indicates that in addition to the host architecture and host network interface, parameters configurable in software (like TCP window size, socket queue size and user data size) significantly affect TCP throughput. <ref> [2] </ref> also shows that UDP performs better than TCP over ATM networks, which is attributed to redundant TCP processing overhead on highly-reliable ATM links.
Reference: [3] <author> John Dilley. OODCE: </author> <title> A C++ Framework for the OSF Distributed Computing Environment. </title> <booktitle> In Proceedings of the Winter Usenix Conference. USENIX Association, </booktitle> <month> January </month> <year> 1995. </year>
Reference-contexts: In both RPC toolkits and CORBA, this transformation process is performed by client-side stubs and server-side skeletons that are generated by interface definition language (IDL) compilers. IDL compilers translate interfaces written in an IDL (such as XDR [15], NDR <ref> [3] </ref>, or CDR [9]) to other forms such as a network wire format. A significant amount of research has been devoted to developing efficient stub generators.
Reference: [4] <author> Minh DoVan, Louis Humphrey, Geri Cox, and Carl Ravin. </author> <title> Initial Experience with Asynchronous Transfer Mode for Use in a Medical Imaging Network. </title> <journal> Journal of Digital Imaging, </journal> <volume> 8(1) </volume> <pages> 43-48, </pages> <month> February </month> <year> 1995. </year>
Reference-contexts: The CORBA implementation transferred the data types using IDL sequences, which are dynamically-sized arrays. These definitions are shown in the Appendix. 3.3 Parameter Settings Existing studies <ref> [4, 7, 2, 13, 12] </ref> of transport protocol performance over ATM demonstrate the impact of parameters 3 Orbix 2.0 does not yet support DSI, so we could not perform the DSI tests for Orbix. 4 We observed many requests were not reaching the ORBeline DSI server since the requests were oneway. <p> Less attention has been paid to integrating the following topics related to communication middleware like CORBA: * Transport Protocol Performance over ATM networks: <ref> [4, 7, 2] </ref> present results on performance of TCP/IP (and UDP/IP [2]) on ATM networks by varying a number of parameters (such as TCP window size, socket queue size, and user data size). <p> This is a serious problem for mission/life-critical applications (such as satellite surveillance and medical imaging <ref> [4] </ref>). This paper illustrates how existing CORBA implementations incur considerable overhead when application use the dynamic invocation interface (DII) and the dynamic skeleton interface (DSI) over high-speed ATM networks.
Reference: [5] <author> Aniruddha Gokhale and Douglas C. Schmidt. </author> <title> Measuring the Performance of Communication Middleware on High-Speed Networks. </title> <booktitle> In Proceedings of SIGCOMM '96, </booktitle> <address> Stanford, CA, </address> <month> August </month> <year> 1996. </year> <note> ACM. </note>
Reference-contexts: As shown below, the primary drawback to using CORBA is its relatively poor performance over high-speed networks. In particular, CORBA implementations of the DII and DSI perform substantially worse than the SII <ref> [5] </ref>. Moreover, the SII itself does not perform well relative to programming with lower-level communication mechanisms (such as using sockets directly over TCP/IP). 3 Experimental Results of CORBA over ATM 3.1 CORBA/ATM Testbed This section describes our CORBA/ATM testbed and presents the results of our performance experiments.
Reference: [6] <author> Phillip Hoschka and Christian Huitema. </author> <title> Automatic Generation of Optimized Code for Marshalling Routines. </title> <booktitle> In IFIP Conference of Upper Layer Protocols, Architectures and Applications ULPAA'94, </booktitle> <address> Barcelona, Spain, 1994. </address> <publisher> IFIP. </publisher>
Reference-contexts: The USC stub compiler supports the automatic generation of device and protocol header marshalling code. The USC tool generates optimized C code that automatically aligns data structures and performs network/host byte order conversions. * Generating code based on Control Flow Analysis of interface specification - <ref> [6] </ref> describes a technique of exploiting application-specific knowledge contained in the type specifications of an application to generate optimized marshalling code. This work tries to achieve an optimal tradeoff between interpreted code (which is slow but compact in size) and compiled code (which is fast but larger in size).
Reference: [7] <author> K. Modeklev, E. Klovning, and O. Kure. </author> <title> TCP/IP Behavior in a High-Speed Local ATM Network Environment. </title> <booktitle> In Proceed ings of the 19 th Conference on Local Computer Networks, </booktitle> <pages> pages 176-185, </pages> <address> Minneapolis, MN, </address> <month> October </month> <year> 1994. </year> <note> IEEE. </note>
Reference-contexts: The CORBA implementation transferred the data types using IDL sequences, which are dynamically-sized arrays. These definitions are shown in the Appendix. 3.3 Parameter Settings Existing studies <ref> [4, 7, 2, 13, 12] </ref> of transport protocol performance over ATM demonstrate the impact of parameters 3 Orbix 2.0 does not yet support DSI, so we could not perform the DSI tests for Orbix. 4 We observed many requests were not reaching the ORBeline DSI server since the requests were oneway. <p> These parameters are shown to have a significant impact on CORBA-level and TCP-level performance on high-speed networks due to their influence on the size of the TCP segment window <ref> [7, 13] </ref>. * Data buffer size: Sender buffers were incremented by powers of two, ranging from 1 K bytes to 128 K bytes. <p> Less attention has been paid to integrating the following topics related to communication middleware like CORBA: * Transport Protocol Performance over ATM networks: <ref> [4, 7, 2] </ref> present results on performance of TCP/IP (and UDP/IP [2]) on ATM networks by varying a number of parameters (such as TCP window size, socket queue size, and user data size).
Reference: [8] <institution> Object Management Group. </institution> <month> CORBAServices: </month> <title> Common Object Services Specification, </title> <note> Revised Edition, 95-3-31 edition, </note> <month> March </month> <year> 1995. </year>
Reference-contexts: None of the systems described above are targeted for communication middleware (e.g., CORBA) requirements and constraints such as heterogeneity, high system reliability, efficient marshalling/demarshalling of parameters, flexible and efficient object location and selection, and higher level mechanisms for collaboration among services <ref> [8] </ref>. 5 Concluding Remarks An important and growing class of applications (such as interface browsers, network management applications, and distributed visualization/debugging tools) require flexible, high- performance communication middleware linked by high- speed networks.
Reference: [9] <institution> Object Management Group. </institution> <note> The Common Object Request Broker: Architectureand Specification, 2.0 edition, </note> <month> July </month> <year> 1995. </year>
Reference-contexts: 1 Introduction The Common Object Request Broker Architecture (CORBA) <ref> [9] </ref>) is a promising approach for improving the flexibility, reliability, and portability of communication software. CORBA is designed as an open standard for distributed object computing. <p> Computing Model 2 Overview of CORBA The CORBA 2.0 standard <ref> [9] </ref> defines a set of components that allow client applications to invoke operations (op) with arguments (args) on object implementations. Object implementations can be configured to run locally and/or remotely without affecting their implementation or use. Figure 1 illustrates the primary components in the CORBA architecture. <p> However, the CORBA specification <ref> [9] </ref> does not specify whether a request created using the create request method can be reused or whether it must be created new and populated by the parameters, and released after every invocation. Orbix 2.0 did not allow reuse of the request. <p> In both RPC toolkits and CORBA, this transformation process is performed by client-side stubs and server-side skeletons that are generated by interface definition language (IDL) compilers. IDL compilers translate interfaces written in an IDL (such as XDR [15], NDR [3], or CDR <ref> [9] </ref>) to other forms such as a network wire format. A significant amount of research has been devoted to developing efficient stub generators.
Reference: [10] <author> Sean W. O'Malley, Todd A. Proebsting, and Allen B. Montz. </author> <title> USC: A Universal Stub Compiler. </title> <booktitle> In Proceedings of the Symposium on Communications Architecturesand Protocols (SIGCOMM), </booktitle> <address> London, UK, </address> <month> August </month> <year> 1994. </year>
Reference-contexts: A significant amount of research has been devoted to developing efficient stub generators. We cite a few of these and classify them as below. * Annotating high level programming languages The Universal Stub Compiler (USC) <ref> [10] </ref> annotates the C programming language with layouts of various data types. The USC stub compiler supports the automatic generation of device and protocol header marshalling code.
Reference: [11] <author> Guru Parulkar, Douglas C. Schmidt, and Jonathan S. Turner. </author> <title> a I t P m: a Strategy for Integrating IP with ATM. </title> <booktitle> In Proceedings of the Symposium on Communications Architectures and Protocols (SIGCOMM). ACM, </booktitle> <month> September </month> <year> 1995. </year>
Reference-contexts: The user-level memory-to- memory bandwidth of our SPARCstation 20 model 712s were measured at 1.4 Gbps, which is comparable to OC24 gigabit ATM networks <ref> [11] </ref>. 3.2 Traffic Generators Earlier studies [13, 12] tested the performance of transferring untyped bytestream data between hosts using several implementations of CORBA and other lower-level mechanisms like sockets.
Reference: [12] <author> Irfan Pyarali, Timothy H. Harrison, and Douglas C. Schmidt. </author> <title> Design and Performance of an Object-Oriented Framework for High-Performance Electronic Medical Imaging. </title> <editor> In Douglas C. Schmidt, editor, </editor> <booktitle> USENIX Computing Systems. </booktitle> <publisher> MIT Press, </publisher> <month> November/December </month> <year> 1996. </year>
Reference-contexts: CORBA is designed as an open standard for distributed object computing. It automates many common network programming tasks such as object registration, location, and activation; request demultiplexing; framing and error-handling; parameter marshalling and demarshalling; and operation dispatching. Our experience over the past several years <ref> [13, 12] </ref> indicates that CORBA is well-suited for statically typed, synchronous request/response applications that run over conventional low-speed networks. However, as developers increasingly attempt to use CORBA for more dynamic types of distributed applications that run over high-speed networks several performance limitations have become evident. <p> The user-level memory-to- memory bandwidth of our SPARCstation 20 model 712s were measured at 1.4 Gbps, which is comparable to OC24 gigabit ATM networks [11]. 3.2 Traffic Generators Earlier studies <ref> [13, 12] </ref> tested the performance of transferring untyped bytestream data between hosts using several implementations of CORBA and other lower-level mechanisms like sockets. <p> The experiments conducted for this paper extend earlier studies by measuring the performance of two different implementations of CORBA (Orbix 2.0 and ORBeline 2.0) for two features of CORBA: * The Dynamic Invocation Interface: Both CORBA implementations of the CORBA-TTCP <ref> [12] </ref> 2 client send 64 MB of richly-typed and untyped data as a sequence data type using the DII. The client tests the invoke (twoway communication) and send oneway (oneway communication) methods supported by the CORBA Request interface. The server uses the skeletons generated by the IDL compiler. <p> The DII client tests the invoke (twoway communication) method 4 supported by the CORBA Request interface. We reused the requests in these tests, as described above. Traffic for the experiments was generated and consumed by an extended version of the CORBA-TTCP <ref> [12] </ref> protocol benchmarking tool. This tool extended the standard TTCP for use with CORBA implementations like Orbix 2.0 and ORBe- line 2.0. CORBA-TTCP measures end-to-end data transfer throughput in Mbps from a transmitter process to a remote receiver process across an ATM network. <p> The CORBA implementation transferred the data types using IDL sequences, which are dynamically-sized arrays. These definitions are shown in the Appendix. 3.3 Parameter Settings Existing studies <ref> [4, 7, 2, 13, 12] </ref> of transport protocol performance over ATM demonstrate the impact of parameters 3 Orbix 2.0 does not yet support DSI, so we could not perform the DSI tests for Orbix. 4 We observed many requests were not reaching the ORBeline DSI server since the requests were oneway.
Reference: [13] <author> Douglas C. Schmidt, Timothy H. Harrison, and Ehab AlShaer. </author> <title> Object-Oriented Components for High-speed Network Programming. </title> <booktitle> In Proceedings of the 1 st Conference on Object-Oriented Technologiesand Systems, </booktitle> <address> Monterey, CA, June 1995. </address> <publisher> USENIX. </publisher>
Reference-contexts: CORBA is designed as an open standard for distributed object computing. It automates many common network programming tasks such as object registration, location, and activation; request demultiplexing; framing and error-handling; parameter marshalling and demarshalling; and operation dispatching. Our experience over the past several years <ref> [13, 12] </ref> indicates that CORBA is well-suited for statically typed, synchronous request/response applications that run over conventional low-speed networks. However, as developers increasingly attempt to use CORBA for more dynamic types of distributed applications that run over high-speed networks several performance limitations have become evident. <p> The user-level memory-to- memory bandwidth of our SPARCstation 20 model 712s were measured at 1.4 Gbps, which is comparable to OC24 gigabit ATM networks [11]. 3.2 Traffic Generators Earlier studies <ref> [13, 12] </ref> tested the performance of transferring untyped bytestream data between hosts using several implementations of CORBA and other lower-level mechanisms like sockets. <p> The CORBA implementation transferred the data types using IDL sequences, which are dynamically-sized arrays. These definitions are shown in the Appendix. 3.3 Parameter Settings Existing studies <ref> [4, 7, 2, 13, 12] </ref> of transport protocol performance over ATM demonstrate the impact of parameters 3 Orbix 2.0 does not yet support DSI, so we could not perform the DSI tests for Orbix. 4 We observed many requests were not reaching the ORBeline DSI server since the requests were oneway. <p> These parameters are shown to have a significant impact on CORBA-level and TCP-level performance on high-speed networks due to their influence on the size of the TCP segment window <ref> [7, 13] </ref>. * Data buffer size: Sender buffers were incremented by powers of two, ranging from 1 K bytes to 128 K bytes. <p> A comparison of our current results for typed data with other work using untyped data in a similar CORBA/ATM testbed <ref> [13] </ref> reveal that the performance of Orbix for sequences of scalar data types is almost the same as that reported for untyped data sequences using the statically generated stubs and the IIOP.
Reference: [14] <institution> Pure Software. </institution> <note> Quantify User's Guide, </note> <year> 1995. </year>
Reference-contexts: Detailed profiling measurements of presentation layer, data copying, and memory management overhead are also presented. The profile information was obtained using the Quantify performance measurement tool <ref> [14] </ref>.
Reference: [15] <author> Sun Microsystems. XDR: </author> <title> External Data Representation Standard. Network Information Center RFC 1014, </title> <month> June </month> <year> 1987. </year> <month> 9 </month>
Reference-contexts: In both RPC toolkits and CORBA, this transformation process is performed by client-side stubs and server-side skeletons that are generated by interface definition language (IDL) compilers. IDL compilers translate interfaces written in an IDL (such as XDR <ref> [15] </ref>, NDR [3], or CDR [9]) to other forms such as a network wire format. A significant amount of research has been devoted to developing efficient stub generators.
References-found: 15

