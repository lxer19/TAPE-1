URL: http://http.cs.berkeley.edu/~aiken/cs264/papers/tagging-optimization.ps.Z
Refering-URL: http://http.cs.berkeley.edu/~aiken/cs264/papers/node9.html
Root-URL: 
Title: Global Tagging Optimization by Type Inference within procedures; efficient: it runs asymptotically in almost-linear time
Author: Fritz Henglein 
Keyword: In TICL [MK90] type analysis of Common LISP programs relies on costly repeated analysis and program mer type declarations.  
Note: aries, not only  well-founded: it is  user-friendly: no annotations by the programmer are necessary; it operates on the program source, provides  (and thus shows which ones can be eliminated without endangering cor rectness of program execution). This agenda is accomplished by:  This improves and complements previous work on tag  
Address: Universitetsparken 1  Denmark  
Affiliation: DIKU University of Copenhagen  Copenhagen  
Email: Internet: henglein@diku.dk  
Phone: 2100  
Abstract: We present a tagging optimization algorithm based on type inference that is structural: it traces tag information in higher order (procedure) values and especially in structured (e.g. list) values, where reportedly 80% of tag handling opera tions take place; implementation-independent: no tag implementation technology is presupposed; the results are displayed as an explicitly typed source program and can be interfaced with compiler backends of statically typed lan guages such as Standard ML; fl This research has been supported by Esprit BRA 3124, Semantique. * scheduling processing steps such that each one contributes to the final result | no idle or partially idle traversals of the syntax tree are performed; instead all relevant constraints are extracted in a single pass over the syntax tree; * In the LISP compiler for S1 [BGS82], in Orbit [KKR*86], and in Screme [VP89,Ple91] tagging optimization (representation analysis) is typically performed for atomic types (numbers), based on local control flow information. Our analysis is global and based on abstract data flow information. * Shivers [Shi91a] similarly uses potentially expensive and complicated data flow reanalysis for type recovery in Scheme and relies to some degree on programmer type declarations; his analysis works on the CPS transform of a Scheme program and as such the results are not presentable to the user/programmer. The main practical contribution of our tagging optimization algorithm is likely to be its combination of execution efficiency and ability to eliminate tag handling operations in structured data, especially in lists: Steenkiste and Hennessy report that 80% of all dynamic type checking operations are due to list operations, most of which are statically eliminated by our type inference algorithm. The computed information can also be used for unboxing and closure allocation (reference escape) analysis, although this is not pursued in this paper. global: it traces tag information across procedure bound
Abstract-found: 1
Intro-found: 1
Reference: [ACPP91] <author> M. Abadi, L. Cardelli, B. Pierce, and G. Plotkin. </author> <title> Dynamic typing in a statically typed language. </title> <journal> ACM Transactions on Programming Languages and Systems (TOPLAS), </journal> <volume> 13(2) </volume> <pages> 237-268, </pages> <month> April </month> <year> 1991. </year> <note> Presented at POPL '89. </note>
Reference: [AM91] <author> A. Aiken and B. Murphy. </author> <title> Static type inference in a dynamically typed language. </title> <booktitle> In Proc. 18th Annual ACM Symp. on Principles of Programming Languages, </booktitle> <address> Orlando, Florida, </address> <pages> pages 279-290, </pages> <publisher> ACM, ACM Press, </publisher> <month> Jan. </month> <year> 1991. </year>
Reference-contexts: 0.0 0% 100% 0% 100% meta 4.3 336 0.1 25% 75% 20% 80% specializer 15.1 500 0.2 30% 70% 10% 90% cogen 65.1 2,569 1.1 (1.2) 50% 50% 25% 75% dyn-typ 66.2 2,685 1.0 (0.9) 35% 65% 35% 65% Table 1: Statistics on performance of dynamic type inference prototype languages <ref> [AM91] </ref> and object-oriented languages; e.g., in Smalltalk [JGZ88] and Self [CU90]. The application of type finding and type information to tagging optimization can be traced to (at least) the early work on SETL optimization [FSS75,SSS81], which is based on Tenenbaum's thesis referenced above.
Reference: [BGS82] <author> R. Brooks, R. Gabriel, and G. Steele. </author> <title> An optimizing compiler for lexically scoped LISP. </title> <booktitle> In Proc. SIGPLAN '82 Symp. on Compiler Construction, </booktitle> <address> Boston, Massachusetts, </address> <pages> pages 261-275, </pages> <month> June </month> <year> 1982. </year> <journal> SIGPLAN Notices, </journal> <volume> Vol. 17, No. </volume> <pages> 6. </pages>
Reference-contexts: Such local (intraprocedural) optimization for atomic types, notably numbers, is performed in several optimizing Scheme compilers; e.g., the S1 LISP compiler <ref> [BGS82] </ref> and Orbit [KKR*86]. <p> Intraprocedu-ral representation analysis for local optimization of primitive operations (operating on atomic data) is described in Brooks, Gabriel and Steele's S1 compiler for (an extension of) Common LISP <ref> [BGS82] </ref> and mentioned in Vegdahl and Pleban's article [VP89] on the run-time system of their Screme compiler for Scheme.
Reference: [Bon91] <author> Anders Bondorf. </author> <title> Automatic autoprojection of higher order recursive equations. </title> <booktitle> Science of Computer Programming, 17 (Selected papers of ESOP '90, the 3rd European Symposium on Programming)(1-3):3-34, </booktitle> <month> Dec. </month> <year> 1991. </year>
Reference-contexts: evaluator Similix (version 4.0, by Anders Bondorf). dyn-typ: The current implementation of dynamic type inference, including parsing and pretty printing, which accounts for 80% of the code (by the author). cogen: A compiler generator generating compilers from interpreters written in Scheme (generated from the partial evaluator Similix by self-application, see <ref> [Bon91] </ref>). cmp: A complete script compiler for the lazy functional programming language BAWL ("Bird-and-Wadler language") (by Jesper Jtrgensen, generated from an in terpreter using Similix, see [Jr92]). Similar numbers as for textual elimination of tag handling operations appear to hold for the dynamic execution of tag handling operations.
Reference: [CF91] <author> R. Cartwright and M. Fagan. </author> <title> Soft typing. </title> <booktitle> In Proc. ACM SIGPLAN '91 Conf. on Programming Language Design and Implementation, </booktitle> <address> Toronto, Ontario, </address> <pages> pages 278-292, </pages> <publisher> ACM, ACM Press, </publisher> <month> June </month> <year> 1991. </year>
Reference-contexts: In his type system there are no untagging operations for first-order values, but instead tagged versions of base operations are used. As a consequence tagging may "spread" to every point reachable from a single tagging operation. Cartwright and Fagan <ref> [CF91] </ref> present a unification-based "soft" typing system as an extension of ML in which static typing failures are handled during unification by opportunistic insertion of run-time type checks. <p> Type information is also instrumental in optimizing the implementation of functional 3 The article <ref> [CF91] </ref> contains some flaws and is currently under revision. 8 1. (Inequality constraint rules) (a) C [ ff (k) (ff 1 . . . ff k ) fl; f (k) (fi 1 . . . fi k ) flg ) C [ ff (k) (ff 1 . . . ff k
Reference: [CU90] <author> C. Chambers and D. Ungar. </author> <title> Iterative type analysis and extended message splitting: optimizing dynamically-typed object-oriented programs. </title> <booktitle> In Proc. ACM SIGPLAN '90 Conf. on Programming Language Design and Implementation (PLDI), </booktitle> <address> White Plains, New York, </address> <pages> pages 150-164, </pages> <publisher> ACM Press, </publisher> <month> June </month> <year> 1990. </year>
Reference-contexts: 75% 20% 80% specializer 15.1 500 0.2 30% 70% 10% 90% cogen 65.1 2,569 1.1 (1.2) 50% 50% 25% 75% dyn-typ 66.2 2,685 1.0 (0.9) 35% 65% 35% 65% Table 1: Statistics on performance of dynamic type inference prototype languages [AM91] and object-oriented languages; e.g., in Smalltalk [JGZ88] and Self <ref> [CU90] </ref>. The application of type finding and type information to tagging optimization can be traced to (at least) the early work on SETL optimization [FSS75,SSS81], which is based on Tenenbaum's thesis referenced above.
Reference: [Dyb87] <author> R. K. Dybvig. </author> <title> The Scheme Programming Language. </title> <publisher> Prentice-Hall, </publisher> <year> 1987. </year>
Reference: [FSS75] <author> S. Freudenberger, J. Schwartz, and M. Sharir. </author> <title> Experience with the SETL optimizer. </title> <journal> ACM TOPLAS, </journal> <volume> 5(1) </volume> <pages> 26-45, </pages> <month> Jan. </month> <year> 1975. </year>
Reference: [Gol91] <author> B. Goldberg. </author> <title> Tag-free garbage collection for strongly typed programming languages. </title> <booktitle> In Proc. ACM SIGPLAN '91 Conf. on Programming Language Design and Implementation (PLDI), </booktitle> <address> Toronto, Ontario, </address> <pages> pages 165-176, </pages> <publisher> ACM Press, </publisher> <month> June </month> <year> 1991. </year>
Reference-contexts: Dynamic type inference offers, however, the prospect of bringing the newly emerging technology of tag-free garbage collection for statically typed programming languages to the realm of run-time typed languages <ref> [Gol91] </ref>. 4.6 I/0 and type testing routines We give each of the type testing routines number?, symbol? etc. the type [Dynamic] ! Boolean. It is also possible (and gives potentially better results) to give them the type scheme 8ff:[ff] ! Boolean.
Reference: [Gom90] <author> C. Gomard. </author> <title> Partial type inference for untyped functional programs (extended abstract). </title> <booktitle> In Proc. LISP and Functional Programming (LFP), </booktitle> <address> Nice, France, </address> <month> July </month> <year> 1990. </year>
Reference-contexts: Gomard <ref> [Gom90] </ref> describes type inference for implicitly typed programs with no required type information at all. In his type system there are no untagging operations for first-order values, but instead tagged versions of base operations are used.
Reference: [Hen91] <author> F. Henglein. </author> <title> Efficient type inference for higher-order binding-time analysis. </title> <booktitle> In Proc. Conf. on Functional Programming Languages and Computer Architecture (FPCA), </booktitle> <address> Cambridge, </address> <publisher> Mas-sachusetts, </publisher> <pages> pages 448-472, </pages> <publisher> Springer, </publisher> <month> Aug. </month> <year> 1991. </year> <booktitle> Lecture Notes in Computer Science, </booktitle> <volume> Vol. </volume> <pages> 523. </pages>
Reference-contexts: Since an inequality solved equationally gives a NOOP solution to the corresponding coercion constraint this gives the desired minimal completion of the input program. When applying this algorithm to the program in Figure 1 the resulting minimal completion for our example program is the one presented Figure 3. In <ref> [Hen91] </ref> it is shown that, using an instrumented unification closure algorithm and the union/find data structure with ranked union and path compression [Tar83], constraint normalization can be implemented in almost linear time (in terms of the size of the input program). <p> It is clearly better to delay tagging until the number is passed to the output routine, which we assume requires a tagged input value. A type system permitting coercions potentially at any point still admits a very fast inference algorithm (see <ref> [Hen91] </ref> for its use in binding-time analysis).
Reference: [Hen92] <author> F. Henglein. </author> <title> Dynamic typing. </title> <booktitle> In Proc. Euro-pean Symp. on Programming (ESOP), Rennes, France, </booktitle> <pages> pages 233-253, </pages> <publisher> Springer, </publisher> <month> Feb. </month> <year> 1992. </year> <booktitle> Lecture Notes in Computer Science, </booktitle> <volume> Vol. </volume> <pages> 582. </pages>
Reference-contexts: Some of the basic theoretical and type inference properties of dynamic typed -calculus are investigated in <ref> [Hen92] </ref>. Note that for every primitive type and type constructor there is only one tag. <p> Empirical results suggest that 60-95% of all tag handling operations in nonnumerical programs, both in terms of syntactic occurrences and execution frequency, can be eliminated in this fashion. In the type inference system considered in <ref> [Hen92] </ref> ar-bitary coercions may be inferred for arbitrary expressions; even induced coercions as in [(?FUNC ! !FUNC )f ], which denotes the expression x : Dynamic:[!FUNC (f [?FUNC x])]. <p> lambda abstraction; a ?FUNC coercion may only occur applied to the function in a function application; a !BOOL coercion may only occur applied to the constants #t and #f; and ?BOOL may only occur applied to the test clause in a conditional; analogously for other types. (In the terminology of <ref> [Hen92] </ref> this corresponds to the class of completions C pf .) The resulting typing rules for the dynamic -calculus with Booleans are given in Figure 4. Note that we use notational conventions familiar from the literature on type inference systems, but adopt Scheme-like notation for the program syntax. <p> of implementing this algorithm. * A project to use dynamic type inference to build a translater from Scheme to the lambda intermediate language of the SML/NJ compiler has just begun at DIKU. * The outlines of a polymorphic dynamic typing discipline with polymorphic objects parameterized by coercions are already in <ref> [Hen92] </ref>, but more work is necessary.
Reference: [HL] <author> R. Harper and M. Lillibridge. </author> <title> The standard ml of new jersey implementation of callcc is not type safe. Announcement on TYPES mailing list, </title> <month> July 8, </month> <year> 1991. </year>
Reference-contexts: The same comment applies to the treatment of continuations <ref> [HL] </ref>. Side effecting operations and mutable objects require no special attention since our type inference system is monomorphic: every user-defined object is required to have a single type, not a type scheme. This may make tagging elimination more conservative than necessary, but not unsound.
Reference: [JGZ88] <author> R. Johnson, J. Graver, and L. Zurawski. </author> <title> TS: an optimizing compiler for Smalltalk. </title> <booktitle> In Object-Oriented Programming Systems, Languages and Applications (OOPSLA), Conf. Proc., </booktitle> <address> San Diego, California, </address> <pages> pages 18-26, </pages> <publisher> ACM Press, </publisher> <month> Sept. </month> <year> 1988. </year>
Reference-contexts: 336 0.1 25% 75% 20% 80% specializer 15.1 500 0.2 30% 70% 10% 90% cogen 65.1 2,569 1.1 (1.2) 50% 50% 25% 75% dyn-typ 66.2 2,685 1.0 (0.9) 35% 65% 35% 65% Table 1: Statistics on performance of dynamic type inference prototype languages [AM91] and object-oriented languages; e.g., in Smalltalk <ref> [JGZ88] </ref> and Self [CU90]. The application of type finding and type information to tagging optimization can be traced to (at least) the early work on SETL optimization [FSS75,SSS81], which is based on Tenenbaum's thesis referenced above.
Reference: [JM76] <author> N. Jones and S. Muchnick. </author> <title> Binding time optimization in programming languages: some thoughts toward the design of the ideal language. </title> <booktitle> In Proc. 3rd ACM Symp. on Principles of Programming Languages, </booktitle> <pages> pages 77-94, </pages> <publisher> ACM, </publisher> <month> Jan. </month> <year> 1976. </year>
Reference: [JM82] <author> N. Jones and S. Muchnick. </author> <title> A flexible approach to interprocedural data flow analysis and programs with recursive data structures. </title> <booktitle> In Proc. ACM Symp. on Principles of Programming Languages, </booktitle> <pages> pages 66-74, </pages> <month> Jan. </month> <year> 1982. </year>
Reference: [Jr92] <author> J. Jt rgensen. </author> <title> Generating a compiler for a lazy language by partial evaluation. </title> <booktitle> In Proc. 19th Annual ACM SIGPLAN-SIGACT Symposium on Principles of Programmin gLanguages (POPL), </booktitle> <address> Albuquerque, New Mexico, </address> <pages> pages 258-268, </pages> <publisher> ACM Press, </publisher> <month> Jan. </month> <year> 1992. </year>
Reference-contexts: code (by the author). cogen: A compiler generator generating compilers from interpreters written in Scheme (generated from the partial evaluator Similix by self-application, see [Bon91]). cmp: A complete script compiler for the lazy functional programming language BAWL ("Bird-and-Wadler language") (by Jesper Jtrgensen, generated from an in terpreter using Similix, see <ref> [Jr92] </ref>). Similar numbers as for textual elimination of tag handling operations appear to hold for the dynamic execution of tag handling operations. So far we have only collected preliminary run-time statistics when executing the dynamic type inference system itself.
Reference: [KKR*86] <author> D. Kranz, R. Kelsey, J. Rees, P. Hudak, J. Philbin, and N. Adams. </author> <title> Orbit: an optimizing compiler for scheme. </title> <booktitle> In Proc. SIGPLAN '86 Symp. on Compiler Construction, </booktitle> <pages> pages 219-233, </pages> <year> 1986. </year>
Reference-contexts: Such local (intraprocedural) optimization for atomic types, notably numbers, is performed in several optimizing Scheme compilers; e.g., the S1 LISP compiler [BGS82] and Orbit <ref> [KKR*86] </ref>.
Reference: [KU80] <author> M. Kaplan and J. Ullman. </author> <title> A scheme for the automatic inference of variable types. </title> <journal> J. ACM, </journal> <volume> 27(1), </volume> <month> Jan. </month> <year> 1980. </year>
Reference-contexts: Type finding based on classical data flow analysis technology goes back to Tenenbaum [Ten74], Jones and Muchnick [JM76,JM82], and Kaplan and Ullman <ref> [KU80] </ref>; more recently it has been extended and adapted to SETL by Weiss [Wei86]; to Icon by Walker [Wal88]; to Common LISP by Ma and Kessler [MK90]; to Scheme by Shivers [Shi91a] (see below).
Reference: [LW91] <author> X. Leroy and P. Weis. </author> <title> Polymorphic type inference and assignment. </title> <booktitle> In Proc. 18th Annual ACM Symp. on Principles of Programming Languages, </booktitle> <address> Orlando, Florida, </address> <pages> pages 291-302, </pages> <publisher> ACM, ACM Press, </publisher> <month> Jan. </month> <year> 1991. </year>
Reference: [MK90] <author> K. Ma and R. Kessler. </author> <title> TICL atype inference system for common lisp. </title> <journal> Software Practice & Experience, </journal> <year> 1990. </year>
Reference-contexts: Type finding based on classical data flow analysis technology goes back to Tenenbaum [Ten74], Jones and Muchnick [JM76,JM82], and Kaplan and Ullman [KU80]; more recently it has been extended and adapted to SETL by Weiss [Wei86]; to Icon by Walker [Wal88]; to Common LISP by Ma and Kessler <ref> [MK90] </ref>; to Scheme by Shivers [Shi91a] (see below). <p> Ma and Kessler's type inference system for Common LISP, TICL <ref> [MK90] </ref>, seeks to propagate programmer type declarations to other parts of Common LISP programs by forwards analysis, repeatedly analyzing procedure definitions in different call contexts.
Reference: [MTH90] <author> R. Milner, M. Tofte., and R. Harper. </author> <title> The Definition of Standard ML. </title> <publisher> MIT Press, </publisher> <year> 1990. </year>
Reference-contexts: Static type information is also useful as a form of user-readable program documentation: explicit typed variable declarations (as in Pascal) specify programmer intent and are checked at compile-time without run-time penalty; inferred types (as in Standard ML <ref> [MTH90] </ref>) provide helpful information, both to the writer and other readers of a program, about fundamental properties of individual program parts.
Reference: [Myc84] <author> A. Mycroft. </author> <title> Dynamic types in statically typed languages. </title> <month> Aug. </month> <year> 1984. </year> <note> Unpublished manuscript, 2nd draft version. </note>
Reference: [Pet89] <author> J. Peterson. </author> <title> Untagged data in tagged environments: choosing optimal representations at compile time. </title> <booktitle> In Proc. Functional Programming Languages and Computer Architecture (FPCA), </booktitle> <address> London, England, </address> <pages> pages 89-99, </pages> <publisher> ACM Press, </publisher> <month> Sept. </month> <year> 1989. </year>
Reference-contexts: It is worthwhile pointing out that Peterson <ref> [Pet89] </ref> ad dresses the orthogonal problem of minimizing the (dynamic) number of changes between the tagged and untagged representation of an object that is, in principle, tagged.
Reference: [Ple91] <author> U. Pleban. </author> <title> Compilation issues in the screme implementation for the 88000. </title> <editor> In P. Lee, editor, </editor> <booktitle> Topics in Advanced Language Implementation, chapter 7, </booktitle> <pages> pages 157-188, </pages> <publisher> MIT Press, </publisher> <year> 1991. </year>
Reference: [Sch91] <institution> IEEE Standard for the Scheme Programming Language. IEEE Computer Society, </institution> <note> IEEE std 1178-1990 edition, </note> <month> May </month> <year> 1991. </year> <title> Sponsored by the Microprocessor and Microcomputer Standards Subcommittee. </title>
Reference: [Ses89] <author> P. Sestoft. </author> <title> Replacing function parameters by global variables. </title> <booktitle> In Proc. Functional Programming Languages and Computer Architecture (FPCA), </booktitle> <address> London, England, </address> <pages> pages 39-53, </pages> <publisher> ACM Press, </publisher> <month> Sept. </month> <year> 1989. </year>
Reference-contexts: The combination of repeated analysis with the need to compute abstract closure sets suggests that his method may be inherently too inefficient for medium- to large-sized programs, though, as the fastest algorithm known to us for closure analysis <ref> [Ses89] </ref> alone is very complicated and requires fi (n 3 ) time. It is worthwhile pointing out that Peterson [Pet89] ad dresses the orthogonal problem of minimizing the (dynamic) number of changes between the tagged and untagged representation of an object that is, in principle, tagged.
Reference: [SH87] <author> P. Steenkiste and J. Hennessy. </author> <title> Tags and type checking in LISP: hardware and software approaches. </title> <booktitle> In Proc. 2nd Int'l Conf. on Architectural Support for Programming Languages and Operating Systems (ASPLOS), ACM, </booktitle> <month> Oct. </month> <year> 1987. </year>
Reference-contexts: But no currently existing compiler seems to attempt tagging optimization for structured or procedure values or to perform global (interprocedural) tagging optimization and this even though Steenkiste and Hennessy <ref> [SH87] </ref> report that 80% of all dynamically executed type checking operations are due to list operations! Our type inference algorithm is global, and it analyzes structured data such as lists and procedures. <p> The main benefits to be gained from tagging optimization, however, are the elimination of untagging operations since the cumulative cost of tagging operations appears to be only marginal <ref> [SH87] </ref>.
Reference: [Shi88] <author> O. Shivers. </author> <title> Control flow analysis in Scheme. </title> <booktitle> In Proc. SIGPLAN '88 Conf. on Programming Language Design and Implementation, </booktitle> <pages> pages 164-174, </pages> <publisher> ACM Press, </publisher> <month> June </month> <year> 1988. </year>
Reference: [Shi91a] <author> O. Shivers. </author> <title> Data-flow analysis and type recovery in scheme. </title> <editor> In P. Lee, editor, </editor> <booktitle> Topics in Advanced Language Implementation, chapter 3, </booktitle> <pages> pages 47-88, </pages> <publisher> MIT Press, </publisher> <year> 1991. </year>
Reference-contexts: on classical data flow analysis technology goes back to Tenenbaum [Ten74], Jones and Muchnick [JM76,JM82], and Kaplan and Ullman [KU80]; more recently it has been extended and adapted to SETL by Weiss [Wei86]; to Icon by Walker [Wal88]; to Common LISP by Ma and Kessler [MK90]; to Scheme by Shivers <ref> [Shi91a] </ref> (see below). <p> appears to be desirable to "push" as many coercions as possible from inside procedure definitions back to their arguments or forwards to their results and thus out of the definitions. * Dynamic type inference based tagging optimization could be combined with flow control information and data flow analysis, as in <ref> [Shi91a] </ref>, to achieve better results. For example, when making the type handling operations explicit in the intermediate code of a language avoiding repeated (un)tagging of the same object becomes an instance of the common subexpression elimination problem.
Reference: [Shi91b] <author> O. Shivers. </author> <title> The semantics of scheme control-flow analysis. </title> <booktitle> In Proc. Symp. on Partial Evaluation and Semantics-Based Program Manipulation (PEPM), </booktitle> <address> New Haven, Connecticut, </address> <pages> pages 190-198, </pages> <publisher> ACM Press, </publisher> <month> June </month> <year> 1991. </year>
Reference: [SSS81] <author> E. Schonberg, J. T. Schwartz, and M. Sharir. </author> <title> An automatic technique for selection of data representations in SETL programs. </title> <journal> ACM TOPLAS, </journal> <volume> 3(2) </volume> <pages> 126-143, </pages> <month> Apr </month> <year> 1981. </year>
Reference: [Ste84] <author> G. Steele. </author> <title> Common LISP The Language. </title> <publisher> Digital Press, </publisher> <year> 1984. </year>
Reference-contexts: 1 Introduction LISP and its modern-day incarnations such as Common LISP <ref> [Ste84] </ref> and Scheme [Dyb87,Sch91] are latently typed languages. This means that data values carry specific (type) tags at run-time that identify the type of the value.
Reference: [Ste91] <author> P. Steenkiste. </author> <title> The implementation of tags and run-time type checking. </title> <editor> In P. Lee, editor, </editor> <booktitle> Topics in Advanced Language Implementation, chapter 7, </booktitle> <pages> pages 157-188, </pages> <publisher> MIT Press, </publisher> <year> 1991. </year>
Reference: [Tar83] <author> R. Tarjan. </author> <title> Data Structures and Network Flow Algorithms. </title> <booktitle> Volume CMBS 44 of Regional Conference Series in Applied Mathematics, </booktitle> <publisher> SIAM, </publisher> <year> 1983. </year>
Reference-contexts: When applying this algorithm to the program in Figure 1 the resulting minimal completion for our example program is the one presented Figure 3. In [Hen91] it is shown that, using an instrumented unification closure algorithm and the union/find data structure with ranked union and path compression <ref> [Tar83] </ref>, constraint normalization can be implemented in almost linear time (in terms of the size of the input program). This bound even applies in the case when coercions are permitted anywhere, not just at data creation and destruction points, and constraints of the form ff fi must be considered. <p> Furthermore, this algorithm exhibits excellent practical run-time behavior as evidenced in Section 6. 6 Status and experimental results We have implemented a rudimentary version of dynamic type inference for Scheme based on an implementation of the union-find data structure with path compression and union-by-rank (see, e.g., <ref> [Tar83, Section 2] </ref>). The preliminary results are very encouraging: the current algorithm, which still misses ample opportunities for eliminating tag handling operations, eliminates typically more than 60% of all occurrences of tag handling operations in nonnumerical code.
Reference: [Ten74] <author> A. Tenenbaum. </author> <title> Type Determination for Very High Level Languages. </title> <type> Technical Report NSO-3, </type> <institution> Courant Institute of Mathematical Sciences, </institution> <address> New York University, </address> <year> 1974. </year>
Reference-contexts: Type finding based on classical data flow analysis technology goes back to Tenenbaum <ref> [Ten74] </ref>, Jones and Muchnick [JM76,JM82], and Kaplan and Ullman [KU80]; more recently it has been extended and adapted to SETL by Weiss [Wei86]; to Icon by Walker [Wal88]; to Common LISP by Ma and Kessler [MK90]; to Scheme by Shivers [Shi91a] (see below).
Reference: [Tha90] <author> S. Thatte. </author> <title> Quasi-static typing. </title> <booktitle> In Proc. ACM Symp. on Principles of Programming Languages, </booktitle> <pages> pages 367-381, </pages> <publisher> ACM, </publisher> <month> Jan. </month> <year> 1990. </year>
Reference-contexts: In this regard it is closely related to Thatte's notion of quasi-static typing <ref> [Tha90] </ref> where tagging and untagging are referred to as positive and negative coercions, respectively. (A subtyping discipline has only positive coercions.) In Thatte's language, however, the types of bound variables must be explicitly declared and it is thus not suitable for application in automatic tagging optimization.
Reference: [Tof90] <author> M. Tofte. </author> <title> Type inference for polymorphic references. </title> <journal> Information and Computation, </journal> <volume> 89(1) </volume> <pages> 1-34, </pages> <month> Nov. </month> <year> 1990. </year>
Reference-contexts: Note that the parameterizations can be compiled to specialized code in accordance with the actual coercion parameters. 4.3 Side effects, mutable objects and continuations The well-known complications and dangers of polymorphic type inference in the presence of pointers and side-effecting operations <ref> [Tof90] </ref> occur only when a naive polymorphic type generalization rule for user-defined objects is used. The same comment applies to the treatment of continuations [HL].
Reference: [VP89] <author> S. Vegdahl and U. Pleban. </author> <title> The runtime environment for Screme, a Scheme implementation on the 88000. </title> <booktitle> In Proc. Architectural Support for Programming Languages and Operating Systems (ASPLOS), </booktitle> <address> Boston, Massachusetts, </address> <pages> pages 172-182, </pages> <month> April </month> <year> 1989. </year> <journal> SIGPLAN Notices, </journal> <volume> Vol. </volume> <pages> 24, </pages> <note> Special Issue May 1989. </note>
Reference-contexts: Intraprocedu-ral representation analysis for local optimization of primitive operations (operating on atomic data) is described in Brooks, Gabriel and Steele's S1 compiler for (an extension of) Common LISP [BGS82] and mentioned in Vegdahl and Pleban's article <ref> [VP89] </ref> on the run-time system of their Screme compiler for Scheme. Ma and Kessler's type inference system for Common LISP, TICL [MK90], seeks to propagate programmer type declarations to other parts of Common LISP programs by forwards analysis, repeatedly analyzing procedure definitions in different call contexts.
Reference: [Wal88] <author> K. Walker. </author> <title> A Type Inference System for Icon. </title> <type> Technical Report 88-25, </type> <institution> University of Arizona, </institution> <month> July </month> <year> 1988. </year>
Reference-contexts: Type finding based on classical data flow analysis technology goes back to Tenenbaum [Ten74], Jones and Muchnick [JM76,JM82], and Kaplan and Ullman [KU80]; more recently it has been extended and adapted to SETL by Weiss [Wei86]; to Icon by Walker <ref> [Wal88] </ref>; to Common LISP by Ma and Kessler [MK90]; to Scheme by Shivers [Shi91a] (see below).
Reference: [Wei86] <author> G. Weiss. </author> <title> Recursive Data Types in SETL: Automatic Determination, Data Language Description, and Efficient Implementation. </title> <type> Technical Report 201, </type> <institution> Courant Institute of Mathematical Sciences, </institution> <address> New York University, </address> <month> March </month> <year> 1986. </year> <month> 11 </month>
Reference-contexts: Type finding based on classical data flow analysis technology goes back to Tenenbaum [Ten74], Jones and Muchnick [JM76,JM82], and Kaplan and Ullman [KU80]; more recently it has been extended and adapted to SETL by Weiss <ref> [Wei86] </ref>; to Icon by Walker [Wal88]; to Common LISP by Ma and Kessler [MK90]; to Scheme by Shivers [Shi91a] (see below).
References-found: 41

