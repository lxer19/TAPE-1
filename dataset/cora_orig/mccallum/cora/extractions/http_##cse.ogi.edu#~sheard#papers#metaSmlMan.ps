URL: http://cse.ogi.edu/~sheard/papers/metaSmlMan.ps
Refering-URL: http://www.cse.ogi.edu/~sheard/sheard.html
Root-URL: http://www.cse.ogi.edu
Title: Introduction to Multi-Stage Programming Using MetaML  
Author: Tim Sheard Matthieu Martel 
Date: September 1997  
Address: P.O. Box 91000 Portland, OR 97291-1000  
Affiliation: Pacific Software Research Center Oregon Graduate Institute of Science and Technology  
Pubnum: OGI Technical Report 97/??  
Abstract-found: 0
Intro-found: 1
Reference: [Dan95] <author> Olivier Danvy. </author> <title> Type-directed partial evaluation. </title> <booktitle> In Proceedings of the ACM Symposium on Principle of Programming Languages, </booktitle> <pages> pages 242-257. </pages> <publisher> ACM, </publisher> <year> 1995. </year>
Reference-contexts: val it = 6 : int Let us examine one other example: -| val liftLike = fn x =&gt; &lt;x&gt;; val liftLike = Fn : ['a].'a -&gt; &lt;'a,empty&gt; The function liftLike behaves like the operator lift, it evaluates its argument, and then returns a piece of code with that value <ref> [Dan95, She97] </ref>. Any value may be so lifted, even function values. The difference between the operator lift and the this lexical capture of free variables (which we sometimes call cross stage persistence) is hidden inside of the implementation.
Reference: [Ler97] <author> Xavier Leroy. </author> <title> The Caml Light system, documentation and user's guide, </title> <journal> realize 0.73. </journal> <note> http://pauillac.inria.fr/caml/man-caml/index.html, 1997. </note>
Reference-contexts: Type safety considerations do not allow the generalization of expressions which do dynamic memory re-allocation [?]. The treatment of non-generalizable type variables depends on the implementations. Standard ML of New Jersey's type-checker rejects such expressions. Caml <ref> [Ler97] </ref> instantiates these variables by non-generalized type variables. Any type may be assigned to a non-generalized type variable v. However, v may only be instantiate once. MetaML uses non-generalized type variables.
Reference: [MTHM97] <author> Robin Milner, Mads Tofte, Robert Harper, and David MacQueen. </author> <title> The Definition of Standard ML (Revised). </title> <publisher> MIT-Press, </publisher> <year> 1997. </year>
Reference-contexts: In MetaML one writes meta-programs in a meta-language which manipulate object-programs in an object-language. In MetaML both the meta-language and object-language is ML <ref> [MTHM97, Pau96] </ref>. Thus every ordinary ML program is also a MetaML program. Such programs just happen to do no object-level manipulation. MetaML is intended to be a conservative extension to ML . <p> MetaML reads and evaluates the current expression. The result is then displayed and a new prompt appears. MetaML accepts different kinds of expressions, which are described by the syntax of ML <ref> [MTHM97] </ref> plus the meta-extensions. For example, constants are the simplest expressions in the language. -| 2; -| 2+3; Above, in the first example the input 2; is parsed, type-checked to have value int, and then evaluated.
Reference: [NN93] <author> Flemming Nielson and Hanne Riis Nielson. </author> <booktitle> number 34 in cambridge tracts in theoretical computer science. In Two-level functional languages. </booktitle> <publisher> Cambridge University Press, </publisher> <year> 1993. </year>
Reference-contexts: In such a process, the computation was staged: in a first stage (or level) the general program was applied to only some of the inputs. A new program was generated. In a second stage, it was applied to the rest of the inputs. Multi-stage programming, introduced in <ref> [NN93] </ref>, is the art of designing staged versions of general algorithms. In this task, the programmer describes what the program will be after the application of some arguments. Multi-stage programs are also referred to as meta-programs since they are programs which manipulate other programs.
Reference: [Pau96] <author> Lawrence C. Paulson. </author> <title> ML for the Working Programmer (2nd Edition). </title> <publisher> Cambridge University Press, </publisher> <year> 1996. </year>
Reference-contexts: In MetaML one writes meta-programs in a meta-language which manipulate object-programs in an object-language. In MetaML both the meta-language and object-language is ML <ref> [MTHM97, Pau96] </ref>. Thus every ordinary ML program is also a MetaML program. Such programs just happen to do no object-level manipulation. MetaML is intended to be a conservative extension to ML .
Reference: [She97] <author> Tim Sheard. </author> <title> A type-directed, on-line partial evaluator for a polymorphic language. </title> <booktitle> In Proceedings of the ACM-SIGPLAN Symposium on Partial Evaluation and semantic based program manipulations PEPM'97, </booktitle> <address> Amsterdam, </address> <publisher> page ?? ACM, </publisher> <year> 1997. </year>
Reference-contexts: val it = 6 : int Let us examine one other example: -| val liftLike = fn x =&gt; &lt;x&gt;; val liftLike = Fn : ['a].'a -&gt; &lt;'a,empty&gt; The function liftLike behaves like the operator lift, it evaluates its argument, and then returns a piece of code with that value <ref> [Dan95, She97] </ref>. Any value may be so lifted, even function values. The difference between the operator lift and the this lexical capture of free variables (which we sometimes call cross stage persistence) is hidden inside of the implementation. <p> makes the system complain. -| e; -| e "aa"; Type Error: Cannot unify the types: in type application the type constructors do not match: int &lt;&gt; string string and in expression: "aa" 15 3.2.2 Multi-stage expressions A formal treatment of the static semantics of multi-stage programs can be found in <ref> [She97] </ref>. Here we informally describe how higher-level expressions are checked by the system. MetaML's type-checker helps the programmer by verifying the consistency of multi-stage expressions. This is three-fold: 1. A particular code type is assigned to every higher-level expression.
Reference: [SSPJ97] <author> Mark Shields, Tim Sheard, and Simon Peyton Jones. </author> <title> Dynamic typing as staged type inference. </title> <note> In To be published, </note> <year> 1997. </year>
Reference-contexts: So, MetaML offers a mechanism denoted dynamic type-checking <ref> [SSPJ97] </ref>. The user may explicitly specify that a piece of code is not to be fully type-checked staticly. This is done by enclosing the frozen expression by dynamic brackets &lt;| |&gt; instead of usual meta-brackets &lt; &gt;.
Reference: [TS97] <author> Walid Taha and Tim Sheard. </author> <title> Multi-stage programming with explicit annotations. </title> <booktitle> In Proceedings of the ACM-SIGPLAN Symposium on Partial Evaluation and semantic based program manipulations PEPM'97, </booktitle> <address> Amsterdam, </address> <publisher> page ?? ACM, </publisher> <year> 1997. </year> <month> 26 </month>
References-found: 8

