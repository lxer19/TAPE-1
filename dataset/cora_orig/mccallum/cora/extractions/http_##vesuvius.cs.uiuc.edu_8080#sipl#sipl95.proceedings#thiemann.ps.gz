URL: http://vesuvius.cs.uiuc.edu:8080/sipl/sipl95.proceedings/thiemann.ps.gz
Refering-URL: http://vesuvius.cs.uiuc.edu:8080/sipl/sipl95.proceedings.html
Root-URL: http://www.cs.uiuc.edu
Title: Terminated References and Automatic Parallelization for State Transformers  
Author: Peter J. Thiemann, Universitt Tbingen, Sand 
Keyword: state monad, trst-class references, ab stract types, implicit parallelism.  
Address: 13, D-72076 Tbingen, Germany  
Abstract: The monadic approach to integrate trst-class references in purely functional programming languages suers from escaping references and over-sequentialization. An extension of the type system by abstract types prevents references from escaping their scope and facilitates transforming mutable objects into immutable ones in constant time. An enhancement of the types of state transformers by effects uncovers implicit parallelism. A program transformation is makes the implicit parallelism explicit so that it can be exploited by a parallel implementation. 
Abstract-found: 1
Intro-found: 1
Reference: [CO93] <author> Kung Chen and Martin Odersky. </author> <title> A type system for a lambda calculus with assignment. </title> <institution> Research Report YALEU/DCS/RR-963, Department of Computer Science, Yale University, </institution> <address> New Haven, Connecticut, </address> <month> May </month> <year> 1993. </year>
Reference-contexts: The source of parallelism in their work is an unsafe function fork where every use must be proved not to introduce side eects. In our work fork is introduced by a transformation and is thus correct once the correctness of the transformation is established. Chen and Odersky <ref> [CO93] </ref> describe a stratited type system for var [ORH93], a lambda calculus extended by imperative features. The system has a type reconstruction algorithm. It is not capable of handling nested state transformers which compute state transformers themselves. The type system proposed here provides that capability.
Reference: [Has92] <author> Report on the programming language Haskell, </author> <title> a non-strict, purely functional language, version 1.2. </title> <journal> SIGPLAN Notices, </journal> <volume> 27(5):R1R164, </volume> <month> May </month> <year> 1992. </year>
Reference-contexts: Its type detnition is: type ST state value = state -&gt; (value, state) This declaration introduces the type constructor ST with two parameters state and value with the obvious meanings. Here and throughout the whole paper, we make liberal use of Haskell <ref> [Has92] </ref> syntax in examples.
Reference: [Hud93] <author> Paul Hudak. </author> <title> Mutable abstract datatypes or how to have your state and munge it too. </title> <institution> Research Report YALEU/DCS/RR-914, Yale University, Department of Computer Science, </institution> <address> New Haven, CT, </address> <month> December </month> <year> 1993. </year> <month> (Revised May </month> <year> 1993). </year>
Reference-contexts: Hudak <ref> [Hud93] </ref> describes several methods for detning mutable abstract datatypes which encapsulate single-threaded computations and which are amenable to implementation with assignments. He generates the specitcation of a mutable abstract datatype from the specitcation of an immutable one if it obeys a linearity condition. <p> It seems unlikely that a similar transformation is possible for continuation-based approaches. Downward and upward abstract types can also be used to ensure encapsulation and termination of references for other mutable abstract datatypes, for example the direct style and the continuation-passing style mutable abstract datatypes of Hudak <ref> [Hud93] </ref>. The automatic extraction of independent parts of state threads as shown in Sections 5.2 and 7 does not depend on our specitc encapsulation mechanism, it works as well with the encapsulation proposed by Launchbury and Peyton Jones [LP94].
Reference: [JH93] <author> Mark P. Jones and Paul Hudak. </author> <title> Implicit and explicit parallel programming in Haskell. </title> <institution> Research Report YALEU/DCS/RR-982, Yale University, </institution> <address> New Haven, CT 06520-2158, </address> <month> August </month> <year> 1993. </year>
Reference-contexts: In a parallel implementation the let in the detni-ton of fork could be replaced by a letpar construct which starts the evaluation of its binders in parallel. Notice that fork as detned above behaves dierent to the fork operator in recent work of Jones and Hudak <ref> [JH93] </ref>. Their fork only interleaves actions if they make use of explicit communication primitives. The transformation becomes pleasingly symmetric using fork, as shown in Fig. 4. <p> He generates the specitcation of a mutable abstract datatype from the specitcation of an immutable one if it obeys a linearity condition. He proposes trst-class references but does not address the problem of escaping references. Jones and Hudak <ref> [JH93] </ref> propose a monadic framework for parallel functional programming. The source of parallelism in their work is an unsafe function fork where every use must be proved not to introduce side eects.
Reference: [KSvP93] <author> P. W. M. Koopman, J. E. W. Smetsers, M. C. J. D. van Eekelen, and M. J. Plasmei-jer. </author> <title> Graph Rewriting Using the Annotated Functional Strategy, chapter 23. </title> <publisher> John Wiley & Sons, </publisher> <year> 1993. </year>
Reference-contexts: The operational semantics is detned by graph rewriting as originally proposed by Wadsworth [Wad71], see also [Pey87]. Graphs are rewritten according to the functional strategy <ref> [KSvP93] </ref> which enriches priority-based term graph rewriting with demand driven rewriting due to pattern matching. Graph nodes are labelled with constants, variables, x, or @ (application) and each node has a list of successors.
Reference: [Lau93] <author> John Launchbury. </author> <title> Lazy imperative programming. </title> <editor> In Paul Hudak, editor, </editor> <booktitle> SIPL '93, ACM SIGPLAN Workshop on State in Programming Languages, number YALEU/DCS/RR-968, </booktitle> <pages> pages 4656, </pages> <address> New Haven, CT, </address> <month> June </month> <year> 1993. </year> <institution> Copenhagen, Denmark. </institution>
Reference-contexts: Among them is the monad of state transformers (state monad, for short) [Wad90, Wad92] which encapsulates the propagation of a state through a whole computation. It provides proper sequencing of I/O operations [PW93] or lazy computations with mutable variables and arrays <ref> [Lau93] </ref>. In this approach, references to mutable variables and arrays are trst-class values which are created and manipulated by primitive operations of the monad. <p> which accepts an initial state value and an action to produce the result after running the action on the initial state (fst returns the trst component of a pair). exec :: s -&gt; ST s v -&gt; v exec init action = fst (action init) Peyton Jones, Wadler, and Launchbury <ref> [PW93, Lau93] </ref> have suggested a more powerful way to use the sequentialization imposed by state transformers. They enhance state transformers by primitive actions to perform an I/O operation, create a reference, read a reference, or assign to a reference. <p> To execute such a computation it suces to apply it to an arbitrary (non-bottom) initial state, for example () of type (). run :: ST () v -&gt; v run action = exec () action With this knowledge a signature for primitive operations on references can be detned <ref> [Lau93] </ref>. In the following, datatypes whose name ends with a ! denote references to mutable objects. <p> Peyton Jones and Wadler [PW93] have used the state monad to ensure proper sequencing of I/O operations and assignment operations on references. Launchbury describes a lazy implementation of mutable arrays and variables in terms of a sequencing monad <ref> [Lau93] </ref>. The independence of dierent incarnations (and thus referential transparency) of the sequencing monad is ensured by assigning each sequencing thread a unique identity. Each operation must trst check the identity in order to guarantee absence of side-eects.
Reference: [LG88] <author> John M. Lucassen and David K. Giord. </author> <title> Polymorphic eect systems. </title> <booktitle> In Proc. 15th ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 4757, </pages> <address> San Diego, CA, </address> <month> January </month> <year> 1988. </year>
Reference-contexts: It does not describe which variables are read or written by a. We need a description of the eects of a. Every result due to the evaluation of an expression which is not reected in its value is called an eect. Therefore, an eect system <ref> [LG88] </ref> relates an expression not only to its type but also to its eects. Function abstractions delay the eects of their body until they are applied to an argument. Hence, function arrows are annotated with their latent eects, which may happen during the application of that function.
Reference: [LO92] <author> Konstantin Lufer and Martin Odersky. </author> <title> An extension of ML with trst-class abstract types. </title> <booktitle> In Proc. ACM SIGPLAN Workshop on ML and its Applications, </booktitle> <pages> pages 7891, </pages> <address> San Francisco, CA, </address> <month> June </month> <year> 1992. </year>
Reference-contexts: The mechanism of upward and downward abstract types is quite similar to existentially quantited types. There is a type reconstruction algorithm [Thi93] which handles them like nullary type constructors (cf. the Skolem type constructors used by Lufer and Odersky <ref> [LO92] </ref> to model abstract types by existentially quantited types as pioneered by Mitchell and Plotkin [MP88]). However, there is no special syntax to introduce a value with an abstract type and type declarations are required to introduce abstract type variables.
Reference: [LP94] <author> John Launchbury and Simon L. Peyton Jones. </author> <title> Lazy functional state threads. </title> <booktitle> In Proc. of the ACM SIGPLAN '93 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 2435, </pages> <address> Orlando, Fla, USA, </address> <month> June </month> <year> 1994. </year> <journal> ACM Press. ACM SIPLAN Notices, v29, </journal> <volume> 6. </volume>
Reference-contexts: Notice that the eect annotation and thus the program transformation to expose parallelism is also usable with the solution to the encapsulation problem of Launchbury and Peyton Jones <ref> [LP94] </ref>. The transformation also sheds some light on how to program communicating processes with local state in a lazy parallel functional language. Outline of the Paper Section 2 briey introduces state transformers and their application to sequence assignments. <p> We call an executing incarnation of a state transformer a (state) thread (cf. <ref> [LP94] </ref>). A value of type ST s v is a (state) action. From the detnitions we see that the state component is propagated through the whole computation without duplication, therefore the state is single-threaded. <p> Example 1 let r = run (crtRef 0) a = incrRef r fl () -&gt; getRef r in (run a, run a) 1 The strictness can be made explicit at the source level by using an algebraic datatype data D x = D x as the state type as in <ref> [PW93, LP94] </ref>. Since that complicates the types we just state the required strictness. By referential transparency, the value of this expression should be a pair of equal numbers. However, depending on the context its value is either (1; 2) or (2; 1). <p> The formalization of this is rather technical and details on it are found in a technical report [Thi93]. 2 This eect is achieved in <ref> [LP94] </ref> by giving run the rank-2 type 8ff:(8fi:ST fi ff) ! ff. 4 Introducing Terminators Arrays in pure functional languages are usually monolithic (the contents cannot be detned incrementally) and immutable (the contents cannot be mod-ited). <p> This former primitive function can now safely be written using a state thread: allocate a mutable array, tll it using assignment operations, and let it escape from its creating thread. But the typing of run prevents exactly that. Launchbury and Peyton Jones <ref> [LP94] </ref> have therefore introduced the operation freezeA :: Array! state v -&gt; ST state (Array v) (ignoring the index which is another parameter of Haskell's Array datatype) such that freezeA a is strict in its state argument and in a and provides the proper retyping. <p> It remains to establish the means to run them independently and to feed back the values of the bound variables of a 1 to a 2 and vice versa. The trst goal is met with the operation interleave :: ST s v -&gt; ST s v <ref> [PW93, LP94] </ref>. split (T; V 1 ; V 2 ; d (ha 1 i fl hxi ! ha 2 i) fl ha 3 ie) = split (T; V 1 ; V 2 ; dha 1 i fl hxi ! (ha 2 i fl ha 3 i)e) (1) split (T; V 1 <p> The transformed expression depends crucially on the irrefutability of the pattern binding (z 1 ; hV 1 i; hV 2 i) = z 0 . Otherwise the required cyclic bindings cannot be established. 6.1 Example: Lazy File Read The motivating example of <ref> [PW93, LP94] </ref> for interleave is the implementation of lazy tle read. The state monad cannot only be used to ensure correct sequencing of actions on references, but it can sequence I/O actions as well. <p> Each operation must trst check the identity in order to guarantee absence of side-eects. This expensive check is not necessary using our approach where the type checker ensures matching identities. More recent work of Launchbury and Peyton Jones <ref> [LP94] </ref> also avoids the split (T; V 1 ; V 2 ; dha 1 i fl hzi ! ha 2 ie) = let M = least-eect (a 1 ) in if T " M 6= ; and M 6 T then let ^x and ^y be fresh variables in let (i; <p> The automatic extraction of independent parts of state threads as shown in Sections 5.2 and 7 does not depend on our specitc encapsulation mechanism, it works as well with the encapsulation proposed by Launchbury and Peyton Jones <ref> [LP94] </ref>. A Operational Semantics The intended setting for the development in the main text is an enriched lazy -calculus. Its syntax is given by where X is an intnite set of variables and K is a set of constant symbols each with a specitc arity (a natural number).
Reference: [Mog89] <author> Eugenio Moggi. </author> <title> Computational lambda-calculus and monads. </title> <booktitle> In Proc. of the 4rd Annual Symposium on Logic in Computer Science, </booktitle> <pages> pages 1423, </pages> <address> Pacitc Grove, CA, June 1989. </address> <publisher> IEEE Computer Society Press. </publisher>
Reference-contexts: Two references are not aliased if their terminator types cannot be equal. In the case of references which may be aliased the original sequence of their update actions must be retained using the mechanism outlined above. 9 Related Work Following Moggi <ref> [Mog89] </ref>, Wadler [Wad90, Wad92] advocates the use of monads to express state-based computations in functional programming. Peyton Jones and Wadler [PW93] have used the state monad to ensure proper sequencing of I/O operations and assignment operations on references.
Reference: [MP88] <author> John C. Mitchell and Gordon D. Plotkin. </author> <title> Abstract types have existential types. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 10(3):470502, </volume> <month> July </month> <year> 1988. </year>
Reference-contexts: There is a type reconstruction algorithm [Thi93] which handles them like nullary type constructors (cf. the Skolem type constructors used by Lufer and Odersky [LO92] to model abstract types by existentially quantited types as pioneered by Mitchell and Plotkin <ref> [MP88] </ref>). However, there is no special syntax to introduce a value with an abstract type and type declarations are required to introduce abstract type variables.
Reference: [ORH93] <author> Martin Odersky, Daniel Rabin, and Paul Hudak. </author> <title> Call-by-name, assignment, and the lambda calculus. </title> <booktitle> In POPL1993 [POP93], </booktitle> <pages> pages 4357. </pages>
Reference-contexts: In our work fork is introduced by a transformation and is thus correct once the correctness of the transformation is established. Chen and Odersky [CO93] describe a stratited type system for var <ref> [ORH93] </ref>, a lambda calculus extended by imperative features. The system has a type reconstruction algorithm. It is not capable of handling nested state transformers which compute state transformers themselves. The type system proposed here provides that capability. Furthermore, var is much more strict than our intended semantics.
Reference: [Pey87] <editor> Simon L. Peyton Jones. </editor> <booktitle> The Implementation of Functional Programming Languages. </booktitle> <publisher> Prentice Hall, </publisher> <year> 1987. </year>
Reference-contexts: The usual conventions for omitting parentheses apply throughout (application associates to the left and the scope of an abstraction extends as far to the right as possible). The operational semantics is detned by graph rewriting as originally proposed by Wadsworth [Wad71], see also <ref> [Pey87] </ref>. Graphs are rewritten according to the functional strategy [KSvP93] which enriches priority-based term graph rewriting with demand driven rewriting due to pattern matching. Graph nodes are labelled with constants, variables, x, or @ (application) and each node has a list of successors.
Reference: [POP93] <editor> Proc. </editor> <booktitle> 20th ACM Symposium on Principles of Programming Languages, </booktitle> <address> Charleston, South Carolina, </address> <month> January </month> <year> 1993. </year> <note> ACM Press. </note>
Reference: [PW93] <editor> Simon L. Peyton Jones and Philip L. Wadler. </editor> <title> Imperative functional programming. </title> <booktitle> In POPL1993 [POP93], </booktitle> <pages> pages 7184. </pages>
Reference-contexts: Among them is the monad of state transformers (state monad, for short) [Wad90, Wad92] which encapsulates the propagation of a state through a whole computation. It provides proper sequencing of I/O operations <ref> [PW93] </ref> or lazy computations with mutable variables and arrays [Lau93]. In this approach, references to mutable variables and arrays are trst-class values which are created and manipulated by primitive operations of the monad. <p> which accepts an initial state value and an action to produce the result after running the action on the initial state (fst returns the trst component of a pair). exec :: s -&gt; ST s v -&gt; v exec init action = fst (action init) Peyton Jones, Wadler, and Launchbury <ref> [PW93, Lau93] </ref> have suggested a more powerful way to use the sequentialization imposed by state transformers. They enhance state transformers by primitive actions to perform an I/O operation, create a reference, read a reference, or assign to a reference. <p> Example 1 let r = run (crtRef 0) a = incrRef r fl () -&gt; getRef r in (run a, run a) 1 The strictness can be made explicit at the source level by using an algebraic datatype data D x = D x as the state type as in <ref> [PW93, LP94] </ref>. Since that complicates the types we just state the required strictness. By referential transparency, the value of this expression should be a pair of equal numbers. However, depending on the context its value is either (1; 2) or (2; 1). <p> It remains to establish the means to run them independently and to feed back the values of the bound variables of a 1 to a 2 and vice versa. The trst goal is met with the operation interleave :: ST s v -&gt; ST s v <ref> [PW93, LP94] </ref>. split (T; V 1 ; V 2 ; d (ha 1 i fl hxi ! ha 2 i) fl ha 3 ie) = split (T; V 1 ; V 2 ; dha 1 i fl hxi ! (ha 2 i fl ha 3 i)e) (1) split (T; V 1 <p> The transformed expression depends crucially on the irrefutability of the pattern binding (z 1 ; hV 1 i; hV 2 i) = z 0 . Otherwise the required cyclic bindings cannot be established. 6.1 Example: Lazy File Read The motivating example of <ref> [PW93, LP94] </ref> for interleave is the implementation of lazy tle read. The state monad cannot only be used to ensure correct sequencing of actions on references, but it can sequence I/O actions as well. <p> In the case of references which may be aliased the original sequence of their update actions must be retained using the mechanism outlined above. 9 Related Work Following Moggi [Mog89], Wadler [Wad90, Wad92] advocates the use of monads to express state-based computations in functional programming. Peyton Jones and Wadler <ref> [PW93] </ref> have used the state monad to ensure proper sequencing of I/O operations and assignment operations on references. Launchbury describes a lazy implementation of mutable arrays and variables in terms of a sequencing monad [Lau93].
Reference: [SBvP93] <author> Sjaak Smetsers, Erik Barendsen, Marko van Eekelen, and Rinus Plasmeijer. </author> <title> Guaranteeing safe destructive updates through a type system with uniqueness information for graphs. </title> <type> Technical Report 93-4, </type> <institution> Department of Computer Science, University of Ni-jmegen, </institution> <year> 1993. </year>
Reference-contexts: Since the programming style in their calculus is strongly inu-enced by continuation-passing style, it is questionable whether parallelization can be achieved solely by program transformation, as suggested here. Smetsers et al. <ref> [SBvP93] </ref> describe a uniqueness type system for term graph rewrite systems. If a node of a redex can be assigned a unique type the corresponding node can be updated destructively, i.e. it can be reused in the contractum.
Reference: [SRI91] <author> Vipin Swarup, Uday S. Reddy, and Evan Ire-land. </author> <title> Assignments for applicative languages. </title> <editor> In John Hughes, editor, </editor> <booktitle> Proc. Functional Programming Languages and Computer Architecture 1991, pages 192214, </booktitle> <address> Cambridge, MA, 1991. </address> <publisher> Springer-Verlag. LNCS 523. </publisher>
Reference-contexts: In var , a state-based computation can only return a value after all operations (assignments and reads) on the state are completed. State transformers can return partial results since they implement lazy state and can defer some operations on the state. Swarup, Reddy, and Ireland <ref> [SRI91] </ref> have detned a calculus which extends the lambda calculus by reference variables and operations on them. The absence of side-eects in the calculus relies on a stratited type system which distinguishes pure expressions, observers, and mutators.
Reference: [Thi93] <author> Peter Thiemann. </author> <title> Safe sequencing of assignments in purely functional programming languages. </title> <type> Technical Report WSI-93-16, </type> <institution> Wilhelm-Schickard-Institut, Tbingen, Ger-many, </institution> <month> November </month> <year> 1993. </year>
Reference-contexts: The transformation relies on an eect annotation of the type constructor for state transformers. The eect annotation describes the use of mutable objects in the local state. The mechanism of upward and downward abstract types is quite similar to existentially quantited types. There is a type reconstruction algorithm <ref> [Thi93] </ref> which handles them like nullary type constructors (cf. the Skolem type constructors used by Lufer and Odersky [LO92] to model abstract types by existentially quantited types as pioneered by Mitchell and Plotkin [MP88]). <p> But existentially quantited type variables are not enough: a function of type 8s; v; : : : :(ST s v ! v) ! : : : can take run as a parameter and reconstruct the situation in Example 1 in its body (see <ref> [Thi93] </ref>). It follows that passing run as a parameter must be ruled out 2 . The following rule ensures this. <p> Therefore, the check if some ff was introduced to the left of the current node of the derivation tree boils down to compare the name of ff with the current name supply. The formalization of this is rather technical and details on it are found in a technical report <ref> [Thi93] </ref>. 2 This eect is achieved in [LP94] by giving run the rank-2 type 8ff:(8fi:ST fi ff) ! ff. 4 Introducing Terminators Arrays in pure functional languages are usually monolithic (the contents cannot be detned incrementally) and immutable (the contents cannot be mod-ited).
Reference: [Wad71] <author> Christopher P. Wadsworth. </author> <title> Semantics and Pragmatics of the Lambda Calculus. </title> <type> PhD thesis, </type> <institution> Programming Research Group, Oxford University, </institution> <year> 1971. </year>
Reference-contexts: The usual conventions for omitting parentheses apply throughout (application associates to the left and the scope of an abstraction extends as far to the right as possible). The operational semantics is detned by graph rewriting as originally proposed by Wadsworth <ref> [Wad71] </ref>, see also [Pey87]. Graphs are rewritten according to the functional strategy [KSvP93] which enriches priority-based term graph rewriting with demand driven rewriting due to pattern matching. Graph nodes are labelled with constants, variables, x, or @ (application) and each node has a list of successors.
Reference: [Wad90] <author> Philip L. Wadler. </author> <title> Comprehending monads. </title> <booktitle> In Proc. Conference on Lisp and Functional Programming, </booktitle> <pages> pages 6178, </pages> <address> Nice, France, 1990. </address> <publisher> ACM. </publisher>
Reference-contexts: Recent approaches to augment purely functional programming languages with mutable data structures have introduced abstract datatypes which ensure single-threaded handling of mutable data structures. Among them is the monad of state transformers (state monad, for short) <ref> [Wad90, Wad92] </ref> which encapsulates the propagation of a state through a whole computation. It provides proper sequencing of I/O operations [PW93] or lazy computations with mutable variables and arrays [Lau93]. <p> Finally, in Section 8, we discuss what to do when a clean separation in independent parts is not possible. Section 9 discusses related work and Section 10 concludes. 2 State Transformers A state transformer <ref> [Wad90, Wad92] </ref> is a function which maps an initial state to a result paired with a tnal state. Its type detnition is: type ST state value = state -&gt; (value, state) This declaration introduces the type constructor ST with two parameters state and value with the obvious meanings. <p> Two references are not aliased if their terminator types cannot be equal. In the case of references which may be aliased the original sequence of their update actions must be retained using the mechanism outlined above. 9 Related Work Following Moggi [Mog89], Wadler <ref> [Wad90, Wad92] </ref> advocates the use of monads to express state-based computations in functional programming. Peyton Jones and Wadler [PW93] have used the state monad to ensure proper sequencing of I/O operations and assignment operations on references.
Reference: [Wad92] <author> Philip L. Wadler. </author> <title> The essence of functional programming. </title> <booktitle> In Proc. 19th ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 114, </pages> <address> Albuquerque, New Mex-ico, </address> <month> January </month> <year> 1992. </year>
Reference-contexts: Recent approaches to augment purely functional programming languages with mutable data structures have introduced abstract datatypes which ensure single-threaded handling of mutable data structures. Among them is the monad of state transformers (state monad, for short) <ref> [Wad90, Wad92] </ref> which encapsulates the propagation of a state through a whole computation. It provides proper sequencing of I/O operations [PW93] or lazy computations with mutable variables and arrays [Lau93]. <p> Finally, in Section 8, we discuss what to do when a clean separation in independent parts is not possible. Section 9 discusses related work and Section 10 concludes. 2 State Transformers A state transformer <ref> [Wad90, Wad92] </ref> is a function which maps an initial state to a result paired with a tnal state. Its type detnition is: type ST state value = state -&gt; (value, state) This declaration introduces the type constructor ST with two parameters state and value with the obvious meanings. <p> Two references are not aliased if their terminator types cannot be equal. In the case of references which may be aliased the original sequence of their update actions must be retained using the mechanism outlined above. 9 Related Work Following Moggi [Mog89], Wadler <ref> [Wad90, Wad92] </ref> advocates the use of monads to express state-based computations in functional programming. Peyton Jones and Wadler [PW93] have used the state monad to ensure proper sequencing of I/O operations and assignment operations on references.
References-found: 21

