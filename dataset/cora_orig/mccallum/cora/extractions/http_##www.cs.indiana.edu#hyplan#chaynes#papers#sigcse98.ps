URL: http://www.cs.indiana.edu/hyplan/chaynes/papers/sigcse98.ps
Refering-URL: http://www.cs.indiana.edu/hyplan/chaynes.html
Root-URL: http://www.aic.nrl.navy.mil/~aha/people.html
Email: chaynes@indiana.edu  
Title: Experience with an Analytic Approach to Teaching Programming Languages  
Author: Christopher T. Haynes 
Address: Bloomington, IN 47405  
Affiliation: Computer Science Department Indiana University  
Abstract:  
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> ABELSON, H., AND JAY SUSSMAN WITH JULIE SUSSMAN, G. </author> <title> Structure and Interpretation of Computer Programs, second ed. </title> <publisher> MIT Press, </publisher> <year> 1996. </year>
Reference-contexts: tradition is particularly strong in the histories of Lisp and Scheme, with interpreters playing a central role in the seminal works on both languages. [7, 12] At least two programming languages textbooks are based substantially on the use of interpreters [3, 8], and several introductory Scheme texts include simple interpreters <ref> [1, 2, 10] </ref>. In the next section we give an example of such an interpreter. Next we suggest some of the wide variety of semantic variations that are possible using interpreters and related programs. Then we review practical considerations that may be critical in teaching with this approach.
Reference: [2] <author> FRIEDMAN, D. P., AND FELLEISEN, M. </author> <title> The Little Schemer, fourth ed. </title> <publisher> MIT Press, </publisher> <year> 1996. </year>
Reference-contexts: tradition is particularly strong in the histories of Lisp and Scheme, with interpreters playing a central role in the seminal works on both languages. [7, 12] At least two programming languages textbooks are based substantially on the use of interpreters [3, 8], and several introductory Scheme texts include simple interpreters <ref> [1, 2, 10] </ref>. In the next section we give an example of such an interpreter. Next we suggest some of the wide variety of semantic variations that are possible using interpreters and related programs. Then we review practical considerations that may be critical in teaching with this approach.
Reference: [3] <author> FRIEDMAN, D. P., WAND, M., AND HAYNES, C. T. </author> <title> Essentials of Programming Languages. </title> <publisher> MIT Press and McGraw-Hill, </publisher> <year> 1991. </year>
Reference-contexts: For reasons we shall discuss, the interpreter tradition is particularly strong in the histories of Lisp and Scheme, with interpreters playing a central role in the seminal works on both languages. [7, 12] At least two programming languages textbooks are based substantially on the use of interpreters <ref> [3, 8] </ref>, and several introductory Scheme texts include simple interpreters [1, 2, 10]. In the next section we give an example of such an interpreter. Next we suggest some of the wide variety of semantic variations that are possible using interpreters and related programs. <p> Variations on parameter-passing mechanisms such as call-by value, call-by-reference, call-by-name, and call-by-need are quite instructive and relatively straightforward. A variety of parameter-passing variations can be achieved simply by changing auxiliary function definitions if one starts with a sufficiently abstract interpreter. <ref> [3] </ref> Modeling such object-oriented programming features as static and dynamic method binding, instance variables, inheritance, self reference, and even meta-level shifts are possible with somewhat (but not substantially) more complicated interpreters. [3] Other syntax-directed forms of program analysis, such as static type checking [6] and compilation [5], may be accomplished in <p> parameter-passing variations can be achieved simply by changing auxiliary function definitions if one starts with a sufficiently abstract interpreter. <ref> [3] </ref> Modeling such object-oriented programming features as static and dynamic method binding, instance variables, inheritance, self reference, and even meta-level shifts are possible with somewhat (but not substantially) more complicated interpreters. [3] Other syntax-directed forms of program analysis, such as static type checking [6] and compilation [5], may be accomplished in a remarkably similar style. It is also possible to learn much by varying the style of an interpreter while maintaining the same interpreted language. <p> The continuation-passing style (CPS) transformation is of particular interest. It removes control ambiguities in the semantics of the interpreted language that were previously resolved by the host language, allows non-standard control operations such as non-local breaks to be easily added to the interpreted language, and highlights tail-calls. <ref> [3] </ref> Another variation models the store (assignable memory) directly as an object that is passed dynamically in the interpreter. <p> Debugging is also facilitated, since there is a built-in printer for s-expressions. If it is desired to support more traditional syntax, a parser that produces syntax trees in the form of s-expressions may be used (as in <ref> [3] </ref>). In the design of programming languages it is now customary to define a core syntax, which cannot reasonably be translated into a smaller syntax, and derived syntax, which may be transformed into core syntax.
Reference: [4] <author> GUNTER, C. A. </author> <title> Semantics of Programming Languages. </title> <publisher> MIT Press, </publisher> <year> 1992. </year>
Reference-contexts: This has prompted the development in the last quarter-century of an extensive theory of programming languages, based on rigorous mathematical techniques such as denotational semantics and structural operational semantics. Recently a variety of textbooks have appeared based on such analytic techniques, such as Gunter <ref> [4] </ref> and Winskel [15]. Unfortunately the mathematical sophistication required for the use of formal semantic techniques makes them unsuitable for most undergraduates. In addition, technology to simulate the behavior of programming languages based on such formal specifications is generally unavailable, and always complex.
Reference: [5] <author> HAYNES, C. T. </author> <title> Compiling: A high-level introduction using scheme. </title> <booktitle> In Proceedings of the Twenty-Eighth SIGCSE Technical Symposium on Computer Science Education (1997), </booktitle> <pages> pp. 253257. </pages>
Reference-contexts: a sufficiently abstract interpreter. [3] Modeling such object-oriented programming features as static and dynamic method binding, instance variables, inheritance, self reference, and even meta-level shifts are possible with somewhat (but not substantially) more complicated interpreters. [3] Other syntax-directed forms of program analysis, such as static type checking [6] and compilation <ref> [5] </ref>, may be accomplished in a remarkably similar style. It is also possible to learn much by varying the style of an interpreter while maintaining the same interpreted language. The continuation-passing style (CPS) transformation is of particular interest.
Reference: [6] <author> HAYNES, C. T. </author> <title> Type checking and inference. </title> <type> Technical Report 491, </type> <institution> Indiana University, Bloomington, Indi-ana, </institution> <year> 1997. </year>
Reference-contexts: one starts with a sufficiently abstract interpreter. [3] Modeling such object-oriented programming features as static and dynamic method binding, instance variables, inheritance, self reference, and even meta-level shifts are possible with somewhat (but not substantially) more complicated interpreters. [3] Other syntax-directed forms of program analysis, such as static type checking <ref> [6] </ref> and compilation [5], may be accomplished in a remarkably similar style. It is also possible to learn much by varying the style of an interpreter while maintaining the same interpreted language. The continuation-passing style (CPS) transformation is of particular interest.
Reference: [7] <author> JOHN MCCARTHY, et al.. </author> <title> LISP 1.5 Programmer's Manual. </title> <publisher> MIT Press, </publisher> <year> 1962. </year>
Reference-contexts: For reasons we shall discuss, the interpreter tradition is particularly strong in the histories of Lisp and Scheme, with interpreters playing a central role in the seminal works on both languages. <ref> [7, 12] </ref> At least two programming languages textbooks are based substantially on the use of interpreters [3, 8], and several introductory Scheme texts include simple interpreters [1, 2, 10]. In the next section we give an example of such an interpreter.
Reference: [8] <author> KAMIN, S. N. </author> <title> Programming Languages: An Imterpreter-based Approach. </title> <publisher> aw, </publisher> <year> 1990. </year>
Reference-contexts: For reasons we shall discuss, the interpreter tradition is particularly strong in the histories of Lisp and Scheme, with interpreters playing a central role in the seminal works on both languages. [7, 12] At least two programming languages textbooks are based substantially on the use of interpreters <ref> [3, 8] </ref>, and several introductory Scheme texts include simple interpreters [1, 2, 10]. In the next section we give an example of such an interpreter. Next we suggest some of the wide variety of semantic variations that are possible using interpreters and related programs.
Reference: [9] <author> MACLENNAN, B. J. </author> <title> Principles of Programming Languages: Design, Evolution, and Implementation, </title> <editor> second ed. Holt-Rinehart & Winston, </editor> <year> 1997. </year>
Reference-contexts: Principles were described informally (in natural language) and illustrated with related features in well known programming languages. This was an improvement, and almost all programming language texts intended for undergraduates are still of this kind. Sethi [11] is a modern example of this approach, while MacLennan <ref> [9] </ref> combines the language survey and principle-based approaches. Programming languages generally have a large number of features that are for most purposes adequately treated by such descriptive techniques.
Reference: [10] <author> MANIS, V. S., AND LITTLE, J. J. </author> <title> The Schematics of Computation. </title> <publisher> Prentice-Hall, </publisher> <year> 1995. </year>
Reference-contexts: tradition is particularly strong in the histories of Lisp and Scheme, with interpreters playing a central role in the seminal works on both languages. [7, 12] At least two programming languages textbooks are based substantially on the use of interpreters [3, 8], and several introductory Scheme texts include simple interpreters <ref> [1, 2, 10] </ref>. In the next section we give an example of such an interpreter. Next we suggest some of the wide variety of semantic variations that are possible using interpreters and related programs. Then we review practical considerations that may be critical in teaching with this approach.
Reference: [11] <author> SETHI, R. </author> <title> Programming Languages: Concepts and Constructs, second ed. </title> <publisher> Addison-Wesley, </publisher> <year> 1996. </year>
Reference-contexts: Principles were described informally (in natural language) and illustrated with related features in well known programming languages. This was an improvement, and almost all programming language texts intended for undergraduates are still of this kind. Sethi <ref> [11] </ref> is a modern example of this approach, while MacLennan [9] combines the language survey and principle-based approaches. Programming languages generally have a large number of features that are for most purposes adequately treated by such descriptive techniques.
Reference: [12] <author> SUSSMAN, G. J., AND STEELE JR., G. L. </author> <title> Scheme: an interpreter for extended lambda calculus. </title> <type> Tech. Rep. AI Memo No. 349, </type> <institution> MIT Artificial Intelligence Laboratory, </institution> <year> 1975. </year> <note> [13] www.cs.indiana.edu/scheme-repository. [14] www.cs.indiana.edu/eip. </note>
Reference-contexts: For reasons we shall discuss, the interpreter tradition is particularly strong in the histories of Lisp and Scheme, with interpreters playing a central role in the seminal works on both languages. <ref> [7, 12] </ref> At least two programming languages textbooks are based substantially on the use of interpreters [3, 8], and several introductory Scheme texts include simple interpreters [1, 2, 10]. In the next section we give an example of such an interpreter.
Reference: [15] <author> WINSKEL, G. </author> <title> The Formal Semantics of Programming Languages: An Introduction. </title> <publisher> MIT Press, </publisher> <year> 1993. </year>
Reference-contexts: This has prompted the development in the last quarter-century of an extensive theory of programming languages, based on rigorous mathematical techniques such as denotational semantics and structural operational semantics. Recently a variety of textbooks have appeared based on such analytic techniques, such as Gunter [4] and Winskel <ref> [15] </ref>. Unfortunately the mathematical sophistication required for the use of formal semantic techniques makes them unsuitable for most undergraduates. In addition, technology to simulate the behavior of programming languages based on such formal specifications is generally unavailable, and always complex.
References-found: 13

