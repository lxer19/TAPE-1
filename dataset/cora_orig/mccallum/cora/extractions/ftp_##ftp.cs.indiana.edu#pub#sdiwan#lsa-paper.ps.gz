URL: ftp://ftp.cs.indiana.edu/pub/sdiwan/lsa-paper.ps.gz
Refering-URL: http://www.cs.indiana.edu/hyplan/sdiwan.html
Root-URL: http://www.cs.indiana.edu
Title: The Linear System Analyzer  
Author: R. Bramley, D. Gannon, T. Stuckey, J. Villacis, E. Akman, J. Balasubramanian, F. Breg, S. Diwan, M. Govindaraju 
Address: Bloomington, IN  
Affiliation: Department of Computer Science Indiana University  
Abstract: The Linear System Analyzer (LSA) is a component-based problem-solving environment (PSE) for the manipulation and solution of large sparse linear systems of equations. Both the underlying component infrastructure and its application to the problem area of linear systems are introduced. Initial results indicate the utility of clearly separating the PSE infrastructure from the particular problem domain(s) which use it, leading to a resuable PSE builder. The component approach provides coarse-grain parallelism between components, allowing larger problems to be solved by simultaneously using the computational resources of multiple machines. Furthermore, the LSA system allows side-by-side comparisons of methods and rapid experimentation to develop practical solution strategies. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> E. Anderson et al. </author> <note> LAPACK User's Guide. </note> <institution> Society for Industrial and Applied Mathematics, </institution> <address> Philadelphia, 1 edition, </address> <year> 1992. </year>
Reference-contexts: [12] routines. * Scale (Filter) applies row and/or column scaling, and equilibration. * Squeeze (Filter) removes entries based on their relative absolute value. * Banded (Solver) is based on Linpack [6] routines, and converts the system to banded data structure and then solves the system. * Dense (Solver) uses Lapack <ref> [1] </ref> routines to solve the system after first converting the system to a dense 2D array data structure. * SuperLU (Solver) is a sparse direct solver based on supernodal methods, and is a code developed at UC Berkeley [5]. * SPLIB (Solver) is a package of preconditioned iterative solvers developed at <p> These base classes define the interaction between the generic module and the computational code. The amount of programming required for the wrapper can vary depending on the complexity of the computational component. For LAPACK <ref> [1] </ref> functions, the wrapper is simple and primarily converts error code values to text messages. However, a library like SPLIB [3] requires an extensive wrapper that must interact with the local file system. In general, the complexity of the wrapper code depends on whether the original library code is reentrant.
Reference: [2] <institution> Scientific Computing Associates. Paradise Product Information, </institution> <address> visited 7 March 98. http://www.sca.com/paradise.html. </address>
Reference-contexts: The GUI is used in a fashion similar to the Iris Explorer [13] or Paradise <ref> [2] </ref> systems. It presents a list of machines and selecting one causes a database query which returns the palette of components available on that machine. A user clicks on a button in the palette to choose that component, and the LSA system starts it on the selected machine.
Reference: [3] <author> Randall Bramley and Xiaoge Wang. SPLIB: </author> <title> A library of iterative methods for sparse linear system. </title> <type> Technical report, </type> <institution> Indiana University-Bloomington, Bloomington, </institution> <note> IN 47405, </note> <year> 1995. </year>
Reference-contexts: solve the system after first converting the system to a dense 2D array data structure. * SuperLU (Solver) is a sparse direct solver based on supernodal methods, and is a code developed at UC Berkeley [5]. * SPLIB (Solver) is a package of preconditioned iterative solvers developed at Indiana University <ref> [3] </ref>. SPLIB includes thirteen iterative methods and seven preconditioners. These are not an exhaustive compendium of numerical software available for large sparse linear systems, but they span enough of the common operations to demonstrate the application of the LSA. <p> The amount of programming required for the wrapper can vary depending on the complexity of the computational component. For LAPACK [1] functions, the wrapper is simple and primarily converts error code values to text messages. However, a library like SPLIB <ref> [3] </ref> requires an extensive wrapper that must interact with the local file system. In general, the complexity of the wrapper code depends on whether the original library code is reentrant.
Reference: [4] <author> Fabian Breg, Shridhar Diwan, Juan Villacis, Jayashree Balasubramanian, Esra Akman, and Dennis Gannon. </author> <title> Java RMI performance and object model interoperability: Experiments with Java/HPC++. Concurrency and Experience, </title> <booktitle> 1998. Presented at 1998 ACM Workshop on Java for High-Performance Network Computing. </booktitle>
Reference-contexts: For example, when component A needs to send its sparse system to component B, A remotely invokes a RecvSystem () function on B, which then gets the system from A. Some details of how this is handled are in <ref> [4] </ref>. 7 Icon 4.4 Information Subsystem Providing information about the solution process to the user is critical for any problem-solving environment. However, the component architecture idea works against the integrated approaches typically used when building PSEs.
Reference: [5] <author> James Demmel, Stanley Eisenstat, John Gilbert, Xiaoye Li, and Joseph Liu. </author> <title> A supern-odal approach to sparse partial pivoting. </title> <type> Technical Report 883, </type> <institution> University of California-Berkeley, </institution> <year> 1995. </year> <note> Submitted to SIAM J. Sci. Comp., and available at ftp.cs.berkeley.edu. </note>
Reference-contexts: data structure and then solves the system. * Dense (Solver) uses Lapack [1] routines to solve the system after first converting the system to a dense 2D array data structure. * SuperLU (Solver) is a sparse direct solver based on supernodal methods, and is a code developed at UC Berkeley <ref> [5] </ref>. * SPLIB (Solver) is a package of preconditioned iterative solvers developed at Indiana University [3]. SPLIB includes thirteen iterative methods and seven preconditioners.
Reference: [6] <author> J. Dongarra, C. Moler, R. Bunch, and G.W. Stewart. </author> <title> Linpack User's Guide. </title> <institution> Society for Industrial and Applied Mathematics, </institution> <address> Philadelphia, 1 edition, </address> <year> 1979. </year>
Reference-contexts: These are modifications of Sparspak [12] routines. * Scale (Filter) applies row and/or column scaling, and equilibration. * Squeeze (Filter) removes entries based on their relative absolute value. * Banded (Solver) is based on Linpack <ref> [6] </ref> routines, and converts the system to banded data structure and then solves the system. * Dense (Solver) uses Lapack [1] routines to solve the system after first converting the system to a dense 2D array data structure. * SuperLU (Solver) is a sparse direct solver based on supernodal methods, and
Reference: [7] <author> Iain S. Duff, Roger G. Grimes, and John G. Lewis. </author> <title> "Users Guide for the Harwell-Boeing Sparse Matrix Collection (Release I)". </title> <type> Technical report, </type> <institution> Cedex and Boeing Computer Services, </institution> <month> October </month> <year> 1992. </year>
Reference-contexts: One goal of the LSA project has been to provide rapid encapsulation of existing codes, including both object-oriented and procedural languages. The components currently available are: * NewSystem (I/O) uses some local and some Sparskit routines to read a system in a Harwell-Boeing <ref> [7] </ref> or Matrix Market [16] formatted file into the LSA. Later this will be extended to accept input from a running process. * ExtractVector (I/O) outputs a vector to a file or another component.
Reference: [8] <institution> Center for Research on Parallel Computing. Nhse: National hpcc software exchange, </institution> <address> visited 7 March 1998. http://www.nhse.org/. </address>
Reference-contexts: Much of this research has been incorporated in sophisticated libraries and codes which are freely available through Netlib and the National High-Performance Software Exchange <ref> [8] </ref>, as well as individual researchers' Web sites.
Reference: [9] <author> I. Foster and C. Kesselman. Globus: </author> <title> A Metacomputing Infrastructure Toolkit. </title> <journal> International Journal of Supercomputer Applications, </journal> <note> 1997. To appear. </note>
Reference-contexts: The second role is to assign unique identifiers, as well as maintain and access the database of available machines and components. Having a minimal modular manager will facilitate its future replacement by the more sophisticated resource management system in Globus <ref> [9] </ref>. 4.3 Communication Subsystem The basic communication runtime system in the LSA is Nexus [10] from Argonne National Laboratory. This cross-platform system is designed for parallel applications and wide-area distributed computing. Nexus uses multi-threading, can take advantage of multiple communications protocols, and provides a bridge between Java and C++.
Reference: [10] <author> I. Foster, C. Kesselman, and S. Tuecke. </author> <title> The Nexus Approach to Integrating Multi-threading and Communication. </title> <journal> J. Parallel and Distributed Computing, </journal> <volume> 37 </volume> <pages> 70-82, </pages> <year> 1996. </year> <month> 11 </month>
Reference-contexts: Having a minimal modular manager will facilitate its future replacement by the more sophisticated resource management system in Globus [9]. 4.3 Communication Subsystem The basic communication runtime system in the LSA is Nexus <ref> [10] </ref> from Argonne National Laboratory. This cross-platform system is designed for parallel applications and wide-area distributed computing. Nexus uses multi-threading, can take advantage of multiple communications protocols, and provides a bridge between Java and C++. This bridge is needed because the LSA is a mixed language system.
Reference: [11] <author> D. Gannon, P. Beckman, E. Johnson, and T. Green. </author> <title> Compilation Issues on Distributed Memory Systems, chapter 3 HPC++ and the HPC++Lib Toolkit. </title> <publisher> Springer-Verlag, </publisher> <year> 1997. </year>
Reference-contexts: Nexus uses multi-threading, can take advantage of multiple communications protocols, and provides a bridge between Java and C++. This bridge is needed because the LSA is a mixed language system. The user control system is in Java, but each computational component is provided with a light-weight wrapper in HPC++ <ref> [11] </ref>, which interacts with a generic control module. The wrapper is implemented as a C++ class that inherits its interface from two abstract base classes. These base classes define the interaction between the generic module and the computational code.
Reference: [12] <author> A. George and W-H Liu. </author> <title> The Computer Solution of Large Sparse Positive Definite Systems. </title> <publisher> Prentice-Hall, </publisher> <address> Engelwood Cliffs, NJ, </address> <year> 1981. </year>
Reference-contexts: It also creates a GIF image of the sparsity (nonzero) structure of the coefficient matrix. 3 * Reorder (Filter) applies some standard re-orderings: reverse Cuthill-McKee, nested dissection, and minimum degree. These are modifications of Sparspak <ref> [12] </ref> routines. * Scale (Filter) applies row and/or column scaling, and equilibration. * Squeeze (Filter) removes entries based on their relative absolute value. * Banded (Solver) is based on Linpack [6] routines, and converts the system to banded data structure and then solves the system. * Dense (Solver) uses Lapack [1]
Reference: [13] <institution> Numerical Algorithms Group. </institution> <note> IRIS Explorer, visited 8-20-97. http://www.nag.co.uk/Welcome IEC.html. </note>
Reference-contexts: The GUI is used in a fashion similar to the Iris Explorer <ref> [13] </ref> or Paradise [2] systems. It presents a list of machines and selecting one causes a database query which returns the palette of components available on that machine.
Reference: [14] <author> Kate Keahey and Dennis Gannon. PARDIS: </author> <title> A Parallel Approach to CORBA. </title> <booktitle> In 6th IEEE International Symposium on High Performance Distributed Computation, </booktitle> <month> August </month> <year> 1997. </year>
Reference-contexts: Both kinds of study are greatly enhanced by the information subsystem, which also provides primitive archiving capabilities. Several research directions are extending the LSA. Among these are the development of methods for components implementing parallel algorithms for this a critical problem is parallel communications between components <ref> [14] </ref>.
Reference: [15] <author> David Krieger and Richard M. Adler. </author> <title> The emergence of distributed component platforms. </title> <journal> IEEE Computer, </journal> <volume> 31(3) </volume> <pages> 43-53, </pages> <month> March </month> <year> 1998. </year>
Reference-contexts: 1 Introduction An important new paradigm in software engineering has been the emergence of distributed component architectures. In this context, components are reusable building blocks for the construction of software systems <ref> [19, 15] </ref>. Modern systems for composing components include Microsoft's ActiveX/DCOM and Sun's JavaBeans and JavaStudio. Conceptually, a user has a palette of components from which to choose, and can compose or wire them together to create complete applications.
Reference: [16] <institution> National Institute of Standards and Technology. </institution> <note> Matrix market, visited 8 March 1998. http://math.nist.gov/MatrixMarket/. </note>
Reference-contexts: One goal of the LSA project has been to provide rapid encapsulation of existing codes, including both object-oriented and procedural languages. The components currently available are: * NewSystem (I/O) uses some local and some Sparskit routines to read a system in a Harwell-Boeing [7] or Matrix Market <ref> [16] </ref> formatted file into the LSA. Later this will be extended to accept input from a running process. * ExtractVector (I/O) outputs a vector to a file or another component.
Reference: [17] <institution> PSEware Research Group. Pseware home page, </institution> <month> 1 October </month> <year> 1997. </year> <note> http://www.extreme.indiana.edu/pseware/. </note>
Reference-contexts: Although component architectures have revolutionized the desktop business application computing environment, they have made few inroads in problem-solving environments for computational science and engineering. As part of the PSEware project <ref> [17] </ref>, we have built a scientific computing component system and implemented a problem-solving environment within it. The Linear System Analyzer (LSA) is an environment for examining and developing solution strategies for large-scale sparse linear systems of equations.
Reference: [18] <author> Y. Saad. SPARSKIT: </author> <title> a basic tool kit for sparse matrix computations. </title> <type> Technical report, </type> <institution> Center for Supercomputing Research and Development, University of Illinois, Urbana, Illinois, </institution> <year> 1990. </year>
Reference-contexts: Much of this research has been incorporated in sophisticated libraries and codes which are freely available through Netlib and the National High-Performance Software Exchange [8], as well as individual researchers' Web sites. Software such as Sparskit <ref> [18] </ref> provides tools for manipulating sparse systems and converting them between standard data structure representations. 2.1 Strategies for Sparse Linear System This profusion of software has brought its own problem; an applications user needs to connect together packages and navigate a combinatorially large parameter space to form an effective solution strategy.
Reference: [19] <author> A. Thomas. </author> <title> A comparison of component models. </title> <booktitle> Distributed Object Computing, </booktitle> <pages> pages 55-57, </pages> <month> July </month> <year> 1997. </year> <month> 12 </month>
Reference-contexts: 1 Introduction An important new paradigm in software engineering has been the emergence of distributed component architectures. In this context, components are reusable building blocks for the construction of software systems <ref> [19, 15] </ref>. Modern systems for composing components include Microsoft's ActiveX/DCOM and Sun's JavaBeans and JavaStudio. Conceptually, a user has a palette of components from which to choose, and can compose or wire them together to create complete applications.
References-found: 19

