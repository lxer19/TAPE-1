URL: http://swarm.cs.wustl.edu/~picco/papers/tosemTR.ps.gz
Refering-URL: http://swarm.cs.wustl.edu/~picco/listpub.html
Root-URL: http://www.cs.wustl.edu
Title: Reasoning About Code Mobility with Mobile UNITY  
Author: Gian Pietro Picco Gruia-Catalin Roman Peter J. McCann 
Date: December 19, 1997  
Address: IN ST LOUIS  Campus Box 1045 One Brookings Drive Saint Louis, MO 63130-4899  
Affiliation: WASHINGTON UNIVERSITY  Washington School of Engineering Applied Science  Department of Computer Science Washington University  
Pubnum: WUCS-97-43  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> R.M. Amadio. </author> <title> An Asynchronous Model of Locality, Failure, and Process Mobility. </title> <booktitle> In Garlan and Metayer [11], </booktitle> <pages> pages 374-391. </pages>
Reference-contexts: In -calculus there is no formal concept of space. Mobility is equated to the ability to "express processes which have changing structure". Under this definition, any model able to pass processes as values, e.g., the Actor model, or link names as values (-calculus) qualifies. Today many researchers <ref> [9, 23, 1] </ref> are building variants and extensions of process algebras in order to provide a better notion of location. Cardelli's work [3], for instance, appears to be directly inspired by the domain of mobile code.
Reference: [2] <author> M. Baldi, S. Gai, </author> <title> and G.P. Picco. Exploiting Code Mobility in Decentralized and Flexible Network Management. </title> <editor> In K. Rothermel and R. Popescu-Zeletin, editors, </editor> <booktitle> Mobile Agents: 1 st International Workshop MA '97, volume 1219 of LNCS, </booktitle> <pages> pages 13-26. </pages> <publisher> Springer, </publisher> <month> Apr. </month> <year> 1997. </year> <month> 35 </month>
Reference-contexts: Actually, many researchers see the main advantage of code mobility as an optimization of communication resources. This does not hold in general [4, 10], and applications can benefit from this kind of optimization in other ways as well <ref> [13, 14, 2] </ref>. We believe that an important benefit of code mobility is the ability to customize dynamically the server according to the user's needs. In client-server applications, the server offers a fixed set of services, defined a priori by the application designer and accessible through a statically defined interface.
Reference: [3] <author> L. Cardelli and A.D. Gordon. </author> <title> Mobile Ambients. </title> <note> Available at http://www.luca.demon.co.uk/Papers.html, July 1997. </note>
Reference-contexts: Under this definition, any model able to pass processes as values, e.g., the Actor model, or link names as values (-calculus) qualifies. Today many researchers [9, 23, 1] are building variants and extensions of process algebras in order to provide a better notion of location. Cardelli's work <ref> [3] </ref>, for instance, appears to be directly inspired by the domain of mobile code. The concept of nested localities whose access is regulated by capabilities associated to mobile processes closely recalls the Telescript model.
Reference: [4] <author> A. Carzaniga, G.P. Picco, and G. Vigna. </author> <title> Designing Distributed Applications with Mobile Code Paradigms. </title> <editor> In R. Taylor, editor, </editor> <booktitle> Proc. of the 19 th Int. Conf. on Software Engineering (ICSE'97), </booktitle> <pages> pages 22-32. </pages> <publisher> ACM Press, </publisher> <year> 1997. </year>
Reference-contexts: 1 Introduction Code mobility is defined informally as the capability, in a distributed application, to dynamically reconfigure the binding between code fragments and the location where they are executed <ref> [4] </ref>. This simple definition, however, raises a lot of questions. <p> This may improve performance by reducing latency and may increase dependability by avoiding problems inherent in partial failures. Actually, many researchers see the main advantage of code mobility as an optimization of communication resources. This does not hold in general <ref> [4, 10] </ref>, and applications can benefit from this kind of optimization in other ways as well [13, 14, 2]. We believe that an important benefit of code mobility is the ability to customize dynamically the server according to the user's needs. <p> The essential features of the interaction patterns found in MCLs can be characterized by considering the kinds of pairwise interactions that are possible between two software design components located on different hosts. As shown in <ref> [4] </ref>, we can accomplish this without having to appeal to the details of any particular language. In the remainder of this section, we will summarize the taxonomy presented in [4] (subject to minor changes in terminology) in order to introduce the reader to the mobile code design paradigms we will express <p> As shown in <ref> [4] </ref>, we can accomplish this without having to appeal to the details of any particular language. In the remainder of this section, we will summarize the taxonomy presented in [4] (subject to minor changes in terminology) in order to introduce the reader to the mobile code design paradigms we will express using Mobile UNITY. The interested reader can find an in-depth discussion of mobile code technologies, paradigms, applications, and their inter-relationship in [10]. <p> Nevertheless, even if our definition of a design component in principle allows sophisticated forms of relocation where different combinations of the constituents are moved, an exhaustive analysis about this issue is outside the scope of this work. We limit our discussion to the design paradigms proposed in <ref> [4] </ref> because they reflect the characteristics of currently available MCLs. In order to provide a basis for comparison, we include the client-server paradigm in our discussion. A schematic view of all the paradigms discussed here appears in Figure 1.
Reference: [5] <author> K.M. Chandy and J. Misra. </author> <title> Distributed Simulation: A Case Study in Design and Verification of Distributed Programs. </title> <journal> IEEE Trans. on Software Engineering, </journal> <volume> 5(5) </volume> <pages> 440-452, </pages> <month> Sept. </month> <year> 1979. </year>
Reference-contexts: We use it first as a vehicle to introduce the reader to the UNITY notation. The example is inspired by the work of Chandy and Misra who provided a formal characterization and solution for a distributed simulation problem <ref> [5] </ref>. The basic idea is to simulate the behavior of a physical system such as an electronic circuit on a network of computing nodes which communicate asynchronously and in the absence of global shared memory.
Reference: [6] <author> K.M. Chandy and J. Misra. </author> <title> Parallel Program Design: A Foundation. </title> <publisher> Addison-Wesley, </publisher> <year> 1988. </year>
Reference-contexts: Furthermore, these kinds of studies may eventually lead to the development of a unified model of mobility. The model we use in our study is called Mobile UNITY [28, 20], an extension of work by Chandy and Misra on UNITY <ref> [6] </ref>. Mobile UNITY provides a programming notation that captures the notion of mobility and transient interactions among mobile nodes and includes an assertional-style proof logic. <p> The value of a local timer can never be behind the GVT. For such cases the function f is undefined. 3.2 A Centralized UNITY Solution In this section, we discuss a solution for the distributed simulation problem using the UNITY notation described in <ref> [6] </ref> and use the associated logic to prove several key properties of the problem. The UNITY program appears in Figure 3. All variable declarations appear in the declare section. The array t contains the values of the local timers for each process i. <p> Hence, according to the consequence weakening theorem <ref> [6] </ref> p unless q; q ) r p unless r (T 9 ) the conclusion holds. Invariant (I 1 ) is proven in the remainder of this section. Invariant (I 2 ), as well as the other introduced in this section, are proven differently in each solution. <p> show that it eventually leads to the goal, that is minTimer ^ oldT ^ noldT ^ :def (Server :q (k)) ^ P (k):RQ = hserver; cs; minServ; fii 7! P (k):t = P (k):T = fi We can exploit this fact through application of the following cancellation theorem of leads-to <ref> [6] </ref> p 7! q _ b; b 7! r : (T 10 ) In our case, application of the cancellation theorem to (cs 14 ) and (cs 15 ) yields minTimer ^ oldClientT ^ Server :T &lt; fi ^ :def (Server :q (k)) 7! (minTimer ^ oldClientT ^ Server :T &lt; <p> Invariant (ma 1 ) states that Server is always co-located with some client, while lemma (ma 2 ) guarantees that Server is forced to visit the next node. Proof of (L 2 ). Our proof will exploit the progress-safety-progress theorem (PSP) <ref> [6] </ref> p 7! q; r unless b p ^ r 7! (q ^ r) _ b 21 P (k):t = hmin l :: Server:o (l)i = fi 7! P (k):t = P (k):T = fi (L 2 ) P (k):t = P (k):T = fi ensures P (k):t &gt; fi (L
Reference: [7] <author> G. Cugola, C. Ghezzi, G.P. Picco, and G. Vigna. </author> <title> Analyzing Mobile Code Languages. </title> <booktitle> In Vitek and Tschudin [33], </booktitle> <pages> pages 93-111. </pages>
Reference-contexts: This network centric style of computing is at the center of the emerging mobile code languages. For a comprehensive survey of MCLs, the reader is directed to <ref> [7] </ref> which reviews a number of existing languages and attempts to extract their essential features. The unit of mobility, called executing unit (EU) in [7], is implemented differently in different languages, but can be thought of as a process in an operating system or a thread in a multi-threaded environment. <p> For a comprehensive survey of MCLs, the reader is directed to <ref> [7] </ref> which reviews a number of existing languages and attempts to extract their essential features. The unit of mobility, called executing unit (EU) in [7], is implemented differently in different languages, but can be thought of as a process in an operating system or a thread in a multi-threaded environment. Mobile code may assume two basic forms, strong and weak. <p> is eventually executed after a client has sent a message request. 4 Mobile code languages implement parameter passing either explicitly by referring to input parameters and code using RPC-like primitives or implicitly by attaching to the procedure to be executed remotely the portion of data space needed for remote computation <ref> [7] </ref>.
Reference: [8] <author> H.C. Cunningham and G.-C. Roman. </author> <title> A UNITY-style Programming Logic for a Shared Dataspace Language. </title> <journal> IEEE Trans. on Parallel and Distributed Systems, </journal> <volume> 1(3) </volume> <pages> 365-376, </pages> <month> July </month> <year> 1990. </year>
Reference-contexts: This could have some negative implications on verification and, if not considered carefully, could interfere with the fairness assumption which are at the foundation of the proof logic. Another option involves building upon the experience with Swarm <ref> [27, 8] </ref>, a version of UNITY in which both data and statements are dynamically created and destroyed. The prospect of making changes to Mobile UNITY may also force us to re-examine the issue of what is an appropriate unit of mobility.
Reference: [9] <author> C. Fournet et al. </author> <title> A Calculus of Mobile Agents. </title> <booktitle> In Proc. of the 7 th Int. Conf. on Concurrency Theory (CONCUR'96), volume 1119 of LNCS, </booktitle> <pages> pages 406-421, </pages> <address> Pisa, Italy, Aug. 1996. </address> <publisher> Springer. </publisher>
Reference-contexts: In -calculus there is no formal concept of space. Mobility is equated to the ability to "express processes which have changing structure". Under this definition, any model able to pass processes as values, e.g., the Actor model, or link names as values (-calculus) qualifies. Today many researchers <ref> [9, 23, 1] </ref> are building variants and extensions of process algebras in order to provide a better notion of location. Cardelli's work [3], for instance, appears to be directly inspired by the domain of mobile code.
Reference: [10] <author> A. Fuggetta, G.P. Picco, and G. Vigna. </author> <title> Understanding Code Mobility. </title> <type> Technical report, </type> <institution> Politecnico di Milano, </institution> <year> 1997. </year> <note> Submitted for publication. http://www.polito.it/picco/papers/tax.ps.gz. </note>
Reference-contexts: This may improve performance by reducing latency and may increase dependability by avoiding problems inherent in partial failures. Actually, many researchers see the main advantage of code mobility as an optimization of communication resources. This does not hold in general <ref> [4, 10] </ref>, and applications can benefit from this kind of optimization in other ways as well [13, 14, 2]. We believe that an important benefit of code mobility is the ability to customize dynamically the server according to the user's needs. <p> The interested reader can find an in-depth discussion of mobile code technologies, paradigms, applications, and their inter-relationship in <ref> [10] </ref>. We consider a design component as the atomic design element, i.e., the smallest software entity that can be given an identity and can be distinguished from the other entities in an architectural schema. Each design component consists of code and its runtime state.
Reference: [11] <author> D. Garlan and D. Le Metayer, </author> <title> editors. </title> <booktitle> Proc. of the 2 nd Int. Conf. on Coordination Models and Languages (COORDINATION '97), volume 1282 of LNCS, </booktitle> <address> Berlin, Germany, Sept. 1997. </address> <publisher> Springer. </publisher>
Reference: [12] <author> R.S. Gray. </author> <title> Agent Tcl: A transportable agent system. </title> <booktitle> In Proc. of the CIKM Workshop on Intelligent Information Agents, </booktitle> <address> Baltimore, Md., </address> <month> Dec. </month> <year> 1995. </year>
Reference-contexts: Agent Tcl <ref> [13, 12] </ref>, an extension of Tcl [25], provides support for strong mobility as well, but upon execution of a migration instruction jump the whole UNIX process containing the interpreter is migrated, instead of a single thread within it.
Reference: [13] <editor> R.S. Gray et al. </editor> <booktitle> Mobile agents for mobile computing. In Proc. of the 2 nd Aizu Int. Symp. on Parallel Algorithms/Architectures Synthesis, Fukushima, </booktitle> <address> Japan, </address> <month> Mar. </month> <year> 1997. </year>
Reference-contexts: Agent Tcl <ref> [13, 12] </ref>, an extension of Tcl [25], provides support for strong mobility as well, but upon execution of a migration instruction jump the whole UNIX process containing the interpreter is migrated, instead of a single thread within it. <p> Actually, many researchers see the main advantage of code mobility as an optimization of communication resources. This does not hold in general [4, 10], and applications can benefit from this kind of optimization in other ways as well <ref> [13, 14, 2] </ref>. We believe that an important benefit of code mobility is the ability to customize dynamically the server according to the user's needs. In client-server applications, the server offers a fixed set of services, defined a priori by the application designer and accessible through a statically defined interface.
Reference: [14] <author> C.G. Harrison, D.M. Chess, and A. Kershenbaum. </author> <title> Mobile Agents: Are they a good idea? In Vitek and Tschudin [33], </title> <type> pages 25-47. </type> <note> Also available as IBM Technical Report. </note>
Reference-contexts: Actually, many researchers see the main advantage of code mobility as an optimization of communication resources. This does not hold in general [4, 10], and applications can benefit from this kind of optimization in other ways as well <ref> [13, 14, 2] </ref>. We believe that an important benefit of code mobility is the ability to customize dynamically the server according to the user's needs. In client-server applications, the server offers a fixed set of services, defined a priori by the application designer and accessible through a statically defined interface.
Reference: [15] <author> D. Johansen, R. van Renesse, and F.B. Schneider. </author> <title> An Introduction to the TACOMA Distributed System Version 1.0. </title> <type> Technical Report 95-23, </type> <institution> Dept. of Computer Science, University of Tromso and Cornell University, Tromso, Norway, </institution> <month> June </month> <year> 1995. </year>
Reference-contexts: On the other hand, in Java [31] the class loader can be programmed to enable a Java program to link dynamically code downloaded from the network, hence providing support for weak mobility. Java derivatives like Odyssey, Aglets, Voyager [17], or Mole [30], as well as languages like TACOMA <ref> [15] </ref>, Facile [18], and M0 [32] support weak mobility by allowing a procedure or function to be sent to another node for remote execution, with the portion of the global environment that is needed to proceed with execution|but with no execution state. fl Dip. di Automatica e Informatica, Politecnico di Torino,
Reference: [16] <author> E. Jul, H. Levy, N. Hutchinson, and A. Black. </author> <title> Fine-grained Mobility in the Emerald System. </title> <journal> ACM Trans. on Computer Systems, </journal> <volume> 6(2) </volume> <pages> 109-133, </pages> <month> Feb. </month> <year> 1988. </year>
Reference-contexts: Brief concluding remarks appear in Section 7. 2 2 Mobile Code Design Paradigms The idea behind code mobility is not new, as witnessed by the work by Stamos et al. [29] and by Black et al. <ref> [16] </ref>. Nevertheless, these technologies were conceived mostly to provide operating system support on a LAN, while MCLs explicitly target large scale distributed systems|like the Internet. On the Internet, client-server is the most used paradigm for the development of applications.
Reference: [17] <author> J. Kiniry and D. Zimmerman. </author> <title> A Hands-On Look at Java Mobile Agents. </title> <journal> IEEE Internet Computing, </journal> <volume> 1(4) </volume> <pages> 21-30, </pages> <address> July-Aug. </address> <year> 1997. </year>
Reference-contexts: On the other hand, in Java [31] the class loader can be programmed to enable a Java program to link dynamically code downloaded from the network, hence providing support for weak mobility. Java derivatives like Odyssey, Aglets, Voyager <ref> [17] </ref>, or Mole [30], as well as languages like TACOMA [15], Facile [18], and M0 [32] support weak mobility by allowing a procedure or function to be sent to another node for remote execution, with the portion of the global environment that is needed to proceed with execution|but with no execution
Reference: [18] <author> F.C. Knabe. </author> <title> Language Support for Mobile Agents. </title> <type> PhD thesis, </type> <institution> Carnegie Mellon University, </institution> <address> Pittsburgh, Pa., </address> <month> Dec. </month> <year> 1995. </year> <note> Also available as Carnagie Mellon School of Computer Science Tech. Rep. </note> <institution> CMU-CS-95-223 and European Computer Industry Centre Tech. </institution> <type> Rep. </type> <institution> ECRC-95-36. </institution>
Reference-contexts: Java derivatives like Odyssey, Aglets, Voyager [17], or Mole [30], as well as languages like TACOMA [15], Facile <ref> [18] </ref>, and M0 [32] support weak mobility by allowing a procedure or function to be sent to another node for remote execution, with the portion of the global environment that is needed to proceed with execution|but with no execution state. fl Dip. di Automatica e Informatica, Politecnico di Torino, C.so Duca
Reference: [19] <author> General Magic. </author> <title> Telescript Language Reference. General Magic, </title> <address> Oct. </address> <year> 1995. </year>
Reference-contexts: Upon migration, executing units are suspended, transmitted to the destination site, and resumed there. Weak mobility allows an executing unit at a site to be bound dynamically to code coming from a different site. Current MCLs provide different mixtures of the above notions of code mobility. For instance, Telescript <ref> [19, 34] </ref> provides full-fledged support for strong mobility.
Reference: [20] <author> P.J. McCann and G-.C. Roman. </author> <title> Compositional Programming Abstractions for Mobile Computing. </title> <type> Technical Report WUCS-97-45, </type> <institution> Dept. of Computer Science, Washington Univ. in St.Louis, </institution> <month> Oct. </month> <year> 1997. </year> <note> To appear in IEEE Trans. on Software Engineering. http://www.cs.wustl.edu/techrep/reports/1997/wucs-97-45.ps.Z. </note>
Reference-contexts: Furthermore, these kinds of studies may eventually lead to the development of a unified model of mobility. The model we use in our study is called Mobile UNITY <ref> [28, 20] </ref>, an extension of work by Chandy and Misra on UNITY [6]. Mobile UNITY provides a programming notation that captures the notion of mobility and transient interactions among mobile nodes and includes an assertional-style proof logic. <p> Each will be expressed in Mobile UNITY <ref> [20] </ref>, a modification of the standard UNITY notation presented in Section 3.2. <p> This is meaningful in light of the fact that transient sharing expresses a constraint upon the value assigned to variables when a particular condition holds|usually involving co-location. A tutorial presentation of the Mobile UNITY model and proof logic can be found in <ref> [20] </ref>. 5 Mobile Code Solutions In this section we present distributed solutions for the problem stated in Section 3 using the mobile code paradigms described earlier.
Reference: [21] <author> P.J. McCann and G-.C. Roman. </author> <title> Mobile UNITY Coordination Constructs Applied to Packet Forwarding for Mobile Hosts. </title> <booktitle> In Garlan and Metayer [11], </booktitle> <pages> pages 338-354. </pages>
Reference-contexts: Restricted forms of these proposed interaction constructs appear to have efficient implementations and more abstract and powerful interaction constructs can be built from the basic forms. In addition, the proof logic has been tentatively evaluated in the verification of the Mobile IP protocol <ref> [21] </ref>.
Reference: [22] <author> R. Milner, J. Parrow, and D. Walker. </author> <title> A Calculus for Mobile Processes I. </title> <journal> Information and Computation, </journal> <volume> 100(1) </volume> <pages> 1-40, </pages> <month> Sept. </month> <year> 1992. </year>
Reference-contexts: Having accomplished this, we will also show how the Mobile UNITY proof logic enables us to verify the correctness of programs using mobile code. Until very recently the only formal model of concurrency to refer to mobility explicitly was -calculus <ref> [22] </ref>, a process algebra proposed by Milner and his colleagues. In -calculus there is no formal concept of space. Mobility is equated to the ability to "express processes which have changing structure".
Reference: [23] <author> R. De Nicola, G. Ferrari, and R. Pugliese. </author> <title> Locality Based Linda: Programming with Explicit Localities. </title> <editor> In M. Bidoit and M. Dauchet, editors, </editor> <booktitle> Proc. of the 7 th Int. Joint Conf. on the Theory and Practice of Software Development (TAPSOFT'97), volume 1214 of LNCS, </booktitle> <address> Lille, France, </address> <month> Apr. </month> <title> 1997. </title> <publisher> Springer. </publisher>
Reference-contexts: In -calculus there is no formal concept of space. Mobility is equated to the ability to "express processes which have changing structure". Under this definition, any model able to pass processes as values, e.g., the Actor model, or link names as values (-calculus) qualifies. Today many researchers <ref> [9, 23, 1] </ref> are building variants and extensions of process algebras in order to provide a better notion of location. Cardelli's work [3], for instance, appears to be directly inspired by the domain of mobile code.
Reference: [24] <institution> Object Management Group. CORBA: Architecture and Specification, </institution> <month> August </month> <year> 1995. </year>
Reference-contexts: Notably, each interaction between the client and the server must exploit the communication infrastructure through message passing or some higher level mechanism like remote procedure call (RPC). Mechanisms that by and large hide the location of components from the application programmer are also being considered, e.g., CORBA <ref> [24] </ref>. By contrast, in MCLs component locations are not hidden. Location is explicitly handled by the programmer who is able to specify where the computation of a given code fragment must take place.
Reference: [25] <author> J. Ousterhout. </author> <title> Tcl and the Tk Toolkit. </title> <publisher> Addison-Wesley, </publisher> <year> 1995. </year>
Reference-contexts: Agent Tcl [13, 12], an extension of Tcl <ref> [25] </ref>, provides support for strong mobility as well, but upon execution of a migration instruction jump the whole UNIX process containing the interpreter is migrated, instead of a single thread within it.
Reference: [26] <author> G.P. Picco, G.-C. Roman, and P.J. McCann. </author> <title> Expressing Code Mobility in Mobile UNITY. </title> <editor> In M. Jazayeri and H. Schauer, editors, </editor> <booktitle> Proc. of the 6 th European Software Engineering Conf. held jointly with the 5 th ACM SIGSOFT Symp. on the Foundations of Software Engineering (ESEC/FSE '97), volume 1301 of LNCS, </booktitle> <pages> pages 500-518, </pages> <address> Zurich, Switzerland, Sept. 1997. </address> <publisher> Springer. </publisher>
Reference-contexts: as Mobile UNITY programs, how one can specify code movement from one location to another by manipulating the location variable, and how one can capture dynamic binding of variables among the mobile and stationary code by means of transient interactions, a concept specific to Mobile UNITY, following the lines of <ref> [26] </ref>. Having accomplished this, we will also show how the Mobile UNITY proof logic enables us to verify the correctness of programs using mobile code.
Reference: [27] <author> G.-C. Roman and H.C. Cunningham. </author> <title> Mixed Programming Metaphors in a Shared Dataspace Model of Concurrency. </title> <journal> IEEE Trans. on Software Engineering, </journal> <volume> 16(12) </volume> <pages> 1361-1373, </pages> <month> Dec. </month> <year> 1990. </year> <month> 36 </month>
Reference-contexts: This could have some negative implications on verification and, if not considered carefully, could interfere with the fairness assumption which are at the foundation of the proof logic. Another option involves building upon the experience with Swarm <ref> [27, 8] </ref>, a version of UNITY in which both data and statements are dynamically created and destroyed. The prospect of making changes to Mobile UNITY may also force us to re-examine the issue of what is an appropriate unit of mobility.
Reference: [28] <author> G-.C. Roman, P.J. McCann, and J.Y. Plun. </author> <title> Mobile UNITY: Reasoning and Specification in Mobile Computing. </title> <journal> ACM Trans. on Software Engineering and Methodology, </journal> <volume> 6(3) </volume> <pages> 250-282, </pages> <month> July </month> <year> 1997. </year>
Reference-contexts: Furthermore, these kinds of studies may eventually lead to the development of a unified model of mobility. The model we use in our study is called Mobile UNITY <ref> [28, 20] </ref>, an extension of work by Chandy and Misra on UNITY [6]. Mobile UNITY provides a programming notation that captures the notion of mobility and transient interactions among mobile nodes and includes an assertional-style proof logic.
Reference: [29] <author> J.W. Stamos and D.K. Gifford. </author> <title> Remote Evaluation. </title> <journal> ACM Trans. on Programming Languages and Systems, </journal> <volume> 12(4) </volume> <pages> 537-565, </pages> <month> Oct. </month> <year> 1990. </year>
Reference-contexts: Brief concluding remarks appear in Section 7. 2 2 Mobile Code Design Paradigms The idea behind code mobility is not new, as witnessed by the work by Stamos et al. <ref> [29] </ref> and by Black et al. [16]. Nevertheless, these technologies were conceived mostly to provide operating system support on a LAN, while MCLs explicitly target large scale distributed systems|like the Internet. On the Internet, client-server is the most used paradigm for the development of applications. <p> Eventually, a result will be sent back to the client component via a message, like in a CS paradigm. Hence, the REV paradigm leverages off the flexibility provided by the server, instead of relying on a fixed functionality. The REV paradigm is inspired by work on the REV <ref> [29] </ref> system, which extends the remote procedure call with one additional parameter containing the code to execute on the server. Among recent MCLs, the paradigm is supported directly by most of the weak MCLs, with the notable exception of Java. <p> Hence, in both solutions the client component is given a uniform interface (the request buffer) to the rest of the system, whose details are handled within the Interactions sections|thus modeling the run-time support for communication provided by, say, implementations of RPC and of the REV <ref> [29] </ref> system. Analogous considerations hold for the output buffer of Server.
Reference: [30] <author> M. Straer, J. Baumann, and F. Hohl. </author> <title> Mole|A Java Based Mobile Agent System. </title> <editor> In M. Muhlauser, editor, </editor> <booktitle> Special Issues in Object-Oriented Programming: Workshop Reader of the 10 th European Conf. on Object-Oriented Programming ECOOP'96, </booktitle> <pages> pages 327-334. </pages> <address> dpunkt, </address> <month> July </month> <year> 1996. </year>
Reference-contexts: On the other hand, in Java [31] the class loader can be programmed to enable a Java program to link dynamically code downloaded from the network, hence providing support for weak mobility. Java derivatives like Odyssey, Aglets, Voyager [17], or Mole <ref> [30] </ref>, as well as languages like TACOMA [15], Facile [18], and M0 [32] support weak mobility by allowing a procedure or function to be sent to another node for remote execution, with the portion of the global environment that is needed to proceed with execution|but with no execution state. fl Dip.
Reference: [31] <author> Sun Microsystems. </author> <title> The Java Language Specification, </title> <address> Oct. </address> <year> 1995. </year>
Reference-contexts: Agent Tcl [13, 12], an extension of Tcl [25], provides support for strong mobility as well, but upon execution of a migration instruction jump the whole UNIX process containing the interpreter is migrated, instead of a single thread within it. On the other hand, in Java <ref> [31] </ref> the class loader can be programmed to enable a Java program to link dynamically code downloaded from the network, hence providing support for weak mobility.
Reference: [32] <author> C.F. Tschudin. </author> <title> An Introduction to the M0 Messenger Language. </title> <institution> Univ. of Geneva, Switzerland, </institution> <year> 1994. </year>
Reference-contexts: Java derivatives like Odyssey, Aglets, Voyager [17], or Mole [30], as well as languages like TACOMA [15], Facile [18], and M0 <ref> [32] </ref> support weak mobility by allowing a procedure or function to be sent to another node for remote execution, with the portion of the global environment that is needed to proceed with execution|but with no execution state. fl Dip. di Automatica e Informatica, Politecnico di Torino, C.so Duca degli Abruzzi 24,
Reference: [33] <author> J. Vitek and C. Tschudin, </author> <title> editors. Mobile Object Systems: Towards the Programmable Internet, </title> <booktitle> volume 1222 of LNCS. </booktitle> <publisher> Springer, </publisher> <month> Apr. </month> <year> 1997. </year>
Reference-contexts: the move on the computations executing at the point of origin and at destination? What aspects of the run-time state move along with the code? What are the boundaries of a location? These questions have received partial answers in a new generation of programming languages called mobile code languages (MCLs) <ref> [33] </ref>. These languages provide specialized abstractions and run-time support capabilities designed to support various forms of code mobility. The impetus for the development of MCLs stems from the need to overcome some of the technological problems facing the Internet today.
Reference: [34] <author> J.E. White. </author> <title> Telescript Technology: Mobile Agents. </title> <editor> In J. Bradshaw, editor, </editor> <booktitle> Software Agents. </booktitle> <publisher> AAAI Press/MIT Press, </publisher> <year> 1996. </year> <month> 37 </month>
Reference-contexts: Upon migration, executing units are suspended, transmitted to the destination site, and resumed there. Weak mobility allows an executing unit at a site to be bound dynamically to code coming from a different site. Current MCLs provide different mixtures of the above notions of code mobility. For instance, Telescript <ref> [19, 34] </ref> provides full-fledged support for strong mobility.
References-found: 34

