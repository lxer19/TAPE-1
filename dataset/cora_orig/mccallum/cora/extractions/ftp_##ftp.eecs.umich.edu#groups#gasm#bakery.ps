URL: ftp://ftp.eecs.umich.edu/groups/gasm/bakery.ps
Refering-URL: http://www.eecs.umich.edu/gasm/algorithm.html
Root-URL: http://www.cs.umich.edu
Title: The Bakery Algorithm: Yet Another Specification and Verification  
Author: Egon B orger Yuri Gurevich Dean Rosenzweig 
Abstract: In a meeting at Schloss Dagstuhl in June 1993, Uri Abraham and Menachem Magidor have challenged the thesis that an evolving algebra can be tailored to any algorithm at its own abstraction level. As example they gave an instructive proof which uses lower and higher views to show correctness of Lamport's bakery algorithm. We construct two evolving algebras capturing lower and higher view respectively, enabling a simple and concise proof of correctness for the bakery algorithm.
Abstract-found: 1
Intro-found: 1
Reference: [Abraham93] <author> Uri Abraham, </author> <title> Bakery Algorithms, </title> <type> Manuscript. </type> <year> 1993, </year> <month> pp.35 </month>
Reference-contexts: Introduction Uri Abraham <ref> [Abraham93] </ref> has devised an instructive correctness proof for various variants of Lamport's bakery algorithm relying on a distinction between a lower view and a higher view of the algorithms. Actions at the higher level represents complex lower level computations. <p> In order to make the paper technically self contained, except for basic notions about evolving algebras of [Gurevich91], we start Section 1 with a review of Lamport's 1979 algorithm and give full details of proofs also in those places where we borrow from <ref> [Abraham93] </ref>. 1 The algorithms This section presents Lamport's algorithm (taken in a form which is adapted from [Abraham93]), the corresponding `lower level' evolving algebra, and the more abstract evolving algebra reflecting the `higher level view'. 1.1 Lamport's algorithm For arbitrary but fixed N let P 1 ; : : : ; <p> for basic notions about evolving algebras of [Gurevich91], we start Section 1 with a review of Lamport's 1979 algorithm and give full details of proofs also in those places where we borrow from <ref> [Abraham93] </ref>. 1 The algorithms This section presents Lamport's algorithm (taken in a form which is adapted from [Abraham93]), the corresponding `lower level' evolving algebra, and the more abstract evolving algebra reflecting the `higher level view'. 1.1 Lamport's algorithm For arbitrary but fixed N let P 1 ; : : : ; P N be processes that may want from time to time to access a `critical section' CS <p> This ordering will help us to formalize the idea that tickets increase together with doorways (see C1 below). This should also apply in a way to overlapping doorways; these are ordered by the following relation , borrowed from <ref> [Abraham93] </ref>. Let X 6= Y , x ranges over doorways of X, y ranges over doorways of Y . Definition 2.2 x y if x " y 6= ; and T 0 (x) &lt; T 0 (y).
Reference: [Gurevich91] <author> Yuri Gurevich, </author> <title> Evolving Algebras: A Tutorial Introduction, </title> <journal> EATCS Bulletin 43, </journal> <month> February </month> <year> 1991, </year> <pages> pp. 264-284. </pages> <note> A slightly revised version in "Current Trends in Theoretical Computer Science", </note> <editor> Eds. G. Rozenberg and A. Salomaa, </editor> <publisher> World Scientific, </publisher> <year> 1993, </year> <pages> 266-292. </pages>
Reference-contexts: At a seminar in Schloss Dagstuhl in June 1993 Uri Abraham and Menachem Magidor have expressed doubts that such a proof could be naturally carried out in the evolving algebra framework of <ref> [Gurevich91] </ref>, since the latter uses a notion of atomic instantaneous action. We construct, in Section 1, two evolving algebras, reflecting the lower and higher views of Lamport's improved version of the bakery algorithm (see [Lamport79]). <p> The correctness proof however remains essentially the same. In order to make the paper technically self contained, except for basic notions about evolving algebras of <ref> [Gurevich91] </ref>, we start Section 1 with a review of Lamport's 1979 algorithm and give full details of proofs also in those places where we borrow from [Abraham93]. 1 The algorithms This section presents Lamport's algorithm (taken in a form which is adapted from [Abraham93]), the corresponding `lower level' evolving algebra, and <p> We introduce for this purpose an external function T whose values are determined dynamically by the outside world, cf. <ref> [Gurevich91] </ref>. The relevant moment to be analyzed is the moment at which a process which has received a ticket is allowed to enter the critical section. This `permission to go' will also be represented by an external function, Go.
Reference: [Gurevich94] <author> Yuri Gurevich, </author> <title> Evolving Algebra 1993: Lipari Guide, this volume. </title>
Reference-contexts: The higher level algebra has only one module, see Figure 4, which has five rules. Again, we assume that initially all registers have value 0 and all customers are satisfied. 2 Atomic actions interpretation 2.1 Semantics of B 1 We rely on the notion of run of <ref> [Gurevich94] </ref>, specialized to real time. This means that we shall speak of a move (rule execution) taking place at moment a. Since we consider atomic actions here, we assume moves to take zero time. <p> An agent is atomic if all its moves are so. 3 If an agent X makes an atomic move and P () = (a; b) then S b (X) is the result of executing one step of X at S a (X). (See <ref> [Gurevich94] </ref> for the definition of the result of a one-step execution of a sequential evolving algebra at a given state.) 4 All customers are atomic. All Check moves of readers are atomic. All Read moves of any r (X; Y ) are atomic with respect to mode (X).
Reference: [Lamport74] <author> Lesli Lamport, </author> <title> A New Solution of Dijkstra Concurrent Programming Problem, </title> <booktitle> in Comm. ACM, vol.17:8 (1974), </booktitle> <pages> 453-455. </pages>
Reference-contexts: Partially supported by CNR/Gnasaga grant 2.94. 1 the proof of the previous section goes through with only slight modifications. For the more general case of safe registers correctness of the algorithm from <ref> [Lamport74] </ref> is then easily proved by a slight adaptation of the present argument|the improved algorithm from [Lamport79] is not correct for safe registers, as shown by a simple counterexample. <p> writes ticket 18 to R [X] and the array 12.30-12.35: X reads R [Y ] getting 117 (by overlap) 12.45-12.50: Y reads 18 from R [X] 13.00: X and Y both go to CS It is however easy to adapt the present proof to show correctness of the algorithm of <ref> [Lamport74] </ref> for safe registers, rephrased as an appropriate evolving algebra, using the same abstract conditions C0-C3. Acknowledgement. We thank Uri Abraham for useful discussions. 11
Reference: [Lamport79] <author> Leslie Lamport, </author> <title> A New Approach to Proving the Correctness of Multiprocess Programs, in: </title> <journal> ACM Transaction on Programming Languages and Systems, </journal> <volume> vol. 1:1, </volume> <month> July </month> <year> 1979, </year> <pages> 84-97. </pages>
Reference-contexts: We construct, in Section 1, two evolving algebras, reflecting the lower and higher views of Lamport's improved version of the bakery algorithm (see <ref> [Lamport79] </ref>). In Section 2 we display abstract conditions on higher level actions, in terms of atomic-action semantics, enabling a simple and concise proof of the first-come-first-served property (FCFS) and deadlock-freedom. The conditions are easily seen to be satisfied by corresponding lower level computations. <p> Partially supported by CNR/Gnasaga grant 2.94. 1 the proof of the previous section goes through with only slight modifications. For the more general case of safe registers correctness of the algorithm from [Lamport74] is then easily proved by a slight adaptation of the present argument|the improved algorithm from <ref> [Lamport79] </ref> is not correct for safe registers, as shown by a simple counterexample. Thus the two interpretations of evolving algebra dynamics reflect two disciplines for accessing shared registers|by atomic and non-overlapping reads and writes, or by durative and possibly overlapping ones. <p> Finally b 6= sup (y), since otherwise we would have R b (Y ) = T (y), contradicting Claim 1. 2 3.5 Counterexample for safe registers The following example shows that the algorithm of <ref> [Lamport79] </ref> is not correct for the more general case of safe registers (see [Lamport86])|where a read overlapping with a write may get any admissible value whatsoever.
Reference: [Lamport86] <author> Leslie Lamport, </author> <title> On Interprocess Communication, </title> <booktitle> in Distributed Computing, </booktitle> <volume> vol. 1, </volume> <pages> 77-101. 12 </pages>
Reference-contexts: In Section 3 we explain the semantics of evolving algebras assuming durative actions, actions taking time, and allowing overlapping of reads and writes to shared registers. Refining the abstract conditions for the case of regular reads (see <ref> [Lamport86] </ref>), we show that 0 "Specification and Validation Methods", ed. E. Borger, Oxford University Press, 1995, 231-243.. 1 Dipartimento di Informatica, Universita di Pisa, Corso Italia 40, I-56100 Pisa, boerger@di.unipi.it. Partially supported by MURST 91. 2 EECS, University of Michigan, Ann Arbor MI 48109-2122, gurevich@umich.edu.
References-found: 6

