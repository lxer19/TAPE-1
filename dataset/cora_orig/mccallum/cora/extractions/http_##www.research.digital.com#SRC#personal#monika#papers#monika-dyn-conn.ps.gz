URL: http://www.research.digital.com/SRC/personal/monika/papers/monika-dyn-conn.ps.gz
Refering-URL: http://www.research.digital.com/SRC/personal/monika/papers.html
Root-URL: http://www.research.digital.com
Title: Randomized Fully Dynamic Graph Algorithms with Polylogarithmic Time per Operation  
Author: Monika Rauch Henzinger Valerie King 
Abstract: This paper solves a longstanding open problem in fully dynamic algorithms: We present the first fully dynamic algorithms that maintain connectivity, bipartiteness, and approximate minimum spanning trees in polylogarithmic time per edge insertion or deletion. The algorithms are designed using a new dynamic technique which combines a novel graph decomposition with randomization. They are Las-Vegas type randomized algorithms which use simple data structures and have a small constant factor. Let n denote the number of nodes in the graph. For a sequence of (m 0 ) operations, where m 0 is the number of edges in the initial graph, the expected time for p updates is O(p log 3 n) 1 for connectivity and bipartiteness. The worst-case time for one query is O(log n= log log n). For the k-edge witness problem ("Does the removal of k given edges disconnect the graph?") the expected time for p updates is O(p log 3 n) and expected time for q queries is O(qk log 3 n). Given a graph with k different weights, the minimum spanning tree can be maintained during a sequence of p updates in expected time O(pk log 3 n). This implies an algorithm to maintain a 1+*-approximation of the minimum spanning tree in expected time O((p log 3 n log U )=*) for p updates, where the weights of the edges are between 1 and U . Finally, we use the data structures to create simple, deterministic algorithms that maintain minimum spanning trees and connectivity fully dynamically. The algorithms take time O( n log n) per update.
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> D. Alberts and M. Rauch Henzinger, </author> <title> "Average Case Analysis of Dynamic Graph Algorithms", </title> <booktitle> to appear in Proc. 5th Symp. on Discrete Algorithms, </booktitle> <year> 1995. </year>
Reference-contexts: If deletions are restricted to "undo" previous insertions in the reverse order in which the insertions occurred, then Westbrook and Tarjan [20] gave an algorithm with takes time O (log n= log log n) per update. In <ref> [1] </ref> it is shown that the average update time of (a variant of) the above connectivity and bipartiteness algorithms is O (n= p m + log n) if the edges used in updates are chosen uniformly from a given edge set.
Reference: [2] <author> D. Eppstein, G. F. Italiano, R. Tamassia, R. E. Tarjan, J. Westbrook, M. Yung, </author> <title> "Maintenance of a Minimum Spanning Forest in a Dynamic Planar Graph". </title> <booktitle> Proc. 1st Symp. on Discrete Algorithms, </booktitle> <year> 1990, </year> <pages> 1-11. </pages>
Reference: [3] <author> D. Eppstein, Z. Galil, G. F. </author> <title> Italiano, "Improved Sparsification", </title> <type> Tech. Report 93-20, </type> <institution> Department of Information and Computer Science, University of California, </institution> <address> Irvine, CA 92717. </address>
Reference-contexts: There is also a large body of work for restricted classes of graphs and for insertions-only algorithms. Currently the best time bounds for fully dynamic algorithms in undirected n-node graphs are: O ( p n) per update for a minimum spanning forest <ref> [3] </ref>; O ( p n) per update and O (1) per query for connectivity [3]; O ( n log n) per update and O (log 2 n) per query for cycle-equivalence ("Does the removal of the given 2 edges disconnect the graph?") [11]; O ( p n) per update and O <p> Currently the best time bounds for fully dynamic algorithms in undirected n-node graphs are: O ( p n) per update for a minimum spanning forest <ref> [3] </ref>; O ( p n) per update and O (1) per query for connectivity [3]; O ( n log n) per update and O (log 2 n) per query for cycle-equivalence ("Does the removal of the given 2 edges disconnect the graph?") [11]; O ( p n) per update and O (1) per query for bipartiteness ("Is the graph bipartite?") [3]. <p> per query for connectivity <ref> [3] </ref>; O ( n log n) per update and O (log 2 n) per query for cycle-equivalence ("Does the removal of the given 2 edges disconnect the graph?") [11]; O ( p n) per update and O (1) per query for bipartiteness ("Is the graph bipartite?") [3]. There is a lower bound in the cell probe model of (log n= log log n) on the amortized time per operation for all these problems which applies to randomized algorithms [9, 11, 13].
Reference: [4] <author> D. Eppstein, Z. Galil, G. F. Italiano, A. Nissenzweig, </author> <title> "Sparsification ATechnique for Speeding up Dynamic Graph Algorithms" Proc. </title> <booktitle> 33rd Symp. on Foundations of Computer Science, </booktitle> <year> 1992, </year> <pages> 60-69. </pages>
Reference-contexts: However, the constant factor of these algorithms is quite large [5]. Thus, the following questions were posed as open questions in <ref> [4, 5] </ref>: (1) Can the above properties be maintained dynamically in polylogarithmic time in (general) graphs? (2) Is the constant factor in the fully dynamic algorithms small such that an efficient implementation is possible? New Results. This paper gives a positive answer to both questions. <p> The amortized time per update for the minimum spanning tree algorithm is O ( p m log n), which can be improved to O ( p n log n) using the sparsification technique <ref> [4] </ref>. The amortized time per update for the connectivity algorithm is O ( n log n). <p> We note that the technique of sparsification <ref> [4] </ref>, when applied on top of this algorithm, will yield an algorithm with O ( p n log n) amortized time per operation. 4.1 A Deletions-Only Minimum Spanning Tree Algorithm The data structures which we use are very similar to those of the randomized connnectivity algorithm.
Reference: [5] <author> D. Eppstein, Z. Galil, G. F. Italiano, and T. Spencer. </author> <title> "Separator Based Sparsification for Dynamic Planar Graph Algorithms". </title> <booktitle> Proc. 25th Symp. on Theory of Computing, </booktitle> <year> 1993, </year> <pages> 208-217. </pages>
Reference-contexts: Thus, for dense graphs their average performance nearly matches the lower bound. In planar graphs fully dynamic algorithms for minimum spanning forest and connectivity are given in <ref> [5] </ref> that are close to the lower bound: they take time O (log 2 n) per deletion and O (log n) per insertions and query. However, the constant factor of these algorithms is quite large [5]. <p> In planar graphs fully dynamic algorithms for minimum spanning forest and connectivity are given in <ref> [5] </ref> that are close to the lower bound: they take time O (log 2 n) per deletion and O (log n) per insertions and query. However, the constant factor of these algorithms is quite large [5]. Thus, the following questions were posed as open questions in [4, 5]: (1) Can the above properties be maintained dynamically in polylogarithmic time in (general) graphs? (2) Is the constant factor in the fully dynamic algorithms small such that an efficient implementation is possible? New Results. <p> However, the constant factor of these algorithms is quite large [5]. Thus, the following questions were posed as open questions in <ref> [4, 5] </ref>: (1) Can the above properties be maintained dynamically in polylogarithmic time in (general) graphs? (2) Is the constant factor in the fully dynamic algorithms small such that an efficient implementation is possible? New Results. This paper gives a positive answer to both questions.
Reference: [6] <author> S. Even and Y. Shiloach, </author> <title> "An On-Line Edge-Deletion Problem", </title> <editor> J. </editor> <booktitle> ACM 28 (1981), </booktitle> <pages> 1-4. </pages>
Reference: [7] <author> G. N. Frederickson, </author> <title> "Data Structures for On-line Updating of Minimum Spanning Trees", </title> <journal> SIAM J. Comput., </journal> <volume> 14 (1985), </volume> <pages> 781-798. </pages>
Reference: [8] <author> G. N. Frederickson, </author> <title> "Ambivalent Data Structures for Dynamic 2-Edge-connectivity and k Smallest Spanning Trees", </title> <booktitle> Proc. 32nd Symp. on Foundations of Computer Science, </booktitle> <year> 1991, </year> <pages> 632-641. </pages>
Reference: [9] <author> M. L. Fredman and M. R. Henzinger, </author> <title> "Lower Bounds for Fully Dynamic Connectivity Problems in Graphs", </title> <note> submitted to Algorithmica. </note>
Reference-contexts: There is a lower bound in the cell probe model of (log n= log log n) on the amortized time per operation for all these problems which applies to randomized algorithms <ref> [9, 11, 13] </ref>. If deletions are restricted to "undo" previous insertions in the reverse order in which the insertions occurred, then Westbrook and Tarjan [20] gave an algorithm with takes time O (log n= log log n) per update.
Reference: [10] <author> Z. Galil and G. F. </author> <title> Italiano, "Fully Dynamic Algorithms for 2-Edge Connectivity", </title> <journal> SIAM J. Comput. </journal> <volume> 21 (1992), </volume> <pages> 1047-1069. 19 </pages>
Reference: [11] <author> M. R. Henzinger, </author> <title> "Fully Dynamic Cycle-Equivalence in Graphs", </title> <booktitle> Proc. 35th Symp. on Foun--dations of Computer Science, </booktitle> <year> 1994, </year> <pages> 744-755. </pages>
Reference-contexts: n) per update for a minimum spanning forest [3]; O ( p n) per update and O (1) per query for connectivity [3]; O ( n log n) per update and O (log 2 n) per query for cycle-equivalence ("Does the removal of the given 2 edges disconnect the graph?") <ref> [11] </ref>; O ( p n) per update and O (1) per query for bipartiteness ("Is the graph bipartite?") [3]. <p> There is a lower bound in the cell probe model of (log n= log log n) on the amortized time per operation for all these problems which applies to randomized algorithms <ref> [9, 11, 13] </ref>. If deletions are restricted to "undo" previous insertions in the reverse order in which the insertions occurred, then Westbrook and Tarjan [20] gave an algorithm with takes time O (log n= log log n) per update.
Reference: [12] <author> M. R. Henzinger and H. La Poutre, </author> <title> "Sparse Certificates for Dynamic Biconnectivity in Graphs", </title> <note> to appear in Proc. 3rd European Symposium on Algorithms 1995. </note>
Reference: [13] <author> P. B. Miltersen, S. Subramanian, J.S. Vitter, and R. Tamassia, </author> <title> "Complexity Models for Incremental Computation", </title> <type> Theoret. </type> <institution> Comput. Science 130, </institution> <year> 1994, </year> <pages> 203-236. </pages>
Reference-contexts: There is a lower bound in the cell probe model of (log n= log log n) on the amortized time per operation for all these problems which applies to randomized algorithms <ref> [9, 11, 13] </ref>. If deletions are restricted to "undo" previous insertions in the reverse order in which the insertions occurred, then Westbrook and Tarjan [20] gave an algorithm with takes time O (log n= log log n) per update. <p> We use an Eulerian tour representation of the spanning trees to linearly order the nontree edges of the graph. The Eulerian tour representation of trees was introduced in [19] and also used in <ref> [13] </ref>. This paper is structured as follows: Section 2 gives the fully dynamic connectivity algorithm, Section 3 presents the results for k-weight minimum spanning trees, 1+*-approximate minimum spanning trees, and bipartiteness.
Reference: [14] <author> H. Nagamochi and T. Ibaraki, </author> <title> "Linear time algorithms for finding a sparse k-connected spanning subgraph of a k-connected graph", </title> <type> Algorithmica 7, </type> <year> 1992, </year> <pages> 583-596. </pages>
Reference-contexts: The maximal spanning forest decomposition is interesting since [ i F i is a graph with O (kn) edges that has the same k-edge connected components as G <ref> [14] </ref>. Additionally we use the data structures to present simple deterministic algorithms that maintain minimum spanning trees and connectivity fully dynamically.
Reference: [15] <author> M. H. Rauch, </author> <title> "Fully Dynamic Biconnectivity in Graphs". </title> <booktitle> Proc. 33rd Symp. on Foundations of Computer Science, </booktitle> <year> 1992, </year> <pages> 50-59. </pages>
Reference: [16] <author> M. H. Rauch, </author> <title> "Improved Data Structures for Fully Dynamic Biconnectivity in Graphs". </title> <booktitle> Proc. 26th Symp. on Theory of Computing, </booktitle> <year> 1994, </year> <pages> 686-695. </pages>
Reference: [17] <author> D. D. Sleator, R. E. Tarjan, </author> <title> "A data structure for dynamic trees" J. </title> <journal> Comput. System Sci. </journal> <volume> 24, </volume> <year> 1983, </year> <pages> 362-381. </pages>
Reference: [18] <author> P. M. Spira and A. Pan, </author> <title> "On Finding and Updating Spanning Trees and Shortest Paths", </title> <journal> SIAM J. Comput., </journal> <volume> 4 (1975), </volume> <pages> 375-380. </pages>
Reference: [19] <author> R. E. Tarjan and U. Vishkin, </author> <title> "An efficient parallel biconnectivity algorithm", </title> <journal> SIAM J. Com-put., </journal> <volume> 14 (1985), </volume> <pages> 862-874. </pages>
Reference-contexts: We use an Eulerian tour representation of the spanning trees to linearly order the nontree edges of the graph. The Eulerian tour representation of trees was introduced in <ref> [19] </ref> and also used in [13]. This paper is structured as follows: Section 2 gives the fully dynamic connectivity algorithm, Section 3 presents the results for k-weight minimum spanning trees, 1+*-approximate minimum spanning trees, and bipartiteness.
Reference: [20] <author> J. Westbrook and R. E. Tarjan, </author> <title> "Amortized Analysis of Algorithms for Set Union with Backtracking", </title> <journal> SIAM J. Comput., </journal> <volume> 18 (1989), </volume> <pages> 1-11. 20 </pages>
Reference-contexts: If deletions are restricted to "undo" previous insertions in the reverse order in which the insertions occurred, then Westbrook and Tarjan <ref> [20] </ref> gave an algorithm with takes time O (log n= log log n) per update.
References-found: 20

