URL: http://www.cs.iastate.edu/tech-reports/TR97-12.ps
Refering-URL: http://www.cs.iastate.edu/tech-reports/catalog.html
Root-URL: http://www.cs.iastate.edu
Title: Executing Formal Specifications with Constraint Satisfaction  
Author: Tim Wahls and Gary T. Leavens and Albert L. Baker Tim Wahls, Gary T. Leavens, and Albert L. Baker, . 
Address: 226 Atanasoff Hall  Ames, Iowa 50011-1040, USA  
Affiliation: Department of Computer Science  Iowa State University  
Note: Copyright c  Submitted for publication.  
Date: August 1997  
Pubnum: TR #97-12  
Abstract: Keywords: formal specification, model-based specification, executable specification, prototyping, constraint solving, constraint satisfaction, sets, unions, sequences, tuples, objects, first-order predicate calculus, constraint logic programming, C++ 1997 CR Categories: D.2.1 [Software Engineering] Requirements/Specifications | Languages, reliability, tools; D.2.m [Software Engineering] Miscellaneous | Rapid prototyping; D.3.2 [Programming Languages] Language Classifications | Nonprocedural languages, very high-level languages; D.3.4 [Programming Languages] Processors | Interpreters; very high-level languages; F.3.1 [Logics and Meaning of Programs] Specifying and verifying and reasoning about programs | Assertions, pre- and post-conditions, specification techniques. 
Abstract-found: 1
Intro-found: 1
Reference: [A + 93] <author> D.J. Andrews et al. </author> <title> Information Technology Programming Languages - VDM-SL: First Committee Draft Standard CD1387-1. Document ISO/IEC JTC1/SC22/WG19 N-20, </title> <booktitle> International Standards Organization, </booktitle> <month> November </month> <year> 1993. </year> <month> ftp://gatekeeper.dec.com/pub/standards/vdmsl/. </month>
Reference-contexts: Any other nonterminals that are not expanded represent either literals of SPECS-C++ types (if ending in -literal) or identifiers. specification languages are VDM [Jon90] <ref> [A + 93] </ref> and Z [Hay93] [Spi89] [Spi92], although many other model-based specification languages have been developed. The model typically includes primitive types such as integers and characters, as well as more structured types such as finite sets, sequences, tuples, and functions.
Reference: [AELL92] <author> Michael Andersen, Rene Elmstrtm, Poul Btgh Lassen, and Peter Gorm Larsen. </author> <title> Making Specifications Executable Using IPTES Meta-IV. </title> <booktitle> In Euromicro '92, </booktitle> <month> September </month> <year> 1992. </year>
Reference-contexts: 1 Introduction Many executable specification languages have been developed <ref> [AELL92] </ref> [Hen86] [HI88] [KK93] [O'N92a] [TC89] [TY92], but all that the authors are aware of except fase3 [KK93] are considerably different from typical non-executable specification languages. <p> This is the most prevalent approach, and examples include EPROL [HI88] [HI86], me too [Hen86], SMLVIEW [O'N92b] [O'N92a], and the technique used for executing IPTES mini-specifications [ELA93] [LL91] <ref> [AELL92] </ref>.
Reference: [BCJ84] <author> H. Barringer, J. H. Cheng, and C. B. Jones. </author> <title> A Logic Covering Undefinedness in Program Proofs. </title> <journal> Acta Informatica, </journal> <volume> 21(3) </volume> <pages> 251-269, </pages> <month> October </month> <year> 1984. </year>
Reference-contexts: Function eval uses the usual axioms for non-strict evaluation of assertions <ref> [BCJ84] </ref>. * active?: constraint fi environment fi store fi store ! boolean This function returns true iff the argument constraint can immediately be solved. * solve: constraint fi environment fi store fi store fi (sequence of backtrack point) ! store fi (sequence of backtrack point) This function solves the argument constraint
Reference: [BMR93] <author> Alex Borgida, John Mylopoulos, and Raymond Reiter. </author> ... <title> And Nothing Else Changes: The Frame Problem in Procedure Specifications. </title> <booktitle> In Proceedings Fifteenth International Conference on Software Engineering, </booktitle> <address> Baltimore, </address> <month> May </month> <year> 1993. </year>
Reference-contexts: Thus, rather than characterizing all possible post-states arising from a specification, our technique simply returns one that is minimal in the sense that sets and sequences contain no elements beyond those that are required by the specification and frame axioms <ref> [BMR93] </ref> (see the end of Section 4.2 for a discussion of frame axioms).
Reference: [CM84] <author> W. F. Clocksin and C. S. Mellish. </author> <title> Programming in Prolog. </title> <publisher> Springer-Verlag, </publisher> <address> New York, </address> <note> second edition, 1984. 21 </note>
Reference-contexts: This review is intended as a brief introduction for readers who are unfamiliar with logic programming, and as a basis for comparison with our technique. The basic execution mechanisms of Prolog <ref> [CM84] </ref> [Col85] [Coh85] are unification, refutation (or resolution), and backtracking. The domain of computation is finite trees, which represent terms. Unification is the process of finding a substitution for the free variables of two atomic formulas or terms that makes the atomic formulas or terms identical.
Reference: [Coh85] <author> Jacques Cohen. </author> <title> Describing Prolog by Its Interpretation and Compilation. </title> <journal> Communi--cations of the ACM, </journal> <volume> 28(12) </volume> <pages> 1311-1324, </pages> <month> December </month> <year> 1985. </year>
Reference-contexts: This review is intended as a brief introduction for readers who are unfamiliar with logic programming, and as a basis for comparison with our technique. The basic execution mechanisms of Prolog [CM84] [Col85] <ref> [Coh85] </ref> are unification, refutation (or resolution), and backtracking. The domain of computation is finite trees, which represent terms. Unification is the process of finding a substitution for the free variables of two atomic formulas or terms that makes the atomic formulas or terms identical.
Reference: [Coh90] <author> Jacques Cohen. </author> <title> Constraint Logic Programming Languages. </title> <journal> Communications of the ACM, </journal> <volume> 33(7):52 - 68, </volume> <month> July </month> <year> 1990. </year>
Reference-contexts: As the execution of a Prolog III program progresses, backtracking occurs whenever the current set of constraints becomes unsatisfiable, or when no rule can be applied. The evaluation of a constraint can be explicitly delayed by the user with a "freeze" mechanism <ref> [Coh90] </ref>. The domains over which constraint solving occurs are infinite trees, lists, booleans, reals, characters, and strings. On the other hand, CLP (R) uses constraint satisfaction only for the reals, and unification for other computational domains. Constraints consist of arithmetic equations and inequalities, and equality of nonarithmetic terms.
Reference: [Col85] <author> Alain Colmerauer. </author> <title> Prolog in 10 Figures. </title> <journal> Communications of the ACM, </journal> <volume> 28(12):1296 - 1310, </volume> <month> December </month> <year> 1985. </year>
Reference-contexts: This review is intended as a brief introduction for readers who are unfamiliar with logic programming, and as a basis for comparison with our technique. The basic execution mechanisms of Prolog [CM84] <ref> [Col85] </ref> [Coh85] are unification, refutation (or resolution), and backtracking. The domain of computation is finite trees, which represent terms. Unification is the process of finding a substitution for the free variables of two atomic formulas or terms that makes the atomic formulas or terms identical.
Reference: [Col90] <author> Alain Colmerauer. </author> <title> An Introduction to Prolog III. </title> <journal> Communications of the ACM, </journal> <volume> 33(7):69 - 90, </volume> <month> July </month> <year> 1990. </year>
Reference-contexts: Many of the contributions of our work come directly from this idea. These contributions include: * handling constraints over specification language domains such as sets, unions, sequences, tuples and objects. Typical CLP languages solve constraints over the reals, and Prolog III <ref> [Col90] </ref> solves constraints over several domains in addition to the reals, but the domains that are typical for specification languages are not typical for CLP languages. * backtracking based on explicit type information. As CLP languages are usually untyped, there is little opportunity to take advantage of type information. <p> The refutation algorithm often has a choice of rules to apply, so that when a choice of one rule results in the inability to conclude the query, the algorithm can backtrack and try a different rule. The best known CLP languages are Prolog III <ref> [Col90] </ref> and CLP (R) [JMSY92]. While the languages have some similarities | for example, both use refutation and backtracking much like Prolog | they are also quite different, both from each other and from Prolog. In Prolog III, unification is completely replaced by constraint solving. <p> Similar lazy techniques could be used to execute specifications involving infinite sets and sequences. A final possibility is to add constraint solving over real valued variables in the sense of CLP (R) [JMSY92] and Prolog III <ref> [Col90] </ref>.
Reference: [DKC90] <author> A.J.J. Dick, P.J. Krause, and J. Cozens. </author> <title> Computer Aided Transformation of Z into Prolog. </title> <editor> In J.E. Nicholls, editor, </editor> <booktitle> Z User Workshop, Oxford 1989, Workshops in Computing, </booktitle> <pages> pages 71-85, </pages> <address> Berlin, 1990. </address> <publisher> Springer-Verlag. </publisher>
Reference-contexts: Use Prolog syntax or code in the specification language, and execute specifications via Prolog. Examples include PLEASE [TC89] and OBSERV [TY92]. 3. Explicitly translate specifications to Prolog programs. A number of researchers have experimented with this approach <ref> [DKC90] </ref> [WE92], but to the authors' knowledge, no completely automated translator exists.
Reference: [DL96] <author> Krishna Kishore Dhara and Gary T. Leavens. </author> <title> Forcing Behavioral Subtyping Through Specification Inheritance. </title> <booktitle> In Proceedings of the 18th International Conference on Software Engineering, </booktitle> <address> Berlin, Germany, </address> <pages> pages 258-267. </pages> <publisher> IEEE Computer Society Press, </publisher> <month> March </month> <year> 1996. </year>
Reference-contexts: Our experience is that the inheritance and subtyping relationships in most specifications of C++ classes are easily implemented by syntactic changes to the specification for example, copying the specification of an operation from the specification of the base class to the specification of the derived class <ref> [DL96] </ref>. Hence, our execution technique assumes that such changes are made before the specification is executed, and so does not deal with inheritance and subtyping. Techniques and concepts from Constraint Logic Programming (CLP) have been inspirational in developing our execution technique for model-based specification languages.
Reference: [ELA93] <author> R. Elmstrtm, P.B. Lassen, and M. Andersen. </author> <title> An Executable Subset of VDM-SL, in an SA/RT Framework. </title> <note> 1993. Submitted for publication in Real-Time Systems Journal. </note>
Reference-contexts: This is the most prevalent approach, and examples include EPROL [HI88] [HI86], me too [Hen86], SMLVIEW [O'N92b] [O'N92a], and the technique used for executing IPTES mini-specifications <ref> [ELA93] </ref> [LL91] [AELL92].
Reference: [Hay93] <author> I. Hayes, </author> <title> editor. Specification Case Studies. </title> <booktitle> International Series in Computer Science. </booktitle> <publisher> Prentice-Hall, </publisher> <address> Englewood Cliffs, N.J., </address> <note> second edition, </note> <year> 1993. </year>
Reference-contexts: Any other nonterminals that are not expanded represent either literals of SPECS-C++ types (if ending in -literal) or identifiers. specification languages are VDM [Jon90] [A + 93] and Z <ref> [Hay93] </ref> [Spi89] [Spi92], although many other model-based specification languages have been developed. The model typically includes primitive types such as integers and characters, as well as more structured types such as finite sets, sequences, tuples, and functions.
Reference: [Hen86] <author> Peter Henderson. </author> <title> Functional Programming, Formal Specification, and Rapid Proto-typing. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> SE-12(2), </volume> <month> February </month> <year> 1986. </year>
Reference-contexts: 1 Introduction Many executable specification languages have been developed [AELL92] <ref> [Hen86] </ref> [HI88] [KK93] [O'N92a] [TC89] [TY92], but all that the authors are aware of except fase3 [KK93] are considerably different from typical non-executable specification languages. <p> This is the most prevalent approach, and examples include EPROL [HI88] [HI86], me too <ref> [Hen86] </ref>, SMLVIEW [O'N92b] [O'N92a], and the technique used for executing IPTES mini-specifications [ELA93] [LL91] [AELL92].
Reference: [HI86] <author> Sharam Hekmatpour and Darrel C. Ince. </author> <title> A Formal Specification-Based Prototyping System. </title> <editor> In D. Barnes and P. Brown, editors, </editor> <booktitle> Software Engineering 86, </booktitle> <pages> pages 317 - 335. </pages> <publisher> Peter Peregrinus Ltd., </publisher> <address> London, UK, </address> <year> 1986. </year>
Reference-contexts: This is the most prevalent approach, and examples include EPROL [HI88] <ref> [HI86] </ref>, me too [Hen86], SMLVIEW [O'N92b] [O'N92a], and the technique used for executing IPTES mini-specifications [ELA93] [LL91] [AELL92].
Reference: [HI88] <author> Sharam Hekmatpour and Darrel C. Ince. </author> <title> Software Prototyping, Formal Methods, and VDM. </title> <publisher> Addison-Wesley, </publisher> <address> Wokingham, England, </address> <year> 1988. </year>
Reference-contexts: 1 Introduction Many executable specification languages have been developed [AELL92] [Hen86] <ref> [HI88] </ref> [KK93] [O'N92a] [TC89] [TY92], but all that the authors are aware of except fase3 [KK93] are considerably different from typical non-executable specification languages. <p> This is the most prevalent approach, and examples include EPROL <ref> [HI88] </ref> [HI86], me too [Hen86], SMLVIEW [O'N92b] [O'N92a], and the technique used for executing IPTES mini-specifications [ELA93] [LL91] [AELL92].
Reference: [JD96] <author> Daniel Jackson and Craig A. Damon. </author> <title> Elements of Style: Analyzing a Software Design Feature with a Counterexample Detector. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 22(7), </volume> <month> July </month> <year> 1996. </year>
Reference-contexts: Otherwise, only small inputs can be used. However, even small "test cases" are helpful in debugging <ref> [JD96] </ref> and in demonstrating the functionality of specifications. 4.7 Future Work Several relatively simple extensions of the execution technique would enhance its usefulness.
Reference: [JMSY92] <author> Joxan Jaffar, Spiro Michaylov, Peter J. Stuckey, and Roland H. C. Yap. </author> <title> The CLP(R) Language and System. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 14(3):339 - 395, </volume> <month> July </month> <year> 1992. </year>
Reference-contexts: The refutation algorithm often has a choice of rules to apply, so that when a choice of one rule results in the inability to conclude the query, the algorithm can backtrack and try a different rule. The best known CLP languages are Prolog III [Col90] and CLP (R) <ref> [JMSY92] </ref>. While the languages have some similarities | for example, both use refutation and backtracking much like Prolog | they are also quite different, both from each other and from Prolog. In Prolog III, unification is completely replaced by constraint solving. <p> It will be checked again when more is known about the post-state. (This is similar to the delaying of non-linear equations in CLP (R) <ref> [JMSY92] </ref>.) Thus, transforming constraints is iterative, and continues until either the constraint set is empty or none of the constraints in the set can be further transformed. The induction steps of constraint transformation handle constraints containing boolean con-nectives and universal and existential quantifiers. These transformations are summarized in Table 1. <p> Similar lazy techniques could be used to execute specifications involving infinite sets and sequences. A final possibility is to add constraint solving over real valued variables in the sense of CLP (R) <ref> [JMSY92] </ref> and Prolog III [Col90].
Reference: [Jon90] <author> Cliff B. Jones. </author> <title> Systematic Software Development Using VDM. </title> <booktitle> International Series in Computer Science. </booktitle> <publisher> Prentice Hall, </publisher> <address> Englewood Cliffs, N.J., </address> <note> second edition, </note> <year> 1990. </year>
Reference-contexts: Any other nonterminals that are not expanded represent either literals of SPECS-C++ types (if ending in -literal) or identifiers. specification languages are VDM <ref> [Jon90] </ref> [A + 93] and Z [Hay93] [Spi89] [Spi92], although many other model-based specification languages have been developed. The model typically includes primitive types such as integers and characters, as well as more structured types such as finite sets, sequences, tuples, and functions. <p> Function noDups would be defined elsewhere in the specification. Abstract functions play the same role as specification functions in VDM <ref> [Jon90] </ref>. constraint is an active constraint that defines one index position in the post-state value of si. Thus, the first conjunct of the postcondition generates all permutations of the pre-state sequence value, as needed.
Reference: [KK93] <author> Samuel Kamin and Tim Kraus. </author> <title> Executable Specifications of C++ Classes. </title> <note> submitted for publication, </note> <year> 1993. </year>
Reference-contexts: 1 Introduction Many executable specification languages have been developed [AELL92] [Hen86] [HI88] <ref> [KK93] </ref> [O'N92a] [TC89] [TY92], but all that the authors are aware of except fase3 [KK93] are considerably different from typical non-executable specification languages. <p> 1 Introduction Many executable specification languages have been developed [AELL92] [Hen86] [HI88] <ref> [KK93] </ref> [O'N92a] [TC89] [TY92], but all that the authors are aware of except fase3 [KK93] are considerably different from typical non-executable specification languages. Executable specification languages usually require the specifier to supply algorithmic information (and so to specify at a lower level of abstraction), or use a syntax that is markedly different from the first-order predicate calculus found in non-executable specification languages. <p> Post-state values are the "outputs" from specified operations function return values, and modifications of parameters and global objects. Only one existing executable specification language that the authors are aware of (fase3 <ref> [KK93] </ref>) can execute any form of such assertions, and fase3 can execute only a very limited form of these assertions. Our technique executes 2 such assertions by extracting constraints from them, and then solving the constraints. <p> Many executable specification languages use quantified assertions, but almost all of these languages only allow such assertions to be evaluated over pre-state values. The fase3 system <ref> [KK93] </ref> is the only other execution technique that the authors are aware of that can use quantified assertions directly in defining the post-state, but fase3 can only use one restricted form of existential quantification in this way. <p> Another possibility for future work is the execution of quantified assertions in which the bound variable ranges over an unspecified or infinite domain. As evidenced by fase3 <ref> [KK93] </ref> [Kra88], one can execute such assertions if the bound variable implicitly ranges over a finite domain. Similar lazy techniques could be used to execute specifications involving infinite sets and sequences. <p> This is the most prevalent approach, and examples include EPROL [HI88] [HI86], me too [Hen86], SMLVIEW [O'N92b] [O'N92a], and the technique used for executing IPTES mini-specifications [ELA93] [LL91] [AELL92]. The fase3 execution technique <ref> [KK93] </ref> [Kra88] can execute a much larger set of assertions than any of the others mentioned here, but can not execute universally quantified assertions that refer to post-state values, and can only execute one very limited form of existentially quantified assertions that refer to post-state values. 20 2.
Reference: [Kra88] <author> Tim Kraus. </author> <title> The FASE3 System for Executable Data Type Specification. </title> <type> Master's thesis, </type> <institution> University of Illinois, Urbana, Illinois, </institution> <year> 1988. </year> <type> Technical Report 87-1789. </type>
Reference-contexts: Another possibility for future work is the execution of quantified assertions in which the bound variable ranges over an unspecified or infinite domain. As evidenced by fase3 [KK93] <ref> [Kra88] </ref>, one can execute such assertions if the bound variable implicitly ranges over a finite domain. Similar lazy techniques could be used to execute specifications involving infinite sets and sequences. <p> This is the most prevalent approach, and examples include EPROL [HI88] [HI86], me too [Hen86], SMLVIEW [O'N92b] [O'N92a], and the technique used for executing IPTES mini-specifications [ELA93] [LL91] [AELL92]. The fase3 execution technique [KK93] <ref> [Kra88] </ref> can execute a much larger set of assertions than any of the others mentioned here, but can not execute universally quantified assertions that refer to post-state values, and can only execute one very limited form of existentially quantified assertions that refer to post-state values. 20 2.
Reference: [LL91] <author> Peter Gorm Larsen and Poul Btgh Lassen. </author> <title> An Executable Subset of Meta-IV with Loose Specification. In VDM '91: Formal Software Development Methods, </title> <address> Berlin, </address> <month> March </month> <year> 1991. </year> <title> VDM Europe, </title> <publisher> Springer-Verlag. </publisher>
Reference-contexts: This is the most prevalent approach, and examples include EPROL [HI88] [HI86], me too [Hen86], SMLVIEW [O'N92b] [O'N92a], and the technique used for executing IPTES mini-specifications [ELA93] <ref> [LL91] </ref> [AELL92].
Reference: [O'N92a] <author> Guy O'Neill. </author> <title> Automatic Translation of VDM Specifications into Standard ML Programs. </title> <journal> The Computer Journal, </journal> <volume> 35(6) </volume> <pages> 623-624, </pages> <month> December </month> <year> 1992. </year>
Reference-contexts: 1 Introduction Many executable specification languages have been developed [AELL92] [Hen86] [HI88] [KK93] <ref> [O'N92a] </ref> [TC89] [TY92], but all that the authors are aware of except fase3 [KK93] are considerably different from typical non-executable specification languages. <p> This is the most prevalent approach, and examples include EPROL [HI88] [HI86], me too [Hen86], SMLVIEW [O'N92b] <ref> [O'N92a] </ref>, and the technique used for executing IPTES mini-specifications [ELA93] [LL91] [AELL92].
Reference: [O'N92b] <author> Guy O'Neill. </author> <title> Automatic Translation of VDM Specifications into Standard ML Programs. </title> <type> Technical Report DITC 196/92, </type> <institution> National Physical Laboratory, Teddington, </institution> <address> Middlesex TW11 OLW, United Kingdom, </address> <month> February </month> <year> 1992. </year>
Reference-contexts: This is the most prevalent approach, and examples include EPROL [HI88] [HI86], me too [Hen86], SMLVIEW <ref> [O'N92b] </ref> [O'N92a], and the technique used for executing IPTES mini-specifications [ELA93] [LL91] [AELL92].
Reference: [Pau91] <author> L. C. Paulson. </author> <title> ML for the Working Programmer. </title> <publisher> Cambridge University Press, </publisher> <address> Cam-bridge, </address> <year> 1991. </year> <month> 22 </month>
Reference-contexts: The interpreter uses an abstract syntax for SPECS-C++ that is basically a parse tree representation of the concrete syntax presented in these examples. The interpreter [WBL94] consists of about 2800 lines of Standard ML <ref> [Pau91] </ref> code, and was written with the aid of the literate programming tool Noweb [Ram91] [Ram94]. Backtracking is implemented via continuation passing. As in denotational semantics [Sch86], state is implemented via a store that is passed to and returned from all functions that modify the state.
Reference: [Ram91] <author> Norman Ramsey. </author> <title> Literate Programming Tools Need Not Be Complex. </title> <type> Technical Report CS-TR-351-91, </type> <institution> Princeton University, </institution> <year> 1991. </year>
Reference-contexts: The interpreter uses an abstract syntax for SPECS-C++ that is basically a parse tree representation of the concrete syntax presented in these examples. The interpreter [WBL94] consists of about 2800 lines of Standard ML [Pau91] code, and was written with the aid of the literate programming tool Noweb <ref> [Ram91] </ref> [Ram94]. Backtracking is implemented via continuation passing. As in denotational semantics [Sch86], state is implemented via a store that is passed to and returned from all functions that modify the state.
Reference: [Ram94] <author> Norman Ramsey. </author> <title> Literate programming simplified. </title> <journal> IEEE Software, </journal> <volume> 11(5) </volume> <pages> 97-105, </pages> <year> 1994. </year>
Reference-contexts: The interpreter uses an abstract syntax for SPECS-C++ that is basically a parse tree representation of the concrete syntax presented in these examples. The interpreter [WBL94] consists of about 2800 lines of Standard ML [Pau91] code, and was written with the aid of the literate programming tool Noweb [Ram91] <ref> [Ram94] </ref>. Backtracking is implemented via continuation passing. As in denotational semantics [Sch86], state is implemented via a store that is passed to and returned from all functions that modify the state.
Reference: [Sch86] <author> David A. Schmidt. </author> <title> Denotational Semantics | A Methodology for Language Development. Wm. </title> <address> C. </address> <publisher> Brown Publishers, </publisher> <address> Dubuque, Iowa, </address> <year> 1986. </year>
Reference-contexts: Of these, only objects are discussed in this paper. Object types are used in SPECS-C++ to model aliasing and mutation at the specification 4 level. In this context, an object is a container for a value. Objects are the same as locations in denotational semantics <ref> [Sch86] </ref>. The pre-state value of an object is extracted by the postfix function ^, and the post-state value by the postfix function '. Thus, x^ is the pre-state value of x, and x' is its post-state value. <p> The interpreter [WBL94] consists of about 2800 lines of Standard ML [Pau91] code, and was written with the aid of the literate programming tool Noweb [Ram91] [Ram94]. Backtracking is implemented via continuation passing. As in denotational semantics <ref> [Sch86] </ref>, state is implemented via a store that is passed to and returned from all functions that modify the state. This allows backtracking to undo "state changes". 4.6 Performance In most cases, the time needed to interpret a specification is largely determined by time spent backtracking.
Reference: [Spi89] <author> J. M. Spivey. </author> <title> An Introduction to Z and Formal Specifications. </title> <journal> Software Engineering Journal, </journal> <pages> pages 40 - 50, </pages> <month> January </month> <year> 1989. </year>
Reference-contexts: Any other nonterminals that are not expanded represent either literals of SPECS-C++ types (if ending in -literal) or identifiers. specification languages are VDM [Jon90] [A + 93] and Z [Hay93] <ref> [Spi89] </ref> [Spi92], although many other model-based specification languages have been developed. The model typically includes primitive types such as integers and characters, as well as more structured types such as finite sets, sequences, tuples, and functions.
Reference: [Spi92] <author> J. M. Spivey. </author> <title> The Z Notation: A Reference Manual. </title> <booktitle> International Series in Computer Science. </booktitle> <publisher> Prentice-Hall, </publisher> <address> New York, </address> <note> second edition, 1992. ISBN 013983768X. </note>
Reference-contexts: Any other nonterminals that are not expanded represent either literals of SPECS-C++ types (if ending in -literal) or identifiers. specification languages are VDM [Jon90] [A + 93] and Z [Hay93] [Spi89] <ref> [Spi92] </ref>, although many other model-based specification languages have been developed. The model typically includes primitive types such as integers and characters, as well as more structured types such as finite sets, sequences, tuples, and functions.
Reference: [Str91] <author> Bjarne Stroustrup. </author> <title> The C++ Programming Language. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, Mas-sachusetts, </address> <note> second edition, </note> <year> 1991. </year>
Reference-contexts: by a fellowship from IBM Rochester. y Leavens's work was supported in part by the National Science Foundation under grant CCR-9593168. 1 Our goal in this work is to execute a large and useful subset of SPECS-C++ [WBL94], a model-based formal specification language designed for specifying the interfaces of C++ <ref> [Str91] </ref> classes. In particular, we want to execute the kinds of specifications that specifiers typically write when they are not thinking about executability. Hence, we observed the ways in which SPECS-C++ specifications are typically written, and concentrated on finding ways to execute the specification idioms used in those specifications. <p> The execution technique described in the next section was developed in the context of the specification language SPECS-C++ [WBL94], which is a formal and model-based language specialized for specifying the interfaces of C++ classes <ref> [Str91] </ref>. Figure 1 contains an EBNF grammar for executable SPECS-C++ assertions. SPECS-C++ operators are discussed in the following text, and the structure of assertions is discussed in Section 4.1. The implementation uses an abstract version of this concrete syntax.
Reference: [TC89] <author> R.B. Terwilliger and R.H. Campbell. </author> <title> PLEASE: Executable Specifications for Incremental Software Development. </title> <journal> Journal of Systems and Software, </journal> <volume> 10(2):97 - 112, </volume> <month> September </month> <year> 1989. </year>
Reference-contexts: 1 Introduction Many executable specification languages have been developed [AELL92] [Hen86] [HI88] [KK93] [O'N92a] <ref> [TC89] </ref> [TY92], but all that the authors are aware of except fase3 [KK93] are considerably different from typical non-executable specification languages. <p> Use Prolog syntax or code in the specification language, and execute specifications via Prolog. Examples include PLEASE <ref> [TC89] </ref> and OBSERV [TY92]. 3. Explicitly translate specifications to Prolog programs. A number of researchers have experimented with this approach [DKC90] [WE92], but to the authors' knowledge, no completely automated translator exists.
Reference: [Tsa93] <author> Edward Tsang. </author> <title> Foundations of Constraint Satisfaction. </title> <booktitle> Computation in Cognitive Science. </booktitle> <publisher> Academic Press, </publisher> <address> London, </address> <year> 1993. </year>
Reference: [TY92] <author> S. Tyszberowicz and A. Yehudai. </author> <title> OBSERV A Prototying Language and Environment. </title> <journal> ACM Transactions on Software Engineering and Methodology, </journal> <volume> 1(3):269 - 309, </volume> <month> July </month> <year> 1992. </year>
Reference-contexts: 1 Introduction Many executable specification languages have been developed [AELL92] [Hen86] [HI88] [KK93] [O'N92a] [TC89] <ref> [TY92] </ref>, but all that the authors are aware of except fase3 [KK93] are considerably different from typical non-executable specification languages. <p> Use Prolog syntax or code in the specification language, and execute specifications via Prolog. Examples include PLEASE [TC89] and OBSERV <ref> [TY92] </ref>. 3. Explicitly translate specifications to Prolog programs. A number of researchers have experimented with this approach [DKC90] [WE92], but to the authors' knowledge, no completely automated translator exists.
Reference: [Van89] <author> Pascal Van Hentenryck. </author> <title> Constraint Satisfaction in Logic Programming. </title> <publisher> The MIT Press, </publisher> <address> Cambridge, Massachusetts, </address> <year> 1989. </year>
Reference-contexts: Because constraints containing existentially quantified constraints are essentially transformed to disjunctions, backtracking can try each element of the domain for i as needed. The body of the existentially quantified 4 Thus, the bound variable is somewhat like a domain variable in the CLP language CHIP <ref> [Van89] </ref> in that it ranges over a known and finite domain. However, our use bound variables is quite different from the use of domain variables in CHIP.
Reference: [WBL94] <author> Tim Wahls, Albert L. Baker, and Gary T. Leavens. </author> <title> The Direct Execution of SPECS-C++: A Model-Based Specification Language for C++ Classes. </title> <type> Technical Report TR94-02, </type> <institution> Department of Computer Science, Iowa State University, Ames, Iowa 50011, </institution> <month> February </month> <year> 1994. </year> <note> available by anonymous ftp from ftp.cs.iastate.edu and by e-mail from almanac@cs.iastate.edu. </note>
Reference-contexts: a relatively high level of abstraction. fl Wahls's work was supported in part by a fellowship from IBM Rochester. y Leavens's work was supported in part by the National Science Foundation under grant CCR-9593168. 1 Our goal in this work is to execute a large and useful subset of SPECS-C++ <ref> [WBL94] </ref>, a model-based formal specification language designed for specifying the interfaces of C++ [Str91] classes. In particular, we want to execute the kinds of specifications that specifiers typically write when they are not thinking about executability. <p> Hence, for our purposes, execution of such specifications means checking that the pre-state satisfies the precondition, and then finding post-state values that satisfy the postcondition. The execution technique described in the next section was developed in the context of the specification language SPECS-C++ <ref> [WBL94] </ref>, which is a formal and model-based language specialized for specifying the interfaces of C++ classes [Str91]. Figure 1 contains an EBNF grammar for executable SPECS-C++ assertions. SPECS-C++ operators are discussed in the following text, and the structure of assertions is discussed in Section 4.1. <p> The interpreter uses an abstract syntax for SPECS-C++ that is basically a parse tree representation of the concrete syntax presented in these examples. The interpreter <ref> [WBL94] </ref> consists of about 2800 lines of Standard ML [Pau91] code, and was written with the aid of the literate programming tool Noweb [Ram91] [Ram94]. Backtracking is implemented via continuation passing.
Reference: [WE92] <author> M.M. West and B.M. Eaglestone. </author> <title> Software development: two approaches to animation of Z specifications using Prolog. </title> <journal> Software Engineering Journal, </journal> <volume> 7(4) </volume> <pages> 264-276, </pages> <month> July </month> <year> 1992. </year>
Reference-contexts: Use Prolog syntax or code in the specification language, and execute specifications via Prolog. Examples include PLEASE [TC89] and OBSERV [TY92]. 3. Explicitly translate specifications to Prolog programs. A number of researchers have experimented with this approach [DKC90] <ref> [WE92] </ref>, but to the authors' knowledge, no completely automated translator exists.
Reference: [WLB97] <author> Tim Wahls, Gary T. Leavens, and Albert L. Baker. </author> <title> The Soundness of an Algorithm for Executing Model-based Specifications. </title> <note> to appear, 1997. 23 </note>
Reference-contexts: Solving an active constraint never results in a post-state that does not satisfy any of the active constraints that have previously been solved, or that does not satisfy a constraint that previously was satisfied. In a forthcoming work <ref> [WLB97] </ref>, we give an operational semantics for the SPECS-C++ execution technique and show that the semantics satisfies these properties. 4.4 Examples (result = x') is delayed because both terms denote undefined post-state values.
References-found: 38

