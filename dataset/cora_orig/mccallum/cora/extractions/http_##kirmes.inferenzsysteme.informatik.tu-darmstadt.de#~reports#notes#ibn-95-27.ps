URL: http://kirmes.inferenzsysteme.informatik.tu-darmstadt.de/~reports/notes/ibn-95-27.ps
Refering-URL: http://www.inferenzsysteme.informatik.tu-darmstadt.de/~reports/
Root-URL: http://www.aic.nrl.navy.mil/~aha/people.html
Email: e-mail: fkolbejwaltherg@inferenzsysteme.informatik.th-darmstadt.de  
Title: Patching Proofs for Reuse  
Author: Thomas Kolbe Christoph Walther 
Address: Alexanderstr. 10, D-64283 Darmstadt, Germany  
Affiliation: FB Informatik, TH Darmstadt,  
Abstract: 1 We investigate the application of machine learning paradigms in automated reasoning in order to improve a theorem prover by reusing previously computed proofs. Our reuse procedure generalizes a previously computed proof of a conjecture yielding a schematic proof which can be instantiated subsequently if a new, similar conjecture is given. We show that for exploiting the full flexibility of second-order instantiations the instantiated schematic proof has to be patched such that a proof of the new conjecture is obtained. We develop an algorithm which computes patched proofs showing thereby that proof patching is always possible in a uniform way. This enables a further processing of the obtained proof, justifies the soundness of our proposal for reusing proofs, and provides a key for comparing our method with other reuse paradigms.
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> J. L. Bates and R. L. Constable. </author> <title> Proofs as Programs. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 7(1) </volume> <pages> 113-136, </pages> <year> 1985. </year>
Reference-contexts: Furthermore proofs can be worked up for planning or synthesis tasks if plans or programs should be extracted form proofs <ref> [1, 14] </ref>. All these applications require a specific proof, i.e. it is not enough to know that some proof exists. As long as we instantiate function variables with function symbols, the proof ((P 0 )) of has the same structure as the schematic proof P 0 . <p> Finally, the replace ( 2 (5))-step is redundant and should be omitted. Thus 2 (P 0 ) has to be patched for obtaining a proof of 2s which can be processed subsequently in applications like <ref> [5, 10, 1, 14] </ref>. This example reveals the need for patching proofs and we show that the necessary modifications can always be performed in a uniform way for an arbitrary second-order substitution. <p> Hence 2 (t) = minus (plus (succ (x); y); plus (succ (x); y)) and 2 (t 0 ) = minus (succ (plus (x; y)); succ (plus (x; y))). The call patch positions (t; p; 2 ) yields the positions <ref> [1; 2] </ref> with 2 (t)j 1 = 2 (t)j 2 = plus (succ (x); y) = 2 (l), i.e. 2 (t)[1; 2 2 (r)] = 2 (t 0 ).
Reference: [2] <author> B. Brock, S. Cooper, and W. Pierce. </author> <title> Analogical Reasoning and Proof Discovery. </title> <booktitle> In Proceedings of the 9th International Conference on Automated Deduction, Argonne, </booktitle> <pages> pages 454-468. </pages> <year> 1988. </year>
Reference-contexts: 1 Introduction Several machine learning paradigms aim to improve a problem solver by reusing previously computed solutions, e.g. explanation-based learning (EBL) [16, 4, 6], analogical reasoning (AR) <ref> [2, 9, 18] </ref> and abstraction techniques (AT) [19, 7]. In EBL a problem's solution is analyzed, yielding an explanation why the solution succeeds. After generalization, the explanation is used for solving (similar) new problems. <p> Hence 2 (t) = minus (plus (succ (x); y); plus (succ (x); y)) and 2 (t 0 ) = minus (succ (plus (x; y)); succ (plus (x; y))). The call patch positions (t; p; 2 ) yields the positions <ref> [1; 2] </ref> with 2 (t)j 1 = 2 (t)j 2 = plus (succ (x); y) = 2 (l), i.e. 2 (t)[1; 2 2 (r)] = 2 (t 0 ). <p> In present research of applying analogical reasoning to theorem proving, e.g. <ref> [2, 18] </ref>, a suitable source conjecture is given (or selected) and matched with the target conjecture, and then the source proof is mapped to the target domain step by step, guiding the target proof. <p> proof of a source problem) which have to be verified for the target domain, whereas the whole new proof can always be constructed in a uniform way, cf. the algorithm patch proof from Section 4. 11 This is the main difference to other applications of analogical reasoning to theorem proving <ref> [2, 18] </ref> in which the reuse is based on the proof structure which has to be modified for increasing the reuse success. Consequently analogical reasoning demands that the whole proof is replayed to guarantee the soundness of the analogical inferences. <p> We have analyzed our approach from the viewpoint of the existing machine learning methodologies. Our method for reusing proofs may be regarded as reasoning by analogy <ref> [9, 2, 18] </ref> or as an application of explanation-based learning [16, 4, 6]. A rather weak relation exists to abstraction techniques [7, 19].
Reference: [3] <author> A. Bundy, A. Stevens, F. van Harmelen, A. Ireland, and A. Smaill. </author> <month> Rippling: </month>
Reference-contexts: The proof of an induction formula is one of the main challenges in automated mathematical induction and therefore has been studied intensively, cf. <ref> [3, 11, 20] </ref>. Induction proofs can be reused in the following way (see [12] for a more detailed account): Once the prover has found a proof P for a conjecture ' from a set of axioms AX , the proof is analyzed yielding a so-called catch C.
References-found: 3

