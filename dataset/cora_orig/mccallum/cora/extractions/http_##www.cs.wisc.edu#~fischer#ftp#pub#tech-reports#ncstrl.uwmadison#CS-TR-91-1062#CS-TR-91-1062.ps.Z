URL: http://www.cs.wisc.edu/~fischer/ftp/pub/tech-reports/ncstrl.uwmadison/CS-TR-91-1062/CS-TR-91-1062.ps.Z
Refering-URL: http://www.cs.wisc.edu/~fischer/ftp/pub/tech-reports/ncstrl.uwmadison/CS-TR-91-1062/
Root-URL: http://www.cs.wisc.edu
Title: Argument Reduction by Factoring  
Author: J. F. Naughton R. Ramakrishnan Y. Sagiv J. D. Ullman 
Date: May 7, 1992  
Abstract: We identify a useful property of a program with respect to a predicate, called factoring. While we prove that detecting factorability is undecidable in general, we show that for a large class of programs, the program obtained by applying the Magic Sets transformation is factorable with respect to the recursive predicate. When the factoring property holds, a simple optimization of the program generated by the Magic Sets transformation results in a new program that is never less efficient than the Magic Sets program and is often dramatically more efficient, due to the reduction of the arity of the recursive predicate. We show that the concept of factoring generalizes some previously identified special cases of recursions, including separable recursions and right- and left-linear recursions.
Abstract-found: 1
Intro-found: 1
Reference: [ASU79] <author> Alfred V. Aho, Yehoshua Sagiv, and Jeffrey D. Ullman. </author> <title> Equivalence of relational expressions. </title> <journal> SIAM Journal of Computing, </journal> <volume> 8(2) </volume> <pages> 218-246, </pages> <year> 1979. </year>
Reference-contexts: Then for every a in A, there is some s in S such that a is an answer to S in the magic program. 23 Because testing for these factorable classes of recursions in general requires testing for containment of conjunctive queries, and testing for conjunctive query containment is NP-complete <ref> [CM77, ASU79] </ref>, testing for membership in these classes is also NP-complete. It is important that the measure of size here is the size of the recursion and query, not the database.
Reference: [BMSU86] <author> Francois Bancilhon, David Maier, Yehoshua Sagiv, and Jeffrey D. Ullman. </author> <title> Magic sets and other strange ways to implement logic programs. </title> <booktitle> In Proceedings of the ACM Symposium on Principles of Database Systems, </booktitle> <pages> pages 1-15, </pages> <address> Cambridge, Mas-sachusetts, </address> <month> March </month> <year> 1986. </year>
Reference-contexts: 1 Introduction The Magic Sets transformation <ref> [BMSU86, BR87] </ref> is a rule rewriting technique that, given a query and a recursive program, produces a new program such that the semi-naive bottom-up evaluation of the new program constructs the answer to the query more efficiently than the original recursion. <p> The rules in the program are then modified by attaching additional literals that act as filters and prevent the rule from generating irrelevant tuples. We assume familiarity with the Magic Sets algorithm, which we illustrate in Example 4.2. The reader is referred to <ref> [BMSU86, BR87, Ram88] </ref> for details. 3 The Factoring Property Consider a program P, a query Q, and a predicate p that appears in P. <p> Note that applying this transformation results in a program that does not contain p, which is replaced by two predicates, p 1 and p 2 , of strictly lower arity. 4 Classes of Factorable Programs The Magic Sets transformation <ref> [BMSU86, BR87, Ram88] </ref> rewrites a program with the objective of restricting the computation by propagating bindings in the query. <p> In addition, for the programs considered in that paper, the Magic Sets plus factoring transformation produces the same final program as the rewriting algorithms from that paper. 32 6.4 The Counting Transformation The Counting transformation <ref> [BMSU86, BR87, SZ86] </ref> can be understood as a variant of the Magic Sets transformation. First, every derived predicate is augmented with some index fields, which, intuitively, encode the derivation of the fact.
Reference: [BR87] <author> Catriel Beeri and Raghu Ramakrishnan. </author> <title> On the power of magic. </title> <booktitle> In Proceedings of the ACM Symposium on Principles of Database Systems, </booktitle> <pages> pages 269-283, </pages> <address> San Diego, California, </address> <month> March </month> <year> 1987. </year>
Reference-contexts: 1 Introduction The Magic Sets transformation <ref> [BMSU86, BR87] </ref> is a rule rewriting technique that, given a query and a recursive program, produces a new program such that the semi-naive bottom-up evaluation of the new program constructs the answer to the query more efficiently than the original recursion. <p> The rules in the program are then modified by attaching additional literals that act as filters and prevent the rule from generating irrelevant tuples. We assume familiarity with the Magic Sets algorithm, which we illustrate in Example 4.2. The reader is referred to <ref> [BMSU86, BR87, Ram88] </ref> for details. 3 The Factoring Property Consider a program P, a query Q, and a predicate p that appears in P. <p> Note that applying this transformation results in a program that does not contain p, which is replaced by two predicates, p 1 and p 2 , of strictly lower arity. 4 Classes of Factorable Programs The Magic Sets transformation <ref> [BMSU86, BR87, Ram88] </ref> rewrites a program with the objective of restricting the computation by propagating bindings in the query. <p> In addition, for the programs considered in that paper, the Magic Sets plus factoring transformation produces the same final program as the rewriting algorithms from that paper. 32 6.4 The Counting Transformation The Counting transformation <ref> [BMSU86, BR87, SZ86] </ref> can be understood as a variant of the Magic Sets transformation. First, every derived predicate is augmented with some index fields, which, intuitively, encode the derivation of the fact. <p> ) :- magic p bf (X ); f irst2 (X; U ): fp (Y ) :- magic p bf (X ); exit (X; Y ): Now consider the counting program (which can be obtained by adding index fields to the magic program and then deleting some arguments, literals and rules <ref> [BR87] </ref>): cnt p bf (5; 0): cnt p bf (U; I + 1) :- cnt p bf (X; I); f irst1 (X; U ): cnt p bf (U; I + 1) :- cnt p bf (X; I); f irst2 (X; U ): 34 p bf (Y; I) :- p bf (Y;
Reference: [CM77] <author> Ashok K. Chandra and Philip M. Merlin. </author> <title> Optimal implementation of conjunctive queries in relational data bases. </title> <booktitle> In Conference Record of the Ninth Annual ACM Symposium on Theory of Computing, </booktitle> <pages> pages 77-90, </pages> <address> Boulder, Colorado, </address> <month> May </month> <year> 1977. </year>
Reference-contexts: Then for every a in A, there is some s in S such that a is an answer to S in the magic program. 23 Because testing for these factorable classes of recursions in general requires testing for containment of conjunctive queries, and testing for conjunctive query containment is NP-complete <ref> [CM77, ASU79] </ref>, testing for membership in these classes is also NP-complete. It is important that the measure of size here is the size of the recursion and query, not the database.
Reference: [Llo84] <author> John W. Lloyd. </author> <title> Foundations of Logic Programming. </title> <publisher> Springer-Verlag, </publisher> <year> 1984. </year>
Reference-contexts: This example is worked out in detail in Example 4.6 2 2 Definitions We consider Horn clause logic programs. We will assume the usual definitions of term, literal and rule <ref> [Llo84] </ref>.
Reference: [Nau87] <author> Jeffrey F. Naughton. </author> <title> One sided recursions. </title> <booktitle> In Proceedings of the ACM Symposium on Principles of Database Systems, </booktitle> <pages> pages 340-348, </pages> <address> San Diego, California, </address> <month> March </month> <year> 1987. </year>
Reference-contexts: t bf (X ); e (X; Y ): query (Y ) :- f t (Y ): 2 6 A Unifying Overview We consider how the refinements of the Magic Sets transformation presented in this paper are related to some previously defined optimizations. 6.1 One-Sided Recursions One-sided recursions were identified in <ref> [Nau87] </ref> as a class of recursions for which there are efficient evaluation algorithms. Here we restate the characterization of one-sided recursions. Theorem 6.1 (Theorem 3.1 from [Nau87]) Let D be a recursive definition with a single, linear recursive rule r. <p> of the Magic Sets transformation presented in this paper are related to some previously defined optimizations. 6.1 One-Sided Recursions One-sided recursions were identified in <ref> [Nau87] </ref> as a class of recursions for which there are efficient evaluation algorithms. Here we restate the characterization of one-sided recursions. Theorem 6.1 (Theorem 3.1 from [Nau87]) Let D be a recursive definition with a single, linear recursive rule r. Then D is one-sided if and only if the full A/V graph for r has only one connected component with a cycle of nonzero weight, and that component has a cycle of weight 1.
Reference: [Nau88a] <author> Jeffrey F. Naughton. </author> <title> Compiling separable recursions. </title> <booktitle> In Proceedings of the SIGMOD International Symposium on Management of Data, </booktitle> <pages> pages 312-319, </pages> <address> Chicago, Illinois, </address> <month> May </month> <year> 1988. </year>
Reference-contexts: While we prove that in general detecting factorable recursions is undecidable, we describe classes of recursions for which the Magic Sets transformation always produces a factorable recursion. The separable recursions <ref> [Nau88a] </ref> and the left- and right-linear recursions [NRSU89] have also been identified as significant classes of recursion for which there are arity reducing evaluation algorithms. <p> In this work we show that these classes of recursions are proper subsets of the class of recursions for which Magic Sets produces a factorable recursion. Furthermore, the special purpose evaluation algorithms of <ref> [Nau88a] </ref> and the special purpose rewriting techniques of [NRSU89] can be derived automatically by simple optimizations applied to the factored Magic program. We introduce the notion of factoring in Section 2, and show that in general it is undecidable. <p> This in turn implies that f ree exit is contained in f ree, so again, the program is selection-pushing. Then again by Theorem 4.1, P mg factors with respect to the query Q = p (A; b)?. 2 6.2 Separable Programs Separable programs, defined in <ref> [Nau88a] </ref>, were defined to be class of recursions for which selection queries have efficient evaluation algorithms. Essentially, [Nau88a] gave conditions that determine if a given recursion is separable and a schema for evaluating selection queries over separable recursions. <p> Then again by Theorem 4.1, P mg factors with respect to the query Q = p (A; b)?. 2 6.2 Separable Programs Separable programs, defined in <ref> [Nau88a] </ref>, were defined to be class of recursions for which selection queries have efficient evaluation algorithms. Essentially, [Nau88a] gave conditions that determine if a given recursion is separable and a schema for evaluating selection queries over separable recursions. Given a specific selection query on a recursion that is separable, the schema can automatically be instantiated to produce an evaluation algorithm for the query.
Reference: [Nau88b] <author> Jeffrey F. Naughton. </author> <title> Compiling separable recursions. </title> <type> Technical Report CS-TR-140-88, </type> <institution> Princeton University, </institution> <year> 1988. </year> <month> 41 </month>
Reference-contexts: If A is nonempty, then any full selection on such a rule must bind both X and Y , since both are in t h for that rule. On such a selection, the separable recursion evaluation algorithm does not reduce the arity of the recursion (see <ref> [Nau88b] </ref> for details.) A more interesting class of recursions are those in which A is empty. A formal definition of this class follows; first we need one auxiliary definition. Definition 6.5 Let r be a linear recursive rule and let t be the recursive predicate in r.
Reference: [NRSU89] <author> Jeffrey F. Naughton, Raghu Ramakrishnan, Yehoshua Sagiv, and Jeffrey D. Ullman. </author> <title> Efficient evaluation of right-, left-, and multi-linear rules. </title> <booktitle> In Proceedings of the ACM SIGMOD International Conference on Management of Data, </booktitle> <pages> pages 235-242, </pages> <address> Portland, Oregon, </address> <month> May </month> <year> 1989. </year>
Reference-contexts: While we prove that in general detecting factorable recursions is undecidable, we describe classes of recursions for which the Magic Sets transformation always produces a factorable recursion. The separable recursions [Nau88a] and the left- and right-linear recursions <ref> [NRSU89] </ref> have also been identified as significant classes of recursion for which there are arity reducing evaluation algorithms. In this work we show that these classes of recursions are proper subsets of the class of recursions for which Magic Sets produces a factorable recursion. <p> In this work we show that these classes of recursions are proper subsets of the class of recursions for which Magic Sets produces a factorable recursion. Furthermore, the special purpose evaluation algorithms of [Nau88a] and the special purpose rewriting techniques of <ref> [NRSU89] </ref> can be derived automatically by simple optimizations applied to the factored Magic program. We introduce the notion of factoring in Section 2, and show that in general it is undecidable. We describe classes of programs for which the corresponding "Magic" programs are factorable in Section 3. <p> A left-linear occurrence of p ff is a body literal p ff (X; U ), and a right-linear occurrence of p ff is a body literal p ff (V ; Y ). The following definitions generalize those in <ref> [NRSU89] </ref>. In the following, by disjoint conjunctive queries we mean conjunctive queries that do not share any variables. <p> Let P be a program, Q a query, and P ad the adorned program corresponding to a left-to-right evaluation of the rules of P . P mg represents the program obtained by applying the Magic Sets transformation to P and Q. Example 4.2 The rewriting algorithms presented in <ref> [NRSU89] </ref> were the first to derive automatically unary programs for single-selection queries for all three forms (left-linear, right-linear, non-linear) of the transitive closure. We achieve the same result here by first applying the Magic Sets transformation and then factoring the rewritten program. <p> Our first theorem essentially generalizes the results in <ref> [NRSU89] </ref>, although it must be used together with the additional optimizations described in Section 4 in order to do so. It uses the following definition. Definition 4.6 Let P; Q be an RLC-stable program with IDB predicate p. <p> bf (Y; W ); d (W; U ); s bf (U; Z): s bf (Y; Z) :- exit (5; Y; Z): query (U ) :- s bf (6; U )? The theorems in Section 3 are applicable to the reduced program. 2 A special class of rules was defined in <ref> [NRSU89] </ref>. 26 Definition 5.3 A pseudo-left-linear rule is a rule that satisfies all the criteria for a left-linear rule, except that the conjunctions lef t and last may share a variable. <p> Essentially, for a full selection on a separable recursion, the instantiated separable recursion evaluation schema represents the same computation as the semi-naive bottom-up evaluation of the output of the factoring rewrite applied to the Magic program. 6.3 Left- and Right-Linear Programs In <ref> [NRSU89] </ref>, recursions containing right-linear, left-linear, mixed-linear, and combined-linear recursions were identified and special rewriting algorithms in the spirit of the Magic Sets transformation were given. A simple check shows that the classes of programs defined in [NRSU89] are a proper subset of the programs satisfying the conditions of Theorem 3.1, and <p> the factoring rewrite applied to the Magic program. 6.3 Left- and Right-Linear Programs In <ref> [NRSU89] </ref>, recursions containing right-linear, left-linear, mixed-linear, and combined-linear recursions were identified and special rewriting algorithms in the spirit of the Magic Sets transformation were given. A simple check shows that the classes of programs defined in [NRSU89] are a proper subset of the programs satisfying the conditions of Theorem 3.1, and that Theorem 3.2 handles some additional programs.
Reference: [Ram88] <author> Raghu Ramakrishnan. </author> <title> Magic templates: A spellbinding approach to logic programs. </title> <booktitle> In Proceedings of the International Conference on Logic Programming, </booktitle> <pages> pages 140-159, </pages> <address> Seattle, Washington, </address> <month> August </month> <year> 1988. </year>
Reference-contexts: The rules in the program are then modified by attaching additional literals that act as filters and prevent the rule from generating irrelevant tuples. We assume familiarity with the Magic Sets algorithm, which we illustrate in Example 4.2. The reader is referred to <ref> [BMSU86, BR87, Ram88] </ref> for details. 3 The Factoring Property Consider a program P, a query Q, and a predicate p that appears in P. <p> Note that applying this transformation results in a program that does not contain p, which is replaced by two predicates, p 1 and p 2 , of strictly lower arity. 4 Classes of Factorable Programs The Magic Sets transformation <ref> [BMSU86, BR87, Ram88] </ref> rewrites a program with the objective of restricting the computation by propagating bindings in the query. <p> Y; Z) :- t (X; U; W ); b (U; Y ); d (Z): query (X; Y ) :- t (X; Y; 5): This illustrates an interesting point: If we wish to treat the last argument of the body literal t as a bound argument, we must allow non-ground tuples <ref> [Ram88] </ref>. We can then factor the program. 2 7.2 Relationship to Other Optimizations We showed that for the classes of factorable Magic programs identified in this paper, the indices in Counting were unnecessary.
Reference: [RBK88] <author> Raghu Ramakrishnan, Catriel Beeri, and Ravi Krishnamurthy. </author> <title> Optimizing existential datalog queries. </title> <booktitle> In Proceedings of the ACM Symposium on Principles of Database Systems, </booktitle> <pages> pages 89-102, </pages> <address> Austin, Texas, </address> <month> March </month> <year> 1988. </year>
Reference-contexts: This is a special case of deletion under uniform equivalence [Sag88]. Proposition 5.5 We may introduce an "anonymous" variable in an argument position if the variable in it appears nowhere else in the rule. As shown in <ref> [RBK88] </ref>, the preceding proposition can be strengthened to prove that an anonymous variable can be introduced in any existential argument position. 2 Example 5.3 Consider again the factored version of P mg from the three-rule transitive closure (Figure 2.) We can delete the first and the third rules defining bt and
Reference: [Sag88] <author> Yehoshua Sagiv. </author> <title> Optimizing datalog programs. </title> <editor> In Jack Minker, editor, </editor> <booktitle> Foundations of Deductive Databases and Logic Programming, </booktitle> <pages> pages 659-698, </pages> <address> Los Altos, California, 94022, 1988. </address> <publisher> Morgan Kaufmann. </publisher>
Reference-contexts: Some additional simple observations that are useful are mentioned below. Proposition 5.4 We may delete a rule if the head literal also appears in the body, or if the head predicate is not reachable from the query predicate. This is a special case of deletion under uniform equivalence <ref> [Sag88] </ref>. Proposition 5.5 We may introduce an "anonymous" variable in an argument position if the variable in it appears nowhere else in the rule.
Reference: [Shm87] <author> Oded Shmueli. </author> <title> Decidability and expressiveness aspects of logic queries. </title> <booktitle> In Proceedings of the ACM Symposium on Principles of Database Systems, </booktitle> <pages> pages 237-249, </pages> <address> San Diego, California, </address> <month> March </month> <year> 1987. </year>
Reference-contexts: Since q 1 and q 2 can be arbitrary Datalog queries, and containment for binary Datalog queries is undecidable <ref> [Shm87] </ref>, detecting factorable programs is also undecidable. 2 The proof of Theorem 3.1 is by reduction from the containment problem for Datalog queries, and assumes multiple IDB predicates. To our knowledge, the decidability of factoring for single IDB predicate programs is open.
Reference: [SZ86] <author> Domenico Sacca and Carlo Zaniolo. </author> <title> The generalized counting methods for recursive logic queries. </title> <booktitle> In Proceedings of the First International Conference on Database Theory, </booktitle> <year> 1986. </year>
Reference-contexts: In addition, for the programs considered in that paper, the Magic Sets plus factoring transformation produces the same final program as the rewriting algorithms from that paper. 32 6.4 The Counting Transformation The Counting transformation <ref> [BMSU86, BR87, SZ86] </ref> can be understood as a variant of the Magic Sets transformation. First, every derived predicate is augmented with some index fields, which, intuitively, encode the derivation of the fact.
Reference: [vEK76] <author> M. H. van Emden and R. A. Kowalski. </author> <title> The semantics of predicate logic as a programming language. </title> <journal> Journal of the ACM, </journal> <volume> 23(4) </volume> <pages> 733-742, </pages> <month> October </month> <year> 1976. </year> <month> 42 </month>
Reference-contexts: This standard form is described further in Section 4. 3 operator, say T P . It is well known that the least Herbrand model of a Horn clause logic program P is equal to the least fixpoint of the T P operator that contains the EDB facts <ref> [vEK76] </ref>.
References-found: 15

