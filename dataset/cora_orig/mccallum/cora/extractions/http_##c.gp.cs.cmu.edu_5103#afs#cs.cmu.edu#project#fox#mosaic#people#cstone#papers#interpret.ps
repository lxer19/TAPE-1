URL: http://c.gp.cs.cmu.edu:5103/afs/cs.cmu.edu/project/fox/mosaic/people/cstone/papers/interpret.ps
Refering-URL: http://c.gp.cs.cmu.edu:5103/afs/cs.cmu.edu/project/fox/mosaic/people/cstone/home.html
Root-URL: http://www.cs.cmu.edu
Email: frwh,cstoneg@cs.cmu.edu  
Title: A Type-Theoretic Interpretation of Standard ML  
Author: Robert Harper and Christopher Stone 
Address: 5000 Forbes Avenue Pittsburgh, PA 15213-3891  
Affiliation: School of Computer Science Carnegie Mellon University  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> Andrew W. Appel. </author> <title> Compiling with Continuations. </title> <publisher> Cambridge University Press, </publisher> <year> 1992. </year>
Reference-contexts: Named form and component renaming ensures that the exact behavior of all (first-order) functors is always expressible in the internal-language signature of the translated functor. Note that the simple renaming mechanism we have outlined here is not "safe for space complexity" <ref> [1] </ref>. In particular, the elaboration given here retains not only the hidden type components that are required for subsequent specifications, but also type components that are not so required, and value components, which are never required.
Reference: [2] <author> Luca Cardelli. </author> <title> Typeful programming. </title> <editor> In E. J. Neuhold and M. Paul, editors, </editor> <booktitle> Formal Description of Programming Concepts. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1991. </year> <note> An earlier version appeared as DEC Systems Research Center Research Report #45, </note> <month> February </month> <year> 1989. </year>
Reference-contexts: Evaluation is defined on "type-erased" expressions; types have no significance during evaluation. Consequently, no management of stamps is required in the dynamic semantics. However, recent work has emphasized typed dynamic semantics in which, for example, polymorphic values take type parameters and primitive operations may analyze types at run-time <ref> [26, 2] </ref>. The typed framework has several advantages. One is that it is strictly more general than the untyped framework since fl This research was sponsored in part by the Advanced Research Projects Agency CSTO under the title "The Fox Project: Advanced Languages for Systems Software", ARPA Order No. <p> This is used to express the propagation of type sharing properties from the argument to the result, without relying on exposure of the implementation of the functor. The sub-signature relation is extended to functor signatures in the usual way, contravariantly in the domain and covariantly in the codomain <ref> [2] </ref>. Only non-dependent functors may be applied to arguments; the dependency must first be eliminated through the use of the sub-signature and signature equivalence relations.
Reference: [3] <author> Luca Cardelli. </author> <title> Type systems. </title> <editor> In Allen B. Tucker Jr., editor, </editor> <booktitle> Handbook of Computer Science and Engineering, </booktitle> <pages> pages 2208-2236. </pages> <publisher> CRC Press, </publisher> <year> 1997. </year>
Reference-contexts: DAAH04-94-G-0289. The views and conclusions contained in this document are those of the authors and should not be interpreted as representing official policies, either expressed or implied, of the Advanced Research Projects Agency, the U.S. Government or the National Science Foundation. 1 See Cardelli's overview of type systems <ref> [3] </ref> for a survey and references to the literature. 1 it is always possible to ignore type information on explicitly-typed terms, whereas we have no choice in the matter if we start with "type-erased" terms.
Reference: [4] <author> Jean-Yves Girard. </author> <title> Une extension de l'interpretation de Godel a l'analyse, et son application a l'elimination des coupures dans l'analyse et la theorie des types. </title> <editor> In Jens Erik Fenstad, editor, </editor> <booktitle> Second Scandinavian Logic Symposium, volume 63 of Studies in Logic and the Foundations of Mathematics, </booktitle> <pages> pages 63-92. </pages> <publisher> North-Holland, </publisher> <year> 1971. </year>
Reference-contexts: However, we do not treat type abstraction and application as a primitive notion (as in the polymorphic -calculus <ref> [4, 23] </ref>). Instead, we represent a polymorphic value as an internal-language functor abstracted on a structure whose components are types, yielding a structure with a single component labeled "it" for the value itself.
Reference: [5] <author> Michael J. Gordon, Robin Milner, and Christo-pher P. Wadsworth. </author> <title> Edinburgh LCF: a mecha-nised logic of computation, </title> <booktitle> volume 78 of LNCS. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1979. </year>
Reference-contexts: 1 Introduction It has been nearly twenty years since Robin Milner introduced ML as the metalanguage of the LCF interactive theorem prover <ref> [5] </ref>. The design of ML has proved to be a decisive step in the development of programming languages.
Reference: [6] <editor> Carl A. Gunter, Elsa L. Gunter, and David B. MacQueen. </editor> <title> An abstract interpretation for ML equality kinds. </title> <booktitle> Lecture Notes in Computer Science, </booktitle> <volume> 526 </volume> <pages> 112-130, </pages> <year> 1991. </year>
Reference-contexts: Our approach is related to the compilation of overloading in Haskell [28] and to the treatment of equality proposed by Gunter, Gunter and MacQueen <ref> [6] </ref>. The judgment ` eq con ; exp v expresses that ` exp v : conficon*Bool is the equality function for type con.
Reference: [7] <author> Robert Harper. </author> <title> A simplified account of polymorphic references. </title> <type> Technical Report CMU-CS-93-169, </type> <institution> School of Computer Science, Carnegie Mellon University, </institution> <year> 1993. </year> <title> 9 Note, however, that principal signatures are not necessary for formulating the translation since we do not rely on "generic structures" for a given signature to define the interpretation. </title> <type> 19 </type>
Reference-contexts: If decs ` E [mod ] : con and mod is closed, then decs ` mod : sig for some signature sig. Furthermore, if decs ` mod 0 : sig where mod 0 is closed, then decs ` E [mod 0 ] : con. Following Harper <ref> [7] </ref> and Wright and Felleisen [30], we say that a store is well-formed with respect to a context , written ` , if 8loc 2 BV (); if ` loc : con Ref then ` (x) : con: This formulation of store typing avoids the need for complex maximal fixed point
Reference: [8] <author> Robert Harper and Mark Lillibridge. </author> <title> A type--theoretic approach to higher-order modules with sharing. </title> <booktitle> In 21st ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 123-137, </pages> <year> 1994. </year>
Reference-contexts: The internal language is derived from the XML language of Harper and Mitchell [9], but with a richer collection of primitive types and a more expressive module system based on the translucent sum <ref> [8] </ref>, or manifest type [12], formalism. The internal language is given a type-passing dynamic semantics in the form of a transition system between states of an abstract machine. <p> The two levels are linked by the ability to declare a module within a core-level expression. The internal language is based loosely on Harper and Mitchell's XML language [9], but with a treatment of modules derived from Harper and Lillibridge's <ref> [8, 14] </ref> translucent sum formalism and Leroy's manifest type system [12]. This section consists of a brief overview of the internal language. The language is defined by a set of inference rules for deriving the judgment forms given in Figure 1. <p> This is exploited heavily in the interpretation of Standard ML given in Section 3. 2.3 Modules and Signatures The module language is based on the translucent sum (or manifest type) formalism <ref> [8, 12] </ref>. The syntax for modules and signatures is given in Figure 4. The basic form of module is a structure, which consists of a sequence of constructor, expression, and module bindings. Structure signatures consist of a corresponding sequence of constructor, expression, and module declarations.
Reference: [9] <author> Robert Harper and John C. Mitchell. </author> <title> On the type structure of Standard ML. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 15(2) </volume> <pages> 211-252, </pages> <year> 1993. </year>
Reference-contexts: The external language is the 1996 revision of Standard ML, as described in the revised Definition [17]. The internal language is derived from the XML language of Harper and Mitchell <ref> [9] </ref>, but with a richer collection of primitive types and a more expressive module system based on the translucent sum [8], or manifest type [12], formalism. The internal language is given a type-passing dynamic semantics in the form of a transition system between states of an abstract machine. <p> The two levels are linked by the ability to declare a module within a core-level expression. The internal language is based loosely on Harper and Mitchell's XML language <ref> [9] </ref>, but with a treatment of modules derived from Harper and Lillibridge's [8, 14] translucent sum formalism and Leroy's manifest type system [12]. This section consists of a brief overview of the internal language. <p> To account for shadowing, declaration sequencing goes beyond simple concatenation of bindings by renaming fields corresponding to shadowed identifiers. 3.3 Polymorphism Polymorphism is interpreted by explicit type abstraction and type application <ref> [9] </ref>. However, we do not treat type abstraction and application as a primitive notion (as in the polymorphic -calculus [4, 23]).
Reference: [10] <author> Robert Harper and Christopher Stone. </author> <title> An interpretation of Standard ML in type theory. </title> <type> Technical Report CMU-CS-97-147, </type> <institution> School of Computer Science, Carnegie Mellon University, </institution> <year> 1997. </year>
Reference-contexts: The language is defined by a set of inference rules for deriving the judgment forms given in Figure 1. A selection of the rules is given in Appendix B; the remainder can be found in a companion technical report <ref> [10] </ref>. For further background and motivation the reader is urged to consult the references cited above. 2.1 Constructors and Kinds The syntax of constructors and kinds is given in Figure 2. Kinds classify constructors. Constructors of kind are called types. <p> A fully detailed account of the interpretation appears in a companion technical report <ref> [10] </ref>. The complete interpretation consists of approximately 270 inference rules, of which approximately 140 form the typing rules and dynamic semantics of the internal language (120 rules and 20 rules, respectively), with the remaining 130 rules being part of the interpretation itself.
Reference: [11] <author> Xavier Leroy. </author> <title> Polymorphism by name for references and continuations. </title> <booktitle> In 20th ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 220-231, </pages> <year> 1993. </year>
Reference-contexts: Valuability of core- and module-level expressions is expressed by a judgment form expressing that the given expression may be evaluated without engendering any computational effect. For decidability reasons, the rules define a conservative approximation of valua-bility. The approximation is strong enough to express the "value restriction" on polymorphism <ref> [29, 11] </ref> in Standard ML, as discussed in Section 3. In particular, all canonical forms are valuable, as are all variables (the dynamic semantics is call-by-value), and any application of a total function to a valuable argument.
Reference: [12] <author> Xavier Leroy. </author> <title> Manifest types, modules, and separate compilation. </title> <booktitle> In 21st ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 109-122, </pages> <year> 1994. </year>
Reference-contexts: The internal language is derived from the XML language of Harper and Mitchell [9], but with a richer collection of primitive types and a more expressive module system based on the translucent sum [8], or manifest type <ref> [12] </ref>, formalism. The internal language is given a type-passing dynamic semantics in the form of a transition system between states of an abstract machine. <p> The internal language is based loosely on Harper and Mitchell's XML language [9], but with a treatment of modules derived from Harper and Lillibridge's [8, 14] translucent sum formalism and Leroy's manifest type system <ref> [12] </ref>. This section consists of a brief overview of the internal language. The language is defined by a set of inference rules for deriving the judgment forms given in Figure 1. <p> This is exploited heavily in the interpretation of Standard ML given in Section 3. 2.3 Modules and Signatures The module language is based on the translucent sum (or manifest type) formalism <ref> [8, 12] </ref>. The syntax for modules and signatures is given in Figure 4. The basic form of module is a structure, which consists of a sequence of constructor, expression, and module bindings. Structure signatures consist of a corresponding sequence of constructor, expression, and module declarations.
Reference: [13] <author> Xavier Leroy. </author> <title> A syntactic theory of type gener-ativity and sharing. </title> <journal> Journal of Functional Programming, </journal> <volume> 6(5) </volume> <pages> 667-698, </pages> <year> 1996. </year>
Reference-contexts: Since we are working with an explicitly-typed internal language, polymorphic instantiation in signature matching is also managed by explicit coercion. 6. Sharing expansion. Uses of type sharing specifications are expanded into uses of type definitions in signatures <ref> [13] </ref>. The where type construct of Standard ML is translated by explicitly "patching" internal-language signatures. 7. Generativity and persistence. In Standard ML type identifiers may persist beyond their apparent scope of definition. <p> Datatype generativity interacts with functor instantiation in such a way that each application of a functor that declares a datatype introduces a "new copy" of that datatype, distinct from all other instances introduced by the same functor (and all types otherwise introduced). Following Leroy <ref> [13] </ref> we capture this behavior by imposing the requirement that module expressions be restricted to "named form". This means that every non-trivial module expression must be bound to a module identifier before it can be used. <p> This restriction is reflected in the grammar by, e.g., the requirement that functor arguments be structure identifiers, rather than arbitrary structure expressions. There is no loss of generality in assuming that programs are written in named form; we can make a prepass introduces bindings for non-trivial module expression <ref> [13] </ref>. The practical effect of the restriction to named form is that the result of every functor application is bound to module variable, which thereafter serves as the "unique name" of that instance of the functor application. Consequently, opaque types (including datatypes) selected from that instance are unique.
Reference: [14] <author> Mark Lillibridge. </author> <title> Translucent Sums: A Foundation for Higher-Order Module Systems. </title> <type> PhD thesis, </type> <institution> School of Computer Science, Carnegie Mel-lon University, </institution> <year> 1997. </year>
Reference-contexts: The two levels are linked by the ability to declare a module within a core-level expression. The internal language is based loosely on Harper and Mitchell's XML language [9], but with a treatment of modules derived from Harper and Lillibridge's <ref> [8, 14] </ref> translucent sum formalism and Leroy's manifest type system [12]. This section consists of a brief overview of the internal language. The language is defined by a set of inference rules for deriving the judgment forms given in Figure 1.
Reference: [15] <author> David MacQueen. </author> <title> Using dependent types to express modular structure. </title> <booktitle> In 13th ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 277-286, </pages> <year> 1986. </year>
Reference-contexts: Translucent sums may be seen as a generalized form of existential type [18] that affords fine-grained control over the "degree" of abstractness of a type. They may also be seen as a variant of the "dependent sum" type <ref> [15] </ref>, adopting the flexible "projection" notation for component selection, but avoiding implementation dependencies. 5 mod ::= var module variable sig ::= [sdecs ] structure signature j [sbnds ] structure j (var :sig)*sig 0 partial functor signature j var:sig:mod functor j (var :sig)!sig 0 total functor signature j mod mod 0 functor
Reference: [16] <author> Robin Milner. </author> <title> A proposal for Standard ML. </title> <booktitle> In 1984 ACM Symposium on LISP and Functional Programming, </booktitle> <pages> pages 184-197, </pages> <year> 1984. </year>
Reference-contexts: Type theory has also begun to be exploited as an implementation tool [26, 25]. By exploiting type information at compile-, link-, and run-time an implementation may use more efficient data representations than was previously possible. Milner's work on ML culminated with his ambitious proposal for Standard ML <ref> [16] </ref> which sought to extend ML to a full-scale programming language supporting functional and imperative programming and an expressive module system. Standard ML presented a serious challenge to rigorous formalization of its static and dynamic semantics.
Reference: [17] <author> Robin Milner, Mads Tofte, Robert Harper, and Dave MacQueen. </author> <title> The Definition of Standard ML (Revised). </title> <publisher> MIT Press, </publisher> <year> 1997. </year>
Reference-contexts: The target of the translation we call the internal language, or IL; the source language is then called the external language. The external language is the 1996 revision of Standard ML, as described in the revised Definition <ref> [17] </ref>. The internal language is derived from the XML language of Harper and Mitchell [9], but with a richer collection of primitive types and a more expressive module system based on the translucent sum [8], or manifest type [12], formalism.
Reference: [18] <author> John C. Mitchell and Gordon Plotkin. </author> <title> Abstract types have existential type. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 10(3) </volume> <pages> 470-502, </pages> <year> 1988. </year>
Reference-contexts: Propagation of type sharing information is managed by the selective exposure of type information in a signature through the use of transparent and opaque type specifications. Translucent sums may be seen as a generalized form of existential type <ref> [18] </ref> that affords fine-grained control over the "degree" of abstractness of a type.
Reference: [19] <author> Eugenio Moggi. </author> <title> Notions of computation and monads. </title> <journal> Information and Computation, </journal> <volume> 93(1) </volume> <pages> 55-92, </pages> <month> July </month> <year> 1991. </year>
Reference-contexts: 1 7!con 1 ; : : :) (labelled) sum type j mod v :lab module projection j var :knd :con constructor function j con constructor fixed-point j con con 0 constructor application j flab 1 =con 1 ; : : : g constructor records We borrow from the computational -calculus <ref> [19] </ref> an abstract notion of "definedness", called valuability, and the closely-associated notion of "totality" for functions. Valuability of core- and module-level expressions is expressed by a judgment form expressing that the given expression may be evaluated without engendering any computational effect.
Reference: [20] <author> Chris Okasaki. </author> <title> Purely Functional Data Structures. </title> <type> PhD thesis, </type> <institution> School of Computer Science, Carnegie Mellon University, </institution> <year> 1996. </year>
Reference-contexts: More efficient algorithms based on decision tree heuristics are routinely used in Standard ML compilers. We present a "reference" implementation of pattern compilation so as to avoid undue commitments to specific strategies, to admit generalizations of pattern matching that may engender effects (such as forcing memoized suspensions <ref> [20] </ref>), and for the sake of perspicuity of the translation. There is a subtle, but important, interaction between pattern compilation and the value restriction on polymorphism.
Reference: [21] <author> Andrew M. Pitts and Ian D. B. Stark. </author> <title> Observable properties of higher order functions that dynamically create local names, or: </title> <booktitle> What's new? In Mathematical Foundations of Computer Science, 18th International Symposium, volume 711 of LNCS, </booktitle> <pages> pages 122-141. </pages> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1993. </year>
Reference-contexts: Total functions include primitives such as record field selection and those partial functions whose bodies are deemed valuable. The internal language type Tagged is a type of dynamically-tagged values, corresponding to the external language type exn. The dynamically-generated tags are similar to the "names" considered by Pitts and Stark <ref> [21] </ref>, except that we associate a type with each name to ensure type safety. Tags of values of type con are themselves values of type con Tag, indicating the type of the tagged value. 2.2 Expressions The syntax of internal language expressions is given in Figure 3.
Reference: [22] <author> Gordon D. Plotkin. </author> <title> A structural approach to operational semantics. </title> <type> Technical Report DAIMI FN-19, </type> <institution> Aarhus University, </institution> <month> September </month> <year> 1981. </year>
Reference-contexts: v ; lab.var=E; sbnds] j get E j E mod j set (exp v ; E) j E:lab j roll con j unroll E j inj con j proj con i E j case con E of exp 1 ; : : : ; exp n end work of Plotkin <ref> [22] </ref> and Wright and Felleisen [30], but is departure from the framework of The Definition of Standard ML. The state-machine presentation avoids the need for implicit evaluation rules for handling exceptions, and supports a natural interpretation of type soundness that does not rely on artificial "wrong" transitions.
Reference: [23] <author> John C. Reynolds. </author> <title> Towards a theory of type structure. </title> <editor> In B. Robinet, editor, </editor> <booktitle> Programming Symposium, Proceedings, Colloque sur la Pro-grammation, volume 19 of LNCS, </booktitle> <pages> pages 408-425, </pages> <year> 1974. </year>
Reference-contexts: However, we do not treat type abstraction and application as a primitive notion (as in the polymorphic -calculus <ref> [4, 23] </ref>). Instead, we represent a polymorphic value as an internal-language functor abstracted on a structure whose components are types, yielding a structure with a single component labeled "it" for the value itself.
Reference: [24] <author> Dana S. Scott. </author> <title> Data types as lattices. </title> <journal> SIAM Journal on Computing, </journal> <volume> 5 </volume> <pages> 522-587, </pages> <month> September </month> <year> 1976. </year>
Reference-contexts: The interpretation described below has application both to semantics and to implementation. From the point of view of semantics, the internal language plays a role analogous to Scott's LAMBDA language for denotational semantics <ref> [24] </ref>. The meaning of a Standard ML program is obtained by translating the program into the internal language, which is given meaning by some other means.
Reference: [25] <author> Zhong Shao and Andrew W. Appel. </author> <title> A type-based compiler for Standard ML. </title> <booktitle> In ACM SIG-PLAN '95 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 116-129, </pages> <year> 1995. </year>
Reference-contexts: Type theory has also begun to be exploited as an implementation tool <ref> [26, 25] </ref>. By exploiting type information at compile-, link-, and run-time an implementation may use more efficient data representations than was previously possible. <p> The interpretation given here also has application to implementation. The TIL/ML compiler [26], and recent versions of the SML/NJ compiler <ref> [25] </ref>, both take as their starting point a type-theoretic interpretation of Standard ML of the kind considered here. The TIL/ML compiler for Standard ML is based on the interpretation described here. The elaboration phase of the compiler is a direct "determinization" of the rules given below.
Reference: [26] <author> David Tarditi, Greg Morrisett, Perry Cheng, Chris Stone, Robert Harper, and Peter Lee. </author> <title> TIL: A type-directed optimizing compiler for ML. </title> <booktitle> In ACM SIGPLAN '96 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 181-192, </pages> <year> 1996. </year>
Reference-contexts: Type theory has also begun to be exploited as an implementation tool <ref> [26, 25] </ref>. By exploiting type information at compile-, link-, and run-time an implementation may use more efficient data representations than was previously possible. <p> Evaluation is defined on "type-erased" expressions; types have no significance during evaluation. Consequently, no management of stamps is required in the dynamic semantics. However, recent work has emphasized typed dynamic semantics in which, for example, polymorphic values take type parameters and primitive operations may analyze types at run-time <ref> [26, 2] </ref>. The typed framework has several advantages. One is that it is strictly more general than the untyped framework since fl This research was sponsored in part by the Advanced Research Projects Agency CSTO under the title "The Fox Project: Advanced Languages for Systems Software", ARPA Order No. <p> Although we know of no complete domain-theoretic account of Standard ML, we conjecture that one could give such an interpretation by providing an adequate denotational semantics for the internal language. The interpretation given here also has application to implementation. The TIL/ML compiler <ref> [26] </ref>, and recent versions of the SML/NJ compiler [25], both take as their starting point a type-theoretic interpretation of Standard ML of the kind considered here. The TIL/ML compiler for Standard ML is based on the interpretation described here. <p> The TIL/ML compiler for Standard ML is based on the interpretation described here. The elaboration phase of the compiler is a direct "determinization" of the rules given below. Preliminary results <ref> [26] </ref> indicate that type-based translation is an effective method for reducing both the time and space requirements of Standard ML as compared to the type-free approach taken in the SML/NJ compiler.
Reference: [27] <author> Mads Tofte. </author> <title> Type inference for polymorphic references. </title> <journal> Information and Computation, </journal> <volume> 89(1) </volume> <pages> 1-34, </pages> <month> November </month> <year> 1990. </year>
Reference-contexts: Wright and Felleisen [30], we say that a store is well-formed with respect to a context , written ` , if 8loc 2 BV (); if ` loc : con Ref then ` (x) : con: This formulation of store typing avoids the need for complex maximal fixed point constructions <ref> [27] </ref>.
Reference: [28] <author> Philip Wadler and Stephen Blott. </author> <title> How to make ad-hoc polymorphism less ad-hoc. </title> <booktitle> In 16th ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 60-76, </pages> <year> 1989. </year>
Reference-contexts: There is no need for separate "equality attributes" in our IL; a type admits equality if and only if the equality compiler is able to generate an equality operation for it. Our approach is related to the compilation of overloading in Haskell <ref> [28] </ref> and to the treatment of equality proposed by Gunter, Gunter and MacQueen [6]. The judgment ` eq con ; exp v expresses that ` exp v : conficon*Bool is the equality function for type con.
Reference: [29] <author> Andrew Wright. </author> <title> Simple imperative polymor-phism. </title> <journal> Journal of Lisp and Symbolic Computation, </journal> <volume> 8(4) </volume> <pages> 343-355, </pages> <month> December </month> <year> 1995. </year>
Reference-contexts: Valuability of core- and module-level expressions is expressed by a judgment form expressing that the given expression may be evaluated without engendering any computational effect. For decidability reasons, the rules define a conservative approximation of valua-bility. The approximation is strong enough to express the "value restriction" on polymorphism <ref> [29, 11] </ref> in Standard ML, as discussed in Section 3. In particular, all canonical forms are valuable, as are all variables (the dynamic semantics is call-by-value), and any application of a total function to a valuable argument.
Reference: [30] <author> Andrew Wright and Matthias Felleisen. </author> <title> A syntactic approach to type soundness. </title> <type> Technical Report TR91-160, </type> <institution> Dept. of Computer Science, Rice University, </institution> <year> 1991. </year> <month> 20 </month>
Reference-contexts: get E j E mod j set (exp v ; E) j E:lab j roll con j unroll E j inj con j proj con i E j case con E of exp 1 ; : : : ; exp n end work of Plotkin [22] and Wright and Felleisen <ref> [30] </ref>, but is departure from the framework of The Definition of Standard ML. The state-machine presentation avoids the need for implicit evaluation rules for handling exceptions, and supports a natural interpretation of type soundness that does not rely on artificial "wrong" transitions. <p> Furthermore, if decs ` mod 0 : sig where mod 0 is closed, then decs ` E [mod 0 ] : con. Following Harper [7] and Wright and Felleisen <ref> [30] </ref>, we say that a store is well-formed with respect to a context , written ` , if 8loc 2 BV (); if ` loc : con Ref then ` (x) : con: This formulation of store typing avoids the need for complex maximal fixed point constructions [27].
References-found: 30

