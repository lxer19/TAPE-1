URL: ftp://ftp.cs.umass.edu/pub/osl/papers/sigplan92.ps.Z
Refering-URL: http://spa-www.cs.umass.edu/bibliography.html
Root-URL: 
Title: Compiler Support for Garbage Collection in a Statically Typed Language  
Author: Amer Diwan Eliot Moss Richard Hudson 
Note: (To appear in SIGPLAN '92 PLDI)  
Address: Amherst, MA 01003  
Affiliation: Object Systems Laboratory Department of Computer Science University of Massachusetts  
Abstract: We consider the problem of supporting compacting garbage collection in the presence of modern compiler optimizations. Since our collector may move any heap object, it must accurately locate, follow, and update all pointers and values derived from pointers. To assist the collector, we extend the compiler to emit tables describing live pointers, and values derived from pointers, at each program location where collection may occur. Significant results include identification of a number of problems posed by optimizations, solutions to those problems, a working compiler, and experimental data concerning table sizes, table compression, and time overhead of decoding tables during collection. While gc support can affect the code produced, our sample programs show no significant changes, the table sizes are a modest fraction of the size of the optimized code, and stack tracing is a small fraction of total gc time. Since the compiler enhancements are also modest, we conclude that the approach is practical. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> M. Atkinson, K. Chisolm, and P. Cockshott, </author> <title> PS-Algol: an Algol with a persistent heap, </title> <journal> ACM SIGPLAN Not., </journal> <volume> vol. 17, </volume> <pages> pp. 24-31, </pages> <month> July </month> <year> 1982. </year>
Reference-contexts: 1 Introduction As part of ongoing efforts to implement orthogonal persistence <ref> [1] </ref> and garbage collection for Modula-3 [2], we have designed and implemented compiler techniques to assist the garbage collector and the persistent memory manager.
Reference: [2] <editor> G. Nelson, ed., </editor> <booktitle> Systems Programming in Modula-3. </booktitle> <address> New Jersey: </address> <publisher> Prentice Hall, </publisher> <year> 1991. </year>
Reference-contexts: 1 Introduction As part of ongoing efforts to implement orthogonal persistence [1] and garbage collection for Modula-3 <ref> [2] </ref>, we have designed and implemented compiler techniques to assist the garbage collector and the persistent memory manager.
Reference: [3] <author> J. E. B. Moss, </author> <title> Implementing persistence for an object oriented language, </title> <type> COINS Technical Report 87-69, </type> <institution> University of Massachusetts, </institution> <address> Amherst, MA 01003, </address> <month> Sept. </month> <year> 1987. </year>
Reference-contexts: With regards to persistence, our scheme must allow objects to be moved, and possibly removed from main memory altogether, for buffer management <ref> [3, 4] </ref> purposes. Moreover, since orthogonality allows any object to become persistent, all objects need to be movable. This requirement is also essential for fully compacting garbage collection (cf. [5, 6]), which yields good locality and fast object allocation time.
Reference: [4] <author> A. L. Hosking, </author> <title> Main memory management for persistence, </title> <address> Oct. </address> <year> 1991. </year> <title> Position paper presented at the OOPSLA '91 Workshop on Garbage Collection. </title>
Reference-contexts: With regards to persistence, our scheme must allow objects to be moved, and possibly removed from main memory altogether, for buffer management <ref> [3, 4] </ref> purposes. Moreover, since orthogonality allows any object to become persistent, all objects need to be movable. This requirement is also essential for fully compacting garbage collection (cf. [5, 6]), which yields good locality and fast object allocation time.
Reference: [5] <author> J. F. Bartlett, </author> <title> Compacting garbage collection with ambiguous roots, </title> <type> Research Report 88/2, </type> <institution> Western Research Laboratory, Digital Equipment Corporation, </institution> <month> Feb. </month> <year> 1988. </year>
Reference-contexts: Moreover, since orthogonality allows any object to become persistent, all objects need to be movable. This requirement is also essential for fully compacting garbage collection (cf. <ref> [5, 6] </ref>), which yields good locality and fast object allocation time. Portability to a wide variety of hardware and software platforms is one of the key goals for Persistent Modula-3. Therefore our scheme must not rely on any special hardware support (such as hardware pointer tags). <p> After describing the scheme, we present some experimental results. 2 Basic Problems Unambiguous full copying collection (cf. <ref> [8, 5, 6] </ref>) must be able to determine if an object is reachable from other live objects or from the roots. Moreover, the garbage collector must be able to find all pointers to a given object so that they may be updated when the object is moved.
Reference: [6] <author> J. F. Bartlett, </author> <title> Mostly-copying garbage collection picks up generations and C++, </title> <type> Technical Note TN-12, </type> <institution> Western Research Laboratory, Digital Equipment Corporation, </institution> <address> Palo Alto, CA 94301, </address> <month> Oct. </month> <year> 1989. </year>
Reference-contexts: Moreover, since orthogonality allows any object to become persistent, all objects need to be movable. This requirement is also essential for fully compacting garbage collection (cf. <ref> [5, 6] </ref>), which yields good locality and fast object allocation time. Portability to a wide variety of hardware and software platforms is one of the key goals for Persistent Modula-3. Therefore our scheme must not rely on any special hardware support (such as hardware pointer tags). <p> After describing the scheme, we present some experimental results. 2 Basic Problems Unambiguous full copying collection (cf. <ref> [8, 5, 6] </ref>) must be able to determine if an object is reachable from other live objects or from the roots. Moreover, the garbage collector must be able to find all pointers to a given object so that they may be updated when the object is moved.
Reference: [7] <author> R. M. Stallman, GCC. </author> <title> Free Software Foundation, </title> <address> Cambridge, MA. </address>
Reference-contexts: These requirements translate to a number of low level requirements on the collector: (i) it must be able to determine the size of heap allocated objects, so that they can be copied; (ii) it must be 2 Our compiler is based on gcc 2.0 and uses its optimizer <ref> [7] </ref>. able to locate pointers contained in heap objects, so they they can be both traced and updated; (iii) it must be able to locate pointers in global variables; (iv) it must be able to find all references in the stack and in the registers at any point in the program <p> Virtual Array Origin: If A is an array of type ARRAY [7..13] OF INTEGER, the obvious method of ac cessing A [i] is: *(&A <ref> [7] </ref> + (i - 7) * sizeof (int)) The subtraction can be avoided by creating an (untidy) pointer to A [0] and using it to index into the array.
Reference: [8] <author> H.-J. Boehm and M. Weiser, </author> <title> Garbage collection in an uncooperative environment, </title> <journal> Software: Practice and Experience, </journal> <volume> vol. 18, </volume> <pages> pp. 807-820, </pages> <month> Sept. </month> <year> 1988. </year>
Reference-contexts: After describing the scheme, we present some experimental results. 2 Basic Problems Unambiguous full copying collection (cf. <ref> [8, 5, 6] </ref>) must be able to determine if an object is reachable from other live objects or from the roots. Moreover, the garbage collector must be able to find all pointers to a given object so that they may be updated when the object is moved.
Reference: [9] <author> C. Chambers and D. Ungar, </author> <title> Making pure object oriented languages practical, </title> <booktitle> in Proceedings of the Conference on Object-Oriented Programming Systems, Languages, and Applications, </booktitle> <address> (Phoenix, Arizona, </address> <month> Oct. </month> <year> 1991), </year> <pages> pp. </pages> <month> 1-15, </month> <journal> ACM SIGPLAN Not. </journal> <volume> 26, </volume> <month> 11 (Nov. </month> <year> 1991). </year>
Reference-contexts: An alternative solution to the ambiguous derivations problem is to use Path Splitting similar to Chambers and Ungar <ref> [9] </ref>. Figure 2 demonstrates this technique. In Figure 2, the body of the loop is duplicated such that the derivation of t in each copy of the loop body is unambiguous. Currently we use the path variable scheme to disambiguate derivations. Both solutions have overheads.
Reference: [10] <author> S. </author> <title> Harbison. </title> <type> Personal Communication, </type> <year> 1992. </year>
Reference-contexts: time. 8 This will not work if allocation is done inline, in which case we must include inline allocations as gc-points. 9 In most systems these points are call points so they do not need special treatment. 6.1 Table Sizes We measured table sizes for 4 Modula-3 programs: typereg, FieldList <ref> [10] </ref>, takl [11] and destroy [12]. typereg implements type registration and type comparisons using structural equivalence for our Modula-3 run-time system. FieldList implements command parsing for a UNIX shell. We considered typereg and FieldList to be good programs to use for our measurements for two reasons.
Reference: [11] <author> R. P. Gabriel, </author> <title> Performance and Evaluation of Lisp Systems. </title> <address> Cambridge, MA: </address> <publisher> MIT Press, </publisher> <year> 1985. </year>
Reference-contexts: This will not work if allocation is done inline, in which case we must include inline allocations as gc-points. 9 In most systems these points are call points so they do not need special treatment. 6.1 Table Sizes We measured table sizes for 4 Modula-3 programs: typereg, FieldList [10], takl <ref> [11] </ref> and destroy [12]. typereg implements type registration and type comparisons using structural equivalence for our Modula-3 run-time system. FieldList implements command parsing for a UNIX shell. We considered typereg and FieldList to be good programs to use for our measurements for two reasons.
Reference: [12] <author> A. L. Hosking, J. E. B. Moss, and D. Stefanovic, </author> <title> A comparative performance evaluation of write barrier implementations, </title> <booktitle> in Proceedings of the Conference on Object-Oriented Programming Systems, Languages, and Applications, </booktitle> <address> (Vancouver, Canada, </address> <month> Oct. </month> <year> 1992). </year> <note> To appear. </note>
Reference-contexts: work if allocation is done inline, in which case we must include inline allocations as gc-points. 9 In most systems these points are call points so they do not need special treatment. 6.1 Table Sizes We measured table sizes for 4 Modula-3 programs: typereg, FieldList [10], takl [11] and destroy <ref> [12] </ref>. typereg implements type registration and type comparisons using structural equivalence for our Modula-3 run-time system. FieldList implements command parsing for a UNIX shell. We considered typereg and FieldList to be good programs to use for our measurements for two reasons. First, they are real programs rather than synthetic benchmarks.
Reference: [13] <author> H.-J. Boehm, </author> <title> A proposal for GC-safe C compilation, </title> <address> Oct. </address> <year> 1991. </year> <title> Position paper for OOPSLA '91 Workshop on Garbage Collection. </title>
Reference-contexts: Note that gc-safety, as proposed by Boehm 10 <ref> [13] </ref>, encounters the same requirement, so this is a basic safety concern rather than a result of our approach. Also, this particular code effect is not likely to occur on load/store architectures. Compiler support for garbage collection may have other effects on the generated code besides the ones described above. <p> The return address in a call is used to locate a routine that knows how to trace the frame of the caller. His work is not done in the context of an optimizing compiler and thus he does not address many of the issues we handle. Boehm <ref> [13, 18] </ref> is currently incorporating garbage collection support in a C compiler. He is using an ambiguous roots collector and his main concern is ensuring that all live ob-jects have at least one pointer to their headers (i.e., there are no live objects that are reachable only from derived values).
Reference: [14] <author> D. Ungar, </author> <title> Generation scavenging: A non-disruptive high performance storage reclamation algorithm, </title> <booktitle> in Proceedings of the ACM SIGSOFT/SIGPLAN Software Engineering Symposium on Practical Software Development Environments, </booktitle> <address> (Pittsburgh, Pennsylvania, </address> <month> Apr. </month> <year> 1984), </year> <pages> pp. </pages> <month> 157-167, </month> <journal> ACM SIGPLAN Not. </journal> <volume> 19, </volume> <month> 5 (May </month> <year> 1984). </year>
Reference-contexts: Also, this particular code effect is not likely to occur on load/store architectures. Compiler support for garbage collection may have other effects on the generated code besides the ones described above. In particular, most generational schemes perform store checks <ref> [14] </ref> when pointers might be written into heap locations.
Reference: [15] <author> R. L. Hudson, J. E. B. Moss, A. Diwan, and C. F. </author> <title> Weight, A language-independent garbage collector toolkit, </title> <type> COINS Technical Report 91-47, </type> <institution> University of Massachusetts, </institution> <address> Amherst, MA 01003, </address> <month> Sept. </month> <year> 1991. </year> <note> Submitted for publication. </note>
Reference-contexts: We ran destroy in our Smalltalk system, which uses the accurate scavenging scheme <ref> [15] </ref> we plan to install in the Modula-3 run-time. We found that collections averaged 280 ms of elapsed time. We coded the benchmark in Modula-3 as similarly as possible, and caused collections at approximately the same points.
Reference: [16] <author> P. Branquart and J. Lewi, </author> <title> A scheme for storage allocation and garbage collection in Algol-68, in Algol 68 Implementation (J. </title> <editor> E. L. Peck, ed.), </editor> <publisher> North-Holland Publishing Company, </publisher> <year> 1971. </year>
Reference-contexts: We conclude that stack tracing overhead is only a small part of gc time, even in a high performance scavenging collector. 7 Related Work Algol-68 implementations were the first to produce compiler generated routines to assist in garbage collection. In the Branquart and Lewi scheme <ref> [16] </ref>, tables are produced that map stack locations to the appropriate garbage collection routine. Unlike our scheme, these tables have to be updated every time a reference to the heap is created on the stack. Goldberg's compiler [17] produces stack tracing routines.
Reference: [17] <author> B. Goldberg, </author> <title> Tag-free garbage collection in strongly typed programming languages, </title> <booktitle> in Proceedings of the ACM SIGPLAN '91 Conference on Programming Language Design and Implementation, </booktitle> <address> (Toronto, Ontario, Canada, </address> <month> June </month> <year> 1991), </year> <pages> pp. </pages> <month> 165-176, </month> <journal> ACM SIGPLAN Not. </journal> <volume> 26, </volume> <month> 6 (June </month> <year> 1991). </year>
Reference-contexts: In the Branquart and Lewi scheme [16], tables are produced that map stack locations to the appropriate garbage collection routine. Unlike our scheme, these tables have to be updated every time a reference to the heap is created on the stack. Goldberg's compiler <ref> [17] </ref> produces stack tracing routines. The return address in a call is used to locate a routine that knows how to trace the frame of the caller.
Reference: [18] <author> H.-J. Boehm, </author> <type> Personal communication, </type> <month> July </month> <year> 1991. </year>
Reference-contexts: The return address in a call is used to locate a routine that knows how to trace the frame of the caller. His work is not done in the context of an optimizing compiler and thus he does not address many of the issues we handle. Boehm <ref> [13, 18] </ref> is currently incorporating garbage collection support in a C compiler. He is using an ambiguous roots collector and his main concern is ensuring that all live ob-jects have at least one pointer to their headers (i.e., there are no live objects that are reachable only from derived values).
Reference: [19] <author> A. Diwan, </author> <title> Exception handling in Modula-3. Internal OOS Document, </title> <year> 1990. </year>
Reference-contexts: Since he never moves objects he does not need to deal with the issues in updating derived values. Exception handling implementations in CLU, Trellis, and Modula-3 also use compiler generated tables. In our Modula-3 implementation <ref> [19] </ref> tables are generated for each point where an exception may be raised. The tables contain the addresses of handlers for the exceptions that can be raised at that point.
Reference: [20] <author> L. W. Zurawski and R. E. Johnson, </author> <title> Debugging optimized code with expected behavior, </title> <journal> ACM Trans. Programming Languages and Systems, </journal> <note> To appear. </note>
Reference-contexts: In our Modula-3 implementation [19] tables are generated for each point where an exception may be raised. The tables contain the addresses of handlers for the exceptions that can be raised at that point. Zurawski and Johnson <ref> [20] </ref> emit compile-time tables to allow them to construct the unoptimized state of the program from the optimized state. Like us, they have to deal with the effects of pointer arithmetic introduced by the optimizer. Their focus, however, is on debugging; some optimizations are disallowed to make debugging possible.
References-found: 20

