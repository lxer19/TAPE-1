URL: ftp://ftp.eecs.umich.edu/groups/gasm/pam2.ps
Refering-URL: http://www.eecs.umich.edu/gasm/papers.html
Root-URL: http://www.cs.umich.edu
Title: Refinement of a typed WAM extension by polymorphic order-sorted types  
Author: Christoph Beierle and Egon Borger 
Keyword: Constraint logic programming, WAM, types, polymorphism, order-sorted types, correctness proof, evolving algebras  
Address: D-58084 Hagen, Germany;  Pisa, Corso Italia 40, I-56100 Pisa, Italia  
Affiliation: 1 Fachbereich Informatik, FernUniversitat Hagen,  Dipartimento di Informatica, Universita di  
Note: slightly modified version appeared in: Formal Aspects of Computing, Vol. 8(5), pp.  
Phone: 2  
Date: 539-564, 1996  
Abstract: We refine the mathematical specification of a WAM extension to type-constraint logic programming given in [BB96]. We provide a full specification and correctness proof of the PROTOS Abstract Machine (PAM), an extension of the WAM by polymorphic order-sorted unification as required by the logic programming language PROTOS-L, by refining the abstract type constraints used in [BB96] to the polymorphic order-sorted types of PROTOS-L. This allows us to develop a detailed and mathematically precise account of the PAM's compiled type constraint representation and solving facilities, and to extend the correctness theorem to compilation on the fully specified PAM. 
Abstract-found: 1
Intro-found: 1
Reference: [AK91] <author> H. At-Kaci. </author> <title> Warren's Abstract Machine: A Tutorial Reconstruction. </title> <publisher> MIT Press, </publisher> <address> Cambridge, MA, </address> <year> 1991. </year>
Reference-contexts: 1. Introduction In [BR95] a mathematical elaboration of Warren's Abstract Machine ([War83], <ref> [AK91] </ref>) for executing Prolog is given, coming in several refinement levels together with correctness proofs, and a correctness proof w.r.t. Borger's phenomenological Prolog description [Bor90].
Reference: [BB96] <author> C. Beierle and E. Borger. </author> <title> Specification and correctness proof of a WAM extension with abstract type constraints. </title> <journal> Formal Aspects of Computing, </journal> <volume> 8(4), </volume> <year> 1996. </year>
Reference-contexts: 1. Introduction In [BR95] a mathematical elaboration of Warren's Abstract Machine ([War83], [AK91]) for executing Prolog is given, coming in several refinement levels together with correctness proofs, and a correctness proof w.r.t. Borger's phenomenological Prolog description [Bor90]. In <ref> [BB96] </ref> we demonstrated how the evolving algebra approach naturally allows for modifications and extensions in the description of both the semantics of programming languages as well as of implementation Address for correspondence: Christoph Beierle, Fachbereich Informatik, LG Praktische In-formatik VIII, FernUniversitat Hagen, Bahnhofstr. 48, D-58084 Hagen, Germany; e-mail: christoph.beierle@fernuni-hagen.de fl The <p> He would also like to thank the Scientific Center of IBM Germany where the work reported here was started. 2 C. Beierle and E. Borger methods. Extending Borger and Rosenzweig's WAM description, <ref> [BB96] </ref> provides a mathematical specification of a WAM extension to type-constraint logic programming and proves its correctness. <p> Our aim is to provide here a full specification and correctness proof of the PAM, including extra-logical features and all WAM optimizations (like environment trimming and last call optimization), as well as PAM specific optimizations (like refined variable representation or switch on typed variables). In <ref> [BB96] </ref> the notion of type constraints was deliberately kept abstract, in order to be applicable to a range of constraint formalisms such as Prolog III or CLP (R). Consequently, also on the abstract machine level, the type contraint solving parts had to be kept abstract. <p> Section 4 gives a detailed account of polymorphic type constraint representation and solving in the PAM. Since this paper is a direct sequel to <ref> [BB96] </ref>, we assume the reader to be familiar with it and refer to it for unexplained definitions and notations and for further references to the literature. 2. PAM algebras with monomorphic type constraints 2.1. <p> update will be executed With this update at hand the third binding rule is if BIND Bind-3 (Bind-Var-Struc) & NOT (unbound (arg2)) then trail (arg1) arg1 &lt;REF,arg2&gt; occur check (arg1,arg2) propagate (arg1,arg2) BINDING LEMMA 1: The bind rules are a correct realization of the binding update of Section 3.2 in <ref> [BB96] </ref>, i.e. the BINDING CONDITIONS 1 and 3 (and thus also 2), the TRAILING CONDITION as well as the STACK VARIABLES PROPERTY are preserved. Proof. <p> (l) = S POLY then is polymorphic (tref (l)) where the auxiliary function typeterm: TYPEAREA ! TYPETERM satisfies the constraints typeterm (l) = TOP if ttag (l) = S TOP typeterm (l) = tref (l) if ttag (l) = S MONO We refine the PAM algebras of Section 5 in <ref> [BB96] </ref> by replacing the universe TYPETERM by its representing universe TYPEAREA. The codomain of the ref function (from 3.1 in [BB96]) now contains TYPEAREA, and in the integrity constraints of 3.1 in [BB96] as well as in the definition of type prefix the case for unbound (l) now contains typeterm (ref <p> typeterm (l) = TOP if ttag (l) = S TOP typeterm (l) = tref (l) if ttag (l) = S MONO We refine the PAM algebras of Section 5 in <ref> [BB96] </ref> by replacing the universe TYPETERM by its representing universe TYPEAREA. The codomain of the ref function (from 3.1 in [BB96]) now contains TYPEAREA, and in the integrity constraints of 3.1 in [BB96] as well as in the definition of type prefix the case for unbound (l) now contains typeterm (ref (l)) instead of ref (l). <p> = tref (l) if ttag (l) = S MONO We refine the PAM algebras of Section 5 in <ref> [BB96] </ref> by replacing the universe TYPETERM by its representing universe TYPEAREA. The codomain of the ref function (from 3.1 in [BB96]) now contains TYPEAREA, and in the integrity constraints of 3.1 in [BB96] as well as in the definition of type prefix the case for unbound (l) now contains typeterm (ref (l)) instead of ref (l). <p> Initialization of type constrained variables In the PAM algebras developed so far the update insert type (l,t) is used as part of the mk unbound update in the variable initialization instructions get variable, put variable, and unify variable (Section 5.2 in <ref> [BB96] </ref>) (Its use in the multiple mk unbounds update in get structure will be refined in Section 2.6 below). <p> 1 ,tt), we have if unbound (l 1 ) and tt 2 TYPETERM with is polymorphic (tt): (term', prefix') = conres (term,prefixnmk var (l 1 ),fmk var (l 1 ) : ttg) TYPE INSERTION LEMMA: The refinement of the insert type update satisfies the TYPE INSERTING CONDITION of 3.5 in <ref> [BB96] </ref>. Proof. By straightforward case analysis for TOP, monomorphic and polymorphic type restrictions; for the latter the POLYMORPHIC TYPE INSERTION CONDITION is used. 2.5. Binding of type constrained variables We refine the binding rules of Section 2.1 according to the type term representation. <p> BINDING LEMMA 2: The refined binding rules correctly realize the binding rules of Section 2.1 and thus the binding update of 3.2 in <ref> [BB96] </ref>. Proof. Following the proof of the BINDING LEMMA in 2.1 we have to show that the rules Bind-2a - Bind-2d and Bind-3a - Bind-3b are correct realizations of the inf function used in Bind-2 and of the propagate update used in Bind-3. <p> This follows by straightforward case analysis for TOP, monomorphic, and polymorphic type restrictions: For TOP, we use its property that it is `maximal' w.r.t. inf and that the propagate update can not have any effect since any TOP restriction trivially holds (Section 2.1 in <ref> [BB96] </ref>). For the monomorphic case we conclude from the last integrity constraint given in Section 2.2 that the propagate update is either empty or fails immediately due to the subsort test, implying that the different cases correctly simulate this situation. <p> For the polymorphic case the POLYMORPHIC INFIMUM and POLYMORPHIC PROPAGATION CONDITIONS are used. 2.6. Getting of structures We refine the get struture rules of Section 3.4 in <ref> [BB96] </ref> according to the type term representation. Rule Get-Structure-1 remains unchanged. <p> CORRECTNESS OF GET-STRUCTURE REFINEMENT: The refined Get-Structure rules are a correct realization of the rules of Section 3.4 in <ref> [BB96] </ref>, i.e. the GETTING LEMMA stills holds for the refined type term representation. Proof. <p> As in the proof of the BINDING LEMMA 2 in the previous subsection we can apply a straightforward case analysis for TOP, monomorphic, and polymorphic type restrictions: For TOP, we observe that always both conditions can propagate (f,TOP) and trivially propagates (f,TOP) used in the Get-Structure rule of 3.4 in <ref> [BB96] </ref> hold. For monomorphic type restrictions, the propagation reduces again to the subsort test. For the polymorphic case the POLYMORPHIC PROPAGATION CONDITION ensures that exactly the type restrictions given by the propagate list function used in 3.4 in [BB96] are propagated onto the arguments of the structure. <p> and trivially propagates (f,TOP) used in the Get-Structure rule of 3.4 in <ref> [BB96] </ref> hold. For monomorphic type restrictions, the propagation reduces again to the subsort test. For the polymorphic case the POLYMORPHIC PROPAGATION CONDITION ensures that exactly the type restrictions given by the propagate list function used in 3.4 in [BB96] are propagated onto the arguments of the structure. <p> Moreover, in the representation of monomorphic sorts one can also easily save a type area location by letting the ref value of a data area location point directly to SORT. Therefore, we extend the codomain of the function ref (see 3.1 in <ref> [BB96] </ref>) to include also SORT. <p> (l,tt) unbound (l) tag (l) 2 fFREE, FREE M, FREE Pg top (l) tag (l) = FREE monomorphic (l) tag (l) = FREE M polymorphic (l) tag (l) = FREE P sort (l) ref (l) if monomorphic (l) The integrity constraint for the case unbound (l) of Section 3.1 in <ref> [BB96] </ref> is replaced by if tag (l) = FREE M then ref (l) 2 SORT if tag (l) = FREE P then ref (l) 2 TYPEAREA typeterm (ref (l)) 2 TYPETERM is polymorphic (typeterm (ref (l))) and in the definition of type prefix the case for unbound (l) is refined to <p> Similarly, the rules for initializing variables (Section 5.2 in <ref> [BB96] </ref>) are modified as explained in the following. <p> Inserting TOP and monomorphic type restrictions for variables obviously has the same effect as in 2.4. Trailing still works fine since in 4.2 in <ref> [BB96] </ref> we trailed the complete val decoration of a data area location including its tag and restored it upon backtracking. With these two observations the proof follows by case analysis for the three different kinds of type restrictions. <p> Switch on Types As opposed to the WAM, in the PAM also a switch on the subtype restriction of a variable is possible (c.f. 5.3 in <ref> [BB96] </ref>) which increases the determinacy detection abilities. <p> Appendix B.7 in <ref> [BB96] </ref>) except that the variable may carry a polymorphic type restriction, which however does not lead to the exclusion of any clauses, since in PROTOS-L no explicit subtype relationships are allowed between polymorphic types [Bei92]. if RUN Switch-on-mono-term & code (p) = switch on mono term (i,Lfree,Lfree m,Lstruc) & tag (deref <p> For the correctness proof for the extended switching instructions we must extend the assumptions on the compiler stated in 2.2 in <ref> [BB96] </ref>. <p> The relationship between the declaration part of the program prog (see 2.1 and 2.4 in <ref> [BB96] </ref>) and the functions on SORT is regulated by the following integrity constraints: For each function declaration of the form f: d 1 : : : d m ! s (ff 1 ,: : : ,ff n ) with m, n 0, pairwise distinct (type) variables ff i that occur in <p> if the machine is still in unifying mode, the update propagate unify (l 1 ,l 2 ) just pushes the two locations to be unified onto the push down list PDL used for unification; otherwise the update unify (l 1 ,l 2 ) initializing unification is executed (see 3.2 in <ref> [BB96] </ref>). POLYMORPHIC PROPAGATION LEMMA: The polymorphic propagation rules given above are a correct realization of the poly propagate (l 1 ,l 2 ) update of Section 2.5. Proof. <p> This exactly is ensured by the updates of rule Polymorphic Propagation 3: By induction on the number of times the unification of the two terms to be unified will again cause a polymorphic propagation invocation, and using the UNIFICATION LEMMA of Section 3.2 in <ref> [BB96] </ref>, we can show that at the time when the unification initiated by the update propagate unify (h, pp t) has been carried out (either with success or with failure) the post-conditions of the POLYMORPHIC PROPAGATION CONDITION are satisfied. 4.5.
Reference: [Bei92] <author> C. Beierle. </author> <title> Logic programming with typed unification and its realization on an abstract machine. </title> <journal> IBM Journal of Research and Development, </journal> <volume> 36(3) </volume> <pages> 375-390, </pages> <month> May </month> <year> 1992. </year>
Reference-contexts: In the presence of types and subtypes, restricting a variable to a subtype represents a constraint in the spirit of constraint logic programming. PROTOS-L <ref> [Bei92] </ref>, is a logic programming language that has a polymorphic, order-sorted type concept (similar to the slightly more general type concept of TEL [Smo88]) and a complete abstract machine implementation, called PAM [BM94] that is an extension of the WAM by the required polymorphic order-sorted unification. <p> The function target sort: SYMBOLTABLE ! SORT yields the target sort of a constructor, where SORT is a new universe, representing sort names. It comes with a function subsort: SORT fi SORT ! BOOL defining the order relation on the monomorphic sorts (and being undefined on the polymorhic sorts <ref> [Bei92] </ref>). <p> Appendix B.7 in [BB96]) except that the variable may carry a polymorphic type restriction, which however does not lead to the exclusion of any clauses, since in PROTOS-L no explicit subtype relationships are allowed between polymorphic types <ref> [Bei92] </ref>. if RUN Switch-on-mono-term & code (p) = switch on mono term (i,Lfree,Lfree m,Lstruc) & tag (deref (x i )) = FREE | FREE M | STRUC then p := Lfree | p := Lfree m | p := Lstruc In the switch on mono term instruction we distinguish the two <p> X m : subres (d m ,subst)g) where the X i are new variables, f has declaration f: d 1 : : : d m ! s (ff 1 ,: : : ,ff n ) 2 prog and subst is the substitution (on type terms) subst = S : (c.f. <ref> [Bei92] </ref>, [BM94]). Note that since s (tt 1 ,: : : ,tt n ) can not contain any type variables, also in subres (d j ,subst) all type variables will have been replaced by ground type terms.
Reference: [BM94] <author> C. Beierle and G. Meyer. </author> <title> Run-time type computations in the Warren Abstract Machine. </title> <journal> Journal of Logic Programming, </journal> <volume> 18(2) </volume> <pages> 123-148, </pages> <month> February </month> <year> 1994. </year>
Reference-contexts: PROTOS-L [Bei92], is a logic programming language that has a polymorphic, order-sorted type concept (similar to the slightly more general type concept of TEL [Smo88]) and a complete abstract machine implementation, called PAM <ref> [BM94] </ref> that is an extension of the WAM by the required polymorphic order-sorted unification. <p> TOP), or a monomorphic, or a polymorphic type restriction, respectively. In the spirit of the WAM's tagged architecture it is thus sensible to distinguish these three different cases efficiently by special tags <ref> [BM94] </ref>. The tag VAR is therefore replaced by the three tags FREE, FREE M, FREE P. Moreover, in the representation of monomorphic sorts one can also easily save a type area location by letting the ref value of a data area location point directly to SORT. <p> m : subres (d m ,subst)g) where the X i are new variables, f has declaration f: d 1 : : : d m ! s (ff 1 ,: : : ,ff n ) 2 prog and subst is the substitution (on type terms) subst = S : (c.f. [Bei92], <ref> [BM94] </ref>). Note that since s (tt 1 ,: : : ,tt n ) can not contain any type variables, also in subres (d j ,subst) all type variables will have been replaced by ground type terms.
Reference: [Bor90] <author> E. Borger. </author> <title> A logical operational semantics of full Prolog. Part I. Selection core and control. </title> <booktitle> CSL'89 3rd Workshop on Computer Science Logic. </booktitle> <volume> LNCS 440, </volume> <pages> pages 36-64. </pages> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1990. </year>
Reference-contexts: 1. Introduction In [BR95] a mathematical elaboration of Warren's Abstract Machine ([War83], [AK91]) for executing Prolog is given, coming in several refinement levels together with correctness proofs, and a correctness proof w.r.t. Borger's phenomenological Prolog description <ref> [Bor90] </ref>.
Reference: [BR95] <author> E. Borger and D. Rosenzweig. </author> <title> The WAM definition and compiler correctness. </title> <editor> In C. Beierle and L. Plumer, editors, </editor> <booktitle> Logic Programming: Formal Methods and Practical Applications, Studies in Computer Science and Artificial Intelligence, chapter 2, </booktitle> <pages> pages 20-90. </pages> <address> Elsevier Science B.V./North-Holland, Amsterdam, </address> <year> 1995. </year>
Reference-contexts: 1. Introduction In <ref> [BR95] </ref> a mathematical elaboration of Warren's Abstract Machine ([War83], [AK91]) for executing Prolog is given, coming in several refinement levels together with correctness proofs, and a correctness proof w.r.t. Borger's phenomenological Prolog description [Bor90].
Reference: [Han91] <author> M. Hanus. </author> <title> Horn clause programs with polymorphic types: Semantics and resolution. </title> <journal> Theoretical Computer Science, </journal> <volume> 89 </volume> <pages> 63-106, </pages> <year> 1991. </year>
Reference-contexts: The reason that types are dealt with at the abstract machine level is that the extension of logic programming by types requires in general not only static type checking, but types may also be present at run time (see e.g. [MO84], <ref> [Han91] </ref>, [Smo89]). In the presence of types and subtypes, restricting a variable to a subtype represents a constraint in the spirit of constraint logic programming.
Reference: [MO84] <author> A. Mycroft and R. A. O'Keefe. </author> <title> A polymorphic type system for Prolog. </title> <journal> Artificial Intelligence, </journal> <volume> 23 </volume> <pages> 295-307, </pages> <year> 1984. </year>
Reference-contexts: The reason that types are dealt with at the abstract machine level is that the extension of logic programming by types requires in general not only static type checking, but types may also be present at run time (see e.g. <ref> [MO84] </ref>, [Han91], [Smo89]). In the presence of types and subtypes, restricting a variable to a subtype represents a constraint in the spirit of constraint logic programming.
Reference: [Smo88] <author> G. Smolka. </author> <title> TEL (Version 0.9), Report and User Manual. </title> <type> SEKI-Report SR 87-17, </type> <institution> FB Informatik, Universitat Kaiserslautern, </institution> <year> 1988. </year>
Reference-contexts: In the presence of types and subtypes, restricting a variable to a subtype represents a constraint in the spirit of constraint logic programming. PROTOS-L [Bei92], is a logic programming language that has a polymorphic, order-sorted type concept (similar to the slightly more general type concept of TEL <ref> [Smo88] </ref>) and a complete abstract machine implementation, called PAM [BM94] that is an extension of the WAM by the required polymorphic order-sorted unification.
Reference: [Smo89] <author> G. Smolka. </author> <title> Logic Programming over Polymorphically Order-Sorted Types. </title> <type> PhD thesis, </type> <institution> FB Informatik, Univ. Kaiserslautern, </institution> <year> 1989. </year>
Reference-contexts: The reason that types are dealt with at the abstract machine level is that the extension of logic programming by types requires in general not only static type checking, but types may also be present at run time (see e.g. [MO84], [Han91], <ref> [Smo89] </ref>). In the presence of types and subtypes, restricting a variable to a subtype represents a constraint in the spirit of constraint logic programming.
Reference: [War83] <author> D. H. D. Warren. </author> <title> An Abstract PROLOG Instruction Set. </title> <type> Technical Report 309, </type> <institution> SRI, </institution> <year> 1983. </year>
References-found: 11

