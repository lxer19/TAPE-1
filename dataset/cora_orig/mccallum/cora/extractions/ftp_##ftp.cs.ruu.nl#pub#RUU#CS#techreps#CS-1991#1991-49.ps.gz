URL: ftp://ftp.cs.ruu.nl/pub/RUU/CS/techreps/CS-1991/1991-49.ps.gz
Refering-URL: http://www.ics.uci.edu/~eppstein/cgt/
Root-URL: http://www.aic.nrl.navy.mil/~aha/people.html
Title: Kayles on special classes of graphs An application of Sprague-Grundy theory  
Author: Hans L. Bodlaender 
Address: P.O. Box 80.089, 3508 TB Utrecht, the Netherlands  
Affiliation: Department of Computer Science, Utrecht University  
Abstract: Kayles is the game, where two players alternately choose a vertex that has not been chosen before nor is adjacent to an already chosen vertex from a given graph. The last player that choses a vertex wins the game. We show, with help of Sprague-Grundy theory, that the problem to determine which player has a winning strategy for a given graph, can be solved in O(n 3 ) time on interval graphs, on circular arc graphs, on permutation graphs, and on co-comparability graphs and in O(n 1:631 ) time on cographs. For general graphs, the problem is known to be PSPACE-complete, but can be solved in time polynomial in the number of isolatable sets of vertices of the graph.
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> E. R. Berlekamp, J. H. Conway, and R. K. Guy. </author> <title> Winning Ways for your mathematical plays, Volume 1: Games in General. </title> <publisher> Academic Press, </publisher> <address> New York, </address> <year> 1982. </year>
Reference-contexts: These six characteristics of Kayles make it possible to analyse the game with help of Sprague-Grundy theory. Some readers may know this theory as the theory of the game Nim. In this theory, one associates to each position a (natural) number, here called nimber after <ref> [1] </ref>. (The position has nimber i, when it can be represented by a stack of corresponding height in the game Nim.) It is possible to do some calculations with these nimbers, and determine which player has a winning strategy. <p> Those basic notions and results of Sprague-Grundy theory that are needed for this paper are reviewed in section 2. For more background, we recommend the reader to consult <ref> [1] </ref> or [3]. Some graph theoretic definitions are also given in section 2. In section 3, we give a data structure, needed for the algorithm, described in section 4. <p> A graph is a co-comparability graph, if it is the complement of a comparability graph. A graph G = (V; E) is a comparability graph, if it has a transitive orientation. Co-comparability graphs can be characterized as the intersection graphs of continous functions f : <ref> [0; 1] </ref> ! R: one can associate to each vertex v 2 V a continuous function f v : [0; 1] ! R, such that for all v; w 2 V , v 6= w: (v; w) 2 E , 9x 2 [0; 1] : f v (x) = f w <p> A graph G = (V; E) is a comparability graph, if it has a transitive orientation. Co-comparability graphs can be characterized as the intersection graphs of continous functions f : <ref> [0; 1] </ref> ! R: one can associate to each vertex v 2 V a continuous function f v : [0; 1] ! R, such that for all v; w 2 V , v 6= w: (v; w) 2 E , 9x 2 [0; 1] : f v (x) = f w (x). See [7]. <p> the intersection graphs of continous functions f : <ref> [0; 1] </ref> ! R: one can associate to each vertex v 2 V a continuous function f v : [0; 1] ! R, such that for all v; w 2 V , v 6= w: (v; w) 2 E , 9x 2 [0; 1] : f v (x) = f w (x). See [7]. Note that some of these classes are properly contained in others: every cograph is a permutation graph, every interval graph is a circular arc graph, and every permutation graph and every interval graph is a co-comparability graph. <p> Next, we review some notions and results from Sprague-Grundy theory. For a good introduction to this theory, the reader is referred to [3] or the less formal and entertaining <ref> [1] </ref>. A nimber is an integer in N = f0; 1; 2; : : :g. For a finite set of nimbers S N , define the minimum excluded nimber of S as mex (S) = minfi 2 N j i 62 Sg. <p> If no move is possible in the position (and hence the player that must move loses the game), the position gets nimber 0. Otherwise the nimber is the minimum excluded nimber of the set of nimbers of positions that can be reached in one move. Theorem 2.1 <ref> [1, 3] </ref> There is a winning strategy for player 1 from a position, if and only if the nimber of that position is at least 1. Denote the nimber of a position p by nb (p). We next define the sum of two games. <p> By (p 1 ; p 2 ) we denote the position in G 1 + G 2 , where the position in G i is p i (i = 1; 2). Theorem 2.2 <ref> [1, 3] </ref> Let p 1 be a position in G 1 , p 2 a position in G 2 . <p> Such an orientation can be found in O (d e) time, where d is the maximum degree of a vertex (see [6], p.129). There exists a collection of continuous functions ff v : <ref> [0; 1] </ref> ! R j v 2 V g, such that these form an intersection model of G (i.e., for all v; w 2 V , v 6= w: (v; w) 2 E , 9x 2 [0; 1] : f v (x) = f w (x)), and for all v; w <p> There exists a collection of continuous functions ff v : <ref> [0; 1] </ref> ! R j v 2 V g, such that these form an intersection model of G (i.e., for all v; w 2 V , v 6= w: (v; w) 2 E , 9x 2 [0; 1] : f v (x) = f w (x)), and for all v; w 2 V : if for all x 2 [0; 1]: f v (x) &lt; f w (x), then v &lt; w [7]. <p> such that these form an intersection model of G (i.e., for all v; w 2 V , v 6= w: (v; w) 2 E , 9x 2 <ref> [0; 1] </ref> : f v (x) = f w (x)), and for all v; w 2 V : if for all x 2 [0; 1]: f v (x) &lt; f w (x), then v &lt; w [7]. Our algorithm does not construct these functions; we use them only for showing correctness of our algorithm. We have two additional functions: define f 0 : [0; 1] ! R by f 0 (x) = min v2V <p> v; w 2 V : if for all x 2 <ref> [0; 1] </ref>: f v (x) &lt; f w (x), then v &lt; w [7]. Our algorithm does not construct these functions; we use them only for showing correctness of our algorithm. We have two additional functions: define f 0 : [0; 1] ! R by f 0 (x) = min v2V f v (x) 1, and define f n+1 : [0; 1] ! R by f n+1 (x) = max v2V f v (x) + 1. <p> Our algorithm does not construct these functions; we use them only for showing correctness of our algorithm. We have two additional functions: define f 0 : <ref> [0; 1] </ref> ! R by f 0 (x) = min v2V f v (x) 1, and define f n+1 : [0; 1] ! R by f n+1 (x) = max v2V f v (x) + 1. Note that f 0 is strictly smaller than all other functions f v , and f n+1 is strictly larger than all these functions. Write v w, iff for all x 2 [0; 1] : <p> n+1 : <ref> [0; 1] </ref> ! R by f n+1 (x) = max v2V f v (x) + 1. Note that f 0 is strictly smaller than all other functions f v , and f n+1 is strictly larger than all these functions. Write v w, iff for all x 2 [0; 1] : f v (x) &lt; f w (x). For 0 i j n + 1, write V ij = fv 2 V j i v j. Write G ij = G [V ij ].
Reference: [2] <author> K. S. Booth and G. S. Lueker. </author> <title> Testing for the consecutive ones property, interval graphs, and graph planarity using pq-tree algorithms. </title> <journal> J. Comp. Syst. Sc., </journal> <volume> 13 </volume> <pages> 335-379, </pages> <year> 1976. </year>
Reference-contexts: Interval graphs can be recognized in O (n + e) time, and in the same order of time, the corresponding interval model can be built <ref> [2] </ref>. As only the order of the endpoints of the intervals matters, one can assume that all b v ; e v 2 f1; 2; : : : ; 2ng. A generalization of the interval graphs are the circular arc graphs.
Reference: [3] <author> J. H. Conway. </author> <title> On Numbers and Games. </title> <publisher> Academic Press, </publisher> <address> London, </address> <year> 1976. </year>
Reference-contexts: Those basic notions and results of Sprague-Grundy theory that are needed for this paper are reviewed in section 2. For more background, we recommend the reader to consult [1] or <ref> [3] </ref>. Some graph theoretic definitions are also given in section 2. In section 3, we give a data structure, needed for the algorithm, described in section 4. This algorithm solves Kayles on a graph with n vertices, e edges, and ff different isolatable sets of vertices, in time O (ffne). <p> Next, we review some notions and results from Sprague-Grundy theory. For a good introduction to this theory, the reader is referred to <ref> [3] </ref> or the less formal and entertaining [1]. A nimber is an integer in N = f0; 1; 2; : : :g. For a finite set of nimbers S N , define the minimum excluded nimber of S as mex (S) = minfi 2 N j i 62 Sg. <p> If no move is possible in the position (and hence the player that must move loses the game), the position gets nimber 0. Otherwise the nimber is the minimum excluded nimber of the set of nimbers of positions that can be reached in one move. Theorem 2.1 <ref> [1, 3] </ref> There is a winning strategy for player 1 from a position, if and only if the nimber of that position is at least 1. Denote the nimber of a position p by nb (p). We next define the sum of two games. <p> By (p 1 ; p 2 ) we denote the position in G 1 + G 2 , where the position in G i is p i (i = 1; 2). Theorem 2.2 <ref> [1, 3] </ref> Let p 1 be a position in G 1 , p 2 a position in G 2 .
Reference: [4] <author> D. G. Corneil, Y. Perl, and L. K. Stewart. </author> <title> A linear recognition algorithm for cographs. </title> <journal> SIAM J. Comput., </journal> <volume> 4 </volume> <pages> 926-934, </pages> <year> 1985. </year>
Reference-contexts: G equals the cograph corresponding with the root of T G . Cographs can be recognized in O (n + e) time, and in the same time the corresponding cotree can be built <ref> [4] </ref>.
Reference: [5] <author> M. Dietzfelbinger, A. Karlin, K. Mehlhorn, F. Meyer auf der Heide, H. Rohn-ert, and R. E. Tarjan. </author> <title> Dynamic perfect hashing: Upper and lower bounds. </title> <booktitle> In Proceedings of the 29th Annual Symposium on Foundations of Computer Science, </booktitle> <pages> pages 524-531, </pages> <year> 1988. </year>
Reference-contexts: The space needed per data structure Y is O (jV j), hence in total O (jV jff), where ff is the number of sets W that are present in the data structure. * as a dynamic perfect hashing data structure, as described by Dietzfelbinger et al <ref> [5] </ref>. Search operations cost O (1) time worst case, insert operations cost O (1) expected time. Memory use is linear in the number of stored keys. This method uses randomization.
Reference: [6] <author> M. C. Golumbic. </author> <title> Algorithmic Graph Theory and Perfect Graphs. </title> <publisher> Academic Press, </publisher> <address> New York, </address> <year> 1980. </year>
Reference-contexts: Permutation graphs can be recognized in O (n 3 ) time, and in the same time, the corresponding numbering of the vertices and permutation can be found <ref> [6] </ref>. A graph is a co-comparability graph, if it is the complement of a comparability graph. A graph G = (V; E) is a comparability graph, if it has a transitive orientation. <p> Suppose V = f1; 2; : : : ; ng, with this ordering on the vertices a topological ordering of a transitive orientation of the complement of G. Such an orientation can be found in O (d e) time, where d is the maximum degree of a vertex (see <ref> [6] </ref>, p.129).
Reference: [7] <author> M. C. Golumbic, D. Rotem, and J. Urrutia. </author> <title> Comparability graphs and intersection graphs. </title> <journal> Disc. Math., </journal> <volume> 43 </volume> <pages> 37-46, </pages> <year> 1983. </year> <month> 18 </month>
Reference-contexts: See <ref> [7] </ref>. Note that some of these classes are properly contained in others: every cograph is a permutation graph, every interval graph is a circular arc graph, and every permutation graph and every interval graph is a co-comparability graph. Next, we review some notions and results from Sprague-Grundy theory. <p> w 2 V , v 6= w: (v; w) 2 E , 9x 2 [0; 1] : f v (x) = f w (x)), and for all v; w 2 V : if for all x 2 [0; 1]: f v (x) &lt; f w (x), then v &lt; w <ref> [7] </ref>. Our algorithm does not construct these functions; we use them only for showing correctness of our algorithm.
Reference: [8] <author> D. Konig. </author> <title> Theorie der endlichen und unendlichen Graphen. </title> <address> Akademische Verlagsgesellschaft, Leipzig, </address> <year> 1936. </year>
Reference-contexts: Also, the analysis of games can provide for entertainment, or beautiful theory that is interesting on its own. It may be interesting to note that one of the first books written on graph theory <ref> [8] </ref> already contained a section on the relations between graphs and games. In this paper we consider a combinatorial game, that is played on graphs, called Kayles. In this game, two players alternately choose a vertex from a given graph.
Reference: [9] <author> T. J. Schaefer. </author> <title> On the complexity of some two-person perfect-information games. </title> <journal> J. Comp. Syst. Sc., </journal> <volume> 16 </volume> <pages> 185-225, </pages> <year> 1978. </year>
Reference-contexts: We consider the problem: given a graph G = (V; E), does there exist a winning strategy for the first player when Kayles is played on G? We denote this problem also by the name Kayles. Kayles has been shown to be PSPACE-complete by Schaefer <ref> [9] </ref>. Despite its intractability for general graphs, Kayles has some nice characteristics, which together allow for efficient algorithms that solve some special cases. We remark that the game Kayles is: * a two player game. * finite. <p> Probably the most notable of these classes is the class of trees. Already in 1978, Schaefer mentioned as an open problem the complexity of Kayles, when restricted to trees where only one vertex has degree at least three <ref> [9] </ref>. To the author's best knowledge, this problem is still unresolved. 15 A Proof of theorem 6.5 Here we show that for all K 0, s (K) 3 K . As it is shown in lemma 6.4 that s (K) 3 K , theorem 6.5 follows.
Reference: [10] <author> A. Tucker. </author> <title> An efficient test for circular-arc graphs. </title> <journal> SIAM J. Comput., </journal> <volume> 9 </volume> <pages> 1-24, </pages> <year> 1980. </year>
Reference-contexts: Recognition of circular arc graphs, and building the corresponding representation can be done in O (n 3 ) time <ref> [10] </ref>. Definition 2.4 Let G 1 = (V 1 ; E 1 ) and G 2 = (V 2 ; E 2 ) be two disjoint graphs.
Reference: [11] <author> P. van Emde Boas, R. Kaas, and E. Zijlstra. </author> <title> Design and implementation of an efficient priority queue. </title> <journal> Mathematical Systems Theory, </journal> <volume> 10 </volume> <pages> 99-127, </pages> <year> 1984. </year> <month> 19 </month>
Reference-contexts: The space needed is O ( P present (W ) jW j). * as an van Emde Boas data structure <ref> [11] </ref>. The operations in data structure Y take now O (log log n) time and the total time per store present or val operation becomes O (jW j log log jV j).
References-found: 11

