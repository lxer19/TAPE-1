URL: http://www.cs.wisc.edu/wpis/papers/tr1383.ps
Refering-URL: http://www.cs.wisc.edu/wpis/html/
Root-URL: http://www.cs.wisc.edu
Title: Parametric Shape Analysis via 3-Valued Logic about properties of stores can be answered by evaluating
Author: Mooly Sagiv, Thomas Reps, and Reinhard Wilhelm 
Keyword: Three-valued logical structures are thus a conservative representation of memory stores. General Terms: Algorithms, Languages, Theory, Verification Additional Key Words: Abstract interpretation, alias analysis, constraint solving, dataflow analysis, destructive updating, pointer analysis, shape analysis, static analysis, three-valued logic  
Note: Questions  
Abstract: We present a family of abstract-interpretation algorithms that are capable of determining "shape invariants" of programs that perform destructive updating on dynamically allocated storage. The main idea is to represent the stores that can possibly arise during execution using three-valued logical structures. * If a formula evaluates to unknown, then we do not know if this formula holds in every store, in some store, or in no store represented by the three-valued structure. The approach described is a parametric framework: It provides the basis for generating a family of shape-analysis algorithms by varying the vocabulary used in the three-valued logic. Different instantiations of the framework allow the usage patterns of different kinds of data structures in a program to be observed, or allow the usage patterns of data structures to be observed with different levels of precision and efficiency. Categories and Subject Descriptors: D.2.5 [Software Engineering]: Testing and Debugging| symbolic execution; D.3.3 [Programming Languages]: Language Constructs and Features| data types and structures; dynamic storage management ; D.3.4 [Programming Languages]: Processors|optimization; E.1 [Data]: Data Structures|graphs; lists; trees; E.2 [Data]: Data Storage Representations|composite structures; linked representations; F.3.1 [Logics and Meanings of Programs]: Specifying and Verifying and Reasoning about Programs|assertions; invariants; mechanical verification; F.3.3 [Logics and Meanings of Programs]: Studies of Program Constructs|type structure; F.4.1 [Mathematical Logic and Formal Languages]: Mathematical Logic|mechanical theorem proving 
Abstract-found: 1
Intro-found: 1
Reference: [AW93] <author> U. Assmann and M. Weinhardt. </author> <title> Interprocedural heap analysis for parallelizing imperative programs. </title> <editor> In W. K. Giloi, S. Jahnichen, and B. D. Shriver, editors, </editor> <booktitle> Programming Models For Massively Parallel Computers, </booktitle> <pages> pages 74-82, </pages> <address> Washington, DC, </address> <month> September </month> <year> 1993. </year> <note> IEEE Press. </note>
Reference-contexts: In the past two decades, many "shape-analysis" algorithms have been developed that can automatically identify shape invariants in some programs that manipulate heap-allocated storage <ref> [JM81, JM82, LH88, HPR89, CWZ90, Str92, AW93, PCK93, Wan94, SRW98] </ref>. A common feature of these algorithms is that they represent multiple run-time locations by a single "shape-node", often called summary-nodes [CWZ90]. <p> The algorithm of Deutsch [Deu92, Deu94] is able to represent cyclic lists but fails to handle many kinds of destructive-update operations (due to the absence of must-alias information). * The framework creates intraprocedural shape-analysis algorithms, not interprocedural ones. Methods for handling procedures are presented in <ref> [CWZ90, AW93, SRW98] </ref>. Because these are instances of the framework, their methods for handling procedures should generalize to the parametric case. * The number of possible shape-nodes that may arise during abstract interpretation is potentially exponential in the size of the specification.
Reference: [CC79] <author> P. Cousot and R. Cousot. </author> <title> Systematic design of program analysis frameworks. </title> <booktitle> In ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 269-282, </pages> <address> New York, NY, 1979. </address> <publisher> ACM Press. </publisher>
Reference-contexts: In contrast to the other two operations, coerce does not depend on the particular statement st; it can be applied at any step (e.g., right after focus and before [[st]]) and may improve precision. It is worthwhile noting that both focus and coerce are semantic-reduction operations (originally defined in <ref> [CC79] </ref>). That is, they convert a set of three-valued structures into a more precise set of structures that describe the same set of stores.
Reference: [CWZ90] <author> D.R. Chase, M. Wegman, and F. Zadeck. </author> <title> Analysis of pointers and structures. </title> <booktitle> In SIGPLAN Conference on Programming Languages Design and Implementation, </booktitle> <pages> pages 296-310, </pages> <address> New York, NY, 1990. </address> <publisher> ACM Press. </publisher> <pages> 39 </pages>
Reference-contexts: In the past two decades, many "shape-analysis" algorithms have been developed that can automatically identify shape invariants in some programs that manipulate heap-allocated storage <ref> [JM81, JM82, LH88, HPR89, CWZ90, Str92, AW93, PCK93, Wan94, SRW98] </ref>. A common feature of these algorithms is that they represent multiple run-time locations by a single "shape-node", often called summary-nodes [CWZ90]. <p> A common feature of these algorithms is that they represent multiple run-time locations by a single "shape-node", often called summary-nodes <ref> [CWZ90] </ref>. One way of looking at these algorithms is that "shape graphs" are indirect representations of store invariants. 1.1 Main Results This paper presents a parametric framework for shape analysis. <p> In this case, the analysis does not know if x and y can be aliases. In Sections 2 and 4, we show how these mechanisms can be exploited to create a parametric framework for shape-analysis. This technique suffices to explain the algorithms of <ref> [JM81, HPR89, CWZ90, Str92] </ref>. 1.1.3 Materialization of New Nodes from Summary Nodes One of the magical aspects of [SRW98] is "materialization", in which a transfer function splits a summary-node into two separate nodes. (This operation is also discussed in [CWZ90, PCK93].) This turns out to be important for maintaining accuracy in <p> This technique suffices to explain the algorithms of [JM81, HPR89, CWZ90, Str92]. 1.1.3 Materialization of New Nodes from Summary Nodes One of the magical aspects of [SRW98] is "materialization", in which a transfer function splits a summary-node into two separate nodes. (This operation is also discussed in <ref> [CWZ90, PCK93] </ref>.) This turns out to be important for maintaining accuracy in the analysis of loops that advance pointers through data structures. The parametric framework provides insight into the workings of materialization. <p> The algorithm of Deutsch [Deu92, Deu94] is able to represent cyclic lists but fails to handle many kinds of destructive-update operations (due to the absence of must-alias information). * The framework creates intraprocedural shape-analysis algorithms, not interprocedural ones. Methods for handling procedures are presented in <ref> [CWZ90, AW93, SRW98] </ref>. Because these are instances of the framework, their methods for handling procedures should generalize to the parametric case. * The number of possible shape-nodes that may arise during abstract interpretation is potentially exponential in the size of the specification. <p> This problem was avoided in <ref> [LH88, CWZ90, PCK93, SRW98] </ref> by keeping a single merged shape graph at every point. This measure has not been employed in this paper in order to simplify the presentation. 1.3 Organization of the Paper We explain our work by presenting two versions of the shape-analysis framework. <p> The shape-analysis algorithm illustrated in Table 2 is essentially that of Chase et al. <ref> [CWZ90] </ref>. Others that are amenable to being simulated in this fashion include [JM81, LH88, HPR89]. Unfortunately, there is also bad news: The method described above and illustrated in Table 2 can be very imprecise. <p> Pred. Intended Meaning Purpose Ref. is (v) Do two or more fields of heap elements lists and trees <ref> [CWZ90, SRW98] </ref> point to v? r (v) Is v reachable from some pointer variable compile-time (i.e., is v a non-garbage element)? garbage collection r x (v) Is v (transitively) reachable from pointer separating disjoint [SRW98, p.38] variable x? data structures c (v) Is v on a directed cycle? reference counting [JM81] <p> S 0 2 represents lists of exactly two elements (but not lists of length three or more). 2 Table 4 lists some interesting instrumentation predicates, and Table 5 lists their defining formulae. * The sharing predicate is was introduced in <ref> [CWZ90] </ref> and also used in [SRW98] to capture list and tree data structures. * The reachability predicate r identifies non-garbage cells. This is useful for determining when compile-time garbage collection can be performed. * The reachability-from-x predicate r x was mentioned in [SRW98, p.38]. <p> Because of this, most pointer-analysis algorithms resort to imprecise approaches in many cases, such as performing weak updates (i.e., n edges emanating from the shape-node that x points to are accumulated) <ref> [LH88, CWZ90] </ref>. * The (three-valued) interpretation of different predicate symbols may be related. For example, heap sharing (i.e., predicate is) constrains the number of incoming selector edges (i.e., predicate n); conversely, the number of incoming selector edges constrains heap sharing.
Reference: [Deu92] <author> A. Deutsch. </author> <title> A storeless model for aliasing and its abstractions using finite representations of right-regular equivalence relations. </title> <booktitle> In IEEE International Conference on Computer Languages, </booktitle> <pages> pages 2-13, </pages> <address> Washington, DC, 1992. </address> <publisher> IEEE Press. </publisher>
Reference-contexts: Other static-analysis techniques (including ones that are not based on shape graphs <ref> [LR91, Hen90, HN90, Deu92, Deu94] </ref>) yield very imprecise information on these programs. 1.1.1 The Use of Logic for Shape Analysis In the shape-analysis framework, predicate-logic formulae play many roles: expressing both the concrete and abstract semantics of the programming language, specifying the parameters used for instantiating the parametric framework in different <p> For example, the algorithm of [Hen90, HN90] handles destructive updates in many cases, but does not handle cyclic or doubly-linked lists. The algorithm of Deutsch <ref> [Deu92, Deu94] </ref> is able to represent cyclic lists but fails to handle many kinds of destructive-update operations (due to the absence of must-alias information). * The framework creates intraprocedural shape-analysis algorithms, not interprocedural ones. Methods for handling procedures are presented in [CWZ90, AW93, SRW98].
Reference: [Deu94] <author> A. Deutsch. </author> <title> Interprocedural may-alias analysis for pointers: Beyond k-limiting. </title> <booktitle> In SIGPLAN Conference on Programming Languages Design and Implementation, </booktitle> <pages> pages 230-241, </pages> <address> New York, NY, 1994. </address> <publisher> ACM Press. </publisher>
Reference-contexts: Other static-analysis techniques (including ones that are not based on shape graphs <ref> [LR91, Hen90, HN90, Deu92, Deu94] </ref>) yield very imprecise information on these programs. 1.1.1 The Use of Logic for Shape Analysis In the shape-analysis framework, predicate-logic formulae play many roles: expressing both the concrete and abstract semantics of the programming language, specifying the parameters used for instantiating the parametric framework in different <p> For example, the algorithm of [Hen90, HN90] handles destructive updates in many cases, but does not handle cyclic or doubly-linked lists. The algorithm of Deutsch <ref> [Deu92, Deu94] </ref> is able to represent cyclic lists but fails to handle many kinds of destructive-update operations (due to the absence of must-alias information). * The framework creates intraprocedural shape-analysis algorithms, not interprocedural ones. Methods for handling procedures are presented in [CWZ90, AW93, SRW98].
Reference: [Eva96] <author> D. Evans. </author> <title> Static detection of dynamic memory errors. </title> <booktitle> In SIGPLAN Conference on Programming Languages Design and Implementation, </booktitle> <year> 1996. </year> <note> Available at "http://larch-www.lcs.mit.edu:8001/~ evs/pldi96-abstract.html". </note>
Reference-contexts: These invariants are usually not preserved by the execution of individual program statements, and it is challenging to prove that invariants are reestablished once a sequence of operations is finished [Hoa75]. Such invariants are useful for sharpening the results obtained from a tool like LClint, which predicts memory-usage bugs <ref> [Eva96] </ref>, and for program optimization (e.g., to improve memory locality [LM96]). In the past two decades, many "shape-analysis" algorithms have been developed that can automatically identify shape invariants in some programs that manipulate heap-allocated storage [JM81, JM82, LH88, HPR89, CWZ90, Str92, AW93, PCK93, Wan94, SRW98].
Reference: [Gin88] <author> M.L. Ginsberg. </author> <title> Multivalued logics: A uniform approach to inference in artificial intelligence. </title> <journal> Computer Intelligence, </journal> <volume> 4 </volume> <pages> 265-316, </pages> <year> 1988. </year>
Reference-contexts: The values 0, 1, and 1=2 form a mathematical structure known as a bi-lattice, e.g., <ref> [Gin88] </ref>, as shown in Figure 4. A bi-lattice has two orderings: the logical order and the information order.
Reference: [Hen90] <author> L. Hendren. </author> <title> Parallelizing Programs with Recursive Data Structures. </title> <type> PhD thesis, </type> <institution> Cornell University, </institution> <address> Ithaca, N.Y., </address> <month> Jan </month> <year> 1990. </year>
Reference-contexts: Other static-analysis techniques (including ones that are not based on shape graphs <ref> [LR91, Hen90, HN90, Deu92, Deu94] </ref>) yield very imprecise information on these programs. 1.1.1 The Use of Logic for Shape Analysis In the shape-analysis framework, predicate-logic formulae play many roles: expressing both the concrete and abstract semantics of the programming language, specifying the parameters used for instantiating the parametric framework in different <p> In Section 5.2.3, we give an algorithm that solves systems of such constraints. 1.2 Limitations The results reported in the paper are limited in the following ways: * There are other algorithms|not based on shape graphs|that are incomparable to our method. For example, the algorithm of <ref> [Hen90, HN90] </ref> handles destructive updates in many cases, but does not handle cyclic or doubly-linked lists.
Reference: [HHN92] <author> L. Hendren, J. Hummel, and A. Nicolau. </author> <title> Abstractions for recursive pointer data structures: Improving the analysis and the transformation of imperative programs. </title> <booktitle> In SIGPLAN Conference on Programming Languages Design and Implementation, </booktitle> <pages> pages 249-260, </pages> <address> New York, NY, June 1992. </address> <publisher> ACM Press. </publisher>
Reference-contexts: variable compile-time (i.e., is v a non-garbage element)? garbage collection r x (v) Is v (transitively) reachable from pointer separating disjoint [SRW98, p.38] variable x? data structures c (v) Is v on a directed cycle? reference counting [JM81] c f:b (v) Does a field-f dereference from v, followed doubly-linked lists <ref> [HHN92, PCK93] </ref> by a field-b deference, yield v? c b:f (v) Does a field-b dereference from v, followed doubly-linked lists [HHN92, PCK93] by a field-f deference, yield v? Table 4: Examples of instrumentation predicates. of "summary-nodes", which were introduced by Jones and Muchnick [JM81] to represent an unbounded number of concrete <p> disjoint [SRW98, p.38] variable x? data structures c (v) Is v on a directed cycle? reference counting [JM81] c f:b (v) Does a field-f dereference from v, followed doubly-linked lists <ref> [HHN92, PCK93] </ref> by a field-b deference, yield v? c b:f (v) Does a field-b dereference from v, followed doubly-linked lists [HHN92, PCK93] by a field-f deference, yield v? Table 4: Examples of instrumentation predicates. of "summary-nodes", which were introduced by Jones and Muchnick [JM81] to represent an unbounded number of concrete elements by a single abstract element. <p> This idea was introduced in <ref> [HHN92] </ref> and also used in [PCK93]. In the general case, a program uses a number of different struct types.
Reference: [HN90] <author> L. Hendren and A. Nicolau. </author> <title> Parallelizing programs with recursive data structures. </title> <journal> IEEE Transactions on Parallel and Distributed Systems, </journal> <volume> 1(1) </volume> <pages> 35-47, </pages> <month> January </month> <year> 1990. </year>
Reference-contexts: Other static-analysis techniques (including ones that are not based on shape graphs <ref> [LR91, Hen90, HN90, Deu92, Deu94] </ref>) yield very imprecise information on these programs. 1.1.1 The Use of Logic for Shape Analysis In the shape-analysis framework, predicate-logic formulae play many roles: expressing both the concrete and abstract semantics of the programming language, specifying the parameters used for instantiating the parametric framework in different <p> In Section 5.2.3, we give an algorithm that solves systems of such constraints. 1.2 Limitations The results reported in the paper are limited in the following ways: * There are other algorithms|not based on shape graphs|that are incomparable to our method. For example, the algorithm of <ref> [Hen90, HN90] </ref> handles destructive updates in many cases, but does not handle cyclic or doubly-linked lists.
Reference: [Hoa75] <author> C.A.R. Hoare. </author> <title> Recursive data structures. </title> <journal> International Journal of Computer and Information Sciences, </journal> <volume> 4(2) </volume> <pages> 105-132, </pages> <year> 1975. </year>
Reference-contexts: These invariants are usually not preserved by the execution of individual program statements, and it is challenging to prove that invariants are reestablished once a sequence of operations is finished <ref> [Hoa75] </ref>. Such invariants are useful for sharpening the results obtained from a tool like LClint, which predicts memory-usage bugs [Eva96], and for program optimization (e.g., to improve memory locality [LM96]).
Reference: [HPR89] <author> S. Horwitz, P. Pfeiffer, and T. Reps. </author> <title> Dependence analysis for pointer variables. </title> <booktitle> In SIGPLAN Conference on Programming Languages Design and Implementation, </booktitle> <pages> pages 28-40, </pages> <address> New York, NY, 1989. </address> <publisher> ACM Press. </publisher>
Reference-contexts: In the past two decades, many "shape-analysis" algorithms have been developed that can automatically identify shape invariants in some programs that manipulate heap-allocated storage <ref> [JM81, JM82, LH88, HPR89, CWZ90, Str92, AW93, PCK93, Wan94, SRW98] </ref>. A common feature of these algorithms is that they represent multiple run-time locations by a single "shape-node", often called summary-nodes [CWZ90]. <p> In this case, the analysis does not know if x and y can be aliases. In Sections 2 and 4, we show how these mechanisms can be exploited to create a parametric framework for shape-analysis. This technique suffices to explain the algorithms of <ref> [JM81, HPR89, CWZ90, Str92] </ref>. 1.1.3 Materialization of New Nodes from Summary Nodes One of the magical aspects of [SRW98] is "materialization", in which a transfer function splits a summary-node into two separate nodes. (This operation is also discussed in [CWZ90, PCK93].) This turns out to be important for maintaining accuracy in <p> (List x) f List y, t; assert (acyclic list (x)); y = NULL; while (x != NULL) f t = y; x = x-&gt;n; g return y; g updating to reverse the list pointed to by parameter x. * The number of shape graphs may be quite large (as in <ref> [JM81, HPR89] </ref>). This problem was avoided in [LH88, CWZ90, PCK93, SRW98] by keeping a single merged shape graph at every point. <p> The shape-analysis algorithm illustrated in Table 2 is essentially that of Chase et al. [CWZ90]. Others that are amenable to being simulated in this fashion include <ref> [JM81, LH88, HPR89] </ref>. Unfortunately, there is also bad news: The method described above and illustrated in Table 2 can be very imprecise. For instance, statement st 4 sets x to x-&gt;n; i.e., it makes x point to the next element in the list.
Reference: [JM81] <editor> N.D. Jones and S.S. Muchnick. </editor> <title> Flow analysis and optimization of Lisp-like structures. </title> <editor> In S.S. Muchnick and N.D. Jones, editors, </editor> <title> Program Flow Analysis: </title> <journal> Theory and Applications, </journal> <volume> chapter 4, </volume> <pages> pages 102-131. </pages> <publisher> Prentice-Hall, </publisher> <address> Englewood Cliffs, NJ, </address> <year> 1981. </year>
Reference-contexts: In the past two decades, many "shape-analysis" algorithms have been developed that can automatically identify shape invariants in some programs that manipulate heap-allocated storage <ref> [JM81, JM82, LH88, HPR89, CWZ90, Str92, AW93, PCK93, Wan94, SRW98] </ref>. A common feature of these algorithms is that they represent multiple run-time locations by a single "shape-node", often called summary-nodes [CWZ90]. <p> In this case, the analysis does not know if x and y can be aliases. In Sections 2 and 4, we show how these mechanisms can be exploited to create a parametric framework for shape-analysis. This technique suffices to explain the algorithms of <ref> [JM81, HPR89, CWZ90, Str92] </ref>. 1.1.3 Materialization of New Nodes from Summary Nodes One of the magical aspects of [SRW98] is "materialization", in which a transfer function splits a summary-node into two separate nodes. (This operation is also discussed in [CWZ90, PCK93].) This turns out to be important for maintaining accuracy in <p> (List x) f List y, t; assert (acyclic list (x)); y = NULL; while (x != NULL) f t = y; x = x-&gt;n; g return y; g updating to reverse the list pointed to by parameter x. * The number of shape graphs may be quite large (as in <ref> [JM81, HPR89] </ref>). This problem was avoided in [LH88, CWZ90, PCK93, SRW98] by keeping a single merged shape graph at every point. <p> The shape-analysis algorithm illustrated in Table 2 is essentially that of Chase et al. [CWZ90]. Others that are amenable to being simulated in this fashion include <ref> [JM81, LH88, HPR89] </ref>. Unfortunately, there is also bad news: The method described above and illustrated in Table 2 can be very imprecise. For instance, statement st 4 sets x to x-&gt;n; i.e., it makes x point to the next element in the list. <p> [CWZ90, SRW98] point to v? r (v) Is v reachable from some pointer variable compile-time (i.e., is v a non-garbage element)? garbage collection r x (v) Is v (transitively) reachable from pointer separating disjoint [SRW98, p.38] variable x? data structures c (v) Is v on a directed cycle? reference counting <ref> [JM81] </ref> c f:b (v) Does a field-f dereference from v, followed doubly-linked lists [HHN92, PCK93] by a field-b deference, yield v? c b:f (v) Does a field-b dereference from v, followed doubly-linked lists [HHN92, PCK93] by a field-f deference, yield v? Table 4: Examples of instrumentation predicates. of "summary-nodes", which were <p> field-f dereference from v, followed doubly-linked lists [HHN92, PCK93] by a field-b deference, yield v? c b:f (v) Does a field-b dereference from v, followed doubly-linked lists [HHN92, PCK93] by a field-f deference, yield v? Table 4: Examples of instrumentation predicates. of "summary-nodes", which were introduced by Jones and Muchnick <ref> [JM81] </ref> to represent an unbounded number of concrete elements by a single abstract element. There are two possible values for sm (u): * 0, when u represents a unique element. This is the case for all elements of concrete stores (because cells in a concrete store represent only themselves). <p> =) v 2 = v (9) Table 5: Formulae that define the meaning of the instrumentation predicates listed in Table 4. structures, since it keeps separate the abstract representations of data structures that are disjoint in the concrete world. * The cyclicity predicate c was introduced by Jones and Muchnick <ref> [JM81] </ref> to aid in determining when reference counting would be sufficient. * The special cyclicity predicates c f:b and c b:f are used to capture doubly-linked lists, in which forward and backward field dereferences cancel each other. This idea was introduced in [HHN92] and also used in [PCK93]. <p> Earlier, Jones and Muchnick proposed making even finer distinctions by keeping exact information on elements within a distance k from a variable <ref> [JM81] </ref>. These collapsing processes can be generalized to any fixed set of unary "abstraction properties" on individuals: Individuals are partitioned into equivalence classes according to their sets of unary abstraction-property values.
Reference: [JM82] <editor> N.D. Jones and S.S. Muchnick. </editor> <title> A flexible approach to interprocedural data flow analysis and programs with recursive data structures. </title> <booktitle> In ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 66-74, </pages> <address> New York, NY, 1982. </address> <publisher> ACM Press. </publisher>
Reference-contexts: In the past two decades, many "shape-analysis" algorithms have been developed that can automatically identify shape invariants in some programs that manipulate heap-allocated storage <ref> [JM81, JM82, LH88, HPR89, CWZ90, Str92, AW93, PCK93, Wan94, SRW98] </ref>. A common feature of these algorithms is that they represent multiple run-time locations by a single "shape-node", often called summary-nodes [CWZ90].
Reference: [Kle87] <author> S.C. Kleene. </author> <title> Introduction to Metamathematics. </title> <publisher> North-Holland, </publisher> <address> second edition, </address> <year> 1987. </year>
Reference-contexts: To express the property "program variables x and y are not may-aliases", we write the formula 8v : :(x (v) ^ y (v)): (2) 1.1.2 Shape Analysis via Three-Valued Logic We use Kleene's three-valued logic <ref> [Kle87] </ref> (which has a third truth value that signifies "unknown") to create a shape-analysis algorithm automatically from a specification. Kleene's logic is useful for 1 shape analysis because we only have partial information about summary nodes: For these nodes, predicates may have the value unknown.
Reference: [LH88] <author> J.R. Larus and P.N. Hilfinger. </author> <title> Detecting conflicts between structure accesses. </title> <booktitle> In SIGPLAN Conference on Programming Languages Design and Implementation, </booktitle> <pages> pages 21-34, </pages> <address> New York, NY, 1988. </address> <publisher> ACM Press. </publisher>
Reference-contexts: In the past two decades, many "shape-analysis" algorithms have been developed that can automatically identify shape invariants in some programs that manipulate heap-allocated storage <ref> [JM81, JM82, LH88, HPR89, CWZ90, Str92, AW93, PCK93, Wan94, SRW98] </ref>. A common feature of these algorithms is that they represent multiple run-time locations by a single "shape-node", often called summary-nodes [CWZ90]. <p> This problem was avoided in <ref> [LH88, CWZ90, PCK93, SRW98] </ref> by keeping a single merged shape graph at every point. This measure has not been employed in this paper in order to simplify the presentation. 1.3 Organization of the Paper We explain our work by presenting two versions of the shape-analysis framework. <p> The shape-analysis algorithm illustrated in Table 2 is essentially that of Chase et al. [CWZ90]. Others that are amenable to being simulated in this fashion include <ref> [JM81, LH88, HPR89] </ref>. Unfortunately, there is also bad news: The method described above and illustrated in Table 2 can be very imprecise. For instance, statement st 4 sets x to x-&gt;n; i.e., it makes x point to the next element in the list. <p> Because of this, most pointer-analysis algorithms resort to imprecise approaches in many cases, such as performing weak updates (i.e., n edges emanating from the shape-node that x points to are accumulated) <ref> [LH88, CWZ90] </ref>. * The (three-valued) interpretation of different predicate symbols may be related. For example, heap sharing (i.e., predicate is) constrains the number of incoming selector edges (i.e., predicate n); conversely, the number of incoming selector edges constrains heap sharing.
Reference: [LM96] <author> C.-K. Luk and T.C. Mowry. </author> <title> Compiler-based prefetching for recursive data structures. </title> <booktitle> In Proceedings of the Seventh International Conference on Architectural Support for Programming Languages and Operating Systems, </booktitle> <pages> pages 222-233, </pages> <month> October </month> <year> 1996. </year>
Reference-contexts: Such invariants are useful for sharpening the results obtained from a tool like LClint, which predicts memory-usage bugs [Eva96], and for program optimization (e.g., to improve memory locality <ref> [LM96] </ref>). In the past two decades, many "shape-analysis" algorithms have been developed that can automatically identify shape invariants in some programs that manipulate heap-allocated storage [JM81, JM82, LH88, HPR89, CWZ90, Str92, AW93, PCK93, Wan94, SRW98]. <p> This information can be used by an optimizing compiler to determine whether it is profitable to generate a prefetch for the next element <ref> [LM96] </ref>.
Reference: [LR91] <author> W. Landi and B.G. Ryder. </author> <title> Pointer induced aliasing: A problem classification. </title> <booktitle> In ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 93-103, </pages> <address> New York, NY, </address> <month> January </month> <year> 1991. </year> <note> ACM Press. </note>
Reference-contexts: Other static-analysis techniques (including ones that are not based on shape graphs <ref> [LR91, Hen90, HN90, Deu92, Deu94] </ref>) yield very imprecise information on these programs. 1.1.1 The Use of Logic for Shape Analysis In the shape-analysis framework, predicate-logic formulae play many roles: expressing both the concrete and abstract semantics of the programming language, specifying the parameters used for instantiating the parametric framework in different
Reference: [PCK93] <author> J. Plevyak, A.A. Chien, and V. Karamcheti. </author> <title> Analysis of dynamic structures for efficient parallel execution. </title> <editor> In U. Banerjee, D. Gelernter, A. Nicolau, and D. Padua, editors, </editor> <booktitle> Languages and Compilers for Parallel Computing, volume 768 of Lecture Notes in Computer Science, </booktitle> <pages> pages 37-57, </pages> <address> Portland, OR, </address> <month> August </month> <year> 1993. </year> <note> Springer-Verlag. </note>
Reference-contexts: In the past two decades, many "shape-analysis" algorithms have been developed that can automatically identify shape invariants in some programs that manipulate heap-allocated storage <ref> [JM81, JM82, LH88, HPR89, CWZ90, Str92, AW93, PCK93, Wan94, SRW98] </ref>. A common feature of these algorithms is that they represent multiple run-time locations by a single "shape-node", often called summary-nodes [CWZ90]. <p> This technique suffices to explain the algorithms of [JM81, HPR89, CWZ90, Str92]. 1.1.3 Materialization of New Nodes from Summary Nodes One of the magical aspects of [SRW98] is "materialization", in which a transfer function splits a summary-node into two separate nodes. (This operation is also discussed in <ref> [CWZ90, PCK93] </ref>.) This turns out to be important for maintaining accuracy in the analysis of loops that advance pointers through data structures. The parametric framework provides insight into the workings of materialization. <p> This problem was avoided in <ref> [LH88, CWZ90, PCK93, SRW98] </ref> by keeping a single merged shape graph at every point. This measure has not been employed in this paper in order to simplify the presentation. 1.3 Organization of the Paper We explain our work by presenting two versions of the shape-analysis framework. <p> To perform a more precise abstract interpretation of programs, we have to be able to materialize new nodes from summary nodes as the program's data structures are traversed. Plevyak et al. <ref> [PCK93] </ref> introduced a way to do materialization for straight-line code, and Sagiv et al. [SRW98] developed a way to do this in the presence of loops and recursion. However, these analyses are hard to understand and to show correct. <p> variable compile-time (i.e., is v a non-garbage element)? garbage collection r x (v) Is v (transitively) reachable from pointer separating disjoint [SRW98, p.38] variable x? data structures c (v) Is v on a directed cycle? reference counting [JM81] c f:b (v) Does a field-f dereference from v, followed doubly-linked lists <ref> [HHN92, PCK93] </ref> by a field-b deference, yield v? c b:f (v) Does a field-b dereference from v, followed doubly-linked lists [HHN92, PCK93] by a field-f deference, yield v? Table 4: Examples of instrumentation predicates. of "summary-nodes", which were introduced by Jones and Muchnick [JM81] to represent an unbounded number of concrete <p> disjoint [SRW98, p.38] variable x? data structures c (v) Is v on a directed cycle? reference counting [JM81] c f:b (v) Does a field-f dereference from v, followed doubly-linked lists <ref> [HHN92, PCK93] </ref> by a field-b deference, yield v? c b:f (v) Does a field-b dereference from v, followed doubly-linked lists [HHN92, PCK93] by a field-f deference, yield v? Table 4: Examples of instrumentation predicates. of "summary-nodes", which were introduced by Jones and Muchnick [JM81] to represent an unbounded number of concrete elements by a single abstract element. <p> This idea was introduced in [HHN92] and also used in <ref> [PCK93] </ref>. In the general case, a program uses a number of different struct types.
Reference: [SRW96] <author> M. Sagiv, T. Reps, and R. Wilhelm. </author> <title> Solving shape-analysis problems in languages with destructive updating. </title> <booktitle> In ACM Symposium on Principles of Programming Languages, </booktitle> <address> New York, NY, </address> <month> January </month> <year> 1996. </year> <note> ACM Press. </note>
Reference-contexts: to go beyond the simplistic approach described above in Section 2.3 by "materializing" new non-summary nodes from summary nodes as data structures are 8 S 6;0 -sm K S 6;1 u 1 y ? u:0 u:1 x abstract-interpretation method of Section 5. traversed. (Thus, Section 5 generalizes the algorithm of <ref> [SRW96] </ref>.) As we will see in Section 5, this allows us to determine the correct shape descriptors for the data structures used in the reverse program. <p> Notice that individual u of U S 2 also represents unreachable elements (i.e., uncollected garbage). Thus, this structure can actually represent a list with one element and one or more garbage cells. It is possible to change the definition of embeddings (abstractions) to explicitly exclude garbage cells (see <ref> [SRW96] </ref>). An alternative is to use an additional instrumentation predicate, r, defined by formula (5), to maintain reachability information explicitly. For every program statement, there would be a predicate-update formula to update r.
Reference: [SRW98] <author> M. Sagiv, T. Reps, and R. Wilhelm. </author> <title> Solving shape-analysis problems in languages with destructive updating. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 20(1) </volume> <pages> 1-50, </pages> <month> January </month> <year> 1998. </year>
Reference-contexts: In the past two decades, many "shape-analysis" algorithms have been developed that can automatically identify shape invariants in some programs that manipulate heap-allocated storage <ref> [JM81, JM82, LH88, HPR89, CWZ90, Str92, AW93, PCK93, Wan94, SRW98] </ref>. A common feature of these algorithms is that they represent multiple run-time locations by a single "shape-node", often called summary-nodes [CWZ90]. <p> In Sections 2 and 4, we show how these mechanisms can be exploited to create a parametric framework for shape-analysis. This technique suffices to explain the algorithms of [JM81, HPR89, CWZ90, Str92]. 1.1.3 Materialization of New Nodes from Summary Nodes One of the magical aspects of <ref> [SRW98] </ref> is "materialization", in which a transfer function splits a summary-node into two separate nodes. (This operation is also discussed in [CWZ90, PCK93].) This turns out to be important for maintaining accuracy in the analysis of loops that advance pointers through data structures. <p> It shows that the essence of materialization involves a step (called focus , discussed in Section 5.1) that forces the values of certain formulae from unknown to true or false. This has the effect of converting a shape graph into one with finer distinctions. In <ref> [SRW98] </ref>, it was observed that node materialization is complicated because various kinds of shape-graph properties are linked. For instance, the heap-sharing properties of shape graphs constrain the sets of potential aliases, and vice versa. <p> The algorithm of Deutsch [Deu92, Deu94] is able to represent cyclic lists but fails to handle many kinds of destructive-update operations (due to the absence of must-alias information). * The framework creates intraprocedural shape-analysis algorithms, not interprocedural ones. Methods for handling procedures are presented in <ref> [CWZ90, AW93, SRW98] </ref>. Because these are instances of the framework, their methods for handling procedures should generalize to the parametric case. * The number of possible shape-nodes that may arise during abstract interpretation is potentially exponential in the size of the specification. <p> This problem was avoided in <ref> [LH88, CWZ90, PCK93, SRW98] </ref> by keeping a single merged shape graph at every point. This measure has not been employed in this paper in order to simplify the presentation. 1.3 Organization of the Paper We explain our work by presenting two versions of the shape-analysis framework. <p> The reverse program allows us to demonstrate many aspects of the shape-analysis framework in a nontrivial, but still relatively digestible, fashion. 2.1 Representing Stores via Three-Valued Structures The standard logical interpretation used in many of the classical dataflow-analysis algorithms, as well as in shape analysis <ref> [SRW98] </ref>, uses two values. It is definite on one of the values and conservative on the other. That is, either "false" means "false" and "true" means "may be true/may be false, or "true" means "true" and "false" means "may be false/may be true". <p> To perform a more precise abstract interpretation of programs, we have to be able to materialize new nodes from summary nodes as the program's data structures are traversed. Plevyak et al. [PCK93] introduced a way to do materialization for straight-line code, and Sagiv et al. <ref> [SRW98] </ref> developed a way to do this in the presence of loops and recursion. However, these analyses are hard to understand and to show correct. <p> Pred. Intended Meaning Purpose Ref. is (v) Do two or more fields of heap elements lists and trees <ref> [CWZ90, SRW98] </ref> point to v? r (v) Is v reachable from some pointer variable compile-time (i.e., is v a non-garbage element)? garbage collection r x (v) Is v (transitively) reachable from pointer separating disjoint [SRW98, p.38] variable x? data structures c (v) Is v on a directed cycle? reference counting [JM81] <p> Meaning Purpose Ref. is (v) Do two or more fields of heap elements lists and trees [CWZ90, SRW98] point to v? r (v) Is v reachable from some pointer variable compile-time (i.e., is v a non-garbage element)? garbage collection r x (v) Is v (transitively) reachable from pointer separating disjoint <ref> [SRW98, p.38] </ref> variable x? data structures c (v) Is v on a directed cycle? reference counting [JM81] c f:b (v) Does a field-f dereference from v, followed doubly-linked lists [HHN92, PCK93] by a field-b deference, yield v? c b:f (v) Does a field-b dereference from v, followed doubly-linked lists [HHN92, PCK93] <p> S 0 2 represents lists of exactly two elements (but not lists of length three or more). 2 Table 4 lists some interesting instrumentation predicates, and Table 5 lists their defining formulae. * The sharing predicate is was introduced in [CWZ90] and also used in <ref> [SRW98] </ref> to capture list and tree data structures. * The reachability predicate r identifies non-garbage cells. This is useful for determining when compile-time garbage collection can be performed. * The reachability-from-x predicate r x was mentioned in [SRW98, p.38]. <p> This is useful for determining when compile-time garbage collection can be performed. * The reachability-from-x predicate r x was mentioned in <ref> [SRW98, p.38] </ref>. <p> This alternative yields bounded structures that have a smaller number of individuals, but may decrease the precision of the shape-analysis algorithm. For instance, canonical abstraction is a generalization of the abstraction function used in <ref> [SRW98] </ref>. 7 The only abstraction predicates used in [SRW98] are the "pointed-to-by-x" predicates. Because sharing predicate is is used only as an instrumentation predicate in [SRW98], but not as an abstraction predicate, the algorithm from [SRW98] does not distinguish between shared and unshared individuals, and thus loses accuracy for stores that <p> This alternative yields bounded structures that have a smaller number of individuals, but may decrease the precision of the shape-analysis algorithm. For instance, canonical abstraction is a generalization of the abstraction function used in <ref> [SRW98] </ref>. 7 The only abstraction predicates used in [SRW98] are the "pointed-to-by-x" predicates. Because sharing predicate is is used only as an instrumentation predicate in [SRW98], but not as an abstraction predicate, the algorithm from [SRW98] does not distinguish between shared and unshared individuals, and thus loses accuracy for stores that contain a shared heap cell that is not <p> For instance, canonical abstraction is a generalization of the abstraction function used in <ref> [SRW98] </ref>. 7 The only abstraction predicates used in [SRW98] are the "pointed-to-by-x" predicates. Because sharing predicate is is used only as an instrumentation predicate in [SRW98], but not as an abstraction predicate, the algorithm from [SRW98] does not distinguish between shared and unshared individuals, and thus loses accuracy for stores that contain a shared heap cell that is not directly pointed to by a variable. <p> For instance, canonical abstraction is a generalization of the abstraction function used in <ref> [SRW98] </ref>. 7 The only abstraction predicates used in [SRW98] are the "pointed-to-by-x" predicates. Because sharing predicate is is used only as an instrumentation predicate in [SRW98], but not as an abstraction predicate, the algorithm from [SRW98] does not distinguish between shared and unshared individuals, and thus loses accuracy for stores that contain a shared heap cell that is not directly pointed to by a variable. <p> Remark. The term "canonical abstraction" was chosen as a reminder that t embed c is a generalization of the abstraction functions that have been used in some of the previous work on shape analysis. As mentioned in the Introduction, an idea that has been used in <ref> [Wan94, SRW98] </ref> to embed unbounded-size stores into bounded-size abstractions is to collapse concrete elements that are not directly pointed to by program variables into one abstract element, whereas concrete elements that are pointed to by different sets of variables are kept apart in different abstract elements. <p> First, we define the Hoare order on sets of structures that is induced by the embedding order. (The shape-analysis algorithm is defined as a least-fixed point with respect to this order.) 7 The shape-analysis algorithm presented in <ref> [SRW98] </ref> is described in terms of Storage Shape Graphs (SSGs), not bounded structures. <p> This case captures the essence of node materialization as described in <ref> [SRW98] </ref>: individual u is bifurcated into two individuals. <p> The call on auxiliary function Expand creates a structure in which individual u is bifurcated into two individuals; this captures the essence of shape-node materialization (cf. <ref> [SRW98] </ref>). Example 5.10 Consider the application of Focus to the structure S 5 from Figure 7 and the formula ' st 4 x . <p> x (v) tracks the property "Is v reachable from pointer variable x?" These instrumentation predicates drastically improve the precision of shape analysis, even for programs that manipulate simple list and tree data structures, because they keep separate the abstract representations of data structures that are disjoint in the concrete world <ref> [SRW98, p.38] </ref>. In addition to supplying the definition of formula ' r x (v), in order to instantiate the shape-analysis framework with the r x predicates, it is necessary to supply predicate-update formulae that specify how each kind of statement causes the value of r x to change.
Reference: [Str92] <author> J. Stransky. </author> <title> A lattice for abstract interpretation of dynamic (Lisp-like) structures. </title> <journal> Information and Computation, </journal> <volume> 101(1) </volume> <pages> 70-102, </pages> <month> November </month> <year> 1992. </year>
Reference-contexts: In the past two decades, many "shape-analysis" algorithms have been developed that can automatically identify shape invariants in some programs that manipulate heap-allocated storage <ref> [JM81, JM82, LH88, HPR89, CWZ90, Str92, AW93, PCK93, Wan94, SRW98] </ref>. A common feature of these algorithms is that they represent multiple run-time locations by a single "shape-node", often called summary-nodes [CWZ90]. <p> In this case, the analysis does not know if x and y can be aliases. In Sections 2 and 4, we show how these mechanisms can be exploited to create a parametric framework for shape-analysis. This technique suffices to explain the algorithms of <ref> [JM81, HPR89, CWZ90, Str92] </ref>. 1.1.3 Materialization of New Nodes from Summary Nodes One of the magical aspects of [SRW98] is "materialization", in which a transfer function splits a summary-node into two separate nodes. (This operation is also discussed in [CWZ90, PCK93].) This turns out to be important for maintaining accuracy in
Reference: [Wan94] <author> E. Y.-B. Wang. </author> <title> Analysis of Recursive Types in an Imperative Language. </title> <type> PhD thesis, </type> <institution> University of California, Berkeley, </institution> <address> CA, </address> <year> 1994. </year> <month> 40 </month>
Reference-contexts: In the past two decades, many "shape-analysis" algorithms have been developed that can automatically identify shape invariants in some programs that manipulate heap-allocated storage <ref> [JM81, JM82, LH88, HPR89, CWZ90, Str92, AW93, PCK93, Wan94, SRW98] </ref>. A common feature of these algorithms is that they represent multiple run-time locations by a single "shape-node", often called summary-nodes [CWZ90]. <p> Remark. The term "canonical abstraction" was chosen as a reminder that t embed c is a generalization of the abstraction functions that have been used in some of the previous work on shape analysis. As mentioned in the Introduction, an idea that has been used in <ref> [Wan94, SRW98] </ref> to embed unbounded-size stores into bounded-size abstractions is to collapse concrete elements that are not directly pointed to by program variables into one abstract element, whereas concrete elements that are pointed to by different sets of variables are kept apart in different abstract elements.
References-found: 23

