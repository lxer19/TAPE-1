URL: http://www.cs.utah.edu/~ganesh/cs611-notes/notes/notes/notes/notes/l20/mcq/report.ps.gz
Refering-URL: http://www.cs.utah.edu/~ganesh/cs611-notes/notes/notes/notes/notes/l20/mcq/
Root-URL: 
Email: veripc@jensen.cs.utah.edu  
Author: Patrick Tullmann Godmar Back Ajay Chitturi John McCorquodale Jeff Turner 
Note: Contents  
Date: November 27, 1996  
Abstract: Fluke IPC Verification Project Report Abstract We have formally described and modeled the reliable Interprocess Communication (IPC) as implemented in the Fluke operating system[4]. With this model we were able to verify certain properties, such as freedom of deadlock, under a number of test scenarios. We have also provided a base of documentation and infrastructure for formal verification of other areas of Fluke. Our model tries to follow closely the actual C implementation of the IPC system, allowing us to make strong claims about the actual system, as opposed to claims simply about the design. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> T. Cattel. </author> <title> Modelling and verification of a multiprocessor realtime OS kernel. </title> <booktitle> In Proceedings of the Seventh International Conference on Formal Description Techniques, </booktitle> <month> Oct. </month> <year> 1994. </year>
Reference-contexts: We examine these briefly here, paying particular attention to difficulties and inflexibilities in these other approaches which have been specifically addressed by the Fluke IPC verification effort. 5.1.1 Harmony Cattel <ref> [1] </ref> performed a SPIN-based verification of the Harmony operating system, a "portable real-time multitasking multiprocess operating system" developed by the Canadian National Research Council in the 1980's and early 1990's. Cattel's effort sought to verify properties of Harmony as a whole, and attempted to model all kernel services.
Reference: [2] <author> G. Duval and J. Julliand. </author> <title> Modeling and verification of the RUBIS -Kernel with SPIN. </title> <booktitle> In Proceedings of the First SPIN Workshop, </booktitle> <month> Oct. </month> <year> 1995. </year> <month> 19 </month>
Reference-contexts: We ultimately envision processes which nondeterministically try all allowed high-level operations, so that we are sure to explore all possible user errors, in addition to reasonable interleavings of operations. 5.1.2 RUBIS Duval and Julliand utilitized SPIN to model the intertask communication facilities of the RUBIS microkernel <ref> [2] </ref>. Like our effort, theirs sought to build and exhaustively test usage scenarios. However, their effort placed emphasis on formally expressing mappings between implementation source code and Promela code via a collection of transformation rules.
Reference: [3] <author> B. Ford, M. Hibler, </author> <title> and Flux Project Members. Fluke: Flexible -kernel Environment (draft documents). </title> <institution> University of Utah. </institution> <note> Postscript and HTML available under http://www.cs.utah.edu/- projects/flux/fluke/html/, </note> <year> 1996. </year>
Reference-contexts: Two other forms of IPC in Fluke, One-way and Idempotent, are described in <ref> [3] </ref>. Reliable IPC is the mechanism Fluke provides for general, high-performance, reliable, protected communication. Reliable IPC in Fluke operates in a stream-oriented model, in which two threads connect to each other directly and can send data to each other as if through a pipe.
Reference: [4] <author> B. Ford, M. Hibler, J. Lepreau, P. Tullmann, G. Back, and S. Clawson. </author> <title> Microkernels meet recursive virtual machines. </title> <booktitle> In Proc. of the Second Symp. on Operating Systems Design and Implementation, </booktitle> <address> Seattle, WA, Oct. 1996. </address> <publisher> USENIX Assoc. </publisher>
Reference-contexts: 1 Introduction Fluke is a microkernel implemented in an object-based spirit. Fluke operations are made available as methods on a collection of primitive Fluke objects such as threads, ports, memory regions, mutexes, condition variables, and others. Fluke's high-level organizing pattern is that of recursive virtual machines or nested processes <ref> [4] </ref>. Nested processes communicate via the low-level Fluke inter-thread communications facility, called Fluke IPC, to provide a virtual machine abstraction. Fluke allows the kernel state of an object to be exported at any time [7]. This even holds for long-running kernel operations in which an object may be involved.
Reference: [5] <author> G. Holzmann. </author> <title> Design and Validation of Computer Protocols. </title> <publisher> Prentice-Hall, </publisher> <year> 1991. </year> <title> [6] makehtml. The source code to the fluke operating system written in C (HTML format). </title> <address> file://home/css/grad/gback/CVS/flukehtml/kernel/main.c.html, </address> <year> 1996. </year>
Reference-contexts: The achievements of this effort are threefold. First, we have reverse-engineered a descriptive model of the Fluke IPC subsystem from the current C implementation. Second, we used this descriptive model to develop a checkable model of the reliable IPC subsystem in Promela <ref> [5] </ref> which we present in sections 2 and 3. Lastly, we have begun evaluating the performance of this model under various realistic scenarios with encouraging results, as presented in section 4. This section we also describe our experiences with SPIN and list some perceived shortcomings.
Reference: [7] <author> P. Tullmann, J. Lepreau, B. Ford, and M. Hibler. </author> <title> User-level checkpointing through exportable kernel state. </title> <booktitle> In Proc. Fifth International Workshop on Object Orientation in Operating Systems, </booktitle> <address> Seattle, WA, </address> <month> Oct. </month> <year> 1996. </year> <journal> IEEE. </journal> <volume> 20 </volume>
Reference-contexts: Fluke's high-level organizing pattern is that of recursive virtual machines or nested processes [4]. Nested processes communicate via the low-level Fluke inter-thread communications facility, called Fluke IPC, to provide a virtual machine abstraction. Fluke allows the kernel state of an object to be exported at any time <ref> [7] </ref>. This even holds for long-running kernel operations in which an object may be involved. Therefore, these operations must be decomposable into smaller units that leave each object in a consistent state which can be exported.
References-found: 6

