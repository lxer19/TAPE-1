URL: http://www.cis.ohio-state.edu/~neelam/papers/behsub.ps.gz
Refering-URL: http://www.cis.ohio-state.edu/~neelam/papers/research.html
Root-URL: 
Email: e-mail: fneelam,fridellag@cis.ohio-state.edu  
Title: Enriching Behavioral Subtyping  
Author: Neelam Soundarajan and Stephen Fridella 
Date: December 1, 1997  
Address: Columbus, OH 43210  
Affiliation: Computer and Information Science The Ohio State University  
Abstract: The standard approach to dealing with OO polymorphism is to require subclasses to be behavioral subtypes of the base class. This ensures that reasoning that has been done about any client code that operates on base class objects will continue to be valid if instances of the subclasses are used in place of the base class objects. But often we are interested in stronger properties of the client code, in particular that its behavior will be appropriate to the specific subclass objects that are used, rather than just generic behavior that ignores the differences between the different subclasses. We present some examples to illustrate the problem, and propose a formal system that allows us to establish stronger properties of the client code on the basis of the richer behavior provided by the appropriate derived classes. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> P. </author> <title> America. Designing an object oriented programming language with behavioral subtyping. </title> <booktitle> In Foundations of Object-Oriented Languages, REX School/Workshop, </booktitle> <volume> LNCS 489, </volume> <pages> pages 69-90. </pages> <publisher> Springer-Verlag, </publisher> <year> 1991. </year>
Reference-contexts: The goal of this paper is to address some questions in the specification and verification of systems that use OO polymorphism. The standard approach to the problem is in terms of behavioral subtyping (see, for instance, <ref> [1, 10] </ref>). <p> Meyer [13] calls this the `open-closed' principle since the compiled code can be used as such (hence `closed'), and can also be extended by adding new derived classes (hence `open'). Other approaches such as those <ref> [1] </ref>, and [10], to reasoning about the behavior of OO code require us to deal with polymorphism essentially by ignoring the differences between the different derived classes and using only the information (about the methods in question) obtainable from the base class. <p> One criticism that may be directed against our approach is that it forces us to do case analysis of the client code on the basis of the particular type of the object on which the code is being applied, whereas approaches like those of <ref> [10, 1] </ref> do not. But note that we have to do case analysis only to the extent that we are interested in establishing additional properties beyond the ones that can be arrived at using the base class specifications.
Reference: [2] <author> L. Cardelli and P. Wegner. </author> <title> On understanding types, data abstraction, and polymorphism. </title> <journal> ACM Computing Surveys, </journal> <year> 1985. </year>
Reference-contexts: Suppose next that we have a number of derived classes D 1 ; : : : ; D n of C. Then we 1 Throughout this paper by `polymorphism', or occasionally `OO polymorphism', we mean the inclusion polymorphism of Cardelli and Wegner <ref> [2] </ref>. 1 can be sure that CC will continue to exhibit the behavior B even if objects of type D i ; i = 1; : : : ; n are used in place of the objects of type C that CC expects, provided each D i is a behavioral subtype
Reference: [3] <author> C. Chambers. </author> <title> The cecil language: specification and rationale. </title> <type> Technical report, </type> <institution> University of Washing-ton, </institution> <year> 1993. </year>
Reference-contexts: modifcation. 13 It may also be appropriate to mention here the work of Lamping and Abadi [8] in which they formalize polymorphism in a very general manner allowing method selection to depend on a variety of criteria such as on the types of all the operands (multi-methods as in Cecil <ref> [3] </ref> or CLOS [7]), or even real-time considerations (as in DROL [15]). But their focus is on formalizing how the method is chosen (by the run-time system) rather than on reasoning about behaviors.
Reference: [4] <author> K.K. Dhara and G.T. Leavens. </author> <title> Forcing behavioral subtyping through specification inheritance. </title> <booktitle> In ICSE-18, </booktitle> <pages> pages 27-51. </pages> <publisher> Springer-Verlag. </publisher>
Reference-contexts: The problem has been noticed by other authors see, for instance, Dhara and Leavens <ref> [4] </ref>. They consider an example consisting of a base class BankAccount and a derived class PlusAccount. <p> We also briefly discuss how our approach can be used for the example from <ref> [4] </ref>. In section 4 we summarize the motivation behind our approach, and reiterate the underlying ideas. We also talk about possible extensions to the system proposed in this paper. 2 2 Specializing Behavior In section 2.1 we introduce our notation for specifying the behavior of base and derived classes. <p> At the end of the section we will also briefly consider the bank account problem from <ref> [4] </ref>. Consider an application which allows users to define, draw, and manipulate many different types of graphical objects on the screen. These objects may include not only basic shapes such as circles, squares, and rectangles, but also more complicated screen entities such as splines, character strings etc. <p> If, on the other hand, we knew that CC was being applied to a Rectangle object, we would similarly be able to specify and verify the behavior appropriate to that case. Let us now briefly consider the bank account example from <ref> [4] </ref>. The example consists of a base class BankAccount and a derived class PlusAccount. Conceptually BankAccount objects have a single balance called credit, while PlusAccount objects have two, one corresponding to the balance in the checking portion of the account, the other corresponding to the savings portion. <p> Dhara and Leavens observe that this is not possible using just behavioral subtyping; as we noted earlier though, this problem is not the focus of <ref> [4] </ref>. 4 Discussion Polymorphism is one of the most important ideas underlying the OO approach. <p> the effect of any method on the base class portion of the conceptual model must be consistent with the base class specification of the method; in this sense our work is an extension of the behavioral subtyping approach. 11 11 The formalisms of [10, 11], as well as that of <ref> [4] </ref>, allow a slightly more general relation between the base class model and the derived class model. <p> It is worth reiterating that although our approach is influenced by the model of inheritance-based poly-morphism in languages like Eiffel and C++, the approach (like those of <ref> [10, 4] </ref> etc.) is applicable also in cases where polymorphism works on a different basis such as the interface inheritance of Java.
Reference: [5] <author> C. Horstmann. </author> <title> Mastering Object-Oriented Design in C++. </title> <publisher> Wiley, </publisher> <year> 1995. </year>
Reference-contexts: how do we specify and verify the behavior of such application code? Since our focus in this paper is on dealing with client code, rather than in showing that implementations of classes meet their specifications, we will only give the specifications of the classes; the interested reader may refer to <ref> [5] </ref> for one possible implementation of the various classes we consider.
Reference: [6] <author> C. Jones. </author> <title> Systematic Software Development Using VDM. </title> <publisher> Prentice-Hall, </publisher> <year> 1990. </year>
Reference-contexts: All of this is fairly standard, see for instance the text by Jones <ref> [6] </ref>. The derived class will similarly have a concrete specification. As discussed in [14], part of this specification can be inherited from the concrete specification of the base class.
Reference: [7] <author> S. E. Keene. </author> <title> Object-Oriented Programming in Common Lisp. </title> <publisher> Addison-Wesley, </publisher> <year> 1989. </year>
Reference-contexts: may also be appropriate to mention here the work of Lamping and Abadi [8] in which they formalize polymorphism in a very general manner allowing method selection to depend on a variety of criteria such as on the types of all the operands (multi-methods as in Cecil [3] or CLOS <ref> [7] </ref>), or even real-time considerations (as in DROL [15]). But their focus is on formalizing how the method is chosen (by the run-time system) rather than on reasoning about behaviors.
Reference: [8] <author> J. Lamping and M. Abadi. </author> <title> Methods as assertions. </title> <booktitle> In ECOOP, </booktitle> <pages> pages 60-80, </pages> <year> 1994. </year>
Reference-contexts: class based but is instead done on the basis of, say, delegation by the object and an object can at run-time change who it delegates a particular method to, our approach will need considerable modifcation. 13 It may also be appropriate to mention here the work of Lamping and Abadi <ref> [8] </ref> in which they formalize polymorphism in a very general manner allowing method selection to depend on a variety of criteria such as on the types of all the operands (multi-methods as in Cecil [3] or CLOS [7]), or even real-time considerations (as in DROL [15]).
Reference: [9] <author> G. Leavens and W. Weihl. </author> <title> Specification and verification of object-oriented programs using supertype abstraction. </title> <journal> Acta Informatica, </journal> <volume> 32 </volume> <pages> 705-778, </pages> <year> 1995. </year>
Reference-contexts: Thus (pc) holds at the end of CC. To formally prove this result we would simply need three applications of axiom (4) from Section 2.2, one for each method call. This result can also be established using other approaches such as those of <ref> [9, 10] </ref> since it involves reasoning only about the base class conceptual state.
Reference: [10] <author> B. Liskov and J. Wing. </author> <title> A new definition of the subtype relation. </title> <booktitle> In ECOOP, </booktitle> <year> 1993. </year>
Reference-contexts: The goal of this paper is to address some questions in the specification and verification of systems that use OO polymorphism. The standard approach to the problem is in terms of behavioral subtyping (see, for instance, <ref> [1, 10] </ref>). <p> Thus (pc) holds at the end of CC. To formally prove this result we would simply need three applications of axiom (4) from Section 2.2, one for each method call. This result can also be established using other approaches such as those of <ref> [9, 10] </ref> since it involves reasoning only about the base class conceptual state. <p> Meyer [13] calls this the `open-closed' principle since the compiled code can be used as such (hence `closed'), and can also be extended by adding new derived classes (hence `open'). Other approaches such as those [1], and <ref> [10] </ref>, to reasoning about the behavior of OO code require us to deal with polymorphism essentially by ignoring the differences between the different derived classes and using only the information (about the methods in question) obtainable from the base class. <p> contained in the base class specification, i.e., the effect of any method on the base class portion of the conceptual model must be consistent with the base class specification of the method; in this sense our work is an extension of the behavioral subtyping approach. 11 11 The formalisms of <ref> [10, 11] </ref>, as well as that of [4], allow a slightly more general relation between the base class model and the derived class model. <p> One criticism that may be directed against our approach is that it forces us to do case analysis of the client code on the basis of the particular type of the object on which the code is being applied, whereas approaches like those of <ref> [10, 1] </ref> do not. But note that we have to do case analysis only to the extent that we are interested in establishing additional properties beyond the ones that can be arrived at using the base class specifications. <p> It is worth reiterating that although our approach is influenced by the model of inheritance-based poly-morphism in languages like Eiffel and C++, the approach (like those of <ref> [10, 4] </ref> etc.) is applicable also in cases where polymorphism works on a different basis such as the interface inheritance of Java.
Reference: [11] <author> B. Liskov and J. Wing. </author> <title> A behavioral notion of subtyping. </title> <journal> ACM TOPLAS, </journal> <volume> 16 </volume> <pages> 1811-1841, </pages> <year> 1994. </year>
Reference-contexts: contained in the base class specification, i.e., the effect of any method on the base class portion of the conceptual model must be consistent with the base class specification of the method; in this sense our work is an extension of the behavioral subtyping approach. 11 11 The formalisms of <ref> [10, 11] </ref>, as well as that of [4], allow a slightly more general relation between the base class model and the derived class model.
Reference: [12] <author> B. Meyer. </author> <title> Object-Oriented Software Construction. </title> <publisher> Prentice Hall, </publisher> <year> 1988. </year>
Reference-contexts: Much has been written about the power of OO polymorphism; see Meyer <ref> [12] </ref>, for instance. The goal of this paper is to address some questions in the specification and verification of systems that use OO polymorphism. The standard approach to the problem is in terms of behavioral subtyping (see, for instance, [1, 10]).
Reference: [13] <author> B. Meyer. </author> <title> Object-Oriented Software Construction. </title> <publisher> Prentice Hall, </publisher> <year> 1988. </year>
Reference-contexts: Indeed the programmer does not even have to make changes, or even recompile, when new derived classes are defined and the same code is applied on objects that are instances of these new derived classes. Meyer <ref> [13] </ref> calls this the `open-closed' principle since the compiled code can be used as such (hence `closed'), and can also be extended by adding new derived classes (hence `open').
Reference: [14] <author> N. Soundarajan and S. Fridella. </author> <title> Inheriting and modifying behavior. In Proceedings of TOOLS, </title> <note> published by IEEE Computer Society (to appear), </note> <year> 1997. </year>
Reference-contexts: Such derived classes of course are not meant to be used polymorphically and will not obey the restrictions imposed in this paper. We will not consider such use of inheritance in this paper; in <ref> [14] </ref> we show how the designer of such derived classes can, in validating his 3 class, make use of much of the reasoning that the base class designer went through in validating the behavior of the base class. <p> As usual, each class will have a concrete specification and an abstract specification. The concrete specification of B is needed not only when establishing the correctness of B's implementation, but also, as we discuss in some detail in <ref> [14] </ref>, when establishing the correctness of D's implementation. Since our focus in this paper is on reasoning about the behavior of client code rather than on establishing that classes meet their specifications, we will not worry about the concrete specifications of the classes, but instead concentrate on their abstract specifications. <p> All of this is fairly standard, see for instance the text by Jones [6]. The derived class will similarly have a concrete specification. As discussed in <ref> [14] </ref>, part of this specification can be inherited from the concrete specification of the base class. <p> Since our interest in this paper is in verifying client code, we will omit these details, as well as the details of verifying that the client code does meet its abstract specification, referring the interested reader to <ref> [14] </ref>. One important difference with the system in [14] is that in the current situation, we have to deal with two abstract specifications for the derived class. <p> Since our interest in this paper is in verifying client code, we will omit these details, as well as the details of verifying that the client code does meet its abstract specification, referring the interested reader to <ref> [14] </ref>. One important difference with the system in [14] is that in the current situation, we have to deal with two abstract specifications for the derived class.
Reference: [15] <author> K. Takashio and M. Tokoro. Drol: </author> <title> An oo language for distributed real-time systems. </title> <booktitle> In OOPSLA, </booktitle> <pages> pages 276-294, </pages> <year> 1992. </year> <month> 14 </month>
Reference-contexts: work of Lamping and Abadi [8] in which they formalize polymorphism in a very general manner allowing method selection to depend on a variety of criteria such as on the types of all the operands (multi-methods as in Cecil [3] or CLOS [7]), or even real-time considerations (as in DROL <ref> [15] </ref>). But their focus is on formalizing how the method is chosen (by the run-time system) rather than on reasoning about behaviors.
References-found: 15

