URL: http://paleale.eecs.berkeley.edu/~pettyk/Papers/verification.ps
Refering-URL: http://paleale.eecs.berkeley.edu/~pettyk/pubs.html
Root-URL: http://www.cs.berkeley.edu
Title: Formal Verification of the PATHO Real-Time Operating System  
Author: Felice Balarin Karl Petty Alberto L. Sangiovanni-Vincentelli Pravin Varaiya 
Address: Berkeley, CA 94720  
Affiliation: Department of Electrical Engineering and Computer Science University of California,  
Abstract: We present several models of PATHO, a real-time operating system for an automatically controlled vehicle. The models are simple and scalable, thus they can be used to evaluate real-time verification tools. We describe the verification of PATHO using real-time extensions of HSIS verification system. Experiments show that user-supplied guidelines are crucial for successful verification. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> R. Alur. </author> <title> Techniques for Automatic Verification of Real-time Systems. </title> <type> PhD thesis, </type> <institution> Stanford University, </institution> <year> 1991. </year>
Reference-contexts: The second observation is that even with hints, we have to deal with the state explosion problem. Verifying property P rop i requires approximately twice as many states and four times as much time as verifying P rop i1 . There are many theoretical results (e.g. <ref> [1] </ref>) suggesting that this complexity is inherent, still recent advances made possible the verification of examples that were previously intractable.
Reference: [2] <author> R. Alur, C. Courcoubetis, and D. L. Dill. </author> <title> Model-checking for real-time systems. </title> <booktitle> In Proceedings of 5th LICS, </booktitle> <pages> pages 414-425, </pages> <month> June </month> <year> 1990. </year>
Reference-contexts: However, it is essential to verify that an embedded system not only reacts to the external stimuli, but reacts in time. For that purpose, one can apply recently developed verification methods for real-time systems (e.g. <ref> [7, 2, 3] </ref>). Even though the theoretical advances are significant, most of the verification tools for real-time systems are still in their infancy, and not yet capable of verifying complete real-life systems. An example of an embedded system is the PATHO real-time operating system.
Reference: [3] <author> R. Alur and D. L. Dill. </author> <title> Automata for modelling real-time systems. </title> <booktitle> In Proceeding of ICALP'90. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1990. </year> <note> LNCS vol. 443. </note>
Reference-contexts: However, it is essential to verify that an embedded system not only reacts to the external stimuli, but reacts in time. For that purpose, one can apply recently developed verification methods for real-time systems (e.g. <ref> [7, 2, 3] </ref>). Even though the theoretical advances are significant, most of the verification tools for real-time systems are still in their infancy, and not yet capable of verifying complete real-life systems. An example of an embedded system is the PATHO real-time operating system. <p> In section 3 we describe PATHO informally, and then in section 4 we describe several formal models of PATHO suitable for automatic verification. Finally, in section 5 we discuss experimental results. 2 Timed automata Timed automata <ref> [3] </ref> are finite state systems extended with finitely many time-measuring devices called timers. Every transition can be conditioned on certain timer values, and on every transition some timers can be reset to 0.
Reference: [4] <author> A. Aziz et al. HSIS: </author> <title> A BDD-based environment for formal verification. </title> <booktitle> In Proceedings of the 31th ACM/IEEE Design Automation Conference, </booktitle> <year> 1994. </year>
Reference-contexts: To preserve vehicle safety, PATHO must meet strict real-time requirements imposed by its environment. In this paper we describe how it can be formally verified that PATHO meets these requirements. We verify PATHO using the verification system HSIS <ref> [4] </ref>, with real-time extensions based on the algorithm described in [5]. The contributions of this paper are twofold. <p> The verification problem is again to check whether some task can reach the dead state. 5 Experimental results In this section we present experimental results obtained using real-time extension of the verification system HSIS <ref> [4] </ref>. This extension is based on the algorithm presented in [5], which we will briefly describe next. The algorithm can be executed in two modes: automatic and directed. In the automatic mode the main steps of the algorithm are: 1. Initially, ignore all timing constraints. 2.
Reference: [5] <author> F. Balarin and A. L. Sangiovanni-Vincentelli. </author> <title> Iterative algorithms for formal verification of embedded real-time systems. </title> <booktitle> In Digest of Technical Papers of the 1994 IEEE International Conference on CAD, </booktitle> <year> 1994. </year>
Reference-contexts: To preserve vehicle safety, PATHO must meet strict real-time requirements imposed by its environment. In this paper we describe how it can be formally verified that PATHO meets these requirements. We verify PATHO using the verification system HSIS [4], with real-time extensions based on the algorithm described in <ref> [5] </ref>. The contributions of this paper are twofold. Firstly, our experience in verifying PATHO can be of use to both the users and the developers of formal fl Supported by SRC under grant # 94-DC-008. y Supported by the California PATH program. verification tools. <p> Still, it is possible to extend the timed automata verification algorithm to deal with this change <ref> [5] </ref>. The algorithm is not guaranteed to terminate in general, but an ad-hoc argument can be made that the algorithm will terminate on the example presented in this paper. The model of PATHO in this extended formalism is shown in Figure 3. <p> The verification problem is again to check whether some task can reach the dead state. 5 Experimental results In this section we present experimental results obtained using real-time extension of the verification system HSIS [4]. This extension is based on the algorithm presented in <ref> [5] </ref>, which we will briefly describe next. The algorithm can be executed in two modes: automatic and directed. In the automatic mode the main steps of the algorithm are: 1. Initially, ignore all timing constraints. 2. Try to verify the abstracted system.
Reference: [6] <author> E. M. Clarke, E. A. Emerson, and A. P. Sistla. </author> <title> Automatic verification of finite-state concurrent systems using temporal logic specifications. </title> <journal> ACM Transactions on Programming Languages Systems, </journal> <volume> 2(8) </volume> <pages> 244-263, </pages> <year> 1986. </year>
Reference-contexts: Therefore, there has been a significant interest in the last decade in the development of practical formal methods and tools for verification. Classical formal models abstract quantitative time and retain only the ordering of events (e.g. <ref> [6, 8] </ref>). However, it is essential to verify that an embedded system not only reacts to the external stimuli, but reacts in time. For that purpose, one can apply recently developed verification methods for real-time systems (e.g. [7, 2, 3]).
Reference: [7] <author> D. L. Dill. </author> <title> Timing assumptions and verification of finite-state concurrent systems. </title> <editor> In J. Sifakis, editor, </editor> <title> Automatic Verification Methods for Finite-State Systems. </title> <publisher> Springer-Verlag, </publisher> <year> 1989. </year> <note> LNCS vol. 407. </note>
Reference-contexts: However, it is essential to verify that an embedded system not only reacts to the external stimuli, but reacts in time. For that purpose, one can apply recently developed verification methods for real-time systems (e.g. <ref> [7, 2, 3] </ref>). Even though the theoretical advances are significant, most of the verification tools for real-time systems are still in their infancy, and not yet capable of verifying complete real-life systems. An example of an embedded system is the PATHO real-time operating system.
Reference: [8] <author> R. P. Kurshan. </author> <title> Analysis of discrete event coordination. </title> <editor> In J. de Bakker, W. de Roever, and G. Rozenberg, editors, </editor> <booktitle> Stepwise Refinement of Distributed Systems : Models, Formalisms, Correctness, </booktitle> <pages> pages 414-453. </pages> <publisher> Springer-Verlag, </publisher> <year> 1990. </year> <note> LNCS vol. 430. </note>
Reference-contexts: Therefore, there has been a significant interest in the last decade in the development of practical formal methods and tools for verification. Classical formal models abstract quantitative time and retain only the ordering of events (e.g. <ref> [6, 8] </ref>). However, it is essential to verify that an embedded system not only reacts to the external stimuli, but reacts in time. For that purpose, one can apply recently developed verification methods for real-time systems (e.g. [7, 2, 3]).
Reference: [9] <author> J. McManis. </author> <title> Verification and Control of Real-Time Discrete Events Dynamical Systems. </title> <type> PhD thesis, </type> <institution> University of California, Berkeley, </institution> <year> 1993. </year>
Reference-contexts: Analyze the failure report provided by the verification tool. If it violates no timing constrains, then stop (the original system is not verified), otherwise proceed with the next step. 3 The idea that freezing the timer is in some cases equivalent to decrementing it is taken from <ref> [9] </ref>. idle run 1 pend t i = pend ^ s i x i &lt; p i r i t i = done y i = r i ^ x i &lt; p i y i r i ^ x i y i p i r i t i = dead
Reference: [10] <author> K. Petty. </author> <title> The PATHO Operating System and User's Guide. </title> <type> Technical report, </type> <institution> UC Berkeley, </institution> <year> 1993. </year>
Reference-contexts: We say that t satisfies x ~ a iff t (x) ~ a. Similarly, t satisfies x y ~ a iff t (x) t (y) ~ a, and t satisfies 1 ^ 2 iff it satisfies both 1 and 2 . 3 PATHO operating system PATHO <ref> [10] </ref> is a real-time operating system that can be used to write programs to control vehicles [11]. PATHO takes a collection of subroutines, called tasks, and manages them in such a way as to allow them to respond to the external environment.
Reference: [11] <author> P. Varaiya. </author> <title> Smart cars on smart roads: Problems of control. </title> <journal> IEEE Trans. on Automatic Control, </journal> <volume> 38(2) </volume> <pages> 195-207, </pages> <month> Feb. </month> <year> 1993. </year>
Reference-contexts: Similarly, t satisfies x y ~ a iff t (x) t (y) ~ a, and t satisfies 1 ^ 2 iff it satisfies both 1 and 2 . 3 PATHO operating system PATHO [10] is a real-time operating system that can be used to write programs to control vehicles <ref> [11] </ref>. PATHO takes a collection of subroutines, called tasks, and manages them in such a way as to allow them to respond to the external environment. There are three different types of tasks: background tasks, control tasks, and event tasks.
References-found: 11

