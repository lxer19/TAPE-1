URL: ftp://ftp.cs.utexas.edu/pub/garbage/carl-msthesis.ps
Refering-URL: http://www.cs.utexas.edu/users/oops/papers.html
Root-URL: http://www.cs.utexas.edu
Title: by  
Author: Stephen Paul Carl 
Date: 1996  
Note: Copyright  
Abstract-found: 0
Intro-found: 1
Reference: [AS85] <author> Harold Abelson and Gerald Sussman. </author> <title> Structure and Interpretation of Computer Programs. </title> <publisher> The MIT Press, </publisher> <year> 1985. </year>
Reference-contexts: Complex expressions are built from primitive expressions, for example, numbers, identifiers, and operators <ref> [AS85] </ref>. Such expressions can be built by enclosing a list of other expressions (which may themselves be primitive or complex) in parentheses, using prefix notation. In prefix notation, the function or operator is always first in the list, as in the expression (+ 1 2). <p> The latter two expressions are combinations, which are procedure call expressions. * Evaluation Combinations may be arbitrarily complex, but there is a simple model for evaluating them <ref> [AS85] </ref>. The leftmost element of a combination is the operator and the rest of the elements are the operands. To evaluate a combination, each of the operand expressions must be evaluated.
Reference: [ASU86] <author> Alfred V. Aho, Ravi Sethi, and Jeffrey D. Ullman. </author> <booktitle> Compilers: Principles, Techniques, and Tools. </booktitle> <publisher> Addison-Wesley, </publisher> <year> 1986. </year>
Reference-contexts: Procedural macros can annotate this data structure and examine annotations left by earlier steps of macro processing, giving us the power of an attribute grammar system with inherited and synthesized attributes <ref> [ASU86] </ref>. Adding annotations to this data structure in ways that depend on information found upstream in the compile-time environment cor 18 responds to inherited attributes; examining annotations left during the compilation of subexpressions and performing actions based on this information corresponds to synthesized attributes.
Reference: [BTS94] <author> Don Batory, Jeff Thomas, and Marty Sirkin. </author> <title> Reengineering a Complex Application Using a Scalable Data Structure Compiler. </title> <booktitle> In Proceedings of the ACM SIGSOFT '94 Conference, </booktitle> <month> December </month> <year> 1994. </year>
Reference-contexts: Similarly, our basic macro facility could be used as a substrate to implement non-traditional parameterized types in the sense of Batory, et. al. <ref> [BTS94] </ref>, allowing the expression of consistent refinement of data structure implementations.
Reference: [BR88] <author> Alan Bawden and Jonathan Rees. </author> <title> Syntactic Closures. </title> <booktitle> In Proceedings of the 1988 ACM Conference on Lisp and Functional Programming. </booktitle> <year> 1988, </year> <pages> pp. 86-95. </pages>
Reference-contexts: of context transformations in systems without an explicit environment structure encoding scope, we would have to essentially "demangle" expressions to recover the environment information implicit in painted identifiers, work our transformation on that environment, and then "remangle" the expressions according to the transformed environment structure. 1.3.4 Syntactic Closures Syntactic closures <ref> [BR88] </ref> have also been advanced as a solution to the name capture problem. The underlying idea is that expressions defined in one context which are substituted into some other context can be closed in the definition context by packaging the context with the expression in a data structure. <p> Consider this example, adapted from <ref> [BR88] </ref>: (define-macro (or a b) `(let ((a-thunk (lambda () ,a)) (b-thunk (lambda () ,b))) (let ((temp (a-thunk))) (if temp temp (b-thunk))))) Using the substitution model, the effect of using this macro in place of the procedure or-proc in the above code gives us (let ((perm (member x permanent-employees)) (temp (member x
Reference: [CR91] <author> William Clinger and Jonathan Rees. </author> <title> Macros That Work. </title> <booktitle> In Proceedings of the 1991 ACM Conference on Principles of Programming Languages. </booktitle> <year> 1991, </year> <pages> pp. 155-162. </pages>
Reference-contexts: The low-level facility (now in some disrepute [Ree93]) gives more power and flexibility, but at the cost of extra work for the programmer; it allows the hygienic facility to be bypassed when necessary. The goal of systems based on hygienic macro expansion is to maintain the following hygiene conditions <ref> [CR91] </ref>: * A hygienic macro cannot introduce a binding of a name that captures references to that name beyond those present in the macro definition.
Reference: [Dijk76] <author> E. W. Dijkstra. </author> <title> A Discipline of Programming. </title> <publisher> Prentice Hall, </publisher> <year> 1976. </year>
Reference-contexts: Such a facility might resemble the transform construct of Gries and Volpano [GV90], supporting the expression and rigorous checking of coordinate transforms (in the sense of Dijkstra <ref> [Dijk76] </ref>) to semi-automatically derive efficient implementations of programs expressed in a higher-level notation. Similarly, our basic macro facility could be used as a substrate to implement non-traditional parameterized types in the sense of Batory, et. al. [BTS94], allowing the expression of consistent refinement of data structure implementations.
Reference: [Dyb92] <author> R. Kent Dybvig. </author> <title> Writing Hygienic Macros In Scheme With Syntax-Case. </title> <type> Technical Report 356, </type> <institution> Indiana Computer Science Department. </institution> <month> June, </month> <year> 1992. </year> <month> 86 </month>
Reference-contexts: This makes examples easy to write and easy to follow. However, the motivation for the mechanisms we use is to support more expressive procedural macros (roughly corresponding to the syntax-case form presented by Dybvig in <ref> [Dyb92] </ref>). With a procedural macro system it is possible to 17 write essentially arbitrary analyses and optimizations to be performed at macro processing time (during compilation).
Reference: [DHB92] <author> R. Kent Dybvig, Robert Hieb and Carl Bruggeman. </author> <title> Syntactic Ab--straction in Scheme. In Lisp and Symbolic Computation: </title> <journal> An International Journal, </journal> <volume> Vol. 5, 4, </volume> <year> 1992. </year>
Reference-contexts: A system that extends hygienic macro expansion in a way that addresses some of the shortcomings of the R4RS proposal is the Syntactic Abstractions of Dybvig, Hieb, and Bruggeman <ref> [DHB92] </ref> Each approach performs a symbol renaming step that amounts to identifier painting.
Reference: [FWH92] <author> Daniel P. Friedman, Mitchell Wand, and Christopher T. Haynes. </author> <title> Essentials of Programming Languages. </title> <publisher> The MIT Press, </publisher> <year> 1992. </year>
Reference-contexts: In parameter-passing disciplines, thunks can be used to implement pass-by-name, in which the evaluation of an argument to a procedure call is delayed until it is used inside the procedure body <ref> [FWH92] </ref>. When an expression is packaged in a thunk it is said to be thunkified. Thunks can be implemented in Scheme by wrapping the expression to be thunkified in a lambda expression with no arguments. This creates a closure which will capture all the necessary information.
Reference: [GV90] <author> David Gries and Dennis Volpano. </author> <title> The Transform|A New Language Construct. </title> <booktitle> In Structured Programming, </booktitle> <volume> No. 11, </volume> <pages> pp. 1-10, </pages> <year> 1990. </year>
Reference-contexts: Such a facility might resemble the transform construct of Gries and Volpano <ref> [GV90] </ref>, supporting the expression and rigorous checking of coordinate transforms (in the sense of Dijkstra [Dijk76]) to semi-automatically derive efficient implementations of programs expressed in a higher-level notation.
Reference: [KR88] <author> Brian W. Kernighan and Dennis M. Ritchie. </author> <title> The C Programming Language, Second Edition. </title> <publisher> Prentice Hall, </publisher> <year> 1988. </year>
Reference: [KdesRB91] <author> Gregor Kiczales, Jim des Riveres, and Daniel G. Bobrow. </author> <title> The Art of the Metaobject Protocol. </title> <publisher> The MIT Press, </publisher> <year> 1991. </year>
Reference-contexts: We believe this can be done in our macro system by combining the approach used in the fluid variable example with a meta-object protocol like that described in <ref> [KdesRB91] </ref>. The metaobject protocol gives us the ability to query the system about the particulars of any given class definition. Once again, the key trick is to implement a new kind of binding which contains hooks that the compiler uses to change scope rules.
Reference: [KFFD86] <author> Eugene E. Kohlbecker, Daniel P. Friedman, Matthias Felleisen, and Bruce Duba. </author> <title> Hygienic Macro Expansion. </title> <booktitle> In Proceedings of the 1986 ACM Conference on Lisp and Functional Programming. </booktitle> <year> 1986, </year> <pages> pp. 151-159. </pages>
Reference-contexts: The proposed 12 Scheme macro system is divided into high-level and low-level facilities. The high--level facility allows macros to be written in a convenient pattern-matching language and is based on a technology called hygienic macro expansion <ref> [KFFD86] </ref>. This facility eliminates the name capture problem. The low-level facility (now in some disrepute [Ree93]) gives more power and flexibility, but at the cost of extra work for the programmer; it allows the hygienic facility to be bypassed when necessary.
Reference: [Pae93] <editor> Andreas Paepcke, ed. </editor> <title> Object Oriented Programming: The CLOS Perspective. </title> <publisher> The MIT Press, </publisher> <year> 1993. </year>
Reference-contexts: Using our macro system, an advanced user will be able to reprogram the 16 compiler by writing macros which allow the system to reflect on scope, where reflec-tion is defined in <ref> [Pae93] </ref> as "the ability to modify an implementation of a language without leaving the realm of the language"; by extending reflection to scope issues, we hope to provide information about identifiers and environments and allow programmers to conveniently code analyses which rely on such information, without having to understand the low-level
Reference: [PJ87] <editor> Simon L. Peyton Jones. </editor> <booktitle> The Implementation of Functional Programming Languages. </booktitle> <publisher> Prentice Hall, </publisher> <year> 1987. </year>
Reference-contexts: We mention these to show how renaming issues are treated in other areas of programming language implementation. It is not necessary to understand these mechanisms to understand our facility, because our system solves the problem more directly. 19 * ff-conversion <ref> [PJ87] </ref> is a process of renaming identifiers to ensure that different variables with the same name in different scopes end up having different names in later stages of processing in which scope information is unavailable.
Reference: [Pit80] <author> Kent Pitman. </author> <title> Special Forms in Lisp. </title> <booktitle> In Lisp Conference. </booktitle> <year> 1980, </year> <pages> pp. 179-187. </pages>
Reference: [Que94] <author> Christian Queinnec. </author> <title> Lisp in Small Pieces. </title> <publisher> Cambridge University Press, </publisher> <year> 1994. </year>
Reference: [Ree93] <author> Jonathan Rees. </author> <title> The Scheme of Things: Implementing Lexically Scoped Macros. </title> <journal> LISP Pointers, </journal> <volume> Vol. 6, 1, </volume> <year> 1993. </year> <month> 87 </month>
Reference-contexts: The high--level facility allows macros to be written in a convenient pattern-matching language and is based on a technology called hygienic macro expansion [KFFD86]. This facility eliminates the name capture problem. The low-level facility (now in some disrepute <ref> [Ree93] </ref>) gives more power and flexibility, but at the cost of extra work for the programmer; it allows the hygienic facility to be bypassed when necessary. <p> It will also rename the syntax forms let and if to guard against the possibility that these names were redefined somewhere between the definition and the use of the macro <ref> [Ree93] </ref>. This type of system is essentially an automated version of the standard way in which Lisp programmers have written macros over the years, which is to avoid name capture by explicitly writing or generating "unique" names. <p> Another discussion of lexically-scoped macro systems that sketches an implementation based on the R4RS Appendix and constrasts syntactic closures with renaming systems can be found in <ref> [Ree93] </ref>. A system that extends hygienic macro expansion in a way that addresses some of the shortcomings of the R4RS proposal is the Syntactic Abstractions of Dybvig, Hieb, and Bruggeman [DHB92] Each approach performs a symbol renaming step that amounts to identifier painting.
Reference: [R4RS] <institution> The Revised 4 Report on the Algorithmic Language Scheme. LISP Pointers, </institution> <note> Vol. 4, 3, </note> <year> 1991. </year>
Reference-contexts: A number of systems have been proposed to do this. For example, the Revised 4 Report on the Algorithmic Language Scheme <ref> [R4RS] </ref> contains an appendix which describes a proposed lexically-scoped macro system for the language. Traditionally, syntactic extension in Scheme, as in Lisp, has been implemented using macro expansion, and suffers from the same problems; the system described in the R4RS appendix is intended to fix these problems. <p> We'd like to be able to provide a similar construct in Scheme, as shown: (for (i 1 10) (write i)) Assuming a pattern-matching facility like that introduced in the Appendix to <ref> [R4RS] </ref>, we can imagine that the following "flattened" version of the above is passed to the macro system: (for i 1 10 (write i)) For purposes of explanation we will continue to use a sort of simplified Scheme syntax when defining macros, and ignore pattern-matching, because pattern-matching is essentially independent of <p> Further, the loop body refers to the loop variable, which implies that this expression must be evaluated inside the environment where the loop variable is bound, not in the call site environment. 3 The RScheme compiler supports most of the <ref> [R4RS] </ref> Appendix pattern-matching syntax, while using the integrated macro processing system rather than hygienic macro expansion. 43 Here is a conventional macro which implements these semantics in terms of a hypothetical repeat-until construct 4 (which we use for ease of understanding), followed by an example of use: (define-macro (for loopvar init
Reference: [Ste79] <author> Guy L. Steele Jr. </author> <title> Compiler Optimization Based on Viewing LAMBDA as Rename Plus GOTO. In Artificial Intelligence: An MIT Perspective. </title> <publisher> The MIT Press, </publisher> <year> 1979, </year> <pages> pp. 397-431. </pages>
Reference-contexts: The structure of the environments created by this definition and use of the procedure is shown in Figure 2.3. The use of thunks to preserve the environment of call when passing arguments to macro calls was described in <ref> [Ste79] </ref>.
Reference: [Ste84] <author> Guy L. Steele Jr. </author> <title> Common Lisp: The Language. </title> <publisher> Digital Press, </publisher> <year> 1984. </year>
Reference-contexts: Then we show an example of context-sensitive macros and discuss a number of systems that could be built using these. 4.1 Special Variables Common Lisp <ref> [Ste84] </ref> provides a special form for declaring variables which have dynamic scope, which contrasts with lexical scope in that such variables can be referenced anywhere in a program once bound, and whose value when referenced is the most recent binding of the variable, irrespective of intervening closures, etc.
Reference: [SG93] <author> Guy L. Steele Jr. and Richard P. Gabriel. </author> <title> The Evolution of Lisp. </title> <booktitle> Second ACM SIGPLAN History of Programming Languages Conference (HOPL-II), in ACM SIGPLAN Notices. </booktitle> <volume> Vol. 8, No. 3, </volume> <year> 1993, </year> <pages> pp. 231-270. </pages>
Reference: [Wil94] <author> Paul R. Wilson. </author> <note> Computer Science 386L Class Notes. See http://www.cs.utexas.edu/users/oops. </note>
Reference: [Wil96] <author> Paul R. Wilson. </author> <title> An Introduction to Scheme and its Implementation. </title> <note> See http://www.cs.utexas.edu/users/oops. </note>
Reference-contexts: This outside-in processing of expressions is structured as a top-down traversal of the abstract syntax tree as it is incrementally constructed from the surface syntax tree (i.e., the input S-expressions constructed by the Scheme reader; see <ref> [Wil96] </ref> for a gentle introduction). During this top-down analysis and transformation process the compiler keeps a context data structure known as the compile-time environment; this structure encodes the information about the run-time context in which the code being compiled will execute. <p> Those familiar with the the Scheme programming language may want to skip the first section. 1 For a gentle yet thorough introduction to Scheme, including a basic discussion of macros, the interested reader may wish to consult <ref> [Wil96] </ref>. This document is available in HTML format for easy browsing, making it a good reference for topics we can't cover thoroughly here. 22 2.1 Building Blocks of Scheme Programs * Expressions: Expressions are the basic elements of Scheme programs.
Reference: [WKC97] <author> Paul R. Wilson, Donovan Kolbly, and Stephen P. Carl. </author> <title> An Integrated, Lexically Scoped "Macro" System for Compiler Extensibility. </title> <note> In preparation. 88 </note>
Reference-contexts: More examples with detailed descriptions of the macros used can be found in <ref> [WKC97] </ref>. 84 Chapter 5 Summary The new macro facility described in this thesis was developed to address the problems with regard to maintaining lexical scope in conventional macro systems, and the shortcomings of facilities that have been proposed to provide lexically scoped macros.
References-found: 25

