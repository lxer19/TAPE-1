URL: http://www.cs.colorado.edu/~klauser/papers/dp-pact98.ps.gz
Refering-URL: http://www.cs.colorado.edu/~klauser/publications.html
Root-URL: http://www.cs.colorado.edu
Title: Dynamic Hammock Predication for Non-predicated Instruction Set Architectures  
Author: Artur Klauser Todd Austin Dirk Grunwald Brad Calder 
Date: 1998  
Note: to appear in Proceedings of the International Conference on Parallel Architectures and Compilation Techniques (PACT)  
Affiliation: University of Colorado at Boulder Department of Computer Science Intel Microcomputer Research Lab University of California, San Diego Department of Computer Science and Engineering  
Abstract: Conventional speculative architectures use branch prediction to evaluate the most likely execution path during program execution. However, certain branches are difficult to predict. One solution to this problem is to evaluate both paths following such a conditional branch. Predicated execution can be used to implement this form of multi-path execution. Predicated architectures fetch and issue instructions that have associated predicates. These predicates indicate if the instruction should commit its result. Predicating a branch reduces the number of branches executed, eliminating the chance of branch misprediction at the cost of executing additional instructions. In this paper, we propose a restricted form of multi-path execution called Dynamic Predication for architectures with little or no support for predicated instructions in their instruction set. Dynamic predication dynamically predicates instruction sequences in the form of a branch hammock, concurrently executing both paths of the branch. A branch hammock is a short forward branch that spans a few instructions in the form of an if-then or if-then-else construct. We mark these and other constructs in the executable. When the decode stage detects such a sequence, it passes a predicated instruction sequence to a dynamically scheduled execution core. Our results show that dynamic predication can accrue speedups of up to 13%. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> D. P. Bhandarkar. </author> <title> Alpha Implementation and Architecture. </title> <publisher> Digital Press, </publisher> <year> 1996. </year>
Reference-contexts: Some current architectures implement limited support for predicated execution, e.g. the Alpha ISA <ref> [1] </ref> supports conditional move instructions and the HP-PA 2.0 ISA [11] supports conditional nullification of one instruction after most computational instructions. In comparison, our approach uses full predication in the microar-chitecture without requiring additional instruction set support. Table 1. Machine configuration parameters. Table 2. Benchmark characteristics and baseline machine performance.
Reference: [2] <author> D. Burger, T. M. Austin, and S. Bennett. </author> <title> Evaluating Future Microprocessors: The SimpleScalar Tools Set. </title> <type> Technical Report TR#1308, </type> <institution> University of Wisconsin, </institution> <month> July </month> <year> 1996. </year>
Reference-contexts: Table 3. Percent speedup for hammock predication with static hammock selection methods (left hand side) and perfect hammock branch execution (right hand side). Perfect prediction and fetch for simple hammock branches represents an upper bound model for hammock predication. 4 Results We have used the SimpleScalar tools <ref> [2] </ref> to build a pipeline-level simulator of our proposed dynamic predication architecture. The baseline machine architecture is a superscalar, out-of-order execution, in-order commit processor with architectural parameters as detailed in Table 1.
Reference: [3] <author> P.-Y. Chang, E. Hao, Y. Patt, and P. Chang. </author> <title> Using Predicated Execution to Improve the Performance of a Dynamically Scheduled Machine with Speculative Execution. </title> <booktitle> In Intl. Conf. on Parallel Arch. and Compilation Techniques, </booktitle> <address> Limassol, Cyprus, </address> <month> June </month> <year> 1995. </year>
Reference-contexts: There is very little work on what we would term dynamic predication. Sprangle and Patt [20] show that with predication, the re-namer can reuse storage if it knows that the storage is predicated under complimentary conditions. Chang et al. <ref> [3] </ref> studied a fully predicated ISA on a speculative architecture with register renaming. They use an additional source input to each instruction to allow copying of the old logical destination register value to the new physical destination register if the predicate is false.
Reference: [4] <author> D. Draper et al. </author> <title> Circuit Techniques in a 266-MHz MMX-Enabled Processor. </title> <journal> IEEE Journal of Solid-State Circuits, </journal> <volume> 32(11), </volume> <month> Nov. </month> <year> 1997. </year>
Reference-contexts: Each injected cmove takes up one dispatch slot when it is put into the instruction window, which delays the dispatch of operations fetched after the join point. Dynamic expansion of ISA instructions into micro-operations is a proven technique used e.g. in the PentiumPro and K6 processor <ref> [4] </ref> implementations. Our technique is much simpler than this full translation of each instruction. 2.3 Scheduler Support The register scheduling logic, for the most part, is unchanged. Using the renaming mechanism described in the previous section, instructions may begin execution as soon as their operands are ready.
Reference: [5] <author> J. Dean, J. E. Hicks, C. A. Waldspurger, W. E. Weihl, and G. Chrysos. ProfileMe: </author> <title> Hardware Support for Instruction-Level Profiling on Out-of-Order Processors. </title> <booktitle> In 30th Annual Intl. Symp. on Microarchitecture, </booktitle> <month> Dec. </month> <year> 1997. </year>
Reference-contexts: We assume the binary modification tool has access to branch prediction profiles. These profiles contain information about correct predictions and mispre-dictions for each branch, and can be gathered with tools like Pro-fileMe <ref> [5] </ref>.
Reference: [6] <author> K. Farkas, P. Chow, N. Jouppi, and Z. Vranesic. </author> <title> Memory-System Design Considerations for Dynamically-Scheduled Processors. </title> <booktitle> In 24th Annual Intl. Symp. on Comp. Architecture, </booktitle> <month> June </month> <year> 1997. </year>
Reference-contexts: However, increasing the issue width of the processor beyond 4 instructions will have decreasing benefits unless the compiler and architecture technology is improved. Studies on current processors, which can issue 4 instructions per cycle, show that on average only 1 to 2 instructions are issued per cycle <ref> [6, 21] </ref>. Therefore, 50% to 75% of the processor's potential performance is not being utilized. A main contributor to this performance degradation is the small size of basic blocks and high branch misprediction penalties. Even with new branch prediction architectures, some branches are still very hard to predict.
Reference: [7] <author> J. Ferrante, K. Ottenstein, and J. Warren. </author> <title> The Program Dependence Graph and Its Use in Optimization. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 9(3):319349, </volume> <month> July </month> <year> 1987. </year>
Reference-contexts: The branch is then eliminated from the instruction stream and instructions from both paths are concurrently executed. The conversion to predicated form occurs while the program executes; hence the name Dynamic Predication. In this paper, we concentrate on dynamic predication for simple branch hammocks <ref> [7] </ref>, or branches that have a clear fork-join form with no nested hammocks.
Reference: [8] <author> D. Grunwald, A. Klauser, S. Manne, and A. Pleszkun. </author> <title> Confidence Estimation for Speculation Control. </title> <booktitle> In 25th Intl. Symp. on Computer Architecture, </booktitle> <address> Barcelona, Spain, </address> <month> June </month> <year> 1998. </year>
Reference-contexts: As seen for perfect hammock branch execution in Table 4, eliminating the interference in the branch predictor contributes approximately 1% to overall speedup. 4.4 Dynamic Hammock Selection Methods We have also considered dynamic hammock selection methods that use a branch confidence estimator <ref> [8, 10] </ref> to dynamically determine if a hammock should be predicated. The two designs studied are Saturating Counters and Miss-Distance Counters. Saturating counters is a simple method that uses the state of the branch predictor counters to derive the confidence estimation. <p> If both indexed counters in the McFarling branch predictor are saturated in the same direction, the branch prediction is of high confidence, otherwise it is low confidence. This scheme is called Both-Strong in <ref> [8] </ref>. It does not require any additional storage for the confidence estimator, since it uses the branch predictor counters. The second scheme is more expensive and keeps a separate table of miss-distance counters (MDC), which count the number of correct predictions since the last misprediction for this index. <p> The MDC is incremented for each correct prediction, and reset to zero for each incorrect prediction. If the MDC value is below a threshold, the prediction is low confidence, otherwise it is high confidence. As suggested in <ref> [8] </ref>, we have adapted the indexing mechanism of the MDC table to the McFarling predictor and keep a separate MDC table for each of the two component predictors. The McFarling meta-predictor selects between the two.
Reference: [9] <author> T. Heil and J. Smith. </author> <title> Selective Dual Path Execution, </title> <month> Nov. </month> <year> 1996. </year> <institution> University of Wisconsin-Madison, </institution> <address> http://www.ece.wisc.edu/ jes/papers/isca.sdpe.ps. </address>
Reference-contexts: This reintroduces output dependencies (write-after-write) between instructions that produce the same logical destination register. Our solution avoids these artificial dependencies by using conditional moves to reconcile data dependencies. Heil and Smith <ref> [9] </ref> and Tyson, Lick and Farrens [22] also discuss dual path execution. The paper by Tyson does not describe an implementation. The paper by Heil mentions duplicating the processor pipeline resources. <p> The paper by Heil mentions duplicating the processor pipeline resources. By comparison, our method can pipeline multiple branch hammocks, meaning that more than two paths can be under evaluation at any one time. Furthermore, our modifications to the decoder, renamer and scheduler are much simpler than the proposal in <ref> [9] </ref>. In [24] Uht et al. describe Disjoint Eager Execution and minimal control dependencies, which allow execution of control and data independent instructions after the join, concurrently with instructions before the fork branch. Our approach has the same property but comes with a much smaller hardware overhead.
Reference: [10] <author> E. Jacobsen, E. Rotenberg, and J. E. Smith. </author> <title> Assigning Confidence to Conditional Branch Predictions. </title> <booktitle> In 29th Annual Intl. Symp. on Microarchitecture, </booktitle> <pages> pages 142152, </pages> <address> Paris, France, </address> <month> Dec. </month> <year> 1996. </year>
Reference-contexts: In the dynamic method, the branch is executed using predication only if a confidence estimator reports a low confidence in the branch prediction. We use a dynamic confidence estimator similar to the design of Jacobsen et al. <ref> [10] </ref>. Clearly, dynamic predication will have the largest influence for branches with little predictability and few instructions. If a branch can be easily predicted, then speculation is more efficient than predication. <p> As seen for perfect hammock branch execution in Table 4, eliminating the interference in the branch predictor contributes approximately 1% to overall speedup. 4.4 Dynamic Hammock Selection Methods We have also considered dynamic hammock selection methods that use a branch confidence estimator <ref> [8, 10] </ref> to dynamically determine if a hammock should be predicated. The two designs studied are Saturating Counters and Miss-Distance Counters. Saturating counters is a simple method that uses the state of the branch predictor counters to derive the confidence estimation.
Reference: [11] <author> G. Kane. </author> <title> PA-RISC 2.0 architecture. </title> <publisher> Prentice Hall PTR, </publisher> <year> 1996. </year>
Reference-contexts: Some current architectures implement limited support for predicated execution, e.g. the Alpha ISA [1] supports conditional move instructions and the HP-PA 2.0 ISA <ref> [11] </ref> supports conditional nullification of one instruction after most computational instructions. In comparison, our approach uses full predication in the microar-chitecture without requiring additional instruction set support. Table 1. Machine configuration parameters. Table 2. Benchmark characteristics and baseline machine performance.
Reference: [12] <author> A. Klauser, A. Paithankar, and D. Grunwald. </author> <title> Selective Eager Execution on the PolyPath Architecture. </title> <booktitle> In 25th Intl. Symp. on Computer Architecture, </booktitle> <address> Barcelona, Spain, </address> <month> June </month> <year> 1998. </year>
Reference-contexts: In [24] Uht et al. describe Disjoint Eager Execution and minimal control dependencies, which allow execution of control and data independent instructions after the join, concurrently with instructions before the fork branch. Our approach has the same property but comes with a much smaller hardware overhead. Klauser et al. <ref> [12] </ref> describe multipath execution, which uses a path naming scheme that has similarities to our context tagging. However, their work only considers fork operations without rejoining paths.
Reference: [13] <author> S. A. Mahlke, R. E. Hank, R. A. Bringmann, J. C. Gyllenhaal, D. M. Gallagher, and W. mei W. Hwu. </author> <title> Characterizing the Impact of Predicated Execution on Branch Prediction. </title> <booktitle> In 27th Annual Intl. Symp. on Microarchitecture, </booktitle> <address> San Jose, CA, </address> <month> Dec. </month> <year> 1994. </year>
Reference-contexts: Full predication was used in the Cydra 5 [18] architecture. Mahlke et al. [15] proposed hyperblocks, or superblock scheduling extended to support predicated architectures. Tyson [23] and Mahlke et al <ref> [13] </ref> studied the potential benefits of predication on branch prediction accuracy. Pnevmatikatos and Sohi [16] proposed guarded execution, where a single instruction specified the predication information for subsequent instructions using a bit-mask. <p> The architected misprediction penalty is 16 cycles. For our performance evaluation, we use the SPECint95 benchmark suite with scaled down input data sets to reduce simulation time. All benchmarks run to completion. Table 2 shows the benchmark characteristics and their performance. 4.1 Branch Misprediction Contributions Tyson and Mahlke <ref> [23, 13] </ref> found that 30% of the dynamic branches could be removed by predication. We have measured the effect on performance if these branches were removed.
Reference: [14] <author> S. A. Mahlke, R. E. Hank, J. E. McCormick, D. I. August, and W. W. Hwu. </author> <title> A Comparison of Full and Partial Predicated Execution Support for ILP Processors. </title> <booktitle> In 22nd Intl. Symp. on Computer Architecture, </booktitle> <pages> pages 138149, </pages> <month> June </month> <year> 1995. </year>
Reference-contexts: Our architectural model addresses a more general control structure (two-sided branch hammocks) and support for speculative loads and stores within the dynamically predicated region. Mahlke et al. <ref> [14] </ref> provide more comparison of fully vs. partially predicated execution, and provide a detailed explanation of scheduling partial predicated code. Mahlke makes the point that simple predication schemes, such as conditional moves, increase the processor instruction count.
Reference: [15] <author> S. A. Mahlke, D. C. Lin, W. Y. Chen, R. E. Hank, and R. A. Bringmann. </author> <title> Effective Compiler Support for Predicated Execution Using the Hyperblock. </title> <booktitle> In 25th Intl. Conf. on Microarchitecture, </booktitle> <pages> pages 4554, </pages> <month> Dec. </month> <year> 1992. </year>
Reference-contexts: Full predication was used in the Cydra 5 [18] architecture. Mahlke et al. <ref> [15] </ref> proposed hyperblocks, or superblock scheduling extended to support predicated architectures. Tyson [23] and Mahlke et al [13] studied the potential benefits of predication on branch prediction accuracy. Pnevmatikatos and Sohi [16] proposed guarded execution, where a single instruction specified the predication information for subsequent instructions using a bit-mask.
Reference: [16] <author> D. N. Pnevmatikatos and G. S. Sohi. </author> <title> Guarded Execution and Branch Prediction in Dynamic ILP Processors. </title> <booktitle> In 21st Intl. Symp. on Computer Architecture, </booktitle> <pages> pages 120129, </pages> <month> June </month> <year> 1994. </year>
Reference-contexts: Full predication was used in the Cydra 5 [18] architecture. Mahlke et al. [15] proposed hyperblocks, or superblock scheduling extended to support predicated architectures. Tyson [23] and Mahlke et al [13] studied the potential benefits of predication on branch prediction accuracy. Pnevmatikatos and Sohi <ref> [16] </ref> proposed guarded execution, where a single instruction specified the predication information for subsequent instructions using a bit-mask.
Reference: [17] <author> B. R. Rau. </author> <title> Dynamically scheduled VLIW processors. </title> <booktitle> In 26th Annual Intl. Symp. on Microarchitecture, </booktitle> <address> Austin, Texas, </address> <month> Dec. </month> <year> 1993. </year>
Reference-contexts: Our approach has the same property but comes with a much smaller hardware overhead. Klauser et al. [12] describe multipath execution, which uses a path naming scheme that has similarities to our context tagging. However, their work only considers fork operations without rejoining paths. Rau <ref> [17] </ref> proposed a mechanism to implement dynamically scheduled VLIW architectures that is similar to our injection of conditional move operations used to reconcile contexts.
Reference: [18] <author> R. Rau, D. Yen, W. Yen, and R. Towle. </author> <title> The Cydra 5 Departmental Supercomputer. </title> <journal> IEEE Computer, </journal> <volume> 22(1):1235, </volume> <month> Jan. </month> <year> 1989. </year>
Reference-contexts: It is interesting to note that dynamic scheduling becomes much more challenging in the presence of generalized compiler-based predication (e.g., as in <ref> [18] </ref>). If individual instructions can be decorated with arbitrary predicates, the dynamic scheduler must assume that any two instructions that share a definition are dependent unless it can prove that their unresolved predicate definitions do not imply each other. <p> Full predication was used in the Cydra 5 <ref> [18] </ref> architecture. Mahlke et al. [15] proposed hyperblocks, or superblock scheduling extended to support predicated architectures. Tyson [23] and Mahlke et al [13] studied the potential benefits of predication on branch prediction accuracy.
Reference: [19] <author> E. Sprangle, R. Chappell, M. Alsup, and Y. Patt. </author> <title> The Agree Predictor: A Mechanism for Reducing Negative Branch History Interference. </title> <booktitle> In 24th Annual Intl. Symp. on Comp. Architecture, </booktitle> <pages> pages 284291, </pages> <month> May </month> <year> 1997. </year>
Reference-contexts: Even with new branch prediction architectures, some branches are still very hard to predict. For example, the SPECint95 program go has only 80% branch prediction accuracy using the latest branch prediction architectures <ref> [19] </ref>. Predicated execution is an important part of future architecture design. Predication allows the removal of conditional branches from the instruction stream through conditional execution of instructions. Predicated architectures fetch and issue instructions that have predicates indicating if the instruction should commit its result.
Reference: [20] <author> E. Sprangle and Y. Patt. </author> <title> Facilitating Superscalar Processing via a Combined Static/Dynamic Register Renaming Scheme. </title> <booktitle> In 27th Annual Intl. Symp. on Microarchitecture, </booktitle> <address> San Jose, CA, </address> <month> Dec. </month> <year> 1994. </year>
Reference-contexts: Mahlke makes the point that simple predication schemes, such as conditional moves, increase the processor instruction count. Our model reduces the impact on the I-cache by dynamically inserting the conditional moves. There is very little work on what we would term dynamic predication. Sprangle and Patt <ref> [20] </ref> show that with predication, the re-namer can reuse storage if it knows that the storage is predicated under complimentary conditions. Chang et al. [3] studied a fully predicated ISA on a speculative architecture with register renaming.
Reference: [21] <author> D. Tullsen, S. Eggers, J. Emer, H. Levy, J. Lo, and R. Stamm. </author> <title> Exploiting Choice: Instruction Fetch and Issue on an Implementable Simultaneous Multithreading Processor. </title> <booktitle> In 23nd Annual Intl. Symp. on Comp. Architecture, </booktitle> <month> May </month> <year> 1996. </year>
Reference-contexts: However, increasing the issue width of the processor beyond 4 instructions will have decreasing benefits unless the compiler and architecture technology is improved. Studies on current processors, which can issue 4 instructions per cycle, show that on average only 1 to 2 instructions are issued per cycle <ref> [6, 21] </ref>. Therefore, 50% to 75% of the processor's potential performance is not being utilized. A main contributor to this performance degradation is the small size of basic blocks and high branch misprediction penalties. Even with new branch prediction architectures, some branches are still very hard to predict.
Reference: [22] <author> G. Tyson, K. Lick, and M. Farrens. </author> <title> Limited Dual Path Execution. </title> <type> CSE-TR 346-97, </type> <institution> University of Michigan, </institution> <year> 1997. </year>
Reference-contexts: This reintroduces output dependencies (write-after-write) between instructions that produce the same logical destination register. Our solution avoids these artificial dependencies by using conditional moves to reconcile data dependencies. Heil and Smith [9] and Tyson, Lick and Farrens <ref> [22] </ref> also discuss dual path execution. The paper by Tyson does not describe an implementation. The paper by Heil mentions duplicating the processor pipeline resources. By comparison, our method can pipeline multiple branch hammocks, meaning that more than two paths can be under evaluation at any one time.
Reference: [23] <author> G. S. Tyson. </author> <title> The Effects of Predicated Execution on Branch Prediction. </title> <booktitle> In 27th Annual Intl. Symp. on Microarchitecture, pages 196206, </booktitle> <address> San Jose, CA, </address> <month> Dec. </month> <year> 1994. </year>
Reference-contexts: Full predication was used in the Cydra 5 [18] architecture. Mahlke et al. [15] proposed hyperblocks, or superblock scheduling extended to support predicated architectures. Tyson <ref> [23] </ref> and Mahlke et al [13] studied the potential benefits of predication on branch prediction accuracy. Pnevmatikatos and Sohi [16] proposed guarded execution, where a single instruction specified the predication information for subsequent instructions using a bit-mask. <p> The architected misprediction penalty is 16 cycles. For our performance evaluation, we use the SPECint95 benchmark suite with scaled down input data sets to reduce simulation time. All benchmarks run to completion. Table 2 shows the benchmark characteristics and their performance. 4.1 Branch Misprediction Contributions Tyson and Mahlke <ref> [23, 13] </ref> found that 30% of the dynamic branches could be removed by predication. We have measured the effect on performance if these branches were removed.
Reference: [24] <author> A. K. Uht, V. Sindagi, and K. Hall. </author> <title> Disjoint Eager Execution: An Optimal Form of Speculative Execution. </title> <booktitle> In 28th Intl. Conf. on Microarchitecture, </booktitle> <pages> pages 313325, </pages> <month> Dec. </month> <year> 1995. </year>
Reference-contexts: By comparison, our method can pipeline multiple branch hammocks, meaning that more than two paths can be under evaluation at any one time. Furthermore, our modifications to the decoder, renamer and scheduler are much simpler than the proposal in [9]. In <ref> [24] </ref> Uht et al. describe Disjoint Eager Execution and minimal control dependencies, which allow execution of control and data independent instructions after the join, concurrently with instructions before the fork branch. Our approach has the same property but comes with a much smaller hardware overhead.
References-found: 24

