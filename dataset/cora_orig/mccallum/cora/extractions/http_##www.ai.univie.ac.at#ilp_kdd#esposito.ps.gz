URL: http://www.ai.univie.ac.at/ilp_kdd/esposito.ps.gz
Refering-URL: http://www.ai.univie.ac.at/ilp_kdd/schedule.html
Root-URL: http://www.aic.nrl.navy.mil/~aha/people.html
Email: -esposito, malerbad, semeraro-@vm.csata.it  
Title: Refinement of Datalog Programs  
Author: Floriana Esposito, Angela Laterza, Donato Malerba and Giovanni Semeraro 
Address: Via E. Orabona 4 70126 Bari, Italy  
Affiliation: Dipartimento di Informatica Universit degli Studi di Bari  
Abstract: Refinement operators are exploited to change in an automated way incorrect clauses of a logic program. In this paper, we present four refinement operators for Datalog programs and demonstrate that all of them meet the properties of local finiteness , properness, and completeness (ideality). Such operators are based on the quasi-ordering induced upon a set of clauses by the generalization model of q-subsumption under object identity. This model of generalization, as well as the four refinement operators have been implemented in a system for theory revision that proved effective in the area of electronic document classification.
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> Bergadano, F., and Gunetti, D., </author> <title> Learning Clauses by Tracing Derivations, </title> <booktitle> Proceedings of the Fourth International Workshop on Inductive Logic Programming, </booktitle> <editor> ILP-94, S. Wrobel (Ed.) , GMD-Studien Nr. </editor> <volume> 237, </volume> <pages> 11-29, </pages> <year> 1994. </year>
Reference-contexts: in the area of ILP have been directed to improve the efficiency of the search by restricting full first order Horn clause logic by means of suitable language biases, such as linkedness [18], ij-determinacy [29], Datalog (i.e., function-free) clauses [31, 35], rule models [22], antecedent description grammars [5], clause sets <ref> [1] </ref> and literal templates [44]. However, these language biases are not sufficient to solve the problem of defining ideal refinement operators.
Reference: 2. <author> Chang, C.-L. and Lee, R. C.-T., </author> <title> Symbolic Logic and Mechanical Theorem Proving, </title> <publisher> Academic Press, </publisher> <year> 1973. </year>
Reference-contexts: Such equational theory is very simple, since it consists of just one further axiom schema, in addition to the set of equality axioms <ref> [2] </ref>: "x x = x (reflexivity) "x, y x = y fi y = x (symmetry) "x, y, z x = y y = z fi x = z (transitivity) "x 1 , x 2 ,, x n , y x i = y fi f (x 1 , x i <p> Loveland [27, page 200] gives a definition of q-subsumption which is slightly different from the classical one, as reported in <ref> [2, 29, 32] </ref> (the difference is underlined).
Reference: 3. <author> Birkhoff, G., and Mac Lane, S., </author> <title> Algebra, </title> <publisher> The Macmillan Company, </publisher> <address> New York, </address> <year> 1965. </year>
Reference-contexts: Let C 1 , C 2 P be two uncomparable clauses and C be one of the minimal elements of -C 1 , C 2 - (whose existence is guaranteed by Proposition 1 in <ref> [3, page 483] </ref>). r complete implies necessarily that C r * ( C 1 ) r * ( C 2 ), which is in contrast with the hypothesis that C 1 and C 2 are uncomparable. q.d.e.
Reference: 4. <author> Clark, K.L., </author> <title> Negation as failure, in Logic and Databases, </title> <editor> H. Gallaire and J. Minker (Eds.), </editor> <publisher> Plenum Press, </publisher> <address> New York, 293-321, </address> <year> 1978. </year>
Reference-contexts: 1 , x i ,, x n ) fi P (x 1 , y,, x n ) (substitutivity) "CL, "t, sterms (C) t = s fi t = s body (C) (OI) The (OI) axiom can be viewed as an extension of Reiter's unique-names assumption [36] and Clark's Equality Theory <ref> [4] </ref> to variables. Henceforth, we will use t s as an abbreviation for t = s. Note that the former of the two substitutivity axioms is useless in Datalog, since no function symbols occur in a Datalog clause.
Reference: 5. <author> Cohen, W. W., </author> <title> Rapid Prototyping of ILP Systems Using Explicit Bias, </title> <booktitle> Proceedings of the IJCAI-93 Workshop on Inductive Logic Programming, </booktitle> <editor> F. Bergadano, L. De Raedt, S. Matwin, S. Muggleton (Eds.), </editor> <month> 24-35, </month> <year> 1993. </year>
Reference-contexts: Research efforts in the area of ILP have been directed to improve the efficiency of the search by restricting full first order Horn clause logic by means of suitable language biases, such as linkedness [18], ij-determinacy [29], Datalog (i.e., function-free) clauses [31, 35], rule models [22], antecedent description grammars <ref> [5] </ref>, clause sets [1] and literal templates [44]. However, these language biases are not sufficient to solve the problem of defining ideal refinement operators.
Reference: 6. <author> De Raedt, L., and Bruynooghe, M., </author> <title> A theory of clausal discovery, </title> , <booktitle> Proceedings of the 13th International Conference on Artificial Intelligence, IJCAI'93, </booktitle> <editor> R. Bajcsy (Ed.) </editor> <publisher> ,Morgan Kaufmann, </publisher> <pages> 1058-1063, </pages> <year> 1993. </year>
Reference-contexts: Q (x, y), Q (x, z) M = P (x) :- Q (x, y), Q (x, x) C = P (x) :- Q (x, y) C'' = P (x) :- Q (x, y), Q (a, v) (a) (b) 15 The notion of ideality can be compared to that of optimality <ref> [6, 17] </ref>, defined as follows.
Reference: 7. <author> Eisinger, N., and Ohlbach, H. J., </author> <title> Deduction Systems Based on Resolution, </title> <booktitle> in Handbook of Logic in Artificial Intelligence and Logic Programming , Volume 1, Logical Foundations, </booktitle> <editor> D. M. Gabbay, C. J. Hogger and J. A. Robinson (Eds.), </editor> <publisher> Oxford Science Publications, </publisher> <pages> 183-271, </pages> <year> 1993. </year>
Reference-contexts: Furthermore, it is well known in the area of automated theorem proving that, if the definition of q-subsumption is not tightened by the constraint on the number of literals, then each factor of a clause is removed because it is q-subsumed by the clause itself <ref> [7, page 228] </ref>. The damaging effect is that the simplification rule of factorization, which is a major step in improving the efficiency of a deduction system, is no longer applied.
Reference: 8. <author> Esposito, F., Malerba, D., and Semeraro, G., INCR/H: </author> <title> A System for Revising Logical Theories, </title> <booktitle> Proceedings of the MLnet Workshop on Theory Revision and Restructuring in Machine Learning, </booktitle> <editor> ECML-94, Arbeitspapiere der GMD N.842, S. Wrobel (Ed.), </editor> <month> 13-15, </month> <year> 1994. </year>
Reference-contexts: Application to Document Classification The refinement operators r OI and d OI have been implemented in a new version of INCR/H <ref> [8] </ref>, an incremental system for revising logic theories expressed as linked constant-free Datalog programs. <p> These operators have been embodied in INCR/H, an incremental learning system for theory revision <ref> [8] </ref>. Extensive experimentation in the area of electronic document processing has shown that the operators are able to refine effectively and efficiently Datalog programs for document classification.
Reference: 9. <author> Esposito, F., Malerba, D., and Semeraro, G., </author> <title> Multistrategy Learning for Document Recognition, </title> <journal> Applied Artificial Intelligence: An International Journal, </journal> <volume> 8 </volume> <pages> 33-84, </pages> <year> 1994. </year>
Reference-contexts: All the experiments have been carried out in the area of electronic document classification, which aims at identifying the membership class of a document <ref> [9] </ref>. In fact, wherever paper documents are handled, a primary demand is that of grouping documents into classes, according to criteria that usually differ from an environment to another, such as the common subject or the kind of processing the documents must undergo. <p> The learning set has been exploited in two distinct ways, according to the mode batch or incremental - adopted to learn the Datalog programs. For the batch mode, this set has been entirely given to INDUBI/H <ref> [9] </ref>, an empirical learning system, as its input. <p> A thorough description of the application to document classification can be found in [39]. These promising results lead us to integrate the operators into PLRS 3 <ref> [9] </ref>, the learning module of IBIsys, a software environment for office automation distributed by Olivetti. Future work will also extend the scope of the refinement operators along three dimensions - Datalog programs, introduction of functions in the language, and ambivalent clauses.
Reference: 10. <author> Esposito, F., Malerba, D., Semeraro, G., Brunk, C., and Pazzani, M., </author> <title> Traps and Pitfalls when Learning Logical Definitions from Relations, </title> <booktitle> in Methodologies for Intelligent Systems, Lecture Notes in Artificial Intelligence 869, </booktitle> <editor> Z. W. Ras and M. Zemankova (Eds.), </editor> <publisher> Springer-Verlag, </publisher> <pages> 376-385, </pages> <year> 1994. </year>
Reference-contexts: Now, we can formally introduce the ordering relation defined by the notion of q-subsumption under object identity -q OI subsumption - upon the set of Datalog clauses. The following definition extends to Datalog the definition given in <ref> [10, 38] </ref> for constant-free (other than function-free) logic languages. Definition 2 (q OI subsumption ordering) Let C, D be two Datalog clauses. <p> One of the problems that affect some of these systems is that there is no formal warranty that the learning process terminates, as pointed out in <ref> [10] </ref>, and this is due to the fact that these systems do not perform a q-subsumption equivalence test for efficiency reasons. In [38], it is proved the following result. "Proposition 11. <p> information about the structure of the clauses (the template) in the Datalog program to be learned, or if we are able to compute the highest complexity of each clause in some way (for instance, from the set B E + E -, through the process of pattern reconstruction described in <ref> [10] </ref>). While the size of a clause provides a syntactic criterion to establish an upper bound, the size under object identity allows to determine the exact number of steps needed to refine a clause.
Reference: 11. <author> Esposito, F., Fanizzi, N., Malerba, D., and Semeraro, G., </author> <title> Downward Refinement of Hierarchical Datalog Theories, </title> <booktitle> Proceedings of the Joint Conference on Declarative Programming , GULP-PRODE'95, </booktitle> <editor> M. Alpuente and M. I. Sessa (Eds.), </editor> <month> 148-159, </month> <year> 1995. </year>
Reference-contexts: Details about the pruning strategies adopted by the downward refinement operator can be found in <ref> [11, 39] </ref>. Several experiments have been designed to verify on an empirical basis whether such operators were efficient and effective when they are exploited to cope with a real-world task of program refinement.
Reference: 12. <author> Esposito, F., Laterza, A., Malerba, D., and Semeraro, G., </author> <title> Locally Finite, Proper and Complete Operators for Refining Datalog programs, </title> <booktitle> in Foundations of Intelligent Systems, Lecture Notes in Artificial Intelligence 1079, </booktitle> <editor> Z.W. Ras and M. Michalewicz (Eds.), </editor> <publisher> Springer, </publisher> <pages> 468-478, </pages> <year> 1996. </year>
Reference-contexts: Moreover, we formally prove that such operators are ideal. 2. Preliminaries and Definitions We assume the reader to be familiar with the notions of substitution, literal, fact, Horn clause and Short versions of this paper have been published in <ref> [12, 40] </ref>. 2 definite clause [26]. A clause C = l 1 l 2 l n , is considered as the set of its literals, that is, C = - l 1 , l 2 , , l n -.
Reference: 13. <author> Garey, M. R., and Johnson, D. S., </author> <title> Computers and Intractability: A Guide to the Theory of NP-Completeness , Freeman, </title> <address> New York, </address> <year> 1979. </year>
Reference-contexts: The problem of reducing a clause requires a test for q-subsumption, which is NP-complete <ref> [13] </ref>. Proposition 3 abates the computational complexity of the clause reduction problem under q OI subsumption to O (n 2 ), where n is the number of literals in the clause.
Reference: 14. <author> Gottlob, G., </author> <title> Subsumption and Implication, </title> <journal> Information Processing Letters, </journal> <volume> 24 </volume> <pages> 109-111, </pages> <year> 1987. </year>
Reference-contexts: For our purposes, it is enough to say that the incompleteness of q-subsumption wrt implication concerns exclusively the tautological and the self-resolving clauses, that is, if C is tautological or D is self-resolving then C |= D is not equivalent to D q C <ref> [14] </ref>. As to the upward refinement operators, examples of uncovered infinite strictly descending chains of a clause C are given by several authors.
Reference: 15. <author> Gottlob, G., and Fermller, C. G., </author> <title> Removing redundancy from a clause, </title> <journal> Artificial Intelligence, </journal> <volume> 61 </volume> <pages> 263-289, </pages> <year> 1993. </year>
Reference-contexts: Proposition 3 abates the computational complexity of the clause reduction problem under q OI subsumption to O (n 2 ), where n is the number of literals in the clause. In other words, removing redundancy from a clause, which is a major problem in several areas of computer science <ref> [15] </ref>, can be coped with in an efficient way for clauses constrained by the OI-equational theory. In logic-based machine learning, top-down systems perform a general-to-specific search to learn the body of a clause whose head contains (a proper variabilization of) the predicate to be learned.
Reference: 16. <editor> Grigoletto, F., </editor> <booktitle> Notes in statistics, Part II (in italian), </booktitle> <address> CLEUP, Padova, </address> <year> 1975. </year>
Reference-contexts: Conversely, the Wilcoxon test does not make any assumption on the distribution of the population data. In our setting, the sample size is 10, i.e. the number of replications, thus the t test might seem to be unsuitable. However, we performed preventively the Cucconi's normality test <ref> [16] </ref> in order to establish whether the population data are normally distributed. Such a test allows us to state that the population is normally distributed at a 0.01 level of significance.
Reference: 17. <author> Grobelnik, M., </author> <title> Markus - an optmized model inference system, </title> <booktitle> in Proceedings of the ECAI workshop on Logical Approaches to Machine Learning, </booktitle> <year> 1992. </year>
Reference-contexts: Q (x, y), Q (x, z) M = P (x) :- Q (x, y), Q (x, x) C = P (x) :- Q (x, y) C'' = P (x) :- Q (x, y), Q (a, v) (a) (b) 15 The notion of ideality can be compared to that of optimality <ref> [6, 17] </ref>, defined as follows.
Reference: 3. <institution> PLRS has been implemented and tested in the workpackage AP of the INTREPID (INnovative Techniques for REcognition and ProcessIng of Documents) project. </institution> <note> The work in the INTREPID project has been done within the framework of the ESPRIT programme and partly funded by the Commission of the European Communities. 21 </note>
Reference-contexts: Let C 1 , C 2 P be two uncomparable clauses and C be one of the minimal elements of -C 1 , C 2 - (whose existence is guaranteed by Proposition 1 in <ref> [3, page 483] </ref>). r complete implies necessarily that C r * ( C 1 ) r * ( C 2 ), which is in contrast with the hypothesis that C 1 and C 2 are uncomparable. q.d.e.
Reference: 18. <author> Helft, N., </author> <title> Inductive Generalization: A Logical Framework, </title> <booktitle> in Progress in Machine Learning - Proceedings of EWSL 87: 2nd European Working Session on Learning, </booktitle> <editor> I. Bratko & N. Lavrac (Eds.), </editor> <publisher> Sigma Press, Wilmslow, </publisher> <pages> 149-157, </pages> <year> 1987. </year>
Reference-contexts: Research efforts in the area of ILP have been directed to improve the efficiency of the search by restricting full first order Horn clause logic by means of suitable language biases, such as linkedness <ref> [18] </ref>, ij-determinacy [29], Datalog (i.e., function-free) clauses [31, 35], rule models [22], antecedent description grammars [5], clause sets [1] and literal templates [44]. However, these language biases are not sufficient to solve the problem of defining ideal refinement operators. <p> A formal definition of linkedness can be found in <ref> [18, 38] </ref>. The uncovered infinite chains (E 3 n ) n1 and (G n ) n2 consist of clauses that are not linked, therefore it could be guessed that, if the learning system adopts such a language bias, it is possible to define ideal refinement operators.
Reference: 19. <author> Idestam-Almquist, P., </author> <title> Generalization of Clauses , Doctoral Thesis, </title> <institution> Dept. of Computer and Systems Sciences, Stockholm University and Royal Institute of Technology, </institution> <type> Report series No. </type> <pages> 93-025, </pages> <month> October </month> <year> 1993. </year>
Reference-contexts: Such a chain is composed of Datalog clauses. Moreover, since all the clauses in the chain are not ambivalent (or self-resolving), this chain does exist under q-subsumption as well as under logical implication. A thorough analysis of the difference between q-subsumption and implication can be found in <ref> [19] </ref>. For our purposes, it is enough to say that the incompleteness of q-subsumption wrt implication concerns exclusively the tautological and the self-resolving clauses, that is, if C is tautological or D is self-resolving then C |= D is not equivalent to D q C [14].
Reference: 20. <author> Jung, B., </author> <title> On Inverting Generality Relations, </title> <booktitle> Proceedings of the Third International Workshop on Inductive Logic Programming, </booktitle> <editor> ILP'93, S. Muggleton (Ed.) , J. </editor> <booktitle> Stefan Institute TR IJS-DP-6707, </booktitle> <pages> 87-101, </pages> <year> 1993. </year>
Reference-contexts: Two examples - the former ascending, the latter descending - are (H n ) n0 and (I n ) n1 , (a chain slightly different from (I n ) n1 can be found in <ref> [20] </ref>), where: C H = Q (x 1 ) :- 7 3 D D D D 243 9 27 4 3 2 1 n-1 n &gt;n H i+1 = (H i - - P (x i, x ) -) i i+1 (- P (x , x ) -) - P (x
Reference: 21. <author> Kanellakis, P. C., </author> <title> Elements of Relational Database Theory, in Handbook of Theoretical Computer Science, Volume B, Formal Models and Semantics, </title> <editor> J. Van Leeuwen (Ed.), </editor> <publisher> Elsevier Science Publishers, </publisher> <pages> 1073-1156, </pages> <year> 1990. </year>
Reference-contexts: This does not limit the expressiveness of the adopted language since any two non-variable disjoint clauses always can be standardized apart. Henceforth, by clause we mean Datalog clause. Datalog is a language for deductive databases. Here, we refer to <ref> [21] </ref> for what concerns the basic notions about deductive databases. The vocabulary of a Datalog program P is composed of intensional database symbols , denoted with IDB's, and extensional database symbols, denoted with EDB's.
Reference: 22. <author> Kietz, J. U., and Wrobel, S., </author> <title> Controlling the Complexity of Learning in Logic through Syntactic and Task-Oriented Models, in Inductive Logic Programming, </title> <editor> S. Muggleton (Ed.), </editor> <publisher> Academic Press, </publisher> <pages> 335-359, </pages> <year> 1992. </year>
Reference-contexts: Research efforts in the area of ILP have been directed to improve the efficiency of the search by restricting full first order Horn clause logic by means of suitable language biases, such as linkedness [18], ij-determinacy [29], Datalog (i.e., function-free) clauses [31, 35], rule models <ref> [22] </ref>, antecedent description grammars [5], clause sets [1] and literal templates [44]. However, these language biases are not sufficient to solve the problem of defining ideal refinement operators.
Reference: 23. <author> Kodratoff, Y., and Ganascia, J.G., </author> <title> Improving the Generalization Step in Learning, in Machine Learning: An Artificial Intelligence Approach , Vol. II, R.S. </title> <editor> Michalski, J.G. Carbonell, and T.M. Mitchell (Eds.), </editor> <address> 215-244, </address> <publisher> Morgan Kaufmann, </publisher> <year> 1986. </year>
Reference-contexts: Future work will also extend the scope of the refinement operators along three dimensions - Datalog programs, introduction of functions in the language, and ambivalent clauses. Furthermore, we planned to investigate the relationship between q OI subsumption and Kodratoff and Ganascia's structural matching <ref> [23] </ref>. Acknowledgment We thank Prof. Shan-Hwei Nienhuys-Cheng and Dr. Patrick van der Laag for the insightful comments on several drafts of this paper. We are indebted with Nicola Fanizzi for the helpful discussions.
Reference: 24. <author> Komorowski, J., and Trcek, S., </author> <title> Towards Refinement of Definite Logic Programs, </title> <booktitle> in Methodologies for Intelligent Systems Proceedings of the 8th International Symposium, ISMIS '94, Lecture Notes in Artificial Intelligence 869, </booktitle> <editor> Z. W. Ras and M. Zemankova (Eds.), </editor> <publisher> Springer-Verlag, </publisher> <pages> 315-325, </pages> <year> 1994. </year>
Reference-contexts: Indeed, when the aim is to develop incrementally a logic program, that should be correct with respect to its intended model at the end of the development process, it becomes relevant to define operators that allow for a stepwise (incremental) refinement of programs <ref> [24] </ref>, which turn out to be too weak or too strong. The ideality of the refinement operators plays a key role when the efficiency and the effectiveness of the design process is an unnegligible requirement [46].
Reference: 25. <author> Ling, X., </author> <title> Inductive Learning from Good Examples, </title> <booktitle> Proceedings of the 12th International Joint Conference on Artificial Intelligence, </booktitle> <editor> J. Mylopoulos and R. Reiter (Eds.), </editor> <address> Sydney, Australia, 751-756, </address> <year> 1991. </year>
Reference-contexts: The most frequently adopted quasi-orderings are those induced by the notions of logical implication and q-subsumption [32]. Nevertheless, the search remains computationally expensive. Indeed, the algorithm in MIS is exponential. Recently, Ling <ref> [25] </ref> has developed a system, called SIM, with the aim at overcoming the overall inefficiency of MIS. SIM performs a specific-to-general search, which strongly relies on positive examples to compute the generalizations of clauses that turn out to be too weak. An upward refinement operator takes care of this task.
Reference: 26. <author> Lloyd, J. W., </author> <title> Foundations of Logic Programming, Second Edition, </title> <publisher> Springer-Verlag, </publisher> <address> New York, </address> <year> 1987. </year>
Reference-contexts: Moreover, we formally prove that such operators are ideal. 2. Preliminaries and Definitions We assume the reader to be familiar with the notions of substitution, literal, fact, Horn clause and Short versions of this paper have been published in [12, 40]. 2 definite clause <ref> [26] </ref>. A clause C = l 1 l 2 l n , is considered as the set of its literals, that is, C = - l 1 , l 2 , , l n -.
Reference: 27. <author> Loveland, D. W., </author> <title> Automated Theorem Proving: A Logical Basis, </title> <publisher> North-Holland, </publisher> <address> Amsterdam, </address> <year> 1978. </year>
Reference-contexts: Indeed, his definition states that "A clause D is a refinement of a clause C if C |- D and size (C) &lt; size (D)." Interestingly, the same problem can be found in the area of automated deduction. Loveland <ref> [27, page 200] </ref> gives a definition of q-subsumption which is slightly different from the classical one, as reported in [2, 29, 32] (the difference is underlined). <p> Lemma 4.1.1 in <ref> [27, page 208] </ref> states that "every sequence of clauses in which each clause properly q-subsumes its predecessor is of finite length." The constraint on the number of literals is a necessary condition for the validity of that lemma.
Reference: 28. <author> Moll, R.N., Arbib, M.A., and Kfoury, A.J., </author> <title> An Introduction to Formal Language Theory, </title> <publisher> Springer-Verlag, </publisher> <address> New York, </address> <year> 1988. </year>
Reference-contexts: C I H 1 &lt; I n for any n 1. Therefore, (H n ) n0 and (I n ) n1 seem to be two Datalog chains that satisfy the Interleaving Lemma, which is one of the main fixed point principles in formal language theory <ref> [28] </ref>. In his influential paper [32, page 163], Plotkin cites the existence of "a rather complicated infinite strictly descending chain 1 [C i ] i1 , with the following properties: 1. Plotkin uses the convention that C D means C is more general than D.
Reference: 29. <author> Muggleton, S., and Feng, C., </author> <title> Efficient Induction of Logic Programs, in Inductive Logic Programming, </title> <editor> S. Muggleton (Ed.), </editor> <address> 281-298, </address> <publisher> Academic Press, </publisher> <year> 1992. </year>
Reference-contexts: Research efforts in the area of ILP have been directed to improve the efficiency of the search by restricting full first order Horn clause logic by means of suitable language biases, such as linkedness [18], ij-determinacy <ref> [29] </ref>, Datalog (i.e., function-free) clauses [31, 35], rule models [22], antecedent description grammars [5], clause sets [1] and literal templates [44]. However, these language biases are not sufficient to solve the problem of defining ideal refinement operators. <p> Loveland [27, page 200] gives a definition of q-subsumption which is slightly different from the classical one, as reported in <ref> [2, 29, 32] </ref> (the difference is underlined).
Reference: 30. <author> Niblett, T., </author> <title> A note on refinement operators, </title> <booktitle> in Machine Learning: ECML-93 - Proceedings of the European Conference on Machine Learning , Lecture Notes in Artificial Intelligence 667, </booktitle> <editor> P. B. Brazdil (Ed.), </editor> <publisher> Springer-Verlag, </publisher> <pages> 329-335, </pages> <year> 1993. </year>
Reference-contexts: However, these language biases are not sufficient to solve the problem of defining ideal refinement operators. Indeed, as Niblett says <ref> [30] </ref>, "it is an open question as to which restrictions on full first order logic are compatible with complete nonredundant refinement operators." In this paper, we define four ideal refinement operators for Datalog programs. These definitions rely on a weaker ordering than q-subsumption, namely q OI subsumption.
Reference: 31. <author> Pazzani, M. , and Kibler, D., </author> <title> The utility of knowledge in inductive learning, </title> <journal> Machine Learning, </journal> <volume> 9 </volume> <pages> 57-94, </pages> <year> 1992. </year>
Reference-contexts: Research efforts in the area of ILP have been directed to improve the efficiency of the search by restricting full first order Horn clause logic by means of suitable language biases, such as linkedness [18], ij-determinacy [29], Datalog (i.e., function-free) clauses <ref> [31, 35] </ref>, rule models [22], antecedent description grammars [5], clause sets [1] and literal templates [44]. However, these language biases are not sufficient to solve the problem of defining ideal refinement operators.
Reference: 32. <author> Plotkin, G. D., </author> <title> A Note on Inductive Generalization, </title> <booktitle> in Machine Intelligence 5, </booktitle> <editor> B. Meltzer and D. Michie (Eds.), </editor> <publisher> Edinburgh University Press, </publisher> <pages> 153 - 163, </pages> <year> 1970. </year>
Reference-contexts: Refinement operators take advantage of the structure given to the specialization graph by the definition of a quasi 3 ordering upon it, in order to control the search and avoid the combinatorial explosion. The most frequently adopted quasi-orderings are those induced by the notions of logical implication and q-subsumption <ref> [32] </ref>. Nevertheless, the search remains computationally expensive. Indeed, the algorithm in MIS is exponential. Recently, Ling [25] has developed a system, called SIM, with the aim at overcoming the overall inefficiency of MIS. <p> Therefore, (H n ) n0 and (I n ) n1 seem to be two Datalog chains that satisfy the Interleaving Lemma, which is one of the main fixed point principles in formal language theory [28]. In his influential paper <ref> [32, page 163] </ref>, Plotkin cites the existence of "a rather complicated infinite strictly descending chain 1 [C i ] i1 , with the following properties: 1. Plotkin uses the convention that C D means C is more general than D. <p> Loveland [27, page 200] gives a definition of q-subsumption which is slightly different from the classical one, as reported in <ref> [2, 29, 32] </ref> (the difference is underlined).
Reference: 33. <author> Plotkin, G. D., </author> <title> Building-in Equational Theories, </title> <booktitle> in Machine Intelligence 7, </booktitle> <editor> B. Meltzer and D. Michie (Eds.), </editor> <publisher> Edinburgh University Press, </publisher> <pages> 73-90, </pages> <year> 1972. </year>
Reference-contexts: In Datalog, the adoption of the object identity assumption can be viewed as a method for building an equational theory into the ordering as well as into the inference rules of the calculus (resolution, factorization and paramodulation) <ref> [33] </ref>.
Reference: 34. <author> Popper, K. R., </author> <title> Conjectures and refutations: The Growth of Scientific Knowledge, </title> <publisher> Harper Torch Books, </publisher> <address> New York, </address> <year> 1968. </year>
Reference-contexts: For instance, Shapiro's Model Inference System (MIS) [41] is an incremental algorithm based on the Popperian methodology of conjectures and refutations <ref> [34] </ref>. The importance of this algorithm is not limited to the area of machine learning and inductive synthesis, but extends to algorithmic debugging of logic programs [43].
Reference: 35. <author> Quinlan, J. R., </author> <title> Learning Logical Implications from Relations, </title> <journal> Machine Learning, </journal> <volume> 5 </volume> <pages> 239-266, </pages> <year> 1990. </year>
Reference-contexts: Research efforts in the area of ILP have been directed to improve the efficiency of the search by restricting full first order Horn clause logic by means of suitable language biases, such as linkedness [18], ij-determinacy [29], Datalog (i.e., function-free) clauses <ref> [31, 35] </ref>, rule models [22], antecedent description grammars [5], clause sets [1] and literal templates [44]. However, these language biases are not sufficient to solve the problem of defining ideal refinement operators.
Reference: 36. <author> Reiter, R., </author> <title> Equality and domain closure in first order databases, </title> <journal> Journal of ACM, </journal> <volume> 27 </volume> <pages> 235-249, </pages> <year> 1980. </year>
Reference-contexts: i = y P (x 1 , x i ,, x n ) fi P (x 1 , y,, x n ) (substitutivity) "CL, "t, sterms (C) t = s fi t = s body (C) (OI) The (OI) axiom can be viewed as an extension of Reiter's unique-names assumption <ref> [36] </ref> and Clark's Equality Theory [4] to variables. Henceforth, we will use t s as an abbreviation for t = s. Note that the former of the two substitutivity axioms is useless in Datalog, since no function symbols occur in a Datalog clause.
Reference: 37. <author> Reynolds, </author> <title> J.C., Transformational Systems and the Algebraic Structure of Atomic Formulas, </title> <booktitle> in Machine Intelligence 5, </booktitle> <editor> B. Meltzer and D. Michie (Eds.), </editor> <publisher> Edinburgh University Press, </publisher> <pages> 135-152, </pages> <year> 1970. </year>
Reference-contexts: C denotes the number of literals in C - the length of C - while size (C) denotes the number of symbol occurrences in C (excluding punctuation) minus the number of distinct variables occurring in C <ref> [37, 42] </ref>. Furthermore, we will denote with vars (C), consts (C), and terms (C) the set of the variables, of the constants and of the terms occurring in C, respectively. Any two clauses will be always assumed to be variable disjoint.
Reference: 38. <author> Semeraro, G., Esposito, F., Malerba, D., Brunk, C., and Pazzani, M., </author> <title> Avoiding Non-Termination when Learning Logic Programs: A Case Study with FOIL and FOCL, </title> <booktitle> in Logic Program Synthesis and Transformation - Meta-Programming in Logic , Lecture Notes in Computer Science 883, </booktitle> <editor> L. Fribourg and F. Turini (Eds.), </editor> <publisher> Springer-Verlag, </publisher> <pages> 183-198, </pages> <year> 1994. </year>
Reference-contexts: SIM performs a specific-to-general search, which strongly relies on positive examples to compute the generalizations of clauses that turn out to be too weak. An upward refinement operator takes care of this task. Here, we recall the notion of object identity given in <ref> [38] </ref>. This notion is the basis for the definition of both an equational theory for Datalog clauses and a quasi-ordering upon them. Definition 1 (Object Identity) Within a clause, terms denoted with different symbols must be distinct. <p> Now, we can formally introduce the ordering relation defined by the notion of q-subsumption under object identity -q OI subsumption - upon the set of Datalog clauses. The following definition extends to Datalog the definition given in <ref> [10, 38] </ref> for constant-free (other than function-free) logic languages. Definition 2 (q OI subsumption ordering) Let C, D be two Datalog clauses. <p> A formal definition of linkedness can be found in <ref> [18, 38] </ref>. The uncovered infinite chains (E 3 n ) n1 and (G n ) n2 consist of clauses that are not linked, therefore it could be guessed that, if the learning system adopts such a language bias, it is possible to define ideal refinement operators. <p> One of the problems that affect some of these systems is that there is no formal warranty that the learning process terminates, as pointed out in [10], and this is due to the fact that these systems do not perform a q-subsumption equivalence test for efficiency reasons. In <ref> [38] </ref>, it is proved the following result. "Proposition 11. Let C and D be two definite Horn clauses: C reduced, C D and vars (C) = vars (D) fi [C] ~ [D] ~ " where [j] ~ denotes the class of clauses that are equivalent to j under q-subsumption.
Reference: 39. <author> Semeraro, G., Esposito, F., Fanizzi, N., and Malerba, D., </author> <title> Revision of Logical Theories, </title> <booktitle> in Topics in Artificial Intelligence, Lecture Notes in Artificial Intelligence 992, </booktitle> <editor> M. Gori and G. Soda (Eds.), </editor> <publisher> Springer, </publisher> <pages> 365-376, </pages> <year> 1995. </year>
Reference-contexts: Details about the pruning strategies adopted by the downward refinement operator can be found in <ref> [11, 39] </ref>. Several experiments have been designed to verify on an empirical basis whether such operators were efficient and effective when they are exploited to cope with a real-world task of program refinement. <p> Comparison of the average predictive accuracies on the test set (P.A.) and the average computational times (Time) for the downward refinement operator. 20 than 52 minutes (3153.3 seconds) to less than 31 minutes (1854.3 seconds). A thorough description of the application to document classification can be found in <ref> [39] </ref>. These promising results lead us to integrate the operators into PLRS 3 [9], the learning module of IBIsys, a software environment for office automation distributed by Olivetti.
Reference: 40. <author> Semeraro, G., Esposito, F., and Malerba, D., </author> <title> Ideal Refinement of Datalog Programs, in Logic Program Synthesis and Transformation, </title> <booktitle> Lecture Notes in Computer Science 1048, </booktitle> <editor> M. Proietti (Ed.), </editor> <publisher> Springer, </publisher> <pages> 120-136, </pages> <year> 1996. </year>
Reference-contexts: Moreover, we formally prove that such operators are ideal. 2. Preliminaries and Definitions We assume the reader to be familiar with the notions of substitution, literal, fact, Horn clause and Short versions of this paper have been published in <ref> [12, 40] </ref>. 2 definite clause [26]. A clause C = l 1 l 2 l n , is considered as the set of its literals, that is, C = - l 1 , l 2 , , l n -.
Reference: 41. <author> Shapiro, E.Y., </author> <title> An Algorithm that Infers Theories from Facts, </title> <booktitle> Proceedings of the 7th International Joint Conference on Artificial Intelligence, </booktitle> <address> Vancouver, Canada, 446-451, </address> <year> 1981. </year>
Reference-contexts: They can be roughly subdivided into batch and incremental, according to the fact that training examples - E + E - - are completely available at learning time or not, respectively. For instance, Shapiro's Model Inference System (MIS) <ref> [41] </ref> is an incremental algorithm based on the Popperian methodology of conjectures and refutations [34]. The importance of this algorithm is not limited to the area of machine learning and inductive synthesis, but extends to algorithmic debugging of logic programs [43].
Reference: 42. <author> Shapiro, E. Y., </author> <title> Inductive Inference of Theories from Facts , Technical Report 192, </title> <institution> Department of Computer Science, Yale University, </institution> <address> New Haven, Connecticut, </address> <year> 1981. </year>
Reference-contexts: C denotes the number of literals in C - the length of C - while size (C) denotes the number of symbol occurrences in C (excluding punctuation) minus the number of distinct variables occurring in C <ref> [37, 42] </ref>. Furthermore, we will denote with vars (C), consts (C), and terms (C) the set of the variables, of the constants and of the terms occurring in C, respectively. Any two clauses will be always assumed to be variable disjoint. <p> In the literature, the research efforts made in order to solve the problem of defining ideal refinement operators have tended towards the introduction of further constraints in the definition of refinement. For instance, Shapiro <ref> [42] </ref> restricts the definition of refinement by introducing the concept of size of a clause C.
Reference: 43. <author> Shapiro, E. Y., </author> <title> Algorithmic Program Debugging, </title> <publisher> MIT Press, </publisher> <year> 1983. </year>
Reference-contexts: For instance, Shapiro's Model Inference System (MIS) [41] is an incremental algorithm based on the Popperian methodology of conjectures and refutations [34]. The importance of this algorithm is not limited to the area of machine learning and inductive synthesis, but extends to algorithmic debugging of logic programs <ref> [43] </ref>.

References-found: 44

