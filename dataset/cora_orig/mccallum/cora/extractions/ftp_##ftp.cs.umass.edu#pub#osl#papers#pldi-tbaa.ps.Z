URL: ftp://ftp.cs.umass.edu/pub/osl/papers/pldi-tbaa.ps.Z
Refering-URL: http://spa-www.cs.umass.edu/bibliography.html
Root-URL: 
Phone: (650) 723-4013  
Title: Type-Based Alias Analysis  
Author: Amer Diwan Kathryn S. M c Kinley J. Eliot B. Moss 
Address: Stanford, CA 94305 University of Massachusetts, Amherst, MA 01003-4610  
Affiliation: Department of Computer Science Department of Computer Science Stanford University,  
Abstract: This paper evaluates three alias analyses based on programming language types. The first analysis uses type compatibility to determine aliases. The second extends the first by using additional high-level information such as field names. The third extends the second with a flow-insensitive analysis. Although other researchers suggests using types to disambiguate memory references, none evaluates its effectiveness. We perform both static and dynamic evaluations of type-based alias analyses for Modula-3, a statically-typed type-safe language. The static analysis reveals that type compatibility alone yields a very imprecise alias analysis, but the other two analyses significantly improve alias precision. We use redundant load elimination (RLE) to demonstrate the effectiveness of the three alias algorithms in terms of the opportunities for optimization, the impact on simulated execution times, and to compute an upper bound on what a perfect alias analysis would yield. We show modest dynamic improvements for (RLE), and more surprisingly, that on average our alias analysis is within 2.5% of a perfect alias analysis with respect to RLE on 8 Modula-3 programs. These results illustrate that to explore thoroughly the effectiveness of alias analyses, researchers need static, dynamic, and upper-bound analysis. In addition, we show that for type-safe languages like Modula-3 and Java, a fast and simple alias analysis may be sufficient for many applications. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Alfred V. Aho, Ravi Sethi, and Jeffrey D. Ullman. </author> <booktitle> Compilers: Principles, Techniques, and Tools. </booktitle> <publisher> Addison-Wesley, </publisher> <year> 1986. </year>
Reference-contexts: To address these concerns, this paper explores using fast alias analyses that rely on programming language types. While prior work <ref> [1, 6] </ref> mentions using type compatibility for alias analysis, none evaluates the idea or presents the details of an algorithm. This paper describes and evaluates three fast alias analyses based on programming language types. The first analysis (TypeDecl ) uses type compatibility to determine aliases. <p> 589 21802 postcard 1038 4208 30890 1623 5278 1615 5262 m3cg 4515 16521 1409449 6154 121476 6153 120525 little or no room for improvement in TBAA. 3.4.1 Redundant Load Elimination Redundant load elimination (RLE) combines variants of loop invariant code motion (similar to register promotion [8]) and common subexpression elimination <ref> [1] </ref>, which most optimizing compilers perform. RLE differs from classic loop invariant code motion and common subexpression elimination in that it eliminates redundant loads instead of redundant computation. <p> Wall [34] does not evaluate an existing alias analysis as we do, but just gives the potential of a perfect alias analysis for instruction level parallelism. Aho, et al. <ref> [1] </ref> and Chase, et al. [6] were among the first to notice that using programming language types could improve alias analysis, but did not present algorithms that did so. Our alias algorithm is most similar to those of Rinard and Diniz [26], Steensgaard [32], and Ruf [27, 28].
Reference: [2] <author> John Banning. </author> <title> An efficient way to find side effects of procedure calls and aliases of variables. </title> <booktitle> In Conference Record of the Sixth Annual ACM SIGACT/SIGPLAN Symposium on Principles of Programming Languages, </booktitle> <pages> pages 2941, </pages> <address> San Antonio, Texas, </address> <month> January </month> <year> 1979. </year>
Reference: [3] <author> Rodney M. Bates. K-trees. </author> <type> Personal communication, </type> <month> November </month> <year> 1994. </year>
Reference-contexts: for im provement in our analysis. 4 Table 4: Description of Benchmark Programs Name Lines Instructions % Heap loads % Other loads Description format [23] 395 1,879,195 10 17 Text formatter dformat [23] 602 1,442,541 9 19 Text formatter write-pickle 654 1,614,437 13 16 Reads and writes an AST k-tree <ref> [3] </ref> 726 50,297,517 10 21 Manages sequences using trees slisp 1,645 11,462,791 27 9 Small lisp interpreter pp 2,328 45,779,402 11 19 Pretty printer for Modula-3 programs dom [24] 6,186 System for building distributed applications postcard 8,214 Graphical mail reader m2tom3 10,574 50,894,990 8 28 Converts Modula-2 code to Modula-3 m3cg
Reference: [4] <author> Michael Burke, Paul R. Carini, Jong-Deok Choi, and Michael Hind. </author> <title> Efficient flow-insensitive alias analysis in the presence of pointers. </title> <type> Technical Report 19546, </type> <institution> IBM T.J. Watson Research Center, </institution> <address> Yorktown Heights, NY, </address> <month> September </month> <year> 1994. </year>
Reference: [5] <author> Brad Calder, Dirk Grunwald, and Joel Emer. </author> <title> A system level perspective on branch architecture performance. </title> <booktitle> In 28th International Symposium on Microarchitecture, </booktitle> <pages> pages 199206, </pages> <month> November </month> <year> 1995. </year>
Reference-contexts: Table 6: Number of Redundant Loads Removed Statically Program TypeDecl FieldTypeDecl SMFieldTypeRefs format 27 29 29 dformat 10 22 22 write-pickle 46 47 47 k-tree 221 228 228 m2tom3 369 396 396 slisp 36 37 37 m3cg 524 613 613 We also measured execution times using a detailed (and validated <ref> [5] </ref>) simulator for an Alpha 21064 workstation with one difference: rather than simulating an 8K primary cache we simulated a 32K primary cache to eliminate variations due to conflict misses that we observed in an 8K direct mapped 6 cache.
Reference: [6] <author> David R. Chase, Mark Wegman, and F. Kenneth Zadeck. </author> <title> Analysis of pointers and structures. </title> <booktitle> In Proceedings of the ACM SIGPLAN '90 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 296310, </pages> <year> 1990. </year> <month> 10 </month>
Reference-contexts: To address these concerns, this paper explores using fast alias analyses that rely on programming language types. While prior work <ref> [1, 6] </ref> mentions using type compatibility for alias analysis, none evaluates the idea or presents the details of an algorithm. This paper describes and evaluates three fast alias analyses based on programming language types. The first analysis (TypeDecl ) uses type compatibility to determine aliases. <p> Wall [34] does not evaluate an existing alias analysis as we do, but just gives the potential of a perfect alias analysis for instruction level parallelism. Aho, et al. [1] and Chase, et al. <ref> [6] </ref> were among the first to notice that using programming language types could improve alias analysis, but did not present algorithms that did so. Our alias algorithm is most similar to those of Rinard and Diniz [26], Steensgaard [32], and Ruf [27, 28].
Reference: [7] <author> Jong-Deok Choi, Michael Burke, and Paul Carini. </author> <title> Efficient flow-sensitive interprocedural computation of pointer-induced aliases and side effects. </title> <booktitle> In Conference Record of the Twentieth Annual ACM SIGACT/SIGPLAN Symposium on Principles of Programming Languages, </booktitle> <pages> pages 232245, </pages> <address> Charleston, SC, </address> <month> January </month> <year> 1993. </year>
Reference: [8] <author> Keith Cooper and John Lu. </author> <title> Register promotion in c programs. </title> <booktitle> In Proceedings of the ACM SIGPLAN '97 Conference on Programming Language Design and Implementation, </booktitle> <address> Las Vegas, Nevada, </address> <month> June </month> <year> 1997. </year>
Reference-contexts: A static analysis that compares the resulting number of optimization opportunities remedies some of this problem. Dynamic Evaluation. A few researchers recently evaluated alias analyses by measuring the execution-time improvement due to an optimization that uses alias analysis <ref> [19, 36, 8, 17] </ref>. Using run-time improvements complements static metrics, since run-time improvements directly measure the impact of the alias analysis on its clients (usually compiler optimizations). However, one of their disadvantages is that the results are specific to the given program inputs. Limit Evaluation. <p> 800 932 29550 589 21802 589 21802 postcard 1038 4208 30890 1623 5278 1615 5262 m3cg 4515 16521 1409449 6154 121476 6153 120525 little or no room for improvement in TBAA. 3.4.1 Redundant Load Elimination Redundant load elimination (RLE) combines variants of loop invariant code motion (similar to register promotion <ref> [8] </ref>) and common subexpression elimination [1], which most optimizing compilers perform. RLE differs from classic loop invariant code motion and common subexpression elimination in that it eliminates redundant loads instead of redundant computation. <p> Ruf [27] compares a context sensitive alias analysis to a context insensitive alias analysis and finds, for his benchmarks, that they are comparable in precision. Our work supports his in that we also find that a simple alias analysis can yield very precise results. Cooper and Lu <ref> [8] </ref> describe and evaluate register promotion, an optimization that moves memory references out of loops and into registers. They evaluate register promotion with two alias analyses: a trivial analysis and a flow-sensitive alias analysis.
Reference: [9] <author> Keith D. Cooper and Ken Kennedy. </author> <title> Fast interprocedural alias analysis. </title> <booktitle> In Conference Record of the Sixteenth Annual ACM SIGACT/SIGPLAN Symposium on Principles of Programming Languages, </booktitle> <pages> pages 4959, </pages> <year> 1989. </year>
Reference: [10] <author> Jeffery Dean, Greg DeFouw, David Grove, Vassily Litvinov, and Craig Chambers. </author> <title> Vortex: An optimizing compiler for object-oriented languages. </title> <booktitle> In Proceedings of the ACM SIGPLAN '96 Conference on Object-Oriented Programming Systems, Languages, and Applications, </booktitle> <pages> pages 83100, </pages> <address> San Jose, CA, </address> <month> October </month> <year> 1996. </year>
Reference-contexts: None of these programs were written to be benchmarks, but other researchers have used several of them in previous studies <ref> [16, 10] </ref>. Table 4 contains the data for the original programs (i.e., without the optimizations proposed here) but with GCC's standard optimizations turned on, which include register allocation and instruction scheduling (except for m2tom3).
Reference: [11] <author> Saumya Debray, Robert Muth, and Matthew Weippert. </author> <title> Alias analysis of executable code. </title> <booktitle> In Conference Record of the Twentyfifth Annual ACM SIGPLAN/SIGACT Symposium on Principles of Programming Languages, </booktitle> <year> 1998. </year>
Reference-contexts: Similarly, Ghiya and Hendren [17] use pointer analysis to improve scalar optimizations, and present run-time improvements. This work was concurrent with ours, They do not present a limit study. Debray et al. <ref> [11] </ref> describe an alias analysis for executable code. They evaluate their algorithm by measuring the percentage of loads eliminated by redundant load elimination. They do not present execution time improvements or a limit study for their alias analysis.
Reference: [12] <author> Digital Equipment Corporation. </author> <title> DEC3000 300/400/500/600/800 Models: System Programmer's Manual, </title> <address> 1 edition, </address> <month> September </month> <year> 1993. </year> <title> First Printing. </title>
Reference-contexts: RLE combines loop invariant code motion and common subexpression elimination of memory references. TBAA and RLE combine to improve simulated program performance modestly, by an average of 4%, and up to 8% on a DEC Alpha 3000-500 <ref> [12] </ref> for 8 Modula-3 benchmarks. We also compare TBAA to an upper bound that represents the best any alias analysis algorithm could hope to do for RLE. This comparison shows that a perfect alias analysis could at most eliminate an average of 2.5% more heap loads.
Reference: [13] <author> Amer Diwan. </author> <title> Understanding and improving the performance of modern programming languages. </title> <type> PhD thesis, </type> <institution> University of Massachusetts, </institution> <address> Amherst, MA 01003, </address> <month> October </month> <year> 1996. </year>
Reference-contexts: We instrument every load in an executable, recording its address and value. If the most recent previous load of an address is redundant with the current load, we mark it as redundant. (Elsewhere we describe this process in more detail <ref> [13] </ref>.) In Figure 9, the black bars give the fraction of heap references that are redundant in the original program. The white bars give the fraction of heap references that are redundant after TBAA and RLE (this fraction is with respect to the original number of heap references).
Reference: [14] <author> Amer Diwan, Eliot Moss, and Kathryn S. McKinley. </author> <title> Simple and effective analysis of statically typed object-oriented programs. </title> <booktitle> In Proceedings of the ACM SIGPLAN '96 Conference on Object-Oriented Programming Systems, Languages, and Applications, </booktitle> <address> San Jose, CA, </address> <month> October </month> <year> 1996. </year>
Reference: [15] <author> Maryam Emami, Rakesh Ghiya, and Laurie J. Hendren. </author> <title> Context-sensitive interprocedural Points-to analysis in the presence of function pointers. </title> <booktitle> In Proceedings of the ACM SIGPLAN '94 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 242256, </pages> <month> June </month> <year> 1994. </year>
Reference: [16] <author> Mary F. Fernandez. </author> <title> Simple and effective link-time optimization of Modula-3 programs. </title> <booktitle> In Proceedings of Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 103115, </pages> <address> La Jolla, CA, </address> <month> June </month> <year> 1995. </year> <title> SIGPLAN, </title> <publisher> ACM Press. </publisher>
Reference-contexts: None of these programs were written to be benchmarks, but other researchers have used several of them in previous studies <ref> [16, 10] </ref>. Table 4 contains the data for the original programs (i.e., without the optimizations proposed here) but with GCC's standard optimizations turned on, which include register allocation and instruction scheduling (except for m2tom3).
Reference: [17] <author> Rakesh Ghiya and Laurie J. Hendren. </author> <title> Putting pointer analysis to work. </title> <booktitle> In Conference Record of the Twentyfifth Annual ACM SIGPLAN/SIGACT Symposium on Principles of Programming Languages, </booktitle> <year> 1998. </year>
Reference-contexts: A static analysis that compares the resulting number of optimization opportunities remedies some of this problem. Dynamic Evaluation. A few researchers recently evaluated alias analyses by measuring the execution-time improvement due to an optimization that uses alias analysis <ref> [19, 36, 8, 17] </ref>. Using run-time improvements complements static metrics, since run-time improvements directly measure the impact of the alias analysis on its clients (usually compiler optimizations). However, one of their disadvantages is that the results are specific to the given program inputs. Limit Evaluation. <p> They evaluate their algorithms by counting optimization opportunities rather than any of the metrics that we use. They find that clients of alias analysis may run faster with a more precise alias analysis than with a less precise alias analysis. Similarly, Ghiya and Hendren <ref> [17] </ref> use pointer analysis to improve scalar optimizations, and present run-time improvements. This work was concurrent with ours, They do not present a limit study. Debray et al. [11] describe an alias analysis for executable code.
Reference: [18] <author> John Hennessy and David Patterson. </author> <booktitle> Computer Architecture </booktitle>
Reference-contexts: RLE differs from classic loop invariant code motion and common subexpression elimination in that it eliminates redundant loads instead of redundant computation. We expect RLE to be a profitable optimization since loads are expensive on modern machines and architects expect they will only get more expensive <ref> [18] </ref>. RLE hoists memory references out of loops if the reference is loop invariant and is executed on every iteration of the loop, leaving it up to the back end to place the hoisted memory reference in a register.
References-found: 18

