URL: ftp://ftp.cs.washington.edu/tr/1993/04/UW-CSE-93-04-02.PS.Z
Refering-URL: http://www.cs.washington.edu/homes/levy/opal/opalpapers.html
Root-URL: 
Title: Sharing and Protection in a Single Address Space Operating System  
Author: Jeffrey S. Chase, Henry M. Levy, Michael J. Feeley, and Edward D. Lazowska 
Address: Seattle, WA 98195 USA  
Affiliation: Department of Computer Science and Engineering, FR-35 University of Washington,  
Date: May 1994)  
Note: (to appear in ACM Transactions on Computer Systems,  
Abstract: Technical Report 93-04-02 April 1993 (revised January 1994) 
Abstract-found: 1
Intro-found: 1
Reference: [Allchin & McKendry 83] <author> Allchin, J. and McKendry, M. </author> <title> Synchronization and recovery of actions. </title> <booktitle> In Proceedings of the 2nd ACM Symposium on Principles of Distributed Computing, </booktitle> <pages> pages 31-44, </pages> <month> August </month> <year> 1983. </year>
Reference-contexts: This strict model of fully disjoint protection accommodates distribution, is tempting in its simplicity, and is central to both "server-structured" [Young et al. 87, Rozier et al. 88, Mullender & Tanenbaum 86, Custer 93] and "object-oriented" <ref> [Allchin & McKendry 83, Almes et al. 85] </ref> systems. However, we believe it is too simplistic and confining for several reasons: * Asymmetric trust relationships are common and can be exploited: A might accept inputs (or memory segments) from B even when B does not trust A. <p> Our performance and generality are comparable to standard page-based systems, but with improved support for sharing. 7.4 Object-Based Operating Systems and Languages Early object-based operating systems, such as Hydra [Wulf et al. 75], Eden [Almes et al. 85], and Clouds <ref> [Allchin & McKendry 83] </ref>, support operating system objects addressed via capabilities. Objects in Eden and Clouds are coarse-grained, meaning that they are implemented as separate virtual address spaces; object encapsulation is enforced by hard protection boundaries.
Reference: [Almes et al. 85] <author> Almes, G. T., Black, A. P., Lazowska, E. D., and Noe, J. D. </author> <title> The Eden system: A technical review. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> SE-11(1):43-59, </volume> <month> January </month> <year> 1985. </year>
Reference-contexts: This strict model of fully disjoint protection accommodates distribution, is tempting in its simplicity, and is central to both "server-structured" [Young et al. 87, Rozier et al. 88, Mullender & Tanenbaum 86, Custer 93] and "object-oriented" <ref> [Allchin & McKendry 83, Almes et al. 85] </ref> systems. However, we believe it is too simplistic and confining for several reasons: * Asymmetric trust relationships are common and can be exploited: A might accept inputs (or memory segments) from B even when B does not trust A. <p> Our performance and generality are comparable to standard page-based systems, but with improved support for sharing. 7.4 Object-Based Operating Systems and Languages Early object-based operating systems, such as Hydra [Wulf et al. 75], Eden <ref> [Almes et al. 85] </ref>, and Clouds [Allchin & McKendry 83], support operating system objects addressed via capabilities. Objects in Eden and Clouds are coarse-grained, meaning that they are implemented as separate virtual address spaces; object encapsulation is enforced by hard protection boundaries.
Reference: [Anderson et al. 86] <author> Anderson, M., Pose, R. D., and Wallace, C. S. </author> <title> The password-capability system. </title> <journal> The Computer Journal, </journal> <volume> 29(1) </volume> <pages> 1-8, </pages> <month> February </month> <year> 1986. </year>
Reference-contexts: A name service supports symbolic names for capabilities, with access control lists (ACLs) for protection. Opal uses password capabilities <ref> [Anderson et al. 86] </ref>, similar to those in Amoeba [Mullender & Tanenbaum 86] and Chorus [Rozier et al. 88], rather than Mach-style capa bilities (also called port rights [Young et al. 87]).
Reference: [Anderson et al. 92] <author> Anderson, T. E., Bershad, B. N., Lazowska, E. D., and Levy, H. M. </author> <title> Scheduler activations: Effective kernel support for the user-level management of parallelism. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 10(1) </volume> <pages> 53-79, </pages> <month> February </month> <year> 1992. </year>
Reference-contexts: ACLs are not implemented in our current prototype; access is always granted to any published or symbolically named capability. 2 Portals were designed as a kernel primitive for implementing protected procedure call (e.g., LRPC [Bershad et al. 90]), particularly in a system with user-level threads based on scheduler activations <ref> [Anderson et al. 92] </ref>. 7 3.4 Using Protection Domains A thread running in one protection domain (the parent domain) can create a new (more restricted) domain (a child), typically to protect the parent's data from an untrusted subprogram. <p> Finally, the Mach thread interface is used as the basis for our user-mode thread package, rather than scheduler activations <ref> [Anderson et al. 92] </ref>.
Reference: [Bershad et al. 90] <author> Bershad, B., Anderson, T., Lazowska, E., and Levy, H. </author> <title> Lightweight remote procedure call. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 8(1), </volume> <month> February </month> <year> 1990. </year>
Reference-contexts: ACLs are not implemented in our current prototype; access is always granted to any published or symbolically named capability. 2 Portals were designed as a kernel primitive for implementing protected procedure call (e.g., LRPC <ref> [Bershad et al. 90] </ref>), particularly in a system with user-level threads based on scheduler activations [Anderson et al. 92]. 7 3.4 Using Protection Domains A thread running in one protection domain (the parent domain) can create a new (more restricted) domain (a child), typically to protect the parent's data from an <p> More importantly, the cost for an Opal cross-domain call is 133 s, which compares favorably with cross-address space calls on Mach (88 s) and other systems <ref> [Bershad et al. 90] </ref>.
Reference: [Bershad et al. 93] <author> Bershad, B., Zekauskas, M., and Sawdon, W. </author> <title> The Midway distributed shared memory system. </title> <booktitle> In Proceedings of the 1993 IEEE Computer Conference, </booktitle> <month> February </month> <year> 1993. </year>
Reference-contexts: We believe that solutions to problems such as coherency and recoverability should be applied at the application level, through a mix of language support, runtime support, and customized external paging servers. That is, many solutions exist (e.g., <ref> [Carter et al. 91, Bershad et al. 93] </ref>), and the operating system should not dictate a single model for coherency and recoverability to all applications. For example, collaborative work applications need different models than do parallel programs.
Reference: [Carter et al. 91] <author> Carter, J. B., Bennett, J. K., and Zwaenepoel, W. </author> <title> Implementation and performance of Munin. </title> <booktitle> In Proceedings of the Thirteenth Symposium on Operating Systems Principles, </booktitle> <pages> pages 152-164. </pages> <publisher> ACM, </publisher> <month> October </month> <year> 1991. </year> <month> 29 </month>
Reference-contexts: We believe that solutions to problems such as coherency and recoverability should be applied at the application level, through a mix of language support, runtime support, and customized external paging servers. That is, many solutions exist (e.g., <ref> [Carter et al. 91, Bershad et al. 93] </ref>), and the operating system should not dictate a single model for coherency and recoverability to all applications. For example, collaborative work applications need different models than do parallel programs.
Reference: [Chang & Mergen 88] <author> Chang, A. and Mergen, M. F. </author> <title> 801 storage: Architecture and programming. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 6(1) </volume> <pages> 28-50, </pages> <month> February </month> <year> 1988. </year>
Reference-contexts: For example, multiple instances of a database program may prefer to execute in separate domains to enforce different access privileges, or to use protection faults to drive implicit locking <ref> [Chang & Mergen 88] </ref>. * Tradeoffs between protection and performance are unavoidable. Complete isolation can never be achieved: even if protection is fully disjoint, granularity tradeoffs still must be made. Also, programs may have naturally overlapping access to stored data, and this may not be known in advance. <p> In this section we discuss several previous systems, contrasting them with Opal's concepts, mechanisms, and goals. 7.1 Multics and Other Segmented Systems Opal is similar to Multics [Daley & Dennis 68] and other segmented systems <ref> [Chang & Mergen 88, Groves & Oehler 90] </ref> in (1) its use of medium-grained virtual memory segments as the units of 24 memory protection and access control, and (2) its emphasis on dynamic sharing and memory- mapped persistent storage.
Reference: [Chao et al. 90] <author> Chao, C., Mackey, M., and Sears, B. </author> <title> Mach on a virtually addressed cache architecture. </title> <booktitle> In Usenix Mach Workshop Proceedings, </booktitle> <pages> pages 31-51, </pages> <month> October </month> <year> 1990. </year>
Reference-contexts: Copy-on-write introduces only a benign form of aliasing called read-only aliasing <ref> [Chao et al. 90] </ref>. Read-only aliasing is a hidden optimization that neither violates the consistent interpretation of pointers nor interferes with the use of a virtually-addressed cache.
Reference: [Chase et al. 89] <author> Chase, J. S., Amador, F. G., Lazowska, E. D., Levy, H. M., and Littlefield, R. J. </author> <title> The Amber system: Parallel programming on a network of multiprocessors. </title> <booktitle> In Proceedings of the 12th ACM Symposium on Operating System Principles, </booktitle> <pages> pages 147-158, </pages> <month> December </month> <year> 1989. </year>
Reference-contexts: We are currently extending our prototype in various ways, for example, to support distribution across a small cluster of workstations. Our basic approach is to use a trusted server that preallocates coarse address ranges to cluster nodes on request (as in Amber <ref> [Chase et al. 89] </ref>); the server also provides stable backing storage for the global virtual memory.
Reference: [Cockshot et al. 84] <author> Cockshot, W. P., Atkinson, M. P., and Chisholm, K. J. </author> <title> Persistent object management system. </title> <journal> Software Practice and Experience, </journal> <volume> 14(1), </volume> <month> January </month> <year> 1984. </year>
Reference-contexts: The Hemlock approach simplifies many aspects of linking, but it complicates the use of a given code module to operate on both private and shared data. 7.7 Swizzling Swizzling <ref> [Cockshot et al. 84] </ref> is a method of simulating a large address space on smaller address hardware by translating pointers (from short "inform" to long "outform", or vice versa) when they are moved in and out of memory.
Reference: [Custer 93] <author> Custer, H. </author> <title> Inside Windows/NT. </title> <publisher> Microsoft Press, </publisher> <year> 1993. </year>
Reference-contexts: In a single address space model, the system rather than the applications coordinates the address bindings, to accommodate dynamic sharing patterns in a uniform way. Recent systems have taken steps in this direction; examples include based sections in Microsoft Windows/NT <ref> [Custer 93] </ref> and the mmap facilities in recent Unix systems. Even in these systems, however, the mix of shared and private regions introduces several problems.
Reference: [Daley & Dennis 68] <author> Daley, R. C. and Dennis, J. B. </author> <title> Virtual memory, processes, and sharing in Multics. </title> <journal> Communications of the ACM, </journal> <volume> 11(5) </volume> <pages> 306-312, </pages> <month> May </month> <year> 1968. </year>
Reference-contexts: Opal provides a single global virtual address space that is shared by all procedures and all data. Crucial to the design is the full separation of addressing and protection, which are intimately bound in the "process" concept of systems such as Unix and Multics <ref> [Daley & Dennis 68] </ref>. The fundamental principle of the Opal system is that addresses have a unique interpretation, for all applications, for potentially all time. Virtual addresses are context-independent: they resolve to the same data, independently of who uses them. <p> The concepts in Opal are related to those of many previous hardware and software systems spanning over 25 years, for example, Multics <ref> [Daley & Dennis 68] </ref>, Hydra [Wulf et al. 75], Pilot [Redell et al. 80], Mon-ads [Rosenberg & Abramson 85], Intel 432 [Organick 83], IBM System 38 [Houdek et al. 81], Psy che [Scott et al. 90], and the early work on capability systems [Dennis & Van Horn 66]. <p> It accommodates alternative language and data models, and relies on language-based facilities for fine-grained protection and storage management. In this section we discuss several previous systems, contrasting them with Opal's concepts, mechanisms, and goals. 7.1 Multics and Other Segmented Systems Opal is similar to Multics <ref> [Daley & Dennis 68] </ref> and other segmented systems [Chang & Mergen 88, Groves & Oehler 90] in (1) its use of medium-grained virtual memory segments as the units of 24 memory protection and access control, and (2) its emphasis on dynamic sharing and memory- mapped persistent storage.
Reference: [Dennis & Van Horn 66] <author> Dennis, J. B. and Van Horn, E. C. </author> <title> Programming semantics for multipro-grammed computations. </title> <journal> Communications of the ACM, </journal> <volume> 9(3) </volume> <pages> 143-155, </pages> <month> March </month> <year> 1966. </year>
Reference-contexts: spanning over 25 years, for example, Multics [Daley & Dennis 68], Hydra [Wulf et al. 75], Pilot [Redell et al. 80], Mon-ads [Rosenberg & Abramson 85], Intel 432 [Organick 83], IBM System 38 [Houdek et al. 81], Psy che [Scott et al. 90], and the early work on capability systems <ref> [Dennis & Van Horn 66] </ref>. A detailed discussion and comparison with these systems is provided in Section 7. <p> An early description of a software system with protection domains, capabilities, and dynamic sharing appeared in the late 1960s <ref> [Dennis & Van Horn 66] </ref>, and many systems tried to implement that approach. We believe that Opal is significant because it exploits modern 64-bit processors to meet the goals of previous systems in a way that is simple, general, and efficient.
Reference: [Dig 92] <institution> Digital Equipment Corporation, Maynard, MA. Alpha Architecture Handbook, </institution> <year> 1992. </year>
Reference-contexts: 1 Introduction The appearance of 64-bit address space architectures, such as the DEC Alpha <ref> [Dig 92] </ref>, HP PA-RISC [Lee 89], and MIPS R4000 [MIP 91], signals a radical increase in the amount of address space available to operating systems and applications. This shift provides the opportunity to reexamine fundamental operating system structure specifically, to change the way that operating systems use address space.
Reference: [Druschel & Peterson 92] <author> Druschel, P. and Peterson, L. </author> <title> High performance cross-domain data transfer. </title> <type> Technical Report 92-11, </type> <institution> University of Arizona, Department of Computer Science, </institution> <month> June </month> <year> 1992. </year>
Reference-contexts: greatly simplifies that sharing. 27 7.8 Alternative Usage of Large Address Spaces Several other researchers have proposed using a single wide virtual address space to reduce the cost of protection. [Okamoto et al. 92] suggests MMU hardware that uses the current value of the PC to determine memory access permissions. <ref> [Druschel & Peterson 92] </ref> points out that shared segments can be protected from accidental error and even malicious use by "hiding" them in the large address space.
Reference: [Druschel et al. 92] <author> Druschel, P., Peterson, L. L., and Hutchinson, N. C. </author> <title> Decoupling modularity and protection in Lipto. </title> <booktitle> In Proceedings of the 12th International Conference on Distributed Computing Systems, </booktitle> <month> June </month> <year> 1992. </year>
Reference-contexts: Complete isolation can never be achieved: even if protection is fully disjoint, granularity tradeoffs still must be made. Also, programs may have naturally overlapping access to stored data, and this may not be known in advance. Fundamentally, we believe (as do others <ref> [Druschel et al. 92] </ref>) that operating system protection structures are not the right level to impose modularity. In fact, protection structures do not impose modularity, they only enforce selected module boundaries.
Reference: [Fabry 74] <author> Fabry, R. S. </author> <title> Capability-based addressing. </title> <journal> Communications of the ACM, </journal> <volume> 17(7) </volume> <pages> 403-412, </pages> <month> July </month> <year> 1974. </year>
Reference-contexts: However, we also want to support multiple safe and unsafe languages, as well as stronger isolation for those who want or need it. 7.3 Capability-Based Architectures Opal's goals are similar in some ways to capability-based hardware systems <ref> [Fabry 74, Levy 84] </ref>. For example, the Intel 432 [Organick 83] emphasized uniform addressing as a basis for supporting sharing and cooperation.
Reference: [Feeley et al. 93] <author> Feeley, M. J., Chase, J. S., and Lazowska, E. D. </author> <title> User-level threads and interpro-cess communication. </title> <type> Technical Report 93-02-03, </type> <institution> University of Washington, Department of Computer Science and Engineering, </institution> <month> March </month> <year> 1993. </year>
Reference-contexts: Second, the thread scheduler adjusts processor usage within each domain as processors move between domains for RPC calls and returns. The thread package is discussed in more detail in <ref> [Feeley et al. 93] </ref>. Thread descriptors and thread stacks are allocated from ordinary heap segments. The thread descriptors hold pointers to some additional thread-specific state.
Reference: [Garrett et al. 93] <author> Garrett, W., Scott, M., Bianchini, R., Kontothanassis, L., McCallum, R., Thomas, J., Wisniewski, R., and Luk, S. </author> <title> Linking shared segments. </title> <booktitle> In Proceedings of the Winter 1993 Usenix, </booktitle> <month> January </month> <year> 1993. </year>
Reference-contexts: one or more protected calls, possibly causing the domains to call each other or the parent. 3.5 Linking and Executing Code The handling of executable code modules in systems such as Opal differs in several respects from that of conventional systems. (This topic is the focus of related work by <ref> [Garrett et al. 93] </ref>.) We wish to make three points in this section: (1) the essentials of linking and execution are the same in both classes of systems, (2) sharing and dynamic use of code modules is easy in the shared address space, and (3) support of private data in shared <p> In contrast, Opal focuses on using domains to protect shared information in a multi-user operating system. We generally assume that cooperating components use the same programming model. Hemlock <ref> [Garrett et al. 93] </ref> extends the Psyche work to a Unix context, adding memory-mapped persistent storage and dynamic linking to shared code modules that encapsulate shared data.
Reference: [Griswold & Notkin 90] <author> Griswold, W. and Notkin, D. </author> <title> Program restructuring to aid software maintenance. </title> <type> Technical Report 90-08-05, </type> <institution> University of Washington, Department of Computer Science and Engineering, </institution> <month> September </month> <year> 1990. </year>
Reference-contexts: The event manager sets up the appropriate connections and attachments among tools and mediators. Our mediator implementation is a test system built for demonstration purposes; however, the mediator paradigm has been used to implement interesting systems for program restructuring <ref> [Griswold & Notkin 90] </ref>, computer-aided geometric design [McCabe 91], and radiotherapy planning [Kalet et al. 91], among others. 5.2.2 An Example of Structuring Using Opal Mediators Opal applications built using mediators can be transparently configured to use different protection arrangements, including overlapping protection domains and shared memory.
Reference: [Groves & Oehler 90] <author> Groves, R. D. and Oehler, R. </author> <title> RISC system/6000 processor architecture. </title> <editor> In Misra, M., editor, </editor> <booktitle> IBM RISC System/6000 Technology, </booktitle> <pages> pages 16-23. </pages> <booktitle> International Business Machines, </booktitle> <year> 1990. </year>
Reference-contexts: In this section we discuss several previous systems, contrasting them with Opal's concepts, mechanisms, and goals. 7.1 Multics and Other Segmented Systems Opal is similar to Multics [Daley & Dennis 68] and other segmented systems <ref> [Chang & Mergen 88, Groves & Oehler 90] </ref> in (1) its use of medium-grained virtual memory segments as the units of 24 memory protection and access control, and (2) its emphasis on dynamic sharing and memory- mapped persistent storage.
Reference: [Houdek et al. 81] <author> Houdek, M., Soltis, F., and Hoffman, R. L. </author> <title> IBM System/38 support for capability-based addressing. </title> <booktitle> In Proc. of the 8th Symposium on Computer Architecture, </booktitle> <month> May </month> <year> 1981. </year> <month> 30 </month>
Reference-contexts: The concepts in Opal are related to those of many previous hardware and software systems spanning over 25 years, for example, Multics [Daley & Dennis 68], Hydra [Wulf et al. 75], Pilot [Redell et al. 80], Mon-ads [Rosenberg & Abramson 85], Intel 432 [Organick 83], IBM System 38 <ref> [Houdek et al. 81] </ref>, Psy che [Scott et al. 90], and the early work on capability systems [Dennis & Van Horn 66]. A detailed discussion and comparison with these systems is provided in Section 7. <p> Because the underlying virtual address space on the physical hardware was too small, the result has always been an emulation, at one level or another, of a large address space system on a small address space machine. 25 The IBM System/38 <ref> [Houdek et al. 81, Soltis 81] </ref> and IBM AS/400 [IBM 88] are coarser-grained and very similar to Opal in their protection model and granularity.
Reference: [Huck & Hays 93] <author> Huck, J. and Hays, J. </author> <title> Architectural support for translation table management in large address space machines. </title> <booktitle> In Proceedings of the 20th Annual International Symposium on Computer Architecture, </booktitle> <month> May </month> <year> 1993. </year>
Reference-contexts: Specifically, address overloading is eliminated. This removes ambiguity in virtual tags in processor caches, as well as the need to maintain separate tables of virtual-physical translations for each process [Koldinger et al. 92]. On processors equipped with software-loaded TLBs, it permits the use of alternative translation table structures (e.g., <ref> [Huck & Hays 93] </ref>) that 3 better accommodate large, sparse virtual memories. (On the negative side, this property prohibits programs from mapping different data at the same virtual addresses. <p> First, the Mach virtual memory system was designed for private address spaces, with a separate translation map for each domain; a global hashed page directory (as in the HP PA-RISC <ref> [Huck & Hays 93] </ref> system and others) would be better suited to Opal's single address space.
Reference: [IBM 88] <institution> IBM. Application System/400 Technology. International Business Machines, </institution> <year> 1988. </year>
Reference-contexts: Because the underlying virtual address space on the physical hardware was too small, the result has always been an emulation, at one level or another, of a large address space system on a small address space machine. 25 The IBM System/38 [Houdek et al. 81, Soltis 81] and IBM AS/400 <ref> [IBM 88] </ref> are coarser-grained and very similar to Opal in their protection model and granularity.
Reference: [Jul et al. 88] <author> Jul, E., Levy, H., Hutchinson, N., and Black, A. </author> <title> Fine-grained mobility in the Emerald system. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 6(1) </volume> <pages> 109-133, </pages> <month> February </month> <year> 1988. </year>
Reference-contexts: Furthermore, programmers can move the protection boundaries between objects to achieve the desired balance between protection and performance, without affecting the modular structure of the program. Object-based distributed languages, such as Emerald <ref> [Jul et al. 88] </ref> and Guide-1 [Krakowiak et al. 90], provide lightweight support for fine-grained objects in a distributed global address space. Again, the global address space exists at the object ID level, and translation of addresses is required for communication and storage.
Reference: [Kalet et al. 91] <author> Kalet, I., Jacky, J., Kromhout-Shiro, S., Niehaus, M., Sweeney, C., and Unger, J. </author> <title> The Prism radiation treatment planning system. </title> <type> Technical Report 91-10-03, </type> <institution> University of Washington, Radiation Oncology Department, </institution> <month> October </month> <year> 1991. </year>
Reference-contexts: Our mediator implementation is a test system built for demonstration purposes; however, the mediator paradigm has been used to implement interesting systems for program restructuring [Griswold & Notkin 90], computer-aided geometric design [McCabe 91], and radiotherapy planning <ref> [Kalet et al. 91] </ref>, among others. 5.2.2 An Example of Structuring Using Opal Mediators Opal applications built using mediators can be transparently configured to use different protection arrangements, including overlapping protection domains and shared memory. To illustrate the structuring options and their performance, we implemented a simple mediator-based application.
Reference: [Koldinger et al. 92] <author> Koldinger, E. J., Chase, J. S., and Eggers, S. J. </author> <title> Architectural support for single address space operating systems. </title> <booktitle> In Proceedings of the Fifth International Conference on Architectural Support for Programming Languages and Operating Systems, </booktitle> <institution> Department of Computer Science and Engineering, </institution> <month> October </month> <year> 1992. </year> <journal> ACM SIGOPS Operating System Review, </journal> <volume> Volume 26. </volume>
Reference-contexts: Furthermore, the single address space structure has properties that can be exploited by the memory system implementation. Specifically, address overloading is eliminated. This removes ambiguity in virtual tags in processor caches, as well as the need to maintain separate tables of virtual-physical translations for each process <ref> [Koldinger et al. 92] </ref>. On processors equipped with software-loaded TLBs, it permits the use of alternative translation table structures (e.g., [Huck & Hays 93]) that 3 better accommodate large, sparse virtual memories. (On the negative side, this property prohibits programs from mapping different data at the same virtual addresses.
Reference: [Kotz & Crow 94] <author> Kotz, D. and Crow, P. </author> <title> The expected lifetime of "single-address-space" operating systems. </title> <booktitle> In Proceedings of the ACM Conference on Measurement and Modeling of Computer Systems (SIGMETRICS 94), </booktitle> <year> 1994. </year> <type> (Technical Report PCS-TR93-198, </type> <institution> Dept. of Mathematics and Computer Science, Dartmouth College). </institution>
Reference-contexts: Recycling is necessary at present given the terabyte-range virtual spaces implemented on current wide-address processors. Opal avoids recycling as long as it can; if the address space is "large enough" then addresses will never be recycled. <ref> [Kotz & Crow 94] </ref> compare several address space allocation and recycling policies for single address space systems. 22 6.3 Unix-style Fork The Unix fork operation copies a parent process' context, including its private address space, into a child process.
Reference: [Krakowiak et al. 90] <author> Krakowiak, S., Meysembourg, M., Van, H. N., Riveill, M., Roisin, C., and Rousset de Pina, X. </author> <title> Design and implementation of an object-oriented, strongly typed language for distributed aapplications. </title> <journal> Journal of Object-Oriented Programming, </journal> <volume> 3(3):11 - 22, </volume> <month> September </month> <year> 1990. </year>
Reference-contexts: Furthermore, programmers can move the protection boundaries between objects to achieve the desired balance between protection and performance, without affecting the modular structure of the program. Object-based distributed languages, such as Emerald [Jul et al. 88] and Guide-1 <ref> [Krakowiak et al. 90] </ref>, provide lightweight support for fine-grained objects in a distributed global address space. Again, the global address space exists at the object ID level, and translation of addresses is required for communication and storage.
Reference: [Lamb et al. 91] <author> Lamb, C., Landis, G., Orenstein, J., and Weinreb, D. </author> <title> The ObjectStore database system. </title> <journal> Communications of the ACM, </journal> <volume> 34(10), </volume> <month> October </month> <year> 1991. </year>
Reference-contexts: Swizzling has recently gained new popularity as a means of supporting a persistent store <ref> [Wilson 91, Lamb et al. 91] </ref>. As described in Section 2.2, we believe that swizzling should be reserved for exceptional cases, such as relocating groups of objects from one network address space to another.
Reference: [Lee 89] <author> Lee, R. B. </author> <title> Precision architecture. </title> <booktitle> IEEE Computer, </booktitle> <pages> pages 78-91, </pages> <month> January </month> <year> 1989. </year>
Reference-contexts: 1 Introduction The appearance of 64-bit address space architectures, such as the DEC Alpha [Dig 92], HP PA-RISC <ref> [Lee 89] </ref>, and MIPS R4000 [MIP 91], signals a radical increase in the amount of address space available to operating systems and applications. This shift provides the opportunity to reexamine fundamental operating system structure specifically, to change the way that operating systems use address space. <p> In contrast, all Opal segments, including persistent segments, are simultaneously and directly visible (given proper protection) in virtual memory by all applications. Linked data structures in Opal can easily span segments, perhaps with different access controls. In this respect Opal is closer to the HP PA-RISC <ref> [Lee 89] </ref>, which supports traditional segmented addressing, but also allows applications to use global virtual addresses directly.
Reference: [Levy 84] <author> Levy, H. M. </author> <title> Capability-Based Computer Systems. </title> <publisher> Digital Press, </publisher> <address> Bedford, Massachusetts, </address> <year> 1984. </year>
Reference-contexts: However, we also want to support multiple safe and unsafe languages, as well as stronger isolation for those who want or need it. 7.3 Capability-Based Architectures Opal's goals are similar in some ways to capability-based hardware systems <ref> [Fabry 74, Levy 84] </ref>. For example, the Intel 432 [Organick 83] emphasized uniform addressing as a basis for supporting sharing and cooperation.
Reference: [McCabe 91] <author> McCabe, T. </author> <title> Programming with mediators: Developing a graphical mesh environment. </title> <type> Master's thesis, </type> <institution> Department of Computer Science and Engineering, University of Washington, </institution> <year> 1991. </year>
Reference-contexts: The event manager sets up the appropriate connections and attachments among tools and mediators. Our mediator implementation is a test system built for demonstration purposes; however, the mediator paradigm has been used to implement interesting systems for program restructuring [Griswold & Notkin 90], computer-aided geometric design <ref> [McCabe 91] </ref>, and radiotherapy planning [Kalet et al. 91], among others. 5.2.2 An Example of Structuring Using Opal Mediators Opal applications built using mediators can be transparently configured to use different protection arrangements, including overlapping protection domains and shared memory.
Reference: [McJones & Swart 87] <author> McJones, P. R. and Swart, G. F. </author> <title> Evolving the Unix system interface to support multithreaded programs. </title> <type> Technical Report 21, </type> <institution> DEC Systems Research Center, </institution> <month> September </month> <year> 1987. </year>
Reference-contexts: The copying semantics of fork also interfere with support for threads <ref> [McJones & Swart 87] </ref>. Opal replaces fork with primitives to create protection domains and initialize them by attaching segments and installing RPC endpoints. Threads in the parent domain can then make cross-domain calls to enter the child domain.
Reference: [MIP 91] <institution> MIPS Computer Systems, Inc., Sunnyvale, CA. </institution> <note> MIPS R4000 Microprocessor User's Manual, first edition, </note> <year> 1991. </year>
Reference-contexts: 1 Introduction The appearance of 64-bit address space architectures, such as the DEC Alpha [Dig 92], HP PA-RISC [Lee 89], and MIPS R4000 <ref> [MIP 91] </ref>, signals a radical increase in the amount of address space available to operating systems and applications. This shift provides the opportunity to reexamine fundamental operating system structure specifically, to change the way that operating systems use address space.
Reference: [Mullender & Tanenbaum 86] <author> Mullender, S. and Tanenbaum, A. </author> <title> The design of a capability-based operating system. </title> <journal> The Computer Journal, </journal> <volume> 29(4) </volume> <pages> 289-299, </pages> <year> 1986. </year>
Reference-contexts: A name service supports symbolic names for capabilities, with access control lists (ACLs) for protection. Opal uses password capabilities [Anderson et al. 86], similar to those in Amoeba <ref> [Mullender & Tanenbaum 86] </ref> and Chorus [Rozier et al. 88], rather than Mach-style capa bilities (also called port rights [Young et al. 87]).
Reference: [Okamoto et al. 92] <author> Okamoto, T., Segawa, H., Shin, S., Nozue, H., Maeda, K., and Saito, M. </author> <title> A micro-kernel architecture for next generation processors. </title> <booktitle> In USENIX Workshop on Microkernels and Other Kernel Architectures, </booktitle> <pages> pages 83-94, </pages> <month> April </month> <year> 1992. </year> <month> 31 </month>
Reference-contexts: The single address space greatly simplifies that sharing. 27 7.8 Alternative Usage of Large Address Spaces Several other researchers have proposed using a single wide virtual address space to reduce the cost of protection. <ref> [Okamoto et al. 92] </ref> suggests MMU hardware that uses the current value of the PC to determine memory access permissions. [Druschel & Peterson 92] points out that shared segments can be protected from accidental error and even malicious use by "hiding" them in the large address space.
Reference: [Organick 83] <author> Organick, E. I. </author> <title> A Programmer's View of the Intel 432 System. </title> <publisher> McGraw-Hill, </publisher> <year> 1983. </year>
Reference-contexts: The concepts in Opal are related to those of many previous hardware and software systems spanning over 25 years, for example, Multics [Daley & Dennis 68], Hydra [Wulf et al. 75], Pilot [Redell et al. 80], Mon-ads [Rosenberg & Abramson 85], Intel 432 <ref> [Organick 83] </ref>, IBM System 38 [Houdek et al. 81], Psy che [Scott et al. 90], and the early work on capability systems [Dennis & Van Horn 66]. A detailed discussion and comparison with these systems is provided in Section 7. <p> However, we also want to support multiple safe and unsafe languages, as well as stronger isolation for those who want or need it. 7.3 Capability-Based Architectures Opal's goals are similar in some ways to capability-based hardware systems [Fabry 74, Levy 84]. For example, the Intel 432 <ref> [Organick 83] </ref> emphasized uniform addressing as a basis for supporting sharing and cooperation.
Reference: [Pollack et al. 81] <author> Pollack, F. J., Kahn, K. C., and Wilkinson, R. M. </author> <title> The iMAX-432 object filing system. </title> <booktitle> In Proc. of the 8th ACM Symposium on Operating Systems Principles, </booktitle> <month> December </month> <year> 1981. </year>
Reference-contexts: In fact, the addressing on the 432 was not fully uniform, due in part to the way the processor address space was managed: capabilities contained only 24 address bits, which were translated to and from 80-bit UIDs <ref> [Pollack et al. 81] </ref> as objects moved between memory and persistent storage. Second, the 432 used very complex hardware-based protection structures and mechanisms to restrict access to fine-grained objects.
Reference: [Redell et al. 80] <author> Redell, D., Dalal, Y., Horsley, T., Lauer, H., Lynch, W., McJones, P., Murray, H., and Purcell, S. </author> <title> Pilot: An operating system for a personal computer. </title> <journal> Communications of the ACM, </journal> <volume> 23(2) </volume> <pages> 81-92, </pages> <month> February </month> <year> 1980. </year>
Reference-contexts: The concepts in Opal are related to those of many previous hardware and software systems spanning over 25 years, for example, Multics [Daley & Dennis 68], Hydra [Wulf et al. 75], Pilot <ref> [Redell et al. 80] </ref>, Mon-ads [Rosenberg & Abramson 85], Intel 432 [Organick 83], IBM System 38 [Houdek et al. 81], Psy che [Scott et al. 90], and the early work on capability systems [Dennis & Van Horn 66]. <p> However, most software on the PA-RISC uses short-form addresses, because they are more compact and efficient, and because they permit backward compatibility with private address space operating systems. 7.2 Cedar and Pilot The Xerox Pilot <ref> [Redell et al. 80] </ref> and Cedar [Swinehart et al. 86] systems support a single virtual address space in which all applications execute. Pilot includes a mapped file system as well.
Reference: [Rosenberg & Abramson 85] <author> Rosenberg, J. and Abramson, D. MONADS-PC: </author> <title> A capability-based workstation to support software engineering. </title> <booktitle> In Proceedings of the 18th Hawaii International Conference on System Sciences, </booktitle> <year> 1985. </year>
Reference-contexts: The concepts in Opal are related to those of many previous hardware and software systems spanning over 25 years, for example, Multics [Daley & Dennis 68], Hydra [Wulf et al. 75], Pilot [Redell et al. 80], Mon-ads <ref> [Rosenberg & Abramson 85] </ref>, Intel 432 [Organick 83], IBM System 38 [Houdek et al. 81], Psy che [Scott et al. 90], and the early work on capability systems [Dennis & Van Horn 66]. A detailed discussion and comparison with these systems is provided in Section 7. <p> Furthermore, these systems require that all applications be written in a single safe language. These languages could run above Opal and benefit from its flexible protection but Opal can support sharing of pointer-based data structures without them. 7.5 Monads Monads <ref> [Rosenberg & Abramson 85, Rosenberg 92] </ref> uses a large (60-bit) shared virtual address space that includes persistent data and spans a local network. A common goal of Monads and Opal is to remove the distinction between persistent data and transient data.
Reference: [Rosenberg 92] <author> Rosenberg, J. </author> <title> Architectural and operating system support for orthogonal persistence. </title> <journal> Computing Systems, </journal> <volume> 5(3), </volume> <month> July </month> <year> 1992. </year>
Reference-contexts: Furthermore, these systems require that all applications be written in a single safe language. These languages could run above Opal and benefit from its flexible protection but Opal can support sharing of pointer-based data structures without them. 7.5 Monads Monads <ref> [Rosenberg & Abramson 85, Rosenberg 92] </ref> uses a large (60-bit) shared virtual address space that includes persistent data and spans a local network. A common goal of Monads and Opal is to remove the distinction between persistent data and transient data.
Reference: [Rozier et al. 88] <author> Rozier, M., Abrossimov, V., Armand, F., Boule, I., Gien, M., Guillemont, M., Herrmann, F., Leonard, P., Langlois, S., and Neuhauser, W. </author> <title> Chorus distributed operating systems. </title> <journal> Computing Systems, </journal> <volume> 1(4), </volume> <year> 1988. </year>
Reference-contexts: A name service supports symbolic names for capabilities, with access control lists (ACLs) for protection. Opal uses password capabilities [Anderson et al. 86], similar to those in Amoeba [Mullender & Tanenbaum 86] and Chorus <ref> [Rozier et al. 88] </ref>, rather than Mach-style capa bilities (also called port rights [Young et al. 87]).
Reference: [Scott et al. 90] <author> Scott, M. L., LeBlanc, T. J., and Marsh, B. D. </author> <booktitle> Multi-model parallel programming in Psyche. In Proceedings of the Second ACM SIGPLAN Symposium on Principles and Practice of Parallel Programming, </booktitle> <pages> pages 70-78, </pages> <month> March </month> <year> 1990. </year>
Reference-contexts: are related to those of many previous hardware and software systems spanning over 25 years, for example, Multics [Daley & Dennis 68], Hydra [Wulf et al. 75], Pilot [Redell et al. 80], Mon-ads [Rosenberg & Abramson 85], Intel 432 [Organick 83], IBM System 38 [Houdek et al. 81], Psy che <ref> [Scott et al. 90] </ref>, and the early work on capability systems [Dennis & Van Horn 66]. A detailed discussion and comparison with these systems is provided in Section 7. <p> addresses directly, with access determined by the protection domain, (2) memory protection in Opal is segment-grained rather than object-grained, (3) Opal uses stock 64-bit processors, and (4) the data model in Opal is defined by languages and applications rather than by the system. 7.6 Psyche and Hemlock The Psyche system <ref> [Scott et al. 90] </ref> uses related concepts to explore parallel programming within a protected global address space on shared-memory multiprocessors. The focus of Psyche is building applications out of cooperating components based on different parallel programming models; these components are partially isolated in separate protection domains.
Reference: [Shapiro 86] <author> Shapiro, M. </author> <title> Structure and encapsulation in distributed systems: The proxy principle. </title> <booktitle> In Proceedings of the Sixth International Conference on Distributed Computing Systems, </booktitle> <month> May </month> <year> 1986. </year>
Reference-contexts: Opal capabilities are implemented in the runtime package, hidden from users behind a C ++ interface based on proxies <ref> [Shapiro 86] </ref>. On the client side, the capability is hidden in an ordinary C ++ object called a proxy; on the server side, the check field is stored in a corresponding object called a guard that holds a pointer to the actual object named by the capability.
Reference: [Shekita & Zwilling 90] <author> Shekita, E. and Zwilling, M. Cricket: </author> <title> A mapped, persistent object store. </title> <booktitle> In Proceedings of the Fourth International Workshop on Persistent Object Systems: Design, Implementation and Use, </booktitle> <month> September </month> <year> 1990. </year>
Reference-contexts: This is similar in many respects to the Cricket database system <ref> [Shekita & Zwilling 90] </ref>, which allows CAD tools to directly map a shared database at fixed virtual addresses.
Reference: [Siewiorek et al. 82] <author> Siewiorek, D. P., Bell, C. G., and Newell, A. </author> <title> Computer Structures: Readings and Examples. </title> <publisher> McGraw Hill Book Company, </publisher> <year> 1982. </year>
Reference-contexts: But in any case, it is clear that address sizes have leaped past the 32-bit boundary and will continue to grow. In the past, this growth has averaged one additional address bit a doubling of address space every year <ref> [Siewiorek et al. 82] </ref>. The purpose of the Opal experiment is to explore the strengths and weaknesses of the single address space approach, which is a significant departure from the traditional model of private virtual address spaces for each executing program (e.g., Unix).
Reference: [Soltis 81] <author> Soltis, F. G. </author> <title> Design of a small business data processing system. </title> <booktitle> Computer, </booktitle> <month> September </month> <year> 1981. </year>
Reference-contexts: Because the underlying virtual address space on the physical hardware was too small, the result has always been an emulation, at one level or another, of a large address space system on a small address space machine. 25 The IBM System/38 <ref> [Houdek et al. 81, Soltis 81] </ref> and IBM AS/400 [IBM 88] are coarser-grained and very similar to Opal in their protection model and granularity.
Reference: [Sullivan & Notkin 92] <author> Sullivan, K. and Notkin, D. </author> <title> Reconciling environment integration and software evolution. </title> <journal> ACM Transactions on Software Engineering, </journal> <volume> 1(3), </volume> <month> July </month> <year> 1992. </year>
Reference-contexts: We begin by describing Boeing's aircraft CAD system in order to illustrate the target application domain and its importance. We then present the results of an experiment using an Opal-based implementation of mediators, a structuring paradigm for integrated environments <ref> [Sullivan & Notkin 92] </ref>. This experiment confirms that shared memory can significantly improve performance and scala bility of integrated applications, and demonstrates that its use is compatible with sound software engineering principles. <p> We wish to support similar interactions for tools with larger and richer information structures, without this cost of converting and copying "lowest common denominator" interchange formats. 5.2.1 Mediators We have implemented a framework to facilitate these kinds of tool relationships based on a variant of mediators <ref> [Sullivan & Notkin 92] </ref>. Mediators do not solve the integration problem, but they do reduce its complexity. The idea behind mediators is that knowledge of inter-tool dependencies is factored out of the tools themselves and into separate components | mediators | that coordinate the behaviors of the tools.
Reference: [Swinehart et al. 86] <author> Swinehart, D., Zellweger, P., Beach, R., and Hagmann, R. </author> <title> A structural view of the Cedar programming environment. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 4(8), </volume> <month> October </month> <year> 1986. </year>
Reference-contexts: However, most software on the PA-RISC uses short-form addresses, because they are more compact and efficient, and because they permit backward compatibility with private address space operating systems. 7.2 Cedar and Pilot The Xerox Pilot [Redell et al. 80] and Cedar <ref> [Swinehart et al. 86] </ref> systems support a single virtual address space in which all applications execute. Pilot includes a mapped file system as well. Protection is based on the use of a single safe programming language, therefore no protection is provided or necessary at the hardware level.
Reference: [Wilson 91] <author> Wilson, P. R. </author> <title> Pointer swizzling at page fault time: Efficiently supporting huge address spaces on standard hardware. </title> <journal> ACM SIGARCH Computer Architecture News, </journal> <volume> 19(4), </volume> <month> June </month> <year> 1991. </year> <institution> University of Illinois at Chicago Technical Report UIC-EECS-90-6, </institution> <month> December </month> <year> 1990. </year>
Reference-contexts: Programming-in-the-large of pointer-based applications demands some language-level knowledge (e.g., compiler-generated templates) of the structure of the data, in order to support garbage collection and integrity checks. Such structures have been used (e.g., <ref> [Wilson 91] </ref>) and can continue to be used to transparently convert the format of data as needed when crossing boundaries outside of the single address space, whatever its scope. <p> Swizzling has recently gained new popularity as a means of supporting a persistent store <ref> [Wilson 91, Lamb et al. 91] </ref>. As described in Section 2.2, we believe that swizzling should be reserved for exceptional cases, such as relocating groups of objects from one network address space to another.
Reference: [Wulf et al. 75] <author> Wulf, W. A., Levin, R., and C.Pierson. </author> <title> Overview of the Hydra operating system development. </title> <booktitle> In Proceedings of the 5th Symposium on Operating Systems Principles, </booktitle> <pages> pages 122-131, </pages> <month> November </month> <year> 1975. </year> <month> 32 </month>
Reference-contexts: The concepts in Opal are related to those of many previous hardware and software systems spanning over 25 years, for example, Multics [Daley & Dennis 68], Hydra <ref> [Wulf et al. 75] </ref>, Pilot [Redell et al. 80], Mon-ads [Rosenberg & Abramson 85], Intel 432 [Organick 83], IBM System 38 [Houdek et al. 81], Psy che [Scott et al. 90], and the early work on capability systems [Dennis & Van Horn 66]. <p> Our performance and generality are comparable to standard page-based systems, but with improved support for sharing. 7.4 Object-Based Operating Systems and Languages Early object-based operating systems, such as Hydra <ref> [Wulf et al. 75] </ref>, Eden [Almes et al. 85], and Clouds [Allchin & McKendry 83], support operating system objects addressed via capabilities. Objects in Eden and Clouds are coarse-grained, meaning that they are implemented as separate virtual address spaces; object encapsulation is enforced by hard protection boundaries.
Reference: [Yarvin et al. 93] <author> Yarvin, C., Bukowski, R., and Anderson, T. Anonymous RPC: </author> <title> Low latency protection in a 64-bit address space. </title> <booktitle> In Proceedings of the Summer USENIX Conference, </booktitle> <month> June </month> <year> 1993. </year>
Reference-contexts: This idea is generalized in <ref> [Yarvin et al. 93] </ref> to allow an untrusted thread to operate on protected data with intra-domain "anonymous" protected calls (ARPC) at lower cost than RPC calls across a hardware-enforced protection boundary. ARPC and the Opal model are complementary, if Opal's implementation assigns segment addresses randomly (our current prototype does not).
Reference: [Young et al. 87] <author> Young, M., Tevanian, A., Rashid, R., Golub, D., Eppinger, J., Chew, J., Bolosky, W., Black, D., and Baron, R. </author> <title> The duality of memory and communication in the implementation of a multiprocessor operating system. </title> <booktitle> In Proceedings of the Eleventh ACM Symposium on Operating Systems Principles, </booktitle> <pages> pages 63-76, </pages> <month> November </month> <year> 1987. </year> <month> 33 </month>
Reference-contexts: A name service supports symbolic names for capabilities, with access control lists (ACLs) for protection. Opal uses password capabilities [Anderson et al. 86], similar to those in Amoeba [Mullender & Tanenbaum 86] and Chorus [Rozier et al. 88], rather than Mach-style capa bilities (also called port rights <ref> [Young et al. 87] </ref>). The advantage is that password capabilities can be passed directly in shared memory and used to name global resources; capabilities in Mach are meaningful only within a Mach protection context (task), preventing this sharing.
References-found: 55

