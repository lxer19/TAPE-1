URL: http://st-www.cs.uiuc.edu/~hanmer/PLoP-97/Proceedings.ps/yeates.ps
Refering-URL: http://st-www.cs.uiuc.edu/~hanmer/PLoP-97/Workshops.html
Root-URL: http://www.cs.uiuc.edu
Title: Design Patterns in Garbage Collection  
Author: Stuart A. Yeates and Michel de Champlain 
Date: October 16, 1996  
Address: New Zealand  
Affiliation: Department of Computer Science University of Canterbury,  
Abstract: An earlier version of this paper appeared in the proceedings of the fourth annual Pattern Languages of Programming (PLoP) conference, held at Allerton Park Illinois, 2-5 September 1997 Abstract This paper describes several design patterns found in garbage collectors. The patterns we present are divided into two groups. The first group are two new design patterns: Rootset and TriColour that have been used in the garbage collection domain for up to 20 years. The second group of patterns are reported in the GoF book, such as Adapter, Facade, Iterator and Proxy ,but we examine their use in the garbage collection domain. These patterns can be used by language implementors to provide a less efficient, but simpler and more flexible way of implementing and reusing garbage collectors in programming languages than current low-level and nonportable methods.
Abstract-found: 1
Intro-found: 1
Reference: <author> Baker, Henry G. </author> <year> 1978. </year> <title> List processing in Real Time on a Serial Computer. </title> <journal> Communications of the ACM, </journal> <volume> 21(4), </volume> <pages> 280-294. </pages>
Reference-contexts: objectives: * The Tolpin collector is a non-incremental mark-and-sweep collector, part of the run-time system for an Oberon-to-C translator, with access to complete type information. * The Boehm collector (Boehm & Weiser, 1988) is a general purpose collector for C/C++ with no access to type information. * The Baker78 collector <ref> (Baker, 1978) </ref> is an incremental collector for Lisp which relies heavily on the traditional Lisp type system. * The Java collector is part of run-time system in Sun Microsystems Java Developers Kit, (May 1995 release), non-incremental mark-and-sweep collector with access to complete type information. <p> Membership of each of the sets is usually indicated using a per-object bit pattern stored in each object, enabling constant time membership tests. Code Example The following example is from my implementation of a garbage collector in Java. It differs from the basic tri-colour as outlined by <ref> (Baker, 1978) </ref> by also including management of unreachable, but unreclaimed objects. This allows the objects to be reclaimed (and if necessary, finalised) incrementally, rather than during the flip, as 5 Baker does.
Reference: <author> Baker, Henry G. </author> <year> 1995a. </year> <note> Editorial. In: </note> <author> (Baker, </author> <year> 1995b). </year>
Reference-contexts: It differs from the basic tri-colour as outlined by (Baker, 1978) by also including management of unreachable, but unreclaimed objects. This allows the objects to be reclaimed (and if necessary, finalised) incrementally, rather than during the flip, as 5 Baker does. Unlike the scheme described in <ref> (Baker, 1995a) </ref>, free objects are managed externally, unreachable objects are those known to be unreachable by the application differing from Baker's fourth set of objects (which are genuinely free and available for reuse) in that by the end of the collection all have been returned to the external memory manager. register
Reference: <author> Baker, Henry G. (ed). </author> <year> 1995b. </year> <title> IWMM95. </title> <booktitle> Lecture Notes in Computer Science, </booktitle> <volume> no. 986. </volume> <publisher> Springer. </publisher>
Reference: <author> Boehm, H.-J., Demers, A. J., & Shenker, S. </author> <year> 1991 </year> <month> (June). </month> <title> Mostly Parallel Garbage Collection. </title> <booktitle> Pages 157-164 of: Proceedings of the ACM SIGPLAN 1991 Conference on Programming Language Design and Implementation. ACM. </booktitle>
Reference-contexts: Implementation Commonly the Adapter is implemented as a wrapper around the garbage collector. When this occurs, inlining can result in the elimination of the overhead of having the Adapter object, while maintaining the full flexibility. Sample Code The following C++ class is taken from the Boehm collector <ref> (Boehm et al., 1991) </ref>, where it adapts the C interface of the collector for use in C++. <p> Comments are used to clarify the interfaces' use, so users of the collector need not look at the internals of the collector, only it's interface. The following file is an abbreviated gc.h from the Boehm collector <ref> (Boehm et al., 1991) </ref>, the facade between the collector and application. #ifndef GC H #define GC H =fl Public read-only variables fl= =fl Heap size in bytes. fl= extern GC word GC heapsize; =fl Counter incremented per collection.
Reference: <author> Boehm, Hans-Juergen, & Weiser, Mark. </author> <year> 1988. </year> <title> Garbage Collection in an Uncooperative Environment. </title> <journal> Software|Practice and Experience, </journal> <volume> 18(9), </volume> <pages> 807-820. </pages>
Reference-contexts: This paper presents design patterns found in four garbage collectors, each with different target languages but similar objectives: * The Tolpin collector is a non-incremental mark-and-sweep collector, part of the run-time system for an Oberon-to-C translator, with access to complete type information. * The Boehm collector <ref> (Boehm & Weiser, 1988) </ref> is a general purpose collector for C/C++ with no access to type information. * The Baker78 collector (Baker, 1978) is an incremental collector for Lisp which relies heavily on the traditional Lisp type system. * The Java collector is part of run-time system in Sun Microsystems Java <p> As such it typically features prominently in system descriptions and informal proofs, but it is not obvious from implementations, which are usually high-optimised for speed <ref> (Boehm & Weiser, 1988) </ref>. The TriColour is also the repository for the state of the garbage collectors traversal of the heap. All incremental garbage collectors which have been studied in this work incorporate TriColour marking or an equivalent data structure.
Reference: <author> Buschmann, F., Meunier, R., Robnert, H., Sommerlad, P., & Stal, M. </author> <year> 1996. </year> <title> Pattern-Oriented Software Architecture: A system of patterns. </title> <publisher> Wiley. </publisher>
Reference: <author> Dijkstra, E. W., Lamport, L., Martin, A. J., Scholten, C. S., & Steffens, E. F. M. </author> <year> 1978. </year> <title> On-the-Fly Garbage Collection: An Exercise in Cooperation. </title> <journal> Communications of the ACM, </journal> <volume> 21(11), </volume> <pages> 966-975. </pages>
Reference-contexts: no no no yes yes Boehm C/C ++ yes yes yes yes yes yes Tolpin Oberon-2 no yes no no yes yes Java Java no no no yes yes yes 1.1 TriColour The TriColour marking is the theoretical proof of correctness on which all known incremental sweeping garbage collection rests <ref> (Dijkstra et al., 1978) </ref>. In the proof, objects are moved between three sets, black (reachable, live, objects), grey (reachable objects which may contain references to objects of unknown reachability) and white (objects of unknown reachability), hence the name.
Reference: <author> Gamma, E., Helm, R., Johnson, R., & Vlissides, J. </author> <year> 1993. </year> <title> Design Patterns: Abstraction and Reuse of Object-Oriented Design. </title> <booktitle> In: ECOOP'93 Object-Oriented Programming. </booktitle>
Reference: <author> Gamma, E., Helm, R., Johnson, R., & Vlissides, J. </author> <year> 1995. </year> <title> Design Patterns: Elements of Reusable Object-Oriented Software. </title> <publisher> Addison-Wesley. </publisher>
Reference-contexts: These collectors were examined as a step in the acquisition of domain knowledge for the construction of a garbage collector by the authors. Design patterns <ref> (Gamma et al., 1995) </ref> were used as a tool to capture this relevant domain knowledge. <p> The design patterns captured in the garbage collectors examined fall into two groups: (1) specific patterns|those unique to a particular domain, in this case, garbage collection, and (2) general patterns|those commonly found in both software and the literature on design patterns, such as those documented in <ref> (Gamma et al., 1995) </ref>. <p> This requires the overhead of a extra level of indirection, but, as with the adaptor, when tuning for efficiency, macros or inlining may be used allowing the overhead to be eliminated at the price of compile-time effort. Implementation As suggested in <ref> (Gamma et al., 1995) </ref>, the application can be further decoupled from the collector by making the Facade an abstract class. 14 Sample Code The Boehm collector, while a large system, has a narrow facade to appli-cations. <p> retarget this ClassListIterator fl= public void retarget (Enumeration enumer)f this.enumer = enumer; g =fl are there more Classes not yet seen ? fl= public boolean hasMoreElements ()f return enumer.hasMoreElements (); g =fl return the next class fl= public Class nextElement ()f 20 return (Class) enumer.nextElement (); g 1.5 Proxy Proxies <ref> (Gamma et al., 1995) </ref> are used in garbage collectors in three ways: 1. To control access to the object they guard. They are used to implement read- and write-barriers in the absence of (or as an alternative to) virtual memory. 2.
Reference: <author> Goldberg, Benjamin. </author> <year> 1991. </year> <title> Tag-Free Garbage Collection for Strongly Typed Programming Languages. </title> <booktitle> Pages 165-176 of: Proceedings of ACM SIGPLAN '91 Conference on Programming Language Design and Implementation. </booktitle>
Reference-contexts: To contain the per-object information about the state of the object they guard. They may be used in garbage collection to store "markbits" (the state of the tricolour) and the type of the object. Alternative implementations exist for each of these (bitmaps and tagless collection <ref> (Goldberg, 1991) </ref> respectively), but the information is commonly stored within a proxy. In garbage collection, proxies are implemented in either of two ways.
Reference: <author> Gosling, J., Joy, B., & Steele, G. </author> <year> 1996. </year> <title> The Java Language Specification. </title> <publisher> Addison-Wesley. </publisher> <address> 23 Guggilla, </address> <note> Satish Kumar. </note> <year> 1994. </year> <title> Generational Garbage Collection of C++ Targeted to SPARC Architectures. </title> <type> Tech. </type> <institution> rept. Department of Computer Science, Iowa State University. </institution>
Reference-contexts: It should be noted that using Enumera tions in this manner may not be suitable for all iterator implementations, since should the Vector be modified during iteration the common implementations of Java Enumer ations <ref> (Gosling et al., 1996) </ref> appear to have unspecified semantics.
Reference: <author> LaLonde, Wilf, & Pugh, John. </author> <year> 1994. </year> <title> Smalltalk V Practice and Experience. </title> <publisher> Prentice Hall. </publisher>
Reference-contexts: Workspace is a singleton class representing the set of all application-visible heap objects. It holds all the objects in an array, for efficiency reasons, it exports references to this array. This array is similar to object tables in early versions of Smalltalk <ref> (LaLonde & Pugh, 1994) </ref> Each of the entries in the array is an atrophied proxy: it is a pointer to the real object, which is held by objects in place of a pointer to the real object. public class Workspace f public static final short MAX OBJECTS = 1000; 20 static
Reference: <author> Wilson, P., Lam, M., & Moher, T. </author> <year> 1991 </year> <month> (June). </month> <title> Effective "static-graph" Reorganisation to Improve Locality in Garbage-Collected Systems. </title> <booktitle> Pages 177-191 of: Proceedings of ACM SIGPLAN 1991. </booktitle>
Reference: <author> Wilson, P., Johnstone, M., Neely, M., & Boles, D. </author> <year> 1995. </year> <title> Dynamic Storage Allocation: A Survey and Critical Review. In: </title> <type> (Baker, </type> <year> 1995b). </year>
Reference-contexts: This second technique is used by traditional memory managers for languages such as C and C++, which commonly store a few bytes of data immediately before objects given to the application. <ref> (Wilson et al., 1995) </ref> Name Proxy Intent Provide a repository for per-object garbage collection state and functionality.
Reference: <author> Wilson, Paul R. </author> <year> 1992. </year> <title> Uniprocessor Garbage Collection Techniques. Pages 1-42 of: </title> <editor> Bekkers, Y., & Cohen, J. (eds), </editor> <booktitle> Proceedings of the 1992 International Workshop of Memory Management. Lecture Notes in Computer Science, </booktitle> <volume> no. 637. </volume> <publisher> Springer. </publisher> <pages> 24 </pages>
Reference-contexts: Incremental algorithms split the collection across many small increments to avoid a pause long enough for users to notice. Compacting algorithms move objects in memory to defragment it. Semi-Space and Generational collectors partition objects by age enabling them to focus on young objects, as most objects die young <ref> (Wilson, 1992) </ref>.
References-found: 15

