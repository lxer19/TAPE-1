URL: file://ftp.di.unipi.it/pub/Papers/meo/ObsEq92.ps.gz
Refering-URL: http://www.di.unipi.it/di/groups/lp/papers.html
Root-URL: 
Email: fgabbri,levi,meog@di.unipi.it  
Title: Observational Equivalences for Logic Programs 1  
Author: Maurizio Gabbrielli, Giorgio Levi, Maria Chiara Meo 
Address: Corso Italia 40, 56125 Pisa, Italia  
Affiliation: Dipartimento di Informatica Universita di Pisa  
Abstract: We first introduce a general semantic scheme for logic programs which provides a uniform framework for defining different compositional semantics parametrically wrt a given notion of observable. The equivalence of the operational (top-down) and fixpoint (bottom-up) costruction of the semantics is ensured by the scheme (provided a congruence property is verified). We then define several observational equivalences on logic programs and investigate how they are related. The equivalences are based on various observables (successful derivations, computed answers, partial computed answers and call patterns) and on a notion of program composition. For each observational equivalence we study the relation with a suitable formal semantics, by investigating correctness and full abstraction properties. All the semantics we consider are obtained as instances of the general scheme. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> K. R. Apt. </author> <title> Introduction to Logic Programming. </title> <editor> In J. van Leeuwen, editor, </editor> <booktitle> Handbook of Theoretical Computer Science, volume B: Formal Models and Semantics. </booktitle> <publisher> Elsevier, Amsterdam and The MIT Press, </publisher> <address> Cambridge, </address> <year> 1990. </year>
Reference-contexts: When R is not specified we will omit the third parameter. The reader is assumed to be familiar with the terminology and the basic results on the semantics of logic programs <ref> [22, 1] </ref>. We assume a given signature S which contains a denumerable set F of function symbols and a set of predicate symbols. <p> In the following we consider T ~ (;;ca) T P defined on canonical representatives. According to definition 3.1, (;;s) is the equivalence induced by successful deriva tions, while (;;ca) is induced by computed answers. By standard results <ref> [1, 22] </ref> M (P ) (the canonical representative of O ~ (;;s) (P )) is correct and fully abstract wrt (;;s) . Moreover, by the strong completeness theorem in [10, 11], the s-semantics O ~ (;;ca) (P ) is correct and fully abstract wrt (;;ca) .
Reference: [2] <author> R. Barbuti, R. Giacobazzi, and G. Levi. </author> <title> A General Framework for Semantics-based Bottom-up Abstract Interpretation of Logic Programs. </title> <type> Technical Report TR 12/91, </type> <institution> Dipartimento di Informatica, Universita di Pisa, </institution> <year> 1991. </year> <note> To appear in ACM Transactions on Programming Languages and Systems. </note>
Reference-contexts: However, as first shown in [10], this is not the case of the classical van Emden and Kowalski's semantics [27]. The need for a different semantics (correct wrt computed answers) gave rise to several new definitions and was particularly recognized in the case of abstract interpretation <ref> [25, 2, 6] </ref> and program transformation [20, 3], where also less abstract observables (e.g. partial computed answers) have sometimes to be modeled [6]. In addition to the problem of modeling observational equivalences, there exists an important property which does not hold in the least Herbrand model semantics, i.e. OR-compositionality.
Reference: [3] <author> A. Bossi and N. Cocco. </author> <title> Basic transformation operations for logic programs which preserve computed answer substitutions. </title> <note> To appear in Journal of Logic Programming, </note> <year> 1991. </year>
Reference-contexts: The need for a different semantics (correct wrt computed answers) gave rise to several new definitions and was particularly recognized in the case of abstract interpretation [25, 2, 6] and program transformation <ref> [20, 3] </ref>, where also less abstract observables (e.g. partial computed answers) have sometimes to be modeled [6]. In addition to the problem of modeling observational equivalences, there exists an important property which does not hold in the least Herbrand model semantics, i.e. OR-compositionality.
Reference: [4] <author> A. Bossi, M. Gabbrielli, G. Levi, and M. C. Meo. </author> <title> Contributions to the Semantics of Open Logic Programs. </title> <booktitle> In Proceedings of the Int'l Conf. on Fifth Generation Computer Systems 1992, </booktitle> <pages> pages 570-580. </pages> <publisher> ICOT, </publisher> <address> Tokyo 1992. </address>
Reference-contexts: If the observable is successful derivation, OR-compositionality can be understood in logical terms since the set of all the (Herbrand) models is OR-compositional [24] (and correct wrt successful derivations). The only OR-compositional semantics correct wrt computed answers are described in <ref> [19, 5, 4] </ref>. Clearly, OR-compositionality is a desirable property both for theoretical (compositional semantics of modules) and for practical (modular program analysis and transformation) purposes. <p> Over the last few years we have developed a general approach to the semantics [13], whose aim was modeling the observable behaviors (possibly in a compositional way) for a variety of logic languages, ranging from positive logic programs <ref> [10, 11, 5, 4] </ref>, to general logic programs [26, 16], constraint logic programs [12] and concurrent constraint programs [14]. Our approach is based on the idea of choosing (equivalence classes of) sets of clauses as semantic domains. <p> Gaifman and Shapiro, using a proof-theoretic approach, introduced the idea of using as domain sets of non-unit clauses to achieve OR-compositionality [18] when considering successful derivations. They then defined (using a different semantic domain) a fully abstract OR-compositional semantics 2 modeling computed answers [19]. The -semantics <ref> [5, 4] </ref> is the real compositional generalization of the s-semantics and uses non-unit clauses as domain. <p> A program P can be composed, by means of 3 [ , with other programs which may further specify the predicates in . Formally, if P red (P ) " P red (Q) then P [ Q = P <ref> [ Q, otherwise P [ Q is not defined [5, 4] </ref>. The observables we analyze are successful derivations (denoted by s), computed answers (ca), partial computed answers (p), correct partial answers (cp), call patterns (pt) and correct call patterns (cpt). <p> A program P can be composed, by means of 3 [ , with other programs which may further specify the predicates in . Formally, if P red (P ) " P red (Q) then P [ Q = P [ Q, otherwise P <ref> [ Q is not defined [5, 4] </ref>. The observables we analyze are successful derivations (denoted by s), computed answers (ca), partial computed answers (p), correct partial answers (cp), call patterns (pt) and correct call patterns (cpt). <p> A program P can be composed, by means of 3 [ , with other programs which may further specify the predicates in . Formally, if P red (P ) " P red (Q) then P [ Q = P [ Q, otherwise P [ Q is not defined <ref> [5, 4] </ref>. The observables we analyze are successful derivations (denoted by s), computed answers (ca), partial computed answers (p), correct partial answers (cp), call patterns (pt) and correct call patterns (cpt). <p> The proofs of the results given in this paper are in [15]. 2 A general semantic scheme The scheme is a generalization of the -open semantics introduced in <ref> [5, 4] </ref> to get compositionality wrt program union. The standard semantics based on atoms are not compositional wrt union of programs since the information necessary to achieve compositionality can (syntactically) only be expressed by clauses. Let P 1 = fp (X) : r (X)g and P 2 = fr (a)g. <p> The semantics of P 1 should contain also the clause p (X) : r (X). The open semantics is then defined on domains consisting of (equivalence classes) of sets of clauses (interpretations). If we abstract from the specific equivalences in <ref> [5, 4] </ref>, the open semantics can be viewed as a semantic framework for correctly modeling (ffi;X) equivalences. 4 Depending on the observable X and the composition operator ffi, the semantics for (ffi;X) can be obtained from the general scheme by defining a specific equivalence relation ~ on sets of clauses and <p> Theorem 4.7 shows that O ~ (;ca) (P ) is compositional wrt program union and correctly models computed answers. Therefore (corollary 4.8) it is correct wrt (;ca) . Similar results (using a different semantic domain based on clauses) have already been given in <ref> [5, 4] </ref>. 8 Theorem 4.7 Let P 1 ; P 2 be programs. If P 1 [ P 2 is defined then O ~ (;ca) ((O ~ (;ca) (P 1 ) t O ~ (;ca) (P 2 ))) = O ~ (;ca) (P 1 [ P 2 ).
Reference: [5] <editor> A. Bossi and M. Menegus. Una Semantica Composizionale per Programmi Logici Aperti. In P. Asirelli, editor, </editor> <booktitle> Proc. Sixth Italian Conf. on Logic Programming, </booktitle> <pages> pages 95-109, </pages> <year> 1991. </year>
Reference-contexts: If the observable is successful derivation, OR-compositionality can be understood in logical terms since the set of all the (Herbrand) models is OR-compositional [24] (and correct wrt successful derivations). The only OR-compositional semantics correct wrt computed answers are described in <ref> [19, 5, 4] </ref>. Clearly, OR-compositionality is a desirable property both for theoretical (compositional semantics of modules) and for practical (modular program analysis and transformation) purposes. <p> Over the last few years we have developed a general approach to the semantics [13], whose aim was modeling the observable behaviors (possibly in a compositional way) for a variety of logic languages, ranging from positive logic programs <ref> [10, 11, 5, 4] </ref>, to general logic programs [26, 16], constraint logic programs [12] and concurrent constraint programs [14]. Our approach is based on the idea of choosing (equivalence classes of) sets of clauses as semantic domains. <p> Gaifman and Shapiro, using a proof-theoretic approach, introduced the idea of using as domain sets of non-unit clauses to achieve OR-compositionality [18] when considering successful derivations. They then defined (using a different semantic domain) a fully abstract OR-compositional semantics 2 modeling computed answers [19]. The -semantics <ref> [5, 4] </ref> is the real compositional generalization of the s-semantics and uses non-unit clauses as domain. <p> A program P can be composed, by means of 3 [ , with other programs which may further specify the predicates in . Formally, if P red (P ) " P red (Q) then P [ Q = P [ Q, otherwise P [ Q is not defined <ref> [5, 4] </ref>. The observables we analyze are successful derivations (denoted by s), computed answers (ca), partial computed answers (p), correct partial answers (cp), call patterns (pt) and correct call patterns (cpt). <p> The proofs of the results given in this paper are in [15]. 2 A general semantic scheme The scheme is a generalization of the -open semantics introduced in <ref> [5, 4] </ref> to get compositionality wrt program union. The standard semantics based on atoms are not compositional wrt union of programs since the information necessary to achieve compositionality can (syntactically) only be expressed by clauses. Let P 1 = fp (X) : r (X)g and P 2 = fr (a)g. <p> The semantics of P 1 should contain also the clause p (X) : r (X). The open semantics is then defined on domains consisting of (equivalence classes) of sets of clauses (interpretations). If we abstract from the specific equivalences in <ref> [5, 4] </ref>, the open semantics can be viewed as a semantic framework for correctly modeling (ffi;X) equivalences. 4 Depending on the observable X and the composition operator ffi, the semantics for (ffi;X) can be obtained from the general scheme by defining a specific equivalence relation ~ on sets of clauses and <p> Theorem 4.7 shows that O ~ (;ca) (P ) is compositional wrt program union and correctly models computed answers. Therefore (corollary 4.8) it is correct wrt (;ca) . Similar results (using a different semantic domain based on clauses) have already been given in <ref> [5, 4] </ref>. 8 Theorem 4.7 Let P 1 ; P 2 be programs. If P 1 [ P 2 is defined then O ~ (;ca) ((O ~ (;ca) (P 1 ) t O ~ (;ca) (P 2 ))) = O ~ (;ca) (P 1 [ P 2 ).
Reference: [6] <author> M. Codish, D. Dams, and E. Yardeni. </author> <title> Bottom-up Abstract Interpretation of Logic Programs. </title> <type> Technical report, </type> <institution> Dept. of Computer Science, The Weizmann Institute, Rehovot, </institution> <year> 1990. </year> <note> To appear in Theoretical Computer Science. </note>
Reference-contexts: However, as first shown in [10], this is not the case of the classical van Emden and Kowalski's semantics [27]. The need for a different semantics (correct wrt computed answers) gave rise to several new definitions and was particularly recognized in the case of abstract interpretation <ref> [25, 2, 6] </ref> and program transformation [20, 3], where also less abstract observables (e.g. partial computed answers) have sometimes to be modeled [6]. In addition to the problem of modeling observational equivalences, there exists an important property which does not hold in the least Herbrand model semantics, i.e. OR-compositionality. <p> The need for a different semantics (correct wrt computed answers) gave rise to several new definitions and was particularly recognized in the case of abstract interpretation [25, 2, 6] and program transformation [20, 3], where also less abstract observables (e.g. partial computed answers) have sometimes to be modeled <ref> [6] </ref>. In addition to the problem of modeling observational equivalences, there exists an important property which does not hold in the least Herbrand model semantics, i.e. OR-compositionality. <p> It is interesting to study equivalences based on partial answers, since these notions are useful in abstract interpretation <ref> [6] </ref>. Another observable which arises in the framework of program analysis is "call patterns". According to the procedural interpretation of logic programs, a selected atom p ( ~ t) in a derivation can be considered a "call" of the procedure p with parameter ~ t.
Reference: [7] <author> P. Cousot and R. Cousot. </author> <title> Abstract Interpretation: A Unified Lattice Model for Static Analysis of Programs by Construction or Approximation of Fixpoints. </title> <booktitle> In Proc. Fourth ACM Symp. POPL, </booktitle> <pages> pages 238-252, </pages> <year> 1977. </year>
Reference-contexts: Indeed, an abstract semantics is simply obtained by considering an "abstract" notion of observable (e.g. groundness, terms rigidity, variables sharing etc.). The correctness of an abstract semantics wrt a concrete one is usually stated by using a Galois connection which relates the two semantics <ref> [7] </ref>. It is worth noting that in our framework, since all the semantics are instances of the same scheme, their relations can be uniformly understood in terms of abstractions.
Reference: [8] <author> S. Debray and R. Ramakrishnan. </author> <title> Generalized Horn Clause Programs. </title> <type> Technical report, </type> <institution> Dept. of Computer Science, The University of Arizona, </institution> <year> 1991. </year>
Reference-contexts: Then T ~ P " ! is the least fixpoint of T ~ P on the complete lattice (= ~ ; v) and T ~ By instantiating T ~ P with a suitable ~ equivalence, we can define various fixpoint semantics, as in the case of the operator in <ref> [8] </ref>. As previously argued, semantics arising in abstract interpretation can be obtained as well by considering suitable observables. Moreover note that our framework can be extended to constraint logic programs in a straightforward way.
Reference: [9] <author> M. Falaschi and G. Levi. </author> <title> Finite failures and partial computations in concurrent logic languages. </title> <journal> Theoretical Computer Science, </journal> <volume> 75 </volume> <pages> 45-66, </pages> <year> 1990. </year>
Reference-contexts: Theorem 4.12 Let P 1 ; P 2 be programs. Then O ~ (;s) (P 1 ) = O ~ (;s) (P 2 ) iff P 1 (;s) P 2 . 5 Partial answers and call patterns A fixpoint semantics for partial answers has been already defined in <ref> [9] </ref> and then extended in [17] to consider also correct partial answers, call patterns and selection rules. In subsection 5.1 we show how the results of [17] can be obtained in our framework by considering suitable instances of the semantic scheme.
Reference: [10] <author> M. Falaschi, G. Levi, M. Martelli, and C. Palamidessi. </author> <title> A new Declarative Semantics for Logic Languages. </title> <editor> In R. A. Kowalski and K. A. Bowen, editors, </editor> <booktitle> Proc. Fifth Int'l Conf. on Logic Programming, </booktitle> <pages> pages 993-1005. </pages> <publisher> The MIT Press, </publisher> <address> Cambridge, Mass., </address> <year> 1988. </year> <month> 14 </month>
Reference-contexts: The most natural observable in the case of logic programs is computed answer substitution, which is usually considered the result of a program execution. Hence any "reference semantics" for logic programs should be correct wrt the observational equivalence based on computed answers. However, as first shown in <ref> [10] </ref>, this is not the case of the classical van Emden and Kowalski's semantics [27]. <p> Over the last few years we have developed a general approach to the semantics [13], whose aim was modeling the observable behaviors (possibly in a compositional way) for a variety of logic languages, ranging from positive logic programs <ref> [10, 11, 5, 4] </ref>, to general logic programs [26, 16], constraint logic programs [12] and concurrent constraint programs [14]. Our approach is based on the idea of choosing (equivalence classes of) sets of clauses as semantic domains. <p> Denotations (that we call -interpretations) are not interpretations in the conventional mathematical logic sense and can be computed both by a top-down construction (a success set) and by a bottom-up construction (the least fixpoint of suitable continuous immediate consequence operators on -interpretations). The s-semantics <ref> [10, 11] </ref> was the first (non-compositional) semantics correct wrt computed answers and which used sets of unit clauses as domain. Gaifman and Shapiro, using a proof-theoretic approach, introduced the idea of using as domain sets of non-unit clauses to achieve OR-compositionality [18] when considering successful derivations. <p> For any I 2 = ~ (;;ca) , the set of unit clauses (modulo variance) of any element in I can be considered the canonical representative of the equivalence class of I. T P is then exactly the immediate consequence operator of <ref> [10] </ref> and its least fixpoint is the s-semantics [10, 11]. In the case of ~ (;;s) the canonical representative of an equivalence class J is obtained by taking the set of the ground instances of the unit clauses of an element in J . <p> T P is then exactly the immediate consequence operator of [10] and its least fixpoint is the s-semantics <ref> [10, 11] </ref>. In the case of ~ (;;s) the canonical representative of an equivalence class J is obtained by taking the set of the ground instances of the unit clauses of an element in J . <p> By standard results [1, 22] M (P ) (the canonical representative of O ~ (;;s) (P )) is correct and fully abstract wrt (;;s) . Moreover, by the strong completeness theorem in <ref> [10, 11] </ref>, the s-semantics O ~ (;;ca) (P ) is correct and fully abstract wrt (;;ca) . We extend now to T ~ (;;ca) P some results for the ground operator T P [24], about the discrimination power of the various equivalences.
Reference: [11] <author> M. Falaschi, G. Levi, M. Martelli, and C. Palamidessi. </author> <title> Declarative Modeling of the Operational Behavior of Logic Languages. </title> <journal> Theoretical Computer Science, </journal> <volume> 69(3) </volume> <pages> 289-318, </pages> <year> 1989. </year>
Reference-contexts: Over the last few years we have developed a general approach to the semantics [13], whose aim was modeling the observable behaviors (possibly in a compositional way) for a variety of logic languages, ranging from positive logic programs <ref> [10, 11, 5, 4] </ref>, to general logic programs [26, 16], constraint logic programs [12] and concurrent constraint programs [14]. Our approach is based on the idea of choosing (equivalence classes of) sets of clauses as semantic domains. <p> Denotations (that we call -interpretations) are not interpretations in the conventional mathematical logic sense and can be computed both by a top-down construction (a success set) and by a bottom-up construction (the least fixpoint of suitable continuous immediate consequence operators on -interpretations). The s-semantics <ref> [10, 11] </ref> was the first (non-compositional) semantics correct wrt computed answers and which used sets of unit clauses as domain. Gaifman and Shapiro, using a proof-theoretic approach, introduced the idea of using as domain sets of non-unit clauses to achieve OR-compositionality [18] when considering successful derivations. <p> T P is then exactly the immediate consequence operator of [10] and its least fixpoint is the s-semantics <ref> [10, 11] </ref>. In the case of ~ (;;s) the canonical representative of an equivalence class J is obtained by taking the set of the ground instances of the unit clauses of an element in J . <p> By standard results [1, 22] M (P ) (the canonical representative of O ~ (;;s) (P )) is correct and fully abstract wrt (;;s) . Moreover, by the strong completeness theorem in <ref> [10, 11] </ref>, the s-semantics O ~ (;;ca) (P ) is correct and fully abstract wrt (;;ca) . We extend now to T ~ (;;ca) P some results for the ground operator T P [24], about the discrimination power of the various equivalences.
Reference: [12] <author> M. Gabbrielli and G. Levi. </author> <title> Modeling Answer Constraints in Constraint Logic Programs. </title> <editor> In K. Furukawa, editor, </editor> <booktitle> Proc. Eighth Int'l Conf. on Logic Programming, pages 238- 252. </booktitle> <publisher> The MIT Press, </publisher> <address> Cambridge, Mass., </address> <year> 1991. </year>
Reference-contexts: the last few years we have developed a general approach to the semantics [13], whose aim was modeling the observable behaviors (possibly in a compositional way) for a variety of logic languages, ranging from positive logic programs [10, 11, 5, 4], to general logic programs [26, 16], constraint logic programs <ref> [12] </ref> and concurrent constraint programs [14]. Our approach is based on the idea of choosing (equivalence classes of) sets of clauses as semantic domains.
Reference: [13] <author> M. Gabbrielli and G. Levi. </author> <title> On the Semantics of Logic Programs. </title> <editor> In J. Leach Albert, B. Monien, and M. Rodriguez-Artalejo, editors, </editor> <booktitle> 18th Int'l Colloquium on Automata, Languages an Programming, volume 510 of Lecture Notes in Computer Science, </booktitle> <pages> pages 1-19. </pages> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1991. </year>
Reference-contexts: Clearly, OR-compositionality is a desirable property both for theoretical (compositional semantics of modules) and for practical (modular program analysis and transformation) purposes. Over the last few years we have developed a general approach to the semantics <ref> [13] </ref>, whose aim was modeling the observable behaviors (possibly in a compositional way) for a variety of logic languages, ranging from positive logic programs [10, 11, 5, 4], to general logic programs [26, 16], constraint logic programs [12] and concurrent constraint programs [14]. <p> They then defined (using a different semantic domain) a fully abstract OR-compositional semantics 2 modeling computed answers [19]. The -semantics [5, 4] is the real compositional generalization of the s-semantics and uses non-unit clauses as domain. In this paper, following the approach of <ref> [13] </ref>, we first define a semantic scheme which generalize -semantics and provides a uniform framework for defining different compositional semantics for logic programs parametrically wrt a given notion of observable.
Reference: [14] <author> M. Gabbrielli and G. Levi. </author> <title> Unfolding and Fixpoint Semantics of Concurrent Constraint Programs. </title> <type> Technical Report TR 2/91, </type> <institution> Dipartimento di Informatica, Universita di Pisa, </institution> <year> 1991. </year> <note> To appear in Theoretical Computer Science. </note>
Reference-contexts: have developed a general approach to the semantics [13], whose aim was modeling the observable behaviors (possibly in a compositional way) for a variety of logic languages, ranging from positive logic programs [10, 11, 5, 4], to general logic programs [26, 16], constraint logic programs [12] and concurrent constraint programs <ref> [14] </ref>. Our approach is based on the idea of choosing (equivalence classes of) sets of clauses as semantic domains.
Reference: [15] <author> M. Gabbrielli, G. Levi, and M. C. Meo. </author> <title> Observational Equivalences for Logic Programs. </title> <type> Technical Report, </type> <institution> Dipartimento di Informatica, Universita di Pisa, </institution> <year> 1992. </year>
Reference-contexts: G # ; P 2 denotes the refutation of G in P with computed answer substitution #. ~ t, ~ X denote tuples of terms and variables respectively, while ~ B denotes a (possibly empty) conjunction of atoms. The proofs of the results given in this paper are in <ref> [15] </ref>. 2 A general semantic scheme The scheme is a generalization of the -open semantics introduced in [5, 4] to get compositionality wrt program union.
Reference: [16] <author> M. Gabbrielli, G. Levi, and D. Turi. </author> <title> A Two Steps Semantics for Logic Programs with Negation. </title> <booktitle> In Proceedings of the Int'l Conf. on Logic Programming and Automated Reasoning, Lecture Notes in Artificial Intelligence. </booktitle> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1992. </year>
Reference-contexts: Over the last few years we have developed a general approach to the semantics [13], whose aim was modeling the observable behaviors (possibly in a compositional way) for a variety of logic languages, ranging from positive logic programs [10, 11, 5, 4], to general logic programs <ref> [26, 16] </ref>, constraint logic programs [12] and concurrent constraint programs [14]. Our approach is based on the idea of choosing (equivalence classes of) sets of clauses as semantic domains.
Reference: [17] <author> M. Gabbrielli and M. C. Meo. </author> <title> Fixpoint Semantics for Partial Computed Answer Substitutions and Call Patterns. </title> <editor> In H. Kirchner and G. Levi, editors, </editor> <booktitle> Proceedings of Third Int'l Conf. on Algebraic and Logic Programming, Lecture Notes in Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1992. </year>
Reference-contexts: For each observational equivalence we study how it is related to a suitable formal semantics (obtained as a specific instance of the general scheme) by investigating correctness and full abstraction properties. For partial answers and call patterns, we rephrase in our semantic framework some results given in <ref> [17] </ref> and we show a semantics [17] which models partial answers when considering also the selection rule (and hence allows to distinguish programs R 1 and R 2 ). <p> For partial answers and call patterns, we rephrase in our semantic framework some results given in <ref> [17] </ref> and we show a semantics [17] which models partial answers when considering also the selection rule (and hence allows to distinguish programs R 1 and R 2 ). <p> Then O ~ (;s) (P 1 ) = O ~ (;s) (P 2 ) iff P 1 (;s) P 2 . 5 Partial answers and call patterns A fixpoint semantics for partial answers has been already defined in [9] and then extended in <ref> [17] </ref> to consider also correct partial answers, call patterns and selection rules. In subsection 5.1 we show how the results of [17] can be obtained in our framework by considering suitable instances of the semantic scheme. In particular we show a fully abstract semantics for partial answers. <p> iff P 1 (;s) P 2 . 5 Partial answers and call patterns A fixpoint semantics for partial answers has been already defined in [9] and then extended in <ref> [17] </ref> to consider also correct partial answers, call patterns and selection rules. In subsection 5.1 we show how the results of [17] can be obtained in our framework by considering suitable instances of the semantic scheme. In particular we show a fully abstract semantics for partial answers. Observables and equivalences depending on the selection rule are considered in subsection 5.2. <p> The following theorem shows the correctness of all the semantics considered and the full abstraction of S (;;p) (P ) (wrt the appropriate x equivalences). The same theorem was already obtained in <ref> [17] </ref> by using a slightly different definition of the semantic domain. Note that the equivalences considered in this section are all different and no one is contained in any other. <p> (;ca) P 2 then P 1 (;;p) P 2 and P 1 (;;cp) P 2 . 5.2 Introducing a selection rule We will consider in this section equivalences based on partial answers with a given selection rule R, showing a correct and fully abstract semantics for them originally defined in <ref> [17] </ref>. Such a semantic is defined both top-down and bottom up, and the equivalence of the two constructions holds only when considering local selection 11 rules. <p> This definition is modified in <ref> [17] </ref> by requiring also that a fixed ordering is given (by means of a bijection on the set of integer numbers) for the selection of atoms in the bodies, and hence for the selection of one the most recently introduced atoms. <p> Adapting definition 2.2 is more complicate and the formal definition of the T (P;R ) operator for the rule R is given in <ref> [17] </ref>. The intuition is that since R is local, the ordering can also be used "locally" on the body of any clause used in the bottom-up "computation" defined by T (P;R ) . <p> In <ref> [17] </ref> is proved that the operator T (P;R ) is continuous on the lattice of -interpretations and that its least fixpoint T (P;R ) " ! is equal to the top-down semantics O (~;R ) (P ). Definition 5.8 [17] Let P be a positive program and R be a local <p> In <ref> [17] </ref> is proved that the operator T (P;R ) is continuous on the lattice of -interpretations and that its least fixpoint T (P;R ) " ! is equal to the top-down semantics O (~;R ) (P ). Definition 5.8 [17] Let P be a positive program and R be a local selection rule. <p> Results based on O (~;R) (P ), similar to those of the previous subsections, can be shown to hold for R-correct partial answers and R-call patterns. Definition 5.9 <ref> [17] </ref> Let P be a positive program and R be a local selection rule. <p> The R-partial answer semantics S (;;p;R) (P ) of P is (] denotes the disjoint union) S (;;p;R) (P ) = S ] T where T = fA j A 2 I for I 2 O (~;R) (P )g =~ Theorem 5.10 <ref> [17] </ref> Let P 1 ; P 2 be programs and R be a local selection rule.
Reference: [18] <author> H. Gaifman and E. Shapiro. </author> <title> Fully abstract compositional semantics for logic programs. </title> <booktitle> In Proc. Sixteenth Annual ACM Symp. on Principles of Programming Languages, </booktitle> <pages> pages 134-142. </pages> <publisher> ACM, </publisher> <year> 1989. </year>
Reference-contexts: The s-semantics [10, 11] was the first (non-compositional) semantics correct wrt computed answers and which used sets of unit clauses as domain. Gaifman and Shapiro, using a proof-theoretic approach, introduced the idea of using as domain sets of non-unit clauses to achieve OR-compositionality <ref> [18] </ref> when considering successful derivations. They then defined (using a different semantic domain) a fully abstract OR-compositional semantics 2 modeling computed answers [19]. The -semantics [5, 4] is the real compositional generalization of the s-semantics and uses non-unit clauses as domain. <p> However, programs P 1 and P 2 have different computed answers (see example 3.3) and, if we consider the OR-composition of programs, Q 1 and Q 2 are different too (see example 3.7). Some equivalences which consider OR-composition have already been studied in <ref> [18, 19] </ref>. However programs R 1 = fp (a); q (b); r (X; Y ) : p (X); q (Y )g and R 2 = fp (a); q (b); r (X; Y ) : q (Y ); p (X)g are identified by all the equivalences considered in [18, 19], while, if <p> been studied in <ref> [18, 19] </ref>. However programs R 1 = fp (a); q (b); r (X; Y ) : p (X); q (Y )g and R 2 = fp (a); q (b); r (X; Y ) : q (Y ); p (X)g are identified by all the equivalences considered in [18, 19], while, if we consider "partial computed answers" with a given selection rule, they can be distinguished (see example 5.1). We extend the study of [24] and [18, 19] by introducing new equivalences, which are able to capture differences such as those of the previous programs, and by analyzing their <p> fp (a); q (b); r (X; Y ) : q (Y ); p (X)g are identified by all the equivalences considered in <ref> [18, 19] </ref>, while, if we consider "partial computed answers" with a given selection rule, they can be distinguished (see example 5.1). We extend the study of [24] and [18, 19] by introducing new equivalences, which are able to capture differences such as those of the previous programs, and by analyzing their relationships. The new equivalences are obtained both considering new observables such as partial computed answers and call patterns and by considering non-standard T P operators. <p> Then we can define for I; J C, I ~ (;s) J iff I " C is weakly subsumption equivalent to J " C . Theorem 4.12 states correctness and full abstraction of the resulting semantics. A different fully abstract invariant wrt (;s) was already given in <ref> [18] </ref>. Theorem 4.12 Let P 1 ; P 2 be programs.
Reference: [19] <author> H. Gaifman and E. Shapiro. </author> <title> Proof theory and semantics of logic programs. </title> <booktitle> In Proc. Fourth IEEE Symp. on Logic In Computer Science, </booktitle> <pages> pages 50-62. </pages> <publisher> IEEE Computer Society Press, </publisher> <year> 1989. </year>
Reference-contexts: If the observable is successful derivation, OR-compositionality can be understood in logical terms since the set of all the (Herbrand) models is OR-compositional [24] (and correct wrt successful derivations). The only OR-compositional semantics correct wrt computed answers are described in <ref> [19, 5, 4] </ref>. Clearly, OR-compositionality is a desirable property both for theoretical (compositional semantics of modules) and for practical (modular program analysis and transformation) purposes. <p> Gaifman and Shapiro, using a proof-theoretic approach, introduced the idea of using as domain sets of non-unit clauses to achieve OR-compositionality [18] when considering successful derivations. They then defined (using a different semantic domain) a fully abstract OR-compositional semantics 2 modeling computed answers <ref> [19] </ref>. The -semantics [5, 4] is the real compositional generalization of the s-semantics and uses non-unit clauses as domain. <p> However, programs P 1 and P 2 have different computed answers (see example 3.3) and, if we consider the OR-composition of programs, Q 1 and Q 2 are different too (see example 3.7). Some equivalences which consider OR-composition have already been studied in <ref> [18, 19] </ref>. However programs R 1 = fp (a); q (b); r (X; Y ) : p (X); q (Y )g and R 2 = fp (a); q (b); r (X; Y ) : q (Y ); p (X)g are identified by all the equivalences considered in [18, 19], while, if <p> been studied in <ref> [18, 19] </ref>. However programs R 1 = fp (a); q (b); r (X; Y ) : p (X); q (Y )g and R 2 = fp (a); q (b); r (X; Y ) : q (Y ); p (X)g are identified by all the equivalences considered in [18, 19], while, if we consider "partial computed answers" with a given selection rule, they can be distinguished (see example 5.1). We extend the study of [24] and [18, 19] by introducing new equivalences, which are able to capture differences such as those of the previous programs, and by analyzing their <p> fp (a); q (b); r (X; Y ) : q (Y ); p (X)g are identified by all the equivalences considered in <ref> [18, 19] </ref>, while, if we consider "partial computed answers" with a given selection rule, they can be distinguished (see example 5.1). We extend the study of [24] and [18, 19] by introducing new equivalences, which are able to capture differences such as those of the previous programs, and by analyzing their relationships. The new equivalences are obtained both considering new observables such as partial computed answers and call patterns and by considering non-standard T P operators. <p> The difficulty here is related to the use of clauses in the semantic domain (note that the full abstractness result in <ref> [19] </ref> was obtained using a domain not containing clauses). We now show the relation of (;ca) to other equivalences. It is easy to prove that if then (;ca) is strictly finer than (;ca) .
Reference: [20] <author> T. Kawamura and T. Kanamori. </author> <title> Preservation of Stronger Equivalence in Unfold/Fold Logic Programming Transformation. </title> <booktitle> In Proc. Int'l Conf. on Fifth Generation Computer Systems, </booktitle> <pages> pages 413-422. </pages> <publisher> ICOT, </publisher> <address> Tokyo, </address> <year> 1988. </year>
Reference-contexts: The need for a different semantics (correct wrt computed answers) gave rise to several new definitions and was particularly recognized in the case of abstract interpretation [25, 2, 6] and program transformation <ref> [20, 3] </ref>, where also less abstract observables (e.g. partial computed answers) have sometimes to be modeled [6]. In addition to the problem of modeling observational equivalences, there exists an important property which does not hold in the least Herbrand model semantics, i.e. OR-compositionality.
Reference: [21] <author> J.-L. Lassez and M. J. Maher. </author> <title> Closures and Fairness in the Semantics of Programming Logic. </title> <journal> Theoretical Computer Science, </journal> <volume> 29 </volume> <pages> 167-184, </pages> <year> 1984. </year>
Reference-contexts: We define (f + g)(X) = f (X) [ g (X) for f, g generic functions, and [[P ]](X) = (T P + id) ! (X) where id denotes the identity function. The closure operator [[P ]] introduced in <ref> [21] </ref> denotes the function corresponding to deductions in any number of step. When considering a function f P obtained by a program P (such as T P or [[P ]]) we define f P 1 = f P 2 iff 8X, f P 1 (X) = f P 2 (X).
Reference: [22] <author> J. W. Lloyd. </author> <title> Foundations of Logic Programming. </title> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1987. </year> <note> Second edition. </note>
Reference-contexts: When R is not specified we will omit the third parameter. The reader is assumed to be familiar with the terminology and the basic results on the semantics of logic programs <ref> [22, 1] </ref>. We assume a given signature S which contains a denumerable set F of function symbols and a set of predicate symbols. <p> In the following we consider T ~ (;;ca) T P defined on canonical representatives. According to definition 3.1, (;;s) is the equivalence induced by successful deriva tions, while (;;ca) is induced by computed answers. By standard results <ref> [1, 22] </ref> M (P ) (the canonical representative of O ~ (;;s) (P )) is correct and fully abstract wrt (;;s) . Moreover, by the strong completeness theorem in [10, 11], the s-semantics O ~ (;;ca) (P ) is correct and fully abstract wrt (;;ca) . <p> This discrepancy is of the same nature of the weakness of the completeness theorem for SLD resolution (only answers more general than correct answers can be computed <ref> [22] </ref>). (Weak) subsumption equivalence is perfectly adequate to model successful derivations.
Reference: [23] <author> J. W. Lloyd and J. C. Shepherdson. </author> <title> Partial Evaluation in Logic Programming. </title> <journal> Journal of Logic Programming, </journal> <volume> 11 </volume> <pages> 217-242, </pages> <year> 1991. </year>
Reference-contexts: Moreover O ~ (P ) is the set of all the resultants <ref> [23] </ref>, obtained from goals of the form p ( ~ X) in P fl . O ~ (P ) can equivalently be defined as the least fixpoint of an operator T ~ P (I) (parametric wrt ~).
Reference: [24] <author> M. J. Maher. </author> <title> Equivalences of Logic Programs. </title> <editor> In J. Minker, editor, </editor> <booktitle> Foundations of Deductive Databases and Logic Programming, </booktitle> <pages> pages 627-658. </pages> <publisher> Morgan Kaufmann, </publisher> <address> Los Altos, Ca., </address> <year> 1988. </year> <month> 15 </month>
Reference-contexts: In the case of logic programs, the least Herbrand model semantics is not compositional wrt the union of programs (i.e. is not OR-compositional). If the observable is successful derivation, OR-compositionality can be understood in logical terms since the set of all the (Herbrand) models is OR-compositional <ref> [24] </ref> (and correct wrt successful derivations). The only OR-compositional semantics correct wrt computed answers are described in [19, 5, 4]. Clearly, OR-compositionality is a desirable property both for theoretical (compositional semantics of modules) and for practical (modular program analysis and transformation) purposes. <p> We then consider various program equivalence notions and investigate how they are related to study their discriminating power. A systematic comparison of various program equivalences has already been given in <ref> [24] </ref>, which, however, considers only equivalences based on logical properties or on the semantics in [27]. We have already argued that all these equivalences are too weak to correctly characterize computed answers. <p> We have already argued that all these equivalences are too weak to correctly characterize computed answers. For example, programs P 1 = fp (X); p (a); q (a); q (b)g and P 2 = fp (X); q (a); q (b)g are identified by all the equivalences considered in <ref> [24] </ref> and the same is true for programs Q 1 = fq (X) : q (X); q (X)g and Q 2 = fq (X) : q (X)g. <p> We extend the study of <ref> [24] </ref> and [18, 19] by introducing new equivalences, which are able to capture differences such as those of the previous programs, and by analyzing their relationships. The new equivalences are obtained both considering new observables such as partial computed answers and call patterns and by considering non-standard T P operators. <p> In the following, for each observable X and 5 composition operator ffi considered we introduce a suitable ~ (X;ffi) equivalence to obtain a correct (in some cases fully abstract) semantics for (X;ffi) . For example (weak) subsumption equivalence <ref> [24] </ref> can be used for the observable X = s and program union (ffi = [), but is too coarse and hence not correct when considering X = ca (see example 3.7). <p> Moreover, by the strong completeness theorem in [10, 11], the s-semantics O ~ (;;ca) (P ) is correct and fully abstract wrt (;;ca) . We extend now to T ~ (;;ca) P some results for the ground operator T P <ref> [24] </ref>, about the discrimination power of the various equivalences. Proposition 3.2 shows that the "non-ground" equivalences are in general strictly finer than their ground versions. 6 Strictness can be shown by counterexamples similar to the one of example 3.3. <p> 4.11) 3. if [[P 1 ]] ~ (;;ca) = [[P 2 ]] ~ (;;ca) then P 1 (;;ca) P 2 and the converse does not hold, 4. the equivalence (;;ca) is different from (neither coarser nor finer than) the equivalences induced by T ~ (;;s) ~ (;;s) A result in <ref> [24] </ref> states that if clause c 1 subsumes clause c 2 then T c 2 T c 1 and hence T P 1 = T P 2 iff P 1 and P 2 are subsumption equivalent. <p> Indeed if P 1 and P 2 are (weak) subsumption equivalent, (id+)T P 1 = (id+)T P 2 <ref> [24] </ref> and therefore the programs have the same least Herbrand model and the same successful derivations. 7 4 Compositional equivalences We consider the general case with [ as composition operator. <p> The leftmost column is from <ref> [24] </ref> (apart from O ~ (;s) (P )). 6 Conclusions Some of the relations among the various equivalences we have studied are illustrated by figure 1. Equivalences in columns from the right to the left correspond to increasingly more abstract observables (partial answers, computed answers and successful derivations respectively).
Reference: [25] <author> K. Marriott and H. Stndergaard. </author> <title> Semantics-based Dataflow Analysis of Logic Programs. </title> <editor> In G. Ritter, editor, </editor> <booktitle> Information Processing 89. </booktitle> <publisher> North-Holland, </publisher> <year> 1989. </year>
Reference-contexts: However, as first shown in [10], this is not the case of the classical van Emden and Kowalski's semantics [27]. The need for a different semantics (correct wrt computed answers) gave rise to several new definitions and was particularly recognized in the case of abstract interpretation <ref> [25, 2, 6] </ref> and program transformation [20, 3], where also less abstract observables (e.g. partial computed answers) have sometimes to be modeled [6]. In addition to the problem of modeling observational equivalences, there exists an important property which does not hold in the least Herbrand model semantics, i.e. OR-compositionality.
Reference: [26] <author> D. Turi. </author> <title> Extending S-Models to Logic Programs with Negation. </title> <editor> In K. Fu-rukawa, editor, </editor> <booktitle> Proc. Eighth Int'l Conf. on Logic Programming, </booktitle> <pages> pages 397-411. </pages> <publisher> The MIT Press, </publisher> <address> Cambridge, Mass., </address> <year> 1991. </year>
Reference-contexts: Over the last few years we have developed a general approach to the semantics [13], whose aim was modeling the observable behaviors (possibly in a compositional way) for a variety of logic languages, ranging from positive logic programs [10, 11, 5, 4], to general logic programs <ref> [26, 16] </ref>, constraint logic programs [12] and concurrent constraint programs [14]. Our approach is based on the idea of choosing (equivalence classes of) sets of clauses as semantic domains.
Reference: [27] <author> M. H. van Emden and R. A. Kowalski. </author> <title> The semantics of predicate logic as a programming language. </title> <journal> Journal of the ACM, </journal> <volume> 23(4) </volume> <pages> 733-742, </pages> <year> 1976. </year>
Reference-contexts: Hence any "reference semantics" for logic programs should be correct wrt the observational equivalence based on computed answers. However, as first shown in [10], this is not the case of the classical van Emden and Kowalski's semantics <ref> [27] </ref>. The need for a different semantics (correct wrt computed answers) gave rise to several new definitions and was particularly recognized in the case of abstract interpretation [25, 2, 6] and program transformation [20, 3], where also less abstract observables (e.g. partial computed answers) have sometimes to be modeled [6]. <p> We then consider various program equivalence notions and investigate how they are related to study their discriminating power. A systematic comparison of various program equivalences has already been given in [24], which, however, considers only equivalences based on logical properties or on the semantics in <ref> [27] </ref>. We have already argued that all these equivalences are too weak to correctly characterize computed answers. <p> Then T ~ (;;s) P (on canonical representatives) is the standard immediate consequence operator T P <ref> [27] </ref> and its least fixpoint is the usual least Herbrand model semantics. In the following we consider T ~ (;;ca) T P defined on canonical representatives. According to definition 3.1, (;;s) is the equivalence induced by successful deriva tions, while (;;ca) is induced by computed answers.
Reference: [28] <author> L. Vieille. </author> <title> Recursive query processing: the power of logic. </title> <journal> Theoretical Computer Science, </journal> <volume> 69 </volume> <pages> 1-53, </pages> <year> 1989. </year> <month> 16 </month>
Reference-contexts: Such a semantic is defined both top-down and bottom up, and the equivalence of the two constructions holds only when considering local selection 11 rules. A local selection rule was defined in <ref> [28] </ref> as a rule which selects in a resolvent ~ N always one of the most recently introduced atoms in the derivation from the goal to ~ N (the atom A is introduced in the resolvent ~ M if A is in the body of the clause used to obtain ~ <p> Note that PROLOG leftmost rule is local and in general local rules produce SLD trees with a simple structure, suitable for efficient searching techniques <ref> [28] </ref>. When considering the selection rule, the ordering of atoms in the body of a clause is relevant. We will therefore consider interpretations as sets of clauses modulo variance (denoted by ~).
References-found: 28

