URL: http://www-icparc.doc.ic.ac.uk/papers/eclipse.ps
Refering-URL: http://www-icparc.doc.ic.ac.uk/papers.html
Root-URL: 
Title: ECL i PS e A Platform for Constraint Logic Programming  
Author: Mark Wallace, Stefano Novello, Joachim Schimpf 
Keyword: into hybrid search techniques.  
Address: College, LONDON SW7 2AZ.  
Affiliation: IC-Parc, William Penney Laboratory, Imperial  
Note: Contact address:  
Email: email: mgw@doc.ic.ac.uk  
Date: August 1997  
Abstract: This paper introduces the Constraint Logic Programming (CLP) platform ECL i PS e . ECL i PS e is designed to be more than an implementation of CLP: it also supports mathematical programming and stochastic programming techniques. The crucial advantage of ECL i PS e is that it enables the programmer to use a combination of algorithms appropriate to the application at hand. This benefit results from the ECL i PS e facility to support fine-grained hybridisation. ECL i PS e is designed for solving difficult "combinatorial" industrial problems in the areas of planning, scheduling and resource allocation. The platform offers a conceptual modelling language for specifying the problem clearly and simply, in a way that is neutral as to the algorithm which will be used to solve it. Based on the conceptual model it is easy to construct alternative design models, also expressed in ECL i PS e . A design model is a runnable program, whose execution in ECL i PS e employs a specific combination of algorithms. Thus the platform supports experimentation with different hybrid algorithms. Technically the different classes of algorithms mentioned above have two aspects: constraint handling, and search. Various different constraint handling facilities are available as ECL i PS e libraries. These include finite domain propagation, interval propagation and linear constraint solving. In ECL i PS e the same constraint can be treated concurrently by several different handlers. With regard to search behaviour, CLP and also mathematical programming typically impose new constraints at lower levels in the search tree. By contrast, stochastic techniques search for good solutions by locally repairing an original solution, and repeating the process again and again. ECL i PS e supports both kinds of search, and allows them to be combined 
Abstract-found: 1
Intro-found: 1
Reference: [Ae97] <author> Abderrahamane Aggoun and et.al. </author> <title> ECLiPSe user manual. </title> <address> IC-Parc, </address> <year> 1997. </year>
Reference-contexts: Grace is implemented using ECL i PS e and Tcl. The manuals and other documentation include a manual covering the non-constraint facilities of ECL i PS e <ref> [Ae97] </ref>, manuals covering the facilities supporting constraints [Be97, SNE97], and information covering the graphical user interface library, and embeddability in C and C++.
Reference: [Be97] <author> Pascal Brisset and et.al. </author> <title> ECLiPSe Extensions manual. </title> <address> IC-Parc, </address> <year> 1997. </year>
Reference-contexts: The other fd constraints (#&lt;, #&gt;, etc.) can be extended with an extra 0/1 variable in the same way. The fd library includes a great variety of facilities, which are best explored by obtaining the ECL i PS e extensions manual <ref> [Be97] </ref> and looking at the programming examples in the section on the fd library there. 3.2 The range Library The range library does very little itself, but it provides a common basis for the interval and the MIP libraries. <p> Other behaviour can be achieved by writing Goal infers consistent or Goal infers ground instead. These behaviours, together with other facilities of the propia library are described in the ECL i PS e extensions manual <ref> [Be97] </ref>. 4.2 The chr (Constraint Handling Rules) Library The ECL i PS e programmer has little control over the behaviour of complex predicates using the propia library. <p> Query 5 uses the fact that the tasks must overlap to remove r 1 from the domain of R2. The chr library offers many more facilities, including multi-headed rules, and augmentation rules. These facilities can be explored in detail by studying the relevant chapter in <ref> [Be97] </ref>, and trying out the example constraint handling rule programs which are distributed with ECL i PS e . [eclipse 1]: lib (chr), lib (fd). * chr loaded * fd loaded [eclipse 2]: chr (chrTaskResource). * chrTaskResource.chr compiled. * yes. [eclipse 3]: chrTR (S1, R1, S2, R2), R1#=r1, R2#=r1. * S1 <p> Events specific to this class of constraints must be specified. 3. New constraint behaviours must be implemented in terms of goals which suspend them selves on these events. The ECL i PS e extensions manual <ref> [Be97] </ref> gives an example of defining such a new constraint library. 5 Search 5.1 Constructive Search 5.1.1 Branch and Bound In the preceding sections we have encountered two optimisation procedures, the finite domain procedure minimize and the MIP procedure optimize. <p> Grace is implemented using ECL i PS e and Tcl. The manuals and other documentation include a manual covering the non-constraint facilities of ECL i PS e [Ae97], manuals covering the facilities supporting constraints <ref> [Be97, SNE97] </ref>, and information covering the graphical user interface library, and embeddability in C and C++.
Reference: [CPL93] <author> CPLEX. </author> <title> Using the cplex callable library and cplex mixed integer library. </title> <type> Technical Report Version 2.1, </type> <institution> CPLEX Optimisation Inc., </institution> <year> 1993. </year>
Reference-contexts: PocketCoins=[P,Tw,Fv,Te,Twe,Ff], applist (range (0,99),[Min|PocketCoins]), Min $= P+Tw+Fv+Te+Twe+Ff, fromto (1,99,genc (PocketCoins)), optimize (min (Min),Cost). genc (PocketCoins,Total) :- Coins=[P1,Tw1,Fv1,Te1,Twe1,Ff1], applist (range (0,99),Coins), Total $= P1+2*Tw1+5*Fv1+10*Te1+20*Twe1+50*Ff1, maplist ( '$=&lt;',Coins,PocketCoins). range (Min,Max,Var) :- integers (Var), Var $&gt;= Min, This program passes all the $= and $&gt;= constraints to the CPLEX mixed integer programming package <ref> [CPL93] </ref>, and invokes the CPLEX branch and bound solver, to minimise the value of the variable M in. This minimum is placed in the variable Cost. <p> Techniques for solving linear constraints have been at the heart of operations research for half a century, and highly efficient linear solvers have been developed. One of the most widely distributed, scaleable and efficient packages incorporating a linear constraint solver is the CPLEX MIP package <ref> [CPL93] </ref>. CPLEX offers several algorithms for solving linear constraints including the Simplex and Dual Simplex algorithms. These algorithms are supported by sophisticated data structures, and the package can handle problems involving ten of thousands of linear constraints over ten of thousands of variables.
Reference: [MJPL92] <author> S. Minton, M. D. Johnston, A. B. Philips, and P. Laird. </author> <title> Minimizing conflicts: a heuristic repair method for constraint satisfaction and scheduling problems. </title> <journal> Artificial Intelligence, </journal> <volume> 58, </volume> <year> 1992. </year>
Reference-contexts: The constraint Y ##X is not affected by the update. In particular, X keeps the value of the existing solution, and is not even being labeled by repair/0. Constructive repair is also known as informed backtracking and has been used successfully on a variety of benchmarks <ref> [MJPL92] </ref>. 5.2.2 Weak Commitment Instead of instantiating a variable in order to repair it, an alternative method is simply to change its tentative value. This approach requires no backtracking, since every conflict can be fixed by just changing tentative values.
Reference: [RR96] <author> Tom Richards and Barry Richards. </author> <title> Nogood learning for constraint satisfaction. </title> <type> Technical report, </type> <institution> IC-Parc, </institution> <year> 1996. </year> <booktitle> In Proceedings CP 96 Workshop on Constraint Programming Application. </booktitle>
Reference-contexts: A paper describing this work <ref> [RR96] </ref> is available from the IC-Parc home page (whose URL is given in section 6 below). 5.2 Solution Repair At the end of the previous section we suggested that even for incomplete search, constructive search with good heuristics can outperform solution repair.
Reference: [RWH97] <author> Robert Rodosek, Mark Wallace, and Mozafian Hajian. </author> <title> A new approach to integrating mixed integer programming with constraint logic programming. </title> <type> Technical report, </type> <institution> IC-Parc, </institution> <year> 1997. </year> <note> To appear in Annals of Operations Research. </note>
Reference-contexts: Another ECL i PS e design model, which is also close to the conceptual model, is handled in ECL i PS e by an automatic translator which builds the MIP model and passes it to the MIP solver of ECL i PS e . This translator is described in <ref> [RWH97] </ref> which is available from the IC-Parc home page (whose URL is given in section 6 below). Whilst the above example shows that such complex constraints can be expressed in terms of numerical inequalities, as required for MIP, the encoding is awkward and difficult to debug. <p> It has proved possible, within ECL i PS e , to achieve much of the flexibility of CLP (R) within the restrictions imposed by MIP solvers <ref> [RWH97] </ref>. 4 Complex Constraints Whilst constraint programming languages offer a broad selection of built-in constraints, each new industrial application typically requires a number of application-specific constraints which aren't among the built-in constraints.
Reference: [SNE97] <author> Joachim Schimpf, Stefano Novello, and Hani El Sakkout. </author> <title> IC-Parc ECLiPSe Library Manual. </title> <address> IC-Parc, </address> <year> 1997. </year>
Reference-contexts: A built-in search predicate called repair is provided which selects a variable whose tentative value violates a repair constraint, labels it and succeeds when all the remaining variables have consistent tentative values. We illustrate this repair algorithm (with an example from the IC-Parc ECL i PS e library manual <ref> [SNE97] </ref>) in figure 26. <p> Grace is implemented using ECL i PS e and Tcl. The manuals and other documentation include a manual covering the non-constraint facilities of ECL i PS e [Ae97], manuals covering the facilities supporting constraints <ref> [Be97, SNE97] </ref>, and information covering the graphical user interface library, and embeddability in C and C++.
Reference: [Wal97] <author> Mark Wallace. </author> <title> Constraint programming. </title> <booktitle> Chapter 17 of The Handbook of Applied Expert Systems, </booktitle> <publisher> CRC Press, </publisher> <year> 1997. </year>
Reference-contexts: 1 Introduction: The ECL i e Philosophy The first generation of constraint programming languages focussed on a single technique: constraint propagation, as described in section 4 of <ref> [Wal97] </ref>. Whilst constraint propagation has proved itself on a variety of applications, it cannot alone suffice to efficiently produce solutions for typical practical industrial problems. <p> ECL i PS e is designed to support both kinds of models, and the mapping between them. In the following two sections we shall examine the ECL i PS e facilities for handling constraints. In <ref> [Wal97] </ref> we encountered different kinds of constraints primitive constraints, propagation constraints and constraint agents. ECL i PS e supports various classes of built-in constraints, both primitive constraints and propagation constraints. <p> The constraints are modelled by relations between the variables. As an example consider the map colouring program, with four countries to colour. This program was also used to illustrate constraint logic programming in <ref> [Wal97] </ref>. ECL i PS e is a constraint logic programming language, and it uses the same syntax as Prolog. Hopefully this syntax will already be familiar to many readers. <p> Every predicate in a logic program defines a relation, either explicitly as a set of facts, or implicitly in terms of rules. We can recall the example from the <ref> [Wal97] </ref>. The predicate meat was defined by two facts: meat (beef,5). meat (pork,7). whilst the predicate main (meaning "main course") was defined by two rules: main (M,I) :- meat (M,I). main (M,I) :- fish (M,I). Variables in logic programming are logical variables. <p> It is supported by the propia library. The behaviour of this constraint is to find which values for each variable are consistent with the constraint. The constraint has the propagation behaviour described in <ref> [Wal97] </ref>: it repeatedly attempts to reduce the domains of its variables further every time any other constraints reduce any of these domains. Figure 19 shows some examples of this behaviour.
Reference: [Yok94] <author> M. Yokoo. </author> <title> Weak-commitment search for solving constraint satisfaction problems. </title> <booktitle> In Proc. 12th National Conference on Artificial Intelligence, </booktitle> <pages> pages 313-318, </pages> <year> 1994. </year> <month> 33 </month>
Reference-contexts: This approach requires no backtracking, since every conflict can be fixed by just changing tentative values. The disadvantage is that cycles can easily occur in which two variables repeatedly switch their tentative values. A very successful algorithm based on repairing tentative values is called Weak Commitment <ref> [Yok94] </ref>. On starting all the variables have tentative values. Variables in conflict are repaired 30 by instantiating them until either there are no more conflicts and the algorithm terminates, or the remaining conflicts cannot be repaired.
References-found: 9

