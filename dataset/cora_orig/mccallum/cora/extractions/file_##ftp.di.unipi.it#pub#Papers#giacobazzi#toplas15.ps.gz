URL: file://ftp.di.unipi.it/pub/Papers/giacobazzi/toplas15.ps.gz
Refering-URL: http://www.di.unipi.it/di/groups/lp/papers.html
Root-URL: 
Title: A General Framework for Semantics-based Bottom-up Abstract Interpretation of Logic Programs  
Author: Roberto Barbuti Roberto Giacobazzi Giorgio Levi 
Keyword: Categories and Subject Descriptors: D.2.2 [Software Engineering]: Tools and Techniques; D.2.4 [Software Engineering]: Program Verification; D.3.1 [Programming Languages]: Formal Definitions and Theory semantics; F.3.2 [Logic and Meaning of Programs]: Semantics of Programming Languages; I.2.3 [Artificial Intelligence]: Deduction and Theorem Proving logic programming. Keywords: Abstract interpretation, logic programming, program analysis.  
Note: in ACM Transactions on Programming Languages and Systems Vol  
Address: Corso Italia 40, 56125 Pisa  
Affiliation: Dipartimento di Informatica Universita di Pisa  
Email: fbarbuti,giaco,levig@di.unipi.it  
Date: 15, January 1993  
Abstract: The theory of abstract interpretation provides a formal framework to develop advanced dataflow analysis tools. The idea is to define a non-standard semantics which is able to compute, in finite time, an approximated model of the program. In this paper we define an abstract interpretation framework based on a fixpoint approach to the semantics. This leads to the definition, by means of a suitable set of operators, of an abstract fixpoint characterization of a -model associated with the program. Thus, we obtain a specializable abstract framework for bottom-up abstract interpretations of definite logic programs. The specialization of the framework is shown on two examples, namely ground dependence analysis and depth-k analysis. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> S. Abramsky and C. Hankin. </author> <title> An Introduction to Abstract Interpretation. </title> <editor> In S. Abramsky and C. Hankin, editors, </editor> <booktitle> Abstract Interpretation of Declarative Languages, </booktitle> <pages> pages 9-31. </pages> <publisher> Ellis Horwood Ltd, </publisher> <year> 1987. </year>
Reference-contexts: An introduction to the subject of abstract interpretation in the field of logic and functional languages can be found in <ref> [1] </ref>. Abstract interpretation is inherently semantics sensitive. However, in many cases the result is an ad-hoc algorithm (see for example [8]). <p> 6 further extensions and applications of the general framework are presented. 2 2 Logic Programs and Abstract Interpretation In this section we recall some notions about lattice theory [7], about the semantics of logic programs (as defined in [23]) and about the general theory of abstract interpretation (as defined in <ref> [1, 13] </ref>.
Reference: [2] <author> R. Barbuti, M. Codish, R. Giacobazzi, and G. Levi. </author> <title> Modelling Prolog Control. </title> <booktitle> In Proc. Nineteenth Annual ACM Symp. on Principles of Programming Languages. ACM, </booktitle> <year> 1992. </year>
Reference-contexts: The idea is to enhance a given (Prolog) program with a transformation defined in terms of an instance of the cc paradigm so that the standard meaning of the enhanced program reflects the required control information <ref> [2] </ref>. This approach to Prolog analysis, needs a richer abstract interpretation technique, general enough to handle the constraint logic programming paradigm. In its present form, the approach can be instantiated to various analyses.
Reference: [3] <author> R. Barbuti and R. Giacobazzi. </author> <title> A Bottom-up Polymorphic Type Inference in Logic Programming. </title> <type> Technical Report TR 27/89, </type> <institution> Dipartimento di Informatica, Universita di Pisa, </institution> <year> 1989. </year>
Reference-contexts: The abstract universe of terms is the set of equivalence classes denotations U ] P = fnat; char; errg. In the abstract universe, terms are then approximated by their type structure. An extension to type polymorphism, by a suitable partitioning of the universe of terms, is presented in <ref> [3] </ref>. The abstract domain of terms can be a non-flat one. If variables are considered [3] the partial ordering relation (less instantiated than) on concrete terms (up to renaming) can be abstracted in order to define a partial ordering relation ] on abstract terms too. 3.1.2 Abstract base The abstract base <p> In the abstract universe, terms are then approximated by their type structure. An extension to type polymorphism, by a suitable partitioning of the universe of terms, is presented in <ref> [3] </ref>. The abstract domain of terms can be a non-flat one. If variables are considered [3] the partial ordering relation (less instantiated than) on concrete terms (up to renaming) can be abstracted in order to define a partial ordering relation ] on abstract terms too. 3.1.2 Abstract base The abstract base of atoms Atoms ] represents the set of atoms instantiated over the abstract universe. 10 <p> g t or t ] = t ; and 8# = f t 1 =x 1 ; :::; t m =x m g where t j 2 t j , j = 1; :::; m, we have t# 2 t (a deeper discussion of type inference can be found in <ref> [3] </ref>). No type labels are returned if the unification is performed with an abstract term g. <p> Given a goal G : ? sum (a; x; y), the abstract substitution returned by ff-unifying the goal into the abstract -model is hnat=x; char=yi corresponding to the success pattern of G <ref> [3] </ref>. 4 Applications In the previous sections we have defined a general scheme which allows us to construct bottom-up abstract interpretations for logic programs according to the Cousot's idea, following the fixpoint approach to the semantics for logic programs. <p> The notion of "useful partial binding" is defined through a refinement of that of previously defined ground dependence, namely, a partial ground binding in a list structure is useful when it allows the consumer to produce ground bindings on other 42 arguments. Finally, we developed <ref> [3] </ref> an application of our framework to polymorphic type inference extending the results in [36, 53]. Acknowledgments The authors are indebted to the anonymous referees for many helpful comments and suggestions on an earlier version of this paper.
Reference: [4] <author> R. Barbuti, R. Giacobazzi, and G. Levi. </author> <title> A Declarative Abstract Semantics for Logic Programs. </title> <editor> In A. Bertoni, C. Bohm, and P. Miglioli, editors, </editor> <booktitle> Proc. of the Third Italian Conference on Theoretical Computer Science, </booktitle> <pages> pages 84-96. </pages> <publisher> World Scientific, </publisher> <year> 1989. </year>
Reference-contexts: As we can observe, the abstract models we obtain are richer than the ones based on different semantics definitions. The semantics defined in [23] was used in <ref> [4] </ref> (an earlier version of our framework) and independently used in [10, 37]. [10] extends our approach with an elegant mechanism to compute call patterns in a bottom-up way, by using program transformations. In [37] an algebraic framework for the abstract interpretation of logic programs is presented.
Reference: [5] <author> R. Barbuti and A. Martelli. </author> <title> A Structured Approach to Semantics Correctness. </title> <booktitle> Science of Computer Programming, </booktitle> <volume> 3 </volume> <pages> 279-311, </pages> <year> 1983. </year>
Reference-contexts: This notion allows us to formally handle the correctness condition on the abstract interpretation framework <ref> [5] </ref>.
Reference: [6] <author> R. Barbuti and M. Martelli. </author> <title> Recognizing Non-Floundering Logic Programs and Goals. </title> <journal> International Journal on Foundations of Computer Science, </journal> <volume> 1(2) </volume> <pages> 151-163, </pages> <year> 1990. </year>
Reference-contexts: Some new applications of the framework are mentioned at the end of Section 4.1. 4.1 Ground Dependence Analysis Ground analysis has been considered by several authors in a top-down framework <ref> [6, 16, 19, 43, 48, 35] </ref>. Most of the above papers are concerned with groundness analysis for code optimization. Thus the emphasis is on obtaining information about call patterns. Our analysis collects goal independent information about success patterns of the program.
Reference: [7] <author> G. Birkhoff. </author> <title> Lattice Theory. </title> <booktitle> In AMS Colloquium Publication, third ed., </booktitle> <year> 1967. </year>
Reference-contexts: In section 5 the relation between our framework and other proposals on the same subject is discussed. Finally, in section 6 further extensions and applications of the general framework are presented. 2 2 Logic Programs and Abstract Interpretation In this section we recall some notions about lattice theory <ref> [7] </ref>, about the semantics of logic programs (as defined in [23]) and about the general theory of abstract interpretation (as defined in [1, 13]. <p> Operators 2 Op such that () = 0 are usually called constants. Groups and lattices are families of algebras, each one satisfying a specified set of postulates <ref> [7] </ref>. The most important generalization of the algebraic lattice concept is provided by semilat-tices. An algebra with a single binary idempotent, commutative and associative operation is called a semilattice [7]. <p> Groups and lattices are families of algebras, each one satisfying a specified set of postulates <ref> [7] </ref>. The most important generalization of the algebraic lattice concept is provided by semilat-tices. An algebra with a single binary idempotent, commutative and associative operation is called a semilattice [7]. If we denote by t (join) and u (meet) the binary operations corresponding to the least upper bound and the greatest lower bound respectively, it follows that any lattice is both a join and a meet-semilattice. <p> Proof. (H P ; ff ) is a finite join-semilattice. Since I ([;] I ) 2 H P and 8I ] 2 H P , I ([;] I ) ff I ] ; and H is a finite domain, (H P ; ff ) is a complete lattice <ref> [7] </ref>. 2 3.1.4 Abstract substitutions In order to model abstract observable properties we have also to reconsider the substitution notion within the abstract framework.
Reference: [8] <author> M. Bruynooghe and G. Janssens. </author> <title> An Instance of Abstract Interpretation Integrating Type and Mode Inferencing. </title> <editor> In R. A. Kowalski and K. A. Bowen, editors, </editor> <booktitle> Proc. Fifth Int'l Conf. on Logic Programming, </booktitle> <pages> pages 669-683. </pages> <publisher> The MIT Press, </publisher> <address> Cambridge, Mass., </address> <year> 1988. </year>
Reference-contexts: An introduction to the subject of abstract interpretation in the field of logic and functional languages can be found in [1]. Abstract interpretation is inherently semantics sensitive. However, in many cases the result is an ad-hoc algorithm (see for example <ref> [8] </ref>). <p> The most popular approach is the top-down one, which propagates the information in the same direction as SLD-resolution does. In this class we can find top-down ad-hoc algorithms, frameworks based on an operational semantics, and frameworks based on a denotational semantics <ref> [8, 9, 19, 43, 48, 46, 58, 35] </ref>. The bottom-up approach propagates the information as in the computation of the least fixpoint of the immediate consequences operator T P [39, 60]. <p> In [37] an algebraic framework for the abstract interpretation of logic programs is presented. The main contribution of the paper is the use of the bottom-up framework to give a rigorous formalization of the Bruynooghe's practical method <ref> [8, 9] </ref>. The main difference between [37] and our framework is the use of abstract substitutions. The presentation in [37] is given without considering the substitution notion, in terms of domains of tuples of atoms.
Reference: [9] <author> M. Bruynooghe, G. Janssens, B. Demoen, and A. Callebaut. </author> <title> Abstract Interpretation: Towards the Global Optimization of Prolog Programs. </title> <booktitle> In Proc Fourth IEEE Symp. Logic Programming, </booktitle> <pages> pages 192-204. </pages> <publisher> IEEE Comp. Soc. Press, </publisher> <year> 1987. </year>
Reference-contexts: Its goal is to collect static (compile-time) information about the run-time behavior of a program (data-flow analysis), to be used by compilers (for error detection, code optimization <ref> [9, 11, 20, 36] </ref>) and, in general, by program manipulation systems [27]. An introduction to the subject of abstract interpretation in the field of logic and functional languages can be found in [1]. Abstract interpretation is inherently semantics sensitive. <p> The most popular approach is the top-down one, which propagates the information in the same direction as SLD-resolution does. In this class we can find top-down ad-hoc algorithms, frameworks based on an operational semantics, and frameworks based on a denotational semantics <ref> [8, 9, 19, 43, 48, 46, 58, 35] </ref>. The bottom-up approach propagates the information as in the computation of the least fixpoint of the immediate consequences operator T P [39, 60]. <p> The abstract interpretation framework is composed of two levels. A core level, shared by all the applications, defines an abstract T P expressed in terms of a suitable set of abstract operators. These operators essentially play the role of similar ones in <ref> [9, 48, 35] </ref>. The specialization level defines the abstract operators for each specific application. The standard semantics can be viewed as a specialization of the abstract one. If the definitions of the abstract operators satisfy some properties, then the correctness of the specific analysis is guaranteed. <p> In [37] an algebraic framework for the abstract interpretation of logic programs is presented. The main contribution of the paper is the use of the bottom-up framework to give a rigorous formalization of the Bruynooghe's practical method <ref> [8, 9] </ref>. The main difference between [37] and our framework is the use of abstract substitutions. The presentation in [37] is given without considering the substitution notion, in terms of domains of tuples of atoms.
Reference: [10] <author> M. Codish, D. Dams, and E. Yardeni. </author> <title> Bottom-up Abstract Interpretation of Logic Programs. </title> <type> Technical report, </type> <institution> Dept. of Computer Science, The Weizmann Institute, Rehovot, </institution> <year> 1990. </year>
Reference-contexts: In some applications, as an example, the analysis returns at most one success pattern per program clause <ref> [10] </ref> or per predicate symbol [19, 47]. This assumption is reasonable if we assume that in most of the real programs, specific predicate arguments are used with the same mode or type structure. As shown in [18], this technique may lead to a considerable simplification in the analysis complexity. <p> However, to make the analysis more concise (and efficient [18]) we can approximate success patterns with their least upper bound, maintaining at most one success pattern per predicate symbol <ref> [10] </ref>. For this reason, we introduce a merging hypergraph operator which, given a set of hypergraphs, returns the least upper bound hypergraph (the hypergraph more general with respect to the dependence information), containing all and only those dependences which are shared by all the elements in the set. <p> As we can observe, the abstract models we obtain are richer than the ones based on different semantics definitions. The semantics defined in [23] was used in [4] (an earlier version of our framework) and independently used in <ref> [10, 37] </ref>. [10] extends our approach with an elegant mechanism to compute call patterns in a bottom-up way, by using program transformations. In [37] an algebraic framework for the abstract interpretation of logic programs is presented. <p> As we can observe, the abstract models we obtain are richer than the ones based on different semantics definitions. The semantics defined in [23] was used in [4] (an earlier version of our framework) and independently used in [10, 37]. <ref> [10] </ref> extends our approach with an elegant mechanism to compute call patterns in a bottom-up way, by using program transformations. In [37] an algebraic framework for the abstract interpretation of logic programs is presented. <p> The idea is to specialize our scheme, by using the same abstract universe of the groundness analysis and a different notion of dependence. Namely, there exists a dependence between some arguments iff the same variable occurs in all of them. The same problem has been considered in <ref> [10] </ref>, where a bottom-up approach, based again on the concrete semantics in [23], is used. An extension of the notion of ground dependence may also be useful to detect cases when pipeline optimizations in AND-Parallelism are applicable.
Reference: [11] <author> M. Corsini and G. </author> <title> File. A Complete Framework for the Abstract Interpretation of Logic Programs: Theory and Application. </title> <type> Technical report, </type> <institution> Universita di Padova, Italy, </institution> <year> 1989. </year>
Reference-contexts: Its goal is to collect static (compile-time) information about the run-time behavior of a program (data-flow analysis), to be used by compilers (for error detection, code optimization <ref> [9, 11, 20, 36] </ref>) and, in general, by program manipulation systems [27]. An introduction to the subject of abstract interpretation in the field of logic and functional languages can be found in [1]. Abstract interpretation is inherently semantics sensitive.
Reference: [12] <author> A. Cortesi and G. </author> <title> File. Abstract Interpretation of Logic Programs: an Abstract Domain for Groundness, Sharing, Freeness and Compoundness Analysis. </title> <booktitle> In Proc. ACM Symposium on Partial Evaluation and Semantics-based Program Transformation. ACM 1991. </booktitle>
Reference-contexts: Let us consider an abstract universe of terms. We want to define it as composed of equivalence classes corresponding to the sets of (definitely) ground and (possibly) non-ground terms. Ground dependence analysis (like sharing analysis <ref> [12, 43, 57] </ref>) requires variable information for each non-ground concrete term. The equivalence relation t is defined as follows 8t 1 ; t 2 2 U P : t 1 t t 2 iff var (t 1 ) = var (t 2 ).
Reference: [13] <author> P. Cousot and R. Cousot. </author> <title> Abstract Interpretation: A Unified Lattice Model for Static Analysis of Programs by Construction or Approximation of Fixpoints. </title> <booktitle> In Proc. Fourth ACM Symp. Principles of Programming Languages, </booktitle> <pages> pages 238-252, </pages> <year> 1977. </year>
Reference-contexts: 1 Introduction An abstract interpretation <ref> [13, 14] </ref> of a program is an approximation of its standard semantics on an abstract simpler, generally finite, domain. <p> explicitly based on a formal semantics definition. fl This work has been supported by "Progetto Finalizzato Sistemi Informatici e Calcolo Parallelo" of C.N.R. under grant n. 9100880.PF69 and by the Esprit Basic Research Action 3012 - Compulog. 1 The last approach (semantics-based abstract interpretation) is closer to the original approach <ref> [13] </ref> in which a specific semantics (collecting semantics) was defined in order to make possible the static dataflow analysis. Different semantics definition styles lead to different approaches to program analysis. In the case of logic programs, there exist mainly two approaches, namely top-down analysis and bottom-up analysis [46]. <p> 6 further extensions and applications of the general framework are presented. 2 2 Logic Programs and Abstract Interpretation In this section we recall some notions about lattice theory [7], about the semantics of logic programs (as defined in [23]) and about the general theory of abstract interpretation (as defined in <ref> [1, 13] </ref>. <p> B 0 9 # 0 = mgu ((B 1 ; :::; B n ); (B 0 n )), then 9 # such that G # P 2 and # 0 2.3 Abstract Interpretation We now formalize the notion of abstract interpretation according to the ideas given by Cousot and Cousot <ref> [13] </ref>. Let us consider a concrete domain D P (a set of computational state representations associated with the generic program P ) which is a complete lattice with respect to a partial order relation D P , and a state transition function E P , defined on D P . <p> According to the notation of Mycroft [52], in the following we denote by O ] the abstract analog of any concrete syntactic object O. The relation between the standard and the abstract semantics was established in <ref> [13] </ref> by defining a pair of functions ff and fl (abstraction and concretization), which form a Galois connection between (D ] ] D P ) and (D P ; D P ) [33, 49, 54]. <p> This notion allows us to formally handle the correctness condition on the abstract interpretation framework [5]. Formally, an abstract interpretation scheme <ref> [13, 45] </ref> is a tuple h (D P ; D P ) ; E P ; (D P ; D P ) ; E P ; ff ; fli such that 1. (D P ; D P ) and (D P ; D P ) are complete lattices, 7 2. <p> Galois connections give us the formal framework to prove correctness of an abstract interpretation. They define a strong relationship between the concrete domain of computations and the abstract, usually simpler, domain associated with the analysis. Their usefulness was outlined in <ref> [13, 14] </ref> as a base to develop soundness conditions for semantics-based analysis of flowchart programs. Galois insertions ensure that the domain D ] P (the abstract domain of computation) does not contain redundant elements. <p> Galois insertions ensure that the domain D ] P (the abstract domain of computation) does not contain redundant elements. According to conditions 4 and 5, the concretization cannot cause any loss of information, while the abstraction of a concrete object may cause some loss of information <ref> [13] </ref>. <p> The correctness of such an approximation can be given by one of the following correct ness conditions <ref> [13, 14] </ref>: * 8 d 2 D P : ff (E P (d)) D ] E P (ff (d)), ] ] Proposition 2.3 [13] 8d 2 D P : ff (E P (d)) D ] E P (ff (d)) ) 8d ] 2 D P : E P (fl (d ] <p> The correctness of such an approximation can be given by one of the following correct ness conditions [13, 14]: * 8 d 2 D P : ff (E P (d)) D ] E P (ff (d)), ] ] Proposition 2.3 <ref> [13] </ref> 8d 2 D P : ff (E P (d)) D ] E P (ff (d)) ) 8d ] 2 D P : E P (fl (d ] )) D P fl (E P (d ] )). <p> These properties are related to two different aspects. The first one concerns monotonicity and allows the definition of a monotonic abstract immediate consequence operator. The second one is related to the correctness of each abstract operator as defined in <ref> [13] </ref>, and ensures a correct definition of the abstract interpretation. * Monotonicity: given a n-tuple of concrete atoms (B 1 ; :::; B n ) 2 B n P , for each I ] ] 2 2 H P such that I 1 ff I 2 we have ff-mgu ((B 1
Reference: [14] <author> P. Cousot and R. Cousot. </author> <title> Systematic Design of Program Analysis Frameworks. </title> <booktitle> In Proc. Sixth ACM Symp. Principles of Programming Languages, </booktitle> <pages> pages 269-282, </pages> <year> 1979. </year>
Reference-contexts: 1 Introduction An abstract interpretation <ref> [13, 14] </ref> of a program is an approximation of its standard semantics on an abstract simpler, generally finite, domain. <p> Galois connections give us the formal framework to prove correctness of an abstract interpretation. They define a strong relationship between the concrete domain of computations and the abstract, usually simpler, domain associated with the analysis. Their usefulness was outlined in <ref> [13, 14] </ref> as a base to develop soundness conditions for semantics-based analysis of flowchart programs. Galois insertions ensure that the domain D ] P (the abstract domain of computation) does not contain redundant elements. <p> The correctness of such an approximation can be given by one of the following correct ness conditions <ref> [13, 14] </ref>: * 8 d 2 D P : ff (E P (d)) D ] E P (ff (d)), ] ] Proposition 2.3 [13] 8d 2 D P : ff (E P (d)) D ] E P (ff (d)) ) 8d ] 2 D P : E P (fl (d ] <p> The definition of abstract domains for program analysis is often a hard step in the abstract interpretation definition. The systematic approach given in <ref> [14] </ref> can be applied to logic programming obtaining elegant techniques to define abstract domains. These techniques can always be summarized by a suitable notion of data equivalence [16, 19]. In the following we develop a step-by-step approach to the abstract domain definition.
Reference: [15] <author> P. </author> <title> Dart. On Derived Dependencies and Connected Databases. </title> <type> Technical Report No. 87/13, </type> <institution> Dept. of Computer Science, Univ. of Melbourne, </institution> <year> 1987. </year> <month> 43 </month>
Reference-contexts: Given a goal G, by abstract unification with atoms in F ] (P ) we obtain information on which arguments will definitely become ground and on ground dependences between the arguments. The underlying analysis is similar to the one in <ref> [15] </ref>, which, however, is not explained in terms of abstract interpretation. In Section 4.1.1 we briefly discuss the use of our analysis to obtain call patterns information. Let us consider an abstract universe of terms. <p> As we will see, the unification process on atoms having data dependences can be summarized in a suitable graph notation. Then, the abstract unification can be specialized in a very efficient way, as a simple data dependences calculus, whose principles were introduced by <ref> [15, 41] </ref>. 25 We propose a new abstract domain of atoms which is isomorphic to the abstract base. Dependence information is represented by means of an hypergraph notation. The resulting analysis is more concise and efficient than the standard one, exploiting explicit dependences. <p> This approach to Prolog analysis, needs a richer abstract interpretation technique, general enough to handle the constraint logic programming paradigm. In its present form, the approach can be instantiated to various analyses. The groundness analysis framework can be extended to deal with variable sharing analysis <ref> [15, 34, 51, 43, 48, 57] </ref>. The idea is to specialize our scheme, by using the same abstract universe of the groundness analysis and a different notion of dependence. Namely, there exists a dependence between some arguments iff the same variable occurs in all of them.
Reference: [16] <author> S. Debray. </author> <title> Efficient Dataflow Analysis of Logic Programs. </title> <booktitle> In Proc. Fifteenth Annual ACM SIGACT-SIGPLAN Symp. on Principles of Programming Languages, </booktitle> <pages> pages 260-273, </pages> <address> San Diego, </address> <year> 1988. </year>
Reference-contexts: The systematic approach given in [14] can be applied to logic programming obtaining elegant techniques to define abstract domains. These techniques can always be summarized by a suitable notion of data equivalence <ref> [16, 19] </ref>. In the following we develop a step-by-step approach to the abstract domain definition. The main problem is what we want to observe from concrete data behavior and how the resulting abstract data are represented in order to have an efficient (concise) data-flow analysis. <p> Some new applications of the framework are mentioned at the end of Section 4.1. 4.1 Ground Dependence Analysis Ground analysis has been considered by several authors in a top-down framework <ref> [6, 16, 19, 43, 48, 35] </ref>. Most of the above papers are concerned with groundness analysis for code optimization. Thus the emphasis is on obtaining information about call patterns. Our analysis collects goal independent information about success patterns of the program.
Reference: [17] <author> S. Debray and R. Ramakrishnan. </author> <title> Generalized Horn Clause Programs. </title> <type> Technical report, </type> <institution> Dept. of Computer Science, The Univ. of Arizona, Tucson, </institution> <year> 1991. </year>
Reference-contexts: Our abstract immediate consequences operators can be viewed as instances of a more general operator whose algebraic properties are defined in <ref> [17] </ref>.
Reference: [18] <author> S. Debray. </author> <title> The Mythical Free Lunch (Notes on the Complexity/Precision Tradeoff in Dataflow Analysis of Logic Programs). </title> <type> Technical report, </type> <institution> Dept. of Computer Science, The Univ. of Arizona, Tucson, </institution> <year> 1991. </year>
Reference-contexts: This assumption is reasonable if we assume that in most of the real programs, specific predicate arguments are used with the same mode or type structure. As shown in <ref> [18] </ref>, this technique may lead to a considerable simplification in the analysis complexity. <p> Hyperarcs are defined as in the abstract atom case. In order to collect all the success patterns, the congruence relation required to define abstract -interpretations is simply identity, H P = 2 B ] P . However, to make the analysis more concise (and efficient <ref> [18] </ref>) we can approximate success patterns with their least upper bound, maintaining at most one success pattern per predicate symbol [10].
Reference: [19] <author> S. Debray and D.S. Warren. </author> <title> Automatic Mode Inference for Logic Programs. </title> <journal> Journal of Logic Programming, </journal> <volume> 5 </volume> <pages> 207-230, </pages> <year> 1988. </year>
Reference-contexts: The most popular approach is the top-down one, which propagates the information in the same direction as SLD-resolution does. In this class we can find top-down ad-hoc algorithms, frameworks based on an operational semantics, and frameworks based on a denotational semantics <ref> [8, 9, 19, 43, 48, 46, 58, 35] </ref>. The bottom-up approach propagates the information as in the computation of the least fixpoint of the immediate consequences operator T P [39, 60]. <p> The systematic approach given in [14] can be applied to logic programming obtaining elegant techniques to define abstract domains. These techniques can always be summarized by a suitable notion of data equivalence <ref> [16, 19] </ref>. In the following we develop a step-by-step approach to the abstract domain definition. The main problem is what we want to observe from concrete data behavior and how the resulting abstract data are represented in order to have an efficient (concise) data-flow analysis. <p> In some applications, as an example, the analysis returns at most one success pattern per program clause [10] or per predicate symbol <ref> [19, 47] </ref>. This assumption is reasonable if we assume that in most of the real programs, specific predicate arguments are used with the same mode or type structure. As shown in [18], this technique may lead to a considerable simplification in the analysis complexity. <p> Some new applications of the framework are mentioned at the end of Section 4.1. 4.1 Ground Dependence Analysis Ground analysis has been considered by several authors in a top-down framework <ref> [6, 16, 19, 43, 48, 35] </ref>. Most of the above papers are concerned with groundness analysis for code optimization. Thus the emphasis is on obtaining information about call patterns. Our analysis collects goal independent information about success patterns of the program. <p> By using the value ng we want to stress that ng represents the set of all non-ground terms in the universe. This shows that the abstract domain for groundness can be used as term representation in ground dependence analysis, and it does not need to be ordered by set-inclusion <ref> [19, 48] </ref>. A more natural ordering relation is, in fact, that based on the usual instantiation relation as given for ] .
Reference: [20] <author> B. Demoen, P. VanRoy, and Y.D. Willems. </author> <title> Improving the Execution Speed of Compiled Prolog with Modes, Clause Selection and Determinism. </title> <editor> In H. Ehrig, R. Kowalski, G. Levi, and U. Montanari, editors, </editor> <booktitle> Proc. TAPSOFT 1987, volume 250 of Lecture Notes in Computer Science, </booktitle> <pages> pages 111-125. </pages> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1987. </year>
Reference-contexts: Its goal is to collect static (compile-time) information about the run-time behavior of a program (data-flow analysis), to be used by compilers (for error detection, code optimization <ref> [9, 11, 20, 36] </ref>) and, in general, by program manipulation systems [27]. An introduction to the subject of abstract interpretation in the field of logic and functional languages can be found in [1]. Abstract interpretation is inherently semantics sensitive. <p> Thus, in this clause the procedure t is always called with a ground argument. This allows several optimizations to be performed in the code of p (for example elimination of backtrack points <ref> [20] </ref>). In the second clause, the unification of the goal ? s (x; y) with s (ng; ng) ? binds y to ng, thus showing that t can be called with a non-ground argument.
Reference: [21] <author> E. Eder. </author> <title> Properties of substitutions and unifications. </title> <journal> Journal of Symbolic Computation, </journal> <volume> 1 </volume> <pages> 31-46, </pages> <year> 1985. </year>
Reference-contexts: We denote by mgu (E) the set f# 2 U nif (E) j 8# 0 2 U nif (E) : # # 0 g. It is well known that all the most general unifiers of a set E are equivalent <ref> [21, 38] </ref>. Consider a program P and the set Cons P of constructors of the first order language underlying P .
Reference: [22] <author> M. Falaschi, G. Levi, M. Martelli, and C. Palamidessi. </author> <title> A new Declarative Semantics for Logic Languages. </title> <editor> In R. A. Kowalski and K. A. Bowen, editors, </editor> <booktitle> Proc. Fifth Int'l Conf. on Logic Programming, </booktitle> <pages> pages 993-1005. </pages> <publisher> The MIT Press, </publisher> <address> Cambridge, Mass., </address> <year> 1988. </year>
Reference-contexts: However, the standard T P operator, whose least fixpoint is the least Herbrand model, being defined on ground atoms only, does not allow to model correctly the concept of logical variable which is essential in describing properties like modes and aliasing [37, 45]. In <ref> [22, 23, 24] </ref> a model-theoretic and a fixpoint semantics is defined which capture (non-ground) computed answer substitutions. The corresponding immediate consequences operator operates on a domain composed of ground and non-ground atoms. This concrete semantics is used as the basis for our abstract interpretation framework. <p> , where mod denotes elements in Op mod and [a] denotes the equivalence class of a with respect to (i.e. [a] = fa 0 j a 0 ag). 2.2 A semantics of Logic Programs adequate to Abstract Interpretation The following results about the semantics of logic programs are defined in <ref> [22, 23] </ref>. The semantic definition in [22, 23] is closer than the one in [39, 60] to the operational behavior of logic programs, which was shown to require a more complex and appropriate notion of model, in general different from the minimal Herbrand model. <p> Op mod and [a] denotes the equivalence class of a with respect to (i.e. [a] = fa 0 j a 0 ag). 2.2 A semantics of Logic Programs adequate to Abstract Interpretation The following results about the semantics of logic programs are defined in <ref> [22, 23] </ref>. The semantic definition in [22, 23] is closer than the one in [39, 60] to the operational behavior of logic programs, which was shown to require a more complex and appropriate notion of model, in general different from the minimal Herbrand model. <p> Thus, in order to capture such operational behaviors, we have to consider non-minimal -models. We introduce now an immediate consequences operator T P on -interpretations whose least fixpoint is a non-minimal -model which is able to capture computed answer substitutions. Definition 2.3 (immediate consequences operator) <ref> [22, 23] </ref> Given a logic program P , the operator T P on the set of -interpretations associated with P is defined as follows T P (I) = f A 0 2 B P j 9 (B 0 n ) 2 I with no variables in common with C and with <p> In the following we use T P " ff as a notation for [ n2ff P (;), where ff is a set of finite ordinals and ! denotes the set of all the finite ordinals. 6 Definition 2.4 (fixpoint semantics F (P )) <ref> [22, 23] </ref> For every program P , F (P ) = lf p (T P ) = T P " !. We observe that each -interpretation I such that T P (I) I is a -model for P . Moreover, F (P ) is a -model as well. <p> Theorem 2.1 (Strong Soundness) <ref> [22, 23] </ref> Let P be a logic program and let G be a goal ? B 1 ; :::; B n . <p> Assume that G # P 2, then 9 B 0 n 2 F (P ) and 9 # 0 = mgu ((B 1 ; :::; B n ); (B 0 n )) such that # 0 jG = # jG . Theorem 2.2 (Strong Completeness) <ref> [22, 23] </ref> Let P be a logic program and let G be a goal ? B 1 ; :::; B n . <p> For example this definition assigns the same meaning to the two programs fp (x)g and fp (x); p (a)g. In the following example we show that the strong soundness and completeness of the underlying concrete semantics <ref> [22, 23] </ref> allows to obtain better abstract information with respect to the usual Herbrand (ground) model approximation [45] and with respect to the bottom-up semantics-based analysis framework given in [46].
Reference: [23] <author> M. Falaschi, G. Levi, M. Martelli, and C. Palamidessi. </author> <title> Declarative Modeling of the Operational Behavior of Logic Languages. </title> <journal> Theoretical Computer Science, </journal> <volume> 69(3) </volume> <pages> 289-318, </pages> <year> 1989. </year>
Reference-contexts: However, the standard T P operator, whose least fixpoint is the least Herbrand model, being defined on ground atoms only, does not allow to model correctly the concept of logical variable which is essential in describing properties like modes and aliasing [37, 45]. In <ref> [22, 23, 24] </ref> a model-theoretic and a fixpoint semantics is defined which capture (non-ground) computed answer substitutions. The corresponding immediate consequences operator operates on a domain composed of ground and non-ground atoms. This concrete semantics is used as the basis for our abstract interpretation framework. <p> If the definitions of the abstract operators satisfy some properties, then the correctness of the specific analysis is guaranteed. The paper is organized as follows. In the first part, the main concepts and results on the fixpoint semantics <ref> [23] </ref> are presented, together with a presentation of the abstract interpretation notions. Section 3 defines the abstract fixpoint semantics based on a suitable set of abstract operators. Section 4 introduces two specific applications, namely ground dependence and depth-k analysis. <p> Finally, in section 6 further extensions and applications of the general framework are presented. 2 2 Logic Programs and Abstract Interpretation In this section we recall some notions about lattice theory [7], about the semantics of logic programs (as defined in <ref> [23] </ref>) and about the general theory of abstract interpretation (as defined in [1, 13]. <p> , where mod denotes elements in Op mod and [a] denotes the equivalence class of a with respect to (i.e. [a] = fa 0 j a 0 ag). 2.2 A semantics of Logic Programs adequate to Abstract Interpretation The following results about the semantics of logic programs are defined in <ref> [22, 23] </ref>. The semantic definition in [22, 23] is closer than the one in [39, 60] to the operational behavior of logic programs, which was shown to require a more complex and appropriate notion of model, in general different from the minimal Herbrand model. <p> Op mod and [a] denotes the equivalence class of a with respect to (i.e. [a] = fa 0 j a 0 ag). 2.2 A semantics of Logic Programs adequate to Abstract Interpretation The following results about the semantics of logic programs are defined in <ref> [22, 23] </ref>. The semantic definition in [22, 23] is closer than the one in [39, 60] to the operational behavior of logic programs, which was shown to require a more complex and appropriate notion of model, in general different from the minimal Herbrand model. <p> The semantic definition in [22, 23] is closer than the one in [39, 60] to the operational behavior of logic programs, which was shown to require a more complex and appropriate notion of model, in general different from the minimal Herbrand model. The model theoretic and fixpoint semantics in <ref> [23] </ref> capture possibly non-ground computed answer substitutions. Such a semantic definition is then the right one in order to develop a bottom-up abstract interpretation framework, without requiring to extend the standard semantics with a somewhat artificial collecting semantics. <p> Thus, in order to capture such operational behaviors, we have to consider non-minimal -models. We introduce now an immediate consequences operator T P on -interpretations whose least fixpoint is a non-minimal -model which is able to capture computed answer substitutions. Definition 2.3 (immediate consequences operator) <ref> [22, 23] </ref> Given a logic program P , the operator T P on the set of -interpretations associated with P is defined as follows T P (I) = f A 0 2 B P j 9 (B 0 n ) 2 I with no variables in common with C and with <p> It derives possibly non-ground atoms by means of a bottom-up inference rule which is based on unification, as in the top-down SLD resolution. As usual, T P is a continuous function on the complete lattice of -interpretations ordered by set-inclusion <ref> [23] </ref>. The following definition gives a fixpoint characterization of the program semantics. <p> In the following we use T P " ff as a notation for [ n2ff P (;), where ff is a set of finite ordinals and ! denotes the set of all the finite ordinals. 6 Definition 2.4 (fixpoint semantics F (P )) <ref> [22, 23] </ref> For every program P , F (P ) = lf p (T P ) = T P " !. We observe that each -interpretation I such that T P (I) I is a -model for P . Moreover, F (P ) is a -model as well. <p> Theorem 2.1 (Strong Soundness) <ref> [22, 23] </ref> Let P be a logic program and let G be a goal ? B 1 ; :::; B n . <p> Assume that G # P 2, then 9 B 0 n 2 F (P ) and 9 # 0 = mgu ((B 1 ; :::; B n ); (B 0 n )) such that # 0 jG = # jG . Theorem 2.2 (Strong Completeness) <ref> [22, 23] </ref> Let P be a logic program and let G be a goal ? B 1 ; :::; B n . <p> Thus = ] fI ] 2 H P j I ] is an abstract -model of P g. The following theorem corresponds to the standard one <ref> [23] </ref> specifying = ] as a finite lattice with respect to ff . Theorem 3.13 = ] is a finite lattice with respect to the ff order relation. Proof. <p> However, the resulting semantics, which is the same as the C-semantics in <ref> [23] </ref>, can only model the non-ground logical consequences of a program but not the computed answer substitutions. For example this definition assigns the same meaning to the two programs fp (x)g and fp (x); p (a)g. <p> For example this definition assigns the same meaning to the two programs fp (x)g and fp (x); p (a)g. In the following example we show that the strong soundness and completeness of the underlying concrete semantics <ref> [22, 23] </ref> allows to obtain better abstract information with respect to the usual Herbrand (ground) model approximation [45] and with respect to the bottom-up semantics-based analysis framework given in [46]. <p> As we can observe, the abstract models we obtain are richer than the ones based on different semantics definitions. The semantics defined in <ref> [23] </ref> was used in [4] (an earlier version of our framework) and independently used in [10, 37]. [10] extends our approach with an elegant mechanism to compute call patterns in a bottom-up way, by using program transformations. <p> The framework can be extended to cope with different language features. One of these features is, of course, negation. However, to handle negation we first need a suitable generalization of the concrete semantics in <ref> [23] </ref> to general programs. In general, we can apply our framework to those features that can be expressed through a suitable immediate consequences operator. <p> Namely, there exists a dependence between some arguments iff the same variable occurs in all of them. The same problem has been considered in [10], where a bottom-up approach, based again on the concrete semantics in <ref> [23] </ref>, is used. An extension of the notion of ground dependence may also be useful to detect cases when pipeline optimizations in AND-Parallelism are applicable. In [28] there is an application of our abstraction scheme able to detect ground dependences among subterms in list structures.
Reference: [24] <author> M. Falaschi, G. Levi, M. Martelli, and C. Palamidessi. </author> <title> A Model-Theoretic Reconstruction of the Operational Semantics of Logic Programs. </title> <type> Technical Report TR 32/89, </type> <institution> Dipartimento di Informat-ica, Universita di Pisa, </institution> <year> 1989. </year> <note> To appear in Information and Computation. </note>
Reference-contexts: However, the standard T P operator, whose least fixpoint is the least Herbrand model, being defined on ground atoms only, does not allow to model correctly the concept of logical variable which is essential in describing properties like modes and aliasing [37, 45]. In <ref> [22, 23, 24] </ref> a model-theoretic and a fixpoint semantics is defined which capture (non-ground) computed answer substitutions. The corresponding immediate consequences operator operates on a domain composed of ground and non-ground atoms. This concrete semantics is used as the basis for our abstract interpretation framework. <p> We extend also the notion of variance to any syntactic object (i.e. terms, atoms, clauses, etc.). In the following, an extended notion of interpretation (-interpretation) is given <ref> [24, 26] </ref>. -interpretations are more expressive than Herbrand interpretations because of the use of more syntactic objects (like variables) in the semantic domains. Analogously to the standard semantics, the Base of -interpretations B P is defined as Atoms= . <p> Analogously to the standard semantics, the Base of -interpretations B P is defined as Atoms= . A -interpretation I is a subset of B P (it represents the set of atoms which are true in I). Definition 2.1 <ref> [24] </ref> A -interpretation I is a -model for the logic program P iff every clause of P is true in the Herbrand interpretation G (I) (i.e. <p> Moreover, every Herbrand model is still a -model. However, the model intersection property does not hold in general for -models, i.e. the information of a -interpretation I 1 may be contained in I 2 without I 1 being a subset of I 2 . Definition 2.2 <ref> [24] </ref> Let I 1 and I 2 be -interpretations. <p> Using this extended semantic definition, it is possible to prove <ref> [24, 26] </ref> that, given a logic program P , * the set of -interpretations is a complete lattice with respect to set-inclusion, * let W be a set of -models of P , then glb (W ) is a -model for P , * the set of -models is a complete
Reference: [25] <author> M. </author> <title> Fitting. A Kripke-Kleene semantics for logic programs. </title> <journal> In Journal of Logic Programming, </journal> <volume> volume 2, </volume> <pages> pages 295-312, </pages> <year> 1985. </year>
Reference-contexts: (x; s (0); s (x)); sum (x; s (s (x 0 )); s (s (x)))g. 40 5 Related work As already mentioned in the introduction, the idea of T P -based bottom-up abstract interpretation goes back to [45], which considers general programs using as concrete semantics the one defined in <ref> [25] </ref>. Since this semantics is defined on a ground domain, the resulting abstract analysis is not able to capture computational properties related to the use of logical variables. [46] solves the above problem by using a non-ground domain for interpretations.
Reference: [26] <author> M. Gabbrielli and G. Levi. </author> <title> On the Semantics of Logic Programs. </title> <editor> In J. Leach Albert and B. Monien and M. Rodriguez-Artalejo, editors, </editor> <booktitle> Proc. of the 18th International Colloquium on Automata, Languages and Programming, volume 510 of Lecture Notes in Computer Science, </booktitle> <pages> pages 1-19. </pages> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1991. </year>
Reference-contexts: We extend also the notion of variance to any syntactic object (i.e. terms, atoms, clauses, etc.). In the following, an extended notion of interpretation (-interpretation) is given <ref> [24, 26] </ref>. -interpretations are more expressive than Herbrand interpretations because of the use of more syntactic objects (like variables) in the semantic domains. Analogously to the standard semantics, the Base of -interpretations B P is defined as Atoms= . <p> Using this extended semantic definition, it is possible to prove <ref> [24, 26] </ref> that, given a logic program P , * the set of -interpretations is a complete lattice with respect to set-inclusion, * let W be a set of -models of P , then glb (W ) is a -model for P , * the set of -models is a complete
Reference: [27] <author> J. Gallagher, M. Codish, and E. Shapiro. </author> <title> Specialization of Prolog and FCP Programs Using Abstract Interpretation. </title> <journal> New Generation Computing, </journal> <volume> 6 (2-3):159-186, </volume> <year> 1988. </year>
Reference-contexts: Its goal is to collect static (compile-time) information about the run-time behavior of a program (data-flow analysis), to be used by compilers (for error detection, code optimization [9, 11, 20, 36]) and, in general, by program manipulation systems <ref> [27] </ref>. An introduction to the subject of abstract interpretation in the field of logic and functional languages can be found in [1]. Abstract interpretation is inherently semantics sensitive. However, in many cases the result is an ad-hoc algorithm (see for example [8]).
Reference: [28] <author> R. Giacobazzi and L. Ricci. </author> <title> Pipeline Optimizations in AND-Parallelism by Abstract Interpretation. </title> <editor> In D. H. D. Warren and P. Szeredi, editors, </editor> <booktitle> Proc. Seventh Int'l Conf. on Logic Programming, </booktitle> <pages> pages 291-305. </pages> <publisher> The MIT Press, </publisher> <address> Cambridge, Mass., </address> <year> 1990. </year>
Reference-contexts: The problem of how abstract information is represented is central in abstract interpretation. Program analysis often requires to capture the interaction between abstract terms, like sharing and functional dependences <ref> [28, 30, 31, 32, 50, 61] </ref>. An equivalence relation on abstract atoms A characterizes such properties. Example 3.2 Let us consider the abstract universe of terms defined with respect to the following equivalence relation t 1 t t 2 iff var (t 1 ) = var (t 2 ). <p> There are further applications of the ground dependence analysis by means of the same abstract data representation. In <ref> [28, 29] </ref> the previous dataflow analysis is enhanced by means of labeled hypergraphs. Deterministic dependences [29] can then be exploited simply by adding a suitable set of labels to each hyperarc, without changing the abstraction framework. <p> Deterministic dependences [29] can then be exploited simply by adding a suitable set of labels to each hyperarc, without changing the abstraction framework. Moreover, the notion of dependence can also be specialized to capture depth-k ground dependence <ref> [28] </ref>. This technique is usefully applied to deduce information (i.e. pipeline AND-parallelism) to optimize the performance of AND/OR-parallel executions of logic programs in a massively parallel system [55]. 4.1.1 Bottom-up Analysis and Call Patterns As pointed out before, our groundness analysis determines an approximation of the program success set. <p> The same problem has been considered in [10], where a bottom-up approach, based again on the concrete semantics in [23], is used. An extension of the notion of ground dependence may also be useful to detect cases when pipeline optimizations in AND-Parallelism are applicable. In <ref> [28] </ref> there is an application of our abstraction scheme able to detect ground dependences among subterms in list structures. This allows to detect that a partial binding generated by a producer may be exploited by a consumer to perform "useful computation".
Reference: [29] <author> R. Giacobazzi and L. Ricci. </author> <title> Detecting Determinate Computations by a Bottom-up Abstract Interpretation. </title> <editor> In B. Krieg-Bruckner, editor, ESOP'92, </editor> <booktitle> Proceedings, Lecture Notes in Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1992. </year>
Reference-contexts: There are further applications of the ground dependence analysis by means of the same abstract data representation. In <ref> [28, 29] </ref> the previous dataflow analysis is enhanced by means of labeled hypergraphs. Deterministic dependences [29] can then be exploited simply by adding a suitable set of labels to each hyperarc, without changing the abstraction framework. <p> There are further applications of the ground dependence analysis by means of the same abstract data representation. In [28, 29] the previous dataflow analysis is enhanced by means of labeled hypergraphs. Deterministic dependences <ref> [29] </ref> can then be exploited simply by adding a suitable set of labels to each hyperarc, without changing the abstraction framework. Moreover, the notion of dependence can also be specialized to capture depth-k ground dependence [28].
Reference: [30] <author> M. Hermenegildo. </author> <title> An Abstract Machine for Restricted AND-Parallel Execution of Logic Programs. </title> <editor> In E. Y. Shapiro, editor, </editor> <booktitle> Proc. Third Int'l Conf. on Logic Programming, volume 225 of Lecture Notes in Computer Science, </booktitle> <pages> pages 25-40. </pages> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1986. </year>
Reference-contexts: The problem of how abstract information is represented is central in abstract interpretation. Program analysis often requires to capture the interaction between abstract terms, like sharing and functional dependences <ref> [28, 30, 31, 32, 50, 61] </ref>. An equivalence relation on abstract atoms A characterizes such properties. Example 3.2 Let us consider the abstract universe of terms defined with respect to the following equivalence relation t 1 t t 2 iff var (t 1 ) = var (t 2 ).
Reference: [31] <author> M. Hermenegildo and R.I. Nasr. </author> <title> Efficient Management of Backtacking in AND-Parallelism. </title> <editor> In E. Y. Shapiro, editor, </editor> <booktitle> Proc. Third Int'l Conf. on Logic Programming, volume 225 of Lecture Notes in Computer Science, </booktitle> <pages> pages 40-55. </pages> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1986. </year>
Reference-contexts: The problem of how abstract information is represented is central in abstract interpretation. Program analysis often requires to capture the interaction between abstract terms, like sharing and functional dependences <ref> [28, 30, 31, 32, 50, 61] </ref>. An equivalence relation on abstract atoms A characterizes such properties. Example 3.2 Let us consider the abstract universe of terms defined with respect to the following equivalence relation t 1 t t 2 iff var (t 1 ) = var (t 2 ).
Reference: [32] <author> M. Hermenegildo and F. Rossi. </author> <title> On the Correctness and Efficiency of Independent And-Parallelism in Logic Programs. </title> <editor> In E. Lusk and R. Overbeck, editors, </editor> <booktitle> Proc. North American Conf. on Logic Programming'89, </booktitle> <pages> pages 369-389. </pages> <publisher> The MIT Press, </publisher> <address> Cambridge, Mass., </address> <year> 1989. </year> <month> 44 </month>
Reference-contexts: The problem of how abstract information is represented is central in abstract interpretation. Program analysis often requires to capture the interaction between abstract terms, like sharing and functional dependences <ref> [28, 30, 31, 32, 50, 61] </ref>. An equivalence relation on abstract atoms A characterizes such properties. Example 3.2 Let us consider the abstract universe of terms defined with respect to the following equivalence relation t 1 t t 2 iff var (t 1 ) = var (t 2 ).
Reference: [33] <author> H. Herrlich and M. Husek. </author> <title> Galois Connections. </title> <editor> In A. Melton, editor, </editor> <booktitle> Mathematical Foundations of Program Semantics, volume 239 of Lecture Notes in Computer Science, </booktitle> <pages> pages 122-134. </pages> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1985. </year>
Reference-contexts: The relation between the standard and the abstract semantics was established in [13] by defining a pair of functions ff and fl (abstraction and concretization), which form a Galois connection between (D ] ] D P ) and (D P ; D P ) <ref> [33, 49, 54] </ref>. This notion allows us to formally handle the correctness condition on the abstract interpretation framework [5]. <p> Given a Galois connection hff; fli on the lattices (D P ; D P ) and (D ] ] D P ), the following statements hold <ref> [33, 49, 54] </ref>. * abstraction and concretization uniquely determine each other, * fl preserves arbitrary meets, that is 8 B ] D P ; glb D P P * ff preserves arbitrary joins (i.e. ff is additive), that is 8 B D P ; lub D ] fff (d) j d <p> This can be reduced to proving ff (fl (I ] )) ff I ] and ff (fl ( ] )) ff ] . In particular, since ff is a surjective map, the previous condition can be reduced to proving <ref> [33, 49, 54] </ref> 15 ff (fl (I ] )) = I ] and ff (fl ( ] )) = ] that is hff; fli and hff ; fl i are Galois insertions. In Figure 3.1, the abstract domains design is shown.
Reference: [34] <author> D. Jacobs and A. Langen. </author> <title> Accurate and Efficient Approximation of Variable Aliasing in Logic Programs. </title> <editor> In E. Lusk and R. Overbeck, editors, </editor> <booktitle> Proc. North American Conf. on Logic Programming'89, </booktitle> <pages> pages 154-165. </pages> <publisher> The MIT Press, </publisher> <address> Cambridge, Mass., </address> <year> 1989. </year>
Reference-contexts: This approach to Prolog analysis, needs a richer abstract interpretation technique, general enough to handle the constraint logic programming paradigm. In its present form, the approach can be instantiated to various analyses. The groundness analysis framework can be extended to deal with variable sharing analysis <ref> [15, 34, 51, 43, 48, 57] </ref>. The idea is to specialize our scheme, by using the same abstract universe of the groundness analysis and a different notion of dependence. Namely, there exists a dependence between some arguments iff the same variable occurs in all of them.
Reference: [35] <author> N.D. Jones and H. Stndergaard. </author> <title> A Semantics-based Framework for the Abstract Interpretation of Prolog. </title> <editor> In S. Abramsky and C. Hankin, editors, </editor> <booktitle> Abstract Interpretation of Declarative Languages, </booktitle> <pages> pages 123-142. </pages> <publisher> Ellis Horwood Ltd, </publisher> <year> 1987. </year>
Reference-contexts: The most popular approach is the top-down one, which propagates the information in the same direction as SLD-resolution does. In this class we can find top-down ad-hoc algorithms, frameworks based on an operational semantics, and frameworks based on a denotational semantics <ref> [8, 9, 19, 43, 48, 46, 58, 35] </ref>. The bottom-up approach propagates the information as in the computation of the least fixpoint of the immediate consequences operator T P [39, 60]. <p> The abstract interpretation framework is composed of two levels. A core level, shared by all the applications, defines an abstract T P expressed in terms of a suitable set of abstract operators. These operators essentially play the role of similar ones in <ref> [9, 48, 35] </ref>. The specialization level defines the abstract operators for each specific application. The standard semantics can be viewed as a specialization of the abstract one. If the definitions of the abstract operators satisfy some properties, then the correctness of the specific analysis is guaranteed. <p> Some new applications of the framework are mentioned at the end of Section 4.1. 4.1 Ground Dependence Analysis Ground analysis has been considered by several authors in a top-down framework <ref> [6, 16, 19, 43, 48, 35] </ref>. Most of the above papers are concerned with groundness analysis for code optimization. Thus the emphasis is on obtaining information about call patterns. Our analysis collects goal independent information about success patterns of the program.
Reference: [36] <author> T. Kanomori and K. Horiuchi. </author> <title> Polymorphic Type Inference in Prolog by Abstract Interpretation. </title> <booktitle> In Logic Programming 87- Tokyo, volume 315 of Lecture Notes in Computer Science, </booktitle> <pages> pages 195-214. </pages> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1988. </year>
Reference-contexts: Its goal is to collect static (compile-time) information about the run-time behavior of a program (data-flow analysis), to be used by compilers (for error detection, code optimization <ref> [9, 11, 20, 36] </ref>) and, in general, by program manipulation systems [27]. An introduction to the subject of abstract interpretation in the field of logic and functional languages can be found in [1]. Abstract interpretation is inherently semantics sensitive. <p> Finally, we developed [3] an application of our framework to polymorphic type inference extending the results in <ref> [36, 53] </ref>. Acknowledgments The authors are indebted to the anonymous referees for many helpful comments and suggestions on an earlier version of this paper.
Reference: [37] <author> R. Kemp and G. Ringwood. </author> <title> An Algebraic Framework for the Abstract Interpretation of Logic Programs. </title> <editor> In S. Debray and M. Hermenegildo, editors, </editor> <booktitle> Proc. North American Conf. on Logic Programming'90, </booktitle> <pages> pages 506-520. </pages> <publisher> The MIT Press, </publisher> <address> Cambridge, Mass., </address> <year> 1990. </year>
Reference-contexts: However, the standard T P operator, whose least fixpoint is the least Herbrand model, being defined on ground atoms only, does not allow to model correctly the concept of logical variable which is essential in describing properties like modes and aliasing <ref> [37, 45] </ref>. In [22, 23, 24] a model-theoretic and a fixpoint semantics is defined which capture (non-ground) computed answer substitutions. The corresponding immediate consequences operator operates on a domain composed of ground and non-ground atoms. This concrete semantics is used as the basis for our abstract interpretation framework. <p> This will be obtained by means of an abstract unification process of a concrete goal (the current program query) with abstract atoms in an approximated model for the program. This approach is not considered in <ref> [37] </ref>, thus failing in capture the abstract program observable properties (i.e. abstract substitutions). However, the abstract model fails to be captured by a semantics definition based only on the notion of abstract substitution. <p> As we can observe, the abstract models we obtain are richer than the ones based on different semantics definitions. The semantics defined in [23] was used in [4] (an earlier version of our framework) and independently used in <ref> [10, 37] </ref>. [10] extends our approach with an elegant mechanism to compute call patterns in a bottom-up way, by using program transformations. In [37] an algebraic framework for the abstract interpretation of logic programs is presented. <p> The semantics defined in [23] was used in [4] (an earlier version of our framework) and independently used in [10, 37]. [10] extends our approach with an elegant mechanism to compute call patterns in a bottom-up way, by using program transformations. In <ref> [37] </ref> an algebraic framework for the abstract interpretation of logic programs is presented. The main contribution of the paper is the use of the bottom-up framework to give a rigorous formalization of the Bruynooghe's practical method [8, 9]. The main difference between [37] and our framework is the use of abstract <p> In <ref> [37] </ref> an algebraic framework for the abstract interpretation of logic programs is presented. The main contribution of the paper is the use of the bottom-up framework to give a rigorous formalization of the Bruynooghe's practical method [8, 9]. The main difference between [37] and our framework is the use of abstract substitutions. The presentation in [37] is given without considering the substitution notion, in terms of domains of tuples of atoms. The 41 notion of refuted answer for a goal replaces the notion of computed answer substitution. <p> The main contribution of the paper is the use of the bottom-up framework to give a rigorous formalization of the Bruynooghe's practical method [8, 9]. The main difference between <ref> [37] </ref> and our framework is the use of abstract substitutions. The presentation in [37] is given without considering the substitution notion, in terms of domains of tuples of atoms. The 41 notion of refuted answer for a goal replaces the notion of computed answer substitution. This technique can always be "implemented" by composition of the ff-mgu and ff-apply operators.
Reference: [38] <author> J.-L. Lassez, M. J. Maher, and K. Marriott. </author> <title> Unification Revisited. </title> <editor> In J. Minker, editor, </editor> <booktitle> Foundations of Deductive Databases and Logic Programming, </booktitle> <pages> pages 587-625. </pages> <publisher> Morgan Kaufmann, </publisher> <address> Los Altos, Ca., </address> <year> 1988. </year>
Reference-contexts: We denote by mgu (E) the set f# 2 U nif (E) j 8# 0 2 U nif (E) : # # 0 g. It is well known that all the most general unifiers of a set E are equivalent <ref> [21, 38] </ref>. Consider a program P and the set Cons P of constructors of the first order language underlying P .
Reference: [39] <author> J.W. Lloyd. </author> <title> Foundations of Logic Programming. </title> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1987. </year> <note> Second edition. </note>
Reference-contexts: The bottom-up approach propagates the information as in the computation of the least fixpoint of the immediate consequences operator T P <ref> [39, 60] </ref>. The idea of bottom-up analysis was first introduced in [45]. [48] uses a bottom-up analysis to reason about top-down computations. The main difference between the top-down and the bottom-up approach is related to goal dependence. <p> The reader is assumed to be acquainted with the basic concepts of logic programming, an introduction to which can be found in <ref> [39] </ref>. 2.1 Preliminaries A set S together with a binary relation which is reflexive, antisymmetric and transitive (a partial-ordering) is called a poset and it is denoted by the pair (S; ). s 2 S is an upper (lower) bound for a subset X S iff x s (s x) for <p> The semantic definition in [22, 23] is closer than the one in <ref> [39, 60] </ref> to the operational behavior of logic programs, which was shown to require a more complex and appropriate notion of model, in general different from the minimal Herbrand model. The model theoretic and fixpoint semantics in [23] capture possibly non-ground computed answer substitutions.
Reference: [40] <author> M.J. Maher. </author> <title> Equivalences of Logic Programs. </title> <editor> In J. Minker, editor, </editor> <booktitle> Foundations of Deductive Databases and Logic Programming, </booktitle> <pages> pages 627-658. </pages> <publisher> Morgan Kaufmann, </publisher> <address> Los Altos, Ca., </address> <year> 1988. </year>
Reference-contexts: We have to consider a different notion of program equivalence <ref> [40] </ref>, rich enough to model the useful information for program analysis, i.e. the observable properties of the operational semantics. The extended Herbrand Universe contains also non-ground terms. <p> The presentation is organized in two sections. The first one introduces the abstract domains and the associated abstract operators, while the second one describes the fixpoint abstract semantics. 3.1 Basic Notions "Each method of giving a semantics to programs induces a, possibly different, equivalence relation on programs" <ref> [40] </ref>. In the standard semantics of logic programs, the observable properties are the computed answer substitutions.
Reference: [41] <author> M.J. Maher and R. Ramakrishnan. </author> <title> Deja Vu in Fixpoints of Logic Programs. </title> <editor> In E. Lusk and R. Overbeck, editors, </editor> <booktitle> Proc. North American Conf. on Logic Programming'89, </booktitle> <pages> pages 963-980. </pages> <publisher> The MIT Press, </publisher> <address> Cambridge, Mass., </address> <year> 1989. </year>
Reference-contexts: As we will see, the unification process on atoms having data dependences can be summarized in a suitable graph notation. Then, the abstract unification can be specialized in a very efficient way, as a simple data dependences calculus, whose principles were introduced by <ref> [15, 41] </ref>. 25 We propose a new abstract domain of atoms which is isomorphic to the abstract base. Dependence information is represented by means of an hypergraph notation. The resulting analysis is more concise and efficient than the standard one, exploiting explicit dependences.
Reference: [42] <author> P. Mancarella and D. Pedreschi. </author> <title> An Algebra of Logic Programs. </title> <editor> In R. A. Kowalski and K. A. Bowen, editors, </editor> <booktitle> Proc. Fifth Int'l Conf. on Logic Programming, </booktitle> <pages> pages 1006-1023. </pages> <publisher> The MIT Press, </publisher> <address> Cambridge, Mass., </address> <year> 1988. </year>
Reference-contexts: By the monotonicity of ff-apply, it follows that T ] ] ] ] Following the approach to program compositionality given in <ref> [42] </ref>, the abstract transforma tion maps can be composed in an algebraic way, such that, for each T ] ] C 2 , the composed abstract transformation map is I ] :(T ] ] We are now able to define an abstract transformation map, associated with the whole program P ,
Reference: [43] <author> H. Mannila and E. Ukkonen. </author> <title> Flow Analysis of Prolog Programs. </title> <booktitle> In Proc. 4th IEEE Symp. on Logic Programming, </booktitle> <pages> pages 205-214, </pages> <year> 1987. </year>
Reference-contexts: The most popular approach is the top-down one, which propagates the information in the same direction as SLD-resolution does. In this class we can find top-down ad-hoc algorithms, frameworks based on an operational semantics, and frameworks based on a denotational semantics <ref> [8, 9, 19, 43, 48, 46, 58, 35] </ref>. The bottom-up approach propagates the information as in the computation of the least fixpoint of the immediate consequences operator T P [39, 60]. <p> Some new applications of the framework are mentioned at the end of Section 4.1. 4.1 Ground Dependence Analysis Ground analysis has been considered by several authors in a top-down framework <ref> [6, 16, 19, 43, 48, 35] </ref>. Most of the above papers are concerned with groundness analysis for code optimization. Thus the emphasis is on obtaining information about call patterns. Our analysis collects goal independent information about success patterns of the program. <p> Let us consider an abstract universe of terms. We want to define it as composed of equivalence classes corresponding to the sets of (definitely) ground and (possibly) non-ground terms. Ground dependence analysis (like sharing analysis <ref> [12, 43, 57] </ref>) requires variable information for each non-ground concrete term. The equivalence relation t is defined as follows 8t 1 ; t 2 2 U P : t 1 t t 2 iff var (t 1 ) = var (t 2 ). <p> This approach to Prolog analysis, needs a richer abstract interpretation technique, general enough to handle the constraint logic programming paradigm. In its present form, the approach can be instantiated to various analyses. The groundness analysis framework can be extended to deal with variable sharing analysis <ref> [15, 34, 51, 43, 48, 57] </ref>. The idea is to specialize our scheme, by using the same abstract universe of the groundness analysis and a different notion of dependence. Namely, there exists a dependence between some arguments iff the same variable occurs in all of them.
Reference: [44] <author> K. Marriott. </author> <title> Finding Explicit Representations for Subsets of the Herbrand Universe. </title> <type> PhD thesis, </type> <institution> University of Melbourne, </institution> <year> 1988. </year> <type> Technical Report 88/22. </type>
Reference-contexts: The resulting abstract interpretation finds depth-k abstractions of success patterns for the atoms in the program. We can classify this kind of analysis as a type inference analysis. We can find some interesting applications for program specialization to most specific logic programs, in <ref> [44] </ref>.
Reference: [45] <author> K. Marriott and H. Stndergaard. </author> <title> Bottom-up Abstract Interpretation of Logic Programs. </title> <editor> In R. A. Kowalski and K. A. Bowen, editors, </editor> <booktitle> Proc. Fifth Int'l Conf. on Logic Programming, </booktitle> <pages> pages 733-748. </pages> <publisher> The MIT Press, </publisher> <address> Cambridge, Mass., </address> <year> 1988. </year>
Reference-contexts: The bottom-up approach propagates the information as in the computation of the least fixpoint of the immediate consequences operator T P [39, 60]. The idea of bottom-up analysis was first introduced in <ref> [45] </ref>. [48] uses a bottom-up analysis to reason about top-down computations. The main difference between the top-down and the bottom-up approach is related to goal dependence. <p> However, the standard T P operator, whose least fixpoint is the least Herbrand model, being defined on ground atoms only, does not allow to model correctly the concept of logical variable which is essential in describing properties like modes and aliasing <ref> [37, 45] </ref>. In [22, 23, 24] a model-theoretic and a fixpoint semantics is defined which capture (non-ground) computed answer substitutions. The corresponding immediate consequences operator operates on a domain composed of ground and non-ground atoms. This concrete semantics is used as the basis for our abstract interpretation framework. <p> Previous attempts of defining bottom-up abstract interpretations failed on non-trivial analyses (like mode analysis) since they were based on an immediate consequence operator leading to a fixpoint semantics which did not model computed answer substitutions <ref> [45, 46] </ref>. <p> This notion allows us to formally handle the correctness condition on the abstract interpretation framework [5]. Formally, an abstract interpretation scheme <ref> [13, 45] </ref> is a tuple h (D P ; D P ) ; E P ; (D P ; D P ) ; E P ; ff ; fli such that 1. (D P ; D P ) and (D P ; D P ) are complete lattices, 7 2. <p> Let us finally remark that the above considerations can naturally be extended to other applications. 4.2 Depth-k Abstractions In this section we define an analysis scheme, based on the Sato & Tamaki's work [56]. A very similar analysis can be found in <ref> [45] </ref>. The resulting abstract interpretation finds depth-k abstractions of success patterns for the atoms in the program. We can classify this kind of analysis as a type inference analysis. We can find some interesting applications for program specialization to most specific logic programs, in [44]. <p> the program is F ] (P ) = fsum (x; 0; x); sum (x; s (0); s (x)); sum (x; s (s (x 0 )); s (s (x)))g. 40 5 Related work As already mentioned in the introduction, the idea of T P -based bottom-up abstract interpretation goes back to <ref> [45] </ref>, which considers general programs using as concrete semantics the one defined in [25]. <p> In the following example we show that the strong soundness and completeness of the underlying concrete semantics [22, 23] allows to obtain better abstract information with respect to the usual Herbrand (ground) model approximation <ref> [45] </ref> and with respect to the bottom-up semantics-based analysis framework given in [46].
Reference: [46] <author> K. Marriott and H. Stndergaard. </author> <title> Semantics-based Dataflow Analysis of Logic Programs. </title> <editor> In G. Rit-ter, editor, </editor> <booktitle> Information Processing 89. </booktitle> <publisher> North-Holland, </publisher> <year> 1989. </year>
Reference-contexts: Different semantics definition styles lead to different approaches to program analysis. In the case of logic programs, there exist mainly two approaches, namely top-down analysis and bottom-up analysis <ref> [46] </ref>. The most popular approach is the top-down one, which propagates the information in the same direction as SLD-resolution does. In this class we can find top-down ad-hoc algorithms, frameworks based on an operational semantics, and frameworks based on a denotational semantics [8, 9, 19, 43, 48, 46, 58, 35]. <p> The most popular approach is the top-down one, which propagates the information in the same direction as SLD-resolution does. In this class we can find top-down ad-hoc algorithms, frameworks based on an operational semantics, and frameworks based on a denotational semantics <ref> [8, 9, 19, 43, 48, 46, 58, 35] </ref>. The bottom-up approach propagates the information as in the computation of the least fixpoint of the immediate consequences operator T P [39, 60]. <p> The main difference between the top-down and the bottom-up approach is related to goal dependence. In particular, the top-down analysis starts with a particular goal and it is able to determine call pattern information <ref> [46] </ref>, that is information about specific procedure calls. On the other side, the bottom-up approach determines an approximation of the success set which is goal independent. As discussed in [46], there are applications for which each of the two approaches is the most adequate. <p> In particular, the top-down analysis starts with a particular goal and it is able to determine call pattern information <ref> [46] </ref>, that is information about specific procedure calls. On the other side, the bottom-up approach determines an approximation of the success set which is goal independent. As discussed in [46], there are applications for which each of the two approaches is the most adequate. In this paper we show that the area of applicability of the bottom-up approach can be extended with respect to the cases devised in [46]. <p> As discussed in <ref> [46] </ref>, there are applications for which each of the two approaches is the most adequate. In this paper we show that the area of applicability of the bottom-up approach can be extended with respect to the cases devised in [46]. The semantics definition underlying the bottom-up approach is related to the computation of the least fixpoint of the immediate consequences operator on Herbrand interpretations. <p> Previous attempts of defining bottom-up abstract interpretations failed on non-trivial analyses (like mode analysis) since they were based on an immediate consequence operator leading to a fixpoint semantics which did not model computed answer substitutions <ref> [45, 46] </ref>. <p> Since this semantics is defined on a ground domain, the resulting abstract analysis is not able to capture computational properties related to the use of logical variables. <ref> [46] </ref> solves the above problem by using a non-ground domain for interpretations. However, the resulting semantics, which is the same as the C-semantics in [23], can only model the non-ground logical consequences of a program but not the computed answer substitutions. <p> In the following example we show that the strong soundness and completeness of the underlying concrete semantics [22, 23] allows to obtain better abstract information with respect to the usual Herbrand (ground) model approximation [45] and with respect to the bottom-up semantics-based analysis framework given in <ref> [46] </ref>. Example 5.1 Let us consider the logic program p (f (x)) : p (x): q (x): For a depth-k analysis (the same holds for general type analysis), the abstract models returned for k = 2 are * fp (x); q (x)g using the semantics in [46], * fq (a); p <p> analysis framework given in <ref> [46] </ref>. Example 5.1 Let us consider the logic program p (f (x)) : p (x): q (x): For a depth-k analysis (the same holds for general type analysis), the abstract models returned for k = 2 are * fp (x); q (x)g using the semantics in [46], * fq (a); p (a); p (f (a)); p (f (f ))g using the standard ground T P , * fq (a); q (x); p (a); p (x); p (f (a)); p (f (f (x)))g in our approach. <p> For a simple mode analysis, U ] P = fg; ngg and g ng, in which we are interested in collecting all the success patterns, we obtain * fp (ng); q (ng)g using the semantics in <ref> [46] </ref> (the analysis approximates the success patterns by their least upper bound) , * fp (g); q (g)g using the standard ground T P (this analysis is not even correct!), * fp (g); p (ng); q (g); q (ng)g in our approach.
Reference: [47] <author> C. Mellish. </author> <title> Some Global Optimizations for a Prolog Compiler. </title> <journal> Journal of Logic Programming, </journal> <volume> 2 </volume> <pages> 43-66, </pages> <year> 1985. </year>
Reference-contexts: In some applications, as an example, the analysis returns at most one success pattern per program clause [10] or per predicate symbol <ref> [19, 47] </ref>. This assumption is reasonable if we assume that in most of the real programs, specific predicate arguments are used with the same mode or type structure. As shown in [18], this technique may lead to a considerable simplification in the analysis complexity.
Reference: [48] <author> C. Mellish. </author> <title> Abstract Interpretation of Prolog Programs. </title> <editor> In S. Abramsky and C. Hankin, editors, </editor> <booktitle> Abstract Interpretation of Declarative Languages, </booktitle> <pages> pages 181-198. </pages> <publisher> Ellis Horwood Ltd, </publisher> <year> 1987. </year>
Reference-contexts: The most popular approach is the top-down one, which propagates the information in the same direction as SLD-resolution does. In this class we can find top-down ad-hoc algorithms, frameworks based on an operational semantics, and frameworks based on a denotational semantics <ref> [8, 9, 19, 43, 48, 46, 58, 35] </ref>. The bottom-up approach propagates the information as in the computation of the least fixpoint of the immediate consequences operator T P [39, 60]. <p> The bottom-up approach propagates the information as in the computation of the least fixpoint of the immediate consequences operator T P [39, 60]. The idea of bottom-up analysis was first introduced in [45]. <ref> [48] </ref> uses a bottom-up analysis to reason about top-down computations. The main difference between the top-down and the bottom-up approach is related to goal dependence. <p> The abstract interpretation framework is composed of two levels. A core level, shared by all the applications, defines an abstract T P expressed in terms of a suitable set of abstract operators. These operators essentially play the role of similar ones in <ref> [9, 48, 35] </ref>. The specialization level defines the abstract operators for each specific application. The standard semantics can be viewed as a specialization of the abstract one. If the definitions of the abstract operators satisfy some properties, then the correctness of the specific analysis is guaranteed. <p> There are many examples in the literature on a suitable partitioning of the universe of terms, like the modes domain in <ref> [48] </ref>. Example 3.1 Consider the logic program p (succ (x)) : p (x): p (0): The observable property for the type analysis is the type structure of terms. <p> Some new applications of the framework are mentioned at the end of Section 4.1. 4.1 Ground Dependence Analysis Ground analysis has been considered by several authors in a top-down framework <ref> [6, 16, 19, 43, 48, 35] </ref>. Most of the above papers are concerned with groundness analysis for code optimization. Thus the emphasis is on obtaining information about call patterns. Our analysis collects goal independent information about success patterns of the program. <p> By using the value ng we want to stress that ng represents the set of all non-ground terms in the universe. This shows that the abstract domain for groundness can be used as term representation in ground dependence analysis, and it does not need to be ordered by set-inclusion <ref> [19, 48] </ref>. A more natural ordering relation is, in fact, that based on the usual instantiation relation as given for ] . <p> This approach to Prolog analysis, needs a richer abstract interpretation technique, general enough to handle the constraint logic programming paradigm. In its present form, the approach can be instantiated to various analyses. The groundness analysis framework can be extended to deal with variable sharing analysis <ref> [15, 34, 51, 43, 48, 57] </ref>. The idea is to specialize our scheme, by using the same abstract universe of the groundness analysis and a different notion of dependence. Namely, there exists a dependence between some arguments iff the same variable occurs in all of them.
Reference: [49] <author> A. Melton, D.A. Schmidt, and G.E. Strecker. </author> <title> Galois Connections and Computer Science Applications. </title> <editor> In D. Pitt et al., editor, </editor> <booktitle> Category Theory and Computer Programming, volume 240 of Lecture Notes in Computer Science, </booktitle> <pages> pages 299-312. </pages> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1986. </year>
Reference-contexts: The relation between the standard and the abstract semantics was established in [13] by defining a pair of functions ff and fl (abstraction and concretization), which form a Galois connection between (D ] ] D P ) and (D P ; D P ) <ref> [33, 49, 54] </ref>. This notion allows us to formally handle the correctness condition on the abstract interpretation framework [5]. <p> A Galois insertion is a connection where fl is one-to-one (injective) or equivalently when the composition ffffifl is the identity on D ] P <ref> [49, 54] </ref>. We note that in any Galois connection, ff is surjective iff fl is one-to-one [49]. Galois connections give us the formal framework to prove correctness of an abstract interpretation. <p> A Galois insertion is a connection where fl is one-to-one (injective) or equivalently when the composition ffffifl is the identity on D ] P [49, 54]. We note that in any Galois connection, ff is surjective iff fl is one-to-one <ref> [49] </ref>. Galois connections give us the formal framework to prove correctness of an abstract interpretation. They define a strong relationship between the concrete domain of computations and the abstract, usually simpler, domain associated with the analysis. <p> Given a Galois connection hff; fli on the lattices (D P ; D P ) and (D ] ] D P ), the following statements hold <ref> [33, 49, 54] </ref>. * abstraction and concretization uniquely determine each other, * fl preserves arbitrary meets, that is 8 B ] D P ; glb D P P * ff preserves arbitrary joins (i.e. ff is additive), that is 8 B D P ; lub D ] fff (d) j d <p> This can be reduced to proving ff (fl (I ] )) ff I ] and ff (fl ( ] )) ff ] . In particular, since ff is a surjective map, the previous condition can be reduced to proving <ref> [33, 49, 54] </ref> 15 ff (fl (I ] )) = I ] and ff (fl ( ] )) = ] that is hff; fli and hff ; fl i are Galois insertions. In Figure 3.1, the abstract domains design is shown.
Reference: [50] <author> A.O. Mendelzon. </author> <title> Functional Dependencies in Logic Programs. </title> <booktitle> In Proc. of the Eleventh International Conference on Very Large Data Bases, </booktitle> <pages> pages 324-330, </pages> <year> 1985. </year> <month> 45 </month>
Reference-contexts: The problem of how abstract information is represented is central in abstract interpretation. Program analysis often requires to capture the interaction between abstract terms, like sharing and functional dependences <ref> [28, 30, 31, 32, 50, 61] </ref>. An equivalence relation on abstract atoms A characterizes such properties. Example 3.2 Let us consider the abstract universe of terms defined with respect to the following equivalence relation t 1 t t 2 iff var (t 1 ) = var (t 2 ).
Reference: [51] <author> K. Muthukumar and M. Hermenegildo. </author> <title> Determination of Variable Dependence Information through Abstract Interpretation. </title> <editor> In E. Lusk and R. Overbeck, editors, </editor> <booktitle> Proc. North American Conf. on Logic Programming'89, </booktitle> <pages> pages 166-185. </pages> <publisher> The MIT Press, </publisher> <address> Cambridge, Mass., </address> <year> 1989. </year>
Reference-contexts: This approach to Prolog analysis, needs a richer abstract interpretation technique, general enough to handle the constraint logic programming paradigm. In its present form, the approach can be instantiated to various analyses. The groundness analysis framework can be extended to deal with variable sharing analysis <ref> [15, 34, 51, 43, 48, 57] </ref>. The idea is to specialize our scheme, by using the same abstract universe of the groundness analysis and a different notion of dependence. Namely, there exists a dependence between some arguments iff the same variable occurs in all of them.
Reference: [52] <author> A. Mycroft. </author> <title> Abstract Interpretation and Optimising Transformations for Applicative Programs. </title> <type> PhD thesis, </type> <institution> University of Edinburgh, </institution> <year> 1981. </year> <month> CST-15/81. </month>
Reference-contexts: Obviously, this kind of analysis is less precise than the one given by the complete semantics definition. According to the notation of Mycroft <ref> [52] </ref>, in the following we denote by O ] the abstract analog of any concrete syntactic object O.
Reference: [53] <author> A. Mycroft and R.A. O'Keefe. </author> <title> A Polymorphic Type System for Prolog. </title> <journal> Artificial Intelligence, </journal> <volume> 23 </volume> <pages> 295-307, </pages> <year> 1984. </year>
Reference-contexts: Finally, we developed [3] an application of our framework to polymorphic type inference extending the results in <ref> [36, 53] </ref>. Acknowledgments The authors are indebted to the anonymous referees for many helpful comments and suggestions on an earlier version of this paper.
Reference: [54] <author> O. </author> <title> Ore. Galois Connections. </title> <journal> In Trans. AMS, </journal> <volume> volume 55, </volume> <pages> pages 493-513, </pages> <year> 1944. </year>
Reference-contexts: The relation between the standard and the abstract semantics was established in [13] by defining a pair of functions ff and fl (abstraction and concretization), which form a Galois connection between (D ] ] D P ) and (D P ; D P ) <ref> [33, 49, 54] </ref>. This notion allows us to formally handle the correctness condition on the abstract interpretation framework [5]. <p> A Galois insertion is a connection where fl is one-to-one (injective) or equivalently when the composition ffffifl is the identity on D ] P <ref> [49, 54] </ref>. We note that in any Galois connection, ff is surjective iff fl is one-to-one [49]. Galois connections give us the formal framework to prove correctness of an abstract interpretation. <p> Given a Galois connection hff; fli on the lattices (D P ; D P ) and (D ] ] D P ), the following statements hold <ref> [33, 49, 54] </ref>. * abstraction and concretization uniquely determine each other, * fl preserves arbitrary meets, that is 8 B ] D P ; glb D P P * ff preserves arbitrary joins (i.e. ff is additive), that is 8 B D P ; lub D ] fff (d) j d <p> This can be reduced to proving ff (fl (I ] )) ff I ] and ff (fl ( ] )) ff ] . In particular, since ff is a surjective map, the previous condition can be reduced to proving <ref> [33, 49, 54] </ref> 15 ff (fl (I ] )) = I ] and ff (fl ( ] )) = ] that is hff; fli and hff ; fl i are Galois insertions. In Figure 3.1, the abstract domains design is shown.
Reference: [55] <author> L. Ricci. </author> <title> Compilation of Logic Programs for Massively Parallel Systems. </title> <type> PhD thesis, </type> <institution> Universita di Pisa, </institution> <month> Feb. </month> <year> 1990. </year> <pages> T.D. 3-90. </pages>
Reference-contexts: Moreover, the notion of dependence can also be specialized to capture depth-k ground dependence [28]. This technique is usefully applied to deduce information (i.e. pipeline AND-parallelism) to optimize the performance of AND/OR-parallel executions of logic programs in a massively parallel system <ref> [55] </ref>. 4.1.1 Bottom-up Analysis and Call Patterns As pointed out before, our groundness analysis determines an approximation of the program success set. In many cases one is interested in determining information about a specific procedure call (call pattern).
Reference: [56] <author> T. Sato and H. Tamaki. </author> <title> Enumeration of Success Patterns in Logic Programs. </title> <journal> Theoretical Computer Science, </journal> <volume> 34 </volume> <pages> 227-240, </pages> <year> 1984. </year>
Reference-contexts: Let us finally remark that the above considerations can naturally be extended to other applications. 4.2 Depth-k Abstractions In this section we define an analysis scheme, based on the Sato & Tamaki's work <ref> [56] </ref>. A very similar analysis can be found in [45]. The resulting abstract interpretation finds depth-k abstractions of success patterns for the atoms in the program. We can classify this kind of analysis as a type inference analysis.
Reference: [57] <author> H. Stndergaard. </author> <title> An Application of Abstract Interpretation of Logic Programs: Occur Check Reduction. </title> <editor> In B. Robinet and R. Wilhelm, editors, </editor> <booktitle> Proc. ESOP 86, volume 213 of Lecture Notes in Computer Science, </booktitle> <pages> pages 327-338. </pages> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1986. </year>
Reference-contexts: Let us consider an abstract universe of terms. We want to define it as composed of equivalence classes corresponding to the sets of (definitely) ground and (possibly) non-ground terms. Ground dependence analysis (like sharing analysis <ref> [12, 43, 57] </ref>) requires variable information for each non-ground concrete term. The equivalence relation t is defined as follows 8t 1 ; t 2 2 U P : t 1 t t 2 iff var (t 1 ) = var (t 2 ). <p> This approach to Prolog analysis, needs a richer abstract interpretation technique, general enough to handle the constraint logic programming paradigm. In its present form, the approach can be instantiated to various analyses. The groundness analysis framework can be extended to deal with variable sharing analysis <ref> [15, 34, 51, 43, 48, 57] </ref>. The idea is to specialize our scheme, by using the same abstract universe of the groundness analysis and a different notion of dependence. Namely, there exists a dependence between some arguments iff the same variable occurs in all of them.
Reference: [58] <author> H. Stndergaard. </author> <title> Semantics-Based Analysis and Transformation of Logic Programs. </title> <type> PhD thesis, </type> <institution> The University of Melbourne, </institution> <month> June </month> <year> 1990. </year> <note> Revised version of PhD thesis, </note> <institution> University of Copenhagen, </institution> <month> December </month> <year> 1989. </year>
Reference-contexts: The most popular approach is the top-down one, which propagates the information in the same direction as SLD-resolution does. In this class we can find top-down ad-hoc algorithms, frameworks based on an operational semantics, and frameworks based on a denotational semantics <ref> [8, 9, 19, 43, 48, 46, 58, 35] </ref>. The bottom-up approach propagates the information as in the computation of the least fixpoint of the immediate consequences operator T P [39, 60].
Reference: [59] <author> J.E. Stoy. </author> <title> Denotational Semantics: The Scott-Strachey Approach to Programming Language Theory. </title> <publisher> MIT Press, </publisher> <year> 1977. </year>
Reference-contexts: A function f : D ! D 0 such that 8X D (possibly non-directed), f (lub D (X)) = lub D 0 ff (x) j x 2 Xg is said to be additive <ref> [59] </ref>. Obviously, additive functions are continuous. Let F : S ! S be a function defined on a complete lattice S.
Reference: [60] <author> M. H. van Emden and R. A. Kowalski. </author> <title> The semantics of predicate logic as a programming language. </title> <journal> Journal of the ACM, </journal> <volume> 23(4) </volume> <pages> 733-742, </pages> <year> 1976. </year>
Reference-contexts: The bottom-up approach propagates the information as in the computation of the least fixpoint of the immediate consequences operator T P <ref> [39, 60] </ref>. The idea of bottom-up analysis was first introduced in [45]. [48] uses a bottom-up analysis to reason about top-down computations. The main difference between the top-down and the bottom-up approach is related to goal dependence. <p> The semantic definition in [22, 23] is closer than the one in <ref> [39, 60] </ref> to the operational behavior of logic programs, which was shown to require a more complex and appropriate notion of model, in general different from the minimal Herbrand model. The model theoretic and fixpoint semantics in [23] capture possibly non-ground computed answer substitutions. <p> A 0 2 B P j 9 (B 0 n ) 2 I with no variables in common with C and with each other; 9# = mgu ((B 1 ; :::; B n ); (B 0 n )) This definition is different with respect to the standard T P operator <ref> [60] </ref>. It derives possibly non-ground atoms by means of a bottom-up inference rule which is based on unification, as in the top-down SLD resolution. As usual, T P is a continuous function on the complete lattice of -interpretations ordered by set-inclusion [23].
Reference: [61] <author> J. Zobel and P. </author> <title> Dart. On Logic Programs, Functional Dependencies, and Types. </title> <type> Technical report, </type> <institution> University of Melbourne, </institution> <year> 1990. </year> <month> 46 </month>
Reference-contexts: The problem of how abstract information is represented is central in abstract interpretation. Program analysis often requires to capture the interaction between abstract terms, like sharing and functional dependences <ref> [28, 30, 31, 32, 50, 61] </ref>. An equivalence relation on abstract atoms A characterizes such properties. Example 3.2 Let us consider the abstract universe of terms defined with respect to the following equivalence relation t 1 t t 2 iff var (t 1 ) = var (t 2 ).
References-found: 61

