URL: http://www.iro.umontreal.ca/~feeley/papers/cc96.ps.gz
Refering-URL: http://www.iro.umontreal.ca/~feeley/
Root-URL: http://www.iro.umontreal.ca
Email: E-mail: fboucherd,feeleyg@iro.umontreal.ca  
Title: Abstract Compilation: a New Implementation Paradigm for Static Analysis  
Author: Dominique Boucher and Marc Feeley 
Keyword: Abstract interpretation, static analysis, partial evaluation, compilation, control flow analysis.  
Address: C.P. 6128, succ. centre-ville, Montreal, Quebec, Canada H3C 3J7  
Affiliation: Departement d'informatique et de recherche operationnelle (IRO) Universite de Montreal  
Abstract: For large programs, static analysis can be one of the most time-consuming phases of the whole compilation process. We propose a new paradigm for the implementation of static analyses that is inspired by partial evaluation techniques. Our paradigm does not reduce the complexity of these analyses, but it allows an efficient implementation. We illustrate this paradigm by its application to the problem of control flow analysis of functional programs. We show that the analysis can be sped up by a factor of 2 over the usual abstract interpretation method. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> A. V. Aho, R. Sethi and J. D. Ullman. </author> <booktitle> Compilers. Principles, Techniques, and Tools. </booktitle> <publisher> Addison-Wesley, </publisher> <year> 1986. </year>
Reference-contexts: Most of these analyses are very time-consuming. It is therefore essential to perform them as efficiently as possible. Speed of analysis is the issue addressed in this paper. For the class of first-order imperative languages, several techniques for static analysis have been designed and are now well established <ref> [1, 6] </ref>. Static analysis of higher-order functional languages is more difficult because the control flow graph (call graph) is not known at compile-time. <p> Although we present here a more efficient implementation of 0cfa, our paradigm is not restricted to analyses designed in the abstract interpretation framework. In fact, it can be applied to more conventional data-flow analyses <ref> [1, 6] </ref>. In [13], Serrano describes the control flow analyses performed in the Bigloo Scheme to C compiler [14]. His results show that these analyses allow significant optimizations to be performed.
Reference: [2] <author> Andrew E. Ayers. </author> <title> Abstract Analysis and Optimization of Scheme. </title> <type> PhD thesis, </type> <institution> MIT, </institution> <month> September </month> <year> 1993. </year>
Reference-contexts: Static analysis of higher-order functional languages is more difficult because the control flow graph (call graph) is not known at compile-time. Nevertheless, several kinds of analyses have been designed <ref> [2, 7, 15] </ref> and some have been successfully integrated in real compilers [13, 15]. 1.1 A New Paradigm A popular approach for implementing static analyses is non-standard interpretation. Even traditional data-flow analysis can be viewed as an interpretation layer, the flow graph being the abstract program to be "executed". <p> It is thus more difficult to predict at compile-time the behavior of programs making heavy use of higher-order functions. One way to do so is the control flow analysis (cfa), of which there exists several variants <ref> [2, 8, 12] </ref>. The 0cfa [15] computes, for each call site (ff ...) of a program, the set of functions that could be bound to ff at runtime. To appreciate the usefulness of 0cfa, consider the Scheme program of Fig. 1. <p> A growing interest has been shown for this framework since the pioneering work of the Cousots [4]. It has been applied to a number of interesting analyses in the area of functional programming, including strictness analysis [11], reference counting [7], and control flow analysis [15]. In <ref> [2] </ref>, Ayers presents several techniques for the efficient implementation of the 0cfa. His "initial call sites" correspond to the calls where our technique can perform the lookup optimization.
Reference: [3] <author> Dominique Boucher and Marc Feeley. </author> <title> Un systeme pour l'optimisation globale de programmes d'ordre superieur par compilation abstraite separee. </title> <type> Technical report 992, </type> <institution> Universite de Montreal, </institution> <month> september </month> <year> 1995. </year>
Reference-contexts: This led us to the idea that the analysis program can be stored in a file and later reloaded together with other analysis programs in order to perform global control flow analysis of separately compiled multimodule programs. We are currently working on this idea <ref> [3] </ref>. 8 Conclusion We have presented a new way of implementing static analyses. It is based on the concept of abstract compilation. This paradigm is attractive for several reasons.
Reference: [4] <author> Patrick Cousot and Radhia Cousot. </author> <title> Abstract interpretation: a unified lattice model for static analysis of programs by construction or approximation of fixed points. </title> <booktitle> In Proceedings of the 4th ACM Symposium on Principles of Programming Languages, </booktitle> <address> Los Angeles, </address> <year> 1977, </year> <pages> pp. 238-252. </pages>
Reference-contexts: Our work originated from the study of abstract interpretation, a framework well-adapted for the design of static analyses. A growing interest has been shown for this framework since the pioneering work of the Cousots <ref> [4] </ref>. It has been applied to a number of interesting analyses in the area of functional programming, including strictness analysis [11], reference counting [7], and control flow analysis [15]. In [2], Ayers presents several techniques for the efficient implementation of the 0cfa.
Reference: [5] <author> Marc Feeley and Guy Lapalme. </author> <title> Using closures for code generation. </title> <journal> Comput. Lang. </journal> <volume> 12, </volume> <pages> 47-66, </pages> <year> 1987. </year>
Reference-contexts: The idea is to represent a compiled expression with a closure. When this closure is applied, it performs the analysis of the given expression. We will thus replace the "code generation" by a "closure generation" (as in the work of Feeley and Lapalme <ref> [5] </ref>). <p> Thus, optimizations of the analysis program, as those we described here, cannot be performed. The use of closures for code generation has previously been proposed for compilation <ref> [5] </ref>. The latter describes an approach to compiling where each compiled expression is embodied by a closure whose application performs the evaluation of the given expression. This idea of replacing "code generation" by "closure generation" is essentially the same as we used in our compilation algorithm.
Reference: [6] <author> Matthew S. Hecht. </author> <title> Flow Analysis of Computer Programs. </title> <publisher> North-Holland, </publisher> <address> New York, </address> <year> 1979. </year>
Reference-contexts: Most of these analyses are very time-consuming. It is therefore essential to perform them as efficiently as possible. Speed of analysis is the issue addressed in this paper. For the class of first-order imperative languages, several techniques for static analysis have been designed and are now well established <ref> [1, 6] </ref>. Static analysis of higher-order functional languages is more difficult because the control flow graph (call graph) is not known at compile-time. <p> Although we present here a more efficient implementation of 0cfa, our paradigm is not restricted to analyses designed in the abstract interpretation framework. In fact, it can be applied to more conventional data-flow analyses <ref> [1, 6] </ref>. In [13], Serrano describes the control flow analyses performed in the Bigloo Scheme to C compiler [14]. His results show that these analyses allow significant optimizations to be performed.
Reference: [7] <author> Paul Hudak. </author> <title> A Semantic Model of Reference Counting and its Abstraction (De--tailed Summary). </title> <booktitle> In Proceedings of the 1986 ACM Conference on Lisp and Functional Programming, </booktitle> <pages> 351-363, </pages> <year> 1986. </year>
Reference-contexts: Static analysis of higher-order functional languages is more difficult because the control flow graph (call graph) is not known at compile-time. Nevertheless, several kinds of analyses have been designed <ref> [2, 7, 15] </ref> and some have been successfully integrated in real compilers [13, 15]. 1.1 A New Paradigm A popular approach for implementing static analyses is non-standard interpretation. Even traditional data-flow analysis can be viewed as an interpretation layer, the flow graph being the abstract program to be "executed". <p> A growing interest has been shown for this framework since the pioneering work of the Cousots [4]. It has been applied to a number of interesting analyses in the area of functional programming, including strictness analysis [11], reference counting <ref> [7] </ref>, and control flow analysis [15]. In [2], Ayers presents several techniques for the efficient implementation of the 0cfa. His "initial call sites" correspond to the calls where our technique can perform the lookup optimization.
Reference: [8] <author> David A. Kranz. </author> <title> ORBIT: An Optimizing Compiler for Scheme. </title> <type> Ph.D. thesis, </type> <institution> Yale University, </institution> <year> 1988. </year>
Reference-contexts: It is thus more difficult to predict at compile-time the behavior of programs making heavy use of higher-order functions. One way to do so is the control flow analysis (cfa), of which there exists several variants <ref> [2, 8, 12] </ref>. The 0cfa [15] computes, for each call site (ff ...) of a program, the set of functions that could be bound to ff at runtime. To appreciate the usefulness of 0cfa, consider the Scheme program of Fig. 1.
Reference: [9] <author> Mark Leone and Peter Lee. </author> <title> Lightweight Run-Time Code Generation. </title> <booktitle> In Proceedings of the 1994 ACM SIGPLAN Workshop on Partial Evaluation and Semantics-Based Program Manipulation, </booktitle> <pages> pp. 97-106. </pages>
Reference-contexts: This idea of replacing "code generation" by "closure generation" is essentially the same as we used in our compilation algorithm. Closure generation is a form of runtime code generation. Leone and Lee <ref> [9] </ref> describe a technique for runtime code generation called deferred compilation. Their results also show that significant speedups can be obtained.
Reference: [10] <author> I-P. Lin and J. Tan. </author> <title> Compiling Dataflow Analysis of Logic Programs. </title> <booktitle> In Proceedings of the 1992 ACM Conference on Programming Language Desing and Implementation, </booktitle> <pages> pp. 106-115. </pages>
Reference-contexts: We argue that if the Bigloo compiler was to produce native code instead of C code, the time lost would not be compensated, thus revealing the real cost of control flow analysis (which has an O (n 3 ) worst-case complexity). Lin and Tan <ref> [10] </ref> show how to compile the dataflow analysis of logic programs.
Reference: [11] <author> Alan Mycroft. </author> <title> Abstract Interpretation and Optimizing Transformations for Applicative Programs. </title> <type> Ph.D. thesis, </type> <institution> University of Edinburgh, </institution> <year> 1981. </year>
Reference-contexts: A growing interest has been shown for this framework since the pioneering work of the Cousots [4]. It has been applied to a number of interesting analyses in the area of functional programming, including strictness analysis <ref> [11] </ref>, reference counting [7], and control flow analysis [15]. In [2], Ayers presents several techniques for the efficient implementation of the 0cfa. His "initial call sites" correspond to the calls where our technique can perform the lookup optimization.
Reference: [12] <author> Guillermo Juan Rozas. </author> <title> Taming the Y operator. </title> <booktitle> In Proceedings of the 1992 ACM Conference on Lisp and Functional Programming, </booktitle> <pages> 226-234, </pages> <year> 1992. </year>
Reference-contexts: It is thus more difficult to predict at compile-time the behavior of programs making heavy use of higher-order functions. One way to do so is the control flow analysis (cfa), of which there exists several variants <ref> [2, 8, 12] </ref>. The 0cfa [15] computes, for each call site (ff ...) of a program, the set of functions that could be bound to ff at runtime. To appreciate the usefulness of 0cfa, consider the Scheme program of Fig. 1.
Reference: [13] <author> Manuel Serrano. </author> <title> Control Flow Analysis: a compilation paradigm for functional languages. </title> <booktitle> In Proceedings of SAC 95. </booktitle>
Reference-contexts: Static analysis of higher-order functional languages is more difficult because the control flow graph (call graph) is not known at compile-time. Nevertheless, several kinds of analyses have been designed [2, 7, 15] and some have been successfully integrated in real compilers <ref> [13, 15] </ref>. 1.1 A New Paradigm A popular approach for implementing static analyses is non-standard interpretation. Even traditional data-flow analysis can be viewed as an interpretation layer, the flow graph being the abstract program to be "executed". <p> Even traditional data-flow analysis can be viewed as an interpretation layer, the flow graph being the abstract program to be "executed". The more recent analyses, devised in the abstract interpretation framework, are implemented as true interpreters (for example, see <ref> [13] </ref>). But interpretation is costly because it adds a layer of abstraction to the analysis process. We propose to go one step further and perform what we call abstract compilation. <p> Also, since every program is finite, oe (v) must be finite for all v. Thus our algorithm will find oe in a finite number of steps. This is the usual way the 0cfa is implemented. For example, <ref> [13] </ref> describes the analysis performed in the Bigloo compiler [14]. It is essentially the same as the one we have presented. It is also very close to the one presented by Shivers 1 For the sake of simplicity, we do not include any error-detection mechanism to the 0cfa. <p> Although we present here a more efficient implementation of 0cfa, our paradigm is not restricted to analyses designed in the abstract interpretation framework. In fact, it can be applied to more conventional data-flow analyses [1, 6]. In <ref> [13] </ref>, Serrano describes the control flow analyses performed in the Bigloo Scheme to C compiler [14]. His results show that these analyses allow significant optimizations to be performed.
Reference: [14] <author> Manuel Serrano. </author> <note> Bigloo User's Manual. Inria-Rocquencourt. </note> <month> March </month> <year> 1994. </year>
Reference-contexts: Also, since every program is finite, oe (v) must be finite for all v. Thus our algorithm will find oe in a finite number of steps. This is the usual way the 0cfa is implemented. For example, [13] describes the analysis performed in the Bigloo compiler <ref> [14] </ref>. It is essentially the same as the one we have presented. It is also very close to the one presented by Shivers 1 For the sake of simplicity, we do not include any error-detection mechanism to the 0cfa. <p> In fact, it can be applied to more conventional data-flow analyses [1, 6]. In [13], Serrano describes the control flow analyses performed in the Bigloo Scheme to C compiler <ref> [14] </ref>. His results show that these analyses allow significant optimizations to be performed. But they also show that it can take 4 to 9 times longer to compile a program when all the optimizations are enabled.
Reference: [15] <author> Olin Shivers. </author> <title> Control-Flow Analysis of Higher-Order Languages. </title> <type> Ph.D. thesis, </type> <institution> Carnegie Mellon University, Pittsburgh, </institution> <year> 1991. </year> <title> This article was processed using the L A T E X macro package with LLNCS style </title>
Reference-contexts: Static analysis of higher-order functional languages is more difficult because the control flow graph (call graph) is not known at compile-time. Nevertheless, several kinds of analyses have been designed <ref> [2, 7, 15] </ref> and some have been successfully integrated in real compilers [13, 15]. 1.1 A New Paradigm A popular approach for implementing static analyses is non-standard interpretation. Even traditional data-flow analysis can be viewed as an interpretation layer, the flow graph being the abstract program to be "executed". <p> Static analysis of higher-order functional languages is more difficult because the control flow graph (call graph) is not known at compile-time. Nevertheless, several kinds of analyses have been designed [2, 7, 15] and some have been successfully integrated in real compilers <ref> [13, 15] </ref>. 1.1 A New Paradigm A popular approach for implementing static analyses is non-standard interpretation. Even traditional data-flow analysis can be viewed as an interpretation layer, the flow graph being the abstract program to be "executed". <p> It is thus more difficult to predict at compile-time the behavior of programs making heavy use of higher-order functions. One way to do so is the control flow analysis (cfa), of which there exists several variants [2, 8, 12]. The 0cfa <ref> [15] </ref> computes, for each call site (ff ...) of a program, the set of functions that could be bound to ff at runtime. To appreciate the usefulness of 0cfa, consider the Scheme program of Fig. 1. <p> ([[if]]; ha 1 ; : : : ; a 3 i; oe) = 0cfa-args (ha 1 ; : : : ; a 3 i; oe) lookup (e; oe) = cond isConst (e) : ; isVar (e) : oe (e) isLam (e) : feg Fig. 4. 0cfa abstract interpretation algorithm in <ref> [15] </ref>. <p> A growing interest has been shown for this framework since the pioneering work of the Cousots [4]. It has been applied to a number of interesting analyses in the area of functional programming, including strictness analysis [11], reference counting [7], and control flow analysis <ref> [15] </ref>. In [2], Ayers presents several techniques for the efficient implementation of the 0cfa. His "initial call sites" correspond to the calls where our technique can perform the lookup optimization.
References-found: 15

