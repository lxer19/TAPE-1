URL: http://www.cse.ogi.edu/~byron/memo/dispose.ps
Refering-URL: http://www.cse.ogi.edu/PacSoft/DARPA-requirements/edcs.html
Root-URL: http://www.cse.ogi.edu
Email: byron@cse.ogi.edu  jl@cse.ogi.edu  
Title: Disposable Memo Functions  
Author: Byron Cook John Launchbury 
Affiliation: Department of Computer Science and Engineering Oregon Graduate Institute  
Abstract: We formalize the meaning of lazy memo-functions in Haskell with an extension to the lazy -calculus, Haskell's computational model. The semantics enable reasoning about memoization's effect on space and time complexity. Based on the semantics, we present a prototype implementation that requires no changes to the garbage-collector; memo-tables are simply reclaimed when no references to them remain. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Ariola, Z. M., and Felleisen, M. </author> <title> The call-by-need lambda calculus. </title> <journal> Journal of Functional Programming 1, </journal> <volume> 1 (1993), </volume> <pages> 1-000. </pages>
Reference: [2] <author> Berry, D. </author> <title> The Edinburgh SML library. </title> <type> Tech. Rep. </type> <institution> ECS-LFCS-91-148, Department of Computer Science, The University of Edinburgh, </institution> <year> 1991. </year>
Reference-contexts: could be verified that m is disposable once translated into the appropriate form: map f l = memoFix m l where m g [] = [] m g (x:xs) = f x: g xs 6.2 Memoization in LISP and SML Our research mirrors similar work in LISP [5] and SML <ref> [2] </ref>. All of the implementations use higher-order functions named memo that return memo-functions. How is our research different? The challenge that we have faced is referential transparency.
Reference: [3] <author> Elliott, C., and Hudak, P. </author> <title> Functional reactive animation. </title> <booktitle> To appear in The International Conference on Functional Programming (Amsterdam, The Nether-lands, </booktitle> <month> June </month> <year> 1997). </year> <month> 7 </month>
Reference-contexts: In Huggies, term' will persist throughout the lifetime of the program. The more term' is used, the more heap it will consume. 2.2 Animation Combinators Reactive Behavior Modeling in Haskell <ref> [3] </ref> (RBMH) is a language in development at Microsoft for describing multimedia interactive animation. RBMH is a suite of combi-nators and simple behaviors from which programmers can build complex behaviors.
Reference: [4] <author> Gunter, C. A. </author> <title> Semantics of Programming Languages: Structures and Techniques. </title> <booktitle> Foundations of Computing Science. </booktitle> <publisher> The MIT Press, </publisher> <year> 1992. </year>
Reference: [5] <author> Hall, M., and Mayfield, J. </author> <title> Improving the performance of AI software: Payoffs and pitfalls in using automatic memoization. </title> <booktitle> In International Symposium on Artificial Intelligence (Monterrey, </booktitle> <address> Mexico, </address> <month> Sept. </month> <year> 1993). </year>
Reference-contexts: with lists), it could be verified that m is disposable once translated into the appropriate form: map f l = memoFix m l where m g [] = [] m g (x:xs) = f x: g xs 6.2 Memoization in LISP and SML Our research mirrors similar work in LISP <ref> [5] </ref> and SML [2]. All of the implementations use higher-order functions named memo that return memo-functions. How is our research different? The challenge that we have faced is referential transparency.
Reference: [6] <author> Hudak, P., Peterson, J., and Fasel, J. </author> <title> A gentle introduction to Haskell. </title> <note> Available at www.haskell.org, Dec. </note> <year> 1997. </year>
Reference: [7] <author> Hughes, R. J. M. </author> <title> Lazy memo-functions. </title> <booktitle> In The Conference on Functional Programming and Computer Architecture (Nancy, </booktitle> <address> France, Sept. 1985), </address> <publisher> Springer-Verlag. </publisher>
Reference-contexts: What's more, we give a formal semantics for memoization that is compatible with Haskell's underlying computational model, and where the garbage-collection rule can reclaim obsolete memo-functions and the space their tables consumed. The key idea in this paper is to adapt Hughes' research on lazy memoization <ref> [7] </ref> and provide a polymorphic function: memo :: Eval a =&gt; (a -&gt; b) -&gt; (a -&gt; b) When applied to a function memo returns an equivalent mem-oized function. <p> The expressions on the right use non-disposable memo-functions. Notice that heap consumption returns to zero in the profiles on the left | indicating that the garbage-collector successfully reclaimed the space. 6 Related Work 6.1 Lazy Memo-functions Rather than defining memoization, Hughes <ref> [7] </ref> focused on the applications of lazy memo-functions and the implementation issues of obsolescence-based purging optimizations Hughes proposed that memo-functions be defined with a language construct rather than a higher-order function.
Reference: [8] <author> Hutton, G., and Meijer, E. </author> <title> Monadic parser combi-nators. </title> <type> Tech. Rep. </type> <institution> NOTTCS-TR-96-4, Department of Computer Science, University of Nottingham, </institution> <year> 1996. </year>
Reference-contexts: As a simple example, consider the grammar for arithmetic expressions: term ::= f actor +f actor j f actor factor j f actor f actor ::= expr * expr j expr / expr j expr expr ::= number j (term) Using Hutton and Meijer's parser combinators <ref> [8] </ref> the corresponding naive parser is: naiveTerm = binary factor '*' factor +++ binary factor '/' factor +++ factor where factor = binary expr '+' expr +++ binary expr '-' expr +++ term expr = num +++ bracketed naiveTerm Unfortunately, naiveTerm is slow.
Reference: [9] <author> John Peterson, e. </author> <title> Report on the programming language haskell: A non-strict, purely functional language, </title> <note> version 1.4. Available at www.haskell.org, Apr. </note> <year> 1997. </year>
Reference: [10] <author> Jones, M. P. </author> <title> The implementation of the Gofer functional programming system. </title> <type> Tech. Rep. </type> <institution> YALEU/DCS/RR-1030, Deptartment of Computer Science, Yale University, </institution> <month> May </month> <year> 1994. </year>
Reference: [11] <author> Jones, S. P., and Meijer, E. Henk: </author> <title> A typed intermediate language. </title> <booktitle> To appear in The Workshop on Types in Compilation (Amsterdam, </booktitle> <address> The Netherlands, </address> <month> June </month> <year> 1997). </year>
Reference: [12] <author> Keller, R. M., and Sleep, M. R. </author> <title> Applicative caching: Programmer control of object sharing and lifetime in distributed implementations of applicative languages. </title> <booktitle> In The Conference on Functional Programming and Computer Architecture (Wentworth-by-the-sea, </booktitle> <address> Portsmouth, New Hampshire, </address> <month> Oct. </month> <year> 1981). </year>
Reference: [13] <author> Launchbury, J., and Jones, S. P. </author> <title> Lazy functional state threads. </title> <booktitle> In Programming Languages Design and Implementation (Orlando, </booktitle> <address> Florida, 1994), </address> <publisher> ACM Press. </publisher>
Reference: [14] <author> Michie, D. </author> <title> Memo functions and machine learning. </title> <booktitle> Nature, </booktitle> <month> 218 (Apr. </month> <year> 1968), </year> <pages> 19-22. </pages> <note> [15] van Dalen, </note> <author> L. </author> <title> Incremental evaluation through memoization. </title> <type> Master's thesis, </type> <institution> Department of Computer Science, Utrecht University, </institution> <address> The Netherlands, </address> <year> 1992. </year> <month> 8 </month>
References-found: 14

