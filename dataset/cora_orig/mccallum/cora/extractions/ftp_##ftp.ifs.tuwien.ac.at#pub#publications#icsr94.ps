URL: ftp://ftp.ifs.tuwien.ac.at/pub/publications/icsr94.ps
Refering-URL: http://www.cs.umd.edu/class/fall97/cmsc735-f97/Reflist.html
Root-URL: 
Email: email: -dieter, tjoa-@ifs.univie.ac.at, gerti@ifs.uni-linz.ac.at  
Title: IEEE Learning the Semantic Similarity of Reusable Software Components  
Author: Dieter Merkl A Min Tjoa Gerti Kappel 
Address: Vienna, 1010 Wien, AUSTRIA  Linz, 4040 Linz, AUSTRIA  
Affiliation: Department of Information Engineering, University of  Department of Computer Science, University of  
Abstract: Properly structured software libraries are crucial for the success of software reuse. Specifically, the structure of the software library ought to reect the functional similarity of the stored software components in order to facilitate the retrieval process. We propose the application of artificial neural network technology to achieve such a structured library. In more detail, we utilize an artificial neural network adhering to the unsupervised learning paradigm. The distinctive feature of this very model is to make the semantic relationship between the stored software components geographically explicit. Thus, the actual user of the software library gets a notion of the semantic relationship between the components in terms of their geographical closeness. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <editor> T. J. Biggerstaff and A. J. Perlis (Eds.). </editor> <booktitle> Software Reusability. Volume I: Concepts and Models. Volume II: Applications and Experience. </booktitle> <address> Reading, MA: </address> <publisher> Addison-Wesley. </publisher> <year> 1989. </year>
Reference-contexts: In this paper we address the second requirement, namely structuring the contents of software libraries in such a way that locating the needed component is facilitated. For an elaborate discussion of other aspects of software reuse we refer to <ref> [1, 6, 14] </ref>. In the rest of this paper we will describe an approach relying on artificial neural network technology to achieve a semantically structured software library. The term semantically structured denotes structuring according to the functional similarity of the stored components. <p> These output units are arranged in some topological order. We use a two-dimensional array of output units each of which is assigned an n-dimensional weight vector. Initially, the components of these weight vectors are assigned small random values in the range of <ref> [0, 1] </ref>. During the learning process the input vectors are repeatedly presented to all output units. Each of which produces one output value proportional to the similarity between the current input vector and the units weight vector. Similarity is commonly measured in terms of the Euclidean distance between the vectors. <p> Moreover, the amount of adaptation is graded by using two scalar functions, i.e. h and x ij . The first function, h, is a gain function which produces a so called learning rate in the range of <ref> [0, 1] </ref> as its output. Obviously, a high learning rate leads to large changes of the weight vectors towards the input vector. <p> The output of this function is 1 for the winning unit itself and decreases gradually proportional to the distance between the unit under consideration and the winning unit. Again, the output is in the range of <ref> [0, 1] </ref>. In order to guarantee convergence of the self-organizing feature map the outcome of the gain function has to decrease gradually in time, i.e. h (t)fi0. <p> This function is used as an inhibition rate which determines the strength of the adaptation. In analogy to equation (3) the output of function b (t) is limited within the range of <ref> [0, 1] </ref> and additionally, the output decreases gradually in time. Thus, at the end of the learning process only the winning unit is adapted; in agreement with the restriction on neighborhood functions as described above. <p> Thus, at the end of the learning process only the winning unit is adapted; in agreement with the restriction on neighborhood functions as described above. It is easy to see that the new neighborhood function computes output values in the range of <ref> [0, 1] </ref>. inhibition of output units. Again in this figure the winning unit is depicted as a black node.
Reference: [2] <author> P. Constantopoulos, M. Jarke, J. Mylopoulos, and Y. Vassiliou. </author> <title> The Software Information Base: A Server for Reuse. </title> <type> Technical Report. </type> <institution> Institute of Computer Science. </institution> <address> Heraklion. Crete. </address> <month> February </month> <year> 1993. </year>
Reference-contexts: In order to obtain a structured library the authors use hierarchical agglomerative clustering methods with the lexical affinities as input. Other approaches rely on semantic networks to capture the relationship between stored software components. For example, within the ESPRIT project ITHACA [13] which addresses software reuse <ref> [2] </ref> the conceptual modeling language Telos [15] is used to describe the stored components and their semantic similarity [20]. An approach that combines faceted classification of software components [17] and semantic networks is reported in [16].
Reference: [3] <author> T. Kohonen. </author> <title> Self-organized formation of topologically correct feature maps. </title> <booktitle> Biological Cybernetics 43. </booktitle> <year> 1982. </year>
Reference-contexts: In other words, components that exhibit similar behavior should be stored near to each other and thus be identifiable. Our approach is based on an artificial neural network adhering to the unsupervised learning paradigm, namely the self-organizing feature map <ref> [3, 4, 5] </ref>. This architecture of neural networks exhibits the distinctive feature of preserving the topological relationship as present in the input data. The topological relationship is made geographically explicit by using a two-dimensional grid of neurons as the output space.
Reference: [4] <author> T. Kohonen. </author> <title> Self-Organization and Associative Memory (3rd edition). </title> <publisher> Berlin: Springer. </publisher> <year> 1989. </year>
Reference-contexts: In other words, components that exhibit similar behavior should be stored near to each other and thus be identifiable. Our approach is based on an artificial neural network adhering to the unsupervised learning paradigm, namely the self-organizing feature map <ref> [3, 4, 5] </ref>. This architecture of neural networks exhibits the distinctive feature of preserving the topological relationship as present in the input data. The topological relationship is made geographically explicit by using a two-dimensional grid of neurons as the output space.
Reference: [5] <author> T. Kohonen. </author> <title> The Self-Organizing Map. </title> <booktitle> Proceedings of the IEEE 78(9). </booktitle> <year> 1990. </year>
Reference-contexts: In other words, components that exhibit similar behavior should be stored near to each other and thus be identifiable. Our approach is based on an artificial neural network adhering to the unsupervised learning paradigm, namely the self-organizing feature map <ref> [3, 4, 5] </ref>. This architecture of neural networks exhibits the distinctive feature of preserving the topological relationship as present in the input data. The topological relationship is made geographically explicit by using a two-dimensional grid of neurons as the output space.
Reference: [6] <author> C. W. Krueger. </author> <title> Software Reuse. </title> <journal> ACM Computing Surveys 24(2). </journal> <year> 1992. </year>
Reference-contexts: In this paper we address the second requirement, namely structuring the contents of software libraries in such a way that locating the needed component is facilitated. For an elaborate discussion of other aspects of software reuse we refer to <ref> [1, 6, 14] </ref>. In the rest of this paper we will describe an approach relying on artificial neural network technology to achieve a semantically structured software library. The term semantically structured denotes structuring according to the functional similarity of the stored components.

Reference: [8] <author> Y. S. Maarek, D. M. Berry, and G. E. Kaiser. </author> <title> An Information Retrieval Approach For Automatically Constructing Software Libraries. </title> <journal> IEEE Transactions on Software Engineering SE-17(8). </journal> <year> 1991. </year>
Reference-contexts: However, to make software reuse operational the actual software developers have to be equipped with libraries containing reusable software components. Concerning software libraries, the most stringent requirements are the following <ref> [8] </ref>. Software libraries should provide a large number of reusable components within a wide spectrum of application domains. These components may be either reused as they are or may be easily adapted to the needs of the application currently under consideration. <p> The second group relies on knowledge-based technology, namely semantic networks. An approach combining information retrieval techniques to build the software representation and cluster analysis to structure the software library is reported in <ref> [7, 8] </ref>. In detail, the classification of reusable software components is performed by using the concept of lexical affinities, i.e. pairs of words that occur frequently together within one sentence. In order to obtain a structured library the authors use hierarchical agglomerative clustering methods with the lexical affinities as input.
Reference: [9] <author> D. Merkl, A M. Tjoa, and G. Kappel. </author> <title> Structuring a Library of Reusable Software Components Using an Artificial Neural Network. </title> <booktitle> Proceedings of the 2nd Intl Conference on Achieving Quality In Software (AQuIS93). </booktitle> <address> Venice. Italy. </address> <year> 1993. </year>
Reference-contexts: In the case of our test environment we identified 39 features and thus, each command is represented by a 39-dimensional feature vector. These feature vectors are the input to the self-organizing feature map. A more detailed description of the test environment is published in <ref> [9] </ref>. Results from using other software libraries are reported in [10, 11]. copy file copy append del file delete xcopy file directory copy 3.2. Semantically structured software libraries The feature vectors representing the operating system commands are used as input vectors during the learning process of the self-organizing feature map.
Reference: [10] <author> D. Merkl. </author> <title> Structuring Software for Reuse - The Case of Self-Organizing Maps. </title> <booktitle> Proceedings of the Intl Joint Conference on Neural Networks (IJCNN93). </booktitle> <address> Nagoya. Japan. </address> <year> 1993. </year>
Reference-contexts: These feature vectors are the input to the self-organizing feature map. A more detailed description of the test environment is published in [9]. Results from using other software libraries are reported in <ref> [10, 11] </ref>. copy file copy append del file delete xcopy file directory copy 3.2. Semantically structured software libraries The feature vectors representing the operating system commands are used as input vectors during the learning process of the self-organizing feature map.
Reference: [11] <author> D. Merkl, A M. Tjoa, and G. Kappel. </author> <title> Application of Self-Organizing Feature Maps With Lateral Inhibition to Structure a Library of Reusable Software Components. </title> <booktitle> Proceedings of the IEEE Intl Conference on Neural Networks (ICNN94). </booktitle> <address> Orlando, FL. </address> <year> 1994. </year>
Reference-contexts: These feature vectors are the input to the self-organizing feature map. A more detailed description of the test environment is published in [9]. Results from using other software libraries are reported in <ref> [10, 11] </ref>. copy file copy append del file delete xcopy file directory copy 3.2. Semantically structured software libraries The feature vectors representing the operating system commands are used as input vectors during the learning process of the self-organizing feature map.
Reference: [12] <author> E. Merlo, I. McAdam, and R. De Mori. </author> <title> Source code informal information analysis using connectionist models. </title> <booktitle> Proceedings of the 13th Intl Joint Conference on Artificial Intelligence (IJCAI93). </booktitle> <address> Chambry. France. </address> <year> 1993. </year>
Reference-contexts: In this work the semantic similarity between the components is captured in weighted connections within the semantic network. An approach to software classification by using an artificial neural network model has been reported recently in <ref> [12] </ref>. In particular, feed-forward and recurrent artificial neural networks adhering to the supervised learning paradigm are used to assign comments and identifiers, which are extracted from the source code, to concepts. Thus, the artificial neural network performs an analysis of the informal information contained in a program.
Reference: [13] <author> V. de Mey, O. Nierstrasz. </author> <title> The ITHACA Application Development Environment. In: Visual Objects (D. </title> <type> Tsichritzis, </type> <institution> ed.). Centre Universitaire dInformatique. University of Geneva. </institution> <year> 1993. </year>
Reference-contexts: In order to obtain a structured library the authors use hierarchical agglomerative clustering methods with the lexical affinities as input. Other approaches rely on semantic networks to capture the relationship between stored software components. For example, within the ESPRIT project ITHACA <ref> [13] </ref> which addresses software reuse [2] the conceptual modeling language Telos [15] is used to describe the stored components and their semantic similarity [20]. An approach that combines faceted classification of software components [17] and semantic networks is reported in [16].
Reference: [14] <author> R. T. Mittermeir and W. Rossak. </author> <title> Reusability. </title> <booktitle> in: Modern Software Engineering - Foundations and Current Perspectives (P. </booktitle> <editor> A. Ng and R. T. Yeh, Eds.). </editor> <address> New York: </address> <publisher> Van Nostrand Reinhold. </publisher> <year> 1990. </year>
Reference-contexts: In this paper we address the second requirement, namely structuring the contents of software libraries in such a way that locating the needed component is facilitated. For an elaborate discussion of other aspects of software reuse we refer to <ref> [1, 6, 14] </ref>. In the rest of this paper we will describe an approach relying on artificial neural network technology to achieve a semantically structured software library. The term semantically structured denotes structuring according to the functional similarity of the stored components.
Reference: [15] <author> J. Mylopoulos, A. Borgida, M. Jarke, and M. Koubarakis. </author> <title> Telos: Representing Knowledge About Information Systems. </title> <journal> ACM Transactions on Information Systems 8(4). </journal> <year> 1990. </year>
Reference-contexts: Other approaches rely on semantic networks to capture the relationship between stored software components. For example, within the ESPRIT project ITHACA [13] which addresses software reuse [2] the conceptual modeling language Telos <ref> [15] </ref> is used to describe the stored components and their semantic similarity [20]. An approach that combines faceted classification of software components [17] and semantic networks is reported in [16]. In this work the semantic similarity between the components is captured in weighted connections within the semantic network.
Reference: [16] <author> E. Ostertag, J. Hendler, R. Prieto Diaz, and C. Braun. </author> <title> Computing Similarity in a Reuse Library. </title> <journal> ACM Transactions on Software Engineering and Methodology 1(3). </journal> <year> 1992. </year>
Reference-contexts: For example, within the ESPRIT project ITHACA [13] which addresses software reuse [2] the conceptual modeling language Telos [15] is used to describe the stored components and their semantic similarity [20]. An approach that combines faceted classification of software components [17] and semantic networks is reported in <ref> [16] </ref>. In this work the semantic similarity between the components is captured in weighted connections within the semantic network. An approach to software classification by using an artificial neural network model has been reported recently in [12].
Reference: [17] <author> R. Prieto Diaz and P. Freeman. </author> <title> Classifying software for reusability. </title> <booktitle> IEEE Software 4(1). </booktitle> <year> 1987. </year>
Reference-contexts: For example, within the ESPRIT project ITHACA [13] which addresses software reuse [2] the conceptual modeling language Telos [15] is used to describe the stored components and their semantic similarity [20]. An approach that combines faceted classification of software components <ref> [17] </ref> and semantic networks is reported in [16]. In this work the semantic similarity between the components is captured in weighted connections within the semantic network. An approach to software classification by using an artificial neural network model has been reported recently in [12].
Reference: [18] <author> H. Ritter and T. Kohonen. </author> <title> Self-Organizing Semantic Maps. </title> <booktitle> Biological Cybernetics 61. </booktitle> <year> 1989. </year>
Reference-contexts: In order to provide such an improved learning function we changed the original neighborhood function as proposed by Ritter and Kohonen <ref> [18] </ref> to capture lateral inhibition of output units. The original neighborhood function only moves weight vectors of neighboring units towards the current input.
Reference: [19] <author> G. Salton and M. McGill. </author> <title> Introduction to Modern Information Retrieval. </title> <address> New York: </address> <publisher> McGraw-Hill. </publisher> <year> 1983. </year>
Reference-contexts: In particular, the library contains 36 MS-DOS commands. The description of the commands is based on extracted words from the operating system manual which describe the behavior of the commands. We chose binary single term indexing <ref> [19] </ref> as the basic means to extract the needed information. The extracted words form the list of possible features of the software components. As an example consider Figure 3 containing the observed features of the operating system commands copy, del, and xcopy. <p> The results of the queries are compared with hierarchical cluster analysis applying the Ward method <ref> [19] </ref> with Euclidean distance as the similarity measure. Similar results were obtained by using complete linkage for clustering. As can be seen, the relevant components appear within the five top ranked commands for every self-organizing feature map.
Reference: [20] <author> G. Spanoudakis and P. Constantopoulos. </author> <title> Similarity for Analogical Software Reuse: A Conceptual Modeling Approach. </title> <booktitle> Proceedings of the 5th Intl Conference CAiSE93. </booktitle> <address> Berlin: </address> <publisher> Springer (LNCS 685). </publisher> <year> 1993. </year>
Reference-contexts: Other approaches rely on semantic networks to capture the relationship between stored software components. For example, within the ESPRIT project ITHACA [13] which addresses software reuse [2] the conceptual modeling language Telos [15] is used to describe the stored components and their semantic similarity <ref> [20] </ref>. An approach that combines faceted classification of software components [17] and semantic networks is reported in [16]. In this work the semantic similarity between the components is captured in weighted connections within the semantic network.
Reference: [21] <author> H. R. Turtle and W. B. Croft. </author> <title> A Comparison of Text Retrieval Models. </title> <journal> The Computer Journal 35(3). </journal> <year> 1992. </year>
Reference-contexts: The extracted words form the list of possible features of the software components. As an example consider Figure 3 containing the observed features of the operating system commands copy, del, and xcopy. The final representation of the commands follows the vector space model <ref> [21] </ref> where input data and queries are represented as vectors in a k-dimensional hyperspace. Each component of the vectors corresponds to a possible feature and is binarily valued. Thus, an entry of zero denotes the fact that the corresponding feature is not used in the description of the software component.
References-found: 20

