URL: http://www.cs.wustl.edu/cs/techreports/1997/wucs-97-08.ps.Z
Refering-URL: http://www.cs.wustl.edu/cs/cs/publications.html
Root-URL: http://www.cs.wustl.edu
Title: End-User Visualization and Manipulation of Aggregate Data  
Author: T. Paul McCartney, Kenneth J. Goldman 
Date: February 1997  
Address: Campus Box 1045 One Brookings Drive Saint Louis, MO 63130-4899  
Affiliation: Department of Computer Science Washington University  
Pubnum: WUCS-97-08  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> Codd, E. F. </author> <title> Relational Completeness of Data Base Sublanguages. In Data Base Systems, </title> <editor> R. Rustin (ed.), </editor> <address> Englewood Cliffs, N.J. </address> <publisher> Prentice-Hall, </publisher> <pages> pages 65-98, </pages> <year> 1972. </year> <title> End-User Visualization and Manipulation of Aggregate Data - 13 </title> - 
Reference-contexts: These mechanisms were developed in the context of state-based distributed computing, but are equally applicable to non-distributed applications. End-users can visually specify how aggregate data is processed from multiple aggregates, using mechanisms functionally similar to select, project, join, and cross product of relational databases <ref> [1] </ref>, [2]. This allows aggregate data to be combined from different sources without the need for textual programming. End-users also visually create mappings of each aggregate to the graphics display, enabling both the visualization and manipulation behavior of the aggregates to be specified without programming.
Reference: [2] <author> Codd, E. F. </author> <title> A relational model for large shared data banks, </title> <journal> Communications of the ACM, </journal> <volume> 13(6) </volume> <pages> 377-387. </pages>
Reference-contexts: These mechanisms were developed in the context of state-based distributed computing, but are equally applicable to non-distributed applications. End-users can visually specify how aggregate data is processed from multiple aggregates, using mechanisms functionally similar to select, project, join, and cross product of relational databases [1], <ref> [2] </ref>. This allows aggregate data to be combined from different sources without the need for textual programming. End-users also visually create mappings of each aggregate to the graphics display, enabling both the visualization and manipulation behavior of the aggregates to be specified without programming.
Reference: [3] <author> Cordy, James R. and T. C. Nicholas Graham. GVL: </author> <title> Visual Specification of Graphical Output. </title> <journal> Journal of Visual Languages and Computing 3(1) </journal> <pages> 25-47, </pages> <month> March </month> <year> 1992. </year>
Reference-contexts: Graphics toolkits such as Garnet [16] and Interviews [9] provide programmatic support for visualizing data sets such as lists and graphs. Our work focuses on allowing end-users to create aggregate visualizations without textual programming. Research systems such as Pavane [17] and Weasel <ref> [3] </ref> allow the visualization of aggregate data through the use of a high-level specification language. Swarm, Pavanes specification language, allows programmers to write a formal textual specification how data from concurrent algorithms is to be mapped to a display.
Reference: [4] <author> Frank, Martin R. Grizzly Bear: </author> <title> A demonstrational learning tool for a user interface specification language. </title> <booktitle> In Proceedings of the ACM Symposium on User Interface Software and Technology, </booktitle> <address> Pittsburgh, Pennsylvania, </address> <pages> pages 75-76, </pages> <month> November </month> <year> 1995. </year>
Reference-contexts: This mechanism would enable a further decoupling of applications from their GUIs by eliminating the need for the application to specify element position information. One approach to this problem is to specify the layout graphically through induction-style rules. With this strategy, similar to a demonstrational approach <ref> [4] </ref>, [15], the end-user would specify the relationship between the first aggregate element (base case), an aggregate instance k, and the relationship to the next element k+1. From this information, the system would inductively place each instance element of the aggregate.
Reference: [5] <author> Freeman-Benson, Bjorn, John Maloney, Alan Borning. </author> <title> An Incremental Constraint Solver. </title> <journal> Communications of the ACM, </journal> <volume> 33(1) </volume> <pages> 54-63, </pages> <year> 1990. </year>
Reference: [6] <author> Gallager, R. G., P. A. Humblet, and P. M. Spira. </author> <title> A Distributed Algorithm for Minimum-Weight Spanning Trees. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 5(1) </volume> <pages> 66-77, </pages> <month> January </month> <year> 1983. </year>
Reference-contexts: Vertices Edges A B E Join array of: id pos array of: v1 v2 name End-User Visualization and Manipulation of Aggregate Data - 9 - 4.4.1 Joined Aggregate Example The Gallager-Humblet-Spira distributed minimum spanning tree algorithm <ref> [6] </ref> can be visualized using aggregate mappings. In this application, each vertex of the underlying graph is an independently running module. The modules work together to find the minimum spanning tree of the complete graph according to the Euclidean distance among the vertices.
Reference: [7] <author> Goldman, Kenneth J., Bala Swaminathan, T. Paul McCartney, Michael D. Anderson, and Ram Sethuraman. </author> <title> The Programmers Playground: I/O Abstraction for User-Configurable Distributed Applications. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 21(9) </volume> <pages> 735-746, </pages> <month> September </month> <year> 1995. </year>
Reference-contexts: End-User Visualization and Manipulation of Aggregate Data - 3 - 3. Background This section describes the software systems that this work was built upon, including a distributed programming environment and a user interface management system. 3.1 The Programmers Playground The Programmers Playground <ref> [7] </ref> is a software library and run-time system that supports a new programming model for distributed applications. The model, called I/O abstraction, provides a separation of computation from communication that is well-suited for end-user construction of customized distributed applications from computational building blocks. <p> The above background discussion of The Programmers Playground and EUPHORIA is sufficient for understanding the research contributions presented in this paper. Further details on The Programmers Playground and EUPHORIA are discussed in <ref> [7] </ref>, [12], [14]. 4. Aggregate Mappings The central contribution of this work is the aggregate mapping, a mechanism that allows end-users to specify how aggregates are to be visualized.
Reference: [8] <author> Jagadeesh, J. and Y. Wang. </author> <title> LabVIEW. Product Review, </title> <booktitle> Computer, </booktitle> <month> February </month> <year> 1993. </year>
Reference-contexts: Section 4 describes aggregate mappings, the end-user mechanism for creating interactive aggregate visualizations. Section 5 discusses possible future research directions, and Section 6 ends with a brief summary. 2. Related Work Commercial products such as Microsoft Excel [10] and LabView <ref> [8] </ref> provide some support for end-user aggregate visualization. Excel users may choose from a number of pre-defined chart representations (e.g., pie charts, histograms) to view spreadsheet data. Excels visualization is static; once a chart is created the user cannot interact with the display.
Reference: [9] <author> Linton, Mark A., John M. Vlissides and Paul R. Calder. </author> <title> Composing User Interfaces with InterViews. </title> <booktitle> IEEE Computer 22(2) </booktitle> <pages> 8-22, </pages> <month> February </month> <year> 1989. </year>
Reference-contexts: Our system gives end-users the ability to specify arbitrary graphical representations of aggregate data and how it is mapped to the display. This gives users the ability to create highly customized, interactive visualizations. Graphics toolkits such as Garnet [16] and Interviews <ref> [9] </ref> provide programmatic support for visualizing data sets such as lists and graphs. Our work focuses on allowing end-users to create aggregate visualizations without textual programming. Research systems such as Pavane [17] and Weasel [3] allow the visualization of aggregate data through the use of a high-level specification language.
Reference: [10] <author> Microsoft Corporation. </author> <title> One Microsoft Way, </title> <address> Redmond, WA 98052-6399. </address>
Reference-contexts: Section 4 describes aggregate mappings, the end-user mechanism for creating interactive aggregate visualizations. Section 5 discusses possible future research directions, and Section 6 ends with a brief summary. 2. Related Work Commercial products such as Microsoft Excel <ref> [10] </ref> and LabView [8] provide some support for end-user aggregate visualization. Excel users may choose from a number of pre-defined chart representations (e.g., pie charts, histograms) to view spreadsheet data. Excels visualization is static; once a chart is created the user cannot interact with the display.
Reference: [11] <author> McCartney, T. Paul. </author> <title> A Usability Study of End-user Construction of Direct Manipulation User Interfaces. </title> <note> To appear in Software-Concepts and Tools. </note>
Reference-contexts: This study showed that end-users with no prior experience with distributed computing or user interface construction could learn to use EUPHORIA in a fairly short period of time (e.g., 30 minutes), and could construct interactive graphical user interfaces <ref> [11] </ref>. Subjects from a variety of backgrounds were chosen (i.e., not just computer science students). The usability study did not involve aggregate mappings explicitly, but the steps to create ordinary constraints within EUPHORIA are similar to the steps used to define aggregate mappings.
Reference: [12] <author> McCartney T. Paul. </author> <title> End-user Construction and Configuration of Distributed Multimedia Applications. D.Sc. </title> <type> Dissertation, </type> <institution> Washington University 1996. </institution> <note> Also appears as Washington University Department of Computer Science technical report WUCS-96-24, </note> <month> September </month> <year> 1996. </year>
Reference-contexts: Element-to-aggregate connections also facilitate the development of distributed applications that gather aggregate data from many different sources. 3.2 EUPHORIA User Interface Management System EUPHORIA, Playgrounds user interface management system <ref> [12] </ref>, [14], is a specialized module for creating customized direct manipulation GUIs without the need to write user interface source code. In EUPHORIA, end-users simply draw GUIs using an interactive graphics editor (Figure 1). GUIs can consist of simple shapes, end-user defined widgets (encapsulated grouping of shapes), and images. <p> Each shape drawn in EUPHORIA has a number of associated attributes (e.g., position, size, etc.) that can be used in forming relationships to other shapes and to external modules of a distributed application. End-User Visualization and Manipulation of Aggregate Data - 4 - End-users can define multi-way constraints <ref> [12] </ref> among shape attributes, allowing graphical interaction behavior to be defined without programming. In EUPHORIA, the handles of a selected graphics object act as data ports to the objects underlying attributes, allowing end-users to define constraints between graphics objects by drawing connection lines between their handles [14]. <p> The above background discussion of The Programmers Playground and EUPHORIA is sufficient for understanding the research contributions presented in this paper. Further details on The Programmers Playground and EUPHORIA are discussed in [7], <ref> [12] </ref>, [14]. 4. Aggregate Mappings The central contribution of this work is the aggregate mapping, a mechanism that allows end-users to specify how aggregates are to be visualized. Aggregate mappings are a general-purpose approach to both creating the visualization and defining communication between aggregate data structures and their corresponding visualizations.
Reference: [13] <author> McCartney, T. Paul and Kenneth J. Goldman. </author> <title> Visual Specification of Interprocess and Intraprocess Communication. </title> <booktitle> In Proceedings of the 10th International Symposium on Visual Languages, </booktitle> <month> October </month> <year> 1994, </year> <pages> pages 80-87. </pages>
Reference-contexts: These types may be arbitrarily nested to form new publishable tuple types, and new publishable aggregates may be defined as well. Playground modules have a visual representation that was designed as part of a simple visual language for interprocess and intraprocess communication <ref> [13] </ref>. A distributed application consists of a collection of independent modules and a configuration of logical connections among the modules published variables. Whenever a module updates one of its own published data items, the new value is implicitly communicated to all connected variables in other modules.
Reference: [14] <author> McCartney, T. Paul, Goldman, K., and Saff, D., EUPHORIA: </author> <title> End-User Construction of Direct Manipulation User Interfaces for Distributed Applications, </title> <journal> Software-Concepts and Tools, </journal> <volume> 16(4) </volume> <pages> 147-159, </pages> <month> December </month> <year> 1995. </year>
Reference-contexts: Element-to-aggregate connections also facilitate the development of distributed applications that gather aggregate data from many different sources. 3.2 EUPHORIA User Interface Management System EUPHORIA, Playgrounds user interface management system [12], <ref> [14] </ref>, is a specialized module for creating customized direct manipulation GUIs without the need to write user interface source code. In EUPHORIA, end-users simply draw GUIs using an interactive graphics editor (Figure 1). GUIs can consist of simple shapes, end-user defined widgets (encapsulated grouping of shapes), and images. <p> In EUPHORIA, the handles of a selected graphics object act as data ports to the objects underlying attributes, allowing end-users to define constraints between graphics objects by drawing connection lines between their handles <ref> [14] </ref>. For example, one could constrain a rectangle object to be a square by drawing a connection line between its width and height handles, constraining its width and height attributes to be equal. Since constraints are multi-way, changing either the rectangles width or height causes the other to also change. <p> The above background discussion of The Programmers Playground and EUPHORIA is sufficient for understanding the research contributions presented in this paper. Further details on The Programmers Playground and EUPHORIA are discussed in [7], [12], <ref> [14] </ref>. 4. Aggregate Mappings The central contribution of this work is the aggregate mapping, a mechanism that allows end-users to specify how aggregates are to be visualized. Aggregate mappings are a general-purpose approach to both creating the visualization and defining communication between aggregate data structures and their corresponding visualizations. <p> The prototype instance is a graphical representation (e.g., a simple shape or widget) that will be used to display each aggregate element. In the morphing example, the prototype instance is a single feature marker (i.e., a square widget containing a numerical display). As described in <ref> [14] </ref>, widgets are constructed interactively by the end-user in EUPHORIA. Recall that graphics object handles are used for forming constraint relationships in EUPHORIA (Section 3.2). Handles are also used in defining the equality relationships between the aggregates element type and the prototype instance.
Reference: [15] <author> Myers, Brad A. </author> <title> Creating User Interfaces by Demonstration. </title> <publisher> Academic Press, </publisher> <address> Boston, </address> <year> 1988. </year>
Reference-contexts: This mechanism would enable a further decoupling of applications from their GUIs by eliminating the need for the application to specify element position information. One approach to this problem is to specify the layout graphically through induction-style rules. With this strategy, similar to a demonstrational approach [4], <ref> [15] </ref>, the end-user would specify the relationship between the first aggregate element (base case), an aggregate instance k, and the relationship to the next element k+1. From this information, the system would inductively place each instance element of the aggregate.
Reference: [16] <author> Myers, Brad A., et al. Garnet: </author> <title> Comprehensive Support for Graphical, Highly Interactive User Interfaces. </title> <journal> IEEE Computer, </journal> <volume> 23(11) </volume> <pages> 71-85, </pages> <month> November </month> <year> 1990. </year>
Reference-contexts: Our system gives end-users the ability to specify arbitrary graphical representations of aggregate data and how it is mapped to the display. This gives users the ability to create highly customized, interactive visualizations. Graphics toolkits such as Garnet <ref> [16] </ref> and Interviews [9] provide programmatic support for visualizing data sets such as lists and graphs. Our work focuses on allowing end-users to create aggregate visualizations without textual programming.
Reference: [17] <author> Roman, G.-C., Kenneth Cox, C. D. Wilcox, and J. Y. Plun. Pavane: </author> <title> a system for declarative visualization of End-User Visualization and Manipulation of Aggregate Data - 14 - concurrent computations. </title> <journal> Journal of Visual Languages and Computing 3, </journal> <pages> 161-193. </pages>
Reference-contexts: Graphics toolkits such as Garnet [16] and Interviews [9] provide programmatic support for visualizing data sets such as lists and graphs. Our work focuses on allowing end-users to create aggregate visualizations without textual programming. Research systems such as Pavane <ref> [17] </ref> and Weasel [3] allow the visualization of aggregate data through the use of a high-level specification language. Swarm, Pavanes specification language, allows programmers to write a formal textual specification how data from concurrent algorithms is to be mapped to a display.
Reference: [18] <author> Swaminathan, Bala. </author> <title> Connection Management in Distributed Programming Environments. D.Sc. Dissertation, </title> <address> Washington University 1995. </address>
Reference-contexts: This section outlines some of these enhancements. Currently, the only aggregate type supported in EUPHORIA is fixed size array 2 . EUPHORIA will eventually support other Playground aggregate types such as lists and mappings. Playground also has a general-purpose aggregate type called grouping <ref> [18] </ref> that can be used to construct other aggregate data structures such as trees and heaps. Since the structure of such aggregates is arbitrary, the end-user mechanism for specifying traversal order is an issue to consider (order will be important for aggregate layout, outlined below).
References-found: 18

