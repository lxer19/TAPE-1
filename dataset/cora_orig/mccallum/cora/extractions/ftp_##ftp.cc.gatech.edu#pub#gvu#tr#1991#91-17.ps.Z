URL: ftp://ftp.cc.gatech.edu/pub/gvu/tr/1991/91-17.ps.Z
Refering-URL: http://www.cs.gatech.edu/gvu/reports/1991/
Root-URL: 
Title: Understanding and Characterizing Program Visualization Systems  
Author: John T. Stasko Charles Patterson 
Keyword: program visualization, algorithm animation, software understanding  
Address: Atlanta, GA 30332-0280  
Affiliation: Graphics, Visualization, and Usability Center College of Computing Georgia Institute of Technology  
Pubnum: Technical Report GIT-GVU-91-17  
Email: E-mail: fstasko,charliepg@cc.gatech.edu  
Date: October 16, 1993  
Abstract: The general term program visualization refers to graphical views or illustrations of the entities and characteristics of computer programs. This term along with many others including data structure display, program animation, algorithm animation, etc., have been used inconsistently in the literature, which has led to confusion in describing systems providing these capabilities. In this paper we present a scaled characterization of program visualization terms along aspect, abstractness, animation, and automation dimensions. Rather than placing existing systems into hard-and-fast categories, we focus on unique and differentiating aspects across all systems. 
Abstract-found: 1
Intro-found: 1
Reference: [AB89] <author> Allen L. Ambler and Margaret M. Burnett. </author> <title> Influence of visual technology on the evolution of language environments. </title> <journal> Computer, </journal> <volume> 22(10) </volume> <pages> 9-22, </pages> <month> October </month> <year> 1989. </year>
Reference-contexts: The ability to debug and demonstrate a program using images, therefore, can make the programming process easier. Visualization techniques have already made a significant impact on programming language environments <ref> [AB89] </ref>. Appropriate animated images have also been used for teaching the purpose and functionality of algorithms [Bro88a, Sta90]. In this paper, we focus on graphical views of computer programs, such as illustrations of variables, code sections, the run-time stack, and program semantics.
Reference: [B + 85] <author> Gretchen P. Brown et al. </author> <title> Program visualization: Graphical support for software development. </title> <journal> Computer, </journal> <volume> 18(8) </volume> <pages> 27-35, </pages> <month> August </month> <year> 1985. </year>
Reference-contexts: We call these types of systems program state visualization systems. The Pecan system [Rei85], a view of which is shown in Figure 2, contains an almost exhaustive set of views including symbol table, data type, stack, flowgraph, and expression displays. The PV system <ref> [B + 85] </ref> provides program structure, flow of control, and program data views, but it also includes views of important phases of the software engineering lifecycle such as diagrams of system requirements.
Reference: [Bae86] <author> Ronald M. Baecker. </author> <title> An application overview of program visualization. </title> <booktitle> Computer Graphics: SIGGRAPH '86, </booktitle> <address> 20(4):325, </address> <month> July </month> <year> 1986. </year>
Reference-contexts: One term that has become accepted for describing this general area is "program visualization." Baecker defines the term as, "the use of the techniques of interactive graphics and the crafts of graphic design, typography, animation, and cinematography to enhance the presentation and understanding of computer programs <ref> [Bae86] </ref>." Unfortunately, so many different names are given to so many hybrids of program visualization systems that it is difficult to consistently recognize the purpose of each.
Reference: [Bas85] <author> David B. Baskerville. </author> <title> Graphic presentation of data structures in the DBX debugger. </title> <type> Technical Report UCB/CSD 86/260, </type> <institution> University of California at Berkeley, Berkeley, </institution> <address> CA, </address> <month> October </month> <year> 1985. </year> <month> 17 </month>
Reference-contexts: This capability, with no turnaround time for view design, is necessary for time-intensive tasks such as debugging. Often, systems support automatic generation of displays, but they also permit viewers to modify the display as desired. The GDBX system <ref> [Bas85] </ref> provides canonical box-and-arrow displays of Pascal and C programs. It allows viewers to reposition or eliminate data structure views as desired during a debugging session. GELO [RMD89] also includes predefined data views, but it allows users to graphically specify specialized data type displays using topological constraints.
Reference: [BK91] <author> Jon L. Bentley and Brian W. Kernighan. </author> <title> A system for algorithm animation. </title> <journal> Computing Systems, </journal> <volume> 4(1), </volume> <month> Winter </month> <year> 1991. </year>
Reference-contexts: The Balsa system [Bro88a] is the prototype for algorithm visualization systems with its high-quality imagery, multiple views, and scripting facilities. Balsa inspired subsequent systems such the Smalltalk based system Animus [Dui86], and ANIM <ref> [BK91] </ref>, a system for building simple algorithm visualizations in a UNIX environment. Note that algorithm visualization systems often encompass or include data structure and program state visualization capabilities. Many views in the above systems illustrate only program data and its characteristics throughout program execution.
Reference: [BM90] <author> Ronald M. Baecker and Aaron Marcus. </author> <title> Human Factors and Typography for More Readable Programs. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, MA, </address> <year> 1990. </year>
Reference-contexts: This dimension most closely represents the purpose of the visualization|why the visualization is being created and what parts of the program are being emphasized. The simplest aspect level of program visualization is just an enhanced presentation of program text. The SEE system <ref> [BM90] </ref> uses human factors knowledge and typography techniques to display C programs. Debuggers often show the text of programs' procedures as they execute, with line by line highlighting. Moving beyond purely textual views, some systems provide views of the data and data structures in programs.
Reference: [Bro88a] <author> Marc H. Brown. </author> <title> Exploring algorithms using Balsa-II. </title> <journal> Computer, </journal> <volume> 21(5) </volume> <pages> 14-36, </pages> <month> May </month> <year> 1988. </year>
Reference-contexts: The ability to debug and demonstrate a program using images, therefore, can make the programming process easier. Visualization techniques have already made a significant impact on programming language environments [AB89]. Appropriate animated images have also been used for teaching the purpose and functionality of algorithms <ref> [Bro88a, Sta90] </ref>. In this paper, we focus on graphical views of computer programs, such as illustrations of variables, code sections, the run-time stack, and program semantics. <p> One of the first examples of algorithm visualization is the film Sorting Out Sorting [BS81], generally accepted as a motivating factor for this research area. The Balsa system <ref> [Bro88a] </ref> is the prototype for algorithm visualization systems with its high-quality imagery, multiple views, and scripting facilities. Balsa inspired subsequent systems such the Smalltalk based system Animus [Dui86], and ANIM [BK91], a system for building simple algorithm visualizations in a UNIX environment.
Reference: [Bro88b] <author> Marc H. Brown. </author> <title> Perspectives on algorithm animation. </title> <booktitle> In Proceedings of the ACM SIGCHI '88 Conference on Human Factors in Computing Systems, </booktitle> <pages> pages 33-38, </pages> <address> Washington D.C., </address> <month> May </month> <year> 1988. </year>
Reference-contexts: However, another view of this data structure could display the data in the form of a clock face with appropriate hour, minute, and second hands. One characterization of the abstractness of a program view is whether the display is iso 6 morphic to the program components it represents <ref> [Bro88b] </ref>. That is, could a data structure be rebuilt from its graphical representation as easily as the representation is created from the data structure? Algorithm visualizations, as discussed in the previous subsection, typically go beyond isomorphic mappings of program data or code to graphical representations of program semantics. <p> Simply presenting a rapid sequence of frames with the disks at their new end-positions (without intermediate movement presented) would be extremely difficult to follow and comprehend. Brown has characterized specific imagery in algorithm animations along three dimensions: transformation, persistence, and content <ref> [Bro88b] </ref>. The animation dimension of our scheme coincides similarly with his transformation dimension. Our notion of characterizing animation by the artificial program states presented between valid program configurations, however, helps to clarify the distinction between program visualizations and animations. <p> Recently, systems providing algorithm views without explicit end-designer support have appeared [HWF90], but they are restricted to specific algorithm domains and they require considerable compiler crafting. Brown makes strong arguments why, under current constraints, explicit programmer design for algorithm animations is typically required and desirable <ref> [Bro88b] </ref>. Nevertheless, recent algorithm animation work has focused on reducing the burden of view design and implementation. These efforts still provide a designer with artistic freedom, but they strive to provide tools which make view development easier and more fun.
Reference: [BS81] <author> Ronald M. Baecker and David Sherman. </author> <title> Sorting Out Sorting. 16mm color sound film, </title> <booktitle> 1981. Shown at SIGGRAPH '81, </booktitle> <address> Dallas TX. </address>
Reference-contexts: Program state visualization systems display code and its syntactic structure, such as scope, but they stop short of showing views of the actual task being performed by the code. One of the first examples of algorithm visualization is the film Sorting Out Sorting <ref> [BS81] </ref>, generally accepted as a motivating factor for this research area. The Balsa system [Bro88a] is the prototype for algorithm visualization systems with its high-quality imagery, multiple views, and scripting facilities.
Reference: [Cha87] <author> Shi-Kuo Chang. </author> <title> Visual languages: A tutorial and survey. </title> <journal> IEEE Software, </journal> <volume> 4(1) </volume> <pages> 29-39, </pages> <month> January </month> <year> 1987. </year>
Reference-contexts: A precise descriptive scheme provides a framework for designers to describe their work and disseminate information. Another research area with a similar descriptive name to program visualization is visual programming <ref> [Cha87, Shu88] </ref>, but it differs importantly from the subject matter of this paper. Visual programming involves actual programming through the use of pictures, icons, and graphical entities. A programmer manipulates the visual entities in order to create a 2 missing) semantically meaningful computational process.
Reference: [Dui86] <author> Robert A. Duisberg. </author> <title> Animated graphical interfaces using temporal constraints. </title> <booktitle> In Proceedings of the ACM SIGCHI '86 Conference on Human Factors in Computing Systems, </booktitle> <pages> pages 131-136, </pages> <address> Boston, MA, </address> <month> April </month> <year> 1986. </year>
Reference-contexts: The Balsa system [Bro88a] is the prototype for algorithm visualization systems with its high-quality imagery, multiple views, and scripting facilities. Balsa inspired subsequent systems such the Smalltalk based system Animus <ref> [Dui86] </ref>, and ANIM [BK91], a system for building simple algorithm visualizations in a UNIX environment. Note that algorithm visualization systems often encompass or include data structure and program state visualization capabilities. Many views in the above systems illustrate only program data and its characteristics throughout program execution.
Reference: [Dui87] <author> Robert A. Duisberg. </author> <title> Visual programming of program visualizations. A gestural interface for animating algorithms. </title> <booktitle> In Proceedings of the 1987 IEEE Computer Society Workshop on Visual Languages, </booktitle> <pages> pages 55-66, </pages> <address> Linkoping, Sweden, </address> <month> August </month> <year> 1987. </year>
Reference-contexts: The Gestural system <ref> [Dui87] </ref> and the Dance animation editor [Sta91] both allow designers to "visually program" their desired program visualization via direct manipulation. 3 Taxonomy We believe that our method of characterizing program visualization systems provides a framework for understanding and discussing these systems in more detail than has been previously available.
Reference: [HHR89] <author> Esa Helttula, Aulikki Hyrskykari, and Kari-Jouko Raiha. </author> <title> Graphical specification of algorithm animations with Aladdin. </title> <booktitle> In Proceedings of the 22nd Hawaii International Conference on System Sciences, </booktitle> <pages> pages 892-901, </pages> <address> Kailua-Kona, HI, </address> <month> January </month> <year> 1989. </year>
Reference-contexts: Nevertheless, recent algorithm animation work has focused on reducing the burden of view design and implementation. These efforts still provide a designer with artistic freedom, but they strive to provide tools which make view development easier and more fun. The Aladdin system <ref> [HHR89] </ref> uses a declarative mechanism to specify view layout.
Reference: [HWF90] <author> Robert R. Henry, Kenneth M. Whaley, and Bruce Forstall. </author> <title> The University of Washington illustrating compiler. </title> <journal> Sigplan Notices: SIGPLAN '90, </journal> <volume> 25(6) </volume> <pages> 223-233, </pages> <month> June </month> <year> 1990. </year>
Reference-contexts: Consequently, algorithm visualizations (and particularly animations), virtually by definition, exhibit a low level of automation. Recently, systems providing algorithm views without explicit end-designer support have appeared <ref> [HWF90] </ref>, but they are restricted to specific algorithm domains and they require considerable compiler crafting. Brown makes strong arguments why, under current constraints, explicit programmer design for algorithm animations is typically required and desirable [Bro88b].
Reference: [ISO87] <author> Sadahiro Isoda, Takao Shimomura, and Yuji Ono. </author> <title> VIPS: A visual debugger. </title> <journal> IEEE Software, </journal> <volume> 4(3) </volume> <pages> 8-19, </pages> <month> May </month> <year> 1987. </year> <month> 18 </month>
Reference-contexts: Program state views such as those of the call graph, run-time stack, or text code can be generated automatically by a program visualization system. Again, these views are extremely useful for debugging which requires little of no view set-up time. For instance, VIPS <ref> [ISO87] </ref> generates multiple run-time views of Ada programs, including data, block structure, and debugger interaction windows. Often, the most difficult part of building a system to display program state is not the generation of the graphics, but the acquisition of the run-time execution data and information driving the graphics.
Reference: [LD85] <author> Ralph L. London and Robert A. Duisberg. </author> <title> Animating programs using Smalltalk. </title> <journal> Computer, </journal> <volume> 18(8) </volume> <pages> 61-71, </pages> <month> August </month> <year> 1985. </year>
Reference-contexts: Our notion of characterizing animation by the artificial program states presented between valid program configurations, however, helps to clarify the distinction between program visualizations and animations. One of the earliest systems to recognize the importance of smooth transitions generates algorithm animations of Smalltalk programs by monitoring message passing <ref> [LD85] </ref>. Later program visualization systems such as Tango [Sta90] provide explicit mechanisms to help produce the in-between configuration views that typify animations. In Tango, view designers develop animations using high-level primitives that hide low-level graphics details.
Reference: [MCS88] <author> Brad A. Myers, Ravinder Chandhok, and Atul Sareen. </author> <title> Automatic data visualization for novice Pascal programmers. </title> <booktitle> In Proceedings of the 1988 IEEE Computer Society Workshop on Visual Languages, </booktitle> <pages> pages 192-198, </pages> <address> Pittsburgh, PA, </address> <month> October </month> <year> 1988. </year>
Reference-contexts: The purpose of such a visualization tool is stated nicely by Myers, et. al.: "Human information processing is clearly optimized for pictorial information, and pictures make the data easier to understand for the programmer <ref> [MCS88] </ref>." The two-dimensional format of a picture can provide greater amounts of relevant information more fluently than 1 a stream of text. Programming textbooks reflect this fact when they use the familiar boxes for variables, columns of boxes for arrays, and arrows for pointers. <p> Moving beyond purely textual views, some systems provide views of the data and data structures in programs. One of the first general purpose data structure display systems, Incense [Mye83], generates a view of user-specified data structures during debugging. A follow-up system, MacGnome <ref> [MCS88] </ref>, focuses on providing simple canonical Pascal data structure views for novice programmers. A linked list data structure view taken from MacGnome is shown in Figure 1. Some systems provide views of program aspects beyond pure data structures.
Reference: [Mye83] <author> Brad A. Myers. </author> <title> A system for displaying data structures. </title> <journal> Computer Graphics: </journal> <volume> SIGGRAPH '83, 17(3) </volume> <pages> 115-125, </pages> <month> July </month> <year> 1983. </year>
Reference-contexts: Debuggers often show the text of programs' procedures as they execute, with line by line highlighting. Moving beyond purely textual views, some systems provide views of the data and data structures in programs. One of the first general purpose data structure display systems, Incense <ref> [Mye83] </ref>, generates a view of user-specified data structures during debugging. A follow-up system, MacGnome [MCS88], focuses on providing simple canonical Pascal data structure views for novice programmers. A linked list data structure view taken from MacGnome is shown in Figure 1. <p> This type of view exhibits a high level of intention content and a high level of abstractness. Some systems such as the data structure display system Incense <ref> [Mye83] </ref>, support the creation of both low-level concrete views and highly abstract views such as the clock face described above.
Reference: [Mye90] <author> Brad A. Myers. </author> <title> Taxonomies of visual programming and program visualization. </title> <journal> Journal of Visual Languages and Computing, </journal> <volume> 1(1) </volume> <pages> 97-123, </pages> <month> March </month> <year> 1990. </year>
Reference-contexts: The matter addressed herein, however, involves the use of pictures to convey information about programs written in traditional textual languages. A good summary of the distinctions between the two can be found in <ref> [Mye90] </ref>. 2 Characterizing Program Visualizations Taxonomies of program visualization and visual programming systems already exist. Myers has developed a program visualization classification scheme using two axes: whether the systems illustrate the code, data, or algorithm of a program, and whether they are dynamic or static [Mye90]. <p> two can be found in <ref> [Mye90] </ref>. 2 Characterizing Program Visualizations Taxonomies of program visualization and visual programming systems already exist. Myers has developed a program visualization classification scheme using two axes: whether the systems illustrate the code, data, or algorithm of a program, and whether they are dynamic or static [Mye90]. Singh presents a similar scheme [Sin90]. Our classification system follows roughly from these|we utilize four classifying dimensions with two corresponding closely to Myers' two dimensions mentioned above. But we do not seek to place existing systems into labelled categories.
Reference: [Rei85] <author> Steve P. Reiss. </author> <title> Pecan: Program development systems that support multiple views. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> SE-11(3):276-285, </volume> <month> March </month> <year> 1985. </year>
Reference-contexts: For instance, a system may include views of flow-of-control such as a rendering of program subroutines as icons, a call-graph view, views of the run-time stack and dynamic links, etc., in addition to data structure views. We call these types of systems program state visualization systems. The Pecan system <ref> [Rei85] </ref>, a view of which is shown in Figure 2, contains an almost exhaustive set of views including symbol table, data type, stack, flowgraph, and expression displays.
Reference: [RMD89] <author> Steven P. Reiss, Scott Meyers, and Carolyn Duby. </author> <title> Using GELO to visualize software systems. </title> <booktitle> In Proceedings of the ACM '89 SIGGRAPH Symposium on User Interface Software and Technology, </booktitle> <pages> pages 149-157, </pages> <address> Williamsburg, VA, </address> <month> November </month> <year> 1989. </year>
Reference-contexts: Often, systems support automatic generation of displays, but they also permit viewers to modify the display as desired. The GDBX system [Bas85] provides canonical box-and-arrow displays of Pascal and C programs. It allows viewers to reposition or eliminate data structure views as desired during a debugging session. GELO <ref> [RMD89] </ref> also includes predefined data views, but it allows users to graphically specify specialized data type displays using topological constraints. It is possible to think of data structure displays that would be very difficult to generate automatically too.
Reference: [Shu88] <author> Nancy C. Shu. </author> <title> Visual Programming. </title> <publisher> Van Nostrand Reinhold, </publisher> <address> New York, NY, </address> <year> 1988. </year>
Reference-contexts: A precise descriptive scheme provides a framework for designers to describe their work and disseminate information. Another research area with a similar descriptive name to program visualization is visual programming <ref> [Cha87, Shu88] </ref>, but it differs importantly from the subject matter of this paper. Visual programming involves actual programming through the use of pictures, icons, and graphical entities. A programmer manipulates the visual entities in order to create a 2 missing) semantically meaningful computational process.
Reference: [Sin90] <author> Gurminder Singh. </author> <title> Graphical support for programming: A survey and taxonomy. </title> <editor> In T. S. Chua and T. L. Kunii, editors, </editor> <booktitle> Proceedings of CG International '90, </booktitle> <pages> pages 331-359. </pages> <publisher> Springer-Verlag, </publisher> <year> 1990. </year>
Reference-contexts: Myers has developed a program visualization classification scheme using two axes: whether the systems illustrate the code, data, or algorithm of a program, and whether they are dynamic or static [Mye90]. Singh presents a similar scheme <ref> [Sin90] </ref>. Our classification system follows roughly from these|we utilize four classifying dimensions with two corresponding closely to Myers' two dimensions mentioned above. But we do not seek to place existing systems into labelled categories. Rather, we show how different systems exhibit varying levels of the four dimensions we have identified.
Reference: [Sta90] <author> John T. Stasko. </author> <title> TANGO: A framework and system for algorithm animation. </title> <journal> Computer, </journal> <volume> 23(9) </volume> <pages> 27-39, </pages> <month> September </month> <year> 1990. </year>
Reference-contexts: The ability to debug and demonstrate a program using images, therefore, can make the programming process easier. Visualization techniques have already made a significant impact on programming language environments [AB89]. Appropriate animated images have also been used for teaching the purpose and functionality of algorithms <ref> [Bro88a, Sta90] </ref>. In this paper, we focus on graphical views of computer programs, such as illustrations of variables, code sections, the run-time stack, and program semantics. <p> Consequently, algorithm visualizations inherently provide a high level of abstractness, and they have even been defined accordingly <ref> [Sta90] </ref>. For instance, a visualization of a program performing an exhaustive search might contain a bar representing the number of unsuccessful search attempts it has made. As more unsuccessful attempts accumulate, the bar grows larger. <p> One of the earliest systems to recognize the importance of smooth transitions generates algorithm animations of Smalltalk programs by monitoring message passing [LD85]. Later program visualization systems such as Tango <ref> [Sta90] </ref> provide explicit mechanisms to help produce the in-between configuration views that typify animations. In Tango, view designers develop animations using high-level primitives that hide low-level graphics details. It is still possible, however, to generate more traditional visualization views without the in-between frames in these systems.
Reference: [Sta91] <author> John T. Stasko. </author> <title> Using direct manipulation to build algorithm animations by demonstration. </title> <booktitle> In Proceedings of the ACM SIGCHI '91 Conference on Human Factors in Computing Systems, </booktitle> <pages> pages 307-314, </pages> <address> New Orleans, LA, </address> <month> May </month> <year> 1991. </year> <month> 19 </month>
Reference-contexts: The Gestural system [Dui87] and the Dance animation editor <ref> [Sta91] </ref> both allow designers to "visually program" their desired program visualization via direct manipulation. 3 Taxonomy We believe that our method of characterizing program visualization systems provides a framework for understanding and discussing these systems in more detail than has been previously available.
References-found: 25

