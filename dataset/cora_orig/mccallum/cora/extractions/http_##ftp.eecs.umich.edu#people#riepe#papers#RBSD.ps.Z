URL: http://ftp.eecs.umich.edu/people/riepe/papers/RBSD.ps.Z
Refering-URL: http://ftp.eecs.umich.edu/people/riepe/papers/
Root-URL: http://www.eecs.umich.edu
Title: A 53-bit RBSD Parallel Array Multiplier with IEEE Double Precision Floating Point Rounding Implemented in
Author: Michael A. Riepe 
Address: 572,  
Affiliation: EECS  
Date: December 16, 1993 11:49 am  Winter 1993  
Note: DRAFT: Last Modified  this design will be compared with two other designs in the same technologya Wallace tree of 4-2 compressors, and a Booth-encoded version of the 4-2 compressor Wallace Tree. The details of the RBSD implementation, as well as the implementation of the IEEE double-precision rounding modes, will be presented.  
Abstract: This paper describes the design and implementation of an IEEE double precision parallel array multiplier. Redundant-Binary Signed-Digit (RBSD) compressors are used in a Wallace Tree to reduce the partial products. A Ling-Modified Carry-Select subtracter will be used to convert the RBSD result to a conventional NonRedundant (NR) representation. This design in being carried out in a 0.6 m m GaAs DCFL process for inclusion in a Superscalar GaAs Floating Point Unit. The simulated critical path length and die area of
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> M. Annaratone, W. Shen, </author> <title> The Design of an LSI Booth Multiplier: NMOS vs. CMOS Technology, </title> <type> CMU Technical Report CMU-CS-84-150, </type> <year> 1984. </year>
Reference-contexts: the carry-out bit can be determined directly from the input digits at that bit position, independently of the carry-in.) With the presence of the 1 digit, however, we can limit the propagation of carries to at most one bit by making the follow ing observation: in two bits, the digit <ref> [1] </ref> can be represented either as [01] or [11], and likewise the digit [1] can be represented either as [01] or [11]. <p> bit position, independently of the carry-in.) With the presence of the 1 digit, however, we can limit the propagation of carries to at most one bit by making the follow ing observation: in two bits, the digit <ref> [1] </ref> can be represented either as [01] or [11], and likewise the digit [1] can be represented either as [01] or [11]. <p> a 1 or 1, The choice of which representation to use can be based on the bit values of the input operands at bit position as follows: if both are nonnegative then there is a possible carry-in of 1, in which case we will want to represent a half-sum of <ref> [1] </ref> as [11], and a half-sum of [1] as [01], so that the 1 and 1 will cancel in the full-sum (the half-sum plus the carry-in.) Likewise, if the input operands at bit are both non-positive there is a potential carry-in of 1, so we will want to represent a half-sum <p> which representation to use can be based on the bit values of the input operands at bit position as follows: if both are nonnegative then there is a possible carry-in of 1, in which case we will want to represent a half-sum of <ref> [1] </ref> as [11], and a half-sum of [1] as [01], so that the 1 and 1 will cancel in the full-sum (the half-sum plus the carry-in.) Likewise, if the input operands at bit are both non-positive there is a potential carry-in of 1, so we will want to represent a half-sum of 1 as [01], and a half-sum <p> Given a NR number X, such that , if X is unsigned, each NR digit X is just assigned to the positive bit-field of each digit (d ), and the negative bit-field (d ) is assigned to zero. Therefore, the NR digit <ref> [1] </ref> maps to the RBSD digit [1], and NR [0] maps to RBSD [0]. This is shown in (EQ 1). (EQ 1) If the NR number is signed, its twos complement representation has the value given in (EQ 2). <p> Given a NR number X, such that , if X is unsigned, each NR digit X is just assigned to the positive bit-field of each digit (d ), and the negative bit-field (d ) is assigned to zero. Therefore, the NR digit <ref> [1] </ref> maps to the RBSD digit [1], and NR [0] maps to RBSD [0]. This is shown in (EQ 1). (EQ 1) If the NR number is signed, its twos complement representation has the value given in (EQ 2).
Reference: [2] <author> A. Avizienis, </author> <title> Signed Digit Number Representations for Fast Parallel Arithmetic, </title> <journal> IRE Trans. Electronic Computers, </journal> <volume> Vol. EC-10, </volume> <pages> pp. 389-400, </pages> <month> Sept. </month> <year> 1961. </year>
Reference-contexts: An alternate scheme from the families of carry-save compressor circuits presented above involves the use of Redundant-Binary Signed-Digit (RBSD) adders in the reduction of the partial products. These are all based on the redundant number systems proposed by Avizienis <ref> [2] </ref>, and more recently refined by Parhami [10]. These schemes have the property that they (like the 4-2 and higher-order compressor schemes) lead to highly regular layouts, and therefore are more desirable than the standard 3-2 compressor circuit.
Reference: [3] <author> C. Baugh, B. </author> <title> Wooley A Twos complement Parallel Array Multiplication Algorithm, </title> <journal> IEEE Trans. on Computers, </journal> <month> Dec. </month> <year> 1973, </year> <pages> pp. 1045-1047. </pages>
Reference: [4] <author> A. </author> <title> Booth A Signed Binary Multiplication Technique, Q. </title> <journal> J. Mech. Appl. Math. </journal> <volume> 4, </volume> <year> 1951. </year> <pages> pp. 236-240. </pages>
Reference-contexts: These results are summarized in Table 1. Many other techniques are available to the designer to further optimize the architecture. Among these are various recoding techniques based on the work of Booth <ref> [4] </ref>, often called Booth-recoding. The most common, known as Radix-4 Modified Booth-Recoding, allows a single partial product to be generated from a pair of multiplier bits. This reduces the number of carry-save adders required by 1/2, from back to .
Reference: [5] <author> G. Goto et. al. </author> <title> A 54 X 54-b Regularly Structured Tree Multiplier, </title> <booktitle> IEEE JSSC September 1992, </booktitle> <pages> pp. 1229-1236 </pages>
Reference: [6] <author> E. Hokenek, R. Montoye. </author> <title> Leading-Zero Anticipator (LZA) in the IBM RISC System/6000 Floating-Point Execution Unit, </title> <journal> IBM J. Res. Develop. </journal> <volume> Vol. 34 NO. 1, </volume> <month> January </month> <year> 1990, </year> <pages> pp. 71-77. </pages>
Reference: [7] <author> H. Makino et. al. </author> <title> A 8.8-ns 54 X 54-bit Multiplier Using New Redundant Binary Architecture, </title> <journal> IEEE Trans. </journal> <volume> ICCD, </volume> <month> October </month> <year> 1993, </year> <pages> pp. 202-205. </pages>
Reference-contexts: Architecture area delay latency (in cycles) serial O (n) O (1) O (n) array O (n parallel array O (n Wallace Tree O (n nlog nlog nlog+ nlog DRAFT: Last Modified December 16, 1993 11:49 am 8.8-ns 54x54-bit multiplier in 0.5 m CMOS <ref> [7] </ref>, the fastest yet reported. <p> For example, in the 53-bit case the 4-2 Wallace tree requires 5 levels of 4-2 com pressor levels, while the RBSD array requires 6 levels of RBSD adders. A better conversion solution was presented by Makino et. al. <ref> [7] </ref> to correct this problem. They show that two NR partial products (NRPPs) can be converted into a single RBSD partial-product (RBSDPP) simply by inverting one of the input NRPPs and adding a correction bit into the array in the appropriate place.
Reference: [8] <author> J. Mori et. al. </author> <title> A 10-ns 54x54 Parallel Structured Full Array Multiplier with 0.5 m CMOS Technology, </title> <booktitle> IEEE JSSC April 1991, </booktitle> <pages> pp. 600-605. </pages>
Reference: [9] <author> M. Nagamatsu et. al. </author> <title> A 15-ns 32x32-b CMOS Multiplier with an Improved Parallel Structure, </title> <booktitle> IEEE JSSC April 1990, </booktitle> <pages> pp. 494-497 </pages>
Reference: [10] <author> B. Parhami, </author> <title> Generalized Signed-Digit Number Systems: A Unifying Framework for Redundant Number Represen tations, </title> <journal> IEEE Trans. on Computers, </journal> <volume> Vol. 39, no. 1, </volume> <month> January </month> <year> 1990. </year>
Reference-contexts: An alternate scheme from the families of carry-save compressor circuits presented above involves the use of Redundant-Binary Signed-Digit (RBSD) adders in the reduction of the partial products. These are all based on the redundant number systems proposed by Avizienis [2], and more recently refined by Parhami <ref> [10] </ref>. These schemes have the property that they (like the 4-2 and higher-order compressor schemes) lead to highly regular layouts, and therefore are more desirable than the standard 3-2 compressor circuit.
Reference: [11] <author> N. Quach, M. Flynn, </author> <title> High Speed Addition in CMOS, </title> <institution> Stanford University Technical Report CSL-TR-90-415, </institution> <month> Feb ruary </month> <year> 1990. </year>
Reference-contexts: The imple mentation of a Wallace Tree involves the design of two major components: the carry-free adder cell, and the final carry-propagating adder. The latter has been well studied and will not be presented here. We chose to use a Ling-modified carry-select adder in our design <ref> [11] </ref>. Instead we will concentrate on the design of the carry-free adder circuit and the options available in their design. The primary requirement of a carry-free adder is the ability to reduce several -bit inputs to a smaller number of puts, without the need to propagate a carry signal. <p> the input digits at that bit position, independently of the carry-in.) With the presence of the 1 digit, however, we can limit the propagation of carries to at most one bit by making the follow ing observation: in two bits, the digit [1] can be represented either as [01] or <ref> [11] </ref>, and likewise the digit [1] can be represented either as [01] or [11]. <p> presence of the 1 digit, however, we can limit the propagation of carries to at most one bit by making the follow ing observation: in two bits, the digit [1] can be represented either as [01] or <ref> [11] </ref>, and likewise the digit [1] can be represented either as [01] or [11]. <p> or 1, The choice of which representation to use can be based on the bit values of the input operands at bit position as follows: if both are nonnegative then there is a possible carry-in of 1, in which case we will want to represent a half-sum of [1] as <ref> [11] </ref>, and a half-sum of [1] as [01], so that the 1 and 1 will cancel in the full-sum (the half-sum plus the carry-in.) Likewise, if the input operands at bit are both non-positive there is a potential carry-in of 1, so we will want to represent a half-sum of 1 <p> that the 1 and 1 will cancel in the full-sum (the half-sum plus the carry-in.) Likewise, if the input operands at bit are both non-positive there is a potential carry-in of 1, so we will want to represent a half-sum of 1 as [01], and a half-sum of 1 as <ref> [11] </ref> so that, again, a possible carry-in will can cel. These rules allow the sum and carry-out from bit position to be calculated given only the input operands at position and position , eliminating carry-rippling. <p> The location at which to add these extra 1 bits into the array can be troubling. This problem will be discussed in the implementation section. An important point to note is that this encoding technique can produce RBSD digits of <ref> [11] </ref>, which some circuits consider a dont care bit combination. Either the logic design of the RBSD adders must support the [11] digit value, or convert it into the equivalent value of [00] before it is operated on. <p> This problem will be discussed in the implementation section. An important point to note is that this encoding technique can produce RBSD digits of <ref> [11] </ref>, which some circuits consider a dont care bit combination. Either the logic design of the RBSD adders must support the [11] digit value, or convert it into the equivalent value of [00] before it is operated on. <p> This sum must be performed with a propagating adder (usu ally a carry-lookahead or carry-select adder), and the boolean equation for the carry-chain is as follows: (EQ 6) If the RBSD digit <ref> [11] </ref> is an illegal value, and guaranteed not to occur, this corresponds to the truth table shown in Table 4. This truth table can easily be seen to represent the equation , which is the equation of a simple multiplexor with the carry-in, C , as the selector input.
Reference: [12] <author> N. Quach, M. Flynn, </author> <title> Leading One PredictionImplementation, Generalization, and Application, </title> <institution> Stanford Univer sity Technical Report CSL-TR-91-483, </institution> <month> March </month> <year> 1991. </year>
Reference-contexts: Several methods have been proposed for this. We examined the method proposed by Quach & Flynn <ref> [12] </ref> which uses a technique of pattern matching similar to the Leading One/Zero Predictor (LOP/LZP) logic used in the IBM RS/6000 oating point processor.
Reference: [13] <author> M. Riepe et. al. </author> <title> A 7-nS 5 53-bit Parallel Array Multiplier Implemented in 0.6 m GaAs DCFL, </title> <note> In Preparation. </note>
Reference-contexts: This reduces the number of carry-save adders required by 1/2, from back to . However, the circuitry required for partial-product generation becomes considerably more complicated than the single AND gate required in conventional algorithms. The trade-off is implementation dependant and was examined for this technology in <ref> [13] </ref>, the results of which will be summarized here. Higher-order encodings can be used, such as Radix-8 Modified Booth Recoding, which examine 3-bits of the multiplier at a time. <p> The primary advantage of the 4-2 compressor circuit is that the tree leads to a more regular oorplan and layout. A multiplier using the 4-2 compressor circuit is presented in <ref> [13] </ref>, and will be compared with the RBSD compressor presented in this paper. Many higher-order compressor circuits are possible, including 7-3, 6-2, 9-2, 5-5-4, and 27-5 compressors. These have been exploited to construct multiplier building-blocks which can easy be tiled together into a regular layout. <p> This technique deserves a reevaluation, and will be reviewed in this paper to make a direct comparison of its performance relative to the 4-2 compressor designs already evaluated in <ref> [13] </ref>. 4 The RBSD Representation In the Redundant-Binary Signed-Digit representation, digits may take on the value -1, hereafter written as 1, as well as the values 1 and 0. The presence of three digit values will require at least two bits to represent each digit. <p> We currently use the same modified-Ling adder in the final RBSD to NR conversion as was reported in <ref> [13] </ref>. 5 54 x 54-bit RBSD Array Multiplier Implementation In this section we discuss the implementation of a 53 x 53-bit RBSD parallel array multiplier prototyped for the purpose of evaluating its relative performance to that of two other array multipliers that have already been evaluated. <p> The goal is to produce a rounded and normalized 53-bit product in under 8nS, two clock cycles in the 150MHz AuroraIII oating point unit. Two other Array multiplier architectures were prototyped in <ref> [13] </ref>: both used a Wallace tree of 4-2 compressors cells, one used radix-4 booth encoding, and one did not. <p> All recent work using RBSD adders use the radix-4 Booth encoding to reduce the size of the partial-product array. However, in <ref> [13] </ref> we demonstrate that (at least in GaAs) Booth encoding adds enough complexity to the design that the multiplier is actually larger and slower than without Booth encoding. Therefore we chose not to use Booth encoding in this design. <p> will improve on the 4-2 adder design, and it may be unnecessary to complete the logic design to rule out this architecture. 5.4 Comparison With Other Algorithms In this section we compare the prototype implementation of the RBSD parallel array multiplier with two prototype implementations already completed, and reported in <ref> [13] </ref>: a booth-encoded parallel array using 4-2 compressor cells, and a non-booth-encoded implementation of the same array. All three prototypes were designed using the same methodology, and all in the same 0.6 m GaAs DCFL process, so comparisons can be made directly.
Reference: [14] <author> R. Sadler et. al. </author> <title> High-Speed GaAs Multipliers Fabricated with a High-Yield 0.4 m Process, </title> <journal> IEEE Trans. on Electron Devices, </journal> <month> September </month> <year> 1993, </year> <pages> pp. 1578-1582. </pages>
Reference: [15] <author> M. Santoro, </author> <title> Design and Clocking of VLSI Multipliers, </title> <institution> Stanford University Technical Report CSL-TR-89-397, </institution> <month> October </month> <year> 1989. </year>
Reference-contexts: Notice that the carry does not propagate across the row, only downward through multiple stages of compressor rows. A Wallace tree of 3-2 compressors would thus be of height Currently, one of the most popular compressor designs is a recent development known as the 4-2 compressor <ref> [15] </ref>, which reduces 4 inputs to 2, for a tree height of . The height of the tree is smaller with the 4-2 compressor, but the 4-2 compressor circuit is more complex than a full adder, so the trade-off is implementation dependant. <p> We will begin by implementing the round-to-nearest/even scheme, since it is the most difficult, and then show what is required to extend this to the other rounding modes. The implementation presented here is based on an implementation described by Santoro <ref> [15] </ref>, but with a new technique which simplifies the logic considerably. The primary goal of the implementation is to maximize speed and minimize the extra hardware required. <p> Several methods have been proposed for this. We examined the method proposed by Quach & Flynn [12] which uses a technique of pattern matching similar to the Leading One/Zero Predictor (LOP/LZP) logic used in the IBM RS/6000 oating point processor. It was also pointed out by Santoro <ref> [15] </ref> that the number of trailing zeros will be equal to the number of trailing zeros in the multiplicand, plus the number in the multiplier, and this can be compared to see if it is greater than 51. <p> If the low-order carry-chain did not have to be implemented these pattern matching tech niques might be a win, but here they are probably not. The most elegant solution was also proposed by Santoro <ref> [15] </ref>. This method computes the sticky bit by taking the logical OR of all of the two rows of input bits to the low 50-bits of the adder.
Reference: [16] <author> P. Song, G. </author> <title> De Micheli Circuit and Architecture Trade-offs for High-Speed Multiplication. </title> <journal> IEEE JSSC, </journal> <volume> Vol. 26, no. 9, </volume> <month> Sept. </month> <year> 1991. </year>
Reference-contexts: These have been exploited to construct multiplier building-blocks which can easy be tiled together into a regular layout. In addition, a circuit constructed from 9-2 counters has been shown to require 1.5 fewer equivalent 3-2 adder delays than one constructed from 4-2 counters <ref> [16] </ref> (assuming the 4-2 compressor is constructed from two cascaded 3-2 counters, as is often the case). An alternate scheme from the families of carry-save compressor circuits presented above involves the use of Redundant-Binary Signed-Digit (RBSD) adders in the reduction of the partial products.
Reference: [17] <author> N. Takagi, </author> <title> High-Speed VLSI Multiplication Algorithm with a Redundant Binary Addition Tree, </title> <journal> IEEE Trans. on Computers, </journal> <volume> Vol. c-34, no. 9, </volume> <month> Sept. </month> <year> 1985. </year> <title> DRAFT: Last Modified December 16, </title> <address> 1993 11:49 am </address>
Reference-contexts: These schemes have the property that they (like the 4-2 and higher-order compressor schemes) lead to highly regular layouts, and therefore are more desirable than the standard 3-2 compressor circuit. The original RBSD work <ref> [17] </ref> is older than that of the 4-2 compressor, and its implementation is often more complex, however recent work has improved on the design of the RBSD array and uncovered some useful properties which have been exploited to construct an Table 1. <p> This property was the original driving force behind the development of this algorithm and has been successfully implemented <ref> [17] </ref>. The development of the 4-2 compressor, however, allowed for the construction of regular arrays using carry-save addition as well.
Reference: [18] <author> VITESSE Semiconductor Corporation, </author> <title> 1992 Product Data Book, </title> <booktitle> p. </booktitle> <pages> 8-36. </pages>
Reference: [19] <author> C. </author> <title> Wallace A Suggestion for a Fast Multiplier, </title> <journal> IEEE Trans. Electronic Computers. </journal> <volume> EC-13, </volume> <year> 1964. </year> <pages> pp. 14-17. </pages> <note> DRAFT: Last Modified December 16, 1993 11:49 am </note>
Reference-contexts: Partial products can be summed pairwise and in parallel using a tree structure of adders. This increases the number of adders needed to 2 n , but decreases the delay to without the need for fast adders. An additional optimization, the Wallace Tree <ref> [19] </ref>, makes use of carry-free adders in the tree, instead of ripple-carry adders, to sum all partial-product bits of the same significance without carry propagation. The traditional Wallace Tree design uses the redundant carry-save adder circuit to achieve carry-free addition.
References-found: 19

