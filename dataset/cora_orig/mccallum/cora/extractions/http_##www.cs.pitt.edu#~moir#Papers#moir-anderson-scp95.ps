URL: http://www.cs.pitt.edu/~moir/Papers/moir-anderson-scp95.ps
Refering-URL: http://www.cs.pitt.edu/~moir/papers.html
Root-URL: 
Title: Wait-Free Algorithms for Fast, Long-Lived Renaming  
Author: Mark Moir and James H. Anderson 
Date: August 1994; revised February 1995  
Address: Chapel Hill, North Carolina 27599-3175, USA  
Affiliation: Department of Computer Science The University of North Carolina at Chapel Hill  
Abstract: In the classic "one-time" renaming problem, processes are required to choose new names in order to reduce the size of their name space. We introduce a new, more general version of the renaming problem called "long-lived" renaming, in which processes may repeatedly acquire and release names. We also present several wait-free algorithms for both one-time and wait-free renaming on shared-memory multiprocessing systems. Previous wait-free renaming algorithms have time complexity that is dependent on the size of the original name space. In contrast, most of our algorithms have time complexity that is independent of the size of the original name space.
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> J. Anderson and M. Moir, </author> <title> "Using k-Exclusion to Implement Resilient, Scalable Shared Objects", </title> <booktitle> Proceedings of the 13th Annual ACM Symposium on Principles of Distributed Computing, </booktitle> <month> August </month> <year> 1994, </year> <pages> pp. 141-150. </pages>
Reference-contexts: This is the essence of an approach we previously presented for the implementation of resilient, scalable shared objects <ref> [1] </ref>. This approach only restricts the number of processes that access the implementation concurrently. Over time, many processes may access the implementation. <p> Over time, many processes may access the implementation. Thus, it is not sufficient to simply acquire a name once and retain that name for future use: a process must be able to release its name so that another process may later acquire the same name. In <ref> [1] </ref>, a simple long-lived renaming algorithm is presented in order to address this issue. To our knowledge, this is the only previous work on long-lived renaming. In this paper, we present several new long-lived renaming algorithms, one of which is a generalization of the algorithm presented in [1]. <p> In <ref> [1] </ref>, a simple long-lived renaming algorithm is presented in order to address this issue. To our knowledge, this is the only previous work on long-lived renaming. In this paper, we present several new long-lived renaming algorithms, one of which is a generalization of the algorithm presented in [1]. In the first part of the paper, we present renaming algorithms that use only atomic read and write instructions. It has been shown that if M &lt; 2k 1, then M -renaming cannot be implemented in a wait-free manner using only atomic reads and writes [7]. <p> An example is shown in Figure 7 for b = 4 and k = 10. In this figure, process p releases name 1 by executing clr bit (X [0]; 1) and process q acquires name 5 by executing set first zero (X <ref> [1] </ref>). Because each process tests the available names in segments, and because processes may release and acquire names concurrently, it may seem possible for a process to reach the last segment when none of the names in that segment are available. <p> For process q, q@1 ^ q:h = 1 holds, so q is about to execute set first zero (X <ref> [1] </ref>). As X [1][1] is the first clear bit in X [1], q:1 will establish q@2 ^ q:h = 2 ^ q:v = 1, and will therefore acquire name 5. (b) Process p has released name 1 and process q has acquired name 5. long-lived bk=2c-renaming for the left group, which <p> For process q, q@1 ^ q:h = 1 holds, so q is about to execute set first zero (X <ref> [1] </ref>). As X [1][1] is the first clear bit in X [1], q:1 will establish q@2 ^ q:h = 2 ^ q:v = 1, and will therefore acquire name 5. (b) Process p has released name 1 and process q has acquired name 5. long-lived bk=2c-renaming for the left group, which are inductively assumed to be correct.
Reference: [2] <author> H. Attiya, A. Bar-Noy, D. Dolev, D. Koller, D. Peleg, and R. Reischuk, </author> <title> "Achievable Cases in an Asynchronous Environment", </title> <booktitle> Proceedings of the 28th Annual IEEE Symposium on Foundations of Computer Science, </booktitle> <month> October </month> <year> 1987, </year> <pages> pp. 337-346. </pages>
Reference-contexts: 1 Introduction In the M renaming problem <ref> [2] </ref>, each of k processes is required to choose a distinct value, called a name, that ranges over f0; :::; M 1g. Each process is assumed to have a unique process identifier ranging over f0; :::; N 1g. It is further required that k M &lt; N . <p> By first using an efficient renaming algorithm to reduce the size of the name space, the time complexity of that computation can be made independent of the size of the original name space. The renaming problem has been studied previously for both message-passing <ref> [2] </ref> and shared-memory multiprocessing systems [3, 5]. In this paper, we consider wait-free implementations of renaming in asynchronous, shared-memory systems. A renaming algorithm is wait-free iff each process is guaranteed to acquire a name after a finite number of that process's steps, even if other processes halt undetectably.
Reference: [3] <author> A. Bar-Noy and D. Dolev, </author> <title> "Shared Memory versus Message-Passing in an Asynchronous Distributed Environment", </title> <booktitle> Proceedings of the 8th Annual ACM Symposium on Principles of Distributed Computing, </booktitle> <month> August </month> <year> 1989, </year> <pages> pp. 307-318. </pages>
Reference-contexts: By first using an efficient renaming algorithm to reduce the size of the name space, the time complexity of that computation can be made independent of the size of the original name space. The renaming problem has been studied previously for both message-passing [2] and shared-memory multiprocessing systems <ref> [3, 5] </ref>. In this paper, we consider wait-free implementations of renaming in asynchronous, shared-memory systems. A renaming algorithm is wait-free iff each process is guaranteed to acquire a name after a finite number of that process's steps, even if other processes halt undetectably. <p> Authors' e-mail addresses: fmoir,andersong@cs.unc.edu. A preliminary version [9] of this paper was presented at the Eighth InternationalWorkshop on Distributed Algorithms, Terschelling, The Netherlands, September, 1994. 1 Reference M Time Complexity Long-Lived? <ref> [3] </ref> k (k + 1)=2 fi (N k) No [5] 2k 1 fi (N k 2 ) No Thm. 2 2k 1 fi (k 4 ) No Table 1: A comparison of wait-free M -renaming algorithms that employ only atomic reads and writes. using long-lived renaming to acquire a name from <p> It has been shown that if M &lt; 2k 1, then M -renaming cannot be implemented in a wait-free manner using only atomic reads and writes [7]. Wait-free, read/write algorithms for one-time renaming that yield an optimal name space of size M = 2k 1 have been proposed in <ref> [3, 5] </ref>. However, in these algorithms, the time complexity of choosing a name is dependent on N , the size of the original name space.
Reference: [4] <institution> BBN Advanced Computers, Inside the TC2000 Computer, </institution> <month> February, </month> <year> 1990. </year>
Reference-contexts: BBN TC2000 multiprocessor <ref> [4] </ref>. The clr bit (X; i) operation clears the ith bit of the b-bit shared variable X. For b = 1, clr bit is a simple write operation. For b &gt; 1, clr bit can be implemented, for example, using the fetch and and operation available on the BBN TC2000. <p> The first algorithm uses set first zero and clr bit to access shared, b-bit variables and has time complexity fi (k=b). As discussed in Section 1, these operations can be implemented, for example, using operations available on the BBN TC2000 <ref> [4] </ref>. The second algorithm in this section has time complexity fi (log k) | a significant improvement over the first algorithm. To achieve this improvement, this algorithm uses the bounded decrement operation.
Reference: [5] <author> E. Borowsky and E. Gafni, </author> <title> "Immediate Atomic Snapshots and Fast Renaming", </title> <booktitle> Proceedings of the 12th Annual ACM Symposium on Principles of Distributed Computing, </booktitle> <month> August </month> <year> 1993, </year> <pages> pp. 41-50. </pages>
Reference-contexts: By first using an efficient renaming algorithm to reduce the size of the name space, the time complexity of that computation can be made independent of the size of the original name space. The renaming problem has been studied previously for both message-passing [2] and shared-memory multiprocessing systems <ref> [3, 5] </ref>. In this paper, we consider wait-free implementations of renaming in asynchronous, shared-memory systems. A renaming algorithm is wait-free iff each process is guaranteed to acquire a name after a finite number of that process's steps, even if other processes halt undetectably. <p> Authors' e-mail addresses: fmoir,andersong@cs.unc.edu. A preliminary version [9] of this paper was presented at the Eighth InternationalWorkshop on Distributed Algorithms, Terschelling, The Netherlands, September, 1994. 1 Reference M Time Complexity Long-Lived? [3] k (k + 1)=2 fi (N k) No <ref> [5] </ref> 2k 1 fi (N k 2 ) No Thm. 2 2k 1 fi (k 4 ) No Table 1: A comparison of wait-free M -renaming algorithms that employ only atomic reads and writes. using long-lived renaming to acquire a name from a reduced name space. <p> It has been shown that if M &lt; 2k 1, then M -renaming cannot be implemented in a wait-free manner using only atomic reads and writes [7]. Wait-free, read/write algorithms for one-time renaming that yield an optimal name space of size M = 2k 1 have been proposed in <ref> [3, 5] </ref>. However, in these algorithms, the time complexity of choosing a name is dependent on N , the size of the original name space. <p> We start by presenting a one-time (k (k + 1)=2)-renaming algorithm that has fi (k) time complexity. We then describe how this algorithm can be combined with previous results <ref> [5] </ref> to obtain a (2k 1)-renaming algorithm with fi (k 4 ) time complexity. It has been shown that renaming is impossible for fewer than 2k 1 names when using only reads and writes so, with respect to the size of the resulting name space, this algorithm is optimal. <p> Using the algorithm recently presented by Borowsky and Gafni in <ref> [5] </ref>, k processes can reduce the size of their name space from N to 2k 1 with time complexity fi (N k 2 ).
Reference: [6] <author> C. A. R. Hoare, </author> <title> "An Axiomatic Basis for Computer Programming", </title> <journal> Communications of the ACM 12, </journal> <month> October </month> <year> 1969, </year> <pages> pp. </pages> <month> 576-580,583. </month>
Reference-contexts: Symbols in parentheses have the same binding power. We sometimes use parentheses to override these binding rules. We sometimes use Hoare triples <ref> [6] </ref> to denote the effects of a statement execution. 2 In the one-time M -renaming problem, each of k processes, with distinct process identifiers ranging over f0; :::; N 1g, chooses a distinct value ranging over f0; :::; M 1g.
Reference: [7] <author> M. Herlihy and N. Shavit, </author> <title> "The Asynchronous Computability Theorem for t-Resilient Tasks", </title> <booktitle> Proceedings of the 25th ACM Symposium on Theory of Computing, </booktitle> <year> 1993, </year> <pages> pp. 111-120. </pages>
Reference-contexts: In the first part of the paper, we present renaming algorithms that use only atomic read and write instructions. It has been shown that if M &lt; 2k 1, then M -renaming cannot be implemented in a wait-free manner using only atomic reads and writes <ref> [7] </ref>. Wait-free, read/write algorithms for one-time renaming that yield an optimal name space of size M = 2k 1 have been proposed in [3, 5]. However, in these algorithms, the time complexity of choosing a name is dependent on N , the size of the original name space. <p> Combining the two algorithms, k processes can reduce the size of their name space from N to 2k 1 with time complexity fi (k) +fi ((k (k +1)=2)k 2 ) = fi (k 4 ). Thus, we have the following result. By results of Herlihy and Shavit <ref> [7] </ref>, this algorithm is optimal with respect to the size of the name space. <p> By using read-modify-write operations, these algorithms significantly improve upon the performance of the algorithms in the previous section. Furthermore, these algorithms yield a name space of size k, which is clearly optimal (the lower bound results of Herlihy and Shavit <ref> [7] </ref> do not apply to algorithms that employ read-modify-write operations). The first algorithm uses set first zero and clr bit to access shared, b-bit variables and has time complexity fi (k=b).
Reference: [8] <author> L. Lamport, </author> <title> "A Fast Mutual Exclusion Algorithm", </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> Vol. 5, No. 1, </volume> <month> February </month> <year> 1987, </year> <pages> pp. 1-11. </pages>
Reference-contexts: In contrast to prior algorithms, our one-time renaming algorithms have time complexity that depends only on k, the number of participating processes. These algorithms employ a novel technique that uses "building blocks" based on the "fast path" mechanism employed by Lamport's fast mutual exclusion algorithm <ref> [8] </ref>. Our read/write algorithm for long-lived renaming algorithm uses a modified version of the one-time building block that allows processes to "reset" the building block so that it may be used repeatedly. Unfortunately, this results in time complexity that is dependent on N . <p> The code fragment shown in Figure 2 shows how the building block can be implemented using atomic read and write operations. The technique employed is essentially that of the "fast path" mechanism used in Lamport's fast mutual exclusion algorithm <ref> [8] </ref>. A process that stops corresponds to a process successfully "taking the fast path" in Lamport's algorithm. <p> This is an important practical advantage because contention should be low in most well-designed applications <ref> [8] </ref>. The algorithm in Figure 8 has time complexity that is logarithmic in k, regardless of the level of contention. There are several questions left open by our research.
Reference: [9] <author> M. Moir and J. Anderson, </author> <title> "Fast, Long-Lived Renaming", </title> <booktitle> Proceedings of the 8th International Workshop on Distributed Algorithms, </booktitle> <month> September, </month> <year> 1994, </year> <pages> pp. 141-155. 14 </pages>
Reference-contexts: For such implementations, performance can be improved by restricting the number of processes that concurrently access the implementation, and by fl Work supported, in part, by NSF Contract CCR-9216421. Authors' e-mail addresses: fmoir,andersong@cs.unc.edu. A preliminary version <ref> [9] </ref> of this paper was presented at the Eighth InternationalWorkshop on Distributed Algorithms, Terschelling, The Netherlands, September, 1994. 1 Reference M Time Complexity Long-Lived? [3] k (k + 1)=2 fi (N k) No [5] 2k 1 fi (N k 2 ) No Thm. 2 2k 1 fi (k 4 ) No
References-found: 9

