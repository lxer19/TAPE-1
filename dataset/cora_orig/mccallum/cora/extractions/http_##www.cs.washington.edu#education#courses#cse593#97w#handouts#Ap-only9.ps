URL: http://www.cs.washington.edu/education/courses/cse593/97w/handouts/Ap-only9.ps
Refering-URL: http://www.cs.washington.edu/education/courses/cse593/97w/
Root-URL: 
Title: Persistent Applications Using Generalized Redo Recovery  
Author: David B. Lomet 
Date: March 10, 1997  
Address: Redmond, WA 98052  
Affiliation: Microsoft Corporation  
Abstract: We describe a new way, using database style recovery, to enable application programs to persist across system crashes. Previous efforts have been based on frequent application checkpointing and/or the logging of application reads, both of which are very expensive. We include application state as a cached object and map application execution to loggable operations which fit into the recovery framework described in [15]. Our logged application operations are logical operations, not physical operations that require writing the entire state, and hence their log records are small. We describe a cache manager that can handle the flush order dependencies introduced by these application operations and a recovery process that can successfully restore application state by replaying the application. The result is application recovery that integrates with database recovery and can be mostly done while neither logging values read nor frequently flushing application state. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Bartlett, J. </author> <title> A NonStop* Kernel. </title> <booktitle> Proc. ACM Symp. on Operating System Principles(1981) 22-29. </booktitle>
Reference-contexts: When the entire application state is contained in recoverable storage, each update to application state, however small, is logged to keep the state recoverable. * Write persistent application checkpoints (which capture the entire process image of the application) at every resource manager interaction <ref> [1, 5, 6] </ref>.
Reference: [2] <author> Bernstein, P., Hadzilacos, V., and Goodman, N. </author> <title> Concurrency Control and Recovery in Database Systems Addison Wesley (1987) Reading, </title> <address> MA </address>
Reference-contexts: Inverting the installation order of these operations makes the persistent store non-recoverable. "Complex" log operations like these require careful write order to remain recoverable. One way to ensure that operations can be replayed is to "install" their effects into the stable state in serialization (conflict graph) order <ref> [2] </ref>. However, this is overkill as we can ignore: write-read edges: A second (reading) operation O 2 can be installed without interfering with the replay of the first (writing) operation O 1 .
Reference: [3] <author> Bernstein, P., Hsu, M., and Mann, B. </author> <title> Implementing Recoverable Requests Using Queues. </title> <booktitle> Proc. ACM SIGMOD Conf.(May, </booktitle> <address> 1990) Atlantic City, NJ 112-122 </address>
Reference-contexts: After the transaction commits, the application returns to the initial state. * Keep application state small and write it in its entirety to a recoverable resource manager when required, e.g. database or recoverable queue <ref> [3] </ref>. This is facilitated by the use of a scripting language for the application [4, 18].
Reference: [4] <author> Bernstein, P., Gyllstrom, P. and Wimberg, T. </author> <title> STDL A Portable Language for Transaction Processing. </title> <booktitle> Proc. Very Large Databases Conf.(Sept. </booktitle> <address> 1993) Dublin, Ireland 218-229. </address>
Reference-contexts: After the transaction commits, the application returns to the initial state. * Keep application state small and write it in its entirety to a recoverable resource manager when required, e.g. database or recoverable queue [3]. This is facilitated by the use of a scripting language for the application <ref> [4, 18] </ref>. The script language interpreter stores the entire application state at well chosen times so that application execution can continue from the saved state after a crash. * Use a persistent programming language that logs updates to a persistent (recoverable) storage [11, 8].
Reference: [5] <author> Borg, A., Baumbach, J. and Glazer, S. </author> <title> A Message System Supporting Fault Tolerance. </title> <booktitle> Proc. ACM Symp. on Operating System Principles(Oct. </booktitle> <address> 1983) Bretton Woods, NH 90-99. </address>
Reference-contexts: When the entire application state is contained in recoverable storage, each update to application state, however small, is logged to keep the state recoverable. * Write persistent application checkpoints (which capture the entire process image of the application) at every resource manager interaction <ref> [1, 5, 6] </ref>.
Reference: [6] <author> Borg, A., Blau, W.. and Graetsch, W. </author> <title> Fault Tolerance Under UNIX ACM Trans. </title> <journal> on Computer Systems 7,1 (Feb. </journal> <year> 1989) </year> <month> 1-24. </month>
Reference-contexts: When the entire application state is contained in recoverable storage, each update to application state, however small, is logged to keep the state recoverable. * Write persistent application checkpoints (which capture the entire process image of the application) at every resource manager interaction <ref> [1, 5, 6] </ref>.
Reference: [7] <author> Borr, A. </author> <title> Transaction Monitoring in Encompass *: Reliable and Distributed Transaction Processing. </title> <booktitle> Proc. Very Large Databases Conf.(Sept. </booktitle> <address> 1981) Cannes, France 155-165. </address>
Reference: [8] <author> Chang, A., and Mergen, M. </author> <title> 801 Storage: Architecture and Programming. </title> <journal> ACM Trans. on Computer Systems 6,1 (Feb. </journal> <year> 1988) </year> <month> 28-50. 15 </month>
Reference-contexts: The script language interpreter stores the entire application state at well chosen times so that application execution can continue from the saved state after a crash. * Use a persistent programming language that logs updates to a persistent (recoverable) storage <ref> [11, 8] </ref>. When the entire application state is contained in recoverable storage, each update to application state, however small, is logged to keep the state recoverable. * Write persistent application checkpoints (which capture the entire process image of the application) at every resource manager interaction [1, 5, 6].
Reference: [9] <author> Eppinger, J., Mummert, L., and Spector, A. Camelot and Avalon: </author> <title> A Distributed Transaction Facility Morgan Kauf- mann (1991) San Mateo, </title> <address> CA </address>
Reference: [10] <author> Gray, J. and Reuter, A. </author> <title> Transaction Processing: Concepts and Techniques. </title> <publisher> Morgan Kaufmann (1993) San Mateo, </publisher> <address> CA </address>
Reference-contexts: This paper explores this mapping of application execution to log operations and the recovery mechanism extensions needed for them. 1 1.2 Existing Techniques Existing ways to deal with application executions interrupted by system crashes have difficulties that restrict their use fulness. * Make applications "stateless" <ref> [10] </ref>. Between transactions, the application is in a state deterministically derived from its initial state. If the application fails between transactions, the application state can be re-created from its stably stored initial state. <p> In particular, the primary RM can log application reads as state transitions instead of needing to log the entire data value read (see Section 2). The functionality we seek is that of persistent save points <ref> [10] </ref>. With persistent save points, transactions do not have to be rolled back when crashes interrupt their execution. Rather, they can continue to execute as though the crash had merely delayed the execution. <p> Hence cache management, during both normal operation and recovery, need respect only read-write installation edges. 3.2 The Write Graph The CM keeps the stable state recoverable by flushing cached objects so that operations are installed in installation graph order. Most database systems log only page-oriented operations <ref> [10, 17] </ref>. This permits flushing pages in arbitrary order as the installation graph edges connect only operations of a single page. Flushing the page installs all operations with earlier updates to that page.
Reference: [11] <author> Haskin, R., Malachi, Y., Sawdon, W. and Chan, G. </author> <title> Recovery Management in QuickSilver. </title> <journal> ACM Trans. on Computer Systems 6,1 (Feb. </journal> <year> 1988) </year> <month> 82-108. </month>
Reference-contexts: The script language interpreter stores the entire application state at well chosen times so that application execution can continue from the saved state after a crash. * Use a persistent programming language that logs updates to a persistent (recoverable) storage <ref> [11, 8] </ref>. When the entire application state is contained in recoverable storage, each update to application state, however small, is logged to keep the state recoverable. * Write persistent application checkpoints (which capture the entire process image of the application) at every resource manager interaction [1, 5, 6].
Reference: [12] <author> Hsu, M. </author> <note> (ed) Special Issue on Workflow and Extended Transaction Systems. Bulletin of the Technical Committee on Data Engineering 16,2 (June 1993) </note>
Reference-contexts: When an application is simple and short, this is of little consequence. For example, the debit/credit application has little to recover that is not already captured by the database state. But this isn't always the case. Stateful applications, such as workflow systems <ref> [12, 13] </ref>, may need to be re-scheduled manually. They may span multiple database transactions. After a crash, system state may contain an incomplete execution of the application. Cleanly coping with partial application executions is very difficult. Applications usually cannot be re-executed as the partial execution has altered the state.
Reference: [13] <author> Hsu, M. </author> <note> (ed) Special Issue on Workflow Systems. Bulletin of the Technical Committee on Data Engineering 18,1 (March 1995) </note>
Reference-contexts: When an application is simple and short, this is of little consequence. For example, the debit/credit application has little to recover that is not already captured by the database state. But this isn't always the case. Stateful applications, such as workflow systems <ref> [12, 13] </ref>, may need to be re-scheduled manually. They may span multiple database transactions. After a crash, system state may contain an incomplete execution of the application. Cleanly coping with partial application executions is very difficult. Applications usually cannot be re-executed as the partial execution has altered the state.
Reference: [14] <author> Lomet, D. </author> <title> Application Recovery with Logical Write Operations. </title> <note> (Technical Report in preparation) 1996 </note>
Reference-contexts: Needing to flush multiple variables atomically is a major complication. Hence we do not pursue logical writes here. Their big advantage, avoiding logging the data value written to an object, causes us to pursue this further in <ref> [14] </ref>. 2. Physical write (W P (O j )) and physiological write (W P L (O j )): Both physical and physiological writes can be replayed to re-create state O j of O without replaying an application, an advantage. <p> To handle writes as "logical" operations requires that we deal with circular flush dependencies. Such dependencies lead to the need to flush several objects in the same atomic flush. This is impossible in many systems, and is always inconvenient. In <ref> [14] </ref>, we show how to deal with this situation so as to avoid multi-object atomic flushes. We then can log logical writes that do not require the logging of the entire value written. This is a further substantial reduction in the recovery overhead during normal operation.
Reference: [15] <author> Lomet, D. and Tuttle, M. </author> <title> Redo Recovery after System Crashes. </title> <booktitle> Proc. Very Large Databases Conf.(Sept. </booktitle> <address> 1995) Zurich, Switzerland 457-468. </address>
Reference-contexts: To handle the more complex application operations, we base our resource manager on the theory developed in <ref> [15] </ref>. The RM doesn't overwrite objects it manages that are read by an application until after the application's state has been flushed (written to the stable system state). Controlling when objects are flushed enables us to control when application states need to be flushed. <p> In section 2, we show how it is possible to handle application state as a persistent object and to decompose application execution into a series of log operations that can be replayed during recovery. Section 3 provides a short summary of the redo recovery framework of <ref> [15] </ref>. This framework identifies what is required of a resource manager to provide recovery for the 3 more complex application operations. Section 4 then describes the enhanced resource manager needed for application recovery. <p> Finally, we summarize what has been accomplished and point to research that further reduces logging cost in section 5. 2 Applications Like the distinction between operation and operation invocation that was made in <ref> [15] </ref>, we need to distinguish an application (the executable code for the application) from its invocation (its runtime instantiation). When we refer in the sequel to application, we will normally mean application invocation, and for application state, the application invocation's state. <p> Thus, application state (and other large object values) have a pointer indirection to permit atomic installation. Testable State During recovery, the system must decide whether to replay a logged operation or to bypass it. It uses a REDO test <ref> [15] </ref> to determine whether an operation is installed or not. If uninstalled, the operation is replayed Otherwise, it can be bypassed. We make each application A's state testable for this purpose. <p> It is only these reads that introduce the extra complexity of a flush dependency between two objects, O and A. 3 Recovery Framework We simplify the system model of <ref> [15] </ref> and describe the units of update and recovery only in terms of operations. (In full generality, an operation may update several variables (objects), and only some of the variables updated may have been flushed when the system crashes.) Our operations all modify but a single object. <p> For application recovery, operations are page-oriented, where we generalize "page" to "variable" or "object", except for R (A; O). Because of reads, our CM enforces a more careful order in which it flushes objects to provide the required installation ordering. Figure 3 is an example of this. In <ref> [15] </ref>, a write graph W is defined as an acyclic graph derived from the installation graph which orders the flushing of objects. <p> (N ) set of variables read by operations in ops (N ) f irstr (N A ; O) first value (or SI) of O read by an operation of ops (N A ) Table 2: Introduced notation How we translate from installation graph to write graph is described abstractly in <ref> [15] </ref>. We describe in Section 4 concretely how to do this in an RM that can handle application recovery. <p> The write graph needed for application recovery is not that simple. Our CM incrementally maintains the active part of a non-trivial write graph as new operations are executed, unlike creating the entire write graph de novo from the installation graph as described in <ref> [15] </ref>. 4.1.1 Flush Dependencies We use the term flush dependency to refer to the relationship between O and A whenever there is an uninstalled read R (A; O) of O by A. At the time of the read this is a potential flush dependency. <p> Hence, no flush dependency cycles form among the variables during the construction of the write graph. This avoids the merging of write graph nodes from the "collapse" present in the write graph construction algorithm of <ref> [15] </ref>. Because all our operations write to exactly one variable, all nodes n of the write graph have exactly one variable in vars (n). Hence, we identify write graph nodes with variables. The write graph node n for which vars (n) = O is denoted as N O .
Reference: [16] <author> Lomet, D. and Tuttle, M. </author> <title> A Formal Treatment of Redo Recovery with Pragmatic Implications. </title> <institution> Cambridge Research Lab, Cambridge, </institution> <note> MA.(in preparation) </note>
Reference: [17] <author> Mohan, C., Haderle, D., Lindsay, B., Pirahesh, H., and Schwarz, P. </author> <title> ARIES: A transaction recovery method supporting fine-granularity locking and partial rollbacks using write-ahead logging. </title> <journal> ACM Trans. on Database Systems 17,1 (Mar. </journal> <year> 1992) </year> <month> 94-162. </month>
Reference-contexts: Hence cache management, during both normal operation and recovery, need respect only read-write installation edges. 3.2 The Write Graph The CM keeps the stable state recoverable by flushing cached objects so that operations are installed in installation graph order. Most database systems log only page-oriented operations <ref> [10, 17] </ref>. This permits flushing pages in arbitrary order as the installation graph edges connect only operations of a single page. Flushing the page installs all operations with earlier updates to that page. <p> Here we focus on rebuilding the cache and ignore transactional issues and hence the undo recovery pass. We consider two passes, analysis and redo. Analysis Phase We first perform an analysis pass on the log <ref> [17] </ref>. We do not use this pass to determine incomplete transactions, but to make repeating history (i.e. redo recovery) efficient by isolating redo recovery to only those objects that have uninstalled operations. The analysis pass rebuilds the object table, which is analogous to the ARIES dirty pages table.
Reference: [18] <author> Salzberg, B. and Tombroff, D. DSDT: </author> <title> Durable scripts containing database transactions. </title> <booktitle> Proc. Int'l Conf. on Data Engineering(Feb. </booktitle> <address> 1996) New Orleans, LA 624-633. </address>
Reference-contexts: After the transaction commits, the application returns to the initial state. * Keep application state small and write it in its entirety to a recoverable resource manager when required, e.g. database or recoverable queue [3]. This is facilitated by the use of a scripting language for the application <ref> [4, 18] </ref>. The script language interpreter stores the entire application state at well chosen times so that application execution can continue from the saved state after a crash. * Use a persistent programming language that logs updates to a persistent (recoverable) storage [11, 8].
Reference: [19] <author> Strom, R. and Yemini, S. </author> <title> Optimistic Recovery in Distributed Systems ACM Trans. </title> <booktitle> on Computer Systems 3,3 (Aug. </booktitle> <year> 1985) </year> <month> 204-226. </month>
Reference-contexts: Of particular concern is how much information needs to be logged, and how frequently the (potentially large) application state needs to be flushed. Each of the techniques above have at least one of these difficulties. 1.3 Application Replay In our approach, like that of <ref> [19] </ref>, application actions are logged during normal execution and are replayed during recovery. This reduces overhead for normal execution while putting more of the overhead on the recovery process itself since now parts of the applications need to be re-executed during recovery. This is justifiable pragmatically because crashes are rare. <p> This is justifiable pragmatically because crashes are rare. Recovery cost is controllable by log checkpoint frequency, exactly as done for database recovery. Unlike <ref> [19] </ref>, we exploit database style recovery. A resource manager or RM (e.g., a database system) keeps two versions of actively used objects, a current cached version and a stable version. It controls when versions of objects in the stable system state are overwritten (i.e. when their cached versions are flushed). <p> The result is much more cost-effective support of persistent applications. We can replay the application over larger execution intervals, reducing the frequency of application flushes. And we can avoid logging most of the values of objects that are read (unlike in <ref> [19] </ref>). Instead, we keep the versions of objects needed for replay available by not overwriting their stable versions. 1.4 Logged Operations Operations are atomic if they are serializable. This is important as we will replay them in the order in which they appear on the log.
References-found: 19

