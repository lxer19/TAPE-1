URL: ftp://theory.lcs.mit.edu/pub/tds/simulations1.ps.gz
Refering-URL: http://theory.lcs.mit.edu/~lynch/publications.html
Root-URL: 
Title: Forward and Backward Simulations Part I: Untimed Systems  
Author: Nancy Lynch Frits Vaandrager 
Keyword: and Phrases: Simulations, automata, refinement mappings, forward simulations, backward simulations, forward-backward simulations, backward-forward simulations, history variables, prophecy variables, history relations, prophecy relations, verification, invariants.  
Note: 1991 Mathematics Subject Classification: 68Q60, 68Q68. 1991 CR Categories:  Notes: This work was supported by ONR contracts N00014-85-K-0168 and N00014-91-J-1988, by NSF grants CCR-8915206 and CCR-9225124, by DARPA contracts N00014-89-J-1988 and N00014-92-J-4033, and ONR-AFOSR contract F49620-94-1-0199.  
Address: Cambridge, MA 02139, USA  P.O. Box 94079, NL-1090 GB Amsterdam  Kruislaan 403, NL-1098 SJ Amsterdam  
Affiliation: MIT Laboratory for Computer Science  CWI  University of Amsterdam Programming Research Group  
Email: lynch@theory.lcs.mit.edu  fritsv@cwi.nl  
Date: October 31, 1994  
Web: F.1.1, F.3.1.  
Abstract: A unified, comprehensive presentation of simulation techniques for verification of concurrent systems is given, in terms of a simple untimed automaton model. In particular, (1) refinements, (2) forward and backward simulations, (3) hybrid forward-backward and backward-forward simulations, and (4) history and prophecy relations are defined. History and prophecy relations are abstract versions of the history and prophecy variables of Abadi and Lamport, as well as the auxiliary variables of Owicki and Gries. Relationships between the different types of simulations, as well as soundness and completeness results, are stated and proved. Finally, it is shown how invariants can be incorporated into all the simulations. Even though many results are presented here for the first time, this paper can also be read as a survey (in a simple setting) of the research literature on simulation techniques. The development for untimed automata is designed to support a similar development for timed automata. In Part II of this paper, it is shown how the results of this paper can be carried over to the setting of timed automata. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> M. Abadi and L. Lamport. </author> <title> The existence of refinement mappings. </title> <journal> Theoretical Computer Science, </journal> <volume> 82(2) </volume> <pages> 253-284, </pages> <year> 1991. </year> <title> 9 Note however that [39] contains some minor flaws (Propositions 7.1, 7.6 and 8.1 are incorrect), and that the auxiliary variables of [25] have the peculiar property that adding them may change the visible behavior of an automaton. </title> <type> 34 </type>
Reference-contexts: Among the kinds of simulations we define are refinements, forward simulations, backward simulations, and hybrid versions that we call forward-backward and backward-forward simulations. We also define history relations and prophecy relations, which are abstract versions of the history and prophecy variables, respectively, of Abadi and Lamport <ref> [1] </ref>. We prove implication relationships among the different types of simulations, as well as soundness and completeness theorems. Finally, we show how invariants can be incorporated into all of the simulations. The simplest kind of simulations we consider are refinements. <p> The final simulations we consider are history relations and prophecy relations. These are new and abstract versions of the history and prophecy variables of Abadi and Lamport <ref> [1] </ref>. The basic concept of history variables goes back at least as far as Lucas [32]. Owicki and Gries [43] defined history variables (which they called auxiliary variables) and used them in verifying parallel programs. Subsequently, Abadi and Lamport [1] gave a more abstract, language independent definition of history variables, and <p> versions of the history and prophecy variables of Abadi and Lamport <ref> [1] </ref>. The basic concept of history variables goes back at least as far as Lucas [32]. Owicki and Gries [43] defined history variables (which they called auxiliary variables) and used them in verifying parallel programs. Subsequently, Abadi and Lamport [1] gave a more abstract, language independent definition of history variables, and also introduced the dual concept of a prophecy variable. Several authors observed that history and prophecy variables are closely related to forward and backward simulations, respectively, [39, 22, 25]. <p> Several authors observed that history and prophecy variables are closely related to forward and backward simulations, respectively, [39, 22, 25]. Inspired by this, we define in this paper the even more abstract notions of history and prophecy relations, and show their equivalence with the history resp. prophecy variables of <ref> [1] </ref>. According to our definitions, a history relation is simply a forward simulation whose inverse is a refinement, while a prophecy relation is simply a backward simulation whose inverse is a refinement. <p> Bisimulations, which combine in a single relation forward simulations in two directions, play a vital role in the theory of process algebras [44, 41, 4]. Backward simulations have so far been much less widely used. Abadi and Lamport <ref> [1] </ref> demonstrate the usefulness of prophecy variables (and hence backward simulations), with some simple examples, while [29] contains a somewhat more practical example. There has not been much work on applying the hybrid forward and backward methods. <p> a second case saying that if B has fin and A flT B, then A iBF B. 5 Auxiliary Variable Constructions In this section, we present two new types of relations, history relations and prophecy relations, which correspond to the notions of history and prophecy variable of Abadi and Lamport <ref> [1] </ref>. We show that there is a close connection between history relations and forward simulations, and also between prophecy relations and backward simulations. <p> Using these connections together with the earlier results of this paper, we can easily derive a completeness theorem for refinements similar to the one of Abadi and Lamport <ref> [1] </ref>. <p> Although inspired by [39, 22, 25], the notion of a history relation is a new contribution of this paper. It provides a simple and abstract view of the history variables of Abadi and Lamport <ref> [1] </ref> (which in turn are abstractions of the auxiliary variables of Owicki and Gries [43]). Translated into the setting of this paper, history variables can be simply defined in terms of history relations, as follows. <p> F B ) (By Theorem 5.16) 9C; D : A P C R D F B ) (By Propositions 3.7 and 3.9) 9C : A P C F B: 5.3 Completeness of History and Prophecy Relations We finish this section with versions of the completeness results of Abadi and Lamport <ref> [1] </ref>. Theorem 5.18 (Completeness of history relations, prophecy relations and refinements, [1]) Suppose A flT B. Then 1. 9C; D : A H C P D R B, and 2. if B has fin then 9C; D : A H C iP D R B. <p> C R D F B ) (By Propositions 3.7 and 3.9) 9C : A P C F B: 5.3 Completeness of History and Prophecy Relations We finish this section with versions of the completeness results of Abadi and Lamport <ref> [1] </ref>. Theorem 5.18 (Completeness of history relations, prophecy relations and refinements, [1]) Suppose A flT B. Then 1. 9C; D : A H C P D R B, and 2. if B has fin then 9C; D : A H C iP D R B. <p> We give some examples. 1. In this paper we follow an action-based approach, in which the behavior of a system is a sequence of (visible) actions. Another popular approach, followed for instance in <ref> [1] </ref>, is based on states: the behavior of a system is a sequence of states (up to stuttering). These different approaches are, in some sense, equivalent. <p> However, if one takes our history variables and maps them to the state based world via the translation of [5], one gets something which is slightly different from the history variables of <ref> [1] </ref>, due to a subtle difference in the treatment of internal actions/stuttering. By slightly restricting our history and prophecy relations one can obtain history and prophecy variables that do correspond exactly to those of [1]. <p> the translation of [5], one gets something which is slightly different from the history variables of <ref> [1] </ref>, due to a subtle difference in the treatment of internal actions/stuttering. By slightly restricting our history and prophecy relations one can obtain history and prophecy variables that do correspond exactly to those of [1]. However, doing this either destroys the classification of Figure 6, or forces us to change the definitions of all the other simulations as well, with the result that the correspondence with previous work on simulations in action-based approaches (for instance, [19, 21, 22, 34, 35, 39]) gets lost. 2. <p> The present paper provides complete proof methods for trace inclusion between automata with finite invisible nondeterminism. Such automata express the class of safety properties [2]. For simplicity, we have not considered liveness properties here. Simulation techniques that deal with liveness are for instance described in <ref> [21, 22, 1, 8] </ref>. The results of [1, 8] are more general than ours because safety and liveness issues are separated through the use of automata that are equipped with additional liveness properties. History variables were first defined at the syntactic level for specific (parallel) programming languages. <p> Such automata express the class of safety properties [2]. For simplicity, we have not considered liveness properties here. Simulation techniques that deal with liveness are for instance described in [21, 22, 1, 8]. The results of <ref> [1, 8] </ref> are more general than ours because safety and liveness issues are separated through the use of automata that are equipped with additional liveness properties. History variables were first defined at the syntactic level for specific (parallel) programming languages. <p> Owicki and Gries [43], for instance, define an auxiliary variable set for a statement S to be a set of variables AV that appears in S only in assignments x := E, where x is in AV . One of the contributions of Abadi and Lamport <ref> [1] </ref> is a language independent, semantic definition of this important concept. In this paper we have simplified their definition and the proof of their completeness theorem by observing that history variables are equivalent to history relations, and the dual prophecy variables are equivalent to prohecy relations.
Reference: [2] <author> B. Alpern and F.B. Schneider. </author> <title> Defining liveness. </title> <journal> Information Processing Letters, </journal> <volume> 21:181 185, </volume> <year> 1985. </year>
Reference-contexts: A specific question here concerns the relationship between forward-backward simulations and the single complete rule for data refinement of [7]. The present paper provides complete proof methods for trace inclusion between automata with finite invisible nondeterminism. Such automata express the class of safety properties <ref> [2] </ref>. For simplicity, we have not considered liveness properties here. Simulation techniques that deal with liveness are for instance described in [21, 22, 1, 8].
Reference: [3] <author> R.J.R. Back and J. von Wright. </author> <title> Refinement calculus, part I: Sequential nondeterministic programs. </title> <editor> In J.W. de Bakker, W.P. de Roever, and G. Rozenberg, editors, </editor> <booktitle> Proceedings REX Workshop on Stepwise Refinement of Distributed Systems: Models, Formalism, Correctness, Mook, The Netherlands, May/June 1989, volume 430 of Lecture Notes in Computer Science, </booktitle> <pages> pages 42-66. </pages> <publisher> Springer-Verlag, </publisher> <year> 1990. </year>
Reference-contexts: We preferred not to use this notion since it fails to reduce reasoning about entire executions to reasoning about individual states and transitions. 7. This paper is related to the work of <ref> [17, 18, 3, 7, 48] </ref> on data refinement. In [17], an operation is a binary relation over some universal set .
Reference: [4] <author> J.C.M. Baeten and W.P. Weijland. </author> <title> Process Algebra. </title> <booktitle> Cambridge Tracts in Theoretical Computer Science 18. </booktitle> <publisher> Cambridge University Press, </publisher> <year> 1990. </year>
Reference-contexts: Forward simulations combine refinement mappings with history variables. Typical examples of their use appear in [19, 31, 34, 29, 42]. Bisimulations, which combine in a single relation forward simulations in two directions, play a vital role in the theory of process algebras <ref> [44, 41, 4] </ref>. Backward simulations have so far been much less widely used. Abadi and Lamport [1] demonstrate the usefulness of prophecy variables (and hence backward simulations), with some simple examples, while [29] contains a somewhat more practical example. <p> We have chosen this model because of its simplicity and because it is used both in the theory of I/O automata [35, 20] and in the theory of process algebras <ref> [4, 16, 41] </ref>, two important approaches toward specification and verification of concurrent systems. Simulations techniques play an important role in many other models of computation, and variants of most of the simulations that we discuss here have been proposed in the literature for other models and other notions of behavior.
Reference: [5] <author> R. De Nicola and F.W. Vaandrager. </author> <title> Three logics for branching bisimulation (ex tended abstract). </title> <booktitle> In Proceedings 5 th Annual Symposium on Logic in Computer Science, </booktitle> <address> Philadelphia, USA, </address> <pages> pages 118-129. </pages> <publisher> IEEE Computer Society Press, </publisher> <year> 1990. </year> <note> Full version to appear in JACM. Available as Rapporto di Ricerca SI-92/07, </note> <institution> Dipartimento di Scienze dell'Informazione, Universita degli Studi di Roma "La Sapienza", </institution> <month> November </month> <year> 1992. </year>
Reference-contexts: Another popular approach, followed for instance in [1], is based on states: the behavior of a system is a sequence of states (up to stuttering). These different approaches are, in some sense, equivalent. In <ref> [5] </ref>, for instance, translations are presented between an action based model of labeled transition systems (LTS's) and a state base model of Kripke structures (KS's). <p> These translations show that the concept of internal actions in action-based approaches is the same, in some sense, as the concept of stuttering in state-based approaches. However, if one takes our history variables and maps them to the state based world via the translation of <ref> [5] </ref>, one gets something which is slightly different from the history variables of [1], due to a subtle difference in the treatment of internal actions/stuttering. By slightly restricting our history and prophecy relations one can obtain history and prophecy variables that do correspond exactly to those of [1].
Reference: [6] <author> E.W. Dijkstra. </author> <title> A Discipline of Programming. </title> <booktitle> Prentice-Hall International, </booktitle> <address> Englewood Cliffs, </address> <year> 1976. </year>
Reference-contexts: They are also widely used in the verification of concurrent and reactive systems. Some typical examples can be found in [28, 14]. There is also a long tradition of using history variables in program verification <ref> [32, 6, 43, 45] </ref>. Often history variables are used together with refinements, see for instance [27]. Forward simulations combine refinement mappings with history variables. Typical examples of their use appear in [19, 31, 34, 29, 42].
Reference: [7] <author> P.H.B. Gardiner and C.C. Morgan. </author> <title> A single complete rule for data refinement. </title> <journal> Journal of Formal Aspects of Computing Science, </journal> <volume> 5 </volume> <pages> 367-382, </pages> <year> 1993. </year>
Reference-contexts: We preferred not to use this notion since it fails to reduce reasoning about entire executions to reasoning about individual states and transitions. 7. This paper is related to the work of <ref> [17, 18, 3, 7, 48] </ref> on data refinement. In [17], an operation is a binary relation over some universal set . <p> Clearly, 33 an important topic for future research is to study the connection between automata based simulation techniques and methods for data refinement. A specific question here concerns the relationship between forward-backward simulations and the single complete rule for data refinement of <ref> [7] </ref>. The present paper provides complete proof methods for trace inclusion between automata with finite invisible nondeterminism. Such automata express the class of safety properties [2]. For simplicity, we have not considered liveness properties here. Simulation techniques that deal with liveness are for instance described in [21, 22, 1, 8].
Reference: [8] <author> R. Gawlick, R. Segala, J.F. Stgaard-Andersen, and N. Lynch. </author> <title> Liveness in timed and untimed systems. </title> <editor> In S. Abiteboul and E. Shamir, editors, </editor> <booktitle> Proceedings 21 th ICALP, Jerusalem, volume 820 of Lecture Notes in Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1994. </year> <note> A full version appears as MIT Technical Report number MIT/LCS/TR-587. </note>
Reference-contexts: The present paper provides complete proof methods for trace inclusion between automata with finite invisible nondeterminism. Such automata express the class of safety properties [2]. For simplicity, we have not considered liveness properties here. Simulation techniques that deal with liveness are for instance described in <ref> [21, 22, 1, 8] </ref>. The results of [1, 8] are more general than ours because safety and liveness issues are separated through the use of automata that are equipped with additional liveness properties. History variables were first defined at the syntactic level for specific (parallel) programming languages. <p> Such automata express the class of safety properties [2]. For simplicity, we have not considered liveness properties here. Simulation techniques that deal with liveness are for instance described in [21, 22, 1, 8]. The results of <ref> [1, 8] </ref> are more general than ours because safety and liveness issues are separated through the use of automata that are equipped with additional liveness properties. History variables were first defined at the syntactic level for specific (parallel) programming languages.
Reference: [9] <author> R. Gerth. </author> <title> Foundations of compositional program refinement (first version). </title> <editor> In J.W. de Bakker, W.P. de Roever, and G. Rozenberg, editors, </editor> <booktitle> Proceedings REX Workshop on Stepwise Refinement of Distributed Systems: Models, Formalism, Correctness, Mook, The Netherlands, May/June 1989, volume 430 of Lecture Notes in Computer Science, </booktitle> <pages> pages 777-808. </pages> <publisher> Springer-Verlag, </publisher> <year> 1990. </year>
Reference-contexts: The definition of a forward-backward simulation has been inspired by the work of Klarlund and Schneider [24, 25] for the case without internal actions. Forward-backward simulations are also similar to the subset-simulations of [22], and the simple failure simulations of <ref> [9] </ref>. Our new notion of a backward-forward simulation is suggested by symmetry with forward-backward simulations. We give soundness and completeness results; while some of the results for backward-forward simulations are symmetric with those for forward-backward simulations, others (notably, certain completeness results) are different. <p> They also occur in the work of Jonsson [22] under the name subset simulations, and are related to the failure simulations of Gerth <ref> [9] </ref>. Forward-backward simulations combine in a single relation both a forward and a backward simulation. Below we present simple proofs of their soundness and completeness by making this connection explicit.
Reference: [10] <author> A. Ginzburg. </author> <title> Algebraic Theory of Automata. </title> <publisher> Academic Press, </publisher> <address> New York - London, </address> <year> 1968. </year>
Reference-contexts: Finally, we show how invariants can be incorporated into all of the simulations. The simplest kind of simulations we consider are refinements. Refinements are similar to the homomorphism between automata in the sense of classical automata theory <ref> [10] </ref>, and to the data refinements that are used in program development to replace abstract mathematical data structures by concrete structures that are more easily implemented [40, 15, 30, 18]. Lamport [28] advocates the use of refinements to prove that one concurrent program module implements another. <p> If s 0 a ! A s then r (s 0 ) ^a =) B r (s). We write A R B if there exists a refinement from A to B. This notion is similar to that of a homomorphism in classical automata theory; see for instance Ginzberg <ref> [10] </ref>. Besides our additional treatment of internal actions, a difference between the two notions is that the classical notion involves a mapping between the action sets of the automata, whereas our refinements do not.
Reference: [11] <author> R.J. van Glabbeek. </author> <title> The linear time branching time spectrum. </title> <editor> In J.C.M. Baeten and J.W. Klop, editors, </editor> <booktitle> Proceedings CONCUR 90, Amsterdam, volume 458 of Lecture Notes in Computer Science, </booktitle> <pages> pages 278-297. </pages> <publisher> Springer-Verlag, </publisher> <year> 1990. </year>
Reference-contexts: Prop. 3.20). 4. Simulation techniques have not only been used to prove trace inclusion, but also for proving several other preorders from Van Glabbeek's <ref> [11, 12] </ref> linear time | branching time spectrum. In [23, 13] for instance, proof methods based on forward and backward simulations are presented and proved to be sound and complete for the failure preorder of CSP [16].
Reference: [12] <author> R.J. van Glabbeek. </author> <title> The linear time branching time spectrum II (the semantics of sequential systems with silent moves). </title> <editor> In E. Best, editor, </editor> <booktitle> Proceedings CONCUR 93, Hildesheim, Germany, volume 715 of Lecture Notes in Computer Science, </booktitle> <pages> pages 66-81. </pages> <publisher> Springer-Verlag, </publisher> <year> 1993. </year> <month> 35 </month>
Reference-contexts: Prop. 3.20). 4. Simulation techniques have not only been used to prove trace inclusion, but also for proving several other preorders from Van Glabbeek's <ref> [11, 12] </ref> linear time | branching time spectrum. In [23, 13] for instance, proof methods based on forward and backward simulations are presented and proved to be sound and complete for the failure preorder of CSP [16].
Reference: [13] <author> J. </author> <title> He. Process simulation and refinement. </title> <journal> Journal of Formal Aspects of Computing Science, </journal> <volume> 1 </volume> <pages> 229-241, </pages> <year> 1989. </year>
Reference-contexts: We next consider forward simulations and backward simulations, generalizations of refinements that allow a set of states of B to correspond to a single state of A. Forward simulations are similar to the simulations of [44, 19, 21], the possibilities mappings of [33, 35], the downward simulations of <ref> [17, 23, 13] </ref>, the forward simulations of [22], and the history measures of [25]. <p> Again, we give soundness and partial completeness results. Backward simulations are similar to the upward simulations of <ref> [17, 23, 13] </ref>, the prophecy mappings of [39], the backwards simulations of [21], and the prophecy measures of [25]. <p> Lemma 2.9 1. can (beh (A)) is a deterministic forest. 2. can (beh (A)) flT A. 4. If A has fin then can (beh (A)) T A. Proof: By combining Lemma 2.5 and Lemma 2.8. 2 This notion is due to He Jifeng <ref> [13] </ref>. 9 3 Basic Simulations In this section, we develop the basic simulation techniques for untimed automata: refinements and forward and backward simulations. 3.1 Refinements The simplest type of simulation we consider is a refinement. <p> to A 8 , but even though A 8 is deterministic there is no image-finite backward simulation. ? q q* fi ? A 7 6 iB 3.4 Combined Forward and Backward Simulations Several authors have observed that forward and backward simulations together give a complete proof method for flT (see <ref> [17, 13, 21, 22, 23, 25] </ref>): if A flT B then there exists an 15 intermediate automaton C with a forward simulation from A to C and a backward simulation from C to B. <p> Prop. 3.20). 4. Simulation techniques have not only been used to prove trace inclusion, but also for proving several other preorders from Van Glabbeek's [11, 12] linear time | branching time spectrum. In <ref> [23, 13] </ref> for instance, proof methods based on forward and backward simulations are presented and proved to be sound and complete for the failure preorder of CSP [16].
Reference: [14] <author> L. Helmink, M.P.A. Sellink, and F.W. Vaandrager. </author> <title> Proof-checking a data link pro tocol. </title> <editor> In H. Barendregt and T. Nipkow, editors, </editor> <booktitle> Proceedings International Workshop TYPES'93, </booktitle> <address> Nijmegen, The Netherlands, </address> <month> May </month> <year> 1993, </year> <booktitle> volume 806 of Lecture Notes in Computer Science, </booktitle> <pages> pages 127-165. </pages> <publisher> Springer-Verlag, </publisher> <year> 1994. </year> <note> Full version available as Report CS-R9420, </note> <institution> CWI, </institution> <address> Amsterdam, </address> <month> March </month> <year> 1994. </year>
Reference-contexts: Abstraction mappings, which are essentially refinement mappings, comprise a basic proof method for implementations of abstract data types [30, 18]. They are also widely used in the verification of concurrent and reactive systems. Some typical examples can be found in <ref> [28, 14] </ref>. There is also a long tradition of using history variables in program verification [32, 6, 43, 45]. Often history variables are used together with refinements, see for instance [27]. Forward simulations combine refinement mappings with history variables.
Reference: [15] <author> C.A.R. Hoare. </author> <title> Proof of correctness of data representations. </title> <journal> Acta Informatica, </journal> <volume> 1 </volume> <pages> 271-281, </pages> <year> 1972. </year>
Reference-contexts: Refinements are similar to the homomorphism between automata in the sense of classical automata theory [10], and to the data refinements that are used in program development to replace abstract mathematical data structures by concrete structures that are more easily implemented <ref> [40, 15, 30, 18] </ref>. Lamport [28] advocates the use of refinements to prove that one concurrent program module implements another.
Reference: [16] <author> C.A.R. Hoare. </author> <title> Communicating Sequential Processes. </title> <booktitle> Prentice-Hall International, </booktitle> <address> En glewood Cliffs, </address> <year> 1985. </year>
Reference-contexts: We have chosen this model because of its simplicity and because it is used both in the theory of I/O automata [35, 20] and in the theory of process algebras <ref> [4, 16, 41] </ref>, two important approaches toward specification and verification of concurrent systems. Simulations techniques play an important role in many other models of computation, and variants of most of the simulations that we discuss here have been proposed in the literature for other models and other notions of behavior. <p> In [23, 13] for instance, proof methods based on forward and backward simulations are presented and proved to be sound and complete for the failure preorder of CSP <ref> [16] </ref>. In the definitions of these simulations additional clauses are present which for instance require that related states have the same initial actions. 5. All the automata studied in this paper have been untimed.
Reference: [17] <author> C.A.R. Hoare, J. He, and J.W. Sanders. </author> <title> Prespecification in data refinement. </title> <journal> Information Processing Letters, </journal> <volume> 25 </volume> <pages> 71-76, </pages> <year> 1987. </year>
Reference-contexts: We next consider forward simulations and backward simulations, generalizations of refinements that allow a set of states of B to correspond to a single state of A. Forward simulations are similar to the simulations of [44, 19, 21], the possibilities mappings of [33, 35], the downward simulations of <ref> [17, 23, 13] </ref>, the forward simulations of [22], and the history measures of [25]. <p> Again, we give soundness and partial completeness results. Backward simulations are similar to the upward simulations of <ref> [17, 23, 13] </ref>, the prophecy mappings of [39], the backwards simulations of [21], and the prophecy measures of [25]. <p> to A 8 , but even though A 8 is deterministic there is no image-finite backward simulation. ? q q* fi ? A 7 6 iB 3.4 Combined Forward and Backward Simulations Several authors have observed that forward and backward simulations together give a complete proof method for flT (see <ref> [17, 13, 21, 22, 23, 25] </ref>): if A flT B then there exists an 15 intermediate automaton C with a forward simulation from A to C and a backward simulation from C to B. <p> We preferred not to use this notion since it fails to reduce reasoning about entire executions to reasoning about individual states and transitions. 7. This paper is related to the work of <ref> [17, 18, 3, 7, 48] </ref> on data refinement. In [17], an operation is a binary relation over some universal set . <p> We preferred not to use this notion since it fails to reduce reasoning about entire executions to reasoning about individual states and transitions. 7. This paper is related to the work of [17, 18, 3, 7, 48] on data refinement. In <ref> [17] </ref>, an operation is a binary relation over some universal set . <p> In <ref> [17] </ref>, a downward simulation from (AI ; fAO j j j 2 J g; AF ) to (BI ; fBO j j j 2 J g; BF ) is defined to be any relation R for which the following inequations hold: BI R ffi AI BF ffi R AF It is <p> A similar correspondence can be established between our backward simulations and the upward simulations of <ref> [17] </ref>. Just as forward and backward simulations provide a sound and complete proof method for trace inclusion between automata, downward and upward simulations offer a sound and complete proof method for refinement between data types. <p> surprising (at least for us) is the fact that the requirements of totality and finite invisible nondeterminism that we used to prove soundness of backward simulations, also play a role in the soundness result of upward simulations in case iteration and recursion can be used in the formation of programs <ref> [17] </ref>. Clearly, 33 an important topic for future research is to study the connection between automata based simulation techniques and methods for data refinement. A specific question here concerns the relationship between forward-backward simulations and the single complete rule for data refinement of [7].
Reference: [18] <author> C.B. Jones. </author> <title> Systematic Software Development using VDM. </title> <booktitle> Prentice-Hall International, </booktitle> <address> Englewood Cliffs, </address> <year> 1986. </year>
Reference-contexts: Refinements are similar to the homomorphism between automata in the sense of classical automata theory [10], and to the data refinements that are used in program development to replace abstract mathematical data structures by concrete structures that are more easily implemented <ref> [40, 15, 30, 18] </ref>. Lamport [28] advocates the use of refinements to prove that one concurrent program module implements another. <p> The usefulness of refinement mappings, history variables, and forward simulations in proving correctness has been well demonstrated. Abstraction mappings, which are essentially refinement mappings, comprise a basic proof method for implementations of abstract data types <ref> [30, 18] </ref>. They are also widely used in the verification of concurrent and reactive systems. Some typical examples can be found in [28, 14]. There is also a long tradition of using history variables in program verification [32, 6, 43, 45]. <p> We preferred not to use this notion since it fails to reduce reasoning about entire executions to reasoning about individual states and transitions. 7. This paper is related to the work of <ref> [17, 18, 3, 7, 48] </ref> on data refinement. In [17], an operation is a binary relation over some universal set .
Reference: [19] <author> B. Jonsson. </author> <title> Compositional Verification of Distributed Systems. </title> <type> PhD thesis, </type> <institution> Department of Computer Systems, Uppsala University, </institution> <year> 1987. </year> <note> DoCS 87/09. </note>
Reference-contexts: We give soundness and partial completeness results for refinements. We next consider forward simulations and backward simulations, generalizations of refinements that allow a set of states of B to correspond to a single state of A. Forward simulations are similar to the simulations of <ref> [44, 19, 21] </ref>, the possibilities mappings of [33, 35], the downward simulations of [17, 23, 13], the forward simulations of [22], and the history measures of [25]. <p> There is also a long tradition of using history variables in program verification [32, 6, 43, 45]. Often history variables are used together with refinements, see for instance [27]. Forward simulations combine refinement mappings with history variables. Typical examples of their use appear in <ref> [19, 31, 34, 29, 42] </ref>. Bisimulations, which combine in a single relation forward simulations in two directions, play a vital role in the theory of process algebras [44, 41, 4]. Backward simulations have so far been much less widely used. <p> Proof: Versions of this proof appear in the cited papers. The proof is similar to that of Theorem 3.4. Also the following result is well-known and variants of it have appeared in many papers (for instance in <ref> [19, 47] </ref>). Theorem 3.11 (Partial completeness of forward simulations) Suppose B is deterministic and A flT B. Then A F B. Proof: The relation f = after (B ) ffi past (A) is a forward simulation from A to B. <p> However, doing this either destroys the classification of Figure 6, or forces us to change the definitions of all the other simulations as well, with the result that the correspondence with previous work on simulations in action-based approaches (for instance, <ref> [19, 21, 22, 34, 35, 39] </ref>) gets lost. 2. In classical automata theory, there is a complete duality between past and future since besides start states there are also final states, and traces correspond to finite executions from a start state to a final state.
Reference: [20] <author> B. Jonsson. </author> <title> Modular verification of asynchronous networks. </title> <booktitle> In Proceedings of the 6 th Annual ACM Symposium on Principles of Distributed Computing, </booktitle> <pages> pages 152-166, </pages> <month> August </month> <year> 1987. </year>
Reference-contexts: For transitivity, use Lemma 3.8 to show that if f and f 0 are forward simulations from A to B and from B to C, respectively, f 0 ffi f is a forward simulation from A to C. Theorem 3.10 (Soundness of forward simulations, <ref> [35, 20, 47] </ref>) A F B ) A T B. Proof: Versions of this proof appear in the cited papers. The proof is similar to that of Theorem 3.4. Also the following result is well-known and variants of it have appeared in many papers (for instance in [19, 47]). <p> We have chosen this model because of its simplicity and because it is used both in the theory of I/O automata <ref> [35, 20] </ref> and in the theory of process algebras [4, 16, 41], two important approaches toward specification and verification of concurrent systems.
Reference: [21] <author> B. Jonsson. </author> <title> On decomposing and refining specifications of distributed systems. </title> <editor> In J.W. de Bakker, W.P. de Roever, and G. Rozenberg, editors, </editor> <booktitle> Proceedings REX Workshop on Stepwise Refinement of Distributed Systems: Models, Formalism, Correctness, Mook, The Netherlands, May/June 1989, volume 430 of Lecture Notes in Computer Science, </booktitle> <pages> pages 361-387. </pages> <publisher> Springer-Verlag, </publisher> <year> 1990. </year>
Reference-contexts: We give soundness and partial completeness results for refinements. We next consider forward simulations and backward simulations, generalizations of refinements that allow a set of states of B to correspond to a single state of A. Forward simulations are similar to the simulations of <ref> [44, 19, 21] </ref>, the possibilities mappings of [33, 35], the downward simulations of [17, 23, 13], the forward simulations of [22], and the history measures of [25]. <p> Again, we give soundness and partial completeness results. Backward simulations are similar to the upward simulations of [17, 23, 13], the prophecy mappings of [39], the backwards simulations of <ref> [21] </ref>, and the prophecy measures of [25]. <p> We do not explore this extension in this paper, primarily because it lacks a key feature of simulation techniques. Namely, it fails to reduce reasoning about executions to reasoning about individual states and steps. The following partial completeness result slightly generalizes a similar result of Jonsson <ref> [21] </ref> in that it also allows for t -steps in the B automaton. Theorem 3.18 (Partial completeness of backward simulations) Suppose A is a forest and A flT B. Then 1. A B B, and 2. if B has fin then A iB B. <p> to A 8 , but even though A 8 is deterministic there is no image-finite backward simulation. ? q q* fi ? A 7 6 iB 3.4 Combined Forward and Backward Simulations Several authors have observed that forward and backward simulations together give a complete proof method for flT (see <ref> [17, 13, 21, 22, 23, 25] </ref>): if A flT B then there exists an 15 intermediate automaton C with a forward simulation from A to C and a backward simulation from C to B. <p> However, doing this either destroys the classification of Figure 6, or forces us to change the definitions of all the other simulations as well, with the result that the correspondence with previous work on simulations in action-based approaches (for instance, <ref> [19, 21, 22, 34, 35, 39] </ref>) gets lost. 2. In classical automata theory, there is a complete duality between past and future since besides start states there are also final states, and traces correspond to finite executions from a start state to a final state. <p> The present paper provides complete proof methods for trace inclusion between automata with finite invisible nondeterminism. Such automata express the class of safety properties [2]. For simplicity, we have not considered liveness properties here. Simulation techniques that deal with liveness are for instance described in <ref> [21, 22, 1, 8] </ref>. The results of [1, 8] are more general than ours because safety and liveness issues are separated through the use of automata that are equipped with additional liveness properties. History variables were first defined at the syntactic level for specific (parallel) programming languages.
Reference: [22] <author> B. Jonsson. </author> <title> Simulations between specifications of distributed systems. </title> <editor> In J.C.M. Baeten and J.F. Groote, editors, </editor> <booktitle> Proceedings CONCUR 91, Amsterdam, volume 527 of Lecture Notes in Computer Science, </booktitle> <pages> pages 346-360. </pages> <publisher> Springer-Verlag, </publisher> <year> 1991. </year>
Reference-contexts: Forward simulations are similar to the simulations of [44, 19, 21], the possibilities mappings of [33, 35], the downward simulations of [17, 23, 13], the forward simulations of <ref> [22] </ref>, and the history measures of [25]. <p> The definition of a forward-backward simulation has been inspired by the work of Klarlund and Schneider [24, 25] for the case without internal actions. Forward-backward simulations are also similar to the subset-simulations of <ref> [22] </ref>, and the simple failure simulations of [9]. Our new notion of a backward-forward simulation is suggested by symmetry with forward-backward simulations. We give soundness and completeness results; while some of the results for backward-forward simulations are symmetric with those for forward-backward simulations, others (notably, certain completeness results) are different. <p> Subsequently, Abadi and Lamport [1] gave a more abstract, language independent definition of history variables, and also introduced the dual concept of a prophecy variable. Several authors observed that history and prophecy variables are closely related to forward and backward simulations, respectively, <ref> [39, 22, 25] </ref>. Inspired by this, we define in this paper the even more abstract notions of history and prophecy relations, and show their equivalence with the history resp. prophecy variables of [1]. <p> Then G satisfies the hypotheses of Lemma A.1, which implies that there is an infinite path in G starting at a root. This corresponds directly to an execution ff 0 of B having trace (ff 0 ) = trace (ff) = fi. Hence, fi 2 traces (B). Jonsson <ref> [22] </ref> considers a weaker image-finiteness condition for backward simulations. <p> to A 8 , but even though A 8 is deterministic there is no image-finite backward simulation. ? q q* fi ? A 7 6 iB 3.4 Combined Forward and Backward Simulations Several authors have observed that forward and backward simulations together give a complete proof method for flT (see <ref> [17, 13, 21, 22, 23, 25] </ref>): if A flT B then there exists an 15 intermediate automaton C with a forward simulation from A to C and a backward simulation from C to B. <p> We prove this below by taking C to be the canonical automaton of A, as defined in Section 2. Alternative proofs can be given using different intermediate automata, for example the automaton obtained by applying the classical subset construction on B (see <ref> [22, 25] </ref>), or the unfolding construction of Section 5.1 on A. Theorem 3.22 (Completeness of forward and backward simulations) If A flT B then the following are true. 1. 9C : A F C B B. 2. If B has fin then 9C : A F C iB B. <p> If B has fin then C iB B follows by Theorem 3.18 (2). 4 Hybrid Simulations 4.1 Forward-Backward Simulations Forward-backward simulations were introduced by Klarlund and Schneider who call them invariants in [24] and ND measures in [25]. They also occur in the work of Jonsson <ref> [22] </ref> under the name subset simulations, and are related to the failure simulations of Gerth [9]. Forward-backward simulations combine in a single relation both a forward and a backward simulation. Below we present simple proofs of their soundness and completeness by making this connection explicit. <p> We write A FB B if there exists a forward-backward simulation from A to B, and A iFB B if there exists an image-set-finite forward-backward simulation from A to B. The following theorem, which is similar to a result of <ref> [22] </ref>, says that a forward-backward simulation is essentially just a combination of a forward and a backward simulation. Theorem 4.1 1. <p> It now follows that h 0 ffi h is a history relation from A to C. Although inspired by <ref> [39, 22, 25] </ref>, the notion of a history relation is a new contribution of this paper. It provides a simple and abstract view of the history variables of Abadi and Lamport [1] (which in turn are abstractions of the auxiliary variables of Owicki and Gries [43]). <p> However, doing this either destroys the classification of Figure 6, or forces us to change the definitions of all the other simulations as well, with the result that the correspondence with previous work on simulations in action-based approaches (for instance, <ref> [19, 21, 22, 34, 35, 39] </ref>) gets lost. 2. In classical automata theory, there is a complete duality between past and future since besides start states there are also final states, and traces correspond to finite executions from a start state to a final state. <p> Furthermore, the implication A F B ^ A is a forest ) A R B of Prop. 3.12 does not carry over to the timed setting. 6. As far as the classification of simulations is concerned, our work is closely related to and extends that of Jonsson <ref> [22] </ref>. Jonsson, however, has a more powerful notion of backward simulation that can also handle automata with infinite invisible nondeterminism. We preferred not to use this notion since it fails to reduce reasoning about entire executions to reasoning about individual states and transitions. 7. <p> The present paper provides complete proof methods for trace inclusion between automata with finite invisible nondeterminism. Such automata express the class of safety properties [2]. For simplicity, we have not considered liveness properties here. Simulation techniques that deal with liveness are for instance described in <ref> [21, 22, 1, 8] </ref>. The results of [1, 8] are more general than ours because safety and liveness issues are separated through the use of automata that are equipped with additional liveness properties. History variables were first defined at the syntactic level for specific (parallel) programming languages. <p> Several authors have observed that forward and backward simulations are closely related to history and prophecy variables, respectively, <ref> [39, 22, 25] </ref>. 9 Still we believe that, through Theorems 5.8 and 5.16, our paper is the first to establish an exact correspondence in a general setting of transition systems. In this paper we have only discussed simulation techniques at the semantic level of automata.
Reference: [23] <author> M.B. Josephs. </author> <title> A state-based approach to communicating processes. </title> <journal> Distributed Com puting, </journal> <volume> 3 </volume> <pages> 9-18, </pages> <year> 1988. </year>
Reference-contexts: We next consider forward simulations and backward simulations, generalizations of refinements that allow a set of states of B to correspond to a single state of A. Forward simulations are similar to the simulations of [44, 19, 21], the possibilities mappings of [33, 35], the downward simulations of <ref> [17, 23, 13] </ref>, the forward simulations of [22], and the history measures of [25]. <p> Again, we give soundness and partial completeness results. Backward simulations are similar to the upward simulations of <ref> [17, 23, 13] </ref>, the prophecy mappings of [39], the backwards simulations of [21], and the prophecy measures of [25]. <p> to A 8 , but even though A 8 is deterministic there is no image-finite backward simulation. ? q q* fi ? A 7 6 iB 3.4 Combined Forward and Backward Simulations Several authors have observed that forward and backward simulations together give a complete proof method for flT (see <ref> [17, 13, 21, 22, 23, 25] </ref>): if A flT B then there exists an 15 intermediate automaton C with a forward simulation from A to C and a backward simulation from C to B. <p> Prop. 3.20). 4. Simulation techniques have not only been used to prove trace inclusion, but also for proving several other preorders from Van Glabbeek's [11, 12] linear time | branching time spectrum. In <ref> [23, 13] </ref> for instance, proof methods based on forward and backward simulations are presented and proved to be sound and complete for the failure preorder of CSP [16].
Reference: [24] <author> N. Klarlund and F.B. Schneider. </author> <title> Verifying safety properties using infinite-state au tomata. </title> <type> Technical Report 89-1039, </type> <institution> Department of Computer Science, Cornell University, </institution> <address> Ithaca, New York, </address> <year> 1989. </year>
Reference-contexts: These are are essentially compositions of one forward and one backward simulation, in the two possible orders. The definition of a forward-backward simulation has been inspired by the work of Klarlund and Schneider <ref> [24, 25] </ref> for the case without internal actions. Forward-backward simulations are also similar to the subset-simulations of [22], and the simple failure simulations of [9]. Our new notion of a backward-forward simulation is suggested by symmetry with forward-backward simulations. <p> If B has fin then C iB B follows by Theorem 3.18 (2). 4 Hybrid Simulations 4.1 Forward-Backward Simulations Forward-backward simulations were introduced by Klarlund and Schneider who call them invariants in <ref> [24] </ref> and ND measures in [25]. They also occur in the work of Jonsson [22] under the name subset simulations, and are related to the failure simulations of Gerth [9]. Forward-backward simulations combine in a single relation both a forward and a backward simulation. <p> Thus S has the required property to show Condition 2. Finally, it is immediate from the definitions that, if g and g 0 are image-set-finite, g 0 * g is also image-set-finite. Proposition 4.4 FB and iFB are preorders. Proof: By Lemma 4.3. Theorem 4.5 (Soundness of forward-backward simulations, <ref> [24] </ref>) 1. A FB B ) A flT B. Proof: For part 1, suppose A FB B. By Theorem 4.1, there exists an automaton C with A F C B B. <p> By soundness of forward simulations, Theorem 3.10, A T C, and by soundness of backward simulations, Theorem 3.17, C flT B. This implies A flT B. Part 2 is similar. Theorem 4.6 (Completeness of forward-backward simulations, <ref> [24] </ref>) Suppose A flT B. Then 1. A FB B, and 2. if B has fin then A iFB B. Proof: By Theorem 3.22, there exists an automaton C with A F C B B. Moreover, if B has fin then A F C iB B.
Reference: [25] <author> N. Klarlund and F.B. Schneider. </author> <title> Proving nondeterministically specified safety properties using progress measures. </title> <journal> Information and Computation, </journal> <volume> 107(1) </volume> <pages> 151-170, </pages> <month> November </month> <year> 1993. </year>
Reference-contexts: Forward simulations are similar to the simulations of [44, 19, 21], the possibilities mappings of [33, 35], the downward simulations of [17, 23, 13], the forward simulations of [22], and the history measures of <ref> [25] </ref>. <p> Again, we give soundness and partial completeness results. Backward simulations are similar to the upward simulations of [17, 23, 13], the prophecy mappings of [39], the backwards simulations of [21], and the prophecy measures of <ref> [25] </ref>. <p> These are are essentially compositions of one forward and one backward simulation, in the two possible orders. The definition of a forward-backward simulation has been inspired by the work of Klarlund and Schneider <ref> [24, 25] </ref> for the case without internal actions. Forward-backward simulations are also similar to the subset-simulations of [22], and the simple failure simulations of [9]. Our new notion of a backward-forward simulation is suggested by symmetry with forward-backward simulations. <p> Subsequently, Abadi and Lamport [1] gave a more abstract, language independent definition of history variables, and also introduced the dual concept of a prophecy variable. Several authors observed that history and prophecy variables are closely related to forward and backward simulations, respectively, <ref> [39, 22, 25] </ref>. Inspired by this, we define in this paper the even more abstract notions of history and prophecy relations, and show their equivalence with the history resp. prophecy variables of [1]. <p> By construction, ff 0 is an execution of B with trace (ff 0 ) = trace (ff) = fi 2 traces (B). Refinements alone are not complete for T or flT . We do have a (very) partial completeness result, however, which slightly generalizes a similar result of <ref> [25] </ref> in that it also allows for t -steps in the A automaton. Theorem 3.5 (Partial completeness of refinements) Suppose A is a forest, B is deterministic and A flT B. Then A R B. <p> to A 8 , but even though A 8 is deterministic there is no image-finite backward simulation. ? q q* fi ? A 7 6 iB 3.4 Combined Forward and Backward Simulations Several authors have observed that forward and backward simulations together give a complete proof method for flT (see <ref> [17, 13, 21, 22, 23, 25] </ref>): if A flT B then there exists an 15 intermediate automaton C with a forward simulation from A to C and a backward simulation from C to B. <p> We prove this below by taking C to be the canonical automaton of A, as defined in Section 2. Alternative proofs can be given using different intermediate automata, for example the automaton obtained by applying the classical subset construction on B (see <ref> [22, 25] </ref>), or the unfolding construction of Section 5.1 on A. Theorem 3.22 (Completeness of forward and backward simulations) If A flT B then the following are true. 1. 9C : A F C B B. 2. If B has fin then 9C : A F C iB B. <p> If B has fin then C iB B follows by Theorem 3.18 (2). 4 Hybrid Simulations 4.1 Forward-Backward Simulations Forward-backward simulations were introduced by Klarlund and Schneider who call them invariants in [24] and ND measures in <ref> [25] </ref>. They also occur in the work of Jonsson [22] under the name subset simulations, and are related to the failure simulations of Gerth [9]. Forward-backward simulations combine in a single relation both a forward and a backward simulation. <p> It now follows that h 0 ffi h is a history relation from A to C. Although inspired by <ref> [39, 22, 25] </ref>, the notion of a history relation is a new contribution of this paper. It provides a simple and abstract view of the history variables of Abadi and Lamport [1] (which in turn are abstractions of the auxiliary variables of Owicki and Gries [43]). <p> However, note that the analogue of Prop. 5.4 does not hold in the setting of Klarlund and Schneider <ref> [25] </ref>, who define their notion of a history variable in terms of forward simulations rather than history relations. Klarlund and Schneider [25] say that an automaton B is obtained from an automaton A by adding history information if there exists a set V such that * states (B ) states (A) <p> However, note that the analogue of Prop. 5.4 does not hold in the setting of Klarlund and Schneider <ref> [25] </ref>, who define their notion of a history variable in terms of forward simulations rather than history relations. Klarlund and Schneider [25] say that an automaton B is obtained from an automaton A by adding history information if there exists a set V such that * states (B ) states (A) fi V , and * the relation f (s; (s; v)) j (s; v) 2 states (B )g is a forward <p> Several authors have observed that forward and backward simulations are closely related to history and prophecy variables, respectively, <ref> [39, 22, 25] </ref>. 9 Still we believe that, through Theorems 5.8 and 5.16, our paper is the first to establish an exact correspondence in a general setting of transition systems. In this paper we have only discussed simulation techniques at the semantic level of automata.
Reference: [26] <author> D.E. Knuth. </author> <title> Fundamental Algorithms, </title> <booktitle> volume 1 of The Art of Computer Programming. </booktitle> <publisher> Addison-Wesley, </publisher> <address> Reading, Massachusetts, </address> <year> 1973. </year> <note> Second edition. </note>
Reference: [27] <author> S.S. Lam and A.U. Shankar. </author> <title> Protocol verification via projections. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 10(4) </volume> <pages> 325-342, </pages> <month> July </month> <year> 1984. </year>
Reference-contexts: Some typical examples can be found in [28, 14]. There is also a long tradition of using history variables in program verification [32, 6, 43, 45]. Often history variables are used together with refinements, see for instance <ref> [27] </ref>. Forward simulations combine refinement mappings with history variables. Typical examples of their use appear in [19, 31, 34, 29, 42]. Bisimulations, which combine in a single relation forward simulations in two directions, play a vital role in the theory of process algebras [44, 41, 4].
Reference: [28] <author> L. Lamport. </author> <title> Specifying concurrent program modules. </title> <journal> ACM Transactions on Program ming Languages and Systems, </journal> <volume> 5(2) </volume> <pages> 190-222, </pages> <year> 1983. </year>
Reference-contexts: Refinements are similar to the homomorphism between automata in the sense of classical automata theory [10], and to the data refinements that are used in program development to replace abstract mathematical data structures by concrete structures that are more easily implemented [40, 15, 30, 18]. Lamport <ref> [28] </ref> advocates the use of refinements to prove that one concurrent program module implements another. <p> Abstraction mappings, which are essentially refinement mappings, comprise a basic proof method for implementations of abstract data types [30, 18]. They are also widely used in the verification of concurrent and reactive systems. Some typical examples can be found in <ref> [28, 14] </ref>. There is also a long tradition of using history variables in program verification [32, 6, 43, 45]. Often history variables are used together with refinements, see for instance [27]. Forward simulations combine refinement mappings with history variables.
Reference: [29] <author> B.W. Lampson, N.A. Lynch, and J.F. Stgaard-Andersen. </author> <title> Correctness of at-most-once message delivery protocols. </title> <booktitle> In FORTE'93 Sixth International Conference on Formal Description Techniques, </booktitle> <pages> pages 387-402, </pages> <address> Boston, MA, </address> <month> October </month> <year> 1993. </year>
Reference-contexts: There is also a long tradition of using history variables in program verification [32, 6, 43, 45]. Often history variables are used together with refinements, see for instance [27]. Forward simulations combine refinement mappings with history variables. Typical examples of their use appear in <ref> [19, 31, 34, 29, 42] </ref>. Bisimulations, which combine in a single relation forward simulations in two directions, play a vital role in the theory of process algebras [44, 41, 4]. Backward simulations have so far been much less widely used. <p> Backward simulations have so far been much less widely used. Abadi and Lamport [1] demonstrate the usefulness of prophecy variables (and hence backward simulations), with some simple examples, while <ref> [29] </ref> contains a somewhat more practical example. There has not been much work on applying the hybrid forward and backward methods.
Reference: [30] <author> B.L. Liskov and J.V. Guttag. </author> <title> Abstraction and Specification in Program Development. </title> <publisher> MIT Press and McGraw Hill, </publisher> <year> 1986. </year>
Reference-contexts: Refinements are similar to the homomorphism between automata in the sense of classical automata theory [10], and to the data refinements that are used in program development to replace abstract mathematical data structures by concrete structures that are more easily implemented <ref> [40, 15, 30, 18] </ref>. Lamport [28] advocates the use of refinements to prove that one concurrent program module implements another. <p> The usefulness of refinement mappings, history variables, and forward simulations in proving correctness has been well demonstrated. Abstraction mappings, which are essentially refinement mappings, comprise a basic proof method for implementations of abstract data types <ref> [30, 18] </ref>. They are also widely used in the verification of concurrent and reactive systems. Some typical examples can be found in [28, 14]. There is also a long tradition of using history variables in program verification [32, 6, 43, 45].
Reference: [31] <author> P. Loewenstein and D.L. Dill. </author> <title> Verification of a multiprocessor cache protocol using sim ulation relations and higher-order logic (summary). In E.M. </title> <editor> Clarke and R.P. Kurshan, editors, </editor> <booktitle> Proceedings of the 2nd International Conference on Computer-Aided Verification, </booktitle> <address> New Brunswick, NJ, USA, </address> <booktitle> volume 531 of Lecture Notes in Computer Science, </booktitle> <pages> pages 302-311. </pages> <publisher> Springer-Verlag, </publisher> <year> 1991. </year>
Reference-contexts: There is also a long tradition of using history variables in program verification [32, 6, 43, 45]. Often history variables are used together with refinements, see for instance [27]. Forward simulations combine refinement mappings with history variables. Typical examples of their use appear in <ref> [19, 31, 34, 29, 42] </ref>. Bisimulations, which combine in a single relation forward simulations in two directions, play a vital role in the theory of process algebras [44, 41, 4]. Backward simulations have so far been much less widely used.
Reference: [32] <author> P. Lucas. </author> <title> Two constructive realizations of the block concept and their equivalence. </title> <type> Technical Report 25.085, </type> <institution> IBM Laboratory, Vienna, </institution> <month> June </month> <year> 1968. </year>
Reference-contexts: The final simulations we consider are history relations and prophecy relations. These are new and abstract versions of the history and prophecy variables of Abadi and Lamport [1]. The basic concept of history variables goes back at least as far as Lucas <ref> [32] </ref>. Owicki and Gries [43] defined history variables (which they called auxiliary variables) and used them in verifying parallel programs. Subsequently, Abadi and Lamport [1] gave a more abstract, language independent definition of history variables, and also introduced the dual concept of a prophecy variable. <p> They are also widely used in the verification of concurrent and reactive systems. Some typical examples can be found in [28, 14]. There is also a long tradition of using history variables in program verification <ref> [32, 6, 43, 45] </ref>. Often history variables are used together with refinements, see for instance [27]. Forward simulations combine refinement mappings with history variables. Typical examples of their use appear in [19, 31, 34, 29, 42].
Reference: [33] <author> N.A. Lynch. </author> <title> Concurrency control for resilient nested transactions. Report TR-285, </title> <publisher> MIT, </publisher> <month> February </month> <year> 1983. </year>
Reference-contexts: We next consider forward simulations and backward simulations, generalizations of refinements that allow a set of states of B to correspond to a single state of A. Forward simulations are similar to the simulations of [44, 19, 21], the possibilities mappings of <ref> [33, 35] </ref>, the downward simulations of [17, 23, 13], the forward simulations of [22], and the history measures of [25].
Reference: [34] <author> N.A. Lynch. </author> <title> Multivalued possibilities mappings. </title> <editor> In J.W. de Bakker, W.P. de Roever, and G. Rozenberg, editors, </editor> <booktitle> Proceedings REX Workshop on Stepwise Refinement of Distributed Systems: Models, Formalism, Correctness, Mook, The Netherlands, May/June 1989, volume 430 of Lecture Notes in Computer Science, </booktitle> <pages> pages 519-543. </pages> <publisher> Springer-Verlag, </publisher> <year> 1990. </year>
Reference-contexts: There is also a long tradition of using history variables in program verification [32, 6, 43, 45]. Often history variables are used together with refinements, see for instance [27]. Forward simulations combine refinement mappings with history variables. Typical examples of their use appear in <ref> [19, 31, 34, 29, 42] </ref>. Bisimulations, which combine in a single relation forward simulations in two directions, play a vital role in the theory of process algebras [44, 41, 4]. Backward simulations have so far been much less widely used. <p> However, doing this either destroys the classification of Figure 6, or forces us to change the definitions of all the other simulations as well, with the result that the correspondence with previous work on simulations in action-based approaches (for instance, <ref> [19, 21, 22, 34, 35, 39] </ref>) gets lost. 2. In classical automata theory, there is a complete duality between past and future since besides start states there are also final states, and traces correspond to finite executions from a start state to a final state.
Reference: [35] <author> N.A. Lynch and M.R. Tuttle. </author> <title> Hierarchical correctness proofs for distributed algorithms. </title> <booktitle> In Proceedings of the 6 th Annual ACM Symposium on Principles of Distributed Computing, </booktitle> <pages> pages 137-151, </pages> <month> August </month> <year> 1987. </year> <note> A full version is available as MIT Technical Report MIT/LCS/TR-387. </note>
Reference-contexts: We next consider forward simulations and backward simulations, generalizations of refinements that allow a set of states of B to correspond to a single state of A. Forward simulations are similar to the simulations of [44, 19, 21], the possibilities mappings of <ref> [33, 35] </ref>, the downward simulations of [17, 23, 13], the forward simulations of [22], and the history measures of [25]. <p> For transitivity, use Lemma 3.8 to show that if f and f 0 are forward simulations from A to B and from B to C, respectively, f 0 ffi f is a forward simulation from A to C. Theorem 3.10 (Soundness of forward simulations, <ref> [35, 20, 47] </ref>) A F B ) A T B. Proof: Versions of this proof appear in the cited papers. The proof is similar to that of Theorem 3.4. Also the following result is well-known and variants of it have appeared in many papers (for instance in [19, 47]). <p> We have chosen this model because of its simplicity and because it is used both in the theory of I/O automata <ref> [35, 20] </ref> and in the theory of process algebras [4, 16, 41], two important approaches toward specification and verification of concurrent systems. <p> However, doing this either destroys the classification of Figure 6, or forces us to change the definitions of all the other simulations as well, with the result that the correspondence with previous work on simulations in action-based approaches (for instance, <ref> [19, 21, 22, 34, 35, 39] </ref>) gets lost. 2. In classical automata theory, there is a complete duality between past and future since besides start states there are also final states, and traces correspond to finite executions from a start state to a final state.
Reference: [36] <author> N.A. Lynch and F.W. Vaandrager. </author> <title> Forward and backward simulations for timing-based systems. </title> <editor> In J.W. de Bakker, C. Huizing, W.P. de Roever, and G. Rozenberg, editors, </editor> <booktitle> Proceedings REX Workshop on Real-Time: Theory in Practice, Mook, </booktitle> <address> The Netherlands, </address> <month> June </month> <year> 1991, </year> <booktitle> volume 600 of Lecture Notes in Computer Science, </booktitle> <pages> pages 397-446. </pages> <publisher> Springer-Verlag, </publisher> <year> 1992. </year>
Reference: [37] <author> N.A. Lynch and F.W. Vaandrager. </author> <title> Forward and backward simulations part I: Untimed systems. </title> <type> Report CS-R9313, </type> <institution> CWI, </institution> <address> Amsterdam, </address> <month> March </month> <year> 1993. </year> <note> Also, </note> <institution> MIT/LCS/TM-486, Laboratory for Computer Science, Massachusetts Institute of Technology, </institution> <address> Cambridge, MA. </address>
Reference-contexts: Now the fact that B is deterministic also implies u 1 = u 2 . The following proposition is mainly of technical interest. It is used as a lemma in the technical report version of this paper, <ref> [37] </ref>, to complete the classification of weak simulations (see Section 6). Proposition 3.20 Suppose all states of A are reachable, B has fin and A B B. Then A iB B. Proof: Let b be a backward simulation from A to B and let s be a state of A. <p> Alternatively, it is possible to derive these results as consequences of the corresponding results for the non-weak case. We do this in a technical report version of this paper, <ref> [37] </ref>. 30 7 Conclusions and Related Work In this paper, we have given a unified, comprehensive presentation of simulation proof methods for untimed automata, including refinements, forward and backward simulations and combinations thereof, and history and prophecy relations. <p> If B has fin, then A M B ) A N B for all automata A and B if and only if there is a path from M to N consisting of thin lines and thick lines. In the technical report version of this paper, <ref> [37] </ref>, this classification is extended to include the various weak simulations as well. iP P H F iBF BF T flT ? ? ? ? ? 66 The classification of Figure 6 has been established for a specific automaton model (la-beled transition systems with multiple start states but without final states)
Reference: [38] <author> N.A. Lynch and F.W. Vaandrager. </author> <title> Forward and backward simulations part II: Timing based systems. </title> <type> Report CS-R9314, </type> <institution> CWI, </institution> <address> Amsterdam, </address> <month> March </month> <year> 1993. </year> <note> Also, </note> <institution> MIT/LCS/TM-487, Laboratory for Computer Science, Massachusetts Institute of Technology, </institution> <address> Cam-bridge, MA. </address>
Reference-contexts: We present our results for the untimed setting in this paper, and extend them to the timed setting in Part II <ref> [38] </ref>. Specifically, in this paper, we present forward and backward simulation techniques for proving trace inclusion relationships between concurrent systems. We describe all the simulation techniques in terms of a simple and general untimed automaton model that includes internal actions. <p> We state results showing how invariants can be used in conjunction with all the types of simulations. We have crafted the development in this paper to be compatible with a similar development for timed systems; this work appears in Part II <ref> [38] </ref>. There, we define a new type 4 of automaton called a timed automaton, and use it to define timed versions of all the simulations in this paper. Happily, the results for the timed setting turn out to be analogous to those for the untimed setting. <p> In the definitions of these simulations additional clauses are present which for instance require that related states have the same initial actions. 5. All the automata studied in this paper have been untimed. In Part II <ref> [38] </ref>, the simu lation definitions and the results of this paper are extended to timed systems. In fact, 32 many of the results for the timed case are obtained as consequences of the analogous results for the untimed case.
Reference: [39] <author> M. Merritt. </author> <title> Completeness theorems for automata. </title> <editor> In J.W. de Bakker, W.P. de Roever, and G. Rozenberg, editors, </editor> <booktitle> Proceedings REX Workshop on Stepwise Refinement of Distributed Systems: Models, Formalism, Correctness, Mook, The Netherlands, May/June 1989, volume 430 of Lecture Notes in Computer Science, </booktitle> <pages> pages 544-560. </pages> <publisher> Springer-Verlag, </publisher> <year> 1990. </year>
Reference-contexts: Again, we give soundness and partial completeness results. Backward simulations are similar to the upward simulations of [17, 23, 13], the prophecy mappings of <ref> [39] </ref>, the backwards simulations of [21], and the prophecy measures of [25]. <p> Subsequently, Abadi and Lamport [1] gave a more abstract, language independent definition of history variables, and also introduced the dual concept of a prophecy variable. Several authors observed that history and prophecy variables are closely related to forward and backward simulations, respectively, <ref> [39, 22, 25] </ref>. Inspired by this, we define in this paper the even more abstract notions of history and prophecy relations, and show their equivalence with the history resp. prophecy variables of [1]. <p> It now follows that h 0 ffi h is a history relation from A to C. Although inspired by <ref> [39, 22, 25] </ref>, the notion of a history relation is a new contribution of this paper. It provides a simple and abstract view of the history variables of Abadi and Lamport [1] (which in turn are abstractions of the auxiliary variables of Owicki and Gries [43]). <p> However, doing this either destroys the classification of Figure 6, or forces us to change the definitions of all the other simulations as well, with the result that the correspondence with previous work on simulations in action-based approaches (for instance, <ref> [19, 21, 22, 34, 35, 39] </ref>) gets lost. 2. In classical automata theory, there is a complete duality between past and future since besides start states there are also final states, and traces correspond to finite executions from a start state to a final state. <p> There are a few results that depend on whether invariants are included in the definitions of the simulations. For example, the implication A B B ^ B has fin ) A iB B is not valid in our setting (Example 3.21), but does hold in the context of <ref> [39] </ref> because there reachability conditions are included in the definition of backward simulations (cf. Prop. 3.20). 4. Simulation techniques have not only been used to prove trace inclusion, but also for proving several other preorders from Van Glabbeek's [11, 12] linear time | branching time spectrum. <p> Several authors have observed that forward and backward simulations are closely related to history and prophecy variables, respectively, <ref> [39, 22, 25] </ref>. 9 Still we believe that, through Theorems 5.8 and 5.16, our paper is the first to establish an exact correspondence in a general setting of transition systems. In this paper we have only discussed simulation techniques at the semantic level of automata.
Reference: [40] <author> R. Milner. </author> <title> An algebraic definition of simulation between programs. </title> <booktitle> In Proceedings 2 nd Joint Conference on Artificial Intelligence, </booktitle> <pages> pages 481-489. </pages> <note> BCS, 1971. Also available as Report No. </note> <institution> CS-205, Computer Science Department, Stanford University, </institution> <month> February </month> <year> 1971. </year>
Reference-contexts: Refinements are similar to the homomorphism between automata in the sense of classical automata theory [10], and to the data refinements that are used in program development to replace abstract mathematical data structures by concrete structures that are more easily implemented <ref> [40, 15, 30, 18] </ref>. Lamport [28] advocates the use of refinements to prove that one concurrent program module implements another.
Reference: [41] <author> R. Milner. </author> <title> Communication and Concurrency. </title> <booktitle> Prentice-Hall International, </booktitle> <address> Englewood Cliffs, </address> <year> 1989. </year>
Reference-contexts: Forward simulations combine refinement mappings with history variables. Typical examples of their use appear in [19, 31, 34, 29, 42]. Bisimulations, which combine in a single relation forward simulations in two directions, play a vital role in the theory of process algebras <ref> [44, 41, 4] </ref>. Backward simulations have so far been much less widely used. Abadi and Lamport [1] demonstrate the usefulness of prophecy variables (and hence backward simulations), with some simple examples, while [29] contains a somewhat more practical example. <p> Proof: Immediate from the soundness of refinements and forward simulations. In fact, a history relation from A to B is just a functional (weak) bisimulation between A and B in the sense of Park [44] and Milner <ref> [41] </ref>. This implies that if there exists a history relation from A to B, both automata are observation-equivalent. Hence, history relations preserve the behavior of automata in a very strong sense. We can now state and prove the completeness results of Sistla [46]. <p> 2 I A then b [s] " I B 6= ;. 7 Sometimes, the term "invariant" is used with a slightly different meaning, to denote a property that holds initially and is preserved by all transitions. 8 This usage of the term "weak" has nothing to do with Milner's usage <ref> [41] </ref>; he uses it to indicate whether or not internal steps are abstracted away. 29 Thus, weak backward simulations allow use of invariants in all the hypothesized states. <p> We have chosen this model because of its simplicity and because it is used both in the theory of I/O automata [35, 20] and in the theory of process algebras <ref> [4, 16, 41] </ref>, two important approaches toward specification and verification of concurrent systems. Simulations techniques play an important role in many other models of computation, and variants of most of the simulations that we discuss here have been proposed in the literature for other models and other notions of behavior.
Reference: [42] <author> T. Nipkow. </author> <title> Formal verification of data type refinement | theory and practice. </title> <editor> In J.W. de Bakker, W.P. de Roever, and G. Rozenberg, editors, </editor> <booktitle> Proceedings REX Workshop on Stepwise Refinement of Distributed Systems: Models, Formalism, Correctness, Mook, The Netherlands, May/June 1989, volume 430 of Lecture Notes in Computer Science, </booktitle> <pages> pages 561-591. </pages> <publisher> Springer-Verlag, </publisher> <year> 1990. </year>
Reference-contexts: There is also a long tradition of using history variables in program verification [32, 6, 43, 45]. Often history variables are used together with refinements, see for instance [27]. Forward simulations combine refinement mappings with history variables. Typical examples of their use appear in <ref> [19, 31, 34, 29, 42] </ref>. Bisimulations, which combine in a single relation forward simulations in two directions, play a vital role in the theory of process algebras [44, 41, 4]. Backward simulations have so far been much less widely used.
Reference: [43] <author> S. Owicki and D. Gries. </author> <title> An axiomatic proof technique for parallel programs. </title> <journal> Acta Informatica, </journal> <volume> 6(4) </volume> <pages> 319-340, </pages> <year> 1976. </year>
Reference-contexts: The final simulations we consider are history relations and prophecy relations. These are new and abstract versions of the history and prophecy variables of Abadi and Lamport [1]. The basic concept of history variables goes back at least as far as Lucas [32]. Owicki and Gries <ref> [43] </ref> defined history variables (which they called auxiliary variables) and used them in verifying parallel programs. Subsequently, Abadi and Lamport [1] gave a more abstract, language independent definition of history variables, and also introduced the dual concept of a prophecy variable. <p> They are also widely used in the verification of concurrent and reactive systems. Some typical examples can be found in [28, 14]. There is also a long tradition of using history variables in program verification <ref> [32, 6, 43, 45] </ref>. Often history variables are used together with refinements, see for instance [27]. Forward simulations combine refinement mappings with history variables. Typical examples of their use appear in [19, 31, 34, 29, 42]. <p> Although inspired by [39, 22, 25], the notion of a history relation is a new contribution of this paper. It provides a simple and abstract view of the history variables of Abadi and Lamport [1] (which in turn are abstractions of the auxiliary variables of Owicki and Gries <ref> [43] </ref>). Translated into the setting of this paper, history variables can be simply defined in terms of history relations, as follows. <p> The results of [1, 8] are more general than ours because safety and liveness issues are separated through the use of automata that are equipped with additional liveness properties. History variables were first defined at the syntactic level for specific (parallel) programming languages. Owicki and Gries <ref> [43] </ref>, for instance, define an auxiliary variable set for a statement S to be a set of variables AV that appears in S only in assignments x := E, where x is in AV .
Reference: [44] <author> D.M.R. Park. </author> <title> Concurrency and automata on infinite sequences. </title> <editor> In P. Deussen, editor, </editor> <booktitle> 5 th GI Conference, volume 104 of Lecture Notes in Computer Science, </booktitle> <pages> pages 167-183. </pages> <publisher> Springer-Verlag, </publisher> <year> 1981. </year>
Reference-contexts: We give soundness and partial completeness results for refinements. We next consider forward simulations and backward simulations, generalizations of refinements that allow a set of states of B to correspond to a single state of A. Forward simulations are similar to the simulations of <ref> [44, 19, 21] </ref>, the possibilities mappings of [33, 35], the downward simulations of [17, 23, 13], the forward simulations of [22], and the history measures of [25]. <p> Forward simulations combine refinement mappings with history variables. Typical examples of their use appear in [19, 31, 34, 29, 42]. Bisimulations, which combine in a single relation forward simulations in two directions, play a vital role in the theory of process algebras <ref> [44, 41, 4] </ref>. Backward simulations have so far been much less widely used. Abadi and Lamport [1] demonstrate the usefulness of prophecy variables (and hence backward simulations), with some simple examples, while [29] contains a somewhat more practical example. <p> Theorem 5.5 (Soundness of history relations) A H B ) A T B. Proof: Immediate from the soundness of refinements and forward simulations. In fact, a history relation from A to B is just a functional (weak) bisimulation between A and B in the sense of Park <ref> [44] </ref> and Milner [41]. This implies that if there exists a history relation from A to B, both automata are observation-equivalent. Hence, history relations preserve the behavior of automata in a very strong sense. We can now state and prove the completeness results of Sistla [46].
Reference: [45] <author> J.C. Reynolds. </author> <title> The Craft of Programming. </title> <booktitle> Prentice-Hall International, </booktitle> <address> Englewood Cliffs, </address> <year> 1981. </year>
Reference-contexts: They are also widely used in the verification of concurrent and reactive systems. Some typical examples can be found in [28, 14]. There is also a long tradition of using history variables in program verification <ref> [32, 6, 43, 45] </ref>. Often history variables are used together with refinements, see for instance [27]. Forward simulations combine refinement mappings with history variables. Typical examples of their use appear in [19, 31, 34, 29, 42].
Reference: [46] <author> A.P. Sistla. </author> <title> Proving correctness with respect to nondeterministic safety specifications. </title> <journal> Information Processing Letters, </journal> <volume> 39(1) </volume> <pages> 45-49, </pages> <month> July </month> <year> 1991. </year>
Reference-contexts: This implies that if there exists a history relation from A to B, both automata are observation-equivalent. Hence, history relations preserve the behavior of automata in a very strong sense. We can now state and prove the completeness results of Sistla <ref> [46] </ref>. Theorem 5.6 (Completeness of history relations and backward simulations, [46]) Suppose A flT B. Then 1. 9C : A H C B B, and 2. if B has fin then 9C : A H C iB B. Proof: Take C = unfold (A). <p> Hence, history relations preserve the behavior of automata in a very strong sense. We can now state and prove the completeness results of Sistla <ref> [46] </ref>. Theorem 5.6 (Completeness of history relations and backward simulations, [46]) Suppose A flT B. Then 1. 9C : A H C B B, and 2. if B has fin then 9C : A H C iB B. Proof: Take C = unfold (A). By Prop. 5.1, C is a forest and A H C.
Reference: [47] <author> E.W. Stark. </author> <title> Proving entailment between conceptual state specifications. </title> <journal> Theoretical Computer Science, </journal> <volume> 56 </volume> <pages> 135-154, </pages> <year> 1988. </year>
Reference-contexts: For transitivity, use Lemma 3.8 to show that if f and f 0 are forward simulations from A to B and from B to C, respectively, f 0 ffi f is a forward simulation from A to C. Theorem 3.10 (Soundness of forward simulations, <ref> [35, 20, 47] </ref>) A F B ) A T B. Proof: Versions of this proof appear in the cited papers. The proof is similar to that of Theorem 3.4. Also the following result is well-known and variants of it have appeared in many papers (for instance in [19, 47]). <p> Proof: Versions of this proof appear in the cited papers. The proof is similar to that of Theorem 3.4. Also the following result is well-known and variants of it have appeared in many papers (for instance in <ref> [19, 47] </ref>). Theorem 3.11 (Partial completeness of forward simulations) Suppose B is deterministic and A flT B. Then A F B. Proof: The relation f = after (B ) ffi past (A) is a forward simulation from A to B.
Reference: [48] <author> J. von Wright. </author> <title> The lattice of data refinement. </title> <journal> Acta Informatica, </journal> <volume> 31 </volume> <pages> 105-135, </pages> <year> 1994. </year>
Reference-contexts: We preferred not to use this notion since it fails to reduce reasoning about entire executions to reasoning about individual states and transitions. 7. This paper is related to the work of <ref> [17, 18, 3, 7, 48] </ref> on data refinement. In [17], an operation is a binary relation over some universal set .
References-found: 48

