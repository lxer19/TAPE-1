URL: http://osl.cs.uiuc.edu/Papers/cacm-sturman.ps
Refering-URL: http://osl.cs.uiuc.edu/ExMembers/sturman/
Root-URL: http://www.cs.uiuc.edu
Email: Email: fsturman j aghag@cs.uiuc.edu  
Phone: Phone: (217) 244-3087 Fax: (217) 333-3501  
Title: Modular Development of Distributed Software DRAFT: Do not circulate or cite  
Author: Daniel C. Sturman and Gul A. Agha 
Address: 1304 W. Springfield Avenue  Urbana, IL 61801, USA  
Affiliation: Department of Computer Science  University of Illinois at Urbana-Champaign  
Abstract: With increased interconnectivity, distributed systems have become central to computing. Software executing on distributed systems consists of many asynchronous, autonomous components which need to interact with each other in order to coordinate local activity. The need for such coordination, as well as requirements such as heterogeneity, scalability, security and availability, considerably increase the complexity of code in distributed systems. Moreover, changing requirements, as well as changes in hardware platforms, lead to software that is constantly evolving. We are developing a programming methodology to simplify the design, implementation and maintenance of complex distributed systems. Two key ideas inspire our methodology. First, distributed systems may be separated into a collection of components carrying out computations locally and a collection of policies describing interactions between groups of components. Such interaction policies provide the glue between components (Figure 1). Second, generic design concerns such as availability, consistency, and security can be represented as application independent protocols which are composed with applications to meet particular requirements. We achieve the desired separation of interaction policies and application components by separating the policies from the mechanisms that are used to implement them. An interaction policy corresponds to the interface of a protocol; the mechanisms used to implement it are its representation. A protocol representation is in terms of a meta-architecture which by design provides a degree of independence from the application level components. Encapsulating a protocol representation in an abstraction boundary is in the spirit of abstract data types. Much as object-oriented programming realizes abstract data types by enabling the publication of a component's interface while hiding its implementation, protocol abstractions present an interface representing the interaction policy while hiding the details of the coordination mechanisms used to implement the policy. Observe that an 
Abstract-found: 1
Intro-found: 1
Reference: [ABB + 86] <author> M. Acceta, R. Baron, W. Bolosky, D. Golub, R. Rashid, A. Tevanian, and M. Young. </author> <title> Mach: A New Kernel Foundation for UNIX Development. </title> <booktitle> In USENIX 1986 Summer Conference Proceedings, </booktitle> <month> June </month> <year> 1986. </year>
Reference-contexts: SIDEBAR:Reflection Traditionally software has been organized into two levels: application and system. Applications interact with the system through system-calls, thereby invoking a predefined function at the system level. To extend this model to support customization, micro-kernels move much of the functionality reserved for the system into the application domain <ref> [ABB + 86] </ref>. Object-oriented operating systems also support customization through the use of frameworks: sets of classes customizing the operating system for a particular execution environment [CIRM93].
Reference: [AFPS93] <author> G. Agha, S. Frtlund, R. Panwar, and D. Sturman. </author> <title> A Linguistic Framework for the Dynamic Composition of Dependability Protocols. </title> <editor> In C.E. Landwehr, B. Randell, and L. Simoncini, editors, </editor> <title> Dependable Computing for Critical Applications 3, </title> <booktitle> volume VIII of Dependable Computing and Fault-Tolerant Systems, </booktitle> <pages> pages 345-363. </pages> <publisher> IFIP Transactions, Springer-Verlag, </publisher> <year> 1993. </year>
Reference-contexts: Tool-kits, although lacking generality, are well suited to applications requiring only the protocols they provide. For example, transaction systems are ideal for distributed database applications, but unsuitable for applications involving real-time synchronization. Customization of component interactions has been explored in the x-Kernel [HP91] Maud <ref> [AFPS93] </ref>, and more recently in Horus [vRBF + 95]. The x-Kernel and Horus utilize protocol stacks to support customization. Each layer in the stack supports a static interface for interaction with the layers above and below it. The interface in these systems is fairly elaborate.
Reference: [Agh86] <author> Gul Agha. </author> <title> Actors: A Model of Concurrent Computation in Distributed Systems. </title> <publisher> MIT Press, </publisher> <year> 1986. </year>
Reference-contexts: These procedures, called methods, manipulate the local state of the object when invoked. In particular, this implies that representations which support the same functionality may be interchanged transparently. We model components as collections of concurrent objects based on the Actor model <ref> [Agh86] </ref>. Actors extend the object model by encapsulating a thread of control together with the state and set of procedures. Actors are a powerful modeling device: memory chips, control devices, actuators, programs, and entire computers can be uniformly represented as actors.
Reference: [Agh90] <author> G. Agha. </author> <title> Concurrent Object-Oriented Programming. </title> <journal> Communications of the ACM, </journal> <volume> 33(9) </volume> <pages> 125-141, </pages> <month> September </month> <year> 1990. </year>
Reference-contexts: Asynchronous communication preserves the available potential for parallel activity: an actor sending a message asynchronously need not block until the recipient is ready to receive (or process) a message. Furthermore, more complex communication patterns, such as RPC, can easily be expressed as a series of asynchronous messages <ref> [Agh90] </ref>. Actors may also create new actors. Actor creation returns a new mail address which serves as an endpoint for actor creation. SIDEBAR:Reflection Traditionally software has been organized into two levels: application and system. Applications interact with the system through system-calls, thereby invoking a predefined function at the system level.
Reference: [AMST96] <author> Gul A. Agha, Ian Mason, Scott Smith, and Carolyn Talcott. </author> <title> A Foundation for Actor Computation. </title> <journal> Journal of Functional Programming, </journal> <note> 1996. (to be published). </note>
Reference-contexts: Actors are a powerful modeling device: memory chips, control devices, actuators, programs, and entire computers can be uniformly represented as actors. Moreover, the Actor model provides a mathematical foundation for reasoning about dynamic creation and reconfiguration in open distributed systems <ref> [AMST96] </ref>.
Reference: [CIRM93] <author> Roy Campbell, Nayeem Islam, David Raila, and Peter Madany. </author> <title> Designing and Implementing Choices: An Object-Oriented System in C++. </title> <journal> Communications of the ACM, </journal> <pages> pages 117-126, </pages> <month> September </month> <year> 1993. </year>
Reference-contexts: To extend this model to support customization, micro-kernels move much of the functionality reserved for the system into the application domain [ABB + 86]. Object-oriented operating systems also support customization through the use of frameworks: sets of classes customizing the operating system for a particular execution environment <ref> [CIRM93] </ref>. These approaches, however, result in coarse-grained customization of a system. 5 In many cases, optimization of an application requires customization on a per-object basis. Reflection provides this ability by allowing application objects to customize the system behavior that describes their own behavior [Smi82] (Figure 4).
Reference: [EMS91] <author> Jeffrey L. Eppinger, Lily B. Mummert, and Alfred Z. Spector, </author> <title> editors. CAMELOT AND AVALON: A Distributed Transaction Facility. </title> <publisher> Morgan Kaufmann Publishers, Inc., </publisher> <year> 1991. </year>
Reference-contexts: Discussion Modularity and customizability are important techniques for software development. Modularity is one attraction of tool-kits for distributed programming. Tool-kits support a small set of protocols for interconnecting application components. For example, in transaction languages such as Avalon <ref> [EMS91] </ref>, the concept of nested transactions is used to structure distributed systems. Tool-kits, although lacking generality, are well suited to applications requiring only the protocols they provide. For example, transaction systems are ideal for distributed database applications, but unsuitable for applications involving real-time synchronization.
Reference: [FB88] <author> Jacques Ferber and Jean-Pierre Briot. </author> <booktitle> Design of a Concurrent Language for Distributed Artificial Intelligence. In Proceedings of the International Conference on Fifth Generation Computer Systems, </booktitle> <volume> volume 2, </volume> <pages> pages 755-762. </pages> <institution> Institute for New Generation Computer Technology, </institution> <year> 1988. </year>
Reference-contexts: Possible customizations include improving continuity of memory values or supporting automatic garbage collection. Invocation of the meta-object is completely transparent to the application: code for the reflective and non-reflective systems is identical. Reflective frameworks for the Actor languages MERING IV and Rosette have been proposed in <ref> [FB88] </ref> and [TS89], respectively. In MERING IV, programs may access meta-instances to modify an object or meta-classes to change a class definition.
Reference: [Frt96] <author> Svend Frtlund. </author> <title> Coordinating Distributed Objects: An Actor-Based Approach to Synchronization. </title> <publisher> MIT Press, </publisher> <year> 1996. </year>
Reference-contexts: Broadway provides C++ support for distributed actor programs including asynchronous communication, dynamic actor creation, and scheduling of actors. Basic actor functionality is augmented with support for migration, exception handling, and synchronization constraints <ref> [Frt96] </ref>. These additional features greatly simplify the development of distributed programs. The platform currently runs on Ultrix for DEC MIPS workstations, on Solaris for SUN Sparc-stations, and IRIX 5 for SGI workstations. Broadway supports basic actor functionality using a multi-thread scheduler, distributed name service, and platform independent communication service.
Reference: [HP91] <author> Norman C. Hutchinson and Larry L. Peterson. </author> <title> The x-Kernel: An Architecture for Implementing Network Protocols. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 17(1) </volume> <pages> 64-75, </pages> <month> January </month> <year> 1991. </year> <month> 13 </month>
Reference-contexts: Tool-kits, although lacking generality, are well suited to applications requiring only the protocols they provide. For example, transaction systems are ideal for distributed database applications, but unsuitable for applications involving real-time synchronization. Customization of component interactions has been explored in the x-Kernel <ref> [HP91] </ref> Maud [AFPS93], and more recently in Horus [vRBF + 95]. The x-Kernel and Horus utilize protocol stacks to support customization. Each layer in the stack supports a static interface for interaction with the layers above and below it. The interface in these systems is fairly elaborate.
Reference: [Kep93] <author> David Keppel. </author> <title> Tools and Techniques for Building Fast Portable Threads Packages. </title> <institution> Tech--nical Report UWCSE 93-05-06, University of Washington, Department of Computer Science and Engineering, </institution> <year> 1993. </year>
Reference-contexts: With one notable exception | replies from RPC invocations | only one method may be active for a single actor: there is no internal concurrency. User threads have been implemented using the QuickThreads package <ref> [Kep93] </ref>. Threads provide fairness in our actor environment: a method which does not terminate cannot prevent the progress of other actors. Threads also allow us to implement an RPC mechanism.
Reference: [Ng90] <author> Tony P. Ng. </author> <title> Probabilistic Failure Detection Using Watchdog Timers. </title> <type> Technical Report UIUCDCS-R-90-1521, </type> <institution> University of Illinois, Department of Computer Science, </institution> <month> March </month> <year> 1990. </year>
Reference-contexts: In addition to run-time functionality, Broadway includes a library of system actors. These actors include an I/O and file system interface, a failure detector, and a migration controller. The failure detector uses a watch-dog timer approach <ref> [Ng90] </ref> to detect crash failures in remote workstations. Application actors interact with system actors using standard asynchronous message passing. 11 Broadway supports customization of actor communication through reflection, thereby providing an implementation platform for Dil. All actors may be customized including meta-level actors.
Reference: [SA96] <author> Daniel C. Sturman and Gul A. Agha. </author> <title> Customizing Dependability with Reusable Software Components. </title> <journal> Transactions on Computer Systems, </journal> <note> 1996. (under submission; draft available from ftp://osl-www.cs.uiuc.edu). </note>
Reference-contexts: Experiment Hard-Coded DIL % Overhead Single Node 2.50 s 2.60 s 4.0% Distributed 50.07 s 50.94 s 1.7% Table 1: Results from experiments on SparcStation IPX workstations. Broadway implements Dil with minimal overhead <ref> [SA96] </ref>. Table 1 shows performance measurements taken on a primary-backup protocol installed on a small database application. Two versions of the application were developed: the first involving a hand-coded version of the protocol embedded into the application code and the second using Dil.
Reference: [Smi82] <author> B. C. Smith. </author> <title> Reflection and Semantics in a Procedural Language. </title> <type> Technical Report 272, </type> <institution> Massachusetts Institute of Technology. Laboratory for Computer Science, </institution> <year> 1982. </year>
Reference-contexts: These approaches, however, result in coarse-grained customization of a system. 5 In many cases, optimization of an application requires customization on a per-object basis. Reflection provides this ability by allowing application objects to customize the system behavior that describes their own behavior <ref> [Smi82] </ref> (Figure 4). Reflection is realized through manipulation of system (or meta-) level objects which implement some functionality in an object's behavior. For example, meta-level objects may customize memory allocation on a per-object basis. Traditionally, an object allocates memory by making a system call.
Reference: [Stu94] <author> Daniel C. Sturman. </author> <title> Fault-Adaptation for Systems in Unpredictable Environments. </title> <type> Master's thesis, </type> <institution> University of Illinois at Urbana-Champaign, </institution> <month> January </month> <year> 1994. </year>
Reference-contexts: Assumption of these roles is carried out in the protocol initialization and operators: ProtocolInstance *pb = newProtocol Two-Phase (MultiMedia); pb!addServer (Client); pb!addServer (Bank); Implementation We have implemented our approach on the actor platform Broadway <ref> [Stu94] </ref>. Broadway provides C++ support for distributed actor programs including asynchronous communication, dynamic actor creation, and scheduling of actors. Basic actor functionality is augmented with support for migration, exception handling, and synchronization constraints [Frt96]. These additional features greatly simplify the development of distributed programs.
Reference: [TS89] <author> C. Tomlinson and V. Singh. </author> <title> Inheritance and Synchronization with Enabled-Sets. </title> <booktitle> In OOPSLA Proceedings, </booktitle> <year> 1989. </year>
Reference-contexts: Possible customizations include improving continuity of memory values or supporting automatic garbage collection. Invocation of the meta-object is completely transparent to the application: code for the reflective and non-reflective systems is identical. Reflective frameworks for the Actor languages MERING IV and Rosette have been proposed in [FB88] and <ref> [TS89] </ref>, respectively. In MERING IV, programs may access meta-instances to modify an object or meta-classes to change a class definition.
Reference: [vRBF + 95] <author> Robbert van Renesse, Kenneth P. Birman, Roy Friedman, Mark Hayden, and David A. Karr. </author> <title> A Framework for Protocol Composition in Horus. </title> <booktitle> In Proceedings of the Fourteenth Annual ACM Symposium on Principles of Distributed Computing, </booktitle> <month> August </month> <year> 1995. </year> <month> 14 </month>
Reference-contexts: For example, transaction systems are ideal for distributed database applications, but unsuitable for applications involving real-time synchronization. Customization of component interactions has been explored in the x-Kernel [HP91] Maud [AFPS93], and more recently in Horus <ref> [vRBF + 95] </ref>. The x-Kernel and Horus utilize protocol stacks to support customization. Each layer in the stack supports a static interface for interaction with the layers above and below it. The interface in these systems is fairly elaborate. Maud supports meta-level customization of protocols for fault-tolerance.
References-found: 17

