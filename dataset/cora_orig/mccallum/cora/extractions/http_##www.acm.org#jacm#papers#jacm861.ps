URL: http://www.acm.org/jacm/papers/jacm861.ps
Refering-URL: http://www.acm.org/jacm/Upcoming.html
Root-URL: 
Title: Fault-tolerant Wait-free Shared Objects  
Author: Prasad Jayanti Tushar Deepak Chandra Sam Toueg 
Abstract: Wait-free implementations of shared objects tolerate the failure of processes, but not the failure of base objects from which they are implemented. We consider the problem of implementing shared objects that tolerate the failure of both processes and base objects. We identify two classes of object failures: responsive and non-responsive. With responsive failures, a faulty object responds to every operation, but its responses may be incorrect. With non-responsive failures, a faulty object may also "hang" without responding. In each class, we define crash, omission, and arbitrary modes of failure. We show that all responsive failure modes can be tolerated. More precisely, for all responsive failure modes F, object types T , and t 0, we show how to implement a shared object of type T which is t-tolerant for F. Such an object remains correct and wait-free even if up to t base objects fail according to F. In contrast to responsive failures, we show that even the most benign non-responsive failure mode cannot be tolerated. We also show that randomization can be used to circumvent this impossibility result. Graceful degradation is a desirable property of fault-tolerant implementations: the implemented object never fails more severely than the base objects it is derived from, even if all the base objects fail. For several failure modes, we show whether this property can be achieved, and, if so, how.
Abstract-found: 1
Intro-found: 1
Reference: [AGMT92] <author> Y. Afek, D. Greenberg, M. Merritt, and G. Taubenfeld. </author> <title> Computing with faulty shared memory. </title> <booktitle> In Proceedings of the 11th Annual ACM Symposium on Principles of Distributed Computing, </booktitle> <pages> pages 47-58, </pages> <month> August </month> <year> 1992. </year>
Reference-contexts: We study the problem of designing t-tolerant and/or gracefully degrading implementations for the various responsive and non-responsive failure modes. An independent work by Afek, Greenberg, Merritt, and Taubenfeld <ref> [AGMT92, AGMT95] </ref> has the same general goal, but differs in many respects. We present a comparison of the two works in Section 8. 1.2 Summary of results The three main topics studied are: tolerating responsive failures, tolerating non-responsive failures, and achieving graceful degradation. <p> The three main topics | tolerating responsive failures, tolerating non-responsive failures, and the feasibility of graceful degradation for crash and omission failure modes | are studied in Sections 5, 6, and 7, respectively. In Section 8, we present a comparison with the results in <ref> [AGMT92, AGMT95] </ref>. 2 Model 2.1 I/O Automata Our description of I/O automata is brief. The reader is referred to the work of Lynch and Tuttle for details [LT88]. <p> argument presented at the beginning of Section 7.2, we have Theorem 7.3 Every type has a t-tolerant gracefully degrading implementation from every universal set of types for omission. 8 Related work In an independent work, Afek et al. consider the problem of coping with shared memory subject to memory failures <ref> [AGMT92, AGMT95] </ref>. Informally, each failure is modeled as a faulty write. The following failure modes are considered: A. There is a bound m on the total number of faulty writes. B. <p> A different failure model is obtained for k = 1. In our terminology, these failure modes are responsive. The second one, with k = 1, corresponds to our arbitrary failure mode. <ref> [AGMT92] </ref> focuses on fault-tolerant implementations of the following types of objects: safe, atomic, binary, and V -valued register from various types of registers; N - process test&set from N -process test&set and bounded register; and N-consensus from read-modify-write (RMW). [AGMT92] also gives a universal fault-tolerant implementation from unbounded RMW, based on <p> one, with k = 1, corresponds to our arbitrary failure mode. <ref> [AGMT92] </ref> focuses on fault-tolerant implementations of the following types of objects: safe, atomic, binary, and V -valued register from various types of registers; N - process test&set from N -process test&set and bounded register; and N-consensus from read-modify-write (RMW). [AGMT92] also gives a universal fault-tolerant implementation from unbounded RMW, based on Herlihy's universal implementation. The main differences between [AGMT92] and this paper are as follows: 1. [AGMT92] does not consider any non-responsive failure mode. 2. <p> types of objects: safe, atomic, binary, and V -valued register from various types of registers; N - process test&set from N -process test&set and bounded register; and N-consensus from read-modify-write (RMW). <ref> [AGMT92] </ref> also gives a universal fault-tolerant implementation from unbounded RMW, based on Herlihy's universal implementation. The main differences between [AGMT92] and this paper are as follows: 1. [AGMT92] does not consider any non-responsive failure mode. 2. Amongst the responsive failure modes, benign ones, such as crash and omission, are also not considered in [AGMT92]. 3. <p> -valued register from various types of registers; N - process test&set from N -process test&set and bounded register; and N-consensus from read-modify-write (RMW). <ref> [AGMT92] </ref> also gives a universal fault-tolerant implementation from unbounded RMW, based on Herlihy's universal implementation. The main differences between [AGMT92] and this paper are as follows: 1. [AGMT92] does not consider any non-responsive failure mode. 2. Amongst the responsive failure modes, benign ones, such as crash and omission, are also not considered in [AGMT92]. 3. This paper does not consider failure modes that bound the number of times faulty objects can fail (in [AGMT92], each "faulty write" is <p> The main differences between <ref> [AGMT92] </ref> and this paper are as follows: 1. [AGMT92] does not consider any non-responsive failure mode. 2. Amongst the responsive failure modes, benign ones, such as crash and omission, are also not considered in [AGMT92]. 3. This paper does not consider failure modes that bound the number of times faulty objects can fail (in [AGMT92], each "faulty write" is counted as a failure). 4. The two approaches to modeling failures appear to be fundamentally different. <p> are as follows: 1. <ref> [AGMT92] </ref> does not consider any non-responsive failure mode. 2. Amongst the responsive failure modes, benign ones, such as crash and omission, are also not considered in [AGMT92]. 3. This paper does not consider failure modes that bound the number of times faulty objects can fail (in [AGMT92], each "faulty write" is counted as a failure). 4. The two approaches to modeling failures appear to be fundamentally different. There is no direct way to model benign failures, such as crash and omission failures, with "faulty writes". <p> This paper introduces the concept of graceful degradation, and presents several re-lated results, in particular, for crash and omission failure modes. For arbitrary failures, graceful degradation reduces to the "strong wait-freedom" concept introduced in <ref> [AGMT92] </ref>. 6. In the Open Problems section of [AGMT92] it is stated: "It would be particularly interesting to implement memory-fault tolerant data objects directly from similar, faulty objects, such as test-and-set from test-and-set, without using atomic registers, or read-modify-write from read modify-write, without using an unbounded universal construction." It is interesting <p> This paper introduces the concept of graceful degradation, and presents several re-lated results, in particular, for crash and omission failure modes. For arbitrary failures, graceful degradation reduces to the "strong wait-freedom" concept introduced in <ref> [AGMT92] </ref>. 6. In the Open Problems section of [AGMT92] it is stated: "It would be particularly interesting to implement memory-fault tolerant data objects directly from similar, faulty objects, such as test-and-set from test-and-set, without using atomic registers, or read-modify-write from read modify-write, without using an unbounded universal construction." It is interesting to note that both of these types do <p> For bounded RMW, this is a direct consequence of Corollary 5.1. For N -process test&set, one can combine the fault-tolerant implementation of test&set from ftest&set, bounded registerg <ref> [AGMT92] </ref>, with the implementation of bounded register from test&set presented in [JCT96]. 7. The existence of a fault-tolerant self -implementation of consensus, shown in this paper, does not follow from the results in [AGMT92]. 8. The fault-tolerant implementation of N -process test&set from ftest&set, bounded registerg, shown in [AGMT92], does not <p> For N -process test&set, one can combine the fault-tolerant implementation of test&set from ftest&set, bounded registerg <ref> [AGMT92] </ref>, with the implementation of bounded register from test&set presented in [JCT96]. 7. The existence of a fault-tolerant self -implementation of consensus, shown in this paper, does not follow from the results in [AGMT92]. 8. The fault-tolerant implementation of N -process test&set from ftest&set, bounded registerg, shown in [AGMT92], does not follow from our results (when N &gt; 2). Acknowledgement We would like to thank Vassos Hadzilacos, Jon Kleinberg, Nancy Lynch, Sendhil Mul-lainathan, Gil Neiger, King Tan, and the anonymous referees. <p> bounded registerg <ref> [AGMT92] </ref>, with the implementation of bounded register from test&set presented in [JCT96]. 7. The existence of a fault-tolerant self -implementation of consensus, shown in this paper, does not follow from the results in [AGMT92]. 8. The fault-tolerant implementation of N -process test&set from ftest&set, bounded registerg, shown in [AGMT92], does not follow from our results (when N &gt; 2). Acknowledgement We would like to thank Vassos Hadzilacos, Jon Kleinberg, Nancy Lynch, Sendhil Mul-lainathan, Gil Neiger, King Tan, and the anonymous referees. Their comments on earlier drafts helped us improve the presentation.
Reference: [AGMT95] <author> Y. Afek, D. Greenberg, M. Merritt, and G. Taubenfeld. </author> <title> Computing with faulty shared objects. </title> <journal> JACM, </journal> <volume> 42(6) </volume> <pages> 1231-1274, </pages> <year> 1995. </year>
Reference-contexts: We study the problem of designing t-tolerant and/or gracefully degrading implementations for the various responsive and non-responsive failure modes. An independent work by Afek, Greenberg, Merritt, and Taubenfeld <ref> [AGMT92, AGMT95] </ref> has the same general goal, but differs in many respects. We present a comparison of the two works in Section 8. 1.2 Summary of results The three main topics studied are: tolerating responsive failures, tolerating non-responsive failures, and achieving graceful degradation. <p> The three main topics | tolerating responsive failures, tolerating non-responsive failures, and the feasibility of graceful degradation for crash and omission failure modes | are studied in Sections 5, 6, and 7, respectively. In Section 8, we present a comparison with the results in <ref> [AGMT92, AGMT95] </ref>. 2 Model 2.1 I/O Automata Our description of I/O automata is brief. The reader is referred to the work of Lynch and Tuttle for details [LT88]. <p> argument presented at the beginning of Section 7.2, we have Theorem 7.3 Every type has a t-tolerant gracefully degrading implementation from every universal set of types for omission. 8 Related work In an independent work, Afek et al. consider the problem of coping with shared memory subject to memory failures <ref> [AGMT92, AGMT95] </ref>. Informally, each failure is modeled as a faulty write. The following failure modes are considered: A. There is a bound m on the total number of faulty writes. B.
Reference: [Asp90] <author> J. Aspnes. </author> <title> Time and space efficient randomized consensus. </title> <booktitle> In Proceedings of the 9th Annual ACM Symposium on Principles of Distributed Computing, </booktitle> <year> 1990. </year>
Reference-contexts: We ask whether randomization can be used to circumvent these impossibility results. The answer is yes. Specifically, we show that register has a t-tolerant (deterministic) self -implementation even for NR-arbitrary failures. Furthermore, randomized implementations of consensus from register are well-known (for example, see <ref> [Asp90] </ref>). <p> Interestingly, every type has a randomized implementation from register [Her91a], but most types have no (deterministic) implementations from register [Her91b]. In the following, we present a generalization of the former result. consensus with safe-reset has a randomized implementation from register <ref> [Asp90] </ref>. Together with Theorem 6.4, this implies that consensus with safe-reset has a t-tolerant randomized implementation from register for NR-arbitrary failures. Combining this with Theorem 6.4, and Theorems 5.5 and 5.6 of Herlihy and Plotkin, we have 9 Observe that every implementation is automatically gracefully degrading for NR-arbitrary failures.
Reference: [BGP89] <author> P. Berman, J. Garay, and K.J. Perry. </author> <title> Towards optimal distributed consensus. </title> <booktitle> In Proceedings of the 30th Annual Symposium on Foundations of Computer Science, </booktitle> <pages> pages 410-415, </pages> <year> 1989. </year> <month> 54 </month>
Reference: [Blo87] <author> B. Bloom. </author> <title> Constructing two writer atomic registers. </title> <booktitle> In Proceedings of the 6th Annual ACM Symposium on Principles of Distributed Computing, </booktitle> <pages> pages 249-259, </pages> <year> 1987. </year>
Reference: [BP87] <author> J. Burns and G. Peterson. </author> <title> Constructing multi-reader atomic values from nonatomic values. </title> <booktitle> In Proceedings of the 6th Annual ACM Symposium on Principles of Distributed Computing, </booktitle> <pages> pages 222-231, </pages> <year> 1987. </year>
Reference: [CHP71] <author> P.J. Courtois, F. Heymans, and D.L. Parnas. </author> <title> Concurrent control with readers and writers. </title> <journal> Communications of the ACM, </journal> <volume> 14(10) </volume> <pages> 667-668, </pages> <year> 1971. </year>
Reference-contexts: In such systems, complex (shared) objects, such as queues and stacks, are implemented in software from simple objects, such as registers and test&sets, which are often supported in hardware. Traditional implementations (for example, <ref> [CHP71] </ref>) fl A preliminary version of this appeared in the proceedings of the 33rd IEEE Annual Symposium on Foundations of Computer Science, October, 1992. y Research partially supported by CCR-9102231 and NSF RIA grant CCR-9410421. Address: 6211 Sudikoff Lab for Computer Science, Dartmouth College, Hanover, NH 03755. z IBM T.J.
Reference: [Coa87] <author> B.A. Coan. </author> <title> Achieving consensus in fault-tolerant distributed computer systems: protocols, lower bounds, and simulations. </title> <type> PhD thesis, </type> <institution> Massachusetts Institute of Technology, </institution> <month> June </month> <year> 1987. </year>
Reference: [CW92] <author> B.A. Coan and J.L. Welch. </author> <title> Modular construction of a byzantine agreement protocol with optimal message bit complexity. </title> <journal> Information and Computation, </journal> <volume> 97(1) </volume> <pages> 61-85, </pages> <year> 1992. </year>
Reference: [DDS87] <author> D. Dolev, C. Dwork, and L. Stockmeyer. </author> <title> On the minimal synchronism needed for distributed consensus. </title> <journal> Journal of the ACM, </journal> <volume> 34(1) </volume> <pages> 77-97, </pages> <month> January </month> <year> 1987. </year>
Reference-contexts: implementation from fconsensus; registerg for omission. 2 The impossibility of implementing a fault-tolerant consensus object from any finite set of base objects, one of which may fail by NR-crash, is shown using the impossibility of solving the consensus problem among a finite number of processes, one of which may crash <ref> [FLP85, LAA87, DDS87] </ref>. 4 1.2.4 Conclusions The following are our main conclusions: (1) It is feasible to design deterministic implementations that tolerate even the most severe of the responsive failures, viz., arbitrary failures, (2) Implementations cannot tolerate even the simplest of non-responsive failures, viz., crash failures, without the use of randomization, <p> In each case, to prove that a certain implementation I does not exist, we show that if I exists, it would violate the well-known impossibility result due to Loui and Abu-Amara [LAA87] and Dolev, Dwork, and Stockmeyer <ref> [DDS87] </ref>. This result is about the consensus problem for n processes, defined informally as follows. Each process P i is initially given an input v i 2 f0; 1g.
Reference: [DRS90] <author> D. Dolev, R. Reischuk, and H.R. </author> <title> Strong. Early stopping in byzantine agreement. </title> <journal> Journal of the ACM, </journal> <volume> 37(4) </volume> <pages> 720-741, </pages> <year> 1990. </year>
Reference: [FLM86] <author> M. Fischer, N. Lynch, and M. Merritt. </author> <title> Easy impossibility proofs for distributed consensus problems. </title> <journal> Distributed Computing, </journal> <volume> 1 </volume> <pages> 26-39, </pages> <year> 1986. </year>
Reference: [FLP85] <author> M. Fischer, N. Lynch, and M. Paterson. </author> <title> Impossibility of distributed consensus with one faulty process. </title> <journal> JACM, </journal> <volume> 32(2) </volume> <pages> 374-382, </pages> <year> 1985. </year>
Reference-contexts: implementation from fconsensus; registerg for omission. 2 The impossibility of implementing a fault-tolerant consensus object from any finite set of base objects, one of which may fail by NR-crash, is shown using the impossibility of solving the consensus problem among a finite number of processes, one of which may crash <ref> [FLP85, LAA87, DDS87] </ref>. 4 1.2.4 Conclusions The following are our main conclusions: (1) It is feasible to design deterministic implementations that tolerate even the most severe of the responsive failures, viz., arbitrary failures, (2) Implementations cannot tolerate even the simplest of non-responsive failures, viz., crash failures, without the use of randomization, <p> We arrive at a contradiction after a series of lemmas involving bivalency arguments <ref> [FLP85] </ref> and indistinguishable scenarios.
Reference: [Her88] <author> M.P. Herlihy. </author> <title> Impossibility and universality results for wait-free synchronization. </title> <booktitle> In Proceedings of the 7th Annual ACM Symposium on Principles of Distributed Computing, </booktitle> <year> 1988. </year>
Reference-contexts: has an implementation from a set S of types if it is possible to wait-free implement an object of type T from objects whose types are in S. (We use the type-writer font for the names of types.) It is known that every type has an implementation from fconsensus; registerg <ref> [Her88, Her91b, Plo89] </ref>. 1 Hence, if the types consensus and register have t-tolerant implementations, so does every type. We therefore focus on obtaining t-tolerant implementations of consensus and register. 1.2.1 Tolerating responsive failures We give t-tolerant self-implementations of consensus for crash, omission, and arbitrary failures.
Reference: [Her91a] <author> M.P. Herlihy. </author> <title> Randomized wait-free concurrent objects. </title> <booktitle> In Proceedings of the 10th Annual ACM Symposium on Principles of Distributed Computing, </booktitle> <pages> pages 11-21, </pages> <month> August </month> <year> 1991. </year>
Reference-contexts: Furthermore, let us informally define a randomized implementation as an implementation in which every correct process completes its operation on the derived object in a finite expected number of operations on the base objects. Interestingly, every type has a randomized implementation from register <ref> [Her91a] </ref>, but most types have no (deterministic) implementations from register [Her91b]. In the following, we present a generalization of the former result. consensus with safe-reset has a randomized implementation from register [Asp90].
Reference: [Her91b] <author> M.P. Herlihy. </author> <title> Wait-free synchronization. </title> <journal> ACM TOPLAS, </journal> <volume> 13(1) </volume> <pages> 124-149, </pages> <year> 1991. </year>
Reference-contexts: has an implementation from a set S of types if it is possible to wait-free implement an object of type T from objects whose types are in S. (We use the type-writer font for the names of types.) It is known that every type has an implementation from fconsensus; registerg <ref> [Her88, Her91b, Plo89] </ref>. 1 Hence, if the types consensus and register have t-tolerant implementations, so does every type. We therefore focus on obtaining t-tolerant implementations of consensus and register. 1.2.1 Tolerating responsive failures We give t-tolerant self-implementations of consensus for crash, omission, and arbitrary failures. <p> For arbitrary failures, our self-implementation is efficient requiring O (t log t) base consensus objects. We also give t-tolerant self-implementations of register for crash, omission, and arbitrary failures. Combining the above results with the universality results in <ref> [Her91b, Plo89] </ref>, we conclude that every type T has a t-tolerant implementation (from fconsensus; registerg) for all responsive failure modes. Moreover, if T implements both consensus and register, then T has a t-tolerant self - implementation. <p> The answer is yes. Specifically, we show that register has a t-tolerant (deterministic) self -implementation even for NR-arbitrary failures. Furthermore, randomized implementations of consensus from register are well-known (for example, see [Asp90]). These two results, together with the universality results in <ref> [Her91b, Plo89] </ref>, imply that every type has a randomized t-tolerant implementation from register even for NR-arbitrary failures. 1.2.3 Achieving graceful degradation If an implementation is gracefully degrading for failure mode F , the derived object never fails more severely than F provided that base objects fail only by F (this property <p> However, H satisfies the following weaker property [Lam86]: If H 0 is the result of removing all read operations in H that are concurrent with a write, then H 0 is linearizable. * Consider the type consensus with safe-reset <ref> [Her91b] </ref>. It supports a reset operation in addition to propose 0 and propose 1 . Its sequential specification is the same as that of consensus (see Figure 1) with one addition: from any state, application of reset causes the state to change to S and return the response ack . <p> Thus, the history H of an object of type consensus with safe-reset does not have to be linearizable. However, H satisfies the following weaker property <ref> [Her91b] </ref>: If H 0 is the maximal prefix of H in which no reset operation is concurrent with any other operation, then H 0 is linearizable. * Consider the type 1-reader 1-writer register. <p> Hence the lemma. 2 18 5 Tolerating responsive failures In this section, we prove that it is feasible to design deterministic implementations that tolerate even the most severe of the responsive failures, viz., arbitrary failures. Herlihy <ref> [Her91b] </ref> and Plotkin [Plo89] showed that one can implement a (wait-free) object of any type using only consensus and register objects. Therefore, if consensus and register have t-tolerant implementations, then every type has a t-tolerant implementation. <p> They are however not gracefully degrading for crash or omission. We study the feasibility of gracefully degrading implementations for benign failure modes in Section 7. The theorems of this section depend on the universality results due to Herlihy and Plotkin <ref> [Her91b, Plo89] </ref>. These results are stated below. Theorem 5.5 (Herlihy) For all types T , there is a k such that T has a (0-tolerant) k-bounded implementation from fconsensus with safe-reset, unbounded registerg. Herlihy's universal construction requires unbounded registers even to implement finite types. <p> It is known that fetch&add, queue, stack, and test&set implement consensus with safe-reset for two processes, and that compare&swap, memory-to-memory move (henceforth move), and memory-to-memory swap (henceforth m-m swap) implement consensus with safe-reset for any number of processes <ref> [Her91b, KM93] </ref>. 8 These are all bounded implementations and, by Lemma 4.2, are gracefully degrading for arbitrary failures. We claim that compare&swap, move, m-m swap, and test&set implement 1-reader 1-writer boolean safe register, and that fetch&add, queue, and stack implement 1-reader 1-writer unbounded safe register. <p> Interestingly, every type has a randomized implementation from register [Her91a], but most types have no (deterministic) implementations from register <ref> [Her91b] </ref>. In the following, we present a generalization of the former result. consensus with safe-reset has a randomized implementation from register [Asp90]. Together with Theorem 6.4, this implies that consensus with safe-reset has a t-tolerant randomized implementation from register for NR-arbitrary failures. <p> A set S of types is universal if every type has an implementation from S. An example of such a set is fconsensus with safe-reset, registerg <ref> [Her91b] </ref>. The main result of this section is the graceful degradation theorem for omission, stated as follows: Every type has a t-tolerant gracefully degrading implementation from every universal set of types for omission. We prove this result through three key lemmas. <p> The steps involved in obtaining the graceful degradation theorem for omission are as follows (in the steps below, the failure mode is implicitly assumed to be omission): Step 1. Every type has a 0-tolerant implementation from fregister, consensus with safe-resetg. (This follows from Herlihy's universality result <ref> [Her91b] </ref>.) Step 2.
Reference: [HV91] <author> S. Haldar and K. Vidyasankar. </author> <title> A simple construction of 1-writer multi-reader multi-valued atomic variable from regular variables. </title> <type> Technical Report Technical Report No: 9108, </type> <institution> Memorial University of Newfoundland, Department of Computer Science, Memorial University of Newfoundland, St. John's, NF, Canada, A1C 5S7, </institution> <year> 1991. </year>
Reference: [HW90] <author> M.P. Herlihy and J.M. Wing. </author> <title> Linearizability: A correctness condition for concurrent objects. </title> <journal> ACM TOPLAS, </journal> <volume> 12(3) </volume> <pages> 463-492, </pages> <year> 1990. </year> <month> 55 </month>
Reference-contexts: contains either infinitely many occurrences of e or infinitely many states in which e is not enabled. 2.6 Linearizability Linearizability requires that each operation, spanning over an interval of time from the invocation of the operation to its response, must appear to take effect at some instant in this interval <ref> [HW90] </ref>. More precisely, let H be the history of some object in an execution of a concurrent system. Let T = (OP ; RES ; G; t ) be a type and s be a state of T .
Reference: [JCT96] <author> P. Jayanti, T. D. Chandra, and S. Toueg. </author> <title> Fault-tolerant wait-free shared objects. </title> <type> Technical Report TR 96-1565, </type> <institution> Cornell University, Department of Computer Science, Upson Hall, Cornell University, </institution> <address> Ithaca, NY 14853, USA, </address> <month> January </month> <year> 1996. </year>
Reference-contexts: This implementation uses 2t + 1 base objects. In fact, 2t + 1 is a lower bound on the resource complexity of any t-tolerant gracefully degrading implementation of consensus for omission. (The implementation and the lower bound can be found in <ref> [JCT96] </ref>.) In contrast to omission, as we will prove later in Section 7, consensus has no t-tolerant gracefully degrading implementation for crash. 5.1.3 Tolerating arbitrary failures In this section, we present a t-tolerant self-implementation for arbitrary failures whose resource complexity is O (t log t). <p> The implementation of Propose (p; v p ; O), as well as its proof of correctness, is the same as before. 2 6 See <ref> [JCT96] </ref> for a 1-tolerant self-implementation of resource complexity 6. 27 Procedure Reset (p; O) i : integer local to p begin reset (p; O 1 ) reset (p; O 2 ) for i := 1 to 3t + 1 reset (p; A 0 [i]) reset (p; A 1 [i]) for i <p> We claim that compare&swap, move, m-m swap, and test&set implement 1-reader 1-writer boolean safe register, and that fetch&add, queue, and stack implement 1-reader 1-writer unbounded safe register. The implementations claimed above are bounded and are easy to obtain. We therefore omit their descriptions. (See <ref> [JCT96] </ref> for an implementation of 1-reader 1-writer boolean safe register from test&set.) As already mentioned, it is known that register has a bounded implementation from 1-reader 1-writer safe register. <p> Furthermore, suppose that the identity of this process is a priori "common knowledge" among all the processes. Even with this extremely weak failure mode, called unfairness to a known process, we can prove the following (the proof can be found in <ref> [JCT96] </ref>): Theorem 6.3 There is no 1-tolerant implementation of consensus, even for two processes, for unfairness to a known process. <p> The details of this implementation are long and tedious, and are therefore omitted. We now prove Theorem 7.1. The proof of Theorem 7.2 is similar and can be found in <ref> [JCT96] </ref>. Proof of Theorem 7.1 Suppose that the theorem is false. Then, there is an order-sensitive type T which has a gracefully degrading implementation from some set of non-order-sensitive types for crash. <p> For bounded RMW, this is a direct consequence of Corollary 5.1. For N -process test&set, one can combine the fault-tolerant implementation of test&set from ftest&set, bounded registerg [AGMT92], with the implementation of bounded register from test&set presented in <ref> [JCT96] </ref>. 7. The existence of a fault-tolerant self -implementation of consensus, shown in this paper, does not follow from the results in [AGMT92]. 8. The fault-tolerant implementation of N -process test&set from ftest&set, bounded registerg, shown in [AGMT92], does not follow from our results (when N &gt; 2).
Reference: [JT92] <author> P. Jayanti and S. Toueg. </author> <title> Some results on the impossibility, universality, and decidability of consensus. </title> <booktitle> In Proceedings of the 6th Workshop on Distributed Algorithms, </booktitle> <address> Haifa, Israel, </address> <month> November </month> <year> 1992. </year> <note> (Appeared in Lecture Notes in Computer Science, Springer-Verlag, No: 647). </note>
Reference-contexts: Herlihy's universal construction requires unbounded registers even to implement finite types. Plotkin's construction, on the other hand, requires only boolean registers in such a situation [Plo89]. (Jayanti and Toueg achieve the same result as Plotkin, but with a more intuitive construction <ref> [JT92] </ref>.) Theorem 5.6 (Plotkin) For all finite types T , there is a k such that T has a (0-tolerant) k-bounded implementation from fconsensus with safe-reset, boolean registerg.
Reference: [KM93] <author> J. Kleinberg and S. Mullainathan. </author> <title> Resource bounds and combinations of consensus objects. </title> <booktitle> In Proceedings of the 12th Annual ACM Symposium on Principles of Distributed Computing, </booktitle> <month> August </month> <year> 1993. </year>
Reference-contexts: It is known that fetch&add, queue, stack, and test&set implement consensus with safe-reset for two processes, and that compare&swap, memory-to-memory move (henceforth move), and memory-to-memory swap (henceforth m-m swap) implement consensus with safe-reset for any number of processes <ref> [Her91b, KM93] </ref>. 8 These are all bounded implementations and, by Lemma 4.2, are gracefully degrading for arbitrary failures. We claim that compare&swap, move, m-m swap, and test&set implement 1-reader 1-writer boolean safe register, and that fetch&add, queue, and stack implement 1-reader 1-writer unbounded safe register.
Reference: [LAA87] <author> M.C. Loui and Abu-Amara. </author> <title> Memory requirements for agreement among unreliable asynchronous processes. </title> <booktitle> Advances in computing research, </booktitle> <volume> 4 </volume> <pages> 163-183, </pages> <year> 1987. </year>
Reference-contexts: implementation from fconsensus; registerg for omission. 2 The impossibility of implementing a fault-tolerant consensus object from any finite set of base objects, one of which may fail by NR-crash, is shown using the impossibility of solving the consensus problem among a finite number of processes, one of which may crash <ref> [FLP85, LAA87, DDS87] </ref>. 4 1.2.4 Conclusions The following are our main conclusions: (1) It is feasible to design deterministic implementations that tolerate even the most severe of the responsive failures, viz., arbitrary failures, (2) Implementations cannot tolerate even the simplest of non-responsive failures, viz., crash failures, without the use of randomization, <p> In each case, to prove that a certain implementation I does not exist, we show that if I exists, it would violate the well-known impossibility result due to Loui and Abu-Amara <ref> [LAA87] </ref> and Dolev, Dwork, and Stockmeyer [DDS87]. This result is about the consensus problem for n processes, defined informally as follows. Each process P i is initially given an input v i 2 f0; 1g.
Reference: [Lam77] <author> L. Lamport. </author> <title> Concurrent reading and writing. </title> <journal> Communications of the ACM, </journal> 20(11) 806-811, 1977. 
Reference-contexts: Wait-free implementations, which have been the focus of much recent research, were introduced to overcome this drawback <ref> [Lam77] </ref>. An implementation is wait-free if every access by a non-faulty process is guaranteed a response, regardless of whether the other processes are slow, fast, or have crashed. Wait-free implementations of shared objects tolerate the failure of processes, but not the failure of base objects from which they are implemented.
Reference: [Lam78] <author> L. Lamport. </author> <booktitle> The implementation of reliable distributed multi-process systems. Computer Networks, </booktitle> <volume> 2 </volume> <pages> 95-114, </pages> <year> 1978. </year>
Reference-contexts: In contrast, we study the consensus problem for asynchronous shared-memory systems and we seek wait-free solutions. Because of these differences, the problem of t-tolerant implementation of consensus does not reduce to any previous problem considered in the literature. The "State Machine" approach <ref> [Lam78, Sch90] </ref> of replicating objects, applying an operation to all objects, and returning the majority response is not useful in deriving t-tolerant implementations of consensus.
Reference: [Lam86] <author> L. Lamport. </author> <title> On interprocess communication, parts i and ii. </title> <journal> Distributed Computing, </journal> <volume> 1 </volume> <pages> 77-101, </pages> <year> 1986. </year>
Reference-contexts: However some important objects that appeared in literature are not linearizable. Here are some examples. 8 * Consider the type safe register, defined by Lamport <ref> [Lam86] </ref>. It supports read and write operations and has the same sequential specification as register: every read returns the value written by the most recent write. However, in the presence of concurrent operations, a safe register extends fewer guarantees than a (linearizable or "atomic") register. <p> In particular, if a read operation on a safe register is concurrent with a write, then that read operation can return an arbitrary response. Thus, the history H of a safe register does not have to be linearizable. However, H satisfies the following weaker property <ref> [Lam86] </ref>: If H 0 is the result of removing all read operations in H that are concurrent with a write, then H 0 is linearizable. * Consider the type consensus with safe-reset [Her91b]. It supports a reset operation in addition to propose 0 and propose 1 . <p> Intuitively, if a read operation on an object of this type overlaps with a write, then that read operation is allowed to return any value <ref> [Lam86] </ref>. <p> Hence the correctness of the implementation. 2 There are many results presenting bounded implementations of one type of register from another [Pet83, Lam86, VA86, Blo87, BP87, NW87, PB87, SAG87, Sch88, Vid88, Vid89, HV91]. Some of them (for example, <ref> [Lam86, SAG87, Sch88] </ref>) can be combined to implement a multi-reader, multi-writer, linearizable register using 1-reader, 1-writer, safe registers. In our terminology, this means that register has a bounded implementation from 1-reader 1-writer safe register.
Reference: [LSP82] <author> L. Lamport, R. Shostak, and M. Pease. </author> <title> The byzantine generals problem. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 4(3) </volume> <pages> 382-401, </pages> <year> 1982. </year>
Reference: [LT88] <author> N. Lynch and M. Tuttle. </author> <title> An introduction to input/output automata. </title> <type> Technical Report MIT/LCS/TM-373, </type> <institution> MIT, MIT Laboratory for Computer Science, </institution> <year> 1988. </year>
Reference-contexts: In Section 8, we present a comparison with the results in [AGMT92, AGMT95]. 2 Model 2.1 I/O Automata Our description of I/O automata is brief. The reader is referred to the work of Lynch and Tuttle for details <ref> [LT88] </ref>.
Reference: [NW87] <author> R. Newman-Wolf. </author> <title> A protocol for wait-free, atomic, multi-reader shared variables. </title> <booktitle> In Proceedings of the 6th Annual ACM Symposium on Principles of Distributed Computing, </booktitle> <pages> pages 232-248, </pages> <year> 1987. </year>
Reference: [PB87] <author> G. Peterson and J. Burns. </author> <title> Concurrent reading while writing ii: the multi-writer case. </title> <booktitle> In Proceedings of the 28th Annual Symposium on Foundations of Computer Science, </booktitle> <year> 1987. </year>
Reference: [Pet83] <author> G. L. Peterson. </author> <title> Concurrent reading while writing. </title> <journal> ACM TOPLAS, </journal> <volume> 5(1) </volume> <pages> 56-65, </pages> <year> 1983. </year>
Reference: [Plo89] <author> S. Plotkin. </author> <title> Sticky bits and universality of consensus. </title> <booktitle> In Proceedings of the 8th Annual ACM Symposium on Principles of Distributed Computing, </booktitle> <pages> pages 159-175, </pages> <month> August </month> <year> 1989. </year>
Reference-contexts: has an implementation from a set S of types if it is possible to wait-free implement an object of type T from objects whose types are in S. (We use the type-writer font for the names of types.) It is known that every type has an implementation from fconsensus; registerg <ref> [Her88, Her91b, Plo89] </ref>. 1 Hence, if the types consensus and register have t-tolerant implementations, so does every type. We therefore focus on obtaining t-tolerant implementations of consensus and register. 1.2.1 Tolerating responsive failures We give t-tolerant self-implementations of consensus for crash, omission, and arbitrary failures. <p> For arbitrary failures, our self-implementation is efficient requiring O (t log t) base consensus objects. We also give t-tolerant self-implementations of register for crash, omission, and arbitrary failures. Combining the above results with the universality results in <ref> [Her91b, Plo89] </ref>, we conclude that every type T has a t-tolerant implementation (from fconsensus; registerg) for all responsive failure modes. Moreover, if T implements both consensus and register, then T has a t-tolerant self - implementation. <p> The answer is yes. Specifically, we show that register has a t-tolerant (deterministic) self -implementation even for NR-arbitrary failures. Furthermore, randomized implementations of consensus from register are well-known (for example, see [Asp90]). These two results, together with the universality results in <ref> [Her91b, Plo89] </ref>, imply that every type has a randomized t-tolerant implementation from register even for NR-arbitrary failures. 1.2.3 Achieving graceful degradation If an implementation is gracefully degrading for failure mode F , the derived object never fails more severely than F provided that base objects fail only by F (this property <p> Hence the lemma. 2 18 5 Tolerating responsive failures In this section, we prove that it is feasible to design deterministic implementations that tolerate even the most severe of the responsive failures, viz., arbitrary failures. Herlihy [Her91b] and Plotkin <ref> [Plo89] </ref> showed that one can implement a (wait-free) object of any type using only consensus and register objects. Therefore, if consensus and register have t-tolerant implementations, then every type has a t-tolerant implementation. We therefore focus on fault-tolerant implementations of consensus and register in Sections 5.1 and 5.2, respectively. <p> They are however not gracefully degrading for crash or omission. We study the feasibility of gracefully degrading implementations for benign failure modes in Section 7. The theorems of this section depend on the universality results due to Herlihy and Plotkin <ref> [Her91b, Plo89] </ref>. These results are stated below. Theorem 5.5 (Herlihy) For all types T , there is a k such that T has a (0-tolerant) k-bounded implementation from fconsensus with safe-reset, unbounded registerg. Herlihy's universal construction requires unbounded registers even to implement finite types. <p> Herlihy's universal construction requires unbounded registers even to implement finite types. Plotkin's construction, on the other hand, requires only boolean registers in such a situation <ref> [Plo89] </ref>. (Jayanti and Toueg achieve the same result as Plotkin, but with a more intuitive construction [JT92].) Theorem 5.6 (Plotkin) For all finite types T , there is a k such that T has a (0-tolerant) k-bounded implementation from fconsensus with safe-reset, boolean registerg.
Reference: [PSL80] <author> M. Pease, R. Shostak, and L. Lamport. </author> <title> Reaching agreement in the presence of faults. </title> <journal> Journal of the ACM, </journal> <volume> 27(2) </volume> <pages> 228-234, </pages> <year> 1980. </year> <month> 56 </month>
Reference: [SAG87] <author> A. Singh, J. Anderson, and M. Gouda. </author> <title> The elusive atomic register, revisited. </title> <booktitle> In Proceedings of the 6th Annual ACM Symposium on Principles of Distributed Computing, </booktitle> <pages> pages 206-221, </pages> <year> 1987. </year>
Reference-contexts: Hence the correctness of the implementation. 2 There are many results presenting bounded implementations of one type of register from another [Pet83, Lam86, VA86, Blo87, BP87, NW87, PB87, SAG87, Sch88, Vid88, Vid89, HV91]. Some of them (for example, <ref> [Lam86, SAG87, Sch88] </ref>) can be combined to implement a multi-reader, multi-writer, linearizable register using 1-reader, 1-writer, safe registers. In our terminology, this means that register has a bounded implementation from 1-reader 1-writer safe register.
Reference: [Sch88] <author> R. Schaffer. </author> <title> On the correctness of atomic multi-writer registers. </title> <type> Technical report, TR No: </type> <institution> MIT/LCS/TM-364, MIT Laboratory for Computer Science, </institution> <year> 1988. </year>
Reference-contexts: Hence the correctness of the implementation. 2 There are many results presenting bounded implementations of one type of register from another [Pet83, Lam86, VA86, Blo87, BP87, NW87, PB87, SAG87, Sch88, Vid88, Vid89, HV91]. Some of them (for example, <ref> [Lam86, SAG87, Sch88] </ref>) can be combined to implement a multi-reader, multi-writer, linearizable register using 1-reader, 1-writer, safe registers. In our terminology, this means that register has a bounded implementation from 1-reader 1-writer safe register.
Reference: [Sch90] <author> F.B. Schneider. </author> <title> Implementing fault-tolerant services using the state machine approach: A tutorial. </title> <journal> ACM Computing Surveys, </journal> <volume> 22(4) </volume> <pages> 299-319, </pages> <year> 1990. </year>
Reference-contexts: In contrast, we study the consensus problem for asynchronous shared-memory systems and we seek wait-free solutions. Because of these differences, the problem of t-tolerant implementation of consensus does not reduce to any previous problem considered in the literature. The "State Machine" approach <ref> [Lam78, Sch90] </ref> of replicating objects, applying an operation to all objects, and returning the majority response is not useful in deriving t-tolerant implementations of consensus.
Reference: [ST87] <author> T.K. Srikanth and S. Toueg. </author> <title> Simulating authenticated broadcasts to derive simple fault-tolerant algorithms. </title> <journal> Distributed Computing, </journal> <volume> 2(2) </volume> <pages> 80-94, </pages> <year> 1987. </year>
Reference: [VA86] <author> P. Vitanyi and B. Awerbuch. </author> <title> Atomic shared register access by asynchronous hardware. </title> <booktitle> In Proceedings of the 27th Annual Symposium on Foundations of Computer Science, </booktitle> <year> 1986. </year>
Reference: [Vid88] <author> K. Vidyasankar. </author> <title> Converting lamport's regular register to atomic register. </title> <journal> IPL, </journal> <volume> 28 </volume> <pages> 287-290, </pages> <year> 1988. </year>
Reference: [Vid89] <author> K. Vidyasankar. </author> <title> An elegant 1-writer multireader multivalued atomic register. </title> <journal> IPL, </journal> <volume> 30 </volume> <pages> 221-223, </pages> <year> 1989. </year> <month> 57 </month>
References-found: 39

