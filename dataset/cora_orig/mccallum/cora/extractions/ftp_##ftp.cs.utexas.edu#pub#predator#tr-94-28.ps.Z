URL: ftp://ftp.cs.utexas.edu/pub/predator/tr-94-28.ps.Z
Refering-URL: http://www.cs.utexas.edu/users/schwartz/pub.htm
Root-URL: 
Title: The LEAPS Algorithms  
Author: Don Batory 
Address: Austin, Texas 78712  
Affiliation: Department of Computer Sciences The University of Texas  
Abstract: LEAPS is a state-of-the-art production system compiler that produces the fastest sequential executables of OPS5 rule sets. The performance of LEAPS is due to its reliance on complex data structures and search algorithms to speed rule processing. In this paper, we explain the LEAPS algorithms in terms of the programming abstractions of the P2 data structure compiler.
Abstract-found: 1
Intro-found: 1
Reference: [Bat93] <author> D. Batory, V. Singhal, M. Sirkin, and J. Thomas, </author> <title> Scalable Software Libraries, </title> <booktitle> Proc. ACM SIGSOFT, </booktitle> <month> December </month> <year> 1993. </year>
Reference-contexts: In this paper, we explain the LEAPS algorithms in terms of the container-cursor programming abstractions of the P2 data structure compiler <ref> [Sir93, Bat93] </ref>. Our specifications of the LEAPS algorithms were used as the basis for the RL (Reengineered-LEAPS) project [Bat94] and have been validated through implementation. Thus, this paper describes a reimplementation of LEAPS using P2. <p> P2 code generation relies on sophisticated macro expansion and partial evaluation techniques <ref> [Bat93] </ref>. Altering a typex declaration yields a different implementation of cursors and containers.
Reference: [Bat94] <author> D. Batory, J. Thomas, and M. Sirkin, </author> <title> Reengineering a Complex Application Using a Scalable Data Structure Compiler, </title> <note> submitted for publication. </note>
Reference-contexts: In this paper, we explain the LEAPS algorithms in terms of the container-cursor programming abstractions of the P2 data structure compiler [Sir93, Bat93]. Our specifications of the LEAPS algorithms were used as the basis for the RL (Reengineered-LEAPS) project <ref> [Bat94] </ref> and have been validated through implementation. Thus, this paper describes a reimplementation of LEAPS using P2.
Reference: [Big94] <author> T. Biggerstaff. </author> <title> The Library Scaling Problem and the Limits of Concrete Component Reuse, </title> <booktitle> IEEE International Conference on Software Reuse, </booktitle> <month> November </month> <year> 1994. </year>
Reference: [Bra91] <author> D. Brant, T.Grose, B. Lofaso, and D. Miranker, </author> <title> Effects of Database Size on Rule System Performance: Five Case Studies, </title> <booktitle> Proc. Very Large Databases, </booktitle> <year> 1991. </year>
Reference-contexts: tuning and maintaining P2 programs, as typex declarations generally account for a very small fraction of a P2 program. 3 The LEAPS Algorithms As mentioned earlier, LEAPS produces the fastest executables of OPS5 rule sets, often outperforming OPS5 interpreters that use RETE-match or TREAT-match algorithms by several orders of magnitude <ref> [Bra91] </ref>. LEAPS translates OPS5 programs into C programs. Besides the expected performance gains made by compilation, LEAPS relies on special algorithms and sophisticated data structures to make rule processing efficient. 5 translate OPS5 rule sets into a P2 program; this translator was called RL (Reengineered Leaps).
Reference: [Bra93a] <author> D. Brant and D. Miranker, </author> <title> Index Support for Rule Activiation, </title> <booktitle> Proc. ACM SIGMOD, </booktitle> <month> May </month> <year> 1993. </year>
Reference-contexts: In general, the idea of using hash joins to obtain improved performance is an obvious consequence of the work of Brant and Miranker <ref> [Bra93a] </ref>. Negation Optimization. Experience has shown that the following is not an effective optimization, but it is an interesting idea never-the-less.
Reference: [Bra93b] <author> D. </author> <title> Brant, Inferencing on Large Data Sets, </title> <type> Ph.D., </type> <institution> Department of Computer Sciences, University of Texas at Austin, </institution> <year> 1993. </year>
Reference-contexts: To avoid such duplication, times tamp qualifications on containers to the left of the container of the seeding dominant object to have timestamps the timestamp of the DO and qualifications on containers to the right of the seeding container to be &lt; the timestamp of the DO <ref> [Bra93b] </ref>. The notion of left and right is determined by the order in which containers are listed to be joined. Note that LEAPS did generate multiple tuples as it did not enforce the ideas outlined in this footnote. 7.
Reference: [Bro94] <editor> J. Browne, et al. </editor> <title> A New Approach to Modularity in Rule-Based Programming, </title> <institution> Department of Computer Sciences, University of Texas at Austin, </institution> <month> April </month> <year> 1994. </year>
Reference-contexts: LEAPS infers the data types of element fields; we chose to augment literalize statements by supplying the data type for each field. Although this is a minor difference between LEAPS and RL, we note that the next generation of LEAPS (called VENUS <ref> [Bro94] </ref>), like RL, uses explicit typing of fields.
Reference: [For81] <author> C. Forgy, </author> <title> OPS5 Users Manual, </title> <type> Technical Report CMU-CS-81-135, </type> <institution> Carnegie Mellon University, </institution> <year> 1981. </year>
Reference-contexts: 1 Introduction OPS5 is a forward-chaining expert system <ref> [McD78, For81] </ref>. LEAPS (Lazy Evaluation Algorithm for Production Systems) is a state-of-the-art production system compiler for OPS5 rule sets [Mir90]. 2 Experimental results have shown that LEAPS produces the fastest sequential executables of OPS5 rule sets; execution times can be over two orders of magnitude faster than OPS5 interpreters.
Reference: [For82] <author> C. Forgy, </author> <title> A Fast Algorithm for the Many Pattern/Many Object Pattern Matching Problem, </title> <journal> Artificial Intelligence, </journal> <volume> vol. 19 (1982), </volume> <pages> 17-37. </pages>
Reference-contexts: Rules that can be matched (i.e., tuples found to satisfy their predicates) are determined; one n-tuple is selected and its corresponding rule is fired. This cycle continues until a fix point has been reached (i.e., no more rules can be fired). RETE-match <ref> [For82] </ref> and TREAT-match [Mir91] algorithms are inherently slow, as they materialize all tuples that satisfy the predicate of a rule. Materialized tuples are stored in data structures and have a negative impact on performance as they must be updated as a result of executing rule actions.
Reference: [McD78] <author> J. McDermott, A. Newall, and J. Moore, </author> <title> The Efficiency of Certain Production Systems, Pattern Directed Inference Systems, </title> <editor> Waterman, Hayes, Roth (ed), </editor> <publisher> Academic Press, </publisher> <address> New York, </address> <year> 1978. </year>
Reference-contexts: 1 Introduction OPS5 is a forward-chaining expert system <ref> [McD78, For81] </ref>. LEAPS (Lazy Evaluation Algorithm for Production Systems) is a state-of-the-art production system compiler for OPS5 rule sets [Mir90]. 2 Experimental results have shown that LEAPS produces the fastest sequential executables of OPS5 rule sets; execution times can be over two orders of magnitude faster than OPS5 interpreters.
Reference: [Mir90] <author> D. Miranker, D. Brant, B. Lofaso, and D. Gadbois, </author> <title> On the Performance of Lazy Matching in Production Systems, </title> <booktitle> Proc. National Conference on Artificial Intelligence, </booktitle> <year> 1990. </year>
Reference-contexts: 1 Introduction OPS5 is a forward-chaining expert system [McD78, For81]. LEAPS (Lazy Evaluation Algorithm for Production Systems) is a state-of-the-art production system compiler for OPS5 rule sets <ref> [Mir90] </ref>. 2 Experimental results have shown that LEAPS produces the fastest sequential executables of OPS5 rule sets; execution times can be over two orders of magnitude faster than OPS5 interpreters.
Reference: [Mir91] <author> D. Miranker and B. Lofaso, </author> <title> The Organization and Performance of a TREAT-Based Production System Compiler, </title> <journal> IEEE Transactions on Knowledge and Data Engineering, </journal> <year> 1991. </year>
Reference-contexts: Rules that can be matched (i.e., tuples found to satisfy their predicates) are determined; one n-tuple is selected and its corresponding rule is fired. This cycle continues until a fix point has been reached (i.e., no more rules can be fired). RETE-match [For82] and TREAT-match <ref> [Mir91] </ref> algorithms are inherently slow, as they materialize all tuples that satisfy the predicate of a rule. Materialized tuples are stored in data structures and have a negative impact on performance as they must be updated as a result of executing rule actions.
Reference: [Sir93] <author> M. Sirkin, D. Batory, and V. Singhal, </author> <title> Software Components in a Data Structure Precompiler, </title> <booktitle> Proc. 15th International Conference on Software Engineering, </booktitle> <month> May </month> <year> 1993. </year>
Reference-contexts: In this paper, we explain the LEAPS algorithms in terms of the container-cursor programming abstractions of the P2 data structure compiler <ref> [Sir93, Bat93] </ref>. Our specifications of the LEAPS algorithms were used as the basis for the RL (Reengineered-LEAPS) project [Bat94] and have been validated through implementation. Thus, this paper describes a reimplementation of LEAPS using P2. <p> Each component encapsulates a consistent data and operation refinement of the cursor-container abstraction and is responsible for generating the code for this refinement <ref> [Sir93] </ref>.
References-found: 13

