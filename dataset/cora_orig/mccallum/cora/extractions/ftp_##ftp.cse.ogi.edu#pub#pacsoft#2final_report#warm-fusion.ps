URL: ftp://ftp.cse.ogi.edu/pub/pacsoft/2final_report/warm-fusion.ps
Refering-URL: http://www.cse.ogi.edu/PacSoft/projects/SDRR/p2_report.html
Root-URL: http://www.cse.ogi.edu
Title: Warm Fusion for the Masses: Detailing Virtual Data Structure Elimination in Fully Recursive Languages  
Author: Patricia Johann John Launchbury 
Date: October 29, 1997  
Affiliation: Pacific Software Research Center  
Abstract: In functional programming, small programs are often combined to construct larger, more complex ones. The component reuse encouraged by this modular style of programming yields many benefits, but, unfortunately, modular programs also tend to be less efficient than their monolithic counterparts. Inefficiency is significantly attributable to the construction of intermediate data structures which "glue" together the smaller program components into larger ones. Fusion is the process of removing intermediate data structures from modularly constructed programs. Two particularly successful approaches to achieving fusion in functional languages have emerged in recent years. The first is a catamorphic fusion technique based on the promotion theorems of category theory. The second is a shortcut based on parametricity which fuses compositional programs via canned applications of traditional fold/unfold program transformation steps. Both techniques apply only to programs written in terms of certain special language constructs, but each contributes significantly to the elimination of intermediate data structures in such programs. Warm fusion combines catamorphic fusion and the shortcut to arrive at a two-step method for fusing programs written not in some highly stylized form, but in the common recursive style. In essence, catamorphic fusion is used to "preprocess" programs into compositions to which the shortcut applies. This paper presents a detailed and self-contained treatment of warm fusion, and traces its evolution from early work in program transformation. The discussion here builds on the original presentation of warm fusion by Launchbury and Sheard, and resolves a number of outstanding issues from their 1995 paper. Warm fusion is presented here in the context of a fully polymorphic higher-order language, in which the role type information plays | essentially in eliminating from programs intermediate data structures other than lists | can be made precise; considerable effort is in fact taken throughout to place all aspects of warm fusion on a secure logical foundation. Finally, a prototype implementation of warm fusion is discussed, together with the maturing of suggestions in [LS95] it has entailed. Our implementation experience suggests that a fully automated method for fusing recursively defined functions | suitable for incorporation into a state-of-the-art compiler | should, in fact, be achievable.
Abstract-found: 1
Intro-found: 1
Reference: [Amt92] <author> T. Amtoft. </author> <title> Unfold/Fold Transformations Preserving Termination Properties. </title> <booktitle> In Proceedings, Programming Language Implementation and Logic Programming, </booktitle> <publisher> LNCS 631, Springer-Verlag, </publisher> <pages> pp. 187 - 201, </pages> <year> 1992. </year>
Reference-contexts: This search has not only led to the development of calculation-based program transformations (e.g., [Fok92], [Jeu93], [Mee92], [Mei92]), but has inspired more general work on fold/unfold transformations as well (see, e.g., <ref> [Amt92] </ref>, [San94]).
Reference: [Bar92] <author> H.P. Barendregt. </author> <title> Lambda Calculi with Types. </title> <booktitle> In Handbook of Logic in Computer Science, </booktitle> <volume> Volume 2, </volume> <publisher> Oxford University Press, </publisher> <pages> pp. 117 - 309, </pages> <year> 1992. </year>
Reference-contexts: Terms other than data constructors and those constructed using cata, build, and case comprise a polymorphic lambda calculus with (in this case, two distinguished sets of) constants. The computational intuition underlying the polymorphic lambda calculus has been discussed at length elsewhere (see, e.g., <ref> [Bar92] </ref> or [Gir89]), and the intuition behind, as well as the typing rule for, terms constructed using case should be self-explanatory.
Reference: [BD77] <author> R. M. Burstall and J. Darlington. </author> <title> A Transformation System for Developing Recursive Programs. </title> <editor> J. </editor> <booktitle> ACM 24:1 (1977), </booktitle> <pages> pp. 44 - 67. </pages>
Reference-contexts: only at the high price of computational inefficiency, Burstall and Darlington concerned themselves with the question of how "a lucid program can be transformed into a more intricate but efficient one in a systematic way, or indeed in a way which could be mechanized." The program transformation system presented in <ref> [BD77] </ref> is systematic, but unfortunately is not fully automatable. In fact, it requires human guidance for two reasons. First, the method requires user-supplied eureka steps during the folding of function calls. <p> Burstall and Darlington address neither the issue of correctness nor that of termination for the transformation system in <ref> [BD77] </ref>; indeed, that paper is offered specifically as an empirical study of the kinds of program improvement which are achievable using their system.
Reference: [CGW89] <author> T. Coquand, C. Gunter, and G. Winskel. </author> <title> Domain Theoretic Models of Polymorphism. </title> <booktitle> Information and Computation 81 (1989), </booktitle> <pages> pp. 123 - 167. </pages>
Reference: [Fok92] <author> M. Fokkinga. </author> <title> Law and Order in Algorithmics. </title> <type> Dissertation, </type> <institution> Universiteit Twente, </institution> <year> 1992. </year>
Reference-contexts: This search has not only led to the development of calculation-based program transformations (e.g., <ref> [Fok92] </ref>, [Jeu93], [Mee92], [Mei92]), but has inspired more general work on fold/unfold transformations as well (see, e.g., [Amt92], [San94]).
Reference: [Fre90] <author> P. Freyd. </author> <title> Recursive Types Reduced to Inductive Types. </title> <booktitle> In Proceedings, IEEE Symposium on Logic in Computer Science, </booktitle> <pages> pp. 498 - 507, </pages> <year> 1990. </year>
Reference: [FW88] <author> A. Ferguson and P. Wadler. </author> <title> When Will Deforestation Stop? In Proceedings, </title> <booktitle> Glasgow Workshop on Functional Programming, </booktitle> <pages> pp. 39 - 56, </pages> <year> 1988. </year>
Reference: [Gil96] <author> A. Gill. </author> <title> Cheap Deforestation for Non-strict Functional Languages. </title> <type> Dissertation, </type> <institution> Department of Computing Science, Glasgow University, </institution> <year> 1996. </year>
Reference-contexts: Some of the issues raised by the incorporation of the cata-build rule into GHC are mentioned briefly in Section 4.3, and the topic is discussed quite thoroughly in <ref> [Gil96] </ref>. There are instances of cata and build for algebraic datatypes other than lists, and results analogous to the ones described in this section do indeed hold for them. <p> The significance of the theorem derives primarily from the facts that most of the types used in functional programming are regular, and that many functions of interest are expressible as catamorphisms over them. 4.3 An Implementation of the Shortcut In the dissertation <ref> [Gil96] </ref>, Gill details his implementation of the shortcut to deforestation described in Section 2.4, and assesses its performance on a suite of real application programs ([Par92]). This implementation includes a translation scheme for list comprehensions which guarantees that intermediate lists between them and their producers and consumers are eliminated. <p> This implies, among other things, that functions should be able to be used freely in datatype definitions, and 3 page 7, <ref> [Gil96] </ref>. 41 that the resulting datatypes involving exponentials are, in some sense, fundamental to functional programming.
Reference: [Gir89] <author> J.-Y. Girard. </author> <title> Proofs and Types. </title> <publisher> Cambridge University Press, </publisher> <year> 1989. </year>
Reference-contexts: Terms other than data constructors and those constructed using cata, build, and case comprise a polymorphic lambda calculus with (in this case, two distinguished sets of) constants. The computational intuition underlying the polymorphic lambda calculus has been discussed at length elsewhere (see, e.g., [Bar92] or <ref> [Gir89] </ref>), and the intuition behind, as well as the typing rule for, terms constructed using case should be self-explanatory.
Reference: [GLPJ93] <author> A. Gill, J. Launchbury, and S. Peyton Jones. </author> <title> A Shortcut to Deforestation. </title> <booktitle> In Proceedings, Conference on Functional Programming and Computer Architecture, </booktitle> <pages> pp. 223 - 232, </pages> <year> 1993. </year>
Reference-contexts: Instead, a similar effect is achieved by performing algebraic transformations on higher-order programs, each of which can be regarded as a canned application of the fold/unfold transformations prevalent in the more traditional virtual data structure elimination techniques. In the discussion of the shortcut in this section, we follow <ref> [GLPJ93] </ref> and focus initially on its use in removing only intermediate lists from compositionally defined programs. Later, in Section 3.2, we describe how the shortcut can be extended to accommodate the elimination of arbitrary algebraic virtual data structures. <p> Operationally, given an appropriate function , a value z, and a list xs, cata replaces all occurrences of cons in xs with and replaces the occurrence of nil at the end of xs by z. The second, new insight offered by <ref> [GLPJ93] </ref> is that function which produce lists in a uniform manner can always be written in terms of a construct called build, which is dual to cata in a sense to be made precise below. <p> The only problem with the cata-build rule as described is that it is, in fact, false. As observed in <ref> [GLPJ93] </ref>, cata () z (build (nc n ! [True])) 6 (nc n ! [True]) () z; for instance: using the definitions of cata and build, it is easily seen that the left-hand side of this equation is True z, whereas its right-hand side is [True]. <p> expressions of type fi which can be constructed from them must be of the form ( a 1 ( a 2 ::: ( a n z):::)): For a language like Haskell, in which explicit type abstraction and application is suppressed, this intuition is made precise in the following theorem from <ref> [GLPJ93] </ref>. Theorem 2.1 If ff is a fixed type and g : 8fi:(ff ! fi ! fi) ! fi ! fi, then cata () z (build g) = g () z: The correctness of the cata-build rule is an immediate consequence of this theorem. <p> Doing this turns out to require the expressivity of a fully polymorphic higher-order language. In the next section, we will describe how the warm fusion method builds upon Sheard and Fegaras' normalization algorithm and the shortcut of <ref> [GLPJ93] </ref> to provide a virtual data structure elimination method for certain recursively defined higher-order programs; working in precisely such a polymorphic language, we will put the warm fusion method on a theoretical foundation secure enough to support its implementation. <p> In the second phase, build-cata forms resulting from the first phase are assembled into compositions corresponding to the original compositions, and these then undergo fusion via the cata-build rule from <ref> [GLPJ93] </ref>. This two-step approach to program fusion can be seen as bringing together the algebraic strand and the recursion equation strand of previous work. <p> In fact, it seems rather remarkable that techniques for eliminating virtual data structures from catamorphic programs can be used to achieve the same for many programs in languages which express recursion equationally as well. Like the normalization algorithm of Sheard and Fegaras, and the shortcut of <ref> [GLPJ93] </ref>, warm fusion is calculation-based rather than search-based, and so at no time in the warm fusion process must arbitrary patterns of recursive calls be spotted.
Reference: [GS96] <author> R. Gluck and M. H. Sorensen. </author> <note> A Roadmap to Metacomputation by Supercompilation, </note> <year> 1996. </year>
Reference-contexts: Partial evaluation also performs program specialization, which can be seen as a special case of deforestation, and hence of positive supercompilation. The connections between fold/unfold 40 methodologies and partial evaluation are explored in Chapter 17 of [JGS93]. The recent paper <ref> [GS96] </ref> is a nice exposition of the ideas underlying Turchin's work. 4.2 The Squiggol School and Calculation-based Programming In the middle 1980's and early 1990's, a new style of programming that would later heavily influence future work in virtual data structure elimination was developed.
Reference: [Hag87] <author> T. Hagino. </author> <title> A Categorical Programming Language. </title> <type> Dissertation, </type> <institution> University of Edinburgh, </institution> <year> 1987. </year>
Reference: [Hug89] <author> J. Hughes. </author> <title> Why Functional Programming Matters. </title> <journal> The Computer Journal 32:2 (1989), </journal> <pages> pp. 98 - 107. </pages>
Reference: [Jeu93] <author> J. Jeuring. </author> <title> Theories for Algorithm Calculation. </title> <type> Dissertation, </type> <institution> Universiteit Utrecht, </institution> <year> 1993. </year>
Reference-contexts: This search has not only led to the development of calculation-based program transformations (e.g., [Fok92], <ref> [Jeu93] </ref>, [Mee92], [Mei92]), but has inspired more general work on fold/unfold transformations as well (see, e.g., [Amt92], [San94]).
Reference: [JGS93] <author> N. Jones, C. Gomard, and P. Sestoft. </author> <title> Partial Evaluation and Automatic Program Generation. </title> <publisher> Prentice-Hall, </publisher> <year> 1993. </year>
Reference-contexts: Modulo the issue of termination, driving thus completely subsumes deforestation. Partial evaluation also performs program specialization, which can be seen as a special case of deforestation, and hence of positive supercompilation. The connections between fold/unfold 40 methodologies and partial evaluation are explored in Chapter 17 of <ref> [JGS93] </ref>. The recent paper [GS96] is a nice exposition of the ideas underlying Turchin's work. 4.2 The Squiggol School and Calculation-based Programming In the middle 1980's and early 1990's, a new style of programming that would later heavily influence future work in virtual data structure elimination was developed.
Reference: [Joh94] <author> T. Johnsson. </author> <title> Fold-unfold Transformations on State Monadic Transformers. </title> <booktitle> In Proceedings of the Glasgow Functional Programming Workshop, </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1994. </year>
Reference-contexts: While Proebsting and Watterson's approach to the fusion problem for stateful computation is ad hoc, an axiomatic treatment for such computations can be found in <ref> [Joh94] </ref>. Johnsson uses manual fold/unfold transformations over stateful interpreters to achieve efficient compilation. <p> Whether or not this is always, or even often, a win remains to be discerned. 3. Extensions All existing fusion methods | as well as the theoretical work underlying them | restrict attention to programs written in pure functional languages. Recent research ([Lau95], <ref> [Joh94] </ref>) suggests that fusion techniques can be extended to functional programs written in monadic style, especially to those written using the monad of state. This in turn suggests that build-cata fusion can be lifted to imperative programs.
Reference: [Lau95] <author> J. Launchbury. </author> <title> Graph Algorithms with a Functional Flavor. </title> <booktitle> In Proceedings, First International Spring School on Advanced Functional Programming, </booktitle> <publisher> Springer-Verlag, </publisher> <pages> pp. 308 - 331, </pages> <year> 1995. </year> <month> 46 </month>
Reference: [LS95] <author> J. Launchbury and T. Sheard. </author> <title> Warm Fusion: Deriving Build-Catas from Recursive Definitions. </title> <booktitle> In Proceedings, Conference on Functional Languages and Computer Architecture, </booktitle> <pages> pp. 314 - 323, </pages> <year> 1995. </year>
Reference-contexts: form appears to be quite a difficult problem, in a 1995 paper 6 entitled Warm Fusion: Deriving Build-Catas from Recursive Definitions (<ref> [LS95] </ref>), Launchbury and Sheard describe a method for transforming a large class of programs computing recursively defined functions into build-cata forms. It is precisely the "preprocessing" method described in [LS95] for recursively defined functions which is the subject of this paper (see Section 1.5). At this point, some benefits of program fusion other than program improvement are worth mentioning. <p> The discussion here is considerably more robust than that in <ref> [LS95] </ref>, and a number of outstanding issues from that paper are resolved; the important role of type information in warm fusion is recognized by considering the method in the context of a fully polymorphic higher-order language, for example, and the application of the method to the removal of virtual data structures <p> That the ideas originally put forth in <ref> [LS95] </ref> have matured into the basis of a realizable and fully automatic algorithm for program fusion is also demonstrated, as this paper reports on a prototype implementation of the warm fusion method. <p> Having already provided a context for the study of virtual data structure elimination in general, and the warm fusion method in particular, the remainder of this paper is organized as follows. Section 2 describes the technical precursors to <ref> [LS95] </ref>, from the fold/unfold transformations which were the basis for the earliest program improvement methods, through Wadler's work on listlessness and, later, treelessness, to the shortcut and catamorphic fusion rules which are so central to warm fusion. <p> and high in the definition of upto', gives a version of sos which produces no intermediate data structures: sos n = upto 00 1 where upto 00 low = if low &lt; n then 0 else (sqr low) + (upto 00 (low + 1)): (A more elaborate scheme described in <ref> [LS95] </ref> will derive the tail recursive version given in Section 1.3.) Generally speaking, the catas at the input ends of list-consuming functions "cancel" with the builds at the output ends of list-producing functions, and this cancellation may in turn bring together other cata-build pairs for deforestation, and so on. <p> But, as pointed out in <ref> [LS95] </ref>, advantage can often be taken of having already transformed into build-cata form definitions of functions called by programs currently being processed. <p> On the one hand, some heuristics can be used to "distribute" the outermost cata over body, and then the resulting function can be fused with the copy function it contains via the promotion theorem. This is essentially the first approach to fusion described on page 320 of <ref> [LS95] </ref>. On the other hand, body can be fused with the copy function via the promotion theorem to arrive at a new catamorphism, with which the outermost cata in the composition can in turn be fused. This is essentially the second approach to fusion described on page 320 of [LS95]. <p> of <ref> [LS95] </ref>. On the other hand, body can be fused with the copy function via the promotion theorem to arrive at a new catamorphism, with which the outermost cata in the composition can in turn be fused. This is essentially the second approach to fusion described on page 320 of [LS95]. Launchbury and Sheard report that although the fusion steps in the second approach sometimes fails, it seems to yield better resulting programs when it succeeds. By contrast, the second approach seems to be more robust than the first. <p> On many common examples, however, both methods are reportedly completely equivalent, in the sense that they both succeed and produce the same build-cata form. The first method requires only first-order fusion, but the second method typically involves higher-order fusion (described in <ref> [LS95] </ref>), which is undoubtedly more difficult to implement. For this reason, we have chosen initially to implement only the first method for producing a catamorphic argument to the introduced build. <p> Our implementation reflects these observations. For the prototype implementation of warm fusion reported on here, we actually restrict successful virtual data structure elimination to a smaller class of first-order-fusable programs than permitted in <ref> [LS95] </ref>. This is done by accepting for non-trivial transformation only programs of a particular syntactic form, but fortunately, this form general enough to accommodate many programs of interest, including programs defined in terms of pattern matching arguments. <p> A technique similar to this one for data structure production can be used to propagate from a function's 18 definition to its call sites information about the way in which it processes its arguments, but this is not explored in <ref> [LS95] </ref> or in our implementation. <p> This problem is not addressed in <ref> [LS95] </ref>, and it is not even clear whether or not the code degradation is sufficiently great to deserve attention. <p> Of course, the term variable v need not appear in e. Mutually recursive declarations are not permitted. The language we describe here differs from that presented in <ref> [LS95] </ref>. One superficial difference is that we permit tuples at neither the type nor the term level, preferring instead to pass bundled arguments as lists. More significantly, the polymorphism of the expression language of [LS95] is not made explicit. <p> The language we describe here differs from that presented in <ref> [LS95] </ref>. One superficial difference is that we permit tuples at neither the type nor the term level, preferring instead to pass bundled arguments as lists. More significantly, the polymorphism of the expression language of [LS95] is not made explicit. <p> The -reduction rule for the polymorphic lambda calculus is not explicitly included in the calculus of <ref> [LS95] </ref>, but repeated use of the rule is, in fact, made throughout, and so we include it explicitly in the set R of basic rewrite rules. The fi-reduction rule for types are also not present in calculus of [LS95] although certainly this was intended. <p> the polymorphic lambda calculus is not explicitly included in the calculus of <ref> [LS95] </ref>, but repeated use of the rule is, in fact, made throughout, and so we include it explicitly in the set R of basic rewrite rules. The fi-reduction rule for types are also not present in calculus of [LS95] although certainly this was intended. The -rule for types, on the other hand, is incompatible with the requirement that type constructors always be fully applied, and so we do not include it in our set of basic rewrite rules. <p> Recall that our implementation currently eliminates virtual data structures only from programs which can be represented as abstracted case statements. Moreover, since we have not implemented higher-order catamorphic fusion, our implementation effects only the first warm fusion method from <ref> [LS95] </ref>, as explained in Section 3.1 of this paper. <p> Composing, on the left, the body of the program being processed with the build-cata representation of an appropriate identity function. This is achieved by introducing a build-cata pair according to the following specification, which extends that in <ref> [LS95] </ref> to accommodate explicit polymorphism.
Reference: [Mal89] <author> G. Malcolm. </author> <title> Homomorphisms and Promotability. In Mathematics of Program Construction, </title> <publisher> Springer-Verlag, </publisher> <year> 1989. </year>
Reference: [Mar95] <author> S. Marlow. </author> <title> Deforestation for Higher-order Functional Programs. </title> <type> Dissertation, </type> <institution> University of Glasgow, </institution> <year> 1995. </year>
Reference-contexts: A fully automatic implementation of the pure treeless transformer is available ([REF]), although a blazed counterpart is not. There have been attempts to extend Wadler's deforestation techniques to programs in higher-order languages ([Chi90], <ref> [Mar95] </ref>), but this seems to be quite difficult, and many problems remain to be solved. 2.3 A Practical Approach to Fusion Wadler's algorithm for virtual data structure elimination based on fold/unfold transformations restricts attention to a syntactically distinguished class of first-order programs written in the common recursive style.
Reference: [Mee86] <author> L. Meertens. </author> <title> Algorithmics Towards Programming as a Mathematical Activity. </title> <booktitle> In Proceedings of the CWI Symposium on Mathematics and Computer Science, </booktitle> <pages> pp. 289 - 334, </pages> <year> 1986. </year>
Reference-contexts: The calculational style of programming, first introduced by Bird and Meertens <ref> [Bir97, Mee86, Mee92] </ref>, stresses calculating programs via algebraic identities over list programs in much the same manner that high school students calculate with the laws of algebra. Inherent in the calculational style are techniques for transforming clear but inefficient programs into ones which use resources efficiently.
Reference: [Mee92] <author> L. Meertens. Paramorphisms. </author> <booktitle> Formal Aspects of Computing 4:5 (1992), </booktitle> <pages> pp. 413 - 424. </pages>
Reference-contexts: This search has not only led to the development of calculation-based program transformations (e.g., [Fok92], [Jeu93], <ref> [Mee92] </ref>, [Mei92]), but has inspired more general work on fold/unfold transformations as well (see, e.g., [Amt92], [San94]). <p> The calculational style of programming, first introduced by Bird and Meertens <ref> [Bir97, Mee86, Mee92] </ref>, stresses calculating programs via algebraic identities over list programs in much the same manner that high school students calculate with the laws of algebra. Inherent in the calculational style are techniques for transforming clear but inefficient programs into ones which use resources efficiently.
Reference: [Mei92] <author> E. Meijer. </author> <title> Calculating Compilers. </title> <type> Dissertation, </type> <institution> Universiteit Nijmegen, </institution> <year> 1992. </year>
Reference-contexts: This search has not only led to the development of calculation-based program transformations (e.g., [Fok92], [Jeu93], [Mee92], <ref> [Mei92] </ref>), but has inspired more general work on fold/unfold transformations as well (see, e.g., [Amt92], [San94]).
Reference: [MH95] <author> E. Meijer and G. Hutton. </author> <title> Bananas in Space: Extending Fold and Unfold to Exponential Types. </title> <booktitle> in Proceedings, Conference on Functional Programming and Computer Architecture, </booktitle> <pages> pp. 324 - 333, </pages> <year> 1995. </year>
Reference: [Par92] <author> W. Partain. </author> <title> The nofib Benchmarking Suite. </title> <booktitle> In Proceedings Glagow Workshop on Functional Programming, </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1992. </year>
Reference: [PJL91] <author> S. Peyton Jones and J. Launchbury. </author> <title> Unboxed Values as First-class Citizens in a Non-strict Functional Language. </title> <booktitle> FPCA 1991. </booktitle>
Reference: [PW96] <author> T. Proebsting and S. Watterson. </author> <title> Filter Fusion. </title> <booktitle> In Proceedings, ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pp. 119 - 130, </pages> <year> 1996. </year>
Reference: [Rey83] <author> J. Reynolds. </author> <title> Types, Abstraction, and Parametric Polymorphism. </title> <booktitle> In Proceedings, Information Processing, </booktitle> <pages> pp. 513 - 523, </pages> <year> 1983. </year>
Reference: [San94] <author> D. Sands. </author> <title> Total Correctness and Improvement in the Transformation of Functional Programs. </title> <type> Unpublished manuscript, </type> <institution> DIKU, University of Copenhagen, </institution> <year> 1994. </year>
Reference-contexts: This search has not only led to the development of calculation-based program transformations (e.g., [Fok92], [Jeu93], [Mee92], [Mei92]), but has inspired more general work on fold/unfold transformations as well (see, e.g., [Amt92], <ref> [San94] </ref>).
Reference: [Sch86] <author> D.A. Schmidt. </author> <title> Denotational Semantics, Wm. </title> <editor> C. Brown, </editor> <year> 1986. </year>
Reference: [SF93] <author> T. Sheard and L. Fegaras. </author> <title> A Fold for All Seasons. </title> <booktitle> In Proceedings, Conference on Functional Programming and Computer Architecture, </booktitle> <pages> pp. 233 - 242, </pages> <year> 1993. </year>
Reference-contexts: In particular, the language of <ref> [SF93] </ref> does not support general recursion. The main recursion operators with which Sheard and Fegaras work are called catamorphisms; their list versions are known variously as fold in ML, reduce in early versions of Miranda, and foldr 10 in Haskell. <p> In addition to insuring that no global program analysis is required to determine applicability of the normalizing transformations, the restriction to catamorphic recursion in <ref> [SF93] </ref> guarantees termination of programs obtained by normalization. Indeed, since all programs expressible in the language of [SF93] necessarily terminate, the correctness of the normalization algorithm is immediate. <p> In addition to insuring that no global program analysis is required to determine applicability of the normalizing transformations, the restriction to catamorphic recursion in <ref> [SF93] </ref> guarantees termination of programs obtained by normalization. Indeed, since all programs expressible in the language of [SF93] necessarily terminate, the correctness of the normalization algorithm is immediate. But even when attention is restricted to languages permitting only catamorphic recursion, a problem arises in practice: without user-supplied guidance, the normalization algorithm unfolds all function definitions in order to propagate producer information to consumer sites. <p> Despite these difficulties | and although unaccompanied by any firm guarantee of termination | the normalization algorithm of Sheard and Fegaras has proved to be considerably more practical than its predecessors. The results of <ref> [SF93] </ref> demonstrate clearly that catamorphic fusion can be achieved using fully automated tools, and so really is suitable for incorporation into real compilers. <p> In A Short Cut to Deforestation ([GLPJ93]), a one-step fusion algorithm is given which completely by-passes the combinatorial explosion problem of <ref> [SF93] </ref>. Like Sheard and Fegaras' normalization algorithm, the shortcut is a calculation-based, rather than a search-based, program improvement technique, and so it relies on programs to be transformed being written in a highly stylized form called build-cata form.
Reference: [Tur86] <author> V. F. Turchin. </author> <title> The Concept of a Supercompiler. </title> <journal> ACM Transactions on Programming Languages and Systems 8:3 (1986), </journal> <pages> pp. 90 - 121. </pages>
Reference: [Wad83] <author> P. Wadler. </author> <title> Listlessness is Better than Laziness. </title> <type> Dissertation, </type> <institution> Department of Computer Science, Carnegie Mellon University, </institution> <year> 1993. </year>
Reference: [Wad84] <author> P. Wadler. </author> <title> Listlessness is Better than Laziness II: Composing Listless Functions. </title> <publisher> In Springer-Verlag LNCS </publisher>
Reference: [Wad89] <author> P. Wadler. </author> <title> Theorems for Free! In Proceedings, </title> <booktitle> Conference on Functional Programming and Computer Architecture, </booktitle> <pages> pp. 347 - 359, </pages> <year> 1989. </year>
Reference-contexts: Fortunately, the kind of uniformity required for correct application of the cata-build rule can be guaranteed simply by restricting the types of the arguments to build. Indeed, the precise version of the cata-build rule for lists is a direct consequence of the "free theorem" ([Rey83], <ref> [Wad89] </ref>) for the type 8fi:(ff ! fi ! fi) ! fi ! fi, which correct applications of the build-cata rule require functional arguments to build to have.
Reference: [Wad90] <author> P. Wadler. </author> <title> Deforestation: Transforming Programs to Eliminate Trees. </title> <booktitle> Theoretical Computer Science 73 (1990), </booktitle> <pages> pp. 231 - 248. </pages>
Reference: [Wat87] <author> R.C. Waters. </author> <title> Obviously Synchronizable Series Expressions: Part I; User's Manual for the OSS Macro Package. </title> <type> Technical report, </type> <institution> Artificial Intelligence Laboratory, Massachusetts Institute of Technology, </institution> <year> 1987. </year>
Reference: [Wat91] <author> R. Waters. </author> <title> Automatic Transformation of Series Expressions into Loops. </title> <journal> Transactions on Programming Languages and Systems 13:1 (1991), </journal> <pages> pp. 52 - 98. </pages>
References-found: 38

