URL: http://seclab.cs.ucdavis.edu/~samorodi/papers/USENIX/coots97/proebsting2.ps
Refering-URL: http://seclab.cs.ucdavis.edu/~samorodi/papers/USENIX/coots97/
Root-URL: http://www.cs.ucdavis.edu
Title: Krakatoa: Decompilation in Java (Does Bytecode Reveal Source?)  
Author: Todd A. Proebsting, Scott A. Watterson 
Address: Portland, Oregon,  
Affiliation: Technologies and Systems  The University of Arizona  
Note: The following paper was originally published in the Proceedings of the Third USENIX Conference on Object-Oriented  For more information about USENIX Association contact:  
Email: Email: office@usenix.org  
Phone: 1. Phone: 510 528-8649 2. FAX: 510 548-5738 3.  4.  
Date: June 1997  
Web: WWW URL: http://www.usenix.org  
Abstract-found: 0
Intro-found: 1
Reference: [AKPW83] <author> J.R. Allen, Ken Kennedy, Carrie Porterfield, and Joe Warren. </author> <booktitle> Conver sion of control dependence to data de-pendence. </booktitle> <pages> pages 177-189, </pages> <year> 1983. </year>
Reference-contexts: Her technique structures old FORTRAN programs for readability. As a result, her technique may leave some goto's in the resulting programs, which is not allowed in Java. Other techniques for eliminating goto's have been proposed <ref> [EH94, Amm92, AKPW83, AM75] </ref>. These techniques may change the structure of the program, and may add condition variables, or create subroutines. 8 Conclusion In this paper, we present a technique for decom-piling Java bytecode into Java source. Our decom-piler, Krakatoa, produces syntactically legal Java source from legal, reducible Java bytecode.
Reference: [AM75] <author> E. Ashcroft and Z. Manna. </author> <title> Translating programs schemas to while-schemas. </title> <journal> SIAM Journal of Computing, </journal> <volume> 4(2) </volume> <pages> 125-146, </pages> <year> 1975. </year>
Reference-contexts: Her technique structures old FORTRAN programs for readability. As a result, her technique may leave some goto's in the resulting programs, which is not allowed in Java. Other techniques for eliminating goto's have been proposed <ref> [EH94, Amm92, AKPW83, AM75] </ref>. These techniques may change the structure of the program, and may add condition variables, or create subroutines. 8 Conclusion In this paper, we present a technique for decom-piling Java bytecode into Java source. Our decom-piler, Krakatoa, produces syntactically legal Java source from legal, reducible Java bytecode.
Reference: [Amm92] <author> Zahira Ammarguellat. </author> <title> A control-flow normalization algorithm and its complexity. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 18(2) </volume> <pages> 237-250, </pages> <year> 1992. </year>
Reference-contexts: Her technique structures old FORTRAN programs for readability. As a result, her technique may leave some goto's in the resulting programs, which is not allowed in Java. Other techniques for eliminating goto's have been proposed <ref> [EH94, Amm92, AKPW83, AM75] </ref>. These techniques may change the structure of the program, and may add condition variables, or create subroutines. 8 Conclusion In this paper, we present a technique for decom-piling Java bytecode into Java source. Our decom-piler, Krakatoa, produces syntactically legal Java source from legal, reducible Java bytecode.
Reference: [ASU86] <author> A. V. Aho, R. Sethi, and J. D. Ull-man. </author> <booktitle> Compilers: Principles, Techniques, and Tools. </booktitle> <publisher> Addison-Wesley, </publisher> <address> Reading, Massachusetts, </address> <year> 1986. </year>
Reference-contexts: As an example, in Figure 6, 1 , 2 , 4 , 5 , 6 , and 7 are equivalent, as are program points 3 and 8 . Both reachability and equivalence are simple to compute via standard control-flow analyses <ref> [ASU86] </ref>. 4.2 AST Rewrite Rules Krakatoa performs a series of AST rewriting transformations to recover as many of the "natural" program constructs as it can (e.g. if-then-else, etc.). Krakatoa applies these rewriting rules repeatedly until no changes occur.
Reference: [Bak77] <author> Brenda S. Baker. </author> <title> An algorithm for structuring flowgraphs. </title> <journal> Journal of the Association for Computing Machinery, </journal> <volume> 24(1) </volume> <pages> 98-120, </pages> <month> January </month> <year> 1977. </year>
Reference-contexts: Node-splitting preserves the execution sequence of a program, but not the structure. We do not consider this reasonable for de-compilation. Baker presents a technique for producing programs from flow graphs <ref> [Bak77] </ref>. Baker generates summary control flow information to guide her graph transformations. Our goal is similar, since the output of the decompiler should be as readable as possible. Her technique structures old FORTRAN programs for readability.
Reference: [Cif93] <author> Cristina Cifuentes. </author> <title> A structuring algorithm for decompilation. </title> <booktitle> In Proceedings of the XIX Conferencia Lati-noamericana de Informatica, </booktitle> <pages> pages 267-276, </pages> <address> Buenos Aires, Argentina, </address> <month> August </month> <year> 1993. </year>
Reference-contexts: This operation presents two difficulties: it requires determining short-circuit operators during expression recovery, and it requires that expression recovery handle non-empty stacks at basic block boundaries. Fortunately, the short-circuit problem can be handled easily with four simple graph-writing rules given in <ref> [Cif93] </ref>. The non-empty stack problem is difficult because it requires combining expressions in our symbolic stack upon entering a basic block with multiple predecessors. <p> He made no attempt to recover high-level control constructs. All high-level control structures were provided by the original Pascal. Several decompilation systems have used a series of graph transformations to recover high-level constructs <ref> [Lic85, Cif93] </ref>. These systems encounter difficulties in the presence of nested loops, and other arbitrarily control flow. Multilevel break's cause considerable problems. Exception handling introduces another difficulty to such systems, as the control flow graph can be entered in several places.
Reference: [EH94] <author> Ana M. Erosa and Laurie J. Hendren. </author> <title> Taming control flow: A structured approach to eliminating goto statements. </title> <booktitle> pages 229-240. International Conference on Computer Languages, </booktitle> <month> May </month> <year> 1994. </year>
Reference-contexts: Her technique structures old FORTRAN programs for readability. As a result, her technique may leave some goto's in the resulting programs, which is not allowed in Java. Other techniques for eliminating goto's have been proposed <ref> [EH94, Amm92, AKPW83, AM75] </ref>. These techniques may change the structure of the program, and may add condition variables, or create subroutines. 8 Conclusion In this paper, we present a technique for decom-piling Java bytecode into Java source. Our decom-piler, Krakatoa, produces syntactically legal Java source from legal, reducible Java bytecode.
Reference: [Lic85] <author> Ulrike Lichtblau. </author> <title> Decompilation of control structures by means of graph transformations. </title> <editor> In C. F. M. Ni-vat Hartmut Ehrig and J. Thatcher, editors, </editor> <booktitle> Mathematical foundations of software development: Proceedings of the International Joint Conference on Theory and Practice of Software Development (TAPSOFT 85): volume 1 Colloquium on Trees in Algebra and Programming (CAAP '85), volume 185 of Lecture Notes in Computer Science, </booktitle> <pages> pages 284-297. </pages> <publisher> Springer-Verlag, </publisher> <month> March </month> <year> 1985. </year>
Reference-contexts: He made no attempt to recover high-level control constructs. All high-level control structures were provided by the original Pascal. Several decompilation systems have used a series of graph transformations to recover high-level constructs <ref> [Lic85, Cif93] </ref>. These systems encounter difficulties in the presence of nested loops, and other arbitrarily control flow. Multilevel break's cause considerable problems. Exception handling introduces another difficulty to such systems, as the control flow graph can be entered in several places.
Reference: [LY97] <author> Tim Lindholm and Frank Yellin. </author> <title> The Java Virtual Machine Specification. The Java Series. </title> <publisher> Addison-Wesley, </publisher> <year> 1997. </year>
Reference-contexts: 1 Introduction Decompilation transforms a low-level language into a high-level language. The Java Virtual Machine (JVM) specifies a low-level bytecode language for a stack-based machine <ref> [LY97] </ref>. This language defines 203 operators, with most of the control flow specified by simple explicit transfers and labels. Compiling a Java class yields a class file that contains type information and bytecode. The JVM requires a significant amount of type information from the class files for object linking.
Reference: [PKT73] <author> W.W. Peterson, T. Kasami, and N. Tokura. </author> <title> On the capabilities of while, repeat and exit statements. </title> <journal> Communications of the ACM, </journal> <volume> 16(8) </volume> <pages> 503-512, </pages> <year> 1973. </year>
Reference-contexts: These augmenting edges occur between every pair of physically adjacent instructions even if actual control flow between them is impossible. He proves that if this augmented graph is reducible, then a structurally equivalent <ref> [PKT73] </ref> program can be created without goto's. However, Ramshaw provides no algorithm for finding a reducible augmented flow graph from a given reducible flow graph. The control-flow graphs of Java programs are reducible. Therefore, the compiled bytecode will likely form a reducible control-flow graph. <p> Mocha often aborts when it confronts tangled|yet structured|control flow (including multi-level break's and continue's). The system does issue type declarations, and uses debugging information (when present) to recover local variable names. Other graph transformation systems used node-splitting to transform an unstructured graph to a structured graph <ref> [WO78, PKT73, Wil77] </ref>. Peter-son, Kasami, and Tokura present a proof that every flow graph can be transformed into an equivalent well-formed flow graph. Williams and Ossher use a similar technique, but they recognize five unstructured sub-graphs, and replace those with equivalent structured graphs.
Reference: [Ram88] <author> Lyle Ramshaw. </author> <title> Eliminating go to's while preserving program structure. </title> <journal> Journal of the Association for Computing Machinery, </journal> <volume> 35(4) </volume> <pages> 893-920, </pages> <month> October </month> <year> 1988. </year>
Reference-contexts: Java, however, has no goto statement, so its control flow must be expressed with structured statements. Ramshaw presented an algorithm for eliminating goto's from Pascal programs while preserving the program's structure <ref> [Ram88] </ref>. This algorithm replaces each goto with a multilevel break to a surrounding loop. The algorithm determines the ap-propropriate locations for these surrounding loops. We trivially extended his algorithm to use multilevel continue's. Ramshaw's (extended) algorithm replaces each forward goto with a break and each backward goto with a continue. <p> It is impossible to jump to the middle of instructions. It is impossible to generate bytecode and then jump to it. 7 Related Work Ramshaw presented a technique for eliminating goto's in Pascal programs by replacing them with multilevel break's and surrounding loops <ref> [Ram88] </ref>. He made no attempt to recover high-level control constructs. All high-level control structures were provided by the original Pascal. Several decompilation systems have used a series of graph transformations to recover high-level constructs [Lic85, Cif93].
Reference: [Sri96] <author> KB Sriram. Hashjava. </author> <note> url: http://www.sbktech.org/hashjava.html, 1996. </note>
Reference-contexts: One code obfuscation technique that is modestly effective is to change the class file's symbol table to contain bizarre names for fields and methods. So long as cooperating classes agree on these names, the class files will link and execute correctly <ref> [vV96, Sri96] </ref>.
Reference: [vV96] <author> Hanpeter van Vliet. Mocha. </author> <note> current url: http://www.brouhaha.com/~eric/ computers/mocha-b1.zip, </note> <year> 1996. </year>
Reference-contexts: One code obfuscation technique that is modestly effective is to change the class file's symbol table to contain bizarre names for fields and methods. So long as cooperating classes agree on these names, the class files will link and execute correctly <ref> [vV96, Sri96] </ref>. <p> Exception handling introduces another difficulty to such systems, as the control flow graph can be entered in several places. Krakatoa easily creates multi-level break's and continue's, and is able to eliminate virtually all of the unnecessary ones via successive application of the rewrite rules. "Mocha" (version 1 beta 1) <ref> [vV96] </ref> is a Java de-compiler written by Hanpeter van Vliet. Mocha uses graph transformations to recover high-level constructs. Mocha often aborts when it confronts tangled|yet structured|control flow (including multi-level break's and continue's). The system does issue type declarations, and uses debugging information (when present) to recover local variable names.
Reference: [Wil77] <author> M.H. Williams. </author> <title> Generating structured flow diagrams: </title> <journal> The nature of unstructuredness. Computer Journal, </journal> <volume> 20(1) </volume> <pages> 45-50, </pages> <year> 1977. </year>
Reference-contexts: Mocha often aborts when it confronts tangled|yet structured|control flow (including multi-level break's and continue's). The system does issue type declarations, and uses debugging information (when present) to recover local variable names. Other graph transformation systems used node-splitting to transform an unstructured graph to a structured graph <ref> [WO78, PKT73, Wil77] </ref>. Peter-son, Kasami, and Tokura present a proof that every flow graph can be transformed into an equivalent well-formed flow graph. Williams and Ossher use a similar technique, but they recognize five unstructured sub-graphs, and replace those with equivalent structured graphs.
Reference: [Wil97] <author> U. G. Wilhelm. </author> <title> Cryptographically protected objects, </title> <month> May </month> <year> 1997. </year> <note> A french version appeared in the Proceedings of RenPar'9, Lausanne, CH. http://lsewww.epfl.ch/~wilhelm/ CryPO.html. </note>
Reference-contexts: lp2 continue lp3; g // lp3 return; g Algorithm) class foo f void foo (int i1, int i2) f lp3: for ( ;!((i1+i2)&gt;=10)&&((i1&gt;5)); ) f i1 = i2; g // then else f i1 += 100; g // lp3 return; g compilation Results) hardware and encryption to protect class files <ref> [Wil97] </ref>. Many traditional countermeasures to reverse-engineering will not work for Java bytecode. It is impossible to mix code and data. It is impossible to jump to the middle of instructions.
Reference: [WO78] <author> M.H. Williams and H.L. Ossher. </author> <title> Conversion of unstructured flow diagrams to structured. </title> <journal> Computer Journal, </journal> <volume> 21(2) </volume> <pages> 161-167, </pages> <year> 1978. </year>
Reference-contexts: Mocha often aborts when it confronts tangled|yet structured|control flow (including multi-level break's and continue's). The system does issue type declarations, and uses debugging information (when present) to recover local variable names. Other graph transformation systems used node-splitting to transform an unstructured graph to a structured graph <ref> [WO78, PKT73, Wil77] </ref>. Peter-son, Kasami, and Tokura present a proof that every flow graph can be transformed into an equivalent well-formed flow graph. Williams and Ossher use a similar technique, but they recognize five unstructured sub-graphs, and replace those with equivalent structured graphs.
References-found: 16

