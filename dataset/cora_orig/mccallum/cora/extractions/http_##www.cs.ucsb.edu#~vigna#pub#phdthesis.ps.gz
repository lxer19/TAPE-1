URL: http://www.cs.ucsb.edu/~vigna/pub/phdthesis.ps.gz
Refering-URL: http://www.cs.ucsb.edu/~vigna/listpub.html
Root-URL: http://www.cs.ucsb.edu
Title: Mobile Code Technologies, Paradigms, and Applications  
Author: Giovanni Vigna Relatore: Prof. Carlo Ghezzi Correlatore: Prof. Rocco De Nicola Tutore: Prof. Alfonso Fuggetta Coordinatore del dottorato: Prof. Sergio Bittanti 
Degree: Dottorato di Ricerca in  Tesi di Dottorato di:  
Affiliation: POLITECNICO DI MILANO  Ingegneria Informatica e Automatica  X ciclo  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> G. Abowd, R. Allen, and D. Garlan. </author> <title> Using Style to Understand Descriptions of Software Architecture. </title> <booktitle> In Proc. of SIGSOFT'93: Foundations of Software Engineering, </booktitle> <month> December </month> <year> 1993. </year>
Reference-contexts: Software architectures with similar characteristics can be represented by architectural styles <ref> [1] </ref> or design paradigms, which define architectural abstractions and reference structures that may be instantiated into actual software architectures. A design paradigm is not necessarily induced by the technology used to develop the software system|it is a conceptually separate entity.
Reference: [2] <author> A. Acharya, M. Ranganathan, and J. Saltz. Sumatra: </author> <title> A Language for Resource-aware Mobile Programs. </title> <booktitle> In Vitek and Tschudin [101], </booktitle> <pages> pages 111-130. </pages>
Reference-contexts: A SURVEY OF MOBILE CODE SYSTEMS 31 Sumatra (http://www.cs.umd.edu/users/saltz/) Sumatra <ref> [2] </ref>, developed at University of Maryland, is a Java extension designed expressly to support the implementation of resource-aware mobile programs, i.e. programs which are able to adapt to resource changes by exploiting mobility. Sumatra provides support for strong mobility of Java threads, which are Sumatra EUs.
Reference: [3] <author> Y. Artsy and R. Finkel. </author> <title> Designing a Process Migration Facility: </title> <booktitle> The Charlotte Experience. IEEE Computer, </booktitle> <pages> pages 47-56, </pages> <month> September </month> <year> 1989. </year>
Reference-contexts: Process migration facilities have been introduced at the operating system level to achieve load balancing across network nodes. Therefore, most of these facilities provide transparent process migration, in which the programmer has neither control nor visibility of the migration process <ref> [3, 23, 76] </ref>. Other systems provide some form of control over the migration process. For example, in the Locus system [93] process migration can be triggered either by an external signal or by the invocation of the migrate system call.
Reference: [4] <author> H.E. Bal, M.F. Kaashoek, </author> <title> and A.S. Tanenbaum. Experience with Distributed Programming in Orca. </title> <journal> IEEE Trans. on Software Engineering, </journal> <volume> 18, </volume> <month> March </month> <year> 1992. </year>
Reference-contexts: In existing MCSs, this mechanism is always used for local communication, although it could be extended to implement remote communication, for example with a distributed shared variable abstraction, as described in <ref> [4] </ref>. Event -based mechanisms, in turn, define an event bus constituting the logical channel through which events are dispatched, together with primitives that allow EUs to generate events and to subscribe for receiving events they are interested in.
Reference: [5] <author> M. Baldi, S. Gai, </author> <title> and G.P. Picco. Exploiting Code Mobility in Decentralized and Flexible Network Management. </title> <booktitle> In Rothermel and Popescu-Zeletin [81], </booktitle> <pages> pages 13-26. </pages>
Reference-contexts: Our initial experience in applying the paradigms <ref> [5, 32] </ref> suggests that these abstractions are effective in the design of distributed applications. Furthermore, they are fairly independent of the particular language or system in which they are eventually implemented. Mobile code paradigms model explicitly the concept of location. <p> Code mobility could be used to design and implement monitoring components that are co-located with the devices being monitored and report events that represent the evolution of the device state. In addition, the shipment of management components to remote sites could improve both performance and flexibility <ref> [5, 33] </ref>. A case study focused on the application of our taxonomy to the network management application domain is presented in [29]. 5.3.5 Workflow management and cooperation Workflow management applications support the cooperation of persons and tools involved in a development process.
Reference: [6] <author> J. Baumann, F. Hohl, N. Radouniklis, K. Rothermel, and M. Straer. </author> <title> Communication Concepts for Mobile Agent Systems. </title> <booktitle> In Rothermel and Popescu-Zeletin [81], </booktitle> <pages> pages 123-135. </pages>
Reference-contexts: Furthermore, building scalable and efficient mechanisms for dispatching events over large-scale networks is still an open research area [79, 80]. Nevertheless, the first proposals of architectures overcoming the problem are beginning to appear in <ref> [6, 108, 22] </ref>. Some of these proposals combine the notion of event with the notion of group. <p> In addition, messengers may use asymmetric encryption to create protected entries in shared memory, accessible by means of a public key, but modifiable only by means of a private key. 3.7. A SURVEY OF MOBILE CODE SYSTEMS 29 Mole (http://www.informatik.uni-stuttgart.de/ipvr/vs/projekte/mole.html) Developed at University of Stuttgart, Mole <ref> [89, 6] </ref> is a Java API that supports weak mobility. Mole agents are Java objects which run as threads of the JVM, which is abstracted into a place, the Mole CE. <p> Hence, data space management by move is exploited. Translation Mole agents are Java programs. Therefore, as for the Aglet system, a "local translation after coding" mechanism is adopted. Communication The Mole project puts a strong emphasis on inter-agent communication which, according to the description in <ref> [6] </ref> is centered around three main concepts: agent groups, sessions, and events. Agent groups can be created by defining a badge, i.e. an application-dependent identifier which an agent can "pin" on and off.
Reference: [7] <author> T. Berners-Lee, R. Cailliau, H.F. Nielsen, and A. </author> <title> Secret. The World-Wide Web. </title> <journal> Communications of the ACM, </journal> <volume> 37(8) </volume> <pages> 76-82, </pages> <month> August </month> <year> 1994. </year>
Reference-contexts: A CASE STUDY In sections 6.5- 6.6 we exemplify these relationships by implementing several designs of the application using different types of technologies. 6.2 The problem: minimizing network traffic The fast growth of the Internet [34] and the success experienced by the World Wide Web infrastructure <ref> [7] </ref> have changed the way information is accessed and distributed. Centralized information systems have evolved into a global distributed information repository interwoven with cross-references. The systems that participate in the World Wide Web are managed in a decentralized, autonomous way.
Reference: [8] <author> K.A. Bharat and L. Cardelli. </author> <title> Migratory Applications. </title> <type> Technical Report 138, </type> <institution> Digital Equipment Corporation, Systems Research Center, </institution> <month> February </month> <year> 1996. </year>
Reference-contexts: A common case is represented by the use of a weak MCS that allows for code shipping for implementing applications designed following the MA paradigm <ref> [8] </ref>. In this case, the architectural concept of a moving component must be implemented using a technology that allows just for mobile code modules.
Reference: [9] <author> S. Bhattacharjee, K.L. Calvert, </author> <title> and E.W. Zegura. An Architecture for Active Networking. </title> <booktitle> In High Performance Networking (HPN'97), </booktitle> <month> April </month> <year> 1997. </year>
Reference-contexts: Although some interpret the idea of active networks without any relation with code mobility <ref> [9] </ref>, most of the approaches rely on it and can be classified along a spectrum delimited by two extremes represented by the programmable switch and the capsule approaches [92].
Reference: [10] <author> L. Bic, M. Fukuda, and M. Dillencourt. </author> <title> Distributed Computing Using Autonomous Objects. </title> <booktitle> IEEE Computer, </booktitle> <month> August </month> <year> 1996. </year>
Reference-contexts: In an early and yet valuable assessment of code mobility [39] the authors analyze and compare issues that belong to different abstraction levels. Analogously, in a recent work about autonomous objects <ref> [10] </ref>, mechanisms like REV [87] and RPC [11] are compared to the Echo distributed algorithms [19], to applications like "intelligent e-mail" and Web browsers, and to paradigms for structuring distributed applications, like mobile agents. These 2.3.
Reference: [11] <author> A. Birrell and B. Nelson. </author> <title> Implementing Remote Procedure Calls. </title> <journal> ACM Trans. on Computer Systems, </journal> <volume> 2(1) </volume> <pages> 29-59, </pages> <month> February </month> <year> 1984. </year>
Reference-contexts: In an early and yet valuable assessment of code mobility [39] the authors analyze and compare issues that belong to different abstraction levels. Analogously, in a recent work about autonomous objects [10], mechanisms like REV [87] and RPC <ref> [11] </ref> are compared to the Echo distributed algorithms [19], to applications like "intelligent e-mail" and Web browsers, and to paradigms for structuring distributed applications, like mobile agents. These 2.3. A MOBILE CODE FRAMEWORK 7 are different concepts and notions that cannot be compared directly. <p> Point-to-point mechanisms Point-to-point mechanisms enable communication between two EUs. The more primitive mechanism is message passing, although no existing MCSs actually uses it for communication between EUs moving arbitrarily, due to the problems arising in presence of mobility, as discussed earlier. Usually, some form of remote procedure call <ref> [11] </ref> (RPC) is provided instead. This may involve invocation of bare procedures or method invocation on remote objects, a la CORBA. RPC is often exploited for both local and remote communication, in order to provide a uniform mechanism. <p> Given a particular paradigm, which technology should be used? As far as mobility is concerned, we can distinguish implementation technologies in three broad classes (see Section 3.3): Non-mobile These technologies enable the communication between remote executing units (EUs) in the form of message exchange. A typical example is RPC <ref> [11] </ref>. Weakly mobile These technologies provide mechanisms that enable an EU to send code to be executed in a remote computational environment (CE) together with some initialization data or to fetch code from a remote CE.
Reference: [12] <author> J.K. Boggs. </author> <title> IBM Remote Job Entry Facility: Generalize Subsystem Remote Job Entry Facility. </title> <journal> IBM Technical Disclosure Bulletin 752, IBM, </journal> <month> August </month> <year> 1973. </year> <note> 77 78 BIBLIOGRAPHY </note>
Reference-contexts: INTRODUCTION Chapter 2 Motivation and approach 2.1 Related work Code mobility is not a new concept. In the recent past, several mechanisms and facilities have been designed and implemented in order to move code among the nodes of a network. Examples are remote batch job submission <ref> [12] </ref> and the use of PostScript [44] to control printers. A more structured approach has been followed in the research work on distributed operating systems.
Reference: [13] <author> N. Borenstein. </author> <title> EMail With A Mind of Its Own: The Safe-Tcl Language for Enabled Mail. Technical report, First Virtual Holdings, </title> <publisher> Inc, </publisher> <year> 1994. </year>
Reference-contexts: Therefore, access to objects and files residing at the engine CE must be granted explicitly by the remote engine passing a reference to a local component when invoking the procedure. Safe-Tcl (http://sunscript.sun.com) Initially developed by the authors of the Internet MIME standard, Safe-Tcl <ref> [13] </ref> is an extension of Tcl [69] conceived to support active e-mail. Mobility In active e-mail, messages may include code to be executed when the recipient receives or reads the message. <p> partial state S i should produce a hash value equal to the one contained in the corresponding receipt message, otherwise the site at step i cheated. 7.4 The SALTA language The SALTA language (Secure Agent Language with Tracing of Actions 6 ) is a modified version of the Safe-Tcl language <ref> [13, 71] </ref>. The available Tcl [69] com mand set is showed in Table 7.1. The Safe-Tcl language has been restricted further, and some new instructions have been added: request, service, reply and go. 6 "Salta" is also an italian verb meaning "jump". 7.4.
Reference: [14] <author> P.M.E. De Bra and R.D.J. Post. </author> <title> Information Retrieval in the World-Wide Web: Making Client-based searching feasable. </title> <booktitle> In Proceedings of the First International World-Wide Web Conference, </booktitle> <address> Geneva, Switzerland, </address> <month> May </month> <year> 1994. </year>
Reference-contexts: While this evolution has provided a larger number of users with access to information and services, at the same time it has made some tasks considerably more complex. A notable example is represented by the retrieval of information concerning a particular subject <ref> [14] </ref>. Several systems, called robots, spiders, wanderers, worms, or internet agents, have been implemented to automate the process of finding and indexing the information provided by the World Wide Web infrastructure [54].
Reference: [15] <author> T. Cai, P. Gloor, and S. Nog. </author> <title> DataFlow: A Workflow Management System on the Web using transportable Agents. </title> <type> Technical Report TR96-283, </type> <institution> Dept. of Computer Science, Dartmouth College, </institution> <address> Hanover, NH, </address> <year> 1996. </year>
Reference-contexts: For example, a mobile component could encapsulate a text document that undergoes several revisions. The component maintains information about the document state, the legal operations on its contents, and the next scheduled step in the revision process. An application of these concepts can be found in <ref> [15] </ref>. 5.3.6 Active networks The idea of active networks has been proposed recently [92, 111] as a means to introduce flexibility into networks and provide more powerful mechanisms to "program" the network according to applications' needs.
Reference: [16] <author> L. Cardelli. </author> <title> A language with distributed scope. </title> <journal> Computing Systems, </journal> <volume> 8(1) </volume> <pages> 27-59, </pages> <year> 1995. </year>
Reference-contexts: Finally, anonymous communication is encompassed by event management, which is still under design. Security As far as security is concerned, Mole does not provide anything but the underlying Java mechanisms. Obliq (http://www.luca.demon.co.uk/Obliq/Obliq.html) Developed at DEC, Obliq <ref> [16] </ref> is an untyped, object-based, lexically scoped, interpreted language. Obliq allows threads, the Obliq EUs, to request the remote execution of procedures to execution engines which implement the CE concept. <p> Here we implement the different designs of our application using different technologies belonging to the classes listed above in order to show in greater detail which are the advantages and disadvantages of each solution [24]. For the actual implementation we will use Tcl-DP [86], Obliq <ref> [16] </ref>, and Agent Tcl [36]. Tcl-DP is an extension of the Tcl language [69] for distributed programming. Tcl-DP provides support for TCP/IP and RPC programming. It is a non-mobile technology. Obliq is an untyped, object-based, lexically scoped, interpreted language. It supports remote method invocation and remote evaluation of code.
Reference: [17] <author> N. Carriero and D. Gelernter. </author> <title> Linda in Context. </title> <journal> Comm. of the ACM, </journal> <volume> 32, </volume> <month> April </month> <year> 1989. </year>
Reference-contexts: The group naming scheme and a distributed event mechanism may provide a good set of abstractions to accomplish this. Another form of implicit communication is provided by tuple spaces. With this mechanism <ref> [17] </ref>, EUs communicate by either inserting the tuples containing the information to be communicated into a shared tuple space, or by searching it for a tuple using some form of pattern matching. This mechanism provides a very powerful abstraction of a communication channel.
Reference: [18] <author> A. Carzaniga, G.P. Picco, and G. Vigna. </author> <title> Designing Distributed Applications with Mobile Code Paradigms. </title> <editor> In R. Taylor, editor, </editor> <booktitle> Proc. of the 19 th Int. Conf. on Software Engineering (ICSE'97), </booktitle> <pages> pages 22-32. </pages> <publisher> ACM Press, </publisher> <year> 1997. </year>
Reference-contexts: A different approach comes from a promising research area which is attacking the problems mentioned so far by exploiting mobile code. Code mobility can be defined informally as the capability to change dynamically the bindings between code fragments and the location where they are executed <ref> [18] </ref>. This powerful concept originated a very interesting range of developments. However, despite the widespread interest in mobile code technology and applications, the field is still quite immature. A sound terminological and methodological common framework is still missing: terms are defined imprecisely and with a loose semantics. <p> We assume the existence of another site S B , which will be involved in the accomplishment of the service. 1 The reader interested in the original formulation of the paradigms described here is directed to <ref> [18] </ref>. A case study centered around a formalization of these paradigms using the UNITY notation is also provided in [75]. 4.3. <p> This type of application has been often considered "the killer application" motivating a design based on the MA paradigm. However, analysis to determine the network traffic in some typical cases evidenced that, according to the parameters of the application, the CS paradigm sometimes can be the best choice <ref> [18] </ref>. 5.3.2 Active documents In active documents applications, traditionally passive data like e-mail or Web pages, are enhanced with the capability of executing programs which are somewhat related with the document contents, enabling enhanced presentation and interaction.
Reference: [19] <author> E.J.H. Chang. </author> <title> Echo Algorithms: Depth Parallel Operations on General Graphs. </title> <journal> IEEE Trans. on Software Engineering, </journal> <month> July </month> <year> 1982. </year>
Reference-contexts: In an early and yet valuable assessment of code mobility [39] the authors analyze and compare issues that belong to different abstraction levels. Analogously, in a recent work about autonomous objects [10], mechanisms like REV [87] and RPC [11] are compared to the Echo distributed algorithms <ref> [19] </ref>, to applications like "intelligent e-mail" and Web browsers, and to paradigms for structuring distributed applications, like mobile agents. These 2.3. A MOBILE CODE FRAMEWORK 7 are different concepts and notions that cannot be compared directly.
Reference: [20] <author> D.M. Chess, B. Grosof, C.G. Harrison, D. Levine, C. Paris, and G. Tsudik. </author> <title> Itinerant Agents for Mobile Computing. </title> <type> IEEE Personal Communication, </type> <month> October </month> <year> 1995. </year> <note> Also available as IBM Technical Report. </note>
Reference-contexts: Inter-CE security Inter-CE security issues encompass authentication, integrity, and privacy of the communication between two CEs, an EU and a remote CE, and two remote EUs. 3.6. SECURITY MECHANISMS 21 When interacting, CEs need to authenticate each other in order to be protected from spoofing <ref> [20] </ref>. <p> A different approach has been followed by some researchers that have designed security mechanisms for the protection of roaming components. These same researcher have tried to identify which goals are impossible or very difficult to achieve <ref> [20, 27] </ref>. <p> From this point of view, the application developer must use the same caution required when developing privileged programs that could receive parameters by untrusted principals (e.g., CGI scripts). 7.3 Cryptographic traces As stated in <ref> [20] </ref>, it is impossible to prevent malicious or faulty sites from tampering with EUs. Sites must have access to an EU code and state in order to support its execution. Still, there are means to detect abnormal behaviors or unauthorized modifications of EU components.
Reference: [21] <author> G. Cugola, C. Ghezzi, G.P. Picco, and G. Vigna. </author> <title> Analyzing Mobile Code Languages. </title> <booktitle> In Vitek and Tschudin [101], </booktitle> <pages> pages 93-111. </pages>
Reference-contexts: The reader interested in a more detailed analysis of the linguistic problems posed by the introduction of mobility in programming languages is directed to <ref> [102, 21] </ref>. 3.2 A distributed virtual machine Traditional distributed systems can be accommodated in the virtual machine shown on the left-hand side of Figure 3.1. The lowest layer, just upon the hardware, is constituted by the Core Operating System (COS).
Reference: [22] <author> G. Cugola, E. Di Nitto, and A. Fuggetta. </author> <title> Exploiting an Event-based Infrastructure to Develop Complex Distributed Systems. </title> <booktitle> In Proc. of the 20 th Int. Conf. on Software Engineering, </booktitle> <address> Kyoto, Japan, </address> <year> 1998. </year>
Reference-contexts: Furthermore, building scalable and efficient mechanisms for dispatching events over large-scale networks is still an open research area [79, 80]. Nevertheless, the first proposals of architectures overcoming the problem are beginning to appear in <ref> [6, 108, 22] </ref>. Some of these proposals combine the notion of event with the notion of group.
Reference: [23] <author> F. Douglis and J. Ousterhout. </author> <title> Transparent Process Migration: Design Alternatives and the Sprite Implementation. </title> <journal> Software Practice and Experience, </journal> <volume> 21(8) </volume> <pages> 757-785, </pages> <month> August </month> <year> 1991. </year>
Reference-contexts: Process migration facilities have been introduced at the operating system level to achieve load balancing across network nodes. Therefore, most of these facilities provide transparent process migration, in which the programmer has neither control nor visibility of the migration process <ref> [3, 23, 76] </ref>. Other systems provide some form of control over the migration process. For example, in the Locus system [93] process migration can be triggered either by an external signal or by the invocation of the migrate system call.
Reference: [24] <author> T. Dovera and N. Nespoli. Paradigmi e tecnologie per lo sviluppo di applicazioni basate su codice mobile. </author> <type> Master's thesis, </type> <institution> Politenico di Milano, </institution> <year> 1996. </year>
Reference-contexts: Here we implement the different designs of our application using different technologies belonging to the classes listed above in order to show in greater detail which are the advantages and disadvantages of each solution <ref> [24] </ref>. For the actual implementation we will use Tcl-DP [86], Obliq [16], and Agent Tcl [36]. Tcl-DP is an extension of the Tcl language [69] for distributed programming. Tcl-DP provides support for TCP/IP and RPC programming. It is a non-mobile technology. Obliq is an untyped, object-based, lexically scoped, interpreted language.
Reference: [25] <author> J.R. Falcone. </author> <title> A Programmable Interface Language for Heterogeneous Distributed Systems. </title> <journal> ACM Trans. on Computer Systems, </journal> <volume> 5(4) </volume> <pages> 330-351, </pages> <month> July </month> <year> 1987. </year>
Reference-contexts: All in all, the first approaches to code mobility <ref> [87, 25] </ref> where conceived as extensions of the remote procedure call communication mechanism. Furthermore, a mobile EU can be used to disseminate information among a set of CEs, thus realizing a form of communication.
Reference: [26] <author> W.M. Farmer, J.D. Guttman, and V. Swarup. </author> <title> Security for Mobile Agents: Authentication and State Appraisal. </title> <editor> In Springer, editor, </editor> <booktitle> Proc. of the 4 th European Symp. on Research in Computer Security, volume 1146 of LNCS, </booktitle> <pages> pages 118-130, </pages> <address> Rome, Italy, </address> <month> September </month> <year> 1996. </year> <note> BIBLIOGRAPHY 79 </note>
Reference-contexts: Permit-based mechanisms determine access rights on the basis of a permit that is associated to the EU. Permits can be statically associated to the EU for its whole lifetime or can be determined dynamically. For example the state appraisal mechanism <ref> [26] </ref>, defines an EU permit on the basis of a state appraisal function that is associated with the migrating EU. The function is evaluated before EU execution passing as parameter the EU current state. The function returns the set of access rights that the EU needs in its current state. <p> In <ref> [26] </ref> a protection mechanism against sites trying to tamper with agents state is presented. The mechanism is based on state appraisal functions. These functions express invariants that the agent state must satisfy. This way, some malicious attempt to tamper with the agent state can be detected.
Reference: [27] <author> W.M. Farmer, J.D. Guttman, and V. Swarup. </author> <title> Security for Mobile Agents: Issues and Requirements. </title> <booktitle> In Proc. of the 19 th National Information Systems Security Conf., </booktitle> <pages> pages 591-597, </pages> <address> Baltimore, MD, USA, </address> <month> October </month> <year> 1996. </year>
Reference-contexts: A different approach has been followed by some researchers that have designed security mechanisms for the protection of roaming components. These same researcher have tried to identify which goals are impossible or very difficult to achieve <ref> [20, 27] </ref>.
Reference: [28] <author> G.H. Forman and J. Zahorjan. </author> <title> The Challenges of Mobile Computing. </title> <journal> IEEE Computer, </journal> <volume> 27(4) </volume> <pages> 38-47, </pages> <year> 1994. </year>
Reference-contexts: For instance, while it might be conceivable to apply a global snapshot algorithm to a LAN, its performance is unacceptable in an Internet setting. Wireless connectivity, whose exploitation in computer networks is often referred to as mobile computing, poses even tougher problems <ref> [28, 43] </ref>. Network nodes may move and be connected discontinuously, hence the topology of the network is no longer defined statically. As a consequence, some of the basic tenets of research on distributed systems are undermined, and adaptation of well-known theoretical and technological results is needed. <p> These differences must be taken into account since from the design level. For instance, recent developments in mobile computing evidenced that low-bandwidth and low-reliable communication channels require new design methodologies for applications in a mobile setting <ref> [28, 43] </ref>. In networks where some regions are connected through wireless links while others are connected through conventional links the design becomes complex, in that it must cope with frequent disconnections and aim at avoiding as much as possible the generation of traf 5.2.
Reference: [29] <author> A. Fuggetta, G.P. Picco, and G. Vigna. </author> <title> Understanding Code Mobility. </title> <journal> IEEE Transactions on Software Engineering, </journal> <year> 1998. </year>
Reference-contexts: In addition, the shipment of management components to remote sites could improve both performance and flexibility [5, 33]. A case study focused on the application of our taxonomy to the network management application domain is presented in <ref> [29] </ref>. 5.3.5 Workflow management and cooperation Workflow management applications support the cooperation of persons and tools involved in a development process. The workflow defines which activities must be carried out in order to accomplish a given task as well as how, where, and when these activities involve each party.
Reference: [30] <author> M. Fukuda, L. Bic, M. Dillencourt, and F. Merchant. </author> <title> Intra- Inter-Object Coordination with MESSENGERS. </title> <booktitle> In 1 st Int. Conf. on Coordination Models and Languages (COORDINATION'96), </booktitle> <year> 1996. </year>
Reference-contexts: The set of technologies considered is not exhaustive, and is constrained by space and by the focus of the thesis. However, the reader may actually verify the soundness of the taxonomy by applying it to other MCSs not considered here, like the ones described in <ref> [108, 30, 49] </ref>.
Reference: [31] <author> M. Genesereth and S. Ketchpel. </author> <title> Software Agents. </title> <journal> Comm. of the ACM, </journal> <volume> 37(7), </volume> <month> July </month> <year> 1994. </year>
Reference-contexts: This component is directed by knowledge of the relationships among events, actions, and goals. Moreover, knowledge can be exchanged with other agents, or increased by some inferential activity <ref> [31] </ref>. Although mobility is not the most characterizing aspect of these entities [109] there is a tendency to blend this notion of intelligent agent with the one coming from distributed systems and thus assume implicitly that a mobile agent is also intelligent and vice versa. <p> Autonomous agents are directed by some knowledge of the relationships among events, actions, and goals. Such knowledge can be exchanged with other agents, or increased by some inferential activity <ref> [31] </ref>. Autonomous agents are often required to be mobile, i.e., to be able to move themselves across environments.
Reference: [32] <author> C. Ghezzi and G. Vigna. </author> <title> Mobile Code Paradigms and Technologies: A Case Study. </title> <booktitle> In Rothermel and Popescu-Zeletin [81], </booktitle> <pages> pages 39-49. </pages>
Reference-contexts: On the other hand, the paradigms themselves are independent of a particular technology, and could even be implemented without using mobile technology at all, as described in the case study presented in <ref> [32] </ref>. 4.3.1 Basic concepts Before introducing design paradigms we present some basic concepts that abstract out the entities that constitute a software system, such as files, variable values, executable code, or processes. In particular, we introduce three architectural concepts: components, interactions, and sites. <p> Our initial experience in applying the paradigms <ref> [5, 32] </ref> suggests that these abstractions are effective in the design of distributed applications. Furthermore, they are fairly independent of the particular language or system in which they are eventually implemented. Mobile code paradigms model explicitly the concept of location. <p> If a strongly mobile technology is used, the component can be directly mapped into a migrating EU and mobility is reduced to a single instruction. Therefore the programmer is set free from handling the management of the component's state and can concentrate on the problem to solve <ref> [32] </ref>. A case study that analyzes these relationships in detail can be found in Chapter 6. 44 CHAPTER 4.
Reference: [33] <author> G. Goldszmidt and Y. Yemini. </author> <title> Distributed Management by Delegation. </title> <booktitle> In Proc. of the 15 th Int. Conf. on Distributed Computing, </booktitle> <month> June </month> <year> 1995. </year>
Reference-contexts: Code mobility could be used to design and implement monitoring components that are co-located with the devices being monitored and report events that represent the evolution of the device state. In addition, the shipment of management components to remote sites could improve both performance and flexibility <ref> [5, 33] </ref>. A case study focused on the application of our taxonomy to the network management application domain is presented in [29]. 5.3.5 Workflow management and cooperation Workflow management applications support the cooperation of persons and tools involved in a development process.
Reference: [34] <author> M. Gray. </author> <title> Growth of the World-Wide Web. </title> <address> http:/www.mit.edu/ gray/web-growth.html, </address> <month> December </month> <year> 1993. </year>
Reference-contexts: A CASE STUDY In sections 6.5- 6.6 we exemplify these relationships by implementing several designs of the application using different types of technologies. 6.2 The problem: minimizing network traffic The fast growth of the Internet <ref> [34] </ref> and the success experienced by the World Wide Web infrastructure [7] have changed the way information is accessed and distributed. Centralized information systems have evolved into a global distributed information repository interwoven with cross-references.
Reference: [35] <author> R. Gray, G. Cybenko, D. Kotz, and D. Rus. D'agents: </author> <title> Security in a multiple-language, mobile agent system. </title> <editor> In G. Vigna, editor, </editor> <title> Mobile Agent Security, </title> <publisher> LNCS. Springer, </publisher> <year> 1998. </year>
Reference-contexts: Translation The design of the Agent Tcl language is aimed at supporting different languages. Presently Tcl is the only language supported. As a consequence, no translation mechanisms are needed. Agents are transferred from site to site in source code form. A new version of the language, called D'Agents <ref> [35] </ref> is under development. This implementation will support agents written in Java, Tcl, and Scheme. Communication Two communication mechanisms are provided: messages and meetings. Messages allow EUs to exchange messages composed of strings. The message recipient can be located in the same CE or in a remote CE.
Reference: [36] <author> R.S. Gray. </author> <title> Agent Tcl: A transportable agent system. </title> <booktitle> In Proc. of the CIKM Workshop on Intelligent Information Agents, </booktitle> <address> Baltimore, Md., </address> <month> December </month> <year> 1995. </year>
Reference-contexts: Each technology is first mapped onto the virtual machine introduced in Section 3.2 and then its characteristics are analyzed with respect to mobility, translation and execution, communication, and security. Agent Tcl (http://www.cs.dartmouth.edu/~agent/) Developed at the University of Darthmouth, Agent Tcl <ref> [36] </ref> provides a Tcl interpreter extended with support for strong mobility. In Agent Tcl, an EU (called agent ) is implemented by a Unix process running the language interpreter. Since EUs run in separate address spaces, they can share only resources provided by the underlying operating system, like files. <p> Here we implement the different designs of our application using different technologies belonging to the classes listed above in order to show in greater detail which are the advantages and disadvantages of each solution [24]. For the actual implementation we will use Tcl-DP [86], Obliq [16], and Agent Tcl <ref> [36] </ref>. Tcl-DP is an extension of the Tcl language [69] for distributed programming. Tcl-DP provides support for TCP/IP and RPC programming. It is a non-mobile technology. Obliq is an untyped, object-based, lexically scoped, interpreted language. It supports remote method invocation and remote evaluation of code.
Reference: [37] <author> R.S. Gray. </author> <title> Agent Tcl: A flexible and secure mobile agent system. </title> <booktitle> In Proc. of the 4 th Annual Tcl/Tk Workshop, </booktitle> <pages> pages 9-23, </pages> <address> Monterey, </address> <institution> Cal., </institution> <month> July </month> <year> 1996. </year>
Reference-contexts: When the packed executing unit reaches its destination, it is unpacked, its state is restored and its execution is restarted from the command following the go. From this point of view SALTA is similar to Agent-Tcl <ref> [37] </ref>. 7.5 A Pulp Fiction Agent In order to give a precise idea of the operations involved in agents execution tracing and verification, we describe a simple electronic commerce application. 7.6.
Reference: [38] <author> R.S. Gray, D. Kotz, S. Nog, D. Rus, and G. Cybenko. </author> <title> Mobile agents for mobile computing. </title> <booktitle> In Proc. of the 2 nd Aizu Int. Symp. on Parallel Algorithms/Architectures Synthesis, Fukushima, </booktitle> <address> Japan, </address> <month> March </month> <year> 1997. </year>
Reference-contexts: Examples of approaches exploiting code mobility can be found in [58] and [60]. A particular class of advanced telecommunications services are those supporting mobile users. In this case, as discussed earlier, autonomous components can provide support for disconnected operations, as discussed in <ref> [38] </ref>. 5.3.4 Remote device control and configuration Remote device control applications are aimed at configuring a network of devices and monitoring their status. This domain encompasses several other application domains, e.g., industrial process control and network management.
Reference: [39] <author> C.G. Harrison, D.M. Chess, and A. Kershenbaum. </author> <title> Mobile Agents: Are they a good idea? In Vitek and Tschudin [101], </title> <type> pages 25-47. </type> <note> Also available as IBM Technical Report. </note>
Reference-contexts: First of all, the fundamental distinction among implementation technologies, specific applications, and paradigms used to design these applications is not always made clear. In an early and yet valuable assessment of code mobility <ref> [39] </ref> the authors analyze and compare issues that belong to different abstraction levels. <p> In [50], Knabe lists the essential characteristics of a mobile code language. They include support for manipulating, transmitting, receiving, and executing "code-containing objects". However, there is no discussion about how to manage the state of mobile components. Other contributions <ref> [73, 39] </ref> consider only the support for mobility of both code and state, without mentioning weaker forms of code mobility involving code migration alone|as we discuss later on. As another example, there is no agreement on the suitable type system for mobile code languages.
Reference: [40] <author> J. Hogg. </author> <title> Island: Aliasing Protection in Object-Oriented Languages. </title> <booktitle> In Proc. of OOPSLA '91, </booktitle> <year> 1991. </year>
Reference-contexts: Mobility Mobility is supported by a mechanism for the asynchronous shipping of stand-alone code, which is executed immediately. The code and data to be sent are determined automatically upon migration using the notion of island <ref> [40] </ref>. An island is the transitive closure over all the objects referenced by the main agent object. Islands, which are generated automatically starting from the main agent object, cannot have object references to the outside; inter-agent references are symbolic and become void upon migration.
Reference: [41] <author> F. Hohl. </author> <title> An approach to Solve the Problem of Malicious Hosts in Mobile Agent Systems, </title> <year> 1997. </year>
Reference-contexts: A different approach is followed by the code scrambling mechanism, in which the EU code is rearranged before EU moves to a CE in order to make almost impossible reverse-engineering <ref> [41, 42] </ref> while maintaining the EU's original behavior. A simpler solution consists in partial encryption of the EU contents. Using this mechanism, an EU could protect data that has to be used in a particular CE by encrypting it with the CE's public-key.
Reference: [42] <author> F. Hohl. </author> <title> Time Limited Blackbox Security: Protecting Mobile Agents From Malicious Hosts. </title> <editor> In G. Vigna, editor, </editor> <title> Mobile Agents and Security, </title> <publisher> LNCS. Springer, </publisher> <year> 1998. </year> <note> 80 BIBLIOGRAPHY </note>
Reference-contexts: A different approach is followed by the code scrambling mechanism, in which the EU code is rearranged before EU moves to a CE in order to make almost impossible reverse-engineering <ref> [41, 42] </ref> while maintaining the EU's original behavior. A simpler solution consists in partial encryption of the EU contents. Using this mechanism, an EU could protect data that has to be used in a particular CE by encrypting it with the CE's public-key.
Reference: [43] <author> T. Imielinsky and B.R. Badrinath. </author> <title> Wireless Computing: Challenges in Data Management. </title> <journal> Comm. of the ACM, </journal> <volume> 37(10) </volume> <pages> 18-28, </pages> <year> 1994. </year>
Reference-contexts: For instance, while it might be conceivable to apply a global snapshot algorithm to a LAN, its performance is unacceptable in an Internet setting. Wireless connectivity, whose exploitation in computer networks is often referred to as mobile computing, poses even tougher problems <ref> [28, 43] </ref>. Network nodes may move and be connected discontinuously, hence the topology of the network is no longer defined statically. As a consequence, some of the basic tenets of research on distributed systems are undermined, and adaptation of well-known theoretical and technological results is needed. <p> These differences must be taken into account since from the design level. For instance, recent developments in mobile computing evidenced that low-bandwidth and low-reliable communication channels require new design methodologies for applications in a mobile setting <ref> [28, 43] </ref>. In networks where some regions are connected through wireless links while others are connected through conventional links the design becomes complex, in that it must cope with frequent disconnections and aim at avoiding as much as possible the generation of traf 5.2.
Reference: [44] <author> Adobe Systems Incorporated. </author> <title> PostScript Language Reference Manual. </title> <publisher> Addison-Wesley, </publisher> <year> 1985. </year>
Reference-contexts: In the recent past, several mechanisms and facilities have been designed and implemented in order to move code among the nodes of a network. Examples are remote batch job submission [12] and the use of PostScript <ref> [44] </ref> to control printers. A more structured approach has been followed in the research work on distributed operating systems. In this context, the main problem is to support the migration of active processes and objects (together with their state and the associated code) at the operating system level.
Reference: [45] <author> ITU-T. </author> <title> Information Technology Open Systems Interconnection The Directory: Authentication Framework. </title> <type> ITU-T Recommendation X.509, </type> <month> November </month> <year> 1993. </year>
Reference-contexts: based simply on identifiers (network addresses or names) that provide little or no security or may use some stronger mechanism based on cryptography [84], namely, secret-key authentication systems (a la Kerberos [88]), or authentication systems based on public-key cryptography and digital signatures, like the ones conforming to the X.509 standard <ref> [45] </ref>. In addition, authentication needs to be accompanied by mechanisms that provide for integrity and privacy of the exchanged data, in particular of code or EUs that are moved from CE to CE. <p> The public key of a principal A is denoted by A p , while A s is used for the corresponding secret key. The principals are users of a public key infrastructure <ref> [45] </ref> that guarantees the association of a principal with the corresponding public key. We assume that, at any moment, any principal can retrieve the public key of any other principal and verify its integrity.
Reference: [46] <author> D. Johansen, R. van Renesse, and F.B. Schneider. </author> <title> An Introduction to the TACOMA Distributed System Version 1.0. </title> <type> Technical Report 95-23, </type> <institution> Dept. of Computer Science, Univ. of Tromst and Cornell Univ., Tromst, Norway, </institution> <month> June </month> <year> 1995. </year>
Reference-contexts: These 2.3. A MOBILE CODE FRAMEWORK 7 are different concepts and notions that cannot be compared directly. It is almost like comparing the emacs editor with the fork UNIX system call and the client-server design paradigm. There is also confusion on terms. For instance, several systems <ref> [46, 72] </ref> claim to be able to move the state of a component together with its code, based on the fact that they allow the programmer to pack some portion of the data space of an executing component before the component's code is sent to a remote destination. <p> This definition has actually different interpretations. For example, while in Telescript [106] an agent is represented by a thread that can migrate among different nodes carrying its execution state, in TACOMA <ref> [46] </ref> agents are just code fragments associated with initialization data that can be shipped to a remote host, without the ability to migrate again while in execution. <p> Differently from other approaches, events are dispatched only locally, in order to inform a thread of resource changes or other site-related information, and are not conceived to be used as an inter-CE communication mechanism. Security No security features are provided. TACOMA (http://www.cs.uit.no/DOS/Tacoma/) In TACOMA <ref> [46] </ref> (Tromst And COrnell Mobile Agents), the Tcl language is extended to include primitives that support weak mobility. Executing units, called agents, are implemented as Unix processes running the Tcl interpreter.
Reference: [47] <author> E. Jul, H. Levy, N. Hutchinson, and A. Black. </author> <title> Fine-grained Mobility in the Emerald System. </title> <journal> ACM Trans. on Computer Systems, </journal> <volume> 6(2) </volume> <pages> 109-133, </pages> <month> February </month> <year> 1988. </year>
Reference-contexts: Object migration makes it possible to move objects among address spaces, implementing a finer grained mobility with respect to systems providing migration at the process level. For example, the Emerald system <ref> [47] </ref> provides object migration at any level of granularity ranging from small, atomic data to complex objects. Emerald does not provide complete transparency since the programmer can determine objects locations and may request explicitly the migration of an object to a particular node.
Reference: [48] <author> G. Karjoth, D. Lange, and M. Oshima. </author> <title> A Security Model for Aglets. </title> <journal> IEEE Internet Computing, </journal> <volume> 1(4) </volume> <pages> 68-77, </pages> <month> July-August </month> <year> 1997. </year>
Reference-contexts: Security In the current aglet implementation, Inter-CE security is achieved by a simple identifier-based authentication mechanism. This mechanism allows a CE manager to select the hosts that can submit aglets. Extensions for achieving integrity adn privacy in inter-CE interactions are under development. Aglets are protected <ref> [48] </ref> from each other by using an internal security mechanism. Operations invoked on an aglet are dispatched to a proxy object that acts as a wrapper for the actual aglet, that can take actions based on the information associated with the operation request before executing the corresponding operation.
Reference: [49] <author> J. Kiniry and D. Zimmerman. </author> <title> A Hands-On Look at Java Mobile Agents. </title> <journal> IEEE Internet Computing, </journal> <volume> 1(4) </volume> <pages> 21-30, </pages> <year> 1997. </year>
Reference-contexts: The set of technologies considered is not exhaustive, and is constrained by space and by the focus of the thesis. However, the reader may actually verify the soundness of the taxonomy by applying it to other MCSs not considered here, like the ones described in <ref> [108, 30, 49] </ref>.
Reference: [50] <author> F.C. Knabe. </author> <title> Language Support for Mobile Agents. </title> <type> PhD thesis, </type> <institution> Carnegie Mellon Univ., </institution> <address> Pittsburgh, PA, USA, </address> <month> December </month> <year> 1995. </year> <note> Also available as Carnegie Mellon School of Computer Science Technical Report CMU-CS-95-223 and European Computer Industry Centre Technical Report ECRC-95-36. </note>
Reference-contexts: This is actually creating confusion about between the layer providing mobility and the one exploiting mobility. Finally, there is no definition or agreement about the distinguishing characteristics of languages supporting code mobility. In <ref> [50] </ref>, Knabe lists the essential characteristics of a mobile code language. They include support for manipulating, transmitting, receiving, and executing "code-containing objects". However, there is no discussion about how to manage the state of mobile components. <p> Facile (http://www.ecrc.de/research/projects/facile/) Developed at ECRC in Munich, Facile [94] is a functional language that extends the Standard ML language with primitives for distribution, concurrency and communication. The language has been extended further in <ref> [50] </ref> to support weak mobility. Executing units are implemented as threads that run in Facile CEs, called nodes. Mobility and communication In Facile, mobility is achieved exploiting the channel communication mechanism provided by the language.
Reference: [51] <author> P. Knudsen. </author> <title> Comparing two Distributed Computing Paradigms a Performance Case Study. </title> <type> Master's thesis, </type> <institution> Univ. of Tromst, </institution> <year> 1995. </year>
Reference-contexts: Code mobility could improve efficiency by migrating the code that performs the search process close to the (possibly huge) information base to be analyzed <ref> [51] </ref>. This type of application has been often considered "the killer application" motivating a design based on the MA paradigm.
Reference: [52] <author> M. Koster. </author> <title> Guidelines for Robot Writers. </title> <note> http://info.webcrawler.com/mak/projects/robots/guidelines.html, 1993. </note>
Reference-contexts: In some cases, this has lead to exhaustion of the available bandwidth in subnetworks hosting WWW servers frequently accessed by robots. Even though protocols to limit the scope of information indexing have been designed [53] and some guidelines for traffic-wise development of robots have been developed <ref> [52] </ref>, the client-server approach to information retrieval shows its limits, at least as far as network traffic is concerned. The mobile code approach has been proposed as a way to reduce the network traffic generated by information retrieval over a set of information servers.
Reference: [53] <author> M. Koster. </author> <title> A Standard for Robot Exclusion. </title> <note> http://info.webcrawler.com/mak/projects/robots/norobots.html, 1994. </note>
Reference-contexts: In some cases, this has lead to exhaustion of the available bandwidth in subnetworks hosting WWW servers frequently accessed by robots. Even though protocols to limit the scope of information indexing have been designed <ref> [53] </ref> and some guidelines for traffic-wise development of robots have been developed [52], the client-server approach to information retrieval shows its limits, at least as far as network traffic is concerned.
Reference: [54] <author> M. Koster. </author> <title> Robots in the Web: threat or treat? ConneXions, </title> <type> 9(4), </type> <month> April </month> <year> 1995. </year>
Reference-contexts: A notable example is represented by the retrieval of information concerning a particular subject [14]. Several systems, called robots, spiders, wanderers, worms, or internet agents, have been implemented to automate the process of finding and indexing the information provided by the World Wide Web infrastructure <ref> [54] </ref>. These systems contact WWW servers, retrieve their pages and analyze them looking for keywords and references to other locations. This process is repeated recursively. This way, robots build an indexed map of the available information.
Reference: [55] <author> D.B. Lange. </author> <title> Java Aglets Application Programming Interface (J-AAPI). </title> <institution> IBM Corp. White Paper, </institution> <month> February </month> <year> 1997. </year>
Reference-contexts: Protection of the CE from EUs is delegated to the underlying operating system mechanisms, and therefore EUs may access any resource that is accessible to the principal that is responsible for the execution of the run-time support. Aglets (http://www.trl.ibm.co.jp/aglets) The Java Aglets API (J-AAPI) <ref> [55] </ref>, developed by IBM Tokyo Research Laboratory in Japan, extends Java with support for weak mobility. Aglets [56], the EUs, are threads in a Java interpreter which constitutes the CE. The API provides the notion of context as an abstraction of the CE.
Reference: [56] <author> D.B. Lange and D.T. Chang. </author> <title> IBM Aglets Workbench|Programming Mobile Agents in Java. </title> <institution> IBM Corp. White Paper, </institution> <month> September </month> <year> 1996. </year>
Reference-contexts: Aglets (http://www.trl.ibm.co.jp/aglets) The Java Aglets API (J-AAPI) [55], developed by IBM Tokyo Research Laboratory in Japan, extends Java with support for weak mobility. Aglets <ref> [56] </ref>, the EUs, are threads in a Java interpreter which constitutes the CE. The API provides the notion of context as an abstraction of the CE.
Reference: [57] <author> R. Lea, C. Jacquemont, and E. Pillevesse. </author> <title> COOL: System Support for Distributed Object-Oriented Programming. </title> <journal> Comm. of the ACM, </journal> <volume> 36(9) </volume> <pages> 37-46, </pages> <month> November </month> <year> 1993. </year> <note> BIBLIOGRAPHY 81 </note>
Reference-contexts: Emerald does not provide complete transparency since the programmer can determine objects locations and may request explicitly the migration of an object to a particular node. An example of system providing transparent migration is the COOL <ref> [57] </ref> object-oriented subsystem. COOL is built on top of the Chorus operating system [82] and is able to move objects among address spaces without user intervention or knowledge. 5 6 CHAPTER 2.
Reference: [58] <author> A. Limongiello, R. Melen, M. Roccuzzo, A. Scalisi, V. Trecordi, and J. Wo-jtowicz. ORCHESTRA: </author> <title> An Experimental Agent-based Service Control Architecture For Broadband Multimedia Networks. GLOBAL Internet '96, </title> <month> November </month> <year> 1996. </year>
Reference-contexts: For example, the application components managing the setup, signalling, and presentation services for a 5.3. APPLICATION DOMAINS FOR MOBILE CODE 49 videoconference could be dispatched to the users by a service broker. Examples of approaches exploiting code mobility can be found in <ref> [58] </ref> and [60]. A particular class of advanced telecommunications services are those supporting mobile users.
Reference: [59] <author> P. Maes. </author> <title> Agents that Reduce Work and Information Overload. </title> <journal> Comm. of the ACM, </journal> <volume> 37(7), </volume> <month> July </month> <year> 1994. </year>
Reference-contexts: On the other hand, in the artificial intelligence community the term "agent" denotes a software 1 component that is able to achieve a goal by performing actions and reacting to events in a dynamic environment <ref> [59] </ref>. This component is directed by knowledge of the relationships among events, actions, and goals. Moreover, knowledge can be exchanged with other agents, or increased by some inferential activity [31]. <p> Other applications of code mobility to electronic commerce can be found in [61, 100]. 5.3.8 Autonomous agents Autonomous agents are applications that are able to achieve a goal, reacting to events in a dynamic environment and performing actions on the environment <ref> [59] </ref>. Autonomous agents are directed by some knowledge of the relationships among events, actions, and goals. Such knowledge can be exchanged with other agents, or increased by some inferential activity [31]. Autonomous agents are often required to be mobile, i.e., to be able to move themselves across environments.
Reference: [60] <author> T. Magedanz, K. Rothermel, and S. Krause. </author> <title> Intelligent Agents: An Emerging Technology for Next Generation Telecommunications? In IN-FOCOM'96, </title> <address> San Francisco, CA, USA, </address> <month> March </month> <year> 1996. </year>
Reference-contexts: For example, the application components managing the setup, signalling, and presentation services for a 5.3. APPLICATION DOMAINS FOR MOBILE CODE 49 videoconference could be dispatched to the users by a service broker. Examples of approaches exploiting code mobility can be found in [58] and <ref> [60] </ref>. A particular class of advanced telecommunications services are those supporting mobile users.
Reference: [61] <author> M. Merz and W. Lamersdorf. </author> <title> Agents, Services, and Electronic Markets: How do they Integrate? In Proc. </title> <booktitle> of the Int'l Conf. on Distributed Platforms. </booktitle> <address> IFIP/IEEE, </address> <year> 1996. </year>
Reference-contexts: This problems make mobile code appealing for this kind of applications. Actually, Telescript [105] was conceived expressly to support electronic commerce. For this reason, the term "mobile agent" is often related with electronic commerce. Other applications of code mobility to electronic commerce can be found in <ref> [61, 100] </ref>. 5.3.8 Autonomous agents Autonomous agents are applications that are able to achieve a goal, reacting to events in a dynamic environment and performing actions on the environment [59]. Autonomous agents are directed by some knowledge of the relationships among events, actions, and goals.
Reference: [62] <author> Sun Microsystems. </author> <title> The Java Language: An Overview. </title> <type> Technical report, </type> <institution> Sun Microsystems, </institution> <year> 1994. </year>
Reference-contexts: Therefore, the language implements a translation after coding mechanism. In addition Facile provides a remote just-in-time mechanism that support dynamic compilation of source code into platform-native format. Security No dedicated security mechanisms are provided at the time of writing. Java (http://java.sun.com/) Developed by Sun Microsystems, Java <ref> [62] </ref> has triggered most of the attention and expectations on code mobility. The original goal of the language designers was to provide a portable, clean, easy-to-learn, and general-purpose object-oriented language, which has been subsequently re-targeted by the growth of Internet.
Reference: [63] <editor> M. Muhlauser, editor. </editor> <booktitle> Special Issues in Object-Oriented Programming: Workshop Reader of the 10 th European Conf. on Object-Oriented Programming ECOOP'96. </booktitle> <address> dpunkt, </address> <month> July </month> <year> 1996. </year>
Reference: [64] <author> G.C. Necula. </author> <title> Proof-Carrying Code. </title> <booktitle> In Proc. of the 24 th ACM Symp. on Principles of Programming Languages, </booktitle> <address> Paris, France, </address> <month> January </month> <year> 1997. </year>
Reference-contexts: Static access control mechanisms aim at determining, before EU execution, if, given the EU code and state, execution will respect the access control policy enforced by the system. If the verification succeeds, no other check will be performed during EU execution. For example the proof-carrying code <ref> [64] </ref> mechanism associates code fragments with a formal proof of their correctness that is verified before code execution. A different approach is followed by code verifiers that use theorem proving techniques to determine if the UE's code preserves some security invariants (e.g. address space containment).
Reference: [65] <author> M. Nuttall. </author> <title> Survey of systems providing process or object migration. </title> <type> Technical Report Doc 94/10, </type> <institution> Dept. of Computing, Imperial College, </institution> <month> May </month> <year> 1994. </year>
Reference-contexts: In this context, the main problem is to support the migration of active processes and objects (together with their state and the associated code) at the operating system level. A survey of systems providing process or object migration can be found in <ref> [65] </ref>. Process migration concerns the transfer of an operating system process from the machine where it is running to a different one.
Reference: [66] <institution> Object Management Group. CORBA: Architecture and Specification, </institution> <month> August </month> <year> 1995. </year>
Reference-contexts: There have been many attempts to provide effective answers, attacking different facets of the problem at different layers of abstraction. Most of the approaches, however, try to adapt well-established models and technology within the new setting, and usually take for granted the traditional client-server architecture. For example, CORBA <ref> [66] </ref> integrates remote procedure calls (RPCs) with the object-oriented paradigm. It attempts to combine the benefits of the latter in terms of modularity and reuse with the well-established communication mechanism of the former. <p> When a service is invoked, there is no clue about the node of the network that will actually provide the service, and even about the presence of a network at all. As an example, CORBA <ref> [66] </ref> services can be regarded as TDS services since a CORBA programmer is usually unaware of the network topology and always interacts with a single well-known object broker. At least in principle, the TDS is built upon the services provided by the underlying NOS.
Reference: [67] <author> National Bureau of Standards. </author> <title> Data Encryption Standard. </title> <type> NBS FIPS PUB 46, </type> <year> 1977. </year>
Reference-contexts: Integrity mechanisms ensure that transmitted data is not modified, either by malicious intent or by errors in the transmission process, using cryptographic checksums (e.g. MD5 [77]). Privacy mechanisms exploit encryption (e.g. DES <ref> [67] </ref>) to ensure that third parties not involved in inter-CE communication cannot access the information transmitted over the network.
Reference: [68] <author> J. Ordille. </author> <title> When agents roam, </title> <type> who can you trust? Technical report, </type> <institution> Bell Labs, Computing Science Research Center, </institution> <year> 1996. </year>
Reference-contexts: For example, if the read (x) instruction gets the integer 3 from the terminal, the associated signature will be x := 3. The signature is empty for white statements. In the following sections we will address problems of increasing complexity. In particular, we will follow the distinction made by <ref> [68] </ref>, firstly tackling the problem of protecting remote code execution, and then analyzing boomerang agents and multi-hop agents. 7.3.1 Remote code execution Suppose that user A wants to execute code C on site B.
Reference: [69] <author> J. Ousterhout. </author> <title> Tcl and the Tk Toolkit. </title> <publisher> Addison-Wesley, </publisher> <year> 1995. </year>
Reference-contexts: Therefore, access to objects and files residing at the engine CE must be granted explicitly by the remote engine passing a reference to a local component when invoking the procedure. Safe-Tcl (http://sunscript.sun.com) Initially developed by the authors of the Internet MIME standard, Safe-Tcl [13] is an extension of Tcl <ref> [69] </ref> conceived to support active e-mail. Mobility In active e-mail, messages may include code to be executed when the recipient receives or reads the message. Hence, in Safe-Tcl there are no mobility or communication mechanisms at the language level|they must be achieved using some external support, like e-mail. <p> For the actual implementation we will use Tcl-DP [86], Obliq [16], and Agent Tcl [36]. Tcl-DP is an extension of the Tcl language <ref> [69] </ref> for distributed programming. Tcl-DP provides support for TCP/IP and RPC programming. It is a non-mobile technology. Obliq is an untyped, object-based, lexically scoped, interpreted language. It supports remote method invocation and remote evaluation of code. Therefore it is a weakly mobile technology. <p> The available Tcl <ref> [69] </ref> com mand set is showed in Table 7.1. The Safe-Tcl language has been restricted further, and some new instructions have been added: request, service, reply and go. 6 "Salta" is also an italian verb meaning "jump". 7.4.
Reference: [70] <author> J. Ousterhout. </author> <title> Scripting: Higher Level Programming for the 21 st Century. </title> <type> Technical report, </type> <institution> Sun Microsystems, </institution> <year> 1997. </year>
Reference-contexts: As another example, there is no agreement on the suitable type system for mobile code languages. For example, while Knabe suggests that strong typing is a desirable property for mobile code languages, Ousterhout <ref> [70] </ref> suggests that untyped scripting languages are the best choice for this kind of systems.
Reference: [71] <author> J. Ousterhout, J. Levy, and B. Welch. </author> <title> The Safe-Tcl Security Model. </title> <type> Technical report, </type> <institution> Sun Microsystems, </institution> <month> November </month> <year> 1996. </year>
Reference-contexts: Presently, most of the fundamental features of Safe-Tcl have been included in the latest release of Tcl/Tk, and a plug-in for the Netscape browser has been developed, allowing Safe-Tcl scripts to be included in HTML pages <ref> [71] </ref>, much like Java applets 3.7. A SURVEY OF MOBILE CODE SYSTEMS 31 Sumatra (http://www.cs.umd.edu/users/saltz/) Sumatra [2], developed at University of Maryland, is a Java extension designed expressly to support the implementation of resource-aware mobile programs, i.e. programs which are able to adapt to resource changes by exploiting mobility. <p> partial state S i should produce a hash value equal to the one contained in the corresponding receipt message, otherwise the site at step i cheated. 7.4 The SALTA language The SALTA language (Secure Agent Language with Tracing of Actions 6 ) is a modified version of the Safe-Tcl language <ref> [13, 71] </ref>. The available Tcl [69] com mand set is showed in Table 7.1. The Safe-Tcl language has been restricted further, and some new instructions have been added: request, service, reply and go. 6 "Salta" is also an italian verb meaning "jump". 7.4.
Reference: [72] <author> A.S. Park and S. Leuker. </author> <title> A Multi-Agent Architecture Supporting Services Access. </title> <booktitle> In Rothermel and Popescu-Zeletin [81], </booktitle> <pages> pages 62-73. </pages>
Reference-contexts: These 2.3. A MOBILE CODE FRAMEWORK 7 are different concepts and notions that cannot be compared directly. It is almost like comparing the emacs editor with the fork UNIX system call and the client-server design paradigm. There is also confusion on terms. For instance, several systems <ref> [46, 72] </ref> claim to be able to move the state of a component together with its code, based on the fact that they allow the programmer to pack some portion of the data space of an executing component before the component's code is sent to a remote destination.
Reference: [73] <author> H. Peine and T. Stolpmann. </author> <title> The Architecture of the Ara Platform for Mobile Agents. </title> <booktitle> In Rothermel and Popescu-Zeletin [81], </booktitle> <pages> pages 50-61. </pages>
Reference-contexts: In [50], Knabe lists the essential characteristics of a mobile code language. They include support for manipulating, transmitting, receiving, and executing "code-containing objects". However, there is no discussion about how to manage the state of mobile components. Other contributions <ref> [73, 39] </ref> consider only the support for mobility of both code and state, without mentioning weaker forms of code mobility involving code migration alone|as we discuss later on. As another example, there is no agreement on the suitable type system for mobile code languages. <p> The CE can be configured to grant particular capabilities (access to the file system, access to the windowing system, and access to network) to aglets on the basis of their source. The mechanism is therefore static and authority-based. Ara (http://www.uni-kl.de/AG-Nehmer/Ara/) Developed at University of Kaiserslautern, Ara <ref> [73] </ref> is a multi-language MCS that supports strong mobility. Ara EUs, called agents, are managed by a language-independent system core plus interpreters for the languages supported| at the time of writing C, C++, and Tcl. The core and the interpreters constitute 26 CHAPTER 3.
Reference: [74] <author> C. Perkins. </author> <title> IP Mobility Support. </title> <institution> IETF draft-ietf-mobileip-16, </institution> <month> April </month> <year> 1996. </year> <note> 82 BIBLIOGRAPHY </note>
Reference-contexts: Similar problems arise in the context of mobile computing, where packet routing must be changed dynamically according to the movement of the physical host, which in addition needs to be aware of the facilities available at a given access point <ref> [74] </ref>. Development of communication mechanisms in MCSs is still in its early phase. This is mainly because until now research has been focused on mobility mechanisms. After the initial successes in this effort, researchers are now investigating more complex forms of interactions among EUs. 18 CHAPTER 3.
Reference: [75] <author> G.P. Picco, G.-C. Roman, and P.J. McCann. </author> <title> Expressing Code Mobility in Mobile UNITY. </title> <editor> In M. Jazayeri and H. Schauer, editors, </editor> <booktitle> Proc. of the 6 th European Software Engineering Conf. held jointly with the 5 th ACM SIG-SOFT Symp. on the Foundations of Software Engineering (ESEC/FSE '97), volume 1301 of LNCS, </booktitle> <pages> pages 500-518, </pages> <address> Zurich, Switzerland, Septem-ber 1997. </address> <publisher> Springer. </publisher>
Reference-contexts: A case study centered around a formalization of these paradigms using the UNITY notation is also provided in <ref> [75] </ref>. 4.3.
Reference: [76] <author> M.L. Powell and B.P. Miller. </author> <title> Process migration in DEMOS/MP. </title> <booktitle> In Proc. of the 6 th Symp. on Operating System Principles, </booktitle> <month> November </month> <year> 1983. </year>
Reference-contexts: Process migration facilities have been introduced at the operating system level to achieve load balancing across network nodes. Therefore, most of these facilities provide transparent process migration, in which the programmer has neither control nor visibility of the migration process <ref> [3, 23, 76] </ref>. Other systems provide some form of control over the migration process. For example, in the Locus system [93] process migration can be triggered either by an external signal or by the invocation of the migrate system call.
Reference: [77] <author> R.L. Rivest. </author> <title> The MD5 Message Digest Algorithm. </title> <type> RFC 1321, </type> <month> April </month> <year> 1992. </year>
Reference-contexts: Integrity mechanisms ensure that transmitted data is not modified, either by malicious intent or by errors in the transmission process, using cryptographic checksums (e.g. MD5 <ref> [77] </ref>). Privacy mechanisms exploit encryption (e.g. DES [67]) to ensure that third parties not involved in inter-CE communication cannot access the information transmitted over the network.
Reference: [78] <author> R.L. Rivest, A. Shamir, and L. Adleman. </author> <title> A Method for Obtaining Digital Signatures and Public-Key Cryptosystems. </title> <journal> Comm. of the ACM, </journal> <volume> 21(2) </volume> <pages> 120-126, </pages> <month> February </month> <year> 1978. </year>
Reference-contexts: The proposed protocol assumes that all the involved principals, namely users and site owners, own a public and a secret key that can be used for encryption and digital signatures <ref> [78] </ref>. The public key of a principal A is denoted by A p , while A s is used for the corresponding secret key. The principals are users of a public key infrastructure [45] that guarantees the association of a principal with the corresponding public key.
Reference: [79] <author> D. Rosenblum and A. Wolf. </author> <title> A Design Framework for Internet-Scale Event Observation and Notification. </title> <booktitle> In Proc. of the 6 th European Software Engineering Conference, </booktitle> <pages> pages pp. 344-360, </pages> <address> Zurich, Switzerland, </address> <year> 1997. </year>
Reference-contexts: In fact, event dispatching suffers of the same problem highlighted for message passing in presence of mobile EUs. Furthermore, building scalable and efficient mechanisms for dispatching events over large-scale networks is still an open research area <ref> [79, 80] </ref>. Nevertheless, the first proposals of architectures overcoming the problem are beginning to appear in [6, 108, 22]. Some of these proposals combine the notion of event with the notion of group.
Reference: [80] <author> D. Rosenblum, A. Wolf, and A. Carzaniga. </author> <title> Critical Considerations and Designs for Internet-Scale, Event-Based Compositional Architectures. </title> <booktitle> In Proceedings of the 1998 Workshop on Compositional Software Architectures, </booktitle> <address> Monterey, CA, </address> <month> jan </month> <year> 1998. </year>
Reference-contexts: In fact, event dispatching suffers of the same problem highlighted for message passing in presence of mobile EUs. Furthermore, building scalable and efficient mechanisms for dispatching events over large-scale networks is still an open research area <ref> [79, 80] </ref>. Nevertheless, the first proposals of architectures overcoming the problem are beginning to appear in [6, 108, 22]. Some of these proposals combine the notion of event with the notion of group.
Reference: [81] <editor> K. Rothermel and R. Popescu-Zeletin, editors. </editor> <booktitle> Mobile Agents: 1 st International Workshop MA '97, volume 1219 of LNCS. </booktitle> <publisher> Springer, </publisher> <month> April </month> <year> 1997. </year>
Reference: [82] <author> M. Rozier, V. Abrossimov, F. Armand, I. Boule, M. Gien, M. Guillemont, F. Herrmann, C. Kaiser, P. Leonard, S. Langlois, and W. Neuhauser. </author> <title> Chorus Distributed Operating Systems. </title> <journal> Computing Systems, </journal> <volume> 1 </volume> <pages> 305-379, </pages> <month> October </month> <year> 1988. </year>
Reference-contexts: Emerald does not provide complete transparency since the programmer can determine objects locations and may request explicitly the migration of an object to a particular node. An example of system providing transparent migration is the COOL [57] object-oriented subsystem. COOL is built on top of the Chorus operating system <ref> [82] </ref> and is able to move objects among address spaces without user intervention or knowledge. 5 6 CHAPTER 2.
Reference: [83] <author> T. Sander and C. Tschudin. </author> <title> Protecting Mobile Agents Against Malicious Host. </title> <editor> In G. Vigna, editor, </editor> <title> Mobile Agents and Security, </title> <publisher> LNCS. Springer, </publisher> <year> 1998. </year>
Reference-contexts: This way data will be accessible only when the EU reaches the intended execution environment. Other mechanisms that exploit execution of cryptographed functions are being studied <ref> [83] </ref>. Detection mechanisms aim at detecting, after EU execution, if some illegal modification of its code and state occurred in the EU lifetime. A first mechanism is based on the state appraisal functions described earlier.
Reference: [84] <author> B. Schneier. </author> <title> Applied Cryptography Protocols, Algorithms, and Source Code in C. </title> <publisher> John Wiley & Sons, Inc., </publisher> <address> 2 nd edition, </address> <year> 1996. </year>
Reference-contexts: SECURITY MECHANISMS 21 When interacting, CEs need to authenticate each other in order to be protected from spoofing [20]. Authentication mechanisms can be based simply on identifiers (network addresses or names) that provide little or no security or may use some stronger mechanism based on cryptography <ref> [84] </ref>, namely, secret-key authentication systems (a la Kerberos [88]), or authentication systems based on public-key cryptography and digital signatures, like the ones conforming to the X.509 standard [45]. <p> The hash value obtained by application of the function H to the message m is denoted by H (m). Several examples of public key cryptosystems 2 and one-way hash functions can be found in <ref> [84] </ref>. A moving EU is composed by some code C and some state S i that has been determined, at some specified point i, by code execution.
Reference: [85] <author> M. Shaw and D. Garlan. </author> <title> Software Architecture: Perspective on an Emerging Discipline. </title> <publisher> Prentice Hall, </publisher> <year> 1996. </year>
Reference-contexts: This is particularly evident in a critical phase of software development: software design. 4.2 Software architectures and architectural styles The goal of design is the creation of a software architecture, which can be defined as the decomposition of a software system in terms of software components and interactions among them <ref> [85] </ref>. Software architectures with similar characteristics can be represented by architectural styles [1] or design paradigms, which define architectural abstractions and reference structures that may be instantiated into actual software architectures.
Reference: [86] <author> B. Smith, S. Yen, and S. Tu. </author> <title> Introduction to Tcl-DP. </title>
Reference-contexts: Here we implement the different designs of our application using different technologies belonging to the classes listed above in order to show in greater detail which are the advantages and disadvantages of each solution [24]. For the actual implementation we will use Tcl-DP <ref> [86] </ref>, Obliq [16], and Agent Tcl [36]. Tcl-DP is an extension of the Tcl language [69] for distributed programming. Tcl-DP provides support for TCP/IP and RPC programming. It is a non-mobile technology. Obliq is an untyped, object-based, lexically scoped, interpreted language.
Reference: [87] <author> J.W. Stamos and D.K. Gifford. </author> <title> Implementing Remote Evaluation. </title> <journal> IEEE Trans. on Software Engineering, </journal> <volume> 16(7) </volume> <pages> 710-722, </pages> <month> July </month> <year> 1990. </year>
Reference-contexts: In an early and yet valuable assessment of code mobility [39] the authors analyze and compare issues that belong to different abstraction levels. Analogously, in a recent work about autonomous objects [10], mechanisms like REV <ref> [87] </ref> and RPC [11] are compared to the Echo distributed algorithms [19], to applications like "intelligent e-mail" and Web browsers, and to paradigms for structuring distributed applications, like mobile agents. These 2.3. A MOBILE CODE FRAMEWORK 7 are different concepts and notions that cannot be compared directly. <p> All in all, the first approaches to code mobility <ref> [87, 25] </ref> where conceived as extensions of the remote procedure call communication mechanism. Furthermore, a mobile EU can be used to disseminate information among a set of CEs, thus realizing a form of communication. <p> A server in the client-server paradigm exports a set of fixed functionality. In turn, an executor in 2 Hereafter, by "remote evaluation" we will refer to the design paradigm presented in this section. Although it has been inspired by work on the REV system <ref> [87] </ref>, they have to be kept definitely distinct. Our REV is a design paradigm, while the REV system is a technology that may be used to actually implement an application designed using the REV paradigm. 40 CHAPTER 4.
Reference: [88] <author> J.G. Steiner, B.C. Neuman, and J.I. Schiller. </author> <title> Kerberos: An Authentication Service for Open Network Systems. </title> <booktitle> In Proc. of the Winter USENIX Conf., </booktitle> <pages> pages 191-201, </pages> <month> February </month> <year> 1988. </year>
Reference-contexts: Authentication mechanisms can be based simply on identifiers (network addresses or names) that provide little or no security or may use some stronger mechanism based on cryptography [84], namely, secret-key authentication systems (a la Kerberos <ref> [88] </ref>), or authentication systems based on public-key cryptography and digital signatures, like the ones conforming to the X.509 standard [45].
Reference: [89] <author> M. Straer, J. Baumann, and F. Hohl. </author> <title> Mole|A Java Based Mobile Agent System. </title> <booktitle> In Muhlauser [63], </booktitle> <pages> pages 327-334. BIBLIOGRAPHY 83 </pages>
Reference-contexts: In addition, messengers may use asymmetric encryption to create protected entries in shared memory, accessible by means of a public key, but modifiable only by means of a private key. 3.7. A SURVEY OF MOBILE CODE SYSTEMS 29 Mole (http://www.informatik.uni-stuttgart.de/ipvr/vs/projekte/mole.html) Developed at University of Stuttgart, Mole <ref> [89, 6] </ref> is a Java API that supports weak mobility. Mole agents are Java objects which run as threads of the JVM, which is abstracted into a place, the Mole CE.
Reference: [90] <author> Sun Microsystems. </author> <title> Java Remote Method Invocation Specification, </title> <month> Febru-ary </month> <year> 1997. </year>
Reference-contexts: Communication Being conceived for the implementation of networked applications, Java is a language with a rich set of communication-oriented APIs. Support for messaging, and stream communication mechanism is provided. In addition, Java features an RPC-like mechanism called Remote Method Invocation (RMI) <ref> [90] </ref>, that allows a Java application to invoke methods exported by other applications. All the mechanisms are both local and remote. Mechanisms for communication based on events and tuple spaces are under development.
Reference: [91] <author> J. Tardo and L. Valente. </author> <title> Mobile agent security and Telescript. </title> <booktitle> In Proc. of IEEE COMPCON'96, </booktitle> <month> February </month> <year> 1996. </year>
Reference-contexts: Then, both method invocation (RPC-like) and shared memory mechanisms cna be used for communication. 3.7. A SURVEY OF MOBILE CODE SYSTEMS 33 Security Of all reviewed MCLs, Telescript provides the most powerful mechanisms to support security <ref> [91] </ref>. In Telescript, each thread object has attributes that can be used to determine its security-related characteristics. For example, attributes are provided to hold the authority of the thread, i.e. the real-world person or organization which it belongs to, and can be accounted for.
Reference: [92] <author> D.L. Tennenhouse, J.M. Smith, W.D. Sincoskie, D.J. Wetherall, and G.J. Minden. </author> <title> A Survey of Active Network Research. </title> <journal> IEEE Communications, </journal> <volume> 35(1) </volume> <pages> 80-86, </pages> <month> January </month> <year> 1997. </year>
Reference-contexts: The component maintains information about the document state, the legal operations on its contents, and the next scheduled step in the revision process. An application of these concepts can be found in [15]. 5.3.6 Active networks The idea of active networks has been proposed recently <ref> [92, 111] </ref> as a means to introduce flexibility into networks and provide more powerful mechanisms to "program" the network according to applications' needs. <p> Although some interpret the idea of active networks without any relation with code mobility [9], most of the approaches rely on it and can be classified along a spectrum delimited by two extremes represented by the programmable switch and the capsule approaches <ref> [92] </ref>. The programmable switch approach is basically an instanti-ation of the COD paradigm, and aims at providing dynamic extensibility of network devices through dynamic linking of code.
Reference: [93] <author> G. Thiel. </author> <title> Locus operating system, a transparent system. </title> <journal> Computer Communications, </journal> <volume> 14(6) </volume> <pages> 336-346, </pages> <year> 1991. </year>
Reference-contexts: Therefore, most of these facilities provide transparent process migration, in which the programmer has neither control nor visibility of the migration process [3, 23, 76]. Other systems provide some form of control over the migration process. For example, in the Locus system <ref> [93] </ref> process migration can be triggered either by an external signal or by the invocation of the migrate system call. Object migration makes it possible to move objects among address spaces, implementing a finer grained mobility with respect to systems providing migration at the process level.
Reference: [94] <author> B. Thomsen, L. Leth, S. Prasad, T.-M. Kuo, A. Kramer, F.C. Knabe, and A. Giacalone. </author> <title> Facile Antigua Release programming guide. </title> <type> Technical Report ECRC-93-20, </type> <institution> European Computer Industry Research Centre, Munich, Germany, </institution> <month> December </month> <year> 1993. </year>
Reference-contexts: Since EUs can interact by message passing only, EU-EU security is achieved using internal mechanisms, i.e. authentication, integrity, and privacy are managed at the application level by the interacting EUs. Facile (http://www.ecrc.de/research/projects/facile/) Developed at ECRC in Munich, Facile <ref> [94] </ref> is a functional language that extends the Standard ML language with primitives for distribution, concurrency and communication. The language has been extended further in [50] to support weak mobility. Executing units are implemented as threads that run in Facile CEs, called nodes.
Reference: [95] <author> C. Tschudin. </author> <title> An Introduction to the M0 Messenger Language. </title> <institution> Univ. of Geneva, Switzerland, </institution> <year> 1994. </year>
Reference-contexts: The former mechanism is a static access control mechanism based on code verification, while the latter is a run-time programmable sandboxing mechanism. Since this mechanism is programmable, both authority-based and permit-based policies can be easily implemented. M0 (http://cuiwww.unige.ch/Telecom-group/msgr/home.html) Implemented at the University of Geneva, M0 <ref> [95] </ref> is a stack-based interpreted language that implements the concept of messengers. Messengers|representing EUs|are sequences of instructions that are transmitted among platforms| representing CEs. Mobility Messengers [96], can submit the code of other messengers to remote platforms.
Reference: [96] <editor> C. Tschudin. OO-Agents and Messengers. </editor> <booktitle> In ECOOP'95 Workshop W10 on Objects and Agents, </booktitle> <month> August </month> <year> 1995. </year>
Reference-contexts: Since this mechanism is programmable, both authority-based and permit-based policies can be easily implemented. M0 (http://cuiwww.unige.ch/Telecom-group/msgr/home.html) Implemented at the University of Geneva, M0 [95] is a stack-based interpreted language that implements the concept of messengers. Messengers|representing EUs|are sequences of instructions that are transmitted among platforms| representing CEs. Mobility Messengers <ref> [96] </ref>, can submit the code of other messengers to remote platforms. Resources are always considered transferrable and fixed, and the submitting messenger may copy them in the message containing the submitted code, in order to make them available at the destination CE.
Reference: [97] <author> G. Vigna. </author> <title> Protecting Mobile Agents through Tracing. </title> <editor> In J. Vitek and C. Tschudin, editors, </editor> <booktitle> Proc. of the 3 rd Int. Workshop on Mobile Object Systems (MOS'97), </booktitle> <year> 1997. </year>
Reference-contexts: A first mechanism is based on the state appraisal functions described earlier. State appraisal is used after execution to detect illegal modifications in the EU state that invalidate some invariants associated with the EU. A second mechanism is cryptographic tracing <ref> [97, 98] </ref> that, using execution traces and digital signatures, allows the owner of an EU to detect, after EU termination, every possible illegal modification of EU's code and state. Cryptographic tracing will be described in detail in Chapter 7.
Reference: [98] <author> G. Vigna. </author> <title> Cryptographic Traces for Mobile Agents. </title> <editor> In G. Vigna, editor, </editor> <title> Mobile Agents and Security, </title> <publisher> LNCS. Springer, </publisher> <year> 1998. </year>
Reference-contexts: A first mechanism is based on the state appraisal functions described earlier. State appraisal is used after execution to detect illegal modifications in the EU state that invalidate some invariants associated with the EU. A second mechanism is cryptographic tracing <ref> [97, 98] </ref> that, using execution traces and digital signatures, allows the owner of an EU to detect, after EU termination, every possible illegal modification of EU's code and state. Cryptographic tracing will be described in detail in Chapter 7.
Reference: [99] <author> G. Vigna, </author> <title> editor. Mobile Agents and Security. </title> <publisher> LNCS. Springer, </publisher> <year> 1998. </year>
Reference-contexts: Instead, tuple spaces are exploited as a mechanism for local communication. 3.6 Security mechanisms Security is a big concern in systems providing support to code mobility and is often considered the main limitation to the wide acceptance of mobile code technologies <ref> [99] </ref>. MCSs provide a distributed computing infrastructure on which applications belonging to different (usually untrusted) users can execute concurrently.
Reference: [100] <author> G. Vigna and L. Bonomi. </author> <title> A Model-Based Electronic Commerce Middle-ware. </title> <type> Technical report, </type> <institution> CEFRIEL, </institution> <year> 1998. </year>
Reference-contexts: This problems make mobile code appealing for this kind of applications. Actually, Telescript [105] was conceived expressly to support electronic commerce. For this reason, the term "mobile agent" is often related with electronic commerce. Other applications of code mobility to electronic commerce can be found in <ref> [61, 100] </ref>. 5.3.8 Autonomous agents Autonomous agents are applications that are able to achieve a goal, reacting to events in a dynamic environment and performing actions on the environment [59]. Autonomous agents are directed by some knowledge of the relationships among events, actions, and goals.
Reference: [101] <author> J. Vitek and C. Tschudin, </author> <title> editors. Mobile Object Systems: Towards the Programmable Internet, </title> <booktitle> volume 1222 of LNCS. </booktitle> <publisher> Springer, </publisher> <month> April </month> <year> 1997. </year>
Reference: [102] <author> D. Volpano. </author> <title> Provably-Secure Programming Languages for Remote Evaluation. </title> <journal> ACM Computing Surveys, </journal> <volume> 28A, </volume> <month> December </month> <year> 1996. </year> <booktitle> Participation statement for ACM Workshop on Strategic Directions in Computing Research. </booktitle>
Reference-contexts: The reader interested in a more detailed analysis of the linguistic problems posed by the introduction of mobility in programming languages is directed to <ref> [102, 21] </ref>. 3.2 A distributed virtual machine Traditional distributed systems can be accommodated in the virtual machine shown on the left-hand side of Figure 3.1. The lowest layer, just upon the hardware, is constituted by the Core Operating System (COS).
Reference: [103] <author> J. Waldo, G. Wyant, A. Wollrath, and S. Kendall. </author> <note> A Note on Distributed Computing. In Vitek and Tschudin [101]. Also available as Sun Microsys-tems Laboratories Technical Report TR-94-29. </note>
Reference-contexts: In these cases, the concepts of location, distribution of components among locations, and migration of components to different locations need to be taken explicitly into account during the design stage. As stated in <ref> [103] </ref>, interaction among components residing on the same host is remarkably different from the case where components reside on different hosts of a computer network in terms of latency, access to memory, partial failure, and concurrency.
Reference: [104] <author> D.J. Wetherall, J. Guttag, and D.L. Tennenhouse. </author> <title> ANTS: A Toolkit for Building an Dynamically Deploying Network Protocols. </title> <type> Technical report, </type> <institution> MIT, </institution> <year> 1997. </year> <note> Submitted for publication to IEEE OPENARCH'98. </note>
Reference-contexts: As an example, in this scenario a mul-tiprotocol router could dynamically download on demand the code needed to handle a packet corresponding to an unknown protocol, or even receive the protocol together with the packet. The work described in <ref> [104] </ref> is an example of an active network architecture exploiting the COD paradigm. 5.3.7 Electronic commerce Electronic commerce applications enable users to perform business transactions through the network. The application environment is composed of several independent and possibly competing business entities.
Reference: [105] <author> J.E. White. </author> <title> Telescript Technology: The Foundation for the Electronic Marketplace. </title> <type> Technical report, </type> <institution> General Magic, Inc., </institution> <year> 1994. </year> <note> White Paper. 84 BIBLIOGRAPHY </note>
Reference-contexts: This problems make mobile code appealing for this kind of applications. Actually, Telescript <ref> [105] </ref> was conceived expressly to support electronic commerce. For this reason, the term "mobile agent" is often related with electronic commerce.
Reference: [106] <author> J.E. White. </author> <title> Telescript Technology: Mobile Agents. </title> <editor> In J. Bradshaw, editor, </editor> <booktitle> Software Agents. </booktitle> <publisher> AAAI Press/MIT Press, </publisher> <year> 1996. </year>
Reference-contexts: In the distributed system community the term "mobile agent" is used to denote a software component that is able to move between different execution environments. This definition has actually different interpretations. For example, while in Telescript <ref> [106] </ref> an agent is represented by a thread that can migrate among different nodes carrying its execution state, in TACOMA [46] agents are just code fragments associated with initialization data that can be shipped to a remote host, without the ability to migrate again while in execution. <p> Second, the execution of the whole system can be confined in a subtree of the host file system. Apart from these mechanisms no inter-CE or intra CE mechanisms are currently implemented. Telescript (http://www.genmagic.com/Telescript) Developed by General Magic, Telescript <ref> [106] </ref> is an object-oriented language conceived for the development of large distributed applications. Security has been one of the driving factors in the language design, together with a focus on strong mobility. Telescript's EUs are agents and places, whose execution is supported by engines, the Telescript CEs.
Reference: [107] <author> U.G. Wilhelm. </author> <title> Cryptographically Protected Objects. </title> <type> Technical report, </type> <institution> Ecole Polytechnique Federale de Lausanne, Switzerland, </institution> <year> 1997. </year>
Reference-contexts: As a consequence, it is very difficult to protect EUs from malicious CEs. Protection mechanisms can be aimed at prevention or detection. Prevention mechanisms try to make it impossible to access or modify an EU data and code in a useful way. For example, tamper-proof devices <ref> [107] </ref> avoid unauthorized modification of EU code and state by executing EUs in a physically sealed environment that is not accessible even by the owner of the system without disrupting the system itself.
Reference: [108] <author> D. Wong, N. Paciorek, T. Walsh, J. DiCelie, M. Young, and B. Peet. Con-cordia: </author> <title> An Infrastructure for Collaborating Mobile Agents. </title> <booktitle> In Rothermel and Popescu-Zeletin [81], </booktitle> <pages> pages 86-97. </pages>
Reference-contexts: The set of technologies considered is not exhaustive, and is constrained by space and by the focus of the thesis. However, the reader may actually verify the soundness of the taxonomy by applying it to other MCSs not considered here, like the ones described in <ref> [108, 30, 49] </ref>. <p> Furthermore, building scalable and efficient mechanisms for dispatching events over large-scale networks is still an open research area [79, 80]. Nevertheless, the first proposals of architectures overcoming the problem are beginning to appear in <ref> [6, 108, 22] </ref>. Some of these proposals combine the notion of event with the notion of group.
Reference: [109] <author> M. Wooldridge and N.R. Jennings. </author> <title> Intelligent Agents: </title> <journal> Theory and Practice. Knowledge Engineering Review, </journal> <volume> 10(2), </volume> <month> June </month> <year> 1995. </year>
Reference-contexts: This component is directed by knowledge of the relationships among events, actions, and goals. Moreover, knowledge can be exchanged with other agents, or increased by some inferential activity [31]. Although mobility is not the most characterizing aspect of these entities <ref> [109] </ref> there is a tendency to blend this notion of intelligent agent with the one coming from distributed systems and thus assume implicitly that a mobile agent is also intelligent and vice versa. This is actually creating confusion about between the layer providing mobility and the one exploiting mobility.
Reference: [110] <author> Y. Yemini. </author> <title> The OSI Network Management Model. </title> <journal> IEEE Communications, </journal> <pages> pages 20-29, </pages> <month> May </month> <year> 1993. </year>
Reference-contexts: In the classical approach, monitoring is achieved by periodical polling of the resource state and configuration is performed using a predefined set of services. This approach, based on the CS paradigm, can lead to a number of problems <ref> [110] </ref>. Code mobility could be used to design and implement monitoring components that are co-located with the devices being monitored and report events that represent the evolution of the device state. In addition, the shipment of management components to remote sites could improve both performance and flexibility [5, 33].
Reference: [111] <author> Y. Yemini and S. da Silva. </author> <title> Towards Programmable Networks. </title> <booktitle> In IFIP/IEEE Int. Workshop on Distributed Systems: Operations and Management, </booktitle> <address> L'Aquila, Italy, </address> <month> October </month> <year> 1996. </year>
Reference-contexts: The component maintains information about the document state, the legal operations on its contents, and the next scheduled step in the revision process. An application of these concepts can be found in [15]. 5.3.6 Active networks The idea of active networks has been proposed recently <ref> [92, 111] </ref> as a means to introduce flexibility into networks and provide more powerful mechanisms to "program" the network according to applications' needs.
Reference: [112] <author> P. Zimmerman. </author> <title> PGP User's Guide, </title> <month> March </month> <year> 1993. </year>
Reference-contexts: Apart from this simple identifier-based CE-CE security mechanism, Agent Tcl provides no other inter-CE security mechanisms. An extension that allows EUs and CEs to authenticate each other and to support privacy and integrity using PGP <ref> [112] </ref> is under development. Inside the CE there is no mechanism to protect EUs from each other and to protect EUs from CEs.
References-found: 112

