URL: http://www.icsi.berkeley.edu/ftp/global/pub/techreports/1994/tr-94-032.ps.gz
Refering-URL: http://www.icsi.berkeley.edu/ftp/global/pub/techreports/1994/
Root-URL: http://www.icsi.berkeley.edu
Email: gri@icsi.berkeley.edu  
Title: Detection of Side_Effects in Function Procedures  
Author: Robert Griesemer 
Date: August 1994  
Address: Berkeley  
Affiliation: International Computer Science Institute,  
Pubnum: TR-94-032  
Abstract: Procedural programming languages usually do not support side_effect free functions but merely a form of function procedures. We argue that functions should be free of (non_local) side_effects, if they are considered as abstraction mechanism for expressions. While it is easy to statically detect side_effects in functions that do not dynamically allocate variables, this is no longer the case for functions that do create new data structures. After giving a classification of different levels of side_effects, we describe a simple and efficient method that allows for their dynamic detection while retaining assignments, i.e., without referring to a pure functional implementation. The method has been implemented for an experimental subset of Oberon. 
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> Dijkstra, E.W. and W.H.J. </author> <month> Feijen </month> <year> (1988). </year> <title> A Method of Programming, </title> <publisher> Addison_Wesley. </publisher>
Reference-contexts: The current state of a program is constituted by the current set of values of all its variables. The repeated execution of a (simple) statement leads to a path in the state space <ref> [1] </ref> of a program whereas the repeated evaluation of a simple expression does not change the current state and always yields the same result.
Reference: 2. <author> Griesemer R. </author> <year> (1993). </year> <title> A Programming Language for Vector Computers, Diss. ETH Nr. </title> <type> 10277, </type> <institution> ETH Zrich, </institution> <note> ftp ftp.inf.ethz.ch, get /doc/diss/th10277.ps. </note>
Reference-contexts: Such a restriction can be enforced easily by controlling the left_hand side of assignments and by disallowing procedure calls from within a function. This method has been used in Euclid [5], a descendant of Pascal, and in the experimental language Oberon_V <ref> [2] </ref>. Unfortunately it restricts these languages to R_functions, which do not allow new data structures as results, quite a useful feature.
Reference: 3. <author> Henderson P. </author> <year> (1980). </year> <title> Functional Programming Application and Implementation, </title> <publisher> Prentice Hall, London. </publisher>
Reference-contexts: Purely functional programming languages ensure static side_effect freeness by disallowing assignments <ref> [3] </ref>. In procedural languages, static side_effect freeness can be guaranteed by restricting assignments within functions to local variables only. Such a restriction can be enforced easily by controlling the left_hand side of assignments and by disallowing procedure calls from within a function.
Reference: 4. <author> Ierusalimschy, R. and N. de la Rocque Rodriguez (1993). </author> <title> "Side Effect Free Functions in Object_Oriented Languages", </title> <note> to be published. </note>
Reference-contexts: Using this observability criterion, we can construct the following tower of function categories (see also <ref> [4] </ref>): R_functions are not allowed to modify any non_local variables. These functions are perfectly side_effect free because no non_local state change is possible. In particular, for a given global state and given arguments, the same value is always returned. Therefore R_functions are referencially transparent.
Reference: 5. <author> Lampson, B.W., J.J. Horning, R.L. London, J.G. Mitchell and G.J. </author> <title> Popek (1977). "Report On The Programming Language Euclid", </title> <journal> ACM SIGPLAN Notices, </journal> <note> 12:2 (February). 13 </note>
Reference-contexts: In procedural languages, static side_effect freeness can be guaranteed by restricting assignments within functions to local variables only. Such a restriction can be enforced easily by controlling the left_hand side of assignments and by disallowing procedure calls from within a function. This method has been used in Euclid <ref> [5] </ref>, a descendant of Pascal, and in the experimental language Oberon_V [2]. Unfortunately it restricts these languages to R_functions, which do not allow new data structures as results, quite a useful feature.
Reference: 6. <author> Winston, P.H. and B.K.P. </author> <title> Horn (1984). Lisp, 2nd edition, </title> <publisher> Addison_Wesley. </publisher>
Reference-contexts: Assignment = Designator ":=" expression. Designator = variableName -selector | "^"-. 5 A side_effect is any assignment during evaluation of an expression, or to be more precise, "anything a (function) procedure has done that persists after it returns a value" <ref> [6] </ref>.
Reference: 7. <author> Wirth, N. </author> <year> (1988). </year> <title> "The Programming Language Oberon", </title> <journal> Software Practice and Experience, </journal> <month> 18:7 (July), </month> <pages> 671-690. </pages>
Reference-contexts: Unfortunately most procedural programming languages do not support side_effect free functions. In these languages, a function is nothing else but a procedure that specifies a return value. Therefore, sometimes the term function procedure is used <ref> [7] </ref>. Because procedures can have side_effects (it is their very purpose), they are usually allowed in function procedures, too. Thus, expressions are not always side_effect free in these languages. <p> However, we have not yet investigated such techniques. We have implemented a simple version of the birthdate method in a compiler for a subset of the programming language Oberon <ref> [7] </ref>. Every dynamic variable contains an additional time_stamp field for the birthdate, no redundant checks are eliminated and no clock resetting is done. The implementation effort for integrating side_effect checks into the compiler was around a dozen lines of code. <p> We can also think of a more explicit method, where the programmer has to use a guard that ensures that a dynamic variable is not older than the active function, very much like Oberon type guards are used to ensure that a variable is at least some given type <ref> [7] </ref>. A possible notation could be p^(NEW).f1 := e1 where (NEW) ensures that p^ is not older that the currently active function. An assignment to a dynamic variable without guard would then be statically illegal (as it is the case for R_functions).
Reference: 8. <author> Wirth, N. and J. </author> <title> Gutknecht (1992). Project Oberon The Design of an Operating System and Compiler, </title> <publisher> Addison Wesley, </publisher> <address> New York. </address>
Reference-contexts: Because the oldest active function is always a function that has been called from within a procedure, the birthdate of the oldest active function can be held in a global variable that is adjusted whenever a procedure calls a function. In an environment like the original Oberon System <ref> [8] </ref>, where garbage collection occurs only between execution of commands, resetting the time_stamps is best combined with garbage collection and the time_stamps can always be reset to zero. In systems where memory allocation is under full control of the language implementation, better solutions can be found for representing the birthdate. <p> For instance, in the whole Oberon System <ref> [8] </ref>, almost all function procedures are essentially S_functions. Only a few function procedures produce side effects (even visible ones for instance, an Oberon window is opened), and they would probably better be written as proper procedures.
References-found: 8

