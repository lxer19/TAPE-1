URL: ftp://ftp.cse.unsw.edu.au/pub/doc/papers/UNSW/9413.ps.Z
Refering-URL: http://www.cse.unsw.edu.au/school/research/tr.html
Root-URL: http://www.cse.unsw.edu.au
Email: E-mail: cjf@cs.uq.oz.au  E-mail: John.Zic@serg.cse.unsw.edu.au  
Phone: 2  
Title: A Simple, Expressive Real-Time CCS  
Author: C. Fidge J. Zic 
Date: November 1994  
Note: 4th  1 Software Verification Research  
Address: 1  UNSW 2  4072, Australia.  NSW 2052, Australia.  
Affiliation: Software Verification Research Centre Department of Computer Science University of Queensland  School of Computer Science and Engineering  Centre, Department of Computer Science, The Uni versity of Queensland, Queensland  Software Engineering Research Group, School of Computer Science and Engineering, University of New South Wales,  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> L. Aceto and D. Murphy. </author> <title> On the ill-timed but well-caused. </title> <editor> In E. Best, editor, Concur'93, </editor> <booktitle> volume 715 of Lecture Notes in Computer Science, </booktitle> <pages> pages 97-111. </pages> <publisher> Springer-Verlag, </publisher> <year> 1993. </year>
Reference-contexts: This model was originally suggested by Fidge [10] and then independently by Aceto and Murphy <ref> [1] </ref> who explored its implications in depth. Secondly, the `marker variable' model was suggested by Zic [22, 23] as an intuitively appealing way of expressing real-time requirements in process algebraic specifications relative to preceding events. <p> An anomaly arises only if we attempt to impose an arbitrary total order on independent actions [12]. As noted by Fidge [10], the true, partial causal ordering never contradicts the temporal one or, as succinctly stated by Aceto and Murphy <ref> [1] </ref>, such traces are "ill-timed but well-caused". Furthermore, rule Com 3 states that agents can interact only if they agree on the time at which the shared action occurs. <p> The loss of this law is more than compensated for by the simplicity of our real-time semantics. It has long been recognised that this law is at odds with the requirements of modelling distributed, real-time systems [13, 9]. Nevertheless, Aceto and Murphy <ref> [1] </ref> show how a form of expansion theorem can be defined for a timed, non-interleaving model by using the transition, rather than prefix, structure of agents as the basis. <p> Indeed, it is telling to note that Toetenel, when defining his own real-time CCS-based process algebra, states that "there is no syntactic o action" but only that "an internal action with very similar semantics is specifiable [emphasis added]" [20]. Similarly, Aceto and Murphy <ref> [1] </ref> provide a new operator `wait' to achieve the effect of a timed o , where this new operator is defined using relative, rather than absolute, timing. The problem seems to be a universal one.
Reference: [2] <author> T. Bolognesi and E. Brinksma. </author> <title> Introduction to the ISO specification language LOTOS. </title> <journal> Computer Networks and ISDN Systems, </journal> <volume> 14(1) </volume> <pages> 25-59, </pages> <year> 1987. </year>
Reference-contexts: If such a delay is used as the second operand to the LOTOS `disabling' operator then the combined behaviour no longer enjoys the simple recursive definition normally possible by `unwinding' the disabling operator as a choice between the initial actions of its two operands <ref> [2] </ref>, because the remaining delay period must change each time an `uninterrupted' action occurs. In effect, the `delay' operator changes the semantics of surrounding operators! 6 Conclusion We have defined, and demonstrated the application of, a new real-time process algebra, based on CCS.
Reference: [3] <author> T. Bolognesi and F. Lucidi. </author> <title> LOTOS-like process algebras with urgent or timed interactions. </title> <editor> In K. Parker and G. Rose, editors, </editor> <booktitle> Formal Description Techniques, IV, </booktitle> <pages> pages 249-264. </pages> <publisher> North-Holland, </publisher> <year> 1992. </year>
Reference-contexts: the associativity of the composition operator, i.e., ((S j C) j T ) n fa; sg : Thus this abstract model describes the behaviour of two distinct implementations. 5 Discussion The constraint-oriented approach advocated above cannot directly express notions of `priority' or `urgency', used in some other timed process algebras <ref> [3, 6, 4] </ref>. Indeed we do not feel that it is appropriate to do so. Being allowed to express a `priority' between two actions carries with it subtle consequences for causality.
Reference: [4] <author> P. Bremond-Gregoire, S. Davidson, and I. Lee. </author> <title> CCSR 92: Calculus for communicating shared resources with dynamic priorities. </title> <editor> In S. Purushothaman and A. Zwarico, editors, </editor> <booktitle> NAPAW 92: Proc. First North American Process Algebra Workshop, </booktitle> <year> 1992. </year> <month> 18 </month>
Reference-contexts: the associativity of the composition operator, i.e., ((S j C) j T ) n fa; sg : Thus this abstract model describes the behaviour of two distinct implementations. 5 Discussion The constraint-oriented approach advocated above cannot directly express notions of `priority' or `urgency', used in some other timed process algebras <ref> [3, 6, 4] </ref>. Indeed we do not feel that it is appropriate to do so. Being allowed to express a `priority' between two actions carries with it subtle consequences for causality.
Reference: [5] <author> A. Burns and A.J. Wellings. </author> <title> The notion of priority in real-time programming languages. </title> <journal> Computer Languages, </journal> <volume> 15(3) </volume> <pages> 153-162, </pages> <year> 1990. </year>
Reference-contexts: How one would be expected to implement a priority order between two geographically-separated actions is very unclear|in the real-time systems community it has been suggested that the concept of priority is flawed and quite meaningless across processor boundaries <ref> [19, 5, 15] </ref>. Furthermore, it appears that the notions of `priority' and `true concurrency' are so closely related [7] that no single language needs to support both.
Reference: [6] <author> J. Camilleri. </author> <title> A conditional operator for CCS. </title> <editor> In J. Baeten and J. Groote, editors, </editor> <booktitle> Concur '91, volume 527 of Lecture Notes in Computer Science, </booktitle> <pages> pages 142-156. </pages> <publisher> Springer-Verlag, </publisher> <year> 1991. </year>
Reference-contexts: the associativity of the composition operator, i.e., ((S j C) j T ) n fa; sg : Thus this abstract model describes the behaviour of two distinct implementations. 5 Discussion The constraint-oriented approach advocated above cannot directly express notions of `priority' or `urgency', used in some other timed process algebras <ref> [3, 6, 4] </ref>. Indeed we do not feel that it is appropriate to do so. Being allowed to express a `priority' between two actions carries with it subtle consequences for causality.
Reference: [7] <author> P. Degano, R. Gorrieri, and S. Vigna. </author> <title> On relating some models for concurrency. </title> <editor> In M.-C. Gaudel and J.-P. Jouannaud, editors, TAPSOFT'93: </editor> <booktitle> Theory and Practice of Software Development, volume 668 of Lecture Notes in Computer Science, </booktitle> <pages> pages 15-30. </pages> <publisher> Springer-Verlag, </publisher> <year> 1993. </year>
Reference-contexts: Indeed we do not feel that it is appropriate to do so. Being allowed to express a `priority' between two actions carries with it subtle consequences for causality. It can make two otherwise independent actions indirectly dependent on one another <ref> [7, 11] </ref>, in a manner not reflected by the communications pattern of the network. <p> Furthermore, it appears that the notions of `priority' and `true concurrency' are so closely related <ref> [7] </ref> that no single language needs to support both. Similarly, we have made no attempt to model the concept of assigning probabilities to nondeterministic choices [14, 21] because we see this as a concept entirely orthogonal to that of `time'.
Reference: [8] <author> M. Faci, L. Logrippo, and B. Stepien. </author> <title> Formal specification of telephone systems in LOTOS: the constraint-oriented style approach. </title> <journal> Computer Networks and ISDN Systems, </journal> <volume> 21(1) </volume> <pages> 53-67, </pages> <year> 1991. </year>
Reference-contexts: If there is no time at which two agents agree to interact then the action is not possible. Clearly the semantics linking timing behaviour and concurrency is very simple in this model. Furthermore, the approach accords well with the abstract `constraint-oriented' specification style <ref> [8] </ref>. 3.1.2 Bisimulations and equivalence The bisimulation semantics of our language is very simple. As shown in Section 3.1.1, the `labels' in our transition system consist of action name/absolute time pairs, rather than just action names.
Reference: [9] <author> C.J. Fidge. </author> <title> Process algebra traces augmented with causal relationships. </title> <editor> In K. Parker and G. Rose, editors, </editor> <booktitle> Formal Description Techniques, IV, </booktitle> <pages> pages 527-541. </pages> <publisher> North-Holland, </publisher> <year> 1992. </year>
Reference-contexts: We do not see this as a serious problem, however. The loss of this law is more than compensated for by the simplicity of our real-time semantics. It has long been recognised that this law is at odds with the requirements of modelling distributed, real-time systems <ref> [13, 9] </ref>. Nevertheless, Aceto and Murphy [1] show how a form of expansion theorem can be defined for a timed, non-interleaving model by using the transition, rather than prefix, structure of agents as the basis.
Reference: [10] <author> C.J. Fidge. </author> <title> A constraint-oriented real-time process calculus. </title> <editor> In M. Diaz and R. Groz, editors, </editor> <booktitle> Formal Description Techniques, V, </booktitle> <pages> pages 363-378. </pages> <publisher> North-Holland, </publisher> <year> 1993. </year>
Reference-contexts: Firstly, the `constraint-oriented', or `well-caused', approach takes advantage of true concurrency semantics in order to define a real-time model that does not suffer from the problematic inter-dependence of processes usually found when time is added to process algebra concurrency operators. This model was originally suggested by Fidge <ref> [10] </ref> and then independently by Aceto and Murphy [1] who explored its implications in depth. Secondly, the `marker variable' model was suggested by Zic [22, 23] as an intuitively appealing way of expressing real-time requirements in process algebraic specifications relative to preceding events. <p> In fact, the times on these two transitions are incomparable in the partial ordering defined by causality. An anomaly arises only if we attempt to impose an arbitrary total order on independent actions [12]. As noted by Fidge <ref> [10] </ref>, the true, partial causal ordering never contradicts the temporal one or, as succinctly stated by Aceto and Murphy [1], such traces are "ill-timed but well-caused". Furthermore, rule Com 3 states that agents can interact only if they agree on the time at which the shared action occurs. <p> This is a very powerful property, not enjoyed by other real-time process algebras. It is made possible only by our rejection of `time-deterministic' choices <ref> [10] </ref> and is a major contributor to the simplicity of our semantics.
Reference: [11] <author> C.J. Fidge. </author> <title> A formal definition of priority in CSP. </title> <journal> ACM Trans. on Programming Languages and Systems, </journal> <volume> 15(4) </volume> <pages> 681-705, </pages> <month> September </month> <year> 1993. </year>
Reference-contexts: Indeed we do not feel that it is appropriate to do so. Being allowed to express a `priority' between two actions carries with it subtle consequences for causality. It can make two otherwise independent actions indirectly dependent on one another <ref> [7, 11] </ref>, in a manner not reflected by the communications pattern of the network.
Reference: [12] <author> C.J. Fidge. </author> <title> Fundamentals of distributed system observation. </title> <journal> Australian Computer Science Communications, </journal> <volume> 16(1) </volume> <pages> 399-408, </pages> <month> January </month> <year> 1994. </year>
Reference-contexts: In fact, the times on these two transitions are incomparable in the partial ordering defined by causality. An anomaly arises only if we attempt to impose an arbitrary total order on independent actions <ref> [12] </ref>. As noted by Fidge [10], the true, partial causal ordering never contradicts the temporal one or, as succinctly stated by Aceto and Murphy [1], such traces are "ill-timed but well-caused". <p> The current language does not allow interacting parallel agents to exchange marker information. If this marker exchange mechanism is allowed, the specifier must be aware that direct use of time readings is not straightforward. This is because time readings in this manner are not, in general, comparable <ref> [12] </ref>.
Reference: [13] <author> J. Godskesen and K. Larsen. </author> <title> Real-time calculi and expansion theorems. </title> <editor> In R. Shyamasundar, editor, </editor> <booktitle> Foundations of Software Technology and Theoretical Computer Science, volume 652 of Lecture Notes in Computer Science, </booktitle> <pages> pages 302-315. </pages> <publisher> Springer-Verlag, </publisher> <year> 1992. </year>
Reference-contexts: We do not see this as a serious problem, however. The loss of this law is more than compensated for by the simplicity of our real-time semantics. It has long been recognised that this law is at odds with the requirements of modelling distributed, real-time systems <ref> [13, 9] </ref>. Nevertheless, Aceto and Murphy [1] show how a form of expansion theorem can be defined for a timed, non-interleaving model by using the transition, rather than prefix, structure of agents as the basis.
Reference: [14] <author> H. Hansson. </author> <title> Modelling timeouts and unreliable media with a timed probabilistic calculus. </title> <editor> In K. Parker and G. Rose, editors, </editor> <booktitle> Formal Description Techniques, IV, </booktitle> <pages> pages 67-82. </pages> <publisher> North-Holland, </publisher> <year> 1992. </year>
Reference-contexts: Furthermore, it appears that the notions of `priority' and `true concurrency' are so closely related [7] that no single language needs to support both. Similarly, we have made no attempt to model the concept of assigning probabilities to nondeterministic choices <ref> [14, 21] </ref> because we see this as a concept entirely orthogonal to that of `time'. The main disadvantage with our definitions is the clumsy algebraic laws for `absolutely-timed' o actions (see Section 3.1.3).
Reference: [15] <author> H. Hansson and F. Orava. </author> <title> A process calculus with incomparable priorities. </title> <editor> In S. Purushothaman and A. Zwarico, editors, </editor> <booktitle> NAPAW 92: Proc. First North American Process Algebra Workshop, </booktitle> <year> 1992. </year>
Reference-contexts: How one would be expected to implement a priority order between two geographically-separated actions is very unclear|in the real-time systems community it has been suggested that the concept of priority is flawed and quite meaningless across processor boundaries <ref> [19, 5, 15] </ref>. Furthermore, it appears that the notions of `priority' and `true concurrency' are so closely related [7] that no single language needs to support both.
Reference: [16] <author> G. Leduc and L. Leonard. </author> <title> A timed LOTOS supporting a dense time domain and including new timed operators. </title> <editor> In M. Diaz and R. Groz, editors, </editor> <booktitle> Formal Description Techniques, V, </booktitle> <pages> pages 87-102. </pages> <publisher> North-Holland, </publisher> <year> 1992. </year>
Reference-contexts: Although we could also have defined such a new operator ourselves we have not done so because adding new real-time operators increases the complexity 17 of the semantics and can have subtle, unanticipated side-effects. For instance, when a `delay' operator is added to an algebra like LOTOS <ref> [16] </ref>, we note that it can interact with other operators in unfortunate ways.
Reference: [17] <author> R. Milner. </author> <title> Communication and Concurrency. </title> <publisher> Prentice-Hall, </publisher> <year> 1989. </year>
Reference-contexts: Secondly, the `marker variable' model was suggested by Zic [22, 23] as an intuitively appealing way of expressing real-time requirements in process algebraic specifications relative to preceding events. To illustrate the combined approach this paper describes how it can be embedded in CCS <ref> [17] </ref>. The resulting language has the following aims and characteristics. * No new operators or transition rules are needed. Syntactically time is introduced by adding extra annotations to the existing prefix operator. <p> We therefore then introduce marker variables and set-valued timing expressions to the full language so that concise and relative timing requirements can be stated. 3.1 Basic language The basic language is identical to standard CCS <ref> [17, x2.4] </ref> with extra annotations on the prefix operator. <p> A = G, agent constant Definition (A 2 K; G 2 G) As usual we allow the `nil' agent 0 to be defined as a choice between no alternatives <ref> [17, p.44] </ref>: 0 = i2fg E i : The only unusual features are the absolute time t associated with each action, and the `context' c associated with each prefix operator. The absolute time t is supplied by the specifier. <p> It is not intended to be seen by the specifier. The context may therefore always be omitted in specifications, in which case a default value is assumed: ff@t : E = ff@t 3.1.1 Transitional semantics The transitional semantics is closely based on standard CCS <ref> [17, x2.5] </ref> except that transition labels carry the absolute time at which each action occurred and the transition rule for prefix is extended. <p> Strong bisimulation <ref> [17, x4.2] </ref> is defined as follows. Definition 1. <p> Thus the following two agents are not bisimilar a@3 : b@5 : 0 6 a@3 : b@4 : 0 ; even though they can both perform the same actions, because they do action b at different times. The definition of weak equivalence <ref> [17, x5.1] </ref> is extended similarly. Let s 2 (Act fi T ) fl be a sequence of `timed' transition labels, and ^s 2 (L fi T ) fl be the 7 sequence gained by deleting all pairs in s whose first element is o . <p> Since this new transition system is defined using the old one `!' <ref> [17, p.107] </ref>, then in order for a `=)' transition to be valid the times in the action sequence between E and E 0 cannot go backwards. Definition 2. <p> Finally, the definition of fully-substitutive equality <ref> [17, x7.2] </ref> is again a straight forward extension. Definition 3. <p> : E 6= (E) c ; even though E has the same `starting time' in both cases, because the two agents are not necessarily equivalent when used as operands in a choice. 8 3.1.3 Equational laws The equational laws of our revised language differ significantly from those of standard CCS <ref> [17, ch.3] </ref> in only two respects. Most of the laws are unchanged. <p> Most of the laws are unchanged. Propositions 1 <ref> [17, p.62] </ref>, 4 [17, p.65], 8, 9, 10 [17, p.80] and Corollary 11 [17, p.81] are not altered in any way, and Corollary 7 [17, p.70] requires only a minor syntactic extension due to our new prefix operator. <p> Most of the laws are unchanged. Propositions 1 [17, p.62], 4 <ref> [17, p.65] </ref>, 8, 9, 10 [17, p.80] and Corollary 11 [17, p.81] are not altered in any way, and Corollary 7 [17, p.70] requires only a minor syntactic extension due to our new prefix operator. <p> Most of the laws are unchanged. Propositions 1 [17, p.62], 4 [17, p.65], 8, 9, 10 <ref> [17, p.80] </ref> and Corollary 11 [17, p.81] are not altered in any way, and Corollary 7 [17, p.70] requires only a minor syntactic extension due to our new prefix operator. <p> Most of the laws are unchanged. Propositions 1 [17, p.62], 4 [17, p.65], 8, 9, 10 [17, p.80] and Corollary 11 <ref> [17, p.81] </ref> are not altered in any way, and Corollary 7 [17, p.70] requires only a minor syntactic extension due to our new prefix operator. <p> Most of the laws are unchanged. Propositions 1 [17, p.62], 4 [17, p.65], 8, 9, 10 [17, p.80] and Corollary 11 [17, p.81] are not altered in any way, and Corollary 7 <ref> [17, p.70] </ref> requires only a minor syntactic extension due to our new prefix operator. Thus our language continues to obey natural properties such as 1 (1) P + Q = Q + P 8 (2) P j (Q j R) = (P j Q) j R and so on. <p> A significant difference occurs in the handling of o actions in prefixes, however. Proposition 2 and Corollary 3 <ref> [17, pp.62-3] </ref> are revised as follows. <p> the laws involving prefix become much more complicated if we allow arbitrary contexts to be supplied, rather than the default of 0, because these could block any action.) Also see Section 5. 9 The second major difference is that the `expansion law', as defined by Propo--sition 5 and Corollary 6 <ref> [17, p.69] </ref>, does not apply to our language (except in the degenerate case where all actions occur at the same time). This is a natural consequence of our decision to use true concurrency semantics|the expansion law is applicable only to interleaving models. <p> Our full real-time language is an extension to Milner's value-passing calculus <ref> [17, x2.8] </ref>, and can thus take advantage of CCS variables in timing expressions. Let V denote the set of CCS value variable names. We introduce a distinct set M of marker variable names which are used to hold absolute times. <p> occurs each of the variables in M will be assigned the value of the absolute time at which the action occurred, for use in subsequent timing expressions. (We also assume, but have not shown above, that action names in prefixes can be followed with message-passing parameters, as in value-passing CCS <ref> [17, p.55] </ref>.) A number of syntactic conveniences are used. <p> Milner lets agents F in the value-passing calculus be rewritten in basic CCS via a simple translation function, denoted b F <ref> [17, p.56] </ref>. <p> This is because time readings in this manner are not, in general, comparable [12]. Simple rules for operators other than prefix allow the translation function to be recursively applied through an entire agent expression, in exactly the same way as the standard CCS model <ref> [17, p.56] </ref>. 14 4 Case study: repeater system To illustrate the use of the full language this section shows how a particular software requirement can be specified. Consider a `repeater' that must read numbers from a memory-mapped i/o location without missing, duplicating or mis-reading them.
Reference: [18] <author> R. Milner. </author> <title> The Polyadic -Calculus: a Tutorial. </title> <institution> Computer Science Department, University of Edinburgh, </institution> <month> October </month> <year> 1991. </year> <month> 19 </month>
Reference-contexts: It offers the advantages of simple semantics, but still has good expressive power. This was achieved by combining the best features of two previous streams of research, the `constraint-oriented' and `marker variable' approaches. Future work will see the application of our approach to Milner's new - calculus <ref> [18] </ref>. Interestingly, this will sidestep the problem with o actions mentioned above, because `syntactic o s' are not part of the language. More importantly, it also offers the potential to treat marker variable names as first class, like other -calculus names.
Reference: [19] <author> M.J. Pilling. </author> <title> Dangers of priority as a structuring principle for real-time languages. </title> <journal> Australian Computer Science Communications, </journal> <volume> 13(1) 18-1-18-10, </volume> <month> February </month> <year> 1991. </year>
Reference-contexts: How one would be expected to implement a priority order between two geographically-separated actions is very unclear|in the real-time systems community it has been suggested that the concept of priority is flawed and quite meaningless across processor boundaries <ref> [19, 5, 15] </ref>. Furthermore, it appears that the notions of `priority' and `true concurrency' are so closely related [7] that no single language needs to support both.
Reference: [20] <author> H. Toetenel. </author> <title> Loose real-time communicating agents. </title> <editor> In D. Andrews, J. Groote, and C. Middelburg, editors, </editor> <booktitle> Semantics of Specification Languages, </booktitle> <pages> pages 135-151. </pages> <publisher> Springer-Verlag, </publisher> <year> 1993. </year>
Reference-contexts: Indeed, it is telling to note that Toetenel, when defining his own real-time CCS-based process algebra, states that "there is no syntactic o action" but only that "an internal action with very similar semantics is specifiable [emphasis added]" <ref> [20] </ref>. Similarly, Aceto and Murphy [1] provide a new operator `wait' to achieve the effect of a timed o , where this new operator is defined using relative, rather than absolute, timing. The problem seems to be a universal one.
Reference: [21] <author> J. Zic. </author> <title> Some thoughts on communication system performance specification. In D.B. </title> <editor> Hoang and E. Chew, editors, </editor> <booktitle> Proc. Open Distributed Processing Workshop, </booktitle> <address> Sydney, </address> <month> January </month> <year> 1990. </year>
Reference-contexts: Furthermore, it appears that the notions of `priority' and `true concurrency' are so closely related [7] that no single language needs to support both. Similarly, we have made no attempt to model the concept of assigning probabilities to nondeterministic choices <ref> [14, 21] </ref> because we see this as a concept entirely orthogonal to that of `time'. The main disadvantage with our definitions is the clumsy algebraic laws for `absolutely-timed' o actions (see Section 3.1.3).
Reference: [22] <author> J. Zic. CSP+T: </author> <title> A Formalism for Describing Real-Time Systems. </title> <type> PhD thesis, </type> <institution> Basser Department of Computer Science, University of Sydney, </institution> <month> July </month> <year> 1991. </year>
Reference-contexts: This model was originally suggested by Fidge [10] and then independently by Aceto and Murphy [1] who explored its implications in depth. Secondly, the `marker variable' model was suggested by Zic <ref> [22, 23] </ref> as an intuitively appealing way of expressing real-time requirements in process algebraic specifications relative to preceding events. To illustrate the combined approach this paper describes how it can be embedded in CCS [17].
Reference: [23] <author> J. Zic. </author> <title> Specifying a time constrained buffer in Timed CSP and CSP+T. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <note> 1994. To appear. 20 </note>
Reference-contexts: This model was originally suggested by Fidge [10] and then independently by Aceto and Murphy [1] who explored its implications in depth. Secondly, the `marker variable' model was suggested by Zic <ref> [22, 23] </ref> as an intuitively appealing way of expressing real-time requirements in process algebraic specifications relative to preceding events. To illustrate the combined approach this paper describes how it can be embedded in CCS [17].
References-found: 23

