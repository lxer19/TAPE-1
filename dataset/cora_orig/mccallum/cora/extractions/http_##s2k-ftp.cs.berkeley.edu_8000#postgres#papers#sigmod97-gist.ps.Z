URL: http://s2k-ftp.cs.berkeley.edu:8000/postgres/papers/sigmod97-gist.ps.Z
Refering-URL: http://gist.cs.berkeley.edu:8000/gist/gist1.html
Root-URL: http://www.cs.berkeley.edu
Email: marcel@cs.berkeley.edu  mohan@almaden.ibm.com  jmh@cs.berkeley.edu  
Title: Concurrency and Recovery in Generalized Search Trees  
Author: Marcel Kornacker C. Mohan Joseph M. Hellerstein 
Web: http://www.cs.berkeley.edu/ marcel  http://www.almaden.ibm.com/ cs/people/mohan  http://www.cs.berkeley.edu/ jmh  
Address: Berkeley  Berkeley  
Affiliation: U. C.  IBM Research Division  U. C.  
Abstract: This paper presents general algorithms for concurrency control in tree-based access methods as well as a recovery protocol and a mechanism for ensuring repeatable read. The algorithms are developed in the context of the Generalized Search Tree (GiST) data structure, an index structure supporting an extensible set of queries and data types. Although developed in a GiST context, the algorithms are generally applicable to many tree-based access methods. The concurrency control protocol is based on an extension of the link technique originally developed for B-trees, and completely avoids holding node locks during I/Os. Repeatable read isolation is achieved with a novel combination of predicate locks and two-phase locking of data records. To our knowledge, this is the first time that isolation issues have been addressed outside the context of B-trees. A discussion of the fundamental structural differences between B-trees and more general tree structures like GiSTs explains why the algorithms developed here deviate from their B-tree counterparts. An implementation of GiSTs emulating B-trees in DB2/Common Server is underway. 
Abstract-found: 1
Intro-found: 1
Reference: [BS77] <author> R. Bayer and M. Schkolnick. </author> <title> Concurrency of Operations on B-Trees. </title> <journal> Acta Informatica, </journal> <volume> 9 </volume> <pages> 1-21, </pages> <year> 1977. </year>
Reference-contexts: The link technique, on which GiST concurrency is based, was first introduced in ([LY81]) as the B-link tree, and has been the basis of many subsequent papers on B-tree concurrency (for example [Sag86]). Its superiority over subtree-locking concurrency protocols, as described in <ref> [BS77] </ref>, has been confirmed by two performance studies ([SC91, JS93]). A different approach than node linking was taken in ARIES/IM ([ML92]), which employs a conventional non-link tree structure and allows latch-coupling during tree descent, but is still able to propagate splits bottom-up without having to lock subtrees.
Reference: [EGLT76] <author> K.P. Eswaran, J.N. Gray, R.A. Lorie, </author> <title> and I.L. Traiger. The notion of consistency and predicate locks in database systems. </title> <journal> Communications of the ACM, </journal> 19(11) 624-633, November 1976. 
Reference: [GR93] <author> J. Gray and A. Reuter. </author> <title> Transaction Processing Concepts and Techniques. </title> <publisher> Morgan Kaufmann Publishers, </publisher> <year> 1993. </year>
Reference-contexts: WAL-based recovery systems often have log sequence numbers (LSNs) associated with their log records, which are reflected in the page they were generated for and facilitate restart (for a description of logging and restart in WAL environments, see [MHL + <ref> [GR93] </ref>). These LSNs are guaranteed to be monotonically increasing, which makes the LSN of the last log record written an ideal candidate for the global counter value. <p> These functions are best realized by a predicate manager component, which can be implemented along the lines of a lock manager within a DBMS (see <ref> [GR93] </ref> for an example). The major data structures within a predicate manager would be: * a list of predicates per transaction; * a list of node attachments for each predicate; * a list of the predicates attached to each node.
Reference: [Gra78] <author> J. Gray. </author> <booktitle> Notes on Database Operating Systems. In Operating Systems An Advanced Course, volume 60 of Lecture Notes in Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1978. </year>
Reference: [Gut84] <author> A. Guttman. R-Trees: </author> <title> A Dynamic Index Structure for Spatial Searching. </title> <booktitle> In Proc. ACM SIGMOD Conf., </booktitle> <pages> pages 47-57, </pages> <month> June </month> <year> 1984. </year>
Reference: [HNP95] <author> J. Hellerstein, J. Naughton, and A. Pfeffer. </author> <title> Generalized Search Trees for Database Systems. </title> <booktitle> In Proc. 21st Int'l Conference on Very Large Databases (VLDB), </booktitle> <pages> pages 562-573, </pages> <month> September </month> <year> 1995. </year>
Reference-contexts: It appears, that the performance benefits of any particular access method other than B-trees do not outweigh the substantial implementation effort. To solve the problem of making innovative access methods easier to integrate into DBMSs, <ref> [HNP95] </ref> developed a Generalized Search Tree (GiST), a template index structure supporting an extensible set of queries and datatypes. <p> Examples of access methods, that can be reformulated as GiST specializations are: R-tree ([Gut84]) and its variants, TV-tree ([LJF94]), P-tree ([Jag90]) and Ch-tree ([KKAD89]). Although the GiST structure considerably reduces the effort involved in implementing a new access method from scratch, <ref> [HNP95] </ref> still does not address the areas of concurrent access, transactional isolation or recovery. In this paper we describe general algorithms for concurrency control, recovery and repeatable read isolation that can be applied to a very broad class of access methods. <p> The GiST logging and recovery protocol as presented in Section 9 directly builds on that prior work. The basic GiST structure itself is described in <ref> [HNP95] </ref>. The paper also gives three examples of implementations of specific trees within the GiST structure and tries to analyze the GiST performance in a general way.
Reference: [Jag90] <author> H. V. Jagadish. </author> <title> Spatial Search with Polyhedra. </title> <booktitle> In Proc. 6th IEEE Int'l Conf. on Data Engin., </booktitle> <year> 1990. </year>
Reference: [JS93] <author> T. Johnson and D. Shasha. </author> <title> The Performance of Current B-Tree Algorithms. </title> <journal> ACM TODS, </journal> <volume> 18(1), </volume> <month> March </month> <year> 1993. </year>
Reference: [KB95] <author> M. Kornacker and D. </author> <title> Banks. High-Concurrency Locking in R-Trees. </title> <booktitle> In Proc. 21st Int'l Conference on Very Large Databases (VLDB), </booktitle> <pages> pages 134-145, </pages> <month> September </month> <year> 1995. </year>
Reference-contexts: GiSTs do not impose these restrictions on the key domain, which means that the B-link strategy by itself is insufficient. <ref> [KB95] </ref> adapts the link strategy to R-trees by assigning sequencenumbers to the nodes and incrementing these during node splits. The sequence number is also recorded in the parent entry, which allows traversing operations to reconstruct the lineage of a node after it was split. <p> The basic GiST structure itself is described in [HNP95]. The paper also gives three examples of implementations of specific trees within the GiST structure and tries to analyze the GiST performance in a general way. The basis of the GiST concurrency protocol was developed in <ref> [KB95] </ref> in the context of R-trees, which have the same structural properties as GiSTs (non-partitioning, non-linear keys). The paper does not sufficiently address the problems of transactional isolation, recovery and node deletion.
Reference: [KKAD89] <author> W. Kim, K.-C. Kim, and A. A. Dale. </author> <title> Object-Oriented Concepts, Databases and Applications, chapter Indexing Techniques for Object-Oriented Databases. </title> <publisher> ACM Press and Addison-Wesley Publishing Co., </publisher> <year> 1989. </year>
Reference: [KL80] <author> H. T. Kung and P. L. Lehman. </author> <title> Concurrent Manipulation of Binary Search Trees. </title> <journal> ACM TODS, </journal> <volume> 5(3), </volume> <year> 1980. </year>
Reference-contexts: either a tree operation visiting a reallocated node detects this and recovers from it by repositioning itself within the tree (as in ARIES/IM [ML92]); or we avoid incorrect pointers altogether by delaying a node deletion until there can be no more active tree operations with pointers to it (introduced in <ref> [KL80] </ref> as the drain technique). The first alternative, recovery from incorrect pointers, is impossible for a variety of reasons. If the node has been split before it is deleted, a tree operation visiting it after the deletion may still need to traverse its rightlink.
Reference: [LJF94] <author> K. Lin, H. Jagadish, and C. Faloutsos. </author> <title> The TV-Tree: An Index Structure for High-Dimensional Data. </title> <journal> VLDB Journal, </journal> <volume> 3, </volume> <month> October </month> <year> 1994. </year>
Reference: [Lom93] <author> D. Lomet. </author> <title> Key Range Locking Strategies for Improved Concurrency. </title> <booktitle> In Proc. 19th Int'l Conf. on Very Large Databases (VLDB), </booktitle> <month> August </month> <year> 1993. </year>
Reference-contexts: See [Moh90b], <ref> [Lom93] </ref> and [Moh95] for some techniques to address this problem. 6 The key range can be expandedgradually, but this would become relatively costly.
Reference: [LS90] <author> D. Lomet and B. Salzberg. </author> <title> The hB-Tree: A Multiat-tribute Indexing Method with Good Guaranteed Performance. </title> <journal> ACM TODS, </journal> <volume> 15(4) </volume> <pages> 625-685, </pages> <month> December </month> <year> 1990. </year>
Reference-contexts: This is not a very restrictive requirement, because it only excludes access methods that are either not proper trees (e.g., the hB-tree, as described in <ref> [LS90] </ref>) or that have other structural peculiarity (for instance, R + -trees, described in [SRF87], replicate leaf entries).
Reference: [LS92] <author> D. Lomet and B. Salzberg. </author> <title> Access Method Concur-rency with Recovery. </title> <booktitle> In Proc. ACM SIGMOD Conf., </booktitle> <pages> pages 351-360, </pages> <year> 1992. </year>
Reference: [LY81] <author> P.L. Lehmann and S.B. Yao. </author> <title> Efficient Locking for Concurrent Operations on B-Trees. </title> <journal> ACM TODS, </journal> <volume> 6(4) </volume> <pages> 650-670, </pages> <month> December </month> <year> 1981. </year>
Reference: [MHL + 92] <author> C. Mohan, D. Haderle, B. Lindsay, H. Pirahesh, and P. Schwarz. </author> <title> ARIES: A Transaction Recovery Method Supporting Fine-Granularity Locking and Partial Rollbacks Using Write-Ahead Logging. </title> <journal> ACM TODS, </journal> <volume> 17(1), </volume> <month> March </month> <year> 1992. </year>
Reference-contexts: Latches are commonlyused to synchronizeaccess to physical objects of the DBMS such as buffer pool frames. Also, latches do not interact with locks, so that it is possible to latch the buffer pool frame holdinga particular node while some other transaction holds a lock on the node. See <ref> [MHL + 92] </ref> for more details. latched leaf can be split in the meantime, we might have to traverse rightlinks, guided by the node's original NSN. 9 6 Key Insertion Key insertion is carried out in several phases: 1. the new data record (stored elsewhere in the database) is X-locked before <p> the building blocks of insert and delete op 12 These atomic units of work have also been called atomic actions ([LS92]) or nested top actions (<ref> [MHL + 92] </ref>) in the research literature. A technique for executing a sequence of page updates as individuallycommitted atomic units of work is described in [MHL + 92].
Reference: [ML92] <author> C. Mohan and F. Levine. ARIES/IM: </author> <title> An Efficient and High Concurrency Index Management Method Using Write-Ahead Logging. </title> <booktitle> In Proc. ACM SIGMOD Conf., </booktitle> <month> June </month> <year> 1992. </year>
Reference-contexts: There are two alternatives to deal with this problem: either a tree operation visiting a reallocated node detects this and recovers from it by repositioning itself within the tree (as in ARIES/IM <ref> [ML92] </ref>); or we avoid incorrect pointers altogether by delaying a node deletion until there can be no more active tree operations with pointers to it (introduced in [KL80] as the drain technique). The first alternative, recovery from incorrect pointers, is impossible for a variety of reasons. <p> The reason why in the latter case rightlink traversal may be necessary is that between the time the index operation was performed and the time the transaction is aborted, the tree structure could have changed (for the same reason, logical undo is also employed in ARIES/IM <ref> [ML92] </ref> and ARIES/KVL [Moh90a]). If a split takes place in the meantime, the relevant entries may be moved rightward onto other leaves. When performing undo recovery after a system crash, all node latches acquired prior to the crash are lost. <p> The paper does not sufficiently address the problems of transactional isolation, recovery and node deletion. The data-only locking approach and logical deletion have been adopted from <ref> [ML92, Moh95] </ref> and [Moh90b]. 12 Conclusion This paper presents algorithms for concurrency, recovery and transactional isolation for a broad class of search trees.
Reference: [Moh90a] <author> C. Mohan. ARIES/KVL: </author> <title> A Key-Value Locking Method for Concurrency Control of Multiaction Transactions Operating on B-Tree Indexes. </title> <booktitle> In Proc. 16th Int'l Conference on Very Large Databases (VLDB), </booktitle> <month> August </month> <year> 1990. </year>
Reference-contexts: The reason why in the latter case rightlink traversal may be necessary is that between the time the index operation was performed and the time the transaction is aborted, the tree structure could have changed (for the same reason, logical undo is also employed in ARIES/IM [ML92] and ARIES/KVL <ref> [Moh90a] </ref>). If a split takes place in the meantime, the relevant entries may be moved rightward onto other leaves. When performing undo recovery after a system crash, all node latches acquired prior to the crash are lost.
Reference: [Moh90b] <author> C. Mohan. </author> <title> Commit LSN: A Novel and Simple Method for Reducing Locking and Latching in Transaction Processing Systems. </title> <booktitle> In Proc. 16th Int'l Conference on Very Large Databases (VLDB), </booktitle> <month> August </month> <year> 1990. </year>
Reference-contexts: See <ref> [Moh90b] </ref>, [Lom93] and [Moh95] for some techniques to address this problem. 6 The key range can be expandedgradually, but this would become relatively costly. <p> This is not applicable to GiSTs for the reasons already mentioned in section 4. Even in B-trees, logical deletion is preferable if increased concurrency is important (see <ref> [Moh90b] </ref> for further discussions of logical deletions). In fact, the new index manager of DB2/MVS V4 has adopted it for that reason. A regular B-tree, where entries in internal nodes are shown as intervals for clarity, although they would only be stored with their left or right boundary. <p> When that happens, it is impossible to determine which nodes have been split off the deleted one. It is clear for these reasons that a node cannot be deleted while active tree operations still hold direct or indirect pointers to it. 11 <ref> [Moh90b] </ref> shows how this can be donecheaply in a WAL environment. Essentially, if the page's LSN is less than the LSN of the oldest active transaction, then all entries must belong to committed transactions and no additional locks have to be tested. <p> The paper does not sufficiently address the problems of transactional isolation, recovery and node deletion. The data-only locking approach and logical deletion have been adopted from [ML92, Moh95] and <ref> [Moh90b] </ref>. 12 Conclusion This paper presents algorithms for concurrency, recovery and transactional isolation for a broad class of search trees.
Reference: [Moh95] <author> C. Mohan. </author> <title> Performance of Concurrency Control Mechanisms in Centralized Database Systems, chapter Concurrency Control and Recovery Methods for B+- Tree Indexes: </title> <editor> ARIES/KVL and ARIES/IM. </editor> <publisher> Prentice Hall, </publisher> <address> Englewood Cliffs, New Jersey, </address> <year> 1995. </year>
Reference-contexts: See [Moh90b], [Lom93] and <ref> [Moh95] </ref> for some techniques to address this problem. 6 The key range can be expandedgradually, but this would become relatively costly. <p> The paper does not sufficiently address the problems of transactional isolation, recovery and node deletion. The data-only locking approach and logical deletion have been adopted from <ref> [ML92, Moh95] </ref> and [Moh90b]. 12 Conclusion This paper presents algorithms for concurrency, recovery and transactional isolation for a broad class of search trees.
Reference: [Sag86] <author> Y. Sagiv. </author> <title> Concurrent Operations on B*-Trees with Overtaking. </title> <journal> Journal of Computer and System Sciences, </journal> <volume> 33(2) </volume> <pages> 275-296, </pages> <year> 1986. </year>
Reference-contexts: The link technique, on which GiST concurrency is based, was first introduced in ([LY81]) as the B-link tree, and has been the basis of many subsequent papers on B-tree concurrency (for example <ref> [Sag86] </ref>). Its superiority over subtree-locking concurrency protocols, as described in [BS77], has been confirmed by two performance studies ([SC91, JS93]).
Reference: [SC91] <author> V. Srinivasan and M. Carey. </author> <title> Performance of B-Tree Concurrency Control Algorithms. </title> <booktitle> In Proc. ACM SIG-MOD Conf., </booktitle> <pages> pages 416-425, </pages> <year> 1991. </year>
Reference: [SG88] <author> D. Shasha and N. Goodman. </author> <title> Concurrent Search Structure Algorithms. </title> <journal> ACM TODS, </journal> <volume> 13(1), </volume> <month> March </month> <year> 1988. </year>
Reference: [SRF87] <author> T. Sellis, N. Roussopoulos, and C. Faloutsos. </author> <title> The R + Tree: A Dynamic Index for Multidimensional Objects. </title> <booktitle> In Proc. 13th Int'l Conference on Very Large Databases (VLDB), </booktitle> <pages> pages 507-518, </pages> <month> September </month> <year> 1987. </year>
Reference-contexts: This is not a very restrictive requirement, because it only excludes access methods that are either not proper trees (e.g., the hB-tree, as described in [LS90]) or that have other structural peculiarity (for instance, R + -trees, described in <ref> [SRF87] </ref>, replicate leaf entries). Although the GiST structure is similar to that of a B-tree, it generalizes the B-tree structure in a way which makes most of the extensively researched concurrency control techniques for B-trees inapplicable in the less restricted context of the GiST structure.
References-found: 25

