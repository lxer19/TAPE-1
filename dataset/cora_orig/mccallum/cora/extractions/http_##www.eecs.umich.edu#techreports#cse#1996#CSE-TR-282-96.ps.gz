URL: http://www.eecs.umich.edu/techreports/cse/1996/CSE-TR-282-96.ps.gz
Refering-URL: http://www.eecs.umich.edu/home/techreports/cse96.html
Root-URL: http://www.eecs.umich.edu
Title: Limits to Branch Prediction  
Author: Trevor N. Mudge*, I-Cheng K. Chen, and John T. Coffey 
Keyword: branch prediction, limit of branch predictability, prediction by partial matching, text compres sion.  
Note: This document was created with FrameMaker 4.0.4  
Address: Ann Arbor, Michigan, 48109-2122  
Affiliation: Electrical Engineering and Computer Science Department The University of Michigan  
Abstract: Branch prediction is an important mechanism in modern microprocessor design. The focus of research in this area has been on designing new branch prediction schemes. In contrast, very few studies address the inherent limit of predictability of program themselves. Programs have an inherent limit of predictability due to the randomness of input data. Knowing the limit helps us to evaluate how good a prediction scheme is and how much we can expect to improve its accuracy. In this paper we propose two complementary approaches to estimating the limits of predictability: exact analysis of the program and the use of a universal compression/prediction algorithm, prediction by partial matching (PPM), that has been very successful in the field of data and image compression. We review the algorithmic basis for both some common branch predictors and PPM and show that two-level branch prediction, the best method currently in use, is a simplified version of PPM. To illustrate exact analysis, we use Quicksort to calibrate the performance of various branch predictors. With other programs, too complicated to analyze exactly, we use PPM, as a measure of inherent predictability. Our initial results show that PPM can approach the theoretical limit in an analyzable program and perform just as well as the best existing branch predictors for SPECInt92. This suggests that universal compression/prediction algorithms, such as PPM, can be used to estimate the limits to branch prediction for a particular workload of programs. 
Abstract-found: 1
Intro-found: 1
Reference: [Bell90] <author> Bell, T.C., Cleary, J.G. and Witten I.H. </author> <title> Text Compression . Englewood Cliffs, </title> <address> NJ: </address> <publisher> Prentice-Hall, </publisher> <year> 1990. </year>
Reference-contexts: Once this limit is obtained, designers can readily evaluate the performance of their new prediction schemes. 2. Branch Prediction Algorithms 2.1 Prediction by Partial Matching In order to compress data effectively, a compression algorithm has to predict future data accurately to build a good probabilistic model for compression <ref> [Bell90] </ref>. Many compression algorithms form a model of the probability distribution for the next symbol, and then encode the next symbol with a compressor tuned to that probability distribution. <p> Prediction by partial matching is a universal compression/prediction algorithm that has been theoretically proven optimal in data compression and prefetching [Cleary84, Krishnan94, Moffat90, Vitter91]. Indeed, it usually outperforms the Lempel-Ziv algorithm (found in Unix press ) due to implementation considerations and faster convergence rate <ref> [Curewitz93, Bell90, Witten94] </ref>. The PPM algorithm for text compression consists of a predictor to estimate probabilities for characters and an arithmetic encoder. We only make use of the predictor. We encode the outcomes of a branch, taken or not taken, as a 1 or a 0.
Reference: [Cleary84] <author> Cleary, J.G. and Witten, I.H. </author> <title> Data compression using adaptive coding and partial string matching . IEEE Transactions on Communications, </title> <journal> Vol. </journal> <volume> 32, No. 4, </volume> <pages> 396-402, </pages> <month> April </month> <year> 1984. </year>
Reference-contexts: Universal compression/prediction algorithms are well-understood and have been applied with great success in the fields of text and image compression. More recently, two examples, Lempel-Ziv and prediction by partial matching (PPM) <ref> [Cleary84, Moffat90] </ref> have been successfully applied to prefetching data from disk memories [Vitter91, Curewitz93]. In this paper we used PPM and show that, although designed for text compression, it performs just as well in this new domain of branch prediction. This paper is organized into five sections. <p> In our experiments we draw on these techniques, adapting them to the new context of branch prediction. Prediction by partial matching is a universal compression/prediction algorithm that has been theoretically proven optimal in data compression and prefetching <ref> [Cleary84, Krishnan94, Moffat90, Vitter91] </ref>. Indeed, it usually outperforms the Lempel-Ziv algorithm (found in Unix press ) due to implementation considerations and faster convergence rate [Curewitz93, Bell90, Witten94]. The PPM algorithm for text compression consists of a predictor to estimate probabilities for characters and an arithmetic encoder.
Reference: [Curewitz93] <author> Curewitz K. M., Krishnan, P. and Vitter, J.S. </author> <booktitle> Practical prefetching via data compression . Proceedings of the 1993 ACM SIGMOD International Conference on Management of Data, </booktitle> <address> Wash-ington, D. C., 257-266, </address> <month> May </month> <year> 1993. </year>
Reference-contexts: Universal compression/prediction algorithms are well-understood and have been applied with great success in the fields of text and image compression. More recently, two examples, Lempel-Ziv and prediction by partial matching (PPM) [Cleary84, Moffat90] have been successfully applied to prefetching data from disk memories <ref> [Vitter91, Curewitz93] </ref>. In this paper we used PPM and show that, although designed for text compression, it performs just as well in this new domain of branch prediction. This paper is organized into five sections. <p> Prediction by partial matching is a universal compression/prediction algorithm that has been theoretically proven optimal in data compression and prefetching [Cleary84, Krishnan94, Moffat90, Vitter91]. Indeed, it usually outperforms the Lempel-Ziv algorithm (found in Unix press ) due to implementation considerations and faster convergence rate <ref> [Curewitz93, Bell90, Witten94] </ref>. The PPM algorithm for text compression consists of a predictor to estimate probabilities for characters and an arithmetic encoder. We only make use of the predictor. We encode the outcomes of a branch, taken or not taken, as a 1 or a 0.
Reference: [Eustace95] <author> Eustace, A. and Srivastava, A. </author> <title> ATOM: </title> <booktitle> A flexible interface for building high performance program analysis tools . Proceedings of the Winter 1995 USENIX Technical Conference on UNIX and Advanced Computing Systems, </booktitle> <pages> 303-314, </pages> <month> January </month> <year> 1995. </year>
Reference-contexts: The SPECInt92 programs are not easily analyzed and therefore make ideal candidates for our study to see if a universal predictor like PPM can be used as a tool for characterizing the limits to predictability of programs. We used ATOM <ref> [Eustace95] </ref>, a code instrumentation interface from Digital Equipment Corporation, to conduct our experiments. The benchmarks are first instrumented with ATOM, then executed on a DEC 21064-based workstation running the OSF/1 operating system.
Reference: [Krishnan94] <author> Krishnan, P. and Vitter, J.S. </author> <booktitle> Optimal prediction for prefetching in the worst case . Proceedings of the 5th Annual ACM-SIAM Symposium on Discrete Algorithms, </booktitle> <month> January </month> <year> 1994. </year>
Reference-contexts: In our experiments we draw on these techniques, adapting them to the new context of branch prediction. Prediction by partial matching is a universal compression/prediction algorithm that has been theoretically proven optimal in data compression and prefetching <ref> [Cleary84, Krishnan94, Moffat90, Vitter91] </ref>. Indeed, it usually outperforms the Lempel-Ziv algorithm (found in Unix press ) due to implementation considerations and faster convergence rate [Curewitz93, Bell90, Witten94]. The PPM algorithm for text compression consists of a predictor to estimate probabilities for characters and an arithmetic encoder.
Reference: [Lee84] <author> Lee, J.K.F. and Smith, A.J. </author> <title> Branch prediction strategies and branch target buffer design . IEEE Computer, </title> <journal> Vol. </journal> <volume> 21, No. 7, </volume> <pages> 6-22, </pages> <month> January </month> <year> 1984. </year>
Reference: [Moffat90] <author> Moffat, A. </author> <title> Implementing the PPM data compression scheme . IEEE Transactions on Communications, </title> <journal> Vol. </journal> <volume> 38, No. 11, </volume> <pages> 1917-1921, </pages> <month> November </month> <year> 1990. </year>
Reference-contexts: Universal compression/prediction algorithms are well-understood and have been applied with great success in the fields of text and image compression. More recently, two examples, Lempel-Ziv and prediction by partial matching (PPM) <ref> [Cleary84, Moffat90] </ref> have been successfully applied to prefetching data from disk memories [Vitter91, Curewitz93]. In this paper we used PPM and show that, although designed for text compression, it performs just as well in this new domain of branch prediction. This paper is organized into five sections. <p> In our experiments we draw on these techniques, adapting them to the new context of branch prediction. Prediction by partial matching is a universal compression/prediction algorithm that has been theoretically proven optimal in data compression and prefetching <ref> [Cleary84, Krishnan94, Moffat90, Vitter91] </ref>. Indeed, it usually outperforms the Lempel-Ziv algorithm (found in Unix press ) due to implementation considerations and faster convergence rate [Curewitz93, Bell90, Witten94]. The PPM algorithm for text compression consists of a predictor to estimate probabilities for characters and an arithmetic encoder.
Reference: [MReport95] <institution> Microprocessor Report, Sebastopol, CA: MicroDesign Resources, </institution> <month> March </month> <year> 1995. </year>
Reference-contexts: Note that the chain is incomplete, because of 0 frequency count transitions. Input sequence: 01 11 0/1 1/3 next bit/frequency January 31, 1996 Limits to Branch Prediction 5 2.2 Hardware Branch Predictors Most of todays high performance microprocessors support some form of branch prediction <ref> [ MReport95 ] </ref>.
Reference: [Nair95] <author> Nair, R. </author> <title> Optimal 2-bit branch predictors . IEEE Transactions on Computers, </title> <journal> Vol. </journal> <volume> 44, No. 5, </volume> <pages> 698-702, </pages> <month> May </month> <year> 1995 </year>
Reference: [Sechrest95] <author> Sechrest, S., Lee, C. and Mudge, T. </author> <booktitle> The role of adaptivity in two-level adaptive branch prediction . Proceedings of the 26th Annual International Symposium on Microarchitecture, </booktitle> <address> Ann Arbor, </address> <month> December </month> <year> 1995. </year>
Reference: [Sedgewick92] <author> Sedgewick, R. </author> <title> Algorithms in C++ . Reading, </title> <address> Massachusetts: </address> <publisher> Addison-Wesley, </publisher> <year> 1992. </year>
Reference-contexts: The analysis follows the approach common found in the con crete analysis of algorithms with the conditional branches being the object of interest. We have chosen Quicksort algorithm <ref> [Sedgewick92] </ref> to illustrate this point. 3.1 Description of Quicksort Quicksort is a divide-and-conquer algorithm. It selects an element from the array being sorted as pivot. <p> Quicksort recursively partitions each subarray until the entire array is sorted. Different variations of Quicksort exist, and we have chosen one described in <ref> [Sedgewick92] </ref>. This implementation, shown in Figure 1, first picks the right end element to be the pivot. It also keeps two scan pointers that initially point to the left end element and the next-to-rightmost element respectively. <p> January 31, 1996 Limits to Branch Prediction 9 It is well known that each subarray of each iteration is in random order, i.e., each possible ordering is equally likely <ref> [Sedgewick92] </ref>. The expected predictability for a subarray varies according to the number of elements. It has also been shown that the overall performance of Quicksort coincides, for large enough arrays, with the performance in one iteration of the algorithm on a sufficiently large array. <p> However, we know that the program trace can be com pressed to bits, and no further, since each of the orderings is equally likely a priori. Thus we conclude that Quicksort has almost certainly decisions on aver age. This matches the well-known estimate of the performance of Quicksort <ref> [Sedgewick92] </ref>. Quicksort also provides a simple example of the potential dangers of extrapolating prediction performance from one program run. Suppose the program we run consists of one iteration of the Quicksort algorithm (so that one pivot is chosen).
Reference: [Smith81] <author> Smith, </author> <title> J.E. </title> <booktitle> A study of branch prediction strategies . Proceedings of the 8th International Symposium on Computer Architecture, Minneapolis, </booktitle> <pages> 135-148, </pages> <month> May </month> <year> 1981. </year>
Reference: [Vitter91] <author> Vitter, J.S. and Krishnan, P. </author> <booktitle> Optimal prefetching via data compression . Proceedings of the 32nd Annual IEEE Symposium on Foundations of Computer Science, </booktitle> <address> San Juan, Puerto Rico, 121-130, </address> <month> October </month> <year> 1991. </year>
Reference-contexts: Universal compression/prediction algorithms are well-understood and have been applied with great success in the fields of text and image compression. More recently, two examples, Lempel-Ziv and prediction by partial matching (PPM) [Cleary84, Moffat90] have been successfully applied to prefetching data from disk memories <ref> [Vitter91, Curewitz93] </ref>. In this paper we used PPM and show that, although designed for text compression, it performs just as well in this new domain of branch prediction. This paper is organized into five sections. <p> In our experiments we draw on these techniques, adapting them to the new context of branch prediction. Prediction by partial matching is a universal compression/prediction algorithm that has been theoretically proven optimal in data compression and prefetching <ref> [Cleary84, Krishnan94, Moffat90, Vitter91] </ref>. Indeed, it usually outperforms the Lempel-Ziv algorithm (found in Unix press ) due to implementation considerations and faster convergence rate [Curewitz93, Bell90, Witten94]. The PPM algorithm for text compression consists of a predictor to estimate probabilities for characters and an arithmetic encoder.
Reference: [Witten94] <author> Witten I.H., Moffat, A. </author> <title> and Bell T.C. </title> <address> Managing Gigabytes . New York, NY: </address> <publisher> Van Nostrand Re-inhold, </publisher> <year> 1994. </year>
Reference-contexts: Prediction by partial matching is a universal compression/prediction algorithm that has been theoretically proven optimal in data compression and prefetching [Cleary84, Krishnan94, Moffat90, Vitter91]. Indeed, it usually outperforms the Lempel-Ziv algorithm (found in Unix press ) due to implementation considerations and faster convergence rate <ref> [Curewitz93, Bell90, Witten94] </ref>. The PPM algorithm for text compression consists of a predictor to estimate probabilities for characters and an arithmetic encoder. We only make use of the predictor. We encode the outcomes of a branch, taken or not taken, as a 1 or a 0.
Reference: [Yeh92] <author> Yeh, T-Y. and Patt, Y. </author> <title> Alternative implementation of Two-Level Adaptive Branch Prediction Proceedings of the 19th International Symposium on Computer Architecture, Gold Coast, </title> <booktitle> Aus-tralia, </booktitle> <pages> 124-134, </pages> <month> May </month> <year> 1992. </year>
Reference-contexts: 2-bit schemes [Lee84, Nair95 The 1- and 2-bit schemes as outlined above are examples of per address schemes because a separate 1- or 2- bit counter is associated with each branch in the program. 2.2.2 Two-level adaptive branch predictors Two-level adaptive predictors are among the best predictors currently in use <ref> [Yeh92, Yeh93] </ref>. In the first level, one or more shift registers (branch history registers) are used to record past branch outcomes as a string of 1s and 0s. <p> We also use 2-bit saturating up-down counters for the pattern history table as suggested in <ref> [Yeh92] </ref>. The best results were obtained with a PAp scheme. It is plotted in Figure 6 as the line of closed circular bullets. In practice only GAg or PAg schemes are implemented in hardware. GAp and PAp can quickly become unwieldy.
Reference: [Yeh93] <author> Yeh, T-Y. and Patt, Y. </author> <title> A comparison of dynamic branch predictors that use two levels of branch history . Proceedings of the 20th International Symposium on Computer Architecture, </title> <address> San Di-ego, 257-266, </address> <month> May </month> <year> 1993. </year>
Reference-contexts: 2-bit schemes [Lee84, Nair95 The 1- and 2-bit schemes as outlined above are examples of per address schemes because a separate 1- or 2- bit counter is associated with each branch in the program. 2.2.2 Two-level adaptive branch predictors Two-level adaptive predictors are among the best predictors currently in use <ref> [Yeh92, Yeh93] </ref>. In the first level, one or more shift registers (branch history registers) are used to record past branch outcomes as a string of 1s and 0s.
References-found: 16

