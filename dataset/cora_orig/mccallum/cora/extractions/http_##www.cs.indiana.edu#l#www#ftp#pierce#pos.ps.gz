URL: http://www.cs.indiana.edu/l/www/ftp/pierce/pos.ps.gz
Refering-URL: http://www.cs.indiana.edu/l/www/ftp/pierce/
Root-URL: http://www.cs.indiana.edu
Title: Positive Subtyping  
Author: Martin Hofmann Benjamin Pierce 
Note: To appear in Information and Computation  
Abstract: The statement S T in a -calculus with subtyping is traditionally interpreted by a semantic coercion function of type [[S]]![[T ]] that extracts the "T part" of an element of S. If the subtyping relation is restricted to covariant positions, this interpretation may be enriched to include both the implicit coercion and an overwriting function put[S; T ] 2 [[S]]![[T ]]![[S]] that updates the T part of an element of S. We give a realizability model and a sound equational theory for a second-order calculus of positive subtyping. Though weaker than familiar calculi of bounded quantification, positive subtyping retains sufficient power to model objects, encapsulation, and message passing, and inheritance. The equational laws relating the behavior of coercions and put functions can be used to prove simple properties of the resulting classes in such a way that proofs for superclasses are "inherited" by subclasses. 
Abstract-found: 1
Intro-found: 1
Reference: [Abadi and Cardelli, 1994] <author> Martn Abadi and Luca Cardelli. </author> <title> A theory of primitive objects: Un-typed and first-order systems. </title> <booktitle> In Theoretical Aspects of Computer Software (TACS), Sendai, </booktitle> <address> 34 Japan, </address> <year> 1994. </year>
Reference: [Abadi and Plotkin, 1990] <author> M Abadi and G. D. Plotkin. </author> <title> A PER model of polymorphism and recursive types. </title> <booktitle> In Proc. IEEE Symp. on Logic in Computer Science, </booktitle> <pages> pages 355-365, </pages> <year> 1990. </year>
Reference-contexts: For larger calculi (including, for example, general fixed-point operators or recursive types, which are often found in more sophisticated models of objects and inheritance), the construction of PER models becomes much more complex <ref> [Abadi and Plotkin, 1990, Amadio, 1991] </ref>. In this case, one would instead define an evaluation relation directly on the syntax of terms, extending the reduction rules in Section 3.1. The equational theory of this system would be based on contextual equivalence in the sense of [Gordon, 1994, etc.].
Reference: [Amadio, 1991] <author> Roberto M. Amadio. </author> <title> Recursion over realizability structures. </title> <journal> Information and Computation, </journal> <volume> 90(2) </volume> <pages> 55-85, </pages> <year> 1991. </year>
Reference-contexts: For larger calculi (including, for example, general fixed-point operators or recursive types, which are often found in more sophisticated models of objects and inheritance), the construction of PER models becomes much more complex <ref> [Abadi and Plotkin, 1990, Amadio, 1991] </ref>. In this case, one would instead define an evaluation relation directly on the syntax of terms, extending the reduction rules in Section 3.1. The equational theory of this system would be based on contextual equivalence in the sense of [Gordon, 1994, etc.].
Reference: [Breazu-Tannen et al., 1991] <author> Val Breazu-Tannen, Thierry Coquand, Carl Gunter, and Andre Sce-drov. </author> <title> Inheritance as implicit coercion. </title> <journal> Information and Computation, </journal> <volume> 93 </volume> <pages> 172-221, </pages> <year> 1991. </year> <editor> Also in Carl A. Gunter and John C. Mitchell, editors, </editor> <title> Theoretical Aspects of Object-Oriented Programming: Types, Semantics, </title> <publisher> and Language Design (MIT Press, </publisher> <year> 1994). </year>
Reference-contexts: Although our development is self-contained, readers may like to compare our system with standard bounded quantification calculi [Curien and Ghelli, 1992, Cardelli et al., 1994] and semantic 3 models of subtyping <ref> [Bruce and Longo, 1990, Breazu-Tannen et al., 1991] </ref>. In Section 6, famil-iarity with the literature on type-theoretic models of object-oriented programming languages [Fisher and Mitchell, 1994, Abadi and Cardelli, 1994, Bruce, 1994, Pierce and Turner, 1994, etc.] may be helpful. <p> However, we conjecture that the reduction relation can be shown to be strongly normalizing by a translation into pure System F (cf. <ref> [Breazu-Tannen et al., 1991] </ref>). <p> But this is an instance of the induction hypothesis, since ([Y 7! p]; t [Y 7! R]) j= ; XU; ; Y V . 2 Our aim is to give meaning to raw terms rather than typing derivations in order to avoid coherence considerations (cf. <ref> [Breazu-Tannen et al., 1991] </ref>). In particular, the interpretation should be independent of particular instances of the subsumption rule. But since the interpretation of put [S; T ] via the Put function is context dependent, we do have to make contexts part of the interpretation of terms. <p> Proof: By induction over a derivation of ` e 2 T . The cases for variables, abstractions, applications, pairing, projections, and subsumption follow the standard pattern for per semantics of F <ref> [Bruce and Longo, 1990, Breazu-Tannen et al., 1991] </ref>. More interesting are the cases for type abstraction, type application, and put ; we consider these in order. <p> obtained for our calculus based on a translation into pure system F upon which a quantified type All (XT ) : : : would be translated into a relativized quantification All (X)(X!T ) ! (X!T !X) ! : : : generalizing the "Penn translation" of F into pure system F <ref> [Breazu-Tannen et al., 1991] </ref>.
Reference: [Bruce and Longo, 1990] <author> Kim B. Bruce and Giuseppe Longo. </author> <title> A modest model of records, inheritance, and bounded quantification. </title> <journal> Information and Computation, </journal> <volume> 87 </volume> <pages> 196-240, </pages> <year> 1990. </year> <editor> Also in Carl A. Gunter and John C. Mitchell, editors, </editor> <title> Theoretical Aspects of Object-Oriented Programming: Types, Semantics, </title> <publisher> and Language Design (MIT Press, </publisher> <year> 1994). </year> <note> An earlier version appeared in the proceedings of the IEEE Symposium on Logic in Computer Science, </note> <year> 1988. </year>
Reference-contexts: Although our development is self-contained, readers may like to compare our system with standard bounded quantification calculi [Curien and Ghelli, 1992, Cardelli et al., 1994] and semantic 3 models of subtyping <ref> [Bruce and Longo, 1990, Breazu-Tannen et al., 1991] </ref>. In Section 6, famil-iarity with the literature on type-theoretic models of object-oriented programming languages [Fisher and Mitchell, 1994, Abadi and Cardelli, 1994, Bruce, 1994, Pierce and Turner, 1994, etc.] may be helpful. <p> Proof: By induction over a derivation of ` e 2 T . The cases for variables, abstractions, applications, pairing, projections, and subsumption follow the standard pattern for per semantics of F <ref> [Bruce and Longo, 1990, Breazu-Tannen et al., 1991] </ref>. More interesting are the cases for type abstraction, type application, and put ; we consider these in order.
Reference: [Bruce, 1994] <author> Kim B. Bruce. </author> <title> A paradigmatic object-oriented programming language: Design, static typing and semantics. </title> <journal> Journal of Functional Programming, </journal> <volume> 4(2), </volume> <month> April </month> <year> 1994. </year> <title> A preliminary version appeared in POPL 1993 under the title "Safe Type Checking in a Statically Typed Object-Oriented Programming Language". </title>
Reference: [Cardelli and Longo, 1991] <author> Luca Cardelli and Giuseppe Longo. </author> <title> A semantic basis for Quest. </title> <journal> Journal of Functional Programming, </journal> <volume> 1(4) </volume> <pages> 417-458, </pages> <month> October </month> <year> 1991. </year> <note> Preliminary version in ACM Conference on Lisp and Functional Programming, June 1990. Also available as DEC SRC Research Report 55, </note> <month> Feb. </month> <year> 1990. </year>
Reference-contexts: This law should give rise to a polymorphic put function put [F; G] 2 All (X) F (X) ! G (X) ! F (X). We expect that our semantics for positive F can be extended straightforwardly to this higher-order calculus using the techniques of <ref> [Cardelli and Longo, 1991, Compagnoni and Pierce, 1995] </ref>. A further extension would accommodate covariance and functorial strength as in [Hofmann and Pierce, 1995], which would provide generic functions for method invocation and also allow automatic insertion of put functions in class definitions.
Reference: [Cardelli and Mitchell, 1991] <author> Luca Cardelli and John Mitchell. </author> <title> Operations on records. </title> <booktitle> Mathematical Structures in Computer Science, </booktitle> <volume> 1 </volume> <pages> 3-48, </pages> <year> 1991. </year> <editor> Also in Carl A. Gunter and John C. Mitchell, editors, </editor> <title> Theoretical Aspects of Object-Oriented Programming: Types, Semantics, and Language Design (MIT Press, </title> <note> 1994); available as DEC Systems Research Center Research Report #48, </note> <month> August, </month> <year> 1989, </year> <booktitle> and in the proceedings of MFPS '89, </booktitle> <publisher> Springer LNCS volume 442. </publisher>
Reference-contexts: But all instances of f have the same behavior, so they are all identities.) This deficiency has led to proposals for enriching the language of types so that in-place modifications of records may be given sound typings <ref> [Cardelli and Mitchell, 1991, Cardelli, 1992] </ref>. But the complexity of these extensions has hindered their widespread acceptance. We propose here a more radical approach: modify the semantics of subtyping to include both projection and update, so that the naive polymorphic typing of bump becomes sound.
Reference: [Cardelli and Wegner, 1985] <author> Luca Cardelli and Peter Wegner. </author> <title> On understanding types, data abstraction, and polymorphism. </title> <journal> Computing Surveys, </journal> <volume> 17(4), </volume> <month> December </month> <year> 1985. </year>
Reference-contexts: S R ` R T (S-Trans) ` S 2 T 2 (S-Arrow) ; XU ` S 2 T 2 (S-All) ` S 1 fiS 2 T 1 fiT 2 (S-Prod) Except for S-Arrow, these are exactly the subtyping rules of F (more precisely, of the Kernel Fun variant of F <ref> [Cardelli and Wegner, 1985] </ref>; full F [Curien and Ghelli, 1992, Cardelli et al., 1994] uses a richer, but problematic, version of S-All; see [Pierce, 1994, Pierce and Steffen, 1995]).
Reference: [Cardelli et al., 1994] <author> Luca Cardelli, Simone Martini, John C. Mitchell, and Andre Scedrov. </author> <title> An extension of system F with subtyping. </title> <journal> Information and Computation, </journal> <note> 109(1-2):4-56, 1994. A preliminary version appeared in TACS '91 (Sendai, Japan, pp. 750-770). </note>
Reference-contexts: In Sections 2, 3, and 4, we introduce the syntax, equational theory, and semantics of a positive variant of the calculus F of second-order bounded quantification <ref> [Cardelli et al., 1994, Curien and Ghelli, 1992] </ref>. Section 5 gives a small example, showing how updateable records can be encoded in this system. <p> Although our development is self-contained, readers may like to compare our system with standard bounded quantification calculi <ref> [Curien and Ghelli, 1992, Cardelli et al., 1994] </ref> and semantic 3 models of subtyping [Bruce and Longo, 1990, Breazu-Tannen et al., 1991]. <p> ` S 2 T 2 (S-Arrow) ; XU ` S 2 T 2 (S-All) ` S 1 fiS 2 T 1 fiT 2 (S-Prod) Except for S-Arrow, these are exactly the subtyping rules of F (more precisely, of the Kernel Fun variant of F [Cardelli and Wegner, 1985]; full F <ref> [Curien and Ghelli, 1992, Cardelli et al., 1994] </ref> uses a richer, but problematic, version of S-All; see [Pierce, 1994, Pierce and Steffen, 1995]). <p> The term "algorithmic" is intended to suggest that these derivations correspond to the succeeding traces of a decision procedure for the subtype relation. 2.1.2 Fact: If ` S T , then there is an algorithmic derivation with this conclusion. Proof: Easy simplification of the standard proof <ref> [Curien and Ghelli, 1992, Cardelli et al., 1994] </ref>. 2 One application of this fact will be needed in the next section: 2.1.3 Lemma: If ` All (XS 1 ) S 2 All (XT 1 ) T 2 , then S 1 = T 1 . <p> If T = T 1 fiT 2 , then there is a product-minimal derivation of ` e 2 S 1 fiS 2 for some S 1 and S 2 . Proof: An execution trace of the standard type synthesis algorithm for F <ref> [Curien and Ghelli, 1992, Cardelli et al., 1994] </ref> can be viewed as a minimal derivation for a term. (Strictly speaking, an easy extension to Curien and Ghelli's algorithm is needed to handle product types.) Part (2) follows from the standard observation that, if a term e has any arrow type, then
Reference: [Cardelli, 1984] <author> Luca Cardelli. </author> <title> A semantics of multiple inheritance. </title> <editor> In G. Kahn, D. MacQueen, and G. Plotkin, editors, </editor> <booktitle> Semantics of Data Types, volume 173 of Lecture Notes in Computer Science, </booktitle> <pages> pages 51-67. </pages> <publisher> Springer-Verlag, </publisher> <year> 1984. </year> <note> Full version in Information and Computation </note> 76(2/3):138-164, 1988. 
Reference-contexts: standard rules for introduction and elimination of functional and quantified types; T-Prod-I, T-Prod-E1, and T-Prod-E2 give pairing and projection; T-Put allows put [S; T ] to be used as a function of the appropriate shape whenever S T ; T-Sub is the rule of subsumption characteristic of -calculi with subtyping <ref> [Cardelli, 1984, Reynolds, 1985] </ref>. Again, we shall need a few simple facts about this definition. 6 2.2.1 Definition: Let d be a derivation of a statement ` e 2 S.
Reference: [Cardelli, 1990] <author> Luca Cardelli. </author> <title> Notes about F ! &lt;: </title> . <type> Unpublished manuscript, </type> <month> October </month> <year> 1990. </year>
Reference-contexts: Moreover, we foresee no barriers to integrating features such as higher-order subtyp-ing <ref> [Cardelli, 1990, Compagnoni, 1994, Pierce and Steffen, 1995] </ref> and partial functions, extending our simple example to a full-scale model of object-oriented programming. <p> if e 2 fx:Int ; c:Color g, then put [fx:Int ; c:Color g; fx:Int g] e fx=7g = e 2 fc:Color g by Proposition 3.4.3. 6 Application to Objects and Inheritance Pierce and Turner [1994] presented a model of objects, message-passing, and inheritance based on the typed -calculus F ! <ref> [Cardelli, 1990, Compagnoni, 1994, Pierce and Steffen, 1995] </ref>, an extension of F with higher-order polymorphism. <p> For them, the "smaller" relation denotes set-theoretic inclusion, which, as in our calculus, requires a restriction of function subtyping to the covariant case. Another useful extension of positive F (or of full F with a distinguished positive fragment) would allow F ! -style type operators, as in <ref> [Cardelli, 1990, Pierce and Steffen, 1995, Compagnoni, 1994] </ref>. The subtyping rule for type operators is just the extension of the positive subtype relation on their codomains: if F (T ) G (T ) for every T , then F G.
Reference: [Cardelli, 1992] <author> Luca Cardelli. </author> <title> Extensible records in a pure calculus of subtyping. Research re port 81, </title> <institution> DEC Systems Research Center, </institution> <month> January </month> <year> 1992. </year> <editor> Also in Carl A. Gunter and John C. 35 Mitchell, editors, </editor> <title> Theoretical Aspects of Object-Oriented Programming: Types, Semantics, </title> <publisher> and Language Design (MIT Press, </publisher> <year> 1994). </year>
Reference-contexts: But all instances of f have the same behavior, so they are all identities.) This deficiency has led to proposals for enriching the language of types so that in-place modifications of records may be given sound typings <ref> [Cardelli and Mitchell, 1991, Cardelli, 1992] </ref>. But the complexity of these extensions has hindered their widespread acceptance. We propose here a more radical approach: modify the semantics of subtyping to include both projection and update, so that the naive polymorphic typing of bump becomes sound.
Reference: [Compagnoni and Pierce, 1995] <author> Adriana B. Compagnoni and Benjamin C. Pierce. </author> <title> Multiple inheritance via intersection types. </title> <note> Mathematical Structures in Computer Science, 1995. To appear. Preliminary version available as University of Edinburgh technical report ECS-LFCS-93-275 and Catholic University Nijmegen computer science technical report 93-18, </note> <month> Aug. </month> <year> 1993. </year>
Reference-contexts: This law should give rise to a polymorphic put function put [F; G] 2 All (X) F (X) ! G (X) ! F (X). We expect that our semantics for positive F can be extended straightforwardly to this higher-order calculus using the techniques of <ref> [Cardelli and Longo, 1991, Compagnoni and Pierce, 1995] </ref>. A further extension would accommodate covariance and functorial strength as in [Hofmann and Pierce, 1995], which would provide generic functions for method invocation and also allow automatic insertion of put functions in class definitions.
Reference: [Compagnoni, 1994] <author> Adriana B. Compagnoni. </author> <title> Subtyping in F ! ^ is decidable. </title> <type> Technical Report ECS-LFCS-94-281, </type> <institution> LFCS, University of Edinburgh, </institution> <month> January </month> <year> 1994. </year> <note> To appear in the proceedings of Computer Science Logic, </note> <month> September </month> <year> 1994, </year> <title> under the title "Decidability of Higher-Order Subtyping with Intersection Types". </title>
Reference-contexts: Moreover, we foresee no barriers to integrating features such as higher-order subtyp-ing <ref> [Cardelli, 1990, Compagnoni, 1994, Pierce and Steffen, 1995] </ref> and partial functions, extending our simple example to a full-scale model of object-oriented programming. <p> if e 2 fx:Int ; c:Color g, then put [fx:Int ; c:Color g; fx:Int g] e fx=7g = e 2 fc:Color g by Proposition 3.4.3. 6 Application to Objects and Inheritance Pierce and Turner [1994] presented a model of objects, message-passing, and inheritance based on the typed -calculus F ! <ref> [Cardelli, 1990, Compagnoni, 1994, Pierce and Steffen, 1995] </ref>, an extension of F with higher-order polymorphism. <p> For them, the "smaller" relation denotes set-theoretic inclusion, which, as in our calculus, requires a restriction of function subtyping to the covariant case. Another useful extension of positive F (or of full F with a distinguished positive fragment) would allow F ! -style type operators, as in <ref> [Cardelli, 1990, Pierce and Steffen, 1995, Compagnoni, 1994] </ref>. The subtyping rule for type operators is just the extension of the positive subtype relation on their codomains: if F (T ) G (T ) for every T , then F G.
Reference: [Cook, 1989] <author> William Cook. </author> <title> A Denotational Semantics of Inheritance. </title> <type> PhD thesis, </type> <institution> Brown Univer sity, </institution> <year> 1989. </year>
Reference-contexts: In particular, we need a notation for predicates on programs and a framework for showing that a function preserves a predicate. Second, to assign a value to self when creating objects, a fixed-point combinator is needed <ref> [Cook, 1989, Kamin and Reddy, 1994] </ref>. Such combinators come in several forms, with varying degrees of power and technical complexity. <p> In the theoretical literature on object-oriented languages, this feature has been modeled by abstracting the methods of classes on a variable self , which is supplied at instantiation time using a fixed-point operator <ref> [Cook, 1989, etc.] </ref>. In the present framework, this extension is accomplished by altering the type of classes as follows: Class (M; R) = All (SR) M (S) ! M (S): The constructors Object and object need not be changed.
Reference: [Curien and Ghelli, 1992] <author> Pierre-Louis Curien and Giorgio Ghelli. </author> <title> Coherence of subsumption: Minimum typing and type-checking in F . Mathematical Structures in Computer Science, </title> <booktitle> 2 </booktitle> <pages> 55-91, </pages> <year> 1992. </year> <editor> Also in Carl A. Gunter and John C. Mitchell, editors, </editor> <title> Theoretical Aspects of Object-Oriented Programming: Types, Semantics, </title> <publisher> and Language Design (MIT Press, </publisher> <year> 1994). </year>
Reference-contexts: In Sections 2, 3, and 4, we introduce the syntax, equational theory, and semantics of a positive variant of the calculus F of second-order bounded quantification <ref> [Cardelli et al., 1994, Curien and Ghelli, 1992] </ref>. Section 5 gives a small example, showing how updateable records can be encoded in this system. <p> Although our development is self-contained, readers may like to compare our system with standard bounded quantification calculi <ref> [Curien and Ghelli, 1992, Cardelli et al., 1994] </ref> and semantic 3 models of subtyping [Bruce and Longo, 1990, Breazu-Tannen et al., 1991]. <p> ` S 2 T 2 (S-Arrow) ; XU ` S 2 T 2 (S-All) ` S 1 fiS 2 T 1 fiT 2 (S-Prod) Except for S-Arrow, these are exactly the subtyping rules of F (more precisely, of the Kernel Fun variant of F [Cardelli and Wegner, 1985]; full F <ref> [Curien and Ghelli, 1992, Cardelli et al., 1994] </ref> uses a richer, but problematic, version of S-All; see [Pierce, 1994, Pierce and Steffen, 1995]). <p> The term "algorithmic" is intended to suggest that these derivations correspond to the succeeding traces of a decision procedure for the subtype relation. 2.1.2 Fact: If ` S T , then there is an algorithmic derivation with this conclusion. Proof: Easy simplification of the standard proof <ref> [Curien and Ghelli, 1992, Cardelli et al., 1994] </ref>. 2 One application of this fact will be needed in the next section: 2.1.3 Lemma: If ` All (XS 1 ) S 2 All (XT 1 ) T 2 , then S 1 = T 1 . <p> If T = T 1 fiT 2 , then there is a product-minimal derivation of ` e 2 S 1 fiS 2 for some S 1 and S 2 . Proof: An execution trace of the standard type synthesis algorithm for F <ref> [Curien and Ghelli, 1992, Cardelli et al., 1994] </ref> can be viewed as a minimal derivation for a term. (Strictly speaking, an easy extension to Curien and Ghelli's algorithm is needed to handle product types.) Part (2) follows from the standard observation that, if a term e has any arrow type, then
Reference: [de Bruijn, 1972] <author> Nicolas G. de Bruijn. </author> <title> Lambda-calculus notation with nameless dummies: a tool for automatic formula manipulation with application to the Church-Rosser theorem. </title> <journal> Indag. Math., </journal> <volume> 34(5) </volume> <pages> 381-392, </pages> <year> 1972. </year>
Reference-contexts: This is equivalent to regarding alphabetic variable names as informal abbreviations for an underlying representation based on de Bruijn indices <ref> [de Bruijn, 1972] </ref>, and implies the usual conventions about name capture during substitution, alpha-conversion, side-conditions concerning freshness of names, etc.
Reference: [Fisher and Mitchell, 1994] <author> Kathleen Fisher and John Mitchell. </author> <booktitle> Notes on typed object-oriented programming. In Proceedings of Theoretical Aspects of Computer Software, Sendai, Japan, </booktitle> <pages> pages 844-885. </pages> <publisher> Springer-Verlag, </publisher> <month> April </month> <year> 1994. </year> <note> LNCS 789. </note>
Reference: [Gordon, 1994] <author> Andrew D. Gordon. </author> <title> Functional Programming and Input/Output. </title> <publisher> Cambridge Uni versity Press, </publisher> <year> 1994. </year>
Reference-contexts: In this case, one would instead define an evaluation relation directly on the syntax of terms, extending the reduction rules in Section 3.1. The equational theory of this system would be based on contextual equivalence in the sense of <ref> [Gordon, 1994, etc.] </ref>. Acknowledgements This research was carried out at the University of Edinburgh's Lab for Foundations of Computer Science. Hofmann was supported by a European Union HCM fellowship. Pierce was supported by a fellowship from the British Science and Engineering Research Council.
Reference: [Gunter, 1992] <author> C. A. Gunter. </author> <title> Semantics of Programming Languages: Structures and Techniques. </title> <publisher> The MIT Press, </publisher> <address> Cambridge, MA, </address> <year> 1992. </year>
Reference-contexts: In this case we say that A is a subper of B. 4.1.1 Fact: Let A and B be pers and m; n 2 dom (A!B). Then m fA!Bg n iff 8x2 dom (A): m x fBg n x: For more information on standard properties of pers, see <ref> [Gunter, 1992] </ref>. 4.2 The Interpretation of Subtyping 4.2.2 Definition: We say that A is an updateable subper of B and write A B, if A is a subper of B and there exists a morphism p 2 A ! (B!A) satisfying the three put-equations from 3.2.1.
Reference: [Hofmann and Pierce, 1995] <author> Martin Hofmann and Benjamin Pierce. </author> <title> A unifying type-theoretic framework for objects. </title> <journal> Journal of Functional Programming, </journal> <note> 1995. To appear. Previous versions appeared in the Symposium on Theoretical Aspects of Computer Science, </note> <year> 1994, </year> <title> (pages 251-262) and, under the title "An Abstract View of Objects and Subtyping (Preliminary Report)," as University of Edinburgh, </title> <type> LFCS technical report ECS-LFCS-92-226, </type> <year> 1992. </year>
Reference-contexts: Similarly, object types must be invariant under the positive subtyping relation: we have Object (M ) Object (N ) only when the interface signatures M and N are identical. When object types are modeled using existential types <ref> [Pierce and Turner, 1994, Hofmann and Pierce, 1995] </ref>, this invariance arises from the considerations above. More generally, it does not seem reasonable to expect any encoding of objects to support positive subtyping between object types. <p> have to leave the position unchanged. (It is illustrative to try defining an update function for the points and colored points of Section 6.3.) It seems possible to get along without subsumption for object types, both in the object-oriented examples of Section 6 and in the more general constructions in <ref> [Pierce and Turner, 1994, Hofmann and Pierce, 1995] </ref>, at the cost of replacing some implicit coercions between object types by polymorphic type applications. Suppose we want to define a function f that operates on both points and colored points. <p> We expect that our semantics for positive F can be extended straightforwardly to this higher-order calculus using the techniques of [Cardelli and Longo, 1991, Compagnoni and Pierce, 1995]. A further extension would accommodate covariance and functorial strength as in <ref> [Hofmann and Pierce, 1995] </ref>, which would provide generic functions for method invocation and also allow automatic insertion of put functions in class definitions.
Reference: [Kamin and Reddy, 1994] <author> Samuel N. Kamin and Uday S. Reddy. </author> <title> Two semantic models of object-oriented languages. </title> <editor> In Carl A. Gunter and John C. Mitchell, editors, </editor> <booktitle> Theoretical Aspects of Object-Oriented Programming: Types, Semantics, and Language Design, </booktitle> <pages> pages 464-495. </pages> <publisher> The MIT Press, </publisher> <year> 1994. </year>
Reference-contexts: In particular, we need a notation for predicates on programs and a framework for showing that a function preserves a predicate. Second, to assign a value to self when creating objects, a fixed-point combinator is needed <ref> [Cook, 1989, Kamin and Reddy, 1994] </ref>. Such combinators come in several forms, with varying degrees of power and technical complexity.
Reference: [Leavens and Weihl, 1992] <author> Gary T. Leavens and William E. Weihl. </author> <title> Subtyping, modular specification, and modular verification for applicative object-oriented programs. </title> <type> Technical Report TR#92-28d, </type> <institution> Department of Computer Science, Iowa State University, </institution> <month> September </month> <year> 1992. </year> <note> Revised September, October 1993, and January, 1994. Portions to appear in Acta Informatica. 36 </note>
Reference-contexts: Naraschewski, in collaboration with Hofmann, has used the LEGO proof checker to experiment with mechanical verification of object-oriented programs along similar lines [Naraschewski, 1994]. The relationship of these reasoning techniques to the literature on non-type-theoretic object oriented verification (see, e.g., <ref> [Leavens and Weihl, 1992] </ref>) remains unexplored. 6.1 Technical Preliminaries Before starting, we need a little technical machinery. First, we want a logic in which proofs about programs may be phrased | a many-sorted, first-order extension of the equational theory given in Section 3.
Reference: [Mart-Oliet and Meseguer, 1990] <author> Narciso Mart-Oliet and Jose Meseguer. </author> <title> Inclusions and subtypes. </title> <type> Technical Report SRI-CSL-90-16, </type> <institution> Computer Science Laboratory, SRI International, </institution> <month> December </month> <year> 1990. </year>
Reference: [Naraschewski, 1994] <author> Wolfgang Naraschewski. </author> <title> Verifikation objektorientierter Programme mit Lego. </title> <type> Studienarbeit, </type> <institution> Universitat Erlangen, </institution> <year> 1994. </year> <note> To appear. </note>
Reference-contexts: Naraschewski, in collaboration with Hofmann, has used the LEGO proof checker to experiment with mechanical verification of object-oriented programs along similar lines <ref> [Naraschewski, 1994] </ref>. The relationship of these reasoning techniques to the literature on non-type-theoretic object oriented verification (see, e.g., [Leavens and Weihl, 1992]) remains unexplored. 6.1 Technical Preliminaries Before starting, we need a little technical machinery.
Reference: [Oles, 1985] <author> Frank J. Oles. </author> <title> Type algebras, functor categories, and block structure. </title> <editor> In Maurice Nivat and John C. Reynolds, editors, </editor> <title> Algebraic Methods in Semantics. </title> <publisher> Cambrige University Press, </publisher> <year> 1985. </year>
Reference: [Pierce and Steffen, 1995] <author> Benjamin Pierce and Martin Steffen. </author> <title> Higher-order subtyping. </title> <booktitle> Theoretical Computer Science, </booktitle> <year> 1995. </year> <note> To appear. A preliminary version appeared in IFIP Working Conference on Programming Concepts, Methods and Calculi (PROCOMET), June 1994, and as University of Edinburgh technical report ECS-LFCS-94-280 and Universitat Erlangen-Nurnberg Interner Bericht IMMD7-01/94, </note> <month> January </month> <year> 1994. </year>
Reference-contexts: Moreover, we foresee no barriers to integrating features such as higher-order subtyp-ing <ref> [Cardelli, 1990, Compagnoni, 1994, Pierce and Steffen, 1995] </ref> and partial functions, extending our simple example to a full-scale model of object-oriented programming. <p> fiS 2 T 1 fiT 2 (S-Prod) Except for S-Arrow, these are exactly the subtyping rules of F (more precisely, of the Kernel Fun variant of F [Cardelli and Wegner, 1985]; full F [Curien and Ghelli, 1992, Cardelli et al., 1994] uses a richer, but problematic, version of S-All; see <ref> [Pierce, 1994, Pierce and Steffen, 1995] </ref>). <p> if e 2 fx:Int ; c:Color g, then put [fx:Int ; c:Color g; fx:Int g] e fx=7g = e 2 fc:Color g by Proposition 3.4.3. 6 Application to Objects and Inheritance Pierce and Turner [1994] presented a model of objects, message-passing, and inheritance based on the typed -calculus F ! <ref> [Cardelli, 1990, Compagnoni, 1994, Pierce and Steffen, 1995] </ref>, an extension of F with higher-order polymorphism. <p> For them, the "smaller" relation denotes set-theoretic inclusion, which, as in our calculus, requires a restriction of function subtyping to the covariant case. Another useful extension of positive F (or of full F with a distinguished positive fragment) would allow F ! -style type operators, as in <ref> [Cardelli, 1990, Pierce and Steffen, 1995, Compagnoni, 1994] </ref>. The subtyping rule for type operators is just the extension of the positive subtype relation on their codomains: if F (T ) G (T ) for every T , then F G.
Reference: [Pierce and Turner, 1994] <author> Benjamin C. Pierce and David N. Turner. </author> <title> Simple type-theoretic foundations for object-oriented programming. </title> <journal> Journal of Functional Programming, </journal> <volume> 4(2) </volume> <pages> 207-247, </pages> <month> April </month> <year> 1994. </year> <note> A preliminary version appeared in Principles of Programming Languages, </note> <year> 1993, </year> <title> and as University of Edinburgh technical report ECS-LFCS-92-225, under the title "Object-Oriented Programming Without Recursive Types". </title>
Reference-contexts: Our account of inheritance based on positive subtyping extends the treatment in <ref> [Pierce and Turner, 1994] </ref> in two ways. First, since updating is built in, we obtain a much simpler inheritance operation which avoids explicit handling of update functions. Second, using the equational theory we can reason about object-oriented programs and structure proofs and specifications along the hierarchy of inheritance. <p> (s:PointR) fx = 1 + s:xgg An object with this representation and collection of methods would then be built by applying object to m and an appropriate initial state: p = object PointM (PointR; fx = 0g; m): Object and object can be encoded in pure F using existential types <ref> [Pierce and Turner, 1994] </ref>, but we are more interested here in convenient ways of constructing the record of methods m. (In the positive subtype relation, Object turns out to be an invariant type constructor, rather than covariant as is usually expected; we return to this point in Section 7.) A class <p> PointR] s fx = 1 + s:xgg 2 Class (PointM ; PointR): 28 This class can be instantiated as follows, yielding a point with the same behavior as p: myPoint = object PointM (PointR; fx = 0g; simplePointClass PointR) This presentation of classes is significantly cleaner than the one in <ref> [Pierce and Turner, 1994] </ref>, which required that the coercion and update functions connecting R and S be managed explicitly by the programmer. <p> More importantly, we can use the equational theory of Section 3 to reason about such classes | something that is not just inconvenient but impossible in low-level models like <ref> [Pierce and Turner, 1994] </ref>, where the connecting functions are carried by ordinary variables with no special properties. <p> Similarly, object types must be invariant under the positive subtyping relation: we have Object (M ) Object (N ) only when the interface signatures M and N are identical. When object types are modeled using existential types <ref> [Pierce and Turner, 1994, Hofmann and Pierce, 1995] </ref>, this invariance arises from the considerations above. More generally, it does not seem reasonable to expect any encoding of objects to support positive subtyping between object types. <p> have to leave the position unchanged. (It is illustrative to try defining an update function for the points and colored points of Section 6.3.) It seems possible to get along without subsumption for object types, both in the object-oriented examples of Section 6 and in the more general constructions in <ref> [Pierce and Turner, 1994, Hofmann and Pierce, 1995] </ref>, at the cost of replacing some implicit coercions between object types by polymorphic type applications. Suppose we want to define a function f that operates on both points and colored points.
Reference: [Pierce, 1994] <author> Benjamin C. Pierce. </author> <title> Bounded quantification is undecidable. </title> <journal> Information and Computation, </journal> <volume> 112(1) </volume> <pages> 131-165, </pages> <month> July </month> <year> 1994. </year> <editor> Also in Carl A. Gunter and John C. Mitchell, editors, </editor> <title> Theoretical Aspects of Object-Oriented Programming: Types, Semantics, </title> <publisher> and Language Design (MIT Press, </publisher> <year> 1994). </year> <note> A preliminary version appeared in POPL '92. </note>
Reference-contexts: fiS 2 T 1 fiT 2 (S-Prod) Except for S-Arrow, these are exactly the subtyping rules of F (more precisely, of the Kernel Fun variant of F [Cardelli and Wegner, 1985]; full F [Curien and Ghelli, 1992, Cardelli et al., 1994] uses a richer, but problematic, version of S-All; see <ref> [Pierce, 1994, Pierce and Steffen, 1995] </ref>).
Reference: [Reynolds, 1985] <author> John Reynolds. </author> <title> Three approaches to type structure. </title> <booktitle> In Mathematical Foundations of Software Development. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1985. </year> <note> Lecture Notes in Computer Science No. 185. </note>
Reference-contexts: standard rules for introduction and elimination of functional and quantified types; T-Prod-I, T-Prod-E1, and T-Prod-E2 give pairing and projection; T-Put allows put [S; T ] to be used as a function of the appropriate shape whenever S T ; T-Sub is the rule of subsumption characteristic of -calculi with subtyping <ref> [Cardelli, 1984, Reynolds, 1985] </ref>. Again, we shall need a few simple facts about this definition. 6 2.2.1 Definition: Let d be a derivation of a statement ` e 2 S.
Reference: [Robinson and Tennent, 1988] <author> Edmund Robinson and Robert Tennent. </author> <title> Bounded quantification and record-update problems. Message to Types electronic mail list, </title> <month> October </month> <year> 1988. </year> <month> 37 </month>
Reference-contexts: Unfortunately, given the standard interpretation of subtyping, this type is not inhabited by any useful functions <ref> [Robinson and Tennent, 1988] </ref>. In effect, the constraint Xfx:Int g is too weak to allow an element e of X to be manipulated in any nontrivial way, aside from throwing away all the information in e except the x field.
References-found: 32

