URL: http://www.cs.utexas.edu/users/moore/publications/km94.ps.Z
Refering-URL: http://www.cs.utexas.edu/users/moore/publications/index.html
Root-URL: 
Title: Design Goals for ACL2  
Author: Matt Kaufmann and J Strother Moore 
Address: 1717 West Sixth Street, Suite 290 Austin, Texas 78703-4776  
Affiliation: Computational Logic, Inc.  
Pubnum: Technical Report  
Email: EMAIL: kaufmann@cli.com and moore@cli.com  
Phone: TEL: +1 512 322 9951  
Date: 101 August, 1994  
Abstract: This work was supported in part at Computational Logic, Inc., by the Defense Advanced Research Projects Agency, ARPA Order 7406. The views and conclusions contained in this document are those of the author(s) and should not be interpreted as representing the official policies, either expressed or implied, of Computational Logic, Inc., the Defense Advanced Research Projects Agency or the U.S. Government. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> R. L. Akers. </author> <title> Strong Static Type Checking for Functional Common Lisp. </title> <type> Ph.D. Thesis, </type> <institution> University of Texas at Austin, </institution> <year> 1993. </year> <note> Also available through Computational Logic, </note> <institution> Inc., </institution> <address> Suite 290, 1717 West Sixth Street, Austin, TX 78703. </address>
Reference-contexts: Because guards are arbitrary expressions, guard verification is, in general, undecidable. But if guards are primitive type expressions on the formals, guard verification is usually a trivial theorem proving problem and can be done by special syntactic means. Some work is this direction has already been done <ref> [1] </ref>. Admissibility does not require guard verification: termination of the recursion can be proved without necessarily showing that all subfunctions are well-defined.
Reference: [2] <author> K. Albin. </author> <title> 68020 Model Validation Testing, </title> <note> CLI Note 280, </note> <month> August </month> <year> 1993. </year>
Reference-contexts: To do so, CLI tested it against an MC68020 chip in the form of a Sun 3 workstation. Over 30,000 test vectors were executed both in the Nqthm model of the MC68020 and on an actual chip <ref> [2] </ref>. Again, the importance of the executability of the Nqthm model is obvious.
Reference: [3] <author> W. R. Bevier. </author> <title> A Verified Operating System Kernel. </title> <type> Ph.D. Thesis, </type> <institution> University of Texas at Austin, </institution> <year> 1987. </year> <note> Also available through Computational Logic, </note> <institution> Inc., </institution> <address> Suite 290, 1717 West Sixth Street, Austin, TX 78703. </address>
Reference-contexts: Finally, the correctness of the interactive convergence clock synchronization algorithm was proved [38]. * Scheduling, Concurrency, and Distributed Computing Nqthm has been used to prove that an operating system implemented in machine code on a uniprocessor correctly provides multitasking and task isolation and communication <ref> [3] </ref>. An Nqthm formalization of Misra and Chandy's Unity language [14] is described in [16, 17] along with the proofs of several Unity programs. An Nqthm-checked proof that an earliest-deadline-first (EDF) scheduler is optimal is proved in [37].
Reference: [4] <author> W. R. Bevier, W. A. Hunt, J S. Moore, and W.D. Young. </author> <title> Special Issue on System Verification. </title> <journal> Journal of Automated Reasoning, </journal> <volume> 5(4), </volume> <pages> 409-530, </pages> <year> 1989. </year>
Reference-contexts: Furthermore, the clock functions can be composed so that it is possible to say how many microcycles are necessary to do a given high-level computation. This work consumed several man years and is described in <ref> [4] </ref>. * Hardware Verification and System Maintenance Since the publication of the short stack work, CLI has designed, verified, and fabricated another microprocessor, called the FM9001 [19]. <p> We reconsider briefly several of the applications. 3.3.1 The CLI Short Stack Consider the Piton task in the CLI short stack project <ref> [4] </ref>. The task was to design an assembly-level language for the FM8502 suitable as the target language for high-level language compilers, implement the language via an assembler and linker, and verify the correctness of the implementation mechanically.
Reference: [5] <author> W. R. Bevier and W. D. Young. </author> <title> Machine Checked Proofs of the Design of a Fault-Tolerant Circuit, </title> <journal> Formal Aspects of Computing, </journal> <volume> Vol. 4, </volume> <pages> pp. 755-775, </pages> <year> 1992. </year> <note> Also available as Technical Report 62, Computational Logic, </note> <institution> Inc., </institution> <address> Suite 290, 1717 West Sixth Street, Austin, TX 78703, </address> <month> August, </month> <year> 1990, </year> <note> and as NASA CR-182099, </note> <month> November, </month> <year> 1990. </year>
Reference-contexts: The correctness of a gate-level design of a device implementing an 8-bit parallel io Byzantine agreement processor has been proved [26]. In addition, it was proved that the algorithm implemented by the Byzantine agreement processor correctly solves the "oral messages" problem <ref> [5] </ref>. Finally, the correctness of the interactive convergence clock synchronization algorithm was proved [38]. * Scheduling, Concurrency, and Distributed Computing Nqthm has been used to prove that an operating system implemented in machine code on a uniprocessor correctly provides multitasking and task isolation and communication [3].
Reference: [6] <author> R. S. Boyer, D. Goldschlag, M. Kaufmann, and J S. Moore. </author> <title> Functional Instantiation in First Order Logic. </title> <booktitle> In Artificial Intelligence and Mathematical Theory of Computation: Papers in Honor of John McCarthy, </booktitle> <publisher> Academic Press, </publisher> <year> 1991, </year> <pages> pp. 7-26. </pages>
Reference-contexts: In addition, the logic provides an axiomatization of a nonconstructive function, V&C$, which is an interpreter for the logic and allows the introduction of any partial recursive function. See <ref> [11, 6] </ref> for details. The mechanization of the Nqthm logic is a system of Common Lisp programs allowing the user to define functions in the logic, execute them on concrete 4 data, and state and prove theorems about such functions. <p> The local definition of f is merely a witness to the consistency of the constraint. "Outside" the encapsulation, (f x) is known only to be rational. A derived rule of inference, called "functional instantiation," <ref> [6] </ref>, gives ACL2 some of the features of a higher order logic by allowing one to instantiate the function symbols of a previously proved theorem, replacing them with other function symbols or lambda-expressions, provided one can prove that the replacements satisfy the constraints on the old symbols.
Reference: [7] <author> Robert S. Boyer, Matt Kaufmann, and J Strother Moore. </author> <title> "The Boyer-Moore Theorem Prover and Its Interactive Enhancement." </title> <note> (Submitted.) </note>
Reference-contexts: Both systems and many of their applications are briefly described in <ref> [7] </ref>. A detailed tutorial introduction to Nqthm and Pc-Nqthm may be found in [24]. The recent Nqthm-1992 release includes 1.3 megabytes of updated documentation consisting of new versions of the five most important chapters in [11].
Reference: [8] <author> R. S. Boyer and J S. Moore. </author> <title> A Computational Logic, </title> <publisher> Academic Press: </publisher> <address> New York, </address> <year> 1979. </year> <note> Design Goals for ACL2 CLI Technical Report #101 39 </note>
Reference-contexts: The "Nqthm" system, developed by Boyer and Moore, provides such a logic and a mechanized theorem prover for it <ref> [8, 11] </ref>. Nqthm is widely used in the formal modeling of digital systems. Nqthm is well known for its robustness and the extensive body of verification work done with it. However, for the past five years the two authors and Robert S. <p> A companion "Pc-Nqthm-1992" was also released. To obtain Nqthm-1992, connect to Internet site ftp.cli.com by anonymous ftp, giving your email address as the password, `get' the file /pub/nqthm/nqthm-1992/README, and follow the instructions therein. (Analogous instruction apply to Pc-Nqthm-1992.) Nqthm is documented in two books <ref> [8, 11] </ref>, and Pc-Nqthm is documented in [20, 21, 22]. Both systems and many of their applications are briefly described in [7]. A detailed tutorial introduction to Nqthm and Pc-Nqthm may be found in [24]. <p> The second illustrates Nqthm's use in modeling other formal systems, a capability that has often been exploited to use Nqthm to do proofs "in" other computational logics: Nqthm has proved the soundness and completeness of a propositional calculus decision procedure <ref> [8] </ref>, the Turing completeness of pure Lisp [10], the Church-Rosser theorem for lambda calculus [33], and the soundness of the proof rules of Misra and Chandy's Unity logic [14, 16]. * System Verification Perhaps most representative of digital systems verification is the now classic example, the "CLI short stack," which combines <p> This is done, as in Nqthm, by the identification of some ordinal measure of the formals that decreases in recursion. In <ref> [8] </ref> we show (for Nqthm) that this insures that one and only one set-theoretic function satisfies the recursive definition and that proof carries over to the ACL2 case, with appropriate treatment of the nonuniqueness of the constrained functions used in the definition.
Reference: [9] <author> R. S. Boyer and J S. Moore. Metafunctions: </author> <title> Proving Them Correct and Using Them Efficiently as New Proof Procedures. </title> <editor> In R. S. Boyer and J S. Moore, editors, </editor> <booktitle> The Correctness Problem in Computer Science, </booktitle> <publisher> Academic Press, </publisher> <year> 1981. </year>
Reference-contexts: If one then proves that such a transformer preserves semantic identity (i.e., that the object denoted by the input term is the same as the object denoted by the output term), the transformation can be incorporated soundly into the simplification routines of the theorem prover. See <ref> [9] </ref>. The link between terms and objects means that some system design and user interface issues impact the choice of axioms. For example, execution efficiency dictates that the quotation of a function symbol be an object in the logic that can be concretely and uniquely represented by that symbol.
Reference: [10] <author> R. S. Boyer and J S. Moore. </author> <title> A Mechanical Proof of the Turing Completeness of Pure Lisp. </title> <editor> In W. W. Bledsoe and D. W. Loveland, editors, </editor> <title> Automated Theorem Proving: After 25 Years, </title> <publisher> American Mathematical Society, </publisher> <address> Providence, R.I., </address> <year> 1984, </year> <pages> pp. 133-167. </pages>
Reference-contexts: The second illustrates Nqthm's use in modeling other formal systems, a capability that has often been exploited to use Nqthm to do proofs "in" other computational logics: Nqthm has proved the soundness and completeness of a propositional calculus decision procedure [8], the Turing completeness of pure Lisp <ref> [10] </ref>, the Church-Rosser theorem for lambda calculus [33], and the soundness of the proof rules of Misra and Chandy's Unity logic [14, 16]. * System Verification Perhaps most representative of digital systems verification is the now classic example, the "CLI short stack," which combines both hardware and software verification.
Reference: [11] <author> R. S. Boyer and J S. Moore. </author> <title> A Computational Logic Handbook, </title> <publisher> Academic Press: </publisher> <address> New York, </address> <year> 1988. </year>
Reference-contexts: The "Nqthm" system, developed by Boyer and Moore, provides such a logic and a mechanized theorem prover for it <ref> [8, 11] </ref>. Nqthm is widely used in the formal modeling of digital systems. Nqthm is well known for its robustness and the extensive body of verification work done with it. However, for the past five years the two authors and Robert S. <p> In addition, the logic provides an axiomatization of a nonconstructive function, V&C$, which is an interpreter for the logic and allows the introduction of any partial recursive function. See <ref> [11, 6] </ref> for details. The mechanization of the Nqthm logic is a system of Common Lisp programs allowing the user to define functions in the logic, execute them on concrete 4 data, and state and prove theorems about such functions. <p> A companion "Pc-Nqthm-1992" was also released. To obtain Nqthm-1992, connect to Internet site ftp.cli.com by anonymous ftp, giving your email address as the password, `get' the file /pub/nqthm/nqthm-1992/README, and follow the instructions therein. (Analogous instruction apply to Pc-Nqthm-1992.) Nqthm is documented in two books <ref> [8, 11] </ref>, and Pc-Nqthm is documented in [20, 21, 22]. Both systems and many of their applications are briefly described in [7]. A detailed tutorial introduction to Nqthm and Pc-Nqthm may be found in [24]. <p> Both systems and many of their applications are briefly described in [7]. A detailed tutorial introduction to Nqthm and Pc-Nqthm may be found in [24]. The recent Nqthm-1992 release includes 1.3 megabytes of updated documentation consisting of new versions of the five most important chapters in <ref> [11] </ref>. <p> This allows the user to ignore ACL2's scrolling commentary (indeed, many users simply do not display that buffer) and simply jump directly to the trouble spots (the "checkpoints" of <ref> [11] </ref> and of the tool described in [23]). 4.5.4 Documentation ACL2 is documented via an online documentation facility that is part of ACL2. The ACL2 documentation is maintained in a hypertext-like structure which may be browsed via ACL2 documentation commands.
Reference: [12] <author> R. S. Boyer and Y. Yu, </author> <title> Automated Correctness Proofs of Machine Code Programs for a Commercial Microprocessor. </title> <editor> In D. Kapur, editor, </editor> <booktitle> Automated Deduction - CADE-11, Lecture Notes in Computer Science 607, </booktitle> <publisher> Springer-Verlag, </publisher> <pages> 416-430, </pages> <year> 1992. </year>
Reference-contexts: The object code for these examples was generated using the Gnu C, the Verdix Ada, and the AKCL Common Lisp compilers. Perhaps most importantly, 21 of the 22 programs in the Berkeley Unix C string library were mechanically verified. See <ref> [12, 39] </ref>.
Reference: [13] <author> B. C. Brock, W. A. Hunt, Jr. and W. D. Young. </author> <title> Introduction to a Formally Defined Hardware Description Language. In Theorem Provers in Circuit Designs, Number A10 in IFIP Transactions. </title> <publisher> North Holland, </publisher> <year> 1992. </year>
Reference-contexts: This work consumed several man years and is described in [4]. * Hardware Verification and System Maintenance Since the publication of the short stack work, CLI has designed, verified, and fabricated another microprocessor, called the FM9001 [19]. This involved formalizing the NDL hardware description language <ref> [13] </ref> of LSI Logic Inc., and 6 verifying that a certain collection of NDL hardware modules implemented a formally described machine language.
Reference: [14] <author> K. M. Chandy and J. Misra. </author> <title> Parallel Program Design: A Foundation. </title> <publisher> Addison-Wesley: </publisher> <address> Massachusetts, </address> <year> 1988. </year>
Reference-contexts: use Nqthm to do proofs "in" other computational logics: Nqthm has proved the soundness and completeness of a propositional calculus decision procedure [8], the Turing completeness of pure Lisp [10], the Church-Rosser theorem for lambda calculus [33], and the soundness of the proof rules of Misra and Chandy's Unity logic <ref> [14, 16] </ref>. * System Verification Perhaps most representative of digital systems verification is the now classic example, the "CLI short stack," which combines both hardware and software verification. <p> An Nqthm formalization of Misra and Chandy's Unity language <ref> [14] </ref> is described in [16, 17] along with the proofs of several Unity programs. An Nqthm-checked proof that an earliest-deadline-first (EDF) scheduler is optimal is proved in [37].
Reference: [15] <author> J. Cowles. </author> <title> Meeting a Challenge of Knuth. Internal Note 286, Computational Logic, </title> <publisher> Inc., </publisher> <address> Austin, Texas, </address> <month> September, </month> <year> 1993. </year>
Reference-contexts: Little substantial use of it appears in Nqthm's benchmarks, and since the introduction of functional instantiation, some of those uses have been replaced by the use of constrained functions and functional instantiation, as illustrated in <ref> [15] </ref> where the two methods are used to prove the termination of Knuth's generalized 91-function [25]. In any case, we decided not to burden ACL2 or its users with an analogue of V&C$.
Reference: [16] <author> D. M. Goldschlag. </author> <title> Mechanizing Unity. </title> <editor> In M. Broy and C. B. Jones, editors, </editor> <booktitle> Programming Concepts and Methods, </booktitle> <publisher> North Holland, </publisher> <address> Amsterdam, </address> <year> 1990. </year>
Reference-contexts: use Nqthm to do proofs "in" other computational logics: Nqthm has proved the soundness and completeness of a propositional calculus decision procedure [8], the Turing completeness of pure Lisp [10], the Church-Rosser theorem for lambda calculus [33], and the soundness of the proof rules of Misra and Chandy's Unity logic <ref> [14, 16] </ref>. * System Verification Perhaps most representative of digital systems verification is the now classic example, the "CLI short stack," which combines both hardware and software verification. <p> An Nqthm formalization of Misra and Chandy's Unity language [14] is described in <ref> [16, 17] </ref> along with the proofs of several Unity programs. An Nqthm-checked proof that an earliest-deadline-first (EDF) scheduler is optimal is proved in [37].
Reference: [17] <author> D. M. Goldschlag. </author> <title> Mechanically Verifying Concurrent Programs with the Boyer-Moore Prover. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 16, </volume> <month> September, </month> <year> 1990. </year>
Reference-contexts: An Nqthm formalization of Misra and Chandy's Unity language [14] is described in <ref> [16, 17] </ref> along with the proofs of several Unity programs. An Nqthm-checked proof that an earliest-deadline-first (EDF) scheduler is optimal is proved in [37].
Reference: [18] <author> W. A. Hunt, Jr. FM8501: </author> <title> A Verified Microprocessor, </title> <type> Ph.D. Thesis, </type> <institution> The University of Texas at Austin, </institution> <month> December, </month> <year> 1985. </year> <note> Also available through Computational Logic, Inc., as Technical Report ICSCA-CMP-47, </note> <institution> Institute for Computing Science and Computer Applications, University of Texas at Austin, </institution> <month> December, </month> <year> 1985. </year>
Reference-contexts: By 1985, Nqthm was being used to prove theorems requiring 1,000 lines to state (Godel's theorem and the correctness of the FM8501 microprocessor <ref> [18] </ref>). By 1990 it was being used to prove theorems requiring almost 8,000 lines to state (FM9001). This is almost two orders of magnitude larger than the "inspirational" theorems of Nqthm's design stage.
Reference: [19] <author> W. A. Hunt, Jr. and B. Brock. </author> <title> A Formal HDL and its use in the FM9001 Verification. </title> <journal> Proceedings of the Royal Society, </journal> <year> 1992. </year>
Reference-contexts: This work consumed several man years and is described in [4]. * Hardware Verification and System Maintenance Since the publication of the short stack work, CLI has designed, verified, and fabricated another microprocessor, called the FM9001 <ref> [19] </ref>. This involved formalizing the NDL hardware description language [13] of LSI Logic Inc., and 6 verifying that a certain collection of NDL hardware modules implemented a formally described machine language.
Reference: [20] <author> M. Kaufmann. </author> <title> A User's Manual for an Interactive Enhancement to the Boyer-Moore Theorem Prover, </title> <type> Technical report 19, </type> <institution> Computational Logic, Inc., </institution> <month> May, </month> <year> 1988. </year> <month> 40 </month>
Reference-contexts: The Nqthm theorem prover uses a variety of proof techniques, e.g., simplification and induction. These techniques are sensitive to rules in a data base. Hundreds of heuristics orchestrate the application these rules. An interactive proof checker for Nqthm, called "Pc-Nqthm" has also been developed <ref> [20, 21] </ref>. Important to Nqthm's success has been the fact that when a new user-supplied theorem is proved, rules are derived from it and stored in its data base; these rules change the way the system behaves. <p> To obtain Nqthm-1992, connect to Internet site ftp.cli.com by anonymous ftp, giving your email address as the password, `get' the file /pub/nqthm/nqthm-1992/README, and follow the instructions therein. (Analogous instruction apply to Pc-Nqthm-1992.) Nqthm is documented in two books [8, 11], and Pc-Nqthm is documented in <ref> [20, 21, 22] </ref>. Both systems and many of their applications are briefly described in [7]. A detailed tutorial introduction to Nqthm and Pc-Nqthm may be found in [24]. The recent Nqthm-1992 release includes 1.3 megabytes of updated documentation consisting of new versions of the five most important chapters in [11].
Reference: [21] <author> M. Kaufmann. </author> <title> Addition of Free Variables to an Interactive Enchance-ment of the Boyer-Moore Theorem Prover, </title> <type> Technical Report 42, </type> <institution> Computational Logic, Inc., </institution> <year> 1990. </year>
Reference-contexts: The Nqthm theorem prover uses a variety of proof techniques, e.g., simplification and induction. These techniques are sensitive to rules in a data base. Hundreds of heuristics orchestrate the application these rules. An interactive proof checker for Nqthm, called "Pc-Nqthm" has also been developed <ref> [20, 21] </ref>. Important to Nqthm's success has been the fact that when a new user-supplied theorem is proved, rules are derived from it and stored in its data base; these rules change the way the system behaves. <p> To obtain Nqthm-1992, connect to Internet site ftp.cli.com by anonymous ftp, giving your email address as the password, `get' the file /pub/nqthm/nqthm-1992/README, and follow the instructions therein. (Analogous instruction apply to Pc-Nqthm-1992.) Nqthm is documented in two books [8, 11], and Pc-Nqthm is documented in <ref> [20, 21, 22] </ref>. Both systems and many of their applications are briefly described in [7]. A detailed tutorial introduction to Nqthm and Pc-Nqthm may be found in [24]. The recent Nqthm-1992 release includes 1.3 megabytes of updated documentation consisting of new versions of the five most important chapters in [11].
Reference: [22] <author> M. Kaufmann. </author> <title> An extension of the Boyer-Moore theorem prover to support first-order quantification. </title> <journal> Journal of Automated Reasoning, </journal> <volume> 9(3) </volume> <pages> 355-372, </pages> <month> December </month> <year> 1992. </year>
Reference-contexts: To obtain Nqthm-1992, connect to Internet site ftp.cli.com by anonymous ftp, giving your email address as the password, `get' the file /pub/nqthm/nqthm-1992/README, and follow the instructions therein. (Analogous instruction apply to Pc-Nqthm-1992.) Nqthm is documented in two books [8, 11], and Pc-Nqthm is documented in <ref> [20, 21, 22] </ref>. Both systems and many of their applications are briefly described in [7]. A detailed tutorial introduction to Nqthm and Pc-Nqthm may be found in [24]. The recent Nqthm-1992 release includes 1.3 megabytes of updated documentation consisting of new versions of the five most important chapters in [11].
Reference: [23] <author> M. Kaufmann. </author> <title> An Assistant for Reading Nqthm Proof Output. </title> <type> Technical Report 85, </type> <institution> Computational Logic, Inc., </institution> <month> November, </month> <year> 1992. </year>
Reference-contexts: This allows the user to ignore ACL2's scrolling commentary (indeed, many users simply do not display that buffer) and simply jump directly to the trouble spots (the "checkpoints" of [11] and of the tool described in <ref> [23] </ref>). 4.5.4 Documentation ACL2 is documented via an online documentation facility that is part of ACL2. The ACL2 documentation is maintained in a hypertext-like structure which may be browsed via ACL2 documentation commands. In addition, it may be browsed via Emacs' Info mode and via Mosaic.
Reference: [24] <author> M. Kaufmann and P. Pecchiari. </author> <title> Interaction with the Boyer-Moore Theorem Prover: A Tutorial Study Using the Arithmetic-Geometric Mean Theorem, </title> <type> Technical Report 102, </type> <institution> Computational Logic, Inc., </institution> <year> 1994. </year>
Reference-contexts: Both systems and many of their applications are briefly described in [7]. A detailed tutorial introduction to Nqthm and Pc-Nqthm may be found in <ref> [24] </ref>. The recent Nqthm-1992 release includes 1.3 megabytes of updated documentation consisting of new versions of the five most important chapters in [11].
Reference: [25] <author> D. E. Knuth. </author> <title> Textbook examples of recursion. </title> <editor> In V. Lifschitz, editor, </editor> <booktitle> Artificial Intelligence and Mathematical Theory of Computation: Papers in Honor of John McCarthy, </booktitle> <publisher> Academic Press, </publisher> <address> San Diego, CA, 207-229, </address> <year> 1991. </year>
Reference-contexts: Little substantial use of it appears in Nqthm's benchmarks, and since the introduction of functional instantiation, some of those uses have been replaced by the use of constrained functions and functional instantiation, as illustrated in [15] where the two methods are used to prove the termination of Knuth's generalized 91-function <ref> [25] </ref>. In any case, we decided not to burden ACL2 or its users with an analogue of V&C$.
Reference: [26] <author> J S. Moore. </author> <title> Verified Hardware Implementing an 8-Bit Parallel InO Byzantine Agreement Processor. </title> <type> Technical Report 69, </type> <institution> Computational Logic, Inc., Austin, Texas, </institution> <month> August, </month> <year> 1991. </year>
Reference-contexts: The correcntess of a gate-level design of a device implementing the biphase mark protocol has been proved [32]. The correctness of a gate-level design of a device implementing an 8-bit parallel io Byzantine agreement processor has been proved <ref> [26] </ref>. In addition, it was proved that the algorithm implemented by the Byzantine agreement processor correctly solves the "oral messages" problem [5].
Reference: [27] <author> J S. Moore. </author> <title> A Formal Model of Asynchronous Communication and Its Use in Mechanically Verifying a Biphase Mark Protocol, </title> <booktitle> Formal Aspects of Computing 6(1), </booktitle> <pages> 60-91, </pages> <year> 1994. </year>
Reference-contexts: related work by Yuan Yu at DEC's Systems Research Center in Palo Alto, California, Nqthm is being used to specify part of the DEC Alpha architecture. * Fault Tolerance A model of asynchronous communication was developed in Nqthm and used to prove the reliability of the biphase mark communications protocol <ref> [27] </ref>. The model transduces the waveform written by one processor into that read by an independently-clocked processor, as a function of the phases and rates of the two clocks and the communications delay.
Reference: [28] <author> J S. Moore. </author> <title> Introduction to the OBDD Algorithm for the ATP Community, </title> <journal> Journal of Automated Reasoning 12, </journal> <pages> 33-45, </pages> <year> 1994. </year>
Reference-contexts: The proof techniques, in order of application are: * preprocessing: This process expands some propositional functions and uses IF-normalization, tautology checking, recognition of common cases, and equivalence closure. An ordered binary decision diagram (OBDD) algorithm has been coded for ACL2 <ref> [28] </ref> and we hope to integrate it into the preprocessor. * simplification: By far the most complicated proof technique, simplification combines primitive type checking, forward chaining, backward chaining, forcing, congruence based rewriting under arbitrary equivalence relations and their refinements, generalized alternative recursive definitions, verified conditional metatheoretic simplifiers, tautology checking, congruence closure,
Reference: [29] <author> Motorola, Inc. </author> <title> MC68020 32-bit Microprocessor User's Manual. </title> <publisher> Prentice Hall, </publisher> <address> New Jersey, </address> <year> 1989. </year>
Reference-contexts: The model is about 80 pages of Lisp and was written using the MC68020 programmer's manual <ref> [29] </ref> as the primary source. While the MC68020 can be regarded as a formal artifact in as much as, ideally, its behavior is exactly as specified by its gate-level design, that design was unavailable to the author of the Nqthm model.
Reference: [30] <author> K. M. Pitman et al. </author> <title> draft proposed American National Standard for Information Systems | Programming Language | Common Lisp; X3J13/93-102. Global Engineering Documents, </title> <publisher> Inc., </publisher> <year> 1994. </year>
Reference-contexts: The definition of Common Lisp used in our work has been [35, 36]. We comment on the draft proposed ANSI standard for Common Lisp <ref> [30] </ref> in the conclusion. Just as Nqthm is more than a verification tool for pure Lisp | in particular, it has been used as a modeling tool for a wide variety of digital systems | ACL2 is intended to be more than a verification tool for Common Lisp. <p> the proof burden introduced by guards, without eliminating the connection to Common Lisp or the ability to use guards as a specification 36 device. 7.2 Draft Proposed ANSI Standard We are aware of one area in which ACL2 is at odds with the draft proposed ANSI standard for Common Lisp <ref> [30] </ref> and that is in connection with the "generalized Boolean" functions of the proposed standard. In ACL2, equal, for example, is a Boolean valued function, meaning that it returns either nil or t. But in [30] equal is a "generalized Boolean" valued function, meaning that it may return any non-nil value <p> in which ACL2 is at odds with the draft proposed ANSI standard for Common Lisp <ref> [30] </ref> and that is in connection with the "generalized Boolean" functions of the proposed standard. In ACL2, equal, for example, is a Boolean valued function, meaning that it returns either nil or t. But in [30] equal is a "generalized Boolean" valued function, meaning that it may return any non-nil value to indicate truth. Many functions that return Booleans in traditional Lisp implementations return generalized Booleans in [30], including equal, &lt;, symbolp, and subsetp. <p> But in <ref> [30] </ref> equal is a "generalized Boolean" valued function, meaning that it may return any non-nil value to indicate truth. Many functions that return Booleans in traditional Lisp implementations return generalized Booleans in [30], including equal, &lt;, symbolp, and subsetp. Apparently programs are not to use such functions in contexts other than those in which their values are tested as propositions. As ACL2 now stands there are gold theorems that are not true of the language described in [30]. <p> implementations return generalized Booleans in <ref> [30] </ref>, including equal, &lt;, symbolp, and subsetp. Apparently programs are not to use such functions in contexts other than those in which their values are tested as propositions. As ACL2 now stands there are gold theorems that are not true of the language described in [30]. One example is (equal (equal nil nil) (equal nil nil)). In ACL2, both of the interior equal terms return t and so the theorem follows from the axiom (equal x x). But in [30] the first (equal nil nil) might return t and the second might return 23 and the <p> ACL2 now stands there are gold theorems that are not true of the language described in <ref> [30] </ref>. One example is (equal (equal nil nil) (equal nil nil)). In ACL2, both of the interior equal terms return t and so the theorem follows from the axiom (equal x x). But in [30] the first (equal nil nil) might return t and the second might return 23 and the two are not equal. This formula violates the spirit of [30]: generalized Booleans are to be used only in propositional tests. To conform to [30] we might introduce a new attribute of function symbols, <p> But in <ref> [30] </ref> the first (equal nil nil) might return t and the second might return 23 and the two are not equal. This formula violates the spirit of [30]: generalized Booleans are to be used only in propositional tests. To conform to [30] we might introduce a new attribute of function symbols, namely whether they have generalized Boolean values, and narrow the class of gold formulas to exclude those where generalized Booleans are "misused." 7.3 The Complexity of ACL2 <p> But in <ref> [30] </ref> the first (equal nil nil) might return t and the second might return 23 and the two are not equal. This formula violates the spirit of [30]: generalized Booleans are to be used only in propositional tests. To conform to [30] we might introduce a new attribute of function symbols, namely whether they have generalized Boolean values, and narrow the class of gold formulas to exclude those where generalized Booleans are "misused." 7.3 The Complexity of ACL2 The proliferation of ACL2 rule classes may be a mistake.
Reference: [31] <author> D. M. Russinoff. </author> <title> A Mechanical Proof of Quadratic Reciprocity. </title> <journal> Journal of Automated Reasoning, </journal> <volume> 8(1), </volume> <pages> 3-21, </pages> <year> 1992. </year>
Reference-contexts: as a flaw to be corrected but we cite these examples to establish the fact that the expressivity Design Goals for ACL2 CLI Technical Report #101 5 of the logic is not a serious bottleneck. * Mathematics for Computation Among the well-known Nqthm benchmarks are Gauss' law of quadratic reciprocity <ref> [31] </ref> and Godel's incompleteness theorem for Shoenfield's first order logic extended with Cohen's axioms for hereditarily finite set theory, Z2, [34]. The first illustrates Nqthm's use in deep reasoning about integers, perhaps the most commonly used mathematical construct in computing.
Reference: [32] <author> D. M. Russinoff. </author> <title> Specification and Verification of Gate-Level VHDL Models of Synchronous and Asynchronous Circuits. </title> <type> Technical Report 99, </type> <institution> Computational Logic, Inc., Austin, Texas, </institution> <month> May, </month> <year> 1994. </year>
Reference-contexts: The model transduces the waveform written by one processor into that read by an independently-clocked processor, as a function of the phases and rates of the two clocks and the communications delay. The correcntess of a gate-level design of a device implementing the biphase mark protocol has been proved <ref> [32] </ref>. The correctness of a gate-level design of a device implementing an 8-bit parallel io Byzantine agreement processor has been proved [26]. In addition, it was proved that the algorithm implemented by the Byzantine agreement processor correctly solves the "oral messages" problem [5].
Reference: [33] <author> N. Shankar. </author> <title> A Mechanical Proof of the Church-Rosser Theorem. </title> <journal> JACM 35(3), </journal> <pages> 475-522, </pages> <year> 1988. </year> <note> Design Goals for ACL2 CLI Technical Report #101 41 </note>
Reference-contexts: use in modeling other formal systems, a capability that has often been exploited to use Nqthm to do proofs "in" other computational logics: Nqthm has proved the soundness and completeness of a propositional calculus decision procedure [8], the Turing completeness of pure Lisp [10], the Church-Rosser theorem for lambda calculus <ref> [33] </ref>, and the soundness of the proof rules of Misra and Chandy's Unity logic [14, 16]. * System Verification Perhaps most representative of digital systems verification is the now classic example, the "CLI short stack," which combines both hardware and software verification.
Reference: [34] <author> N. Shankar. </author> <title> Metamathematics, Machines, and Godel's Proof, </title> <publisher> Cambridge University press, </publisher> <year> 1994. </year>
Reference-contexts: for ACL2 CLI Technical Report #101 5 of the logic is not a serious bottleneck. * Mathematics for Computation Among the well-known Nqthm benchmarks are Gauss' law of quadratic reciprocity [31] and Godel's incompleteness theorem for Shoenfield's first order logic extended with Cohen's axioms for hereditarily finite set theory, Z2, <ref> [34] </ref>. The first illustrates Nqthm's use in deep reasoning about integers, perhaps the most commonly used mathematical construct in computing.
Reference: [35] <author> G. L. Steele Jr. </author> <title> Common LISP: The Language, </title> <publisher> Digital Press: </publisher> <address> Bedford, MA, </address> <year> 1984. </year>
Reference-contexts: The definition of Common Lisp used in our work has been <ref> [35, 36] </ref>. We comment on the draft proposed ANSI standard for Common Lisp [30] in the conclusion. <p> It is our intention that all of the Common Lisp functions on the above data types are axiomatized or defined as functions or macros in ACL2. By "Common Lisp functions" here we mean the programs specified in <ref> [35] </ref> or [36] that are (i) applicative, (ii) not dependent on state, implicit parameters, or data types other than those in ACL2, and (iii) completely specified, unambiguously, in a host-independent manner. Approximately 150 such symbols are axiomatized. Common Lisp functions are partial; they are not defined for all possible inputs.
Reference: [36] <author> G. L. Steele, Jr. </author> <title> Common Lisp The Language, Second Edition. </title> <publisher> Digital Press, </publisher> <address> 30 North Avenue, Burlington, MA 01803, </address> <year> 1990. </year>
Reference-contexts: The definition of Common Lisp used in our work has been <ref> [35, 36] </ref>. We comment on the draft proposed ANSI standard for Common Lisp [30] in the conclusion. <p> It is our intention that all of the Common Lisp functions on the above data types are axiomatized or defined as functions or macros in ACL2. By "Common Lisp functions" here we mean the programs specified in [35] or <ref> [36] </ref> that are (i) applicative, (ii) not dependent on state, implicit parameters, or data types other than those in ACL2, and (iii) completely specified, unambiguously, in a host-independent manner. Approximately 150 such symbols are axiomatized. Common Lisp functions are partial; they are not defined for all possible inputs. <p> Approximately 150 such symbols are axiomatized. Common Lisp functions are partial; they are not defined for all possible inputs. Consider for example the primitive function car. Page 411 of <ref> [36] </ref> says that the argument to car "must be" a cons or nil. <p> Suppose f is a function symbol of one argument defined in some certified book (as described below), that the guard of f is t, that f is gold, and that (equal (f x) t) is a theorem of ACL2 proved in that book. Consider any Common Lisp compliant to <ref> [36] </ref> into which the ACL2 kernel has been loaded. Load the book into that Lisp.
Reference: [37] <author> M. Wilding. </author> <title> An optimal real-time scheduler based on a simple model of computation. Internal Note 276, Computational Logic, </title> <publisher> Inc., </publisher> <month> July </month> <year> 1993. </year>
Reference-contexts: An Nqthm formalization of Misra and Chandy's Unity language [14] is described in [16, 17] along with the proofs of several Unity programs. An Nqthm-checked proof that an earliest-deadline-first (EDF) scheduler is optimal is proved in <ref> [37] </ref>. The final theorem is the classic theorem about EDF schedulers. 3.3 The Role of Executability The executability of Nqthm's logic played a significant role in the development and use of the computational models described above.
Reference: [38] <author> W.D. Young. </author> <title> Verifying the Interactive Convergence Clock Synchronization Algorithm using the Boyer-Moore Theorem Prover. </title> <type> Contractor Report 189649, </type> <institution> NASA, </institution> <month> April </month> <year> 1992. </year>
Reference-contexts: In addition, it was proved that the algorithm implemented by the Byzantine agreement processor correctly solves the "oral messages" problem [5]. Finally, the correctness of the interactive convergence clock synchronization algorithm was proved <ref> [38] </ref>. * Scheduling, Concurrency, and Distributed Computing Nqthm has been used to prove that an operating system implemented in machine code on a uniprocessor correctly provides multitasking and task isolation and communication [3].
Reference: [39] <author> Y. Yu. </author> <title> Automated Proofs of Object Code for a Widely Used Microprocessor. </title> <type> Ph.D. Thesis, </type> <institution> The University of Texas at Austin, </institution> <year> 1992. </year> <note> Also available through Systems Research Center, </note> <institution> Digital Equipment Corporation, </institution> <address> 130 Lytton Avenue, Palo Alto, California, </address> <month> 94301. </month>
Reference-contexts: The object code for these examples was generated using the Gnu C, the Verdix Ada, and the AKCL Common Lisp compilers. Perhaps most importantly, 21 of the 22 programs in the Berkeley Unix C string library were mechanically verified. See <ref> [12, 39] </ref>.
References-found: 39

