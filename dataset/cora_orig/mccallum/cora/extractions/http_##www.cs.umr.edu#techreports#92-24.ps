URL: http://www.cs.umr.edu/techreports/92-24.ps
Refering-URL: http://www.cs.umr.edu/techreports/
Root-URL: 
Email: ff@cs.umr.edu  (hanan@csd.uwo.ca).  
Title: AN APPLICATION-ORIENTED APPROACH TO DISTRIBUTED ERROR-DETECTING BRANCH BOUND  
Author: Aggie Y. Sun, Hanan Lutfiyya, and Bruce McMillin 
Note: This work was supported in part by the National Science Foundation under Grant Number MSS-9216479, and, in part, from the Air Force Office of Scientific Research under contract number F49620-92-J-0546. Hanan Lutfiyya is with the  The work was performed when Dr. Lutfiyya was at the University of Missouri-Rolla. Aggie Sun (aggies@cs.umr.edu) and Bruce McMillin (ff@cs.umr.edu) are with the  
Address: Rolla, Missouri 65401  Ontario, London, ONTARIO N6A 5B7  Rolla, MO 65401.  
Affiliation: Department of Computer Science University of Missouri at Rolla  Department of Computer Science at the University of Western  Department of Computer Science at the University of Missouri-Rolla,  
Date: December 18, 1992  
Pubnum: CSC-92-24  
Abstract-found: 0
Intro-found: 1
Reference: [AmKB89] <author> Ammann, Paul E., Knight, John C., and Brilliant, S. S., </author> <title> ``The Inuence of Testing on Fault-Tolerant Software,'' </title> <booktitle> Proc. 12th Int'l Symposium on Fault-Tolerant Computing, </booktitle> <month> June 26-28, </month> <year> 1990, </year> <pages> pp. 408-415. </pages>
Reference: [ChAv83] <author> Chen, Liming and Avizienis, Algirdas, </author> <title> "N-Version Programming: A Fault-Tolerance Approach to Reliability of Software Operation," </title> <booktitle> 13th Annual Int'l Symp on Fault Tolerant Computing, </booktitle> <month> June </month> <year> 1983, </year> <pages> pp. 120-126. </pages>
Reference: [Hoar69] <author> Hoare, C. </author> <title> ``An Axiomatic Basis for Computer Programming'', </title> <journal> Communications of the ACM, </journal> <volume> 12, 10, </volume> <year> 1969, </year> <pages> 576-583. </pages>
Reference: [Hoar78] <author> Hoare, C. </author> <title> ``Communicating Sequential processes'', </title> <journal> Communications of the ACM, </journal> <volume> 21, </volume> <year> 1978, </year> <pages> 666-677. </pages>
Reference-contexts: The axiomatic proof system found in [LeGr81], which is used for Hoare's model of concurrent programming, Communicating Sequential Processes (CSP) <ref> [Hoar78] </ref> forms the basis for the verification system used in this paper. 2.1. GAA Proof System A proof outline employing global auxiliary variables [LeGr81] as a proof aid is, perhaps, the easiest approach to reason about concurrent systems . In this system, processes in isolation are reasoned about.
Reference: [HoMc91] <author> Hong, C., and McMillin, B., </author> <title> ``Fault-Tolerant Matrix Multiplication with One-Iteration Fault Latency,'' </title> <booktitle> Proceedings of the 15th International COMPSAC, </booktitle> <month> September, </month> <year> 1991. </year>
Reference: [HoSL78] <author> Hopkins Jr., A.L. Smith, III,T.B. and Lala, J.H. </author> <title> "FTMP - A Highly Reliable Fault-Tolerant Multiprocessor for Aircraft," </title> <journal> Proc. IEEE, </journal> <volume> Vol. 66, No. 10, </volume> <month> Oct. </month> <year> 1978, </year> <pages> pp. </pages> <month> 1,221-1,239. </month>
Reference: [HuAb84] <author> Huang, Kuang-Hua and Abraham, Jacob A., </author> <title> "Algorithm-Based Fault Tolerance for Matrix Operation," </title> <journal> IEEE Transaction on Computers, </journal> <volume> Vol. c-33, No. 6, </volume> <month> June, </month> <pages> 1984 pp. 518-528. </pages>
Reference: [KoSt74] <author> Kohler, W., and Steiglitz, K., </author> <title> ``Characterization and Theoretical Comparison of Branch-and-Bound Algorithms for Permutation Problems,'' </title> <journal> Journal of the ACM, vo. </journal> <volume> 21, no. 1, </volume> <year> 1974, </year> <pages> pp. 140-156. </pages>
Reference-contexts: The manhattan distance represents the distance each tile is out of place as well as a lower bound for any solution. The level corresponds to the number of legal moves taken thus far. Theorem 3.1: <ref> [KoSt74] </ref> Let s denote any node representing a minimal cost node according to the cost function f, where f is monotonically nondecreasing. s is then an optimal node in the search -- -- space. Theorem 3.2: The optimization function, f is a monotonic nondecreasing function as k increases.
Reference: [LaMG91] <author> Larangeria, L., Malek, M., and Jenevein, J., </author> <title> ``On Tolerating Faults in Naturally Redundant Algorithms,'' </title> <booktitle> Tenth Symposium on Reliable Distributed Systems, </booktitle> <year> 1991, </year> <pages> pp. 118-127. </pages>
Reference-contexts: The consistency condition can then be ensured by using the Byzantine General's algorithm [LaSP82]. This is clearly infeasible due to the time overhead and connectivity requirements. This section introduces the notion of natural redundancy and demonstrates how this concept implies consistency. A naturally redundant algorithm <ref> [LaMG91] </ref> running on a processor architecture P has at least the potential to restore the correct value of any single erroneous component in its output. In the parallel execution of many applications, processors communicate their intermediate calculation values to other processors as the computation proceeds. <p> Call W F 5 -- -- divided into phases that are themselves naturally redundant An algorithm may be be loosely correct <ref> [LaMG91] </ref> if the value of a component of the output of a phase is not equal to the value calculated by the algorithm, but its utilization in subsequent calculations will still lead to the expected results (those that would be achieved if only strictly correct values were used).
Reference: [LaSP82] <author> Lamport, L., Shostack, R. and Pease, M., </author> <title> ``The Byzantine General's Problem,'' </title> <journal> ACM Transaction on Programming Language Systems, </journal> <volume> vol. 4, </volume> <month> July </month> <year> 1982, </year> <pages> pp. 382-401. </pages>
Reference-contexts: Since the HAA system mimics the operational environment, in a system with no faults, assertions are checked by straightforward translation of postconditions, Q, into executable assertions. However, in the Byzantine <ref> [LaSP82] </ref> faulty environment, to operationally test executable assertions, it is necessary to ensure that faulty processors cannot fool executable assertions by incorrect augmented communication of GAV sets through sending inconsistent messages to different processors. The consistency executable assertions strengthen the effectiveness of the 2.1. <p> This case is coined the ``silent worker'' scenario. Generally, a w ay of testing the postcondition would be for each process to broadcast its perception of the best solution to all other processes. The consistency condition can then be ensured by using the Byzantine General's algorithm <ref> [LaSP82] </ref>. This is clearly infeasible due to the time overhead and connectivity requirements. This section introduces the notion of natural redundancy and demonstrates how this concept implies consistency.
Reference: [LeGr81] <author> Levin, G.M and Gries, </author> <title> David ``A Proof Technique for Communicating Sequential Process,'' </title> <journal> Acta Information, </journal> <volume> 15, </volume> <year> 1981, </year> <pages> 281-302. </pages>
Reference-contexts: The axiomatic proof system found in <ref> [LeGr81] </ref>, which is used for Hoare's model of concurrent programming, Communicating Sequential Processes (CSP) [Hoar78] forms the basis for the verification system used in this paper. 2.1. GAA Proof System A proof outline employing global auxiliary variables [LeGr81] as a proof aid is, perhaps, the easiest approach to reason about concurrent <p> The axiomatic proof system found in <ref> [LeGr81] </ref>, which is used for Hoare's model of concurrent programming, Communicating Sequential Processes (CSP) [Hoar78] forms the basis for the verification system used in this paper. 2.1. GAA Proof System A proof outline employing global auxiliary variables [LeGr81] as a proof aid is, perhaps, the easiest approach to reason about concurrent systems . In this system, processes in isolation are reasoned about. <p> The proof system in <ref> [LeGr81] </ref> makes use of global auxiliary variables (GAVs). Auxiliary variables can neither affect the ow of control nor the value of any non-auxiliary variables; otherwise, this unrestricted use of auxiliary variables would destroy the soundness of the proof system.
Reference: [LMSK63] <author> Little, J.D.C., et al. </author> <title> ``An Algorithm for the Traveling Salesman Problem,'' </title> <journal> Operations Research, </journal> <volume> Vol. 11, No. 6, </volume> <year> 1963, </year> <pages> pp. 972-989. </pages> -- -- 
Reference-contexts: Both the N Puzzle and the Traveling Salesman require the use of an optimization function to choose the next state to expand. The optimization function used in the Traveling Salesman algorithm is the one given by <ref> [LMSK63] </ref>. Furthermore, both optimization functions exhibit similar monotonic behavior. The only difference is in the definition of a state. In the N-Puzzle problem, a state was a particular configuration of a board.
Reference: [LuMc91b] <author> Lutfiyya, H. and McMillin, B. </author> <title> ``Formal Generation Of Executable Assertions For A Fault-Tolerant Parallel Matrix Relaxation,'' </title> <institution> UMR Department of Computer Science Technical Report CSC-91-13, </institution> <month> October, </month> <year> 1991. </year>
Reference: [LuMc91c] <author> Lutfiyya, H. and McMillin, B. </author> <title> ``Comparison of Three Axiomatic Systems for CSP,'' </title> <institution> UMR Department of Computer Science Technical Report CSC-91-07, </institution> <month> August, </month> <year> 1991. </year>
Reference-contexts: Hence, auxiliary variables are not necessary to the computation, but are essential for verification. Auxiliary variables The verification system was not chosen based on power <ref> [LuMc91c] </ref>, but rather out of convenience, since many people prefer shared memory programming, the global auxiliary system is used as a starting point. -- -- are used to record part of the history of the communication sequence.
Reference: [LuSM92] <author> Lutfiyya, H., Schollmeyer, M., and McMillin, B., </author> <title> ``Fault-Tolerant Distributed Sort Generated from a Verification Proof Outline,'' 2nd Responsive Systems Symposium, </title> <note> Springer-Verlag (to appear). </note>
Reference: [LuSM92a] <author> Lutfiyya, H., Schollmeyer, M., and McMillin, B., </author> <title> ``Formal Generation of Executable Assertions for Application-Oriented Fault Tolerance,'' </title> <institution> UMR Department of Computer Science Technical Report CSC-92-15, </institution> <month> October, </month> <year> 1992. </year>
Reference-contexts: Thus, to evaluate logical assertions containing global auxiliary variables at run time, requires an explicit updating mechanism to be created. The HAA verification proof system <ref> [LuSM92a] </ref>, where HAA is an abbreviation for "History of Auxiliary variables Approach", is a translation from the GAA proof system such that updates of global auxiliary variables are exchanged at communication time.
Reference: [MaML83] <author> Mahmood, A., McCluskey, E. J., and Lu, D. J. </author> <title> "Concurrent Fault Detection using a Watchdog Processor and Assertions", </title> <booktitle> IEEE 1983 Int'l Test Conf. </booktitle> <pages> pp. 622-628. </pages>
Reference: [McNi88] <author> McMillin, B. and Ni, L., </author> <title> ``Executable Assertion Development for the Distributed Parallel Environment,'' </title> <booktitle> Proceedings of the 12th International COMPSAC, </booktitle> <address> Chicago, IL, </address> <month> October </month> <year> 1988, </year> <pages> pp. 284-291. </pages>
Reference: [McNi89] <author> McMillin, B. and Ni, L., </author> <title> ``A Reliable Parallel Algorithm for Relaxation Labeling,'' Parallel Processing for Computer Vision and Display, </title> <editor> P. M. Dew, R. A. Earnshaw, and T. R. Heywood, eds., Addi-son-Wesley, </editor> <year> 1989, </year> <pages> pp. 190-209. </pages>
Reference: [McNi92] <author> McMillin, B. and Ni, L., </author> <title> ``Reliable Distributed Sorting Through The Application-oriented Fault Tolerance Paradigm,'' </title> <journal> IEEE Transactions on Parallel and Distributed Computing, </journal> <volume> Vol. 3, No. 4, </volume> <pages> pp. 411-420. </pages>
Reference: [Mili81] <author> Mili, A. </author> <title> ``Self-Checking Programs: An Axiomatization of Program Validation by Executable Assertions,'' </title> <booktitle> 11th Annual Int'l Symp. on Fault-Tolerant Computing, </booktitle> <year> 1981, </year> <pages> pp 118-120. </pages>
Reference: [Quin88] <author> Quinn, M. J., </author> <title> Designing Efficient Algorithms for Parallel Computers, </title> <publisher> McGraw Hill, </publisher> <year> 1988, </year> <pages> pp. 185-195. </pages>
Reference-contexts: The algorithm described in this paper is the N Puzzle Problem where N+1 is a perfect square. The description of the problem is given below. 1 2 3 7 6 5 5 4 7 Most people are familiar with the N Puzzle Problem <ref> [Quin88] </ref>. The initial board configuration for the N Puzzle Problem consists of N+1 tile positions with N tiles distinctly numbered ranging from 1 to N, with 0 representing a blank space as shown in Figure 3.1.
Reference: [Rand75] <author> Randell, Brian, </author> <title> "System Structure for Software Fault Tolerance," </title> <journal> IEEE Trans. on Software Engineering, </journal> <volume> Vol. SE-1, No. 2, </volume> <month> June </month> <year> 1975 </year>
Reference: [ScSc84] <author> Schlichting, R., and Schneider, F., </author> <title> ``Using Message Passing For Distributed Programming: Proof Rules and Disciplines,'' </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> vol. 6, No. 3, </volume> <month> July </month> <year> 1984, </year> <pages> pp. 402-431. </pages>
Reference-contexts: In order to relate the different interleavings of processes via interleaved communication histories on the global auxiliary variables requires a proof of ``non-interference'', or a proof that executions in one process do not affect assertions in another and a ``satisfaction'' proof to show soundness. In the asynchronous message-passing environment <ref> [ScSc84] </ref>, each pair of processors i and j has two auxiliary variables s ij , r ij , where s ij is the set of all messages sent from process i to process j and r ij is the set of all messages j actually receives from i.
Reference: [Soun84] <author> Soundararajan, </author> <title> N ``Axiomatic Semantics of Communicating Sequential Processes,'' </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 6, 4, </volume> <year> 1984, </year> <pages> 647-662. </pages>
Reference-contexts: T denotes the time at which the value Val was assigned to variable Var and C denotes the communication path. It is important to note that these tuples are different from those defined in the verification system of <ref> [Soun84] </ref>.
Reference: [Vorn87] <author> Vornberger, Oliver, </author> <title> "Fault Tolerant Parallelization of Branch-&-Bound Algorithms ," The 7th Distributed Computing Symposium, </title> <booktitle> 1987, </booktitle> <pages> pp. 194-199. </pages>
Reference: [Wens78] <editor> Wensley, J.H. et al., "SIFT: </editor> <title> Design and Analysis of a Fault-Tolerant Computer for Aircraft Control," </title> <journal> Proc. IEEE, </journal> <volume> Vol. 66, No. 10, </volume> <month> Oct. </month> <year> 1978, </year> <pages> pp. </pages> <month> 1,240-1,255. </month>
Reference: [YaCh75] <author> Yau, S. S. and Cheung R. C. </author> <title> ``Design of Self-Checking Software,'' </title> <booktitle> Proc. Int'l Conf. on Reliability Software, </booktitle> <month> April </month> <year> 1975, </year> <pages> pp 450-457. </pages> -- --
References-found: 28

