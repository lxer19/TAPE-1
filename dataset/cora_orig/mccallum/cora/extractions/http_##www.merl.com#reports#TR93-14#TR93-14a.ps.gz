URL: http://www.merl.com/reports/TR93-14/TR93-14a.ps.gz
Refering-URL: http://www.merl.com/reports/TR93-14/index.html
Root-URL: http://www.aic.nrl.navy.mil/~aha/people.html
Email: osborne@merl.com  
Author: Randy B. Osborne 
Address: Cambridge, Massachusetts 02139  
Note: To be published in Proceedings of the 1992 Parallel Symbolic Computing Workshop at M.I.T. in Springer-Verlag Lecture Notes on Computer Science,  Copyright c Mitsubishi Electric Research Laboratories, 1993 201 Broadway,  
Date: 93-14 July 1993  November 1993.  
Affiliation: MITSUBISHI ELECTRIC RESEARCH LABORATORIES CAMBRIDGE RESEARCH CENTER  
Pubnum: Technical Report  
Abstract: Speculative computing is a technique to improve the execution time of certain applications by starting some computations before it is known that the computations are required. A speculative computation will eventually become mandatory (i.e. required) or irrelevant (i.e. not required). In the absence of side effects irrelevant computations may be aborted. However, with side effects a computation which is irrelevant for the value it produces may still be relevant for the side effects it performs. One problem that can result is the relevant synchronization problem wherein one computation requires some side effect event (a "relevant synchronization") to be performed by another computation, which might be aborted, before the first computation can make progress. Another problem that can arise is the preemptive delay problem wherein a computation that will perform some awaited side effect event is preempted by a computation whose importance (e.g. priority) is less than that of computations waiting for the event. In this paper we show how the sponsor model developed for speculative computation in Multilisp can be extended to provide a novel solution to these two problems. The idea is for the computation awaiting some action, such as the production of a value or the release of a semaphore, to sponsor the computation or set of computations that will perform the awaited action. This sponsorship ensures that the awaited action executes, and executes with at least the waiter's level of importance. We show how to apply this technique to solve the above problems for several producer/consumer and semaphore applications. The idea extends naturally to other synchronization mechanisms. This work may not be copied or reproduced in whole or in part for any commercial purpose. Permission to copy in whole or in part without payment of fee is granted for nonprofit educational and research purposes provided that all such whole or partial copies include the following: a notice that such copying is by permission of Mitsubishi Electric Research Laboratories of Cambridge, Massachusetts; an acknowledgment of the authors and individual contributions to the work; and all applicable portions of the copyright notice. Copying, reproduction, or republishing for any other purpose shall require a license with payment of fee to Mitsubishi Electric Research Laboratories. All rights reserved. 
Abstract-found: 1
Intro-found: 1
Reference: [AS84] <author> H. Abelson and G. Sussman. </author> <title> Structure and Interpretation of Computer Programs. </title> <publisher> M.I.T. Press, </publisher> <address> Cambridge, MA., </address> <year> 1984. </year>
Reference-contexts: While we are primarily interested in side effect-free applications (we believe side effects should be used sparingly), there are many applications for which side effects add important expressive power (see, for example, the discussion in Chapter 3 of <ref> [AS84] </ref>). Thus it is important to examine the issues with side effects. We restrict our scope in this paper to the issues involved with intertask synchronization side effects by which we mean broadly any side effect that can directly affect the progress of another task. <p> Queued readers have priority on admission to the critical region over new readers. When a writer enters the 11 Streams <ref> [AS84] </ref> provide a more elegant way to achieve producer-consumer synchronization. However, buffer-based formulations offer better control over storage use.
Reference: [GG89] <author> R. Goldman and R. Gabriel. </author> <title> Qlisp: </title> <booktitle> Parallel processing in Lisp. IEEE Software, </booktitle> <pages> pages 51-59, </pages> <month> July </month> <year> 1989. </year>
Reference-contexts: In contrast, aborting is a common event in speculative computation so more liberal solutions are necessary. The works closest in spirit to ours are Multi-Scheme [Mil87] and Qlisp <ref> [GM87, GG89] </ref> which both have some support for speculative styles of computation. Both provide support for aborting tasks and thus suffer from the speculative deadlock/relevant synchronization problem. MultiScheme uses "finalization" to solve this problem.
Reference: [GM87] <author> R. Gabriel and J. McCarthy. </author> <title> Qlisp. </title> <editor> In J. Kowalik, editor, </editor> <booktitle> Parallel Computation and Computers for Artificial Intelligence. </booktitle> <publisher> Kluwer Academic Publishers, </publisher> <year> 1987. </year>
Reference-contexts: In contrast, aborting is a common event in speculative computation so more liberal solutions are necessary. The works closest in spirit to ours are Multi-Scheme [Mil87] and Qlisp <ref> [GM87, GG89] </ref> which both have some support for speculative styles of computation. Both provide support for aborting tasks and thus suffer from the speculative deadlock/relevant synchronization problem. MultiScheme uses "finalization" to solve this problem.
Reference: [Hal85] <author> R. Halstead. </author> <title> Multilisp: A language for concurrent symbolic computation. </title> <journal> ACM Trans. on Prog. Languages and Systems, </journal> <pages> pages 501-538, </pages> <month> October </month> <year> 1985. </year>
Reference-contexts: Section 3 illustrates the relevant synchronization and preemptive delay problems by examining two producer-consumer and three semaphore applications. Section 4 solves the problems with the examples in Section 3 within our sponsor model. Section 5 discusses related work and Section 6 concludes the paper. 2 Background 2.1 Multilisp Multilisp <ref> [Hal85] </ref> is a version of the Scheme programming language [IEE91] extended with explicit parallelism constructs. Multilisp is based on a shared memory paradigm and includes all the side effects of Scheme. (future exp) creates a task to evaluate exp and immediately returns a placeholder for the result. <p> These operations are indivisible. (signal-sema sema) makes the semaphore sema free if no tasks are queued on sema; otherwise, it dequeues and resumes one of the tasks enqueued on sema. These operations are indivisible. Semaphore requests are queued for resumption in first-come-first-served (FCFS) order. See <ref> [Hal85] </ref> or [Osb89] for additional Multilisp constructs. For the purposes of this paper Multilisp does not include Scheme's call-with-current-continuation.
Reference: [Her91] <author> M. Herlihy. </author> <title> Wait free synchronization. </title> <journal> ACM Trans. on Prog. Languages and Systems, </journal> <month> January </month> <year> 1991. </year>
Reference-contexts: Thus there is no critical section in which a task can be stayed or preempted. (This compare-and-swap technique is the basis of "wait-free" synchronization <ref> [Her91] </ref>.) For example, a semaphore-enforced critical section operation to add an element element to the head of a difference list (a list represented by a pair with pointers to the head and tail of the list) can be transformed to a copy-and-compare pointer operation as shown below (we assume the difference
Reference: [IEE91] <editor> IEEE Std 1178-1990. </editor> <title> IEEE Standard for the Scheme Programming Language. </title> <publisher> Institute of Electrical and Electronic Engineers, Inc., </publisher> <address> New York, NY, </address> <year> 1991. </year>
Reference-contexts: Section 4 solves the problems with the examples in Section 3 within our sponsor model. Section 5 discusses related work and Section 6 concludes the paper. 2 Background 2.1 Multilisp Multilisp [Hal85] is a version of the Scheme programming language <ref> [IEE91] </ref> extended with explicit parallelism constructs. Multilisp is based on a shared memory paradigm and includes all the side effects of Scheme. (future exp) creates a task to evaluate exp and immediately returns a placeholder for the result.
Reference: [KH81] <author> W. Kornfeld and C. Hewitt. </author> <title> The scientific community metaphor. </title> <journal> IEEE Trans. on Systems, Man, and Cybernetics, </journal> <pages> pages 24-33, </pages> <month> January </month> <year> 1981. </year>
Reference-contexts: Sha et al considered only simple applications, such as the semaphore serializer in 17 Kornfeld and Hewitt proposed the idea of sponsors in <ref> [KH81] </ref> but to our knowledge neither they nor anyone else has used sponsors to solve the relevant synchronization and preemptive delay problems. Extending the Multilisp Sponsor Model July 1993 27 Example 1, for which the tasks producing a synchronizing event (the synchronizer tasks) are implicitly well-defined.
Reference: [KHM89] <author> D. Kranz, R. Halstead, and E. Mohr. Mul-T: </author> <title> A high-performance parallel Lisp. </title> <booktitle> In SigPlan Conf. on Prog. Language Design and Implementation, </booktitle> <pages> pages 81-90, </pages> <year> 1989. </year>
Reference: [KW90] <author> M. Katz and D. Weise. </author> <title> Continuing into the Future: On the interaction of Futures and First-class Continuations. </title> <booktitle> In ACM Conference on Lisp and Functional Programming, </booktitle> <year> 1990. </year>
Reference-contexts: These operations are indivisible. Semaphore requests are queued for resumption in first-come-first-served (FCFS) order. See [Hal85] or [Osb89] for additional Multilisp constructs. For the purposes of this paper Multilisp does not include Scheme's call-with-current-continuation. In the presence of side effects, continuations pose some difficult problems in Multilisp (see <ref> [KW90] </ref>). 2.2 Speculative Computation in Multilisp In other work [Osb90a, Osb90b, Osb89] we developed a sponsor model for speculative computation in Multilisp. Computation proceeds in this model by specifying both an expression to be evaluated 3 and a sponsorship source (a sponsor). Sponsorship is an abstraction of machine resources.
Reference: [LR80] <author> B. Lampson and D. Redell. </author> <title> Experience with Processes and Monitors in Mesa. </title> <journal> Communications of the ACM, </journal> <pages> pages 105-117, </pages> <month> February </month> <year> 1980. </year>
Reference-contexts: Consequently the waiting computations E,F ,G,: : : may be delayed by a computation of lessor importance. 1 Preemptive delay is a problem in any environment with preemption, and is not restricted to speculative computation or our sponsor model. For example, the preemptive delay problem was first examined by <ref> [LR80] </ref> in the context of monitors. To illustrate the relevant synchronization and preemptive delay problems we examine five different applications, three involving semaphores and two involving producer-consumer synchronization. <p> There are three approaches to the preemptive delay problem. One approach is to make tasks non-preemptable in the critical section, but like the non-stayable region, this is overkill because it prevents preemptions if there are no waiters of higher priority. A second approach, used by Mesa <ref> [LR80] </ref>, is to execute the task in the critical section at a priority higher than that of all tasks that could ever attempt to ever the critical section.
Reference: [Mil87] <author> J. Miller. MultiScheme: </author> <title> A parallel processing system based on MIT Scheme. </title> <type> Technical Report TR-402, </type> <institution> Laboratory for Computer Science, M.I.T., </institution> <month> September </month> <year> 1987. </year>
Reference-contexts: In contrast, aborting is a common event in speculative computation so more liberal solutions are necessary. The works closest in spirit to ours are Multi-Scheme <ref> [Mil87] </ref> and Qlisp [GM87, GG89] which both have some support for speculative styles of computation. Both provide support for aborting tasks and thus suffer from the speculative deadlock/relevant synchronization problem. MultiScheme uses "finalization" to solve this problem.
Reference: [Osb89] <author> R. Osborne. </author> <title> Speculative computation in Multilisp. </title> <type> Technical Report TR-464, </type> <institution> Laboratory for Computer Science, M.I.T., </institution> <month> November </month> <year> 1989. </year> <title> Extending the Multilisp Sponsor Model July 1993 29 </title>
Reference-contexts: 1 Introduction Speculative computing is a technique to improve the execution time of appropriate applications by starting some computations before it is known that the computations are required. A speculative computation will eventually become mandatory (i.e. required) or irrelevant (i.e. not required). In previous work <ref> [Osb90a, Osb90b, Osb89] </ref> we presented a sponsor model for speculative computation and demonstrated how this model adds expressive and computational power to Multilisp. However, there were many issues concerning side effects that we did not consider, particularly in the context of aborting irrelevant computations. <p> These operations are indivisible. (signal-sema sema) makes the semaphore sema free if no tasks are queued on sema; otherwise, it dequeues and resumes one of the tasks enqueued on sema. These operations are indivisible. Semaphore requests are queued for resumption in first-come-first-served (FCFS) order. See [Hal85] or <ref> [Osb89] </ref> for additional Multilisp constructs. For the purposes of this paper Multilisp does not include Scheme's call-with-current-continuation. <p> See [Hal85] or [Osb89] for additional Multilisp constructs. For the purposes of this paper Multilisp does not include Scheme's call-with-current-continuation. In the presence of side effects, continuations pose some difficult problems in Multilisp (see [KW90]). 2.2 Speculative Computation in Multilisp In other work <ref> [Osb90a, Osb90b, Osb89] </ref> we developed a sponsor model for speculative computation in Multilisp. Computation proceeds in this model by specifying both an expression to be evaluated 3 and a sponsorship source (a sponsor). Sponsorship is an abstraction of machine resources. <p> Touch and determine automatically trigger the addition and removal, respectively, of toucher sponsors. * Controller sponsors | Controller sponsors receive sponsorship and actively distribute it among the tasks in their control domain according to some built-in control strategy. See [Osb90a] or <ref> [Osb89] </ref> for further details of this model. 2 There is also an analagous rplacd-eq extension of Scheme's set-cdr! mutator. 3 The environment for evaluation is the lexical environment in which the expression appears. <p> Thus a stayed task may be restarted by re-sponsoring the task so that the task's effective priority becomes greater than 0. Of the many language extensions to Multilisp to implement this sponsor model subset we discuss only those few that are pertinent to the discussion in this paper. See <ref> [Osb89, Osb90b, Osb90a] </ref> for the full set of extensions. (make-sponsor-class class-type) creates and returns a class object. A class is a collection of tasks and a controller sponsor. <p> Suppose, for example, that there is a single reader in the system at line 9 and suppose that before 12 This contrived example is a simplification of a real problem | the implementation of monitors with semaphores [SG91]. See <ref> [Osb89] </ref> for details. Extending the Multilisp Sponsor Model July 1993 12 this reader arrives at line 10 a writer enters the critical section, updates the database, and exits the critical section.
Reference: [Osb90a] <author> R. Osborne. </author> <title> Speculative computation in Multilisp. </title> <editor> In T. Ito and R. Halstead, editors, </editor> <booktitle> Parallel Lisp: Languages and Systems, Proceedings of U.S./Japan Workshop on Parallel Lisp. Lecture Notes in Computer Science, </booktitle> <publisher> Springer-Verlag, </publisher> <address> Number 441, </address> <month> July </month> <year> 1990. </year>
Reference-contexts: 1 Introduction Speculative computing is a technique to improve the execution time of appropriate applications by starting some computations before it is known that the computations are required. A speculative computation will eventually become mandatory (i.e. required) or irrelevant (i.e. not required). In previous work <ref> [Osb90a, Osb90b, Osb89] </ref> we presented a sponsor model for speculative computation and demonstrated how this model adds expressive and computational power to Multilisp. However, there were many issues concerning side effects that we did not consider, particularly in the context of aborting irrelevant computations. <p> See [Hal85] or [Osb89] for additional Multilisp constructs. For the purposes of this paper Multilisp does not include Scheme's call-with-current-continuation. In the presence of side effects, continuations pose some difficult problems in Multilisp (see [KW90]). 2.2 Speculative Computation in Multilisp In other work <ref> [Osb90a, Osb90b, Osb89] </ref> we developed a sponsor model for speculative computation in Multilisp. Computation proceeds in this model by specifying both an expression to be evaluated 3 and a sponsorship source (a sponsor). Sponsorship is an abstraction of machine resources. <p> Touch and determine automatically trigger the addition and removal, respectively, of toucher sponsors. * Controller sponsors | Controller sponsors receive sponsorship and actively distribute it among the tasks in their control domain according to some built-in control strategy. See <ref> [Osb90a] </ref> or [Osb89] for further details of this model. 2 There is also an analagous rplacd-eq extension of Scheme's set-cdr! mutator. 3 The environment for evaluation is the lexical environment in which the expression appears. <p> Thus a stayed task may be restarted by re-sponsoring the task so that the task's effective priority becomes greater than 0. Of the many language extensions to Multilisp to implement this sponsor model subset we discuss only those few that are pertinent to the discussion in this paper. See <ref> [Osb89, Osb90b, Osb90a] </ref> for the full set of extensions. (make-sponsor-class class-type) creates and returns a class object. A class is a collection of tasks and a controller sponsor. <p> We will discuss the consequence of this later. 3.3 Example 3: Multiple Potential Determiners Multiple potential determiners for a placeholder is an example of multiple-approach speculative computation (see [Osb90b] or <ref> [Osb90a] </ref>), a fairly common instance of speculative computing. Figure 2 shows such an example where we are interested only in the first solution to a set of problems. For simplicity, we assume that a solution will be found for at least one of the problems.
Reference: [Osb90b] <author> R. Osborne. </author> <title> Speculative computation in Multilisp: An overview. </title> <booktitle> In ACM Conference on Lisp and Functional Programming, </booktitle> <year> 1990. </year>
Reference-contexts: 1 Introduction Speculative computing is a technique to improve the execution time of appropriate applications by starting some computations before it is known that the computations are required. A speculative computation will eventually become mandatory (i.e. required) or irrelevant (i.e. not required). In previous work <ref> [Osb90a, Osb90b, Osb89] </ref> we presented a sponsor model for speculative computation and demonstrated how this model adds expressive and computational power to Multilisp. However, there were many issues concerning side effects that we did not consider, particularly in the context of aborting irrelevant computations. <p> See [Hal85] or [Osb89] for additional Multilisp constructs. For the purposes of this paper Multilisp does not include Scheme's call-with-current-continuation. In the presence of side effects, continuations pose some difficult problems in Multilisp (see [KW90]). 2.2 Speculative Computation in Multilisp In other work <ref> [Osb90a, Osb90b, Osb89] </ref> we developed a sponsor model for speculative computation in Multilisp. Computation proceeds in this model by specifying both an expression to be evaluated 3 and a sponsorship source (a sponsor). Sponsorship is an abstraction of machine resources. <p> Thus a stayed task may be restarted by re-sponsoring the task so that the task's effective priority becomes greater than 0. Of the many language extensions to Multilisp to implement this sponsor model subset we discuss only those few that are pertinent to the discussion in this paper. See <ref> [Osb89, Osb90b, Osb90a] </ref> for the full set of extensions. (make-sponsor-class class-type) creates and returns a class object. A class is a collection of tasks and a controller sponsor. <p> Thus a reader cannot necessarily identify which task is responsible for its lack of progress (by failing to release the semaphore). We will discuss the consequence of this later. 3.3 Example 3: Multiple Potential Determiners Multiple potential determiners for a placeholder is an example of multiple-approach speculative computation (see <ref> [Osb90b] </ref> or [Osb90a]), a fairly common instance of speculative computing. Figure 2 shows such an example where we are interested only in the first solution to a set of problems. For simplicity, we assume that a solution will be found for at least one of the problems.
Reference: [Osb92] <author> R. Osborne. </author> <title> Details on Extending the Multilisp Sponsor Model to Handle Semaphore-based Intertask Synchronization. </title> <institution> Mitsubishi Electric Research Labs, </institution> <note> Technical Note, </note> <month> October </month> <year> 1992. </year>
Reference-contexts: Finally, waiter-class has class type sponsor-max-priority so that we do not disrupt the priority ordering of queued readers. We give a formal derivation of correctness of this solution in another paper <ref> [Osb92] </ref>. 4.8 Summary and Discussion Through our five examples, we have illustrated the relevant synchronization and preemptive delay problems and shown how to extend our sponsor model to solve these problems in each case. Each example makes a different point.
Reference: [Ran75] <author> B. Randell. </author> <title> System Structure for Software Fault Tolerance. </title> <booktitle> In International Conference on Reliable Software, </booktitle> <pages> pages 437-449, </pages> <year> 1975. </year>
Reference-contexts: Of course, it may be possible to perform roll-back using some sort of checkpointing scheme (e.g. recovery blocks <ref> [Ran75] </ref>), wherein the system state is restored to the state at some previous checkpoint. This seems unduly expensive. Now consider the case of the stayed producers in the producer-consumer synchronization between writers and readers.
Reference: [RSL88] <author> R. Rajkumar, L. Sha, and J.P. Lehoczky. </author> <title> Real-Time Synchronization Protocols for Multiprocessors. </title> <booktitle> In Proceedings of Real-time Systems Symposium, </booktitle> <month> December </month> <year> 1988. </year>
Reference-contexts: Sha et al suggested priority inheritance protocols in which a task in a critical section executes at the priority of at least the maximum priority task waiting to enter that region <ref> [SRL87, RSL88] </ref>. Sha et al considered only simple applications, such as the semaphore serializer in 17 Kornfeld and Hewitt proposed the idea of sponsors in [KH81] but to our knowledge neither they nor anyone else has used sponsors to solve the relevant synchronization and preemptive delay problems.
Reference: [SG91] <author> J. Silberschatz, A. Peterson and P. Galvin. </author> <title> Operating System Concepts, 3rd Edition. </title> <publisher> Addison-Wesley, </publisher> <year> 1991. </year>
Reference-contexts: | serializers In a semaphore serializer, each task wishing to serialize some action (with respect to other tasks) executes the following simple code sequence: (wait-sema sema) some action ; critical section (mutual exclusion region) (signal-sema sema) In addition to mutual exclusion, the usual requirements for such a serializer (see, e.g. <ref> [SG91] </ref>) include bounded waiting which implies bounded access time and fairness (in the sense that no process can wait indefinitely for access while others proceed). <p> Suppose, for example, that there is a single reader in the system at line 9 and suppose that before 12 This contrived example is a simplification of a real problem | the implementation of monitors with semaphores <ref> [SG91] </ref>. See [Osb89] for details. Extending the Multilisp Sponsor Model July 1993 12 this reader arrives at line 10 a writer enters the critical section, updates the database, and exits the critical section.

References-found: 18

