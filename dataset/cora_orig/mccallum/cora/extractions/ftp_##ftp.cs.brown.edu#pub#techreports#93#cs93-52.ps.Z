URL: ftp://ftp.cs.brown.edu/pub/techreports/93/cs93-52.ps.Z
Refering-URL: http://www.cs.brown.edu/publications/techreports/reports/CS-93-52.html
Root-URL: http://www.cs.brown.edu/
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> M. Bruynooghe. </author> <title> A Practical Framework for the Abstract Interpretation of Logic Programs. </title> <journal> Journal of Logic Programming, </journal> <volume> 10 </volume> <pages> 91-124, </pages> <year> 1991. </year>
Reference-contexts: The algorithm uses memoization, a dependency graph to avoid redundant computation, the abstract operations of the abstract semantics, and the ordering relation on the abstract domain. It has many similarities with PLAI [18] and can be seen either as an implementation of Bruynooghe's framework <ref> [1] </ref> or as an instance of a general fixpoint algorithm [13]. In the experimental results, we use the prefix version of the algorithm [6]. 5 The Generic Pattern Domain In this section, we briefly recall the basic notions behind the generic abstract domain Pat (R).
Reference: [2] <author> M Bruynooghe and G Janssens. </author> <title> An Instance of Abstract Interpretation: Integrating Type and Mode Inferencing. </title> <booktitle> In Proc. Fifth International Conference on Logic Programming, </booktitle> <pages> pages 669-683, </pages> <address> Seattle, WA, </address> <month> August </month> <year> 1988. </year>
Reference-contexts: A type inference system based on this approach was developed by Heintze [8] and the experimental results (on programs up to 32 clauses) indicate that there is hope to make this approach practical. Another line of research is the approach of Bruynooghe and Janssens (e.g. <ref> [2, 10] </ref>) which is based on a traditional abstract interpretation approach [4]. The key idea is to approximate a collecting semantics of the language by an abstract semantics where sets of substitutions are described by type graphs, i.e. disjunctive rational trees.
Reference: [3] <author> A. Cortesi, B. Le Charlier, and P. Van Hentenryck. </author> <title> Combinations of Abstract Domains for Logic Programming. </title> <booktitle> In 21st Annual ACM SIGPLAN-SIGACT Symposium on Principles Of Programming Languages, </booktitle> <address> Portland, OR, </address> <month> January </month> <year> 1994. </year>
Reference-contexts: The system is best described as GAIA (Pat (Type)), where GAIA is a generic top-down fixpoint algorithm for Prolog [12, 6] 2 , Pat is a generic pattern domain for structural information <ref> [3] </ref>, and Type is a type graph domain. The main contribution of the system (about 15,000 lines of C) is to show that type analysis based on abstract interpretation and type graphs can be engineered to be practical, at least for medium-sized programs (up to 450 lines of Prolog).
Reference: [4] <author> P Cousot and R. Cousot. </author> <title> Abstract Interpretation: A Unified Lattice Model for Static Analysis of Programs by Construction or Approximation of Fixpoints. </title> <booktitle> In Conf. Record of Fourth ACM Symposium on Programming Languages (POPL'77), </booktitle> <pages> pages 238-252, </pages> <address> Los Angeles, CA, </address> <year> 1977. </year>
Reference-contexts: Another line of research is the approach of Bruynooghe and Janssens (e.g. [2, 10]) which is based on a traditional abstract interpretation approach <ref> [4] </ref>. The key idea is to approximate a collecting semantics of the language by an abstract semantics where sets of substitutions are described by type graphs, i.e. disjunctive rational trees. A fixpoint algorithm is then used to compute the least fixpoint or a postfixpoint of the abstract semantics. <p> The framework is presented in details in [12] and is close to the work of Marriott and Sondergaard [14] and Winsborough [22]. It follows the traditional approach to abstract interpretation <ref> [4] </ref>. Concrete Semantics As is traditional in abstract interpretation, the starting point of the analysis is a collecting semantics for the programming language. Our concrete semantics is a collecting fixpoint semantics which captures the top-down execution of logic programs using a left-to-right computation rule and ignores the clause selection rule. <p> To overcome this difficulty, Bruynooghe and Janssens [10] use a finite subdomain by restricting the number of occurrences of a functional symbol on the paths of the graphs. We adopted a different, less syntactic, solution based on a widening operator as proposed in <ref> [4] </ref>. The design of widening operators is experimental in nature and it affects both the performance and accuracy of the analysis. The examples given previously in the paper shows that our widening operator leads to accurate results and is effective in keeping the graph sizes small.
Reference: [5] <author> M. Dincbas, H. Simonis, and P. Van Hentenryck. </author> <title> Solving Large Combinatorial Problems in Logic Programming. </title> <journal> Journal of Logic Programming, </journal> <volume> 8(1-2):75-93, </volume> <year> 1990. </year>
Reference-contexts: PR is a symbolic equation-solver [19]. CS is a program to generate a number of configurations representing various ways of cutting a wood board into small shelves [20]. DS is the generate and test equivalent of a disjunctive scheduling problem <ref> [5] </ref>. RE is the Prolog tokeniser and reader of R.O'keefe and D.H.D.Warren. PG is a program written by W. Older to solve a specific mathematical problem. BR is a program taken from Gabriel benchmark. PL is a planning program from [19]. QU solves the n-queens problem.
Reference: [6] <author> V. Englebert, B. Le Charlier, D. Roland, and P. Van Hentenryck. </author> <title> Generic Abstract Interpretation Algorithms for Prolog: Two Optimization Techniques and Their Experimental Evaluation. </title> <journal> Software Practice and Experience, </journal> <volume> 23(4), </volume> <month> April </month> <year> 1993. </year>
Reference-contexts: The purpose of this paper is to describe the design and implementation of a type system based on the second approach. The system is best described as GAIA (Pat (Type)), where GAIA is a generic top-down fixpoint algorithm for Prolog <ref> [12, 6] </ref> 2 , Pat is a generic pattern domain for structural information [3], and Type is a type graph domain. <p> It has many similarities with PLAI [18] and can be seen either as an implementation of Bruynooghe's framework [1] or as an instance of a general fixpoint algorithm [13]. In the experimental results, we use the prefix version of the algorithm <ref> [6] </ref>. 5 The Generic Pattern Domain In this section, we briefly recall the basic notions behind the generic abstract domain Pat (R).
Reference: [7] <author> T. Fruehwirth, E. Shapiro, M. Vardi, and E. Yardeni. </author> <title> Logic Programs as Types for Logic Programs. </title> <booktitle> In IEEE 6th Annual Symposium on Logic in Computer Science, </booktitle> <pages> pages 300-309, </pages> <year> 1991. </year>
Reference-contexts: Extensive research has been devoted to type inference in logic programming, although few systems have actually been developed. A popular line of research, called the cartesian closure approach in [9], was initiated by [15] and further developed in many authors (See <ref> [7] </ref> for a complete account). The key idea is to approximate the traditional T p operator by replacing substitutions by sets of substitutions and using a cartesian closure operator to ignore inter-variable and inter-argument dependencies. <p> The type inference problem in this approach was shown to be decidable by Heintze and Jaffar [9] using a reduction to set constraints. By reducing the problem to the inference of (a subclass of) monadic logic programs, Fruehwirth et al. <ref> [7] </ref> gave an exponential lower bound for type checking and an exponential algorithm for type inference. The appealing feature of this approach is that the problem is amenable to precise characterization and hence its properties can be studied more easily. <p> The rule associated with an any-vertex is simply T v ::= Any. In the presentation of the results, we generally apply some partial evaluation of the grammar to improve its readability. 9 Relation to Monadic Logic Programs Type graphs can also be related to monadic logic programs of <ref> [7] </ref>. The logic program associated with a type graph succeeds for all well-typed terms. A simple way is to associate a procedure p v with each vertex v. The procedure for an any-vertex is simply any (X).
Reference: [8] <author> N. Heintze. </author> <title> Practical Aspects of Set-based Analysis. </title> <booktitle> In Proceedings of the International Joint Conference and Symposium on Logic Programming (JICSLP-92), </booktitle> <address> Washington, DC, </address> <month> November </month> <year> 1992. </year>
Reference-contexts: Its limitation for type analyis is that the relationships between predicate arguments are ignored which may entail a loss of precision and makes it difficult to integrate the system with other analyses such as modes and sharing. A type inference system based on this approach was developed by Heintze <ref> [8] </ref> and the experimental results (on programs up to 32 clauses) indicate that there is hope to make this approach practical. Another line of research is the approach of Bruynooghe and Janssens (e.g. [2, 10]) which is based on a traditional abstract interpretation approach [4].
Reference: [9] <author> N. Heintze and J. Jaffar. </author> <title> A Finite Presentation Theorem for Approximating Logic Programs. </title> <booktitle> In Proc. 17th ACM Symp. on Principles of Programming Languages, </booktitle> <pages> pages 197-209, </pages> <year> 1990. </year>
Reference-contexts: Information about the functor of the second argument would only enable to specialize the first call to insert. Extensive research has been devoted to type inference in logic programming, although few systems have actually been developed. A popular line of research, called the cartesian closure approach in <ref> [9] </ref>, was initiated by [15] and further developed in many authors (See [7] for a complete account). The key idea is to approximate the traditional T p operator by replacing substitutions by sets of substitutions and using a cartesian closure operator to ignore inter-variable and inter-argument dependencies. <p> This approach originated in type checking applications but can be used for type analysis as well. The type inference problem in this approach was shown to be decidable by Heintze and Jaffar <ref> [9] </ref> using a reduction to set constraints. By reducing the problem to the inference of (a subclass of) monadic logic programs, Fruehwirth et al. [7] gave an exponential lower bound for type checking and an exponential algorithm for type inference.
Reference: [10] <author> G. Janssens and M. Bruynooghe. </author> <title> Deriving Description of Possible Values of Program Variables by Means of Abstract Interpretation. </title> <journal> Journal of Logic Programming, </journal> <volume> 13(2-3):205-258, </volume> <year> 1992. </year>
Reference-contexts: A type inference system based on this approach was developed by Heintze [8] and the experimental results (on programs up to 32 clauses) indicate that there is hope to make this approach practical. Another line of research is the approach of Bruynooghe and Janssens (e.g. <ref> [2, 10] </ref>) which is based on a traditional abstract interpretation approach [4]. The key idea is to approximate a collecting semantics of the language by an abstract semantics where sets of substitutions are described by type graphs, i.e. disjunctive rational trees. <p> The drawback is that the result of the analysis is more difficult to characterize formally as the design of the abstract domain is an experimental endeavour. This approach has been implemented in a prototype system <ref> [10] </ref> but experimental results have only been reported on very small programs and were not very encouraging. Hence the practicability of this approach remains open. <p> This allows the domain Type to be kept as simple as possible and should be contrasted with the approach of <ref> [10] </ref> where both information are handled in the same domain. The key intuition behind Pat (R) is to represent information on some subterms occurring in a substitution instead of information on terms bound to variables only. <p> We start with type graphs and then define the domain, its operations, and the widening operator. 6.1 Type Graphs Our type graphs are essentially what Bruynooghe and Janssens call rigid types and readers are referred to <ref> [10] </ref> for a complete coverage of type graphs. Our presentation uses more algorithmic concepts to simplify the rest of the presentation. <p> Restrictions 1,2, and 4 are adaptations of similar restrictions in <ref> [10] </ref>. The second restriction actually reduces the expressive power of type graphs and is called the principal functor restriction in [10] (pf-restriction for short). Restriction 3 requires cycles to start at functor-vertices and to end at or-vertices while restriction 4 prevents subgraphs from sharing. <p> Restrictions 1,2, and 4 are adaptations of similar restrictions in <ref> [10] </ref>. The second restriction actually reduces the expressive power of type graphs and is called the principal functor restriction in [10] (pf-restriction for short). Restriction 3 requires cycles to start at functor-vertices and to end at or-vertices while restriction 4 prevents subgraphs from sharing. When these restrictions are adopted, it makes sense to refer to the pf-set of an or-vertex as the set of all functors of its successors. <p> The first two operations are described in <ref> [10] </ref>. Note that intersection is used for unification since our type graphs are downward-closed. The third operation is not described in [10] which uses an indirect approach: first, an or-vertex is created with the two inputs as successors; then a compaction algorithm is applied to satisfy the restrictions. <p> The first two operations are described in <ref> [10] </ref>. Note that intersection is used for unification since our type graphs are downward-closed. The third operation is not described in [10] which uses an indirect approach: first, an or-vertex is created with the two inputs as successors; then a compaction algorithm is applied to satisfy the restrictions. Our system uses a direct implementation which does not raise any difficulty. <p> In fact, it is not even a cpo. To overcome this difficulty, Bruynooghe and Janssens <ref> [10] </ref> use a finite subdomain by restricting the number of occurrences of a functional symbol on the paths of the graphs. We adopted a different, less syntactic, solution based on a widening operator as proposed in [4].
Reference: [11] <author> T. Kanamori and T. Kawamura. </author> <title> Analysing Success Patterns of Logic Programs by Abstract Hybrid Interpretation. </title> <type> Technical report, </type> <institution> ICOT, </institution> <year> 1987. </year>
Reference-contexts: It should be emphasized that the pattern information is optional. In theory, information on all subterms could be kept but the requirement for a finite analysis makes this impossible for almost all applications. As a consequence, the domain shares some features with the depth-k abstraction <ref> [11] </ref>, although Pat (R) does not impose a fixed depth but adjusts it dynamically through upper bound and widening operations. Pat (R) is thus composed of three components: a pattern component, a same value component, and a R-component.
Reference: [12] <author> B. Le Charlier and P. Van Hentenryck. </author> <title> Experimental Evaluation of a Generic Abstract Interpretation Algorithm for Prolog. </title> <journal> ACM Transactions on Programming Languages and Systems. </journal> <note> To appear. An extended abstract appeared in the Proceedings of Fourth IEEE International Conference on Computer Languages (ICCL'92), </note> <institution> San Francisco, </institution> <address> CA, </address> <month> April </month> <year> 1992. </year>
Reference-contexts: The purpose of this paper is to describe the design and implementation of a type system based on the second approach. The system is best described as GAIA (Pat (Type)), where GAIA is a generic top-down fixpoint algorithm for Prolog <ref> [12, 6] </ref> 2 , Pat is a generic pattern domain for structural information [3], and Type is a type graph domain. <p> The next three sections are devoted to each of the subsystems with a special emphasis on Type since the other two systems have been presented elsewhere. 4 The Abstract Interpretation Framework In this section, we briefly review our abstract interpretation framework. The framework is presented in details in <ref> [12] </ref> and is close to the work of Marriott and Sondergaard [14] and Winsborough [22]. It follows the traditional approach to abstract interpretation [4]. Concrete Semantics As is traditional in abstract interpretation, the starting point of the analysis is a collecting semantics for the programming language. <p> The upper bound operation is a consistent abstraction of the union of sets of substitutions. 6 The Fixpoint Algorithm The last step of the methodology consists in computing the least fixpoint or a postfixpoint of the abstract semantics. The fixpoint algorithm GAIA <ref> [12] </ref> is a top-down fixpoint algorithm computing a small, but sufficient, subset of least fixpoint (or of a postfixpoint) necessary to answer a user query. <p> Hence the analysis should infer as many tags as possible. In addition, we compare the information so obtained with the information produced by an analysis preserving only principal functors, i.e. the pattern domain of <ref> [12] </ref>. The type analysis described here is always more precise than the pattern domain and the gain can come from disjunctive and recursive types. Note also that when the pattern domain infers a single functor for an argument, so does our type analysis.
Reference: [13] <author> B. Le Charlier and P. Van Hentenryck. </author> <title> A Universal Top-Down Fixpoint Algorithm. </title> <type> Technical Report CS-92-25, </type> <institution> CS Department, Brown University, </institution> <year> 1992. </year> <month> 22 </month>
Reference-contexts: It has many similarities with PLAI [18] and can be seen either as an implementation of Bruynooghe's framework [1] or as an instance of a general fixpoint algorithm <ref> [13] </ref>. In the experimental results, we use the prefix version of the algorithm [6]. 5 The Generic Pattern Domain In this section, we briefly recall the basic notions behind the generic abstract domain Pat (R).
Reference: [14] <author> K. Marriott and H. Sondergaard. </author> <title> Notes for a Tutorial on Abstract Interpretation of Logic Programs. </title> <booktitle> North American Conference on Logic Programming, </booktitle> <address> Cleveland, Ohio, </address> <year> 1989. </year>
Reference-contexts: The framework is presented in details in [12] and is close to the work of Marriott and Sondergaard <ref> [14] </ref> and Winsborough [22]. It follows the traditional approach to abstract interpretation [4]. Concrete Semantics As is traditional in abstract interpretation, the starting point of the analysis is a collecting semantics for the programming language.
Reference: [15] <author> P. Mishra. </author> <title> Towards a Theory of Types in Prolog. </title> <booktitle> In International Symposium on Logic Programming, </booktitle> <pages> pages 289-298, </pages> <year> 1984. </year>
Reference-contexts: Extensive research has been devoted to type inference in logic programming, although few systems have actually been developed. A popular line of research, called the cartesian closure approach in [9], was initiated by <ref> [15] </ref> and further developed in many authors (See [7] for a complete account). The key idea is to approximate the traditional T p operator by replacing substitutions by sets of substitutions and using a cartesian closure operator to ignore inter-variable and inter-argument dependencies.
Reference: [16] <author> B. Monsuez. </author> <title> Polymorphic Types and Widening Operators. </title> <booktitle> In International Workshop on Static Analysis (WSA-93), </booktitle> <address> Padova, Italy, </address> <month> September </month> <year> 1993. </year>
Reference-contexts: Note also that the use of widening operators for type inference has been recently investigated in the context of functional programming but the technical details of this work are fundamentally different <ref> [16] </ref>. The rest of this paper is organized as follows. Section 2 illustrates the functionality of the system on a variety of small but representative examples. Section 3 gives an overview of the paper. Sections 4 and 5 briefly review our abstract interpretation framework and the generic pattern domain.
Reference: [17] <author> A. Mulkers, W. Winsborough, and M. Bruynooghe. </author> <title> Analysis of Shared Data Structures for Compile-Time Garbage Collection in Logic Programs. </title> <booktitle> In Seventh International Conference on Logic Programming (ICLP-90), </booktitle> <address> Jerusalem, Israel, </address> <month> June </month> <year> 1990. </year>
Reference-contexts: The appealing features of this approach is the possibility of exploiting variable dependencies and the ease with which type analysis can be combined with other analyses as required by applications such as compile-time garbage collection <ref> [17] </ref>. The drawback is that the result of the analysis is more difficult to characterize formally as the design of the abstract domain is an experimental endeavour. <p> It also shows that type graphs can be practical and this is of importance for many applications such 2 GAIA is available by anonymous ftp from Brown University. 1 as compile-time garbage collection (e.g. <ref> [17] </ref>) and automatic termination analysis (e.g. [21]).
Reference: [18] <author> K. Muthukumar and M. Hermenegildo. </author> <title> Compile-Time Derivation of Variable Dependency Using Abstract Interpretation. </title> <journal> Journal of Logic Programming, </journal> <volume> 13(2-3):315-347, </volume> <year> 1992. </year>
Reference-contexts: The algorithm uses memoization, a dependency graph to avoid redundant computation, the abstract operations of the abstract semantics, and the ordering relation on the abstract domain. It has many similarities with PLAI <ref> [18] </ref> and can be seen either as an implementation of Bruynooghe's framework [1] or as an instance of a general fixpoint algorithm [13].
Reference: [19] <author> L. Sterling and E. Shapiro. </author> <title> The Art of Prolog: Advanced Programming Techniques. </title> <publisher> MIT Press, </publisher> <address> Cambridge, Ma, </address> <year> 1986. </year>
Reference-contexts: We first describe the benchmarks and discuss the efficiency and accuracy of the analysis. The Benchmarks The benchmark programs 3 are hopefully representative of "pure" logic programs. KA is an alpha-beta program to play the game of kalah <ref> [19] </ref>. PR is a symbolic equation-solver [19]. CS is a program to generate a number of configurations representing various ways of cutting a wood board into small shelves [20]. DS is the generate and test equivalent of a disjunctive scheduling problem [5]. <p> We first describe the benchmarks and discuss the efficiency and accuracy of the analysis. The Benchmarks The benchmark programs 3 are hopefully representative of "pure" logic programs. KA is an alpha-beta program to play the game of kalah <ref> [19] </ref>. PR is a symbolic equation-solver [19]. CS is a program to generate a number of configurations representing various ways of cutting a wood board into small shelves [20]. DS is the generate and test equivalent of a disjunctive scheduling problem [5]. RE is the Prolog tokeniser and reader of R.O'keefe and D.H.D.Warren. <p> RE is the Prolog tokeniser and reader of R.O'keefe and D.H.D.Warren. PG is a program written by W. Older to solve a specific mathematical problem. BR is a program taken from Gabriel benchmark. PL is a planning program from <ref> [19] </ref>. QU solves the n-queens problem. Finally, PE is a the peephole optimizer of SB-Prolog, written by Debray. We will also prefix some programs by L to indicate that the input query assigns lists to some arguments.
Reference: [20] <author> P. Van Hentenryck. </author> <title> Constraint Satisfaction in Logic Programming. Logic Programming Series, </title> <publisher> The MIT Press, </publisher> <address> Cambridge, MA, </address> <year> 1989. </year>
Reference-contexts: KA is an alpha-beta program to play the game of kalah [19]. PR is a symbolic equation-solver [19]. CS is a program to generate a number of configurations representing various ways of cutting a wood board into small shelves <ref> [20] </ref>. DS is the generate and test equivalent of a disjunctive scheduling problem [5]. RE is the Prolog tokeniser and reader of R.O'keefe and D.H.D.Warren. PG is a program written by W. Older to solve a specific mathematical problem. BR is a program taken from Gabriel benchmark.
Reference: [21] <author> K. Verschaetse and D. De Schreye. </author> <title> Deriving Termination Proofs for Logic Programs Using Abstract Procedures. </title> <booktitle> In Eighth International Conference on Logic Programming (ICLP-91), </booktitle> <address> Paris (France), </address> <month> June </month> <year> 1991. </year>
Reference-contexts: It also shows that type graphs can be practical and this is of importance for many applications such 2 GAIA is available by anonymous ftp from Brown University. 1 as compile-time garbage collection (e.g. [17]) and automatic termination analysis (e.g. <ref> [21] </ref>).
Reference: [22] <author> W. Winsborough. </author> <title> Multiple Specialization using Minimal-Function Graph Semantics. </title> <journal> Journal of Logic Programming, </journal> <volume> 13(4), </volume> <year> 1992. </year> <month> 23 </month>
Reference-contexts: The framework is presented in details in [12] and is close to the work of Marriott and Sondergaard [14] and Winsborough <ref> [22] </ref>. It follows the traditional approach to abstract interpretation [4]. Concrete Semantics As is traditional in abstract interpretation, the starting point of the analysis is a collecting semantics for the programming language.
References-found: 22

