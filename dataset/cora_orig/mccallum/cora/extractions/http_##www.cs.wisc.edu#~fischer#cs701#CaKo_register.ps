URL: http://www.cs.wisc.edu/~fischer/cs701/CaKo_register.ps
Refering-URL: http://www.cs.wisc.edu/~fischer/cs701/readings.html
Root-URL: 
Title: Register Allocation via Hierarchical Graph Coloring  
Author: David Callahan Brian Koblenz 
Address: 400 N 34th Street, Suite 300 Seattle, WA 98103  
Affiliation: Tera Computer Company  
Abstract: We present a graph coloring register allocator designed to minimize the number of dynamic memory references. We cover the program with sets of blocks called tiles and group these tiles into a tree reflecting the program's hierarchical control structure. Registers are allocated for each tile using standard graph coloring techniques and the local allocation and conflict information is passed around the tree in a two phase algorithm. This results in an allocation of registers that is sensitive to local usage patterns while retaining a global perspective. Spill code is placed in less frequently executed portions of the program and the choice of variables to spill is based on usage patterns between the spills and the reloads rather than usage patterns over the entire program. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> F. E. Allen. </author> <title> Control Flow Analysis. </title> <booktitle> In Proceedings of the SIGPLAN '70 Symposium on Compiler Construction, </booktitle> <pages> pages 1-19, </pages> <month> July </month> <year> 1970. </year>
Reference: [2] <author> D. Bernstein, D. Goldin, M. Golumbic, H. Krawczyk, Y. Mansour, I. Nahshon, and R. Pinter. </author> <title> Spill code minimization techniques for optimizing compilers. </title> <booktitle> In Proceedings of the ACM SIGPLAN 89 Conference on Program Language Design and Implementation, </booktitle> <pages> pages 258-263, </pages> <month> June </month> <year> 1989. </year>
Reference-contexts: This is the variable that is least likely to benefit from a register and most likely to enable other variables to become colorable. Bernstein et al. <ref> [2] </ref> use a complementary combination of spill heuristics and pick the best set of variables to spill over the entire program. Our algorithm could easily use either method but is implemented using Chaitin's heuristic with our cost metric.
Reference: [3] <author> P. Briggs, K. Cooper, K. Kennedy, and L. Torc-zon. </author> <title> Coloring Heuristics for Register Allocation. </title> <booktitle> In Proceedings of the ACM SIGPLAN 89 Conference on Program Language Design and Implementation, </booktitle> <pages> pages 275-284, </pages> <month> June </month> <year> 1989. </year>
Reference: [4] <author> P. Briggs, K. Cooper, and L. Torczon. </author> <title> Aggressive Live range Splitting. </title> <type> Technical report, </type> <institution> Rice University, </institution> <year> 1991. </year>
Reference-contexts: Another disadvantage of the Chow and Hen-nessy scheme is that they separate local and global variables and color them from distinct register sets. This results in extra copies that coalescing and pref-erencing can avoid and also reduces the number of available registers for global coloring. Briggs, Cooper and Torczon <ref> [4] </ref> find the loop structure of the program and perform live range splitting (with limited coalescing) at loop boundaries. They spill intelligently, but their interference graphs are large and they cannot spill inside of conditional statements.
Reference: [5] <author> D. Callahan, S. Carr, and K. Kennedy. </author> <title> Improving Register Allocation for Subscripted Variables. </title> <booktitle> In Proceedings of the ACM SIGPLAN 90 Conference on Program Language Design and Implementation, </booktitle> <pages> pages 53-65, </pages> <month> June </month> <year> 1990. </year>
Reference-contexts: In order to find these concurrent operations and hide the pipeline latency, aggressive loop unrolling and operation scheduling are required, both of which increase register pressure at various points in the program <ref> [5] </ref>. In Chaitin's allocator [6] the decision to spill a variable is based on a weighted reference count and the number of conflict edges in the interference graph. This heuristic suffers because the program flow structure is not represented in the interference graph and local reference patterns are not visible.
Reference: [6] <author> G. Chaitin. </author> <title> Register Allocation and Spilling via Graph Coloring. </title> <booktitle> In Proceedings of the SIGPLAN '82 Symposium on Compiler Construction, </booktitle> <pages> pages 98-105, </pages> <month> June </month> <year> 1982. </year>
Reference-contexts: In order to find these concurrent operations and hide the pipeline latency, aggressive loop unrolling and operation scheduling are required, both of which increase register pressure at various points in the program [5]. In Chaitin's allocator <ref> [6] </ref> the decision to spill a variable is based on a weighted reference count and the number of conflict edges in the interference graph. This heuristic suffers because the program flow structure is not represented in the interference graph and local reference patterns are not visible. <p> These conflict edges come from a variety of sources. 1. A conflict edge exists between two variables if they conflict in a block in blocks (t ). This initial conflict graph is built ignoring the subtile information using an algorithm similar to Chaitin <ref> [6] </ref>. 2. A variable conflicts with tile summary variables and other global variables as indicated in the conflict summaries for each subtile. 3. Any variable that is live in a subtile but was not part of the subtile's allocation summary, conflicts with all of the subtile's tile summary variables. <p> If there is a simple assignment from one variable to another, than those variables become preferenced. Explicit preferencing is used as an alternative to coalescing <ref> [6] </ref> where nodes satisfying the above conditions, especially the last, would simply be subsumed into a single node before coloring. We feel our method is superior because the separate live ranges of the individual variables allow more precise spill decisions to be made. <p> Following Briggs et al.[3] we prioritize the remaining variables and next place the least valuable variable on the stack; we delay the actual decision to spill until a variable fails to find a valid color. Chaitin <ref> [6] </ref> spills the variable with the lowest spill cost to conflict count ratio where the spill cost is the penalty of accessing this variable from memory. This is the variable that is least likely to benefit from a register and most likely to enable other variables to become colorable. <p> parent of t and if weight t (v) &gt; transfer t (v) we generate memory to register transfers otherwise we change the allocation of v in t to reflect that it should be in memory. 5 Related Work Our work is primarily an extension of the work done by Chaitin <ref> [6] </ref>. We retain the accuracy of Chaitin's interference graph but, unlike Chaitin, we are able to benefit from local usage patterns and can place spill code intelligently. Chow and Hennessy [8] and Larus and Hilfin-ger [13] handle conflicts more coarsely than we do. <p> Most modern processor designs allow such operands to only come from registers and so a register must be made available to hold the value immediately before its use. A simple solution [13] to this problem is to reserve registers specifically for this purpose. Another solution <ref> [6] </ref> is to introduce temporary variables for each such use and then repeat the entire register allocation process considering these temporary variables. Repeating the allocation is expensive [3][11] and the potential for register spills is increased with aggressive optimization techniques.
Reference: [7] <author> F. Chow. </author> <title> Minimizing Register Usage Penalty at Procedure Calls. </title> <booktitle> In Proceedings of the ACM SIGPLAN 88 Conference on Program Language Design and Implementation, </booktitle> <pages> pages 85-94, </pages> <month> June </month> <year> 1988. </year>
Reference-contexts: In this case, the cost analysis will indicate sub-tile summary variables should be spilled in the root tile, rather than the variables occupying callee-save registers. The net effect is the same as the "shrink wrapping" discussed by Chow <ref> [7] </ref>: a callee-save register is not saved until an execution path which actually requires the register is selected.
Reference: [8] <author> F. Chow and J. Hennessy. </author> <title> Register Allocation by Priority-based Coloring. </title> <booktitle> In Proceedings of Page 10 the SIGPLAN '84 Symposium on Compiler Con--struction, SIGPLAN Notices Vol. </booktitle> <volume> 19, No. 6, </volume> <pages> pages 222-232, </pages> <month> June </month> <year> 1984. </year>
Reference-contexts: We retain the accuracy of Chaitin's interference graph but, unlike Chaitin, we are able to benefit from local usage patterns and can place spill code intelligently. Chow and Hennessy <ref> [8] </ref> and Larus and Hilfin-ger [13] handle conflicts more coarsely than we do. They represent each variable as a set of contiguous basic blocks | a live range | where the variable must occupy a register.
Reference: [9] <author> R. Cytron, J. Ferrante, B. Rosen, M. Wegman, and K. Zadeck. </author> <title> An Efficient Method of Computing Static Single Assignment Form. </title> <booktitle> In Conference Record of the Sixteenth ACM Symposium on the Principles of Programming Languages, </booktitle> <pages> pages 25-35, </pages> <month> January </month> <year> 1989. </year>
Reference-contexts: We assume that each program variable has been fully renamed <ref> [9] </ref> and that variables correspond to an unbounded set of pseudo-registers. 2 We say a variable v is local to a tile t if all references to v are made by blocks within t and v is not live along any entry or exit edge of t.
Reference: [10] <author> J. Ferrante, K. J. Ottenstein, and J. D. Warren. </author> <title> The Program Dependence Graph and Its Use in Optimization. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 9(3) </volume> <pages> 319-349, </pages> <month> July </month> <year> 1987. </year>
Reference: [11] <author> R. Gupta, M. L. Soffa, and T. Steele. </author> <title> Register Allocation via Clique Separators. </title> <booktitle> In Proceedings of the ACM SIGPLAN 89 Conference on Program Language Design and Implementation, </booktitle> <pages> pages 264-274, </pages> <month> June </month> <year> 1989. </year>
Reference-contexts: We are not claiming to be asymptotically smaller, but with this technique it is not necessary to construct the full conflict graph at any one time. This is similar to the benefit of clique separators described by Gupta, Soffa, and Steele <ref> [11] </ref> yet we are able to retain a global view of the program permitting better spill analysis. The next section describes the tile tree. Section 3 gives details for the allocation and section 4 describes how spill decisions are made.
Reference: [12] <author> K. Knobe and A. Meltzer. </author> <title> Control Tree based Register Allocation. </title> <type> Technical report, COMPASS, </type> <year> 1990. </year>
Reference-contexts: Briggs, Cooper and Torczon [4] find the loop structure of the program and perform live range splitting (with limited coalescing) at loop boundaries. They spill intelligently, but their interference graphs are large and they cannot spill inside of conditional statements. Meltzer and Knobe <ref> [12] </ref> independently attempted to incorporate the program structure into a register allocator and have a similar notion of local and global variables. They construct a "control tree" based on the work of Sharir [14].
Reference: [13] <author> J. Larus and P. Hilfinger. </author> <title> Register Allocation in the SPUR Lisp Compiler. </title> <booktitle> In Proceedings of the SIGPLAN '86 Symposium on Compiler Construction, SIGPLAN Notices Vol. </booktitle> <volume> 21, No. 7, </volume> <pages> pages 255-263, </pages> <month> June </month> <year> 1986. </year>
Reference-contexts: We retain the accuracy of Chaitin's interference graph but, unlike Chaitin, we are able to benefit from local usage patterns and can place spill code intelligently. Chow and Hennessy [8] and Larus and Hilfin-ger <ref> [13] </ref> handle conflicts more coarsely than we do. They represent each variable as a set of contiguous basic blocks | a live range | where the variable must occupy a register. <p> Most modern processor designs allow such operands to only come from registers and so a register must be made available to hold the value immediately before its use. A simple solution <ref> [13] </ref> to this problem is to reserve registers specifically for this purpose. Another solution [6] is to introduce temporary variables for each such use and then repeat the entire register allocation process considering these temporary variables.
Reference: [14] <author> M. Sharir. </author> <title> Structural Analysis: A New Approach to Flow Analysis in Optimizing Compilers. </title> <journal> Computer Languages, </journal> <volume> 5 </volume> <pages> 151-153, </pages> <year> 1980. </year>
Reference-contexts: Meltzer and Knobe [12] independently attempted to incorporate the program structure into a register allocator and have a similar notion of local and global variables. They construct a "control tree" based on the work of Sharir <ref> [14] </ref>. This is similar to our tile tree for structured programs but we believe our algorithm is more easily adapted to varying tile granularities. Also, Sharir may view branches out of nested loops as if statements where we continue to see the natural loop structure.
Reference: [15] <author> R. E. Tarjan. </author> <title> Testing Flow Graph Reducibility. </title> <journal> Journal of Computer and System Sciences, </journal> <volume> 9 </volume> <pages> 355-365, </pages> <year> 1974. </year>
References-found: 15

