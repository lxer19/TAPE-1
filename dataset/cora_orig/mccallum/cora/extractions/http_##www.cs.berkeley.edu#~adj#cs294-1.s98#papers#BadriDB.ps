URL: http://www.cs.berkeley.edu/~adj/cs294-1.s98/papers/BadriDB.ps
Refering-URL: http://www.cs.berkeley.edu/~adj/cs294-1.s98/plan.html
Root-URL: 
Email: e-mail:fbadri, phatakg@cs..rutgers.edu  
Title: A Database Architecture for Handling Mobile Clients  
Author: B. R. Badrinath Shirish Hemant Phatak 
Address: New Brunswick, NJ 08903  
Affiliation: Department of Computer Science Rutgers University  
Abstract: The use of mobile computers is gaining popularity. The number of users with laptops and notebooks is increasing and this trend is likely to continue in the future where the number of mobile clients will far exceed the number of traditional fixed clients. Applications running on mobile clients download information by periodically connecting to repositories of data. Mobile clients constitute a new and different kind of workload and exhibit different access patterns than those seen in traditional client server systems. Though file systems have been modified to handle clients that are capable of downloading information, updating the information while disconnected, and later reintegrating the updates, databases have not been redesigned to accommodate mobile clients. Thus, there is a need to support mobile clients in the context of client server databases. In this paper, we present a new architecture for database systems which takes mobile environments into consideration. This architecture allows us to address issues of concurrency control, disconnection, and replica control in mobile databases. We also propose the concept of hoard attributes which facilitate hoarding. We present simulation results that illustrate the performance of an example database system with both disconnected and traditional clients.
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> R. Alonso and H. F. Korth, </author> <title> Database System Issues in Nomadic Computing, </title> <booktitle> Proceedings of the ACM SIGMOD, </booktitle> <month> Jun. </month> <year> 1993, </year> <pages> pages 388-392. </pages>
Reference: [2] <author> P. A. Bernstein and N. Goodman, </author> <title> Concurrency Control in Distributed Database Systems, </title> <journal> ACM Computing Surveys, </journal> <volume> 13(2), </volume> <month> Jun. </month> <year> 1981, </year> <pages> pages 185-221. </pages>
Reference-contexts: Thus, the hoard-reintegrate database is a special case of a replicated database. Replicated database systems have already been studied in some depth in literature <ref> [2, 7, 28] </ref>. Unfortunately, all these systems assume that there is a persistent connection between all the replica servers and any disconnection is due to failure. Thus, these solutions work poorly in a mobile disconnected environment.
Reference: [3] <author> B. R. Badrinath and S. H. Phatak, </author> <title> Database Server Organization for Handling Mobile Clients, </title> <institution> Department of Computer Science Technical Report DCS-TR-324, Rutgers University, </institution> <address> New Jersey. </address>
Reference-contexts: To capitalize on this fact the relations on the server are horizontally fragmented to optimize hoarding and reintegration performance. Our simulations (see <ref> [3] </ref>) indicate that this can be done without significantly impacting time to access disk of traditional clients, even though such clients do not demonstrate any such locality of access. Note that performance of such clients is still affected by the resources consumed by hoarding operation. <p> These physical fragments must be carefully designed to capture the locality of access of "typical" hoard clients. This needs analysis of the workload offered by such hoard clients. As our results in <ref> [3] </ref> indicate, a well organized relation can lead to an improvement of up to three time in raw i/o performance of hoard queries, without significantly affecting traditional i/o performance. We present our techniques for fragmenting relations using hoard attributes in section 4. <p> We use the following performance metrics: normalized traditional transaction performance (time per request), normalized hoarding performance (hoard time per tuple) and reintegration performance (fraction of mobile transactions rolled back). Our simulation model in <ref> [3] </ref> measures disk access performance without taking into account the effects of concurrency control. This simulation demonstrated that raw access performance can be improved by a factor of 3 for hoard clients, while only marginally impacting traditional clients. The simulation model presented here additionally incorporates concurrency control.
Reference: [4] <author> B. R. Badrinath and S. H. Phatak, </author> <title> An Architecture for Mobile Databases, </title> <institution> Department of Computer Science Technical Report DCS-TR-351, Rutgers University, </institution> <address> New Jersey. </address>
Reference-contexts: Unfortunately, both the approaches reduce effective availability of the database. This is a compelling reason for restricting hoard clients from hoarding master replicas of fragments for long periods of time. Our simulations (section 5 and <ref> [4] </ref>) indicate that Davidson's algorithm can significantly outperform CODA like approaches. Unfortunately, Davidson's algorithm is expensive to implement since it requires maintenance of the serializability graphs and read/write-sets of all transactions on the client as well as the server. <p> CODA style results have only been plotted for reintegration performance. The figures have been grouped by the classes of experiments. Additional data was also collected, but is not presented here. (For more data pertaining to the first two classes of experiments, see <ref> [4] </ref>). From these simulation results, we make the following observations: 1. As the number of physical fragments increases, the performance of traditional clients degrades (figure 8). This is because consecutive tuples are distributed across fragments. <p> As the number of physical fragments increases, the performance of traditional clients degrades (figure 8). This is because consecutive tuples are distributed across fragments. Thus, if the number of fragments is too large, each tuple leads to a disk access. (This has been shown in <ref> [4] </ref>.) As expected both the hoarding and reintegration performance improves with number of fragments (figures 9 and 10). Hoarding performance (figure 9) improves due to the clustering effect of fragments. <p> This is because of the reduction of the collision cross section of reintegrating transactions, which is an entire physical fragment in CODA style reintegration. 2. As the fraction of the load offered by traditional clients increases, traditional transaction performance improves tremendously (figure 11). We have shown in <ref> [4] </ref> that this is not due to improved cache performance or reduced disk accesses, rather it is due to the fact that traditional requests spend less time waiting. This is because each hoard client generates a large burst of read requests, delaying other i/o activity.
Reference: [5] <author> K. P. Brown, M. J. Carey and M. Livny, </author> <title> Goal-Oriented Buffer Management Revisited, </title> <booktitle> Proceedings of the ACM SIGMOD, </booktitle> <month> Jun. </month> <year> 1996, </year> <pages> pages 353-364. </pages>
Reference-contexts: The traditional transactions are generated by the traditional transaction source. These are generated in a Markovian fashion with average inter-arrival time set to 2 seconds (TraditionalThink-Time). Each transaction is "hot" with probability 0.8 (ProbTraditionalHot). We define "hot" and "cold" in a manner analogous to <ref> [5] </ref>: "hot" transactions are range queries on the primary key whereas "cold" transactions access tuples at random. Each request generated by a traditional transaction is an update with probability 0.2 (ProbTraditionalWrite).
Reference: [6] <author> M. J. Carey, M. J. Franklin, M. Livny, E. J. Shekita, </author> <title> Data Caching Tradeoffs in Client-Server DBMS Architectures, </title> <booktitle> Proceedings of the ACM SIGMOD, </booktitle> <month> May </month> <year> 1991, </year> <pages> pages 357-366. </pages>
Reference: [7] <author> S. Ceri and G. Pelagatti, </author> <title> Distributed Databases|Principles and Systems, </title> <publisher> McGraw-Hill, </publisher> <year> 1984. </year>
Reference-contexts: Thus, the hoard-reintegrate database is a special case of a replicated database. Replicated database systems have already been studied in some depth in literature <ref> [2, 7, 28] </ref>. Unfortunately, all these systems assume that there is a persistent connection between all the replica servers and any disconnection is due to failure. Thus, these solutions work poorly in a mobile disconnected environment. <p> For example, consider the following schema with two hoard attributes, modeled from <ref> [7] </ref>: SUPPLY (SNUM,PNUM,DEPTNUM,QUAN) Primary Key is SNUM, Foreign Keys are PNUM and DEPTNUM, External Hoard Attributes are DEPTNUM and PNUM The domain of DEPTNUM is [0; : : : ; 30] and that of PNUM is [0; : : :; 4000].
Reference: [8] <author> E. F. Codd, E. S. Codd and C. T. Salley, </author> <title> Beyond Decision Support, </title> <booktitle> Computerworld 27:30, </booktitle> <month> Jul. </month> <year> 1993, </year> <pages> pages 87-89. </pages>
Reference-contexts: None of the above work deals specifically with server organization of data to accommodate mobile clients. However, the idea of reorganizing databases for specific applications is not new. For 3 example, in Multidimensional Online Analytical Processing or MOLAP <ref> [8] </ref>, a flat relational database is reorganized into a multidimensional read-only store to support analytical queries involving operators such as min, max and sum. Each dimension holds the result of applying some operators to the database.
Reference: [9] <author> S. B. Davidson, </author> <title> Optimism and Consistency in Partitioned Distributed Database Systems ACM Transactions on Database Systems, </title> <type> 9(3), </type> <month> Sep. </month> <year> 1984, </year> <pages> pages 456-481. </pages>
Reference-contexts: Hoarding can be initiated explicitly (say through a begin hoard primitive) or implicitly (data downloaded during browsing can be treated as the hoard). Reintegration can be performed using any partition healing algorithm that can work with just two servers participating. In particular, Davidson's algorithm <ref> [9] </ref>, CODA like approaches 5 , or application semantics based approaches can be used. With the introduction of hoard clients, database servers can expect two distinct kinds of workload: the workload generated by hoard requests from hoard clients and the workload generated by traditional queries from traditional clients. <p> For example, suppose DEPTNUM is a physical hoard attribute and PNUM is a logical hoard attribute as in Figure 6. The database is physically fragmented for each P i . In this case there are three fragments consisting of tuples having DEPTNUM with values in the ranges <ref> [0; : : :; 9] </ref>, [11; : : :; 19] and [20; : : :; 30] respectively. Each of the logical fragments for the Q i 's are realized using indexes.
Reference: [10] <author> A. Demers, K. Petersen, M. Spreitzer, D. Terry, M. Theimer and B. Welch, </author> <title> The BAYOU Architecture: Support for Data Sharing Among Mobile Users, </title> <booktitle> Proceedings of the IEEE Workshop on Mobile Computing Systems and Applications, </booktitle> <month> Dec. </month> <year> 1994, </year> <pages> pages 2-7. </pages>
Reference-contexts: These systems allow clients to update replicas of files while disconnected, and reconcile updates on reconnection. CODA uses a single server to reconcile updates, whereas FICUS uses a peer-to-peer mechanism. Both use pessimistic conflict resolution to perform reconciliation of updates. In BAYOU <ref> [10] </ref>, the hoard is replaced by a local copy of an entire data repository. Bayou requires applications to specify both the conflict detection and resolution mechanisms with the updates. Updates are reconciled whenever two data repositories get connected.
Reference: [11] <author> M. J. Franklin, B. T. Jonsson and D. Kossmann, </author> <title> Performance Tradeoffs for Client-Server Query Processing, </title> <booktitle> Proceedings of the ACM SIGMOD, </booktitle> <month> Jun. </month> <year> 1996, </year> <pages> pages 149-160. </pages>
Reference-contexts: The database is physically fragmented for each P i . In this case there are three fragments consisting of tuples having DEPTNUM with values in the ranges [0; : : :; 9], <ref> [11; : : :; 19] </ref> and [20; : : :; 30] respectively. Each of the logical fragments for the Q i 's are realized using indexes.
Reference: [12] <author> J. Gray, P. Helland, P. E. O'Neil and D. Shasha, </author> <title> The Dangers of Replication and a Solution, </title> <booktitle> Proceedings of ACM SIGMOD, </booktitle> <month> Jun. </month> <year> 1996, </year> <pages> pages 173-182. </pages>
Reference-contexts: Reconciliation takes place by rolling back all updates made by both connecting servers and replaying both sets of updates together (including conflict detection and resolution mechanisms) in timestamp order. Note that the data repository here is not a database. In the update anytime, anywhere model proposed in <ref> [12] </ref>, the database is a collection of replicated objects with primary copies at certain sites known as object masters. The model uses a two tier replication scheme, with one tier on the mobile (disconnected) nodes and the other on the base (connected) nodes.
Reference: [13] <author> J. Gray and A. Reuter, </author> <title> Transaction Processing: Concepts and Techniques, </title> <publisher> Morgan-Kaufmann, </publisher> <year> 1993. </year>
Reference: [14] <author> T. Imielinski and B. R. Badrinath, </author> <title> Mobile Wireless Computing: </title> <booktitle> Challenges in Data Management Communications of the ACM, </booktitle> <volume> 37(10), </volume> <year> 1994, </year> <pages> pages 18-28. </pages>
Reference: [15] <author> R. Katz and S. Weiss, </author> <title> Design Transaction Management, </title> <booktitle> Proceedings of the 21st Design Automation Conference, </booktitle> <year> 1984, </year> <pages> pages 692-693. </pages>
Reference-contexts: There are three approaches for dealing with consistency problems in the face of imminent disconnection: 1. Allow clients to checkout data as in <ref> [15] </ref>. Here data hoarded by the client is locked on the server until the client reintegrates its hoard 8 . Obviously this scheme is only practicable if multiple clients rarely attempt to access the same data. 7 It is possible to work around this assumption using hoard profiles [17].
Reference: [16] <author> N. Krishnakumar and R. Jain, </author> <title> Mobile Support for Sales and Inventory Applications, in Mobile Computing, </title> <editor> T. Imielinski and H. F. </editor> <publisher> Korth Ed. </publisher>
Reference: [17] <author> G. Kuenning, G. J. Popek and P. Reiher, </author> <title> An Analysis of Trace Data for Predictive File Caching in Mobile Computing, </title> <booktitle> Proceedings of the USENIX Summer Conference, </booktitle> <year> 1994, </year> <pages> pages 291-303. </pages>
Reference-contexts: Finally, section 6 presents conclusions and discusses new issues resulting from our approach to server organization for handling mobile clients. 2 Related Work As mentioned before, hoarding is a concept that has been successfully applied to file systems. Examples of such systems are CODA [26] and FICUS <ref> [17] </ref>. These systems allow clients to update replicas of files while disconnected, and reconcile updates on reconnection. CODA uses a single server to reconcile updates, whereas FICUS uses a peer-to-peer mechanism. Both use pessimistic conflict resolution to perform reconciliation of updates. <p> Here data hoarded by the client is locked on the server until the client reintegrates its hoard 8 . Obviously this scheme is only practicable if multiple clients rarely attempt to access the same data. 7 It is possible to work around this assumption using hoard profiles <ref> [17] </ref>. Here the client need not explicitly specify which fragments to download. Instead, the client, say a sales manager on her way to a meeting in Singapore, can indirectly ask for data, as in, "download everything related to Singapore". <p> In the latter case, the index data structures and the physical layout of the database might change dynamically. Thus, efficient schemes for tracing and evaluating database activity and dynamically reorganizing the database are needed (see <ref> [17] </ref>). Furthermore, hoard profiles could be generated for all the users of the database. How exactly to reorganize the database for a given set of hoard profiles is an open research problem.
Reference: [18] <author> P. Kumar and M. Satyanarayanan, </author> <title> Supporting Application-Specific Resolution in an Opti--mistically Replicated File System, </title> <booktitle> Proceedings of the Fourth IEEE Workshop on Workstation Operating Systems, </booktitle> <month> Oct. </month> <year> 1993, </year> <pages> pages 66-70. </pages>
Reference-contexts: In this paper we use the terms hoard and local replica interchangeably. The modified client-server model has been successfully used for file systems such as CODA [26], and has been extended to other applications using Application Specific Resolvers <ref> [18] </ref>. The granularity of hoarding in CODA is an entire file. CODA uses a simple pessimistic scheme to reconcile updates: the client copy of a file replaces the server copy iff the server copy was not modified after the client hoarded the file.
Reference: [19] <author> H. T. Kung and J. T. Robinson, </author> <title> On Optimistic Methods of Concurrency Control, </title> <journal> ACM Transactions on Database Systems, </journal> <volume> 6(2), </volume> <month> Jun. </month> <year> 1981, </year> <pages> pages 213-226. </pages>
Reference-contexts: The database is physically fragmented for each P i . In this case there are three fragments consisting of tuples having DEPTNUM with values in the ranges [0; : : :; 9], <ref> [11; : : :; 19] </ref> and [20; : : :; 30] respectively. Each of the logical fragments for the Q i 's are realized using indexes.
Reference: [20] <author> Q. Lu and M. Satyanarayanan, </author> <title> Isolation-Only Transaction for Mobile Computing, </title> <journal> Operating Systems Review, </journal> <volume> 28(2), </volume> <month> May </month> <year> 1981, </year> <pages> pages 81-87. </pages>
Reference-contexts: Locally committed transactions may release all locks and resources, but must be held pending global commit. Locally committed transactions can be rolled back at any time. Thus, in our approach locally committed transactions are not guaranteed durability. This model is similar to the isolation-only transaction model proposed in <ref> [20] </ref>, except that atomicity is automatically guaranteed by the local server on the client. In our model the granularity for management of consistency issues is a physical fragment. Accordingly the data items are collectively mastered as a data-set in terms of an entire physical fragment. <p> The database is physically fragmented for each P i . In this case there are three fragments consisting of tuples having DEPTNUM with values in the ranges [0; : : :; 9], [11; : : :; 19] and <ref> [20; : : :; 30] </ref> respectively. Each of the logical fragments for the Q i 's are realized using indexes.
Reference: [21] <author> K. Mogi and M. Kitsuregawa, </author> <title> Hot Mirroring: A Method of Hiding Parity Update Penalty and Degradation during Rebuilds for RAID5, </title> <booktitle> Proceedings of ACM SIGMOD, </booktitle> <month> Jun. </month> <year> 1996, </year> <pages> pages 183-194. </pages>
Reference: [22] <author> L. B. Mummert, M. R. Ebling and M. Satyanarayanan, </author> <title> Exploiting Weak Connectivity for Mobile File Access, </title> <booktitle> Proceedings of the 15th ACM Symposium on Operating System Principles 29(5), </booktitle> <month> Dec. </month> <year> 1995, </year> <pages> pages 143-155. </pages>
Reference-contexts: These links can be used to perform limited synchronization between the client and the server, such as locking, tuple invalidation and trickle reintegration to reintegrate low volume updates (see <ref> [22] </ref>). This has interesting consequences 18 As we saw in the last section, pessimistic 2-phase concurrency control had significant effect on the hoarding transactions.
Reference: [23] <author> P. E. O'Neil, </author> <title> The Escrow Transactional Method, </title> <journal> ACM TODS 11(4), </journal> <month> Dec. </month> <year> 1986, </year> <pages> pages 405-430. </pages>
Reference: [24] <author> P. E. O'Neil, Database|Principles, </author> <title> Programming, and Performance, </title> <publisher> Morgan-Kaufmann, </publisher> <year> 1994. </year>
Reference-contexts: Use knowledge of application semantics to manage consistency issues. Examples of this approach include using escrow techniques for inventory databases and using commutativity of certain arithmetic operators (see <ref> [24, 30] </ref>). 3. Use some general purpose partition healing algorithm, such as Davidson's algorithm or CODA like schemes, to perform reintegration. These approaches can suffer due to a high volume of (possibly unresolvable) conflicts. However, they are attractive since they provide high availability of the system.
Reference: [25] <author> U. W. Pooch and J. A. Wall, </author> <title> Discrete Event Simulation|A Practical Approach, </title> <publisher> CRC Press, </publisher> <year> 1993. </year>
Reference: [26] <author> M. Satyanarayanan, CODA: </author> <title> A Highly Available File System for a Distributed Workstation Environment, </title> <booktitle> Proceedings of the Second IEEE Workshop on Workstation Operating Systems, </booktitle> <month> Sep. </month> <year> 1989, </year> <pages> pages 447-459. </pages>
Reference-contexts: Whenever this client reconnects, the local server reconciles its replica with the servers copy by reintegrating any local updates. In this paper we use the terms hoard and local replica interchangeably. The modified client-server model has been successfully used for file systems such as CODA <ref> [26] </ref>, and has been extended to other applications using Application Specific Resolvers [18]. The granularity of hoarding in CODA is an entire file. <p> Finally, section 6 presents conclusions and discusses new issues resulting from our approach to server organization for handling mobile clients. 2 Related Work As mentioned before, hoarding is a concept that has been successfully applied to file systems. Examples of such systems are CODA <ref> [26] </ref> and FICUS [17]. These systems allow clients to update replicas of files while disconnected, and reconcile updates on reconnection. CODA uses a single server to reconcile updates, whereas FICUS uses a peer-to-peer mechanism. Both use pessimistic conflict resolution to perform reconciliation of updates.
Reference: [27] <author> A. Silberschatz, H. Korth and S. Sudarshan, </author> <title> Database System Concepts, </title> <publisher> McGraw-Hill, </publisher> <year> 1997. </year>
Reference: [28] <author> M. Tamer Ozsu and P. Valduriez, </author> <title> Principles of Distributed Database Systems, </title> <publisher> Prentice Hall Inc., </publisher> <year> 1991. </year>
Reference-contexts: Thus, the hoard-reintegrate database is a special case of a replicated database. Replicated database systems have already been studied in some depth in literature <ref> [2, 7, 28] </ref>. Unfortunately, all these systems assume that there is a persistent connection between all the replica servers and any disconnection is due to failure. Thus, these solutions work poorly in a mobile disconnected environment.
Reference: [29] <author> D. B. Terry, A. J. Demers, K. Petersen, M. J. Spreitzer, M. M. Theimer and B. B. Welch, </author> <title> Session Guarantees for Weakly Consistent Replicated Data, </title> <booktitle> Proceedings of the International Conference on Parallel and Distributed Information Systems (PDIS), </booktitle> <month> Sept. </month> <year> 1994, </year> <pages> pages 140-149. </pages>
Reference: [30] <author> G. Walborn and P. Chrysanthis, </author> <title> Supporting Semantics-Based Transaction Processing in Mobile Database Systems, </title> <booktitle> Proceedings of the 14th Symposium on Reliable Database Systems, </booktitle> <month> Sep. </month> <year> 1995. </year>
Reference-contexts: Use knowledge of application semantics to manage consistency issues. Examples of this approach include using escrow techniques for inventory databases and using commutativity of certain arithmetic operators (see <ref> [24, 30] </ref>). 3. Use some general purpose partition healing algorithm, such as Davidson's algorithm or CODA like schemes, to perform reintegration. These approaches can suffer due to a high volume of (possibly unresolvable) conflicts. However, they are attractive since they provide high availability of the system. <p> For example, consider the following schema with two hoard attributes, modeled from [7]: SUPPLY (SNUM,PNUM,DEPTNUM,QUAN) Primary Key is SNUM, Foreign Keys are PNUM and DEPTNUM, External Hoard Attributes are DEPTNUM and PNUM The domain of DEPTNUM is <ref> [0; : : : ; 30] </ref> and that of PNUM is [0; : : :; 4000]. <p> The database is physically fragmented for each P i . In this case there are three fragments consisting of tuples having DEPTNUM with values in the ranges [0; : : :; 9], [11; : : :; 19] and <ref> [20; : : :; 30] </ref> respectively. Each of the logical fragments for the Q i 's are realized using indexes.
Reference: [31] <author> G. Walborn and P. Chrysanthis, </author> <title> Transaction Processing in Mobile Computing Environment, </title> <booktitle> IEEE Workshop on Advances in Parallel and Distributed Systems, </booktitle> <month> Oct. </month> <year> 1993, </year> <pages> pages 77-82. 22 </pages>
References-found: 31

