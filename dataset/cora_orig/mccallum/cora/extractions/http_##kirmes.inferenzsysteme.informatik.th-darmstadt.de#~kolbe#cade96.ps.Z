URL: http://kirmes.inferenzsysteme.informatik.th-darmstadt.de/~kolbe/cade96.ps.Z
Refering-URL: http://kirmes.inferenzsysteme.informatik.th-darmstadt.de/~kolbe/
Root-URL: 
Email: Email: fkolbejwaltherg@inferenzsysteme.informatik.th-darmstadt.de  
Title: Termination of Theorem Proving by Reuse  
Author: Thomas Kolbe and Christoph Walther 
Address: Alexanderstr. 10, D-64283 Darmstadt, Germany.  
Affiliation: Fachbereich Informatik, Technische Hochschule Darmstadt,  
Abstract: We investigate the improvement of theorem provers by reusing previously computed proofs. We formulate our method for reusing proofs as an instance of the problem reduction paradigm and then develop a termination requirement for our reuse procedure. We prove the soundness of our proposal and show that reusability of proofs is not spoiled by the termination requirement imposed on the reuse procedure. We also give evidence for the general usefulness of our termination re quirement for lemma speculation in induction theorem proving.
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> A. Bouhoula, E. Kounalis, and M. Rusinowitch. spike: </author> <title> An Automatic Theorem Prover. </title> <booktitle> In Proceedings of the Conference on Logic Programming and Automated Reasoning (LPAR-92), </booktitle> <address> St. Petersburg, Russia. </address> <publisher> Springer, </publisher> <year> 1992. </year>
Reference-contexts: The latter feature is particularly important, because it is retained if the human advisor is substituted by a machine, i.e. an automated induction theorem prover, cf. <ref> [1, 2, 10, 11, 19] </ref>: Many domains, such as induction theorem proving or planning, do not have complete problem solvers, i.e. problem solvers which solve each solvable problem. Then the speculation of useful subgoals yields a relevant improvement of the system's problem solving performance.
Reference: 2. <author> R. S. Boyer and J. S. Moore. </author> <title> A Computational Logic. </title> <booktitle> ACM Monograph Series. </booktitle> <publisher> Academic Press, </publisher> <year> 1979. </year>
Reference-contexts: The latter feature is particularly important, because it is retained if the human advisor is substituted by a machine, i.e. an automated induction theorem prover, cf. <ref> [1, 2, 10, 11, 19] </ref>: Many domains, such as induction theorem proving or planning, do not have complete problem solvers, i.e. problem solvers which solve each solvable problem. Then the speculation of useful subgoals yields a relevant improvement of the system's problem solving performance. <p> Additionally, conjecture (6) has been speculated as a lemma which is required for proving conjecture . 3 The Phases of the Reuse Procedure Our approach for reusing proofs is organized into the following steps: Prove: <ref> [cf. Sections 1, 2] </ref> If required, a direct proof p for (an induction formula) ' from a set of axioms AX is given by the human advisor or an automated induction theorem prover. <p> non-empty sets of so-called recursion variables R f fx 1 ; :::; x n g with each term f (x 1 ; :::; x n ), where x 1 ; :::; x n are distinct variables, if f is recursively defined, cf. [19] and the notion of "measured subsets" in <ref> [2] </ref>. Each such set R f stipulates the variables to be induced upon when a statement containing a term f (x 1 ; :::; x n ) is to be proved by induction.
Reference: 3. <author> J. Brauburger. </author> <title> Plagiator | Design and Implementation of a Learning Theorem Prover. </title> <type> Diploma Thesis, </type> <institution> TH Darmstadt, </institution> <year> 1994. </year> <note> (in German). </note>
Reference-contexts: The presence and the degree of these benefits strongly depend on the quality of the problem solver and the domain it is operating on, cf. [17]. Here we consider a domain where problems are conjectures to be proved. We have developed and implemented the Plagiator system <ref> [3] </ref> which proves theorems by mathematical induction 2 in the spirit of the problem reduction paradigm [18]: If ? This work was supported under grants no.
Reference: 4. <author> N. Dershowitz. </author> <title> Termination of Rewriting. </title> <journal> Journal of Symbolic Computation, </journal> <volume> 3(1,2):69-115, </volume> <year> 1987. </year>
Reference-contexts: We merge these comparisons into one by using the non strict multiset order ~ imposed by % on multisets of finite subsets of [ V, cf. <ref> [4] </ref>. These multisets are denoted by f ::: g like e.g. f fx; yg; ftimes; sumg; fx; yg g. For incorporation of recursion arguments, &gt; F now is redefined: Definition 3. <p> Corollary 4. &gt; F is well-founded. Proof. &gt; 1 is well-founded by Theorem 2, and the well-foundedness of &gt; 2 is obvious. &gt; 3 is well-founded as the strict part of ~ is well-founded by Theorem 2 and <ref> [4] </ref>. &gt; 4 is the strict subsumption order fl on formulas which is also well-founded, cf. [5].
Reference: 5. <author> N. Dershowitz and J.-P. Jouannaud. </author> <title> Rewrite Systems, </title> <booktitle> volume B of the Handbook of Theoretical Computer Science: Formal Models and Semantics, chapter 6, </booktitle> <pages> pages 243-320. </pages> <publisher> Elsevier Science Publishers B.V., </publisher> <address> 1990. Jan van Leeuwen (Ed.). </address>
Reference-contexts: Proof. &gt; 1 is well-founded by Theorem 2, and the well-foundedness of &gt; 2 is obvious. &gt; 3 is well-founded as the strict part of ~ is well-founded by Theorem 2 and [4]. &gt; 4 is the strict subsumption order fl on formulas which is also well-founded, cf. <ref> [5] </ref>.
Reference: 6. <author> N. Dershowitz and Z. Manna. </author> <title> Proving Termination with Multiset Orderings. </title> <journal> Communications of the ACM, </journal> <volume> 22(8) </volume> <pages> 465-476, </pages> <year> 1979. </year>
Reference-contexts: We extend &gt; def to a quasi-ordering % on 2 [V : Let def be the strict multiset order imposed by &gt; def on the multisets of d . def is well-founded because &gt; def is, cf. <ref> [6] </ref>.
Reference: 7. <author> T. </author> <title> Ellman. Explanation-Based Learning: A Survey of Programs and Perspectives. </title> <journal> ACM Computing Surveys, </journal> <volume> 21(2) </volume> <pages> 163-221, </pages> <year> 1989. </year>
Reference-contexts: 1 Introduction We investigate the improvement of theorem provers by reusing previously computed proofs, cf. [12, 13]. Our work has similarities with the methodologies of explanation-based learning <ref> [7] </ref>, analogical reasoning [9], and abstraction [8], cf. [14] for a more detailed comparison. Consider the following general architecture: Some problem solver PS is augmented with a facility for storing and retrieving solutions of problems solved during the system's lifetime.
Reference: 8. <author> F. Giunchiglia and T. Walsh. </author> <title> A Theory of Abstraction. </title> <journal> Artificial Intelligence, </journal> <volume> 57 </volume> <pages> 323-389, </pages> <year> 1992. </year>
Reference-contexts: 1 Introduction We investigate the improvement of theorem provers by reusing previously computed proofs, cf. [12, 13]. Our work has similarities with the methodologies of explanation-based learning [7], analogical reasoning [9], and abstraction <ref> [8] </ref>, cf. [14] for a more detailed comparison. Consider the following general architecture: Some problem solver PS is augmented with a facility for storing and retrieving solutions of problems solved during the system's lifetime.
Reference: 9. <author> R. P. Hall. </author> <title> Computational Approaches to Analogical Reasoning: A Comparative Analysis. </title> <journal> Artificial Intelligence, </journal> <volume> 39 </volume> <pages> 39-120, </pages> <year> 1989. </year>
Reference-contexts: 1 Introduction We investigate the improvement of theorem provers by reusing previously computed proofs, cf. [12, 13]. Our work has similarities with the methodologies of explanation-based learning [7], analogical reasoning <ref> [9] </ref>, and abstraction [8], cf. [14] for a more detailed comparison. Consider the following general architecture: Some problem solver PS is augmented with a facility for storing and retrieving solutions of problems solved during the system's lifetime.
Reference: 10. <author> A. Ireland and A. Bundy. </author> <title> Productive Use of Failure in Inductive Proof. Special Issue of the Journal of Automated Reasoning on Automation of Proofs by Mathematical Induction, </title> <year> 1996. </year>
Reference-contexts: The latter feature is particularly important, because it is retained if the human advisor is substituted by a machine, i.e. an automated induction theorem prover, cf. <ref> [1, 2, 10, 11, 19] </ref>: Many domains, such as induction theorem proving or planning, do not have complete problem solvers, i.e. problem solvers which solve each solvable problem. Then the speculation of useful subgoals yields a relevant improvement of the system's problem solving performance. <p> Conjectures and helpful lemmata about +; fi; exp Table 4 illustrates the usefulness of &gt; F by additional examples for lemma speculation borrowed from <ref> [10] </ref>. There 50 theorems T 1; :::; T 50 are given which can be proved by 24 speculated lemmata L1; :::; L24 (and 12 generalizations). <p> Theorems and Lemmata from <ref> [10] </ref> For dealing with the theorem-lemma-pair T 15 &gt; F L1 in Table 4, criterion (d) of Definition 3 is used. This is because Lemma L1 which is speculated for proving Theorem T 15 can also be obtained as a generalization (by inverted substitution, cf. [19]) of T 15.
Reference: 11. <author> D. Kapur and H. Zhang. RRL: </author> <title> A Rewrite Rule Laborarory. </title> <editor> In E. Lusk and R. Overbeek, editors, </editor> <booktitle> Proceedings of the 9th International Conference on Automated Deduction (CADE-88), Argonne, </booktitle> <pages> pages 768-769. </pages> <publisher> Springer LNCS 310, </publisher> <year> 1988. </year>
Reference-contexts: The latter feature is particularly important, because it is retained if the human advisor is substituted by a machine, i.e. an automated induction theorem prover, cf. <ref> [1, 2, 10, 11, 19] </ref>: Many domains, such as induction theorem proving or planning, do not have complete problem solvers, i.e. problem solvers which solve each solvable problem. Then the speculation of useful subgoals yields a relevant improvement of the system's problem solving performance.
Reference: 12. <author> T. Kolbe and C. Walther. </author> <title> Reusing Proofs. </title> <editor> In A. Cohn, editor, </editor> <booktitle> Proceedings of the 11th European Conference on Artificial Intelligence (ECAI-94), </booktitle> <address> Amsterdam, The Netherlands, </address> <pages> pages 80-84. </pages> <publisher> John Wiley & Sons, Ltd., </publisher> <year> 1994. </year>
Reference-contexts: 1 Introduction We investigate the improvement of theorem provers by reusing previously computed proofs, cf. <ref> [12, 13] </ref>. Our work has similarities with the methodologies of explanation-based learning [7], analogical reasoning [9], and abstraction [8], cf. [14] for a more detailed comparison. <p> We also give evidence for the general usefulness of our termination requirement for lemma speculation in induction theorem proving. 2 Reusing Proofs | An Example Let us briefly sketch our method for reusing proofs (see <ref> [12] </ref> for more details): An induction formula IH ! IC is either a step formula or a base formula in which case IH equals true. Induction formulas are proved by modifying the induction conclusion IC using given axioms until the induction hypothesis IH is applicable. <p> The set of axioms AX consists of defining axioms, previously proved lemmata, and logical axioms like x x, ' ! ' etc. Analyze: <ref> [12] </ref> The simple proof analysis which was illustrated in Section 2 analyzes a proof p of ', yielding a proof catch c. Formally, the catch c is a finite subset of non-logical axioms of AX such that c logically implies '. <p> For instance the (step formula of) statement 2 := plus (length (x); length (y)) length (append (x; y)) cannot be proved by reusing the proof shell from Figure 1, because one formula of the instantiated catch does not hold, cf. <ref> [12] </ref>. However, the reuse succeeds if refined analysis is applied (see below). Generalize: [12] Both ' and c are generalized by replacing (different occurrences of) function symbols with (different) function variables. <p> (step formula of) statement 2 := plus (length (x); length (y)) length (append (x; y)) cannot be proved by reusing the proof shell from Figure 1, because one formula of the instantiated catch does not hold, cf. <ref> [12] </ref>. However, the reuse succeeds if refined analysis is applied (see below). Generalize: [12] Both ' and c are generalized by replacing (different occurrences of) function symbols with (different) function variables.
Reference: 13. <author> T. Kolbe and C. Walther. </author> <title> Patching Proofs for Reuse. </title> <editor> In N. Lavrac and S. Wrobel, editors, </editor> <booktitle> Proceedings of the European Conference on Machine Learning (ECML-95), </booktitle> <address> Heraklion, Greece, </address> <pages> pages 303 - 306. </pages> <publisher> Springer LNAI 912, </publisher> <year> 1995. </year>
Reference-contexts: 1 Introduction We investigate the improvement of theorem provers by reusing previously computed proofs, cf. <ref> [12, 13] </ref>. Our work has similarities with the methodologies of explanation-based learning [7], analogical reasoning [9], and abstraction [8], cf. [14] for a more detailed comparison. <p> Solutions are computed by second-order matching modulo symbolical evaluation, cf. [16]. For the example, the solution 2 := fF 2;3 =succ (w 2 ); D 4 =addg is obtained which e.g. instantiates (11) to the axiom length (add (n; x)) succ (length (x)). 7 Patch: <ref> [13] </ref> Often one is not only interested in the provability of , but also in a proof of which can be presented to a human or can be processed subsequently. <p> Figure 1. computed substitution t := ffi because t might destroy the structure of P . Therefore the instantiated proof t (P ) is patched (which always succeeds) by removing void resp. inserting additional inference steps for obtaining a proof p 0 of , cf. <ref> [13] </ref>. Apart from initial proofs provided by the human advisor in the "prove" step, none of these steps necessitates human support.
Reference: 14. <author> T. Kolbe and C. Walther. </author> <title> Patching Proofs for Reuse. </title> <type> Technical Report IBN 95/27, </type> <institution> Technische Hochschule Darmstadt, </institution> <year> 1995. </year>
Reference-contexts: 1 Introduction We investigate the improvement of theorem provers by reusing previously computed proofs, cf. [12, 13]. Our work has similarities with the methodologies of explanation-based learning [7], analogical reasoning [9], and abstraction [8], cf. <ref> [14] </ref> for a more detailed comparison. Consider the following general architecture: Some problem solver PS is augmented with a facility for storing and retrieving solutions of problems solved during the system's lifetime.
Reference: 15. <author> T. Kolbe and C. Walther. </author> <title> Proof Management and Retrieval. </title> <booktitle> In Proceedings of the IJCAI'95 Workshop on Formal Approaches to the Reuse of Plans, Proofs, and Programs, </booktitle> <pages> pages 16-20, </pages> <year> 1995. </year>
Reference-contexts: Here e.g. the function variables F 1 ; F 2 ; F 3 correspond to different occurrences of the function symbol plus, i.e. the schematic equation (10) stems from generalizing (lem-1). Store: <ref> [15] </ref> Proofs shells h; C 1 i, ... ,h; C n i (sharing a common schematic goal formula ) are merged into a proof volume P V := h; fC 1 ; :::; C n gi which then is stored in the proof dictionary P D, i.e. a library of "proof <p> 1 (n; x); y)) s := &gt; &gt; &lt; (7) G 1 (D 1 (n; x)) F 2 (n; G 1 (x)) (9) G 3 (D 4 (n; x)) F 3 (n; G 3 (x)) 9 &gt; &gt; ; s for the proof of ' s (Refined Analysis) 6 Retrieve: <ref> [15] </ref> If a new conjecture is to be proved, the proof dictionary is searched for a proof volume P V := h; fC 1 ; :::; C n gi such that = () for some second-order matcher . <p> Here some restrictions on the class of admissible matchers can be imposed to make the retrieval more efficient, cf. <ref> [15] </ref>. E.g. 2 := fF 1 =plus; G 1;2;3 =length; H 1 =append; D 1;2 =addg is obtained by matching 0 s from Figure 3 with 2 above. If successful, the schematic conjecture and in turn also the proof volume P V applies for (via the matcher ).
Reference: 16. <author> T. Kolbe and C. Walther. </author> <title> Second-Order Matching modulo Evaluation | A Technique for Reusing Proofs. </title> <booktitle> In Proceedings of the 14th International Joint Conference on Artificial Intelligence (IJCAI-95), </booktitle> <address> Montreal, Canada, </address> <pages> pages 190-195, </pages> <year> 1995. </year>
Reference-contexts: In this way the system shall exhibit an intelligent behavior, although it is unable to find an original proof on its own, thus motivating the system's name, viz. the German word for plagiarist. Our approach has two benefits, as several experiments with the Plagiator system reveal <ref> [16] </ref>: (1) Resources are saved, because the number of required user interactions is decreased. (2) The performance of the overall system is improved, because the Plagiator system is able to speculate lemmata, which are helpful to prove a given conjecture. <p> length (add (n; x)) F 2 (n; length (x)) (12) append (add (n; x); y) D 4 (n; append (x; y)) (13) length (D 4 (n; x)) F 3 (n; length (x)) (14) plus (F 2 (x; y); z) F 3 (x; plus (y; z)) 9 &gt; &gt; ; Adapt: <ref> [16] </ref> Since a partially instantiated catch (C i ) may contain free function variables, i.e. function variables which occur in C i but not in , these function variables have to be instantiated by known functions. <p> Such a second-order substitution is called a solution (for the free function variables), and is proved by reuse because semantical entailment is invariant w.r.t. (second-order) instantiation. Solutions are computed by second-order matching modulo symbolical evaluation, cf. <ref> [16] </ref>.
Reference: 17. <author> T. Kolbe and C. Walther. </author> <title> On the Benefits of Reusing Past Problem Solutions. </title> <type> Technical Report IBN 96/35, </type> <institution> Technische Hochschule Darmstadt, </institution> <year> 1996. </year>
Reference-contexts: The presence and the degree of these benefits strongly depend on the quality of the problem solver and the domain it is operating on, cf. <ref> [17] </ref>. Here we consider a domain where problems are conjectures to be proved. We have developed and implemented the Plagiator system [3] which proves theorems by mathematical induction 2 in the spirit of the problem reduction paradigm [18]: If ? This work was supported under grants no.
Reference: 18. <author> N. J. Nilsson. </author> <title> Problem Solving Methods in Artificial Intelligence. </title> <publisher> McGraw Hill, </publisher> <address> New York, </address> <year> 1971. </year>
Reference-contexts: Here we consider a domain where problems are conjectures to be proved. We have developed and implemented the Plagiator system [3] which proves theorems by mathematical induction 2 in the spirit of the problem reduction paradigm <ref> [18] </ref>: If ? This work was supported under grants no. <p> as an instance of the problem reduction paradigm, where a problem p is mapped to a finite set of subproblems fp 1 ; :::; p n g by some (problem-)reduction operators, and each of the subproblems p i is mapped to a finite set of subproblems in turn, etc., cf. <ref> [18] </ref>. The reduction process stops successfully, if each subproblem eventually is reduced to a primitive problem p 0 where primitiveness is a syntactical notion depending on the particular problem solving domain. The only requirement is that "primitive" problems are trivially solvable indeed and that a solution is obvious.
Reference: 19. <author> C. Walther. </author> <title> Mathematical Induction. </title> <editor> In D. M. Gabbay, C. J. Hogger, and J. A. Robinson, editors, </editor> <booktitle> Handbook of Logic in Artificial Intelligence and Logic Programming, </booktitle> <volume> volume 2, </volume> <pages> pages 127-227. </pages> <publisher> Oxford University Press, </publisher> <year> 1994. </year>
Reference-contexts: The latter feature is particularly important, because it is retained if the human advisor is substituted by a machine, i.e. an automated induction theorem prover, cf. <ref> [1, 2, 10, 11, 19] </ref>: Many domains, such as induction theorem proving or planning, do not have complete problem solvers, i.e. problem solvers which solve each solvable problem. Then the speculation of useful subgoals yields a relevant improvement of the system's problem solving performance. <p> G (u)) G (H (x; u)) ! C s := &lt; (1) G (D (n; x)) F (n; G (x)) (3) F (F (x; y); z) F (x; F (y; z)) = If a new statement shall be proved, a suitable induction axiom is selected by well-known automated methods, cf. <ref> [19] </ref>, from which a set of induction formulas I is computed for . Then for proving an induction formula i 2 I by reuse, it is tested whether some proof shell PS applies for i , i.e. whether i is a (second-order) instance of the schematic induction formula of PS. <p> 0 from Figure 3 applies for via the second-order matcher 9 = fF 1 =plus (w 1 ; succ (w 1 )); G 1 =w 1 ; G 3 =succ (w 1 ); H 1 =plus (w 1 ; w 1 ); 8 Simplified conjectures are obtained by symbolic evaluation <ref> [19] </ref>. <p> Obviously, &gt; def is transitive and by the requirements for the introduction of function symbols which in particular exclude mutual recursion, cf. <ref> [19] </ref>, &gt; def is well-founded. We have, for instance, exp &gt; def times &gt; def plus and prod &gt; def times &gt; def plus as well as sum &gt; def plus. <p> defining axioms are uniformly obtained), we may identify non-empty sets of so-called recursion variables R f fx 1 ; :::; x n g with each term f (x 1 ; :::; x n ), where x 1 ; :::; x n are distinct variables, if f is recursively defined, cf. <ref> [19] </ref> and the notion of "measured subsets" in [2]. Each such set R f stipulates the variables to be induced upon when a statement containing a term f (x 1 ; :::; x n ) is to be proved by induction. <p> By requirement (d), a pair of conjectures ' and can also be related if is strictly more general than '. This feature is useful in particular if a speculated lemma can be obtained as a generalization by inverted substitution <ref> [19] </ref>, see Section 6. Corollary 4. &gt; F is well-founded. <p> Theorems and Lemmata from [10] For dealing with the theorem-lemma-pair T 15 &gt; F L1 in Table 4, criterion (d) of Definition 3 is used. This is because Lemma L1 which is speculated for proving Theorem T 15 can also be obtained as a generalization (by inverted substitution, cf. <ref> [19] </ref>) of T 15. Our order &gt; F is only appropriate for this kind of generalizations, and an extension of the termination requirement for incorporating other generalizations is subject for future research. <p> Note that there is no well-founded relation A such that ' A for each sound generalization of a conjecture ', because there are non-well-founded generalizations like := ' ^ ' 0 for some ' 0 , cf. <ref> [19] </ref>. But as sophisticated heuristics are used for deciding when and which generalization is performed, one might find a well-founded relation sufficient for dealing with practical examples. Acknowledgements. We thank Jurgen Giesl for comments on an earlier version of this paper.
References-found: 19

