URL: http://www.cs.wisc.edu/~venkatar/papers/vldbjnl.ps
Refering-URL: http://www.cs.wisc.edu/~venkatar/venkatar.html
Root-URL: 
Title: Parallelizing OODBMS Traversals: A Performance Evaluation  
Author: David J. DeWitt Jeffrey F. Naughton John C. Shafer Shivakumar Venkataraman 
Date: May 2, 1995  
Abstract: In this paper we describe the design and implementation of ParSets, a means of exploiting parallelism in the SHORE OODBMS. We used ParSets to parallelize the graph traversal portion of the OO7 OODBMS benchmark, and present speedup and scaleup results from parallel SHORE running these traversals on a cluster of commodity workstations connected by a standard ethernet. For some OO7 traversals, SHORE achieved excellent speedup and scaleup; for other OO7 traversals, only marginal speedup and scaleup occurred. The characteristics of these traversals shed light on when the ParSet approach to parallelism can and cannot be applied to speed up an application.
Abstract-found: 1
Intro-found: 1
Reference: [BBKV87] <author> F. Bancilhon, T. Briggs, S. Khoshafian, and P. Valduriez. </author> <title> FAD, a powerful and simple database language. </title> <booktitle> In Proc. VLDB Conf., </booktitle> <address> Brighton, England, </address> <year> 1987. </year>
Reference-contexts: facility is a variation of an idea that has appeared in many places before: essentially, it allows a program to invoke a method on every object in a set in parallel. (One place this idea appeared in a database context was the "filter" operation in the Bubba project at MCC <ref> [BBKV87] </ref>.
Reference: [Cat93] <author> R. Cattell. </author> <title> The Object Database Standard: ODMG-93. </title> <publisher> Morgan Kaufmann, </publisher> <address> San Mateo, CA, </address> <year> 1993. </year>
Reference-contexts: A ParSet is simply a set of objects of the same type or an appropriate subtype. The SHORE Data Language (SDL), which is our interpretation of the ODMG standard data definition language ODL <ref> [Cat93] </ref>, is used as the type language for ParSet objects. These sets of objects may be declustered over one or more SHORE servers; they are manipulated through several operations supported in the ParSet Library.
Reference: [CDF + 94] <author> Michael J. Carey, David J. DeWitt, Michael J. Franklin, Nancy E. Hall, Mark McAuliffe, Jeffrey F. Naughton, Daniel T. Schuh, Marvin H. Solomon, C. K. Tan, Odysseas Tsatalos, Seth White, and Michael J. Zwilling. </author> <title> Shoring up persistent applications. </title> <booktitle> In Proceedings of the 1994 ACM-SIGMOD Conference on the Management of Data, </booktitle> <address> Minneapolis, MN, </address> <month> May </month> <year> 1994. </year>
Reference-contexts: A main goal of the SHORE Persistent Object Store project <ref> [CDF + 94] </ref> is to exploit parallelism to improve the performance of OODBMS applications. Our goal is not, however, to solve the problem of automatically parallelizing arbitrary C++ code. <p> In this section we present an overview of the SHORE system in order to make this paper self-contained. This section is a greatly abridged version of material in <ref> [CDF + 94] </ref>. A primary goal for SHORE is to provide a robust, high-performance, persistent object system that is flexible enough to be employed in a wide range of applications and computing environments. To meet this requirement, SHORE's implementation is based on a novel peer-to-peer process structure.
Reference: [CDN] <author> Michael J. Carey, David J. DeWitt, and Jeffrey F. Naughton. </author> <title> The OO7 multiuser benchmark: Preliminary studies. </title> <note> Submitted for publication. </note>
Reference-contexts: The way we did so was to increase the number of modules in the database in proportion to the number of processors. (This same scaleup is being used in the multiuser OO7 benchmark that is currently under development <ref> [CDN] </ref>.) The only required change to the traversal code is that now the initial assembly traversal that gathers the OIDs of composite parts must traverse the assembly hierarchy of all modules. fits entirely in memory.
Reference: [CDN93] <author> Michael J. Carey, David J. DeWitt, and Jeffrey F. Naughton. </author> <title> The OO7 benchmark. </title> <booktitle> In Proceedings of the 1993 ACM-SIGMOD Conference on the Management of Data, </booktitle> <address> Washington D.C., </address> <month> May </month> <year> 1993. </year>
Reference-contexts: This paper describes the design and implementation of one primitive we have provided (the ParSet facility), discusses how ParSets can be used to parallelize the OO7 OODBMS benchmark traversals <ref> [CDN93] </ref>, and finally presents performance results from an implementation on a cluster of Sun workstations. <p> about the termination of the application and terminates the slaves. 15 4 The OO7 Benchmark Overview In this section we describe enough of the OO7 benchmark to make this paper self-contained; a more detailed description of the benchmark, along with performance results from a number of commercial systems, appears in <ref> [CDN93] </ref>. 4.1 The OO7 Database The OO7 benchmark is intended to be suggestive of many different CAD/CAM/CASE applications, although in its details it does not model any specific application. The goal of the benchmark is to test many aspects of system performance, rather than to model a specific application.
Reference: [DG92] <author> D. DeWitt and J. Gray. </author> <title> Parallel database systems: The future of high performance database processing. </title> <journal> Communications of the ACM, </journal> <month> June </month> <year> 1992. </year>
Reference-contexts: 1 Introduction The commercial success of parallel relational database systems (RDBMS) demonstrates convincingly that for RDBMS, parallelism is a highly effective tool for providing high performance <ref> [DG92] </ref>. However, it is much less clear whether parallelism can be effectively applied in object-oriented database systems (OODBMS.) This is primarily because of the difference in workloads between RDBMS and OODBMS: while RDBMS typically execute queries specified in a set-oriented declarative language (SQL), OODBMS typically execute arbitrary C++ code.
Reference: [DNSV94] <author> David J. DeWitt, Jeffrey F. Naughton, John Shafer, and Shivakumar Venkataraman. </author> <title> Paral-lelizing OODBMS Traversals: A Performance Evaluation. </title> <booktitle> In Proceedings of the 1994 Conference on Parallel and Distributed Information Systems, </booktitle> <address> Austin, Texas, </address> <month> Sept </month> <year> 1994. </year>
Reference: [Kil] <author> Michael F. Kilian. </author> <type> Personal Communication. </type> <month> Feb </month> <year> 1994. </year>
Reference-contexts: Currently a related facility is being implemented at Kendall Square Research on top of the Matisse OODBMS <ref> [Kil] </ref>.) Since this not a new idea, this is not the contribution of this paper; rather, the contributions of this paper are (1) a description of how the ParSet facility is actually implemented within SHORE, and (2) a description of how the ParSet facility can be used to parallelize the traversals
Reference: [Kil92] <author> Michael F. Kilian. </author> <title> Parallel Sets: An Object-Oriented Methodology for Massively Parallel Programming. </title> <type> PhD thesis, </type> <institution> Harvard Center for Research in Computing Technology, </institution> <address> Cambridge, MA, </address> <year> 1992. </year>
Reference-contexts: facility is sufficient for a basic understanding of the rest of this paper; readers that are not interested in the details of ParSets and how they are implemented can safely skip to Section 4. 3.1 What is a ParSet? The idea of a ParSet was first proposed by Michael Kilian <ref> [Kil92] </ref> (under the name "Parallel Set") as a way of adopting the data parallel approach to C++, although the ideas used in ParSets have appeared earlier in other data-parallel languages. SHORE ParSets differ from Kilian's ParSets in a number of ways, as will be discussed below.
References-found: 9

