URL: http://www.cs.nmsu.edu/~epontell/ilps97/10.ps.gz
Refering-URL: http://www.cs.nmsu.edu/lldap/ilps97/programme.html
Root-URL: http://www.cs.nmsu.edu
Email: zhou@mse.kyutech.ac.jp  
Title: The Finite-Domain Constraint Compiler of  
Author: B-Prolog Neng-Fa Zhou 
Address: 680-4 Kawazu, Iizuka, Fukuoka 820, Japan  
Affiliation: Faculty of Computer Science and Systems Engineering Kyushu Institute of Technology  
Abstract: In this paper, we describe a simple but efficient compiler for compiling constraints over finite domains. The compiler translates constraints into Prolog predicates that use the general delay mechanism and primitives on domain variables to encode the constraint propagation procedures tailored to the source constraints. The compiler is simple because it uses Prolog as the object language and uses the general delay mechanism. Most of the widely used compilers, such as CLP(FD) developed at INRIA and SICStus-Prolog developed at SICS, compile constraints into primitive ones, called indexicals, to which the delay mechanism is wired. Besides the simplicity in implementation, our compiler also has the following three advantages: First, because our compiler translates one or multiple constraints into one Prolog predicate, the compiled constraints are coarse-grained and the cost for managing the constraint queue is low. Second, by compiling several constraints into one predicate, some common delay-condition tests against variables can be merged. Finally, because Prolog with delaying has a much stronger description power than indexicals, our compiler opens new ways to compiling constraints, especially n-ary constraints. The compiler has been implemented by modifying the B-Prolog compiler and is available from http://www.cad.mse.kyutech.ac.jp/people/zhou/bprolog.html. For several benchmark programs, the compiler, although an emulator-based one having great potentials for further improvements, is comparable in performance with the C-based CLP(FD) compiler developed at INRIA. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Abderrahmane Aggoun and Nicolas Beldiceanu: </author> <title> Overview of the CHIP Compiler System, </title> <booktitle> In Proceedings of the 8th International Conference on Logic Programming, </booktitle> <pages> 775-789, </pages> <publisher> MIT Press, </publisher> <year> 1991. </year>
Reference-contexts: The propagation procedure adopted is general enough for handling all types of constraints. Learning from the experience of compiling logic programs into the WAM [10], several researchers have extended the WAM for compiling CLP (FD). In the CHIP compiler <ref> [1] </ref>, constraints are compiled into low level instructions such that canonical-forms can be constructed quickly and different specialized propagation procedures can be used for different types of constraints. <p> Algorithm Time Effect Consistency check generated X 2 2::5; Y 2 1::4 Forward checking X = 3 X = 3; Y = 2 Partial lookahead X 6= 5 X 2 2::4; Y 2 1::3 Full lookahead X 6= 4 X 2 [2; 3; 5]; Y 2 <ref> [1; 2; 4] </ref> 4 Workshop on Parallelism and Implementation Technology 2.3. Delay Clause Each Prolog predicate is defined by several optional delay clauses followed by a sequence of definite clauses. A delay clause takes the following form: delay Head :- Condition : Action.
Reference: [2] <author> Philippe Codognet and Daniel Diaz: </author> <title> Compiling Constraints in clp(FD), </title> <journal> Journal of Logic Programming, </journal> <pages> 185-226, </pages> <year> 1996. </year>
Reference-contexts: Recently, Codognet and Diaz at INRIA have developed a compiler, referred to as CD compiler below, that compiles every constraint into a sequence of primitive constraints (also called indexicals) in the form X in r where X is a domain variable and r specifies the range for X <ref> [2] </ref>. For each primitive constraint, a propagation procedure specific to the constraint is adopted. <p> Algorithm Time Effect Consistency check generated X 2 2::5; Y 2 1::4 Forward checking X = 3 X = 3; Y = 2 Partial lookahead X 6= 5 X 2 2::4; Y 2 1::3 Full lookahead X 6= 4 X 2 <ref> [2; 3; 5] </ref>; Y 2 [1; 2; 4] 4 Workshop on Parallelism and Implementation Technology 2.3. Delay Clause Each Prolog predicate is defined by several optional delay clauses followed by a sequence of definite clauses. A delay clause takes the following form: delay Head :- Condition : Action. <p> Algorithm Time Effect Consistency check generated X 2 2::5; Y 2 1::4 Forward checking X = 3 X = 3; Y = 2 Partial lookahead X 6= 5 X 2 2::4; Y 2 1::3 Full lookahead X 6= 4 X 2 [2; 3; 5]; Y 2 <ref> [1; 2; 4] </ref> 4 Workshop on Parallelism and Implementation Technology 2.3. Delay Clause Each Prolog predicate is defined by several optional delay clauses followed by a sequence of definite clauses. A delay clause takes the following form: delay Head :- Condition : Action. <p> This method is adopted in the CD compiler. It does not has the size-explosion problem of the first method and can take advantage of the constraint library which is usually well tuned and sometimes implemented in low-level languages. In addition, this method, as described in <ref> [2] </ref>, can restrict a propagation within a small constraint as long as the shared variable does not change. However, this method has to introduce new variables and constraints. The third method is to incrementally simplify n-ary constraints to lower degree ones. <p> This way of handling disjunctive constraints is said to be constructive and has been studied by many authors, e.g., <ref> [2, 6] </ref>. 6. Performance Evaluation The CLP (FD) compiler described in this paper has been implemented by modifying the B-Prolog compiler, an emulator-based fast Prolog system. Currently, the compiler is still not able to compile composite constraints as described in this paper. <p> Table 1 compares the CPU times 1 required to execute several programs by three systems: CD, the CD compiler (version 2.21); and BP, the B-Prolog compiler (version 2.1). All the programs are taken from <ref> [5, 2] </ref>. The first four programs include only inequality (#"=) constraints; the magic4 program includes both equality and inequality constraints; and the remaining four programs include only equality constraints. All the programs, except for queens-96 and queens-256, instantiate variables in the given order.
Reference: [3] <author> Philippe Codognet and Daniel Diaz: </author> <title> A Simple and Efficient Boolean Solver for Constraint Logic Programming, </title> <journal> Journal of Automated Reasoning, </journal> <volume> 17 </volume> <pages> 97-128, </pages> <year> 1996. </year>
Reference-contexts: This open way of defining constraint propagation not only simplifies the constraint solver but also makes it easy to handle many other types of constraints such as Boolean constraints <ref> [3] </ref>. In this paper, we describe a different glass-box compiler that compiles CLP (FD) into Prolog. Constraints are compiled basically into Prolog predicates one to one. In some cases, constraints that share some variables are compiled into only one predicate. <p> Algorithm Time Effect Consistency check generated X 2 2::5; Y 2 1::4 Forward checking X = 3 X = 3; Y = 2 Partial lookahead X 6= 5 X 2 2::4; Y 2 1::3 Full lookahead X 6= 4 X 2 <ref> [2; 3; 5] </ref>; Y 2 [1; 2; 4] 4 Workshop on Parallelism and Implementation Technology 2.3. Delay Clause Each Prolog predicate is defined by several optional delay clauses followed by a sequence of definite clauses. A delay clause takes the following form: delay Head :- Condition : Action.
Reference: [4] <author> M. Dincbas, P. Van Hentenryck, H. Simonis, A. Aggoun, T. Graf, and F. Berthier: </author> <title> The Constraint Logic Programming Language CHIP, </title> <booktitle> In Proceedings of the Fifth Generation Computer Systems, </booktitle> <pages> 693-702, </pages> <publisher> ICOT, </publisher> <year> 1988. </year>
Reference-contexts: CLP (FD), which is the most important instance of the general Constraint Logic Programming scheme [7], has been used successfully to solve a large number of real-life problems in scheduling, planning, design, etc. In early CLP (FD) systems, such as in the CHIP system <ref> [4] </ref>, constraints are interpreted rather than compiled: constraints are first transformed into canonical-form terms and are then executed by 1 2 Workshop on Parallelism and Implementation Technology an interpreter that performs, among other things, constraint propagation. The propagation procedure adopted is general enough for handling all types of constraints. <p> Algorithm Time Effect Consistency check generated X 2 2::5; Y 2 1::4 Forward checking X = 3 X = 3; Y = 2 Partial lookahead X 6= 5 X 2 2::4; Y 2 1::3 Full lookahead X 6= 4 X 2 [2; 3; 5]; Y 2 <ref> [1; 2; 4] </ref> 4 Workshop on Parallelism and Implementation Technology 2.3. Delay Clause Each Prolog predicate is defined by several optional delay clauses followed by a sequence of definite clauses. A delay clause takes the following form: delay Head :- Condition : Action.
Reference: [5] <author> Pascal Van Hentenryck: </author> <title> Constraint Satisfaction in Logic Programming. </title> <publisher> MIT Press, </publisher> <year> 1989. </year>
Reference-contexts: Constraint propagation has been incorporated as an important step into many search algorithms, such as the forward checking and lookahead algorithms [8]. It has been also employed as one of the basic operations in CLP (FD) <ref> [5, 6] </ref>. CLP (FD), which is the most important instance of the general Constraint Logic Programming scheme [7], has been used successfully to solve a large number of real-life problems in scheduling, planning, design, etc. <p> Algorithm Time Effect Consistency check generated X 2 2::5; Y 2 1::4 Forward checking X = 3 X = 3; Y = 2 Partial lookahead X 6= 5 X 2 2::4; Y 2 1::3 Full lookahead X 6= 4 X 2 <ref> [2; 3; 5] </ref>; Y 2 [1; 2; 4] 4 Workshop on Parallelism and Implementation Technology 2.3. Delay Clause Each Prolog predicate is defined by several optional delay clauses followed by a sequence of definite clauses. A delay clause takes the following form: delay Head :- Condition : Action. <p> Note that our event handler is not sensitive to changes to intermediate elements in domains. This means that our scheme cannot be used to implement the full lookahead algorithm <ref> [5, 8] </ref>. In practice, this is not a drawback because it was found better to perform constraint propagation in a limited form and the full lookahead algorithm has in general worse performance than the forward checking and partial lookahead algorithms [8]. 3. <p> Table 1 compares the CPU times 1 required to execute several programs by three systems: CD, the CD compiler (version 2.21); and BP, the B-Prolog compiler (version 2.1). All the programs are taken from <ref> [5, 2] </ref>. The first four programs include only inequality (#"=) constraints; the magic4 program includes both equality and inequality constraints; and the remaining four programs include only equality constraints. All the programs, except for queens-96 and queens-256, instantiate variables in the given order.
Reference: [6] <author> Pascal Van Hentenryck, Vijay Saraswat, and Yves Deville: </author> <title> Design, Implementation, and Evaluation of the Constraint Language cc(FD), </title> <type> Technical Report No.CS-93-02, </type> <institution> Brown University, </institution> <year> 1993. </year>
Reference-contexts: Constraint propagation has been incorporated as an important step into many search algorithms, such as the forward checking and lookahead algorithms [8]. It has been also employed as one of the basic operations in CLP (FD) <ref> [5, 6] </ref>. CLP (FD), which is the most important instance of the general Constraint Logic Programming scheme [7], has been used successfully to solve a large number of real-life problems in scheduling, planning, design, etc. <p> This way of handling disjunctive constraints is said to be constructive and has been studied by many authors, e.g., <ref> [2, 6] </ref>. 6. Performance Evaluation The CLP (FD) compiler described in this paper has been implemented by modifying the B-Prolog compiler, an emulator-based fast Prolog system. Currently, the compiler is still not able to compile composite constraints as described in this paper.
Reference: [7] <author> Joxan Jaffar and J.-L. Lassez: </author> <booktitle> Constraint Logic Programming In Proceedings of 14th ACM Symposium on Principle on Programming Languages, </booktitle> <pages> 111-119, </pages> <year> 1987. </year>
Reference-contexts: It has been also employed as one of the basic operations in CLP (FD) [5, 6]. CLP (FD), which is the most important instance of the general Constraint Logic Programming scheme <ref> [7] </ref>, has been used successfully to solve a large number of real-life problems in scheduling, planning, design, etc.
Reference: [8] <author> Vipin Kumar. </author> <title> Algorithms for Constraint Satisfaction Problems: A Survey. </title> <journal> AI Magazine, </journal> <pages> 32-44, </pages> <booktitle> 1992,. Workshop on Parallelism and Implementation Technology 11 </booktitle>
Reference-contexts: Constraint propagation has been incorporated as an important step into many search algorithms, such as the forward checking and lookahead algorithms <ref> [8] </ref>. It has been also employed as one of the basic operations in CLP (FD) [5, 6]. CLP (FD), which is the most important instance of the general Constraint Logic Programming scheme [7], has been used successfully to solve a large number of real-life problems in scheduling, planning, design, etc. <p> Note that our event handler is not sensitive to changes to intermediate elements in domains. This means that our scheme cannot be used to implement the full lookahead algorithm <ref> [5, 8] </ref>. In practice, this is not a drawback because it was found better to perform constraint propagation in a limited form and the full lookahead algorithm has in general worse performance than the forward checking and partial lookahead algorithms [8]. 3. <p> In practice, this is not a drawback because it was found better to perform constraint propagation in a limited form and the full lookahead algorithm has in general worse performance than the forward checking and partial lookahead algorithms <ref> [8] </ref>. 3. Compiling Basic Constraints The compiler first translates a constraint into a canonical-form and then generates a predicate that performs the constraint propagation.
Reference: [9] <author> Alan K. Mackworth. </author> <title> Constraint Satisfaction. </title> <booktitle> In Encyclopedia of Artificial Intelligence, </booktitle> <publisher> John Wiley & Sons, </publisher> <pages> 205-211, </pages> <year> 1986. </year>
Reference-contexts: 1. Introduction Constraint propagation is a prominent technique originated in Artificial Intelligence for solving constraint satisfaction problems (CSPs) <ref> [9] </ref>. It uses constraints actively to prune search spaces as follows: whenever a variable changes, i.e., the variable has been instantiated or its domain has been updated, the domains of all the remaining variables are filtered to contain only those values that are consistent with this variable.
Reference: [10] <author> David H.D. Warren. </author> <title> An Abstract Prolog Instruction. </title> <type> Technical Report TR-309, </type> <institution> SRI International, </institution> <year> 1983. </year>
Reference-contexts: The propagation procedure adopted is general enough for handling all types of constraints. Learning from the experience of compiling logic programs into the WAM <ref> [10] </ref>, several researchers have extended the WAM for compiling CLP (FD). In the CHIP compiler [1], constraints are compiled into low level instructions such that canonical-forms can be constructed quickly and different specialized propagation procedures can be used for different types of constraints.
Reference: [11] <author> Neng-Fa Zhou. </author> <title> Parameter Passing and Control Stack Management in Prolog Implementation Revisited, </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 18 </volume> <pages> 752-779, </pages> <month> November </month> <year> 1996. </year>
Reference-contexts: As constraints in our system is coarse-grained, the constraint queue tends to be short. Second, by compiling several constraints that share some variables into one predicate, we can greatly reduce the number of delay-condition tests. The compiler has been implemented by modifying the B-Prolog compiler <ref> [11] </ref>, an emulator-based compiler. The experimental results are very promising. Although there are great potentials Workshop on Parallelism and Implementation Technology 3 for further improvements, it is comparable in performance to that of the CD compiler. <p> In this way, the condition needs not be executed each time when the bounds of domains are updated. Shared tests among clauses are combined into one by the Prolog compiler <ref> [11] </ref>. Thus, when X is found to be a nonvariable term, then the second clause will be skipped and the third clause will be executed. In Introduction, we have shown the generated predicate for the inequality constraint X#"=Y.
Reference: [12] <author> Neng-Fa Zhou. </author> <title> A Novel Implementation Method of Delay. </title> <booktitle> In Proceedings of Joint International Conference and Symposium on Logic Programming, </booktitle> <pages> pages 97-111, </pages> <publisher> MIT Press, </publisher> <year> 1996. </year>
Reference-contexts: It would be impossible to implement a fast CLP (FD) system based on our scheme without a fast delay mechanism. Fortunately, we already have a fast delay mechanism implemented in the B-Prolog system <ref> [12] </ref>. Besides adopting the general purpose but fast delay mechanism, our compiler also has two advantages over the CD compiler concerning efficiency. First, in the CD compiler, each constraint with n variables is compiled into n primitive constraints, each of which is a coroutine.
References-found: 12

