URL: http://www.cs.wustl.edu/~schmidt/Connector.ps.gz
Refering-URL: http://www.cs.wustl.edu/~schmidt/new.html
Root-URL: http://www.cs.wustl.edu
Email: schmidt@cs.wustl.edu  
Phone: (314) 935-7538  
Title: Connector A Design Pattern for Actively Initializing Network Services  
Author: Douglas C. Schmidt 
Address: St. Louis, MO 63130, USA  
Affiliation: Department of Computer Science Washington University  
Abstract: This paper appeared in the January 1996 issue of the C++ Report magazine. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> D. C. Schmidt, </author> <title> Design Patterns for Initializing Network Services: Introducing the Acceptor and Connector Patterns, </title> <journal> C++ Report, </journal> <volume> vol. 7, </volume> <month> November/December </month> <year> 1995. </year>
Reference-contexts: The topic of this article is the Connector pattern. This design pattern enables the tasks performed by network services to evolve independently of the mechanisms that actively initialize the services. The Connector pattern is a companion to the Acceptor pattern <ref> [1] </ref>, which enables network services to evolve independently of the mechanisms that passively establish connections used by the services. The Connector and Acceptor patterns are commonly used in conjunction with connection-oriented protocols (such as TCP or SPX). These protocols reliably deliver data between two communication endpoints. <p> This separation of concerns increases the reusability, portability, and extensibility of this implementation of the Connector pattern. There is a striking similarity between the structure of the Connector class diagram and the Acceptor class diagram shown in <ref> [1] </ref>. In particular, the Reactive Layer is identical in both and the roles of the Svc Handler and Concrete Svc Handler are also very similar. <p> The Gateway plays the active role in establishing connections with Peers (an implementation of a Peer using the Acceptor pattern appears in <ref> [1] </ref>). are structured in the Gateway. 3.7.1 Svc Handlers for Routing The classes shown below, Status Router, Bulk Data Router, and Command Router, route data they receive from a source Peer to one or more destination Peers.
Reference: [2] <author> E. Gamma, R. Helm, R. Johnson, and J. Vlissides, </author> <title> Design Patterns: Elements of Reusable Object-Oriented Software. </title> <address> Reading, MA: </address> <publisher> Addison-Wesley, </publisher> <year> 1994. </year>
Reference-contexts: The Gateway is connected to the Peers via reliable, connection-oriented interprocess communication (IPC) protocols such as TCP. Using a connection-oriented protocol simplifies application error handling and enhances performance over long-delay WANs. Each communication service 1 In design patterns terminology, the Gateway is a Mediator <ref> [2] </ref> that coordinates interactions between its connected Peers. 1 in the Peers sends and receives status information, bulk data, and commands to and from the Gateway using separate TCP connections. The different services are connected to unique port numbers. <p> A service can run in a single-thread, in multiple threads, or multiple processes, regardless of how the connection was established. The following section describes the Connector pattern in detail, using a modified form of the design pattern description format presented in <ref> [2] </ref>. <p> An even more dynamic type of decoupling could be achieved via inheritance and polymorphism by using the Factory Method and Strategy patterns described in <ref> [2] </ref>. Parameterized types improve run-time efficiency at the expense of additional space and time 5 overhead during program compiling and linking. The implementation of the Connector's methods is pre sented below. To save space, most of the error handling has been omitted. <p> Once connections are established, applications then send and receive multi-megabyte medical images to and from these image stores. 3.9 Related Patterns The Connector pattern utilizes several other patterns <ref> [2] </ref>. It is a Factory that implements a generic Strategy for actively connecting to peers and activating a service handler when the connection is established. The connected service handler then performs its tasks using data exchanged on the connection.
Reference: [3] <author> G. Booch, </author> <title> Object Oriented Analysis and Design with Applications (2 nd Edition). </title> <address> Redwood City, California: Ben-jamin/Cummings, </address> <year> 1993. </year>
Reference-contexts: depend on the steps required to actively initialize a service; * An application must establish a large number of connections with peers connected over long-delay networks (such as satellite WANs). 3.3 Structure and Participants The structure of the participants in the Connector pattern is illustrated by the Booch class diagram <ref> [3] </ref> in Figure 2 and described below: 2 * Connector Connects and activates a Svc Handler. The Connector's connect method implements the strategy for actively connecting the Svc Handler with its remote peer.
Reference: [4] <author> D. C. Schmidt, ASX: </author> <title> an Object-Oriented Framework for Developing Distributed Applications, </title> <booktitle> in Proceedings of the 6 th USENIX C++ Technical Conference, </booktitle> <address> (Cambridge, Mas-sachusetts), </address> <publisher> USENIX Association, </publisher> <month> April </month> <year> 1994. </year>
Reference-contexts: The implementation described below is based on the ACE OO network programming toolkit <ref> [4] </ref>. <p> When all Peer connections are completely established, the Gateway can route and forward messages sent to it by Peers. 3.8 Known Uses The Reactor, Svc Handler, and Connector classes described in this article are all provided as reusable C++ components in the ACE toolkit <ref> [4] </ref>. <p> UNIX versions of the Connector, Acceptor, and Reactor patterns are freely available via the World Wide Web at URL http://www.cs.wustl.edu/schmidt/. This distribution contains complete source code, documentation, and example test drivers for the C++ components developed as part of the ACE object-oriented network programming toolkit <ref> [4] </ref> developed at the University of California, Irvine and Washington University. ACE is currently being used in communication software at many companies including Bellcore, Siemens, Motorola, Ericsson, and Kodak. Thanks to Tim Harrison for comments on this paper.
Reference: [5] <author> D. C. Schmidt, </author> <title> Reactor: An Object Behavioral Pattern for Concurrent Event Demultiplexing and Event Handler Dispatching, in Pattern Languages of Program Design (J. </title> <editor> O. Coplien and D. C. Schmidt, eds.), </editor> <address> Reading, MA: </address> <publisher> Addison-Wesley, </publisher> <year> 1995. </year>
Reference-contexts: The two participants at this layer, the Reactor and Event Handler, are reused from the Reactor pattern <ref> [5] </ref>. This pattern encapsulates OS event demultiplexing system calls (such as select, poll [6], and WaitForMultipleObjects [7]) with an extensible and portable callback-driven object-oriented interface. The Reactor pattern enables efficient demultiplexing of multiple types of events from multiple sources within a single thread of control. <p> The behavior of this pure virtual method must be defined by a subclass, which performs service-specific initializations. A subclass of Svc Handler is also responsible for determining the service's concurrency strategy. For example, a Svc Handler may employ the Reactor <ref> [5] </ref> pattern to process data from peers in a single-thread of control. To enable this, Svc Handler inherits from the Reactor pattern's Event Handler, which the Reactor to dispatch its handle event method when events occur on the PEER STREAM endpoint of communication.
Reference: [6] <author> W. R. Stevens, </author> <title> UNIX Network Programming. </title> <address> Englewood Cliffs, NJ: </address> <publisher> Prentice Hall, </publisher> <year> 1990. </year>
Reference-contexts: The two participants at this layer, the Reactor and Event Handler, are reused from the Reactor pattern [5]. This pattern encapsulates OS event demultiplexing system calls (such as select, poll <ref> [6] </ref>, and WaitForMultipleObjects [7]) with an extensible and portable callback-driven object-oriented interface. The Reactor pattern enables efficient demultiplexing of multiple types of events from multiple sources within a single thread of control. <p> For example, the SOCK Acceptor, SOCK Connector, and SOCK Stream classes used in Section 3.7 are part of the SOCK SAP C++ wrapper library for sockets [10]. Likewise, the corresponding TLI * classes are part of the TLI SAP C++ wrapper library for the Transport Layer Interface <ref> [6] </ref>. SOCK SAP and TLI SAP encapsulate the stream-oriented semantics of connection-oriented protocols like TCP and SPX with a efficient, portable, and type-safe C++ wrappers.
Reference: [7] <author> H. Custer, </author> <title> Inside Windows NT. </title> <address> Redmond, Washington: </address> <publisher> Mi-crosoft Press, </publisher> <year> 1993. </year>
Reference-contexts: The two participants at this layer, the Reactor and Event Handler, are reused from the Reactor pattern [5]. This pattern encapsulates OS event demultiplexing system calls (such as select, poll [6], and WaitForMultipleObjects <ref> [7] </ref>) with an extensible and portable callback-driven object-oriented interface. The Reactor pattern enables efficient demultiplexing of multiple types of events from multiple sources within a single thread of control.
Reference: [8] <author> D. C. Schmidt, </author> <title> The Object-Oriented Design and Implementation of the Reactor: A C++ Wrapper for UNIX I/O Multiplexing (Part 2 of 2), </title> <journal> C++ Report, </journal> <volume> vol. 5, </volume> <month> September </month> <year> 1993. </year>
Reference-contexts: The Reactor pattern enables efficient demultiplexing of multiple types of events from multiple sources within a single thread of control. An implementation of the Reactor pattern is shown in <ref> [8] </ref> and the two omain roles in the Reactive layer are describe below. * Reactor: This class defines an interface for registering, removing, and dispatching Event Handler objects (such as the Connector and Svc Handler).
Reference: [9] <author> R. G. Lavender and D. C. Schmidt, </author> <title> Active Object: an Object Behavioral Pattern for Concurrent Programming, </title> <booktitle> in Proceedings of the 2 nd Annual Conference on the Pattern Languages of Programs, </booktitle> <address> (Monticello, </address> <publisher> Illinois), </publisher> <pages> pp. 1-7, </pages> <month> September </month> <year> 1995. </year>
Reference-contexts: To enable this, Svc Handler inherits from the Reactor pattern's Event Handler, which the Reactor to dispatch its handle event method when events occur on the PEER STREAM endpoint of communication. Conversely, a Svc Handler might use the Active Object pattern <ref> [9] </ref> to process incoming data in a different thread of control than the one the Connector object used to connect it. Section 3.7 illustrates several different concurrency policies. * Connector: This abstract class implements the generic strategy for actively initializing network services.
Reference: [10] <author> D. C. Schmidt, </author> <title> IPC SAP: An Object-Oriented Interface to Interprocess Communication Services, </title> <journal> C++ Report, </journal> <volume> vol. 4, </volume> <month> November/December </month> <year> 1992. </year>
Reference-contexts: The IPC mechanisms are encapsulated in C++ classes to simplify programming, enhance reuse, and to enable wholesale replacement of IPC mechanisms. For example, the SOCK Acceptor, SOCK Connector, and SOCK Stream classes used in Section 3.7 are part of the SOCK SAP C++ wrapper library for sockets <ref> [10] </ref>. Likewise, the corresponding TLI * classes are part of the TLI SAP C++ wrapper library for the Transport Layer Interface [6]. SOCK SAP and TLI SAP encapsulate the stream-oriented semantics of connection-oriented protocols like TCP and SPX with a efficient, portable, and type-safe C++ wrappers.
Reference: [11] <author> D. C. Schmidt and T. Suda, </author> <title> An Object-Oriented Framework for Dynamically Configuring Extensible Distributed Communication Systems, </title> <journal> IEE/BCS Distributed Systems Engineering Journal (Special Issue on Configurable Distributed Systems), </journal> <volume> vol. 2, </volume> <pages> pp. 280-293, </pages> <month> December </month> <year> 1994. </year>
Reference-contexts: The Connector pattern has been used in the following systems: * The Ericsson EOS Call Center Management system <ref> [11] </ref> uses the Connector pattern to allow application-level Call Center Manager Gateways to actively establish connections with passive Peer hosts in a distributed system. * The high-speed medical image transfer subsystem of project Spectrum [12] uses the Connector pattern to actively establish connections and initialize application services for storing large medical
Reference: [12] <author> G. Blaine, M. Boyd, and S. Crider, </author> <title> Project Spectrum: Scalable Bandwidth for the BJC Health System, </title> <journal> HIMSS, Health Care Communications, </journal> <pages> pp. 71-81, </pages> <year> 1994. </year>
Reference-contexts: pattern has been used in the following systems: * The Ericsson EOS Call Center Management system [11] uses the Connector pattern to allow application-level Call Center Manager Gateways to actively establish connections with passive Peer hosts in a distributed system. * The high-speed medical image transfer subsystem of project Spectrum <ref> [12] </ref> uses the Connector pattern to actively establish connections and initialize application services for storing large medical images. Once connections are established, applications then send and receive multi-megabyte medical images to and from these image stores. 3.9 Related Patterns The Connector pattern utilizes several other patterns [2].
Reference: [13] <author> F. Buschmann, R. Meunier, H. Rohnert, P. Sommerlad, and M. Stal, </author> <title> Pattern-Oriented Software Architecture A System of Patterns. </title> <journal> Wileys and Sons, </journal> <note> to appear 1996. 10 </note>
Reference-contexts: The connected service handler then performs its tasks using data exchanged on the connection. Thus, the service is decoupled from the protocol used to establish the connection. The Connector pattern has an intent similar to the Client/Dispatcher/Server pattern described in <ref> [13] </ref>. They both are concerned with separating active connection establishment from the subsequent service. The primary difference is that the Connector pattern addresses both synchronous and asynchronous connection establishment.
References-found: 13

