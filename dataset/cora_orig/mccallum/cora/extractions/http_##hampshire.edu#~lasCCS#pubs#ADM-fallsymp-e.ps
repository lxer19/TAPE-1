URL: http://hampshire.edu/~lasCCS/pubs/ADM-fallsymp-e.ps
Refering-URL: http://hampshire.edu/~lasCCS/publications.html
Root-URL: http://www.aic.nrl.navy.mil/~aha/people.html
Title: Evolving Control Structures with Automatically Defined Macros  Evolving Control Structures with Automatically Defined Macros.  
Author: by Lee Spector 
Note: Full citation: Spector, L. 1995.  Working Notes of the AAAI Fall Symposium on Genetic Programming. The American Association for Artificial Intelligence. pp. 99-105.  
Abstract-found: 0
Intro-found: 1
Reference: <author> Dean, T.L. and M.P. Wellman. </author> <year> 1991. </year> <title> Planning and Control. </title> <address> San Mateo, CA: </address> <publisher> Morgan Kaufmann Publishers. </publisher>
Reference-contexts: Computational architectures for dynamic-world planning tend to use multiple control "levels," blackboard-based opportunistic control structures, "monitor" processes, and other complex and unusual control structures <ref> (Dean & Wellman 1991, Spector 1992) </ref>. A genetic programming system with ADMs should be capable of evolving and refining such control structures to suit particular problem environments.
Reference: <author> Graham, P. </author> <year> 1994. </year> <title> On Lisp: Advanced Techniques for Common Lisp. </title> <address> Englewood Cliffs, NJ: </address> <publisher> Prentice Hall. </publisher>
Reference-contexts: For example, the following macro causes the robot to turn until the given sense-expression returns non-nil, and returns the value of the given value-expression in its final orientation: (defmacro where-sensed (sense-expression value-expression) `(progn (while (not ,sense-expression) (turn)) ,value-expression)) 1 A good discussion of related issues can be found in <ref> (Graham 1994) </ref>. 2 The "backquote" syntax used in this definition is doc umented in (Steele 1990). This macro would be most useful when the bodies of code specified for sense-expression and value-expression depend on the orientation of the robot. <p> This is achieved by changing the runtime interpretation of a parameter symbol to branch to the code tree passed as an argument; actual expansion of the macro call is thereby avoided altogether. 3 Examples of macros that perform more exotic code transformations can be found in <ref> (Graham 1994) </ref>. More complex implementation strategies are required for ADMs that perform non-substitutional transformations of their arguments. In some cases it may be necessary to fully expand the ADMs prior to evaluation; this may lead to long macro-expansion delays and to very large expansions.
Reference: <author> Kernighan, B.W. and D.M. Ritchie. </author> <year> 1988. </year> <title> The C Programming Language. Second Edition. </title> <address> Engle-wood Cliffs, NJ: </address> <publisher> Prentice Hall. </publisher>
Reference-contexts: While subroutines promote program modularity and code reuse, they do not normally provide programmers with the tools needed to produce new control structures or to otherwise enhance the structure of their programming languages. Many languages provide an alternative mechanism, macros, to support this need <ref> (Kernighan & Ritchie 1988) </ref> (Steele 1990). In this paper I show how a genetic programming system can simultaneously evolve a program and its control structures; that is, I show how a genetic programming system can simultaneously evolve a main program and a collection of automatically defined macros (ADMs). <p> Macros I use the term "macro" to refer to operators that perform source code transformations. Many programming languages provide macro definition facilities, although the power of such facilities varies widely. For example, C provides substitution macros by means of a preprocessor <ref> (Kernighan & Ritchie 1988) </ref>, while Common Lisp allows the full power of the programming language to be used in the specification of macros (Steele 1990). A macro "call" is textually transformed into new source code prior to compilation or interpretation; this process is often called macro expansion.
Reference: <author> Kinnear, K.E. Jr. </author> <year> 1994. </year> <title> Alternatives in Automatic Function Definition: A Comparison of Performance. </title>
Reference-contexts: Further studies have investigated factors underlying the performance of Koza's automatically defined functions (ADFs) along with alternative techniques for the automatic generation of subroutines <ref> (Kinnear 1994) </ref>. While subroutines promote program modularity and code reuse, they do not normally provide programmers with the tools needed to produce new control structures or to otherwise enhance the structure of their programming languages. <p> Koza showed that the use of ADFs allows a genetic programming system to better exploit regularities of problem domains, improving system performance. Further studies have investigated factors underlying the performance of Koza's ADFs along with alternative techniques for the automatic generation of subroutines <ref> (Kinnear 1994) </ref>. Macros I use the term "macro" to refer to operators that perform source code transformations. Many programming languages provide macro definition facilities, although the power of such facilities varies widely.
Reference: <editor> In K.E. Kinnear Jr., Ed., </editor> <booktitle> Advances in Genetic Programming. </booktitle> <pages> pp. 119-141. </pages> <address> Cambridge, MA: </address> <publisher> The MIT Press. </publisher>
Reference: <editor> Koza, J.R. </editor> <booktitle> 1992. Genetic Programming. </booktitle> <address> Cambridge, MA: </address> <publisher> The MIT Press. </publisher>
Reference-contexts: I present data from case studies, discuss the results, and describe directions for future research. Genetic Programming Genetic programming is a technique for the automatic generation of computer programs by means of natural selection <ref> (Koza 1992) </ref>. The genetic programming process starts by creating a large initial population of programs that are random combinations of elements from problem-specific function and terminal sets. Each of the programs in the initial population is assessed for fitness.
Reference: <editor> Koza, J.R. </editor> <booktitle> 1994a. Genetic Programming II. </booktitle> <address> Cam-bridge, MA: </address> <publisher> The MIT Press. </publisher>
Reference-contexts: Introduction Modern programming languages support the production of structured, modular programs through several mechanisms including subroutines, coroutines, and macros. Koza has shown that the power of a genetic programming system can often be enhanced by allowing for the simultaneous evolution of a main program and a collection of subroutines <ref> (Koza 1994a) </ref>. Further studies have investigated factors underlying the performance of Koza's automatically defined functions (ADFs) along with alternative techniques for the automatic generation of subroutines (Kinnear 1994). <p> Koza has shown that the performance of a genetic programming system, as measured by the number of individuals that must be processed to produce a solution with a probability of 99%, can often be improved by allowing for the simultaneous evolution of a main program and a collection of subroutines <ref> (Koza 1994a) </ref>. He implements the evolution of subroutines by considering one part of an evolved program to be a main program (or "result producing branch") while other parts are treated as definitions for automatically defined functions (ADFs). <p> Incrementally expanded substitution ADMs are easy to implement through minor modifications to Koza's publicly available ADF code <ref> (Koza 1994a) </ref>. Koza's ADF functions are defined to fast-eval the evolved ADF code trees, after first binding the parameter symbols to the (evaluated) values passed to the ADF. For ADMs one can change fast-eval so that it treats ADMs like pseudo-macros, passing them unevaluated code trees as arguments. <p> Whenever the robot succeeds in moving onto a new square (by means of either a single move or a jump), it mops the location of the floor onto which it moves. <ref> (Koza 1994a, p. 365) </ref> OAR uses terminal sets consisting of the 0-argument function (MOP), the 0-argument function (LEFT), random vector constants modulo 8 (&lt; v8 ), and the names of arguments for ADFs. <p> The calculations of P (M,i) and I (M,i,z) were performed according to the discussion on pages 99 through 103 of <ref> (Koza 1994a) </ref>. P (M,i) is calculated by dividing the number of runs that succeed in each generation by the total number of runs, and by then calculating a running sum of the quotients across generations. <p> I performed 200 runs of a genetic programming system on the 64-square Lawnmower problem, half with ADFs and half with ADMs. Aside from the switch to ADMs for half of the runs, I used the same parameters as did Koza <ref> (Koza 1994a) </ref>. The results are shown in Figures 4 and 5. Figure 4 shows P (M,i) for ADFs and for ADMs on this problem; it is not obvious from casual inspection of this graph that either type of module provides greater benefit.
Reference: <author> Koza, J.R. </author> <year> 1994b. </year> <title> Architecture-altering Operations for Evolving the Architecture of a Multi-part Program in Genetic Programming. </title> <institution> Computer Science Department, Stanford University. CS-TR-94-1528. </institution>
Reference-contexts: Koza has previously made limited use of macro expansion in genetic programming; he used it as a means for deleting elements of programs during the simultaneous evolution of programs and their architectures <ref> (Koza 1994b) </ref>. The present work argues for the more general use of macro expansion through the evolution of ADMs. <p> Since the optimal number of ADFs and ADMs may not be clear from the outset, it may also be advantageous to simultaneously evolve programs and their macro-extended architectures, in the style of <ref> (Koza 1994b) </ref>. Future Work A reasonable speculation is that architectures that include both ADFs and ADMs will be particularly useful in application areas that have traditionally made use of exotic control structures.
Reference: <author> Russell, S.J., and P. Norvig. </author> <year> 1995. </year> <title> Artificial Intelligence, A Modern Approach. </title> <address> Englewood Cliffs, NJ: </address> <publisher> Prentice Hall. </publisher>
Reference-contexts: A genetic programming system with ADMs should be capable of evolving and refining such control structures to suit particular problem environments. One clear avenue for future work therefore is to apply ADM-based techniques to dynamic-world planning problems; preliminary work on the "wumpus world" environment <ref> (Russell & Norvig 1995) </ref> has produced results similar to those reported for DSOAR above, indicating that ADMs are indeed useful for such applications.
Reference: <author> Spector, L. </author> <year> 1992. </year> <title> Supervenience in Dynamic-World Planning. </title> <type> Ph.D. </type> <institution> diss., Dept. of Computer Science, University of Maryland. </institution>
Reference: <author> Steele, G.L. Jr. </author> <year> 1990. </year> <title> Common Lisp. Second Edition. </title> <publisher> Digital Press. </publisher>
Reference-contexts: While subroutines promote program modularity and code reuse, they do not normally provide programmers with the tools needed to produce new control structures or to otherwise enhance the structure of their programming languages. Many languages provide an alternative mechanism, macros, to support this need (Kernighan & Ritchie 1988) <ref> (Steele 1990) </ref>. In this paper I show how a genetic programming system can simultaneously evolve a program and its control structures; that is, I show how a genetic programming system can simultaneously evolve a main program and a collection of automatically defined macros (ADMs). <p> Many programming languages provide macro definition facilities, although the power of such facilities varies widely. For example, C provides substitution macros by means of a preprocessor (Kernighan & Ritchie 1988), while Common Lisp allows the full power of the programming language to be used in the specification of macros <ref> (Steele 1990) </ref>. A macro "call" is textually transformed into new source code prior to compilation or interpretation; this process is often called macro expansion. Macros, like subroutines, can assist in the modu-larization of complex programs and in the exploitation of domain regularities. <p> sense-expression returns non-nil, and returns the value of the given value-expression in its final orientation: (defmacro where-sensed (sense-expression value-expression) `(progn (while (not ,sense-expression) (turn)) ,value-expression)) 1 A good discussion of related issues can be found in (Graham 1994). 2 The "backquote" syntax used in this definition is doc umented in <ref> (Steele 1990) </ref>. This macro would be most useful when the bodies of code specified for sense-expression and value-expression depend on the orientation of the robot.
Reference: <author> Zongker, D. and B. Punch. </author> <year> 1995. </year> <note> lil-gp 1.0 User's Manual. Available via the Web at http://isl.cps.msu.edu/GA/software/lil-gp, or via anonymous FTP to isl.cps.msu.edu, in the directory "/pub/GA/lilgp". </note>
Reference-contexts: One can then define the ADM functions to substitute the unevaluated code trees for the parameter symbols, and then to fast-eval the result: (defun adm0 (a0) (fast-eval (subst a0 'arg0 *adm0*))) Zongker's C-based lil-gp system provides an even simpler way to implement substitution ADMs <ref> (Zongker 1995) </ref>. One can simply use the evaluation function type EVAL EXPR (rather than EVAL DATA, which is used for normal ADFs), and ADM semantics will result.
References-found: 12

