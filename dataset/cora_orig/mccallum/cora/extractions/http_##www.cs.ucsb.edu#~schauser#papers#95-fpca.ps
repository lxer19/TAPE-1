URL: http://www.cs.ucsb.edu/~schauser/papers/95-fpca.ps
Refering-URL: http://www.cs.ucsb.edu/~schauser/papers/
Root-URL: http://www.cs.ucsb.edu
Email: schauser@cs.ucsb.edu  sethg@cs.berkeley.edu  
Title: How Much Non-strictness do Lenient Programs Require?  
Author: Klaus E. Schauser Seth C. Goldstein 
Address: Santa Barbara, CA 93106  Berkeley, CA 94720  
Affiliation: Department of Computer Science University of California, Santa Barbara  Computer Science Division University of California, Berkeley  
Abstract: Lenient languages, such as Id90, have been touted as among the best functional languages for massively parallel machines [AHN88]. Lenient evaluation combines non-strict semantics with eager evaluation [Tra91]. Non-strictness gives these languages more expressive power than strict semantics, while eager evaluation ensures the highest degree of parallelism. Unfortunately, non-strictness incurs a large overhead, as it requires dynamic scheduling and synchronization. As a result, many powerful program analysis techniques have been developed to statically determine when non-strictness is not required [CPJ85, Tra91, Sch94]. This paper studies a large set of lenient programs and quantifies the degree of non-strictness they require. We identify several forms of non-strictness, including functional, conditional, and data structure non-strictness. Surprisingly, most Id90 programs require neither functional nor conditional non-strictness. Many benchmark programs, however, make use of a limited form of data structure non-strictness. The paper refutes the myth that lenient programs require extensive non-strictness. 
Abstract-found: 1
Intro-found: 1
Reference: [AA89] <author> Z. Ariola and Arvind. P-TAC: </author> <title> A parallel intermediate language. </title> <booktitle> In Proceedings of the 1989 Conference on Functional Programming Languages and Computer Architecture, </booktitle> <pages> pages 230-242, </pages> <month> September </month> <year> 1989. </year>
Reference-contexts: This example also shows the duality between conditionals and function calls made through function variables. A conditional can be viewed as a call site, where one of two functions is called depending on the predicate <ref> [AA89] </ref>. These two functions contain the code of the then side and else side of the conditional, respectively. 3.3 Data Structure Non-strictness In non-strict languages, data structure constructors exhibit the same form of non-strictness as function calls, i.e., the result may be required before all the elements are defined.
Reference: [AE88] <author> Arvind and K. Ekanadham. </author> <title> Future Scientific Programming on Parallel Machines. </title> <journal> Journal of Parallel and Distributed Computing, </journal> <volume> 5(5) </volume> <pages> 460-493, </pages> <month> October </month> <year> 1988. </year>
Reference-contexts: The application areas represented by these programs include scientific computing, sorting and search problems, symbolic computing, NAS parallel benchmarks, and small kernels. Most of the programs fall into the catagory of scientific computing, the area specifically targeted by the implicitly parallel language Id90 <ref> [AE88] </ref>. Most of the programs contain many conditionals and function calls and exhibit fine-grained behavior (e.g., Quicksort), while programs such as the blocked matrix multiply are more medium-grained [SGS + 93]. 4.4 Non-strictness Requirements Following the methodology described above we determined the degree of non-strictness each of the programs requires. <p> Mergesort 103 Merge sort (I-structures) [SB93c] Shellsort 90 Shell sort (M-structures) [SB93c] Scientific computation Wavefront 40 Simple wavefront SOR [ANP89] Pseudoknot 3323 Molecular Biology [HFA + 94] Gamteb 649 Monte Carlo neutron transport [BCS + 89] MCNP 2351 Monte Carlo photon transport [HL93] Simple 1105 Hydrodynamics and heat conduc tion <ref> [AE88] </ref> Speech 172 Speech processing [Sah91] DTW 100 Dynamic time warp [Sah91] MM 74 Matrix multiply [HCAA93] MMT44 118 Blocked matrix multiply test [CGSvE93] Eigen3 151 Eigen problem Householder 304 Householder Eigen-Solver [SB93a] Jacobi 215 Jacobi Eigen-Solver [BH93] Jacobi group 162 Jacobi Eigen-Solver (group rota tions) [BH93] FT fu 370 NAS
Reference: [AHN88] <author> Arvind, S. K. Heller, and R. S. Nikhil. </author> <title> Programming Generality and Parallel Computers. </title> <booktitle> In Proc. of the Fourth Int. Symp. on Biological and Artificial Intelligence Systems, </booktitle> <pages> pages 255-286. </pages> <address> ESCOM (Leider), Trento, Italy, </address> <month> September </month> <year> 1988. </year>
Reference-contexts: The three evaluation strategies differ in their expressiveness, parallelism, and efficiency. Many arguments have been made in favor of lenient evaluation, as embodied in the language Id90, 1 as the best choice for massively parallel machines <ref> [AHN88, Nik90] </ref>. Being non-strict, lenient evaluation retains much of the expressive power of lazy evaluation at a much lower overhead, while exhibiting more parallelism than both strict and lazy evaluation [Tra91]. 2.1 The Lenient Language Id90 Id90 is a functional language augmented with synchronizing data structures. <p> For example, the recursive binding a = (cons 1 a) denotes a simple cyclic list, and a = (cons 2 (hd a)) denotes an 2-tuple containing the same element. This power of non-strictness also extends to list comprehensions, array comprehensions, and I- and M-structures <ref> [AHN88, ANP89, BNA91] </ref>. We can define the following hierarchy of non-strictness in data structures. Functionally strict: All elements must be evaluated be fore the data structure is created. <p> For most of the programs we were able to find a schedule that results in no fetches deferring at run-time. This result is contrary to the current thought that lenient programs inherently require dynamic scheduling. Program Lines Short Description and Reference Symbolic computation Paraffins 185 Enumerate isomers of paraffins <ref> [AHN88] </ref> Primes filter 40 Generate primes by filtering [Hel89] Primes sieve 50 Primes using sieve of Eratosthenes [Tre94] Compresspath 89 Recursive doubling algorithm [SPR90] N-Queens 66 N-queens problem (using circular lists) [All93] NQ Solutions 66 Number of N-queens solutions [All93] Permutations 57 Generate permutations of sets of elements (using circular structure)
Reference: [All92] <author> L. Allison. </author> <title> Lazy dynamic-programming can be eager. </title> <journal> Info. Proc. Letters, </journal> <volume> 43(4) </volume> <pages> 207-212, </pages> <year> 1992. </year>
Reference-contexts: Lazy evaluation is required only if the program manipulates infinite lists. His observation is that for most programs lenient evaluation is sufficient. He found that, contrary to what other authors claimed, most of the programs presented in <ref> [Bir84, All92, 8 All93] </ref> do not require laziness. Tremblay also studied how lazy evaluation impacts parallelism (under the TTDA execution model). Much research has been devoted to analysis techniques that determine when the full generality of non-strictness is not required.
Reference: [All93] <author> L. Allison. </author> <title> Application of recursively defined data structures. </title> <journal> Australian Comp. Journal, </journal> <volume> 25(1) </volume> <pages> 14-20, </pages> <year> 1993. </year>
Reference-contexts: Program Lines Short Description and Reference Symbolic computation Paraffins 185 Enumerate isomers of paraffins [AHN88] Primes filter 40 Generate primes by filtering [Hel89] Primes sieve 50 Primes using sieve of Eratosthenes [Tre94] Compresspath 89 Recursive doubling algorithm [SPR90] N-Queens 66 N-queens problem (using circular lists) <ref> [All93] </ref> NQ Solutions 66 Number of N-queens solutions [All93] Permutations 57 Generate permutations of sets of elements (using circular structure) [All93] Id Compiler 38919 Id in Id compiler Id Interpreter 740 Top level Id interpreter Quicksort 55 Quick sort on lists [CSS + 91] Arraysort 75 Selection sort on arrays [CSS <p> Description and Reference Symbolic computation Paraffins 185 Enumerate isomers of paraffins [AHN88] Primes filter 40 Generate primes by filtering [Hel89] Primes sieve 50 Primes using sieve of Eratosthenes [Tre94] Compresspath 89 Recursive doubling algorithm [SPR90] N-Queens 66 N-queens problem (using circular lists) <ref> [All93] </ref> NQ Solutions 66 Number of N-queens solutions [All93] Permutations 57 Generate permutations of sets of elements (using circular structure) [All93] Id Compiler 38919 Id in Id compiler Id Interpreter 740 Top level Id interpreter Quicksort 55 Quick sort on lists [CSS + 91] Arraysort 75 Selection sort on arrays [CSS + 91] Bitonicsort 142 Bitonic sort (M-structures) [SB93c] <p> Primes filter 40 Generate primes by filtering [Hel89] Primes sieve 50 Primes using sieve of Eratosthenes [Tre94] Compresspath 89 Recursive doubling algorithm [SPR90] N-Queens 66 N-queens problem (using circular lists) <ref> [All93] </ref> NQ Solutions 66 Number of N-queens solutions [All93] Permutations 57 Generate permutations of sets of elements (using circular structure) [All93] Id Compiler 38919 Id in Id compiler Id Interpreter 740 Top level Id interpreter Quicksort 55 Quick sort on lists [CSS + 91] Arraysort 75 Selection sort on arrays [CSS + 91] Bitonicsort 142 Bitonic sort (M-structures) [SB93c] Bubblesort 67 Bubble sort (M-structures) [SB93c] Heapsort IS 128 Heap sort (I-structures)
Reference: [ANP87] <author> Arvind, R. S. Nikhil, and K. K. Pingali. I-Structures: </author> <title> Data Structures for Parallel Computing. </title> <type> Technical Report CSG Memo 269, </type> <institution> MIT Lab for Comp. Sci., </institution> <month> February </month> <year> 1987. </year> <title> (Also in Proc. of the Graph Reduction Workshop, </title> <address> Santa Fe, NM. </address> <month> October </month> <year> 1986.). </year>
Reference-contexts: One limitation is that in order to be purely functional, the elements of the array have to be defined completely within the array comprehension. This ensures that referential transparency is preserved. Because this is not sufficient for certain problems <ref> [ANP87] </ref>, Id90 also provides two non-functional data structures, I-structures [ANP89] and M-structures [BNA91].
Reference: [ANP89] <author> Arvind, R. S. Nikhil, and K. K. Pingali. I-Structures: </author> <title> Data Structures for Parallel Computing. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 11(4) </volume> <pages> 598-632, </pages> <month> October </month> <year> 1989. </year>
Reference-contexts: One limitation is that in order to be purely functional, the elements of the array have to be defined completely within the array comprehension. This ensures that referential transparency is preserved. Because this is not sufficient for certain problems [ANP87], Id90 also provides two non-functional data structures, I-structures <ref> [ANP89] </ref> and M-structures [BNA91]. I-structures are write-once data structures which separate the creation of the structure from the definition of its 1 Parallel Haskell (pH), an ongoing development which integrates many concepts of Id90 into Haskell, may also be based on lenient evaluation. elements. <p> For example, the recursive binding a = (cons 1 a) denotes a simple cyclic list, and a = (cons 2 (hd a)) denotes an 2-tuple containing the same element. This power of non-strictness also extends to list comprehensions, array comprehensions, and I- and M-structures <ref> [AHN88, ANP89, BNA91] </ref>. We can define the following hierarchy of non-strictness in data structures. Functionally strict: All elements must be evaluated be fore the data structure is created. <p> Dynamic: A dynamic schedule is required. (This im plies that presence bits are needed, as fetches from elements may defer.) The two small examples above using cons can be classified as circular and recursive, respectively. Other frequently cited examples using recursively defined data structures are wavefront <ref> [ANP89] </ref> and the following function computing an array of the first n Fibonacci numbers. def fib_array n = array (0,n) of | [0] = 1 | [i] = A [i-1]+A [i-2] || i &lt;- 2 to n-; Both examples can be scheduled statically, i.e., a static scheduling of the program can <p> sort (M-structures) [SB93c] Heapsort IS 128 Heap sort (I-structures) [SB93c] Heapsort MS 123 Heap sort (M-structures) [SB93c] Quicksort IS 124 Quick sort (I-structures) [SB93c] Quicksort MS 115 Quick sort (M-structures) [SB93c] Mergesort 103 Merge sort (I-structures) [SB93c] Shellsort 90 Shell sort (M-structures) [SB93c] Scientific computation Wavefront 40 Simple wavefront SOR <ref> [ANP89] </ref> Pseudoknot 3323 Molecular Biology [HFA + 94] Gamteb 649 Monte Carlo neutron transport [BCS + 89] MCNP 2351 Monte Carlo photon transport [HL93] Simple 1105 Hydrodynamics and heat conduc tion [AE88] Speech 172 Speech processing [Sah91] DTW 100 Dynamic time warp [Sah91] MM 74 Matrix multiply [HCAA93] MMT44 118 Blocked
Reference: [BCS + 89] <author> P. J. Burns, M. Christon, R. Schweitzer, O. M. Lubeck, H. J. Wasserman, M. L. Simmons, and D. V. Pryor. </author> <title> Vectorization of Monte-Carlo Particle Transport: An Architectural Study using the LANL Benchmark "Gamteb". </title> <booktitle> In Proc. Supercomputing '89. IEEE Computer Society and ACM SIGARCH, </booktitle> <address> New York, NY, </address> <month> November </month> <year> 1989. </year> <month> 9 </month>
Reference-contexts: sort (M-structures) [SB93c] Quicksort IS 124 Quick sort (I-structures) [SB93c] Quicksort MS 115 Quick sort (M-structures) [SB93c] Mergesort 103 Merge sort (I-structures) [SB93c] Shellsort 90 Shell sort (M-structures) [SB93c] Scientific computation Wavefront 40 Simple wavefront SOR [ANP89] Pseudoknot 3323 Molecular Biology [HFA + 94] Gamteb 649 Monte Carlo neutron transport <ref> [BCS + 89] </ref> MCNP 2351 Monte Carlo photon transport [HL93] Simple 1105 Hydrodynamics and heat conduc tion [AE88] Speech 172 Speech processing [Sah91] DTW 100 Dynamic time warp [Sah91] MM 74 Matrix multiply [HCAA93] MMT44 118 Blocked matrix multiply test [CGSvE93] Eigen3 151 Eigen problem Householder 304 Householder Eigen-Solver [SB93a] Jacobi
Reference: [BH87] <author> A. Bloss and P. Hudak. </author> <title> Path Semantics. </title> <booktitle> In Mathe--matical Foundations of Programming Language Semantics (LNCS 298). </booktitle> <publisher> Springer-Verlag, </publisher> <month> April </month> <year> 1987. </year>
Reference-contexts: Much research has been devoted to analysis techniques that determine when the full generality of non-strictness is not required. These techniques include strictness analysis [Pey87], backwards analysis [Hug88b], path analysis <ref> [BH87] </ref>, and partitioning [Tra91, SCvE91, HDGS91]. For lenient languages the compilation approach is to schedule instructions statically into sequential threads and have dynamic scheduling only between threads. The task of identifying portions of the program that can be scheduled statically and ordered into threads is called partitioning [Tra91]. <p> Tremblay also studied how lazy evaluation impacts parallelism (under the TTDA execution model). Much research has been devoted to analysis techniques that determine when the full generality of non-strictness is not required. These techniques include strictness analysis [Pey87], backwards analysis [Hug88b], and path analysis <ref> [BH87] </ref>. For lenient languages this is approached by partitioning a program into sequential threads [Tra91]. Partitioning algorithms have been developed by [Tra91, SCvE91, HDGS91, SCG95].
Reference: [BH93] <author> W. Bohm and R. E. Hiromoto. </author> <title> A Functional Implementation of the Jacobi Eigen-Solver. </title> <type> Tech. Report CS-93-106, </type> <institution> Colorado State University, </institution> <month> May </month> <year> 1993. </year>
Reference-contexts: 2351 Monte Carlo photon transport [HL93] Simple 1105 Hydrodynamics and heat conduc tion [AE88] Speech 172 Speech processing [Sah91] DTW 100 Dynamic time warp [Sah91] MM 74 Matrix multiply [HCAA93] MMT44 118 Blocked matrix multiply test [CGSvE93] Eigen3 151 Eigen problem Householder 304 Householder Eigen-Solver [SB93a] Jacobi 215 Jacobi Eigen-Solver <ref> [BH93] </ref> Jacobi group 162 Jacobi Eigen-Solver (group rota tions) [BH93] FT fu 370 NAS benchmark FT (functional) [SB93b] FT is 333 NAS benchmark FT (I-structures) [SB93b] FT ms 356 NAS benchmark FT (M-structures) [SB93b] Small examples KT-cond 5 Traub's non-strict conditional [Tra91] Two 5 Non-strict function with two results [SCG95] Cube <p> and heat conduc tion [AE88] Speech 172 Speech processing [Sah91] DTW 100 Dynamic time warp [Sah91] MM 74 Matrix multiply [HCAA93] MMT44 118 Blocked matrix multiply test [CGSvE93] Eigen3 151 Eigen problem Householder 304 Householder Eigen-Solver [SB93a] Jacobi 215 Jacobi Eigen-Solver <ref> [BH93] </ref> Jacobi group 162 Jacobi Eigen-Solver (group rota tions) [BH93] FT fu 370 NAS benchmark FT (functional) [SB93b] FT is 333 NAS benchmark FT (I-structures) [SB93b] FT ms 356 NAS benchmark FT (M-structures) [SB93b] Small examples KT-cond 5 Traub's non-strict conditional [Tra91] Two 5 Non-strict function with two results [SCG95] Cube 6 Non-strict cube function [SCvE91] Flat 17 Flatten leaves
Reference: [Bir84] <author> R. S. Bird. </author> <title> Using Circular Programs to Eliminate Multiple Traversals of Data. </title> <journal> Acta Informatica, </journal> <volume> 21(4) </volume> <pages> 239-250, </pages> <year> 1984. </year>
Reference-contexts: In Section 3 we present several of such examples. Under the purely functional setting, non-strictness results in more efficient programs|in both space and time requirements <ref> [Hug88a, Bir84, Joh87] </ref>. In addition, lazy evaluation provides the control structure to handle infinite data structures, as long as only a finite part is accessed. <p> Lazy evaluation is required only if the program manipulates infinite lists. His observation is that for most programs lenient evaluation is sufficient. He found that, contrary to what other authors claimed, most of the programs presented in <ref> [Bir84, All92, 8 All93] </ref> do not require laziness. Tremblay also studied how lazy evaluation impacts parallelism (under the TTDA execution model). Much research has been devoted to analysis techniques that determine when the full generality of non-strictness is not required.
Reference: [BNA91] <author> P. S. Barth, R. S. Nikhil, and Arvind. </author> <title> M-Structures; Extending a Parallel, Non-strict, Functional Language with State. </title> <booktitle> In Proceedings of the 1991 Conference on Functional Programming Languages and Computer Architecture, </booktitle> <address> Cambridge, MA, </address> <month> August </month> <year> 1991. </year>
Reference-contexts: This ensures that referential transparency is preserved. Because this is not sufficient for certain problems [ANP87], Id90 also provides two non-functional data structures, I-structures [ANP89] and M-structures <ref> [BNA91] </ref>. I-structures are write-once data structures which separate the creation of the structure from the definition of its 1 Parallel Haskell (pH), an ongoing development which integrates many concepts of Id90 into Haskell, may also be based on lenient evaluation. elements. <p> For example, the recursive binding a = (cons 1 a) denotes a simple cyclic list, and a = (cons 2 (hd a)) denotes an 2-tuple containing the same element. This power of non-strictness also extends to list comprehensions, array comprehensions, and I- and M-structures <ref> [AHN88, ANP89, BNA91] </ref>. We can define the following hierarchy of non-strictness in data structures. Functionally strict: All elements must be evaluated be fore the data structure is created.
Reference: [CGSvE93] <author> D. E. Culler, S. C. Goldstein, K. E. Schauser, and T. von Eicken. </author> <title> TAM | A Compiler Controlled Threaded Abstract Machine. </title> <journal> Journal of Parallel and Distributed Computing, </journal> <volume> 18 </volume> <pages> 347-370, </pages> <month> July </month> <year> 1993. </year>
Reference-contexts: The compiler uses a front-end developed at MIT [Tra86] which produces dataflow graphs. The back-end partitions these dataflow graphs into threads and then generates code for TAM, a Threaded Abstract Machine <ref> [CGSvE93] </ref>. The TAM code is then translated to the target machine. Our translation path uses C as a portable "intermediate form" and produces code for the CM-5 as well as for various standard sequential machines [Gol94]. <p> Biology [HFA + 94] Gamteb 649 Monte Carlo neutron transport [BCS + 89] MCNP 2351 Monte Carlo photon transport [HL93] Simple 1105 Hydrodynamics and heat conduc tion [AE88] Speech 172 Speech processing [Sah91] DTW 100 Dynamic time warp [Sah91] MM 74 Matrix multiply [HCAA93] MMT44 118 Blocked matrix multiply test <ref> [CGSvE93] </ref> Eigen3 151 Eigen problem Householder 304 Householder Eigen-Solver [SB93a] Jacobi 215 Jacobi Eigen-Solver [BH93] Jacobi group 162 Jacobi Eigen-Solver (group rota tions) [BH93] FT fu 370 NAS benchmark FT (functional) [SB93b] FT is 333 NAS benchmark FT (I-structures) [SB93b] FT ms 356 NAS benchmark FT (M-structures) [SB93b] Small examples KT-cond
Reference: [CPJ85] <author> C. Clack and S. L. Peyton-Jones. </author> <title> Strictness Analysis </title>
References-found: 14

