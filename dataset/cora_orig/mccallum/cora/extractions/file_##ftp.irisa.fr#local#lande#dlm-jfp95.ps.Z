URL: file://ftp.irisa.fr/local/lande/dlm-jfp95.ps.Z
Refering-URL: http://www.irisa.fr/lande/LeMetayer.html
Root-URL: http://www.aic.nrl.navy.mil/~aha/people.html
Title: Proving the Correctness of Compiler Optimisations Based on a Global Analysis: A Study of Strictness Analysis  
Author: Geoffrey Burn Daniel Le Metayer Irisa/Inria, 
Address: London SW7 2BZ, United Kingdom  35042 Rennes Cedex, France  
Affiliation: Department of Computing, Imperial College of Science, Technology and Medicine, 180 Queen's Gate,  Campus de Beaulieu,  
Abstract: A substantial amount of work has been devoted to the proof of correctness of various program analyses but much less attention has been paid to the correctness of compiler optimisations based on these analyses. In this paper we tackle the problem in the context of strictness analysis for lazy functional languages. We show that compiler optimisations based on strictness analysis can be expressed formally in the functional framework using continuations. This formal presentation has two benefits: it allows us to give a rigorous correctness proof of the optimised compiler; and it exposes the various optimisations made possible by a strictness analysis.
Abstract-found: 1
Intro-found: 1
Reference: [App92] <author> A. W. Appel. </author> <title> Compiling with Continuations. </title> <publisher> Cambridge University Press, </publisher> <year> 1992. </year>
Reference-contexts: Steele was the first to show that it was beneficial to do this for Scheme programs in his seminal work on the Rabbit compiler [Ste78]. Some of the most efficient implementations of Scheme [KKR*86, Kra88] and ML <ref> [App92] </ref> use cps-translation. <p> by -conversion into: N 0 [[x:E]] = c:c (x:N 0 [[E]]) The rule for application becomes: N 0 [[E 1 E 2 ]] = c:N 0 [[E 1 ]] (f:f (N 0 [[E 2 ]]) c) Passing the continuation as the second argument is quite common in the literature, see <ref> [App92, DH93, Rey74, Plo75] </ref> for instance, but the continuation in first position also occurs in [Fis72, Fis93, CFF93, SF93]. The above simplification rule for lambda abstraction suggests that passing the continuation as the second argument sometimes leads to a more compact representation.
Reference: [Ben92] <author> P.N. Benton. </author> <title> Strictness logic and polymorphic invariance. </title> <editor> In A. Nerode and M. Taitslin, editors, </editor> <booktitle> Proceedings of the International Symposium on Logical Foundations of Computer Science, </booktitle> <pages> pages 33-44, </pages> <publisher> Springer-Verlag LNCS620, Tver, </publisher> <address> Russia, </address> <month> 20-24 July </month> <year> 1992. </year>
Reference-contexts: Although the test given in the rule is not effective, many analyses have been developed which can find a subset of the cases when it holds (see <ref> [Ben92, BHA86, Jen92a, KM89, Myc81, Nie88] </ref> for example). * when the functional expression is not strict (second rule), the translation has the same structure as the call-by-name cps conversion, but uses the S conversion scheme so that strictness information can be used in translating subex pressions. <p> ;. ffi 4 Related Work As mentioned in the introduction a number of papers have been devoted to step (1): proving the correctness of the original compiler [Sch80, Wan82, NN88, Dyb85, Mor73, Mos80, TWW81, Les87, Les88, CCM87, FM91]; and step (2): proving the correctness of the result of the analysis <ref> [CC79, CC92b, CC92a, Bur91b, Nie89, WH87, LM91, Jen92a, Ben92] </ref>. Some of the work devoted to the proof of step (1) include a number of local optimi-sations (such as peephole optimisations), but very few consider optimisations relying on a global analysis.
Reference: [BHA86] <author> G.L. Burn, C.L. Hankin, and S. Abramsky. </author> <title> Strictness analysis of higher-order functions. </title> <booktitle> Science of Computer Programming, </booktitle> <volume> 7 </volume> <pages> 249-278, </pages> <month> November </month> <year> 1986. </year> <month> 19 </month>
Reference-contexts: Although the test given in the rule is not effective, many analyses have been developed which can find a subset of the cases when it holds (see <ref> [Ben92, BHA86, Jen92a, KM89, Myc81, Nie88] </ref> for example). * when the functional expression is not strict (second rule), the translation has the same structure as the call-by-name cps conversion, but uses the S conversion scheme so that strictness information can be used in translating subex pressions. <p> However, many program analyses have been presented in the literature which can determine safe approximations to the information (see <ref> [Myc81, BHA86, WH87, Wad87, Hun91, Jen92a, LM91] </ref> for example). The second translation rule for application is used when there is to be no change of evaluation order.
Reference: [Bur90] <author> G.L. Burn. </author> <title> Using projection analysis in compiling lazy functional programs. </title> <booktitle> In Proceedings of the 1990 ACM Conference on Lisp and Functional Programming, </booktitle> <pages> pages 227-241, </pages> <address> Nice, France, </address> <month> 27-29 June </month> <year> 1990. </year>
Reference-contexts: Projection-based analyses can also give information of the form: "this argument cannot be evaluated yet, but if it is ever evaluated, then do so much evaluation of it" <ref> [Bur90] </ref>. Again we should be able to modify the rule for application to accommodate this.
Reference: [Bur91a] <author> G.L. Burn. </author> <title> The evaluation transformer model of reduction and its correctness. </title> <editor> In S. Abramsky and T.S.E. Maibaum, editors, </editor> <booktitle> Proceedings of TAPSOFT'91, </booktitle> <volume> Volume 2, </volume> <pages> pages 458-482, </pages> <publisher> Springer-Verlag LNCS 494, </publisher> <address> Brighton, UK, </address> <month> 8-12 April </month> <year> 1991. </year>
Reference-contexts: Scott-closed sets capture denotationally the two properties that we require of an eval uation context <ref> [Bur91a] </ref>. <p> j [[fix (x:E)]] where W = V S 2. if X S and X is directed, then F We only consider non-empty Scott-closed sets in this paper. ffi The key idea behind the transformation rules defined in Figure 6 is the following fact, sometimes known as the Evaluation Transformer Theorem <ref> [Bur91a, Theorem 7.5] </ref>. Fact 3.2 Let S and T be Scott-closed sets. <p> This corresponds to passing the evaluation context to a tail-call. In order to illustrate the transformation T , let us consider two common evaluation contexts BOT and INF <ref> [Bur91a, Wad87] </ref>. BOT contains only ? and IN F is the Scott-closed set containing all infinite lists and lists ending with a ?.
Reference: [Bur91b] <author> G.L. Burn. </author> <title> Lazy Functional Languages: Abstract Interpretation and Compilation. </title> <booktitle> Research Monographs in Parallel and Distributed Computing, </booktitle> <publisher> Pitman in association with MIT Press, </publisher> <year> 1991. </year> <month> 238pp. </month>
Reference-contexts: We call the amount of evaluation required of an expression the evaluation context of the expression. A number of useful evaluation contexts such as head-strictness or tail-strictness have been defined in the literature and several analyses have been proposed to derive context information automatically (see <ref> [Bur91b, Jen92b, LM91, NN92, WH87, Wad87] </ref> for example). However the various ways of exploiting this context information within a compiler have never been described formally and little work has been done on assessing their effectiveness. We show in this section how these optimisations can be described formally in our framework. <p> ;. ffi 4 Related Work As mentioned in the introduction a number of papers have been devoted to step (1): proving the correctness of the original compiler [Sch80, Wan82, NN88, Dyb85, Mor73, Mos80, TWW81, Les87, Les88, CCM87, FM91]; and step (2): proving the correctness of the result of the analysis <ref> [CC79, CC92b, CC92a, Bur91b, Nie89, WH87, LM91, Jen92a, Ben92] </ref>. Some of the work devoted to the proof of step (1) include a number of local optimi-sations (such as peephole optimisations), but very few consider optimisations relying on a global analysis. <p> Also the fact that the second phase is a call-by-value CPS transformation entails that evaluated values are systematically passed unboxed. As in [Les88], only simple strictness information is considered. 18 A less thoroughgoing attempt at this problem is also presented in <ref> [Bur91b] </ref>, which shows that the operational model underlying the transformation given in Figure 6 is correct. <p> This can be seen most clearly where the test for changing the evaluation order is given, where the function is applied to i arbitrary arguments, rather than any arguments it was already applied to (c.f. the concept of `context-sensitive' evaluation transformers in <ref> [Bur91b, Section 5.3] </ref>). Projection-based analyses can also give information of the form: "this argument cannot be evaluated yet, but if it is ever evaluated, then do so much evaluation of it" [Bur90]. Again we should be able to modify the rule for application to accommodate this.
Reference: [CC79] <author> P. Cousot and R. Cousot. </author> <title> Systematic design of program analysis frameworks. </title> <booktitle> In Proceedings of the Sixth Annual Symposium on Principles of Programming Languages, </booktitle> <pages> pages 269-282, </pages> <publisher> ACM, </publisher> <month> January </month> <year> 1979. </year>
Reference-contexts: ;. ffi 4 Related Work As mentioned in the introduction a number of papers have been devoted to step (1): proving the correctness of the original compiler [Sch80, Wan82, NN88, Dyb85, Mor73, Mos80, TWW81, Les87, Les88, CCM87, FM91]; and step (2): proving the correctness of the result of the analysis <ref> [CC79, CC92b, CC92a, Bur91b, Nie89, WH87, LM91, Jen92a, Ben92] </ref>. Some of the work devoted to the proof of step (1) include a number of local optimi-sations (such as peephole optimisations), but very few consider optimisations relying on a global analysis.
Reference: [CC92a] <author> P. Cousot and R. Cousot. </author> <title> Abstract interpretation and application to logic programs. </title> <journal> Journal of Logic Programming, </journal> <volume> 13(2-3):103-179, </volume> <year> 1992. </year>
Reference-contexts: ;. ffi 4 Related Work As mentioned in the introduction a number of papers have been devoted to step (1): proving the correctness of the original compiler [Sch80, Wan82, NN88, Dyb85, Mor73, Mos80, TWW81, Les87, Les88, CCM87, FM91]; and step (2): proving the correctness of the result of the analysis <ref> [CC79, CC92b, CC92a, Bur91b, Nie89, WH87, LM91, Jen92a, Ben92] </ref>. Some of the work devoted to the proof of step (1) include a number of local optimi-sations (such as peephole optimisations), but very few consider optimisations relying on a global analysis.
Reference: [CC92b] <author> P. Cousot and R. Cousot. </author> <title> Abstract interpretation frameworks. </title> <journal> Journal of Logic and Computation, </journal> <volume> 2(4), </volume> <year> 1992. </year> <note> Special Issue on Abstract Interpretation. </note>
Reference-contexts: ;. ffi 4 Related Work As mentioned in the introduction a number of papers have been devoted to step (1): proving the correctness of the original compiler [Sch80, Wan82, NN88, Dyb85, Mor73, Mos80, TWW81, Les87, Les88, CCM87, FM91]; and step (2): proving the correctness of the result of the analysis <ref> [CC79, CC92b, CC92a, Bur91b, Nie89, WH87, LM91, Jen92a, Ben92] </ref>. Some of the work devoted to the proof of step (1) include a number of local optimi-sations (such as peephole optimisations), but very few consider optimisations relying on a global analysis.
Reference: [CCM87] <author> G. Cousineau, P.-L. Curien, and M. Mauny. </author> <title> The categorical abstract machine. </title> <booktitle> Science of Computer Programming, </booktitle> <volume> 8 </volume> <pages> 173-202, </pages> <year> 1987. </year>
Reference-contexts: For all closed terms of ground type E : , S [[T ; 0 f? S g [[E]]]] ; = S [[N [[E]]]] ;. ffi 4 Related Work As mentioned in the introduction a number of papers have been devoted to step (1): proving the correctness of the original compiler <ref> [Sch80, Wan82, NN88, Dyb85, Mor73, Mos80, TWW81, Les87, Les88, CCM87, FM91] </ref>; and step (2): proving the correctness of the result of the analysis [CC79, CC92b, CC92a, Bur91b, Nie89, WH87, LM91, Jen92a, Ben92].
Reference: [CFF93] <author> B. F. Duba C. Flanagan, A. Sabry and M. Felleisen. </author> <title> The essence of compiling with continuations. </title> <booktitle> In ACM Sigplan '93 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 237-247, </pages> <booktitle> ACM Sigplan Notices 28(6), </booktitle> <address> Albuquerque, </address> <month> June </month> <year> 1993. </year>
Reference-contexts: becomes: N 0 [[E 1 E 2 ]] = c:N 0 [[E 1 ]] (f:f (N 0 [[E 2 ]]) c) Passing the continuation as the second argument is quite common in the literature, see [App92, DH93, Rey74, Plo75] for instance, but the continuation in first position also occurs in <ref> [Fis72, Fis93, CFF93, SF93] </ref>. The above simplification rule for lambda abstraction suggests that passing the continuation as the second argument sometimes leads to a more compact representation.
Reference: [DF91] <author> O. Danvy and A. Filinski. </author> <title> Representing Control: a Study of the Cps Transformation. </title> <type> Technical Report TR CIS-91-2, </type> <institution> Kansas State University, </institution> <year> 1991. </year>
Reference-contexts: The interested reader can find in <ref> [DF91] </ref> and [SF92] techniques for the systematic elimination of administrative redexes. 6 S [[x]] = x S [[if E 1 E 2 E 3 ]] = c:S [[E 1 ]] (if c (S [[E 2 ]] c) (S [[E 3 ]] c)) if 8 : drop (S [[E 1 ]] )
Reference: [DH93] <author> O. Danvy and J. Hatcliff. </author> <title> CPS transformation after strictness analysis. </title> <journal> ACM Letters on Programming Languages and Systems, </journal> <volume> 1(3) </volume> <pages> 195-212, </pages> <year> 1993. </year>
Reference-contexts: by -conversion into: N 0 [[x:E]] = c:c (x:N 0 [[E]]) The rule for application becomes: N 0 [[E 1 E 2 ]] = c:N 0 [[E 1 ]] (f:f (N 0 [[E 2 ]]) c) Passing the continuation as the second argument is quite common in the literature, see <ref> [App92, DH93, Rey74, Plo75] </ref> for instance, but the continuation in first position also occurs in [Fis72, Fis93, CFF93, SF93]. The above simplification rule for lambda abstraction suggests that passing the continuation as the second argument sometimes leads to a more compact representation. <p> Also their methods deal with local transformations where strictness-based optimisations involve global modifications of the program. The works that are closest in spirit to this paper are [Les88] and <ref> [DH93] </ref>. The first states a correctness property of an optimisation based on strictness analysis in the context of combinator graph reduction on a version of the G-machine.
Reference: [Dyb85] <author> P. Dybjer. </author> <title> Using domain algebras to prove the correctness of a compiler. </title> <booktitle> In Proceedings of STACS85, </booktitle> <pages> pages 98-108, </pages> <publisher> Springer-Verlag LNCS182, </publisher> <year> 1985. </year>
Reference-contexts: For all closed terms of ground type E : , S [[T ; 0 f? S g [[E]]]] ; = S [[N [[E]]]] ;. ffi 4 Related Work As mentioned in the introduction a number of papers have been devoted to step (1): proving the correctness of the original compiler <ref> [Sch80, Wan82, NN88, Dyb85, Mor73, Mos80, TWW81, Les87, Les88, CCM87, FM91] </ref>; and step (2): proving the correctness of the result of the analysis [CC79, CC92b, CC92a, Bur91b, Nie89, WH87, LM91, Jen92a, Ben92].
Reference: [FB93] <author> S.O. Finne and G.L. Burn. </author> <title> Assessing the evaluation transformer model of reduction on the spineless g-machine. </title> <booktitle> In Proceedings of the Conference on Functional Programming and Computer Architecture, </booktitle> <pages> pages 331-340, </pages> <publisher> ACM, </publisher> <address> Copenhagen, </address> <month> 9-11 June </month> <year> 1993. </year>
Reference-contexts: (Scott-closed set) A set S is Scott-closed of a domain D if 1. it is down-closed, that is, if 8d 2 D such that 9s 2 S such that d v s, then d 2 S; and 1 Results from some initial experiments investigating this question can be found in <ref> [FB93] </ref>. 14 T V i Q j [[x]] = x if x 62 V T V i Q j [[k ]] = N [[k ]] if k 6= if = c:T V 0 f? S bool g [[E 1 ]] (if c (T V i Q j [[E 2 ]] c)
Reference: [Fis72] <author> M. J. Fischer. </author> <title> Lambda calculus schemata. </title> <booktitle> In ACM Conference on Proving Assertions about Programs, </booktitle> <pages> pages 104-109, </pages> <booktitle> ACM Sigplan Notices 7(1), </booktitle> <address> New Mexico, </address> <month> January </month> <year> 1972. </year>
Reference-contexts: becomes: N 0 [[E 1 E 2 ]] = c:N 0 [[E 1 ]] (f:f (N 0 [[E 2 ]]) c) Passing the continuation as the second argument is quite common in the literature, see [App92, DH93, Rey74, Plo75] for instance, but the continuation in first position also occurs in <ref> [Fis72, Fis93, CFF93, SF93] </ref>. The above simplification rule for lambda abstraction suggests that passing the continuation as the second argument sometimes leads to a more compact representation.
Reference: [Fis93] <author> M. J. Fischer. </author> <title> Lambda calculus schemata. </title> <journal> Lisp and Symbolic Computation (Special issue on continuations), </journal> 6(3/4):259-287, 1993. <volume> 20 </volume>
Reference-contexts: becomes: N 0 [[E 1 E 2 ]] = c:N 0 [[E 1 ]] (f:f (N 0 [[E 2 ]]) c) Passing the continuation as the second argument is quite common in the literature, see [App92, DH93, Rey74, Plo75] for instance, but the continuation in first position also occurs in <ref> [Fis72, Fis93, CFF93, SF93] </ref>. The above simplification rule for lambda abstraction suggests that passing the continuation as the second argument sometimes leads to a more compact representation. <p> Having the continuation in first position allows us to produce machine code without leaving the purely functional framework. The head function becomes the next instruction to execute and the (contiguous) continuation is the rest of the code. The interested reader is refered to <ref> [Fis93] </ref> and [JH94] for further discussions on this choice. We have left the types off the translated terms for clarity. Ans is the type of answers. The result of translating an expression of type is an expression of type B [[]] = C [[]] ! Ans.
Reference: [FM91] <author> P. Fradet and D Le Metayer. </author> <title> Compilation of functional languages by program transformation. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 13(1) </volume> <pages> 21-51, </pages> <month> January </month> <year> 1991. </year>
Reference-contexts: The main results of this paper are three cps-conversions, which use strictness information to generate better code, and are proven to preserve the semantics of programs. Any of these can then replace the cps-translation phase in the compiler described in <ref> [FM91] </ref>, so that we can demonstrate an optimising compiler which has been proved correct. We start by showing how simple strictness information can be used to change evaluation order (Section 2.1). <p> The alternative cps-translations we have given in this paper could be used in such a compiler to produce better code. For example, they can be used in the context of <ref> [FM91] </ref> to produce a correct optimising compiler. 2 Using Simple Strictness Information Figures 1 and 2 describe the syntax of our functional language and its semantics. Note that we use lifted function domains. <p> The functions lif t and drop are used to map values from a domain to its lifted counterpart (and vice versa). Our starting point is an adaptation of the compiler described in <ref> [FM91] </ref>. The key feature of this compiler is the fact that it is described entirely within the functional framework as a succession of transformations. <p> The important point about N [[E]] is that it has at most one redex outside the scope of a lambda, which means that call-by-value and call-by-name coincide for the translated term [Plo75]. Furthermore, this redex is always at the head of the expression <ref> [FM91] </ref>, and the expression can be reduced without dynamic search for the next redex, just like machine code. We should mention at this stage another possibility for passing the continuation as an extra argument to a lambda abstraction. <p> In any case, the impact of this choice is not significant for the results presented here. Our choice was motivated by the fact that the work described in this paper is part of a broader project for the design of a complete compiler described as a succession of transformations <ref> [FM91, GM90] </ref>. Having the continuation in first position allows us to produce machine code without leaving the purely functional framework. The head function becomes the next instruction to execute and the (contiguous) continuation is the rest of the code. <p> (c:plus c (F 2 c) 2 7) k !! plus c (F 2 k) 2 7 !! F 2 k 9 !! plus c k 9 1 !! k 10 In fact, for this particular expression E, S 0 [[E]] is what is produced by the compilation rules for call-by-value <ref> [FM91] </ref>. It is also important to note that the types of the transformed terms give us significant information. <p> For all closed terms of ground type E : , S [[T ; 0 f? S g [[E]]]] ; = S [[N [[E]]]] ;. ffi 4 Related Work As mentioned in the introduction a number of papers have been devoted to step (1): proving the correctness of the original compiler <ref> [Sch80, Wan82, NN88, Dyb85, Mor73, Mos80, TWW81, Les87, Les88, CCM87, FM91] </ref>; and step (2): proving the correctness of the result of the analysis [CC79, CC92b, CC92a, Bur91b, Nie89, WH87, LM91, Jen92a, Ben92].
Reference: [Fra88] <author> P. Fradet. </author> <title> Compilation des Langages fonctionnels par transformation de pro-grammes. </title> <type> PhD thesis, </type> <institution> Universite de Rennes I, </institution> <year> 1988. </year>
Reference: [Ger75] <author> S.L. Gerhart. </author> <title> Correctness-preserving program transformations. </title> <booktitle> In Proceedings of POPL75, </booktitle> <pages> pages 54-66, </pages> <publisher> ACM, </publisher> <year> 1975. </year>
Reference-contexts: The latter are more difficult to validate because they involve context-dependent transformations. The only papers addressing this issue, to our knowledge, are [Nie85] and <ref> [Ger75] </ref>. The second paper is concerned with partial correctness and relies on program annotations and theorem-proving methods. The first paper considers a simple imperative language and a collecting semantics associating with each program point the set of states which are possible when control reaches that point.
Reference: [GM90] <author> J.F. Giorgi and D. Le Metayer. </author> <booktitle> Continuation-based parallel implementation of functional programming languages. In Proceedings of the 1990 ACM Conference on Lisp and Functional Programming, </booktitle> <pages> pages 227-241, </pages> <address> Nice, France, </address> <month> 27-29 June </month> <year> 1990. </year>
Reference-contexts: In any case, the impact of this choice is not significant for the results presented here. Our choice was motivated by the fact that the work described in this paper is part of a broader project for the design of a complete compiler described as a succession of transformations <ref> [FM91, GM90] </ref>. Having the continuation in first position allows us to produce machine code without leaving the purely functional framework. The head function becomes the next instruction to execute and the (contiguous) continuation is the rest of the code.
Reference: [Gun92] <author> C.A. Gunter. </author> <title> Semantics of Programming Languages: Structures and Techniques. </title> <booktitle> Foundations of Computing, </booktitle> <publisher> MIT Press, </publisher> <year> 1992. </year>
Reference-contexts: Note that we use lifted function domains. This is consistent with most implementations of lazy functional languages which evaluate expressions as far as Weak Head Normal Form (WHNF) (no evaluation inside lambda abstractions) <ref> [Gun92, Chapter 4] </ref>. The functions lif t and drop are used to map values from a domain to its lifted counterpart (and vice versa). Our starting point is an adaptation of the compiler described in [FM91].
Reference: [Hun91] <author> L.S. Hunt. </author> <title> Abstract Interpretation of Functional Languages: From Theory to Practice. </title> <type> PhD thesis, </type> <institution> Department of Computing, Imperial College of Science, Technology and Medicine, University of London, </institution> <year> 1991. </year>
Reference-contexts: However, many program analyses have been presented in the literature which can determine safe approximations to the information (see <ref> [Myc81, BHA86, WH87, Wad87, Hun91, Jen92a, LM91] </ref> for example). The second translation rule for application is used when there is to be no change of evaluation order.
Reference: [Jen92a] <author> T. P. Jensen. </author> <title> Abstract Interpretation in Logical Form. </title> <type> PhD thesis, </type> <institution> Imperial College, University of London, </institution> <month> November </month> <year> 1992. </year>
Reference-contexts: Although the test given in the rule is not effective, many analyses have been developed which can find a subset of the cases when it holds (see <ref> [Ben92, BHA86, Jen92a, KM89, Myc81, Nie88] </ref> for example). * when the functional expression is not strict (second rule), the translation has the same structure as the call-by-name cps conversion, but uses the S conversion scheme so that strictness information can be used in translating subex pressions. <p> However, many program analyses have been presented in the literature which can determine safe approximations to the information (see <ref> [Myc81, BHA86, WH87, Wad87, Hun91, Jen92a, LM91] </ref> for example). The second translation rule for application is used when there is to be no change of evaluation order. <p> ;. ffi 4 Related Work As mentioned in the introduction a number of papers have been devoted to step (1): proving the correctness of the original compiler [Sch80, Wan82, NN88, Dyb85, Mor73, Mos80, TWW81, Les87, Les88, CCM87, FM91]; and step (2): proving the correctness of the result of the analysis <ref> [CC79, CC92b, CC92a, Bur91b, Nie89, WH87, LM91, Jen92a, Ben92] </ref>. Some of the work devoted to the proof of step (1) include a number of local optimi-sations (such as peephole optimisations), but very few consider optimisations relying on a global analysis.
Reference: [Jen92b] <author> T.P. Jensen. </author> <title> Disjunctive strictness analysis. </title> <booktitle> In Proceedings of the 7th Symposium on Logic In Computer Science, </booktitle> <pages> pages 174-185, </pages> <publisher> Computer Society Press of the IEEE, </publisher> <address> Santa Cruz, California, </address> <month> 22-25 June </month> <year> 1992. </year>
Reference-contexts: We call the amount of evaluation required of an expression the evaluation context of the expression. A number of useful evaluation contexts such as head-strictness or tail-strictness have been defined in the literature and several analyses have been proposed to derive context information automatically (see <ref> [Bur91b, Jen92b, LM91, NN92, WH87, Wad87] </ref> for example). However the various ways of exploiting this context information within a compiler have never been described formally and little work has been done on assessing their effectiveness. We show in this section how these optimisations can be described formally in our framework.
Reference: [JH94] <author> O. Danvy J. Hatcliff. </author> <title> A generic account of continuation-passing styles. </title> <booktitle> In Proceedings of the 21st ACM Sigplan-Sigact Symposium on Principles Of Programming Languages, ACM, </booktitle> <year> 1994. </year>
Reference-contexts: (x:E)]] = fix B [[]] (x:N [[E]]) Translation of Terms plus c c m n = c (plus m n) if c E 1 E 2 = v:if v E 1 E 2 cons c c E 1 E 2 = c (cons E 1 E 2 ) shown in <ref> [JH94, SF93] </ref>. In any case, the impact of this choice is not significant for the results presented here. <p> Having the continuation in first position allows us to produce machine code without leaving the purely functional framework. The head function becomes the next instruction to execute and the (contiguous) continuation is the rest of the code. The interested reader is refered to [Fis93] and <ref> [JH94] </ref> for further discussions on this choice. We have left the types off the translated terms for clarity. Ans is the type of answers. The result of translating an expression of type is an expression of type B [[]] = C [[]] ! Ans.
Reference: [JL91] <author> S.L. Peyton Jones and J. Launchbury. </author> <title> Unboxed values as first class citizens in a non-strict functional language. </title> <editor> In J. Hughes, editor, </editor> <booktitle> Proceedings of the Conference on Functional Programming and Computer Architecture, </booktitle> <pages> pages 636-666, </pages> <publisher> Springer-Verlag LNCS523, </publisher> <address> Cambridge, Massachussets, USA, </address> <month> 26-28 August </month> <year> 1991. </year>
Reference-contexts: This appears to be a natural alternative to that given in <ref> [JL91] </ref> for expressing the boxed/unboxed distinction. In the translation rules, we state what properties must hold in order to use particular rules. Safe approximations to these properties can be determined using established program analyses. <p> This distinction has been called boxed versus unboxed representation in <ref> [JL91] </ref>. In our framework B [[]] denotes a boxed implementation of and U [[]] is an unboxed representation of , so that the `boxedness' of a value can be determined from its type.
Reference: [KKR*86] <author> D.A. Kranz, R. Kelsey, J.A. Rees, P. Hudak, J. Philbin, and N.I. Adams. </author> <title> Orbit: an optimising compiler for scheme. </title> <booktitle> In Proceedings of the SIGPLAN '86 Symposium on Compiler Construction, </booktitle> <pages> pages 219-233, </pages> <publisher> ACM, </publisher> <month> June </month> <year> 1986. </year>
Reference-contexts: Steele was the first to show that it was beneficial to do this for Scheme programs in his seminal work on the Rabbit compiler [Ste78]. Some of the most efficient implementations of Scheme <ref> [KKR*86, Kra88] </ref> and ML [App92] use cps-translation.
Reference: [KM89] <author> Tsung-Min Kuo and P. Mishra. </author> <title> Strictness analysis: a new perspective based on type inference. </title> <booktitle> In Proceedings of the Conference on Functional Programming Languages and Computer Architecture, </booktitle> <pages> pages 260-272, </pages> <publisher> ACM, </publisher> <address> London, </address> <month> 11-13 September </month> <year> 1989. </year>
Reference-contexts: Although the test given in the rule is not effective, many analyses have been developed which can find a subset of the cases when it holds (see <ref> [Ben92, BHA86, Jen92a, KM89, Myc81, Nie88] </ref> for example). * when the functional expression is not strict (second rule), the translation has the same structure as the call-by-name cps conversion, but uses the S conversion scheme so that strictness information can be used in translating subex pressions.
Reference: [Kra88] <author> D.A. Kranz. </author> <title> Orbit: An Optimising Compiler for Scheme. </title> <type> PhD thesis, </type> <institution> Department of Computer Science, Yale University, </institution> <month> February </month> <year> 1988. </year> <title> Report Number YALEU/DCS/RR-632. </title> <type> 21 </type>
Reference-contexts: Steele was the first to show that it was beneficial to do this for Scheme programs in his seminal work on the Rabbit compiler [Ste78]. Some of the most efficient implementations of Scheme <ref> [KKR*86, Kra88] </ref> and ML [App92] use cps-translation.
Reference: [Les87] <author> D. Lester. </author> <title> The G-machine as a representation of stack semantics. </title> <editor> In G. Kahn, editor, </editor> <booktitle> Proceedings of the Functional Programming Languages and Computer Architecture Conference, </booktitle> <pages> pages 46-59, </pages> <publisher> Springer-Verlag LNCS 274, </publisher> <month> September </month> <year> 1987. </year>
Reference-contexts: For all closed terms of ground type E : , S [[T ; 0 f? S g [[E]]]] ; = S [[N [[E]]]] ;. ffi 4 Related Work As mentioned in the introduction a number of papers have been devoted to step (1): proving the correctness of the original compiler <ref> [Sch80, Wan82, NN88, Dyb85, Mor73, Mos80, TWW81, Les87, Les88, CCM87, FM91] </ref>; and step (2): proving the correctness of the result of the analysis [CC79, CC92b, CC92a, Bur91b, Nie89, WH87, LM91, Jen92a, Ben92].
Reference: [Les88] <author> D.R. Lester. </author> <title> Combinator Graph Reduction: A Congruence and its Applications. </title> <type> PhD thesis, </type> <institution> Oxford University, </institution> <year> 1988. </year> <note> Also published as Technical Monograph PRG-73. </note>
Reference-contexts: For all closed terms of ground type E : , S [[T ; 0 f? S g [[E]]]] ; = S [[N [[E]]]] ;. ffi 4 Related Work As mentioned in the introduction a number of papers have been devoted to step (1): proving the correctness of the original compiler <ref> [Sch80, Wan82, NN88, Dyb85, Mor73, Mos80, TWW81, Les87, Les88, CCM87, FM91] </ref>; and step (2): proving the correctness of the result of the analysis [CC79, CC92b, CC92a, Bur91b, Nie89, WH87, LM91, Jen92a, Ben92]. <p> Also their methods deal with local transformations where strictness-based optimisations involve global modifications of the program. The works that are closest in spirit to this paper are <ref> [Les88] </ref> and [DH93]. The first states a correctness property of an optimisation based on strictness analysis in the context of combinator graph reduction on a version of the G-machine. <p> They assume a type checker to guarantee the well-foundedness of the annotations. Also the fact that the second phase is a call-by-value CPS transformation entails that evaluated values are systematically passed unboxed. As in <ref> [Les88] </ref>, only simple strictness information is considered. 18 A less thoroughgoing attempt at this problem is also presented in [Bur91b], which shows that the operational model underlying the transformation given in Figure 6 is correct.
Reference: [LM91] <author> A. Leung and P. Mishra. </author> <title> Reasoning about simple and exhaustive demand in higher-order languages. </title> <editor> In J. Hughes, editor, </editor> <booktitle> Proceedings of the Conference on Functional Programming and Computer Architecture, </booktitle> <pages> pages 329-351, </pages> <publisher> Springer-Verlag LNCS523, </publisher> <address> Cambridge, Massachussets, USA, </address> <month> 26-28 August </month> <year> 1991. </year>
Reference-contexts: We call the amount of evaluation required of an expression the evaluation context of the expression. A number of useful evaluation contexts such as head-strictness or tail-strictness have been defined in the literature and several analyses have been proposed to derive context information automatically (see <ref> [Bur91b, Jen92b, LM91, NN92, WH87, Wad87] </ref> for example). However the various ways of exploiting this context information within a compiler have never been described formally and little work has been done on assessing their effectiveness. We show in this section how these optimisations can be described formally in our framework. <p> However, many program analyses have been presented in the literature which can determine safe approximations to the information (see <ref> [Myc81, BHA86, WH87, Wad87, Hun91, Jen92a, LM91] </ref> for example). The second translation rule for application is used when there is to be no change of evaluation order. <p> ;. ffi 4 Related Work As mentioned in the introduction a number of papers have been devoted to step (1): proving the correctness of the original compiler [Sch80, Wan82, NN88, Dyb85, Mor73, Mos80, TWW81, Les87, Les88, CCM87, FM91]; and step (2): proving the correctness of the result of the analysis <ref> [CC79, CC92b, CC92a, Bur91b, Nie89, WH87, LM91, Jen92a, Ben92] </ref>. Some of the work devoted to the proof of step (1) include a number of local optimi-sations (such as peephole optimisations), but very few consider optimisations relying on a global analysis.
Reference: [MB93] <author> J. Muylaert Filho and G.L. Burn. </author> <title> Continuation passing transformation and abstract intrepretation. In G.L. Burn, S.J. Gay, </title> <editor> and M.D. Ryan, editors, </editor> <booktitle> Theory and Formal Methods 1993: Proceedings of the First Imperial C ol-lege, Department of Computing, Workshop on Theory and Formal Methods, </booktitle> <publisher> Springer-Verlag, Isle of Thorns Conference Centre, Chelwood Gate, </publisher> <address> Sussex, UK, </address> <month> 29-31 March </month> <year> 1993. </year>
Reference: [Mor73] <author> F.L. Morris. </author> <title> Advice on structuring compilers and proving them correct. </title> <booktitle> In Proceedings of POPL73, </booktitle> <pages> pages 144-152, </pages> <publisher> ACM, </publisher> <year> 1973. </year>
Reference-contexts: For all closed terms of ground type E : , S [[T ; 0 f? S g [[E]]]] ; = S [[N [[E]]]] ;. ffi 4 Related Work As mentioned in the introduction a number of papers have been devoted to step (1): proving the correctness of the original compiler <ref> [Sch80, Wan82, NN88, Dyb85, Mor73, Mos80, TWW81, Les87, Les88, CCM87, FM91] </ref>; and step (2): proving the correctness of the result of the analysis [CC79, CC92b, CC92a, Bur91b, Nie89, WH87, LM91, Jen92a, Ben92].
Reference: [Mos80] <author> P.D. Mosses. </author> <title> A constructive approach to compiler correctness. </title> <booktitle> In Proceedings of ICALP80, </booktitle> <pages> pages 449-462, </pages> <publisher> Springer-Verlag LNCS85, </publisher> <year> 1980. </year>
Reference-contexts: For all closed terms of ground type E : , S [[T ; 0 f? S g [[E]]]] ; = S [[N [[E]]]] ;. ffi 4 Related Work As mentioned in the introduction a number of papers have been devoted to step (1): proving the correctness of the original compiler <ref> [Sch80, Wan82, NN88, Dyb85, Mor73, Mos80, TWW81, Les87, Les88, CCM87, FM91] </ref>; and step (2): proving the correctness of the result of the analysis [CC79, CC92b, CC92a, Bur91b, Nie89, WH87, LM91, Jen92a, Ben92].
Reference: [MW85] <author> A. Meyer and M. Wand. </author> <title> Continuation semantics in the typed lambda-calculus. </title> <booktitle> In Proceedings of Logics of Programs, </booktitle> <pages> pages 219-224, </pages> <publisher> Springer-Verlag LNCS 193, </publisher> <address> Berlin, </address> <year> 1985. </year>
Reference-contexts: Meyer and Wand first showed that the type of the cps-translation of an expression could be derived from the type of the original expression <ref> [MW85] </ref>. Each primitive operator op has a cps version op c . For instance plus c performs the addition and passes the result to its continuation. We also use primitive eq in the example in section 3; it is treated in the same way as plus.
Reference: [Myc81] <author> A. Mycroft. </author> <title> Abstract Interpretation and Optimising Transformations for Applicative Programs. </title> <type> PhD thesis, </type> <institution> University of Edinburgh, Department of Computer Science, </institution> <month> December </month> <year> 1981. </year> <note> Also published as CST-15-81. </note>
Reference-contexts: Although the test given in the rule is not effective, many analyses have been developed which can find a subset of the cases when it holds (see <ref> [Ben92, BHA86, Jen92a, KM89, Myc81, Nie88] </ref> for example). * when the functional expression is not strict (second rule), the translation has the same structure as the call-by-name cps conversion, but uses the S conversion scheme so that strictness information can be used in translating subex pressions. <p> However, many program analyses have been presented in the literature which can determine safe approximations to the information (see <ref> [Myc81, BHA86, WH87, Wad87, Hun91, Jen92a, LM91] </ref> for example). The second translation rule for application is used when there is to be no change of evaluation order.
Reference: [Nie85] <author> F. Nielson. </author> <title> Program transformations in a denotational setting. </title> <journal> ACM TOPLAS, </journal> <volume> 7 </volume> <pages> 359-379, </pages> <year> 1985. </year>
Reference-contexts: The latter are more difficult to validate because they involve context-dependent transformations. The only papers addressing this issue, to our knowledge, are <ref> [Nie85] </ref> and [Ger75]. The second paper is concerned with partial correctness and relies on program annotations and theorem-proving methods. The first paper considers a simple imperative language and a collecting semantics associating with each program point the set of states which are possible when control reaches that point.
Reference: [Nie88] <author> F. Nielson. </author> <title> Strictness analysis and denotational abstract interpretation. </title> <journal> Inform. and Comput., </journal> <volume> 76 </volume> <pages> 29-92, </pages> <year> 1988. </year>
Reference-contexts: Although the test given in the rule is not effective, many analyses have been developed which can find a subset of the cases when it holds (see <ref> [Ben92, BHA86, Jen92a, KM89, Myc81, Nie88] </ref> for example). * when the functional expression is not strict (second rule), the translation has the same structure as the call-by-name cps conversion, but uses the S conversion scheme so that strictness information can be used in translating subex pressions.
Reference: [Nie89] <author> F. Nielson. </author> <title> Two-level semantics and abstract interpretation. </title> <journal> Theoretical Computer Science, </journal> <volume> 69 </volume> <pages> 117-242, </pages> <year> 1989. </year>
Reference-contexts: ;. ffi 4 Related Work As mentioned in the introduction a number of papers have been devoted to step (1): proving the correctness of the original compiler [Sch80, Wan82, NN88, Dyb85, Mor73, Mos80, TWW81, Les87, Les88, CCM87, FM91]; and step (2): proving the correctness of the result of the analysis <ref> [CC79, CC92b, CC92a, Bur91b, Nie89, WH87, LM91, Jen92a, Ben92] </ref>. Some of the work devoted to the proof of step (1) include a number of local optimi-sations (such as peephole optimisations), but very few consider optimisations relying on a global analysis.
Reference: [NN88] <author> H Riis Nielson and F. Nielson. </author> <title> Two-level semantics and code generation. </title> <journal> TCS, </journal> <volume> 56 </volume> <pages> 59-133, </pages> <year> 1988. </year>
Reference-contexts: For all closed terms of ground type E : , S [[T ; 0 f? S g [[E]]]] ; = S [[N [[E]]]] ;. ffi 4 Related Work As mentioned in the introduction a number of papers have been devoted to step (1): proving the correctness of the original compiler <ref> [Sch80, Wan82, NN88, Dyb85, Mor73, Mos80, TWW81, Les87, Les88, CCM87, FM91] </ref>; and step (2): proving the correctness of the result of the analysis [CC79, CC92b, CC92a, Bur91b, Nie89, WH87, LM91, Jen92a, Ben92].
Reference: [NN92] <author> F. Nielson and H. Riis Nielson. </author> <title> The tensor product in Wadler's analysis of lists. </title> <editor> In B. Krieg-Bruckner, editor, </editor> <booktitle> Proceedings of ESOP'92, </booktitle> <pages> pages 351-370, </pages> <publisher> Springer-Verlag LNCS582, Rennes, </publisher> <address> France, </address> <month> February </month> <year> 1992. </year> <note> Preliminary version of Chapter 8 of Two-level Functional Languages, CUP, 1992. 22 </note>
Reference-contexts: We call the amount of evaluation required of an expression the evaluation context of the expression. A number of useful evaluation contexts such as head-strictness or tail-strictness have been defined in the literature and several analyses have been proposed to derive context information automatically (see <ref> [Bur91b, Jen92b, LM91, NN92, WH87, Wad87] </ref> for example). However the various ways of exploiting this context information within a compiler have never been described formally and little work has been done on assessing their effectiveness. We show in this section how these optimisations can be described formally in our framework.
Reference: [Plo75] <author> G.D. Plotkin. </author> <title> Call-by-name, call-by-value and the -calculus. </title> <journal> Theoretical Computer Science, </journal> <volume> 1 </volume> <pages> 125-159, </pages> <year> 1975. </year>
Reference-contexts: The important point about N [[E]] is that it has at most one redex outside the scope of a lambda, which means that call-by-value and call-by-name coincide for the translated term <ref> [Plo75] </ref>. Furthermore, this redex is always at the head of the expression [FM91], and the expression can be reduced without dynamic search for the next redex, just like machine code. We should mention at this stage another possibility for passing the continuation as an extra argument to a lambda abstraction. <p> by -conversion into: N 0 [[x:E]] = c:c (x:N 0 [[E]]) The rule for application becomes: N 0 [[E 1 E 2 ]] = c:N 0 [[E 1 ]] (f:f (N 0 [[E 2 ]]) c) Passing the continuation as the second argument is quite common in the literature, see <ref> [App92, DH93, Rey74, Plo75] </ref> for instance, but the continuation in first position also occurs in [Fis72, Fis93, CFF93, SF93]. The above simplification rule for lambda abstraction suggests that passing the continuation as the second argument sometimes leads to a more compact representation.
Reference: [Rey74] <author> J.C. Reynolds. </author> <title> On the relation between direct and continuation semantics. </title> <booktitle> In Proceedings of the Second Colloquium on Automata, Languages and Programming, </booktitle> <pages> pages 141-156, </pages> <publisher> Springer-Verlag, Saarbrucken, </publisher> <year> 1974. </year>
Reference-contexts: by -conversion into: N 0 [[x:E]] = c:c (x:N 0 [[E]]) The rule for application becomes: N 0 [[E 1 E 2 ]] = c:N 0 [[E 1 ]] (f:f (N 0 [[E 2 ]]) c) Passing the continuation as the second argument is quite common in the literature, see <ref> [App92, DH93, Rey74, Plo75] </ref> for instance, but the continuation in first position also occurs in [Fis72, Fis93, CFF93, SF93]. The above simplification rule for lambda abstraction suggests that passing the continuation as the second argument sometimes leads to a more compact representation.
Reference: [Sch80] <author> D.A. Schmidt. </author> <title> State transition machines for lambda-calculus expressions. </title> <booktitle> In Proceedings of the Semantics-Directed Compiler Generation Workshop, </booktitle> <pages> pages 415-440, </pages> <publisher> Springer-Verlag LNCS94, </publisher> <year> 1980. </year>
Reference-contexts: For all closed terms of ground type E : , S [[T ; 0 f? S g [[E]]]] ; = S [[N [[E]]]] ;. ffi 4 Related Work As mentioned in the introduction a number of papers have been devoted to step (1): proving the correctness of the original compiler <ref> [Sch80, Wan82, NN88, Dyb85, Mor73, Mos80, TWW81, Les87, Les88, CCM87, FM91] </ref>; and step (2): proving the correctness of the result of the analysis [CC79, CC92b, CC92a, Bur91b, Nie89, WH87, LM91, Jen92a, Ben92].
Reference: [SF92] <author> A. Sabry and M. Felleisen. </author> <title> Reasoning about Programs in Continuation-Passing Style. </title> <type> Technical Report TR 92-180, </type> <institution> Rice University, </institution> <year> 1992. </year>
Reference-contexts: The interested reader can find in [DF91] and <ref> [SF92] </ref> techniques for the systematic elimination of administrative redexes. 6 S [[x]] = x S [[if E 1 E 2 E 3 ]] = c:S [[E 1 ]] (if c (S [[E 2 ]] c) (S [[E 3 ]] c)) if 8 : drop (S [[E 1 ]] ) ? =
Reference: [SF93] <author> A. Sabry and M. Felleisen. </author> <title> Reasoning about programs in continuation-passing style. </title> <journal> Lisp and Symbolic Computation (Special issue on continuations), </journal> <volume> 6(3/4), </volume> <year> 1993. </year>
Reference-contexts: becomes: N 0 [[E 1 E 2 ]] = c:N 0 [[E 1 ]] (f:f (N 0 [[E 2 ]]) c) Passing the continuation as the second argument is quite common in the literature, see [App92, DH93, Rey74, Plo75] for instance, but the continuation in first position also occurs in <ref> [Fis72, Fis93, CFF93, SF93] </ref>. The above simplification rule for lambda abstraction suggests that passing the continuation as the second argument sometimes leads to a more compact representation. <p> (x:E)]] = fix B [[]] (x:N [[E]]) Translation of Terms plus c c m n = c (plus m n) if c E 1 E 2 = v:if v E 1 E 2 cons c c E 1 E 2 = c (cons E 1 E 2 ) shown in <ref> [JH94, SF93] </ref>. In any case, the impact of this choice is not significant for the results presented here.
Reference: [Ste78] <author> G.L. Steele Jr. Rabbit: </author> <title> A Compiler for Scheme. </title> <type> Technical Report AI Tech. Rep. 474, </type> <institution> MIT, </institution> <address> Cambridge, Mass., </address> <year> 1978. </year>
Reference-contexts: We would like to stress that translating programs into continuation-passing style as an early stage in a compiler is of more than theoretical interest. Steele was the first to show that it was beneficial to do this for Scheme programs in his seminal work on the Rabbit compiler <ref> [Ste78] </ref>. Some of the most efficient implementations of Scheme [KKR*86, Kra88] and ML [App92] use cps-translation.
Reference: [TWW81] <author> J.W. Thatcher, E.G Wagner, and J.B. Wright. </author> <title> More advice on structuring compilers and proving them correct. </title> <journal> Theoretical Computer Science, </journal> <volume> 15 </volume> <pages> 223-249, </pages> <year> 1981. </year>
Reference-contexts: For all closed terms of ground type E : , S [[T ; 0 f? S g [[E]]]] ; = S [[N [[E]]]] ;. ffi 4 Related Work As mentioned in the introduction a number of papers have been devoted to step (1): proving the correctness of the original compiler <ref> [Sch80, Wan82, NN88, Dyb85, Mor73, Mos80, TWW81, Les87, Les88, CCM87, FM91] </ref>; and step (2): proving the correctness of the result of the analysis [CC79, CC92b, CC92a, Bur91b, Nie89, WH87, LM91, Jen92a, Ben92].
Reference: [Wad87] <author> P.L. Wadler. </author> <title> Strictness analysis on non-flat domains (by abstract interpretation over finite domains). </title> <editor> In S. Abramsky and C.L. Hankin, editors, </editor> <booktitle> Abstract Interpretation of Declarative Languages, chapter 12, </booktitle> <pages> pages 266-275, </pages> <publisher> Ellis Hor-wood Ltd., </publisher> <address> Chichester, West Sussex, England, </address> <year> 1987. </year>
Reference-contexts: We call the amount of evaluation required of an expression the evaluation context of the expression. A number of useful evaluation contexts such as head-strictness or tail-strictness have been defined in the literature and several analyses have been proposed to derive context information automatically (see <ref> [Bur91b, Jen92b, LM91, NN92, WH87, Wad87] </ref> for example). However the various ways of exploiting this context information within a compiler have never been described formally and little work has been done on assessing their effectiveness. We show in this section how these optimisations can be described formally in our framework. <p> However, many program analyses have been presented in the literature which can determine safe approximations to the information (see <ref> [Myc81, BHA86, WH87, Wad87, Hun91, Jen92a, LM91] </ref> for example). The second translation rule for application is used when there is to be no change of evaluation order. <p> This corresponds to passing the evaluation context to a tail-call. In order to illustrate the transformation T , let us consider two common evaluation contexts BOT and INF <ref> [Bur91a, Wad87] </ref>. BOT contains only ? and IN F is the Scott-closed set containing all infinite lists and lists ending with a ?. <p> In operational terms, BOT is the context corresponding to the evaluation up to WHNF and IN F is the context indicating the evaluation of the whole structure of the expression. We assume that the transformation relies on a strictness analyser which is powerful enough to show that (see <ref> [Wad87] </ref> for such an analyser): 8x 2 S ; 8y 2 IN F: cons x y 2 IN F 8x 2 INF: reverse x 2 BOT We show how the expression reverse (cons e 1 e 2 ) is transformed by T .
Reference: [Wan82] <author> M. Wand. </author> <title> Deriving target code as a representation of continuation semantics. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 4(3) </volume> <pages> 496-517, </pages> <month> July </month> <year> 1982. </year>
Reference-contexts: For all closed terms of ground type E : , S [[T ; 0 f? S g [[E]]]] ; = S [[N [[E]]]] ;. ffi 4 Related Work As mentioned in the introduction a number of papers have been devoted to step (1): proving the correctness of the original compiler <ref> [Sch80, Wan82, NN88, Dyb85, Mor73, Mos80, TWW81, Les87, Les88, CCM87, FM91] </ref>; and step (2): proving the correctness of the result of the analysis [CC79, CC92b, CC92a, Bur91b, Nie89, WH87, LM91, Jen92a, Ben92].
Reference: [WH87] <author> P. Wadler and R. J. M. Hughes. </author> <title> Projections for strictness analysis. </title> <editor> In G. Kahn, editor, </editor> <booktitle> Proceedings of the Functional Programming Languages and Computer Architecture Conference, </booktitle> <pages> pages 385-407, </pages> <publisher> Springer-Verlag LNCS 274, </publisher> <month> Septem-ber </month> <year> 1987. </year>
Reference-contexts: We call the amount of evaluation required of an expression the evaluation context of the expression. A number of useful evaluation contexts such as head-strictness or tail-strictness have been defined in the literature and several analyses have been proposed to derive context information automatically (see <ref> [Bur91b, Jen92b, LM91, NN92, WH87, Wad87] </ref> for example). However the various ways of exploiting this context information within a compiler have never been described formally and little work has been done on assessing their effectiveness. We show in this section how these optimisations can be described formally in our framework. <p> However, many program analyses have been presented in the literature which can determine safe approximations to the information (see <ref> [Myc81, BHA86, WH87, Wad87, Hun91, Jen92a, LM91] </ref> for example). The second translation rule for application is used when there is to be no change of evaluation order. <p> ;. ffi 4 Related Work As mentioned in the introduction a number of papers have been devoted to step (1): proving the correctness of the original compiler [Sch80, Wan82, NN88, Dyb85, Mor73, Mos80, TWW81, Les87, Les88, CCM87, FM91]; and step (2): proving the correctness of the result of the analysis <ref> [CC79, CC92b, CC92a, Bur91b, Nie89, WH87, LM91, Jen92a, Ben92] </ref>. Some of the work devoted to the proof of step (1) include a number of local optimi-sations (such as peephole optimisations), but very few consider optimisations relying on a global analysis.
References-found: 53

