URL: http://csg-www.lcs.mit.edu:8001/mcrctr/tr44/ipc-phase1.ps.Z
Refering-URL: http://csg-www.lcs.mit.edu:8001/mcrctr/
Root-URL: 
Email: cottonsg@mcrc.mot.com  
Title: IPC: Implicitly Parallel C (Extended Abstract)  
Author: James E. Hicks Mark H. Nodine Michael J. Beckerle Cotton Seed fjamey, nodine, mikeb, 
Note: Copyright c 1994 Motorola, Inc. All Rights Reserved  
Address: One Kendall Square, Building 200 Cambridge, MA 02139  
Affiliation: Motorola Cambridge Research Center  
Abstract: Motorola Technical Report MCRC-TR-44 Version 002 January 30, 1995 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Zahira Ammarguellat. </author> <title> A control-flow normalizations algorithm and its complexity. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 18(3), </volume> <month> March </month> <year> 1992. </year>
Reference-contexts: The Miprac compiler performs two very important functions for us: Control-Flow Normalization Miprac normalizes control-flow, yielding a program with only structured control-flow, using Ammarguellat's algorithm <ref> [1] </ref>. This process eliminates all goto, break and continue statements from the program and converts all control-flow 2 loops into single-entry, single-exit while loops. This algorithms produces no code blow up except in the case of irreducible control-flows. <p> 1); t-&gt;r = build_tree (n - 2); return t; - int sum_tree (tree_t *p) - if (p == NULL) return 0; t1 = sum_tree (p-&gt;l); t2 = sum_tree (p-&gt;r); return p-&gt;x + t1 + t2; - void main (int argc, char *argv []) - tree_t *q = build_tree (atoi (argv <ref> [1] </ref>)); int x = sum_tree (q); printf ("%d"n", x); - Perhaps the most important observation to make about the SDFG for sum_tree is found about 40% of the way down the else clause, where there are two boxes labeled "call". These boxes are the recursive calls to sum_tree.
Reference: [2] <author> Arvind, Rishiyur S. Nikhil, and Keshav K. Pingali. I-structures: </author> <title> Data structures for parallel computing. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 11(4) </volume> <pages> 598-632, </pages> <month> October </month> <year> 1989. </year>
Reference-contexts: CSG's research has been based around the Id [7] programming language and dataflow architectures [4]. The Id language, which has greatly evolved over the years, consists of a a functional programming language core extended with single-assignment data structures <ref> [3, 2] </ref>. Functional programming languages are attractive for implicitly-parallel processing because they are side-effect free; hence, they eliminate any need for sophisticated dependence analysis techniques to extract parallelism from programs.
Reference: [3] <author> D. D. Chamberlin. </author> <title> The "single-assignment" approach to parallel processing. </title> <booktitle> In Proceedings of AFIPS Fall Joint Computer Conference, </booktitle> <pages> pages 403-408, </pages> <address> Montvale, NJ, April 1968. </address> <publisher> AFIPS Press. </publisher>
Reference-contexts: CSG's research has been based around the Id [7] programming language and dataflow architectures [4]. The Id language, which has greatly evolved over the years, consists of a a functional programming language core extended with single-assignment data structures <ref> [3, 2] </ref>. Functional programming languages are attractive for implicitly-parallel processing because they are side-effect free; hence, they eliminate any need for sophisticated dependence analysis techniques to extract parallelism from programs.
Reference: [4] <author> David E. Culler and Gregory M. Papadopoulos. </author> <title> The explicit token store. </title> <journal> Journal of Parallel and Distributed Computing, </journal> <note> January 1991. (Also published as Computation Structures Group Memo 312). </note>
Reference-contexts: MIT has advocated an implicitly-parallel approach to parallel programming, in which the compiler, run-time system, and underlying computer architecture are responsible for automatically exploiting parallelism. CSG's research has been based around the Id [7] programming language and dataflow architectures <ref> [4] </ref>. The Id language, which has greatly evolved over the years, consists of a a functional programming language core extended with single-assignment data structures [3, 2].
Reference: [5] <author> Williams Ludwell Harrison III. </author> <title> The interprocedural analysis and automatic parallelization of Scheme programs. </title> <journal> Lisp and Symbolic Computation, </journal> 2(3/4):179-396, October 1989. 
Reference-contexts: The abstract interpreter uses a notion of procedure strings, which denote the instruction pointer in terms of procedure invocations and returns, as an abstract measure of time [6]. The results of this interprocedural analysis are surprisingly precise because of the procedure strings, which are described in detail in <ref> [5] </ref>. Miprac takes C and produces (MIL Intermediate Language) code and a set of tables summarizing the dependences between various creates, reads, and writes in the program. MIL is roughly equivalent to register-transfer level operations plus procedure calls and structured control flow.
Reference: [6] <author> W.L. Harrison III and Z. Ammarguellat. </author> <title> A program's eye view of Miprac. </title> <editor> In D. Gelernter, N. Nicolau, and D. Padua, editors, </editor> <booktitle> Languages and Compilers for Parallel Computing. </booktitle> <publisher> MIT Press, </publisher> <month> August </month> <year> 1992. </year>
Reference-contexts: As we will see in Section 6, use of sync storage is crucial to the automatic extraction of producer-consumer parallelism from IPC programs. 4 Structure of the IPC Compiler The overall structure of the IPC compiler is given in Figure 1. We use the Miprac <ref> [6] </ref> compiler from the University of Illinois as a "front end", although it does both the normal front-end work as well as powerful analysis and optimization. <p> The abstract interpreter uses a notion of procedure strings, which denote the instruction pointer in terms of procedure invocations and returns, as an abstract measure of time <ref> [6] </ref>. The results of this interprocedural analysis are surprisingly precise because of the procedure strings, which are described in detail in [5]. Miprac takes C and produces (MIL Intermediate Language) code and a set of tables summarizing the dependences between various creates, reads, and writes in the program.
Reference: [7] <author> Rishiyur S. Nikhil. </author> <title> Id 90 reference manual. </title> <type> CSG Memo 284-1, </type> <institution> MIT Laboratory for Computer Science, </institution> <address> Cambridge, MA, </address> <month> September </month> <year> 1990. </year>
Reference-contexts: MIT has advocated an implicitly-parallel approach to parallel programming, in which the compiler, run-time system, and underlying computer architecture are responsible for automatically exploiting parallelism. CSG's research has been based around the Id <ref> [7] </ref> programming language and dataflow architectures [4]. The Id language, which has greatly evolved over the years, consists of a a functional programming language core extended with single-assignment data structures [3, 2].
Reference: [8] <author> K. Pingali, M. Beck, R. Johnson, M. Moudgill, and P. Stodghill. </author> <title> Dependence flow graphs: An algebraic approach to program dependencies. </title> <type> Technical Report TR-90-1152, </type> <institution> Dept. of Computer Science, Cornell University, </institution> <month> September </month> <year> 1990. </year> <month> 11 </month>
Reference-contexts: MIL is roughly equivalent to register-transfer level operations plus procedure calls and structured control flow. From the MIL code and dependence tables, we create a data structure called a Structured Dependence Flow Graph (SDFG). SDFG's are similar to Pingali et al.'s Dependence Flow Graphs <ref> [8] </ref>, but SDFG's are much simpler since Miprac's control flow normalization phase eliminates unstructured control flows. An SDFG consists of a number of expression nodes joined together by directed arcs. There are two types of SDFG arcs: value arcs and dependence arcs.
References-found: 8

