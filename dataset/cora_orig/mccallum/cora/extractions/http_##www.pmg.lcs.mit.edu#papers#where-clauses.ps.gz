URL: http://www.pmg.lcs.mit.edu/papers/where-clauses.ps.gz
Refering-URL: http://www.pmg.lcs.mit.edu/areas/object-impl.html
Root-URL: 
Email: Day@crd.lotus.com  fgruber,liskov,andrug@lcs.mit.edu  
Title: Subtypes vs. Where Clauses: Constraining Parametric Polymorphism  
Author: Mark Day Mark Robert Gruber Barbara Liskov Andrew C. Myers 
Web: URL: http://www.pmg.lcs.mit.edu/.  
Note: Web  This research was supported in part by the Advanced Research Projects Agency of the Department of Defense, monitored by the Office of Naval Research under contract N00014-91-J-4136, and in part by the National Science Foundation under Grant CCR-8822158.  
Address: 1 Rogers Street Cambridge, MA 02142  545 Technology Square, Cambridge, MA 02139  
Affiliation: Lotus Development Corporation  Laboratory for Computer Science, Massachusetts Institute of Technology,  
Abstract: All object-oriented languages provide support for subtype polymorphism, which allows the writing of generic code that works for families of related types. There is also a need, however, to write code that is generic across types that have no real family relationship. To satisfy this need a programming language must provide a mechanism for parametric polymorphism, allowing for types as parameters to routines and types. We show that to support modular programming and separate compilation there must be a mechanism for constraining the actual parameters of the routine or type. We describe a simple and powerful constraint mechanism and compare it with constraint mechanisms in other languages in terms of both ease of use and semantic expressiveness. We also discuss the interaction between subtype and parametric polymorphism: we discuss the subtype relations that can exist between instantiations of parameterized types, and which of those relations are useful and can be implemented efficiently. We illustrate our points using examples in Theta, a new object-oriented language, and we describe the time- and space-efficient implementation of parametric polymorphism used in Theta. Copyright c fl1995 by the Association for Computing Machinery, Inc. Permission to make digital or hard copies of part or all of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that new copies bear this notice and the full citation on the first page. Copyrights for components of this work owned by others than ACM must be honored. Abstracting with credit is permitted. To copy otherwise, to republish, to post on servers, or to redistribute to lists, requires prior specific permission and/or a fee. Request permissions from Publications Dept, ACM Inc., fax +1 (212) 869-0481, or permissions@acm.org. 
Abstract-found: 1
Intro-found: 1
Reference: [ALS78] <author> Russell Atkinson, Barbara Liskov, and Robert Scheifler. </author> <title> Aspects of implementing CLU. </title> <booktitle> In Proceedings of the ACM 1978 Annual Conference, </booktitle> <month> October </month> <year> 1978. </year>
Reference-contexts: Details can be found in [LCD + 94]. 6 Implementation This section presents an efficient implementation of parameterized abstractions for Theta. Our solution is inspired by the way parameterization was implemented for CLU <ref> [ALS78] </ref>. We assume that code is not recompiled for each actual parameter type, since this approach leads to code duplication. The scheme described here is compatible with selector-table-indexed dispatch schemes [DMSV89, Mye95, Ros88, Str87]. A more complete description of our technique can be found in [ML94]. <p> Since some dispatch vectors contain pointers to other dispatch vectors or to procedure objects that contain dispatch vectors, the instantiation process is recursive. In certain pathological implementations, the instantiation process cannot complete, because infinitely many instantiations must be generated <ref> [ALS78] </ref>; linking fails in this case. The problem could be solved by deferring some instantiations until run time, but recursive instantiations are not a problem in practice. The technique described here has low cost in terms of both space and time.
Reference: [BH95] <author> Andrew Black and Norman Hutchinson, </author> <month> August </month> <year> 1995. </year> <type> Personal communication. </type>
Reference-contexts: single method function equal [Integer] ! [Boolean], and would then check whether Integer was a subtype of this type. (The mechanism in PolyTOIL [BSvG95] is similar to Emerald's but the details of the matching rule are different.) Emerald does not allow independent type definitions to be introduced to express constraints <ref> [BH95] </ref>; a new type must be defined in each matching clause. Thus, Emerald matching clauses are similar to where clauses, since the required methods are all written out explicitly.
Reference: [BHJ + 87] <author> Andrew Black, Norman Hutchinson, Eric Jul, Henry Levy, and Larry Carter. </author> <title> Distribution and abstract types in Emerald. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> SE-13(1):65-76, </volume> <month> January </month> <year> 1987. </year>
Reference-contexts: This is the usual definition of conformance <ref> [SCW85, BHJ + 87, Car84] </ref> extended to support exceptions. As discussed by others, e.g., [BHJ + 87], the first two rules are the weakest rules that ensure that static type checking guarantees no run-time type errors. <p> This is the usual definition of conformance [SCW85, BHJ + 87, Car84] extended to support exceptions. As discussed by others, e.g., <ref> [BHJ + 87] </ref>, the first two rules are the weakest rules that ensure that static type checking guarantees no run-time type errors. The rule for exceptions ensures that a subtype method signals only exceptions defined for the supertype method. <p> Thus string set and string bag are not the same type. Similarly, one type is a subtype of another only if its specification declares this and the declaration is legal. In some object-oriented languages, e.g., Emerald <ref> [BHJ + 87] </ref>, PolyTOIL [BSvG95], and School [RIR93], type relations are derived: two specifications define the same type if they are identical except for the names of the types they are defining, and a type is a subtype of another type if it provides the necessary methods and their signatures conform. <p> First, array [int] is not a subtype of array [comparable] even if int &lt; comparable; we discuss this issue further in Section 4. Second, there are essentially no useful subtypes of comparable, because the contravariance of arguments in the method conformance rules has undesirable consequences <ref> [BHJ + 87, RIR93] </ref>. <p> Two variants of this approach are shown in Figure 4. This figure shows the different ways of specifying the member routine discussed earlier; it repeats the where clause example, followed by examples in the languages Rapide [KLMM94] and Emerald <ref> [BHJ + 87] </ref>. (Rapide and Emerald do not have iterators, so we had to invent some syntax.) To constrain a type in Rapide one defines an auxiliary parameterized type to capture the desired constraint (the desired set of methods).
Reference: [BSvG95] <author> Kim Bruce, Angela Schuett, and Robert van Gent. Polytoil: </author> <title> A type-safe polymorphic object-oriented language. </title> <booktitle> In ECOOP'95, </booktitle> <year> 1995. </year>
Reference-contexts: Thus string set and string bag are not the same type. Similarly, one type is a subtype of another only if its specification declares this and the declaration is legal. In some object-oriented languages, e.g., Emerald [BHJ + 87], PolyTOIL <ref> [BSvG95] </ref>, and School [RIR93], type relations are derived: two specifications define the same type if they are identical except for the names of the types they are defining, and a type is a subtype of another type if it provides the necessary methods and their signatures conform. <p> to check the call y.member [Integer, : : : ], Emerald would substitute Integer for EqAble within the definition of EqAble, to obtain a type with a single method function equal [Integer] ! [Boolean], and would then check whether Integer was a subtype of this type. (The mechanism in PolyTOIL <ref> [BSvG95] </ref> is similar to Emerald's but the details of the matching rule are different.) Emerald does not allow independent type definitions to be introduced to express constraints [BH95]; a new type must be defined in each matching clause.
Reference: [Car84] <author> Luca Cardelli. </author> <title> A semantics of multiple inheritance. In Semantics of Data Types, </title> <publisher> LNCS 173, </publisher> <pages> pages 51-68. </pages> <publisher> Springer-Verlag, </publisher> <year> 1984. </year> <month> 12 </month>
Reference-contexts: This is the usual definition of conformance <ref> [SCW85, BHJ + 87, Car84] </ref> extended to support exceptions. As discussed by others, e.g., [BHJ + 87], the first two rules are the weakest rules that ensure that static type checking guarantees no run-time type errors.
Reference: [CCH + 89] <author> Peter Canning, William Cook, Walter Hill, John Mitchell, and Walter Olthoff. </author> <title> F-bounded poly-morphism for object-oriented programming. </title> <booktitle> In Proceedings of the Conference on Functional Programming Languages and Computer Architecture, </booktitle> <pages> pages 273-280, </pages> <year> 1989. </year>
Reference-contexts: So far we have been concerned with the ease of expressing constraints. Another issue is semantic expressiveness. A common way to formalize type systems for object-oriented languages is to use F-bounded quantification <ref> [CCH + 89] </ref>. The languages we examined are either equivalent to or more powerful than F-bounded quantification. The issue is whether one can express mutual dependencies between type parameters.
Reference: [Coo89] <author> William R. Cook. </author> <title> A proposal for making Eiffel type-safe. </title> <booktitle> In ECOOP'89, </booktitle> <pages> pages 52-72, </pages> <month> October </month> <year> 1989. </year>
Reference-contexts: It is worth noting that Meyer [Mey86] concluded that the above problem with comparable did not arise, but he was using an unsound definition of conformance that allowed covariant argument types <ref> [Coo89] </ref>. 3.1 Expressing Constraints The Theta mechanism for supporting genericity is constrained parametric polymorphism, which was first introduced in CLU [LSAS77]. With this mechanism, types are explicitly provided as parameters to polymorphic types and routines.
Reference: [DMSV89] <author> R. Dixon, T. McKee, P. Schweitzer, and M. Vaughan. </author> <title> A fast method dispatcher for compiled languages with multiple inheritance. </title> <booktitle> In OOPSLA '89 Conference Proceedings, </booktitle> <pages> pages 211-214, </pages> <address> New Orleans, LA, </address> <month> October </month> <year> 1989. </year> <note> Published as SIGPLAN Notices 24(10), Octo-ber, </note> <year> 1989. </year>
Reference-contexts: Our solution is inspired by the way parameterization was implemented for CLU [ALS78]. We assume that code is not recompiled for each actual parameter type, since this approach leads to code duplication. The scheme described here is compatible with selector-table-indexed dispatch schemes <ref> [DMSV89, Mye95, Ros88, Str87] </ref>. A more complete description of our technique can be found in [ML94]. Because parameterized code is shared by all in-stantiations, the key issue is how the code accesses the methods described by the where clauses. For example, consider the mapC class from Figure 6.
Reference: [ES90] <author> Margaret A. Ellis and Bjarne Stroustrup. </author> <title> The Annotated C++ Reference Manual. </title> <publisher> Addison-Wesley, </publisher> <year> 1990. </year>
Reference-contexts: Thus the instantiation member [int,set [int]] is legal but member [char,set [int]] is not. 3.2 Discussion Some languages with parametric polymorphism do not have a mechanism for stating constraints on type parameters, e.g., C++ templates <ref> [ES90] </ref> and Modula-3 generics [Nel91]. To check that an actual instantiation of a parameterized routine or type is correct, the compiler rewrites the body of the routine or type, replacing the type parameter with the actual type, and then checks the result.
Reference: [JL78] <author> Anita K. Jones and Barbara Liskov. </author> <title> A language extension for expressing constraints on data access. </title> <journal> CACM, </journal> <volume> 21(5) </volume> <pages> 358-367, </pages> <month> May </month> <year> 1978. </year>
Reference-contexts: But the result is that our set of elephants now contains a rhinoceros! (It's interesting to note that this problem was first pointed out in 1978 in the context of access control <ref> [JL78] </ref>.) Another curious point is that sometimes the subtype relation goes in the opposite way: * P [T] &lt; P [S] when S &lt; T This relation makes sense whenever P is an output-only abstraction, such as an output stream.
Reference: [KLMM94] <author> Dinesh Katiyar, David Luckham, John Mitchell, and Sigurd Melda. </author> <title> Polymorphism and subtyping in interfaces. </title> <journal> ACM SIGPLAN Notices, </journal> <volume> 29(9) </volume> <pages> 22-34, </pages> <month> August </month> <year> 1994. </year>
Reference-contexts: Two variants of this approach are shown in Figure 4. This figure shows the different ways of specifying the member routine discussed earlier; it repeats the where clause example, followed by examples in the languages Rapide <ref> [KLMM94] </ref> and Emerald [BHJ + 87]. (Rapide and Emerald do not have iterators, so we had to invent some syntax.) To constrain a type in Rapide one defines an auxiliary parameterized type to capture the desired constraint (the desired set of methods).
Reference: [LCD + 94] <author> Barbara Liskov, Dorothy Curtis, Mark Day, Sanjay Ghemawhat, Robert Gruber, Paul Johnson, and Andrew C. Myers. </author> <title> Theta Reference Manual. Programming Methodology Group Memo 88, </title> <institution> MIT Laboratory for Computer Science, </institution> <address> Cambridge, MA, </address> <month> February </month> <year> 1994. </year> <note> Also available at http://www.pmg.lcs.mit.edu/papers/thetaref/. </note>
Reference-contexts: We present Theta's encapsulation mechanism and discuss the relationship of encapsulation to polymorphism. We also describe our time- and space-efficient implementation of parametric polymorphism. The paper considers only a portion of Theta. A complete description can be found in <ref> [LCD + 94] </ref>. The remainder of the paper is organized as follows. We begin by discussing types and subtype polymor-phism in a strongly-typed programming language. Section 3 discusses parametric polymorphism and mechanisms for constraining type parameters, while Section 4 discusses subtype relations among instantiations of parameterized types. <p> Theta allows a class to inherit code from a single superclass. The type hierarchy is separate from the inheritance hierarchy; the subclass need not implement a subtype of the type implemented by the superclass. Details can be found in <ref> [LCD + 94] </ref>. 6 Implementation This section presents an efficient implementation of parameterized abstractions for Theta. Our solution is inspired by the way parameterization was implemented for CLU [ALS78]. We assume that code is not recompiled for each actual parameter type, since this approach leads to code duplication.
Reference: [LG86] <author> Barbara Liskov and John Guttag. </author> <title> Abstraction and Specification in Program Development. </title> <address> Cambridge MA: </address> <publisher> MIT Press, </publisher> <address> New York: McGraw Hill, </address> <year> 1986. </year>
Reference-contexts: array [S] object to change all the pointers doesn't work because it doesn't preserve sharing (and of course it's expensive too). 5 Modules and Encapsulation The main issue in designing a mechanism to implement abstractions is providing encapsulation so that local reasoning about the correctness of an implementation is sound <ref> [LG86] </ref>. The encapsulation unit could be the implementation of just one abstraction, or of many abstractions.
Reference: [LSAS77] <author> Barbara Liskov, Alan Snyder, Russell Atkinson, and Craig Schaffert. </author> <title> Abstraction mechanisms in CLU. </title> <journal> CACM, </journal> <volume> 20(8) </volume> <pages> 564-576, </pages> <month> August </month> <year> 1977. </year>
Reference-contexts: added to a string bag several times it appears in the bag multiple times (and the elements iterator will yield it many times) whereas it would appear in the set just once. (An iterator is a special kind of routine that yields a sequence of results one at a time <ref> [LSAS77] </ref>.) The specification for string int map indicates that it is a subtype of string set (using the &lt; symbol); this makes sense because string int map stores a single mapping for each string, and defines the elements iterator to yield the strings that are mapped. <p> is worth noting that Meyer [Mey86] concluded that the above problem with comparable did not arise, but he was using an unsound definition of conformance that allowed covariant argument types [Coo89]. 3.1 Expressing Constraints The Theta mechanism for supporting genericity is constrained parametric polymorphism, which was first introduced in CLU <ref> [LSAS77] </ref>. With this mechanism, types are explicitly provided as parameters to polymorphic types and routines. A parameterized definition defines a set of types or routines; the set contains an element for each legal substitution of actual types for the type parameters. <p> Having explicit type parameters isn't the whole story, because we still need a way of expressing constraints on allowable parameters. This is the purpose of the where clause. Originally defined in CLU <ref> [LSAS77] </ref>, the where clause has been adapted in Theta (and also in School [RIR93]) to an object-oriented language with subtyping. A where clause lists the names and signatures of required methods for the parameters.
Reference: [LW94] <author> Barbara Liskov and Jeannette M. Wing. </author> <title> A behavioral notion of subtyping. </title> <journal> ACM TOPLAS, </journal> <volume> 16(6) </volume> <pages> 1811-1841, </pages> <month> November </month> <year> 1994. </year>
Reference-contexts: Similarly, string int map is not a subtype of string bag since a string bag keeps track of duplicates whereas string int map does not. (See <ref> [LW94] </ref> for further discussion of when subtyping makes sense behaviorally.) Type specifications in Theta define only the methods of the type's objects but do not define ways to create objects from scratch. Such creators are specified separately and are typically stand-alone routines (i.e., not methods).
Reference: [Mey86] <author> Bertrand Meyer. </author> <title> Genericity versus inheritance. </title> <booktitle> In Proceedings of OOPSLA '86, </booktitle> <month> September </month> <year> 1986. </year>
Reference-contexts: In general, only types that satisfy certain constraints are allowed, where the constraints rule out types whose objects don't have certain methods (i.e., we need constrained genericity <ref> [Mey86] </ref>). One might try to capture constraints using the subtype relation. <p> Clearly we do not want to follow this path, as it effectively eliminates an important part of compile-time type-checking for gt. Furthermore, forcing all implementations of subtypes of comparable to handle arbitrary comparable objects is both a nuisance and costly at run-time. It is worth noting that Meyer <ref> [Mey86] </ref> concluded that the above problem with comparable did not arise, but he was using an unsound definition of conformance that allowed covariant argument types [Coo89]. 3.1 Expressing Constraints The Theta mechanism for supporting genericity is constrained parametric polymorphism, which was first introduced in CLU [LSAS77].
Reference: [ML94] <author> Andrew C. Myers and Barbara Liskov. </author> <title> Efficient Implementation of Parameterized Types in an Object-Oriented Language. Programming Methodology Group Memo 91, </title> <institution> MIT Lab for Computer Science, </institution> <month> July </month> <year> 1994. </year> <note> Also available at ftp://ftp.pmg.lcs.mit.edu/pub/thor/param-impl.ps.gz. </note>
Reference-contexts: We assume that code is not recompiled for each actual parameter type, since this approach leads to code duplication. The scheme described here is compatible with selector-table-indexed dispatch schemes [DMSV89, Mye95, Ros88, Str87]. A more complete description of our technique can be found in <ref> [ML94] </ref>. Because parameterized code is shared by all in-stantiations, the key issue is how the code accesses the methods described by the where clauses. For example, consider the mapC class from Figure 6.
Reference: [Mye94] <author> Andrew C. Myers. </author> <title> Fast Object Operations in a Persistent Programming System. </title> <type> Technical Report MIT/LCS/TR-599, </type> <institution> MIT Laboratory for Computer Science, </institution> <address> Cambridge, MA, </address> <month> January </month> <year> 1994. </year> <type> Master's thesis. </type>
Reference-contexts: An assignment x: T := y where y is of type S results in x pointing to a different dispatch vector (a different place in the object's header) than y does. This approach allows for fast method dispatch; details are given in <ref> [Mye94, Mye95] </ref>. The implementation problem is the following: A reference to S object y from within an array [T] object would point to y's T dispatch vector, while a reference from within an array [S] object would point to y's S dispatch vector.
Reference: [Mye95] <author> Andrew.C. Myers. </author> <title> Bidirectional object layout for separate compilation. </title> <booktitle> In OOPSLA '95 Conference Proceedings, </booktitle> <address> Austin, TX, </address> <month> October </month> <year> 1995. </year>
Reference-contexts: Declared type relations provide a finer granularity of type checking than is possible when type relations are derived; also, they allow renaming of methods to resolve conflicts among supertype methods, and can lead to more efficient language implementations <ref> [Mye95] </ref>. For example, string set objects behave differently from string bag objects even though they have the same methods. <p> An assignment x: T := y where y is of type S results in x pointing to a different dispatch vector (a different place in the object's header) than y does. This approach allows for fast method dispatch; details are given in <ref> [Mye94, Mye95] </ref>. The implementation problem is the following: A reference to S object y from within an array [T] object would point to y's T dispatch vector, while a reference from within an array [S] object would point to y's S dispatch vector. <p> A constructor creates an object with a slot for each instance variable of its class and a pointer to a dispatch vector that contains pointers to the object's methods (there might be several dispatch vectors, as discussed in <ref> [Mye95] </ref>); all instance variables are then initialized to the provided values. <p> Our solution is inspired by the way parameterization was implemented for CLU [ALS78]. We assume that code is not recompiled for each actual parameter type, since this approach leads to code duplication. The scheme described here is compatible with selector-table-indexed dispatch schemes <ref> [DMSV89, Mye95, Ros88, Str87] </ref>. A more complete description of our technique can be found in [ML94]. Because parameterized code is shared by all in-stantiations, the key issue is how the code accesses the methods described by the where clauses. For example, consider the mapC class from Figure 6. <p> This slot is located at the same offset in the dispatch vector in all objects of mapC or any subclass of mapC. The where-routines are placed at negative offsets in the dispatch vector, as if they were private methods of the class <ref> [Mye95] </ref>, but negative offsets are not essential. Routines are implemented as if they were objects with a single invoke method. For routines with where clauses, the associated where-routines are appended to the dispatch vector of the routine object.
Reference: [Nel91] <author> Greg Nelson, </author> <title> editor. Systems Programming with Modula-3. </title> <publisher> Prentice-Hall, </publisher> <year> 1991. </year>
Reference-contexts: Thus the instantiation member [int,set [int]] is legal but member [char,set [int]] is not. 3.2 Discussion Some languages with parametric polymorphism do not have a mechanism for stating constraints on type parameters, e.g., C++ templates [ES90] and Modula-3 generics <ref> [Nel91] </ref>. To check that an actual instantiation of a parameterized routine or type is correct, the compiler rewrites the body of the routine or type, replacing the type parameter with the actual type, and then checks the result. <p> Thus, types and routines are implemented by modules, and the question this raises is whether or not modules should be parameterized. Parameterizing modules (as in Modula 3 <ref> [Nel91] </ref>) could be convenient: information about parameters and constraints could be stated just once, in the module header. However, the approach has an important drawback: it does not allow a single module to contain implementations of abstractions with different parameters and different where clauses.
Reference: [RIR93] <author> Noemi Rodrigues, Roberto Ierusalimschy, and Jos e L. Rangel. </author> <title> Types in school. </title> <journal> ACM SIGPLAN Notices, </journal> <volume> 28(8) </volume> <pages> 81-89, </pages> <month> August </month> <year> 1993. </year>
Reference-contexts: Thus string set and string bag are not the same type. Similarly, one type is a subtype of another only if its specification declares this and the declaration is legal. In some object-oriented languages, e.g., Emerald [BHJ + 87], PolyTOIL [BSvG95], and School <ref> [RIR93] </ref>, type relations are derived: two specifications define the same type if they are identical except for the names of the types they are defining, and a type is a subtype of another type if it provides the necessary methods and their signatures conform. <p> First, array [int] is not a subtype of array [comparable] even if int &lt; comparable; we discuss this issue further in Section 4. Second, there are essentially no useful subtypes of comparable, because the contravariance of arguments in the method conformance rules has undesirable consequences <ref> [BHJ + 87, RIR93] </ref>. <p> Having explicit type parameters isn't the whole story, because we still need a way of expressing constraints on allowable parameters. This is the purpose of the where clause. Originally defined in CLU [LSAS77], the where clause has been adapted in Theta (and also in School <ref> [RIR93] </ref>) to an object-oriented language with subtyping. A where clause lists the names and signatures of required methods for the parameters. For example, the where clause in the specification of set indicates that any legal parameter must have an equal method.
Reference: [Ros88] <author> John R. Rose. </author> <title> Fast dispatch mechanisms for stock hardware. </title> <booktitle> In OOPSLA '88 Conference Proceedings, </booktitle> <pages> pages 27-35, </pages> <address> San Diego, CA, </address> <month> October </month> <year> 1988. </year> <note> Published as SIGPLAN Notices 23(11), </note> <month> November, </month> <year> 1988. </year>
Reference-contexts: Our solution is inspired by the way parameterization was implemented for CLU [ALS78]. We assume that code is not recompiled for each actual parameter type, since this approach leads to code duplication. The scheme described here is compatible with selector-table-indexed dispatch schemes <ref> [DMSV89, Mye95, Ros88, Str87] </ref>. A more complete description of our technique can be found in [ML94]. Because parameterized code is shared by all in-stantiations, the key issue is how the code accesses the methods described by the where clauses. For example, consider the mapC class from Figure 6.
Reference: [SCW85] <author> Craig Schaffert, Topher Cooper, and Carrie Wilpolt. </author> <title> Trellis Object-Based Environment, Language Reference Manual. </title> <type> Technical Report DEC-TR-372, </type> <institution> Digital Equipment Corporation, </institution> <month> November </month> <year> 1985. </year> <note> Published as SIGPLAN Notices 21(11), </note> <month> November, </month> <year> 1986. </year>
Reference-contexts: This is the usual definition of conformance <ref> [SCW85, BHJ + 87, Car84] </ref> extended to support exceptions. As discussed by others, e.g., [BHJ + 87], the first two rules are the weakest rules that ensure that static type checking guarantees no run-time type errors.
Reference: [Str87] <author> Bjarne Stroustrup. </author> <title> Multiple inheritance for C++. </title> <booktitle> In Proceedings of the Spring '87 Euro-pean Unix Systems Users's Group Conference, </booktitle> <address> Helsinki, </address> <month> May </month> <year> 1987. </year> <month> 13 </month>
Reference-contexts: Our solution is inspired by the way parameterization was implemented for CLU [ALS78]. We assume that code is not recompiled for each actual parameter type, since this approach leads to code duplication. The scheme described here is compatible with selector-table-indexed dispatch schemes <ref> [DMSV89, Mye95, Ros88, Str87] </ref>. A more complete description of our technique can be found in [ML94]. Because parameterized code is shared by all in-stantiations, the key issue is how the code accesses the methods described by the where clauses. For example, consider the mapC class from Figure 6.
References-found: 24

