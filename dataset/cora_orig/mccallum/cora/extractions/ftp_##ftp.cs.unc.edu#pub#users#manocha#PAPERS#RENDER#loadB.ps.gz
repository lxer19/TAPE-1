URL: ftp://ftp.cs.unc.edu/pub/users/manocha/PAPERS/RENDER/loadB.ps.gz
Refering-URL: http://www.cs.unc.edu/~geom/RENDER/surfacepapers.html
Root-URL: http://www.cs.unc.edu
Title: Scalable Algorithms For Interactive Visualization Of Curved Surfaces  
Author: Subodh Kumar Chun-Fa Chang Dinesh Manocha 
Keyword: Surface tessellation, Load balancing, Real-time rendering, Simulation-based Design, Splines.  
Address: Chapel Hill, NC 27599-3175, USA  
Affiliation: University of North Carolina  Center for Computer Graphics and Scientific Visualization.  
Note: Appeared in Proc. of SuperComputing'96  Supported in part by ARPA ISTO Order No. A410, NSF Grant No. MIP-9306208, an Alfred P. Sloan Foundation Fellowship, ARO Contract P-34982-MA, NSF Grant CCR-9319957, ONR Contract N00014-94-1-07 38, ARPA Contract DABT63-93-C-0048 and NSF/ARPA  
Pubnum: Technical Paper  
Email: Email: fkumar,chang,manochag@cs.unc.edu  
Phone: Ph: (919) 962-1943. Fax: (919) 962-1799.  
Abstract: We present efficient parallel algorithms for interactive display of higher order surfaces on current graphics systems. At each frame, these algorithms approximate the surface by polygons and rasterize them over the graphics pipeline. The time for polygon generation for each surface primitive varies between successive frames and we address issues in distributing the load across processors for different environments. This includes algorithms to statically distribute the primitives to reduce dynamic load imbalance as well a distributed wait-free algorithm for machines on which re-distribution is efficient, e.g. shared memory machine. These algorithms have been implemented on different graphics systems and applied to interactive display of trimmed spline models. In practice, we are able to obtain almost linear speed-ups (as a function of number of processors). Moreover, the distributed wait-free algorithm is faster by 25 30% as compared to static and dynamic schemes. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> S.S. Abi-Ezzi and L.A. Shirman. </author> <title> Tessellation of curved surfaces under highly varying transformations. </title> <booktitle> Proceedings of Eurographics, </booktitle> <pages> pages 385-397, </pages> <year> 1991. </year>
Reference-contexts: The general algorithm, though, is applicable to all objects with dynamically varying load. Recently, a number of polygonization based trimmed spline renderers have been proposed in the literature <ref> [1, 2, 19, 15, 13, 10] </ref>. <p> Although the actual method of this tessellation is not the subject of this paper, a brief introduction is in order. A Bezier surface F of degree m fi n defined by parameters u; v 2 <ref> [0; 1] </ref>, is specified by a mesh of control points C ij ; 0 i m; 0 j n: F (u; v) = i=0 j=0 i (u)B n where the Bernstein polynomial B is given by B n i t i (1 t) ni In addition, trimmed spline surfaces have two
Reference: [2] <author> S.S. Abi-Ezzi and S. Subramaniam. </author> <title> Fast dynamic tessellation of trimmed nurbs surfaces. </title> <journal> Computer Graphics Forum, </journal> <volume> 13(3) </volume> <pages> 107-26, </pages> <year> 1994. </year> <note> Proc. of Eurographics'94. </note>
Reference-contexts: The general algorithm, though, is applicable to all objects with dynamically varying load. Recently, a number of polygonization based trimmed spline renderers have been proposed in the literature <ref> [1, 2, 19, 15, 13, 10] </ref>.
Reference: [3] <author> K. Akeley. </author> <title> Reality Engine Graphics. </title> <booktitle> In Proceedings of ACM Siggraph, </booktitle> <pages> pages 109-116, </pages> <year> 1993. </year>
Reference-contexts: Systems that generate off-line triangular approximation of surfaces need to generate a large number of triangles to ensure good image quality. Although high-end graphics systems can now render millions of polygons per second <ref> [5, 3] </ref>, this is nearly not enough for interactive display of large surface model. To ensure that the graphics unit is not bottled up with too many triangles, ideally we would like to generate the triangles that are likely to be important on screen [13].
Reference: [4] <author> D. Ellsworth, H. Good, and B. Tebbs. </author> <title> Distributing display lists on a multicom-puter. </title> <journal> ACM Computer Graphics, </journal> <volume> 24(2), </volume> <year> 1990. </year> <title> (In Symposium on Interactive 3D Graphics). </title>
Reference-contexts: For dynamic loads, a much more dynamic algorithm is warranted. In the graphics literature a number of algorithms have been proposed for polygonal models and for parallel ray-tracing. In [18, 20, 16] algorithms dividing the primitives in terms of screen-regions are presented. Moreover, <ref> [17, 4, 22] </ref> balance the load in object space. However, these techniques cannot be applied to rendering of higher-order surfaces, as the rendering-cost of a spline surface varies significantly across frames.
Reference: [5] <author> H. Fuchs and J. Poulton et al. </author> <title> Pixel-Planes 5: A heterogeneous multiprocessor graphics system using processor-enhanced memories. </title> <journal> ACM Computer Graphics, </journal> <volume> 23(3) </volume> <pages> 79-88, </pages> <year> 1989. </year> <note> (SIGGRAPH Proceedings). </note>
Reference-contexts: Systems that generate off-line triangular approximation of surfaces need to generate a large number of triangles to ensure good image quality. Although high-end graphics systems can now render millions of polygons per second <ref> [5, 3] </ref>, this is nearly not enough for interactive display of large surface model. To ensure that the graphics unit is not bottled up with too many triangles, ideally we would like to generate the triangles that are likely to be important on screen [13]. <p> Triangle rasterization, and shading is performed on renderer units which contain arrays of 128 by 128 1-bit processors with local memory <ref> [5] </ref> and an instruction sequencer. The processing units are connected by a 160 million word per second ring communications network. The multiple processors shown in the left box are used for tessellation. With a configuration of 25 GPs our load-distribution scheme shows an average speedup of 10%.
Reference: [6] <author> G. Georgiannakis and C. Houstis et. al. </author> <title> Description of the adaptive resource management problem, cost functions and performance objectives. </title> <type> Technical Report TR 130, </type> <institution> The Institute of Computer Science, Foundation for Research and Technology - Hellas, </institution> <year> 1995. </year>
Reference-contexts: The distributed load management algorithm improves the speed-ups to 25 30% on shared-memory graphics systems. We include tables and graphs later in the paper that demonstrate our speed-ups on some specific models. 1.1 Related Work Load-imbalance is an old and well studied problem in parallel and distributed computing. <ref> [6] </ref> offers an excellent survey on load-balancing techniques. If the load is known a priori, it can be optimally allocated to processors in an off-line process, spending little time at run-time to manage load. For dynamic loads, a much more dynamic algorithm is warranted.
Reference: [7] <author> B. Hendrickson and R. Leland. </author> <title> A multilevel algorithm for partitioning graphs. </title> <booktitle> Proc. Supercomputing '95, </booktitle> <year> 1995. </year>
Reference-contexts: If we randomly distribute primitives, say in a round robin manner, to processors, load imbalances of more than 1:50 are not uncommon. A number of load balancing algorithms reduce the problem to graph partitioning <ref> [7, 9] </ref>. All these algorithms assume the existence of a load-graph. To construct such a graph, we must first know the processing cost of each primitive.
Reference: [8] <author> M. Herlihy. </author> <title> A methodology for implementing highly concurrent data objects. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 15(5) </volume> <pages> 745-770, </pages> <year> 1993. </year> <month> 16 </month>
Reference-contexts: However, these techniques cannot be applied to rendering of higher-order surfaces, as the rendering-cost of a spline surface varies significantly across frames. For dynamic load-balancing, in the presence of shared-memory, distributed computing literature presents a number of algorithms to arbitrate shared accesses with consistency <ref> [14, 21, 8] </ref>. Indeed, for each sequential data structure there exists a shared implementation that requires no locks [8]. For example, [8] present a hierarchy of shared objects, with wait-free accesses. However, the objects presented in these papers are more general and do not result in significant performance improvement. <p> For dynamic load-balancing, in the presence of shared-memory, distributed computing literature presents a number of algorithms to arbitrate shared accesses with consistency [14, 21, 8]. Indeed, for each sequential data structure there exists a shared implementation that requires no locks <ref> [8] </ref>. For example, [8] present a hierarchy of shared objects, with wait-free accesses. However, the objects presented in these papers are more general and do not result in significant performance improvement. <p> For dynamic load-balancing, in the presence of shared-memory, distributed computing literature presents a number of algorithms to arbitrate shared accesses with consistency [14, 21, 8]. Indeed, for each sequential data structure there exists a shared implementation that requires no locks <ref> [8] </ref>. For example, [8] present a hierarchy of shared objects, with wait-free accesses. However, the objects presented in these papers are more general and do not result in significant performance improvement.
Reference: [9] <author> G. Karypis and V. Kumar. </author> <title> Multilevel k-way partitioning scheme for irregular graphs. </title> <type> Technical Report TR95-064, </type> <institution> Department of Computer Science, University of Minnesota, </institution> <year> 1995. </year>
Reference-contexts: If we randomly distribute primitives, say in a round robin manner, to processors, load imbalances of more than 1:50 are not uncommon. A number of load balancing algorithms reduce the problem to graph partitioning <ref> [7, 9] </ref>. All these algorithms assume the existence of a load-graph. To construct such a graph, we must first know the processing cost of each primitive.
Reference: [10] <author> R. Klein and W. Straber. </author> <title> Large mesh generation from boundary models with parametric face representation. </title> <booktitle> In Proc. of ACM/Siggraph Symposium on Solid Modeling, </booktitle> <pages> pages 431-440, </pages> <year> 1995. </year>
Reference-contexts: The general algorithm, though, is applicable to all objects with dynamically varying load. Recently, a number of polygonization based trimmed spline renderers have been proposed in the literature <ref> [1, 2, 19, 15, 13, 10] </ref>.
Reference: [11] <author> S. Kumar, S. Krishnan, and D. Manocha. </author> <title> Interactive display of large solid models for walkthroughs. </title> <journal> IEEE Computer Graphics and Applications, </journal> <volume> 16(2) </volume> <pages> 9-11, </pages> <year> 1996. </year>
Reference-contexts: Many applications like interactive walkthroughs and design validation, need to interactively visualize these surface models <ref> [11] </ref>, which means we must render it at more than 15 frames a second. Current renderers of sculptured models on commercial graphics systems, while faster than ever before, are not able to render them in real time for applications involving virtual worlds, walkthroughs and other immersive technologies.
Reference: [12] <author> S. Kumar and D. Manocha. </author> <title> Efficient rendering of trimmed NURBS surfaces. </title> <booktitle> Computer-Aided Design, </booktitle> <volume> 27(7) </volume> <pages> 509-521, </pages> <month> July </month> <year> 1995. </year>
Reference-contexts: In Section 4 we present the load re-distribution algorithm. We consider the 4 problem of real-time display and present the greedy rendering algorithm in Section 5. We discuss its implementation and performance in Section 6. 2 Spline Rendering The spline surfaces are rendered based on the algorithm presented in <ref> [12] </ref>. Given a trimmed spline model, the algorithm represent them as trimmed Bezier surfaces using knot-insertion algorithm. At run-time it tessellates each surface into an appropriate number of triangles at each frame (see Fig. 3). <p> Only those points of the domain that are enclosed by these curves map to the final surface. A brief overview of the tessellation algorithm <ref> [12] </ref> is given below. 1. Perform view-frustum and back-facing surface visibility to eliminate hidden surface. We compute a bounding box around each Bezier surface. If the bounding box does not lie on the screen, the surface is not tessellated.
Reference: [13] <author> S. Kumar, D. Manocha, and A. Lastra. </author> <title> Interactive display of large scale NURBS models. </title> <booktitle> In Symposium on Interactive 3D Graphics, </booktitle> <pages> pages 51-58, </pages> <address> Monterey, CA, </address> <year> 1995. </year>
Reference-contexts: A number of techniques including polygonization, ray-tracing, scan-line conversion and pixel-level subdivision have been proposed for rendering splines. However, in practice, only the algorithms based on polygonization <ref> [13] </ref> are able to achieve close to interactive display on common graphics systems. At each frame, these algorithms approximate the surface using triangles and render those triangles using the graphics pipeline. A typical graphics pipeline is shown in Fig. 1. <p> To ensure that the graphics unit is not bottled up with too many triangles, ideally we would like to generate the triangles that are likely to be important on screen <ref> [13] </ref>. This implies, the set of triangles used to approximate a surface in different frames can be quite different. Thus the cost of tessellating a surface varies dynamically. <p> The general algorithm, though, is applicable to all objects with dynamically varying load. Recently, a number of polygonization based trimmed spline renderers have been proposed in the literature <ref> [1, 2, 19, 15, 13, 10] </ref>. <p> Due to their micro-coded implementation, GL routines are not able to make much use of multiple CPUs. In addition, they do not store triangles, but rather generate them for each frame. Also, our tessellation algorithm itself is more efficient than the one used by GL <ref> [13] </ref>. In practice, our parallelization technique is able to obtain close to 85% of the ideal speedup. Our static load-allocation scheme improves the average frame rate by about 10% as compared to a round robin allocation scheme.
Reference: [14] <author> L. Lamport. </author> <title> A fast mutual exclusion algorithm. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 5(1) </volume> <pages> 1-11, </pages> <year> 1987. </year>
Reference-contexts: However, these techniques cannot be applied to rendering of higher-order surfaces, as the rendering-cost of a spline surface varies significantly across frames. For dynamic load-balancing, in the presence of shared-memory, distributed computing literature presents a number of algorithms to arbitrate shared accesses with consistency <ref> [14, 21, 8] </ref>. Indeed, for each sequential data structure there exists a shared implementation that requires no locks [8]. For example, [8] present a hierarchy of shared objects, with wait-free accesses. However, the objects presented in these papers are more general and do not result in significant performance improvement.
Reference: [15] <author> W.L. Luken and Fuhua Cheng. </author> <title> Rendering trimmed NURB surfaces. </title> <institution> Computer science research report 18669(81711), IBM Research Division, </institution> <year> 1993. </year>
Reference-contexts: The general algorithm, though, is applicable to all objects with dynamically varying load. Recently, a number of polygonization based trimmed spline renderers have been proposed in the literature <ref> [1, 2, 19, 15, 13, 10] </ref>.
Reference: [16] <author> C. Mueller. </author> <title> The sort-first rendering architecture for high-performance graphics. </title> <booktitle> In Symposium on Interactive 3D Graphics, </booktitle> <pages> pages 75-84, </pages> <address> Monterey, CA, </address> <year> 1995. </year>
Reference-contexts: For dynamic loads, a much more dynamic algorithm is warranted. In the graphics literature a number of algorithms have been proposed for polygonal models and for parallel ray-tracing. In <ref> [18, 20, 16] </ref> algorithms dividing the primitives in terms of screen-regions are presented. Moreover, [17, 4, 22] balance the load in object space. However, these techniques cannot be applied to rendering of higher-order surfaces, as the rendering-cost of a spline surface varies significantly across frames.
Reference: [17] <author> Thierry Priol and Kadi Bouatouch. </author> <title> Static load balancing for A parallel ray tracing on a MIMD hypercube. </title> <journal> The Visual Computer, </journal> 5(1/2):109-119, March 1989. 
Reference-contexts: For dynamic loads, a much more dynamic algorithm is warranted. In the graphics literature a number of algorithms have been proposed for polygonal models and for parallel ray-tracing. In [18, 20, 16] algorithms dividing the primitives in terms of screen-regions are presented. Moreover, <ref> [17, 4, 22] </ref> balance the load in object space. However, these techniques cannot be applied to rendering of higher-order surfaces, as the rendering-cost of a spline surface varies significantly across frames.
Reference: [18] <author> D. Roble. </author> <title> A load balanced parallel scan-line z-buffer algorithm for the ipsc hypercube. </title> <booktitle> In Pixim, </booktitle> <pages> pages 177-192, </pages> <address> Paris, France, </address> <year> 1988. </year>
Reference-contexts: For dynamic loads, a much more dynamic algorithm is warranted. In the graphics literature a number of algorithms have been proposed for polygonal models and for parallel ray-tracing. In <ref> [18, 20, 16] </ref> algorithms dividing the primitives in terms of screen-regions are presented. Moreover, [17, 4, 22] balance the load in object space. However, these techniques cannot be applied to rendering of higher-order surfaces, as the rendering-cost of a spline surface varies significantly across frames.
Reference: [19] <author> A. Rockwood, K. Heaton, and T. Davis. </author> <title> Real-time rendering of trimmed surfaces. </title> <journal> ACM Computer Graphics, </journal> <volume> 23(3) </volume> <pages> 107-117, </pages> <year> 1989. </year> <note> (SIGGRAPH Proceedings). </note>
Reference-contexts: The general algorithm, though, is applicable to all objects with dynamically varying load. Recently, a number of polygonization based trimmed spline renderers have been proposed in the literature <ref> [1, 2, 19, 15, 13, 10] </ref>.
Reference: [20] <author> S. Whitman. </author> <title> Dynamic load balancing for parallel polygon rendering. </title> <journal> IEEE Computer Graphics and Applications, </journal> <volume> 14(4) </volume> <pages> 41-48, </pages> <year> 1994. </year>
Reference-contexts: For dynamic loads, a much more dynamic algorithm is warranted. In the graphics literature a number of algorithms have been proposed for polygonal models and for parallel ray-tracing. In <ref> [18, 20, 16] </ref> algorithms dividing the primitives in terms of screen-regions are presented. Moreover, [17, 4, 22] balance the load in object space. However, these techniques cannot be applied to rendering of higher-order surfaces, as the rendering-cost of a spline surface varies significantly across frames.
Reference: [21] <author> J.H. Yang and J. Anderson. </author> <title> Fast, scalable synchronization with minimal hardware support. </title> <booktitle> In ACM symposium on Principles of Distributed Computing, </booktitle> <pages> pages 171-182, </pages> <year> 1993. </year>
Reference-contexts: However, these techniques cannot be applied to rendering of higher-order surfaces, as the rendering-cost of a spline surface varies significantly across frames. For dynamic load-balancing, in the presence of shared-memory, distributed computing literature presents a number of algorithms to arbitrate shared accesses with consistency <ref> [14, 21, 8] </ref>. Indeed, for each sequential data structure there exists a shared implementation that requires no locks [8]. For example, [8] present a hierarchy of shared objects, with wait-free accesses. However, the objects presented in these papers are more general and do not result in significant performance improvement.
Reference: [22] <author> Y. Zheng, D. Kerbyson, and G. Nudd. </author> <title> Efficient load balancing techniques for image analysis on an M-SIMD machine. </title> <type> Technical Report CS-RR-214, </type> <institution> Dept. of CS, University of Warwick, </institution> <year> 1992. </year> <pages> 17 18 </pages>
Reference-contexts: For dynamic loads, a much more dynamic algorithm is warranted. In the graphics literature a number of algorithms have been proposed for polygonal models and for parallel ray-tracing. In [18, 20, 16] algorithms dividing the primitives in terms of screen-regions are presented. Moreover, <ref> [17, 4, 22] </ref> balance the load in object space. However, these techniques cannot be applied to rendering of higher-order surfaces, as the rendering-cost of a spline surface varies significantly across frames.
References-found: 22

