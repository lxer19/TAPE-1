URL: http://ftp.eecs.umich.edu/people/yenmin/icdcs14.ps
Refering-URL: http://ftp.eecs.umich.edu/people/yenmin/
Root-URL: http://www.eecs.umich.edu
Title: Linguistic Support for Controlling Protocol Execution  
Author: Yen-Min Huang Chinya V. Ravishankar 
Address: R.T.P, NC 27715 Ann Arbor, MI 48109-2122  
Affiliation: Experimental Systems Department of EECS IBM Corporation The University of Michigan  
Abstract: Implementing efficient communication protocols is an important task in building distributed systems, but is complicated by the difficulties of dealing with complex multi-thread interactions and timing-related bugs. This paper describes Cicero, a set of language constructs designed to alleviate these difficulties. Cicero uses the notion of event patterns [1] to help programmers build robust protocol implementations. Event patterns provide structure for controlling synchrony, asynchrony, and concurrency in protocol execution, and also allow implementors to exploit parallelism of varying grains. Event patterns can be translated into other formal models, so that existing verification techniques may be used. Our prototype implementation indicates that the total overhead imposed by event patterns accounts for less than 5% of the overall latency for protocols above the transport layer on single-processor implementations. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> C. V Ravishankar and R. Finkel. </author> <title> Linguistic Support for Dataflow. </title> <type> Technical Report CSE-TR-14-89, </type> <institution> Dept. of EECS, The University of Michigan, Ann Arbor, Michigan, </institution> <year> 1989. </year>
Reference-contexts: However, an event-driven model is insufficient because complex relationships between events must be expressed in a structured way. For this purpose, we have borrowed the notion of event patterns from POST <ref> [1] </ref>. Event patterns use event combinators to recursively describe relationships between events. Cicero uses the three event combina-tors "^", ",", and "", to express synchronous, asynchronous, and sequential relationships between events respectively. Event patterns in Cicero have active semantics [1, 17]. <p> Event patterns use event combinators to recursively describe relationships between events. Cicero uses the three event combina-tors "^", ",", and "", to express synchronous, asynchronous, and sequential relationships between events respectively. Event patterns in Cicero have active semantics <ref> [1, 17] </ref>. They behave as safeguards, locally guaranteeing relationships between events, rather than passively detecting these relationships. Our event patterns ensure specified relationships between events before performing actions, rather than detecting some relationships between events and then performing actions as in many other event-driven languages [14, 16]. <p> We have found a restricted dataflow model [18] helpful. An obvious analogy can be drawn between events and data tokens in a dataflow model, where token arrival triggers/fires actions <ref> [1] </ref>. We simply associate event patterns with code segments of the proper granularity. By changing the code granularity, we can change the granularity of parallelism in Cicero. This capability allows programmers to experiment with different granularities in tuning performance. The dataflow model also has other advantages. <p> We refer the reader to [10] for an expanded discussion of material in this section. Cicero integrates the following ideas: * Event Patterns: The semantics of event patterns are borrowed from POST <ref> [1] </ref>, but POST is designed as a general pattern-driven dataflow language, while Cicero is designed for protocol construction. Event patterns are also reminiscent of path expressions [17] and data path expressions [16], but have different us age and semantics. <p> Also, this separation allows Cicero to adopt additional programming abstractions for protocol implementa tion, including the object-based abstraction provided in [20]. * Dataflow Execution Model : Many languages <ref> [1, 21] </ref> and machines [22, 23] have been designed based on this model. Cicero uses this model differently, and primarily to describe event-driven execution at different granularities, and as formalism to allow Cicero to be translated to/from other protocol specification models (e.g.
Reference: [2] <author> K. S. Yap, P. Jalote, and S. Tripathi. </author> <title> Fault Tolerant Remote Procedure Call. </title> <booktitle> In Proc. of 8th International Conference on Distributed Computing Systems, </booktitle> <pages> pages 48-54, </pages> <address> San Jose, CA, </address> <month> June </month> <year> 1988. </year>
Reference-contexts: In the future, more advanced functionality will likely be moved down to protocol implementations to save application development effort. This trend is evident from the recent development of RPCs to include semantics for supporting group communication, transactions, fault-tolerance, etc <ref> [2, 3, 4] </ref>. As new distributed applications continue to emerge, protocol developers will also be challenged to provide correct and efficient implementations managing concurrent I/O channels, and to increase the protocol throughput to meet real-time requirements.
Reference: [3] <author> B. Liskov and R. Scheifler. </author> <title> Guardians and Actions: Linguistic Support for Robust, Distributed Programs. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 5(3) </volume> <pages> 381-404, </pages> <month> July </month> <year> 1983. </year>
Reference-contexts: In the future, more advanced functionality will likely be moved down to protocol implementations to save application development effort. This trend is evident from the recent development of RPCs to include semantics for supporting group communication, transactions, fault-tolerance, etc <ref> [2, 3, 4] </ref>. As new distributed applications continue to emerge, protocol developers will also be challenged to provide correct and efficient implementations managing concurrent I/O channels, and to increase the protocol throughput to meet real-time requirements.
Reference: [4] <author> L. Zahn, T. H. Dineen, P. J. Leach, E. A. Martin, N. W. Mishkin, J. N. Pato, and G. L. Wyant. </author> <title> Network Computing Architecture. </title> <publisher> Prentice-Hall, </publisher> <address> Engle-wood Cliffs, N.J., </address> <year> 1990. </year>
Reference-contexts: In the future, more advanced functionality will likely be moved down to protocol implementations to save application development effort. This trend is evident from the recent development of RPCs to include semantics for supporting group communication, transactions, fault-tolerance, etc <ref> [2, 3, 4] </ref>. As new distributed applications continue to emerge, protocol developers will also be challenged to provide correct and efficient implementations managing concurrent I/O channels, and to increase the protocol throughput to meet real-time requirements.
Reference: [5] <author> G. v. Bochmann, G. Gerbert, and J. M. Serre. </author> <title> Semiautomatic Implementation of Communication Protocols. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 13(9) </volume> <pages> 989-999, </pages> <month> September </month> <year> 1987. </year>
Reference-contexts: We have chosen C as our present target language for Cicero because it is portable and has efficient compilers. Cicero is designed to facilitate hybrid protocol implementation strategies. Protocols can either be implemented by hand or be synthesized from specifications <ref> [5, 6, 7, 8] </ref>. These two approaches represent opposite strategies, and are effective in different situations. We argue that they can be combined, given a good protocol construction language that enables the representation of execution aspects of protocol implementations, but which does not complicate verification.
Reference: [6] <author> J. P. Briand, M. C. Fehri, L. Logrippo, and A. Obaid. </author> <title> Executing LOTOS Specifications. </title> <editor> In B. Sarikaya and G. v. Bochmann, editors, </editor> <title> Protocol Specification, Testing and Verification VI (IFIP/WG 6.1), </title> <address> Amsterdam, The Netherlands, </address> <publisher> North-Holland, </publisher> <year> 1987. </year>
Reference-contexts: We have chosen C as our present target language for Cicero because it is portable and has efficient compilers. Cicero is designed to facilitate hybrid protocol implementation strategies. Protocols can either be implemented by hand or be synthesized from specifications <ref> [5, 6, 7, 8] </ref>. These two approaches represent opposite strategies, and are effective in different situations. We argue that they can be combined, given a good protocol construction language that enables the representation of execution aspects of protocol implementations, but which does not complicate verification.
Reference: [7] <author> J. P. Ansart, P. D. Amer, V. Chari, J. F. Lenotre, L. Lumbroso, E. Mariani, and E. Mattera. </author> <title> Software Tools for Estelle. </title> <editor> In B. Sarikaya and G. v. Bochmann, editors, </editor> <title> Protocol Specification, Testing and Verification VI (IFIP/WG 6.1), </title> <publisher> Amsterdam, The Nether-lands, North-Holland, </publisher> <year> 1987. </year>
Reference-contexts: We have chosen C as our present target language for Cicero because it is portable and has efficient compilers. Cicero is designed to facilitate hybrid protocol implementation strategies. Protocols can either be implemented by hand or be synthesized from specifications <ref> [5, 6, 7, 8] </ref>. These two approaches represent opposite strategies, and are effective in different situations. We argue that they can be combined, given a good protocol construction language that enables the representation of execution aspects of protocol implementations, but which does not complicate verification.
Reference: [8] <author> S. T. Vuong, A. C. Lau, and R. I. Chan. </author> <title> Semiautomatic Implementation of Protocols Using an Estelle-C Compiler. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 14(3) </volume> <pages> 384-393, </pages> <month> March </month> <year> 1988. </year>
Reference-contexts: We have chosen C as our present target language for Cicero because it is portable and has efficient compilers. Cicero is designed to facilitate hybrid protocol implementation strategies. Protocols can either be implemented by hand or be synthesized from specifications <ref> [5, 6, 7, 8] </ref>. These two approaches represent opposite strategies, and are effective in different situations. We argue that they can be combined, given a good protocol construction language that enables the representation of execution aspects of protocol implementations, but which does not complicate verification. <p> Petri nets [19]). * Protocol Specifications: Several Formal Description Techniques (FDT), like LOTOS [12], Estelle [13], and SDL [24], have been developed to specify protocol behavior formally. Much research has been conducted in automatically generating protocol implementations from these FDTs <ref> [8, 25] </ref>. However, the protocol implementations generated by these means are generally in the form of skeletons which must be filled in by programmer code [20]. Also, the efficiency of generated code is a concern [26].
Reference: [9] <author> Y. Huang and C. V. Ravishankar. </author> <title> Designing An Agent Synthesis System for Cross RPC Communication. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 20(3), </volume> <month> March </month> <year> 1994. </year>
Reference-contexts: Our work attempts to combine these two approaches by giving programmers an executable specification language to specify control aspects of protocol execution as well as implementation details. We have implemented Cicero and used it with Nestor <ref> [9] </ref> and the URPC toolkit [10] for describing RPC protocols. Nestor is an agent synthesis and man-agement system for synthesizing cross-RPC gateway agents [11, 9]. URPC (Universal RPC) is a toolkit for prototyping new RPC systems rapidly [10]. <p> We have implemented Cicero and used it with Nestor [9] and the URPC toolkit [10] for describing RPC protocols. Nestor is an agent synthesis and man-agement system for synthesizing cross-RPC gateway agents <ref> [11, 9] </ref>. URPC (Universal RPC) is a toolkit for prototyping new RPC systems rapidly [10]. Experience in these projects has shown that Cicero is effective in implementing a variety of RPC protocols.
Reference: [10] <author> Y. Huang and C. V. Ravishankar. Cicero: </author> <title> A Protocol Construction Language. </title> <type> Technical Report CSE-TR-171-93, </type> <institution> Dept. of EECS, The University of Michigan, Ann Arbor, Michigan, </institution> <year> 1993. </year>
Reference-contexts: Our work attempts to combine these two approaches by giving programmers an executable specification language to specify control aspects of protocol execution as well as implementation details. We have implemented Cicero and used it with Nestor [9] and the URPC toolkit <ref> [10] </ref> for describing RPC protocols. Nestor is an agent synthesis and man-agement system for synthesizing cross-RPC gateway agents [11, 9]. URPC (Universal RPC) is a toolkit for prototyping new RPC systems rapidly [10]. Experience in these projects has shown that Cicero is effective in implementing a variety of RPC protocols. <p> We have implemented Cicero and used it with Nestor [9] and the URPC toolkit <ref> [10] </ref> for describing RPC protocols. Nestor is an agent synthesis and man-agement system for synthesizing cross-RPC gateway agents [11, 9]. URPC (Universal RPC) is a toolkit for prototyping new RPC systems rapidly [10]. Experience in these projects has shown that Cicero is effective in implementing a variety of RPC protocols. Ci-cero offers a better protocol implementation paradigm with little overhead, amounting to less than 5% for protocols above transport layer, even for non-parallel implementations. <p> Petri nets [19]), making it possible to use existing protocol verification methods/tools, and easier to construct tools for generating protocol implementations from existing protocol specifications. These capabilities can further automate protocol implementation and improve the quality of implementation. The translation of event patterns to Petri nets is described in <ref> [10] </ref>. 2.3 The Communication Primitives Several design choices present themselves for communication primitives in Cicero: remote events, new communication constructs, or library calls. However, our goal is to design a language for implementing protocols, not a language for general distributed computing. <p> Scheduling in Cicero is preemptive; however, the scheduling quantum is unspecified. 3.2.4 Event Pattern Semantics Here we describe the semantics of event patterns informally. The formal description can be found in <ref> [10] </ref>. The syntax "P : actions : overflow-actions" denotes an event pattern, associated actions and overflow actions respectively. Let E 1 and E 2 be two event patterns comprising P . <p> We refer the reader to <ref> [10] </ref> for an expanded discussion of material in this section. Cicero integrates the following ideas: * Event Patterns: The semantics of event patterns are borrowed from POST [1], but POST is designed as a general pattern-driven dataflow language, while Cicero is designed for protocol construction.
Reference: [11] <author> Y. Huang and C. V. Ravishankar. </author> <title> Accommodating RPC Heterogeneities in Large Heterogeneous Distributed Environments. </title> <booktitle> In Proc. of the 26th Hawaii International Conference on System Sciences (HICSS-26), </booktitle> <month> January </month> <year> 1993. </year>
Reference-contexts: We have implemented Cicero and used it with Nestor [9] and the URPC toolkit [10] for describing RPC protocols. Nestor is an agent synthesis and man-agement system for synthesizing cross-RPC gateway agents <ref> [11, 9] </ref>. URPC (Universal RPC) is a toolkit for prototyping new RPC systems rapidly [10]. Experience in these projects has shown that Cicero is effective in implementing a variety of RPC protocols. <p> This approach allows developers to customize Cicero for implementing different classes of protocols. For example, we have used Cicero to construct heterogeneous RPC mech-anisms to facilitate the interconnection between the client and server programs speaking different RPC protocols <ref> [11] </ref>.
Reference: [12] <author> ISO. </author> <title> Information Processing Systems Open System Interconnection - LOTOS A Formal Description Technique Based on the Temporal Ordering of Observational Behavior, </title> <year> 1985. </year>
Reference-contexts: It can be effective in implementing protocols in other layers. 2 Design Rationale 2.1 Basic Language Abstractions and Se mantics A natural abstraction for protocols is an event-driven paradigm, which views a protocol as a machine reacting to internal/external events or messages <ref> [12, 13, 14, 15, 16] </ref>. However, an event-driven model is insufficient because complex relationships between events must be expressed in a structured way. For this purpose, we have borrowed the notion of event patterns from POST [1]. Event patterns use event combinators to recursively describe relationships between events. <p> Cicero uses this model differently, and primarily to describe event-driven execution at different granularities, and as formalism to allow Cicero to be translated to/from other protocol specification models (e.g. Petri nets [19]). * Protocol Specifications: Several Formal Description Techniques (FDT), like LOTOS <ref> [12] </ref>, Estelle [13], and SDL [24], have been developed to specify protocol behavior formally. Much research has been conducted in automatically generating protocol implementations from these FDTs [8, 25].
Reference: [13] <author> ISO. </author> <title> Information Processing Systems Open System Interconnection - Estelle (Formal Description Technique Based on an Extended State Transition Model) , 1987. </title>
Reference-contexts: It can be effective in implementing protocols in other layers. 2 Design Rationale 2.1 Basic Language Abstractions and Se mantics A natural abstraction for protocols is an event-driven paradigm, which views a protocol as a machine reacting to internal/external events or messages <ref> [12, 13, 14, 15, 16] </ref>. However, an event-driven model is insufficient because complex relationships between events must be expressed in a structured way. For this purpose, we have borrowed the notion of event patterns from POST [1]. Event patterns use event combinators to recursively describe relationships between events. <p> Cicero uses this model differently, and primarily to describe event-driven execution at different granularities, and as formalism to allow Cicero to be translated to/from other protocol specification models (e.g. Petri nets [19]). * Protocol Specifications: Several Formal Description Techniques (FDT), like LOTOS [12], Estelle <ref> [13] </ref>, and SDL [24], have been developed to specify protocol behavior formally. Much research has been conducted in automatically generating protocol implementations from these FDTs [8, 25].
Reference: [14] <author> G. Berry and G. Gonthier. </author> <title> The Synchronous Programming Language ESTEREL: Design, Semantics, Implementation. </title> <type> Technical Report 842, </type> <institution> INRIA, </institution> <year> 1988. </year>
Reference-contexts: It can be effective in implementing protocols in other layers. 2 Design Rationale 2.1 Basic Language Abstractions and Se mantics A natural abstraction for protocols is an event-driven paradigm, which views a protocol as a machine reacting to internal/external events or messages <ref> [12, 13, 14, 15, 16] </ref>. However, an event-driven model is insufficient because complex relationships between events must be expressed in a structured way. For this purpose, we have borrowed the notion of event patterns from POST [1]. Event patterns use event combinators to recursively describe relationships between events. <p> They behave as safeguards, locally guaranteeing relationships between events, rather than passively detecting these relationships. Our event patterns ensure specified relationships between events before performing actions, rather than detecting some relationships between events and then performing actions as in many other event-driven languages <ref> [14, 16] </ref>. For example, in Cicero, the event pattern (a b) sequences the order of events a and b, delivering a first. If event b actually occurs first, its delivery is delayed until event a has first been delivered. <p> Data path expressions [16] provide passive pattern-matching semantics. * Event-Driven Abstraction : Our event-driven model is similar to the notion of event flows in ESTEREL <ref> [14] </ref>, and to some concepts in Actor [15]. However, neither system includes event patterns, which express complex relationships between events for controlling the execution.
Reference: [15] <author> G. Agha. </author> <title> Actors: A Model of Concurrent Computation in Distributed Systems. </title> <publisher> MIT Press, </publisher> <address> Cambridge, Mass., </address> <year> 1986. </year>
Reference-contexts: It can be effective in implementing protocols in other layers. 2 Design Rationale 2.1 Basic Language Abstractions and Se mantics A natural abstraction for protocols is an event-driven paradigm, which views a protocol as a machine reacting to internal/external events or messages <ref> [12, 13, 14, 15, 16] </ref>. However, an event-driven model is insufficient because complex relationships between events must be expressed in a structured way. For this purpose, we have borrowed the notion of event patterns from POST [1]. Event patterns use event combinators to recursively describe relationships between events. <p> Data path expressions [16] provide passive pattern-matching semantics. * Event-Driven Abstraction : Our event-driven model is similar to the notion of event flows in ESTEREL [14], and to some concepts in Actor <ref> [15] </ref>. However, neither system includes event patterns, which express complex relationships between events for controlling the execution.
Reference: [16] <author> W. Hseush and G. E. Kaiser. </author> <title> Modeling Concur-rency in Parallel Debugging. </title> <booktitle> In Proc. of 2nd ACM SIGLPAN Symposium on Principles and Practice of Parallel Programming, </booktitle> <pages> pages 11-20, </pages> <month> March </month> <year> 1990. </year>
Reference-contexts: It can be effective in implementing protocols in other layers. 2 Design Rationale 2.1 Basic Language Abstractions and Se mantics A natural abstraction for protocols is an event-driven paradigm, which views a protocol as a machine reacting to internal/external events or messages <ref> [12, 13, 14, 15, 16] </ref>. However, an event-driven model is insufficient because complex relationships between events must be expressed in a structured way. For this purpose, we have borrowed the notion of event patterns from POST [1]. Event patterns use event combinators to recursively describe relationships between events. <p> They behave as safeguards, locally guaranteeing relationships between events, rather than passively detecting these relationships. Our event patterns ensure specified relationships between events before performing actions, rather than detecting some relationships between events and then performing actions as in many other event-driven languages <ref> [14, 16] </ref>. For example, in Cicero, the event pattern (a b) sequences the order of events a and b, delivering a first. If event b actually occurs first, its delivery is delayed until event a has first been delivered. <p> Cicero integrates the following ideas: * Event Patterns: The semantics of event patterns are borrowed from POST [1], but POST is designed as a general pattern-driven dataflow language, while Cicero is designed for protocol construction. Event patterns are also reminiscent of path expressions [17] and data path expressions <ref> [16] </ref>, but have different us age and semantics. Event patterns are used to specify when to execute a piece of code, while path expressions are used to specify the synchronization constraints on how procedures can be executed. <p> Data path expressions <ref> [16] </ref> provide passive pattern-matching semantics. * Event-Driven Abstraction : Our event-driven model is similar to the notion of event flows in ESTEREL [14], and to some concepts in Actor [15]. However, neither system includes event patterns, which express complex relationships between events for controlling the execution.
Reference: [17] <author> R. H. Campbell and A. N. Habermann. </author> <title> The Specification of Process Synchronization by Path Expression. </title> <booktitle> In Lecture Notes in Computer Science, </booktitle> <volume> volume 16, </volume> <pages> pages 89-102, </pages> <address> New York, 1974. </address> <publisher> Springer-Verlag. </publisher>
Reference-contexts: Event patterns use event combinators to recursively describe relationships between events. Cicero uses the three event combina-tors "^", ",", and "", to express synchronous, asynchronous, and sequential relationships between events respectively. Event patterns in Cicero have active semantics <ref> [1, 17] </ref>. They behave as safeguards, locally guaranteeing relationships between events, rather than passively detecting these relationships. Our event patterns ensure specified relationships between events before performing actions, rather than detecting some relationships between events and then performing actions as in many other event-driven languages [14, 16]. <p> Cicero integrates the following ideas: * Event Patterns: The semantics of event patterns are borrowed from POST [1], but POST is designed as a general pattern-driven dataflow language, while Cicero is designed for protocol construction. Event patterns are also reminiscent of path expressions <ref> [17] </ref> and data path expressions [16], but have different us age and semantics. Event patterns are used to specify when to execute a piece of code, while path expressions are used to specify the synchronization constraints on how procedures can be executed.
Reference: [18] <author> R. M. Karp and R. E. Miller. </author> <title> Properties of a Model for Parallel Computation: Determinacy, Termination, Queueing. </title> <journal> SIAM Journal of App. Math, </journal> <pages> pages 1390-1411, </pages> <month> November </month> <year> 1966. </year>
Reference-contexts: We have found a restricted dataflow model <ref> [18] </ref> helpful. An obvious analogy can be drawn between events and data tokens in a dataflow model, where token arrival triggers/fires actions [1]. We simply associate event patterns with code segments of the proper granularity. By changing the code granularity, we can change the granularity of parallelism in Cicero.
Reference: [19] <author> K. M. Kavi, B. P. Buckles, and U. N. Bhat. </author> <title> Isomorphism Between Petri nets and Dataflow Graphs. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 13(10) </volume> <pages> 1127-1134, </pages> <month> October </month> <year> 1987. </year>
Reference-contexts: By changing the code granularity, we can change the granularity of parallelism in Cicero. This capability allows programmers to experiment with different granularities in tuning performance. The dataflow model also has other advantages. First, it is mathematically well-defined <ref> [19] </ref> and well-understood. Second, it can be translated to/from other formal models (e.g. Petri nets [19]), making it possible to use existing protocol verification methods/tools, and easier to construct tools for generating protocol implementations from existing protocol specifications. <p> This capability allows programmers to experiment with different granularities in tuning performance. The dataflow model also has other advantages. First, it is mathematically well-defined <ref> [19] </ref> and well-understood. Second, it can be translated to/from other formal models (e.g. Petri nets [19]), making it possible to use existing protocol verification methods/tools, and easier to construct tools for generating protocol implementations from existing protocol specifications. These capabilities can further automate protocol implementation and improve the quality of implementation. <p> Cicero uses this model differently, and primarily to describe event-driven execution at different granularities, and as formalism to allow Cicero to be translated to/from other protocol specification models (e.g. Petri nets <ref> [19] </ref>). * Protocol Specifications: Several Formal Description Techniques (FDT), like LOTOS [12], Estelle [13], and SDL [24], have been developed to specify protocol behavior formally. Much research has been conducted in automatically generating protocol implementations from these FDTs [8, 25].
Reference: [20] <author> M. B. Abbott and L. L. Peterson. </author> <title> A Language-Based Approach to Protocol Implementation. </title> <journal> IEEE/ACM Transactions on Networking, </journal> <volume> 1(1) </volume> <pages> 4-19, </pages> <month> February </month> <year> 1993. </year>
Reference-contexts: Remote communication must often deal with the additional problem of partial failures, and the re silience of failure can vary greatly across protocols. Also, this separation allows Cicero to adopt additional programming abstractions for protocol implementa tion, including the object-based abstraction provided in <ref> [20] </ref>. * Dataflow Execution Model : Many languages [1, 21] and machines [22, 23] have been designed based on this model. Cicero uses this model differently, and primarily to describe event-driven execution at different granularities, and as formalism to allow Cicero to be translated to/from other protocol specification models (e.g. <p> Much research has been conducted in automatically generating protocol implementations from these FDTs [8, 25]. However, the protocol implementations generated by these means are generally in the form of skeletons which must be filled in by programmer code <ref> [20] </ref>. Also, the efficiency of generated code is a concern [26].
Reference: [21] <author> W. W. Wadge and E. A. Ashcroft. </author> <title> Lucid, the Dataflow Programming Language. </title> <publisher> Academic Press U.K., </publisher> <year> 1985. </year>
Reference-contexts: Also, this separation allows Cicero to adopt additional programming abstractions for protocol implementa tion, including the object-based abstraction provided in [20]. * Dataflow Execution Model : Many languages <ref> [1, 21] </ref> and machines [22, 23] have been designed based on this model. Cicero uses this model differently, and primarily to describe event-driven execution at different granularities, and as formalism to allow Cicero to be translated to/from other protocol specification models (e.g.
Reference: [22] <author> W. W. Hwu and Y. Patt. HPSm, </author> <title> a High Performance Restricted Data Flow Architecture having Minimal Functionality. </title> <booktitle> In The 13th International Symposium on Computer Architecture Conference Proceedings, </booktitle> <pages> pages 297-306, </pages> <month> June </month> <year> 1986. </year>
Reference-contexts: Also, this separation allows Cicero to adopt additional programming abstractions for protocol implementa tion, including the object-based abstraction provided in [20]. * Dataflow Execution Model : Many languages [1, 21] and machines <ref> [22, 23] </ref> have been designed based on this model. Cicero uses this model differently, and primarily to describe event-driven execution at different granularities, and as formalism to allow Cicero to be translated to/from other protocol specification models (e.g.
Reference: [23] <author> M. Johnson. </author> <title> Superscalar Microprocessor Design. </title> <publisher> Prentice-Hall, </publisher> <address> Englewood Cliffs, N.J., </address> <year> 1991. </year>
Reference-contexts: Also, this separation allows Cicero to adopt additional programming abstractions for protocol implementa tion, including the object-based abstraction provided in [20]. * Dataflow Execution Model : Many languages [1, 21] and machines <ref> [22, 23] </ref> have been designed based on this model. Cicero uses this model differently, and primarily to describe event-driven execution at different granularities, and as formalism to allow Cicero to be translated to/from other protocol specification models (e.g.
Reference: [24] <author> CCITT. </author> <title> Specification and Description Language - Recommendation Z.100 , 1986. </title>
Reference-contexts: Cicero uses this model differently, and primarily to describe event-driven execution at different granularities, and as formalism to allow Cicero to be translated to/from other protocol specification models (e.g. Petri nets [19]). * Protocol Specifications: Several Formal Description Techniques (FDT), like LOTOS [12], Estelle [13], and SDL <ref> [24] </ref>, have been developed to specify protocol behavior formally. Much research has been conducted in automatically generating protocol implementations from these FDTs [8, 25]. However, the protocol implementations generated by these means are generally in the form of skeletons which must be filled in by programmer code [20].
Reference: [25] <author> A. Valenzano, R. Sisto, and L. Ciminiera. </author> <title> Rapid Prototyping of Protocols from LOTOS Specification. </title> <journal> Software Practice and Experience, </journal> <volume> 23(1) </volume> <pages> 31-54, </pages> <month> Jan-uary </month> <year> 1993. </year>
Reference-contexts: Petri nets [19]). * Protocol Specifications: Several Formal Description Techniques (FDT), like LOTOS [12], Estelle [13], and SDL [24], have been developed to specify protocol behavior formally. Much research has been conducted in automatically generating protocol implementations from these FDTs <ref> [8, 25] </ref>. However, the protocol implementations generated by these means are generally in the form of skeletons which must be filled in by programmer code [20]. Also, the efficiency of generated code is a concern [26].
Reference: [26] <author> L. Svobodova. </author> <title> Implementing OSI Systems. </title> <journal> IEEE Journal on Selected Areas in Communications, </journal> <volume> 7(7) </volume> <pages> 1115-1130, </pages> <month> September </month> <year> 1989. </year>
Reference-contexts: Much research has been conducted in automatically generating protocol implementations from these FDTs [8, 25]. However, the protocol implementations generated by these means are generally in the form of skeletons which must be filled in by programmer code [20]. Also, the efficiency of generated code is a concern <ref> [26] </ref>. Cicero is designed as an executable specification language to allow programmers to have direct control over generated code, and requires no additional patching to the generated code. 7 Implementation and Performance Our Cicero implementation includes the Cicero compiler and the Cicero runtime library.
Reference: [27] <author> Sun Microsystems. </author> <title> Programming Utilities and Libraries, </title> <month> March </month> <year> 1990. </year>
Reference-contexts: Each when construct is compiled to a procedure and executed as a thread. The Cicero runtime library does not provide its own thread package, since thread packages are often platform-dependent. It provides interfaces to existing thread packages instead. Currently, the runtime library supports interfaces to SUN LWP <ref> [27] </ref>, and UNIX Cthreads [28]. when required, the Cicero runtime can also operate with no threads by calling the when constructs in order. The control mechanism and the underlying thread package are the two sources of overhead.
Reference: [28] <author> K. Schwan, H. Forbes, A. Gheith, B. Mukherjee, and Y. Samiotakis. </author> <title> A CThread Library for Multiprocessors. </title> <type> Technical Report GIT-ICS-91/02, </type> <institution> College of Computing, Georgia Institute of Technology, </institution> <year> 1991. </year>
Reference-contexts: The Cicero runtime library does not provide its own thread package, since thread packages are often platform-dependent. It provides interfaces to existing thread packages instead. Currently, the runtime library supports interfaces to SUN LWP [27], and UNIX Cthreads <ref> [28] </ref>. when required, the Cicero runtime can also operate with no threads by calling the when constructs in order. The control mechanism and the underlying thread package are the two sources of overhead. The first overhead includes that of for emitting event instances and executing event patterns.
References-found: 28

