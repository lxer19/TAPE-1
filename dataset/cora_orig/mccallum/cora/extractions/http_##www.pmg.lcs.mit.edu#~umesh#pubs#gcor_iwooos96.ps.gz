URL: http://www.pmg.lcs.mit.edu/~umesh/pubs/gcor_iwooos96.ps.gz
Refering-URL: http://www.pmg.lcs.mit.edu/~umesh/pubs/
Root-URL: 
Title: Partitioned Garbage Collection of a Large Stable Heap (Extended Abstract)  
Author: Barbara Liskov Umesh Maheshwari Tony Ng 
Address: Cambridge, MA 02139  
Affiliation: MIT Laboratory for Computer Science,  
Abstract: This paper describes a new garbage collection scheme for large persistent object stores. The scheme makes efficient use of the disk and main memory and does not delay applications. The heap is divided into partitions that are collected independently using stable information about inter-partition references. We use novel techniques to maintain this information using in-memory data structures and a log to avoid disk accesses. The result is a scheme that truly preserves the localized and scalable nature of partitioned collection. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> L. Amsaleg, O. Gruber, and M. Franklin. </author> <title> Efficient incremental garbage collection for workstation-server database systems. </title> <booktitle> In Proc. 21st VLDB. </booktitle> <publisher> ACM Press, </publisher> <year> 1995. </year>
Reference-contexts: Schemes that trace the entire heap (e.g., [2, 8, 18]) do not scale to very large heaps because the non-local nature of garbage collection causes random disk accesses. Therefore, some systems partition the heap into independently collectible areas <ref> [4, 7, 21, 1, 15, 5] </ref>. This is also the approach taken in many distributed system, e.g. [10, 9, 13, 19]. <p> Increasing the partition size helps reduce inter-partition references, but tracing large partitions slows both the garbage collector and the applications due to increased contention for the cache and disk <ref> [1] </ref>. We present a new partitioned scheme that uses a log and in-memory data structures to provide the following benefits: 1. Disk accesses for reading and updating information about inter-partition references are deferred and batched. 2. <p> Like a page, a segment is stored contiguously on disk and is the unit of disk access. A segment provides opaque references for its objects, so that objects can be compacted within their segment without having to update references to them stored in other objects (as in <ref> [1] </ref>). References need not be completely opaque; for example, in Thor, a reference contains the segment number of the referenced object so that objects can be located efficiently without a global object table. Objects in the heap may contain references to other objects. <p> Most generational schemes solve this problem by remembering the exact objects or locations in other partitions that refer to a given object [20], but this is too much information to maintain in a large heap. Therefore, we compact objects within each segment and thus preserve object names, as in <ref> [1] </ref>. Note that objects that are not referenced from other partitions or the applications (as indicated by the root set) could indeed be moved to other segments within the partition.
Reference: [2] <author> H. G. Baker. </author> <title> List processing in real-time on a serial computer. </title> <journal> CACM, </journal> <volume> 21(4) </volume> <pages> 280-94, </pages> <year> 1978. </year>
Reference-contexts: In these systems, the heap resides on the disk because it is much larger than the main memory and must be recoverable after a crash. Applications access the objects through a memory cache and log updates for crash recovery. Schemes that trace the entire heap (e.g., <ref> [2, 8, 18] </ref>) do not scale to very large heaps because the non-local nature of garbage collection causes random disk accesses. Therefore, some systems partition the heap into independently collectible areas [4, 7, 21, 1, 15, 5].
Reference: [3] <author> H. G. Baker. </author> <title> `Infant mortality' and generational garbage collection. </title> <journal> ACM SIGPLAN Notices, </journal> <volume> 28(4), </volume> <year> 1993. </year>
Reference-contexts: This is also the approach taken in many distributed system, e.g. [10, 9, 13, 19]. Generational collectors are a variant of partitioned collection that use the ages of objects to optimize the collection of younger, smaller partitions [11]; however, the age-based heuristics are not applicable to persistent stores <ref> [3] </ref>. A problem with partitioned collection is the efficient maintenance of information about inter-partition references, which is needed to trace partitions independently. For a large heap with many partitions, and also for fast crash recovery, Contact: umesh@lcs.mit.edu.
Reference: [4] <author> P. B. Bishop. </author> <title> Computer systems with a very large address space and garbage collection. </title> <type> Technical Report MIT/LCS/TR-178, </type> <institution> MIT, </institution> <year> 1977. </year>
Reference-contexts: Schemes that trace the entire heap (e.g., [2, 8, 18]) do not scale to very large heaps because the non-local nature of garbage collection causes random disk accesses. Therefore, some systems partition the heap into independently collectible areas <ref> [4, 7, 21, 1, 15, 5] </ref>. This is also the approach taken in many distributed system, e.g. [10, 9, 13, 19].
Reference: [5] <author> J. E. Cook, A. W. Klauser, A. L. Wolf, and B. G. Zorn. Semiautomatic, </author> <title> self-adaptive control of garbage collection rates in object databases. </title> <booktitle> In Proc. 1996 SIGMOD. </booktitle> <publisher> ACM Press, </publisher> <year> 1996. </year>
Reference-contexts: Schemes that trace the entire heap (e.g., [2, 8, 18]) do not scale to very large heaps because the non-local nature of garbage collection causes random disk accesses. Therefore, some systems partition the heap into independently collectible areas <ref> [4, 7, 21, 1, 15, 5] </ref>. This is also the approach taken in many distributed system, e.g. [10, 9, 13, 19].
Reference: [6] <author> J. E. Cook, A. L. Wolf, and B. G. Zorn. </author> <title> Partition selection policies in object databases garbage collection. </title> <booktitle> In Proc. 1994 SIGMOD. </booktitle> <publisher> ACM Press, </publisher> <year> 1994. </year>
Reference-contexts: The generation of the various lists is shown in Figure 1. 3.4 Collecting a Partition Any policy may be used to select partitions for collection. (Studies have shown that it is desirable to be flexible in selecting partitions <ref> [6] </ref>.) To trace a selected partition, we load its segments into the cache and process the log completely to generate the partition's full potential inlist. Since a partition is a fraction (say, 10%) of the cache, it does not disturb the cache much when loaded. The Roots.
Reference: [7] <author> R. L. Hudson and J. E. B. Moss. </author> <title> Incremental garbage collection for mature objects. </title> <booktitle> In Proc. IWMM, volume 637 of Lecture Notes in Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1992. </year>
Reference-contexts: Schemes that trace the entire heap (e.g., [2, 8, 18]) do not scale to very large heaps because the non-local nature of garbage collection causes random disk accesses. Therefore, some systems partition the heap into independently collectible areas <ref> [4, 7, 21, 1, 15, 5] </ref>. This is also the approach taken in many distributed system, e.g. [10, 9, 13, 19]. <p> In particular, maintaining this information for a large heap on disk requires efficient use of memory and disk. However, the only other work that addresses this issue is PMOS by Moss et al. <ref> [7, 15] </ref>. PMOS collects segments independently; a segment is the unit of fetching and tracing. Each segment contains an inlist, which identifies the source segments that contain references to any given object; such inlists take more space than reference counts.
Reference: [8] <author> E. K. Kolodner and W. E. Weihl. </author> <title> Atomic incremental garbage collection and recovery for large stable heap. </title> <booktitle> In Proc. 1993 SIGMOD, </booktitle> <pages> pages 177-186, </pages> <year> 1993. </year>
Reference-contexts: In these systems, the heap resides on the disk because it is much larger than the main memory and must be recoverable after a crash. Applications access the objects through a memory cache and log updates for crash recovery. Schemes that trace the entire heap (e.g., <ref> [2, 8, 18] </ref>) do not scale to very large heaps because the non-local nature of garbage collection causes random disk accesses. Therefore, some systems partition the heap into independently collectible areas [4, 7, 21, 1, 15, 5].
Reference: [9] <author> R. Ladin and B. Liskov. </author> <title> Garbage collection of a distributed heap. </title> <booktitle> In Proc. International Conference on Distributed Computing Systems. </booktitle> <publisher> IEEE Press, </publisher> <year> 1992. </year>
Reference-contexts: Therefore, some systems partition the heap into independently collectible areas [4, 7, 21, 1, 15, 5]. This is also the approach taken in many distributed system, e.g. <ref> [10, 9, 13, 19] </ref>. Generational collectors are a variant of partitioned collection that use the ages of objects to optimize the collection of younger, smaller partitions [11]; however, the age-based heuristics are not applicable to persistent stores [3].
Reference: [10] <author> B. Lang, C. Queinniec, and J. Piquer. </author> <title> Garbage collecting the world. </title> <booktitle> In Proc. POPL '92, </booktitle> <pages> pages 39-50. </pages> <publisher> ACM Press, </publisher> <year> 1992. </year>
Reference-contexts: Therefore, some systems partition the heap into independently collectible areas [4, 7, 21, 1, 15, 5]. This is also the approach taken in many distributed system, e.g. <ref> [10, 9, 13, 19] </ref>. Generational collectors are a variant of partitioned collection that use the ages of objects to optimize the collection of younger, smaller partitions [11]; however, the age-based heuristics are not applicable to persistent stores [3].
Reference: [11] <author> H. Lieberman and C. E. Hewitt. </author> <title> A real-time garbage collector based on the lifetimes of objects. </title> <journal> CACM, </journal> <volume> 26(6) </volume> <pages> 419-29, </pages> <year> 1983. </year>
Reference-contexts: This is also the approach taken in many distributed system, e.g. [10, 9, 13, 19]. Generational collectors are a variant of partitioned collection that use the ages of objects to optimize the collection of younger, smaller partitions <ref> [11] </ref>; however, the age-based heuristics are not applicable to persistent stores [3]. A problem with partitioned collection is the efficient maintenance of information about inter-partition references, which is needed to trace partitions independently. For a large heap with many partitions, and also for fast crash recovery, Contact: umesh@lcs.mit.edu.
Reference: [12] <author> B. Liskov, A. Adya, M. Castro, M. Day, S. Ghemawat, R. Gruber, U. Maheshwari, A. Myers, and L. Shrira. </author> <title> Safe and efficient sharing of persistent objects in Thor. </title> <booktitle> In Proc. 1996 SIGMOD. </booktitle> <publisher> ACM Press, </publisher> <year> 1996. </year>
Reference-contexts: The overall effect is that the collector makes infrequent and localized accesses to the disk. In particular, to collect a partition, only that partition and the information about inter-partition references concerning its objects, need be read/written to disk. The scheme has been partially implemented within Thor <ref> [12, 17] </ref>. We have also extended it with a global incremental marking scheme that allows collection of inter-partition cyclic garbage [14]. One other scheme, PMOS [15], makes use of a log to defer and batch processing of information about inter-partition references. We compare the two approaches in Section 4.
Reference: [13] <author> U. Maheshwari and B. Liskov. </author> <title> Fault-tolerant distributed garbage collection in a client-server object-oriented database. </title> <booktitle> In Proc. 3rd Parallel and Distributed Information Systems. </booktitle> <publisher> IEEE Press, </publisher> <year> 1994. </year>
Reference-contexts: Therefore, some systems partition the heap into independently collectible areas [4, 7, 21, 1, 15, 5]. This is also the approach taken in many distributed system, e.g. <ref> [10, 9, 13, 19] </ref>. Generational collectors are a variant of partitioned collection that use the ages of objects to optimize the collection of younger, smaller partitions [11]; however, the age-based heuristics are not applicable to persistent stores [3].
Reference: [14] <author> U. Maheshwari, B. Liskov, and T. Ng. </author> <title> Partitioned garbage collection of a large stable heap. </title> <type> Technical Report MIT/LCS/TR-699, </type> <institution> MIT LCS, </institution> <year> 1996. </year>
Reference-contexts: The scheme has been partially implemented within Thor [12, 17]. We have also extended it with a global incremental marking scheme that allows collection of inter-partition cyclic garbage <ref> [14] </ref>. One other scheme, PMOS [15], makes use of a log to defer and batch processing of information about inter-partition references. We compare the two approaches in Section 4. The remainder of the paper is organized as follows. Section 2 describes the system model. Section 3 describes partitioned collection. <p> Thus, multiple segments may be accessed while collecting a segment. Our scheme collects inter-partition cyclic garbage using an incremental global marking scheme that preserves the locality of partitioned collection <ref> [14] </ref>.
Reference: [15] <author> J. E. B. Moss, D. S. Munro, and R. L. Hudson. Pmos: </author> <title> A complete and coarse-grained incremental garbage collector for persistent object stores. </title> <booktitle> In Proc. 7th Workshop on Persistent Object Systems, </booktitle> <year> 1996. </year>
Reference-contexts: Schemes that trace the entire heap (e.g., [2, 8, 18]) do not scale to very large heaps because the non-local nature of garbage collection causes random disk accesses. Therefore, some systems partition the heap into independently collectible areas <ref> [4, 7, 21, 1, 15, 5] </ref>. This is also the approach taken in many distributed system, e.g. [10, 9, 13, 19]. <p> The scheme has been partially implemented within Thor [12, 17]. We have also extended it with a global incremental marking scheme that allows collection of inter-partition cyclic garbage [14]. One other scheme, PMOS <ref> [15] </ref>, makes use of a log to defer and batch processing of information about inter-partition references. We compare the two approaches in Section 4. The remainder of the paper is organized as follows. Section 2 describes the system model. Section 3 describes partitioned collection. <p> In particular, maintaining this information for a large heap on disk requires efficient use of memory and disk. However, the only other work that addresses this issue is PMOS by Moss et al. <ref> [7, 15] </ref>. PMOS collects segments independently; a segment is the unit of fetching and tracing. Each segment contains an inlist, which identifies the source segments that contain references to any given object; such inlists take more space than reference counts.
Reference: [16] <author> S. M. Nettles, J. W. O'Toole, D. Pierce, and N. Haines. </author> <title> Replication-based incremental copying collection. </title> <booktitle> In Proc. IWMM, volume 637 of Lecture Notes in Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1992. </year>
Reference-contexts: Tracing Scheme. Our approach can be used in combination with various tracing schemes. For example, we could use a replicating collector like that described in <ref> [16] </ref>, in which applications access the old copies of segments while the collector is generating the new ones with the aid of the modification log. Such a scheme requires little synchronization with applications, but needs space for two partitions in primary memory.
Reference: [17] <author> T. Ng. </author> <title> Efficient garbage collection for large object-oriented databases. </title> <type> Technical Report MIT/LCS/TR-692, </type> <institution> MIT LCS, </institution> <year> 1996. </year>
Reference-contexts: The overall effect is that the collector makes infrequent and localized accesses to the disk. In particular, to collect a partition, only that partition and the information about inter-partition references concerning its objects, need be read/written to disk. The scheme has been partially implemented within Thor <ref> [12, 17] </ref>. We have also extended it with a global incremental marking scheme that allows collection of inter-partition cyclic garbage [14]. One other scheme, PMOS [15], makes use of a log to defer and batch processing of information about inter-partition references. We compare the two approaches in Section 4.
Reference: [18] <author> J. W. O'Toole, S. M. Nettles, and D. Gifford. </author> <title> Concurrent compacting garbage collection of a persistent heap. </title> <booktitle> In Proc. 14th SOSP, </booktitle> <pages> pages 161-174, </pages> <year> 1993. </year>
Reference-contexts: In these systems, the heap resides on the disk because it is much larger than the main memory and must be recoverable after a crash. Applications access the objects through a memory cache and log updates for crash recovery. Schemes that trace the entire heap (e.g., <ref> [2, 8, 18] </ref>) do not scale to very large heaps because the non-local nature of garbage collection causes random disk accesses. Therefore, some systems partition the heap into independently collectible areas [4, 7, 21, 1, 15, 5].
Reference: [19] <author> M. Shapiro and P. Ferreira. Larchant-RDOSS: </author> <title> a distributed shared persistent memory and its garbage collector. </title> <booktitle> In Proc. Workshop on Distributed Algorithms, number 972 in Lecture Notes in Computer Science, </booktitle> <pages> pages 198-214. </pages> <publisher> Springer-Verlag, </publisher> <year> 1995. </year>
Reference-contexts: Therefore, some systems partition the heap into independently collectible areas [4, 7, 21, 1, 15, 5]. This is also the approach taken in many distributed system, e.g. <ref> [10, 9, 13, 19] </ref>. Generational collectors are a variant of partitioned collection that use the ages of objects to optimize the collection of younger, smaller partitions [11]; however, the age-based heuristics are not applicable to persistent stores [3].
Reference: [20] <author> D. M. Ungar. </author> <title> Generation scavenging: A non-disruptive high performance storage reclamation algorithm. </title> <journal> ACM SIGPLAN Notices, </journal> <volume> 19(5) </volume> <pages> 157-167, </pages> <year> 1984. </year>
Reference-contexts: Most generational schemes solve this problem by remembering the exact objects or locations in other partitions that refer to a given object <ref> [20] </ref>, but this is too much information to maintain in a large heap. Therefore, we compact objects within each segment and thus preserve object names, as in [1].
Reference: [21] <author> V. Yong, J. Naughton, and J. Yu. </author> <title> Storage reclamation and reorganization in clinet-server persistent object stores. </title> <booktitle> In Proc. Data Engineering, </booktitle> <pages> pages 120-133. </pages> <publisher> IEEE Press, </publisher> <year> 1994. </year>
Reference-contexts: Schemes that trace the entire heap (e.g., [2, 8, 18]) do not scale to very large heaps because the non-local nature of garbage collection causes random disk accesses. Therefore, some systems partition the heap into independently collectible areas <ref> [4, 7, 21, 1, 15, 5] </ref>. This is also the approach taken in many distributed system, e.g. [10, 9, 13, 19].
References-found: 21

