URL: ftp://ftp.cs.toronto.edu/pub/bonner/papers/hypotheticals/naclp90.ps
Refering-URL: http://www.cs.toronto.edu/DB/people/bonner/papers.html
Root-URL: 
Email: bonner@paul.rutgers.edu mccarty@cs.rutgers.edu  
Title: Adding Negation-as-Failure to Intuitionistic Logic Programming  
Author: Anthony J. Bonner L. Thorne McCarty 
Address: New Brunswick, NJ 08903  
Affiliation: Rutgers University Department of Computer Science  
Abstract: Intuitionistic logic programming is an extension of Horn-clause logic programming in which implications may appear "embedded" on the right-hand side of a rule. Thus, rules of the form A(x) [B(x) C(x)] are allowed. These rules are called embedded implications. In this paper, we develop a language in which negation-as-failure is combined with embedded implications in a principled way. Although this combination has been studied by other researchers, Gabbay has argued in [10] that the entire idea is logically incoherent since modus ponens would not be valid in such a system. We show how to solve this problem by drawing a distinction between rules and goals. To specify the semantics of rules and goals, we then develop an analogue of Przymusinski's perfect model semantics for stratified Horn-clause logic [20]. Several modifications are necessary to adapt this idea from classical logic to intuitionistic logic, but we eventually show how to define a preferred model of a stratified intuitionistic rulebase, and this enables us to specify the semantics of such a rulebase by reference to its preferred models. Finally, we prove a soundness and completeness theorem. Throughout the paper, we discuss various examples of the use of intuitionistic embedded implications plus negation-as-failure, to demonstrate the utility of the language. This paper appears in Proceedings of the North American Conference on Logic Programming (NACLP), pages 681-703. MIT press. Conference held in Austin, TX, Oct 29-Nov 1 1990. This paper is available at the following URL: ftp://db.toronto.edu/pub/bonner/papers/hypotheticals/naclp90.ps.gz 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> K.R. Apt, H.A. Blair, and A. Walker. </author> <title> Towards a Theory of Declarative Knowledge. </title> <editor> In Jack Minker, editor, </editor> <booktitle> Foundations of Deductive Databases and Logic Programming, chapter 2, </booktitle> <pages> pages 89-148. </pages> <publisher> Morgan Kaufmann, </publisher> <year> 1988. </year>
Reference-contexts: As in Horn logic, however, it is not difficult to provide an operational semantics for negation-as-failure as long as there is no recursion through negation. In particular, a rulebase can be stratified, or layered, as described 10 in <ref> [1] </ref>. This section develops the notion of stratification for intuitionistic rulebases. Given a goal P (x) ( Q (x), we call the predicate symbol P the head predicate of the goal. Head predicates are central to our notion of stratification. They are defined recursively in the following definition. <p> R + DB ` iff R + DB ` k+1 . This completes the definition of the operational semantics of stratified embedded-implications. 3.4 A Special Case In the case of stratified Horn rules, the semantics developed above reduce to the semantics of Apt, Blair and Walker <ref> [1] </ref> and of Przymusinski [20]. It is worth noting, however, that these semantics differ from the semantics of Prolog in a special case: for rules of the form A ~ B (x). Because of the possibility of floundering, Prolog gives such rules a special interpretation. <p> In this respect, our semantics treats Horn rules with negation in the same way that classical logic programming does. However, our semantics, like those of <ref> [1] </ref> and [20], differ from the semantics of Prolog in one respect: In Prolog, rules such as A ~ C (y) are 14 given a special interpretation. <p> Conceptually, then, the operational semantics described in Section 3.3 provides a uniform interpretation of stratified rulebases. In the special case of stratified Horn rulebases, this semantics is equivalent to others in the literature <ref> [1, 20] </ref>. In the very special case of unguarded Horn rules, this semantics can be translated into the semantics of Prolog in a straightforward way. 3.5 Examples This section shows that stratified rulebases of embedded implications can solve some familiar problems.
Reference: [2] <author> A.J. Bonner. </author> <title> A Logic for Hypothetical Reasoning. </title> <booktitle> In Proceedings of the Seventh National Conference on Artificial Intelligence, </booktitle> <pages> pages 480484, </pages> <address> Saint Paul, MN, </address> <month> August 21-26 </month> <year> 1988. </year> <note> Published in expanded form as Technical Report TR-DCS-230, </note> <institution> Department of Computer Science, Rutgers University, </institution> <address> New Brunswick, NJ 08903. </address>
Reference-contexts: Thus, rules of the form A (x) [B (x) C (x)] are allowed. Several researchers have investigated the properties of these "embedded implications" [11, 10, 14, 15, 17, 4], and have shown them to be useful for hypothetical reasoning <ref> [2] </ref>, for legal reasoning [16], for modular logic programming [17], and for lexical scoping [18]. In a series of prior papers [4, 3, 6], Bonner, et al., have established various theoretical results on the complexity and expressibility of intuitionistic embedded implications in the function-free (Datalog) case. <p> In <ref> [2] </ref>, it is shown that there is a precise sense in which such rules cannot be expressed in classical logic, even in full classical logic. However, the embedded implication in this rule has a natural interpretation in intuitionistic logic.
Reference: [3] <author> A.J. Bonner. </author> <title> Hypothetical Datalog: Negation and Linear Recursion. </title> <booktitle> In Proceedings of the ACM Symposium on the Principles of Database Systems (PODS), </booktitle> <pages> pages 286-300, </pages> <address> Philadelphia, PA, </address> <month> March </month> <year> 1989. </year>
Reference-contexts: Several researchers have investigated the properties of these "embedded implications" [11, 10, 14, 15, 17, 4], and have shown them to be useful for hypothetical reasoning [2], for legal reasoning [16], for modular logic programming [17], and for lexical scoping [18]. In a series of prior papers <ref> [4, 3, 6] </ref>, Bonner, et al., have established various theoretical results on the complexity and expressibility of intuitionistic embedded implications in the function-free (Datalog) case. <p> If the rules are at most linear recursive, then the language can express any database query in NP, and if linear recursion alternates with negation-as-failure in a stratified manner, then the language can express the database queries at each level in the polynomial time hierarchy above P <ref> [3] </ref>. It is interesting that these complexity classes can all be generated by a single language with a natural sequence of syntactic restrictions. Note the role played by negation-as-failure in these results. <p> Sev- eral examples are discussed in Sections 2 and 3.5 below. Thus a theory of negation-as-failure in the context of intuitionistic logic programming seems essential. In our prior papers <ref> [4, 3, 6] </ref>, the treatment of negation-as-failure was entirely proof-theoretic. In this paper, to round out the picture, we develop a semantic theory and prove a soundness and completeness theorem. <p> The development in this paper is for a language without function symbols. This is the kind of language typically used in database applications, and it is exactly the language needed for the expressibility results in <ref> [4, 3, 6] </ref>. Although it is function-free, we allow the language to have an infinite set of 3 constant symbols. <p> Note that node selection is non-deterministic, so in effect, the rulebase searches the graph for all possible Hamiltonian paths. It is the ability to record facts, such as which nodes are marked, that distinguishes this logic from (function free) Horn logic and accounts for its computational complexity <ref> [4, 3] </ref>. In [12], Harland develops a semantics for intuitionistic embedded implications augmented with negation-as-failure. The two examples above highlight the differences between Harland's treatment and our own. Harland's approach does not depend on stratification, and assigns a meaning even to the rule: A ~ A. <p> This dual role for the predicate MARK is crucial. A similar observation applies to the rulebase that computes Hamiltonian paths in Example 7, and to the Turing machine encodings that are needed for the expressibility results in <ref> [4, 3] </ref>. It does not appear that these rulebases would be handled correctly by Harland's semantics. Note, however, that the rules in Examples 1 and 2 of Section 2 cause no such problems. <p> Then R ` iff R j= . 25 6 Conclusion This paper has developed a semantics for the addition of stratified negation- as-failure to intuitionistic logic programming, as a complement to the proof- theoretic treatment in our earlier work <ref> [4, 3, 6] </ref>. Several difficulties were encountered along the way, and overcome. Problems pointed out by Gabbay in [10] were handled by drawing a distinction between rules: A B, and goals: A ( B. <p> Note that the class of rules for which this approach works, namely, stratified intuitionistic rulebases, as given by Definition 3.3, is exactly the class of rules needed for the expressibility results in <ref> [4, 3] </ref>. Harland's proposal for the semantics of negation-as-failure [12], discussed in Sections 1 and 3.5, is complementary to our proposal in this respect. There are several directions in which the work of the present paper might be extended. First, the logic could be extended to include function symbols.
Reference: [4] <author> A.J. Bonner. </author> <title> Hypothetical Datalog: Complexity and Expressibility. </title> <journal> Theoretical Computer Science (TCS), </journal> <volume> 76 </volume> <pages> 3-51, </pages> <year> 1990. </year> <booktitle> Special issue on the 2 nd International Conference on Database Theory (ICDT), </booktitle> <address> Bruge, Belgium, </address> <month> Aug/Sept </month> <year> 1988. </year> <note> Also appears, </note> <editor> in abridged form, </editor> <booktitle> in volume 326 of Lecture Notes in Computer Science, </booktitle> <pages> pages 144-160. </pages> <publisher> Springer-Verlag, </publisher> <year> 1988. </year>
Reference-contexts: 1 Introduction Intuitionistic logic programming is an extension of Horn-clause logic programming in which implications may appear "embedded" on the right-hand side of a rule. Thus, rules of the form A (x) [B (x) C (x)] are allowed. Several researchers have investigated the properties of these "embedded implications" <ref> [11, 10, 14, 15, 17, 4] </ref>, and have shown them to be useful for hypothetical reasoning [2], for legal reasoning [16], for modular logic programming [17], and for lexical scoping [18]. <p> Several researchers have investigated the properties of these "embedded implications" [11, 10, 14, 15, 17, 4], and have shown them to be useful for hypothetical reasoning [2], for legal reasoning [16], for modular logic programming [17], and for lexical scoping [18]. In a series of prior papers <ref> [4, 3, 6] </ref>, Bonner, et al., have established various theoretical results on the complexity and expressibility of intuitionistic embedded implications in the function-free (Datalog) case. <p> For the full language, in which universal quantifiers may also appear "embedded" on the right-hand side of a rule, the query problem is undecidable [6], but if embedded universal quantifiers are barred from the language, the query problem is decidable and its data-complexity is PSPACE-complete <ref> [4] </ref>. If negation-as- failure is added to the language, these complexity results can be extended to expressibility results. <p> If the language includes negation-as-failure, but no embedded universal quantifiers, then it can express any typed, generic database query in PSPACE <ref> [4] </ref>. Additional syntactic restrictions yield additional complexity classes. <p> Sev- eral examples are discussed in Sections 2 and 3.5 below. Thus a theory of negation-as-failure in the context of intuitionistic logic programming seems essential. In our prior papers <ref> [4, 3, 6] </ref>, the treatment of negation-as-failure was entirely proof-theoretic. In this paper, to round out the picture, we develop a semantic theory and prove a soundness and completeness theorem. <p> The development in this paper is for a language without function symbols. This is the kind of language typically used in database applications, and it is exactly the language needed for the expressibility results in <ref> [4, 3, 6] </ref>. Although it is function-free, we allow the language to have an infinite set of 3 constant symbols. <p> However, in order to analyze these more complex examples, it is necessary to formulate the inference system of our language with greater precision. This is the subject of the following section. 3 Inference A number of researchers have developed inference systems for intuitionisitic logic programming <ref> [11, 15, 17, 4] </ref>. However, most of this work has focused on the negation-free case. As pointed out by Gabbay in [10], negation-as-failure introduces subtle problems for intuitionistic logic. In this section, we first review the negation-free case and discuss the problems of introducing negation. <p> It is an extension of function-free Horn logic (i.e., Dat- alog), both syntactically and proof theoretically. In <ref> [4] </ref>, it is shown that the data complexity of this system is complete for polynomial space. The syntax of the logic is first order. <p> Note that node selection is non-deterministic, so in effect, the rulebase searches the graph for all possible Hamiltonian paths. It is the ability to record facts, such as which nodes are marked, that distinguishes this logic from (function free) Horn logic and accounts for its computational complexity <ref> [4, 3] </ref>. In [12], Harland develops a semantics for intuitionistic embedded implications augmented with negation-as-failure. The two examples above highlight the differences between Harland's treatment and our own. Harland's approach does not depend on stratification, and assigns a meaning even to the rule: A ~ A. <p> This dual role for the predicate MARK is crucial. A similar observation applies to the rulebase that computes Hamiltonian paths in Example 7, and to the Turing machine encodings that are needed for the expressibility results in <ref> [4, 3] </ref>. It does not appear that these rulebases would be handled correctly by Harland's semantics. Note, however, that the rules in Examples 1 and 2 of Section 2 cause no such problems. <p> Then R ` iff R j= . 25 6 Conclusion This paper has developed a semantics for the addition of stratified negation- as-failure to intuitionistic logic programming, as a complement to the proof- theoretic treatment in our earlier work <ref> [4, 3, 6] </ref>. Several difficulties were encountered along the way, and overcome. Problems pointed out by Gabbay in [10] were handled by drawing a distinction between rules: A B, and goals: A ( B. <p> Note that the class of rules for which this approach works, namely, stratified intuitionistic rulebases, as given by Definition 3.3, is exactly the class of rules needed for the expressibility results in <ref> [4, 3] </ref>. Harland's proposal for the semantics of negation-as-failure [12], discussed in Sections 1 and 3.5, is complementary to our proposal in this respect. There are several directions in which the work of the present paper might be extended. First, the logic could be extended to include function symbols.
Reference: [5] <author> A.J. Bonner and L.T. McCarty. </author> <title> Adding Negation-as-Failure to Intuitionistic Logic Programming. </title> <type> Technical report, </type> <institution> Department of Computer Science, Rutgers University, </institution> <address> New Brunswick, NJ 08903, </address> <year> 1992. </year>
Reference-contexts: We then show that the canonical model M R is a preferred model of R, and, up to equivalence, the only preferred model of R. Soundness and completeness then follow immediately. Because of space limitations, all proofs are omitted. The interested reader is referred to <ref> [5] </ref> for details. To construct the canonical model, we first define a box notation for our inference system analogous to the box notation introduced in Section 4.3. Definition 5.1 (Monotonic Inference) Let R be a stratified rulebase and let be a closed goal. <p> the tuple M R = hS; ; i, where S = The set of all databases. is the binary relation given by Definition 5.2. (DB ) = fB j R + DB ` B where B is atomicg 24 It is not hard to show that is transitive and reflexive <ref> [5] </ref>. The canonical model is therefore a valid, non-monotonic structure, by Definition 4.6. The following theorem is our first major result about canonical models. Theorem 5.1 Let R be a stratified rulebase.
Reference: [6] <author> A.J. Bonner, L.T. McCarty, and K. Vadaparty. </author> <title> Expressing Database Queries with Intuitionistic Logic. </title> <booktitle> In Proceedings of the North American Conference on Logic Programming (NACLP), </booktitle> <pages> pages 831-850, </pages> <address> Cleveland, Ohio, October 16-20 1989. </address> <publisher> MIT Press. </publisher>
Reference-contexts: Several researchers have investigated the properties of these "embedded implications" [11, 10, 14, 15, 17, 4], and have shown them to be useful for hypothetical reasoning [2], for legal reasoning [16], for modular logic programming [17], and for lexical scoping [18]. In a series of prior papers <ref> [4, 3, 6] </ref>, Bonner, et al., have established various theoretical results on the complexity and expressibility of intuitionistic embedded implications in the function-free (Datalog) case. <p> For the full language, in which universal quantifiers may also appear "embedded" on the right-hand side of a rule, the query problem is undecidable <ref> [6] </ref>, but if embedded universal quantifiers are barred from the language, the query problem is decidable and its data-complexity is PSPACE-complete [4]. If negation-as- failure is added to the language, these complexity results can be extended to expressibility results. Thus, as shown in [6], the unrestricted language with embedded universal quantifiers <p> a rule, the query problem is undecidable <ref> [6] </ref>, but if embedded universal quantifiers are barred from the language, the query problem is decidable and its data-complexity is PSPACE-complete [4]. If negation-as- failure is added to the language, these complexity results can be extended to expressibility results. Thus, as shown in [6], the unrestricted language with embedded universal quantifiers plus negation-as-failure can express any typed, generic, computable database query in the sense defined by Chandra and Harel in [7, 8]. <p> Sev- eral examples are discussed in Sections 2 and 3.5 below. Thus a theory of negation-as-failure in the context of intuitionistic logic programming seems essential. In our prior papers <ref> [4, 3, 6] </ref>, the treatment of negation-as-failure was entirely proof-theoretic. In this paper, to round out the picture, we develop a semantic theory and prove a soundness and completeness theorem. <p> The development in this paper is for a language without function symbols. This is the kind of language typically used in database applications, and it is exactly the language needed for the expressibility results in <ref> [4, 3, 6] </ref>. Although it is function-free, we allow the language to have an infinite set of 3 constant symbols. <p> In a complete development of intuitionistic semantics, each substate may have its own distinct domain of constant symbols. We have assumed here, however, that the domain of each substate is equal to the universe of all constant symbols. In <ref> [6] </ref>, we show that for embedded implications, these are the only kind of structures that one needs to consider. We continue to use these simplified structures in this paper, since they simplify the theoretical development. 18 Truth in an intuitionistic structure M is defined relative to its substates. <p> Definition 4.4 (Validity) A formula is valid iff M j= for all intu- itionistic structures M . Definition 4.5 (Entailment) Suppose 1 and 2 are formulas. Then 1 j= 2 iff the formula 2 1 is valid. The following theorem is a central result of <ref> [6] </ref>: Theorem 4.1 (Soundness and Completeness) Let R be a negation-free rulebase and be a goal. Then R ` iff R j= . 4.2 Non-Monotonic Structures In the tradition of logic programming, we would like to identify a single model that characterizes all the inferences sanctioned by a rulebase R. <p> That is, we would like to find a single intuitionistic structure M R that is a model of R and for which M R j= iff R ` for all goals . We call such a structure a canonical model of R. In <ref> [6] </ref>, it is shown that negation-free rulebases have a canonical intuitionistic model. When intuitionistic logic is augmented with negation-as-failure, it is not possible to construct a canonical model. Let us forget for the moment that 19 we have introduced two types of implication in the proof theory of strati-fied rulebases. <p> Then R ` iff R j= . 25 6 Conclusion This paper has developed a semantics for the addition of stratified negation- as-failure to intuitionistic logic programming, as a complement to the proof- theoretic treatment in our earlier work <ref> [4, 3, 6] </ref>. Several difficulties were encountered along the way, and overcome. Problems pointed out by Gabbay in [10] were handled by drawing a distinction between rules: A B, and goals: A ( B. <p> This extension to locally stratified rulebases also seems straightforward. Third, although the full language of intuitionistic logic programming described in <ref> [14, 15, 6] </ref> includes embedded universal quantifiers, we have considered in this paper only the restricted (and decidable!) sublanguage in which universal quantification is confined to the top level of the rules. Adding negation-as-failure to the full language raises additional problems, and requires another subtle adjustment of the semantics.
Reference: [7] <author> A.K. Chandra and D. Harel. </author> <title> Computable Queries for Relational Databases. </title> <journal> Journal of Computer and System Sciences (JCSS), </journal> <volume> 21(2) </volume> <pages> 156-178, </pages> <year> 1980. </year>
Reference-contexts: If negation-as- failure is added to the language, these complexity results can be extended to expressibility results. Thus, as shown in [6], the unrestricted language with embedded universal quantifiers plus negation-as-failure can express any typed, generic, computable database query in the sense defined by Chandra and Harel in <ref> [7, 8] </ref>. If the language includes negation-as-failure, but no embedded universal quantifiers, then it can express any typed, generic database query in PSPACE [4]. Additional syntactic restrictions yield additional complexity classes.
Reference: [8] <author> A.K. Chandra and D. Harel. </author> <title> Structure and Complexity of Relational Queries. </title> <journal> Journal of Computer and System Sciences (JCSS), </journal> <volume> 25(1):99128, </volume> <year> 1982. </year>
Reference-contexts: If negation-as- failure is added to the language, these complexity results can be extended to expressibility results. Thus, as shown in [6], the unrestricted language with embedded universal quantifiers plus negation-as-failure can express any typed, generic, computable database query in the sense defined by Chandra and Harel in <ref> [7, 8] </ref>. If the language includes negation-as-failure, but no embedded universal quantifiers, then it can express any typed, generic database query in PSPACE [4]. Additional syntactic restrictions yield additional complexity classes. <p> SELECT (x): SELECT (x) NODE (x); ~ MARK (x): Then R; DB ` YES iff the graph represented by DB has a directed Hamil <br>- tonian path. 2 1 It is worthwhile noting that this problem cannot be solved in Datalog (function-free Horn logic) even when stratified negation is allowed <ref> [8] </ref>. 16 The rulebase in this example is best understood from the top-down per-spective. During inference, the rulebase tries to construct a Hamiltonian path one node at a time. The first rule selects a node x at which the path is to begin.
Reference: [9] <author> M.C. </author> <title> Fitting. Intuitionistic Logic, Model Theory and Forcing. </title> <address> NorthHolland, </address> <year> 1969. </year>
Reference-contexts: The following sections then show how this semantics can be modified to account for negation-as-failure. 4.1 Intuitionistic Semantics The following is a simplified development of the Kripke semantics of intu- itionistic logic. A complete development may be found in <ref> [9, 13] </ref>. <p> Rather, it has an independent semantic definition. An intuitive interpretation of this semantics may be found in [13] and <ref> [9] </ref>. Definition 4.3 (Models) M j= iff s; M j= for all substates s of M . If M j= , then M is a model of . Definition 4.4 (Validity) A formula is valid iff M j= for all intu- itionistic structures M .
Reference: [10] <author> D.M. Gabbay. N-Prolog: </author> <title> an Extension of Prolog with Hypothetical Implications. II. Logical Foundations and Negation as Failure. </title> <journal> Journal of Logic Programming (JLP), </journal> <volume> 2(4) </volume> <pages> 251-283, </pages> <year> 1985. </year> <month> 27 </month>
Reference-contexts: 1 Introduction Intuitionistic logic programming is an extension of Horn-clause logic programming in which implications may appear "embedded" on the right-hand side of a rule. Thus, rules of the form A (x) [B (x) C (x)] are allowed. Several researchers have investigated the properties of these "embedded implications" <ref> [11, 10, 14, 15, 17, 4] </ref>, and have shown them to be useful for hypothetical reasoning [2], for legal reasoning [16], for modular logic programming [17], and for lexical scoping [18]. <p> In this paper, to round out the picture, we develop a semantic theory and prove a soundness and completeness theorem. There are reasons to think that the addition of negation-as-failure to intu <p>- 2 itionistic logic programming will lead to serious semantic difficulties. Gabbay studied the problem in <ref> [10] </ref>, and concluded that the entire idea was logically incoherent, since modus ponens would no longer be valid. We address this problem in Section 3.2. More recently, Harland [12] has proposed a semantics for negation-as-failure within intuitionistic logic programming, based on the fixed-point construction of Miller [17]. <p> This is the subject of the following section. 3 Inference A number of researchers have developed inference systems for intuitionisitic logic programming [11, 15, 17, 4]. However, most of this work has focused on the negation-free case. As pointed out by Gabbay in <ref> [10] </ref>, negation-as-failure introduces subtle problems for intuitionistic logic. In this section, we first review the negation-free case and discuss the problems of introducing negation. <p> As in Horn logic, difficult problems arise if rulebases with negation are not stratified. Section 3.3 develops the notion of stratification for intuitionistic rulebases. Even when they are stratified, however, embedded implications display interesting paradoxes, as originally pointed out by Gabbay <ref> [10] </ref>. This section examines some of these paradoxes and proposes a syntactic solution. Section 4 proposes a semantic solution. If implicational queries are allowed, then paradoxes arise even for stratified Horn rulebases. The following example, for instance, shows that for such rulebases, implication is not transitive. Example 4. <p> Several difficulties were encountered along the way, and overcome. Problems pointed out by Gabbay in <ref> [10] </ref> were handled by drawing a distinction between rules: A B, and goals: A ( B. The "bias" of intuitionistic Kripke structures towards monotonic rules was handled simply by dropping the monotonicity condition, and satisfaction in non-monotonic structures was then defined separately for the connectives and (.
Reference: [11] <editor> D.M. Gabbay and U. Reyle. N-Prolog: </editor> <title> an Extension of Prolog with Hypothetical Implications. I. </title> <journal> Journal of Logic Programming (JLP), </journal> <volume> 1(4) </volume> <pages> 319-355, </pages> <year> 1984. </year>
Reference-contexts: 1 Introduction Intuitionistic logic programming is an extension of Horn-clause logic programming in which implications may appear "embedded" on the right-hand side of a rule. Thus, rules of the form A (x) [B (x) C (x)] are allowed. Several researchers have investigated the properties of these "embedded implications" <ref> [11, 10, 14, 15, 17, 4] </ref>, and have shown them to be useful for hypothetical reasoning [2], for legal reasoning [16], for modular logic programming [17], and for lexical scoping [18]. <p> However, in order to analyze these more complex examples, it is necessary to formulate the inference system of our language with greater precision. This is the subject of the following section. 3 Inference A number of researchers have developed inference systems for intuitionisitic logic programming <ref> [11, 15, 17, 4] </ref>. However, most of this work has focused on the negation-free case. As pointed out by Gabbay in [10], negation-as-failure introduces subtle problems for intuitionistic logic. In this section, we first review the negation-free case and discuss the problems of introducing negation.
Reference: [12] <author> J. Harland. </author> <title> A Kripke-like model for negation as failure. </title> <booktitle> In Proceedings of the North American Conference on Logic Programming (NACLP), </booktitle> <pages> pages 626-642, </pages> <address> Cleveland, Ohio, October 1989. </address> <publisher> MIT Press. </publisher>
Reference-contexts: Gabbay studied the problem in [10], and concluded that the entire idea was logically incoherent, since modus ponens would no longer be valid. We address this problem in Section 3.2. More recently, Harland <ref> [12] </ref> has proposed a semantics for negation-as-failure within intuitionistic logic programming, based on the fixed-point construction of Miller [17]. Harland's approach seems to overcome some of Gabbay's objections. <p> It is the ability to record facts, such as which nodes are marked, that distinguishes this logic from (function free) Horn logic and accounts for its computational complexity [4, 3]. In <ref> [12] </ref>, Harland develops a semantics for intuitionistic embedded implications augmented with negation-as-failure. The two examples above highlight the differences between Harland's treatment and our own. Harland's approach does not depend on stratification, and assigns a meaning even to the rule: A ~ A. <p> Harland's approach does not depend on stratification, and assigns a meaning even to the rule: A ~ A. On the other hand, Harland's semantics cannot handle the rulebases above. To see this, we need to examine the operational semantics in <ref> [12] </ref> more closely. Harland draws a distinction between "completely defined" predicates, such as APPEND, and "incompletely defined" predicates, such as CARCINOGEN . Negation-as-failure is available only for completely defined predicates, while goals must have incompletely defined predicates in their premises. <p> Note that the class of rules for which this approach works, namely, stratified intuitionistic rulebases, as given by Definition 3.3, is exactly the class of rules needed for the expressibility results in [4, 3]. Harland's proposal for the semantics of negation-as-failure <ref> [12] </ref>, discussed in Sections 1 and 3.5, is complementary to our proposal in this respect. There are several directions in which the work of the present paper might be extended. First, the logic could be extended to include function symbols.
Reference: [13] <author> S. Kripke. </author> <title> Semantical Analysis of Intuitionistic Logic. </title> <editor> I. In J.N. Crossley and M.A.E. Dummett, editors, </editor> <booktitle> Formal Systems and Recursive Functions, </booktitle> <pages> pages 92-130. </pages> <publisher> North Holland, </publisher> <address> Amsterdam, </address> <year> 1965. </year>
Reference-contexts: In the case of intuitionistic logic programming, the natural generalization would be to define a preference relation on the intu- itionistic models of the rulebase, which are usually taken to be Kripke models <ref> [13] </ref>. However, it turns out that we need to make two modifications of Przy- musinski's original idea in order to generalize it to intuitionistic logic. First, we need to generalize the notion of a Kripke structure, which is monotonic, to the notion of a non-monotonic structure, which is not. <p> The following sections then show how this semantics can be modified to account for negation-as-failure. 4.1 Intuitionistic Semantics The following is a simplified development of the Kripke semantics of intu- itionistic logic. A complete development may be found in <ref> [9, 13] </ref>. <p> Rather, it has an independent semantic definition. An intuitive interpretation of this semantics may be found in <ref> [13] </ref> and [9]. Definition 4.3 (Models) M j= iff s; M j= for all substates s of M . If M j= , then M is a model of . Definition 4.4 (Validity) A formula is valid iff M j= for all intu- itionistic structures M .
Reference: [14] <author> L.T. McCarty. </author> <title> Clausal Intuitionistic Logic. I. Fixed-Point Semantics. </title> <journal> Journal of Logic Programming (JLP), </journal> <volume> 5(1) </volume> <pages> 1-31, </pages> <year> 1988. </year>
Reference-contexts: 1 Introduction Intuitionistic logic programming is an extension of Horn-clause logic programming in which implications may appear "embedded" on the right-hand side of a rule. Thus, rules of the form A (x) [B (x) C (x)] are allowed. Several researchers have investigated the properties of these "embedded implications" <ref> [11, 10, 14, 15, 17, 4] </ref>, and have shown them to be useful for hypothetical reasoning [2], for legal reasoning [16], for modular logic programming [17], and for lexical scoping [18]. <p> It should therefore be straightforward to generalize the development given here to include function symbols, since in a logic with function symbols but without equality (e.g., Prolog), each Herbrand term can be treated as a distinct constant symbol. The intuitionistic logic programming language discussed in <ref> [14, 15] </ref> treats function symbols in precisely this way. 2 Examples In this section, we present two examples of the use of intuitionistic embedded implications combined with negation-as-failure. The reader will note the appearance of two implication symbols in these examples: and (. <p> When interpreted either classically or intuitionistically, a goal is equivalent to a definite Horn clause. Rules include the formulas A B and A (B C; D) and A [(B C) D]. Such rules are called embedded implications <ref> [14, 15] </ref>. A rulebase is defined to be a finite set of rules, and a database is defined to be a finite set of ground atomic formulas. Definition 3.1 (Inference) Suppose R is a rulebase. <p> First, the logic could be extended to include function symbols. The development in this paper assumes that the logic includes constants but no function symbols. Since we allow the set of constants to be infinite, however, incorporating function symbols without equality, as in Prolog, should be straightforward. See <ref> [14, 15] </ref> for an example of how this might be done. Second, the requirement that an intuitionistic rulebase be globally stratified could be relaxed to the requirement of local stratification [20]. <p> This extension to locally stratified rulebases also seems straightforward. Third, although the full language of intuitionistic logic programming described in <ref> [14, 15, 6] </ref> includes embedded universal quantifiers, we have considered in this paper only the restricted (and decidable!) sublanguage in which universal quantification is confined to the top level of the rules. Adding negation-as-failure to the full language raises additional problems, and requires another subtle adjustment of the semantics.
Reference: [15] <author> L.T. McCarty. </author> <title> Clausal Intuitionistic Logic. II. Tableau Proof Procedures. </title> <journal> Journal of Logic Programming (JLP), </journal> <volume> 5(2) </volume> <pages> 93-132, </pages> <year> 1988. </year>
Reference-contexts: 1 Introduction Intuitionistic logic programming is an extension of Horn-clause logic programming in which implications may appear "embedded" on the right-hand side of a rule. Thus, rules of the form A (x) [B (x) C (x)] are allowed. Several researchers have investigated the properties of these "embedded implications" <ref> [11, 10, 14, 15, 17, 4] </ref>, and have shown them to be useful for hypothetical reasoning [2], for legal reasoning [16], for modular logic programming [17], and for lexical scoping [18]. <p> It should therefore be straightforward to generalize the development given here to include function symbols, since in a logic with function symbols but without equality (e.g., Prolog), each Herbrand term can be treated as a distinct constant symbol. The intuitionistic logic programming language discussed in <ref> [14, 15] </ref> treats function symbols in precisely this way. 2 Examples In this section, we present two examples of the use of intuitionistic embedded implications combined with negation-as-failure. The reader will note the appearance of two implication symbols in these examples: and (. <p> However, in order to analyze these more complex examples, it is necessary to formulate the inference system of our language with greater precision. This is the subject of the following section. 3 Inference A number of researchers have developed inference systems for intuitionisitic logic programming <ref> [11, 15, 17, 4] </ref>. However, most of this work has focused on the negation-free case. As pointed out by Gabbay in [10], negation-as-failure introduces subtle problems for intuitionistic logic. In this section, we first review the negation-free case and discuss the problems of introducing negation. <p> When interpreted either classically or intuitionistically, a goal is equivalent to a definite Horn clause. Rules include the formulas A B and A (B C; D) and A [(B C) D]. Such rules are called embedded implications <ref> [14, 15] </ref>. A rulebase is defined to be a finite set of rules, and a database is defined to be a finite set of ground atomic formulas. Definition 3.1 (Inference) Suppose R is a rulebase. <p> First, the logic could be extended to include function symbols. The development in this paper assumes that the logic includes constants but no function symbols. Since we allow the set of constants to be infinite, however, incorporating function symbols without equality, as in Prolog, should be straightforward. See <ref> [14, 15] </ref> for an example of how this might be done. Second, the requirement that an intuitionistic rulebase be globally stratified could be relaxed to the requirement of local stratification [20]. <p> This extension to locally stratified rulebases also seems straightforward. Third, although the full language of intuitionistic logic programming described in <ref> [14, 15, 6] </ref> includes embedded universal quantifiers, we have considered in this paper only the restricted (and decidable!) sublanguage in which universal quantification is confined to the top level of the rules. Adding negation-as-failure to the full language raises additional problems, and requires another subtle adjustment of the semantics.
Reference: [16] <author> L.T. McCarty. </author> <title> A Language for Legal Discourse. I. Basic Features. </title> <booktitle> In Proceedings of the Second International Conference on Artificial Intelligence and Law, </booktitle> <pages> pages 180-189. </pages> <publisher> ACM Press, </publisher> <month> June </month> <year> 1989. </year>
Reference-contexts: Thus, rules of the form A (x) [B (x) C (x)] are allowed. Several researchers have investigated the properties of these "embedded implications" [11, 10, 14, 15, 17, 4], and have shown them to be useful for hypothetical reasoning [2], for legal reasoning <ref> [16] </ref>, for modular logic programming [17], and for lexical scoping [18]. In a series of prior papers [4, 3, 6], Bonner, et al., have established various theoretical results on the complexity and expressibility of intuitionistic embedded implications in the function-free (Datalog) case.
Reference: [17] <author> D. Miller. </author> <title> A Logical Analysis of Modules in Logic Programming. </title> <journal> Journal of Logic Programming (JLP), </journal> <volume> 6 </volume> <pages> 79-108, </pages> <year> 1989. </year>
Reference-contexts: 1 Introduction Intuitionistic logic programming is an extension of Horn-clause logic programming in which implications may appear "embedded" on the right-hand side of a rule. Thus, rules of the form A (x) [B (x) C (x)] are allowed. Several researchers have investigated the properties of these "embedded implications" <ref> [11, 10, 14, 15, 17, 4] </ref>, and have shown them to be useful for hypothetical reasoning [2], for legal reasoning [16], for modular logic programming [17], and for lexical scoping [18]. <p> Thus, rules of the form A (x) [B (x) C (x)] are allowed. Several researchers have investigated the properties of these "embedded implications" [11, 10, 14, 15, 17, 4], and have shown them to be useful for hypothetical reasoning [2], for legal reasoning [16], for modular logic programming <ref> [17] </ref>, and for lexical scoping [18]. In a series of prior papers [4, 3, 6], Bonner, et al., have established various theoretical results on the complexity and expressibility of intuitionistic embedded implications in the function-free (Datalog) case. <p> We address this problem in Section 3.2. More recently, Harland [12] has proposed a semantics for negation-as-failure within intuitionistic logic programming, based on the fixed-point construction of Miller <ref> [17] </ref>. Harland's approach seems to overcome some of Gabbay's objections. However, Harland's semantics requires that we label predicates as "completely defined" or "incompletely defined", and this requirement precludes the use of the very rules that are needed for our expressibility results. This point is discussed further in Section 3.5. <p> However, in order to analyze these more complex examples, it is necessary to formulate the inference system of our language with greater precision. This is the subject of the following section. 3 Inference A number of researchers have developed inference systems for intuitionisitic logic programming <ref> [11, 15, 17, 4] </ref>. However, most of this work has focused on the negation-free case. As pointed out by Gabbay in [10], negation-as-failure introduces subtle problems for intuitionistic logic. In this section, we first review the negation-free case and discuss the problems of introducing negation.
Reference: [18] <author> D. Miller. </author> <title> Lexical scoping as universal quantification. </title> <editor> In G. Levi and M. Martelli, editors, </editor> <booktitle> Logic Programming: Proceedings of the Sixth International Conference, </booktitle> <pages> pages 268-283, </pages> <address> Cambridge, MA, 1989. </address> <publisher> MIT Press. </publisher>
Reference-contexts: Several researchers have investigated the properties of these "embedded implications" [11, 10, 14, 15, 17, 4], and have shown them to be useful for hypothetical reasoning [2], for legal reasoning [16], for modular logic programming [17], and for lexical scoping <ref> [18] </ref>. In a series of prior papers [4, 3, 6], Bonner, et al., have established various theoretical results on the complexity and expressibility of intuitionistic embedded implications in the function-free (Datalog) case.
Reference: [19] <author> R. Pareschi. </author> <title> A definite clause version of categorial grammar. </title> <booktitle> In Proceedings, 26th Annual Meeting of the Association for Computational Linguistics, </booktitle> <pages> pages 270-277, </pages> <address> Buffalo, NY, </address> <month> June </month> <year> 1988. </year>
Reference-contexts: This means that a stipend is available to those students who need to take exactly one course in order to satisfy the graduation requirements. This observation becomes important in the following example. Example 2. In <ref> [19] </ref>, Pareschi studies the use of intuitionistic embedded implications in a definite clause version of Categorical Grammar. Classi- cal Categorical Grammar (CG) encodes linguistic information by assigning syntactic types to lexical items. <p> Pareschi considers several possible solutions to this problem, including a modification of the intuitionistic proof theory and a filtering of certain kinds of proofs <ref> [19] </ref>. But there is an obvious solution using negation-as-failure.
Reference: [20] <author> T. Przymusinski. </author> <title> On the Declarative Semantics of Deductive Databases and Logic Programs. </title> <editor> In Jack Minker, editor, </editor> <booktitle> Foundations of Deductive Databases and Logic Programming, chapter 5, </booktitle> <pages> pages 193-216. </pages> <publisher> Morgan Kaufmann, </publisher> <year> 1988. </year> <month> 28 </month>
Reference-contexts: This point is discussed further in Section 3.5. Our approach, instead, is based on Przymusinski's perfect model semantics for stratified Horn-clause logic augmented by negation-as-failure <ref> [20] </ref>. Although this approach requires that we restrict our attention to stratified intuition- istic rulebases, a term defined in Section 3.3, this restriction turns out to be acceptable for our intended applications. <p> In the case of classical logic programming, Przymusinski's idea was to define a preference relation on the classical models of a rulebase, and then to identify the minimal elements in the preference ordering as the intended models of the rules <ref> [20] </ref>. In the case of intuitionistic logic programming, the natural generalization would be to define a preference relation on the intu- itionistic models of the rulebase, which are usually taken to be Kripke models [13]. <p> This completes the definition of the operational semantics of stratified embedded-implications. 3.4 A Special Case In the case of stratified Horn rules, the semantics developed above reduce to the semantics of Apt, Blair and Walker [1] and of Przymusinski <ref> [20] </ref>. It is worth noting, however, that these semantics differ from the semantics of Prolog in a special case: for rules of the form A ~ B (x). Because of the possibility of floundering, Prolog gives such rules a special interpretation. <p> In this respect, our semantics treats Horn rules with negation in the same way that classical logic programming does. However, our semantics, like those of [1] and <ref> [20] </ref>, differ from the semantics of Prolog in one respect: In Prolog, rules such as A ~ C (y) are 14 given a special interpretation. <p> Conceptually, then, the operational semantics described in Section 3.3 provides a uniform interpretation of stratified rulebases. In the special case of stratified Horn rulebases, this semantics is equivalent to others in the literature <ref> [1, 20] </ref>. In the very special case of unguarded Horn rules, this semantics can be translated into the semantics of Prolog in a straightforward way. 3.5 Examples This section shows that stratified rulebases of embedded implications can solve some familiar problems. <p> When negation is introduced, new semantic de-vices are needed to account for the non-monotonicity of the resulting system. A common approach, due to Przymusinski, is to introduce a preference relation on the classical models of the rulebase, and then to focus on the most preferred, or perfect, models <ref> [20] </ref>. It is now well known that stratified Horn rulebases have a unique perfect model [20]. Similarly, in intuitionistic logic programming, the semantics is truly in- tuitionistic only in the negation-free case. <p> A common approach, due to Przymusinski, is to introduce a preference relation on the classical models of the rulebase, and then to focus on the most preferred, or perfect, models <ref> [20] </ref>. It is now well known that stratified Horn rulebases have a unique perfect model [20]. Similarly, in intuitionistic logic programming, the semantics is truly in- tuitionistic only in the negation-free case. When negation is introduced, a natural approach would be to introduce a preference relation on intuition- istic models to account for the non-monotonicity. When we attempt to do this, however, two difficulties emerge. <p> When we attempt to do this, however, two difficulties emerge. First, a preference relation by itself does not fully account for non-monotonicity. Second, because intuitionistic logic is not a two-valued logic (i.e., it lacks the law of the excluded middle), the preference relation developed in <ref> [20] </ref> is not strong enough. The rest of this section addresses these two difficulties and proposes novel solutions. This first section below provides a brief development of intuitionistic semantics. <p> The "bias" of intuitionistic Kripke structures towards monotonic rules was handled simply by dropping the monotonicity condition, and satisfaction in non-monotonic structures was then defined separately for the connectives and (. Our basic approach was inspired by Przymusinski's perfect model semantics for stratified Horn-clause logic <ref> [20] </ref>, but with various modifications dictated by the intuitionistic setting. Thus, we defined a preference ordering on non-monotonic structures that minimizes positive goals and maximizes negative goals simultaneously, a more complex criterion than was needed in classical logic. <p> See [14, 15] for an example of how this might be done. Second, the requirement that an intuitionistic rulebase be globally stratified could be relaxed to the requirement of local stratification <ref> [20] </ref>. In fact, the rules in Example 2 are not globally stratified, since a relative clause may appear inside the derivation of a sentence, but such rules would be locally stratified by virtue of the usual constraints on string positions. This extension to locally stratified rulebases also seems straightforward.
References-found: 20

