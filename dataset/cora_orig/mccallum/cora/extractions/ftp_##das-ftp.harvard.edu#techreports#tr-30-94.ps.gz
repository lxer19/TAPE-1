URL: ftp://das-ftp.harvard.edu/techreports/tr-30-94.ps.gz
Refering-URL: http://www.eecs.harvard.edu/~chris/papers/
Root-URL: 
Email: fchris,margog@das.harvard.edu  
Title: VINO: An Integrated Platform for Operating System and Database Research Kernel mechanisms are reusable by
Author: Christopher Small and Margo Seltzer 
Note: Operating system services in many existing systems are either too slow or inappropriate. Current DBMSs usually provide their own and make little or no use of those offered by the operating system. [STON81] Applications direct policy.  
Address: Cambridge, MA 02138  
Affiliation: Harvard University  Harvard Computer Science Laboratory  
Pubnum: Technical Report TR-30-94  
Abstract: The standard operating system model has changed little since that time, and we believe that, at its core, it is the wrong model for DBMS and other resource-intensive applications. The standard model is inflexible, uncooperative, and irregular in its treatment of resources. We describe the design of a new system, the VINO kernel, which addresses the limitations of standard operating systems. It focuses on three key ideas: 
Abstract-found: 1
Intro-found: 1
Reference: <institution> References </institution>
Reference: [ACET86] <author> Acetta, M., R. Baron, W. Bolosky, D. Golub, R. Rashid, A. Tevanian, and M. Young, </author> <title> "Mach: A New Kernel Foundation for UNIX Development", </title> <booktitle> Proceedings of the Summer Usenix Conference (July 1986). </booktitle>
Reference: [APPEL91] <author> Appel, A., Li, K., </author> <title> "Virtual Memory Primitives for User Programs," </title> <booktitle> Proceedings of ASPLOS IV (1991). </booktitle>
Reference-contexts: Typically, a DBMS knows in advance which pages will be needed soon, and could inform the operating system of its future requirements. There have been numerous attempts to empower applications with the ability to control prefetching and page replacement <ref> [CAO94, MCNAM90, PATT93, HART92, APPEL91] </ref>. All of these approaches provide potential solutions, but the solutions apply only to buffer management and require the implementation of special purpose mechanisms. In VINO, application-specific tailoring is the norm, not the exception.
Reference: [BERS94] <author> Bershad, B., C., Chambers, S. Eggers, C. Maeda, D. McNamee, P. Pardyak, S. Savage, E. Sirer, </author> <title> "SPIN An Extensible Microkernel for Application-specific Operating System Services", </title> <note> University of Washington Technical Report 94-03-03 (February 1994). </note>
Reference: [BILI94] <author> Biliris, S., Dar, S., Gehani, N., Jagadish, H. V., and Ramamritham, K., </author> <title> "ASSET: A System for Supporting Extended Transactions", </title> <booktitle> Proceedings of SIGMOD 94, </booktitle> <address> Minneapolis, MN (May 1994). </address>
Reference-contexts: The mixing and matching of logging and locking components enables VINO to support arbitrarily complex transaction protocols. Because the implementation of the transaction manager can be incrementally modified, different transaction se-matics (e.g. as outlined in <ref> [BILI94] </ref>) can be implemented as needed by applications. 5.4 Name Service Persistent objects are denoted by a (manager, storage-id) pair. A manager is a kernel resource that implements a file-like interface for each of the resources under its control.
Reference: [CAO94] <author> Cao, P., Felten, E., and Li, K., </author> <title> "Application-Controlled File Caching Policies", </title> <booktitle> Proceedings of the 1994 Winter Usenix Conference, </booktitle> <pages> pp. </pages> <month> 171-182 (June </month> <year> 1994). </year>
Reference-contexts: Typically, a DBMS knows in advance which pages will be needed soon, and could inform the operating system of its future requirements. There have been numerous attempts to empower applications with the ability to control prefetching and page replacement <ref> [CAO94, MCNAM90, PATT93, HART92, APPEL91] </ref>. All of these approaches provide potential solutions, but the solutions apply only to buffer management and require the implementation of special purpose mechanisms. In VINO, application-specific tailoring is the norm, not the exception.
Reference: [CHANG90] <author> Chang, A., Mergen, M., Rader, R., Roberts, J., Porter, S., </author> <title> "Evolution of storage facilities in AIX Version 3 for RISC System/6000 processors," </title> <journal> IBM Journal of Research and Development v. </journal> <volume> 34, </volume> <editor> n. </editor> <month> 1 (January </month> <year> 1990). </year> <month> 9 </month>
Reference: [CHEN93] <author> Chen, B., and Bershad, B., </author> <title> "The Impact of Operating System Structure on Memory System Performance", </title> <booktitle> Proceedings of the 14th SOSP, </booktitle> <address> Asheville, NC (December 1993). </address>
Reference-contexts: VINO places extension code into the kernel, rather than leaving it in user space (as is done in Mach). Research has shown that the cost of crossing protection boundaries (between user and system, or user-system-user, as in the case of a Mach external server) is very high <ref> [MOGUL91, CHEN93, GUIL91] </ref>. By placing extension code in the kernel, we decrease the number of protection boundary crossings, which improves performance.
Reference: [CHOU85] <author> Chou, H. and D. Dewitt, </author> <title> "An Evaluation of Buffer Management Strategies for Relational Database Systems", </title> <booktitle> Proceedings of VLDB 85, </booktitle> <pages> pp. 127-141, </pages> <address> Stockholm, </address> <month> Sweeden </month> <year> (1985). </year>
Reference-contexts: The motivation for Application-Directed Kernel Policy is to enable applications to select their own resource management policies, leaving the kernel with the task of arbitrating between competing policies. Chou and DeWitt <ref> [CHOU85] </ref> characterized disk access patterns for the different phases of operation of a relational database. Some blocks are reused, others are not.
Reference: [CHUT92] <author> Chutani, S., O. T. Anderson, M. L. Kazar, B. W. Leverett, W. A. Mason, and R. N. Side-botham, </author> <title> "The Episode File System," </title> <booktitle> Proceedings of the 1992 Winter Usenix Conference, </booktitle> <pages> pp. </pages> <month> 43-60 (Jan-uary </month> <year> 1992). </year>
Reference: [DEWI90] <author> Dewitt, D., D. Maier, P. Futtersack, and F. Velez, </author> <title> "A Study of Three Alternative Workstation-Server Architectures for ODBMS", </title> <booktitle> Proceedings of the 16th VLDB (1990). </booktitle>
Reference-contexts: The new type would implement the abstract behavior shared by all fields (i.e. get/set value, compare value with another Field), and would respond to requests to build and maintain type-specific indexes as needed. 6.3 Object Page Server An object page server <ref> [DEWI90] </ref> serves pages of objects to client applications. Several current database systems (e.g. ObjectStore [LAMB91] and QuickStore [WHITE94]) are based on this model. Object references are represented by virtual memory pointers. If an object is not in the client cache, its address is unmapped (invalid).
Reference: [DION78] <author> Dionysios, C. T., and A. Klug (eds.) </author> <title> "The ANSI/X3/SPARC CMBS Framework: Report on the Study Group on Data Base Management Systems", Information Systems, </title> <publisher> v. </publisher> <month> 3 </month> <year> (1978). </year>
Reference: [ENGL94] <author> Engler, D., M. F. Kaashoek, and J. O'Toole, </author> <title> "The Operating System Kernel as a Secure Programmable Machine" Proceedings of the Sixth SIGOPS European Workshop (September 1994). </title>
Reference: [EPPI91] <author> Eppinger, J, L. Mummert, and A. Spector, eds, "Camelot And Avalon, </author> <title> A Distributed Transaction Facility", </title> <publisher> Morgan Kaufman, </publisher> <address> San Mateo, CA (1991). </address>
Reference: [GRAY76] <author> Gray, J., Lorie, R., Putzolu, F., and Traiger, I., </author> <title> "Granularity of locks and degrees of consistency in a large shared data base," Modeling in Data Base Management Systems, </title> <publisher> Elsevier North Holland, </publisher> <address> New York, </address> <pages> pp. </pages> <month> 365-394 </month> <year> (1976). </year> <note> [GUIL91] , Guillemont, </note> <author> M., Lipkis, J., Orr, D., Rozier, M., </author> <title> "A Second-Generation Micro-Kernel Based UNIX: Lessons in Performance and Compatibility," </title> <booktitle> Proceedings of the 1991 Winter Usenix Technical Conference (January 1991). </booktitle>
Reference-contexts: This interface is available both to the kernel and to applications. As the resources being locked become more complex, so does the locking paradigm. The VINO lock manager supports general-purpose hierarchical locking <ref> [GRAY76] </ref>. For example, the file system typically requires locking on block, file, directory and file system levels. In most conventional kernels, this hierarchy is enforced by convention. In VINO, it is enforced by design. We call the various levels at which locking may be needed the containment hierarchy.
Reference: [HASK88] <author> Haskin, R., Y. Malachi, W. Sawdon, and G. Chan, </author> <title> "Recovery Management in Quicksilver", </title> <journal> ACM Transactions on Computer Systems, v. </journal> <volume> 6, </volume> <editor> n. </editor> <volume> 1, </volume> <pages> pp. </pages> <month> 82-108 (February </month> <year> 1988). </year>
Reference: [HART92] <author> Harty, K., Cheriton, D., </author> <title> "Application-Controlled Physical Memory using External Page-Cache Management," </title> <booktitle> Proceedings of ASPLOS V, </booktitle> <address> Boston MA, </address> <pages> pp. </pages> <month> 187-192 (October </month> <year> 1992). </year>
Reference-contexts: Typically, a DBMS knows in advance which pages will be needed soon, and could inform the operating system of its future requirements. There have been numerous attempts to empower applications with the ability to control prefetching and page replacement <ref> [CAO94, MCNAM90, PATT93, HART92, APPEL91] </ref>. All of these approaches provide potential solutions, but the solutions apply only to buffer management and require the implementation of special purpose mechanisms. In VINO, application-specific tailoring is the norm, not the exception.
Reference: [ILLU94] <editor> Illustra User's Guide, Illustra Server Releae 2.1, </editor> <booktitle> Illustra Information Technologies, </booktitle> <publisher> Inc., </publisher> <address> Oakland CA, </address> <month> (June </month> <year> 1994). </year>
Reference: [KLEI86] <author> S.R. Kleiman, "Vnodes: </author> <title> An Architecture for Multiple File System Types in Sun UNIX," </title> <booktitle> Proceedings of the 1986 Summer Usenix Conference, </booktitle> <pages> pp. </pages> <month> 238-247 (June </month> <year> 1986). </year>
Reference: [LAMB91] <author> Lamb, C., G. Landis, J. Orenstein, and D. Weinreb, </author> <title> "The ObjectStore Database System," </title> <journal> Communications of the ACM, v. </journal> <volume> 34, </volume> <editor> n. </editor> <volume> 10, </volume> <pages> pp. </pages> <month> 50-63 (October </month> <year> 1991). </year>
Reference-contexts: Several current database systems (e.g. ObjectStore <ref> [LAMB91] </ref> and QuickStore [WHITE94]) are based on this model. Object references are represented by virtual memory pointers. If an object is not in the client cache, its address is unmapped (invalid). When a client dereferences an unmapped pointer, a virtual memory fault takes place.
Reference: [LISK93] <author> Liskov, B., M. Day, and L. Shrira, </author> <title> "Distributed Object Management in Thor", in Distributed Object Management, </title> <publisher> Morgan Kaufmann, </publisher> <address> San Mateo, </address> <month> Cali-fornia </month> <year> (1993). </year>
Reference: [MCKU84] <author> McKusick, M., Joy, W., Le*er, S., Fabry, R., </author> <title> "A Fast File System for UNIX," </title> <journal> Transactions on Computer Systems, v. </journal> <volume> 2 n. 3, </volume> <pages> pp. </pages> <month> 181-197 (August </month> <year> 1984). </year>
Reference-contexts: For example, a filesystem stores both data (file contents) and metadata (directory structure). When the metadata is modified, the modifications must be written out in such a way that the metadata can be recovered in case of a crash. Some filesystems carefully order writes (e.g. the Berkeley Fast Filesystem <ref> [MCKU84] </ref>); others use a write-ahead log for the meta-data ([CHUT92, CHANG90]). Still other file systems use a log-structured representation for the entire file system [ROSE91]. While all these systems provide transaction semantics to metadata operations, none export this functionality to user-level.
Reference: [MCNAM90] <author> McNamee, D., and K. Armstrong, </author> <title> "Extending The Mach External Pager Interface To Accommodate User-Level Page Replacement Policies," </title> <booktitle> Proceedings of the 1990 Usenix Mach Workshop, </booktitle> <address> Burlington, VT (1990). </address>
Reference-contexts: Typically, a DBMS knows in advance which pages will be needed soon, and could inform the operating system of its future requirements. There have been numerous attempts to empower applications with the ability to control prefetching and page replacement <ref> [CAO94, MCNAM90, PATT93, HART92, APPEL91] </ref>. All of these approaches provide potential solutions, but the solutions apply only to buffer management and require the implementation of special purpose mechanisms. In VINO, application-specific tailoring is the norm, not the exception.
Reference: [MOGUL91] <author> Mogul, J, and Borg, A., </author> <title> "The Affect of Context Switches on Cache Performance", </title> <booktitle> Proceedings of ASPLOS IV (1991). </booktitle>
Reference-contexts: VINO places extension code into the kernel, rather than leaving it in user space (as is done in Mach). Research has shown that the cost of crossing protection boundaries (between user and system, or user-system-user, as in the case of a Mach external server) is very high <ref> [MOGUL91, CHEN93, GUIL91] </ref>. By placing extension code in the kernel, we decrease the number of protection boundary crossings, which improves performance.
Reference: [MYERS93] <author> Myers, A., </author> <booktitle> "Resolving the Integrity / Performance Conflict" Fourth Workshop on Workstation Operating Systems, </booktitle> <pages> pp. </pages> <month> 156-159 (October </month> <year> 1993). </year>
Reference: [NELS88] <author> Nelson, M., Welch, B., and Ousterhout, J., </author> <title> "Caching in the Sprite Network File System", </title> <journal> ACM Transactions on Computer Systems, v. </journal> <volume> 6, </volume> <editor> n. </editor> <month> 1 (February </month> <year> 1988). </year>
Reference-contexts: Modification of virtual memory protection is done without performing a system call. It can take less time to copy a page of data over the network than to read it from a local disk <ref> [NELS88] </ref>. If the server has a page in its in-memory cache, a client need not write an unmodified page to disk when it is evicted.
Reference: [ORA89] <institution> Oracle Database Administrator's Guide, Oracle Corporation, </institution> <month> 3601-V6.0 (April </month> <year> 1989). </year>
Reference: [PATT93] <author> Patterson, R., G. Gibson, M. Satyanarayanan, </author> <title> "A Status Report on Transparent Informed Prefetching", Operating Systems Review, </title> <editor> v. </editor> <volume> 27, </volume> <editor> n. </editor> <volume> 2, </volume> <pages> pp. </pages> <month> 21-34 (April </month> <year> 1993). </year>
Reference-contexts: Typically, a DBMS knows in advance which pages will be needed soon, and could inform the operating system of its future requirements. There have been numerous attempts to empower applications with the ability to control prefetching and page replacement <ref> [CAO94, MCNAM90, PATT93, HART92, APPEL91] </ref>. All of these approaches provide potential solutions, but the solutions apply only to buffer management and require the implementation of special purpose mechanisms. In VINO, application-specific tailoring is the norm, not the exception.
Reference: [PRES90] <author> Presotto, D., R. Pike, H. Trickey, and K. Thompson, </author> <title> "Plan 9, a Distributed System, </title> <booktitle> Proceedings of the Spring 1991 EurOpen Conference (May 1991). </booktitle>
Reference-contexts: Network sockets and disk files are both accessed through the use of file descriptors, although they are supported by entirely different implementations. Some systems (e.g. Plan 9 <ref> [PRES90] </ref>) choose a single, compromise interface for all resources. The disadvantage of choosing one abstraction for all resources is that each must implement the complete interface, and none can extend it.
Reference: [RABIN81] <author> Rabin, M., </author> <title> "Fingerprinting by Random Polynomials", </title> <institution> Harvard University Center for Research in Computing Technology TR-15-81 (1981). </institution> <month> 10 </month>
Reference-contexts: Sandboxing masks faults instead of detecting them, but it is more efficient than range checking. Code generated by the graft compiler is marked with an encrypted fingerprint that is effectively impossible to forge <ref> [RABIN81] </ref>. A fingerprint is a type of digital signature; if the fingerprint for a file is valid, its contents have not been modified.
Reference: [RASH88] <author> Rashid, R., A. Tevanian, M. Young, D. Golub, R. Baron, D. Black, W. Bolosky and J. Chew, </author> <title> "Machine-Independent Virtual Memory Management for Page Uniprocessor and Multiprocessor Architectures," </title> <journal> IEEE Transactions on Computers, v. </journal> <volume> 37, </volume> <editor> n. </editor> <month> 8 (August </month> <year> 1988). </year>
Reference: [ROSE91] <author> Rosenblum, M., Ousterhout, J. K., </author> <title> "The Design and Implementation of a Log-Structured File System," </title> <journal> Transactions on Computer Systems v. </journal> <volume> 10, </volume> <editor> n. </editor> <volume> 1, </volume> <pages> pp. </pages> <month> 26-52 (February </month> <year> 1992). </year>
Reference-contexts: Some filesystems carefully order writes (e.g. the Berkeley Fast Filesystem [MCKU84]); others use a write-ahead log for the meta-data ([CHUT92, CHANG90]). Still other file systems use a log-structured representation for the entire file system <ref> [ROSE91] </ref>. While all these systems provide transaction semantics to metadata operations, none export this functionality to user-level. In VINO, general-purpose log management code is used to facilitate the management of filesystem metadata, and is also available for use by applications.
Reference: [SELT92] <author> Seltzer, M., Olson, M., "LIBTP: </author> <title> Portable, Modular Transactions for UNIX," </title> <booktitle> Proceedings 1992 Winter Usenix Conference, </booktitle> <address> San Francisco, CA, </address> <pages> pp. </pages> <month> 9-26 (January </month> <year> 1992). </year>
Reference-contexts: For example, System V-style user-level semaphores incur a large number of system calls and context switches while simple spin-locks are virtually free <ref> [SELT92] </ref>. VINO provides a kernel lock manager, accessible to resources. In its simplest form, the lock manager provides spin-lock synchronization on memory locations, requiring kernel intervention only in the case of a contested lock. This interface is available both to the kernel and to applications.
Reference: [SELT93] <author> Seltzer, M., K. Bostic, M. K. McKusic, and C. Staelin, </author> <title> "An Implementation of a Log-structured Filesystem for UNIX", </title> <booktitle> Proceedings of the Winter Usenix Conference (January 1993). </booktitle>
Reference-contexts: Relational systems use this model to represent data as tuples, whether the data is stored in a B-tree, hash table, or other structure. Operating systems use this model as well; for example, the Network File System, the Berkeley Fast Filesystem, and the Berkeley Log-structured Filesystem <ref> [SELT93] </ref> provide the same interface to application programs, but the underlying representations are very different. Network sockets and disk files are both accessed through the use of file descriptors, although they are supported by entirely different implementations. Some systems (e.g.
Reference: [SKAR94] <author> Skarra, A., </author> <title> "Using OS Locking Services to Implement a DBMS: An Experience Report", </title> <booktitle> Proceedings of the Summer USENIX Conference, </booktitle> <address> Boston MA, </address> <pages> pp. </pages> <month> 73-86 (June </month> <year> 1994). </year>
Reference: [SOLA94] <institution> Solaris 2.3 User's Guide, Sun Microsystems (1994). </institution>
Reference: [STON81] <author> Stonebraker, M., </author> <title> "Operaing System Support for Database Management", </title> <journal> Communications of the ACM, v. </journal> <volume> 24, </volume> <editor> n. </editor> <volume> 7, </volume> <pages> pp. </pages> <month> 412-418 (July </month> <year> 1981). </year>
Reference: [STON87] <author> Stonebraker, M., and L. Rowe, </author> <note> "The POST-GRES Papers", Memorandum No. </note> <institution> UCB/ERL M86/85, Electronics Research Laboratory, University of California, </institution> <address> Berkeley (June 1987). </address>
Reference: [SULL91] <author> Sullivan, M., and R. Chillarege, </author> <title> "Software Defects and Their Impact on System Availability A Study of Field Failures in Operating Systems", </title> <booktitle> Digest 21st International Symposium on Fault Tolerant Computing (June 1991). </booktitle>
Reference: [SYB90] <institution> Sybase Administration Guide, Sybase Corporation, 3250-4.2 Rev. </institution> <month> 3 (May </month> <year> 1990). </year>
Reference: [WAHBE93] <author> Wahbe, R., Lucco, S., Anderson, T., and Graham, S., </author> <title> "Efficient Software-Based Fault Isolation", </title> <booktitle> Proceedings of the 14th SOSP, </booktitle> <address> Asheville, NC (December 1993). </address>
Reference-contexts: The graft compiler inserts range checks on all memory accesses (including function calls). The checks ensure that a graft does not stray outside its bounds, or modify itself to do so. A second scheme that ensures safety, sandboxing, was proposed by Wahbe et al. <ref> [WAHBE93] </ref>. Sandboxing assigns a range of memory to the code and data of each graft. Instructions are inserted into the code which force all memory references to fall within the assigned segments. Sandboxing masks faults instead of detecting them, but it is more efficient than range checking.
Reference: [WHITE94] <author> White, S., DeWitt, D., </author> <title> "QuickStore: A High Performance Mapped Object Store", </title> <booktitle> Proceedings of SIGMOD 94, </booktitle> <address> Minneapolis, MN (May 1994). </address> <month> 11 </month>
Reference-contexts: Several current database systems (e.g. ObjectStore [LAMB91] and QuickStore <ref> [WHITE94] </ref>) are based on this model. Object references are represented by virtual memory pointers. If an object is not in the client cache, its address is unmapped (invalid). When a client dereferences an unmapped pointer, a virtual memory fault takes place.
References-found: 42

