URL: http://www.win.tue.nl/win/cs/csr/csr93/93.41.ps
Refering-URL: http://www.win.tue.nl/win/cs/csr/csr93.html
Root-URL: http://www.win.tue.nl
Title: Temporal operators viewed as predicate transformers  
Author: A. Bijlsma 
Address: P.O. Box 513, 5600 MB Eindhoven, The Netherlands  
Affiliation: Department of Mathematics and Computing Science Eindhoven University of Technology  
Date: 1  November 14, 1995  
Pubnum: AB34e  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> K.R. Apt & E.-R. Olderog, </author> <title> Verification of sequential and concurrent programs. </title> <publisher> Springer, </publisher> <address> New York, </address> <year> 1991. </year> <note> AB34e 11 </note>
Reference-contexts: In particular, verifying that a particular mathematical object satisfies the axioms now merely entails checking the two defining properties of a shift operator. This has been done in [2] for an operational semantics in the style of <ref> [1] </ref> in order to provide a language-independent definition of the progress predicate transformer proposed in [12]. How to lift the restriction to deterministic computations is discussed in [6].
Reference: [2] <author> A. Bijlsma, </author> <title> A shift operator for deterministic progress. </title> <institution> Memorandum AB38. Eindhoven University of Technology, </institution> <month> December </month> <year> 1992. </year>
Reference-contexts: In particular, verifying that a particular mathematical object satisfies the axioms now merely entails checking the two defining properties of a shift operator. This has been done in <ref> [2] </ref> for an operational semantics in the style of [1] in order to provide a language-independent definition of the progress predicate transformer proposed in [12]. How to lift the restriction to deterministic computations is discussed in [6].
Reference: [3] <author> R.T. Boute, </author> <title> `A calculus for reasoning about temporal phenomena', </title> <booktitle> in: Stimulerende informatica (proceedings NGI-SION Symposium 1986). </booktitle> <publisher> Stichting Informatica Congressen, Amsterdam, </publisher> <pages> 1986; pp. 405-411. </pages>
Reference-contexts: It is our contention that the calculus proposed below, while equivalent in its descriptive power, places less of a burden on the user. Our approach was inspired by work of Boute <ref> [3] </ref> and Hehner [8], but diverges from these in that we refrain from explicit mention of time coordinates. In [5], E.W. Dijkstra and C.S. Scholten presented a version of predicate calculus based on equational reasoning rather than natural deduction. <p> The term `shift operator' is taken from <ref> [3] </ref>, where it denotes the particular substition t := t + t , a translation in time. However, as we shall see, it is not necessary to be that specific. <p> The advantages of this are argued at length in <ref> [3] </ref>. A valid criticism of our approach is that it corresponds to something stronger than ordinary temporal logic: in our system we might express phrases like `after k steps', a possibility lacking in standard versions of temporal logic [10][14].
Reference: [4] <author> R.T. Boute, </author> <title> `On the shortcomings of the axiomatic approach as presently used in computer science', in: System design: concepts, methods, </title> <booktitle> and tools (proceedings IEEE Com-pEuro 88). IEEE Computer Society, </booktitle> <address> Washington, </address> <note> 1988; pp. 184-193. </note>
Reference-contexts: This may be a disadvantage if one is interested in proving properties of the calculus itself, but it is a great advantage when the calculus is being used as a tool in proving properties of actual programs <ref> [4] </ref>. When the same principles are applied to program semantics, the axioms and inference rules of Floyd-Hoare logic are replaced with the definition of a class of predicate transformers called weakest preconditions. <p> From the point of view of applications, however, this can hardly be called a sacrifice at all, as it actually facilitates the embedding of temporal concepts in other systems of description and specification: our calculus constitutes an `open semantics' in the sense of <ref> [4] </ref>, whereas temporal logic does not. The advantages of this are argued at length in [3].
Reference: [5] <author> E.W. Dijkstra & C.S. Scholten, </author> <title> Predicate calculus and program semantics. </title> <publisher> Springer, </publisher> <address> New York, </address> <year> 1990. </year>
Reference-contexts: Our approach was inspired by work of Boute [3] and Hehner [8], but diverges from these in that we refrain from explicit mention of time coordinates. In <ref> [5] </ref>, E.W. Dijkstra and C.S. Scholten presented a version of predicate calculus based on equational reasoning rather than natural deduction. Their work, whose style owes more to algebra than to logic, leads to very smooth calculational proofs. <p> Finally, in section 5, examples demonstrate that reasoning with shift operators often leads to proofs that are considerably shorter than those of temporal logic. AB34e 2 Our point of departure is the predicate calculus as developed in <ref> [5] </ref>, whose notation and terminology are adopted. In particular, square brackets denote universal quantification over the anonymous state space. <p> This discrepancy is caused by the absence of our square brackets in the system of [13], and, conversely, by the absence of meta-language symbols for provability in the system of <ref> [5] </ref>.
Reference: [6] <author> R.M. Dijkstra, </author> <title> Temporal operators and fixpoint calculus. </title> <institution> Memorandum rutger10. University of Groningen, </institution> <month> April </month> <year> 1993. </year>
Reference-contexts: This has been done in [2] for an operational semantics in the style of [1] in order to provide a language-independent definition of the progress predicate transformer proposed in [12]. How to lift the restriction to deterministic computations is discussed in <ref> [6] </ref>. What we have sacrificed is self-containedness: rather than imposing a formal proof system with its own inference rules, we have elected to work within the framework of mathematics and predicate algebra.
Reference: [7] <author> R. Goldblatt, </author> <title> Logics of time and computation. </title> <publisher> CSLI, Stanford, </publisher> <year> 1987. </year>
Reference-contexts: AB34e 10 6 Discussion The preceding pages do not provide any new insight into temporal logic: indeed, the connection between linear-time temporal logic and the order type of the natural numbers is well-known <ref> [7, chap. 8] </ref>. What we have achieved is an equivalent alternative characterization of predicate transformers in the Dijkstra-Scholten calculus that satisfy the axioms of temporal logic.
Reference: [8] <author> E.C.R. Hehner, </author> <title> `Termination is timing', </title> <editor> in: J.L.A. van de Snepscheut (ed.), </editor> <booktitle> Mathematics of Program Construction. Lecture Notes in Computer Science 375. </booktitle> <publisher> Springer, Berlin, </publisher> <pages> 1989; pp. 35-47. </pages>
Reference-contexts: It is our contention that the calculus proposed below, while equivalent in its descriptive power, places less of a burden on the user. Our approach was inspired by work of Boute [3] and Hehner <ref> [8] </ref>, but diverges from these in that we refrain from explicit mention of time coordinates. In [5], E.W. Dijkstra and C.S. Scholten presented a version of predicate calculus based on equational reasoning rather than natural deduction.
Reference: [9] <author> F. Kroger, </author> <title> Temporal logics of programs. </title> <booktitle> EATCS Monographs on Theoretical Computer Science 8. </booktitle> <publisher> Springer, </publisher> <address> Berlin, </address> <year> 1987. </year>
Reference-contexts: This axiom system has been selected because it seems to be the best-known one, not because it is in any sense minimal. (For instance, (8) can be derived from the other axioms.) Different and smaller axiomatizations can be found in the literature <ref> [9] </ref>. 3 From shift operators to temporal logic Theorem 3 Let ffi be a shift operator.
Reference: [10] <author> R.P. Kurshan, S.S. Pinter, & B. Solomon, </author> <title> `Extensions of temporal logic for counting with applications to model verification', </title> <editor> in: E. Brinksma, G. Scollo, & C.A. Vissers (eds.), </editor> <title> Protocol specification, testing, and verification IX . North Holland, </title> <publisher> Amsterdam, </publisher> <pages> 1990; pp. 373-386. </pages>
Reference: [11] <author> L. Lamport, </author> <title> `What good is temporal logic?', in: R.E.A. </title> <editor> Mason (ed.), </editor> <booktitle> Information Processing 83 . North Holland, </booktitle> <address> Amsterdam, </address> <note> 1983; pp. 657- 668. </note>
Reference-contexts: Another possible criticism centres on the prominent role of the `next' operator, which, although part of linear time temporal logic, enjoys a bad reputation because it does not correspond to macroscopically relevant program properties <ref> [11] </ref>. It seems that this objection is best addressed by prohibiting the use of `next' in specifications; it does not follow that `next' must be avoided in the construction of the underlying theory. Acknowledgements Many colleagues at Eindhoven University contributed valuable comments on previous drafts of this paper.
Reference: [12] <author> J.J. Lukkien & J.L.A. van de Snepscheut, </author> <title> `Weakest preconditions for progress'. Formal Asp. </title> <journal> Comp. </journal> <volume> 4 (1992), </volume> <pages> 195-236. </pages>
Reference-contexts: This has been done in [2] for an operational semantics in the style of [1] in order to provide a language-independent definition of the progress predicate transformer proposed in <ref> [12] </ref>. How to lift the restriction to deterministic computations is discussed in [6]. What we have sacrificed is self-containedness: rather than imposing a formal proof system with its own inference rules, we have elected to work within the framework of mathematics and predicate algebra.
Reference: [13] <author> Z. Manna & A. Pnueli, </author> <title> `Verification of concurrent programs: a temporal proof system', </title> <editor> in: J.W. de Bakker & J. van Leeuwen (eds.), </editor> <booktitle> Foundations of Computer Science IV. Distributed systems: part 2, semantics and logic. </booktitle> <publisher> Mathematical Centre Tracts 159. Mathe-matisch Centrum, Amsterdam, </publisher> <pages> 1983; pp. 163-255. </pages>
Reference-contexts: Temporal logic is a form of modal logic, designed for the description of time-dependent phenomena. Several different kinds of temporal logic have been proposed, but in the present paper only the linear time version <ref> [13] </ref> is treated. A common characteristic of all kinds of temporal logic is that they require a large number of irregularly-shaped axioms; as a result, proofs within such a system tend to be tortuous and mystifying. <p> fl p] ; (8) [2p ) fl 2p] ; (10) AB34e 3 [:3p j 2:p] ; (13) [p U q j q _ (p ^ fl (p U q))] : (15) Formulae (4) through (15) are the equivalent, in our notation, of the axioms of temporal logic as presented in <ref> [13] </ref>. This is immediately obvious except, perhaps, in the case of (7), which figures in [13] as an inference rule rather than an axiom. This discrepancy is caused by the absence of our square brackets in the system of [13], and, conversely, by the absence of meta-language symbols for provability in <p> ; (13) [p U q j q _ (p ^ fl (p U q))] : (15) Formulae (4) through (15) are the equivalent, in our notation, of the axioms of temporal logic as presented in <ref> [13] </ref>. This is immediately obvious except, perhaps, in the case of (7), which figures in [13] as an inference rule rather than an axiom. This discrepancy is caused by the absence of our square brackets in the system of [13], and, conversely, by the absence of meta-language symbols for provability in the system of [5]. <p> our notation, of the axioms of temporal logic as presented in <ref> [13] </ref>. This is immediately obvious except, perhaps, in the case of (7), which figures in [13] as an inference rule rather than an axiom. This discrepancy is caused by the absence of our square brackets in the system of [13], and, conversely, by the absence of meta-language symbols for provability in the system of [5]. <p> 2p j fdefinitions of fl and 2 g ffi:(8j :: ffi j :p) j f ffi distributes over logicg (8j :: ffi:(ffi j :p)) j fassociativity of functional compositiong AB34e 9 j fdefinitions of 2 and fl g 2 fl p : This theorem is proved as Theorem 16 in <ref> [13] </ref>. There the proof has 14 steps and uses several derived inference rules. Theorem 6 [p U (q _ r) j (p U q) _ (p U r)] . <p> (A:j ^ ffi j :q) _ (A:j ^ ffi j :r)) j fterm splitg (9j :: A:j ^ ffi j :q) _ (9j :: A:j ^ ffi j :r) j fdefinition of U g (p U q) _ (p U r) : This theorem is proved as Theorem 30 in <ref> [13] </ref>. There the proof has 15 steps and uses an auxiliary theorem. Theorem 7 [true U p j 3p] .
Reference: [14] <author> P. Wolper, </author> <title> `Temporal logic can be more expressive'. </title> <booktitle> Information and Control 56 (1983), </booktitle> <pages> 72-99. </pages>
References-found: 14

