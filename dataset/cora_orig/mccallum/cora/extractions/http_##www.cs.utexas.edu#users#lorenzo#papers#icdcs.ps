URL: http://www.cs.utexas.edu/users/lorenzo/papers/icdcs.ps
Refering-URL: http://www.cs.utexas.edu/users/lorenzo/publications.html
Root-URL: 
Title: Message Logging: Pessimistic, Optimistic, and Causal  
Author: Lorenzo Alvisi Keith Marzullo 
Address: Ithaca, NY  La Jolla, CA  
Affiliation: Cornell University Department of Computer Science  University of California, San Diego Department of Computer Science and Engineering  
Abstract: Message logging protocols are an integral part of a technique for implementing processes that can recover from crash failures. All message logging protocols require that, when recovery is complete, there be no orphan processes, which are surviving processes whose states are inconsistent with the recovered state of a crashed process. We give a precise specification of the consistency property "no orphan processes". From this specification, we describe how different existing classes of message logging protocols (namely optimistic, pessimistic, and a class that we call causal) implement this property. We then propose a set of metrics to evaluate the performance of message logging protocols, and characterize the protocols that are optimal with respect to these metrics. Finally, starting from a protocol that relies on causal delivery order, we show how to derive optimal causal protocols that tolerate f overlapping failures and recoveries for a parameter f : 1 f n. 
Abstract-found: 1
Intro-found: 1
Reference: [AHM93] <author> Lorenzo Alvisi, Bruce Hoppe, and Keith Marzullo. </author> <title> Nonblocking and orphan-free message logging protocols. </title> <booktitle> In Proceedings of the 23rd Fault-Tolerant Computing Symposium, </booktitle> <pages> pages 145-154, </pages> <month> June </month> <year> 1993. </year>
Reference-contexts: We call such protocols causal message logging protocols, for reasons that will become clear later. Examples of this class are presented in [EZ92] and <ref> [AHM93] </ref>. All message logging protocols must address the problem of recovering a process that communicates with the environment, such as sensors, terminals and actuators. It is natural to model such communication in terms of the sending and delivery of messages. <p> Hence, we call the protocols in this class causal message logging protocols. Family-Based-Logging <ref> [AHM93] </ref> and Manetho [EZ92] are two examples of causal message logging protocols for the special cases f = 1 and f = n respectively. 3 In pessimistic sender based logging [JZ87] process m.dest increases jLog (m)j by sending the value of m.rsn to process m:source, piggybacked on the acknowledgment of message <p> Nevertheless, the protocols that we call optimal are unique in optimally addressing the theoretical desiderata of the message logging approach. 6 Deriving an Optimal Causal Protocol Family-Based-Logging <ref> [AHM93] </ref> and Manetho [EZ92] are two examples of optimal causal protocols for the special cases f = 1 and f = n respectively.
Reference: [AM94] <author> Lorenzo Alvisi and Keith Marzullo. </author> <title> Optimal message logging protocols. </title> <type> Technical Report TR94-1457, </type> <institution> Cornell University Department of Computer Science, </institution> <month> September </month> <year> 1994. </year>
Reference-contexts: A thorough discussion of such optimal causal protocols and of the tradeoffs involved in their implementation is presented in <ref> [AM94] </ref>. The paper proceeds as follows. Section 2 describes the system model commonly assumed for message logging protocols. Section 3 discusses the notion of consistency in message logging protocols. Section 4 presents the derivation of the "no-orphan processes" condition, and explains how pessimistic, optimistic and causal protocols implement it. <p> However, this protocol can be used as the starting point of a refinement to a more efficient protocol by choosing an instance of a causal delivery order protocol. For example, the class of 8 optimal causal message logging protocols described in <ref> [AM94] </ref> can be derived by choosing the original ISIS causal multicast protocol [BJ87]. Consider Property 10. If q does not know that m 1 has already reached r, then q can include a copy of m 1 piggybacked on m 2 . <p> Two important questions are how to represent jLog (m)j and evaluate the condition jLog (m)j f efficiently, and how to use the logged information to perform recovery. We discuss these issues in <ref> [AM94] </ref>, in which we present a class of optimal causal protocols that tolerate f overlapping failures and recoveries for a parameter f : 1 f n. <p> A thorough discussion of optimal protocols and of the tradeoffs involved in their implementation is presented in <ref> [AM94] </ref>. Acknowledgments We would like to thank Bruce Hoppe, Fred Schneider and Sam Toueg for many discussions on this research and on early versions of this paper. We would also like to thank Matthew Clegg and Jeremy Sussman for their comments on drafts of this paper. 9
Reference: [BBG83] <author> Anita Borg, J. Baumbach, and S. Glazer. </author> <title> A message system supporting fault tolerance. </title> <booktitle> In Proceedings of the Symposium on Operating Systems Principles, </booktitle> <pages> pages 90-99. </pages> <publisher> ACM SIGOPS, </publisher> <month> October </month> <year> 1983. </year>
Reference-contexts: 1 Introduction Message logging (for example, <ref> [BBG83, PP83, SY85, JZ87, SBY88, SW89, JZ90, VJ94, EZ92] </ref>) is a common technique used to build systems that can tolerate process crash failures. These protocols require that each process periodically record its local state and log the messages it received after having recorded that state. <p> For purposes of completeness, we define pessimistic protocols that log the determinant of m in local stable storage to be 1-blocking, since there is one event (the acknowledgment of #m being written to stable storage) that must occur between deliver m:dest (m) and a subsequent send <ref> [BBG83] </ref>.
Reference: [BJ87] <author> Kenneth Birman and Tommy Joseph. </author> <title> Reliable communication in the presence of failures. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 5(2) </volume> <pages> 47-76, </pages> <month> February </month> <year> 1987. </year>
Reference-contexts: For example, the class of 8 optimal causal message logging protocols described in [AM94] can be derived by choosing the original ISIS causal multicast protocol <ref> [BJ87] </ref>. Consider Property 10. If q does not know that m 1 has already reached r, then q can include a copy of m 1 piggybacked on m 2 .
Reference: [BSS91] <author> K. Birman, A. Schiper, and P. Stephenson. </author> <title> Lightweight causal and atomic group multi-cast. </title> <journal> ACM Transactions on Computer System, </journal> <volume> 9(3) </volume> <pages> 272-314, </pages> <month> August </month> <year> 1991. </year>
Reference-contexts: We now show how optimal causal protocols for arbitrary values of f can be derived by giving the outline of a refinement starting from a message logging protocol that uses causal delivery order <ref> [BSS91] </ref>. Let send p (m) to q denote the event whereby process p sends message m to process q.
Reference: [CL85] <author> K. M. Chandy and L. Lamport. </author> <title> Distributed snapshots: determining global states of distributed systems. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 3(1) </volume> <pages> 63-75, </pages> <month> February </month> <year> 1985. </year>
Reference-contexts: A collection of states, one from each process, is a consistent global state if all pairs of states are mutually consistent <ref> [CL85] </ref>; 1 otherwise it is 1 This definition is different from that of [CL85] in that it is defined in terms of deliver events rather than receive events. Our usage corresponds to the literature on message-logging protocols. 2 inconsistent. <p> A collection of states, one from each process, is a consistent global state if all pairs of states are mutually consistent <ref> [CL85] </ref>; 1 otherwise it is 1 This definition is different from that of [CL85] in that it is defined in terms of deliver events rather than receive events. Our usage corresponds to the literature on message-logging protocols. 2 inconsistent.
Reference: [EZ92] <author> E. N. Elnozahy and W. Zwaenepoel. Manetho: </author> <title> Transparent rollback-recovery with low overhead, limited rollback and fast output commit. </title> <journal> IEEE Transactions on Computers, </journal> <volume> 41(5) </volume> <pages> 526-531, </pages> <month> May </month> <year> 1992. </year>
Reference-contexts: 1 Introduction Message logging (for example, <ref> [BBG83, PP83, SY85, JZ87, SBY88, SW89, JZ90, VJ94, EZ92] </ref>) is a common technique used to build systems that can tolerate process crash failures. These protocols require that each process periodically record its local state and log the messages it received after having recorded that state. <p> We call such protocols causal message logging protocols, for reasons that will become clear later. Examples of this class are presented in <ref> [EZ92] </ref> and [AHM93]. All message logging protocols must address the problem of recovering a process that communicates with the environment, such as sensors, terminals and actuators. It is natural to model such communication in terms of the sending and delivery of messages. <p> Hence, we call the protocols in this class causal message logging protocols. Family-Based-Logging [AHM93] and Manetho <ref> [EZ92] </ref> are two examples of causal message logging protocols for the special cases f = 1 and f = n respectively. 3 In pessimistic sender based logging [JZ87] process m.dest increases jLog (m)j by sending the value of m.rsn to process m:source, piggybacked on the acknowledgment of message m. <p> Nevertheless, the protocols that we call optimal are unique in optimally addressing the theoretical desiderata of the message logging approach. 6 Deriving an Optimal Causal Protocol Family-Based-Logging [AHM93] and Manetho <ref> [EZ92] </ref> are two examples of optimal causal protocols for the special cases f = 1 and f = n respectively.
Reference: [EZ94] <author> E.N. Elnozahy and W. Zwaenepoel. </author> <title> On the use and implementation of message logging. </title> <booktitle> In Digest of Papers: 24 Annual International Symposium on Fault-Tolerant Computing, </booktitle> <pages> pages 298-307. </pages> <publisher> IEEE Computer Society, </publisher> <month> June </month> <year> 1994. </year>
Reference-contexts: In addition, other issues that are difficult to quantify, such as the cost of output commit, must be taken into consideration in assessing the performance of a message logging protocol <ref> [EZ94] </ref>.
Reference: [Gra77] <author> James N. Gray. </author> <title> Notes on data base operating systems. </title> <editor> In R. Bayer, R. M. Graham, and G. Seegmueller, editors, </editor> <booktitle> Operating Systems: An Advanced Course, </booktitle> <pages> pages 393-481. </pages> <publisher> Springer-Verlag, </publisher> <year> 1977. </year> <note> Lecture Notes on Computer Science 60. </note>
Reference-contexts: Some message logging protocols take advantage of stable storage, a system utility used to atomically and reliably log data for later retrieval <ref> [Gra77] </ref>. If the determinant of deliver m:dest (m) is logged in stable storage, then any subset of the processes in N can crash without #m being lost. In this case, we will say that the size of Log (m), written jLog (m)j, is greater than n.
Reference: [JV87] <author> T.Y. Juang and S. Venkatesan. </author> <title> Crash recovery with little overhead. </title> <booktitle> In Proceedings of the 11th International Conference on Distributed Computing Systems, </booktitle> <pages> pages 454-461. </pages> <publisher> IEEE Computer Society, </publisher> <month> June </month> <year> 1987. </year>
Reference-contexts: An example of such a protocol is given in <ref> [JV87] </ref> where the value of #m for some message m may be inferred by "holes" in the sequence of logged receive sequence numbers.
Reference: [JZ87] <author> D.B. Johnson and W. Zwaenepoel. </author> <title> Sender-based message logging. </title> <booktitle> In Digest of Papers: 17 Annual International Symposium on Fault-Tolerant Computing, </booktitle> <pages> pages 14-19. </pages> <publisher> IEEE Computer Society, </publisher> <month> June </month> <year> 1987. </year>
Reference-contexts: 1 Introduction Message logging (for example, <ref> [BBG83, PP83, SY85, JZ87, SBY88, SW89, JZ90, VJ94, EZ92] </ref>) is a common technique used to build systems that can tolerate process crash failures. These protocols require that each process periodically record its local state and log the messages it received after having recorded that state. <p> Hence, we call the protocols in this class causal message logging protocols. Family-Based-Logging [AHM93] and Manetho [EZ92] are two examples of causal message logging protocols for the special cases f = 1 and f = n respectively. 3 In pessimistic sender based logging <ref> [JZ87] </ref> process m.dest increases jLog (m)j by sending the value of m.rsn to process m:source, piggybacked on the acknowledgment of message m. <p> We say that a message logging protocol is k-blocking if, in all failure-free runs and for all messages m, process m.dest delivers no less than k messages between deliver m:dest (m) and e. For example, pessimistic sender-based logging <ref> [JZ87] </ref> is 1-blocking because process m.dest must receive a message acknowledging the logging of m.rsn before sending a message subsequent to the delivery of m. Optimistic protocols are, by design, 0-blocking. <p> Suppose now that is run using instead of ` . We say that sends additional messages in if sends more messages than ` . For example, in order to tolerate single crash failures pessimistic sender based logging <ref> [JZ87] </ref> potentially requires that one extra acknowledgment be sent for each message exchanged in the system.
Reference: [JZ90] <author> D.B. Johnson and W. Zwaenepoel. </author> <title> Recovery in distributed systems using optimistic message logging and checkpointing. </title> <journal> Journal of Algorithms, </journal> <volume> 11 </volume> <pages> 462-491, </pages> <year> 1990. </year>
Reference-contexts: 1 Introduction Message logging (for example, <ref> [BBG83, PP83, SY85, JZ87, SBY88, SW89, JZ90, VJ94, EZ92] </ref>) is a common technique used to build systems that can tolerate process crash failures. These protocols require that each process periodically record its local state and log the messages it received after having recorded that state.
Reference: [Lam78] <author> Leslie Lamport. </author> <title> Time, clocks, and the ordering of events in a distributed system. </title> <journal> Communications of the ACM, </journal> <volume> 21(7) </volume> <pages> 558-565, </pages> <month> July </month> <year> 1978. </year>
Reference-contexts: The execution of the system is represented by a run, which is an irreflexive partial ordering of the send events, receive events and local events ordered by potential causality <ref> [Lam78] </ref>. Delivery events are local events that represent the delivery of a received message to the application or applications running in that process. For any message m from process p to process q, q delivers m only if it has received m, and q delivers m no more than once. <p> For any message m from process p to process q, q delivers m only if it has received m, and q delivers m no more than once. We use the happens-before relationship of Lamport <ref> [Lam78] </ref>.
Reference: [Pnu77] <author> Amir Pnueli. </author> <title> The temporal logic of programs. </title> <booktitle> In Proceedings of the Eighteenth Annual Symposium on Foundations of Computer Science, </booktitle> <pages> pages 46-57, </pages> <month> November </month> <year> 1977. </year> <month> 10 </month>
Reference-contexts: Thus, optimistic message logging protocols implement the following weaker property: 8m : ((jLog (m)j f ) ) ((Log (m) C) ) 3 (Depend (m) C))) (5) where 3 is the temporal "eventually" operator <ref> [Pnu77] </ref>. Pessimistic message logging protocols, however, do not admit orphans and so must implement Property 4.
Reference: [PP83] <author> M.L. Powell and D.L. Presotto. </author> <title> Publishing: A reliable broadcast communication mech-anism. </title> <booktitle> In Proceedings of the Ninth Symposium on Operating System Principles, </booktitle> <pages> pages 100-109. </pages> <publisher> ACM SIGOPS, </publisher> <month> October </month> <year> 1983. </year>
Reference-contexts: 1 Introduction Message logging (for example, <ref> [BBG83, PP83, SY85, JZ87, SBY88, SW89, JZ90, VJ94, EZ92] </ref>) is a common technique used to build systems that can tolerate process crash failures. These protocols require that each process periodically record its local state and log the messages it received after having recorded that state.
Reference: [SBY88] <author> R. E. Strom, D. F. Bacon, and S. A. Yemini. </author> <title> Volatile logging in n-fault-tolerant distributed systems. </title> <booktitle> In Proceedings of the Eighteenth Annual International Symposium on Fault-Tolerant Computing, </booktitle> <pages> pages 44-49, </pages> <year> 1988. </year>
Reference-contexts: 1 Introduction Message logging (for example, <ref> [BBG83, PP83, SY85, JZ87, SBY88, SW89, JZ90, VJ94, EZ92] </ref>) is a common technique used to build systems that can tolerate process crash failures. These protocols require that each process periodically record its local state and log the messages it received after having recorded that state. <p> Our usage corresponds to the literature on message-logging protocols. 2 inconsistent. We assume that processes are piecewise deterministic <ref> [SBY88] </ref> in that the only nondeterminism in a process arises from the nondeterministic order in which messages are received.
Reference: [Sch84] <author> Fred B. Schneider. </author> <title> Byzantine generals in action: Implementing fail-stop processors. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 2(2) </volume> <pages> 145-154, </pages> <month> May </month> <year> 1984. </year>
Reference-contexts: The state interval p [0] is defined to be the interval of states of p from its initial state to the state immediately before the delivery of the first message. We further assume that: * Processes fail independently according to the fail-stop model <ref> [Sch84] </ref>; * There exists common knowledge on the identity of the fixed set of processes that belong to the system; * Channels are point-to-point, FIFO, and fail by intermittently losing messages. 3 Consistency in Message Logging Protocols In message logging protocols, each process typically records both the content and receive sequence
Reference: [SW89] <author> A.P. Sistla and J.L. Welch. </author> <title> Efficient distributed recovery using message logging. </title> <booktitle> In Proceedings of the Eighth Symposium on Principles of Distributed Computing, </booktitle> <pages> pages 223-238. </pages> <publisher> ACM SIGACT/SIGOPS, </publisher> <month> August </month> <year> 1989. </year>
Reference-contexts: 1 Introduction Message logging (for example, <ref> [BBG83, PP83, SY85, JZ87, SBY88, SW89, JZ90, VJ94, EZ92] </ref>) is a common technique used to build systems that can tolerate process crash failures. These protocols require that each process periodically record its local state and log the messages it received after having recorded that state. <p> We will say that sends a additional data if the maximum value of jm j - jmj is a for all such m and m taken from all pairs of equivalent runs. For example, for optimistic protocols tracking direct dependencies a is a constant <ref> [SW89, VJ94] </ref>, while for optimistic protocols tracking transitive dependencies a is proportional to the number of processes in the system [SY85, SW89]. Clearly, a lower bound for a is 0, and pessimistic receiver-based logging proves that the bound is tight. <p> For example, for optimistic protocols tracking direct dependencies a is a constant [SW89, VJ94], while for optimistic protocols tracking transitive dependencies a is proportional to the number of processes in the system <ref> [SY85, SW89] </ref>. Clearly, a lower bound for a is 0, and pessimistic receiver-based logging proves that the bound is tight.
Reference: [SY85] <author> R. B. Strom and S. Yemeni. </author> <title> Optimistic recovery in distributed systems. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 3(3) </volume> <pages> 204-226, </pages> <month> April </month> <year> 1985. </year>
Reference-contexts: 1 Introduction Message logging (for example, <ref> [BBG83, PP83, SY85, JZ87, SBY88, SW89, JZ90, VJ94, EZ92] </ref>) is a common technique used to build systems that can tolerate process crash failures. These protocols require that each process periodically record its local state and log the messages it received after having recorded that state. <p> For any message m delivered by process p, the receive sequence number of m, denoted m.rsn, represents the order in which m was delivered: m.rsn = ` if m is the ` th message delivered by p <ref> [SY85] </ref>. The state interval that initiates with the delivery of m is denoted p [`] where `, the index of p [`], is equal to m.rsn. <p> For example, for optimistic protocols tracking direct dependencies a is a constant [SW89, VJ94], while for optimistic protocols tracking transitive dependencies a is proportional to the number of processes in the system <ref> [SY85, SW89] </ref>. Clearly, a lower bound for a is 0, and pessimistic receiver-based logging proves that the bound is tight.
Reference: [VJ94] <author> S. Venkatesan and T.Y. Juang. </author> <title> Efficient algorithms for optimistic crash recovery. </title> <journal> Distributed Computing, </journal> <volume> 8(2) </volume> <pages> 105-114, </pages> <month> June </month> <year> 1994. </year> <month> 11 </month>
Reference-contexts: 1 Introduction Message logging (for example, <ref> [BBG83, PP83, SY85, JZ87, SBY88, SW89, JZ90, VJ94, EZ92] </ref>) is a common technique used to build systems that can tolerate process crash failures. These protocols require that each process periodically record its local state and log the messages it received after having recorded that state. <p> We will say that sends a additional data if the maximum value of jm j - jmj is a for all such m and m taken from all pairs of equivalent runs. For example, for optimistic protocols tracking direct dependencies a is a constant <ref> [SW89, VJ94] </ref>, while for optimistic protocols tracking transitive dependencies a is proportional to the number of processes in the system [SY85, SW89]. Clearly, a lower bound for a is 0, and pessimistic receiver-based logging proves that the bound is tight.
References-found: 20

