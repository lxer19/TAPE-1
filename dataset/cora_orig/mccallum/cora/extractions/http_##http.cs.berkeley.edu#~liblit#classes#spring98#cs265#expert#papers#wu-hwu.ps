URL: http://http.cs.berkeley.edu/~liblit/classes/spring98/cs265/expert/papers/wu-hwu.ps
Refering-URL: http://http.cs.berkeley.edu/~liblit/classes/spring98/cs265/expert/
Root-URL: 
Email: Email: flcwu, hwug@crhc.uiuc.edu  
Title: Novel Breakpoint Implementation Scheme for Debugging Optimized Code  
Author: Le-Chun Wu Wen-mei W. Hwu 
Date: January 1998  
Address: Urbana, IL 61801  
Affiliation: Department of Computer Science Department of Electrical and Computer Engineering and The Coordinated Science Laboratory University of Illinois  
Note: A  
Pubnum: Technical Report IMPACT-98-01  
Abstract: Technical Report IMPACT-98-01 1 Abstract Providing a clear and correct source-level debugger for programmers to debug highly optimized code has become a necessity with executable binaries increasingly generated by compilers which incorporate advanced optimization techniques. Implementing source break-points is essential for providing such a debugger. In this paper, a novel source breakpoint implementation scheme for debugging optimized code is proposed. The approach is aimed at solving the fundamental problem suffered by the traditional scheme. By taking over the control early and executing instructions under a new forward recovery model, the debugger can preserve and gather the required program states. With this information accumulated and the help of a data location tracking method, the expected values of user variables can be recovered at source breakpoints. In order to facilitate this new breakpoint implementation scheme, additional information needs to be generated and maintained during compilation. The compiler support for our approach is also described. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> A. Adl-Tabatabai and T. Gross, </author> <title> "Detection and recovery of endangered variables caused by instruction scheduling," </title> <booktitle> in Proceedings of the ACM SIGPLAN '93 Conference on Programming Language Design and Implementation, </booktitle> <pages> pp. 13-25, </pages> <month> June </month> <year> 1993. </year>
Reference-contexts: In order to support these debugging activities while debugging optimized code, implementing source breakpoints is essential for providing a correct and clear solution to the problem of debugging optimized code. Traditionally, the debugger maps a breakpoint set at a source statement to an object code location (called object breakpoint <ref> [1] </ref>) and halt the execution when the object breakpoint is reached. The debugger then uses the program state at this point to answer user's requests. However, compiler optimizations cause difficulties to the debuggers using the traditional approach.
Reference: [2] <author> P. T. Zellweger, </author> <title> Interactive Source-Level Debugging of Optimized Programs. </title> <type> PhD thesis, </type> <institution> Electrical Engineering and Computer Sciences, University of Cali-fornia, Berkeley, </institution> <address> CA 94720, </address> <year> 1984. </year>
Reference-contexts: Also instruction I6 which should have been executed in order to obtain the expected value of variable a has not been executed at this point. Even though there have been different object breakpoint mapping schemes proposed such as semantic breakpoints <ref> [2] </ref>, syntactic breakpoints [2], and statement labels [3, 4], each of which maps a source breakpoint to a different place in the object code, the fundamental problem of this traditional scheme remains only the program state of a single point is available. <p> Also instruction I6 which should have been executed in order to obtain the expected value of variable a has not been executed at this point. Even though there have been different object breakpoint mapping schemes proposed such as semantic breakpoints <ref> [2] </ref>, syntactic breakpoints [2], and statement labels [3, 4], each of which maps a source breakpoint to a different place in the object code, the fundamental problem of this traditional scheme remains only the program state of a single point is available.
Reference: [3] <author> A. Adl-Tabatabai, </author> <title> Source-Level Debugging of Globally Optimized Code. </title> <type> PhD thesis, </type> <institution> School of Computer Science, Carnegie Mellon University, </institution> <address> Pitts-burgh, PA 15213, </address> <year> 1996. </year>
Reference-contexts: Also instruction I6 which should have been executed in order to obtain the expected value of variable a has not been executed at this point. Even though there have been different object breakpoint mapping schemes proposed such as semantic breakpoints [2], syntactic breakpoints [2], and statement labels <ref> [3, 4] </ref>, each of which maps a source breakpoint to a different place in the object code, the fundamental problem of this traditional scheme remains only the program state of a single point is available. <p> There Technical Report IMPACT-98-01 2 fore the optimized code debuggers which adopt a traditional breakpoint implementation scheme usually have problems reporting the expected values of the variables which are updated either too early or too late <ref> [3, 4] </ref>. When the values of these variables are requested, the user will be informed that the values are not available at this point. The availability of the variable values decreases when the code is optimized by increasingly aggressive techniques which usually cause more code reorganization. <p> Since I2 is a conditional anchor point, the compiler needs to record the condition r1 &gt; 5. The anchor points of source statements are similar to the statement labels mentioned in <ref> [3, 4] </ref>. We extend the concept of the statement label into the anchor points to indicate whether a breakpoint should be allowed to take effect.
Reference: [4] <author> D. Coutant, S. Meloy, and M. Ruscetta, </author> <title> "Doc: A practical approach to source-level debugging of globally optimized code," </title> <booktitle> in Proceedings of the ACM SIGPLAN '88 Conference on Programming Language Design and Implementation, </booktitle> <pages> pp. 125-134, </pages> <month> June </month> <year> 1988. </year>
Reference-contexts: Also instruction I6 which should have been executed in order to obtain the expected value of variable a has not been executed at this point. Even though there have been different object breakpoint mapping schemes proposed such as semantic breakpoints [2], syntactic breakpoints [2], and statement labels <ref> [3, 4] </ref>, each of which maps a source breakpoint to a different place in the object code, the fundamental problem of this traditional scheme remains only the program state of a single point is available. <p> There Technical Report IMPACT-98-01 2 fore the optimized code debuggers which adopt a traditional breakpoint implementation scheme usually have problems reporting the expected values of the variables which are updated either too early or too late <ref> [3, 4] </ref>. When the values of these variables are requested, the user will be informed that the values are not available at this point. The availability of the variable values decreases when the code is optimized by increasingly aggressive techniques which usually cause more code reorganization. <p> Since I2 is a conditional anchor point, the compiler needs to record the condition r1 &gt; 5. The anchor points of source statements are similar to the statement labels mentioned in <ref> [3, 4] </ref>. We extend the concept of the statement label into the anchor points to indicate whether a breakpoint should be allowed to take effect.
Reference: [5] <author> A. Adl-Tabatabai and T. Gross, </author> <title> "Evicted variables and the interation of global register allocation and symbolic debugging," in Conference Record of the 5 Two practical issues are discussed in detail in Appendix D. </title> <booktitle> Technical Report IMPACT-98-01 10 20th Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pp. 371-383, </pages> <month> January </month> <year> 1993. </year>
Reference-contexts: Sometimes there is no way to recover the expected value of a variable because the value of the variable does not exist at all after the debugger takes over the control <ref> [5] </ref>. Sometimes some practical limitations of our approach make us take a conservative approach and therefore the values of the variables can not be recovered.
Reference: [6] <author> D. M. Lavery and W. W. Hwu, </author> <title> "Unrolling-based optimizations for modulo scheduling," </title> <booktitle> in Proceedings of the 28th International Symposium on Microarchi-tecture, </booktitle> <pages> pp. 327-337, </pages> <month> November </month> <year> 1995. </year>
Reference-contexts: In this technical report we only base the discussion of our approach on the assumption that all the loops in the optimized code are monotonic loops (such as unrolled loops). The approach presented here can be extended to handle non-monotonic loops such as modulo scheduled loops <ref> [6, 7] </ref>.
Reference: [7] <author> D. M. Lavery and W. W. Hwu, </author> <title> "Modulo scheduling of loops in control-intensive non-numeric programs," </title> <booktitle> in Proceedings of the 29th International Symposium on Microarchitecture, </booktitle> <pages> pp. 126-141, </pages> <month> December </month> <year> 1996. </year>
Reference-contexts: In this technical report we only base the discussion of our approach on the assumption that all the loops in the optimized code are monotonic loops (such as unrolled loops). The approach presented here can be extended to handle non-monotonic loops such as modulo scheduled loops <ref> [6, 7] </ref>.
Reference: [8] <author> S. A. Mahlke, W. Y. Chen, W. W. Hwu, B. R. Rau, and M. S. Schlansker, </author> <title> "Sentinel scheduling for VLIW and supercalar processors," </title> <booktitle> in Proceedings of the 5th International Conference on Architectural Support for Programming Languages and Operating Systems, </booktitle> <pages> pp. 238-247, </pages> <month> October </month> <year> 1992. </year>
Reference-contexts: For some advanced architectures which support non-trapping versions of instructions <ref> [8] </ref>, the problem can be solved by replacing the post-breakpoint instructions with the non-trapping version of them. When a finish point is reached, the debugger stops to answer the user's requests.
References-found: 8

