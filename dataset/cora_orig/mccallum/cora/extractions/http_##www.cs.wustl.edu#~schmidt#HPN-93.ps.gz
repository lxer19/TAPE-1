URL: http://www.cs.wustl.edu/~schmidt/HPN-93.ps.gz
Refering-URL: http://www.cs.wustl.edu/~schmidt/resume.html
Root-URL: 
Email: dbox@ics.uci.edu, schmidt@ics.uci.edu and suda@ics.uci.edu  
Title: ADAPTIVE An Object-Oriented Framework for Flexible and Adaptive Communication Protocols  
Author: Donald F. Box, Douglas C. Schmidt and Tatsuya Suda 
Address: Irvine, CA 92717 1  
Affiliation: Department of Information and Computer Science, University of California,  
Abstract: Traditional transport systems do not adequately provide the functionality or flexibility required by existing and future multimedia applications. Conventional protocol architectures based on a static configuration of relatively few protocols are incapable of providing the level of performance the channel is capable of producing while still performing the processing needed by the application. Multimedia applications require transport systems that can be configured to match the the functional requirements of diverse multimedia traffic sources as well as capable of adapting to the dynamism inherent in multimedia applications and heterogeneous internetworks. This paper describes ADAPTIVE, a transport system architecture to support multimedia applications for high-speed networks. The ADAPTIVE system applies object-oriented design and implementation techniques to build an integrated framework for protocol specification, composition, prototyp-ing and experimentation. It utilizes a hierarchical specification technique that allows both the policies of a communication session to be specified and the actual mechanisms used to carry out these policies. Its monitoring and analysis facilities provide a rich environment for controlled experimentation through the use of rapid prototyping and integrated instrumentation. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> N. C. Hutchinson and L. L. Peterson, </author> <booktitle> Design of the x-Kernel, in Proceedings of the SIGCOMM '88 Symposium, (Stanford, Calif.), </booktitle> <pages> pp. 6575, </pages> <month> August </month> <year> 1988. </year>
Reference-contexts: This diversity appears in both the available hardware (e.g., CPU, network interface, memory hierarchy) and the supporting system software. Software-related issues such as scheduling mechanisms (e.g., x-kernel <ref> [1] </ref> lightweight processes vs. STREAMS [2] service routines), user-kernel data delivery mechanisms (e.g., BSD socket layer [3] vs. x-kernel upcall mechanism), buffer management schemes (e.g., BSD mbufs vs. STREAMS mblk ts) and protocol composition and de-multiplexing mechanisms (e.g., STREAMS modules vs. x-kernel protocol and session objects). <p> The services required from the operating environment include scheduling, buffer management, multiplexing/demultiplexing and context management. Most existing systems provide some subset of these services (e.g., BSD-UNIX [3], UNIX System V STREAMS [2], x-kernel <ref> [1] </ref>), but with very little consistency across environments.
Reference: [2] <author> UNIX Software Operations, </author> <title> UNIX System V Release 4 Programmer's Guide: STREAMS. </title> <publisher> Prentice Hall, </publisher> <year> 1990. </year>
Reference-contexts: This diversity appears in both the available hardware (e.g., CPU, network interface, memory hierarchy) and the supporting system software. Software-related issues such as scheduling mechanisms (e.g., x-kernel [1] lightweight processes vs. STREAMS <ref> [2] </ref> service routines), user-kernel data delivery mechanisms (e.g., BSD socket layer [3] vs. x-kernel upcall mechanism), buffer management schemes (e.g., BSD mbufs vs. STREAMS mblk ts) and protocol composition and de-multiplexing mechanisms (e.g., STREAMS modules vs. x-kernel protocol and session objects). <p> The services required from the operating environment include scheduling, buffer management, multiplexing/demultiplexing and context management. Most existing systems provide some subset of these services (e.g., BSD-UNIX [3], UNIX System V STREAMS <ref> [2] </ref>, x-kernel [1]), but with very little consistency across environments.
Reference: [3] <author> S. J. Leffler, M. McKusick, M. Karels, and J. Quarterman, </author> <title> The Design and Implementation of the 4.3BSD UNIX Operating System. </title> <publisher> Addison-Wesley, </publisher> <year> 1989. </year>
Reference-contexts: This diversity appears in both the available hardware (e.g., CPU, network interface, memory hierarchy) and the supporting system software. Software-related issues such as scheduling mechanisms (e.g., x-kernel [1] lightweight processes vs. STREAMS [2] service routines), user-kernel data delivery mechanisms (e.g., BSD socket layer <ref> [3] </ref> vs. x-kernel upcall mechanism), buffer management schemes (e.g., BSD mbufs vs. STREAMS mblk ts) and protocol composition and de-multiplexing mechanisms (e.g., STREAMS modules vs. x-kernel protocol and session objects). <p> The services required from the operating environment include scheduling, buffer management, multiplexing/demultiplexing and context management. Most existing systems provide some subset of these services (e.g., BSD-UNIX <ref> [3] </ref>, UNIX System V STREAMS [2], x-kernel [1]), but with very little consistency across environments.
Reference: [4] <author> J. Jain, M. Schwartz, and T. Bashkow, </author> <title> Transport Protocol Processing at GBPS Rates, </title> <booktitle> in Proceedings of the Symposium on Communications Architectures and Protocols (SIG-COMM), </booktitle> <address> (Philadelphia, PA), </address> <pages> pp. 188199, </pages> <publisher> ACM, </publisher> <month> Sept. </month> <year> 1990. </year>
Reference-contexts: STREAMS mblk ts) and protocol composition and de-multiplexing mechanisms (e.g., STREAMS modules vs. x-kernel protocol and session objects). Hardware issues that are variable across host systems include processor architectures (e.g., uniprocessor vs. shared memory multiprocessor <ref> [4] </ref> vs. message passing multiprocessor [5, 6]), explicit support for protocol processing (e.g., performing all protocol processing off-board processors [7, 8], specialized hardware to assist a single protocol function [9]), effects of interrupts on overall system performance (e.g., number of interrupts required to move data between the host system memory and
Reference: [5] <author> M. Zitterbart, </author> <title> Parallel Protocol Implementations on Trans-puters Experiences with OSI TP4, OSI CLNP, </title> <booktitle> and XTP, in Proceedings of the First IEEE Workshop on the Architecture and Implementation of High Performance Communication Subsystems, </booktitle> <month> Feb. </month> <year> 1992. </year>
Reference-contexts: STREAMS mblk ts) and protocol composition and de-multiplexing mechanisms (e.g., STREAMS modules vs. x-kernel protocol and session objects). Hardware issues that are variable across host systems include processor architectures (e.g., uniprocessor vs. shared memory multiprocessor [4] vs. message passing multiprocessor <ref> [5, 6] </ref>), explicit support for protocol processing (e.g., performing all protocol processing off-board processors [7, 8], specialized hardware to assist a single protocol function [9]), effects of interrupts on overall system performance (e.g., number of interrupts required to move data between the host system memory and the network interface, performance penalty
Reference: [6] <author> T. F. L. Porta and M. Schwartz, </author> <title> Design, Verification, and Analysis of a High Speed Protocol Parallel Implementation Architecture, </title> <booktitle> in Proceedings of the First IEEE Workshop on the Architecture and Implementation of High Performance Communication Subsystems, </booktitle> <month> Feb. </month> <year> 1992. </year>
Reference-contexts: STREAMS mblk ts) and protocol composition and de-multiplexing mechanisms (e.g., STREAMS modules vs. x-kernel protocol and session objects). Hardware issues that are variable across host systems include processor architectures (e.g., uniprocessor vs. shared memory multiprocessor [4] vs. message passing multiprocessor <ref> [5, 6] </ref>), explicit support for protocol processing (e.g., performing all protocol processing off-board processors [7, 8], specialized hardware to assist a single protocol function [9]), effects of interrupts on overall system performance (e.g., number of interrupts required to move data between the host system memory and the network interface, performance penalty
Reference: [7] <author> H. Kanakia and D. R. Cheriton, </author> <title> The VMP Network Adapter Board (NAB): High-Performance Network Communication for Multiprocessors, </title> <booktitle> in Proceedings of the Symposium on Communications Architectures and Protocols (SIGCOMM), </booktitle> <address> (Stanford, CA), </address> <pages> pp. 175187, </pages> <publisher> ACM, </publisher> <month> Aug. </month> <year> 1988. </year>
Reference-contexts: Hardware issues that are variable across host systems include processor architectures (e.g., uniprocessor vs. shared memory multiprocessor [4] vs. message passing multiprocessor [5, 6]), explicit support for protocol processing (e.g., performing all protocol processing off-board processors <ref> [7, 8] </ref>, specialized hardware to assist a single protocol function [9]), effects of interrupts on overall system performance (e.g., number of interrupts required to move data between the host system memory and the network interface, performance penalty from interrupt-driven processing due to the amount of context a processor must save across
Reference: [8] <author> P. Steenkiste, </author> <title> Analysis of the Nectar Communication Processor, </title> <booktitle> in Proceedings of the First IEEE Workshop on the Architecture and Implementation of High Performance Communication Subsystems, </booktitle> <month> Feb. </month> <year> 1992. </year>
Reference-contexts: Hardware issues that are variable across host systems include processor architectures (e.g., uniprocessor vs. shared memory multiprocessor [4] vs. message passing multiprocessor [5, 6]), explicit support for protocol processing (e.g., performing all protocol processing off-board processors <ref> [7, 8] </ref>, specialized hardware to assist a single protocol function [9]), effects of interrupts on overall system performance (e.g., number of interrupts required to move data between the host system memory and the network interface, performance penalty from interrupt-driven processing due to the amount of context a processor must save across
Reference: [9] <author> M. L. Bailey, M. A. Pagels, and L. L. Peterson, </author> <title> The x-chip: An Experiment in Hardware Demultiplexing, </title> <booktitle> in Proceedings of the First IEEE Workshop on the Architecture and Implementation of High Performance Communication Subsystems, </booktitle> <month> Feb. </month> <year> 1992. </year>
Reference-contexts: Hardware issues that are variable across host systems include processor architectures (e.g., uniprocessor vs. shared memory multiprocessor [4] vs. message passing multiprocessor [5, 6]), explicit support for protocol processing (e.g., performing all protocol processing off-board processors [7, 8], specialized hardware to assist a single protocol function <ref> [9] </ref>), effects of interrupts on overall system performance (e.g., number of interrupts required to move data between the host system memory and the network interface, performance penalty from interrupt-driven processing due to the amount of context a processor must save across interrupts, cache invalidation and pipeline flushing).
Reference: [10] <author> D. C. Schmidt, D. F. Box, and T. Suda, </author> <title> ADAPTIVE: A Flexible and Adaptive Transport System Architecture to Support Lightweight Protocols for Multimedia Applications on High-Speed Networks, </title> <booktitle> in Proceedings of the 1 st Symposium on High-Performance Distributed Computing (HPDC-1), </booktitle> <address> (Syra-cuse, New York), </address> <pages> pp. 174186, </pages> <publisher> IEEE, </publisher> <month> September </month> <year> 1992. </year>
Reference-contexts: The ADAPTIVE System: ADAPTIVE is A Dynamically Assembled Protocol Transformation, Intergration, and Validation Environment. The ADAPTIVE system <ref> [10] </ref> has been designed to address the diversity described above by providing: (1) a flexible and adaptive kernel of protocol mechanisms that provide a framework for protocol composition, (2) a unified scheme for specifying both the policies and the mechanisms that are used to provide communication services, and (3) an integrated
Reference: [11] <author> M. Zitterbart, B. Stiller, and A. Tantawy, </author> <title> A Model for Flexible High-Performance Communication Subsystems, </title> <type> Tech. Rep. TC 17801 (78023), </type> <institution> IBM Research Division, </institution> <month> February </month> <year> 1992. </year>
Reference-contexts: Section 5 describes UNITES in detail. 2 ADAPTIVE Design Principles Adequately supporting the diversity of application requirements and network characteristics described in Section 1 requires a flexible transport system architecture that provides communication service appropriate for the specific traffic sources and underlying network technologies <ref> [11, 12, 13] </ref>. ADAPTIVE allows the behavior of a communication session to be precisely tailored to the required service by implementing a protocol in terms of a set of independently recombin-able protocol mechanisms.
Reference: [12] <author> B. Heinrichs, </author> <title> Versatile Protocol Processing for Multimedia Communications, </title> <booktitle> in 4th IEEE ComSoc International Workshop on Multimedia Communications, </booktitle> <address> (Monterey, California), </address> <pages> pp. 160169, </pages> <publisher> IEEE, </publisher> <year> 1992. </year>
Reference-contexts: Section 5 describes UNITES in detail. 2 ADAPTIVE Design Principles Adequately supporting the diversity of application requirements and network characteristics described in Section 1 requires a flexible transport system architecture that provides communication service appropriate for the specific traffic sources and underlying network technologies <ref> [11, 12, 13] </ref>. ADAPTIVE allows the behavior of a communication session to be precisely tailored to the required service by implementing a protocol in terms of a set of independently recombin-able protocol mechanisms.
Reference: [13] <author> C. Tschudin, </author> <title> Flexible Protocol Stacks, </title> <booktitle> in Proceedings of the Symposium on Communications Architectures and Protocols (SIGCOMM), </booktitle> <address> (Zurich Switzerland), </address> <pages> pp. </pages> <address> 197205, </address> <publisher> ACM, </publisher> <month> Sept. </month> <year> 1991. </year>
Reference-contexts: Section 5 describes UNITES in detail. 2 ADAPTIVE Design Principles Adequately supporting the diversity of application requirements and network characteristics described in Section 1 requires a flexible transport system architecture that provides communication service appropriate for the specific traffic sources and underlying network technologies <ref> [11, 12, 13] </ref>. ADAPTIVE allows the behavior of a communication session to be precisely tailored to the required service by implementing a protocol in terms of a set of independently recombin-able protocol mechanisms.
Reference: [14] <author> W. Doeringer, D. Dykeman, M. Kaiserswerth, B. Meister, H. Rudin, and R. Williamson, </author> <title> A Survey of Light-Weight Transport Protocols for High-Speed Networks, </title> <journal> IEEE Transactions on Communication, </journal> <volume> vol. 38, </volume> <pages> pp. </pages> <address> 20252039, </address> <month> Novem-ber </month> <year> 1990. </year>
Reference-contexts: For example, the effect on protocol performance due to changing the Connection Management function from one that is implicit timer-based to one that is explicit handshake-based can be attributed to the mechanism selection, as all other factors can be held constant. Previous comparisons of various protocol mechanisms <ref> [14, 15, 16, 17] </ref> have been done largely based on their implementations within the context of a complete protocol, thus making it difficult to isolate a single mechanism from its interactions with the rest of the system.
Reference: [15] <author> D. C. Feldmeier and E. W. Biersack, </author> <title> Comparison of Error Control Protocols for High Bandwidth-Delay Product Networks, in Protocols for High-Speed Networks II, </title> <booktitle> IFIP, 1991. </booktitle> <publisher> a. </publisher>
Reference-contexts: For example, the effect on protocol performance due to changing the Connection Management function from one that is implicit timer-based to one that is explicit handshake-based can be attributed to the mechanism selection, as all other factors can be held constant. Previous comparisons of various protocol mechanisms <ref> [14, 15, 16, 17] </ref> have been done largely based on their implementations within the context of a complete protocol, thus making it difficult to isolate a single mechanism from its interactions with the rest of the system.
Reference: [16] <author> B. W. Meister, </author> <title> A Performance Study of the ISO Transport Protocol, </title> <journal> IEEE Transactions on Computers, </journal> <volume> vol. 40, </volume> <pages> pp. 253 262, </pages> <month> March </month> <year> 1991. </year>
Reference-contexts: For example, the effect on protocol performance due to changing the Connection Management function from one that is implicit timer-based to one that is explicit handshake-based can be attributed to the mechanism selection, as all other factors can be held constant. Previous comparisons of various protocol mechanisms <ref> [14, 15, 16, 17] </ref> have been done largely based on their implementations within the context of a complete protocol, thus making it difficult to isolate a single mechanism from its interactions with the rest of the system.
Reference: [17] <author> L. Svobodova, </author> <title> Measured Performance of Transport Service in LANs, </title> <booktitle> in Computer Networks and ISDN Systems, </booktitle> <year> 1989. </year>
Reference-contexts: For example, the effect on protocol performance due to changing the Connection Management function from one that is implicit timer-based to one that is explicit handshake-based can be attributed to the mechanism selection, as all other factors can be held constant. Previous comparisons of various protocol mechanisms <ref> [14, 15, 16, 17] </ref> have been done largely based on their implementations within the context of a complete protocol, thus making it difficult to isolate a single mechanism from its interactions with the rest of the system.
Reference: [18] <author> B. Meyer, </author> <title> Object Oriented Software Construction. </title> <address> Engle-wood Cliffs, NJ: </address> <publisher> Prentice Hall, </publisher> <year> 1989. </year>
Reference-contexts: ADAPTIVE provides a framework of reusable mechanism objects <ref> [18] </ref> that allow protocols to be developed from new and existing component mechanisms that are independently implemented, tested, and maintained.
Reference: [19] <author> Bjarne Stroustrup and Margret Ellis, </author> <title> The Annotated C++ Reference Manual. </title> <publisher> Addison-Wesley, </publisher> <year> 1990. </year>
Reference-contexts: Protocol mechanisms are implemented as C ++ objects <ref> [19] </ref> that encapsulate both the current state of a protocol and the operations that are performed to implement the mechanism as one unified abstract data type. Instances of these data types are then instantiated and configured at run-time to provide the desired protocol function.
Reference: [20] <author> D. L. Parnas, P. Clements, and D. Weiss, </author> <title> Enhancing Reusability with Information Hiding, </title> <booktitle> ITT Proceeding of the Workshop on Reusability in Programming, </booktitle> <year> 1983. </year>
Reference-contexts: Instances of these data types are then instantiated and configured at run-time to provide the desired protocol function. Implementing protocol mechanisms as objects yields several desirable results: 1. Information Hiding details specific to the internal implementation of a given mechanism are hidden behind a uniform interface <ref> [20] </ref>. By enforcing the principle of separation of concerns, this uniform interface creates a firewall between a mechanism's clients (e.g., the application programmer or protocol implementer) and the mechanism's provider (e.g., the mechanism imple menter). 2.
Reference: [21] <author> M. Zitterbart and B. Stiller, </author> <title> A Concept for A Flexible High Performance Transport System, </title> <booktitle> in Telecommunications and Multimedia Applications in Computer Science, </booktitle> <pages> pp. 365374, </pages> <month> Oct. </month> <year> 1991. </year>
Reference-contexts: Various schemes for specifying an application's quality of service (QoS) requirements (e.g., error rate, throughput, delay) as well as it's functionality of service (FoS) requirements (e.g., connection-oriented vs. connectionless, best effort vs. acknowledged vs. reliable delivery) exist <ref> [21, 22, 23] </ref>. Existing schemes have been designed for transport systems that are either inflexible and/or non-adaptive to diversity in application or network characteristics. For a specification scheme to provide applications with an adequate interface to flexible and adaptive transport services, explicit support must be offered for the following: 1.
Reference: [22] <author> CCITT, </author> <title> Geneva, CCITT Recommendation I.211: B-ISDN Service Aspects, </title> <year> 1991. </year>
Reference-contexts: Various schemes for specifying an application's quality of service (QoS) requirements (e.g., error rate, throughput, delay) as well as it's functionality of service (FoS) requirements (e.g., connection-oriented vs. connectionless, best effort vs. acknowledged vs. reliable delivery) exist <ref> [21, 22, 23] </ref>. Existing schemes have been designed for transport systems that are either inflexible and/or non-adaptive to diversity in application or network characteristics. For a specification scheme to provide applications with an adequate interface to flexible and adaptive transport services, explicit support must be offered for the following: 1.
Reference: [23] <author> EC, </author> <title> IBC Application Analysis, research and Develope-ment in Advanced Communications Technologies in Europe, </title> <type> Tech. Rep. </type> <note> R1071, Commission of the European Communities, xxx 1991. </note>
Reference-contexts: Various schemes for specifying an application's quality of service (QoS) requirements (e.g., error rate, throughput, delay) as well as it's functionality of service (FoS) requirements (e.g., connection-oriented vs. connectionless, best effort vs. acknowledged vs. reliable delivery) exist <ref> [21, 22, 23] </ref>. Existing schemes have been designed for transport systems that are either inflexible and/or non-adaptive to diversity in application or network characteristics. For a specification scheme to provide applications with an adequate interface to flexible and adaptive transport services, explicit support must be offered for the following: 1.
Reference: [24] <author> D. D. Clark, </author> <title> The Structuring of Systems Using Upcalls, </title> <booktitle> in Proceedings of the 10 th Symposium on Operating System Principles, (Shark Is., </booktitle> <address> WA), </address> <year> 1985. </year>
Reference-contexts: This entails dictating when to deliver the data (e.g., immediately upon reception, periodically, or based on reception of related data) as well as how to deliver the data (e.g., using an upcall mechanism <ref> [24] </ref> or read/write system calls). (b) Application-guided Adaptation, which specifies both the conditions the transport system needs to react to (e.g., end-to-end delay exceeding some threshold, a remote application requesting an additional data stream on a connection) as well as the actions that are to be taken (e.g., change re transmission
Reference: [25] <author> A. N. Netravali, W. D. Roome, and K. Sabnani, </author> <title> Design and Implementation of a High Speed Transport Protocol, </title> <journal> IEEE Transactions on Communications, </journal> <year> 1990. </year>
Reference-contexts: TKO-OSIL provides a consistent interface to these basic operating system services for use by TKO-MCL protocol implementations by providing the following three C ++ classes: 1. TKEvent the basic abstraction for temporal events. Many protocols must respond to temporal events such as retransmission timer expiration or periodic update requests <ref> [25] </ref>. The TKEvent class defines an infrastructure for event management, providing operations like TKEvent::schedule, TKEvent::happen, and TKEvent::cancel. TKEvent objects schedule themselves to happen one or more times (i.e., they are intermittent or periodic), they may be cancelled, and they are triggered to happen asynchronously by the operating system's timer facility.
Reference: [26] <author> D. D. Clark, V. Jacobson, J. Romkey, and H. Salwen, </author> <title> An Analysis of TCP Processing Overhead, </title> <journal> IEEE Communications Magazine, </journal> <volume> vol. 27, </volume> <pages> pp. 2329, </pages> <month> June </month> <year> 1989. </year>
Reference-contexts: TKMessage the basic abstraction for incoming and outgoing network messages. Previous work has shown that memory-to-memory copying is a significant source of transport system overhead <ref> [26] </ref>. Therefore, some form of buffer management is necessary to avoid unnecessary copying when moving messages between protocol entities and when adding or deleting headers and trailers [27]. The TKMessage class provides a uniform interface for services that create, copy, prepend, and split messages.
Reference: [27] <author> S. W. O'Malley, M. B. Abbott, N. C. Hutchinson, and L. L. Peterson, </author> <title> A Transparent Blast Facility, </title> <journal> Journal of Internet-working, </journal> <volume> vol. 1, </volume> <month> December </month> <year> 1990. </year>
Reference-contexts: Previous work has shown that memory-to-memory copying is a significant source of transport system overhead [26]. Therefore, some form of buffer management is necessary to avoid unnecessary copying when moving messages between protocol entities and when adding or deleting headers and trailers <ref> [27] </ref>. The TKMessage class provides a uniform interface for services that create, copy, prepend, and split messages. TKMessage objects are internally divided into two distinct regions: the header and the data. The data region supports efficient logical copying operations and segmenting and reassembling of data chunks.
Reference: [28] <author> R. Campbell, V. Russo, and G. Johnson, </author> <title> The Design of a Multiprocessor Operating System, </title> <booktitle> in Proceedings of the USENIX C++ Workshop, </booktitle> <pages> pp. 109126, </pages> <publisher> USENIX Association, </publisher> <month> November </month> <year> 1987. </year>
Reference-contexts: Although studies have shown that it is possible to efficiently implement operating systems and communication protocols using these techniques <ref> [28, 29] </ref>, ADAPTIVE/TKO provides several optimizations that streamline the creation and operation of commonly instantiated protocol configurations. Composites: Figure 5 shows that Reliability Management is implemented as a Composite Component. Composites allow multiple related mechanism families to be bundled together into one larger mechanism.
Reference: [29] <author> J. M. Zweig, </author> <title> The Conduit: a Communication Abstraction in C++, </title> <booktitle> in Proceedings of the 2 nd USENIX C++ Conference, </booktitle> <pages> pp. </pages> <address> 191203, </address> <publisher> USENIX Association, </publisher> <month> April </month> <year> 1990. </year>
Reference-contexts: Although studies have shown that it is possible to efficiently implement operating systems and communication protocols using these techniques <ref> [28, 29] </ref>, ADAPTIVE/TKO provides several optimizations that streamline the creation and operation of commonly instantiated protocol configurations. Composites: Figure 5 shows that Reliability Management is implemented as a Composite Component. Composites allow multiple related mechanism families to be bundled together into one larger mechanism.
Reference: [30] <author> O. Endriss, M. Steinbrunn, and M. Zitterbart, </author> <title> NETMON-II a monitoring tool for distributed and multiprocessor systems, </title> <booktitle> Performance Evaluation, </booktitle> <pages> pp. </pages> <address> 191201, </address> <year> 1991. </year>
Reference-contexts: As shown in Figure 6, the UNITES Metric Repository stores the collected performance data in a shared database to minimize the intrusion made by the metric collection process <ref> [30] </ref>. Users may access this information via (1) UNITES-provided interactive graphic displays, (2) the UNITES C ++ run-time library, or (3) standard network management protocols such as SNMP or CMIP. This metric data is available on either a systemwide, per-host, or per-connection basis.
Reference: [31] <author> P. Gunningberg, M. Bjorkman, E. Nordmark, S. Pink, P. Sjodin, and J.-E. Stromquist, </author> <title> Application Protocols and Performance Benchmarks, </title> <journal> IEEE Communications Magazine, </journal> <volume> vol. 27, </volume> <pages> pp. 3036, </pages> <month> June </month> <year> 1989. </year> <month> 12 </month>
Reference-contexts: ADAPTIVE then selectively instruments the instantiated TKO configurations and automatically collects the performance data during the operation of the system. Metric collection may also be specified independent of a communication session using either a graphics-based or language-based interface to UNITES. Sjodin et al. <ref> [31] </ref> defines a specification language that indicates what measurements to collect and what traffic to generate.
Reference: [32] <author> H. K. Huang, T. Suda, and Y. Noguchi, </author> <title> LAN With Collision Avoidance: Switch Implementation and Simulation Study, </title> <booktitle> in Proceedings of the 15th Conference on Local Computer Networks, </booktitle> <year> 1990. </year> <month> 13 </month>
Reference-contexts: We plan to use this prototype to experiment with different transport system configurations that support multimedia applications (e.g., network voice and video) running on several different networks (e.g., Ethernet, Tree Network <ref> [32] </ref>, DQDB, and FDDI). 10 Acknowledgments We would like to thank Hung Huang, Unmesh Rathi, and Girish Kotmire for their help in designing the ADAPTIVE system. 11
References-found: 32

