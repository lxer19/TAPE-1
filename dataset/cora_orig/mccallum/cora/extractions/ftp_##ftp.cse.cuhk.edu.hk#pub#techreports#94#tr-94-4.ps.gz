URL: ftp://ftp.cse.cuhk.edu.hk/pub/techreports/94/tr-94-4.ps.gz
Refering-URL: ftp://ftp.cs.cuhk.hk/pub/techreports/README.html
Root-URL: http://www.aic.nrl.navy.mil/~aha/people.html
Email: Email: mhwong@cs.cuhk.hk  
Phone: Fax: (852)-603-5024  Phone: (852)-609-8406  
Title: Recovery for Transaction Failures in Object-Based Databases  
Author: Man Hon Wong 
Address: Shatin, N.T., Hong Kong  
Affiliation: Department of Computer Science The Chinese University of Hong Kong  
Abstract: In this paper, a set of recoverability theory is derived for an object-based database. Instead of considering serializability and recoverability as two orthogonal concepts, we simply keep serializabil-ity as the only correctness criterion and require serializability to be maintained even when failures of transactions may occur. Based on this fundamental notion of correctness, the definition of re-coverability is derived. Fortunately, the recoverability theory derived in this way is a generalization of the traditional recoverability theory in the read/write model. In addition, we find that the set of strict histories depends on the strength of the inverse operations being used to cancel the effects of aborted operations. At one extreme, when the strongest inverse operations are used, the set of strict histories is the same as the set of avoid cascading aborts histories. At the other extreme, when the weakest inverse operations are used, the set of strict histories is the same as the set of rigorous histories.
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> G. Alonso, D. Agrawal, and A. El Abbadi. </author> <title> Reducing Recovery Constraints on Locking based Protocols. </title> <booktitle> In Proceedings of the Thirteenth ACM Symposium on Principles of Database Systems, </booktitle> <pages> pages 129-138, </pages> <month> May </month> <year> 1994. </year>
Reference-contexts: Otherwise, restore the value written by the write operation. By using such an inverse operation for the write operation, the above history becomes acceptable. This example illustrates that the set of acceptable histories depends on the set of inverse operations being used. This issue has also been observed in <ref> [1] </ref>. In this paper, we will further investigate how the strength of inverse operations affects the set of accepted histories. We say that the strength of an inverse operation is strong if the synchronization constraints it places on the execution is weak.
Reference: [2] <author> P. A. Bernstein, V. Hadzilacos, and N. Goodman. </author> <title> Concurrency Control and Recovery in Database Systems. </title> <publisher> Addison Wesley, </publisher> <address> Reading, Massachusetts, </address> <year> 1987. </year>
Reference-contexts: 1 Introduction A user interacts with a database by performing a series of operations, referred to as a transaction. Concurrency control and recovery are two of the main components for transaction management. Con-currency control enforces serializability <ref> [4, 2] </ref> which requires the effects of a history to be equivalent to a serial history. Recovery mandates recoverability [8, 2] which ensures the correctness of a history even when failures of transactions may occur. <p> Concurrency control and recovery are two of the main components for transaction management. Con-currency control enforces serializability [4, 2] which requires the effects of a history to be equivalent to a serial history. Recovery mandates recoverability <ref> [8, 2] </ref> which ensures the correctness of a history even when failures of transactions may occur. Intuitively, a history is recoverable if whenever an uncommitted transaction aborts, its effects can be wiped out without subsequently aborting any committed 1 transaction. <p> Consider the following execution on a read/write object 1 : Transaction T 1 : write 10 to the object Transaction T 2 : write 20 to the object If the inverse operation of a write operation is to restore the before image <ref> [2] </ref> of the write operation, the above history is not acceptable. Consider the case that when T 1 aborts, it is obviously incorrect to restore the before image of the write operation of T 1 blindly. However, if a more sophisticated inverse operation is used, the above history is acceptable. <p> Therefore, in this section, the correctness criterion adopted in our system under a failure free environment is defined first. Then the notion of recoverability will be derived in the next section. We begin by reviewing the traditional definition of conflict serializability <ref> [4, 2] </ref>. Two operations conflict if they both operate on the same data object and at least one of them is a write operation. Two operation sequences are conflict equivalent if they contain the same set of operations and order the conflicting operations in the same way. <p> However, it does not guarantee that uncommitted transactions are not affected. Hence, aborting a transaction may trigger further abortions of affected transactions, a phenomenon known as cascading abort <ref> [2] </ref>. In order to avoid cascading aborts, a stronger correctness criterion is required to enforce that a history is still correct after the operations and the events of any subset of uncommitted transactions are removed. <p> The reason of enforcing strictness in the read/write model is that when strictness is enforced, the simple method of restoring the before image of a write operation can be used to undo the effects of the write operation <ref> [2] </ref>. The idea of strictness was extended for the object-based model in [11] in which a rather complicated state-based approach is used to define inverse operations and conflict relations. In this paper, a similar notion of strictness is also adopted.
Reference: [3] <author> P. K. Chrysanthis, S. Raghuram, and K. Ramamritham. </author> <title> Extracting Concurrency from Objects: A Methodology. </title> <booktitle> In Proceedings of the 1991 ACM SIGMOD International Conference on Management of Data, </booktitle> <pages> pages 108-117, </pages> <month> May </month> <year> 1991. </year>
Reference-contexts: In particular, databases or the hot spots of databases are modeled by collections of abstract data objects and semantics of objects are used to improve concurrency. Various concurrency control protocols which adopt different serializability criteria have been proposed <ref> [10, 13, 14, 6, 9, 3, 15, 16] </ref>. However, relatively not much work has been done on the recovery issues in such models. Actually, serializability and recoverability are two closely related concepts which cannot be considered separately. There are two issues that deserve more investigation. <p> For example, if the initial state of a counter object X is 0, then X : [increment (5); ok] X : [read; 5] is a valid operation sequence, and X : [increment (5); ok] X : <ref> [read; 3] </ref> is an invalid operation sequence, where "" denotes concatenation of operation sequences.
Reference: [4] <author> K. P. Eswaran, J. N. Gray, R. A. Lorie, and I. L. Traiger. </author> <title> The Notions of Consistency and Predicate Locks in a Database System. </title> <journal> Communications of the ACM, </journal> 19(11) 624-633, November 1976. 
Reference-contexts: 1 Introduction A user interacts with a database by performing a series of operations, referred to as a transaction. Concurrency control and recovery are two of the main components for transaction management. Con-currency control enforces serializability <ref> [4, 2] </ref> which requires the effects of a history to be equivalent to a serial history. Recovery mandates recoverability [8, 2] which ensures the correctness of a history even when failures of transactions may occur. <p> For example, a counter can be defined as an abstract data object which can only be accessed by increment, decrement, read and write operations. Users can interact with the database by executing transactions <ref> [4, 5] </ref>. A transaction can access an object or modify the state of the object only by invoking operations defined for that object. The corresponding result of the invocation is returned to the transaction through a response message. <p> Therefore, in this section, the correctness criterion adopted in our system under a failure free environment is defined first. Then the notion of recoverability will be derived in the next section. We begin by reviewing the traditional definition of conflict serializability <ref> [4, 2] </ref>. Two operations conflict if they both operate on the same data object and at least one of them is a write operation. Two operation sequences are conflict equivalent if they contain the same set of operations and order the conflicting operations in the same way.
Reference: [5] <author> J. N. Gray. </author> <title> Notes on database systems. </title> <editor> In R. Bayer, R. M. Graham, and G. Seegmuller, editors, </editor> <booktitle> Operating Systems: An Advanced Course, volume 60 of Lecture Notes in Computer Science, </booktitle> <pages> pages 393-481. </pages> <publisher> Springer-Verlag, </publisher> <year> 1978. </year>
Reference-contexts: For example, a counter can be defined as an abstract data object which can only be accessed by increment, decrement, read and write operations. Users can interact with the database by executing transactions <ref> [4, 5] </ref>. A transaction can access an object or modify the state of the object only by invoking operations defined for that object. The corresponding result of the invocation is returned to the transaction through a response message. <p> Hence, an operation sequence is valid if all the responses of the operations in the sequence are correct with respect to the specification. For example, if the initial state of a counter object X is 0, then X : [increment (5); ok] X : <ref> [read; 5] </ref> is a valid operation sequence, and X : [increment (5); ok] X : [read; 3] is an invalid operation sequence, where "" denotes concatenation of operation sequences.
Reference: [6] <author> T. Hadzilacos and V Hadzilacos. </author> <title> Transaction Synchronisation in Object Bases. </title> <booktitle> In Proceedings of the Seventh ACM Symposium on Principles of Database Systems, </booktitle> <pages> pages 193-200, </pages> <year> 1988. </year>
Reference-contexts: In particular, databases or the hot spots of databases are modeled by collections of abstract data objects and semantics of objects are used to improve concurrency. Various concurrency control protocols which adopt different serializability criteria have been proposed <ref> [10, 13, 14, 6, 9, 3, 15, 16] </ref>. However, relatively not much work has been done on the recovery issues in such models. Actually, serializability and recoverability are two closely related concepts which cannot be considered separately. There are two issues that deserve more investigation.
Reference: [7] <author> T. Hadzilacos and V. Hadzilacos. </author> <title> Transaction Synchronization in Object Bases. </title> <journal> Journal of Computer and System Sciences, </journal> <volume> 43(1) </volume> <pages> 2-24, </pages> <month> August </month> <year> 1991. </year> <booktitle> Special issue on the 7th Annual ACM SIGACT-SIGMOD Symposium on the Principles of Database Systems, </booktitle> <month> March 21-23, </month> <year> 1988. </year>
Reference-contexts: In fact, any symmetric relation R defined over the operations of an object X is a conflict relation, if R contains the complement of the right backward commutativity relation <ref> [7, 14] </ref> of X . The right backward commutativity relation for an object is defined below.
Reference: [8] <author> T. Harder and A. Reuter. </author> <title> Principles of transaction oriented database recovery. </title> <journal> ACM Computing Surveys, </journal> <volume> 15(4), </volume> <month> December </month> <year> 1983. </year> <month> 23 </month>
Reference-contexts: Concurrency control and recovery are two of the main components for transaction management. Con-currency control enforces serializability [4, 2] which requires the effects of a history to be equivalent to a serial history. Recovery mandates recoverability <ref> [8, 2] </ref> which ensures the correctness of a history even when failures of transactions may occur. Intuitively, a history is recoverable if whenever an uncommitted transaction aborts, its effects can be wiped out without subsequently aborting any committed 1 transaction. <p> Unlike the traditional read/write model, the operation type of an operation in an object-based database depends on both the invocation and the response. Operations with the same invocation but different responses may have different conflict relations with other operations. In our model, update-in-place recovery strategy <ref> [8, 14] </ref> is used for the execution of operations; i.e., the effects of an operation is incorporated to an object immediately after its execution. An operation sequence is a series of operations. An operation sequence on an object is valid, if it satisfies the specification of the object. <p> It has been shown in [14] that the complement of the right backward commutative relation is an optimal conflict relation when update-in-place recovery strategy is used, while the complement of the forward commutativity relation is an optimal conflict relation when deferred update recovery strategy <ref> [8, 14] </ref> is used. Therefore, we use right backward commutativity relation to derive the conflict relation between normal operations, but we use forward commutative relation to derive the "conflict relation" between an inverse operation and a normal operation.
Reference: [9] <author> M. P. Herlihy and W. E. Weihl. </author> <title> Hybrid Concurrency Control for Abstract Data Types. </title> <journal> Journal of Computer and System Sciences, </journal> <volume> 43(1) </volume> <pages> 25-61, </pages> <month> August </month> <year> 1991. </year> <booktitle> Special issue on the 7th Annual ACM SIGACT-SIGMOD Symposium on the Principles of Database Systems, </booktitle> <month> March 21-23, </month> <year> 1988. </year>
Reference-contexts: In particular, databases or the hot spots of databases are modeled by collections of abstract data objects and semantics of objects are used to improve concurrency. Various concurrency control protocols which adopt different serializability criteria have been proposed <ref> [10, 13, 14, 6, 9, 3, 15, 16] </ref>. However, relatively not much work has been done on the recovery issues in such models. Actually, serializability and recoverability are two closely related concepts which cannot be considered separately. There are two issues that deserve more investigation. <p> In addition, we assume that for any object X , the specification of the object satisfies the prefix closure property, i.e, any prefix of a valid operation sequence is valid. 5 Two operation sequences h 1 and h 2 are equieffective <ref> [9] </ref> if, for any operation sequence g, h 1 g is valid if and only if h 2 g is valid. That means whenever an operation sequence is valid on h 1 , the same operation sequence (with the same responses) is valid on h 2 , and vice versa.
Reference: [10] <author> H. F. Korth. </author> <title> Locking Primitives in a Database System. </title> <journal> Journal of the ACM, </journal> <volume> 30(1) </volume> <pages> 55-79, </pages> <month> January </month> <year> 1983. </year>
Reference-contexts: In particular, databases or the hot spots of databases are modeled by collections of abstract data objects and semantics of objects are used to improve concurrency. Various concurrency control protocols which adopt different serializability criteria have been proposed <ref> [10, 13, 14, 6, 9, 3, 15, 16] </ref>. However, relatively not much work has been done on the recovery issues in such models. Actually, serializability and recoverability are two closely related concepts which cannot be considered separately. There are two issues that deserve more investigation.
Reference: [11] <author> R. Rastogi, H.F.Korth, and A. Silberschatz. </author> <title> Strict Histories in Object-Based Database Systems. </title> <booktitle> In Proceedings of the Twelfth ACM Symposium on Principles of Database Systems, </booktitle> <pages> pages 288-299, </pages> <month> May </month> <year> 1993. </year>
Reference-contexts: Therefore, transaction T 2 reads from transaction T 1 , and hence the above history is not recoverable under the traditional read/write model because T 2 has committed before T 1 commits. Recently, some researchers <ref> [11, 12] </ref> have proposed to use the semantics of data objects to relax the requirements for recoverable histories. In particular, inverse operations are used to wiped out the effects of aborted transactions. <p> The idea of strictness was extended for the object-based model in <ref> [11] </ref> in which a rather complicated state-based approach is used to define inverse operations and conflict relations. In this paper, a similar notion of strictness is also adopted.
Reference: [12] <author> H. Schek, G. Weikum, and H. Ye. </author> <title> Towards a Unified Theory of Concurrency Control and Recovery. </title> <booktitle> In Proceedings of the Twelfth ACM Symposium on Principles of Database Systems, </booktitle> <pages> pages 300-311, </pages> <month> May </month> <year> 1993. </year>
Reference-contexts: Therefore, transaction T 2 reads from transaction T 1 , and hence the above history is not recoverable under the traditional read/write model because T 2 has committed before T 1 commits. Recently, some researchers <ref> [11, 12] </ref> have proposed to use the semantics of data objects to relax the requirements for recoverable histories. In particular, inverse operations are used to wiped out the effects of aborted transactions. <p> Although NPCRC is meaningless in the practical sense, we do mention it here for the sake of comparison with reducibility <ref> [12] </ref> in section 6. In the rest of the paper, SR-RC will refer to the class of histories which satisfy the SR-RC requirement in Definition 4 for every prefix of the histories. <p> In short, we show that when the weakest inverse operations are used, the set of strict histories is equal to the set of rigorous histories. 6 Comparison In this section, we discuss the relationships among the newly introduced correctness criteria, the reducibility and the prefix-reducibility introduced in <ref> [12] </ref> and the traditional correctness criteria in the read/write model. In [12], a schedule (history) is expanded by adding undo actions (inverse operations) to the original schedule to cancel the effects of the uncommitted or aborted transactions. <p> inverse operations are used, the set of strict histories is equal to the set of rigorous histories. 6 Comparison In this section, we discuss the relationships among the newly introduced correctness criteria, the reducibility and the prefix-reducibility introduced in <ref> [12] </ref> and the traditional correctness criteria in the read/write model. In [12], a schedule (history) is expanded by adding undo actions (inverse operations) to the original schedule to cancel the effects of the uncommitted or aborted transactions. An expanded schedule is reducible (RED), if it can be transformed into a serial schedule by 1. Swapping adjacent operations which are commutative. 2. <p> Removing any operation with null effect. If a history is RED, obviously the history is still serializable after all the aborted operations are removed; i.e. SR-NPCRC. However, there are two reasons that SR-NPCRC histories may not be RED. First, the inverse operations used in <ref> [12] </ref> is much weaker than the universal inverse operation. For example, the inverse operation used in [12] for a write operation in the read/write object is to restore the before image of the write operation which is weaker than the universal inverse operation. <p> SR-NPCRC. However, there are two reasons that SR-NPCRC histories may not be RED. First, the inverse operations used in <ref> [12] </ref> is much weaker than the universal inverse operation. For example, the inverse operation used in [12] for a write operation in the read/write object is to restore the before image of the write operation which is weaker than the universal inverse operation. Second, the way they expand a schedule impose some requirements on the commutativity relation between inverse operations. <p> The abortion of T 1 will trigger the abortion of T 2 , as shown in the following history: T 1 : X:[write (2),ok] (p) T 2 : X:[increase-read (),ok] (q) T 1 : abort T 2 : abort In <ref> [12] </ref>, the order of the inverse operations added to the original history follows the order of the abort events. <p> In the above history q of T 2 is affected and is required to be aborted. Then the inverse operations will be executed in the reverse order of their corresponding operations in the history; i.e., q 1 before p 1 . In short, RED SR-NPCRC. Prefix-reducible (PRED) <ref> [12] </ref> enforces RED for every prefix in a history,. Similarly, SR-RC enforces SR-NPCRC for every prefix in a history. Since, RED SR-NPCRC because of the above two reasons, it is not difficult to show that PRED SR-RC. <p> Since, RED SR-NPCRC because of the above two reasons, it is not difficult to show that PRED SR-RC. As pointed out in Section 3, the SR-RC defined in this paper is consistent with the conventional definition in the read/write model. It is claimed in <ref> [12] </ref> that RED is incomparable to SR-RC. The reason of existing histories which are RED but not SR-RC is obvious, since RED is a non-prefix closed property, while SR-RC is a prefix closed property. <p> The reason of existing histories which are RED but not SR-RC is obvious, since RED is a non-prefix closed property, while SR-RC is a prefix closed property. The reason of existing histories which are SR-RC but not RED is because the power of the inverse operations used 20 in <ref> [12] </ref> is not optimal. The following is a similar example given in [12] to show that there exists a history in SR-RC but it is not RED: T 1 : X:[write (5),ok] T 2 : X:[write (6),ok] T 1 : abort T 2 : abort The above history is SR-RC but <p> The reason of existing histories which are SR-RC but not RED is because the power of the inverse operations used 20 in <ref> [12] </ref> is not optimal. The following is a similar example given in [12] to show that there exists a history in SR-RC but it is not RED: T 1 : X:[write (5),ok] T 2 : X:[write (6),ok] T 1 : abort T 2 : abort The above history is SR-RC but not RED because the inverse of X : [write (5); ok] does <p> At the other extreme, when the weakest inverse operations are used, the set of strict histories is the same as the set of rigorous histories. The proposed correctness criteria are also compared with the reducibility and prefix-reducibility proposed in <ref> [12] </ref>. It has been shown that our non-prefix closed notion of recoverability with serializability is less restricted than reducibility (non-prefix closed) and our prefix closed notion of recoverability with serializability is also less restricted than prefix-reducibility (prefix closed).
Reference: [13] <author> P. M. Schwarz and A. Z. Spector. </author> <title> Synchronizing Shared Abstract Types. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 2(3) </volume> <pages> 223-250, </pages> <month> August </month> <year> 1984. </year>
Reference-contexts: In particular, databases or the hot spots of databases are modeled by collections of abstract data objects and semantics of objects are used to improve concurrency. Various concurrency control protocols which adopt different serializability criteria have been proposed <ref> [10, 13, 14, 6, 9, 3, 15, 16] </ref>. However, relatively not much work has been done on the recovery issues in such models. Actually, serializability and recoverability are two closely related concepts which cannot be considered separately. There are two issues that deserve more investigation.
Reference: [14] <author> W. E. Weihl. </author> <title> Local Atomicity Properties: Modular Concurrency Control for Abstract Data Types. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 11(2) </volume> <pages> 249-283, </pages> <month> April </month> <year> 1989. </year>
Reference-contexts: In particular, databases or the hot spots of databases are modeled by collections of abstract data objects and semantics of objects are used to improve concurrency. Various concurrency control protocols which adopt different serializability criteria have been proposed <ref> [10, 13, 14, 6, 9, 3, 15, 16] </ref>. However, relatively not much work has been done on the recovery issues in such models. Actually, serializability and recoverability are two closely related concepts which cannot be considered separately. There are two issues that deserve more investigation. <p> T 2 : writes 10 to counter X Transaction T 3 : reads counter X and get 10 Transaction T 3 : reads counter Y and get 0 Transaction T 2 : writes 5 to counter Y Transaction T 2 : commits Transaction T 3 : commits If semantics serializability <ref> [14] </ref> is adopted, the above history is serializable in the order of T 1 T 3 T 2 , since the final states of the counter objects and the response to each operation is the same as that of the serial history executed in the order of T 1 T 3 <p> Unlike the traditional read/write model, the operation type of an operation in an object-based database depends on both the invocation and the response. Operations with the same invocation but different responses may have different conflict relations with other operations. In our model, update-in-place recovery strategy <ref> [8, 14] </ref> is used for the execution of operations; i.e., the effects of an operation is incorporated to an object immediately after its execution. An operation sequence is a series of operations. An operation sequence on an object is valid, if it satisfies the specification of the object. <p> In fact, any symmetric relation R defined over the operations of an object X is a conflict relation, if R contains the complement of the right backward commutativity relation <ref> [7, 14] </ref> of X . The right backward commutativity relation for an object is defined below. <p> When T p commits, p 1 will be aborted; otherwise when T p aborts, the inverse operation will commit, hence the effects of p 1 will be incorporated to the object to cancel the effects of p. It has been shown in <ref> [14] </ref> that the complement of the right backward commutative relation is an optimal conflict relation when update-in-place recovery strategy is used, while the complement of the forward commutativity relation is an optimal conflict relation when deferred update recovery strategy [8, 14] is used. <p> It has been shown in [14] that the complement of the right backward commutative relation is an optimal conflict relation when update-in-place recovery strategy is used, while the complement of the forward commutativity relation is an optimal conflict relation when deferred update recovery strategy <ref> [8, 14] </ref> is used. Therefore, we use right backward commutativity relation to derive the conflict relation between normal operations, but we use forward commutative relation to derive the "conflict relation" between an inverse operation and a normal operation. <p> Therefore, we use right backward commutativity relation to derive the conflict relation between normal operations, but we use forward commutative relation to derive the "conflict relation" between an inverse operation and a normal operation. The definition of forward commutativity <ref> [14] </ref> is formally defined as follows: 14 Definition 10 An operation p forward commutes with an operation q, if for any state s, whenever s p and s q are valid, then s p q and s q p are valid and equieffective to each other.
Reference: [15] <author> M. H. Wong and D. Agrawal. </author> <title> Context-Specific Synchronization for Atomic Data Types. </title> <booktitle> In Proceedings of the International Conference on Database Theory, </booktitle> <pages> pages 201-215, </pages> <month> October </month> <year> 1992. </year>
Reference-contexts: In particular, databases or the hot spots of databases are modeled by collections of abstract data objects and semantics of objects are used to improve concurrency. Various concurrency control protocols which adopt different serializability criteria have been proposed <ref> [10, 13, 14, 6, 9, 3, 15, 16] </ref>. However, relatively not much work has been done on the recovery issues in such models. Actually, serializability and recoverability are two closely related concepts which cannot be considered separately. There are two issues that deserve more investigation.
Reference: [16] <author> M. H. Wong and D. Agrawal. </author> <title> Context-based Synchronization: An Approach Beyond Semantics for Concurrency Control. </title> <booktitle> In Proceedings of the ACM SIGMOD-SIGACT Symposium on Principles of Databases, </booktitle> <pages> pages 276-287, </pages> <month> June </month> <year> 1993. </year>
Reference-contexts: In particular, databases or the hot spots of databases are modeled by collections of abstract data objects and semantics of objects are used to improve concurrency. Various concurrency control protocols which adopt different serializability criteria have been proposed <ref> [10, 13, 14, 6, 9, 3, 15, 16] </ref>. However, relatively not much work has been done on the recovery issues in such models. Actually, serializability and recoverability are two closely related concepts which cannot be considered separately. There are two issues that deserve more investigation.
References-found: 16

