URL: http://www.cs.ucla.edu/~adam/pointers.ps.gz
Refering-URL: http://www.cs.ucla.edu/~adam/
Root-URL: http://www.cs.ucla.edu
Title: Slicing in the Presence of Pointer Variables  
Author: Panos E. Livadas Adam Rosenstein 
Address: Gainesville, FL 32611  
Affiliation: Computer and Information Sciences Department University of Florida  
Abstract: Slicing is a technique that is useful in software engineering applications. Calculation of def-use pairs, essential for slicing and other dataflow analyses, is complicated by the presence of pointer variables because they allow for unbounded data structures to be created at run-time. We propose a simulation of the various structures existing in heap-allocated storage during the execution of a program. This simulation is accomplished via graphs called Storage Shape Graphs. These graphs,first proposed by Chase et al. [Cha90], allow for space-efficient representation of the patterns of the multiple, interconnected data structures allocated during run-time. We have extended the graph notation and calculation algorithm to capture data dependence information and to accommodate complicated data structures and pointer references, such as are found in the ANSI-C language. We also built a tool to test our theories and their applicability. 
Abstract-found: 1
Intro-found: 1
Reference: [Cha90] <author> D. Chase, M. Wegman, and F. Zadeck. </author> <title> "Analysis of Pointers and 21 Structures," </title> <booktitle> Proceedings of the ACM SIGPLAN'90 Conference on Programming Language Design and Implementation, </booktitle> <pages> pp. 296-309, </pages> <address> White Plains, New York (June 20-22, </address> <year> 1990). </year>
Reference-contexts: This pattern is captured in graphs that depict a memory pattern of data nodes for each point in the program's execution. But imprecision can occur in such an analysis because summarizations must be made in order to keep the size of the graphs bounded. Chase et al <ref> [Cha90] </ref> devised a method for simulating run-time heap allocated data structures using heuristics related to programmer behavior. Chase's method was created in order to analyze access paths to data structures which are allocated dynamically. We have expanded Chase's algorithm to accommodate data flow analysis. <p> The PDG/SDG notation was discussed thoroughly in our previous paper [Liv94]. 2.1 The PDG Our data flow analysis extends the work by Chase et al <ref> [Cha90] </ref>. Chase's work required that all programs to be analyzed be in Static Single Assignment (SSA) form [Cyt89]. The first distinction between our approach and Chase's is our ability to perform static analysis without resorting to this form. <p> Specifically, a graph is made to simulate malloced structures immediately after each program point (flow node, in our case) has been executed. These graphs are referred to as Storage Shape Graphs or SSGs <ref> [Cha90] </ref>. The calculation of data flow for a program proceeds in two phases. Each program point 2 p has two SSG's associated with it: an IN and an OUT, denoted In (p) and Out (p) . <p> For each statement p In (p) and Out (p) are initialized to empty graphs. The construction of the SSG's is the first phase of data flow analysis. This phase proceeds according to the simple, fixed point algorithm proposed by Chase <ref> [Cha90] </ref> pp. 298-299, and proceeds as follows: 1. The entry point to the program or func tion is enqueued on a worklist. 2. A program point p is dequeued from the work list. * In (p) set to the outgoing SSG of p's flowgraph predecessor. <p> This constitutes the second phase of the data flow analysis algorithm. 3.1 Storage Shape Graphs The graphs we use to model memory are similar proposed by Chase <ref> [Cha90] </ref> pp. 297-298, although many new types of nodes exist. For clarity, we discuss all common and diverse elements of the SSGs in this section. SSGs consist of Variable Nodes, Heap Nodes, and Virtual Heap Nodes. Variable nodes are named storage constructs and can be any declared variable. <p> The weak update is shown only to highlight the differences between a strong and weak update. 3.1.3 Join Points and Merging In order to keep the SSGs bounded, merging must occur. The merging algorithm is very similar to that proposed in <ref> [Cha90] </ref> pp. 299-300. A merge of a two SSG nodes results in one SSG node that represents both of the original nodes. This summary node, then replaces the original two nodes. <p> Horrowitz's method has been described above (x1 and x??). This method allows the summarization of nodes that are from entirely 20 different dynamic structures. The drawbacks of the K-bounded approximation are summa rized by Chase <ref> [Cha90] </ref>: : : : they [K-bounded approximations] are very low (unless K is very slow), unbounded structures lose all structure beyond depth K, and information provided by the program struc ture is ignored. But Chase's algorithm could not be applied directly to dataflow analysis.
Reference: [Hor89] <author> S. Horrowitz, T. Reps, and D. Bink-ley. </author> <title> "Integrating Non-interfering Versions of Programs," </title> <journal> ACM TOPLAS (January, </journal> <year> 1990). </year>
Reference-contexts: Therefore, any summarizing simulation algorithm needs a method of keeping only the nodes of interest during dataflow analysis. 2.7 A Solution to the Problems of Heap Allocated Storage There have been many suggestions for methods to handle data flow analysis in the presence of pointers, including work by Horrowitz <ref> [Hor89] </ref>. Horrowitz utilizes graphs called Store 7 Graphs which simulate run-time heap stor-age. Horrowitz utilizes a technique called K-bounded approximation, in which the arbitrary length of a simulated data structure is represented by a constant number (K) of nodes including summary nodes to approximate the (possible) remaining nodes.
Reference: [Hor90] <author> S. Horrowitz, P. Pfeiffer, and Thomas Reps. </author> <title> "Dependence Analysis for Pointer Variables," </title> <booktitle> Proceedings of SIGPLAN'89 Symposium on Compiler Construction (June 1989). </booktitle>
Reference-contexts: But because of the presence of pointers, which can point to data objects of any size or structure, dataflow analysis can never perfectly capture the data dependencies of a program. Horrowitz <ref> [Hor90] </ref> suggested simulating the pattern of discrete data elements that would by created by a program utilizing pointers. This pattern is captured in graphs that depict a memory pattern of data nodes for each point in the program's execution. <p> Our parse tree includes pseudo-terminal and some non-terminal nodes. After parsing, the tree is decorated with edges showing control flow, control dependence, and dataflow. The PDG notation (introduced by Ottenstein et al [Ott84] and extended to the SDG by Horrowitz et al <ref> [Hor90] </ref>) allows for a linear time interprocedural slice. The PDG/SDG notation was discussed thoroughly in our previous paper [Liv94]. 2.1 The PDG Our data flow analysis extends the work by Chase et al [Cha90].
Reference: [Liv91] <author> P. Livadas and S. Croll. </author> <title> "Static Program Slicing," </title> <type> Technical Report, </type> <institution> Software Engineering Research Center, </institution> <month> SERC-TR-55-F (December </month> <year> 1991). </year>
Reference-contexts: Once the Ghinsu static analysis tool is completely implemented a phase of testing and empirical study will begin. Some metrics have been proposed in our previous papers <ref> [Liv91] </ref>, and the tool will be used to correlate these with other measurements of programming. In addition, the effectiveness of the tool as a debugging aid will be the topic of statistical experiments.
Reference: [Liv94] <author> P. Livadas and S. Croll. </author> <title> "System Dependence Graphs Based on Parse Trees and their Use in Software Maintenance," </title> <journal> Journal of Information Sciences, </journal> <volume> Vol 76, No. 384, </volume> <pages> pp. </pages> <month> 197-232 (February </month> <year> 1994). </year>
Reference-contexts: This tool (dubbed Gh-insu to reflect its primary functions) includes a powerful graphical user interface, a set of data and control flow analysis tools, and a set of dynamic analysis tools as well. 2 Background Our previous interprocedural dataflow analysis algorithms were capable only of analyzing non-dynamic variables <ref> [Liv94] </ref>. In the old version, the program under analysis is represented by a graph called the System Dependence Graph (SDG). Currently, we are able to analyze data flow through data objects created during run time; however, this analysis has not yet been extended to the interproce-dural case. <p> The PDG notation (introduced by Ottenstein et al [Ott84] and extended to the SDG by Horrowitz et al [Hor90]) allows for a linear time interprocedural slice. The PDG/SDG notation was discussed thoroughly in our previous paper <ref> [Liv94] </ref>. 2.1 The PDG Our data flow analysis extends the work by Chase et al [Cha90]. Chase's work required that all programs to be analyzed be in Static Single Assignment (SSA) form [Cyt89]. <p> Complications in control flow calculation are summarized in previous reports <ref> [Liv94] </ref>, and construction of the annotated flowgraph is covered in [Cro94]. 2.3 Control Dependence Control dependence is an expression of the conditional nature of certain control structures. <p> As an example, the dependence sets for Program Point Dependence Sets After Execution of line var [1] [2] [3] y ; [2] [2] Table 1: The dependence sets for the program in 5 2.5 Slicing Although our parse-tree-level slicing algorithm is covered in detail in previous reports <ref> [Liv94] </ref>, the outline is described here. The control dependence and flow calculations are outside the scope of this paper, and the dataflow calculation is discussed in detail below. Therefore, this brief discussion of the slicing algorithm can continue assuming that the PDG is already built.
Reference: [Ott84] <author> K. Ottenstein and L. Ottenstein. </author> <title> "The Program Dependence Graph in a Software Development Environment," </title> <booktitle> Proceedings of the ACM SIG-SOFT/SIGPLAN Software Engineering Symposium on Practical Software Development Environments, </booktitle> <address> Pitts-burgh, Pa. </address> <month> (April 23-25 </month> <year> 1984). </year>
Reference-contexts: The Program Dependence Graph is based on a parse tree. Our parse tree includes pseudo-terminal and some non-terminal nodes. After parsing, the tree is decorated with edges showing control flow, control dependence, and dataflow. The PDG notation (introduced by Ottenstein et al <ref> [Ott84] </ref> and extended to the SDG by Horrowitz et al [Hor90]) allows for a linear time interprocedural slice. The PDG/SDG notation was discussed thoroughly in our previous paper [Liv94]. 2.1 The PDG Our data flow analysis extends the work by Chase et al [Cha90].
Reference: [Cyt89] <author> R. Cytron, J. Ferrante, B.H. Rosen, M.N. Wegman, and F.K. Zadek. </author> <title> "An Efficient Method of Computing Static single Assignment Form," </title> <booktitle> Conf. Rec. Sixteenth ACM Symp. on Principles of Programming Languages, </booktitle> <month> (January </month> <year> 1989). </year>
Reference-contexts: The PDG/SDG notation was discussed thoroughly in our previous paper [Liv94]. 2.1 The PDG Our data flow analysis extends the work by Chase et al [Cha90]. Chase's work required that all programs to be analyzed be in Static Single Assignment (SSA) form <ref> [Cyt89] </ref>. The first distinction between our approach and Chase's is our ability to perform static analysis without resorting to this form. SSA form replaces all complicated expressions with a series of assignments to temporary variables, breaking up any operation requiring more than two operands.
Reference: [Ost91] <author> T.J. Osstrand and E.J. Weyuker. </author> <title> "Data Flow-Based Test Adequacy Analysis for Languages with Pointers," </title> <booktitle> Sixth Annual Pacific Northwest Software Quality Conference, </booktitle> <pages> pp. 58-71, </pages> <address> Portland, Oregon, </address> <month> (September </month> <year> 1988). </year>
Reference-contexts: Analyses using this method were very imprecise when pointers were encountered, however. The ASSET system, created by Frankl and Weyuker, could calculate def-use associations for programs written in the Pascal language. But, as Os-trand <ref> [Ost91] </ref> points out: : : : ASSET assumes that a Pascal pointer reference is distinct from the actual storage it is referencing, and makes no attempt to connect two pointers that might be referencing the same storage. <p> need to pre-calculate an SSA form of the input pro gram * The addition of semantics for structures and arrays * The support of multi-level pointers, and thus limited type conversion The preliminary results from our implementation (the Ghinsu tool) show that we handle variable aliasing as well as Ostrand <ref> [Ost91] </ref>, that we handle cyclic and multiply connected data structures better than a K-bounded approach, and that a variety of ANSI-C constructs can be combined without difficulty. 6 Future Work We intend to re-implement our original two-phase slicing algorithm for interprocedural analysis.
Reference: [Cro94] <author> Steven Croll. </author> <title> ""Towards an Internal Program Representation: The Ghinsu Core," </title> <type> Masters Thesis: </type> <institution> University of Florida, </institution> <year> 1994. </year>
Reference-contexts: Complications in control flow calculation are summarized in previous reports [Liv94], and construction of the annotated flowgraph is covered in <ref> [Cro94] </ref>. 2.3 Control Dependence Control dependence is an expression of the conditional nature of certain control structures. For example, in an if or while statement the dependent expression (e.g. the body of the while loop) will not execute unless the conditional expression (i.e. the predicate) evaluates to true.
Reference: [Fer87] <author> Jeanne Ferrante. </author> <title> "The Program Dependence Graph and Its Use in Optimization," </title> <journal> ACM Tansactions on Programming Languages and Systems, pp. </journal> <volume> 319-349, Vol. 9, No. 3, </volume> <month> (July </month> <year> 1987). </year>
Reference-contexts: In essence, statements [2] and [4] are control dependent on statement [1]. A more formal definition of control dependence can be found in <ref> [Fer87] </ref>. [1] if (exp) [3] else [4] y = 6; fragment in Figure 3. 2.4 DU Chains The basic element of Data Dependence is the DU chain. A DU chain connects definitions of variables with their subsequent uses.
References-found: 10

