URL: http://www.cs.princeton.edu/~appel/papers/asdl97.ps
Refering-URL: http://www.cs.princeton.edu/~appel/vita.html
Root-URL: http://www.cs.princeton.edu
Email: fdanwang,appel,jlkg@cs.princeton.edu, csserra@cs.wisc.edu  
Title: The Zephyr Abstract Syntax Description Language  
Author: Daniel C. Wang Andrew W. Appel Jeff L. Korn Christopher S. Serra 
Address: Princeton, NJ, 08544  
Affiliation: Department of Computer Science, Princeton University,  
Abstract: The Zephyr 1 Abstract Syntax Description Language (ASDL) describes the abstract syntax of compiler intermediate representations (IRs) and other tree-like data structures. Just as the lexical and syntactic structures of programming languages are described with regular expressions and context free grammars, ASDL provides a concise notation for describing the abstract syntax of programming languages. Tools can convert ASDL descriptions into the appropriate data-structure definitions and functions to convert the data-structures to or from a standard flattened representation. This makes it easier to build compiler components that interoperate. Although ASDL lacks subtyping and inheritance, it is able to describe the Stanford University Intermediate Format (SUIF) compiler IR, originally implemented in C++. We have built a tool that converts ASDL into C, C++, Java, and ML data-structure definitions and conversion functions. We have also built a graphical browser-editor of ASDL data structures. ASDL shares features found in many network interface description languages (IDLs), algebraic data types, and languages such as ASN.1 and SGML. Compared to other alternatives ASDL is simple and powerful. This document describes ASDL in detail and presents an initial evaluation of ASDL. 
Abstract-found: 1
Intro-found: 1
Reference: [Bat96] <author> Rodney M. Bates. </author> <title> Examining the Cocktail toolbox. </title> <journal> Dr. Dobb's Journal of Software Tools, 21(3):78, </journal> <volume> 8082, 9596, </volume> <month> March </month> <year> 1996. </year>
Reference-contexts: ASDL descriptions are more concise than data-structure definitions in languages such as C, C++, and Java. The idea of special notation for tree-like data structures is not new. Compiler-construction systems and attribute-evaluation tools contain small sublan-guages that are descriptions of tree-like data structures <ref> [GHL + 92, Bat96, Vol91, JPJ + 90] </ref>.
Reference: [BMS80] <author> R. Burstall, D. MacQueen, and D. San-nella. </author> <title> Hope: an experimental applicative language. </title> <booktitle> In Proceedings of the 1980 LISP Conference, </booktitle> <pages> pages 13643, </pages> <address> Stanford, </address> <year> 1980. </year>
Reference-contexts: data types also have concise notation for defining tree-like data struc Good Notation Language Independent Simple Compiler Construction Systems yes no yes Algebraic Data Types yes no yes ASN.1 could be better yes no SGML no yes no Network IDLs no yes yes Table 1: Evaluation of existing systems tures <ref> [BMS80] </ref>. Unfortunately these systems and languages do not solve the problem of providing IR implementations for more than one programming language. Languages like SGML [GR90] and ASN.1 [ISO87, ITU95b] are not much more than complex description languages for tree-like data structures.
Reference: [BNOW93] <author> Andrew Birrell, Greg Nelson, Susan Ow-icki, and Edward Wobber. </author> <title> Network objects. </title> <booktitle> In Proceedings of the 14th Symposium on Operating System Principles, </booktitle> <pages> pages 217 230, </pages> <year> 1993. </year>
Reference-contexts: A simple way to transmit IR values across different components is to read and write the IR to a file in a standard format. These files are called pickles, and conversion to pickles is called pickling or marshaling <ref> [BNOW93] </ref>. Since different compiler research groups program in different implementation languages, IRs need to be implemented in more than one programming language. Otherwise compiler components written in different languages cannot interoperate. Unfortunately, many IRs are only described by one implementation in one language.
Reference: [CXF94] <author> Chemical exchagne format. ftp://info. cas.org/pub/cxf, </author> <year> 1994. </year>
Reference-contexts: This prototype generates definitions for four different languages. Although ASN.1 is intended to describe network data, it is also used to describe data in other domains, such as chemical abstracts <ref> [CXF94] </ref> and gene sequences [NCB96]. These ASN.1 specifications exist to help improve the exchange of information across software systems written to manipulate data in these domains.
Reference: [FH95] <author> Chris W. Fraser and David R. Hanson. </author> <title> A Retargetable C Compiler: Design and Implementation. </title> <publisher> Benjamin/Cummings Pub. Co., </publisher> <address> Redwood City, CA, USA, </address> <year> 1995. </year>
Reference-contexts: Table 1 summarizes our evaluation of existing systems. The following is a summary of the concrete design goals of ASDL. * The language must be simple and concise. * The language must be able to encode existing IR's such as SUIF [W + 94], FLINT [Sha97], and lcc's IR <ref> [FH95] </ref>. * Tools that use the language must initially be able to produce code for C, C++, Java, and ML. * Tools must be able to produce code designed to be understood by programmers, not just other tools. * Language features must have a natural encoding in all the target languages.
Reference: [GHL + 92] <author> Robert W. Gray, Vincent P. Heuring, Steven P. Levi, Anthony M. Sloane, and William M. Waite. Eli: </author> <title> A complete, flexible compiler construction system. </title> <journal> Communications of the ACM, </journal> <volume> 35(2):121130, </volume> <month> February </month> <year> 1992. </year>
Reference-contexts: ASDL descriptions are more concise than data-structure definitions in languages such as C, C++, and Java. The idea of special notation for tree-like data structures is not new. Compiler-construction systems and attribute-evaluation tools contain small sublan-guages that are descriptions of tree-like data structures <ref> [GHL + 92, Bat96, Vol91, JPJ + 90] </ref>.
Reference: [GR90] <author> Charles F. Goldfarb and Yuri Rubinsky. </author> <title> The SGML handbook. </title> <publisher> Clarendon Press, Oxford, </publisher> <address> UK, </address> <year> 1990. </year>
Reference-contexts: Unfortunately these systems and languages do not solve the problem of providing IR implementations for more than one programming language. Languages like SGML <ref> [GR90] </ref> and ASN.1 [ISO87, ITU95b] are not much more than complex description languages for tree-like data structures. These descriptions are declarative specifications of structured data, independent of a particular implementation language. However, these languages have many features not needed in the description of compiler IRs.
Reference: [ISO87] <institution> Information Processing Open Systems Interconnection Specification of Abstract Syntax Notation One (ASN.1). International Organization for Standardization and International Electrotechnical Committee, </institution> <year> 1987. </year> <note> International Standard 8824. </note>
Reference-contexts: Unfortunately these systems and languages do not solve the problem of providing IR implementations for more than one programming language. Languages like SGML [GR90] and ASN.1 <ref> [ISO87, ITU95b] </ref> are not much more than complex description languages for tree-like data structures. These descriptions are declarative specifications of structured data, independent of a particular implementation language. However, these languages have many features not needed in the description of compiler IRs.
Reference: [ITU95a] <editor> Information Technology Abstract Syntax Notation One (ASN.1): </editor> <title> Encoding Rules Packed Encoding Rules (PER). </title> <booktitle> International Telecommuncation Union, </booktitle> <year> 1995. </year> <note> ITU-T Recommendation X.691. </note>
Reference-contexts: Smaller pickles reduce the system IO since there is less data to write or read. Smaller pickles are also more likely to fit completely in the cache of the IO system. The ASDL pickle format resembles the Packed En--coding Rules (PER) of ASN.1 <ref> [ITU95a] </ref>. Like the ASDL pickle format the PER is a prefix encoding of tree values. Neither format encodes redundant type information.
Reference: [ITU95b] <institution> Information Technology Abstract Syntax Notation One (ASN.1): Specification of Basic Notation. International Telecom-muncation Union, </institution> <year> 1995. </year> <note> ITU-T Recommendation X.680. </note>
Reference-contexts: Unfortunately these systems and languages do not solve the problem of providing IR implementations for more than one programming language. Languages like SGML [GR90] and ASN.1 <ref> [ISO87, ITU95b] </ref> are not much more than complex description languages for tree-like data structures. These descriptions are declarative specifications of structured data, independent of a particular implementation language. However, these languages have many features not needed in the description of compiler IRs. <p> The official context free grammar of the most recent version of ASN.1 contains over 150 non-terminals and 300 productions, and occupies eight pages <ref> [ITU95b] </ref>. The equivalent ASDL context free grammar contains a little over ten non-terminals, twenty productions, and easily fits on half a page. The size of the ASN.1 grammar alone makes it difficult to build tools for it.
Reference: [JJ97] <author> Patrik Jansson and Johan Jeuring. </author> <title> PolyP a polytypic programming language extension. </title> <booktitle> In Conference Record of POPL '97: The 24th ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages, </booktitle> <pages> pages 470482, </pages> <address> Paris, France, </address> <month> 15 17 January </month> <year> 1997. </year>
Reference-contexts: Tools could also perform more aggressive automatic representation optimizations on the generated code. It seems appropriate to reuse ASDL descriptions for a wide variety of other tools, such as attribute evaluators, parsers, pattern matchers, and pretty printers. All these systems can benefit from the formalisms that ASDL provides. Jansson <ref> [JJ97] </ref> presents a formalism (polytypic programming) to describe functions that generate functions based on structural induction on an arbitary algebraic data type. Polytypic programming allows the creation of generator generators. Jansson's approach could be extended into a tool that generates code generators for ASDL data types.
Reference: [JPJ + 90] <author> M. Jourdan, D. Parigot, C. Julie, O. Durin, and C. Le Bellec. </author> <title> Design, implementation and evaluation of the FNC-2 attribute grammar system. </title> <booktitle> In In Proceedings of the ACM SIGPLAN'90 Conference on Programming Language Design and Implementation, pages 209222, </booktitle> <address> White Plains, New York, </address> <month> June </month> <year> 1990. </year>
Reference-contexts: ASDL descriptions are more concise than data-structure definitions in languages such as C, C++, and Java. The idea of special notation for tree-like data structures is not new. Compiler-construction systems and attribute-evaluation tools contain small sublan-guages that are descriptions of tree-like data structures <ref> [GHL + 92, Bat96, Vol91, JPJ + 90] </ref>.
Reference: [NCB96] <institution> National center for biotechnology software development toolkit. ftp://ncbi.nlm. nih.gov/toolbox/ncbi_tools, </institution> <year> 1996. </year>
Reference-contexts: This prototype generates definitions for four different languages. Although ASN.1 is intended to describe network data, it is also used to describe data in other domains, such as chemical abstracts [CXF94] and gene sequences <ref> [NCB96] </ref>. These ASN.1 specifications exist to help improve the exchange of information across software systems written to manipulate data in these domains.
Reference: [Obj95] <institution> Object Management Group, Inc., </institution> <note> 492 Old Connecticut Path, </note> <editor> Framingham, </editor> <title> MA 01701. The Common Object Request Broker: Architecture and Specification, </title> <address> 2.0 edition, </address> <year> 1995. </year>
Reference-contexts: Heterogeneous networked systems have solved a similar component interoperation problem with interface description languages (IDLs) that describe abstract interfaces to network services. Tools automatically generate glue code from an IDL description and export a service to the network. ONC RPC [Sri95], OMG CORBA <ref> [Obj95] </ref>, and Xerox's ILU [Xer96] are examples of this approach. Unfortunately CORBA and the other IDLs have awkward encodings for the tree-like data structures seen in IRs. Ideally those in the compiler research community could reuse existing solutions.
Reference: [Opp80] <author> Dereck C. Oppen. </author> <title> Prettyprinting. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 2(4):465483, </volume> <month> October </month> <year> 1980. </year>
Reference-contexts: Rather than manipulating raw strings, the tool works with data structures that represent the abstract syntax trees (AST) of the target languages (C, C++, Java, ML). The AST is then pretty printed <ref> [Opp80] </ref> to produce the final output. The tool uses the translation techniques outlined in Section 3. A related tool produces a set of C++ functions that automatically pickle and unpickle the C++ data structures.
Reference: [OW97] <author> Martin Odersky and Philip Wadler. </author> <title> Pizza into Java: Translating theory into practice. </title> <booktitle> In Proceedings POPL 1997, </booktitle> <address> Paris, </address> <month> January 15-17 </month> <year> 1997. </year>
Reference-contexts: ASDL pickling code need not depend on any special runtime support and can be optimized based on static information. Java has borrowed the pickling techniques and ideas from Modula-3 to provide the automatic serializing of arbitrary language objects. Pizza <ref> [OW97] </ref> is a superset of Java that provides algebraic data types, giving Java concise notation for treelike data structures. A combination of Pizza along with the automatic serialization of types in Java has some similarities to the ASDL approach.
Reference: [Sam93] <editor> Michael Sample. Snacc 1.1. </editor> <address> http://www. nsg.bc.ca/Software.html, </address> <year> 1993. </year>
Reference-contexts: The equivalent ASDL context free grammar contains a little over ten non-terminals, twenty productions, and easily fits on half a page. The size of the ASN.1 grammar alone makes it difficult to build tools for it. A freely available ASN.1 compiler <ref> [Sam93] </ref>, which converts a subset of ASN.1 to C and C++ but parses the full ASN.1 language, has a 3000 line yacc grammar. The rest of the system consists of 13000 lines of C. Because of ASDL's simplicity, it is easy to construct a definitions generator for different languages.
Reference: [Ser97] <author> Christopher S. Serra. </author> <title> Bridging suif and zephyr:a compiler infrastructure interchange. </title> <institution> Princeton University Senior Thesis, </institution> <month> May </month> <year> 1997. </year>
Reference-contexts: Using these functions along with code automatically generated from the ASDL description, we have built a tool tool that allows the compilers written in ML and Java to interface to the existing SUIF compiler components <ref> [Ser97] </ref>. 3.2 ASDL Syntax Table 2 compares the size of ASDL SUIF description and the C++ implementation. The C++ kernel is the core set of source files that defines the structure of the SUIF IR and the related support functions. <p> produces data structures defintions and pickling routines in C, C++, Java, and ML * A browser-editor that can graphically view and ma nipulate arbitrary ASDL pickles * A tool to convert between the original C++ SUIF data structures and data structures produced from the ASDL description by the definitions generator <ref> [Ser97] </ref>. 3.3.1 Prototype Definitions Generator ASDL has been used to describe the internal data structures of a prototype tool that generates code from ASDL descriptions.
Reference: [Sha97] <author> Zhong Shao. </author> <title> An overview of the FLINT/ML compiler. </title> <booktitle> In Proc. 1997 ACM SIGPLAN Workshop on Types in Compilation, </booktitle> <month> June </month> <year> 1997. </year>
Reference-contexts: Table 1 summarizes our evaluation of existing systems. The following is a summary of the concrete design goals of ASDL. * The language must be simple and concise. * The language must be able to encode existing IR's such as SUIF [W + 94], FLINT <ref> [Sha97] </ref>, and lcc's IR [FH95]. * Tools that use the language must initially be able to produce code for C, C++, Java, and ML. * Tools must be able to produce code designed to be understood by programmers, not just other tools. * Language features must have a natural encoding in
Reference: [Sri95] <author> Raj Srinivasan. </author> <title> RFC 1831: RPC: Remote Procedure Call Protocol specification version 2, </title> <month> August </month> <year> 1995. </year>
Reference-contexts: Heterogeneous networked systems have solved a similar component interoperation problem with interface description languages (IDLs) that describe abstract interfaces to network services. Tools automatically generate glue code from an IDL description and export a service to the network. ONC RPC <ref> [Sri95] </ref>, OMG CORBA [Obj95], and Xerox's ILU [Xer96] are examples of this approach. Unfortunately CORBA and the other IDLs have awkward encodings for the tree-like data structures seen in IRs. Ideally those in the compiler research community could reuse existing solutions.
Reference: [Vol91] <author> J. Vollmer. </author> <title> Experiences with gentle: Efficient compiler construction based on logic programming. </title> <booktitle> Lecture Notes in Computer Science, </booktitle> <address> 528:425??, </address> <year> 1991. </year>
Reference-contexts: ASDL descriptions are more concise than data-structure definitions in languages such as C, C++, and Java. The idea of special notation for tree-like data structures is not new. Compiler-construction systems and attribute-evaluation tools contain small sublan-guages that are descriptions of tree-like data structures <ref> [GHL + 92, Bat96, Vol91, JPJ + 90] </ref>.
Reference: [W + 94] <author> Robert Wilson et al. </author> <title> SUIF: An infrastructure for research on parallelizing and optimizing compilers. </title> <journal> ACM SIGPLAN Notices, </journal> <volume> 29(12):3137, </volume> <month> December </month> <year> 1994. </year>
Reference-contexts: Table 1 summarizes our evaluation of existing systems. The following is a summary of the concrete design goals of ASDL. * The language must be simple and concise. * The language must be able to encode existing IR's such as SUIF <ref> [W + 94] </ref>, FLINT [Sha97], and lcc's IR [FH95]. * Tools that use the language must initially be able to produce code for C, C++, Java, and ML. * Tools must be able to produce code designed to be understood by programmers, not just other tools. * Language features must have <p> insights gained by attempting to respecify an existing compiler IR in ASDL, an evaluation of ASDL's syntax, and some initial experiences using ASDL related tools to build applications. 3.1 ASDL SUIF ASDL has been used to respecify the core IR of an existing compiler infrastructure, the Stanford University Intermediate Format <ref> [W + 94] </ref> (SUIF) written in C++. Being able to specify existing compiler IRs in ASDL is one of the key design goals of ASDL.
Reference: [Wir77] <author> N. Wirth. </author> <title> What can be do about the unnecessary diversity of notation for syntactic definitions? Communications of the ACM, </title> <address> 20(11):882, </address> <month> November </month> <year> 1977. </year>
Reference-contexts: ASN.1 and SGML also have qualifiers to specify that the order of components in sequences has no meaning. They support the notion of a set of values. ASDL does not support this feature, since sequences can model sets. 2.6 Product Types, Attributes, and Options Those familiar with EBNF <ref> [Wir77] </ref> or algebraic data types may expect to be able to write descriptions with productions such as t = C (int, (int, int)*) . However, complex expressions of this type are not allowed in ASDL.
Reference: [Xer96] <institution> Xerox Corporation. </institution> <note> ILU 2.0alpha8 Refer-nce Manual, May 1996. ftp://ftp. parc.xerox.com/pub/ilu/ilu.html. </note>
Reference-contexts: Heterogeneous networked systems have solved a similar component interoperation problem with interface description languages (IDLs) that describe abstract interfaces to network services. Tools automatically generate glue code from an IDL description and export a service to the network. ONC RPC [Sri95], OMG CORBA [Obj95], and Xerox's ILU <ref> [Xer96] </ref> are examples of this approach. Unfortunately CORBA and the other IDLs have awkward encodings for the tree-like data structures seen in IRs. Ideally those in the compiler research community could reuse existing solutions.
Reference: [XML97] <institution> Extensible markup language (XML). </institution> <note> http://www.w3.org/TR/WD-xml, 1997. </note>
Reference-contexts: There already are groups advocating the use of a simplified subset of SGML for for distribution of web content <ref> [XML97] </ref>. ASDL in some ways can be viewed as simplification of ASN.1. Heterogeneous networked systems have solved a similar component interoperation problem with interface description languages (IDLs) that describe abstract interfaces to network services. Tools automatically generate glue code from an IDL description and export a service to the network.
References-found: 25

