URL: http://www.ri.cmu.edu/afs/cs.cmu.edu/project/venari/papers/ml-workshop92/ml-workshop92.ps
Refering-URL: http://www.ri.cmu.edu/afs/cs.cmu.edu/project/venari/www/ml-workshop92.html
Root-URL: 
Title: Extensions to Standard ML to Support Transactions  
Author: Jeannette M. Wing, Manuel Faehndrich, J. Gregory Morrisett, and Scott Nettles 
Address: Pittsburgh, PA 15213  
Affiliation: School of Computer Science Carnegie Mellon University  
Abstract: A transaction is a control abstraction that lets programmers treat a sequence of operations as an atomic ("all-or-nothing") unit. This paper describes our progress on on-going work to extend SML with transactions. What is novel about our work on transactions is support for multi-threaded concurrent transactions. We use SML's modules facility to reflect explicitly orthogonal concepts heretofore inseparable in other transaction-based programming languages. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> E.C. Cooper and J. Gregory Morrisett. </author> <title> Adding threads to Standard ML. </title> <type> Technical Report CMU-CS-90-186, CMU, </type> <month> December </month> <year> 1990. </year>
Reference-contexts: We reported on this work at the Pittsburgh 1991 ML workshop. Also, along with others at Carnegie Mellon, we have separately designed and built a threads package for SML/NJ <ref> [1] </ref>. We reported on this work at the Edinburgh 1990 ML workshop. 1 This paper reports on our progress for combining our support for threads and that for transactions. We address concurrency, in two ways: making an individual transaction multi-threaded and allowing multiple transactions to run concurrently. <p> Thus, it is impossible to violate the isolation principle if the programmer uses only safe refs. 2 Appendix B shows parts of the THREAD SYSTEM and other relevant signatures; see <ref> [1] </ref> for a discussion of threads in SML. signature TRANSACT = sig structure Trans : sig exception Abort val transact : ('a -&gt; 'b) -&gt; 'a -&gt; 'b val abort_top_level: unit -&gt; 'a val abort: unit -&gt; 'a eqtype rw_lock val rw_lock : unit -&gt; rw_lock val acquire_read : rw_lock -&gt; <p> If the transaction now aborts, and we are to undo all of its effects, including reacquiring the lock, we may deadlock if s is waiting to acquire some other held lock. 4.2 Per transaction state Just as there is per thread state <ref> [1] </ref>, we assume there is per transaction state. This state includes four pieces of separable information: * The data objects accessed by the transaction.
Reference: [2] <author> D. L. Detlefs, M. P. Herlihy, and J. M. Wing. </author> <title> Inheritance of synchronization and recovery properties in Avalon/C++. </title> <booktitle> IEEE Computer, </booktitle> <pages> pages 57-69, </pages> <month> December </month> <year> 1988. </year>
Reference-contexts: Systems like Tabs [8] and Camelot [3] demonstrate the viability of layering a general-purpose transactional facility on top of an operating system. Languages such as Argus [4] and Avalon/C++ <ref> [2] </ref> go one step further by providing linguistic support for transactions in the context of a general-purpose programming language. In principle programmers can now use transactions as a unit of encapsulation to structure an application program without regard for how they are implemented at the operating system level.
Reference: [3] <author> J. Eppinger, L. Mummert, and A. Spector. Camelot and Avalon: </author> <title> A Distributed Transaction Facility. </title> <publisher> Morgan Kaufmann, </publisher> <year> 1991. </year>
Reference-contexts: If it completes successfully, it commits; otherwise, it aborts; (2) concurrent transactions are serializable (appear to occur one-at-a-time), supporting the principle of isolation; and (3) effects of committed transactions are persistent (survive failures). Systems like Tabs [8] and Camelot <ref> [3] </ref> demonstrate the viability of layering a general-purpose transactional facility on top of an operating system. Languages such as Argus [4] and Avalon/C++ [2] go one step further by providing linguistic support for transactions in the context of a general-purpose programming language.
Reference: [4] <author> B. Liskov and R. Scheifler. </author> <title> Guardians and actions: Linguistic support for robust, distributed programs. </title> <journal> ACM TOPLAS, </journal> <volume> 5(3) </volume> <pages> 382-404, </pages> <month> July </month> <year> 1983. </year>
Reference-contexts: Systems like Tabs [8] and Camelot [3] demonstrate the viability of layering a general-purpose transactional facility on top of an operating system. Languages such as Argus <ref> [4] </ref> and Avalon/C++ [2] go one step further by providing linguistic support for transactions in the context of a general-purpose programming language.
Reference: [5] <author> J.E.B. Moss. </author> <title> Nested transactions: An approach to reliable distributed computing. </title> <type> Technical Report MIT/LCS/TR-260, </type> <institution> MIT, </institution> <month> April </month> <year> 1981. </year>
Reference-contexts: We have implemented the interfaces shown in Figure 3. We use standard two-phase read/write locks to ensure serializability among concurrent transactions. We use Moss's locking rules for nested concurrent transactions <ref> [5] </ref>. Two items of note are visible through these interfaces. <p> Release all mutex locks held by non-root threads running on behalf of the transaction. 4. Anti-inherit all read/write locks to its parent <ref> [5] </ref>. 5. If the transaction is top-level, save the state of persistent memory. 6. Exit the transaction and continue processing. 4.5 What happens upon abort? A transaction may voluntarily abort or be involuntarily aborted (e.g., due to a system crash).
Reference: [6] <author> Scott M. Nettles and J.M. Wing. </author> <title> Persistence + Undoability = Transactions. </title> <booktitle> In Proc. of HICSS-25, </booktitle> <month> January </month> <year> 1992. </year>
Reference-contexts: In the case of single-site, single-threaded, nested transactions, we support separately the persistence and undoability prop 2 erties of transactions in terms of two different modules; we then compose them to build a module for transactions <ref> [6] </ref>. We reported on this work at the Pittsburgh 1991 ML workshop. Also, along with others at Carnegie Mellon, we have separately designed and built a threads package for SML/NJ [1]. <p> Threads provide functionality, e.g., two-way communication, and performance benefits that transactions do not. 5 thread/transaction A thread/transaction B (a) thread/transaction A thread/transaction B (b) 6 3 Design Overview As in our design for single-threaded transactions for SML <ref> [6] </ref>, if f is a function applied to some argument a, then to execute: f a in a transaction, we want programmers to be able to write: (transact f) a or more probably, ((transact f) a ) handle Abort =&gt; [some work] Here f might be multi-threaded. <p> If the transaction is top-level, save the state of persistent memory. 6. Exit the transaction and continue processing. 4.5 What happens upon abort? A transaction may voluntarily abort or be involuntarily aborted (e.g., due to a system crash). Following our semantics for single-threaded transact <ref> [6] </ref>, we mask any exception as an abort. Moreover, we treat any unhandled exception as an abort. The effect of an abort is to undo all changes to the data state made by all threads executing on behalf of the transaction. Upon abort, we do the following: 1.
Reference: [7] <author> M. Satyanarayanan et al. Coda: </author> <title> A highly available file system for a distributed workstation environment. </title> <journal> IEEE Trans. Comp., </journal> <volume> 39(4) </volume> <pages> 447-459, </pages> <month> April </month> <year> 1990. </year>
Reference-contexts: One problem is that state-of-the-art transactional facilities are so tightly integrated that application builders must buy into a facility in toto, even if they need only one of its services. For example, the Coda file system <ref> [7] </ref> was originally built on top of Camelot, which supports distributed, fl This research was sponsored by the Avionics Lab, Wright Research and Development Center, Aeronautical Systems Division (AFSC), U. S. Air Force, Wright-Patterson AFB, OH 45433-6543 under Contract F33615-90-C-1465, Arpa Order No. 7597. concurrent, nested transactions.
Reference: [8] <author> A.Z. Spector et al. </author> <title> Support for distributed transactions in the TABS prototype. </title> <journal> IEEE TSE, </journal> <volume> 11(6) </volume> <pages> 520-530, </pages> <month> June </month> <year> 1985. </year>
Reference-contexts: If it completes successfully, it commits; otherwise, it aborts; (2) concurrent transactions are serializable (appear to occur one-at-a-time), supporting the principle of isolation; and (3) effects of committed transactions are persistent (survive failures). Systems like Tabs <ref> [8] </ref> and Camelot [3] demonstrate the viability of layering a general-purpose transactional facility on top of an operating system. Languages such as Argus [4] and Avalon/C++ [2] go one step further by providing linguistic support for transactions in the context of a general-purpose programming language.
Reference: [9] <author> A.P. Tolmach and A.W. Appel. </author> <title> Debugging Standard ML without reverse engineering. </title> <booktitle> In Proceedings of the ACM Lisp and Functional Programming Conference, </booktitle> <pages> pages 1-12, </pages> <year> 1990. </year> <month> 12 </month>
Reference-contexts: Second, we guarantee the principle of isolation for transactions by making use of "safe" refs <ref> [9] </ref> (and correspondingly "safe" arrays). In the context of just threads, a normal SML ref is unsafe, while a ref protected by a mutex is a safe ref.
References-found: 9

