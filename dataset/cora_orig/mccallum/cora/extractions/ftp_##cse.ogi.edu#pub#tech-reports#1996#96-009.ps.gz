URL: ftp://cse.ogi.edu/pub/tech-reports/1996/96-009.ps.gz
Refering-URL: ftp://cse.ogi.edu/pub/tech-reports/README.html
Root-URL: http://www.cse.ogi.edu
Email: fbell,bellegar,hookg@cse.ogi.edu  
Title: Type-driven Defunctionalization  
Author: Jeffrey M. Bell Fran~coise Bellegarde James Hook 
Address: PO Box 91000 Portland, Oregon 97291-1000 USA  
Affiliation: Pacific Software Research Center Oregon Graduate Institute of Science Technology  
Abstract: In 1972, Reynolds outlined a general method for eliminating functional arguments known as defunctionalization. The idea underlying defunctionalization is encoding functional values as first-order data, and then to realized the applications of the encoded function via an apply function. Although this process is simple enough, problems arise when defunctionalization is used in a polymorphic language. In such a language, a functional argument of a higher-order function can take different type instances in different applications. As a consequence, its associated apply function can be untypable in the soucre language. In the paper we present a defunctionalization transformation which preserves typa-bility. Moreover, the transformation imposes no restriction on functional arguments of recursive functions, and it handles functions as results as well as functions encapsulated in constructors or tuples. The key to this success is the use of type information in the defunctionalization transformation. Run-time characteristics are preserved by defunction-alization; hence, there is no performance improvement coming from the transformation itself. However closures need not be implemented to compile the transformed program. Since the defunctionalization is driven by type information, it can also easily perform a specialization of higher-order functions with respect to the values of their functional arguments, hence gaining a real run-time improvement of the transformed program. 
Abstract-found: 1
Intro-found: 1
Reference: [B + 94] <author> J. Bell et al. </author> <title> Software Design for Reliability and Reuse: A proof-of-concept demonstration. </title> <booktitle> In TRI-Ada '94 Proceedings, </booktitle> <pages> pages 396-404. </pages> <publisher> ACM, </publisher> <month> November </month> <year> 1994. </year>
Reference-contexts: The defunctionalization transformation, we present in this paper, is a step in a pipe-line of transformations designed to automatically derive a program generator <ref> [B + 94, KBB + 94] </ref> from the semantics of a domain-specific design language. The purpose of the transformation is to obtain satisfactory performance and to tailor the implementation to a specific platform and software environment. Defunctionaliza-tion accommodates software environments which penalize or prohibit functionals.
Reference: [BBH96] <author> Jeffrey M. Bell, Fran~coise Bellegarde, and James Hook. Type-driven defunc-tionalization. </author> <type> Technical report, </type> <institution> OGICSE, </institution> <year> 1996. </year>
Reference-contexts: The remainder of the paper is organized as follows. Section 2 describes how the type-driven defunctionalization transformation is applied to higher-order programs. Section 3 summarizes the results related to soundness, termination, and effectiveness of the transformation (full proofs are given in a technical report <ref> [BBH96] </ref>). Section 4 presents our conclusions and future work. The appendices include several illustrative examples. 2 Presentation of the transformation The defunctionalization transformation applies to a restricted form of higher-order polymorphic strongly-typed functional language. A grammar for the language is presented in Table 1.
Reference: [Bel94] <author> J. M. Bell. </author> <title> An Implementation of Reynold's Defunctionalization Method for a Modern Functional Language. </title> <type> Master's thesis, </type> <institution> Department of Computer Science and Engineering, Oregon Graduate Institute, </institution> <month> January </month> <year> 1994. </year>
Reference-contexts: Chin and Darlington address this in their A-algorithm [CD], which removes some functional results by -expansion. Our transformation includes the capabilities of the A-algorithm. Problems arise when defunctionalization is used in a polymorphic language <ref> [Bel94, BH94a] </ref>. In the above example, map is called twice, each time passing a function of type int ! int. Suppose that the second call to map used a function with a different type, e.g. str2int : string ! int.
Reference: [Bel95a] <author> F. Bellegarde. Astre: </author> <title> Towards a fully automated program transformation system. </title> <booktitle> In Proceedings of the sixth conference on Rewriting Techniques and Applications, volume 914 of LNCS. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1995. </year>
Reference-contexts: The purpose of the transformation is to obtain satisfactory performance and to tailor the implementation to a specific platform and software environment. Defunctionaliza-tion accommodates software environments which penalize or prohibit functionals. It is also used to translate functional programs into term-rewriting systems in the transformation system Astre <ref> [Bel95b, Bel95a] </ref> which uses term-rewriting techniques to perform algebraic manipulation on functional programs.
Reference: [Bel95b] <author> F. Bellegarde. </author> <title> Automatic Synthesis by Completion. In Journees Francophones sur les Langages Applicatifs, </title> <institution> INRIA, collection didactiques, </institution> <year> 1995. </year>
Reference-contexts: The purpose of the transformation is to obtain satisfactory performance and to tailor the implementation to a specific platform and software environment. Defunctionaliza-tion accommodates software environments which penalize or prohibit functionals. It is also used to translate functional programs into term-rewriting systems in the transformation system Astre <ref> [Bel95b, Bel95a] </ref> which uses term-rewriting techniques to perform algebraic manipulation on functional programs.
Reference: [BH94a] <author> Jeffrey M. Bell and James Hook. </author> <title> Defunc-tionalization of typed programs. </title> <type> Technical Report 94-025, </type> <institution> Department of Computer Science and Engineering, Oregon Graduate Institute, </institution> <month> February </month> <year> 1994. </year>
Reference-contexts: Chin and Darlington address this in their A-algorithm [CD], which removes some functional results by -expansion. Our transformation includes the capabilities of the A-algorithm. Problems arise when defunctionalization is used in a polymorphic language <ref> [Bel94, BH94a] </ref>. In the above example, map is called twice, each time passing a function of type int ! int. Suppose that the second call to map used a function with a different type, e.g. str2int : string ! int.
Reference: [BH94b] <author> Fran~coise Bellegarde and James Hook. </author> <title> Substitution: A formal methods case study using monads and transformations. </title> <booktitle> Science of Computer Programming, </booktitle> <address> 23(2-3):287-311, </address> <year> 1994. </year>
Reference: [CD] <author> W. Chin and J. Darlington. </author> <title> Higher-Order Removal: A modular approach. </title> <note> To appear in Lisp and Symbolic Computation. </note>
Reference-contexts: Chin and Darlington address this in their A-algorithm <ref> [CD] </ref>, which removes some functional results by -expansion. Our transformation includes the capabilities of the A-algorithm. Problems arise when defunctionalization is used in a polymorphic language [Bel94, BH94a]. In the above example, map is called twice, each time passing a function of type int ! int. <p> Although specialization-based techniques for de-functionalization exist <ref> [CD] </ref>, they do not defunctionalize functions in data constructors (e.g. lists of functions). In addition, there are higher-order functions on which specialization fails because an infinite family of specializations would be generated, such as the example in Figure 4. Our type-driven transformation is presented as a set of transformation rules. <p> Although recursion can be recovered by way of recursive local functions, the macro method supports only functional arguments which remain identical in recursive calls. The method that specializes functional applications with respect to the values of arrow type arguments is limited to so called variable-only arrow type arguments <ref> [CD] </ref>. None of these methods consider the case of higher-order constructor applications. Our transformation is based on Reynolds's method [Rey72] of encoding functional arguments. Our main contribution is to bring together this idea and the idea of using functional application types to drive the defunctionalization transformation. <p> Our main contribution is to bring together this idea and the idea of using functional application types to drive the defunctionalization transformation. This is crucial for handling polymorphic higher-order functions as has been noted by Chin and Darlington in their A-algorithm <ref> [CD] </ref>, which is used to remove some functional results by eta-expansion. Our transformation includes the functionality of the A-algorithm. <p> The only gains in performance come from removing the penalties incurred by the implementation of higher-order functions. In contrast, Chin and Darlington's R algorithm <ref> [CD] </ref> relies on specialization with respect to the values of functional arguments and returns, when it is applicable, an improved first-order program.
Reference: [Joh85] <author> Thomas Johnsson. </author> <title> Lambda lifting: transforming programs to recursive equations. </title> <editor> In J-P. Jouannaud, editor, </editor> <booktitle> Functional Programming Languages and Computer Architecture, volume 201 of LNCS, </booktitle> <pages> pages 190-203. </pages> <publisher> Springer-Verlag, </publisher> <year> 1985. </year>
Reference-contexts: Only function symbols, function variables, and constructors can appear in function application position. A program consists of datatype declarations followed by function declarations followed by a (top-level) term. This language form can be calculated from, say, a core ML program by the standard lambda-lifting transformation <ref> [Joh85] </ref>. These restrictions simplify the exposition; the language can be extended without fundamental changes. The naming conventions used in this and following Sections are given in Table 2.
Reference: [KBB + 94] <author> Richard B. Kieburtz, Fran~coise Belle-garde, Jef Bell, James Hook, Jeffrey Lewis, Dino Oliva, Tim Sheard, Lisa Wal-ton, and Tong Zhou. </author> <title> Calculating software generators from solution specifications. </title> <type> Technical Report OGI-CSE-94-032B, </type> <institution> Department of Computer Science and Engineering, Oregon Graduate Institute, </institution> <month> Oc-tober </month> <year> 1994. </year>
Reference-contexts: The defunctionalization transformation, we present in this paper, is a step in a pipe-line of transformations designed to automatically derive a program generator <ref> [B + 94, KBB + 94] </ref> from the semantics of a domain-specific design language. The purpose of the transformation is to obtain satisfactory performance and to tailor the implementation to a specific platform and software environment. Defunctionaliza-tion accommodates software environments which penalize or prohibit functionals.
Reference: [Mil78] <author> R. Milner. </author> <title> A theory of type polymor-phism. </title> <journal> Journal of Computer and System Science, </journal> <pages> pages 348-375, </pages> <year> 1978. </year>
Reference-contexts: No more transformation rules are needed to cope with recursive calls in a set of mutually recursive clone declarations, as explained in the following section. 2.3 Higher-order recursive functions In a clone, types can be inferred with Hindley-Milner type inference <ref> [Mil78] </ref> augmented with the rules of Figure 6 and from the type label of the clone function symbol.
Reference: [PS87] <author> A. Pettorossi and A. Skowron. </author> <title> Higher order generalization in program derivation. </title> <publisher> In Springer Verlag, </publisher> <editor> editor, </editor> <booktitle> Proceedings of TAPSOFT '87: Theory and Practice of Software Development, volume 250 of LNCS, </booktitle> <year> 1987. </year>
Reference: [Rey72] <author> John C. Reynolds. </author> <title> Definitional interpreters for higher-order programming languages. </title> <booktitle> In ACM National Conference, </booktitle> <pages> pages 717-740. </pages> <publisher> ACM, </publisher> <year> 1972. </year>
Reference-contexts: The algorithm presented performs necessary type specialization but does not generate a strictly monomorphic representation. Reynolds outlined a general method for defunctionaliza-tion <ref> [Rey72] </ref>. The idea underlying defunctionalization is encoding functional values as first-order data. Since a first-order value cannot be applied as a function, applications of the encoded functionals need to be modified, by introducing a call to an apply function. <p> The method that specializes functional applications with respect to the values of arrow type arguments is limited to so called variable-only arrow type arguments [CD]. None of these methods consider the case of higher-order constructor applications. Our transformation is based on Reynolds's method <ref> [Rey72] </ref> of encoding functional arguments. Our main contribution is to bring together this idea and the idea of using functional application types to drive the defunctionalization transformation.

References-found: 13

