URL: http://www.win.tue.nl/~richard/Docs/ppg.ps
Refering-URL: http://WWWcg.win.tue.nl/~richard/Project/index.html
Root-URL: http://www.win.tue.nl
Email: e-mail: Remco.Veltkamp@cs.ruu.nl  e-mail: richard@cwi.nl  
Title: Information Hiding and the Complexity of Constraint Satisfaction  
Author: Remco C. Veltkamp Richard H. M. C. Kelleners and 
Address: Padualaan 14, 3584 CH Utrecht, The Netherlands  Kruislaan 413, 1098 SJ Amsterdam, The Netherlands  Den Dolech 2, 5612 AZ, Eindhoven, The Netherlands  
Affiliation: Utrecht University, Department of Computing Science  CWI, Department of Interactive Systems  Technical University of Eindhoven, Department of Computing Science  
Abstract: This paper discusses the complexity of constraint satisfaction, and the effect of information hiding. On the one hand, powerful constraint satisfaction is necessarily global, and tends to break information hiding. On the other hand, preserving strict information hiding increases the complexity of constraint satisfaction, or severely limits the power of the constraint solver. Ultimately, under strict information hiding, constraint satisfaction on complex objects cannot be guaranteed. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Sara Baase. </author> <title> Computer Algorithms: Introduction to Design and Analysis. </title> <publisher> Addison-Wesley, </publisher> <year> 1978. </year>
Reference-contexts: This can be deduced from the fact that the satisfiability variant can be converted in polynomial time into the CNF-satisfiability problem, which is NP-complete <ref> [1] </ref>. The CNF-satisfiability problem is to determine if there is a truth assignment (a way to assign the values true and false) for the variables in a logical expression in conjunctive normal form (CNF) such that the value of the expression is true. <p> The condition of `different colors' corresponds to `different walls, plus fixed distance'; both conditions take constant time to check. Just like general constraint satisfaction, k-Graph Coloring is known to be NP-complete <ref> [1] </ref>. Determining if a graph is 2-colorable is easy (polynomial). Determining if it is 3-colorable is NP-complete. It is still NP-complete if the graphs are planar and the maximal degree is four. If the maximal degree is at most two, the k-coloring problem is easy.
Reference: [2] <author> Grady Booch. </author> <title> Object-Oriented Analysis and Design with applications. </title> <publisher> The Benjamin/Cummings Publishing, </publisher> <year> 1994. </year>
Reference-contexts: Whereas abstraction focuses on the observable behavior of an object, encapsulation focuses on the implementation behind that behavior. Encapsulation is the process of compartmentalizing the elements of an abstraction that constitute its structure and behavior. It serves to separate the contractual interface of an abstraction and its implementation <ref> [2] </ref>. Encapsulation could be achieved by physical separation, e.g. residing the data structures and methods of each object on a private processor. Encapsulation is most often achieved through information hiding, i.e. the process of hiding all the secrets of an object that do not contribute to its essential characteristics. <p> Encapsulation is most often achieved through information hiding, i.e. the process of hiding all the secrets of an object that do not contribute to its essential characteristics. Typically, the structure of an object is hidden, as well as the implementation of its methods <ref> [2] </ref>. The justification for combining objects and constraints derives from the fact that it addresses the problems of complexity in large interactive graphical systems which arises on two fronts. The first is the complexity inherent in specifying the behavior of animations and interactions with many components or objects.
Reference: [3] <author> C. Choppy, S. Kaplan, and M. Soria. </author> <title> Complexity analysis of term-rewriting systems. </title> <journal> Theoretical Computer Science, </journal> <volume> 67(2/3):261 - 282, </volume> <year> 1989. </year>
Reference-contexts: Very little has been written about the complexity of term rewriting. An approach to determine the complexity of term rewriting systems is given in <ref> [3] </ref>, where a notion of the complexity is given by means of the cost of terms.
Reference: [4] <author> Eric Cournarie and Michel Beaudouin-Lafon. </author> <title> Alien: a prototype-based constraint system. </title> <editor> In Laffra et al. </editor> <volume> [11], </volume> <pages> pages 92-110. </pages>
Reference-contexts: For example C ++ provides the `friend' declaration to grant functions access to the private part of objects. This is also comparable to the approach taken by <ref> [4] </ref>, where special variables (slots) are accessible by constraints only. One can argue that encapsulation is still violated (and specifically that the C ++ friend construct could be easily misused). This raises the question how strict information hiding affects (the complexity of) constraint satisfaction.
Reference: [5] <author> Jacques Davy. </author> <title> Go, a graphical and interactive C++ toolkit for application data presentation and editing. </title> <booktitle> In Proceedings 5th Annual Technical Conference on the X Window System, </booktitle> <year> 1991. </year>
Reference-contexts: In [12], the methods of an object that may violate constraints are guarded by so-called propagators. The propagators send messages to other objects to maintain the constraints. This technique is similar to the pre- and postcondition facilities in Go <ref> [5] </ref>. It is limited to constraint maintenance (i.e. truth maintenance, as opposed to starting with an inconsistent situation that is then resolved), and not further considered in this paper. A more powerful technique is presented in [23].
Reference: [6] <author> R. Dechter and J. Pearl. </author> <title> Network-based heuristics for constraint satisfaction problems. </title> <journal> AI, </journal> <volume> 34 </volume> <pages> 1-38, </pages> <year> 1988. </year>
Reference-contexts: E.g., when there are no cycles in the constraint graph, achieving node and arc-consistency implies that the graph is backtrack-free, i.e. a solution can be found without backtracking [8]. In a backtrack-free graph, a solution is found in time linear in the number of nodes <ref> [6] </ref>. When there are cycles in the graph, additional algorithms have to be used to reduce the problem, such as the recognition of certain patterns (e.g. k-trees). 6.1 Linkage Positioning Problem In CP-1, there are no unary constraints on the variables, thus, by definition it is node-consistent.
Reference: [7] <author> Bjorn N. Freeman-Benson and Alan Borning. </author> <title> Integrating constraints with an object-oriented language. </title> <editor> In O. Lehrmann Madsen, editor, </editor> <booktitle> Proceedings ECOOP'92, </booktitle> <volume> LNCS 615, </volume> <pages> pages 268-286. </pages> <publisher> Springer-Verlag, </publisher> <year> 1992. </year>
Reference-contexts: If the constraint system is part of a programming language, the infringement of information hiding is under control of the constraint solver. From the application programmer's point of view the data encapsulation is still preserved. Indeed, as pointed out by <ref> [7] </ref>, requiring the language's internal constraint system to respect information hiding is similar to requiring an optimizing compiler to respect information hiding, which would make part of its task impossible.
Reference: [8] <author> Eugene C. Freuder. </author> <title> A sufficient condition for backtrack-free search. </title> <journal> Journal of the ACM, </journal> <volume> 29(1) </volume> <pages> 24-32, </pages> <month> January </month> <year> 1982. </year>
Reference-contexts: These algorithms are used to reduce the search space of the problem. E.g., when there are no cycles in the constraint graph, achieving node and arc-consistency implies that the graph is backtrack-free, i.e. a solution can be found without backtracking <ref> [8] </ref>. In a backtrack-free graph, a solution is found in time linear in the number of nodes [6].
Reference: [9] <author> Hans-Werner Gusgen and Joachim Hertzberg. </author> <title> Some fundamental properties of local constraint propagation. </title> <journal> AI, </journal> <volume> 36 </volume> <pages> 237-247, </pages> <year> 1988. </year>
Reference-contexts: These variables and the constraints on them are put into the queue. Because constraints on changed variables are placed in a first-in-first-out queue (as opposed to an unordered set), they are guaranteed to be revised later on, whether the propagation is finite or infinite. This is called fair propagation <ref> [9] </ref>. If there are no cycles in the constraint graph, LP solves each constraint exactly once, and so the time complexity is linear in the number of constraints. Let R be the time needed to revise a constraint. The time complexity for LP is then O (Re).
Reference: [10] <author> Quinton Hoole and Edwin Blake. </author> <title> OOCS constraints in an object oriented environment. </title> <booktitle> In [24], </booktitle> <pages> pages 215-230, </pages> <year> 1994. </year>
Reference-contexts: In this way, a set of solution programs is generated, which is offered to the application. The application must choose a solution program from that set to execute in order to satisfy the constraints. Another system, which is quite similar to Equate, is the Object-Oriented Constraint System, OOCS <ref> [10] </ref>. The main difference between these systems is that OOCS does not use term rewriting. Instead, an object supplies a set of solution program segments for each constraint that has been imposed upon it. <p> Note that in the end the use of read-sets and write-sets in Equate and OOCS, which contain implementation specific knowledge of an object, infringes the concept of information hiding after all. In <ref> [10] </ref> is put forward that encapsulation is maintained from the application programmer's perspective. The read-sets and write-sets are only available to the constraint solver, thus keeping the benefits of object-oriented programming for the programmer.
Reference: [11] <author> C. Laffra, E. H. Blake, V. de Mey, and X. Pintado, </author> <title> editors. Object Oriented Programming for Graphics, Focus on Computer Graphics. </title> <publisher> Springer, </publisher> <year> 1995. </year>
Reference: [12] <author> Chris Laffra and Jan van den Bos. </author> <title> Propagators and concurrent constraints. </title> <journal> OOPS Messenger, </journal> <volume> 2(2) </volume> <pages> 68-72, </pages> <month> April </month> <year> 1991. </year>
Reference-contexts: To avoid this problem, approaches based on message passing have been proposed. In <ref> [12] </ref>, the methods of an object that may violate constraints are guarded by so-called propagators. The propagators send messages to other objects to maintain the constraints. This technique is similar to the pre- and postcondition facilities in Go [5].
Reference: [13] <author> Wm. Leler. </author> <title> Constraint Programming Languages. </title> <publisher> Addison-Wesley, </publisher> <year> 1988. </year>
Reference-contexts: Very little has been written about the complexity of term rewriting. An approach to determine the complexity of term rewriting systems is given in [3], where a notion of the complexity is given by means of the cost of terms. In <ref> [13] </ref> is mentioned that if the set of terms is strictly left-sequential, there is a fast algorithm which can find a rule in the rule-base in time linear in the length of the expression to be rewritten (the head of the rule).
Reference: [14] <author> Richard J. Lipton. </author> <title> Dna solution of hard computational problems. </title> <journal> Science, </journal> <volume> 268 </volume> <pages> 542-545, </pages> <month> April </month> <year> 1995. </year>
Reference-contexts: Because the general CSP is a hard problem, satisfaction algorithms are often slow. One way to speed up satisfaction is to perform computations in parallel. For example, <ref> [14] </ref> performs massively parallel computations by means of chemical reactions on DNA strands. One can also confine the domain of the constraints and the variables and exploit some of the specific knowledge of the domain.
Reference: [15] <author> A. K. Mackworth. </author> <title> Consistency in networks of relations. </title> <journal> AI, </journal> <volume> 8 </volume> <pages> 99-118, </pages> <year> 1977. </year>
Reference-contexts: We call a constraint satisfaction problem node-consistent if and only if for all variables, all values in its domain satisfy the unary constraints on that variable (cf. <ref> [15] </ref>). <p> s 2 in v 2 .domain ()) f if (check (s 1 ,s 2 )) f delete = FALSE; break; g g if (delete) f v 1 .domain ().remove (s 1 ); changed = TRUE; g g return changed; g The following simple algorithm for arc-consistency is called AC-3, after <ref> [15] </ref>: AC-3 (V, C) while ( NOT C.empty ()) do f C.select (c 1 , v 1 , v 2 ); C.remove (c 1 , v 1 , v 2 ); if (c 1 .revise (v 1 ,v 2 )) for (each (c 2 ,v 2 ,v 3 ) 6= (c
Reference: [16] <author> A. K. Mackworth and E. Freuder. </author> <title> The complexity of some polynomial network consistency algorithms for constraint satisfaction problems. </title> <journal> AI, </journal> <volume> 25 </volume> <pages> 65-74, </pages> <year> 1985. </year>
Reference-contexts: If the constraint graph is planar, then the time complexity is also linear in the number of variables <ref> [16] </ref>. A less simple but optimal algorithm, AC-4, is presented in [17]. It has time complexity O (ea 2 ). The algorithm is easily adapted for continuous domains, but termination of the algorithm then is not assured.
Reference: [17] <author> R. Mohr and T. C. Henderson. </author> <title> Arc and path consistency revisited. </title> <journal> AI, </journal> <volume> 28 </volume> <pages> 225-233, </pages> <year> 1986. </year>
Reference-contexts: If the constraint graph is planar, then the time complexity is also linear in the number of variables [16]. A less simple but optimal algorithm, AC-4, is presented in <ref> [17] </ref>. It has time complexity O (ea 2 ). The algorithm is easily adapted for continuous domains, but termination of the algorithm then is not assured. The time complexity becomes O (Re), with the number of loops taken in the algorithm, and R the time necessary to revise a constraint.
Reference: [18] <author> John R. Rankin. </author> <title> A graphics object oriented constraint solver. </title> <editor> In Laffra et al. </editor> <volume> [11], </volume> <pages> pages 71-91. </pages>
Reference-contexts: This however, allows every other object to get and set these values, which is clearly against the object-oriented philosophy. One way to restrict this, is to have an object allow value setting only when its internal constraints remain satisfied (see <ref> [18] </ref>). A constraint could be made internal by constructing a `container object', which contains the constraint and the operand objects, but this does not solve the basic problem.
Reference: [19] <author> Michael Sannella. </author> <title> Constraint Satisfaction and Debugging for Interactive User Interfaces. </title> <type> PhD thesis, </type> <institution> University of Washington, </institution> <address> Seattle, Washington, </address> <year> 1994. </year>
Reference-contexts: This problem could be circumvented by allowing a constraint to change the value of the variable it was triggered from. Prior to performing local propagation one can perform an analysis to plan the best order to propagate constraints <ref> [19] </ref>. It is sometimes efficient to plan how to solve constraints before actually doing it.
Reference: [20] <author> Ivan E. Sutherland. </author> <title> Sketchpad: A man-machine graphical communication system. </title> <booktitle> In Proceedings of the Spring Joint Computer Conference, </booktitle> <address> Detroit, Michigan, </address> <month> May 21-23 </month> <year> 1963, </year> <pages> pages 329-345. </pages> <publisher> AFIPS Press, </publisher> <year> 1963. </year>
Reference-contexts: The use of constraints in managing the complexity of designing interactive graphics systems dates back to the earliest days of interactive graphics (consider Sutherland's Sketchpad from the early sixties <ref> [20] </ref>), and still receives much attention. It has an intuitive appeal to regard the requirements of a model, interaction, or animation as constraints that have to be maintained.
Reference: [21] <author> Edward Tsang. </author> <title> Foundations of Constraint Satisfaction. </title> <publisher> Academic Press, </publisher> <year> 1993. </year>
Reference-contexts: This carries on until either a solution is found or all combinations of values have been tried and have failed. Below, the backtrack algorithm is given in pseudocode (see <ref> [21] </ref>).
Reference: [22] <author> Remco C. Veltkamp and Edwin H. Blake. Event-based.constraints: coordinate.satisfaction -&gt; object.solution. </author> <booktitle> In [24], </booktitle> <pages> pages 251-262, </pages> <year> 1994. </year>
Reference-contexts: If one is to sacrifice strict information hiding in order to facilitate constraint satisfaction, care should be taken not to allow abuse. In <ref> [22] </ref> we propose a radical separation of the constraint system and the normal object-oriented framework by means of two orthogonal communication strategies for objects: messages on the one hand, and events and data-flow on the other hand.
Reference: [23] <author> Michael Wilk. Equate: </author> <title> an object-oriented constraint solver. </title> <booktitle> In Proceedings OOP-SLA'91, </booktitle> <pages> pages 286-298, </pages> <year> 1991. </year>
Reference-contexts: This technique is similar to the pre- and postcondition facilities in Go [5]. It is limited to constraint maintenance (i.e. truth maintenance, as opposed to starting with an inconsistent situation that is then resolved), and not further considered in this paper. A more powerful technique is presented in <ref> [23] </ref>. There, the constraint solver produces a set of programs that solve constraints which are stated in the form of equations. It translates a declarative constraint equation into procedural solutions in terms of messages back to objects. The problem is the local character of the solution. <p> The complexity for RX is then O (m (q + m + n)). For CP-3, the number of constraints increases to n + m, resulting in a complexity of O ((m + n)). 9 Equate and OOCS Equate <ref> [23] </ref> is a constraint satisfaction system that uses term rewriting as a guide to find solutions. Constraints are specified as equations. Rewrite rules convert equations into equivalent sets of equations that can more easily be solved.
Reference: [24] <editor> P. Wisskirchen, editor. </editor> <booktitle> Proceedings 4th Eurographics Workshop on Object-Oriented Graphics, </booktitle> <address> Sintra, Portugal, </address> <month> May </month> <year> 1994. </year>
References-found: 24

