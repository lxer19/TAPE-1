URL: ftp://ftp.cse.unsw.edu.au/pub/doc/papers/UNSW/9407.ps.Z
Refering-URL: http://www.cse.unsw.edu.au/school/research/tr.html
Root-URL: http://www.cse.unsw.edu.au
Title: Time Constrained Buffer Specifications in CSP+T and Timed CSP  
Author: John J. Zic 
Affiliation: SCHOOL OF COMPUTER SCIENCE AND ENGINEERING THE UNIVERSITY OF NEW SOUTH WALES  
Abstract: SCS&E Report 9407 March, 1994 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> ISO/TC 97/SC 16/ WG 6. </author> <title> Information Processing Systems Open Systems Interconnection Transport Service Definition - Connectionless mode transmission. Standard ISO-8072-1986-Addendum1, ISO, </title> <year> 1986. </year>
Reference-contexts: Besides this most abstract functionality of order preservation, a communication system may also need to provide end users with some real-time performance. For example, maximum and 1 average message delays, throughput, reliability, probability of loss of a message, and other client requirements may be important <ref> [1, 4] </ref>. <p> The process behaves as Stop if it cannot engage in an alternative event (after the "expiration" of the current event). For example, an event a which has an enabling time interval of <ref> [0 ; 1 ] </ref> is written as [0 ; 1 ]:a and must occur only once in the specified time interval (between 0 and 1 time units after a's preceding event). Another event [1 ; 1 ]:b must occur precisely at one time unit immediately after its preceding event. <p> The process behaves as Stop if it cannot engage in an alternative event (after the "expiration" of the current event). For example, an event a which has an enabling time interval of <ref> [0 ; 1 ] </ref> is written as [0 ; 1 ]:a and must occur only once in the specified time interval (between 0 and 1 time units after a's preceding event). Another event [1 ; 1 ]:b must occur precisely at one time unit immediately after its preceding event. <p> For example, an event a which has an enabling time interval of [0 ; 1 ] is written as [0 ; 1 ]:a and must occur only once in the specified time interval (between 0 and 1 time units after a's preceding event). Another event <ref> [1 ; 1 ] </ref>:b must occur precisely at one time unit immediately after its preceding event. An example process which uses event enabling intervals is 0 :? ! [1 ; 2 ]:a ! Stop. <p> That is, a given choice set at one point in time reduces to a smaller subset as time progresses. Events "expire" and are removed from the choice set. For example, assume that the original choice set (at time 0 ) is f <ref> [1 ; 1 ] </ref>:a; [2 ; 3 ):b; [4 ; 5 ]:cg. If the process does not engage in the a event at time 1 , then the choice set is reduced to f [2 ; 3 ):b; [4 ; 5 ]:cg.
Reference: [2] <author> Ed. Brinksma. </author> <title> An Introduction to LOTOS. </title> <editor> In H. Rudin and C.H. West, editors, </editor> <title> Protocol Specification, Testing, and Verification, VII. </title> <publisher> Elsevier Science Publishers B.V., </publisher> <address> Amsterdam, </address> <month> May </month> <year> 1987. </year>
Reference-contexts: Gerber, Lee and Zwarico [6] introduced a timed action operation (effectively, a time was associated with each prefix operation) to temporally separate adjacent events into their extended CSP and provided an Timed Acceptance semantics for the language. Quemada and Fernandez [10] proposed an extension to the LOTOS specification language <ref> [2] </ref> by associating an enabling interval with each event. This time interval represents the time over which a process may engage the event. There are difficulties in describing and specifying complex system timings using this type of construction (where an event timing is defined solely by its immediate predecessor). <p> Another event [1 ; 1 ]:b must occur precisely at one time unit immediately after its preceding event. An example process which uses event enabling intervals is 0 :? ! <ref> [1 ; 2 ] </ref>:a ! Stop. This is a process which will engage in a single a event only between 1 and 2 time units since it was instantiated (at time 0 ), and then break.
Reference: [3] <author> Jim Davies and Steve Schneider. </author> <title> A brief history of Timed CSP. </title> <type> Technical report, </type> <institution> Programming Research Group, Oxford University, </institution> <address> Oxford OX1 3QD UK, </address> <year> 1992. </year>
Reference-contexts: Other algebras adopt the former view, and use a temporal operation or process to provide the required interevent delay. We start, then, with the Timed CSP model first proposed by Reed and Roscoe [11], which has been subsequently modified to eliminate the system delay constant <ref> [3] </ref> so that any event timing must be explicitly described using a WAIT process.
Reference: [4] <author> D. Ferrari. </author> <title> Client requirements for real-time communication services. Internet RFC, </title> <year> 1990 </year> <month> November. 10 </month>
Reference-contexts: Besides this most abstract functionality of order preservation, a communication system may also need to provide end users with some real-time performance. For example, maximum and 1 average message delays, throughput, reliability, probability of loss of a message, and other client requirements may be important <ref> [1, 4] </ref>.
Reference: [5] <author> C.J. Fidge. </author> <title> A constraint-oriented real-time process calculus. </title> <editor> In M. Diaz and R. Groz, editors, </editor> <booktitle> Formal Description Techniques V, </booktitle> <pages> pages 363-378. </pages> <publisher> North-Holland, </publisher> <year> 1993. </year>
Reference-contexts: This paper attempts to describe a communication system with the following characteristics given by a (somewhat) naive client: * up to 128 messages in transit at any time, * message latency in the range <ref> [2 ; 5 ] </ref> time units, * message input rate set to 1 message per time unit, and * message output rate of 1 message per two time units. As these timing constraints stand, there will be problems with any implementation. <p> That is, a given choice set at one point in time reduces to a smaller subset as time progresses. Events "expire" and are removed from the choice set. For example, assume that the original choice set (at time 0 ) is f [1 ; 1 ]:a; <ref> [2 ; 3 ):b; [4 ; 5 ] </ref>:cg. If the process does not engage in the a event at time 1 , then the choice set is reduced to f [2 ; 3 ):b; [4 ; 5 ]:cg. <p> Events "expire" and are removed from the choice set. For example, assume that the original choice set (at time 0 ) is f [1 ; 1 ]:a; [2 ; 3 ):b; <ref> [4 ; 5 ] </ref>:cg. If the process does not engage in the a event at time 1 , then the choice set is reduced to f [2 ; 3 ):b; [4 ; 5 ]:cg. <p> For example, assume that the original choice set (at time 0 ) is f [1 ; 1 ]:a; <ref> [2 ; 3 ):b; [4 ; 5 ] </ref>:cg. If the process does not engage in the a event at time 1 , then the choice set is reduced to f [2 ; 3 ):b; [4 ; 5 ]:cg. If the process then does not engage in the b event, then the choice set is reduced to f [4 ; 5 ]:cg. <p> assume that the original choice set (at time 0 ) is f [1 ; 1 ]:a; [2 ; 3 ):b; <ref> [4 ; 5 ] </ref>:cg. If the process does not engage in the a event at time 1 , then the choice set is reduced to f [2 ; 3 ):b; [4 ; 5 ]:cg. If the process then does not engage in the b event, then the choice set is reduced to f [4 ; 5 ]:cg. <p> If the process does not engage in the a event at time 1 , then the choice set is reduced to f [2 ; 3 ):b; <ref> [4 ; 5 ] </ref>:cg. If the process then does not engage in the b event, then the choice set is reduced to f [4 ; 5 ]:cg. If time progresses and the process fails to engage in the c event during the specified time interval, no further choices may be made and the process behaves as Stop from that point on. This should be regarded as a mistaken construction. <p> Producing a buffer which delays each message by the required delay is straightforward in this model: SPB = X * in?x ! WAIT I ; out!x ! X (2) with the interval I = <ref> [2 ; 5 ] </ref>. This buffer accepts an input, then delays by an amount taken from the interval I , and then outputs the message. Notice that there is an asymmetry in this process. <p> The transit delay constraint may be met by introducing a another process into the parallel composition with the Buff1 process, which spaces inputs to outputs using the parallel composition: TD = in?x ! (WAIT <ref> [2 ; 5 ] </ref> ; out !x ! Stop) jjj TD (7) with the parallel composition done using an interleaving to prevent the system from deadlocking at the very first recursive call. <p> In the above case, the process behaviour is determined by the time at which the first event occurs, and so recording this time in some manner is important in the "serialisation" of the system. This is identified both by Schneider [12] and Fidge <ref> [5] </ref>. Schneider proposes a new operator to do this, and creates a pre-normal form for a Timed CSP language.
Reference: [6] <author> R. Gerber, I. Lee, and A. Zwarico. </author> <title> A complete axiomatization of real-time processes. </title> <type> Technical Report MS-CIS-88-88, </type> <institution> Dept. of Computer and Information Science, School of Engineering and Applied Sciences, Uni. of Pennsylvania PA 19104, </institution> <month> November </month> <year> 1988. </year>
Reference-contexts: At approximately the same time, Reed and Roscoe [11] introduced a similar special process WAIT into CSP and provided a complete semantics (based on Timed Failures) for their Timed CSP language. Gerber, Lee and Zwarico <ref> [6] </ref> introduced a timed action operation (effectively, a time was associated with each prefix operation) to temporally separate adjacent events into their extended CSP and provided an Timed Acceptance semantics for the language.
Reference: [7] <author> C.A.R. Hoare. </author> <title> Communicating Sequential Processes. </title> <booktitle> International Series in Computer Science. </booktitle> <publisher> Prentice-Hall International (UK) Ltd, </publisher> <address> 66 Wood Lane End, Hemel Hempstead, Hertfordshire HP2 4RG UK, </address> <year> 1985. </year>
Reference-contexts: 1 Introduction There has been considerable effort recently in extending Hoare's CSP <ref> [7] </ref> and Milner's CCS [8, 9] to allow formal reasoning about real-time systems. <p> Eventually all of these conditions cannot be simultaneously satisfied, and the system fails (in some manner). 3 A brief description of the extensions The CSP+T syntax is a superset of the basic untimed deterministic CSP syntax presented by Hoare <ref> [7] </ref>. <p> Instead, we use a finite size buffer as a starting point. The buffer presented (Buff0 ) is based on the infinite buffer of example X9 in <ref> [7, p138] </ref>. 1 Buff0 b= W hi where W hi = in?x ! W hxi then else out!S 0 ! W S 0 fi This buffer, like any other implementation, must resolve what actions to take under "error" conditions such as the buffer filling or messages arriving at the incorrect rate.
Reference: [8] <author> R. Milner. </author> <title> A Calculus of Communicating Systems, </title> <booktitle> volume 92 of Lecture Notes in Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <address> Berlin-Heidelberg-New York, </address> <year> 1980. </year>
Reference-contexts: 1 Introduction There has been considerable effort recently in extending Hoare's CSP [7] and Milner's CCS <ref> [8, 9] </ref> to allow formal reasoning about real-time systems. Examples of such systems are commonly found in communication protocols where the response to a message is required before the message becomes obsolete, or where message outputs need to be spaced so as to avoid overflow conditions at the receiving end.
Reference: [9] <author> Robin Milner. </author> <title> Communication and Concurrency. </title> <booktitle> International Series in Computer Science. </booktitle> <publisher> Prentice-Hall International (UK) Ltd, </publisher> <address> 66 Wood Lane End, Hemel Hempstead, Hertford-shire HP2 4RG UK, </address> <year> 1989. </year>
Reference-contexts: 1 Introduction There has been considerable effort recently in extending Hoare's CSP [7] and Milner's CCS <ref> [8, 9] </ref> to allow formal reasoning about real-time systems. Examples of such systems are commonly found in communication protocols where the response to a message is required before the message becomes obsolete, or where message outputs need to be spaced so as to avoid overflow conditions at the receiving end.
Reference: [10] <author> Juan Quemada and Angel Fernandez. </author> <title> Introduction of quantitative relative time into LO-TOS. </title> <editor> In H. Rudin and C.H. West, editors, </editor> <title> Protocol Specification, Testing, and Verification, </title> <booktitle> VII, </booktitle> <pages> pages 105-121. </pages> <publisher> Elsevier Science Publishers B.V., </publisher> <year> 1987. </year>
Reference-contexts: Gerber, Lee and Zwarico [6] introduced a timed action operation (effectively, a time was associated with each prefix operation) to temporally separate adjacent events into their extended CSP and provided an Timed Acceptance semantics for the language. Quemada and Fernandez <ref> [10] </ref> proposed an extension to the LOTOS specification language [2] by associating an enabling interval with each event. This time interval represents the time over which a process may engage the event.
Reference: [11] <author> G.M. Reed and A.W. Roscoe. </author> <title> A Timed Model for Communicating Sequential Processes. </title> <booktitle> In Automata, Languages, and Programming , 13th Intl. Colloqium Proceedings, Lecture Notes in Computer Science, </booktitle> <address> Berlin-Heidelberg-New York, 1986. </address> <publisher> Springer-Verlag. </publisher>
Reference-contexts: The author proposed some informal time (and probability) extensions to CSP in [13] where a special DELAY process allowed temporal separation between any two successive events. At approximately the same time, Reed and Roscoe <ref> [11] </ref> introduced a similar special process WAIT into CSP and provided a complete semantics (based on Timed Failures) for their Timed CSP language. <p> Other algebras adopt the former view, and use a temporal operation or process to provide the required interevent delay. We start, then, with the Timed CSP model first proposed by Reed and Roscoe <ref> [11] </ref>, which has been subsequently modified to eliminate the system delay constant [3] so that any event timing must be explicitly described using a WAIT process.
Reference: [12] <author> Steve Schneider. </author> <title> Unbounded Nondeterminism for Real-Time Processes. </title> <type> Technical Report TR-12, </type> <institution> Programming Research Group, Oxford University, </institution> <address> UK, 8-11 Keble Rd Oxford OX1 3QD, </address> <month> July </month> <year> 1992. </year>
Reference-contexts: In the above case, the process behaviour is determined by the time at which the first event occurs, and so recording this time in some manner is important in the "serialisation" of the system. This is identified both by Schneider <ref> [12] </ref> and Fidge [5]. Schneider proposes a new operator to do this, and creates a pre-normal form for a Timed CSP language.
Reference: [13] <author> J.J. Zic. </author> <title> A New Communication Protocol Specification and Analysis Technique. </title> <type> Technical Report TR287, </type> <institution> Basser Department of Computer Science, </institution> <month> July </month> <year> 1986. </year>
Reference-contexts: The author proposed some informal time (and probability) extensions to CSP in <ref> [13] </ref> where a special DELAY process allowed temporal separation between any two successive events. At approximately the same time, Reed and Roscoe [11] introduced a similar special process WAIT into CSP and provided a complete semantics (based on Timed Failures) for their Timed CSP language.
Reference: [14] <author> John J. Zic. CSP+T: </author> <title> a formalism for describing real-time systems. </title> <type> PhD thesis, </type> <institution> Basser Department of Computer Science, University of Sydney, NSW 2006, </institution> <month> July </month> <year> 1991. </year> <month> 11 </month>
Reference-contexts: Furthermore, these events may have occurred a long time in the past execution of the process. To address these problems, the author in <ref> [14] </ref> proposed an extended CSP (called CSP+T) which associated an enabling interval with each event, and also allowed this interval to be expressed as a function of one or more marker events. It will be seen that the CSP+T approach differs fundamentally from the Timed CSP solution.
References-found: 14

