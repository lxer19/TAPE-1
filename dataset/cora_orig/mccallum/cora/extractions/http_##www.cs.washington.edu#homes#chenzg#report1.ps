URL: http://www.cs.washington.edu/homes/chenzg/report1.ps
Refering-URL: http://www.cs.washington.edu/homes/chenzg/oldindex.html
Root-URL: http://www.cs.washington.edu
Author: Robert Chen, Arvind Jain, and AnHai Doan 
Note: CSE 551  
Abstract: Flexible Security Schemes for Java Application Project Report 
Abstract-found: 1
Intro-found: 1
Reference: [1] <institution> JavaSoft Corporation. </institution> <note> http://www.javasoft.com. </note>
Reference-contexts: 1 Introduction The recent introduction of the Java language from Sun Microsystems Inc. <ref> [1] </ref> has made the widespread distribution of platform-independent software possible. However, there are still many Java-related issues that remain to be discussed and settled before Java can become a truly useful platform-independent language. One such crucial issue is the security of Java computing. <p> However, there are still many Java-related issues that remain to be discussed and settled before Java can become a truly useful platform-independent language. One such crucial issue is the security of Java computing. Until recently, Java security model as exemplified in Java Development Kit 1.0.2 (JDK 1.0.2) <ref> [1] </ref> represents extremes. In this model, if the Java application resides on the local machine, then it will be executed using the null security environment, meaning it is allowed to do anything the user can do on the machine. <p> We compare and contrast these models with ours. 6.1 The JDK 1.1.1 Java Security Model In JDK 1.1.1 just shipped by JavaSoft Corp. <ref> [1] </ref>, the sandbox security model has been relaxed for Java applets downloaded from remote sites. Applets now can be signed, and signed applets, once downloaded and properly authenticated, can be declared trusted, and run with the same resource-access priviledges as trusted codes. <p> In particular, JavaSoft plans to provide fuller support for key management, certificate management, and access control, as well as mechanisms to support the uniform treatment of application and applets <ref> [1] </ref>. 6.2 Other Proposed Java Security Models Along with JavaSoft's efforts, a number of flexible Java security models have also been proposed by the academic community. <p> count = dis.read (sigfl,0, 100); - catch (IOException e)- - System.out.println (count); return count; - public void load (String arg1, String arg2)- Class newclass = null; user_name = arg1; class_name = arg2; FileInputStream fin; sigfile = loadSig (user_name+"/"+class_name+".sign"); siglen = readSig (user_name, sigfile, j); drawpanel.addlines (data [0], readvector); drawpanel.addlines (data <ref> [1] </ref>, writevector); drawpanel.addlines (data [2], connectvector); drawpanel.addlines (data [3], listenvector); drawpanel.addlines (data [4], acceptvector); drawpanel.addlines (data [5], systemvector); drawpanel.addlines (data [6], deletevector); drawpanel.addlines (data [7], loadvector); drawpanel.addlines (data [8], linkvector); drawpanel.addlines (data [9], packagevector); drawpanel.addlines (data [10], null); drawpanel.addlines (data [11], null); 49 drawpanel.show (); OkDialog okdialog = new OkDialog (parent, <p> (); OkDialog okdialog = new OkDialog (parent, this); okdialog.show (); - public void writeACL ()- int i, length; if (!readvector.isEmpty ())- length = readvector.size (); for (i=0; i&lt;length; i++) AccessList.write (data [0], (String)readvector.elementAt (i), 0, user_name); - if (!writevector.isEmpty ())- length = writevector.size (); for (i=0; i&lt;length; i++) AccessList.write (data <ref> [1] </ref>, (String)writevector.elementAt (i), 0, user_name); - if (!connectvector.isEmpty ())- length = connectvector.size (); for (i=0; i&lt;length; i++) AccessList.write (data [2], (String)connectvector.elementAt (i), 0, user_name); - if (!listenvector.isEmpty ())- length = listenvector.size (); for (i=0; i&lt;length; i++) AccessList.write (data [3], (String)listenvector.elementAt (i), 0, user_name); - if (!acceptvector.isEmpty ())- length = acceptvector.size ();
Reference: [2] <author> D. Dean D. Wallach, D. Balfanz and E. Felten. </author> <title> Extensible security architectures for java. 1997. </title> <type> Technical Report 546-97, </type> <institution> Department of Computer Science, Princeton University. </institution> <month> 59 </month>
Reference-contexts: We have checked out a number of such proposals and found the one by Wallach and his colleguages at the Princeton University to be most interesting. In their proposal <ref> [2] </ref>, Wallach requires the use of digital signature so that codes can be associated with principals. Different security policies then can be enforced based on the principals of the code being executed. Wallach proposes three strategies for implementing principal-based security policy: capabilities, extended stack introspection, and type hiding. <p> Different security policies then can be enforced based on the principals of the code being executed. Wallach proposes three strategies for implementing principal-based security policy: capabilities, extended stack introspection, and type hiding. Detailed description of these strategies can be found in <ref> [2] </ref>. <p> We believe that this is the correct and comprehensive security model that Java should use. Unfortunately, implementing any of the Wallach protocol requires a substantial amount of coding and human efforts that is clearly not available for a class project (see <ref> [2] </ref>). So we decided on the current protocols that we have implemented. <p> 100); - catch (IOException e)- - System.out.println (count); return count; - public void load (String arg1, String arg2)- Class newclass = null; user_name = arg1; class_name = arg2; FileInputStream fin; sigfile = loadSig (user_name+"/"+class_name+".sign"); siglen = readSig (user_name, sigfile, j); drawpanel.addlines (data [0], readvector); drawpanel.addlines (data [1], writevector); drawpanel.addlines (data <ref> [2] </ref>, connectvector); drawpanel.addlines (data [3], listenvector); drawpanel.addlines (data [4], acceptvector); drawpanel.addlines (data [5], systemvector); drawpanel.addlines (data [6], deletevector); drawpanel.addlines (data [7], loadvector); drawpanel.addlines (data [8], linkvector); drawpanel.addlines (data [9], packagevector); drawpanel.addlines (data [10], null); drawpanel.addlines (data [11], null); 49 drawpanel.show (); OkDialog okdialog = new OkDialog (parent, this); okdialog.show (); - <p> (!readvector.isEmpty ())- length = readvector.size (); for (i=0; i&lt;length; i++) AccessList.write (data [0], (String)readvector.elementAt (i), 0, user_name); - if (!writevector.isEmpty ())- length = writevector.size (); for (i=0; i&lt;length; i++) AccessList.write (data [1], (String)writevector.elementAt (i), 0, user_name); - if (!connectvector.isEmpty ())- length = connectvector.size (); for (i=0; i&lt;length; i++) AccessList.write (data <ref> [2] </ref>, (String)connectvector.elementAt (i), 0, user_name); - if (!listenvector.isEmpty ())- length = listenvector.size (); for (i=0; i&lt;length; i++) AccessList.write (data [3], (String)listenvector.elementAt (i), 0, user_name); - if (!acceptvector.isEmpty ())- length = acceptvector.size (); for (i=0; i&lt;length; i++) AccessList.write (data [4], (String)acceptvector.elementAt (i), 0, user_name); - if (!systemvector.isEmpty ())- length = systemvector.size ();
References-found: 2

