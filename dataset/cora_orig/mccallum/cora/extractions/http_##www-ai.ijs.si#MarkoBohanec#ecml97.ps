URL: http://www-ai.ijs.si/MarkoBohanec/ecml97.ps
Refering-URL: http://www-ai.ijs.si/MarkoBohanec/hmodres.html
Root-URL: 
Email: fjanez.demsar, ivan.bratkog@fri.uni-lj.si  fblaz.zupan, marko.bohanecg@ijs.si  
Phone: 2  
Title: Constructing Intermediate Concepts by Decomposition of Real Functions  
Author: Janez Demsar Blaz Zupan Marko Bohanec Ivan Bratko ; 
Address: 1000 Ljubljana, Slovenia  1000 Ljubljana, Slovenia  
Affiliation: 1 Faculty of Computer and Information Sciences,  Jozef Stefan Institute,  
Abstract: In learning from examples it is often useful to expand an attribute-vector representation by intermediate concepts. The usual advantage of such structuring of the learning problem is that it makes the learning easier and improves the comprehensibility of induced descriptions. In this paper, we develop a technique for discovering useful intermediate concepts when both the class and the attributes are real-valued. The technique is based on a decomposition method originally developed for the design of switching circuits and recently extended to handle incompletely specified multi-valued functions. It was also applied to machine learning tasks. In this paper, we introduce modifications, needed to decompose real functions and to present them in symbolic form. The method is evaluated on a number of test functions. The results show that the method correctly decomposes fairly complex functions. The decomposition hierarchy does not depend on a given repertoir of basic functions (background knowledge). 
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> R. L. </author> <title> Ashenhurst (1952): The Decomposition of Switching Functions, </title> <type> Technical report, </type> <institution> Bell Laboratories BL-1(11), </institution> <month> 541-602 </month>
Reference-contexts: The output of the algorithm is a decomposition tree or, generally, a directed acyclic graph with input variables as leaves and subfunctions as internal nodes. A decomposition algorithm was originally developed in late 1940's and 1950's by Ashenhurst <ref> [1] </ref> and Curtis [2] to be used for decomposition of boolean functions in switching circuits design. However, the method was rarely used in practice, mostly because of its computational intractability. Much later, the interest in the algorithm has been renewed. <p> Function f (x; y; z) = 2:5xy + 0:5z: Candidates for intermediate function 2 when decomposing by B = fxy; zg f (x; y) = xy. The ordinary product xy with x; y 2 <ref> [0; 1] </ref> is an example of a function where discretization almost causes the wrong decomposition due to the similarity of functions, as shown in Table 4. function r g xy 0.9712 x 0:91 sin (y) 0.9701 . . . Table 4.
Reference: 2. <author> H. A. </author> <title> Curtis (1962): Design of Switching Circuits, </title> <address> D. </address> <publisher> Van Nostrand Company </publisher>
Reference-contexts: The output of the algorithm is a decomposition tree or, generally, a directed acyclic graph with input variables as leaves and subfunctions as internal nodes. A decomposition algorithm was originally developed in late 1940's and 1950's by Ashenhurst [1] and Curtis <ref> [2] </ref> to be used for decomposition of boolean functions in switching circuits design. However, the method was rarely used in practice, mostly because of its computational intractability. Much later, the interest in the algorithm has been renewed. <p> Then, it focuses on the changes of this algorithm that are needed to perform the decomposition of real function. 2.1 The Basic Decomposition Algorithm The input for algorithms that are based on Curtis' function decomposition algorithm <ref> [2] </ref> is a function f (X), "sampled" in a finite number of points, where X is an argument vector. The function is presented as a table of attribute-value vectors, each consisting of values of input variables x k and a function value z k = f (x k ).
Reference: 3. <author> V. </author> <month> Krizman </month> <year> (1993): </year> <title> Noise handling in dynamic system modelling Master thesis (in Slovene), </title> <institution> University Ljubljana, Faculty of Computer and Information Science </institution>
Reference-contexts: The function g is from the same set of basic functions as mentioned above. For each function, a and n are found by the classical least-squares method and the difference between f (x) and ag (F (x)) + n is measured by corrected relative error <ref> [3] </ref>. The most accurate function is added to the decomposition tree as the root's parent. Discarding invalid contour strips. Besides the noise in the data, the algorithm also encounters the noise caused by discretization of variables and granulation of function value. <p> This result shows the main advantage of this method in comparison with some existing methods of function discovery, such as GoldHorn <ref> [3] </ref>, which performs an exhaustive search over the space of functions it can represent. <p> On the other hand, the accuracy of constants appearing in the symbolic representation is low due to the discrete nature of the method. However, as described in <ref> [3] </ref>, the accuracy can be further improved by the simplex method. <p> We are currently investigating a promising method that decomposes such functions by using splits with one bound variable. In comparison with some existing methods for function discovery, for example GoldHorn <ref> [3] </ref>, we can conclude that our method is able to reconstruct relatively complex functions but with low accuracy of coefficients, while GoldHorn offers high accuracy on functions of limited complexity.
Reference: 4. <author> T. </author> <month> Luba </month> <year> (1995): </year> <title> Decomposition of Multiple-valued Functions, </title> <booktitle> 25th Intl. Symposium on Multiple-valued Logic, </booktitle> <pages> 256-261, </pages> <address> Bloomington, Indiana. </address>
Reference-contexts: However, the method was rarely used in practice, mostly because of its computational intractability. Much later, the interest in the algorithm has been renewed. Perkowski et al. [5] improved the original algorithm to handle incompletely specified functions, and Luba <ref> [4] </ref> proposed to decompose multi-valued functions by representing a multi-valued variable by a set of Boolean variables. Zupan and Bohanec [7] developed an algorithm that induces a hierarchy of multi-valued variables without the need to represent them as Boolean.
Reference: 5. <author> M. A. Perkowski et al. </author> <year> (1996): </year> <title> Unified Approach to Functional Decomposition of Switching Functions, </title> <type> Unpublished technical report, </type> <institution> Wright Laboratory WL/AART-2, Ohio </institution>
Reference-contexts: However, the method was rarely used in practice, mostly because of its computational intractability. Much later, the interest in the algorithm has been renewed. Perkowski et al. <ref> [5] </ref> improved the original algorithm to handle incompletely specified functions, and Luba [4] proposed to decompose multi-valued functions by representing a multi-valued variable by a set of Boolean variables. <p> The basic step is then recursively repeated on functions F and . The partition can be selected using heuristic methods <ref> [5] </ref>. Alternative approach is to investigate all possible partitions and choose the one that induces the best functions and F according to some criterion. <p> After the first step of the decomposition is made, 1 is introduced that directly depends on x and y and has values between 0 and 100, so 2:5 1 2 [0; 250]. The other remaining variable z is between 0 and 10, 0:5z 2 <ref> [0; 5] </ref>, hence it is negligible in comparison with 1 . If both variables are discretized using the same number of intervals, the algorithm discovers functions like 0:001z + 1 and the measure of quality r g is very low (&lt; 0:07). <p> The method presented in this paper fails to give any meaningful result. However, the methods to support such decompositions do exist for Boolean and multi-valued functions <ref> [5, 7] </ref>. We are working on extension of these methods to handle real-valued functions as well.
Reference: 6. <author> T. D. Ross et al. </author> <year> (1994): </year> <title> On the Decomposition of Real-valued Functions, </title> <booktitle> 3rd International Workshop of Post-Binary VLSI Systems </booktitle>
Reference-contexts: Also, their work shows that the algorithm is applicable in fairly complex machine learning tasks. Not much work has been done to extend the algorithm to decomposition of real-valued functions. Ross <ref> [6] </ref> discusses the possible use of the method for functions with real valued outputs and inputs but he does not propose any algorithm for general use. In this paper, we extended the algorithm to handle continuous variables and functions.
Reference: 7. <author> B. Zupan, M. </author> <month> Bohanec </month> <year> (1996): </year> <title> Learning Concept Hierarchies from Examples by Function Decomposition, </title> <type> Technical Report, </type> <note> J. </note> <author> Stefan Institute, </author> <title> URL ftp://ftp-e8.ijs.si/pub/reports/IJSDP-7455.ps This article was processed using the L A T E X macro package with LLNCS style </title>
Reference-contexts: Much later, the interest in the algorithm has been renewed. Perkowski et al. [5] improved the original algorithm to handle incompletely specified functions, and Luba [4] proposed to decompose multi-valued functions by representing a multi-valued variable by a set of Boolean variables. Zupan and Bohanec <ref> [7] </ref> developed an algorithm that induces a hierarchy of multi-valued variables without the need to represent them as Boolean. Also, their work shows that the algorithm is applicable in fairly complex machine learning tasks. Not much work has been done to extend the algorithm to decomposition of real-valued functions. <p> For purposes of switching circuits design, the algorithm was first used on Boolean functions. An extension of this approach to handle nominal functions with more than two different output values is presented in <ref> [7] </ref>. 2.2 Algorithm for Real-Function Decomposition The basis of our method is the decomposition algorithm described in the previous section, limited to disjunctive splits, A " B = ;, with two bound variables, jBj = 2. <p> Instead, functions and F are left in tabular form. As shown in <ref> [7] </ref>, the interpretation of a discrete function can be done manually provided that its input and output variables have only small number of possible values. <p> Thus, the discovered function is 0:98x + ln (1:09y + ln (1:02w + z)). f (x; y) = sin (x + y) . For x; y 2 <ref> [0; 7] </ref>, this function is non-injective and the program is unable to decompose it, as shown in Table 8. <p> The method presented in this paper fails to give any meaningful result. However, the methods to support such decompositions do exist for Boolean and multi-valued functions <ref> [5, 7] </ref>. We are working on extension of these methods to handle real-valued functions as well.
References-found: 7

