URL: http://theory.stanford.edu/~dabo/papers/biocircuit.ps.gz
Refering-URL: http://theory.stanford.edu/~dabo/publications.html
Root-URL: 
Email: dabo@cs.princeton.edu ctd@cs.princeton.edu rjl@cs.princeton.edu  sgallj@mbox.cesnet.cz  
Title: On The Computational Power of DNA  
Author: Dan Boneh Christopher Dunworth Richard J. Lipton Jir Sgall 
Note: Mathematical Institute, AV CR Zitna 25 115 67 Praha 1 Czech Republic  
Address: Princeton, NJ 08544  
Affiliation: Department of Computer Science Princeton University  
Abstract: We show how DNA based computers can be used to solve the satisfiability problem for boolean circuits. Furthermore, we show how DNA computers can solve optimization problems directly without first solving several decision problems. Our methods also enable random sampling of satisfying assignments.
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> L. Adleman. </author> <title> Molecular computation of solutions to combinatorial problems. </title> <journal> Science, </journal> <volume> 266 </volume> <pages> 1021-1024, </pages> <month> Nov. 11, </month> <year> 1994. </year>
Reference-contexts: 1 Introduction In the very short history of DNA (deoxyribonucleic acid) based computing there have already been a number of exciting results. First was Adleman's <ref> [1] </ref> beautiful insight that biological experiments could solve the Directed Hamiltonian Path problem (DHP). Then Lipton [12] showed how to use DNA to solve more general problems, namely to find satisfying assignments for arbitrary (directed) contact networks, which includes the important case of arbitrary boolean formulas. <p> The various parameters in the table are explained in more detail in the text. Here are some more specific comments about the results from Table 1: (1) This is the famous result of Adleman that shows that Directed Hamiltonian Path problem can be solved by a DNA based computer <ref> [1] </ref>. His method also implies the same for any NP problem via reductions. However, the difficulty with using this method for general NP problems is that it uses too many strands of DNA to be practical for large scale problems. <p> The operations that we make use of are derived from the following experiments commonly used in molecular biology today <ref> [1] </ref>. Here we present an idealized model which assumes that all the operations are error-free. It is possible to dissolve the double strands into single strands by heating the solution. This process is referred to as melting. <p> We convert them to single strands by heating as needed for other operations. Using restriction enzymes, it is possible to cut the strands at some distinctive marker. Using a gelling technique called gel-electrophoresis <ref> [1] </ref> it is possible to separate the DNA strands by length. It is possible to detect if there is a DNA strand in a test tube and to sequence a given strand (i.e., to "read" the sequence of bases of the strand). <p> Some more difficult experiments are described below. 3.1.1 Extract We need the ability to extract from a test tube all strands that contain any specific short nucleotide sequence. To accomplish this we use the method of biotin-avidin affinity purification as described in <ref> [1] </ref>. This technique works in the following way. If we want to extract all strands containing the sequence " x, then we first create many copies of its complementary oligo (a short DNA strand), namely # x. <p> To initialize our algorithms, we create a test tube of DNA strands representing all 2 n binary strings of length n. This is done by forming all paths in the graph of Figure 1 using the method of Adleman <ref> [1] </ref>. <p> This is done by forming all paths in the graph of Figure 1 using the method of Adleman <ref> [1] </ref>. The length of the DNA strand representing an assignment with m 1's is 20 (2n + 1) + 10m. <p> We apply the algorithm from Theorem 4.1 to obtain a tube containing DNA strands representing all the satisfying assignments. (For MAX-CNF-Satisfiability we use Lipton's algorithm from [12].) We now use the gelling technique described in <ref> [1] </ref> to separate the DNA strands by length. The longest DNA strand corresponds to a maximal satisfying assignment. 2 10 The simplicity of this algorithm is perhaps best seen on the example of the MAX-Clique problem.
Reference: [2] <author> L. Adleman. </author> <title> On constructing a molecular computer. </title> <booktitle> In proceedings of the first DIMACS workshop on DNA computing. </booktitle>
Reference-contexts: It follows that the frequency of every satisfying assignment in the final test tube is the same. Using a method described by Adleman <ref> [2] </ref> one can pick a random DNA strand from the test tube and read from it a satisfying assignment (this can also be done using cloning techniques). Hence one can perform random sampling on the set of satisfying assignments.
Reference: [3] <author> M. Amos, A. Gibbons and D Hodgson. </author> <title> Error-resistant Implementation of DNA Computations. </title> <type> Unpublished manuscript. </type>
Reference-contexts: For the sake of completeness we note that several researchers have already begun to take steps to make DNA algorithms more noise tolerant <ref> [8, 10, 3] </ref>. 2 Comparison of several DNA computing results Table 1 describes the results on simulation of various classical computational models using DNA computation. <p> We also showed that the algorithm can be extended to perform approximate counting. There are still many issues to be considered. Foremost is the issue of errors. DNA molecules are known to be fragile, they break easily. Steps towards coping with errors were taken in <ref> [8, 9, 10, 3] </ref>. It is essential to obtain a better understanding of the type of errors which may occur and to come up with further techniques for error recovery.
Reference: [4] <author> E. Bach, A. Condon, E. Glaser and C. Tanguay. </author> <title> DNA Models and Algorithms for NP-Complete Problems. </title> <booktitle> Proceedings of the 11th Annual IEEE Conference on Computational Complexity, </booktitle> <year> 1996. </year>
Reference-contexts: For example, for the MAX-Clique problem, there are algorithms achieving running time of about 2 n=3 [20, 17], and these will be preferable to the approach presented here which needs 2 n strands of DNA. The methods presented in this paper can be combined with results of <ref> [4] </ref> to produce more efficient DNA algorithms for solving the MAX-Clique problem. In general, DNA algorithms work for any problem, and hence may be favorable for problems where no algorithms significantly faster than 2 n are known. <p> At the end of the process we separate the DNA strands by length. The longest DNA strand corresponds to a maximal clique in G. This process requires only n 2 jEj biological steps. We note that recently <ref> [4] </ref> showed that these techniques combined with a more clever combinatorial algorithm can be used to solve MAX-Clique and 3-Coloring more efficiently, i.e. using less than 2 n strands for a graph with n vertices. 4.3 Regular-Circuit-Satisfiability: using state automata As was explained in the introduction, molecular computers can be thought
Reference: [5] <author> D. Beaver. </author> <title> A universal molecular computer. </title> <type> Technical Report CSE-95-001, </type> <institution> Penn State University, </institution> <year> 1995. </year>
Reference-contexts: We feel that, therefore, this result is not of great practical importance. The result was discovered by several authors using various significantly different constructions. See for example Beaver <ref> [5] </ref>, Papadimitriou [13], Rothemund [16], Smith and Schweitzer [18], Roo and Wagner [15]. (7): This is a construction due to Winfree [21] which shows how complicated DNA patterns can be used to simulate cellular automata. <p> The attractive feature of this model is that computations are done in vitro. Unlike other models, no intervention of a lab technician is required. (8): This is the result of Beaver <ref> [5] </ref>, Reif [14] and Papadimitriou [13] that it is possible to simulate PSPACE with DNA operations; S denotes the space needed. This, too, is mainly a theoretical result. The problem is that these methods use biological operations that are likely to be impossible to implement in practice. <p> The algorithm presented is considerably more efficient than simulating a NTM using DNA as was suggested by <ref> [5, 15, 16, 18] </ref>. Furthermore we showed how to improve the performance of the algorithm by using state automata. For optimization problems such as MAX-Clique we showed a technique for solving the problem directly without first solving several decision problems.
Reference: [6] <author> D. Boneh, C. Dunworth, and R. J. Lipton. </author> <title> Breaking DES using a molecular computer. </title> <type> Technical Report CS-TR-489-95, </type> <institution> Princeton University, </institution> <year> 1995. </year> <note> Also in Proceedings of first DIMACS workshop on DNA computing. </note>
Reference-contexts: We discuss the different operations later in this section. We also do not account for the possibility of executing some of the operations in parallel, 2 which would add additional dimension to the classification; we should note however that this is important in the mentioned DES result <ref> [6] </ref>. A further description of each entry is given below. <p> In general, DNA algorithms work for any problem, and hence may be favorable for problems where no algorithms significantly faster than 2 n are known. An interesting example of an application where the use of DNA may be favorable to classical algorithms is the method for breaking DES <ref> [6] </ref>. To make these results practically applicable, it would be necessary to perform large-scale experiments to verify whether it is possible to perform the needed operations on such a scale as needed here, and give estimates of how long these operations will take. <p> Two strands of DNA can form (under appropriate conditions) a double strand, if the respective bases are Watson-Crick complements of each other A matches T and C matches G; also 3' end matches 5' end. (For more discussion of the relevant biological background and the model see e.g. <ref> [6] </ref>.) We use a simple notation to explain the various operations to be performed on DNA.
Reference: [7] <author> D. Boneh, C. Dunworth, R. J. Lipton, and J. Sgall. </author> <title> On the computational power of DNA. </title> <type> Technical Report CS-TR-499-95, </type> <institution> Princeton University, </institution> <year> 1995. </year>
Reference-contexts: Unfortunately, like (9) it requires the manipulation of DNA in ways which is unlikely to work in practice. It appeared in the previous version of this paper <ref> [7] </ref>, but we omit it in the current version because of our doubts about its practical relevance. Next we compare the results based on the operations that they use.
Reference: [8] <author> D. Boneh and R. J. Lipton. </author> <title> Making DNA computers error resistant. </title> <type> Technical Report CS-TR-491-95, </type> <institution> Princeton University, </institution> <year> 1995. </year>
Reference-contexts: For the sake of completeness we note that several researchers have already begun to take steps to make DNA algorithms more noise tolerant <ref> [8, 10, 3] </ref>. 2 Comparison of several DNA computing results Table 1 describes the results on simulation of various classical computational models using DNA computation. <p> We also showed that the algorithm can be extended to perform approximate counting. There are still many issues to be considered. Foremost is the issue of errors. DNA molecules are known to be fragile, they break easily. Steps towards coping with errors were taken in <ref> [8, 9, 10, 3] </ref>. It is essential to obtain a better understanding of the type of errors which may occur and to come up with further techniques for error recovery. <p> The classification according to the volume and uniformity turns out to be very important in the context of resistance to errors decreasing volume and uniform algorithms are significantly better than others in this respect, whereas mixed volume and nonuniform algorithms are hard to deal with, see <ref> [8, 9] </ref> for a discussion of this topic. All our algorithms are very good in this respect, since they are all uniform and constant volume.
Reference: [9] <author> D. Boneh, R. J. Lipton, and J. Sgall. </author> <title> Error resistant and uniform DNA computers. </title> <note> In preparation. </note>
Reference-contexts: We also showed that the algorithm can be extended to perform approximate counting. There are still many issues to be considered. Foremost is the issue of errors. DNA molecules are known to be fragile, they break easily. Steps towards coping with errors were taken in <ref> [8, 9, 10, 3] </ref>. It is essential to obtain a better understanding of the type of errors which may occur and to come up with further techniques for error recovery. <p> Let us point out that our algorithms seem to be more feasible and resistant to certain kind of errors than most of the previous ones. In <ref> [9] </ref> the algorithms are classified in two ways. First, the algorithms are classified according to how the volume changes during the computation. <p> The classification according to the volume and uniformity turns out to be very important in the context of resistance to errors decreasing volume and uniform algorithms are significantly better than others in this respect, whereas mixed volume and nonuniform algorithms are hard to deal with, see <ref> [8, 9] </ref> for a discussion of this topic. All our algorithms are very good in this respect, since they are all uniform and constant volume.
Reference: [10] <author> R. Karp, C. Kenyon, O. Waarts. </author> <title> Error-resilient DNA computations. </title> <booktitle> In Proceedings of SODA 1996, </booktitle> <pages> pp. 458-467. </pages>
Reference-contexts: For the sake of completeness we note that several researchers have already begun to take steps to make DNA algorithms more noise tolerant <ref> [8, 10, 3] </ref>. 2 Comparison of several DNA computing results Table 1 describes the results on simulation of various classical computational models using DNA computation. <p> We also showed that the algorithm can be extended to perform approximate counting. There are still many issues to be considered. Foremost is the issue of errors. DNA molecules are known to be fragile, they break easily. Steps towards coping with errors were taken in <ref> [8, 9, 10, 3] </ref>. It is essential to obtain a better understanding of the type of errors which may occur and to come up with further techniques for error recovery.
Reference: [11] <author> R. Kannan. </author> <title> Markov chains and polynomial time algorithms. </title> <booktitle> In Proceedings of the 35th Annual Symposium on Foundations of Computer Science, </booktitle> <pages> pages 656-671. </pages> <publisher> IEEE, </publisher> <year> 1994. </year>
Reference-contexts: While for some problems approximate counting is known to be in random polynomial time (mostly using rapidly mixing Markov chains, see e.g. <ref> [11] </ref> and references therein), in general it is only known to be in 2 " 2 .
Reference: [12] <author> R. J. Lipton. </author> <title> Using DNA to solve NP-complete problems. </title> <journal> Science, </journal> <volume> 268 </volume> <pages> 542-545, </pages> <month> Apr. 28, </month> <year> 1995. </year>
Reference-contexts: 1 Introduction In the very short history of DNA (deoxyribonucleic acid) based computing there have already been a number of exciting results. First was Adleman's [1] beautiful insight that biological experiments could solve the Directed Hamiltonian Path problem (DHP). Then Lipton <ref> [12] </ref> showed how to use DNA to solve more general problems, namely to find satisfying assignments for arbitrary (directed) contact networks, which includes the important case of arbitrary boolean formulas. Since then there has been a number of papers on DNA computation. <p> We show how to compute efficiently satisfying assignments for general boolean circuits with arbitrary binary gates. This solves one of the main open problems from <ref> [12] </ref>, where only the case of contact networks is studied. <p> Accordingly, encoding the problem via boolean circuits and using our new algorithms leaves us with 2 fi (n log n) strands, as we would encode each node of the path by log n bits. (2) This is the result of Lipton <ref> [12] </ref> that SAT (satisfiability for formulas in conjunctive normal form) and more generally contact network satisfiability (which includes general boolean formula satisfiability) can be done in time linear in the size of the network (resp. formula). <p> general class of problems, while the number of strands is only 2 n where n is the number of variables. (3): We show that using DNA we can efficiently find satisfying assignments for general boolean circuits with fan-in two (i.e. with arbitrary binary gates), which significantly improves the result from <ref> [12] </ref>. The fact that circuits are very efficient for a wide variety of problems and they are easy to design, unlike efficient Turing machines or contact networks, makes this result applicable for practical problems. <p> It appeared in the previous version of this paper [7], but we omit it in the current version because of our doubts about its practical relevance. Next we compare the results based on the operations that they use. In our model of DNA computation, as introduced by Lipton in <ref> [12] </ref> and described in more detail in Section 3, a computation 4 is just a sequence of test tubes. Each test tube contains many strands of DNA that encode certain computations. Each subsequent test tube is created from earlier ones by some biological operation. <p> We call this operation append. We note that there are alternate methods for implementing append using restriction enzymes. 3.2 Representing Binary Strings DNA strands can be used to represent binary strings as was shown in <ref> [12] </ref>. Let x = x 1 : : : x n be an n-bit binary string. The idea is to assign a unique sequence of 30 bases (a 30-mer) to each bit position and bit value. <p> Proof We start as in Lipton <ref> [12] </ref> with a test tube of DNA strands that code all 2 n possible input bit sequences x 1 : : : x n . <p> The length of the DNA strand representing an assignment with m 1's is 20 (2n + 1) + 10m. We apply the algorithm from Theorem 4.1 to obtain a tube containing DNA strands representing all the satisfying assignments. (For MAX-CNF-Satisfiability we use Lipton's algorithm from <ref> [12] </ref>.) We now use the gelling technique described in [1] to separate the DNA strands by length. The longest DNA strand corresponds to a maximal satisfying assignment. 2 10 The simplicity of this algorithm is perhaps best seen on the example of the MAX-Clique problem. <p> A typical application is the following problem: Given a graph G = (V; E) with jV j odd, find a 3-coloring of G with an even number of red vertices. The method of <ref> [12] </ref> can be used to solve this problem in the following way: first create a set of DNA strands representing all strings in fR; G; Bg jV j . This can be done using a graph similar to the one shown in Figure 1.
Reference: [13] <author> C. Papadimitriou. </author> <title> Private communications. </title> <type> 14 </type>
Reference-contexts: We feel that, therefore, this result is not of great practical importance. The result was discovered by several authors using various significantly different constructions. See for example Beaver [5], Papadimitriou <ref> [13] </ref>, Rothemund [16], Smith and Schweitzer [18], Roo and Wagner [15]. (7): This is a construction due to Winfree [21] which shows how complicated DNA patterns can be used to simulate cellular automata. <p> The attractive feature of this model is that computations are done in vitro. Unlike other models, no intervention of a lab technician is required. (8): This is the result of Beaver [5], Reif [14] and Papadimitriou <ref> [13] </ref> that it is possible to simulate PSPACE with DNA operations; S denotes the space needed. This, too, is mainly a theoretical result. The problem is that these methods use biological operations that are likely to be impossible to implement in practice.
Reference: [14] <author> J. Reif. </author> <title> Parallel Molecular Computation. </title> <booktitle> In proceedings of 7th Annual ACM Symposium on Parallel Algorithms and Architectures SPAA'95, </booktitle> <year> 1995, </year> <pages> pp. 213-223. </pages>
Reference-contexts: The attractive feature of this model is that computations are done in vitro. Unlike other models, no intervention of a lab technician is required. (8): This is the result of Beaver [5], Reif <ref> [14] </ref> and Papadimitriou [13] that it is possible to simulate PSPACE with DNA operations; S denotes the space needed. This, too, is mainly a theoretical result. The problem is that these methods use biological operations that are likely to be impossible to implement in practice.
Reference: [15] <author> D. Roo and K. W. Wagner. </author> <title> On the power of bio-computers. </title> <type> Technical report, </type> <institution> University of Wurzburg, </institution> <year> 1995. </year>
Reference-contexts: We feel that, therefore, this result is not of great practical importance. The result was discovered by several authors using various significantly different constructions. See for example Beaver [5], Papadimitriou [13], Rothemund [16], Smith and Schweitzer [18], Roo and Wagner <ref> [15] </ref>. (7): This is a construction due to Winfree [21] which shows how complicated DNA patterns can be used to simulate cellular automata. <p> The algorithm presented is considerably more efficient than simulating a NTM using DNA as was suggested by <ref> [5, 15, 16, 18] </ref>. Furthermore we showed how to improve the performance of the algorithm by using state automata. For optimization problems such as MAX-Clique we showed a technique for solving the problem directly without first solving several decision problems.
Reference: [16] <author> Rothemund. </author> <title> A DNA and restriction enzyme implementation of Turing machines. </title> <note> Available at http://www.ugcs.caltech.edu/ pwkr/oett.html. </note>
Reference-contexts: We feel that, therefore, this result is not of great practical importance. The result was discovered by several authors using various significantly different constructions. See for example Beaver [5], Papadimitriou [13], Rothemund <ref> [16] </ref>, Smith and Schweitzer [18], Roo and Wagner [15]. (7): This is a construction due to Winfree [21] which shows how complicated DNA patterns can be used to simulate cellular automata. <p> The algorithm presented is considerably more efficient than simulating a NTM using DNA as was suggested by <ref> [5, 15, 16, 18] </ref>. Furthermore we showed how to improve the performance of the algorithm by using state automata. For optimization problems such as MAX-Clique we showed a technique for solving the problem directly without first solving several decision problems.
Reference: [17] <author> J. Robson. </author> <title> Algorithms for maximum independent sets. </title> <journal> J.of Algorithms, </journal> <volume> 7, </volume> <year> 1986, </year> <pages> pp. 425-440. </pages>
Reference-contexts: It depends on the particular problem whether DNA computations have a good chance to compare favorably with classical problems or not. For example, for the MAX-Clique problem, there are algorithms achieving running time of about 2 n=3 <ref> [20, 17] </ref>, and these will be preferable to the approach presented here which needs 2 n strands of DNA. The methods presented in this paper can be combined with results of [4] to produce more efficient DNA algorithms for solving the MAX-Clique problem.
Reference: [18] <author> W. Smith and A. Schweitzer. </author> <title> DNA computers in vitro and vivo. </title> <type> Technical report, </type> <institution> NEC, </institution> <year> 1995. </year>
Reference-contexts: We feel that, therefore, this result is not of great practical importance. The result was discovered by several authors using various significantly different constructions. See for example Beaver [5], Papadimitriou [13], Rothemund [16], Smith and Schweitzer <ref> [18] </ref>, Roo and Wagner [15]. (7): This is a construction due to Winfree [21] which shows how complicated DNA patterns can be used to simulate cellular automata. <p> The algorithm presented is considerably more efficient than simulating a NTM using DNA as was suggested by <ref> [5, 15, 16, 18] </ref>. Furthermore we showed how to improve the performance of the algorithm by using state automata. For optimization problems such as MAX-Clique we showed a technique for solving the problem directly without first solving several decision problems.
Reference: [19] <author> L. Stockmeyer. </author> <title> On Approximating Algorithms for #P. </title> <journal> SIAM J. on Computing, </journal> <volume> 14, </volume> <year> 1985, </year> <pages> pp. 849-861. </pages>
Reference-contexts: Hence one can perform random sampling on the set of satisfying assignments. Once we can do random sampling of satisfying assignments, it is well-known we can also approximately count their number using polynomial number of samples <ref> [19] </ref>. Note that we do not need to repeat the whole procedure to obtain another sample|rather we can take many samples from the single last test tube, amplifying it first if necessary.
Reference: [20] <author> R. Tarjan and A. Trojanowsky. </author> <title> Finding a maximum independent set. </title> <journal> SIAM J. on Computing 6, </journal> <year> 1977, </year> <pages> pp. 537-546. </pages>
Reference-contexts: It depends on the particular problem whether DNA computations have a good chance to compare favorably with classical problems or not. For example, for the MAX-Clique problem, there are algorithms achieving running time of about 2 n=3 <ref> [20, 17] </ref>, and these will be preferable to the approach presented here which needs 2 n strands of DNA. The methods presented in this paper can be combined with results of [4] to produce more efficient DNA algorithms for solving the MAX-Clique problem.
Reference: [21] <author> E. Winfree. </author> <title> On the Computational Power of DNA Annealing and Ligation. </title> <note> Available at http://dope.caltech.edu/winfree/DNA.html. 15 </note>
Reference-contexts: We feel that, therefore, this result is not of great practical importance. The result was discovered by several authors using various significantly different constructions. See for example Beaver [5], Papadimitriou [13], Rothemund [16], Smith and Schweitzer [18], Roo and Wagner [15]. (7): This is a construction due to Winfree <ref> [21] </ref> which shows how complicated DNA patterns can be used to simulate cellular automata. The number of nucleotides used by the DNA pattern is proportional to the product of the space used by the automata (S) and the number of generations for which it is run (t).
References-found: 21

