URL: http://www.cs.wustl.edu/~schmidt/RTAS-98.ps.gz
Refering-URL: http://www.cs.wustl.edu/~schmidt/corba-research-realtime.html
Root-URL: 
Email: fschmidt,sumedh,sergio,gokhaleg@cs.wustl.edu  
Title: Alleviating Priority Inversion and Non-determinism in Real-time CORBA ORB Core Architectures  
Author: Douglas C. Schmidt, Sumedh Mungee, Sergio Flores-Gaitan, and Aniruddha Gokhale 
Keyword: Real-time CORBA Object Request Broker, QoS-enabled OO Middleware, Performance Measurements  
Address: St. Louis, MO 63130, USA  
Affiliation: Department of Computer Science, Washington University  
Abstract: This paper appeared in the proceedings of 4 th IEEE Real-time Technology and Applications Symposium (RTAS), Den-ver, Colorado, June 3-5, 1998. Abstract There is increasing demand to extend Object Request Broker (ORB) middleware to support distributed applications with stringent real-time requirements. However, conventional ORB implementations, such as CORBA ORBs, exhibit substantial priority inversion and non-determinism, which makes them unsuitable for applications with deterministic real-time requirements. This paper provides two contributions to the study and design of real-time ORB middleware. First, it illustrates empirically why conventional ORBs do not yet support real-time quality of service. Second, it evaluates connection and concur-rency software architectures to identify strategies that reduce priority inversion and non-determinism in real-time CORBA ORBs. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> D. C. Schmidt, D. L. Levine, and S. Mungee, </author> <title> The Design and Performance of Real-Time Object Request Brokers, </title> <journal> Computer Communications, </journal> <volume> vol. 21, </volume> <pages> pp. 294324, </pages> <month> Apr. </month> <year> 1998. </year>
Reference-contexts: It requires a vertically and horizontally integrated ORB endsystem architecture that can deliver end-to-end QoS guarantees at multiple levels throughout a distributed system. The key levels in an ORB endsystem include the network adapters, OS I/O subsystems, communication protocols, ORB middleware, and higher-level services <ref> [1] </ref>. The main focus of this paper is on software architectures that are suitable for real-time ORB Cores. <p> The avionics application manages sensors and operator displays, navigate the aircraft's course, and control weapon release. To meet the scheduling demands of real-time applications, TAO supports predictable scheduling and dispatching of periodic processing operations <ref> [1] </ref>, as well as efficient event filtering and correlation mechanisms [6]. The C++ source code for TAO and ACE is freely available at www.cs.wustl.edu/~schmidt/TAO.html. Acknowledgments We gratefully acknowledge Expersoft, IONA, and Sun for providing us with their ORB software for the benchmarking testbed.
Reference: [2] <author> S. Vinoski, </author> <title> CORBA: Integrating Diverse Applications Within Distributed Heterogeneous Environments, </title> <journal> IEEE Communications Magazine, </journal> <volume> vol. 14, </volume> <month> February </month> <year> 1997. </year>
Reference-contexts: The ORB Core also typically implements the transport endpoint demultiplexing and concurrency architecture used by applications. Figure 1 illustrates how an ORB Core interacts with other CORBA components. <ref> [2] </ref> describes each of these com ponents in more detail.
Reference: [3] <author> S. Khanna and et. al., </author> <title> Realtime Scheduling in SunOS 5.0, </title> <booktitle> in Proceedings of the USENIX Winter Conference, </booktitle> <pages> pp. 375390, </pages> <publisher> USENIX Association, </publisher> <year> 1992. </year>
Reference-contexts: One servant runs in a higher priority thread than the other. Each thread processes requests that are sent to its servant by client threads on the other UltraSPARC-2. Solaris real-time threads <ref> [3] </ref> are used to implement servant priorities. The high-priority servant thread has the highest real-time priority available on Solaris and the low-priority servant has the lowest real-time priority. <p> Moreover, priority inversion is exacerbated if multiple thread with multiple levels of thread priorities share common locks. For instance, medium priority threads can preempt a low priority thread that is holding a lock required by a high priority thread, which can lead to unbounded priority inversion <ref> [3] </ref>. We recommend that real-time ORBs should allow application developers to determine whether requests with different priorities are multiplexed over shared connections. Currently, neither miniCOOL, CORBAplus, nor MT-Orbix support this level of control, though TAO provides this model by default. 3.
Reference: [4] <author> D. C. Schmidt, R. Bector, D. Levine, S. Mungee, and G. Parulkar, </author> <title> An ORB Endsystem Architecture for Statically Scheduled Real-time Applications, </title> <booktitle> in Proceedings of the Workshop on Middleware for Real-Time Systems and Services, </booktitle> <address> (San Francisco, CA), </address> <publisher> IEEE, </publisher> <month> December </month> <year> 1997. </year>
Reference-contexts: Each priority has its own queue of requests to avoid priority inversion within the queue. This inversion could otherwise occur if a high-priority servant and a low-priority servant dequeue requests from the same queue. * TAO: which uses the thread-per-priority concurrency architecture described in <ref> [4] </ref>. Version 1.0 of TAO integrates the thread-per-priority concurrency architecture with a non-multiplexed connection architecture, as shown in Figure 6. In contrast, the other three ORBs multiplex all requests from client threads in each process over a single connection to the server process. <p> Therefore, TAO's ORB Core minimizes additional user-level locking operations per-request and uses no kernel-level locks in its ORB Core. * TAO connection architecture: TAO uses a non-multiplexed connection architecture, which pre-establishes connections to servants, as described in <ref> [4] </ref>. One connection is pre-established for each priority level, thereby avoiding the non-deterministic delay involved in dynamic connection setup. In addition, different priority levels have their own connection. <p> In addition, different priority levels have their own connection. This design avoids request-level priority inversion, which would otherwise occur from FIFO queueing across client threads with different priorities. * TAO concurrency architecture: TAO supports several concurrency architectures, as described in <ref> [4] </ref>. The thread-per-priority architecture was used for the benchmarks in this paper. In this concurrency architecture, a separate thread is created for each priority level i.e., each rate group. Thus, the low-priority client issues CORBA requests at a lower rate than the high-priority client (10 Hz vs. 20 Hz, respectively).
Reference: [5] <author> P. S. Inc., </author> <title> Quantify User's Guide. </title> <institution> PureAtria Software Inc., </institution> <year> 1996. </year>
Reference-contexts: Section 2.2.1 explains the blackbox results. Whitebox benchmarks: To precisely pinpoint the source of priority inversion and performance non-determinism, we employed whitebox benchmarks. These benchmarks used profiling tools such as UNIX truss and Quantify <ref> [5] </ref>. These tools trace and log the activities of the ORBs and measure the time spent on various tasks, as explained in Section 2.2.2. Together, the blackbox and whitebox benchmarks indicate the end-to-end latency/jitter incurred by CORBA clients and help explain the reason for these results.
Reference: [6] <author> T. H. Harrison, D. L. Levine, and D. C. Schmidt, </author> <title> The Design and Performance of a Real-time CORBA Event Service, </title> <booktitle> in Proceedings of OOPSLA '97, </booktitle> <address> (Atlanta, GA), </address> <publisher> ACM, </publisher> <month> October </month> <year> 1997. </year>
Reference-contexts: Nine clients were low-priority and one was high-priority. Each client sent 4,000 twoway requests to the server, which had a low-priority servant and high-priority servant thread. Our previous experience using CORBA for real-time avion-ics mission computing <ref> [6] </ref> indicated that locks constitute a significant source of overhead, non-determinism and potential priority inversion for real-time ORBs. Using Quantify and truss, we measured the time the ORBs consumed performing tasks like synchronization, I/O, and protocol processing. <p> The architectural principles used in TAO can be applied to other ORBs and other real-time software systems. TAO has been used to develop a number of real-time applications, including a real-time audio/video streaming service [17] and a real-time ORB endsystem for avionics mission computing <ref> [6] </ref>. The avionics application manages sensors and operator displays, navigate the aircraft's course, and control weapon release. To meet the scheduling demands of real-time applications, TAO supports predictable scheduling and dispatching of periodic processing operations [1], as well as efficient event filtering and correlation mechanisms [6]. <p> endsystem for avionics mission computing <ref> [6] </ref>. The avionics application manages sensors and operator displays, navigate the aircraft's course, and control weapon release. To meet the scheduling demands of real-time applications, TAO supports predictable scheduling and dispatching of periodic processing operations [1], as well as efficient event filtering and correlation mechanisms [6]. The C++ source code for TAO and ACE is freely available at www.cs.wustl.edu/~schmidt/TAO.html. Acknowledgments We gratefully acknowledge Expersoft, IONA, and Sun for providing us with their ORB software for the benchmarking testbed. In addition, we would like to thank Frank Buschmann and Bil Lewis for their comments on this paper.
Reference: [7] <author> J. Eykholt, S. Kleiman, S. Barton, R. Faulkner, A. Shivalingiah, M. Smith, D. Stein, J. Voll, M. Weeks, and D. Williams, </author> <title> Beyond Multiprocessing... Multithreading the SunOS Kernel, </title> <booktitle> in Proceedings of the Summer USENIX Conference, </booktitle> <address> (San Antonio, Texas), </address> <month> June </month> <year> 1992. </year>
Reference-contexts: The number of calls per-request to kernel-level locking mechanisms at the server (shown in Figure 14) are unusually high. This overhead stems from the fact that miniCOOL uses system scoped threads on Solaris, which require kernel intervention for all synchronization operations <ref> [7] </ref>. The miniCOOL connection and concurrency architectures are outlined briefly below. * miniCOOL connection architecture: The miniCOOL ORB connection architecture uses a leader/follower model that allows the leader thread to block in select on the shared socket.
Reference: [8] <author> A. Gokhale and D. C. Schmidt, </author> <title> Evaluating the Performance of Demultiplexing Strategies for Real-time CORBA, </title> <booktitle> in Proceedings of GLOBECOM '97, </booktitle> <address> (Phoenix, AZ), </address> <publisher> IEEE, </publisher> <month> November </month> <year> 1997. </year>
Reference-contexts: In addition, the results show that priority inversion and non-determinism are significant problems in conventional ORBs. As a result, these ORBs are not currently suitable for applications with deterministic real-time requirements. Based on our results, and our prior experience <ref> [8, 9, 10, 11] </ref> measuring the performance of CORBA ORB endsystems, we suggest the following recommendations to decrease non-determinism and limit priority inversion in real-time ORB endsystems. 1. Real-time ORBs should avoid dynamic connection establishment: ORBs that establish connections dynamically suffer from high jitter. <p> Real-time ORB endsystem architectures should be guided by empirical performance benchmarks: Our prior research on pinpointing performance bottlenecks and optimizing middleware like Web servers [15, 16] and CORBA ORBs <ref> [9, 8, 11, 10] </ref> demonstrates the efficacy of a measurement-driven research methodology. We recommend that the OMG adopt standard real-time CORBA benchmark-ing techniques and metrics. These benchmarks will simplify the communication and comparison of performance results and real-time ORB behavior patterns.
Reference: [9] <author> A. Gokhale and D. C. Schmidt, </author> <title> Measuring the Performance of Communication Middleware on High-Speed Networks, </title> <booktitle> in Proceedings of SIGCOMM '96, </booktitle> <address> (Stanford, CA), </address> <pages> pp. 306317, </pages> <publisher> ACM, </publisher> <month> August </month> <year> 1996. </year>
Reference-contexts: In addition, the results show that priority inversion and non-determinism are significant problems in conventional ORBs. As a result, these ORBs are not currently suitable for applications with deterministic real-time requirements. Based on our results, and our prior experience <ref> [8, 9, 10, 11] </ref> measuring the performance of CORBA ORB endsystems, we suggest the following recommendations to decrease non-determinism and limit priority inversion in real-time ORB endsystems. 1. Real-time ORBs should avoid dynamic connection establishment: ORBs that establish connections dynamically suffer from high jitter. <p> Real-time ORB endsystem architectures should be guided by empirical performance benchmarks: Our prior research on pinpointing performance bottlenecks and optimizing middleware like Web servers [15, 16] and CORBA ORBs <ref> [9, 8, 11, 10] </ref> demonstrates the efficacy of a measurement-driven research methodology. We recommend that the OMG adopt standard real-time CORBA benchmark-ing techniques and metrics. These benchmarks will simplify the communication and comparison of performance results and real-time ORB behavior patterns.
Reference: [10] <author> A. Gokhale and D. C. Schmidt, </author> <title> The Performance of the CORBA Dynamic Invocation Interface and Dynamic Skeleton Interface over High-Speed ATM Networks, </title> <booktitle> in Proceedings of GLOBECOM '96, </booktitle> <address> (London, England), </address> <pages> pp. 5056, </pages> <publisher> IEEE, </publisher> <month> November </month> <year> 1996. </year>
Reference-contexts: In addition, the results show that priority inversion and non-determinism are significant problems in conventional ORBs. As a result, these ORBs are not currently suitable for applications with deterministic real-time requirements. Based on our results, and our prior experience <ref> [8, 9, 10, 11] </ref> measuring the performance of CORBA ORB endsystems, we suggest the following recommendations to decrease non-determinism and limit priority inversion in real-time ORB endsystems. 1. Real-time ORBs should avoid dynamic connection establishment: ORBs that establish connections dynamically suffer from high jitter. <p> Real-time ORB endsystem architectures should be guided by empirical performance benchmarks: Our prior research on pinpointing performance bottlenecks and optimizing middleware like Web servers [15, 16] and CORBA ORBs <ref> [9, 8, 11, 10] </ref> demonstrates the efficacy of a measurement-driven research methodology. We recommend that the OMG adopt standard real-time CORBA benchmark-ing techniques and metrics. These benchmarks will simplify the communication and comparison of performance results and real-time ORB behavior patterns.
Reference: [11] <author> A. Gokhale and D. C. Schmidt, </author> <title> Evaluating Latency and Scalability of CORBA Over High-Speed ATM Networks, </title> <booktitle> in Proceedings of the International Conference on Distributed Computing Systems, </booktitle> <address> (Baltimore, Maryland), </address> <publisher> IEEE, </publisher> <month> May </month> <year> 1997. </year>
Reference-contexts: In addition, the results show that priority inversion and non-determinism are significant problems in conventional ORBs. As a result, these ORBs are not currently suitable for applications with deterministic real-time requirements. Based on our results, and our prior experience <ref> [8, 9, 10, 11] </ref> measuring the performance of CORBA ORB endsystems, we suggest the following recommendations to decrease non-determinism and limit priority inversion in real-time ORB endsystems. 1. Real-time ORBs should avoid dynamic connection establishment: ORBs that establish connections dynamically suffer from high jitter. <p> Real-time ORB endsystem architectures should be guided by empirical performance benchmarks: Our prior research on pinpointing performance bottlenecks and optimizing middleware like Web servers [15, 16] and CORBA ORBs <ref> [9, 8, 11, 10] </ref> demonstrates the efficacy of a measurement-driven research methodology. We recommend that the OMG adopt standard real-time CORBA benchmark-ing techniques and metrics. These benchmarks will simplify the communication and comparison of performance results and real-time ORB behavior patterns.
Reference: [12] <author> Object Management Group, </author> <title> Minimum CORBA Request for Proposal, </title> <editor> OMG Document orbos/97-06-14 ed., </editor> <month> June </month> <year> 1997. </year>
Reference-contexts: Neither CORBAplus, miniCOOL, nor MT-Orbix provide APIs for preestablishing connections; TAO provides these APIs as extensions to CORBA. We recommend that APIs to control the pre-establishment of connections should be defined as an OMG standard for real-time CORBA <ref> [12, 13] </ref>. 2. Real-time ORBs should avoid multiplexing requests of different priorities over a shared connection: Sharing connections requires synchronization. Thus, high-priority requests can be blocked until low-priority threads release the shared connection lock.
Reference: [13] <institution> Object Management Group, Realtime CORBA 1.0 Request for Proposals, OMG Document orbos/97-09-31 ed., </institution> <month> September </month> <year> 1997. </year>
Reference-contexts: Neither CORBAplus, miniCOOL, nor MT-Orbix provide APIs for preestablishing connections; TAO provides these APIs as extensions to CORBA. We recommend that APIs to control the pre-establishment of connections should be defined as an OMG standard for real-time CORBA <ref> [12, 13] </ref>. 2. Real-time ORBs should avoid multiplexing requests of different priorities over a shared connection: Sharing connections requires synchronization. Thus, high-priority requests can be blocked until low-priority threads release the shared connection lock.
Reference: [14] <author> D. C. Schmidt, T. Harrison, and N. Pryce, </author> <title> Thread-Specific Storage An Object Behavioral Pattern for Accessing per-Thread State Efficiently, </title> <booktitle> in The 4 th Pattern Languages of Programming Conference (Washington University technical report #WUCS-97-34), </booktitle> <month> September </month> <year> 1997. </year>
Reference-contexts: This lock sharing contributes to the overhead shown in Figure 13. We recommend that real-time ORBs avoid excessive sharing of dynamic memory locks via the use of OS features such as thread-specific storage <ref> [14] </ref>, which allocates memory from separate heaps that are unique to each thread. 4. Real-time ORB concurrency architectures should be flexible, yet efficient and predictable: Many ORBs, such as miniCOOL and CORBAPlus, create threads on behalf of server applications.
Reference: [15] <author> J. Hu, I. Pyarali, and D. C. Schmidt, </author> <title> Measuring the Impact of Event Dispatching and Concurrency Models on Web Server Performance Over High-speed Networks, </title> <booktitle> in Proceedings of the 2 nd Global Internet Conference, IEEE, </booktitle> <month> November </month> <year> 1997. </year>
Reference-contexts: Real-time ORB endsystem architectures should be guided by empirical performance benchmarks: Our prior research on pinpointing performance bottlenecks and optimizing middleware like Web servers <ref> [15, 16] </ref> and CORBA ORBs [9, 8, 11, 10] demonstrates the efficacy of a measurement-driven research methodology. We recommend that the OMG adopt standard real-time CORBA benchmark-ing techniques and metrics. These benchmarks will simplify the communication and comparison of performance results and real-time ORB behavior patterns.
Reference: [16] <author> J. Hu, S. Mungee, and D. C. Schmidt, </author> <title> Principles for Developing and Measuring High-performance Web Servers over ATM, </title> <booktitle> in Proceeedings of INFOCOM '98, </booktitle> <month> March/April </month> <year> 1998. </year>
Reference-contexts: Real-time ORB endsystem architectures should be guided by empirical performance benchmarks: Our prior research on pinpointing performance bottlenecks and optimizing middleware like Web servers <ref> [15, 16] </ref> and CORBA ORBs [9, 8, 11, 10] demonstrates the efficacy of a measurement-driven research methodology. We recommend that the OMG adopt standard real-time CORBA benchmark-ing techniques and metrics. These benchmarks will simplify the communication and comparison of performance results and real-time ORB behavior patterns.
Reference: [17] <institution> Object Management Group, Control and Management of Audio/Video Streams: OMG RFP Submission, 1.2 ed., </institution> <month> Mar. </month> <year> 1997. </year>
Reference-contexts: The architectural principles used in TAO can be applied to other ORBs and other real-time software systems. TAO has been used to develop a number of real-time applications, including a real-time audio/video streaming service <ref> [17] </ref> and a real-time ORB endsystem for avionics mission computing [6]. The avionics application manages sensors and operator displays, navigate the aircraft's course, and control weapon release.
References-found: 17

