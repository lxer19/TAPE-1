URL: http://www.cs.ucsb.edu/TRs/techreports/TRCS93-20.ps
Refering-URL: http://www.cs.ucsb.edu/TRs/
Root-URL: http://www.aic.nrl.navy.mil/~aha/people.html
Title: On the Serializability Theorem for Nested Transactions  
Author: R. F. Resende A. El Abbadi 
Keyword: Databases, Concurrency, Conflict Serializability, Nested Transactions.  
Address: Santa Barbara, CA 93106  
Affiliation: Department of Computer Science University of California  
Abstract: The fundamental theorem of the classical serializability theory states the necessary and sufficient conditions for the conflict serializability of an execution. In this paper, we extend the correctness criteria of the classical theory by presenting a definition of conflict serializability for concurrency control of nested transactions. We define a serialization graph for nested transactions and we prove that its acyclicity is a sufficient and necessary condition for conflict serializability. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> C. Beeri, P. A. Bernstein, and N. Goodman, </author> <title> "A Model for Concurrency in Nested Transactions Systems", </title> <journal> Journal of the Association for Computing Machinery, </journal> <volume> 36(2) </volume> <pages> 230-269, </pages> <month> April </month> <year> 1989. </year>
Reference-contexts: Our contribution is a well balanced group of definitions based on <ref> [1] </ref> and [3] and a proof of the fundamental theorem of serializability theory. We define a serialization graph for nested transactions and we prove that its acyclicity is a sufficient and necessary condition for conflict serializability. <p> We conclude the paper by deriving a proof of the correctness of executions produced by a modular graph testing scheduler. 2 The Model This section is divided in two subsections. In the first subsection we summarize part of the work presented in Beeri, Bernstein and Goodman <ref> [1] </ref>. In the second subsection we introduce our notion of equivalence and correctness. 2.1 Database System Model The components of a computation are states, operations, transactions, return values, and a partial order. <p> Proposition 1. <ref> [1] </ref> Let c = (s 1 ; A; &lt;; r; s 2 ) be a CF. <p> Now we will prove that if two DM tuples are conflict equivalent and one of them is a D-computation then the other is also a D-computation. We will use the technique of reversing commutative operations presented in <ref> [1] </ref> and [6]. First we show that the DM-tuple obtained by inverting the order of two contiguous and commutative operations of a D-computation is also in D. Lemma 1. <p> A CF is conflict serializable iff it is conflict equivalent to some serial CF. Our notion of serializability differs from previously proposed notions. In <ref> [1] </ref> two CFs are equivalent if they have the same initial and final states and their roots have the same return values. In [3] the equivalence concept was strengthened by requiring not only the same roots but also the same forest (with the same return value for each node). <p> We consider states and return values only to take advantage of the state-dependent commutativity definition, thus remaining within the confines of the general theory presented in <ref> [1] </ref>. Note that in [4] serial 2 Such a pair exists, by choosing x and y to be the pair of operations that are reversed in c 0 and closest together in c (without loss of generality, suppose x precedes y in c). <p> The combination of these two facts shows x precedes y in c 0 , contradicting the definition. 5 correctness for T 0 corresponds to serializability in <ref> [1] </ref>. To illustrate the difference between the equiv-alence definitions of [1] and [3], consider a transaction that increments an integer data item, using a read and a write operation. Consider two increment subtransactions belonging to two different top-level transactions. In [1] the order of the two increments is irrelevant as long <p> The combination of these two facts shows x precedes y in c 0 , contradicting the definition. 5 correctness for T 0 corresponds to serializability in <ref> [1] </ref>. To illustrate the difference between the equiv-alence definitions of [1] and [3], consider a transaction that increments an integer data item, using a read and a write operation. Consider two increment subtransactions belonging to two different top-level transactions. In [1] the order of the two increments is irrelevant as long as the underlying read and write operations are not interleaved. <p> definition. 5 correctness for T 0 corresponds to serializability in <ref> [1] </ref>. To illustrate the difference between the equiv-alence definitions of [1] and [3], consider a transaction that increments an integer data item, using a read and a write operation. Consider two increment subtransactions belonging to two different top-level transactions. In [1] the order of the two increments is irrelevant as long as the underlying read and write operations are not interleaved. In contrast, in [3], the order is significant since all operations must return the same values, including the read and write that implement the increment operation. <p> Hence, for the subset of executions that strictly depends on conflict information from the leaves, our approach complements the theory of Beeri, Bernstein and Goodman <ref> [1] </ref>.
Reference: [2] <author> P. A. Bernstein, V. Hadzilacos, V. and N. Goodman, </author> <title> Concurrency Control and Recovery in Database Systems, </title> <publisher> Addison Wesley, </publisher> <year> 1987. </year>
Reference-contexts: This has been done, and in most systems the programmer simply has to design a program without considering interferences from other programs accessing shared data. The simplicity of this concept was formally captured by the serializability theory <ref> [2] </ref> [6]. Most of the results of the serializability theory are related to a system model that has two levels, that of atomic operations, and above it, programs that use those operations. These systems are called flat, and the corresponding theory classical. <p> This paper chooses a more restrictive notion of "conflict serializability", and then proves that this is equivalent to acyclicity of a serialization graph. Thus we show that one can obtain theorems for nested transactions systems that correspond to the standard theorems of the classical theory <ref> [2] </ref>. We conclude the paper by deriving a proof of the correctness of executions produced by a modular graph testing scheduler. 2 The Model This section is divided in two subsections. In the first subsection we summarize part of the work presented in Beeri, Bernstein and Goodman [1]. <p> The difference between our notion of equivalence and that of [3] can be easily illustrated by any view serializable execution of flat transactions that is not conflict serializable <ref> [2] </ref>. Although more restrictive, our approach allows for the development of a serializability theory similar to the classical theory for flat transactions. In the next section we develop a serialization graph for nested transactions and show that the acyclicity of the graph is both necessary and sufficient for conflict serializability. <p> based on operational techniques such as commutativity-based reversals and substitution while conflict serializability can be proven using graph-theoretical techniques. 3 The Serializability Theorem In this section we prove a theorem which establishes a necessary and sufficient condition for conflict serializability of nested transactions, similar to the fundamental theorem of serializability <ref> [2] </ref> for flat transactions. First we define the serialization graph for nested transactions then we present the theorem.
Reference: [3] <author> T. Hadzilacos and V. Hadzilacos, </author> <title> "Transaction Synchronization in Object Bases", </title> <journal> Journal of Computer and System Sciences, V43, </journal> <volume> N1:2-24, </volume> <month> August </month> <year> 1991. </year>
Reference-contexts: Our contribution is a well balanced group of definitions based on [1] and <ref> [3] </ref> and a proof of the fundamental theorem of serializability theory. We define a serialization graph for nested transactions and we prove that its acyclicity is a sufficient and necessary condition for conflict serializability. In prior work on nested transactions, Hadzilacos and Hadzilacos [3] define a serialization graph and prove that <p> group of definitions based on [1] and <ref> [3] </ref> and a proof of the fundamental theorem of serializability theory. We define a serialization graph for nested transactions and we prove that its acyclicity is a sufficient and necessary condition for conflict serializability. In prior work on nested transactions, Hadzilacos and Hadzilacos [3] define a serialization graph and prove that its acyclicity is a sufficient condition for their notion of serializability. Fekete et al.[4] give a similar graph using a different system model, and again only prove sufficiency. <p> Operation o 1 conflicts with o 2 if o 1 does not commute with o 2 . Let &lt; and &lt; 0 be total orders such that &lt; is a permutation of &lt; 0 . We say that &lt; 0 is conflict consistent <ref> [3] </ref> with &lt; if whenever o conflicts with and precedes o 0 in &lt; then o precedes o 0 in &lt; 0 . 1 We will maintain the denomination "Computation Forest" or "CF", despite the introduction of t 0 . 4 Two DM tuples c = (s 1 ; O; &lt;; <p> A CF is conflict serializable iff it is conflict equivalent to some serial CF. Our notion of serializability differs from previously proposed notions. In [1] two CFs are equivalent if they have the same initial and final states and their roots have the same return values. In <ref> [3] </ref> the equivalence concept was strengthened by requiring not only the same roots but also the same forest (with the same return value for each node). <p> The combination of these two facts shows x precedes y in c 0 , contradicting the definition. 5 correctness for T 0 corresponds to serializability in [1]. To illustrate the difference between the equiv-alence definitions of [1] and <ref> [3] </ref>, consider a transaction that increments an integer data item, using a read and a write operation. Consider two increment subtransactions belonging to two different top-level transactions. In [1] the order of the two increments is irrelevant as long as the underlying read and write operations are not interleaved. <p> Consider two increment subtransactions belonging to two different top-level transactions. In [1] the order of the two increments is irrelevant as long as the underlying read and write operations are not interleaved. In contrast, in <ref> [3] </ref>, the order is significant since all operations must return the same values, including the read and write that implement the increment operation. The difference between our notion of equivalence and that of [3] can be easily illustrated by any view serializable execution of flat transactions that is not conflict serializable <p> In contrast, in <ref> [3] </ref>, the order is significant since all operations must return the same values, including the read and write that implement the increment operation. The difference between our notion of equivalence and that of [3] can be easily illustrated by any view serializable execution of flat transactions that is not conflict serializable [2]. Although more restrictive, our approach allows for the development of a serializability theory similar to the classical theory for flat transactions. <p> Edges of type (b) correspond to the transaction order or algorithmic precedence relation between siblings. We first prove a technical lemma, then we show that the acyclicity of our graph is both necessary and sufficient for conflict serializability. Our sufficiency part of the proof follows the proof in <ref> [3] </ref>. Lemma 3. Given a graph G = (V; E), a set of vertices C V; jCj 2, and P , a set of two or more disjoint nonempty partitions of vertices in C. <p> to c. [Definition of &lt; s ] Let the level of a node in SG (c) be the number of its proper ancestors in A (thus root (A) is at level 0). &lt; s is the relation at the end of the execution of the following Hierarchical Topological Sort (HTS) <ref> [3] </ref>: &lt; s := f (x; y) : there is an edge x ! y in SG (c)g for l := 1 to "max. level of any node in SG (c)" do "extend &lt; s to totally order all level l nodes" "further extend &lt; s by setting x &lt; s <p> Thus no cycle can exist in SG (c). That is, if CF c is conflict serializable then SG (c) is acyclic. 2 The graph SG (c) that we have defined differs in two main ways from that defined by Hadzi-lacos and Hadzilacos <ref> [3] </ref> (which we refer to as SG HH (c)). Firstly, SG HH includes edges between incomparable nodes even if those nodes are not siblings. For example, condition (a) gives edges in SG HH between any incomparable ancestors of x and y. <p> In both respects, our definition is closer to the serialization graph defined in [4]. 4 An application of serializability theorem In this section we derive a simple proof of correctness of a serialization graph testing scheduler [7]. Hadzilacos and Hadzilacos <ref> [3] </ref> show proofs for a lock and for a timestamp based protocols. The Children's Serialization Graph of transaction t, CSG (t), is a directed graph where nodes are the children of t.
Reference: [4] <author> A. Fekete, N. Lynch, and W. Weihl, </author> <title> "A Serialization Graph Construction for Nested Transactions", </title> <booktitle> Proceedings of the 9th ACM Symposium on Principles of Database Systems, </booktitle> <address> April 2-4, 1990, Nashville, Tennessee, </address> <publisher> ACM, </publisher> <address> New York, </address> <year> 1990, </year> <pages> pp. 94-108. </pages>
Reference-contexts: Nested transactions allow the benefits of atomicity to be used within a transaction, so that, for example, a transaction can include several simultaneous remote procedure calls, which can be coded without considering possible interference among them <ref> [4] </ref>. In this paper, we extend the correctness criteria of the classical theory by presenting a definition of conflict serializability for concurrency control of nested transactions. <p> The special case in which F is a one-level forest, c is also a DM tuple. Sometimes it is convenient to treat a given forest as a tree. This can be done adding a root (in <ref> [4] </ref> this root is called "mythical" t 0 ). <p> We consider states and return values only to take advantage of the state-dependent commutativity definition, thus remaining within the confines of the general theory presented in [1]. Note that in <ref> [4] </ref> serial 2 Such a pair exists, by choosing x and y to be the pair of operations that are reversed in c 0 and closest together in c (without loss of generality, suppose x precedes y in c). <p> The extra vertices for atomic operations seem essential for the definition to capture the intuitive notion of correct execution. In both respects, our definition is closer to the serialization graph defined in <ref> [4] </ref>. 4 An application of serializability theorem In this section we derive a simple proof of correctness of a serialization graph testing scheduler [7]. Hadzilacos and Hadzilacos [3] show proofs for a lock and for a timestamp based protocols.
Reference: [5] <author> J. E. B. Moss, </author> <title> "Nested Transactions: An Approach to Reliable Distributed Computing", </title> <type> Ph.D. Thesis, Technical Report MIT/LCS/TR-260, </type> <month> April </month> <year> 1981. </year>
Reference-contexts: These systems are called flat, and the corresponding theory classical. In nested transactions, transactions may use subtransactions, which in turn may use subtransactions, and so on <ref> [5] </ref>. Nested transactions allow the benefits of atomicity to be used within a transaction, so that, for example, a transaction can include several simultaneous remote procedure calls, which can be coded without considering possible interference among them [4].
Reference: [6] <author> C. H. Papadimitriou, </author> <title> The Theory of Database Concurrency Control, </title> <publisher> Computer Science Press, </publisher> <year> 1986. </year>
Reference-contexts: This has been done, and in most systems the programmer simply has to design a program without considering interferences from other programs accessing shared data. The simplicity of this concept was formally captured by the serializability theory [2] <ref> [6] </ref>. Most of the results of the serializability theory are related to a system model that has two levels, that of atomic operations, and above it, programs that use those operations. These systems are called flat, and the corresponding theory classical. <p> Now we will prove that if two DM tuples are conflict equivalent and one of them is a D-computation then the other is also a D-computation. We will use the technique of reversing commutative operations presented in [1] and <ref> [6] </ref>. First we show that the DM-tuple obtained by inverting the order of two contiguous and commutative operations of a D-computation is also in D. Lemma 1.
Reference: [7] <author> R. F. Resende and A. El Abbadi, </author> <title> "A Graph Testing Concurrency Control Protocol for Object Bases", </title> <booktitle> Proceedings of the 4th International Conference on Computing and Information, </booktitle> <month> May 28-30, </month> <year> 1992, </year> <institution> Toronto, </institution> <address> Canada, </address> <publisher> IEEE, Los Alamitos, </publisher> <year> 1992, </year> <pages> pp. 316-317. 9 </pages>
Reference-contexts: In both respects, our definition is closer to the serialization graph defined in [4]. 4 An application of serializability theorem In this section we derive a simple proof of correctness of a serialization graph testing scheduler <ref> [7] </ref>. Hadzilacos and Hadzilacos [3] show proofs for a lock and for a timestamp based protocols. The Children's Serialization Graph of transaction t, CSG (t), is a directed graph where nodes are the children of t.
References-found: 7

