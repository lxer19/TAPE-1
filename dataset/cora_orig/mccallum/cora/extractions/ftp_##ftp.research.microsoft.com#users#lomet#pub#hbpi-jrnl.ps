URL: ftp://ftp.research.microsoft.com/users/lomet/pub/hbpi-jrnl.ps
Refering-URL: http://www.research.microsoft.com/users/lomet/
Root-URL: http://www.research.microsoft.com
Title: The hB -tree: A Multi-attribute Index Supporting Concurrency, Recovery and Node Consolidation  
Author: Georgios Evangelidis David Lomet Betty Salzberg 
Keyword: process.  
Note: Ph.D., Senior Scientist,  Ph.D., Professor,  corresponding author: Betty Salzberg  This work was partially supported by NSF grants IRI-91-02821 and IRI-93-03403. 1-year Appointment.  
Address: P.O. Box 14561, Thessaloniki, GR-54101, Greece, tel. 30-31-791-295  One Microsoft Way, Bldg 9, Redmond, WA 98052-6399,  Boston, MA 02115,  
Affiliation: Informatics Department Technological Educational Institute of Thessaloniki  Microsoft Corporation  College of Computer Science Northeastern University,  
Email: (gevan@alpha.it.teithe.gr)  (lomet@microsoft.com)  (salzberg@ccs.neu.edu)  E-mail: salzberg@ccs.neu.edu  
Phone: tel. (206) 703-1853  tel. (617) 373-2229  Phone: (617) 373-2229, Fax: (617) 373-5121,  
Degree: Ph.D., Assistant Professor  
Abstract: Categories and Subject Descriptors: E.1 [Data]: Data Structures Trees; E.2 [Data]: Data Storage Representations Composite Structures; H.2.2 [Database Management]: Physical Design Access methods; H.2.4 [Database Management]: Systems - Concurrency; H.3.3 [Information Storage and Retrieval]: Information Search and Retrieval Clustering, Retrieval models, Search 
Abstract-found: 1
Intro-found: 1
Reference: [Bar92] <author> M. Barrena. </author> <title> Private communication. </title> <year> 1992. </year>
Reference-contexts: Posting them later, during an index term posting atomic action, is similar to filling in gaps in existing kd-trees. We are now faced with a new problem, that was first brought to our attention by <ref> [Bar92] </ref>. This is illustrated in Figure 23. After inserting kd-tree node c in between kd-tree nodes a and b, we need to determine whether the kd-subtree rooted at c, which is the previous right child of a, will become a left or a right child of b.
Reference: [Ben79] <author> J. L. Bentley. </author> <title> Multidimensional binary search trees in database applications. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> SE-5(4):333-340, </volume> <month> July </month> <year> 1979. </year>
Reference-contexts: They contain a kd-tree <ref> [Ben79] </ref> which is used to organize information about children on the next lower level of the hB-tree and about regions which have been extracted and transferred to siblings on the same index level. * Data nodes contain the actual data records.
Reference: [BKSS90] <author> N. Beckmann, H.-P. Kriegel, R. Schneider, and B. Seeger. </author> <title> The R fl -tree: An efficient and robust access method for points and rectangles. </title> <booktitle> In Proceedings of ACM/SIGMOD Annual Conference on Management of Data, </booktitle> <pages> pages 322-331, </pages> <year> 1990. </year>
Reference-contexts: Then it uses any single-attribute index, e.g., the B + -tree, to index the resulting attribute. The rest of the mentioned methods explicitly index multi-attribute data. Proposed methods for spatial (or non-point) data include the R-tree [Gut84] and its variations (R + -tree [SRF87], R fl -tree <ref> [BKSS90] </ref>), and the cell tree [Gue89]. An alternative approach maps k-dimensional spatial objects to 2k-dimensional points. This can be done by taking the minimum bounding box of the spatial object and using a 2k dimensional point to represent it (low and high values for each attribute) [Hin85].
Reference: [BM72] <author> R. Bayer and E. McCreight. </author> <title> Organization and maintenance of large ordered indexes. </title> <journal> Acta Informatica, </journal> <volume> 1(3) </volume> <pages> 173-189, </pages> <year> 1972. </year>
Reference-contexts: 1 Introduction Traditional Database Management Systems (DBMSs) efficiently organize, access, and manipulate very large quantities of data for business applications in banks, airlines, government agencies, hospitals, and other large organizations. Almost all of them implement some variation of the B + -tree <ref> [BM72, Com79] </ref> for ordered single-attribute indexing. In general, "traditional" data can be viewed as linear data. Each data item is identified by some attribute that distinguishes it from other data items and this is what we call a primary key for the data item.
Reference: [BS77] <author> R. Bayer and M. Schkolnick. </author> <title> Concurrency of operations on B-Trees. </title> <journal> Acta Informatica, </journal> <volume> 9(1) </volume> <pages> 1-21, </pages> <year> 1977. </year>
Reference-contexts: Then, any point data method can be used to index the transformed space. Concurrency control in B + -trees has been the subject of many papers <ref> [BS77, LY81, Sal85, Sag86, SG88, ML89, LS92] </ref>. Most of these papers, with the exception of [ML89, LS92], have not addressed the problem of system crashes during structure changes. 1.2 Our Approach We introduce a new access method for multi-attribute data that we call the hB -tree.
Reference: [Com79] <author> D. Comer. </author> <title> The Ubiquitous B-Tree. </title> <journal> ACM Computing Surveys, </journal> <volume> 11(4) </volume> <pages> 121-137, </pages> <year> 1979. </year>
Reference-contexts: 1 Introduction Traditional Database Management Systems (DBMSs) efficiently organize, access, and manipulate very large quantities of data for business applications in banks, airlines, government agencies, hospitals, and other large organizations. Almost all of them implement some variation of the B + -tree <ref> [BM72, Com79] </ref> for ordered single-attribute indexing. In general, "traditional" data can be viewed as linear data. Each data item is identified by some attribute that distinguishes it from other data items and this is what we call a primary key for the data item.
Reference: [ES93] <author> G. Evangelidis and B. Salzberg. </author> <title> Using the Holey Brick Tree for Spatial Data in General Purpose DBMSs. </title> <journal> IEEE Database Engineering Bulletin, </journal> <volume> 16(3) </volume> <pages> 34-39, </pages> <month> September </month> <year> 1993. </year>
Reference: [GSE + 94] <author> J. Gray, P. Sundaresan, S. Englert, K. Baclawski, and P. Weinberger. </author> <title> Quickly generating billion-record synthetic databases. </title> <booktitle> In Proceedings of ACM/SIGMOD Annual Conference on Management of Data, </booktitle> <pages> pages 243-252, </pages> <address> Minneapolis, MN, </address> <month> May </month> <year> 1994. </year> <month> 49 </month>
Reference-contexts: To do this we performed the following transformation on each value (v is the old value and v 0 is the new one): where n determines the degree of skewness. For example, for n = 21:85 we get a 90:10 skewed distribution <ref> [Knu68, Lom83, GSE + 94] </ref>. In our experiments we used one quarter million records, each one consisting of twelve 4-byte attributes. To simulate hB -trees of various dimensionalities we used between one and twelve of them as indexing attributes.
Reference: [Gue89] <author> O. Guenther. </author> <title> The design of the cell tree: an object oriented index structure for geometric databases. </title> <booktitle> In Proceedings of IEEE Data Engineering Conference, </booktitle> <pages> pages 598-605, </pages> <address> Los Angeles, CA, </address> <year> 1989. </year>
Reference-contexts: The rest of the mentioned methods explicitly index multi-attribute data. Proposed methods for spatial (or non-point) data include the R-tree [Gut84] and its variations (R + -tree [SRF87], R fl -tree [BKSS90]), and the cell tree <ref> [Gue89] </ref>. An alternative approach maps k-dimensional spatial objects to 2k-dimensional points. This can be done by taking the minimum bounding box of the spatial object and using a 2k dimensional point to represent it (low and high values for each attribute) [Hin85].
Reference: [Gut84] <author> A. Guttman. R-trees: </author> <title> A dynamic index structure for spatial searching. </title> <booktitle> In Proceedings of ACM/SIGMOD Annual Conference on Management of Data, </booktitle> <pages> pages 47-57, </pages> <address> Boston, MA, </address> <month> June </month> <year> 1984. </year>
Reference-contexts: Z-ordering maps k attributes to a single one by alternating their bit representations. Then it uses any single-attribute index, e.g., the B + -tree, to index the resulting attribute. The rest of the mentioned methods explicitly index multi-attribute data. Proposed methods for spatial (or non-point) data include the R-tree <ref> [Gut84] </ref> and its variations (R + -tree [SRF87], R fl -tree [BKSS90]), and the cell tree [Gue89]. An alternative approach maps k-dimensional spatial objects to 2k-dimensional points. <p> With a page size of 1K bytes and larger, there is almost no effect on the size of the hB -tree and the node space utilization as the dimensions increase. (Page sizes larger than 2K bytes are not shown.) This is in contrast, for example, with the R-tree <ref> [Gut84] </ref>, where index entries are bounding coordinates of objects plus a pointer. Thus, in the R-Tree (and its variants) the size of the index is proportional to the dimension of the space. 7 Conclusion 7.1 Summary Indexing of multi-attribute data in general purpose DBMSs is a very desirable feature.
Reference: [Hin85] <author> K. H. Hinrichs. </author> <title> The grid file: implementation and case studies of applications. </title> <type> PhD thesis, </type> <institution> Swiss Federal Institute of Technology, </institution> <address> Zurich, Switzerland, </address> <year> 1985. </year>
Reference-contexts: An alternative approach maps k-dimensional spatial objects to 2k-dimensional points. This can be done by taking the minimum bounding box of the spatial object and using a 2k dimensional point to represent it (low and high values for each attribute) <ref> [Hin85] </ref>. Then, any point data method can be used to index the transformed space. Concurrency control in B + -trees has been the subject of many papers [BS77, LY81, Sal85, Sag86, SG88, ML89, LS92].
Reference: [Knu68] <author> D. E. Knuth. </author> <booktitle> The art of computer programming, </booktitle> <volume> volume 3. </volume> <publisher> Addison-Wesley, </publisher> <address> Reading, MA, </address> <year> 1968. </year>
Reference-contexts: To do this we performed the following transformation on each value (v is the old value and v 0 is the new one): where n determines the degree of skewness. For example, for n = 21:85 we get a 90:10 skewed distribution <ref> [Knu68, Lom83, GSE + 94] </ref>. In our experiments we used one quarter million records, each one consisting of twelve 4-byte attributes. To simulate hB -trees of various dimensionalities we used between one and twelve of them as indexing attributes.
Reference: [Lom77] <author> D. B. Lomet. </author> <title> Process structuring, synchronization, and recovery using atomic actions. </title> <journal> SIGPLAN Notices, </journal> <volume> 12(3) </volume> <pages> 128-137, </pages> <month> March </month> <year> 1977. </year>
Reference-contexts: This algorithm is applicable to an abstract index tree structure, the -tree. The main idea is to make it possible to hold only short term locks on non-leaf nodes. This is achieved by making -tree structure changes consist of a sequence of atomic actions <ref> [Lom77] </ref>. Most of these actions are separate from the transaction whose update triggered the structure change and each one of them leaves the tree in an intermediate well-formed state. What we do here is review the structure of a -tree and the concurrency and recovery algorithms applying to it.
Reference: [Lom83] <author> D. B. Lomet. </author> <title> Bounded index exponential hashing. </title> <journal> ACM Transactions on Database Systems, </journal> <volume> 8(1) </volume> <pages> 136-165, </pages> <month> March </month> <year> 1983. </year>
Reference-contexts: To do this we performed the following transformation on each value (v is the old value and v 0 is the new one): where n determines the degree of skewness. For example, for n = 21:85 we get a 90:10 skewed distribution <ref> [Knu68, Lom83, GSE + 94] </ref>. In our experiments we used one quarter million records, each one consisting of twelve 4-byte attributes. To simulate hB -trees of various dimensionalities we used between one and twelve of them as indexing attributes.
Reference: [LS90] <author> D. Lomet and B. Salzberg. </author> <title> The hB-Tree: A multiattribute indexing method with good guaranteed performance. </title> <journal> ACM Transactions on Database Systems, </journal> <volume> 15(4) </volume> <pages> 625-658, </pages> <month> Decem-ber </month> <year> 1990. </year>
Reference-contexts: Spatial data that can be viewed as subspaces in a k-dimensional space, for example, polygons in the two-dimensional Euclidean space. This type of multi-attribute data is almost always geographical data. 3 Proposed point data indexing methods include Z-ordering [OM84], the grid file [NHS84], the K-D--B-tree [Rob81], and the hB-tree <ref> [LS90] </ref>. Z-ordering maps k attributes to a single one by alternating their bit representations. Then it uses any single-attribute index, e.g., the B + -tree, to index the resulting attribute. The rest of the mentioned methods explicitly index multi-attribute data. <p> It is based on the hB-tree, a multi-attribute point data access method <ref> [LS90] </ref> and the -tree, an abstract index tree for which a general algorithm for concurrency and recovery is available [LS92]. The -tree is essentially a generalization of the B link -tree [LY81]. <p> The result of this modification of the hB-tree is called the hB -tree. In a series of experiments, we test the various splitting and posting algorithms and measure the overall performance of the hB -tree. 1.3 Overview In section 2 we review the -tree [LS92]. We modify the hB-tree <ref> [LS90] </ref> to become a subcase of the -tree. We call the new method the hB -tree and we present its structural characteristics in Section 3. Section 4 is devoted to the various node splitting and index term posting algorithms for the hB - tree. <p> More details can be found in [LS92]. 3 The hB -tree: Structure In this section we first briefly review the hB-tree and then we describe the structural modifications that transform the hB-tree into the hB -tree. 3.1 Review of the hB-tree 3.1.1 Structure The hB-tree (or holey Brick tree) <ref> [LS90] </ref> consists of index and data nodes. * Index nodes are responsible for k-dimensional subspaces. <p> are created during hB -tree node splitting, and finally, how index terms should be posted, and more importantly, what they should look like. 14 4.1 Description of A Problem We begin by showing here how one could adapt the original hB-tree node splitting and index term posting algorithms (described in <ref> [LS90] </ref>) for use in the hB -tree. This is a straightforward adaptation since the main innovation of the hB -tree are the side-pointers and the fact that node splitting and index term posting are performed by separate atomic actions. <p> Index nodes contain a kd-tree only, whereas, data nodes contain either a collection of records known as a record-list, or a kd-tree and one or more record-lists. Index node splitting is straightforward. In <ref> [LS90] </ref> it is shown that one can always split off a kd-subtree with between one third and two thirds of the kd-tree nodes. This is the extracted kd-subtree that is moved to the extracted node (a newly allocated hB -tree node). <p> On the other hand, we can use both indexing attributes and extract all records that have both x 20 and y 20. This kind of split introduces two kd-tree nodes in node A that describe the resulting space decomposition. In <ref> [LS90] </ref>, it is shown that it is always possible to achieve a one third to two thirds corner split. If there is a kd-tree in the data node, we may be able to find and extract a kd-subtree that refers to a collection of record-lists, instead of splitting a record-list. <p> We have just sketched the basic ideas behind index term posting. We will not describe this procedure in more detail. The reason is that we have found that the posting algorithm for the hB-tree <ref> [LS90] </ref> is not correct. <p> We say that such splits do not preserve DSBs. Also, we say that a kd-tree defines DSBs when the space decomposition it describes preserves DSBs. With the help of the scenario demonstrated in Figures 8 through 11, we show that the splitting and posting algorithm of the hB-tree <ref> [LS90] </ref> is erroneous. These figures use an hB -tree, but the argument we will use also holds for hB-trees. <p> was posted to B1 (see Figure 8), * B2 was extracted from B1, and the condensed path (y5) was posted to A1 (see Figure 9), * C3 has just been extracted from C1, and we are ready to post the index term for that split (see The algorithm described in <ref> [LS90] </ref> does not cope with space decompositions that do not preserve DSBs. As shown in Figure 11, it would post kd-tree node x5 above y5 in B1, and change the C1 decoration to a C3 decoration in B2.
Reference: [LS92] <author> D. Lomet and B. Salzberg. </author> <title> Access method concurrency with recovery. </title> <booktitle> In Proceedings of ACM/SIGMOD Annual Conference on Management of Data, </booktitle> <pages> pages 351-360, </pages> <address> San Diego, CA, </address> <month> June </month> <year> 1992. </year>
Reference-contexts: Then, any point data method can be used to index the transformed space. Concurrency control in B + -trees has been the subject of many papers <ref> [BS77, LY81, Sal85, Sag86, SG88, ML89, LS92] </ref>. Most of these papers, with the exception of [ML89, LS92], have not addressed the problem of system crashes during structure changes. 1.2 Our Approach We introduce a new access method for multi-attribute data that we call the hB -tree. <p> Then, any point data method can be used to index the transformed space. Concurrency control in B + -trees has been the subject of many papers [BS77, LY81, Sal85, Sag86, SG88, ML89, LS92]. Most of these papers, with the exception of <ref> [ML89, LS92] </ref>, have not addressed the problem of system crashes during structure changes. 1.2 Our Approach We introduce a new access method for multi-attribute data that we call the hB -tree. <p> It is based on the hB-tree, a multi-attribute point data access method [LS90] and the -tree, an abstract index tree for which a general algorithm for concurrency and recovery is available <ref> [LS92] </ref>. The -tree is essentially a generalization of the B link -tree [LY81]. The B link -tree has side-pointers or links pointing from each index node to the next index node on the same level of the tree in key order. <p> The result of this modification of the hB-tree is called the hB -tree. In a series of experiments, we test the various splitting and posting algorithms and measure the overall performance of the hB -tree. 1.3 Overview In section 2 we review the -tree <ref> [LS92] </ref>. We modify the hB-tree [LS90] to become a subcase of the -tree. We call the new method the hB -tree and we present its structural characteristics in Section 3. Section 4 is devoted to the various node splitting and index term posting algorithms for the hB - tree. <p> Finally, in Section 7 we summarize and give some directions for future work. 4 2 -tree Concurrency and Recovery In this section we briefly review a general algorithm for concurrency and recovery for a wide class of index trees (single-attribute, multi-attribute, or versioned) <ref> [LS92] </ref>. This algorithm is applicable to an abstract index tree structure, the -tree. The main idea is to make it possible to hold only short term locks on non-leaf nodes. This is achieved by making -tree structure changes consist of a sequence of atomic actions [Lom77]. <p> In the case an update is to be made at some level of the tree, the nodes are locked with an exclusive lock at the level of the tree where the update is to be made. (In <ref> [LS92] </ref> a slightly less restrictive lock is used at the update level; we are making a simplification.) On all other levels, or if no updates are to be made, the search locks are share locks. <p> If an update or read is to be to on a data item, only the database lock on the data item (of whatever granularity the database system supports) is held to end of transaction. The node locks of the searching algorithm of <ref> [LS92] </ref> need not be held once the search has finished and the data item is read or updated. (Database locks are not part of the -tree algorithms, which are mainly concerned with tree structure modifications.) For range searches, multiple children nodes are visited at each level. <p> If they do not match, search for the correct parent begins again in the root. More details can be found in <ref> [LS92] </ref>. Node splitting is exactly the same (except for possible database locks) at the abstraction level of the -tree in [LS92] for both data and index nodes. However, a particular -tree (such as a B + -tree) 6 may have index terms which look quite different from data records. <p> If they do not match, search for the correct parent begins again in the root. More details can be found in <ref> [LS92] </ref>. Node splitting is exactly the same (except for possible database locks) at the abstraction level of the -tree in [LS92] for both data and index nodes. However, a particular -tree (such as a B + -tree) 6 may have index terms which look quite different from data records. The details of such splitting will differ from example to example. <p> Complete atomic actions (actions all of whose log records are on disk) are redone at recovery if their results have not reached the disk. Thus, the transaction manager must know about atomic actions in the sense it knows about database or system transactions. More details can be found in <ref> [LS92] </ref>. 3 The hB -tree: Structure In this section we first briefly review the hB-tree and then we describe the structural modifications that transform the hB-tree into the hB -tree. 3.1 Review of the hB-tree 3.1.1 Structure The hB-tree (or holey Brick tree) [LS90] consists of index and data nodes. *
Reference: [LY81] <author> P. Lehman and S. B. Yao. </author> <title> Efficient locking for concurrent operations on B-trees. </title> <journal> ACM Transactions on Database Systems, </journal> <volume> 6(4) </volume> <pages> 650-670, </pages> <month> December </month> <year> 1981. </year>
Reference-contexts: Then, any point data method can be used to index the transformed space. Concurrency control in B + -trees has been the subject of many papers <ref> [BS77, LY81, Sal85, Sag86, SG88, ML89, LS92] </ref>. Most of these papers, with the exception of [ML89, LS92], have not addressed the problem of system crashes during structure changes. 1.2 Our Approach We introduce a new access method for multi-attribute data that we call the hB -tree. <p> It is based on the hB-tree, a multi-attribute point data access method [LS90] and the -tree, an abstract index tree for which a general algorithm for concurrency and recovery is available [LS92]. The -tree is essentially a generalization of the B link -tree <ref> [LY81] </ref>. The B link -tree has side-pointers or links pointing from each index node to the next index node on the same level of the tree in key order.
Reference: [ML89] <author> C. Mohan and F. Levine. ARIES/IM: </author> <title> an efficient and high concurrency index management method using write-ahead logging. </title> <institution> IBM Research Report RJ 6846, IBM Almaden Research Center, </institution> <address> San Jose, CA, </address> <month> August </month> <year> 1989. </year>
Reference-contexts: Then, any point data method can be used to index the transformed space. Concurrency control in B + -trees has been the subject of many papers <ref> [BS77, LY81, Sal85, Sag86, SG88, ML89, LS92] </ref>. Most of these papers, with the exception of [ML89, LS92], have not addressed the problem of system crashes during structure changes. 1.2 Our Approach We introduce a new access method for multi-attribute data that we call the hB -tree. <p> Then, any point data method can be used to index the transformed space. Concurrency control in B + -trees has been the subject of many papers [BS77, LY81, Sal85, Sag86, SG88, ML89, LS92]. Most of these papers, with the exception of <ref> [ML89, LS92] </ref>, have not addressed the problem of system crashes during structure changes. 1.2 Our Approach We introduce a new access method for multi-attribute data that we call the hB -tree.
Reference: [NHS84] <author> J. Nievergelt, H. Hinterberger, and K. C. Sevcik. </author> <title> The Grid File: An adaptable, symmetric, multikey file structure. </title> <journal> ACM Transactions on Database Systems, </journal> <volume> 9(1) </volume> <pages> 38-71, </pages> <month> March </month> <year> 1984. </year>
Reference-contexts: Spatial data that can be viewed as subspaces in a k-dimensional space, for example, polygons in the two-dimensional Euclidean space. This type of multi-attribute data is almost always geographical data. 3 Proposed point data indexing methods include Z-ordering [OM84], the grid file <ref> [NHS84] </ref>, the K-D--B-tree [Rob81], and the hB-tree [LS90]. Z-ordering maps k attributes to a single one by alternating their bit representations. Then it uses any single-attribute index, e.g., the B + -tree, to index the resulting attribute. The rest of the mentioned methods explicitly index multi-attribute data.
Reference: [OM84] <author> J. A. Orenstein and T. Merrett. </author> <title> A class of data structures for associative searching. </title> <booktitle> In Proceedings of SIGART-SIGMOD 3rd Symposium on Principles of Database Systems, </booktitle> <pages> pages 181-190, </pages> <address> Waterloo, Canada, </address> <year> 1984. </year>
Reference-contexts: Spatial data that can be viewed as subspaces in a k-dimensional space, for example, polygons in the two-dimensional Euclidean space. This type of multi-attribute data is almost always geographical data. 3 Proposed point data indexing methods include Z-ordering <ref> [OM84] </ref>, the grid file [NHS84], the K-D--B-tree [Rob81], and the hB-tree [LS90]. Z-ordering maps k attributes to a single one by alternating their bit representations. Then it uses any single-attribute index, e.g., the B + -tree, to index the resulting attribute.
Reference: [Rob81] <author> J. T. Robinson. </author> <title> The K-D-B-Tree: A search structure for large multidimensional dynamic indexes. </title> <booktitle> In Proceedings of ACM/SIGMOD Annual Conference on Management of Data, </booktitle> <pages> pages 10-18, </pages> <address> New York, NY, </address> <month> April </month> <year> 1981. </year>
Reference-contexts: Spatial data that can be viewed as subspaces in a k-dimensional space, for example, polygons in the two-dimensional Euclidean space. This type of multi-attribute data is almost always geographical data. 3 Proposed point data indexing methods include Z-ordering [OM84], the grid file [NHS84], the K-D--B-tree <ref> [Rob81] </ref>, and the hB-tree [LS90]. Z-ordering maps k attributes to a single one by alternating their bit representations. Then it uses any single-attribute index, e.g., the B + -tree, to index the resulting attribute. The rest of the mentioned methods explicitly index multi-attribute data.
Reference: [Sag86] <author> Y. Sagiv. </author> <title> Concurrent operations on b fl -trees with overtaking. </title> <journal> Journal of Computer and System Sciences, </journal> <volume> 33(2) </volume> <pages> 275-296, </pages> <year> 1986. </year>
Reference-contexts: Then, any point data method can be used to index the transformed space. Concurrency control in B + -trees has been the subject of many papers <ref> [BS77, LY81, Sal85, Sag86, SG88, ML89, LS92] </ref>. Most of these papers, with the exception of [ML89, LS92], have not addressed the problem of system crashes during structure changes. 1.2 Our Approach We introduce a new access method for multi-attribute data that we call the hB -tree.
Reference: [Sal85] <author> B. Salzberg. </author> <title> Restructuring the Lehman-Yao tree. </title> <type> Technical Report NU-CCS-85-21, </type> <institution> College of Computer Science, Northeastern University, </institution> <address> Boston, MA, </address> <year> 1985. </year> <month> 50 </month>
Reference-contexts: Then, any point data method can be used to index the transformed space. Concurrency control in B + -trees has been the subject of many papers <ref> [BS77, LY81, Sal85, Sag86, SG88, ML89, LS92] </ref>. Most of these papers, with the exception of [ML89, LS92], have not addressed the problem of system crashes during structure changes. 1.2 Our Approach We introduce a new access method for multi-attribute data that we call the hB -tree.
Reference: [Sal91] <author> B. Salzberg. </author> <title> Practical spatial database access methods. </title> <booktitle> In Proceedings of the Symposium on Applied Computing, </booktitle> <pages> pages 82-90, </pages> <address> Kansas City, MI, </address> <year> 1991. </year>
Reference-contexts: To efficiently handle multi-attribute data one needs explicitly multi-attribute indexes. It is essential to cluster "nearby" k-dimensional data in contiguous areas of a disk. There is no "perfect" way to map multi-attribute data on linear physical disk storage, though. In general, the desirable properties of multi-attribute indexes are <ref> [Sal91] </ref>: 1. good space utilization in both index and data nodes, 2. high fan-out (the index should be significantly smaller than the data collection), 3. fast exact match search (given the coordinates, the data should be obtained quickly), 4. fair clustering in data pages by all attributes for good range search
Reference: [SC91] <author> V. Srinivasan and M. Carey. </author> <title> Performance of B-tree concurrency control algorithms. </title> <booktitle> In Proceedings of ACM/SIGMOD Annual Conference on Management of Data, </booktitle> <pages> pages 416-425, </pages> <address> Denver, CO, </address> <month> May </month> <year> 1991. </year>
Reference-contexts: This implies that the locks needed for splitting can be dropped before the locks for posting are acquired. A recent study compared the performance of various concurrency control algorithms <ref> [SC91] </ref>. Its most important conclusion was that algorithms using the link technique provide the most concurrency and the best overall performance. The -tree generalizes the B link -tree because it treats the multi-attribute case, it considers node consolidation, and it considers recovery as well as concurrency.
Reference: [SFGM93] <author> M. Stonebraker, J. Frew, K. Gardels, and J. Meredith. </author> <title> The Sequoia 2000 Storage Benchmark. </title> <booktitle> In Proceedings of ACM/SIGMOD Annual Conference on Management of Data, </booktitle> <pages> pages 2-11, </pages> <address> Washington, DC, </address> <month> May </month> <year> 1993. </year>
Reference-contexts: Section 5 presents a node consolidation algorithm for the hB -tree. The splitting/posting and consolidation algorithms have been tested in the implemented hB -tree under various data distributions. The data we used was either computer generated or geographical data from the Sequoia 2000 Storage Benchmark <ref> [SFGM93] </ref>. The results are shown in Section 6. <p> 3. 6 Performance Results In this section we first describe the nature of multi-attribute data we used to test the various versions of the hB -tree, and then we present the performance results we obtained. 6.1 Workload We used both computer-generated data and data from the Sequoia 2000 Storage Benchmark <ref> [SFGM93] </ref>. 6.1.1 Computer-Generated Data Computer-generated data was created by skewing values obtained from a random number generator. To do this we performed the following transformation on each value (v is the old value and v 0 is the new one): where n determines the degree of skewness. <p> In the rest of this section we will be referring to this kind of data as "computer-generated data". 41 6.1.2 Sequoia Data The Regional version of the Sequoia 2000 Storage Benchmark <ref> [SFGM93] </ref> consists of geographic data from the state of California. This is point, polygon, graph, and raster data. In our experiments we used the point data. <p> We need to further assess the performance of our method when on such unusual data distributions. In particular, we want to know how they affect range search performance. The polygon and graph data from the Sequoia 2000 Benchmark <ref> [SFGM93] </ref> would be appropriate for this purpose. Another very interesting and important problem are spatial joins. An example of a spatial join is "give me all cities that are 10 miles away from the Mississippi river".
Reference: [SG88] <author> D. Shasha and N. Goodman. </author> <title> Concurrent search structure algorithms. </title> <journal> ACM Transactions on Database Systems, </journal> <volume> 13(1) </volume> <pages> 53-90, </pages> <month> March </month> <year> 1988. </year>
Reference-contexts: Then, any point data method can be used to index the transformed space. Concurrency control in B + -trees has been the subject of many papers <ref> [BS77, LY81, Sal85, Sag86, SG88, ML89, LS92] </ref>. Most of these papers, with the exception of [ML89, LS92], have not addressed the problem of system crashes during structure changes. 1.2 Our Approach We introduce a new access method for multi-attribute data that we call the hB -tree.
Reference: [SRF87] <author> T. Sellis, N. Roussopoulos, and C. Faloutsos. </author> <title> The R + -tree: a dynamic index for multidimensional objects. </title> <booktitle> In International Conference on Very Large Data Bases, </booktitle> <pages> pages 1-24, </pages> <address> Brighton, England, </address> <year> 1987. </year> <month> 51 </month>
Reference-contexts: Then it uses any single-attribute index, e.g., the B + -tree, to index the resulting attribute. The rest of the mentioned methods explicitly index multi-attribute data. Proposed methods for spatial (or non-point) data include the R-tree [Gut84] and its variations (R + -tree <ref> [SRF87] </ref>, R fl -tree [BKSS90]), and the cell tree [Gue89]. An alternative approach maps k-dimensional spatial objects to 2k-dimensional points.
References-found: 28

