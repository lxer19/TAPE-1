URL: ftp://ftp.cs.unc.edu/pub/users/geom/papers/INTERSECT/eff_alg_num.ps.gz
Refering-URL: http://www.cs.unc.edu/~keyser/research.html
Root-URL: http://www.cs.unc.edu
Email: fkeyser,krishnas,dm,culverg@cs.unc.edu  
Title: Efficient and Reliable Computation with Algebraic Numbers for Geometric Algorithms  
Author: J. Keyser S. Krishnan D. Manocha T. Culver 
Note: Supported in part by a Sloan fellowship, ARO Contract P-34982-MA, NSF grant CCR-9319957, NSF grant CCR-9625217 and ONR Young Investigator Award. Currently at AT T Research Labs  
Date: March 24, 1998  
Address: Chapel Hill, NC 27599-3175  
Affiliation: Department of Computer Science University of North Carolina  
Abstract: Many geometric algorithms involve dealing with numeric data corresponding to high degree algebraic numbers. They come up in computing generalized Voronoi diagrams of lines and planes, medial axis of a polyhedron and geometric computation on non-linear primitives described using algebraic functions. Earlier algorithms dealing with algebraic numbers either use fixed precision arithmetic or techniques from symbolic computation. While the former can be inaccurate, the latter is too slow in practice. We present efficient representations and algorithms for reliable computations with algebraic numbers. We use these representations to efficiently perform geometric queries like inside/outside tests, which-side or orientation tests. The overall approach combines different techniques from symbolic computation based on exact arithmetic with floating point arithmetic. We demonstrate its applications to efficient and reliable computation of curve and surface intersections. In practice, it is about one order of magnitude faster as compared to earlier implementations that produce reliable results. 
Abstract-found: 1
Intro-found: 1
Reference: [AB88] <author> S.S. Abhyankar and C. Bajaj. </author> <title> Computations with algebraic curves. </title> <booktitle> In Lecture Notes in Computer Science, </booktitle> <volume> volume 358, </volume> <pages> pages 279-284. </pages> <publisher> Springer Verlag, </publisher> <year> 1988. </year>
Reference: [ABD + 97] <author> F. Avnaim, J.-D. Boissonnat, O. Devillers, F. Preparata, and M. Yvinec. </author> <title> Evaluating signs of determinants using single-precision arithmetic. </title> <journal> Algorithmica, </journal> <volume> 17 </volume> <pages> 111-132, </pages> <year> 1997. </year>
Reference-contexts: Designing a specialized implementation for evaluating such predicates can in many cases avoid the use of a general purpose multi-precision software. In the last few years, a number of algorithms have been proposed to reliably evaluate the sign of a determinant <ref> [ABD + 97, BEPP97, BY97, Cla92] </ref>. While these algorithms are general, their implementations have been restricted to determinants of small matrices of order (e.g. up to 6 fi 6) or assume that the matrix entries are restricted based on the machine precision (e.g. 53 bits for IEEE double precision arithmetic).
Reference: [Baj90] <author> C. L. Bajaj. </author> <title> Geometric computations with algebraic varieties of bounded degree. </title> <booktitle> In Proc. 6th Annu. ACM Sympos. Comput. Geom., </booktitle> <pages> pages 148-156, </pages> <year> 1990. </year>
Reference-contexts: These are based on resultants, Grobner bases and root isolation techniques <ref> [Baj90, Buc89, Can88, CGT91, Col75, MC93] </ref>. Most of the earlier work has been on isolating roots of univariate polynomials [CK92].
Reference: [BBP95] <author> I. Biehl, J. Buchmann, and T. Papanikolaou. Lidia: </author> <title> A library for computational number theory. </title> <type> Technical Report SFB 124-C1, </type> <institution> Fachbereich Informatik, Universitt des Saarlandes, </institution> <year> 1995. </year>
Reference-contexts: A reasonable strategy is to compute Hadamard's bound for the given matrix, and use this bound to decide on the number of fields over which the determinant will be taken. This appears to be the approach used in LiDIA <ref> [BBP95] </ref>. An alternative to full reconstruction of the determinant is Newton's iterative reconstruction [MC93] which terminates early for determinants which are much smaller in magnitude than Hadamard's bound predicts. With extremely low probability, Newton's algorithm mistakenly terminates and produces a wrong answer.
Reference: [BEPP97] <author> H. Bronnimann, I. Emiris, V. Pan, and S. Pion. </author> <title> Computing exact geometric predicates using modular arithmetic with single precision. </title> <booktitle> In Proc. 13th Annu. ACM Sympos. Comput. Geom., </booktitle> <pages> pages 174-182, </pages> <year> 1997. </year>
Reference-contexts: Designing a specialized implementation for evaluating such predicates can in many cases avoid the use of a general purpose multi-precision software. In the last few years, a number of algorithms have been proposed to reliably evaluate the sign of a determinant <ref> [ABD + 97, BEPP97, BY97, Cla92] </ref>. While these algorithms are general, their implementations have been restricted to determinants of small matrices of order (e.g. up to 6 fi 6) or assume that the matrix entries are restricted based on the machine precision (e.g. 53 bits for IEEE double precision arithmetic). <p> For a large matrix with a small determinant, Newton's algorithm lets us compute the determinant over as few as two finite fields, instead of several hundred. Recently, a new reconstruction method has been proposed by Bronnimann et al. <ref> [BEPP97] </ref>, where the reconstruction process gives an early exit when the determinant is fairly small. <p> The entries in the matrix determinant are of size O ((N + 1)) bits. We evaluate N matrix determinant signs of size 3; 5; 7; : : : ; 2N 1. Currently, the theoretically-best method to evaluate determinant signs in the literature is by Bronnimann, Emiris et. al <ref> [BEPP97] </ref>. Their method of recursive relaxation of moduli enables them to carry out sign determination by using only floating point computations in single precision. Their method finds the sign of a n fi n determinant in O (n 4 log n) single precision operations. <p> For each value of n, an n fi n matrix was tested, whose largest entry has a bit-length between 300 and 350 bits. The LiDIA time represents a call to bigint matrix::det (). The Relax time is our modification to Sylvain Pion's relaxed-multiplication code <ref> [BEPP97] </ref>. (The modification is to allow arbitrary integers, rather than just 53-bit integers, in the matrix.) The Newton time is the same code as Relax, but using Newton's iterative, probabilistic reconstruction.
Reference: [BKM + 95] <author> Christoph Burnikel, Jochen Konnemann, Kurt Mehlhorn, Ste-fan Naher, Stefan Schirra, and Christian Uhrig. </author> <title> Exact geometric computation in LEDA. </title> <booktitle> In Proc. 11th Annu. ACM Sympos. Com-put. Geom., </booktitle> <pages> pages C18-C19, </pages> <year> 1995. </year>
Reference-contexts: A second approach advocates the use of exact real arithmetic. However, a naive implementation of exact arithmetic can be quite slow and a number of techniques have been proposed in the literature to speed it up. One proposed solution has been to compute certain predicates exactly <ref> [BKM + 95, EM90, FV93, Yap97] </ref>. This may involve computing a few algebraic expressions to a high enough precision to answer queries [FV93, Yap97] or using an algorithm that performs a specific test exactly. <p> These techniques have been appropriate for algorithms that use primitives of low algebraic total degree in two or three dimensions [FvW96]. Devillers and Preparata have investigated the theoretical behavior of some filters [DP97]. In degenerate or nearly degenerate cases, exact arithmetic has to be performed in full. LEDA <ref> [BKM + 95] </ref> has support for exact arithmetic on algebraic numbers. However, it's main limitation is that algebraic numbers can be created only from double precision values and the nth root operation. There is no support to repre-sent algebraic numbers as roots of an arbitrary polynomial. <p> Typically the entries of these matrices are bigints whose magnitude grows quadratically with the degrees of the input equations. Computing the determinant with floating-point arithmetic may produce incorrect results. A floating-point filter, as in LEDA <ref> [BKM + 95] </ref> returns one of +1; 1, or NO IDEA for the sign of the determinant. We have found that this significantly speeds up computation for determinants of small matrices, but usually returns NO IDEA for the larger determinants that arise in higher-degree Sturm computations.
Reference: [BR95] <author> C. Bajaj and A. Royappa. </author> <title> Finite representations of real parametric curves and surfaces. </title> <journal> Internat. J. Comput. Geom. Appl., </journal> <volume> 5 </volume> <pages> 313-326, </pages> <year> 1995. </year>
Reference-contexts: Schewchuck [She96] has described an adaptive and reliable implementation for low dimensional predicates with input entries specified using floating point numbers. Bajaj and Royappa have presented algorithms for parametric curves and surfaces based on finite precision representation <ref> [BR95] </ref>. 2.2 Symbolic Computation A number of algorithms have been proposed in the symbolic computation literature for computation and manipulation of algebraic numbers. These are based on resultants, Grobner bases and root isolation techniques [Baj90, Buc89, Can88, CGT91, Col75, MC93].
Reference: [BT71] <author> J.S. Brown and J.F. Traub. </author> <title> On euclid's algorithm and the theory of subresultant. </title> <journal> Journal of ACM, </journal> <volume> 18(4) </volume> <pages> 505-514, </pages> <year> 1971. </year>
Reference-contexts: This is due to the fact that the size of the coefficients needed in each successive polynomial grows exponentially [Knu81]. This is a fairly well-studied problem in polynomial gcds, and has led to the development of the subresultant polynomial remainder sequence algorithm <ref> [BT71] </ref>). With this approach, the coefficients of the terms of the polynomial sequence can be formulated as the determinant of a submatrix of a Sylvester matrix.
Reference: [Buc89] <author> B. </author> <title> Buchberger. Applications of groebner bases in non-linear computational geometry. </title> <editor> In D. Kapur and J. Mundy, editors, </editor> <booktitle> Geometric Reasoning, </booktitle> <pages> pages 415-447. </pages> <publisher> MIT Press, </publisher> <year> 1989. </year>
Reference-contexts: In many cases, such tests cannot be reduced to computing sign of a single algebraic predicate (such as the sign of a determinant). A number of algorithms have been proposed in the symbolic computation literature to represent and compute high degree algebraic numbers <ref> [Buc89, Can88, Col75, CKL89, Reg95] </ref>. Many of them have been implemented, however, their performance is too slow for most geometric applications. <p> These are based on resultants, Grobner bases and root isolation techniques <ref> [Baj90, Buc89, Can88, CGT91, Col75, MC93] </ref>. Most of the earlier work has been on isolating roots of univariate polynomials [CK92].
Reference: [BY97] <author> H. Bronnimann and M. Yvinec. </author> <title> Efficient exact evaluation of signs of determinants. </title> <booktitle> In Proc. 13th Annu. ACM Sympos. Comput. Geom., </booktitle> <pages> pages 166-173, </pages> <year> 1997. </year>
Reference-contexts: Designing a specialized implementation for evaluating such predicates can in many cases avoid the use of a general purpose multi-precision software. In the last few years, a number of algorithms have been proposed to reliably evaluate the sign of a determinant <ref> [ABD + 97, BEPP97, BY97, Cla92] </ref>. While these algorithms are general, their implementations have been restricted to determinants of small matrices of order (e.g. up to 6 fi 6) or assume that the matrix entries are restricted based on the machine precision (e.g. 53 bits for IEEE double precision arithmetic).
Reference: [Can88] <author> J.F. Canny. </author> <title> The Complexity of Robot Motion Planning. ACM Doctoral Dissertation Award. </title> <publisher> MIT Press, </publisher> <year> 1988. </year>
Reference-contexts: In many cases, such tests cannot be reduced to computing sign of a single algebraic predicate (such as the sign of a determinant). A number of algorithms have been proposed in the symbolic computation literature to represent and compute high degree algebraic numbers <ref> [Buc89, Can88, Col75, CKL89, Reg95] </ref>. Many of them have been implemented, however, their performance is too slow for most geometric applications. <p> These are based on resultants, Grobner bases and root isolation techniques <ref> [Baj90, Buc89, Can88, CGT91, Col75, MC93] </ref>. Most of the earlier work has been on isolating roots of univariate polynomials [CK92]. <p> Techniques using bit-length estimates may, in the worst case, require bit-lengths which are exponential with respect to the degree of the algebraic functions <ref> [Can88, Yu92] </ref>. Techniques based on quantifier elimination [Col75] can also be used to resolve some of the queries arising in geometric algorithms.
Reference: [CGT91] <author> P. Cellini, P. Gianni, and C. Traverso. </author> <title> Algorithms for the shape of semialgebraic sets: A new approach. </title> <booktitle> In Proceedings of Applied Algebra, Algebraic Algorithms and Error-Correcting Codes, </booktitle> <pages> pages 1-18, </pages> <year> 1991. </year> <booktitle> Lecture Notes in Computer Science, </booktitle> <volume> vol. 539, </volume> <publisher> Springer-Verlag. </publisher>
Reference-contexts: These are based on resultants, Grobner bases and root isolation techniques <ref> [Baj90, Buc89, Can88, CGT91, Col75, MC93] </ref>. Most of the earlier work has been on isolating roots of univariate polynomials [CK92].
Reference: [CK92] <author> G.E. Collins and W. Krandick. </author> <title> An efficient algorithm for infallible polynomial complex root isolation. </title> <booktitle> In Proceedings of International Symposium on Symbolic and Algebraic Computation, </booktitle> <pages> pages 189-194, </pages> <address> Berkeley, California, </address> <year> 1992. </year>
Reference-contexts: These are based on resultants, Grobner bases and root isolation techniques [Baj90, Buc89, Can88, CGT91, Col75, MC93]. Most of the earlier work has been on isolating roots of univariate polynomials <ref> [CK92] </ref>. More recently, Milne [Mil92] and Pedersen [Ped91] have extended Sturm sequences to multi-polynomial systems, which, along with resultants or Grobner bases, can be used to isolate roots of multi-variate polynomial systems. In this paper, we present efficient algorithms based on multivariate Sturm sequences to represent algebraic numbers.
Reference: [CKL89] <author> J. Canny, E. Kaltofen, and Y. Laksman. </author> <title> Solving system of nonlinear polynomial equations faster. </title> <booktitle> In Proceedings of International Symposium on Symbolic and Algebraic Computation, </booktitle> <year> 1989. </year>
Reference-contexts: In many cases, such tests cannot be reduced to computing sign of a single algebraic predicate (such as the sign of a determinant). A number of algorithms have been proposed in the symbolic computation literature to represent and compute high degree algebraic numbers <ref> [Buc89, Can88, Col75, CKL89, Reg95] </ref>. Many of them have been implemented, however, their performance is too slow for most geometric applications.
Reference: [Cla92] <author> K. L. Clarkson. </author> <title> Safe and effective determinant evaluation. </title> <booktitle> In Proc. 33rd Annu. IEEE Sympos. Found. Comput. Sci., </booktitle> <pages> pages 387-395, </pages> <year> 1992. </year>
Reference-contexts: Designing a specialized implementation for evaluating such predicates can in many cases avoid the use of a general purpose multi-precision software. In the last few years, a number of algorithms have been proposed to reliably evaluate the sign of a determinant <ref> [ABD + 97, BEPP97, BY97, Cla92] </ref>. While these algorithms are general, their implementations have been restricted to determinants of small matrices of order (e.g. up to 6 fi 6) or assume that the matrix entries are restricted based on the machine precision (e.g. 53 bits for IEEE double precision arithmetic).
Reference: [Col75] <author> G.E. Collins. </author> <title> Quantifier elimination for real closed fields by cylindrical algebraic decomposition. </title> <booktitle> In Lecture Notes in Computer Science, number 33, </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1975. </year>
Reference-contexts: In many cases, such tests cannot be reduced to computing sign of a single algebraic predicate (such as the sign of a determinant). A number of algorithms have been proposed in the symbolic computation literature to represent and compute high degree algebraic numbers <ref> [Buc89, Can88, Col75, CKL89, Reg95] </ref>. Many of them have been implemented, however, their performance is too slow for most geometric applications. <p> These are based on resultants, Grobner bases and root isolation techniques <ref> [Baj90, Buc89, Can88, CGT91, Col75, MC93] </ref>. Most of the earlier work has been on isolating roots of univariate polynomials [CK92]. <p> Techniques using bit-length estimates may, in the worst case, require bit-lengths which are exponential with respect to the degree of the algebraic functions [Can88, Yu92]. Techniques based on quantifier elimination <ref> [Col75] </ref> can also be used to resolve some of the queries arising in geometric algorithms. However, current implementations [Hon92] are too slow for most geometric applications. 2.3 Geometric and Solid Modeling The problem of CSG to boundary representation ("B-rep") conversion has been a fundamental problem in solid modeling [RV85, Hof89].
Reference: [DP97] <author> O. Devillers and F. Preparata. </author> <title> A probabilistic analysis of the power of arithmetic filters. </title> <note> Discrete amd Computational Geometry, 1997. to appear. </note>
Reference-contexts: Fortune and Van Wyk used this approach in the LN package [FV93] and achieved considerable speed-up. These techniques have been appropriate for algorithms that use primitives of low algebraic total degree in two or three dimensions [FvW96]. Devillers and Preparata have investigated the theoretical behavior of some filters <ref> [DP97] </ref>. In degenerate or nearly degenerate cases, exact arithmetic has to be performed in full. LEDA [BKM + 95] has support for exact arithmetic on algebraic numbers. However, it's main limitation is that algebraic numbers can be created only from double precision values and the nth root operation.
Reference: [DSB92] <author> T. K. Dey, K. Sugihara, and C. L. Bajaj. </author> <title> Delaunay triangulations in three dimensions with finite precision arithmetic. </title> <journal> Comput. Aided Geom. Design, </journal> <volume> 9 </volume> <pages> 457-470, </pages> <year> 1992. </year>
Reference-contexts: Many approaches have been proposed in the literature to handle this problem. These include the design of geometric algorithms such that robust implementations can be obtained using only the fixed precision hardware <ref> [DSB92, For95, Hof89, Mil89, Sug89] </ref>. However, designing such algorithms is quite involved and has been restricted to only a few problems. A second approach advocates the use of exact real arithmetic.
Reference: [EM90] <author> H. Edelsbrunner and E. P. Mucke. </author> <title> Simulation of simplicity: a technique to cope with degenerate cases in geometric algorithms. </title> <journal> ACM Trans. Graph., </journal> <volume> 9 </volume> <pages> 66-104, </pages> <year> 1990. </year>
Reference-contexts: A second approach advocates the use of exact real arithmetic. However, a naive implementation of exact arithmetic can be quite slow and a number of techniques have been proposed in the literature to speed it up. One proposed solution has been to compute certain predicates exactly <ref> [BKM + 95, EM90, FV93, Yap97] </ref>. This may involve computing a few algebraic expressions to a high enough precision to answer queries [FV93, Yap97] or using an algorithm that performs a specific test exactly.
Reference: [For95] <author> S. Fortune. </author> <title> Numerical stability of algorithms for 2-d Delaunay triangulations. </title> <journal> Internat. J. Comput. Geom. Appl., </journal> <volume> 5(1) </volume> <pages> 193-213, </pages> <year> 1995. </year>
Reference-contexts: Many approaches have been proposed in the literature to handle this problem. These include the design of geometric algorithms such that robust implementations can be obtained using only the fixed precision hardware <ref> [DSB92, For95, Hof89, Mil89, Sug89] </ref>. However, designing such algorithms is quite involved and has been restricted to only a few problems. A second approach advocates the use of exact real arithmetic.
Reference: [For96] <author> S. Fortune. </author> <title> Robustness issues in geometric algorithms. </title> <editor> In M.C. Lin and D. Manocha, editors, </editor> <booktitle> Applied Computational Geometry, </booktitle> <pages> pages 9-14. </pages> <publisher> Springer-Verlag, </publisher> <year> 1996. </year>
Reference-contexts: The primitives of a CSG tree are typically composed of closed algebraic sets or solids bounded by piecewise algebraic surfaces. However, the problem of robust and accurate computation of the boundary is considered one of the difficult problems in geometric and solid modeling <ref> [For96, KKM97] </ref>. It is important that the computed B-rep be accurate, or at least topologically consistent, and this can be jeopardized by even small amounts of error in the representation of the model or in finite-precision computations.
Reference: [FV93] <author> S. Fortune and C. J. Van Wyk. </author> <title> Efficient exact arithmetic for com-putational geometry. </title> <booktitle> In Proc. 9th Annu. ACM Sympos. Comput. Geom., </booktitle> <pages> pages 163-172, </pages> <year> 1993. </year>
Reference-contexts: A second approach advocates the use of exact real arithmetic. However, a naive implementation of exact arithmetic can be quite slow and a number of techniques have been proposed in the literature to speed it up. One proposed solution has been to compute certain predicates exactly <ref> [BKM + 95, EM90, FV93, Yap97] </ref>. This may involve computing a few algebraic expressions to a high enough precision to answer queries [FV93, Yap97] or using an algorithm that performs a specific test exactly. <p> One proposed solution has been to compute certain predicates exactly [BKM + 95, EM90, FV93, Yap97]. This may involve computing a few algebraic expressions to a high enough precision to answer queries <ref> [FV93, Yap97] </ref> or using an algorithm that performs a specific test exactly. In the latter category, most of the work has been on computing the sign of a multivariate polynomial with integer coefficients or the sign of a determinant of a matrix with integer entries. <p> As a result, they require using software multi-precision arithmetic. However, a naive approach based on use of bignums can be rather expensive in practice and a number of authors have proposed techniques to speed up the paradigm of exact geometric computing. One approach, proposed by Fortune and Van Wyk <ref> [FV93] </ref>, recommends the use of arithmetic filters. These filters safely evaluate a predicate in most cases, in order to avoid performing a more expensive exact computation. Fortune and Van Wyk used this approach in the LN package [FV93] and achieved considerable speed-up. <p> One approach, proposed by Fortune and Van Wyk <ref> [FV93] </ref>, recommends the use of arithmetic filters. These filters safely evaluate a predicate in most cases, in order to avoid performing a more expensive exact computation. Fortune and Van Wyk used this approach in the LN package [FV93] and achieved considerable speed-up. These techniques have been appropriate for algorithms that use primitives of low algebraic total degree in two or three dimensions [FvW96]. Devillers and Preparata have investigated the theoretical behavior of some filters [DP97]. <p> However, their use has been restricted to inputs dealing with linear primitives or low--degree non-linear primitives [FvW96]. For example, the orientation of the intersection point of 3 planes with respect to a fourth plane reduces to computing the sign of a 4 fi 4 determinant <ref> [FV93] </ref>. However, in the non-linear case, the orientation test is equivalent to a quantifier elimination problem over algebraic sets.
Reference: [FvW96] <author> S. Fortune and C. J. van Wyk. </author> <title> Static analysis yields efficient exact integer arithmetic for computational geometry. </title> <journal> ACM Trans. Graph., </journal> <volume> 15(3) </volume> <pages> 223-248, </pages> <month> July </month> <year> 1996. </year>
Reference-contexts: Fortune and Van Wyk used this approach in the LN package [FV93] and achieved considerable speed-up. These techniques have been appropriate for algorithms that use primitives of low algebraic total degree in two or three dimensions <ref> [FvW96] </ref>. Devillers and Preparata have investigated the theoretical behavior of some filters [DP97]. In degenerate or nearly degenerate cases, exact arithmetic has to be performed in full. LEDA [BKM + 95] has support for exact arithmetic on algebraic numbers. <p> Hybrid approaches using a combination of exact arithmetic and floating point arithmetic have been used earlier in computational geometry. However, their use has been restricted to inputs dealing with linear primitives or low--degree non-linear primitives <ref> [FvW96] </ref>. For example, the orientation of the intersection point of 3 planes with respect to a fourth plane reduces to computing the sign of a 4 fi 4 determinant [FV93]. However, in the non-linear case, the orientation test is equivalent to a quantifier elimination problem over algebraic sets.
Reference: [Hof89] <author> C. Hoffmann. </author> <title> Geometric and Solid Modeling. </title> <publisher> Morgan-Kaufmann, </publisher> <address> San Mateo, CA, </address> <year> 1989. </year>
Reference-contexts: Many approaches have been proposed in the literature to handle this problem. These include the design of geometric algorithms such that robust implementations can be obtained using only the fixed precision hardware <ref> [DSB92, For95, Hof89, Mil89, Sug89] </ref>. However, designing such algorithms is quite involved and has been restricted to only a few problems. A second approach advocates the use of exact real arithmetic. <p> The set of geometric algorithms include computing convex hulls, intersections, boundary evaluation of a primitive defined using CSG operations, etc. It is rather difficult to design robust algorithms based on fixed precision arithmetic or iterative numerical methods for such problems <ref> [Hof89, KKM97] </ref>. An accurate algorithm involves computing an exact representation of geometric entities (e.g. vertices, curves or surfaces) and performing geometric queries (e.g. inside/outside tests, which-side or orientation tests) with these representations. <p> However, current implementations [Hon92] are too slow for most geometric applications. 2.3 Geometric and Solid Modeling The problem of CSG to boundary representation ("B-rep") conversion has been a fundamental problem in solid modeling <ref> [RV85, Hof89] </ref>. The primitives of a CSG tree are typically composed of closed algebraic sets or solids bounded by piecewise algebraic surfaces. However, the problem of robust and accurate computation of the boundary is considered one of the difficult problems in geometric and solid modeling [For96, KKM97].
Reference: [Hon92] <author> Hoon Hong. </author> <title> Simple solution formula construction in cylindrical algebraic decomposition based quantifier elimination. </title> <booktitle> In Proceedings of International Symposium on Symbolic and Algebraic Computation, </booktitle> <pages> pages 177-188, </pages> <year> 1992. </year>
Reference-contexts: Techniques using bit-length estimates may, in the worst case, require bit-lengths which are exponential with respect to the degree of the algebraic functions [Can88, Yu92]. Techniques based on quantifier elimination [Col75] can also be used to resolve some of the queries arising in geometric algorithms. However, current implementations <ref> [Hon92] </ref> are too slow for most geometric applications. 2.3 Geometric and Solid Modeling The problem of CSG to boundary representation ("B-rep") conversion has been a fundamental problem in solid modeling [RV85, Hof89]. <p> Most implementations of root isolation have been restricted to univariate polynomials and we are not aware of any extensions to multi-variate systems. The algebraic toolkit, developed by Rege and Canny [Reg95], has support for univariate root isolation algorithms. Most quantifier elimination implementations, (e.g. SAC-2 or the one presented in <ref> [Hon92] </ref>) are quite slow as compared to our implementation. There is considerable work on numeric approximation to algebraic numbers based on homotopy methods [MSW89] or combination of resultant and eigenvalue methods [Man94]. However, they use finite precision arithmetic and cannot guarantee accurate or reliable results.
Reference: [KKM97] <author> J. Keyser, S. Krishnan, and D. Manocha. </author> <title> Efficient and accurate b-rep generation of low degree sculptured solids using exact arithmetic. </title> <booktitle> In ACM/SIGGRAPH Symposium on Solid Modeling, </booktitle> <pages> pages 42-55, </pages> <year> 1997. </year>
Reference-contexts: The set of geometric algorithms include computing convex hulls, intersections, boundary evaluation of a primitive defined using CSG operations, etc. It is rather difficult to design robust algorithms based on fixed precision arithmetic or iterative numerical methods for such problems <ref> [Hof89, KKM97] </ref>. An accurate algorithm involves computing an exact representation of geometric entities (e.g. vertices, curves or surfaces) and performing geometric queries (e.g. inside/outside tests, which-side or orientation tests) with these representations. <p> The primitives of a CSG tree are typically composed of closed algebraic sets or solids bounded by piecewise algebraic surfaces. However, the problem of robust and accurate computation of the boundary is considered one of the difficult problems in geometric and solid modeling <ref> [For96, KKM97] </ref>. It is important that the computed B-rep be accurate, or at least topologically consistent, and this can be jeopardized by even small amounts of error in the representation of the model or in finite-precision computations.
Reference: [Knu81] <author> D. Knuth. </author> <title> The Art of Computer Programming: Seminumerical Algorithms. </title> <publisher> Addison-Wesley, </publisher> <year> 1981. </year>
Reference-contexts: This method can be quite efficient, particularly for lower degree polynomials. For higher degree polynomials, however, Euclid's method can become quite inefficient. This is due to the fact that the size of the coefficients needed in each successive polynomial grows exponentially <ref> [Knu81] </ref>. This is a fairly well-studied problem in polynomial gcds, and has led to the development of the subresultant polynomial remainder sequence algorithm [BT71]). With this approach, the coefficients of the terms of the polynomial sequence can be formulated as the determinant of a submatrix of a Sylvester matrix.
Reference: [Mac02] <author> F.S. </author> <title> Macaulay. On some formula in elimination. </title> <journal> Proceedings of London Mathematical Society, </journal> <volume> 1(33) </volume> <pages> 3-27, </pages> <month> May </month> <year> 1902. </year>
Reference-contexts: One option is to eliminate variables one-by-one with successive Sylvester resultants. The disadvantage here is that this process will amass a large extraneous factor. A more efficient approach is to use the Macaulay resultant by eliminating x, y and z in one step, with no extraneous factors <ref> [Mac02] </ref>. The Macaulay formulation expresses the resultant as a ratio of two determinants. The immediate drawback here is that the order of the matrices grows with the degrees of the input equations.
Reference: [Man94] <author> D. Manocha. </author> <title> Solving systems of polynomial equations. </title> <journal> IEEE Computer Graphics and Applications, </journal> <pages> pages 46-55, </pages> <month> March </month> <year> 1994. </year> <note> Special Issue on Solid Modeling. </note>
Reference-contexts: Most quantifier elimination implementations, (e.g. SAC-2 or the one presented in [Hon92]) are quite slow as compared to our implementation. There is considerable work on numeric approximation to algebraic numbers based on homotopy methods [MSW89] or combination of resultant and eigenvalue methods <ref> [Man94] </ref>. However, they use finite precision arithmetic and cannot guarantee accurate or reliable results.
Reference: [MC92] <author> D. Manocha and J.F. Canny. </author> <title> The implicit representation of rational parametric surfaces. </title> <journal> Journal of Symbolic Computation, </journal> <volume> 13 </volume> <pages> 485-510, </pages> <year> 1992. </year>
Reference-contexts: Rational parametric surfaces in our algorithms are represented with parametric functions and a corresponding domain. We make use of an implicit form of these surfaces when intersecting them. The implicit form can be computed efficiently using implicitization algorithms <ref> [MC92] </ref>. The rational surfaces may be trimmed by algebraic curves in the domain. A rational surface is then represented by a rational function X: &lt; 2 ! &lt; 3 , together with a collection of trimmed regions in &lt; 2 .
Reference: [MC93] <author> D. Manocha and J.F. Canny. </author> <title> Multipolynomial resultant algorithms. </title> <journal> Journal of Symbolic Computation, </journal> <volume> 15(2) </volume> <pages> 99-122, </pages> <year> 1993. </year>
Reference-contexts: These are based on resultants, Grobner bases and root isolation techniques <ref> [Baj90, Buc89, Can88, CGT91, Col75, MC93] </ref>. Most of the earlier work has been on isolating roots of univariate polynomials [CK92]. <p> The Sylvester resultant can be set up as the determinant of a matrix where each term is a polynomial in terms of u. However, this would involve symbolic manipulations, which can be very expensive to perform. Instead, we set up the problem as an interpolation problem <ref> [MC93] </ref>. We use a Vander-monde matrix formulation, where we solve numerical Sylvester resultants to determine the right-hand side of the system. Since we can compute the maximum degree of u in R (u) using Newton's polytope (mixed volumes) method, we know the size of the Vandermonde system. <p> This appears to be the approach used in LiDIA [BBP95]. An alternative to full reconstruction of the determinant is Newton's iterative reconstruction <ref> [MC93] </ref> which terminates early for determinants which are much smaller in magnitude than Hadamard's bound predicts. With extremely low probability, Newton's algorithm mistakenly terminates and produces a wrong answer. <p> Although this discussion has been about roots in one dimension, the same principle holds for intersections in higher dimensions. For example, in two dimensions, the intersection point between two curves can be determined in floating-point by posing it as a generalized eigenvalue problem (see <ref> [MC93] </ref>). The approximations of the intersection points thus obtained can then be used 2 In practice, rather than computing *, we simply choose it so as to minimize damage to the bit-lengths of ff *. to rapidly isolate the exact roots and determine them to whatever precision necessary.
Reference: [Mil89] <author> V. Milenkovic. </author> <title> Double precision geometry: a general technique for calculating line and segment intersections using rounded arithmetic. </title> <booktitle> In Proc. 30th Annu. IEEE Sympos. Found. Comput. Sci., </booktitle> <pages> pages 500-505, </pages> <year> 1989. </year>
Reference-contexts: Many approaches have been proposed in the literature to handle this problem. These include the design of geometric algorithms such that robust implementations can be obtained using only the fixed precision hardware <ref> [DSB92, For95, Hof89, Mil89, Sug89] </ref>. However, designing such algorithms is quite involved and has been restricted to only a few problems. A second approach advocates the use of exact real arithmetic.
Reference: [Mil92] <author> P. S. Milne. </author> <title> On the solutions of a set of polynomial equations. </title> <booktitle> In Symbolic and Numerical Computation for Artificial Intelligence, </booktitle> <pages> pages 89-102, </pages> <year> 1992. </year>
Reference-contexts: These are based on resultants, Grobner bases and root isolation techniques [Baj90, Buc89, Can88, CGT91, Col75, MC93]. Most of the earlier work has been on isolating roots of univariate polynomials [CK92]. More recently, Milne <ref> [Mil92] </ref> and Pedersen [Ped91] have extended Sturm sequences to multi-polynomial systems, which, along with resultants or Grobner bases, can be used to isolate roots of multi-variate polynomial systems. In this paper, we present efficient algorithms based on multivariate Sturm sequences to represent algebraic numbers. <p> We represent solutions (algebraic numbers) of zero-dimensional algebraic systems (vertices or points in geometric applications) using rational boxes. These boxes isolate the algebraic points and can be resolved (the box tightened) in a lazy manner. Isolation and resolution are accomplished using multivariate Sturm sequences <ref> [Mil92] </ref>. In practice, root isolation can be expensive and its cost is directly proportional to the number of Sturm sequence evaluations. To minimize evaluations, we evaluate the points using double precision arithmetic first. The results are verified using Sturm sequences in rational arithmetic. <p> In this section we discuss efficient algorithms for computing with these representations. 5.1 2D Computations Most of the 2D operations involve solving for zeros of two bivariate polynomials. These operations arise frequently in boundary evaluation and Voronoi region computation algorithms. Multivariate Sturm sequences, as described in <ref> [Mil92] </ref>, are used to determine the zeros. <p> Let the maximum degree of s in f (s; t) be m 1 , and the maximum degree of t in f (s; t) be n 1 . Similarly define m 2 and n 2 for g (s; t). We use the following theorem, as given in <ref> [Mil92] </ref> for resultant computation.
Reference: [MSW89] <author> A.P. Morgan, A.J. Sommese, and L.T. Watson. </author> <title> Finding all isolated solutions to polynomial systems using hompack. </title> <journal> ACM Transactions on Mathematical Software, </journal> <volume> 15 </volume> <pages> 93-122, </pages> <year> 1989. </year>
Reference-contexts: Most quantifier elimination implementations, (e.g. SAC-2 or the one presented in [Hon92]) are quite slow as compared to our implementation. There is considerable work on numeric approximation to algebraic numbers based on homotopy methods <ref> [MSW89] </ref> or combination of resultant and eigenvalue methods [Man94]. However, they use finite precision arithmetic and cannot guarantee accurate or reliable results.
Reference: [Ped91] <author> P. Pedersen. </author> <title> Multivariate sturm theory. </title> <booktitle> In Proceedings of AAECC, </booktitle> <pages> pages 318-332. </pages> <publisher> Springer-Verlag, </publisher> <year> 1991. </year>
Reference-contexts: These are based on resultants, Grobner bases and root isolation techniques [Baj90, Buc89, Can88, CGT91, Col75, MC93]. Most of the earlier work has been on isolating roots of univariate polynomials [CK92]. More recently, Milne [Mil92] and Pedersen <ref> [Ped91] </ref> have extended Sturm sequences to multi-polynomial systems, which, along with resultants or Grobner bases, can be used to isolate roots of multi-variate polynomial systems. In this paper, we present efficient algorithms based on multivariate Sturm sequences to represent algebraic numbers.
Reference: [Reg95] <author> Ashutosh Rege. </author> <title> A complete and practical algorithm for geometric theorem proving. </title> <booktitle> In Proc. 11th Annu. ACM Sympos. Comput. Geom., </booktitle> <pages> pages 277-286, </pages> <year> 1995. </year>
Reference-contexts: In many cases, such tests cannot be reduced to computing sign of a single algebraic predicate (such as the sign of a determinant). A number of algorithms have been proposed in the symbolic computation literature to represent and compute high degree algebraic numbers <ref> [Buc89, Can88, Col75, CKL89, Reg95] </ref>. Many of them have been implemented, however, their performance is too slow for most geometric applications. <p> Most implementations of root isolation have been restricted to univariate polynomials and we are not aware of any extensions to multi-variate systems. The algebraic toolkit, developed by Rege and Canny <ref> [Reg95] </ref>, has support for univariate root isolation algorithms. Most quantifier elimination implementations, (e.g. SAC-2 or the one presented in [Hon92]) are quite slow as compared to our implementation.
Reference: [RV85] <author> A.A.G. Requicha and H.B. Voelcker. </author> <title> Boolean operations in solid modeling: boundary evaluation and merging algorithms. </title> <booktitle> Proceedings of the IEEE, </booktitle> <volume> 73(1), </volume> <year> 1985. </year>
Reference-contexts: However, current implementations [Hon92] are too slow for most geometric applications. 2.3 Geometric and Solid Modeling The problem of CSG to boundary representation ("B-rep") conversion has been a fundamental problem in solid modeling <ref> [RV85, Hof89] </ref>. The primitives of a CSG tree are typically composed of closed algebraic sets or solids bounded by piecewise algebraic surfaces. However, the problem of robust and accurate computation of the boundary is considered one of the difficult problems in geometric and solid modeling [For96, KKM97].
Reference: [She96] <author> Jonathan R. Shewchuk. </author> <title> Robust adaptive floating-point geometric predicates. </title> <booktitle> In Proc. 12th Annu. ACM Sympos. Comput. Geom., </booktitle> <pages> pages 141-150, </pages> <year> 1996. </year>
Reference-contexts: While these algorithms are general, their implementations have been restricted to determinants of small matrices of order (e.g. up to 6 fi 6) or assume that the matrix entries are restricted based on the machine precision (e.g. 53 bits for IEEE double precision arithmetic). Schewchuck <ref> [She96] </ref> has described an adaptive and reliable implementation for low dimensional predicates with input entries specified using floating point numbers.
Reference: [Sug89] <author> K. Sugihara. </author> <title> On finite-precision representations of geometric objects. </title> <journal> J. Comput. Syst. Sci., </journal> <volume> 39 </volume> <pages> 236-247, </pages> <year> 1989. </year>
Reference-contexts: Many approaches have been proposed in the literature to handle this problem. These include the design of geometric algorithms such that robust implementations can be obtained using only the fixed precision hardware <ref> [DSB92, For95, Hof89, Mil89, Sug89] </ref>. However, designing such algorithms is quite involved and has been restricted to only a few problems. A second approach advocates the use of exact real arithmetic.
Reference: [Win96] <author> F. Winkler. </author> <title> Polynomial Algorithms in Computer Algebra. </title> <publisher> Springer-Verlag, </publisher> <year> 1996. </year>
Reference-contexts: The total cost of this step (given that Bareiss's version of Gaussian elimination <ref> [Win96] </ref> takes about n 3 =2 operations) is (N + 1) [(N + 1) 2 + (m 1 + n 1 + m 2 + n 2 ) 3 ]: The asymptotic cost clearly depends on the value of N . <p> Therefore, at the end of the entire algorithm the bit lengths of the coefficients of the volume function could be as high as O (2 N+1 ). Factoring out the gcds for these coefficients could potentially be very expensive. However, Bareiss's modification of this method <ref> [Win96] </ref> identifies divisors of rows in the elimination process without actually having to compute gcds. In this method, instead of doubling bit size during each row operation, the increase is by each time. Thus the bit size of the coefficients of the volume function is roughly O ((N + 1)).
Reference: [Yap97] <author> C. Yap. </author> <title> Towards exact geometric computation. </title> <journal> Comput. Geom. Theory Appl., </journal> <volume> 7 </volume> <pages> 3-23, </pages> <year> 1997. </year>
Reference-contexts: A second approach advocates the use of exact real arithmetic. However, a naive implementation of exact arithmetic can be quite slow and a number of techniques have been proposed in the literature to speed it up. One proposed solution has been to compute certain predicates exactly <ref> [BKM + 95, EM90, FV93, Yap97] </ref>. This may involve computing a few algebraic expressions to a high enough precision to answer queries [FV93, Yap97] or using an algorithm that performs a specific test exactly. <p> One proposed solution has been to compute certain predicates exactly [BKM + 95, EM90, FV93, Yap97]. This may involve computing a few algebraic expressions to a high enough precision to answer queries <ref> [FV93, Yap97] </ref> or using an algorithm that performs a specific test exactly. In the latter category, most of the work has been on computing the sign of a multivariate polynomial with integer coefficients or the sign of a determinant of a matrix with integer entries. <p> LEDA [BKM + 95] has support for exact arithmetic on algebraic numbers. However, it's main limitation is that algebraic numbers can be created only from double precision values and the nth root operation. There is no support to repre-sent algebraic numbers as roots of an arbitrary polynomial. Yap <ref> [Yap97] </ref> has also advocated the use of exact arithmetic on algebraic numbers and shown that it is useful for a number of geometric algorithms. Many authors have proposed algorithms to reliably evaluate various predicates. In most cases, these predicates correspond to sign of an algebraic expression or a determinant.
Reference: [Yu92] <author> J. Yu. </author> <title> Exact arithmetic solid modeling. </title> <type> PhD thesis, </type> <institution> Purdue University, </institution> <year> 1992. </year>
Reference-contexts: Techniques using bit-length estimates may, in the worst case, require bit-lengths which are exponential with respect to the degree of the algebraic functions <ref> [Can88, Yu92] </ref>. Techniques based on quantifier elimination [Col75] can also be used to resolve some of the queries arising in geometric algorithms.
References-found: 42

