URL: http://www.cs.wustl.edu/~schmidt/C++-report-col12.ps.gz
Refering-URL: http://www.cs.wustl.edu/~schmidt/resume.html
Root-URL: http://www.cs.wustl.edu
Email: schmidt@cs.wustl.edu vinoski@iona.com  
Title: Object Interconnections Using the Portable Object Adapter for Transient and Persistent CORBA Objects (Column 12)  
Author: Douglas C. Schmidt Steve Vinoski 
Note: This column will appear in the April, 1998 issue of the SIGS C++ Report magazine.  
Address: St. Louis, MO 63130 60 Aberdeen Ave., Cambridge, MA 02138  
Affiliation: Department of Computer Science IONA Technologies, Inc. Washington University,  
Abstract-found: 0
Intro-found: 1
Reference: [1] <institution> Object Management Group, </institution> <note> Specification of the Portable Object Adapter (POA), OMG Document orbos/97-05-15 ed., </note> <month> June </month> <year> 1997. </year>
Reference-contexts: 1 Introduction In this column, we continue our presentation of the new OMG Portable Object Adapter (POA) <ref> [1] </ref>. The POA was adopted by the OMG in mid-1997 as a replacement for the Basic Object Adapter (BOA), which was the original CORBA object adapter. As we described in our last column, the BOA was a major source of portability problems for CORBA applications due to its imprecise specification. <p> CORBA::ORB_var orb = CORBA::ORB_init (argc, argv); // Obtain an object reference for // the Root POA. CORBA::Object_var obj = orb-&gt;resolve_initial_references ("RootPOA"); PortableServer::POA_var poa = POA::_narrow (obj); // (1) Create the desired POA policies. CORBA::PolicyList policies; policies.length (2); policies [0] = poa-&gt;create_lifespan_policy (PortableServer::PERSISTENT); policies <ref> [1] </ref> = poa-&gt;create_id_assignment_policy (PortableServer::USER_ID); // (2) Create a POA for persistent objects. PortableServer::POAManager_var poa_mgr = poa-&gt;the_POAManager (); poa = poa-&gt;create_POA ("persistent", poa_mgr, policies); // (3) Create an ObjectId. PortableServer::ObjectId_var oid = string_to_ObjectId ("my_object"); // Create a servant to service // client requests. <p> To create the object reference, let's change the code near our call to activate object with id near comment (4) as follows: PortableServer::ObjectId_var oid = string_to_ObjectId ("my_object"); // Check command-line arguments to see if // we're creating the object or reactivating it. if (argc == 2 && strcmp (argv <ref> [1] </ref>, "create") == 0) - // Create an object reference. CORBA::Object_var obj = poa-&gt;create_reference_with_id (oid, "IDL:Null:1.0"); // Stringify it and write it to stdout. CORBA::String_var s = orb-&gt;object_to_string (obj); cout &lt;< s.in () &lt;< endl; - else - // Create a servant to service // client requests.
Reference: [2] <author> D. C. Schmidt and S. Vinoski, </author> <title> Object Interconnections: Object Adapters: Concepts and Terminology, </title> <journal> C++ Report, </journal> <volume> vol. 11, </volume> <month> November/December </month> <year> 1997. </year>
Reference-contexts: The POA specification is rather daunting, so we can't cover all the features and use-cases in a single column. Therefore, we'll start by explaining the usage of several POA policies described in our previous column <ref> [2] </ref>. Our primary focus in this column will be on the POA features that support transient and persistent CORBA objects.
Reference: [3] <author> E. Gamma, R. Helm, R. Johnson, and J. Vlissides, </author> <title> Design Patterns: Elements of Reusable Object-Oriented Software. </title> <address> Reading, MA: </address> <publisher> Addison-Wesley, </publisher> <year> 1995. </year>
Reference-contexts: An object reference for the Root POA is obtained by invoking resolve initial references on the ORB. This operation provides a miniature Naming service that bootstraps a CORBA application with essential object references. Object references obtained from resolve initial references can be references to per-ORB Singleton <ref> [3] </ref> services, such as the Root POA or Interface Repository. Applications can also obtain references to services from which other object references can be obtained, such as the Naming Service or the Trader Service [4].
Reference: [4] <institution> Object Management Group, </institution> <month> CORBAServices: </month> <title> Common Object Services Specification, </title> <note> Revised Edition, </note> <editor> 97-12-02 ed., </editor> <month> Nov. </month> <year> 1997. </year>
Reference-contexts: Object references obtained from resolve initial references can be references to per-ORB Singleton [3] services, such as the Root POA or Interface Repository. Applications can also obtain references to services from which other object references can be obtained, such as the Naming Service or the Trader Service <ref> [4] </ref>. Since the return value of resolve initial references is typed as CORBA::Object, the result must be narrowed to the desired type, which in this case is PortableServer::POA.
Reference: [5] <author> A. Gokhale and D. C. Schmidt, </author> <title> Evaluating the Performance of Demultiplexing Strategies for Real-time CORBA, </title> <booktitle> in Proceedings of GLOBECOM '97, </booktitle> <address> (Phoenix, AZ), </address> <publisher> IEEE, </publisher> <month> Novem-ber </month> <year> 1997. </year>
Reference-contexts: Ultimately, the POA uses the active object map to demultiplex incoming CORBA requests to the appropriate servant <ref> [5] </ref>, so that the servant's designated C++ method can be dispatched automatically. The type of the object reference returned by this is determined by the most-derived IDL interface supported by the servant.
Reference: [6] <author> D. Schmidt and S. Vinoski, </author> <title> Distributed Callbacks and Decou-pled Communication in CORBA, </title> <journal> C++ Report, </journal> <volume> vol. 8, </volume> <month> October </month> <year> 1996. </year>
Reference-contexts: This property must hold even if the server program were restarted on the same host using the same communications port to receive requests. Transient CORBA objects can be useful for certain things like callback objects, such as the event notification service described in <ref> [6] </ref>. In this case, once the process goes away, receiving a callback or event notification is probably no longer a necessity. However, many CORBA applications must be able to exit and then later start back up.
References-found: 6

