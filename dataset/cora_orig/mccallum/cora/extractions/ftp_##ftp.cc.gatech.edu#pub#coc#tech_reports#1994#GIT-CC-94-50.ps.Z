URL: ftp://ftp.cc.gatech.edu/pub/coc/tech_reports/1994/GIT-CC-94-50.ps.Z
Refering-URL: http://www.cs.gatech.edu/tech_reports/index.94.html
Root-URL: 
Title: Integrating Visualization Support Into Distributed Computing Systems  
Author: Brad Topol John T. Stasko Vaidy Sunderam 
Address: Atlanta, Georgia 30332-0280.  Atlanta, GA, 30322  
Affiliation: College of Computing, Georgia Institute of Technology,  Department of Math and Computer Science, Emory University,  
Note: Author's address:  Author's address:  
Date: October 10, 1994  
Pubnum: GIT-CC-94/50  
Abstract: Visualization and animation tools may become extremely important aids in the understanding, verification, and performance tuning of parallel computations. Presently, however, the use of visualization has had only a limited use for enhancing parallel computation. We hypothesize that one of the primary reasons for the limited use of visualization tools in parallel program development is the difficulty of acquiring the information necessary to drive the visual display. Our approach to this impediment focuses on integrating visualization support directly into a distributed computing system. Central to this integration is the addition of a logical clock that prevents the timestamps of events from violating causality. The implementation requires the "piggybacking" of a negligible amount of extra header information on system messages and the impact on performance is minimal. This results in a system that produces useful visualizations with no extra effort required by the applications programmer. Also integrated into the distributed system is support which simplifies the creation of programmer-defined, application-specific visualizations, unique to each new parallel program developed. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Adam Beguelin, Jack Dongarra, Al Geist, and Vaidy Sunderam. </author> <title> Visualization and debugging in a heterogeneous environment. </title> <journal> Computer, </journal> <volume> 26(6) </volume> <pages> 88-95, </pages> <month> June </month> <year> 1993. </year>
Reference-contexts: This is a clear advantage over relinking to special libraries or adding extra header files as necessary in systems such as Xab <ref> [1] </ref>. Every effort is made to insure that support needed for visualization does not hinder or delay the application programmer. It simply should be there on demand. 4.3 Synchronization Modifications The Conch system provides common synchronization primitives such as barriers, Ada style rendezvous, and the wait-event construct.
Reference: [2] <author> Adam Beguelin and Erik Seligman. </author> <title> Causality-preserving timestamps in distributed programs. </title> <type> Technical Report CMU-CS-93-167, </type> <institution> Carnegie Mellon University, </institution> <address> Pittsburgh, PA, </address> <month> June </month> <year> 1993. </year>
Reference-contexts: Visualizations that use trace data filled with causality violations like this clearly will be misleading. Creative techniques used during postprocessing such as those used in <ref> [2] </ref> can produce makeshift solutions to some impediments that visualizers face. Nonetheless, this is yet another example of how visualizers must expend excessive effort to solve problems that can be avoided with proper system support. <p> This is a well known method for providing timestamps that preserve causality in a distributed system, and we used it to add logical clock times-tamps to the Conch event traces. As alluded to earlier and discussed thoroughly in <ref> [2] </ref>, if various system clocks are used for timestamping, lack of synchronization in the clocks will result in obvious causality violations. <p> This differs substantially from the approach of having an external monitoring tool attempt to implement the logical clock, which can be problematic and adds computing overhead better directed to other tasks. For example, Xab <ref> [2] </ref>, a monitoring tool for PVM programs, implements a similar logical clock in both its online monitoring and postprocessing modes. In the online monitoring mode, Xab logical timestamping support for the PVM barrier synchronization primitive could not be done efficiently without having the PVM developers modify the system directly. <p> This approach is similar to our notion of providing 14 support for application-specific views. Both allow the user to decide what and how things are visualized. ChaosMON requires significantly more programmer involvement to utilize the views, however. Xab <ref> [2] </ref> provides support for program understanding and debugging. Xab monitors PVM applications by providing macros for the standard PVM library routines. The macros generate trace information, and then call the normal PVM functions.
Reference: [3] <author> Doug Bowman, Adam Ferrari, Melisa Kelley, Brian Schmidt, Brad Topol, and Vaidy Sunderam. </author> <title> The Conch network concurrent programming system. </title> <type> Technical report, </type> <institution> Emory University, </institution> <address> Atlanta, GA, </address> <month> January </month> <year> 1994. </year> <month> 15 </month>
Reference-contexts: Our visualization framework used POLKA, an object-oriented software visualization methodology and library. 3.1 Distributed Computing System|Conch The Conch system <ref> [3] </ref> is an experimental heterogeneous network computing system. Like its predecessors, Conch is a framework for parallel distributed computing, allowing a network of Unix workstations to function as a single parallel computer. <p> Log files are differentiated by appending the processing element's process identifier to the user provided filename. It is also possible to designate all these command-line parameters by using the CONCHENV environment variable, a Conch feature more thoroughly discussed in <ref> [3] </ref>. Once a Conch application has terminated execution, the programmer can use a tool, viz-trace, we have created that reads the trace files and produces the visualization.
Reference: [4] <author> G.A. Geist et al. </author> <title> PICL:A Portable Instrumented Communication Library, C reference manual. </title> <type> Technical Report ORNL/TM-11130, </type> <institution> Oak Ridge National Lab., Oak Ridge, Tenn., </institution> <year> 1990. </year>
Reference-contexts: Therefore, the routine produces the trace event information necessary for visualization automatically, instead of the parallel application being annotated by hand. A similar approach is used by the ParaGraph [5] system, as its information is derived from PICL <ref> [4] </ref>, a portable instrumentation communication interface. Our approach goes one step further, however. By truly integrating into the system itself, all system primitives can provide automatic annotation generation. This is in contrast to PICL, which can only provide annotations for the generic communication primitives that it supports. <p> The ParaGraph [5] system, perhaps the best know application of visualization to parallel programming, provides general purpose visualization support for performance analysis and tuning. ParaGraph utilizes the PICL <ref> [4] </ref> trace file format. In order to use ParaGraph, a parallel program must use the PICL communication facilities, or emulate their trace format. This implies that a user may only visualize information that exists in the PICL trace files.
Reference: [5] <author> Michael T. Heath and Jennifer A. Etheridge. </author> <title> Visualizing the performance of parallel programs. </title> <journal> IEEE Software, 8(5):29 -39, </journal> <month> September </month> <year> 1991. </year>
Reference-contexts: Therefore, the routine produces the trace event information necessary for visualization automatically, instead of the parallel application being annotated by hand. A similar approach is used by the ParaGraph <ref> [5] </ref> system, as its information is derived from PICL [4], a portable instrumentation communication interface. Our approach goes one step further, however. By truly integrating into the system itself, all system primitives can provide automatic annotation generation. <p> We feel that views which only portray a serialization of a concurrent program execution fail to convey critical information to the viewer. 6 Related Work A fairly substantial amount of work has been done in the visualization of parallel programs [7]. The ParaGraph <ref> [5] </ref> system, perhaps the best know application of visualization to parallel programming, provides general purpose visualization support for performance analysis and tuning. ParaGraph utilizes the PICL [4] trace file format. In order to use ParaGraph, a parallel program must use the PICL communication facilities, or emulate their trace format.
Reference: [6] <author> Carol Kilpatrick and Karsten Schwan. </author> <title> ChaosMON-application-specific monitoring and display of performance information for parallel and distributed systems. </title> <journal> SIGPLAN Notices, </journal> <volume> 26(12) </volume> <pages> 57-67, </pages> <month> December </month> <year> 1991. </year> <booktitle> (Proceedings of the ACM/ONR '91 Workshop on Parallel and Distributed Debugging). </booktitle>
Reference-contexts: Pablo primarily derives its event tracing by instrumenting source code. A graphical interface is provided for the user to specify instrumentation points. Pablo provides a data analysis environment for reducing, analyzing, and presenting performance data, and is portable to various massively parallel systems. ChaosMON <ref> [6] </ref> provides language support that allows for an easy mapping of performance information to user built display objects. This approach is similar to our notion of providing 14 support for application-specific views. Both allow the user to decide what and how things are visualized.
Reference: [7] <author> Eileen Kraemer and John T. Stasko. </author> <title> The visualization of parallel systems: An overview. </title> <journal> Journal of Parallel and Distributed Computing, </journal> <volume> 18(2) </volume> <pages> 105-117, </pages> <month> June </month> <year> 1993. </year>
Reference-contexts: Until now, however, the use of visualization has had only a limited impact on concurrent program understanding, verification, and performance tuning. The systems that have been created are mostly research prototypes and few have achieved wide usage <ref> [7] </ref>. Visualization's limited impact is an enigma. It is clear that an appropriate picture or image can convey the same amount of information as hundreds or thousands of lines of text [15]. <p> We feel that views which only portray a serialization of a concurrent program execution fail to convey critical information to the viewer. 6 Related Work A fairly substantial amount of work has been done in the visualization of parallel programs <ref> [7] </ref>. The ParaGraph [5] system, perhaps the best know application of visualization to parallel programming, provides general purpose visualization support for performance analysis and tuning. ParaGraph utilizes the PICL [4] trace file format.
Reference: [8] <author> Eileen Kraemer and John T. Stasko. </author> <title> Toward flexible control of the temporal mapping from concurrent program events to animations. </title> <booktitle> In Proceedings of the 8th International Parallel Processing Symposium (IPPS '94), </booktitle> <pages> pages 902-908, </pages> <address> Cancun, Mexico, </address> <month> April </month> <year> 1994. </year>
Reference-contexts: The logical times-tamps guarantee that the visualization is representative of a plausible ordering of events, but other plausible orderings may exist also. In development, as described in <ref> [8] </ref>, is a tool that "choreographs" the visualization of many of the different possible plausible orderings. The logical clock is a prime example of the benefits of our system integrated approach; implementing a logical clock in the system was relatively straightforward.
Reference: [9] <author> Leslie Lamport. </author> <title> Time, clocks, and the ordering of events in a distributed system. </title> <journal> Communications of the ACM, </journal> <volume> 21(7) </volume> <pages> 558-565, </pages> <month> July </month> <year> 1978. </year>
Reference-contexts: Ideally, each program event would be timestamped from a perfectly synchronized real-time global clock. This is clearly unrealistic. What is desirable, however, is a logical clock as described in <ref> [9] </ref> that provides causality ordered timestamps needed to produce accurate visualizations. Also desirable is the addition of a real-time local clock timestamp to provide information for performance visualization. Our approach provides both these alternatives. These requirements have driven our program visualization support within a recently developed distributed system. <p> The following are more detailed descriptions of some of the more interesting and challenging Conch system modifications that were necessary for meeting the requirements posed earlier. 4.1 Logical Clock One fundamental system enhancement made to Conch was the addition of a Lamport logical clock capability as described in <ref> [9] </ref>. This is a well known method for providing timestamps that preserve causality in a distributed system, and we used it to add logical clock times-tamps to the Conch event traces.
Reference: [10] <author> A. Malony, B. Mohr, P. Beckman, D. Gannon, S. Yang, and Bodin F. </author> <title> Performance analysis of pC++: A portable data-parallel programming system for scalable parallel computers. </title> <booktitle> In Proceedings of the 8th International Parallel Processing Symposium (IPPS '94), </booktitle> <pages> pages 75-84, </pages> <address> Cancun, Mexico, </address> <month> April </month> <year> 1994. </year>
Reference: [11] <author> Daniel A. Reed, Ruth A. Aydt, Tara M. Madhyastha, Roger J. Noe, Kieth A. Shields, and Bradley W. Schwartz. </author> <title> An overview of the Pablo performance analysis environment. </title> <type> Technical report, </type> <institution> University of Illinois, Urbana, Illinois 61801, </institution> <month> November </month> <year> 1992. </year>
Reference-contexts: First, for a parallel application to be visualized, it must be annotated to provide information to "drive" the visualization. One method of supplying annotation is to directly modify a parallel application. For large applications, the modifications can be extensive. Environments such as PABLO <ref> [11] </ref> provide a graphical interface for interactively specifying annotations, but extra effort is still required from the application programmer. Our approach minimizes the need for annotation by having the distributed system automatically generate the annotation whenever possible. This is performed by integrating annotation support directly into the distributed system primitives. <p> Further, with our system integrated approach, we are in a strategic position to develop system-specific visualizations. As systems become more complex, these can be crucial to discerning what is happening in the distributed system. The Pablo <ref> [11] </ref> performance environment also provides visualization support for performance analysis and tuning. Pablo primarily derives its event tracing by instrumenting source code. A graphical interface is provided for the user to specify instrumentation points.
Reference: [12] <author> John T. Stasko and Eileen Kraemer. </author> <title> A methodology for building application-specific visualizations of parallel programs. </title> <journal> Journal of Parallel and Distributed Computing, </journal> <volume> 18(2) </volume> <pages> 258-264, </pages> <month> June </month> <year> 1993. </year>
Reference-contexts: serve as proof of concept, but it should benefit future users of the system in real parallel program development. 3.2 Visualization System|POLKA The POLKA system is an object-oriented software visualization and animation methodology that includes high-level graphical object and animation primitives particularly useful for building animations of concurrent program executions <ref> [12] </ref>. POLKA provides color, 2-D animation and is implemented on top of the X Window System and Motif. Individual windows created with POLKA, called Views, can provide different, unique presentations of the program being visualized. Each View is composed of a set of routines that are called Scenes in POLKA.
Reference: [13] <author> V.S. Sunderam. </author> <title> PVM: A framework for parallel distributed computing. </title> <journal> Concurrency: Practice & Experience, </journal> <volume> 2(4) </volume> <pages> 315-339, </pages> <month> December </month> <year> 1990. </year>
Reference-contexts: Conch provides features such as custom configurable machine topologies, fault tolerance, and a shared system-user context that allows the system to execute with less system overhead. The Conch system is based on two popular and established high performance concurrent computing systems. The first of these, PVM <ref> [13] </ref>, is well regarded as a leading system for writing distributed and parallel applications. PVM is in widespread use and is considered by many to be the de facto standard for network computing.
Reference: [14] <author> V.S. Sunderam and Vernon J. Rego. </author> <title> EcliPSe: A system for high performance concurrent simulation. </title> <journal> Software: Practice & Experience, </journal> <volume> 21(11) </volume> <pages> 1289-1219, </pages> <month> November </month> <year> 1991. </year>
Reference-contexts: The first of these, PVM [13], is well regarded as a leading system for writing distributed and parallel applications. PVM is in widespread use and is considered by many to be the de facto standard for network computing. The second influence on the development of Conch is EcliPSe <ref> [14] </ref>, a system used mainly for high performance concurrent simulation. The following is a brief introduction to the facilities provided by Conch. 3.1.1 Virtual Machine Configuration One of the first choices a Conch application programmer must make is the type of virtual machine to be configured.
Reference: [15] <author> Edward R. Tufte. </author> <title> Envisioning Information. </title> <publisher> Graphics Press, </publisher> <address> Cheshire, CT, </address> <year> 1990. </year>
Reference-contexts: The systems that have been created are mostly research prototypes and few have achieved wide usage [7]. Visualization's limited impact is an enigma. It is clear that an appropriate picture or image can convey the same amount of information as hundreds or thousands of lines of text <ref> [15] </ref>. Certainly, computer graphics hardware and software environments have matured and are now widely available, so they are not culpable. We hypothesize that one of the primary difficulties limiting the impact of visualization on parallel computation is the difficulty of acquiring the information necessary to drive the visualization display.
Reference: [16] <author> S.J. Turner and Cai W. </author> <title> The `logical clocks' approach to the visualization of parallel programs. </title> <editor> In G. Kotsis and G. Haring, editors, </editor> <booktitle> Performance Measurement and Visualization of Parallel Programs, </booktitle> <pages> pages 45-66. </pages> <publisher> Elsevier, </publisher> <year> 1993. </year> <month> 16 </month>
Reference-contexts: Our approach differs from Xab's as we have integrated all our necessary support directly into the distributed system. This allows us to cleanly provide novel features such as using logical event timestamping and the choice of monitoring support options at execution time. Turner et al <ref> [16] </ref> also utilize logical clocks to visualize parallel programs. Their approach is similar to Xab's in that an external monitoring process is responsible for implementing logical clocks for all processes. Again, our approach differs as there is no need for a centralized monitor that all nodes must interact with.
References-found: 16

