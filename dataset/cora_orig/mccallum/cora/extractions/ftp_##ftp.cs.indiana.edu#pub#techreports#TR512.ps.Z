URL: ftp://ftp.cs.indiana.edu/pub/techreports/TR512.ps.Z
Refering-URL: http://www.cs.indiana.edu/ftp/techreports/index.html
Root-URL: http://www.cs.indiana.edu
Title: Efficient Computation via Incremental Computation  
Author: Yanhong A. Liu 
Keyword: caching, incremental computation, incremental programs, incrementalization, program analysis, program optimization, program transformation, programming environments, reuse  
Date: July 1998  
Abstract: Incremental computation takes advantage of repeated computations on inputs that differ slightly from one another, computing each output efficiently by exploiting the previous output. This paper gives an overview of a general and systematic approach to incrementalization. Given a program f and an operation , the approach yields an incremental program that computes f (x y) efficiently by using the result of f (x), the intermediate results of f (x), and auxiliary information about f (x) that can be inexpensively maintained. Since every non-trivial computation proceeds by iteration or recursion, the approach can be used for achieving efficient computation in general, by computing each iteration incrementally using an appropriate incremental program. This method has been applied to problems in interactive systems, optimizing compilers, transformational programming, etc. The design and implementation of a prototype system, CACHET, for deriving incremental programs is also described. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> M. Abadi, B. Lampson, and J.-J. Levy. </author> <title> Analysis and caching of dependencies. </title> <booktitle> In Proceedings of the 1996 ACM SIGPLAN International Conference on Functional Programming. ACM, </booktitle> <address> New York, </address> <month> May </month> <year> 1996. </year>
Reference-contexts: The second category is called incremental execution frameworks. The idea is to allow different application programs to run in such a framework without deriving explicit incremental 2 algorithms. These are general methods for incremental problems. Examples are incremental attribute evaluation framework [14], function caching [12], lambda reduction <ref> [1] </ref>, traditional partial evaluation [16], change detailing network [17], program abstraction [4], etc. Each such framework gives some language for describing application programs and, in particular, fixes the classes of input changes that the framework can handle, and uses a particular incremental algorithm to handle the input changes.
Reference: [2] <author> F. E. Allen, J. Cocke, and K. Kennedy. </author> <title> Reduction of operator strength. </title> <editor> In S. S. Muchnick and N. D. Jones, editors, </editor> <booktitle> Program Flow Analysis, </booktitle> <pages> pages 79-101. </pages> <publisher> Prentice-Hall, </publisher> <address> Englewood Cliffs, N.J., </address> <year> 1981. </year>
Reference-contexts: Indeed, many methods for program efficiency improvement in optimizing compilers, transformational programming, and programming methodology do derive efficient incremental programs and use them in computing each iteration of an overall computation. Examples are strength reduction in optimizing compilers <ref> [2] </ref>, finite differencing in transformational programming [11, 15], and maintaining loop invariance in programming methodology [3]. Our work falls into this category. While existing work either handles only limited primitive operators or gives only high-level strategies, our work is more general and systematic.
Reference: [3] <editor> D. Gries. </editor> <booktitle> The Science of Programming. </booktitle> <publisher> Springer-Verlag, </publisher> <address> New York, </address> <year> 1981. </year> <pages> 14 15 </pages>
Reference-contexts: Examples are strength reduction in optimizing compilers [2], finite differencing in transformational programming [11, 15], and maintaining loop invariance in programming methodology <ref> [3] </ref>. Our work falls into this category. While existing work either handles only limited primitive operators or gives only high-level strategies, our work is more general and systematic.
Reference: [4] <author> R. Hoover. Alphonse: </author> <title> Incremental computation as a programming abstraction. </title> <booktitle> In Proceedings of the ACM SIGPLAN '92 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 261-272. </pages> <publisher> ACM, </publisher> <address> New York, </address> <month> June </month> <year> 1992. </year>
Reference-contexts: These are general methods for incremental problems. Examples are incremental attribute evaluation framework [14], function caching [12], lambda reduction [1], traditional partial evaluation [16], change detailing network [17], program abstraction <ref> [4] </ref>, etc. Each such framework gives some language for describing application programs and, in particular, fixes the classes of input changes that the framework can handle, and uses a particular incremental algorithm to handle the input changes.
Reference: [5] <author> Y. A. Liu. CACHET: </author> <title> An interactive, incremental-attribution-based program transformation system for deriving incremental programs. </title> <booktitle> In Proceedings of the 10th Knowledge-Based Software Engineering Conference, </booktitle> <pages> pages 19-26. </pages> <publisher> IEEE CS Press, Los Alamitos, </publisher> <address> Calif., </address> <month> Nov. </month> <year> 1995. </year>
Reference-contexts: The incrementalization approach has a spectrum of applications, from compiler optimizations to programming methodologies: * fully automatic for optimizing compilers; * semi-automatic in transformational programming; * off-line as methodology for program efficiency improvement and deriving incremental algorithms. For example, our semi-automatic implementation, CACHET <ref> [5] </ref>, can be used for transformational programming; an automatic version is being implemented for use by a software development group at Motorola. Also, the optimization of aggregate array computations [6] is automatic and is being implemented for use in optimizing compilers. CACHET: A prototype implementation. <p> Also, the optimization of aggregate array computations [6] is automatic and is being implemented for use in optimizing compilers. CACHET: A prototype implementation. CACHET is a semi-automatic supporting tool for deriving incremental programs <ref> [5] </ref>. It is implemented using the Synthesizer Generator [14], a system for generating language-based editing environments. Compared with other program transformation systems, such as KIDS [15] and APTS [10], CACHET benefits from many existing techniques and tools built into the Synthesizer Generator, in particular, for generating attribute-grammar-based programming environments.
Reference: [6] <author> Y. A. Liu and S. D. Stoller. </author> <title> Loop optimization for aggregate array computations. </title> <booktitle> In Proceedings of the IEEE 1998 International Conference on Computer Languages, </booktitle> <pages> pages 262-271. </pages> <publisher> IEEE CS Press, Los Alamitos, </publisher> <address> Calif., </address> <month> May </month> <year> 1998. </year>
Reference-contexts: Even though we have presented the approach and examples using programs written in a simple functional language, the underlying principle of incrementalization is general and applies to other languages as well. For example, we have applied the approach to incrementalize loops and aggregate array computations <ref> [6] </ref>. The incrementalization approach has a spectrum of applications, from compiler optimizations to programming methodologies: * fully automatic for optimizing compilers; * semi-automatic in transformational programming; * off-line as methodology for program efficiency improvement and deriving incremental algorithms. <p> For example, our semi-automatic implementation, CACHET [5], can be used for transformational programming; an automatic version is being implemented for use by a software development group at Motorola. Also, the optimization of aggregate array computations <ref> [6] </ref> is automatic and is being implemented for use in optimizing compilers. CACHET: A prototype implementation. CACHET is a semi-automatic supporting tool for deriving incremental programs [5]. It is implemented using the Synthesizer Generator [14], a system for generating language-based editing environments.
Reference: [7] <author> Y. A. Liu, S. D. Stoller, and T. Teitelbaum. </author> <title> Discovering auxiliary information for incremental computation. </title> <booktitle> In Conference Record of the 23rd Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 157-170. </pages> <publisher> ACM, </publisher> <address> New York, </address> <month> Jan. </month> <year> 1996. </year>
Reference-contexts: Our work is the first in which these three aspects are explicitly identified and put into a general framework that unifies existing methods and techniques. The approach is modular, systematic, and powerful. Details of the analysis and transformations for P1, P2, and P3 are described in separate papers <ref> [9, 8, 7] </ref>. These papers also contain detailed as well as additional examples. Even though we have presented the approach and examples using programs written in a simple functional language, the underlying principle of incrementalization is general and applies to other languages as well.
Reference: [8] <author> Y. A. Liu, S. D. Stoller, and T. Teitelbaum. </author> <title> Static caching for incremental computation. </title> <journal> ACM Trans. Program. Lang. Syst., </journal> <volume> 20(3), </volume> <month> May </month> <year> 1998. </year>
Reference-contexts: Our work is the first in which these three aspects are explicitly identified and put into a general framework that unifies existing methods and techniques. The approach is modular, systematic, and powerful. Details of the analysis and transformations for P1, P2, and P3 are described in separate papers <ref> [9, 8, 7] </ref>. These papers also contain detailed as well as additional examples. Even though we have presented the approach and examples using programs written in a simple functional language, the underlying principle of incrementalization is general and applies to other languages as well.
Reference: [9] <author> Y. A. Liu and T. Teitelbaum. </author> <title> Systematic derivation of incremental programs. </title> <journal> Sci. Comput. Program., </journal> <volume> 24(1) </volume> <pages> 1-39, </pages> <month> Feb. </month> <year> 1995. </year>
Reference-contexts: Our work is the first in which these three aspects are explicitly identified and put into a general framework that unifies existing methods and techniques. The approach is modular, systematic, and powerful. Details of the analysis and transformations for P1, P2, and P3 are described in separate papers <ref> [9, 8, 7] </ref>. These papers also contain detailed as well as additional examples. Even though we have presented the approach and examples using programs written in a simple functional language, the underlying principle of incrementalization is general and applies to other languages as well.
Reference: [10] <author> R. Paige. </author> <title> Viewing a program transformation system at work. </title> <editor> In M. Hermenegildo and J. Penjam, editors, </editor> <booktitle> Proceedings of Joint 6th International Conference on Programming Languages: Implementations, Logics and Programs and 4th International Conference on Algebraic and Logic Programming, volume 844 of Lecture Notes in Computer Science, </booktitle> <pages> pages 5-24. </pages> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <month> Sept. </month> <year> 1994. </year>
Reference-contexts: CACHET: A prototype implementation. CACHET is a semi-automatic supporting tool for deriving incremental programs [5]. It is implemented using the Synthesizer Generator [14], a system for generating language-based editing environments. Compared with other program transformation systems, such as KIDS [15] and APTS <ref> [10] </ref>, CACHET benefits from many existing techniques and tools built into the Synthesizer Generator, in particular, for generating attribute-grammar-based programming environments. We can easily use many program manipulation facilities|lexical analysis, parsing, semantic analysis, pretty printing, interactive editing, etc.
Reference: [11] <author> R. Paige and S. Koenig. </author> <title> Finite differencing of computable expressions. </title> <journal> ACM Trans. Program. Lang. Syst., </journal> <volume> 4(3) </volume> <pages> 402-454, </pages> <month> July </month> <year> 1982. </year>
Reference-contexts: Indeed, many methods for program efficiency improvement in optimizing compilers, transformational programming, and programming methodology do derive efficient incremental programs and use them in computing each iteration of an overall computation. Examples are strength reduction in optimizing compilers [2], finite differencing in transformational programming <ref> [11, 15] </ref>, and maintaining loop invariance in programming methodology [3]. Our work falls into this category. While existing work either handles only limited primitive operators or gives only high-level strategies, our work is more general and systematic.
Reference: [12] <author> W. Pugh and T. Teitelbaum. </author> <title> Incremental computation via function caching. </title> <booktitle> In Conference Record of the 16th Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 315-328. </pages> <publisher> ACM, </publisher> <address> New York, </address> <month> Jan. </month> <year> 1989. </year>
Reference-contexts: The second category is called incremental execution frameworks. The idea is to allow different application programs to run in such a framework without deriving explicit incremental 2 algorithms. These are general methods for incremental problems. Examples are incremental attribute evaluation framework [14], function caching <ref> [12] </ref>, lambda reduction [1], traditional partial evaluation [16], change detailing network [17], program abstraction [4], etc.
Reference: [13] <author> G. Ramalingam and T. Reps. </author> <title> A categorized bibliography on incremental computation. </title> <booktitle> In Conference Record of the 20th Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 502-510. </pages> <publisher> ACM, </publisher> <address> New York, </address> <month> Jan. </month> <year> 1993. </year>
Reference-contexts: We use P1, P2, and P3 to denote these three subproblems. Related work. There has been a great deal of work on incremental computation <ref> [13] </ref>. Despite various classifications, we separate all the work into three categories. The first category consists of incremental algorithms, which includes dynamic algorithms and on-line algorithms. They are particular algorithms manually derived to handle particular problems and particular input changes.
Reference: [14] <author> T. Reps and T. Teitelbaum. </author> <title> The Synthesizer Generator: A System for Constructing Language-Based Editors. </title> <publisher> Springer-Verlag, </publisher> <address> New York, </address> <year> 1988. </year>
Reference-contexts: The second category is called incremental execution frameworks. The idea is to allow different application programs to run in such a framework without deriving explicit incremental 2 algorithms. These are general methods for incremental problems. Examples are incremental attribute evaluation framework <ref> [14] </ref>, function caching [12], lambda reduction [1], traditional partial evaluation [16], change detailing network [17], program abstraction [4], etc. <p> Also, the optimization of aggregate array computations [6] is automatic and is being implemented for use in optimizing compilers. CACHET: A prototype implementation. CACHET is a semi-automatic supporting tool for deriving incremental programs [5]. It is implemented using the Synthesizer Generator <ref> [14] </ref>, a system for generating language-based editing environments. Compared with other program transformation systems, such as KIDS [15] and APTS [10], CACHET benefits from many existing techniques and tools built into the Synthesizer Generator, in particular, for generating attribute-grammar-based programming environments. <p> We can easily use many program manipulation facilities|lexical analysis, parsing, semantic analysis, pretty printing, interactive editing, etc. Furthermore, program analyses can 13 be specified using attribute equations, and thus, with incremental attribute evaluator auto-matically generated from these equations <ref> [14] </ref>, we achieve incremental program analysis as programs are repeatedly transformed.
Reference: [15] <author> D. R. Smith. KIDS: </author> <title> A semiautomatic program development system. </title> <journal> IEEE Trans. Softw. Eng., </journal> <volume> 16(9) </volume> <pages> 1024-1043, </pages> <month> Sept. </month> <year> 1990. </year>
Reference-contexts: Indeed, many methods for program efficiency improvement in optimizing compilers, transformational programming, and programming methodology do derive efficient incremental programs and use them in computing each iteration of an overall computation. Examples are strength reduction in optimizing compilers [2], finite differencing in transformational programming <ref> [11, 15] </ref>, and maintaining loop invariance in programming methodology [3]. Our work falls into this category. While existing work either handles only limited primitive operators or gives only high-level strategies, our work is more general and systematic. <p> CACHET: A prototype implementation. CACHET is a semi-automatic supporting tool for deriving incremental programs [5]. It is implemented using the Synthesizer Generator [14], a system for generating language-based editing environments. Compared with other program transformation systems, such as KIDS <ref> [15] </ref> and APTS [10], CACHET benefits from many existing techniques and tools built into the Synthesizer Generator, in particular, for generating attribute-grammar-based programming environments. We can easily use many program manipulation facilities|lexical analysis, parsing, semantic analysis, pretty printing, interactive editing, etc.
Reference: [16] <author> R. S. Sundaresh and P. Hudak. </author> <title> Incremental computation via partial evaluation. </title> <booktitle> In Conference Record of the 18th Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 1-13. </pages> <publisher> ACM, </publisher> <address> New York, </address> <month> Jan. </month> <year> 1991. </year>
Reference-contexts: The idea is to allow different application programs to run in such a framework without deriving explicit incremental 2 algorithms. These are general methods for incremental problems. Examples are incremental attribute evaluation framework [14], function caching [12], lambda reduction [1], traditional partial evaluation <ref> [16] </ref>, change detailing network [17], program abstraction [4], etc. Each such framework gives some language for describing application programs and, in particular, fixes the classes of input changes that the framework can handle, and uses a particular incremental algorithm to handle the input changes.

References-found: 16

