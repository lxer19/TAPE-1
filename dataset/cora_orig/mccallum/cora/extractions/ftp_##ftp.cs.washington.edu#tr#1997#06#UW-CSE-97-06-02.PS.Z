URL: ftp://ftp.cs.washington.edu/tr/1997/06/UW-CSE-97-06-02.PS.Z
Refering-URL: http://www.cs.washington.edu/research/tr/tr-by-title.html
Root-URL: 
Title: On the Effectiveness of Code Reordering Algorithms for theAlpha and IA32 Architectures  
Author: TR -- Ori Gershony, Jean-Loup Baer and Dennis Lee 
Note: This work was supported in part by NSF Grant CCR-9401689, by Intel Corp. and by a fellowship from National Semiconductor  
Date: June 30, 1997  
Address: Box 352350  Seattle, WA 98195  
Affiliation: Department of Computer Science and Engineering,  University of Washington  
Abstract: The impact of instruction cache misses and branch mispredictions on performance is becoming increasingly important for processors that issue multiple instructions per cycle. Mechanisms that address these two sources of performance degradation need to be studied and refined. In this paper, we consider the effects of one such mechanism, namely code reordering algorithms. We evaluate the performance improvements of three variations of the Pettis and Hansen code reordering algorithm on two instruction set architectures: RISC Alpha and CISC IA32. We show that the algorithms lead to substantial improvements in the fall-through rate of branches which results in decreases in instruction cache miss rates and branch mispredictions. We show that the improvement in fall-through rate and branch prediction is comparable in both ISA's but that the relative improvement in the instruction cache miss rate is higher on the IA32 architecture. 
Abstract-found: 1
Intro-found: 1
Reference: [Bhandarkar & Ding 97] <author> Bhandarkar, D. and Ding, J. </author> <title> Performance Characterization of the Pentium Pro Processor. </title> <booktitle> In IEEE Micro, </booktitle> <pages> pages 288-297, </pages> <year> 1997. </year>
Reference-contexts: For example, on the Pentium Pro, the CPI for gcc is around 1.4 <ref> [Bhandarkar & Ding 97] </ref>. Thus, the performance improvement we could expect with the global layout is approximately 15% (20 cycles saved 6 divided by 1.4).
Reference: [Bhandarkar 97] <author> Bhandarkar, D. </author> <title> RISC versus CISC: A Tale of Two Chips. </title> <journal> In Computer Architecture News, </journal> <volume> 25, </volume> <pages> pages 1-12, </pages> <month> March 1 </month> <year> 1997. </year>
Reference-contexts: ijpeg compress perl m88ksim original bb only proc-block global misfetches by almost a factor of 2 for those benchmarks that have large misfetch rates in the original code. 4.3 Branch Prediction The complexity and implementation sophistication of branch prediction mechanisms are far apart in the recent Alpha and IA32 implementations <ref> [Bhandarkar 97] </ref>. We chose to simulate mechanisms midway between those implementations to evaluate the effects of the code reordering algorithms.
Reference: [Calder & Grunwald 94] <author> Calder, B. and Grunwald, D. </author> <title> Reducing Branch Costs via Branch Alignment. </title> <booktitle> In Sixth International Conference on Architectural Support for Programming Languages and Operating Systems, </booktitle> <pages> pages 242-251, </pages> <month> October 4-7, </month> <year> 1994. </year>
Reference-contexts: Their algorithm is cache size and line size specific. They report a reduction of 17% over Pettis and Hansen in instruction cache miss rate. Calder and Grunwald <ref> [Calder & Grunwald 94] </ref> address specifically the branch alignment problem and give two algorithms that improve on Pettis and Hansen's for the reduction of penalties due to branch mispredictions.
Reference: [Digital Equipment Corporation 94] <author> Digital Equipment Corporation. </author> <title> ATOM user manual, </title> <year> 1994. </year>
Reference-contexts: We chose to use the second method, binary rewriting, to share the same reordering code across two very different platforms running two different compilers (i.e., cc on the DEC Alpha platform and MSVC on the IA32 platform). The binary instrumentation tools that we use are ATOM <ref> [Digital Equipment Corporation 94] </ref> running on the DEC Alpha and Etch [Romer, et. al. 97] running on Pentium and Pentium Pro. The measurement process consists of three phases: 1. We instrument the applications to record profiling information.
Reference: [Fisher & Freudenberger 92] <author> Fisher, J. and Freudenberger, S. </author> <booktitle> Predicting Conditional Branch Directions From previous Runs of a Program In Fifth International Conference on Architectural Support for Programming Languages and Operating Systems, </booktitle> <pages> pages 85-95, </pages> <month> October </month> <year> 1992. </year>
Reference-contexts: We are not aware of any study that measures the impact of such schemes on the instruction cache miss rate. Finally, we should note that control flow predictions based on profiling runs are generally good <ref> [Fisher & Freudenberger 92] </ref>. Our experiments confirm this observation.
Reference: [Hashemi, Kaeli, & Calder 97] <author> Hashemi, A., Kaeli, D., and Calder, B. </author> <title> Efficient Procedure Mapping Using Cache Line Coloring In Proceedings of the SIGPLAN Conference on Programming Language Design and Implementation, </title> <month> June </month> <year> 1997. </year>
Reference-contexts: His algorithm is sensitive to the size of the instruction cache and does not give a comparable increase in the branch fall-through rate, but can yield the lowest instruction cache miss rate. In a similar vein, Hashemi et al. <ref> [Hashemi, Kaeli, & Calder 97] </ref> use Pettis and Hansen as a base and extend it through cache line coloring to avoid conflicts between concurrently executing procedures. Their algorithm is cache size and line size specific. They report a reduction of 17% over Pettis and Hansen in instruction cache miss rate.
Reference: [Hwu & Chang 89] <author> Hwu, W. and Chang, P. </author> <title> Achieving High Instruction Cache Performance with an Optimizing Compiler. </title> <booktitle> In Proceedings of the ACM, </booktitle> <pages> pages 242-251, </pages> <year> 1989. </year>
Reference-contexts: Pettis and Hansen [Pettis & Hansen 90] introduced the algorithm that we implemented for this work. Their algorithm yields an impressive reduction in the instruction cache miss rate and does not use inlining which can increase the size of the binary. Hwu and Chang <ref> [Hwu & Chang 89] </ref> proposed a similar algorithm, with inlining, that performs layout of traces (basic blocks which tend to execute in sequence) instead of basic blocks.
Reference: [Krall 94] <author> Krall, A. </author> <booktitle> Improving Semi-Static Branch Prediction by Code Replication In Proceedings of the SIGPLAN Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 97-106, </pages> <year> 1994. </year>
Reference-contexts: Calder and Grunwald [Calder & Grunwald 94] address specifically the branch alignment problem and give two algorithms that improve on Pettis and Hansen's for the reduction of penalties due to branch mispredictions. Spurred by the advances in hardware based two-level branch predictors [Yeh & Patt 91], Krall <ref> [Krall 94] </ref> and Young and Smith [Young & Smith 94] have proposed schemes which, by profiling patterns, can recognize correlated branches. Prediction performance can be improved at the expense of increased code size through duplication of some basic blocks.
Reference: [McFarling 89] <author> McFarling, S. </author> <title> Program Optimization For Instruction Caches. </title> <booktitle> In Proc. 3rd International Conference On Architectural Support For Programming Languages And Operating Systems, </booktitle> <pages> pages 183-191, </pages> <month> April </month> <year> 1989. </year> <month> 19 </month>
Reference-contexts: Hwu and Chang [Hwu & Chang 89] proposed a similar algorithm, with inlining, that performs layout of traces (basic blocks which tend to execute in sequence) instead of basic blocks. McFarling <ref> [McFarling 89] </ref> takes a slightly different approach: instead of trying to position related basic blocks close to each other, he tries to position them in non-conflicting cache locations.
Reference: [McFarling 92] <author> McFarling, S. </author> <note> Combining Branch Predictors WRL Technical Note TN-36 June 1993. </note>
Reference-contexts: Unless otherwise specified, the instruction cache will be an 8 KB direct-mapped cache with 32-byte line size. The branch architecture will use a 64 entry 4-way set-associative BTB and a 512 entry gshare Pattern History Table (PHT) <ref> [McFarling 92] </ref>.
Reference: [Microprocessor Report 95] <institution> P6 Underscores Intel's Lead vol 9, </institution> <address> Number 2, </address> <month> Feb </month> <year> 1995. </year>
Reference-contexts: The gshare configuration used in our simulations is more complex that the single PHT, associated with cache lines, of the Alpha 21164 and less complex than the scheme present in the Pentium Pro <ref> [Microprocessor Report 95, Yeh & Patt 91] </ref>. Code reordering algorithms should improve on the use of the BTB because the BTB only stores target addresses for branches that are taken. Increasing the number of non-taken branches should leave more room in the BTB for those that are taken.
Reference: [Pettis & Hansen 90] <author> Pettis, K. and Hansen, R. </author> <title> Profile Guided Code Positioning. </title> <booktitle> In Proc. Conference On Programming Language Design And Implementation, </booktitle> <pages> pages 16-26, </pages> <month> June </month> <year> 1990. </year>
Reference-contexts: This compaction can decrease memory requirements, reduce the Translation Lookaside Buffer (TLB) miss rate, and reduce the traffic on the processor-memory bus. In this paper, we evaluate the performance improvement of the Pettis and Hansen code reordering algorithm <ref> [Pettis & Hansen 90] </ref> on two different Instruction Set Architectures (ISA): CISC (Intel IA32) and RISC (DEC Alpha). We show that the algorithm substantially improves the fall-through rate of branches, reduces the instruction cache miss rate, and improves the accuracy of branch prediction. <p> The rest of this paper is organized as follows. In Section 2 we briefly review related work in code reordering algorithms and describe in detail our implementation of the Pettis and Hansen algorithm <ref> [Pettis & Hansen 90] </ref>. Section 3 presents our evaluation methodology including our tools, benchmarks and experiments. Section 4 contains the results and analyses of our simulations. <p> Pettis and Hansen <ref> [Pettis & Hansen 90] </ref> introduced the algorithm that we implemented for this work. Their algorithm yields an impressive reduction in the instruction cache miss rate and does not use inlining which can increase the size of the binary.
Reference: [Romer, et. al. 97] <author> Romer, T., Voelker, G., Lee, D., Wolman, A., Levy, H., Bershad, B., and Chen, B. </author> <title> Instrumentation and Optimization of Win32/Intel Executables. </title> <booktitle> In Proc. USENIX Windows NT Workshop, </booktitle> <month> August 11-13, </month> <year> 1997. </year>
Reference-contexts: The binary instrumentation tools that we use are ATOM [Digital Equipment Corporation 94] running on the DEC Alpha and Etch <ref> [Romer, et. al. 97] </ref> running on Pentium and Pentium Pro. The measurement process consists of three phases: 1. We instrument the applications to record profiling information. We then run the resulting binaries to produce a CFG where edge weights correspond to frequencies of control transfer.
Reference: [Yeh & Patt 91] <author> Yeh, T. and Patt, Y. </author> <title> Two-Level Adaptive Branch Prediction. </title> <booktitle> In Proceedings of the 24th Annual ACM/IEEE International Symposium and Workshop on Microarchitecture, </booktitle> <pages> pages 51-61, </pages> <month> November </month> <year> 1991. </year>
Reference-contexts: Calder and Grunwald [Calder & Grunwald 94] address specifically the branch alignment problem and give two algorithms that improve on Pettis and Hansen's for the reduction of penalties due to branch mispredictions. Spurred by the advances in hardware based two-level branch predictors <ref> [Yeh & Patt 91] </ref>, Krall [Krall 94] and Young and Smith [Young & Smith 94] have proposed schemes which, by profiling patterns, can recognize correlated branches. Prediction performance can be improved at the expense of increased code size through duplication of some basic blocks. <p> The gshare configuration used in our simulations is more complex that the single PHT, associated with cache lines, of the Alpha 21164 and less complex than the scheme present in the Pentium Pro <ref> [Microprocessor Report 95, Yeh & Patt 91] </ref>. Code reordering algorithms should improve on the use of the BTB because the BTB only stores target addresses for branches that are taken. Increasing the number of non-taken branches should leave more room in the BTB for those that are taken.
Reference: [Young & Smith 94] <author> Young, C. and Smith, M. </author> <title> Improving the Accuracy of Static branch prediction Using Branch Correlation In Sixth International Conference on Architectural Support for Programming Languages and Operating Systems, </title> <address> pages 232-231, </address> <month> October 4-7, </month> <year> 1994. </year> <month> 20 </month>
Reference-contexts: Spurred by the advances in hardware based two-level branch predictors [Yeh & Patt 91], Krall [Krall 94] and Young and Smith <ref> [Young & Smith 94] </ref> have proposed schemes which, by profiling patterns, can recognize correlated branches. Prediction performance can be improved at the expense of increased code size through duplication of some basic blocks.
References-found: 15

