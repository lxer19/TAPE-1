URL: http://www.cs.colostate.edu/~ftppub/TechReports/1993/tr-133.ps.Z
Refering-URL: http://www.cs.colostate.edu/~ftppub/
Root-URL: 
Title: Analysis of Non-Strict Functional Implementations of the Dongarra-Sorensen Eigensolver  
Affiliation: Department of Computer Science  Colorado State University  
Abstract: S. Sur and W. Bohm Technical Report CS-93-133 December 15, 1993 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Bohm, A. P. and R. E. Hiromoto, </author> <title> "The Dataflow Time and Space Complexity of FFTs", </title> <journal> J. Par and Dist Comp, </journal> <volume> Vol. 18, </volume> <pages> pp. 301-313, </pages> <year> 1993. </year>
Reference: [2] <author> Bunch, J. R., C.P. Nielsen and D. C. Sorensen, </author> <title> "Rank-one Modification of the Symmetric Eigenprob-lem", </title> <journal> Numerische Mathematik, </journal> <volume> 31, </volume> <pages> pp. 31-48, </pages> <address> 1978. Reading, MA, </address> <year> 1972. </year>
Reference-contexts: In this section we introduce the existing theory regarding Dongarra-Sorensen algorithm for solving the eigenvalue problem of a tridiagonal matrix in some more detail, because we will introduce a bottom up version of the algorithm later. The Dongarra-Sorensen algorithm is a divide and conquer approach <ref> [4, 2] </ref> for computing the eigen 2 values and eigenvectors of a symmetric tridiagonal matrix. <p> A Newton's method to solve this will not converge <ref> [2] </ref> and the general bisection method would be too slow. However, this equation has the delightful property of having a distinct root between every pair of consecutive diagonal elements (ffi i ; ffi i+1 ). <p> This situation is very suitable for an iterative method for solving the equation () = 1 + () One can start with an initial guess 0 close to ffi i in the appropriate interval so that 0 &lt; <ref> [2] </ref>, and then construct simple rational interpolants of the form p ; r + ffi where ffi is fixed at ffi i+1 (the i+1th diagonal element of D) and the parameters p, q, r, s are defined by the interpolation conditions p = ( 0 ); r + ffi 0 p <p> Bunch et. al. <ref> [2] </ref> showed that this iteration converges quadratically from one side of the root and does not need any safeguarding. 3 A bottom-up approach The theory described in the previous section is particularly suitable for a top-down implementation, where each problem is recursively reduced to two smaller size problems, until the trivial
Reference: [3] <author> Culler, D. E., </author> <title> "Managing parallelism and resources in scientific dataflow programs", </title> <type> PhD Thesis, </type> <institution> MIT, </institution> <month> June </month> <year> 1989. </year>
Reference-contexts: Therefore, in order to shorten the critical path of the program, attention should be paid to this part of the algorithm. Improving the parallelism of Householder can be easily achieved by by increasing the K-Bounds of the loops <ref> [3] </ref>. 11 * The matrix multiplication (color 3) can only start after the matrix Q has been produced by the Householder function, and contributes largely to the critical path length.
Reference: [4] <author> Dongarra, J. J. and D. C. Sorensen, </author> <title> "A Fully Parallel Algorithm for the Symmetric Eigenvalue Problem", </title> <journal> SIAM J. Sci and Stat Comp, </journal> <volume> Vol. 8, </volume> <pages> pp. </pages> <address> S139-154, </address> <month> March </month> <year> 1987. </year>
Reference-contexts: To obtain information about the space usage of our programs, we determine the largest problem size that can run on a one node (one processor module and one storage module) Monsoon machine. Dongarra and Sorensen mention the possibility of exploiting producer-consumer parallelism between Householder and their algorithm <ref> [4] </ref> and mention that "an efficient implementation of this scheme is difficult". We will show that in a non-strict functional execution environment, the Dongarra-Sorensen algorithm can run completely in parallel with the Householder function. <p> In this section we introduce the existing theory regarding Dongarra-Sorensen algorithm for solving the eigenvalue problem of a tridiagonal matrix in some more detail, because we will introduce a bottom up version of the algorithm later. The Dongarra-Sorensen algorithm is a divide and conquer approach <ref> [4, 2] </ref> for computing the eigen 2 values and eigenvectors of a symmetric tridiagonal matrix. <p> This modified element ~a k+1 is given by ~a k+1 = a k+1 2 . The factor is incorporated to avoid certain numerical difficulties associated with cancellation of diagonal terms <ref> [4] </ref>. 2.2 Divide and conquer step: Now we have two smaller tridiagonal eigenvalue problems to solve. <p> We also assume that no component i of vector z is zero. The eigensolver can be modified to solve problems with equal eigenvalues and zero components of z by incorporating certain deflation techniques into the algorithm <ref> [4] </ref>. We will, however, not deal with these deflation techniques. Under above assumptions, the eigenpair (the eigenvalue) and q (the corresponding eigenvector) satisfying (D + zz T )q = q can be obtained from satisfying the following equations [4]: 1 + z T (D I) 1 z = 0 (6) and <p> zero components of z by incorporating certain deflation techniques into the algorithm <ref> [4] </ref>. We will, however, not deal with these deflation techniques. Under above assumptions, the eigenpair (the eigenvalue) and q (the corresponding eigenvector) satisfying (D + zz T )q = q can be obtained from satisfying the following equations [4]: 1 + z T (D I) 1 z = 0 (6) and q is obtained from q = (D I) 1 z (7) If equation (6) is written in terms of the components i of z, then must be a root of the equation f () = 1 + j=1 <p> However, this equation has the delightful property of having a distinct root between every pair of consecutive diagonal elements (ffi i ; ffi i+1 ). This property is used by Dongarra and Sorensen <ref> [4] </ref> to come up with a fast root-finder described below. 4 2.4 The root-finder of the secular equation: Without loss of generality, one can assume that the coefficient of the secular equation is positive. <p> This verifies the claim in <ref> [4] </ref> that even in sequential mode, the Dongarra-Sorensen algorithm outperforms QL. Also note that QL cannot do much work until all of d and e have been produced, which is an inherent characteristic of the algorithm.
Reference: [5] <author> Golub, G. H. and C. F. Van Loan, </author> <title> "Matrix Computations", </title> <publisher> The Johns Hopkins University Press, </publisher> <address> 2nd edition, </address> <year> 1989. </year>
Reference-contexts: The Dongarra-Sorensen algorithm performs the same operation as QL, but in a divide and conquer fashion. For further details concerning eigensolvers we refer to <ref> [5] </ref>. In this section we introduce the existing theory regarding Dongarra-Sorensen algorithm for solving the eigenvalue problem of a tridiagonal matrix in some more detail, because we will introduce a bottom up version of the algorithm later.
Reference: [6] <author> Hicks, James, D. Chiou, B. S. Ang and Arvind, </author> <title> "Performance studies of Id on the Monsoon dataflow system," </title> <journal> Journal of Parallel and Distributed Computing no. </journal> <volume> 18, </volume> <pages> pp 273-300, </pages> <year> 1993. </year>
Reference-contexts: Also, we compare both versions of the Dongarra-Sorensen solver with the more traditional QL algorithm, and verify that the Dongarra-Sorensen solver is much more efficient, even when run in a serial mode. Our algorithms are written in Id [8] and run on the Motorola Monsoon machine <ref> [6] </ref>. To obtain parallelism profiles, we run our programs on a Monsoon Interpreter. To obtain information about the space usage of our programs, we determine the largest problem size that can run on a one node (one processor module and one storage module) Monsoon machine. <p> Table 1 gives for each implementation information regarding the number of instructions per function, the total number of instructions executed, the total critical path length, and the maximum size problem that can be run on a one node Monsoon machine <ref> [6] </ref>, which has a 4 Megaword data memory. From the figures and table we draw the following conclusions. * Both top-down and bottom-up Dongarra-Sorensen implementations (color 4) exploit producer-consumer parallelism, and run in parallel with the part of Householder that creates the diagonals d and e.
Reference: [7] <author> Hughes, J. </author> <title> "Why Functional Programming Matters", </title> <journal> The Computer Journal, </journal> <month> April </month> <year> 1989. </year>
Reference-contexts: In this paper, for example, we study an Eigensolver composed of a tridiagonalization function, a tridiagonal solver, and a matrix multiplication. We verify the claim that non-strict functional languages allow the natural exploitation of fine-grain parallelism of modular programs <ref> [7] </ref>. Elements of a non-strict data structure can be used before the whole structure is defined. Combined with the data-driven execution of functional modules, this provides for maximal exploitation of parallelism without the need for explicit specification of it.
Reference: [8] <author> Nikhil, R. S. </author> , <title> "Id Reference Manual, </title> <note> version 90.1", Computation structures group memo 284-2, </note> <institution> MIT Laboratory for Computer Science, </institution> <address> Cambridge, MA, </address> <month> Sept </month> <year> 1990. </year>
Reference-contexts: Also, we compare both versions of the Dongarra-Sorensen solver with the more traditional QL algorithm, and verify that the Dongarra-Sorensen solver is much more efficient, even when run in a serial mode. Our algorithms are written in Id <ref> [8] </ref> and run on the Motorola Monsoon machine [6]. To obtain parallelism profiles, we run our programs on a Monsoon Interpreter.
Reference: [9] <author> Ruggiero, C. A. and J. Sargeant, </author> <title> "Control of Parallelism in the Manchester Dataflow Computer", </title> <booktitle> Lecture Notes in Computer Science no. </booktitle> <volume> 274, </volume> <pages> pp 1-15, </pages> <year> 1987. </year> <month> 13 </month>
Reference-contexts: This is because the recursive algorithm is executed in an eager, breadth first order, which uses excessive amounts of frame store. This relates directly to the throttling problem <ref> [9] </ref> of controlling the amount of program parallelism such that the machine resources are utilized, but not swamped. * For the 16 fi 16 problem, QL (color 4) has a 75% longer critical path length than the two Dongarra-Sorensen algorithms, and executes 80% more instructions.
References-found: 9

