URL: http://www.cs.nmsu.edu/~epontell/ilps97/7.ps.gz
Refering-URL: http://www.cs.nmsu.edu/lldap/ilps97/programme.html
Root-URL: http://www.cs.nmsu.edu
Title: Realizing Modularity in Prolog  
Author: Gopalan Nadathur and Guanshan Tong 
Keyword: Prolog, Prolog, modularity, separate compilation, implementation.  
Address: Chicago, IL 60637  
Affiliation: Department of Computer Science The University of Chicago  
Email: -gopalan, guanshan-@cs.uchicago.edu  
Phone: (773)702-3497, 2575  
Date: September 1997  
Abstract: The language Prolog incorporates a module notion that permits the space of names and procedure declarations to be decomposed into smaller units. Interactions between these units can take place through either an accumulation or an importation process. There are both static and dynamic eoeects to such interactions: the parsing of expressions may require names declared in another module and executable code may utilize procedures deoned elsewhere. We describe a method for implementing this feature for modular programming that is based on the separate compilation of each module into an appropriate fragment of code. The dynamic semantics of module importation involves enhancing existing program contexts with the procedures deoned in other modules. This eoeect is achieved through a run-time process for including the compiler generated code for such procedures. Our implementation method partitions the code space into distinct chunks corresponding to the module structure, with the management of the sub-parts being realized through a module table. EOEciency of execution requires the use of uniform structures, such as a common symbol table, for the code in all sub-components. To realize this requirement, we describe a suitable communication between the compilation and loading processes. The scheme presented here has been implemented and tested in conjunction with an abstract machine for Prolog. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> A. Brogi, P. Mancarella, D. Pedreschi, and F. Turini. </author> <title> Composition operators for logic theories. </title> <editor> In J.W. Lloyd, editor, </editor> <booktitle> Computational Logic, Symposium Proceedings, </booktitle> <pages> pages 117134. </pages> <publisher> Springer-Verlag, </publisher> <year> 1992. </year>
Reference-contexts: Bugliesi, Lamma and Mello [2] classify these proposals into two kinds: those that retain Horn clauses as the logical core but endow the framework with metalinguistic mechanisms for composing separately constructed program fragments, an approach exemplioed by <ref> [1, 7, 13, 14] </ref>, and those that extract composition and scoping mechanisms from an enrichment of the underlying logic, an approach exemplioed by [3, 8, 10]. We consider in this paper the implementation of a modularity notion in the language Prolog that arises from following the latter approach [9]. <p> Notice that the computation described up to this point has introduced a deonition for the procedure rev aux and that this must be used in solving a new goal. Carrying this process to fruition will eventually result in the query variable L being bound to <ref> [2; 1] </ref>. New devices are needed for implementing the scoping primitives described above. It appears at the outset that rather simple machinery might suOEce for universal goals: we merely instantiate universal quantioers with newly generated constants. <p> coming from the explicit local declaration module m1. module m2 . . . . . . module m3. module m4. module m5. import m1. import m2. accumulate m3; m4. local r. local r; w. local q. [clauses in m3] [clauses in m4] [clauses in m5] module m5. local q; r <ref> [1] </ref>; w; r [2]. import m2 [q ! orst local, r ! second local, w ! third local ] [clauses f rom m4] with constant references suitably resolved import m1 [q ! orst local, r ! fourth local ] [clauses f rom m3] with constant references suitably resolved [clauses f rom <p> This is reAEected in the local declaration in the preprocessed form, with r <ref> [1] </ref> and r [2] indicating the iversionsj of r arising from distinct sources. The clauses in the composite form of m5 can be partitioned into three sets depending on the import statements that are scoped over them. This structure is made explicit in Figure 5.
Reference: [2] <author> Michele Bugliesi, Evelina Lamma, and Paola Mello. </author> <title> Modularity in logic programming. </title> <journal> Journal of Logic Programming, </journal> <volume> 19,20:443502, </volume> <month> May/July </month> <year> 1994. </year>
Reference-contexts: This fact has stimulated several proposals of mechanisms that support the modular construction of programs. Bugliesi, Lamma and Mello <ref> [2] </ref> classify these proposals into two kinds: those that retain Horn clauses as the logical core but endow the framework with metalinguistic mechanisms for composing separately constructed program fragments, an approach exemplioed by [1, 7, 13, 14], and those that extract composition and scoping mechanisms from an enrichment of the underlying <p> Notice that the computation described up to this point has introduced a deonition for the procedure rev aux and that this must be used in solving a new goal. Carrying this process to fruition will eventually result in the query variable L being bound to <ref> [2; 1] </ref>. New devices are needed for implementing the scoping primitives described above. It appears at the outset that rather simple machinery might suOEce for universal goals: we merely instantiate universal quantioers with newly generated constants. <p> explicit local declaration module m1. module m2 . . . . . . module m3. module m4. module m5. import m1. import m2. accumulate m3; m4. local r. local r; w. local q. [clauses in m3] [clauses in m4] [clauses in m5] module m5. local q; r [1]; w; r <ref> [2] </ref>. import m2 [q ! orst local, r ! second local, w ! third local ] [clauses f rom m4] with constant references suitably resolved import m1 [q ! orst local, r ! fourth local ] [clauses f rom m3] with constant references suitably resolved [clauses f rom m5] with constant <p> This is reAEected in the local declaration in the preprocessed form, with r [1] and r <ref> [2] </ref> indicating the iversionsj of r arising from distinct sources. The clauses in the composite form of m5 can be partitioned into three sets depending on the import statements that are scoped over them. This structure is made explicit in Figure 5.
Reference: [3] <author> L. Giordano, A. Martelli, </author> <title> and G.F. Rossi. Extending Horn clause logic with modules constructs. </title> <booktitle> Theoretical Computer Science, </booktitle> <address> 95:4374, </address> <year> 1992. </year>
Reference-contexts: kinds: those that retain Horn clauses as the logical core but endow the framework with metalinguistic mechanisms for composing separately constructed program fragments, an approach exemplioed by [1, 7, 13, 14], and those that extract composition and scoping mechanisms from an enrichment of the underlying logic, an approach exemplioed by <ref> [3, 8, 10] </ref>. We consider in this paper the implementation of a modularity notion in the language Prolog that arises from following the latter approach [9].
Reference: [4] <author> Keehang Kwon, Gopalan Nadathur, and Debra Sue Wilson. </author> <title> Implementing a notion of modules in the logic programming language Prolog. </title> <editor> In Evelina Lamma and Paola Mello, editors, </editor> <booktitle> Extensions of Logic Programming: Proceedings of the Third International Workshop, Bologna, Italy, </booktitle> <pages> pages 359393. </pages> <publisher> Springer-Verlag, </publisher> <year> 1993. </year> <note> Vol 660 of Lecture Notes in Artiocial Intelligence. </note>
Reference-contexts: In particular, it is necessary to describe (a) run-time structures that will realize changing program contexts satisfactorily and (b) compilation and loading methods for extracting and setting up the information that is needed during execution. Such questions have been considered previously in the literature <ref> [4, 6, 11] </ref>. We expand on prior work in this paper in two signiocant ways. First, we provide a treatment of information hiding and a notion of module accumulation in addition to a previously considered notion of module importation. <p> The scheme described above is naive in the following respect: if clauses from an importing module are used more than once, it will repeat the addition of code for the importing modules and this is shown to be redundant in <ref> [4] </ref>. 4 To avoid this, we augment import point records with a new cell, called a backchained cell, that indicates whether or not a clause from the module has previously been used.
Reference: [5] <author> Keehang Kwon, Gopalan Nadathur, and Debra Sue Wilson. </author> <title> Implementing polymorphic typing in a logic programming language. </title> <booktitle> Computer Languages, </booktitle> <address> 20(1):2542, </address> <year> 1994. </year>
Reference-contexts: Assuming some form of interface or signature deonitions, it supports the separate compilation of modules. 2. It partitions the active code space into distinct chunks corresponding to the module 1 In reality, Prolog has many other new features, each of which requires embellishments to the WAM <ref> [5, 11, 12] </ref>. We elide this aspect for simplicity in presentation. structure and it manages this space through a global module table. 3. Despite the partitioning of code space, it realizes eOEciency in execution by using uniform structures, such as a common symbol table, for all relevant code. <p> This abstract machine utilizes the basic structure of the WAM in the treatment of nondeterminism and uniocation. However, it also represents a considerable enhancement to the WAM, with mechanisms being added to treat features such as typing <ref> [5] </ref>, scoping over names and procedure deonitions [11] and lambda terms as data structures with higher-order uniocation being used as the corresponding destructuring operation [12].
Reference: [6] <author> Evelina Lamma, Paola Mello, and Antonio Natali. </author> <title> An extended Warren abstract machine for the execution of structured logic programs. </title> <journal> Journal of Logic Programming, </journal> <volume> 14:187222, </volume> <year> 1992. </year>
Reference-contexts: In particular, it is necessary to describe (a) run-time structures that will realize changing program contexts satisfactorily and (b) compilation and loading methods for extracting and setting up the information that is needed during execution. Such questions have been considered previously in the literature <ref> [4, 6, 11] </ref>. We expand on prior work in this paper in two signiocant ways. First, we provide a treatment of information hiding and a notion of module accumulation in addition to a previously considered notion of module importation.
Reference: [7] <author> P. Mancarella and D. Pedreschi. </author> <title> An algebra of logic programs. </title> <editor> In Kenneth A. Bowen and Robert A. Kowalski, editors, </editor> <booktitle> Fifth International Logic Programming Conference, </booktitle> <pages> pages 10061023, </pages> <address> Seattle, Washington, August 1988. </address> <publisher> MIT Press. </publisher>
Reference-contexts: Bugliesi, Lamma and Mello [2] classify these proposals into two kinds: those that retain Horn clauses as the logical core but endow the framework with metalinguistic mechanisms for composing separately constructed program fragments, an approach exemplioed by <ref> [1, 7, 13, 14] </ref>, and those that extract composition and scoping mechanisms from an enrichment of the underlying logic, an approach exemplioed by [3, 8, 10]. We consider in this paper the implementation of a modularity notion in the language Prolog that arises from following the latter approach [9].
Reference: [8] <author> Dale Miller. </author> <title> A logical analysis of modules in logic programming. </title> <journal> Journal of Logic Programming, </journal> <volume> 6:79108, </volume> <year> 1989. </year>
Reference-contexts: kinds: those that retain Horn clauses as the logical core but endow the framework with metalinguistic mechanisms for composing separately constructed program fragments, an approach exemplioed by [1, 7, 13, 14], and those that extract composition and scoping mechanisms from an enrichment of the underlying logic, an approach exemplioed by <ref> [3, 8, 10] </ref>. We consider in this paper the implementation of a modularity notion in the language Prolog that arises from following the latter approach [9]. <p> The intended dynamic eoeect is to make the procedure deonitions in the imported modules available for solving the goals in the bodies of program clauses that appear in the importing module. The exact eoeect can be clarioed by using module implication <ref> [8] </ref>. Suppose that the clause P :- G appears in a module that imports the modules M 1; : : : ; M k. The dynamic semantics involves interpreting this clause as the following one instead: P :- (M 1 ==&gt; (M k ==&gt; G)).
Reference: [9] <author> Dale Miller. </author> <title> A proposal for modules in Prolog. </title> <editor> In Roy Dyckhooe, editor, </editor> <booktitle> Proceedings of the 1993 Workshop on Extensions to Logic Programming, pages 206221. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1994. </year> <booktitle> Volume 798 of Lecture Notes in Computer Science. </booktitle>
Reference-contexts: We consider in this paper the implementation of a modularity notion in the language Prolog that arises from following the latter approach <ref> [9] </ref>. Programming in a Prolog-like language to a large extent consists of identifying two kinds of collections: the names of constants, functions and predicates that can be used in constructing well-formed expressions, and procedure deonitions that might be used in solving goals.
Reference: [10] <author> Lus Monteiro and Antnio Porto. </author> <title> Contextual logic programming. </title> <editor> In G. Levi and M. Martelli, editors, </editor> <booktitle> Sixth International Logic Programming Conference, </booktitle> <pages> pages 284 299, </pages> <address> Lisbon, Portugal, June 1989. </address> <publisher> MIT Press. </publisher>
Reference-contexts: kinds: those that retain Horn clauses as the logical core but endow the framework with metalinguistic mechanisms for composing separately constructed program fragments, an approach exemplioed by [1, 7, 13, 14], and those that extract composition and scoping mechanisms from an enrichment of the underlying logic, an approach exemplioed by <ref> [3, 8, 10] </ref>. We consider in this paper the implementation of a modularity notion in the language Prolog that arises from following the latter approach [9].
Reference: [11] <author> Gopalan Nadathur, Bharat Jayaraman, and Keehang Kwon. </author> <title> Scoping constructs in logic programming: Implementation problems and their solution. </title> <journal> Journal of Logic Programming, </journal> <volume> 25(2):119161, </volume> <month> November </month> <year> 1995. </year>
Reference-contexts: In particular, it is necessary to describe (a) run-time structures that will realize changing program contexts satisfactorily and (b) compilation and loading methods for extracting and setting up the information that is needed during execution. Such questions have been considered previously in the literature <ref> [4, 6, 11] </ref>. We expand on prior work in this paper in two signiocant ways. First, we provide a treatment of information hiding and a notion of module accumulation in addition to a previously considered notion of module importation. <p> Assuming some form of interface or signature deonitions, it supports the separate compilation of modules. 2. It partitions the active code space into distinct chunks corresponding to the module 1 In reality, Prolog has many other new features, each of which requires embellishments to the WAM <ref> [5, 11, 12] </ref>. We elide this aspect for simplicity in presentation. structure and it manages this space through a global module table. 3. Despite the partitioning of code space, it realizes eOEciency in execution by using uniform structures, such as a common symbol table, for all relevant code. <p> The constructs for modular programming that are of interest to us derive in signiocant part from scoping devices already present in the core language. An appreciation of this relationship and of the method we have previously proposed for realizing the scoping notions <ref> [11] </ref> is useful in understanding the present implementation ideas. We provide this background in the next section. In Section 3, we present the important components of the modules language and we sketch the compilation and run-time processes needed to support it. <p> The solution to this problem is to modify uniocation to respect quantioer order. There is a simple way to achieve this that is based on tagging variables and constants with (small) positive integers. We sketch this scheme here, referring the reader to <ref> [11] </ref> for details. The key step is to think of the collection of all terms as being arranged in an increasing hierarchy of universes. The level 1 universe consists of all the constant symbols that appear in the program clauses and the original goal. <p> This binding is permitted only if t does not contain any constants with a tag value greater than i. The main issue in implementing implication goals is to provide an eOEcient realization of changing program contexts. The essence of the scheme described in <ref> [11] </ref> is in viewing a program as a composite of compiled code and a layered access function to this code, with each implication goal causing a new layer to be added to an existing access function. <p> This abstract machine utilizes the basic structure of the WAM in the treatment of nondeterminism and uniocation. However, it also represents a considerable enhancement to the WAM, with mechanisms being added to treat features such as typing [5], scoping over names and procedure deonitions <ref> [11] </ref> and lambda terms as data structures with higher-order uniocation being used as the corresponding destructuring operation [12]. A satisfactory realization of all these features requires many low-level decisions, such as those pertaining to term representation, to be dioeerent from those adopted in typical WAM emulators.
Reference: [12] <author> Gopalan Nadathur, Bharat Jayaraman, and Debra Sue Wilson. </author> <title> Implementation considerations for higher-order features in logic programming. </title> <type> Technical Report CS-1993-16, </type> <institution> Department of Computer Science, Duke University, </institution> <month> June </month> <year> 1993. </year>
Reference-contexts: Assuming some form of interface or signature deonitions, it supports the separate compilation of modules. 2. It partitions the active code space into distinct chunks corresponding to the module 1 In reality, Prolog has many other new features, each of which requires embellishments to the WAM <ref> [5, 11, 12] </ref>. We elide this aspect for simplicity in presentation. structure and it manages this space through a global module table. 3. Despite the partitioning of code space, it realizes eOEciency in execution by using uniform structures, such as a common symbol table, for all relevant code. <p> However, it also represents a considerable enhancement to the WAM, with mechanisms being added to treat features such as typing [5], scoping over names and procedure deonitions [11] and lambda terms as data structures with higher-order uniocation being used as the corresponding destructuring operation <ref> [12] </ref>. A satisfactory realization of all these features requires many low-level decisions, such as those pertaining to term representation, to be dioeerent from those adopted in typical WAM emulators.
Reference: [13] <author> Richard O'Keefe. </author> <title> Towards an algebra for constructing logic programs. </title> <editor> In J. Cohen and J. Conery, editors, </editor> <booktitle> 1985 Symposium on Logic Programming, </booktitle> <pages> pages 152160, </pages> <address> Boston, Massachusetts, 1985. </address> <publisher> IEEE Computer Society Press. </publisher>
Reference-contexts: Bugliesi, Lamma and Mello [2] classify these proposals into two kinds: those that retain Horn clauses as the logical core but endow the framework with metalinguistic mechanisms for composing separately constructed program fragments, an approach exemplioed by <ref> [1, 7, 13, 14] </ref>, and those that extract composition and scoping mechanisms from an enrichment of the underlying logic, an approach exemplioed by [3, 8, 10]. We consider in this paper the implementation of a modularity notion in the language Prolog that arises from following the latter approach [9].
Reference: [14] <author> D.T. Sannella and L.A. Wallen. </author> <title> A calculus for the construction of modular Prolog programs. </title> <journal> Journal of Logic Programming, </journal> <volume> 12:147178, </volume> <month> January </month> <year> 1992. </year>
Reference-contexts: Bugliesi, Lamma and Mello [2] classify these proposals into two kinds: those that retain Horn clauses as the logical core but endow the framework with metalinguistic mechanisms for composing separately constructed program fragments, an approach exemplioed by <ref> [1, 7, 13, 14] </ref>, and those that extract composition and scoping mechanisms from an enrichment of the underlying logic, an approach exemplioed by [3, 8, 10]. We consider in this paper the implementation of a modularity notion in the language Prolog that arises from following the latter approach [9].
Reference: [15] <author> D.H.D. Warren. </author> <title> An abstract Prolog instruction set. </title> <type> Technical Note 309, </type> <institution> SRI International, </institution> <month> October </month> <year> 1983. </year>
Reference-contexts: Second, in contrast to earlier discussions, we pay attention here to certain ilow-levelj details that are important to the actual execution model. We present our implementation ideas in the form of enhancements to an underlying Prolog engine such as the Warren Abstract Machine (WAM) <ref> [15] </ref> serving to realize the dynamic aspects of the module notion. 1 There are several interesting characteristics to the scheme we ultimately suggest, including the following: 1. Assuming some form of interface or signature deonitions, it supports the separate compilation of modules. 2.
References-found: 15

