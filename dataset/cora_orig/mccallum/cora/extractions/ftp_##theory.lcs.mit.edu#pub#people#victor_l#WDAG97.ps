URL: ftp://theory.lcs.mit.edu/pub/people/victor_l/WDAG97.ps
Refering-URL: http://theory.lcs.mit.edu/~victor_l/papers/WDAG97.html
Root-URL: 
Title: Precedence-Based Memory Models  
Author: Victor Luchangco 
Affiliation: M.I.T.  
Abstract: This paper presents a general framework for understanding precedence-based memory models, which are generalizations of standard multiprocessor models. Precedence-based models need not mention processes explicitly, and can express any conditions that rely only on some operations being required to precede other operations. We define a generalized notion of sequential consistency and per-location sequential consistency in this framework, and we analyze the Backer algorithm used in the Cilk system [3], showing that it implements per-location sequential consistency. We also give conditions under which client processes cannot distinguish a per-location sequentially consistent memory from a sequentially consistent one.
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> S. Adve and K. Gharachorloo. </author> <title> Shared memory consistency models: A tutorial. </title> <type> Tech nical Report 9512, </type> <institution> Rice University, </institution> <month> Sept. </month> <year> 1995. </year>
Reference-contexts: Thus, some systems are willing to tolerate some inconsistency in order to improve performance. In order to reason about these systems, many weaker memory models have been proposed, such as processor consistency [9], release consistency [7], location consistency [6], scope consistency [10], eventual-serializability [5], dag-consistency [3], and others (see <ref> [1] </ref>). Unfortunately, these models are defined using different formalisms, and some of them do not even have formal definitions, making it hard to compare them rigorously. Another drawback of sequential consistency and most of the models mentioned above is that the programmer must explicitly indicate which process issues each operation. <p> We believe that the careful definition and characterization of the serial semantics of data will also be helpful in understanding memory, and how algorithms can exploit specific classes of data, particular read/write memories. Many people have proposed different memory models (see <ref> [1] </ref> for an overview), but only a few have proposed a unified framework that can be used to compare different models. Gibbons and Merritt [8] present a framework to specify non-blocking shared memories, and they do so at roughly the same level as we do.
Reference: 2. <author> H. Attiya, S. Chaudhuri, R. Friedman, and J. Welch. </author> <title> Shared memory consistency conditions for non-sequential execution: Definitions and programming strategies. </title> <booktitle> In Proc. of the Fifth ACM Symp. on Parallel Algorithms and Architectures, </booktitle> <month> June </month> <year> 1993. </year>
Reference-contexts: Gibbons and Merritt [8] present a framework to specify non-blocking shared memories, and they do so at roughly the same level as we do. Attiya, et al <ref> [2] </ref> present a higher level framework which also considers the control operations in programs. However, both still model processes explicitly, and thus would not be able to model the Cilk system, for example.
Reference: 3. <author> R. D. Blumofe, M. Frigo, C. F. Joerg, C. E. Leiserson, and K. H. Randall. </author> <title> Dag consistent distributed shared memory. </title> <booktitle> In Proc. of the 10th Int'l Parallel Processing Symp., </booktitle> <address> Honolulu, Hawaii, </address> <month> Apr. </month> <year> 1996. </year>
Reference-contexts: Thus, some systems are willing to tolerate some inconsistency in order to improve performance. In order to reason about these systems, many weaker memory models have been proposed, such as processor consistency [9], release consistency [7], location consistency [6], scope consistency [10], eventual-serializability [5], dag-consistency <ref> [3] </ref>, and others (see [1]). Unfortunately, these models are defined using different formalisms, and some of them do not even have formal definitions, making it hard to compare them rigorously. <p> We consider how restrictions on the clients, or on the types of operations that can be applied to the data, can be used to guarantee greater consistency. To demonstrate the utility of this framework, we formally specify and analyze the Backer algorithm used in the Cilk system <ref> [3] </ref>, and we show that it implements per-location sequential consistency for read/write memories. The rest of the paper is organized as follows: Section 2 defines some conventions used throughout the paper and Section 3 describes the formal model. Section 4 characterizes the serial semantics of the data. <p> Since operators are oblivious to operators at different locations, the return values are determined by this subsequence, and these are the values that must be recorded in return-value. 7 Generic Backer Automaton We now specify and analyze the Backer algorithm of <ref> [3] </ref>. The algorithm implements a per-location sequentially consistent read/write memory on a multiprocessor system with a cache for each process and a shared "backing store". Operations may depend explicitly on operations done at other processors. <p> This work continues in the direction of Fekete, et al [5] and Blumofe, et al <ref> [3] </ref> in allowing memory models without explicit processes, but can still express models with explicit processes. It is not intended to express all memory models, however, since this task has proven to be very difficult.
Reference: 4. <author> R. D. Blumofe, C. F. Joerg, B. C. Kuszmaul, C. E. Leiserson, K. H. Randall, and Y. Zhou. Cilk: </author> <title> An efficient multithreaded runtime system. </title> <booktitle> In Proc. of the Fifth ACM SIGPLAN Symp. on Principles and Practice of Parallel Programming (PPoPP), </booktitle> <pages> pages 207-216, </pages> <address> Santa Barbara, California, </address> <month> July </month> <year> 1995. </year>
Reference-contexts: Another drawback of sequential consistency and most of the models mentioned above is that the programmer must explicitly indicate which process issues each operation. Thus they cannot model systems such as Cilk <ref> [4, 13] </ref>, which do not make processes directly accessible to the programmer. ? Supported by AFOSR-ONR contract F49640-94-1-0199, by ARPA contracts N00014 92-J-4033 and F19628-95-C-0118, and by NSF grant 9225124-CCR. This paper presents a general framework for understanding precedence-based memory models, which are generalizations of standard multiprocessor models. <p> This prevents cyclic dependencies. We also maintain some useful bookkeeping variables. Note that this one automaton models all the clients together. This allows us to specify more general and abstract programming systems which may not have any explicit notion of processes, such as the Cilk system <ref> [4, 13] </ref>. This is important because the specification of practical programming systems is an active area of research. Systems in which the process that issues each request is explicit can easily be modelled in this framework by incorporating the process identifier into the operation identifier, or even the operator.
Reference: 5. <author> A. Fekete, D. Gupta, V. Luchangco, N. Lynch, and A. Shvartsman. </author> <title> Eventually serializable data services. </title> <booktitle> In Proc. of the 15th ACM Symp. on Principles of Distributed Computing, </booktitle> <pages> pages 300-309, </pages> <month> May </month> <year> 1996. </year>
Reference-contexts: Thus, some systems are willing to tolerate some inconsistency in order to improve performance. In order to reason about these systems, many weaker memory models have been proposed, such as processor consistency [9], release consistency [7], location consistency [6], scope consistency [10], eventual-serializability <ref> [5] </ref>, dag-consistency [3], and others (see [1]). Unfortunately, these models are defined using different formalisms, and some of them do not even have formal definitions, making it hard to compare them rigorously. <p> This work continues in the direction of Fekete, et al <ref> [5] </ref> and Blumofe, et al [3] in allowing memory models without explicit processes, but can still express models with explicit processes. It is not intended to express all memory models, however, since this task has proven to be very difficult.
Reference: 6. <author> G. R. Gao and V. Sarkar. </author> <title> Location consistency: Stepping beyond the barriers of memory coherence and serializability. </title> <type> Technical Report 78, </type> <institution> McGill University, ACAPS Laboratory, </institution> <month> Dec. </month> <year> 1993. </year>
Reference-contexts: Unfortunately, maintaining such guarantees is expensive, even impossible on some systems. Thus, some systems are willing to tolerate some inconsistency in order to improve performance. In order to reason about these systems, many weaker memory models have been proposed, such as processor consistency [9], release consistency [7], location consistency <ref> [6] </ref>, scope consistency [10], eventual-serializability [5], dag-consistency [3], and others (see [1]). Unfortunately, these models are defined using different formalisms, and some of them do not even have formal definitions, making it hard to compare them rigorously.
Reference: 7. <author> K. Gharachorloo, D. Lenoski, J. Laudon, P. Gibbons, A. Gupta, and J. Hennessy. </author> <title> Memory consistency and event ordering in scalable shared-memory multiprocessors. </title> <booktitle> In Proc. of the 17th Int'l Symp. on Computer Architecture, </booktitle> <pages> pages 15-26, </pages> <address> Seattle, Washington, </address> <month> June </month> <year> 1990. </year>
Reference-contexts: Unfortunately, maintaining such guarantees is expensive, even impossible on some systems. Thus, some systems are willing to tolerate some inconsistency in order to improve performance. In order to reason about these systems, many weaker memory models have been proposed, such as processor consistency [9], release consistency <ref> [7] </ref>, location consistency [6], scope consistency [10], eventual-serializability [5], dag-consistency [3], and others (see [1]). Unfortunately, these models are defined using different formalisms, and some of them do not even have formal definitions, making it hard to compare them rigorously.
Reference: 8. <author> P. Gibbons and M. Merritt. </author> <title> Specifying nonblocking shared memories. </title> <booktitle> In Proc. of the Fourth ACM Symp. on Parallel Algorithms and Architectures, </booktitle> <month> June </month> <year> 1992. </year>
Reference-contexts: Many people have proposed different memory models (see [1] for an overview), but only a few have proposed a unified framework that can be used to compare different models. Gibbons and Merritt <ref> [8] </ref> present a framework to specify non-blocking shared memories, and they do so at roughly the same level as we do. Attiya, et al [2] present a higher level framework which also considers the control operations in programs.
Reference: 9. <author> J. R. Goodman. </author> <title> Cache consistency and sequential consistency. </title> <type> Technical Report 61, </type> <institution> IEEE Scalable Coherent Interface (SCI) Working Group, </institution> <month> Mar. </month> <year> 1989. </year>
Reference-contexts: Unfortunately, maintaining such guarantees is expensive, even impossible on some systems. Thus, some systems are willing to tolerate some inconsistency in order to improve performance. In order to reason about these systems, many weaker memory models have been proposed, such as processor consistency <ref> [9] </ref>, release consistency [7], location consistency [6], scope consistency [10], eventual-serializability [5], dag-consistency [3], and others (see [1]). Unfortunately, these models are defined using different formalisms, and some of them do not even have formal definitions, making it hard to compare them rigorously.
Reference: 10. <author> L. Iftode, J. P. Singh, and K. Li. </author> <title> Scope consistency: A bridge between release consistency and entry consistency. </title> <booktitle> In Proc. of the Eighth ACM Symp. on Parallel Algorithms and Architectures, </booktitle> <month> June </month> <year> 1996. </year>
Reference-contexts: Thus, some systems are willing to tolerate some inconsistency in order to improve performance. In order to reason about these systems, many weaker memory models have been proposed, such as processor consistency [9], release consistency [7], location consistency [6], scope consistency <ref> [10] </ref>, eventual-serializability [5], dag-consistency [3], and others (see [1]). Unfortunately, these models are defined using different formalisms, and some of them do not even have formal definitions, making it hard to compare them rigorously.
Reference: 11. <author> L. Lamport. </author> <title> How to make a multiprocessor computer that correctly executes multi process programs. </title> <journal> IEEE Transactions on Computers, </journal> <volume> C-28(9):690-691, </volume> <month> Sept. </month> <year> 1979. </year>
Reference-contexts: One common approach is to provide the processes with shared memory, which appears as though it is maintained by a single process. This provides programmers with relatively simple and intuitive semantics, called sequential consistency <ref> [11] </ref>. Unfortunately, maintaining such guarantees is expensive, even impossible on some systems. Thus, some systems are willing to tolerate some inconsistency in order to improve performance.
Reference: 12. <author> N. A. Lynch. </author> <title> Distributed Algorithms. </title> <publisher> Morgan Kaufmann Publishers, </publisher> <address> San Francisco, Calif., </address> <year> 1996. </year>
Reference-contexts: A serialization ff is consistent with a partial order if ff is, and it includes the partial order if ff does. 3 Formal Model We use a slight simplification of the I/O automaton of Lynch and Tuttle <ref> [12] </ref>, ignoring the aspects related to liveness. <p> Theorem 3. If there is a simulation from A to B then A B. 4 Serial Data Type This section introduces the formal framework to specify the serial semantics of shared objects. This is similar to the definitions of Lynch <ref> [12] </ref>.
Reference: 13. <institution> Supercomputing Technologies Group. Cilk 4.0 Reference Manual. MIT Laboratory for Computer Science, 545 Technology Square, </institution> <address> Cambridge, Massachusetts 02139, </address> <month> June </month> <year> 1996. </year> <title> This article was processed using the L A T E X macro package with LLNCS style </title>
Reference-contexts: Another drawback of sequential consistency and most of the models mentioned above is that the programmer must explicitly indicate which process issues each operation. Thus they cannot model systems such as Cilk <ref> [4, 13] </ref>, which do not make processes directly accessible to the programmer. ? Supported by AFOSR-ONR contract F49640-94-1-0199, by ARPA contracts N00014 92-J-4033 and F19628-95-C-0118, and by NSF grant 9225124-CCR. This paper presents a general framework for understanding precedence-based memory models, which are generalizations of standard multiprocessor models. <p> This prevents cyclic dependencies. We also maintain some useful bookkeeping variables. Note that this one automaton models all the clients together. This allows us to specify more general and abstract programming systems which may not have any explicit notion of processes, such as the Cilk system <ref> [4, 13] </ref>. This is important because the specification of practical programming systems is an active area of research. Systems in which the process that issues each request is explicit can easily be modelled in this framework by incorporating the process identifier into the operation identifier, or even the operator.
References-found: 13

