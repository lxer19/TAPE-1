URL: ftp://ftp.eecs.umich.edu/groups/gasm/manysort.ps.gz
Refering-URL: http://www.eecs.umich.edu/gasm/papers.html
Root-URL: http://www.eecs.umich.edu
Title: A Theory of Many-sorted Evolving Algebras  
Abstract-found: 0
Intro-found: 1
Reference: [AO91a] <author> K.R. Apt and E.-R. Olderog. </author> <title> Introduction to program verification. </title> <editor> In E.J. Neuhold and M. Paul, editors, </editor> <booktitle> Formal Description of Programming Concepts, </booktitle> <pages> pages 363-429. </pages> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1991. </year>
Reference-contexts: Hoare-style proof systems, also known as axiomatic semantics, can be seen as a tool to describe the semantics of programming languages. Many text books have been written on this subject, see for example <ref> [AO91a, AO91b, Dah92, Fra92] </ref>. In the area of evolving algebras not much has been done on this subject, with possible exception of [PH94]. However, in this paper another point of view is taken. The author aims at deriving partial correctness logics for deterministic sequential programming languages specified by EAs.
Reference: [AO91b] <author> K.R. Apt and E.-R. Olderog. </author> <title> Verification of Sequential and Concurrent Programs. Texts and Monographs in Computer Science. </title> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1991. </year>
Reference-contexts: Hoare-style proof systems, also known as axiomatic semantics, can be seen as a tool to describe the semantics of programming languages. Many text books have been written on this subject, see for example <ref> [AO91a, AO91b, Dah92, Fra92] </ref>. In the area of evolving algebras not much has been done on this subject, with possible exception of [PH94]. However, in this paper another point of view is taken. The author aims at deriving partial correctness logics for deterministic sequential programming languages specified by EAs. <p> Note that our treatment of the update rule by means of extended functions and terms differs from the usual one (see e.g. <ref> [AO91b] </ref>). Our notation is less general, but easier to read. After having defined a Fitch-style natural deduction system for E-logic, we presented a semantics for it based on partial structures with possibly empty domains. This was a natural step, as static algebras can be seen as partial structures without predicates. <p> For other constructs, a lot work has to be done probably. It is not unlikely that the work done in the field of axiomatic semantics for parallel and distributed programming languages (see e.g. <ref> [AO91b] </ref>) can be of use. 179 Furthermore, regarding our axiomatic proof system, one could ask the question of what happens if it is being restricted to evolving algebras without remove updates.
Reference: [Apt81] <author> K.R. Apt. </author> <title> Ten years of Hoare's Logic: A survey | Part I. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 3(4) </volume> <pages> 431-483, </pages> <year> 1981. </year>
Reference-contexts: But in that case, by 6.17 again, we also have J j= :#b, which clearly is a contradiction. We conclude that the system P is not complete. 6.1.34 Remark It might be the case that the system is complete in the sense of Cook (see e.g. <ref> [Apt81] </ref>) for EAs without contraction updates. This could be a topic for future research. 6.1. The proof system 163 Up to now, we have considered only partial correctness. Suppose that we have derived a correctness formula f'gRf g.
Reference: [Ast91] <author> E. Astesiano. </author> <title> Inductive and operational semantics. </title> <editor> In E.J. Neuhold and M. Paul, editors, </editor> <booktitle> Formal Description of Programming Concepts, </booktitle> <pages> pages 51-136. </pages> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1991. </year>
Reference-contexts: This kind of semantics was pioneered by Plotkin (see for example [Plo83]), and is covered nowadays in many textbooks on the semantics of programming languages (see, for example, [Hen90, NN92, SK95] for introductions, and <ref> [Ast91] </ref> for a more comprehensive account). In our version of EAs, extension updates are, in fact, compound updates, i.e. they are structured. It is possible that this kind of updates has to be executed in parallel with other updates, possibly structured as well.
Reference: [Bar85] <author> J. Barwise. </author> <title> Model-Theoretic Logics: Background and Aims, </title> <booktitle> chapter I in [BF85], </booktitle> <pages> pages 3-23. </pages> <publisher> Springer-Verlag, </publisher> <year> 1985. </year>
Reference-contexts: Which universes and which functions are in the standard part of a signature is solely depending on the application domain where the logic is used. In the literature standard logics which deal with natural numbers |in the sense that quantification over them is possible| are called !-logics (see e.g. <ref> [Bar85] </ref>). Due to Godels incompleteness theorem it is of course impossible to have a recursive axiomatization for these logics. As we will see, incompleteness can be repaired by taking as additional axioms all sentences which are true in the fixed structure, and by extending the notion of standard interpretation 4.4.
Reference: [BCGR94] <author> E. Borger, G. Del Casto, P. Glavan, and D. Rosenzweig. </author> <title> Towards a mathematical specification of the APE100 architecture: the APESE model. </title> <editor> In B. Pehrson and I. Simon, editors, </editor> <booktitle> IFIP 13th World Computer Congress 94, Volume I: Technology and Foundations, </booktitle> <pages> pages 396-401, </pages> <address> Amsterdam, 1994. </address> <publisher> North-Holland. </publisher>
Reference: [BF85] <editor> J. Barwise and S. Feferman, editors. </editor> <booktitle> Model-Theoretic Logics. Perspectives in Mathematical Logic. </booktitle> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1985. </year>
Reference: [BG94] <author> A. Blass and Y. Gurevich. </author> <title> Evolving algebras and linear time hierarchy. </title> <editor> In B. Pehrson and I. Simon, editors, </editor> <booktitle> IFIP 13th World Computer Congress 94, Volume I: Technology and Foundations, </booktitle> <pages> pages 383-390, </pages> <address> Amsterdam, 1994. </address> <publisher> North-Holland. </publisher>
Reference: [Bor90a] <author> E. Borger. </author> <title> A logical operational semantics of full Prolog; Part I: Selection core and control. </title> <editor> In E. Borger, H. Kleine Buning, and M.M. Richter, editors, </editor> <booktitle> Computer Science Logic; 3rd Workshop, </booktitle> <address> CSL'89; Kaiserslautern, FRG, </address> <month> October 2-6, </month> <year> 1989, </year> <booktitle> proceedings, </booktitle> <pages> pages 36-64, </pages> <address> Berlin, 1990. </address> <publisher> Springer-Verlag, LNCS 440. </publisher>
Reference: [Bor90b] <author> E. Borger. </author> <title> A logical operational semantics of full Prolog; Part II: Built-in predicates for database manipulations. </title> <editor> In B. Rovan, </editor> <title> 181 182 References editor, </title> <booktitle> Symposium on Mathematical Foundations of Computer Science; MFCS '90; Banska Bystrica, </booktitle> <address> Czechoslovakia, </address> <month> August 27-31, </month> <year> 1990, </year> <booktitle> proceedings, </booktitle> <pages> pages 1-14, </pages> <address> Berlin, 1990. </address> <publisher> Springer-Verlag, LNCS 452. </publisher>
Reference: [Bor92] <author> E. Borger. </author> <title> A logical operational semantics of full Prolog; Part III: Built-in predicates for files, terms, arithmetic and input-output. </title> <editor> In Y.N. Moschovakis, editor, </editor> <booktitle> Logic from Computer Science; proceedings of a workshop held November 13-17, 1989, </booktitle> <address> New York, 1992. </address> <publisher> Springer-Verlag, </publisher> <address> MSRI 21. </address>
Reference: [BP94] <editor> L.C. Beierle and L. Plumer, editors. </editor> <booktitle> Logic Programming: Formal Methods and Practical Applications. Series in Computer Science and Artificial Intelligence. </booktitle> <publisher> North-Holland, </publisher> <year> 1994. </year>
Reference: [BR92] <author> E. Borger and D. Rosenzweig. </author> <title> The WAM |definition and compiler correctness. </title> <type> Technical Report TR-14/92, </type> <institution> Universita degli Studi di Pisa, Dipartimento di Informatica, </institution> <address> Corso Italia 40, 56100 Pisa, Italy, </address> <month> June </month> <year> 1992. </year> <note> Also in [BP94]. </note>
Reference: [BR93] <author> E. Borger and E. Riccobene. </author> <title> A formal specification of Parlog. </title> <editor> In M. Droste and Y. Gurevich, editors, </editor> <booktitle> Semantics of Programming Languages and Model Theory, </booktitle> <pages> pages 1-42. </pages> <publisher> Gordon and Breach, </publisher> <year> 1993. </year>
Reference: [BR94] <author> E. Borger and D. Rosenzweig. </author> <title> A mathematical definition of full Prolog. </title> <booktitle> Science of Computer Programming, </booktitle> <year> 1994. </year>
Reference: [CDG96] <author> G. Del Castillo, I. Durdanovic, and U. Glasser. </author> <title> An Evolving Algebra Abstract Machine. </title> <editor> In H.K. Buning, editor, </editor> <booktitle> Computer Science Logic, Selected papers from CSL'95, </booktitle> <pages> pages 191-214, </pages> <address> Berlin, 1996. </address> <publisher> Springer-Verlag, LNCS 1092. </publisher>
Reference: [Che86] <author> J.H. Cheng. </author> <title> A Logic for Partial Functions. </title> <type> PhD thesis, </type> <institution> University of Manchester, </institution> <year> 1986. </year>
Reference: [CK90] <author> C.C. Chang and H.J. Keisler. </author> <title> Model Theory. </title> <booktitle> Studies in Logic and the Foundations of Mathematics, </booktitle> <volume> Volume 73. </volume> <publisher> North-Holland, </publisher> <address> Amsterdam, third edition, </address> <year> 1990. </year>
Reference-contexts: The converse need, of course, not to be true. For instance, it is well-known that structures exist which are elementary equivalent to the standard model of Peano arithmetic, but which are not isomorphic to it (see e.g. <ref> [CK90] </ref>). Although we call these structures `semis-tandard', they are usually called nonstandard. 4.4.7 Convention If 0 is a subsignature of , and A is a (semi)standard - structure with respect to 0 and B, then we will call 0 and B the standard parts of and A, respectively.
Reference: [Cli73] <author> M. Clint. </author> <title> Program proving: Coroutines. </title> <journal> Acta Informatica, </journal> <volume> 2 </volume> <pages> 50-63, </pages> <year> 1973. </year>
Reference-contexts: In this case, we will record its serial number (called index). This makes it possible to directly relate the position of a character in a string to the index of a node in the stack. The idea of auxiliary symbols is not new. In <ref> [Cli73] </ref> a correctness proof is given using so-called mythical variables. Updates of these variables in a program are put between quotes, meaning that these can be ingnored during runtime. They are only used in proving the correctness. <p> Updates of these variables in a program are put between quotes, meaning that these can be ingnored during runtime. They are only used in proving the correctness. The authors of [OG76] introduce a proof rule for auxiliary variables in this way formalizing the idea of <ref> [Cli73] </ref>. We will do so as well in the context of EAs.
Reference: [CM88] <author> K.M. Chandy and J. Misra. </author> <title> Parallel Program Design, A Foundation. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, Massachusetts, </address> <year> 1988. </year> <note> Reprinted in 1989. </note>
Reference: [Dah92] <author> O.-J. Dahl. </author> <title> Verifiable Programming. </title> <publisher> Prentice Hall International Series in Computer Science. Prentice Hall, </publisher> <address> New York, </address> <year> 1992. </year> <note> References 183 </note>
Reference-contexts: Hoare-style proof systems, also known as axiomatic semantics, can be seen as a tool to describe the semantics of programming languages. Many text books have been written on this subject, see for example <ref> [AO91a, AO91b, Dah92, Fra92] </ref>. In the area of evolving algebras not much has been done on this subject, with possible exception of [PH94]. However, in this paper another point of view is taken. The author aims at deriving partial correctness logics for deterministic sequential programming languages specified by EAs.
Reference: [Dil90] <author> A. Diller. </author> <title> Z, An Introduction to Formal Methods. </title> <publisher> John Wiley & Sons, </publisher> <address> Chichester, </address> <year> 1990. </year>
Reference: [Fit52] <author> F.B. Fitch. </author> <title> Symbolic Logic, An Introduction. </title> <publisher> Ronald Press, </publisher> <address> New York, </address> <year> 1952. </year>
Reference: [FJ92] <author> L.M.G. Feijs and H.B.M. Jonkers. </author> <title> Formal Specification and Design. </title> <booktitle> Cambridge tracts in theoretical computer science 35. </booktitle> <publisher> Cambridge University Press, </publisher> <address> Cambridge, UK, </address> <year> 1992. </year>
Reference: [Fra92] <author> N. Francez. </author> <title> Program Verification. </title> <booktitle> International Computer Science Series. </booktitle> <publisher> Addison-Wesley, </publisher> <address> Workingham, England, </address> <year> 1992. </year>
Reference-contexts: Hoare-style proof systems, also known as axiomatic semantics, can be seen as a tool to describe the semantics of programming languages. Many text books have been written on this subject, see for example <ref> [AO91a, AO91b, Dah92, Fra92] </ref>. In the area of evolving algebras not much has been done on this subject, with possible exception of [PH94]. However, in this paper another point of view is taken. The author aims at deriving partial correctness logics for deterministic sequential programming languages specified by EAs.
Reference: [Geu93] <author> J.H. </author> <title> Geuvers. Logics and Type Systems. </title> <type> PhD thesis, </type> <institution> University of Nijmegen, </institution> <address> Toernooiveld 1, 6525 ED Nijmegen, The Netherlands, </address> <year> 1993. </year>
Reference: [GH96] <author> Y. Gurevich and J.K. Huggins. </author> <title> The Railroad Crossing Problem: An experiment with instantaneous actions and immediate reactions. </title> <editor> In H.K. Buning, editor, </editor> <booktitle> Computer Science Logic, Selected papers from CSL'95, </booktitle> <pages> pages 266-290, </pages> <address> Berlin, 1996. </address> <publisher> Springer-Verlag, LNCS 1092. </publisher>
Reference: [GM88] <author> Y. Gurevich and J. Morris. </author> <title> Algebraic operational semantics and Modula-2. </title> <editor> In E. Borger, H. Kleine Buning, and M.M. Richter, editors, </editor> <booktitle> Computer Science Logic; 1st Workshop, </booktitle> <address> CSL'87; Karlsruhe, FRG, </address> <month> October 12-16, </month> <year> 1987, </year> <booktitle> proceedings proceedings, </booktitle> <pages> pages 81-101, </pages> <address> Berlin, 1988. </address> <publisher> Springer-Verlag, LNCS 329. </publisher>
Reference: [GM90] <author> Y. Gurevich and L. Moss. </author> <title> Algebraic operational semantics and Occam. </title> <editor> In E. Borger, H. Kleine Buning, and M.M. Richter, editors, </editor> <booktitle> Computer Science Logic; 3rd Workshop, </booktitle> <address> CSL'89; Kaiserslautern, FRG, </address> <month> October 2-6, </month> <year> 1989, </year> <booktitle> proceedings, </booktitle> <pages> pages 176-192, </pages> <address> Berlin, 1990. </address> <publisher> Springer-Verlag, LNCS 440. </publisher>
Reference: [GM95] <author> Y. Gurevich and R. Mani. </author> <title> Group membership protocol: Specification and verification. </title> <editor> In E. Borger, editor, </editor> <booktitle> Specification and Validation Methods, </booktitle> <pages> pages 295-328. </pages> <publisher> Clarendon Press, Oxford, </publisher> <year> 1995. </year>
Reference: [GR93] <author> P. Glavan and D. Rosenzweig. </author> <title> Communicating Evolving Algebras. </title> <editor> In E. Borger, G. Jager, and H. Kleine Buning, editors, </editor> <booktitle> Computer Science Logic; 6th Workshop, </booktitle> <address> CSL'92; San Miniato, Italy, </address> <month> Septem-ber 28 - October 2, </month> <year> 1992, </year> <title> selected papers, </title> <address> Berlin, 1993. </address> <publisher> Springer-Verlag, LNCS 702. </publisher>
Reference-contexts: Note that variable assignments are partial functions. This means that variables are not necessarily denoting terms. Here we differ from <ref> [GR93] </ref> who use total variable assignments. This is also the reason we have adopted E-logic, rather than E + -logic in which free variables are always denoting. <p> Moreover, let ' 2 Form. Then: Cons (V; ') ) Cons (U ; '): Proof This corollary follows from Proposition 5.2.22. 5.2.24 Convention Let R 2 Rule be the update if ' then U , then (following <ref> [GR93] </ref>) we will write: R? = '; 5.2.25 Definition A rule R 2 Rule is called consistent, if Cons (R!; R?). 5.2.26 Definition An evolving algebra is called consistent if all its rules are consistent.
Reference: [Gur88] <author> Y Gurevich. </author> <title> Logic and the challenge of computer science. </title> <editor> In E. Borger, editor, </editor> <booktitle> Trends in Theoretical Computer Science, chapter 1, </booktitle> <pages> pages 1-57. </pages> <publisher> Computer Science Press, </publisher> <address> Rockville, </address> <year> 1988. </year> <note> 184 References </note>
Reference: [Gur91] <author> Y. Gurevich. </author> <title> Evolving Algebras, a tutorial introduction. </title> <journal> Bulletin of the European Association for Theoretical Computer Science, </journal> <volume> 43 </volume> <pages> 264-284, </pages> <month> February </month> <year> 1991. </year>
Reference-contexts: On the other hand practice will learn us which features will survive, and which won't. The kind of formalization we have chosen is based on many-sorted algebras. In this respect we differ from the approach by Gurevich (see e.g. <ref> [Gur91, Gur95] </ref>) which is based on one-sorted algebras. It is well-known, however, that many-sorted systems can be simulated by one-sorted systems, and vice versa.
Reference: [Gur95] <author> Y Gurevich. </author> <title> Evolving Algebras 1993: Lipari guide. </title> <editor> In E. Borger, editor, </editor> <booktitle> Specification and Validation Methods, </booktitle> <pages> pages 9-36. </pages> <publisher> Clarendon Press, Oxford, </publisher> <year> 1995. </year>
Reference-contexts: On the other hand practice will learn us which features will survive, and which won't. The kind of formalization we have chosen is based on many-sorted algebras. In this respect we differ from the approach by Gurevich (see e.g. <ref> [Gur91, Gur95] </ref>) which is based on one-sorted algebras. It is well-known, however, that many-sorted systems can be simulated by one-sorted systems, and vice versa. <p> Allowing free variables can serve different purposes like bounded or unbounded parallelism and nondeterministic choice (see <ref> [Gur95] </ref>). We will not go into these possibilities here. 5.1.18 Example We will give an example of an evolving algebra R, such that R computes the reverse of a character string. First we specify the signature of R. <p> The Conversion Theorem shows that the extension variables behave like real bound variables. Due to this fact, our operational semantics is not sensitive to accidentally used variable names. The informal semantics in <ref> [Gur95] </ref> lacks this property. There it is assumed that bound and free variables are all different. The analysis of our semantics yielded two other interesting theorems. <p> In fact, this study can be extended in several ways. We will discuss some of these in the remainder of this chapter. The first possibility to extend our research program is by adding other evolving algebra constructs, especially those introduced in <ref> [Gur95] </ref> or the slightly different proposals in [Gur97]. These extensions include, more general rules, external functions, rules with first-order guards, declared variables, nondeterministic choice, and multi-agent evolving algebras. Since Gurevich makes no distinction between updates and rules, his rules can be more complex than ours. <p> However, if the nesting can be removed by rewriting the rule, nesting does not to be harmful per se. For instance, the if : : : then : : : elseif : : : then : : : endif proposed in <ref> [Gur95] </ref> can easily be removed. External functions are, from the evolving algebra point of view, a sort of oracles. At each invocation of an evolving algebra rule, the environment sets the value of the external functions. <p> Coping with external functions can be done by setting this hidden variable at each invocation of a rule at the level of the operational semantics. This implementation would be slightly different from the one in <ref> [Gur95] </ref>, where at each invocation of a rule an external function may be called only once. This ensures that the value of the external function is constant during the execution of the evolving algebra rule. Rules with first-order guards can straightforwardly be accounted for in our semantics.
Reference: [Gur97] <author> Y. Gurevich. </author> <note> The 1997 ASM Guide (in preparation), 1997. </note> <institution> University of Michigan, Electrical Engineering and Computer Science Department. </institution> <note> http://www.eecs.umich.edu/ealgebras/Guide97/. </note>
Reference-contexts: In fact, this study can be extended in several ways. We will discuss some of these in the remainder of this chapter. The first possibility to extend our research program is by adding other evolving algebra constructs, especially those introduced in [Gur95] or the slightly different proposals in <ref> [Gur97] </ref>. These extensions include, more general rules, external functions, rules with first-order guards, declared variables, nondeterministic choice, and multi-agent evolving algebras. Since Gurevich makes no distinction between updates and rules, his rules can be more complex than ours. According to his definition, rules can be arbitrarily nested.
Reference: [GW88] <author> J.A. Goguen and T. Winkler. </author> <title> Introducing OBJ3. </title> <type> Technical Report SRI-CSL-88-9, </type> <institution> Computer Science Laboratory, SRI International, </institution> <address> 333 Ravenswood Avenue, Menlo Park, California 94025, U.S.A., </address> <month> August </month> <year> 1988. </year>
Reference: [Har79] <author> D. Harel. </author> <title> First-Order Dynamic Logic, </title> <booktitle> volume 68 of Lecture Notes in Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1979. </year>
Reference: [Har84] <author> D. Harel. </author> <title> Dynamic Logic. </title> <editor> In D. Gabbay and F. Guenthner, editors, </editor> <booktitle> Handbook of Philosophical Logic, Volume II, chapter II.10, </booktitle> <pages> pages 497-604. </pages> <address> D. </address> <publisher> Reidel Publishing Company, </publisher> <address> Dordrecht, </address> <year> 1984. </year>
Reference: [Hen90] <author> M. Hennessy. </author> <title> The Semantics of Programming Languages, An elementary Introduction using Structural Operational Semantics. </title> <publisher> John Wiley & Sons, </publisher> <address> Chichester, England, </address> <year> 1990. </year>
Reference-contexts: The kind of formalism in which we will express the semantics, will be Structural Operational Semantics. This kind of semantics was pioneered by Plotkin (see for example [Plo83]), and is covered nowadays in many textbooks on the semantics of programming languages (see, for example, <ref> [Hen90, NN92, SK95] </ref> for introductions, and [Ast91] for a more comprehensive account). In our version of EAs, extension updates are, in fact, compound updates, i.e. they are structured. It is possible that this kind of updates has to be executed in parallel with other updates, possibly structured as well.
Reference: [HF92] <author> P. Hudak and J.H. Fasel. </author> <title> A gentle introduction to haskell. </title> <journal> SIG-PLAN Notices, </journal> <volume> 27(5), </volume> <month> May </month> <year> 1992. </year>
Reference: [Hug97] <author> J. Huggings. </author> <title> Web site: Abstract State Machines (Evolving Algebras), </title> <note> 1997. http://www.eecs.umich.edu/ealgebras/. </note>
Reference: [Jen92] <author> K. Jensen. </author> <title> Coloured Petri Nets; basic concepts, analysis methods and practical use. Vol 1. </title> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1992. </year>
Reference: [JM93] <author> C.B. Jones and C.A. Middelburg. </author> <title> A typed logic of partial functions reconstructed classically. </title> <type> Technical Report 89, </type> <institution> Department of Philosophy, Utrecht University, Heidelberglaan 8, 3584 CS Utrecht, </institution> <address> The Netherlands, </address> <month> April </month> <year> 1993. </year>
Reference: [Jon90] <author> C.B. Jones. </author> <title> Systematic Software Development using VDM. </title> <publisher> Prentice Hall International Series in Computer Science. Prentice Hall, </publisher> <address> New York, </address> <note> second edition, </note> <year> 1990. </year>
Reference: [KU58] <author> A.N. Kolmogorov and V.A. Uspensky. </author> <title> On the definition of an algorithm. </title> <journal> Uspekhi Mat. Nauk, </journal> <volume> 13(4) </volume> <pages> 3-28, </pages> <year> 1958. </year> <title> Translation in English: AMS Translations, </title> <booktitle> series 2, </booktitle> <volume> vol. 21 </volume> <pages> 217-245, </pages> <year> 1963. </year> <note> References 185 </note>
Reference: [Kup94] <author> J. Kuper. </author> <title> Partiality in Logic and Computation, |Aspects of Un-definedness. </title> <type> PhD thesis, </type> <institution> University of Twente, </institution> <year> 1994. </year>
Reference: [Man93] <author> M. Manzano. </author> <title> Introduction to many-sorted logic. </title> <editor> In K. Meinke and J.V. Tucker, editors, </editor> <title> Many-Sorted Logic and its Applications, </title> <booktitle> chapter 1, </booktitle> <pages> pages 3-86. </pages> <publisher> John Wiley & Sons, </publisher> <address> Chichester, England, </address> <year> 1993. </year>
Reference: [Mor88] <author> J. Morris. </author> <title> Algebraic Operational Semantics for Modula 2. </title> <type> PhD thesis, </type> <institution> University of Michigan, </institution> <year> 1988. </year>
Reference: [NN92] <author> H.R. Nielson and F. Nielson. </author> <title> Semantics with Applications, A Formal Introduction. </title> <publisher> Wiley Professional Computing. John Wiley & Sons, </publisher> <address> Chichester, England, </address> <year> 1992. </year>
Reference-contexts: The kind of formalism in which we will express the semantics, will be Structural Operational Semantics. This kind of semantics was pioneered by Plotkin (see for example [Plo83]), and is covered nowadays in many textbooks on the semantics of programming languages (see, for example, <ref> [Hen90, NN92, SK95] </ref> for introductions, and [Ast91] for a more comprehensive account). In our version of EAs, extension updates are, in fact, compound updates, i.e. they are structured. It is possible that this kind of updates has to be executed in parallel with other updates, possibly structured as well.
Reference: [NPS90] <author> B. Nordstrom, K. Petersson, and J.M. Smith. </author> <title> Programming in Martin-Lof's Type Theory: An Introduction. </title> <publisher> Oxford Science Publications, </publisher> <year> 1990. </year>
Reference: [OG76] <author> S. Owicki and D. Gries. </author> <title> An axiomatic proof technique for parallel programs I. </title> <journal> Acta Informatica, </journal> <volume> 6 </volume> <pages> 319-340, </pages> <year> 1976. </year>
Reference-contexts: The idea of auxiliary symbols is not new. In [Cli73] a correctness proof is given using so-called mythical variables. Updates of these variables in a program are put between quotes, meaning that these can be ingnored during runtime. They are only used in proving the correctness. The authors of <ref> [OG76] </ref> introduce a proof rule for auxiliary variables in this way formalizing the idea of [Cli73]. We will do so as well in the context of EAs.
Reference: [PH94] <author> A. Poetzsch-Heffter. </author> <title> Deriving partial correctness logics from evolving algebras. </title> <editor> In B. Pehrson and I. Simon, editors, </editor> <booktitle> IFIP 13th World Computer Congress 94, Volume I: Technology and Foundations, </booktitle> <pages> pages 434-439, </pages> <address> Amsterdam, 1994. </address> <publisher> North-Holland. </publisher>
Reference-contexts: Many text books have been written on this subject, see for example [AO91a, AO91b, Dah92, Fra92]. In the area of evolving algebras not much has been done on this subject, with possible exception of <ref> [PH94] </ref>. However, in this paper another point of view is taken. The author aims at deriving partial correctness logics for deterministic sequential programming languages specified by EAs. We will directly address the problem of developing a (partial and total) correctness logic for EAs themselves.
Reference: [Plo83] <author> G. Plotkin. </author> <title> An operational semantics for CSP. </title> <editor> In D. Bjorner, editor, </editor> <booktitle> Proceedings IFIP TC 2 Working Conference: Formal Description of Programming Concepts - II, </booktitle> <pages> pages 199-223, </pages> <address> Amsterdam, 1983. </address> <publisher> North-Holland. </publisher>
Reference-contexts: The kind of formalism in which we will express the semantics, will be Structural Operational Semantics. This kind of semantics was pioneered by Plotkin (see for example <ref> [Plo83] </ref>), and is covered nowadays in many textbooks on the semantics of programming languages (see, for example, [Hen90, NN92, SK95] for introductions, and [Ast91] for a more comprehensive account). In our version of EAs, extension updates are, in fact, compound updates, i.e. they are structured.
Reference: [RdL84] <author> G.R. Renardel de Lavalette. </author> <title> Theories with Type-Free Application and Extended Bar Induction. </title> <type> PhD thesis, </type> <institution> University of Amsterdam, </institution> <year> 1984. </year>
Reference: [Rei87] <author> H. Reichel. </author> <title> Initial Computability, Algebraic Specifications, and Partial Algebras, </title> <booktitle> volume 2 of The International Series of Monographs on Computer Science. </booktitle> <publisher> Clarendon Press, Oxford, </publisher> <year> 1987. </year>
Reference-contexts: Like structures for so-called free logic, structures for E-logic may have empty domains. Moreover, functions on these structures are allowed to be partial. These so-called partial structures, which we will define in Section 4.1, are straightforward generalizations of partial algebras (see <ref> [Rei87] </ref>) which deal with partial functions. In partial structures also predicates are interpreted. Their denotation will not be partial, however. Section 4.2 deals with operations on interpretations. One of these operations, the modification operator, changes the interpretation of function symbols.
Reference: [Sch80] <author> A. Schonhage. </author> <title> Storage Modification Machines. </title> <journal> SIAM J. on Computing, </journal> <volume> 9(3) </volume> <pages> 490-508, </pages> <year> 1980. </year>
Reference: [Sco67] <author> D. Scott. </author> <title> Existence and description in formal logic. </title> <editor> In R. Schoen-man, editor, Bertrand Russell, </editor> <booktitle> Philosopher of the Century, chapter 16, </booktitle> <pages> pages 181-200. </pages> <publisher> George Allen & Unwin Ltd, </publisher> <address> London, </address> <year> 1967. </year> <note> 186 References </note>
Reference: [Sco79] <author> D.S. Scott. </author> <title> Identity and existence in intuitionistic logic. In M.P. </title> <editor> Fourman, C.J. Mulvey, and D.S. Scott, editors, </editor> <booktitle> Applications of Sheaves, Proceedings, Durham 1977, </booktitle> <pages> pages 660-696, </pages> <address> Berlin, 1979. </address> <publisher> Springer-Verlag. </publisher>
Reference: [SK95] <author> K. Slonneger and B.L. Kurtz. </author> <title> Formal Syntax and Semantics of Programming Languages |A laboratory based approach. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, Massachusetts, </address> <year> 1995. </year>
Reference-contexts: The kind of formalism in which we will express the semantics, will be Structural Operational Semantics. This kind of semantics was pioneered by Plotkin (see for example [Plo83]), and is covered nowadays in many textbooks on the semantics of programming languages (see, for example, <ref> [Hen90, NN92, SK95] </ref> for introductions, and [Ast91] for a more comprehensive account). In our version of EAs, extension updates are, in fact, compound updates, i.e. they are structured. It is possible that this kind of updates has to be executed in parallel with other updates, possibly structured as well.
Reference: [TD88] <author> A.S. Troelstra and D. van Dalen. </author> <title> Constructivism in Mathematics, An Introduction, Volume I, </title> <booktitle> volume 21 of Studies in Logic and the Foundations of Mathematics. </booktitle> <publisher> North-Holland, </publisher> <address> Amsterdam, </address> <year> 1988. </year>
Reference-contexts: A Fitch-style deduction system for E-logic 33 3.3.6 Remark In the version of E-logic described in <ref> [TD88] </ref> a rule called sub is used, which, under certain conditions, allows to instantiate free variables by terms. Since we introduced a special term ? to denote the `undefined value', we do not need this rule. <p> In fact, the formula 8x u ' ^ '[x u :=?] expresses that ' holds for any term substituted for x u , even if it is non-denoting. As a result, in our logic free variables are not schematic, as in <ref> [TD88] </ref>, which simplifies the semantics of free variables. 3.3.7 Remark If we leave out rule :E, we have an intuitionistic variant of E-logic. 3.3.8 Definition Let ' 2 Form and Form.
Reference: [TF92] <author> H. Tonino and K.-E. Fujita. </author> <title> On the adequacy of representing higher order intuitionistic logic as a pure type system. </title> <journal> Annals of Pure and Applied Logic, </journal> <volume> 57 </volume> <pages> 251-276, </pages> <year> 1992. </year>
Reference: [TV96] <author> H. Tonino and J. Visser. </author> <title> Stepwise refinement of an abstract state machine for WHNF-reduction of lambda terms. </title> <type> Technical Report 96-154, </type> <institution> Faculty of Technical Mathematics and Informatics, Delft University of Technology, </institution> <address> Zuidplantsoen 4, 2628 BZ Delft, The Netherlands, </address> <month> December </month> <year> 1996. </year>
Reference: [Vis96] <author> J.M.W. </author> <title> Visser. </title> <type> Evolving algebras (master's thesis). Technical report, </type> <institution> Faculty of Technical Mathematics and Informatics, Delft University of Technology, </institution> <address> Zuidplantsoen 4, 2628 BZ Delft, The Nether-lands, </address> <year> 1996. </year>
Reference-contexts: Section 4.4), standard interpretations are the most natural candidates for being called `states'. In actual implementations of evolving algebras only the dynamic universes, functions and constants will be implemented, however. The static functions and constants will be explicitly presented as values and routines, respectively (see e.g. <ref> [Vis96] </ref>). 5.2.35 Remark The transition rule for extension updates is nondeterministic: the actual choice of the element d 2 D is free. <p> Probably, the Fitch-style inference system is not of very much use in that case. Rather, a resolution-based prover should be developed and implemented to achieve this goal. A third topic for further study has to do with evolving algebra interpreters and pragmatics. The evolving algebra interpreter described in <ref> [Vis96] </ref> can be extended to cope with the extensions of evolving algebras we discussed above. The current interpreter does not accept evolving algebras with remove updates, however. This feature has still to be implemented. A special feature of the implementation concerns modules.

References-found: 63

