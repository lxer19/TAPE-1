URL: http://www.cs.wustl.edu/cs/techreports/1995/wucs-95-21.ps.Z
Refering-URL: http://www.cs.wustl.edu/cs/cs/publications.html
Root-URL: http://www.cs.wustl.edu
Title: Efficient Demultiplexing of Network Packets by Automatic Parsing  
Author: Mahesh Jayaram Ron K. Cytron wucs-- 
Note: This work supported by the National Science Foundation Grant NCR-9405444  
Address: Campus Box 1045  One Brookings Drive St. Louis, MO 63130-4899  
Affiliation: Department of Computer Science  Washington University  
Date: July 19, 1995  
Abstract-found: 0
Intro-found: 1
Reference: [ABB + 86] <author> M. J. Accetta, R. V. Baron, W. Bolosky, D. B. Golub, R. F. Rashid, A. Tevanian. Jr, and M. W. Young. </author> <title> Mach: A new kernel foundation for unix development. </title> <booktitle> In Winter 1986 USENIX Conference, </booktitle> <month> July </month> <year> 1986. </year>
Reference-contexts: Moreover, implementing protocols in the user space hides protocol-specific details from the kernel, greatly reducing its complexity. However, the performance of user-level protocols depends on how efficiently packets are demultiplexed to the user space. Packet filters help in producing efficient user-level protocols. In the Mach operating system <ref> [ABB + 86] </ref>, MPF supports protocol 2 processing in the user endpoint. The user process contains the whole protocol stack, and is responsible for the entire protocol processing. MPF demultiplexes incoming packets to the appropriate endpoint.
Reference: [App91] <author> Andrew W. Appel. </author> <title> Garbage collection. </title> <editor> In Peter Lee, editor, </editor> <booktitle> Topics in Advanced Language Implementation, chapter 4. </booktitle> <publisher> The MIT Press, </publisher> <year> 1991. </year>
Reference-contexts: In systems with virtual memory hardware, the cost of maintaining safety is mini mal <ref> [App91] </ref>, especially where safety is not violated. Specification generality: The specification language, LR grammars, is powerful enough to allow easy specification of different kinds of filters. For example, no special treat ment is needed for packets with varying length fields.
Reference: [BGS + 94] <author> M. L. Bailey, B. Gopal, P. Sarkar, M. A. Pagels, and L. L. Peterson. Pathfinder: </author> <title> A pattern-based packet classifier. </title> <booktitle> In Proceedings of the 1 st Symposium on Operating System Design and Implementation. USENIX, </booktitle> <month> November </month> <year> 1994. </year>
Reference-contexts: The code could be compiled and executed for greater efficiency, if the security of executing the packet filter were not a concern. 3 * Alternately the specification can be in the form of a pattern, or a set of rules <ref> [BGS + 94] </ref>. The filter mechanism then checks whether a packet conforms to the pattern. This is the approach followed in this paper. There are a number of properties desirable in any packet filtering mechanism: 1. It must be protocol independent and able to support filters for different protocols. 2. <p> Existing packet filter mechanisms CSPF [MRA87] and BPF [MJ93] are interpreter-based filter mechanisms that do not support composition. MPF [YBMM94] is similar to BPF but adds support for composing filter specifications for special cases and for dealing with fragmented packets. PathFinder <ref> [BGS + 94] </ref> is a pattern-based filtering mechanism that allows a greater degree of composition than MPF and allows for an efficient implementation. We discuss the above filter mechanisms in greater detail in Section 5. <p> In the IP header, the Flags and Fragment Offset fields are used to detect fragmentation. The above approach of dealing with fragmentation is the simplest, and may involve some overhead for fragmented packets; however, with some modifications, other meth ods <ref> [YBMM94, BGS + 94] </ref> can be incorporated in our filtering mechanism. 2 One might be concerned that a packet specifications beyond context-free might be necessary. <p> Related Work In this section we describe related work in the areas of packet filters and LR parsing . We discuss four major packet filter schemes: CSPF [MRA87], BPF [MJ93], MPF [YBMM94], PathFinder <ref> [BGS + 94] </ref>.
Reference: [Bra88] <author> R. T. Braden. </author> <title> A pseudo-machine for packet monitoring and statistics. </title> <booktitle> In Proceedings of the Symposium on Communications Architectures and Protocols(SIGCOMM), </booktitle> <address> Stanford, CA, </address> <month> August </month> <year> 1988. </year> <note> ACM. </note>
Reference-contexts: Such applications are abundant, spanning diverse domains including satellite communication systems, network management systems, real-time market data analysis systems, on-line news services, distributed systems, and active databases <ref> [isi94, Bra88, nit90, MRA87, GJS94] </ref>.
Reference: [DDH84] <author> P. Dencker, K. Durre, and J. Heuft. </author> <title> Optimization of parser tables for portable compilers. </title> <journal> ACM Trans. Prog. Lang. and Systems, </journal> <volume> 6(4), </volume> <year> 1984. </year>
Reference-contexts: LR parsing optimizations:. There has been a lot of work in optimizing LR parsing. Some of the optimizations have been : optimization of the driver program of LR parsing [Gro88] , converting table-driven LR parsers to directly executable code [Pen86], reducing storage requirements for parsers <ref> [DDH84] </ref>, making stack access optimizations [HW90]. As of now, there has been no attempt to skip past input tokens which are irrelevant to the process of parsing or matching multiple tokens simultaneously, as suggested in this paper.
Reference: [GJS94] <author> N. Gehani, H. V. Jagadish, and O. Shmueli. Compose: </author> <title> A system for composite event specification and detection. In Book chapter in Advanced Database Concepts and Research Issues (N. </title> <editor> R. Adam and B. Bhargava, eds.), </editor> <booktitle> Lecture Notes in Computer Science. </booktitle> <publisher> Springer Verlag, </publisher> <year> 1994. </year>
Reference-contexts: Such applications are abundant, spanning diverse domains including satellite communication systems, network management systems, real-time market data analysis systems, on-line news services, distributed systems, and active databases <ref> [isi94, Bra88, nit90, MRA87, GJS94] </ref>.
Reference: [Gro88] <author> J. Grosch. </author> <title> Generators for high-speed front ends. </title> <type> Technical Report 11, </type> <institution> University of Karlsruhe, </institution> <month> September </month> <year> 1988. </year>
Reference-contexts: LR parsing optimizations:. There has been a lot of work in optimizing LR parsing. Some of the optimizations have been : optimization of the driver program of LR parsing <ref> [Gro88] </ref> , converting table-driven LR parsers to directly executable code [Pen86], reducing storage requirements for parsers [DDH84], making stack access optimizations [HW90].
Reference: [Hor90] <author> R. N. Horspool. </author> <title> Incremental generation of LR parsers. </title> <journal> Computer Languages, </journal> <volume> 15(4), </volume> <year> 1990. </year>
Reference-contexts: We expect that incorporating this optimization should improve performance significantly. Another improvement to be made to the filter mechanism is to make dynamic installation and removal of filters efficient. For this we hope to profit from the work done in incremental parser generation <ref> [Hor90] </ref>. Incremental parser generating techniques address the problem of incrementally modifying parse tables when the grammar is modified. The motivation behind incremental parser generation is to be able to efficiently accomodate small changes to the grammar and avoid the computational effort involved in analyzing the full grammar.
Reference: [HW90] <author> R. Nigel. Horspool and Michael Whitney. </author> <title> Even faster LR parsing. </title> <journal> Software-Practice and Experience, </journal> <volume> 20(6), </volume> <month> June </month> <year> 1990. </year>
Reference-contexts: A tool such as yacc [Joh79] then generates an LR parse table for the grammar, assuming the grammar presents no conflicts. As discussed in Section 3, we optimize the tables produced by yacc, in a manner quite different from optimizations typically seen in the context of parsing programming languages <ref> [Pen86, HW90] </ref>. The tables are in fact optimized for a modified LR parsing engine, which has the ability to skip tokens. It is this engine (driven by the optimized LR table) that acts as a packet filter, accepting packets conforming to the grammar specification. <p> Related Work In this section we describe related work in the areas of packet filters and LR parsing . We discuss four major packet filter schemes: CSPF [MRA87], BPF [MJ93], MPF [YBMM94], PathFinder [BGS + 94]. We also discuss related work in optimizing LR parsing <ref> [Pen86, HW90] </ref>. 0 1 2 0 20 40 60 80 100 Filtering time (msecs) Number of endpoints BPF (warm cache) Grammar-based filter (warm cache) BPF (cold cache) Grammar-based filter (cold cache) Packet size (bytes) Time (msecs) 500 0.070 1500 0.190 Machine: Sun 4/300 Sparc 5 Sparc 20 OS: NetBSD SunOS SunOS <p> There has been a lot of work in optimizing LR parsing. Some of the optimizations have been : optimization of the driver program of LR parsing [Gro88] , converting table-driven LR parsers to directly executable code [Pen86], reducing storage requirements for parsers [DDH84], making stack access optimizations <ref> [HW90] </ref>. As of now, there has been no attempt to skip past input tokens which are irrelevant to the process of parsing or matching multiple tokens simultaneously, as suggested in this paper. <p> In the case of TCP Connections a large percentage of pushes are redundant. This is due to the fact that after performing our optimizations, a number of states are skipped and never entered, though they may still be pushed onto the stack. <ref> [HW90] </ref> discusses a technique of avoiding such redundant activity . Significant performance improvement is reported even for grammars which do not have much redundancy. We expect that incorporating this optimization should improve performance significantly.
Reference: [isi94] <institution> Isis Distributed Systems Inc., </institution> <month> Marlboro, </month> <title> MA, Isis User's Guide: Reliable Distributed Objects for C++, </title> <month> April </month> <year> 1994. </year>
Reference-contexts: Such applications are abundant, spanning diverse domains including satellite communication systems, network management systems, real-time market data analysis systems, on-line news services, distributed systems, and active databases <ref> [isi94, Bra88, nit90, MRA87, GJS94] </ref>.
Reference: [JLM89] <author> V. Jacobson, C. Leres, and S. McCanne. </author> <title> The Tcpdump Manual Page. </title> <institution> Lawrence Berkeley Laboratory, Berkeley, </institution> <address> CA, </address> <month> June </month> <year> 1989. </year>
Reference-contexts: They help developers and maintainers of software to detect and solve network problems. They can also be used to monitor performance of communication software. To build such tools, the kernel must provide user programs access to unprocessed network traffic efficiently. Tcpdump <ref> [JLM89] </ref>, Arpwatch [Ler92], and Sun's NIT [nit90] are examples of tools that use a packet filtering mechanism. User level protocols: As has already been mentioned, it is difficult to implement protocols in the kernel, as kernel resident code is typically difficult to write, maintain, and debug.
Reference: [Joh79] <author> S. C. Johnson. </author> <title> YACC yet another compiler compiler in UNIX Programmer's manual, </title> <address> 7 edition, </address> <year> 1979. </year> <month> 22 </month>
Reference-contexts: Figure 3 shows the basic filtering mechanism. The pattern to be matched in the packets is encoded in the form of an LR grammar, so that the desired packets form the language recognized by the grammar. A tool such as yacc <ref> [Joh79] </ref> then generates an LR parse table for the grammar, assuming the grammar presents no conflicts. As discussed in Section 3, we optimize the tables produced by yacc, in a manner quite different from optimizations typically seen in the context of parsing programming languages [Pen86, HW90].
Reference: [Ler92] <author> C. Leres. </author> <title> The Arpwatch Manual Page. </title> <institution> Lawrence Berkeley Laboratory, Berkeley, </institution> <address> CA, </address> <month> Sept. </month> <year> 1992. </year>
Reference-contexts: They help developers and maintainers of software to detect and solve network problems. They can also be used to monitor performance of communication software. To build such tools, the kernel must provide user programs access to unprocessed network traffic efficiently. Tcpdump [JLM89], Arpwatch <ref> [Ler92] </ref>, and Sun's NIT [nit90] are examples of tools that use a packet filtering mechanism. User level protocols: As has already been mentioned, it is difficult to implement protocols in the kernel, as kernel resident code is typically difficult to write, maintain, and debug.
Reference: [MJ93] <author> Steven McCanne and Van Jacobson. </author> <title> The BSD Packet Filter. </title> <booktitle> In Winter USENIX, </booktitle> <pages> pages 259-269, </pages> <month> January </month> <year> 1993. </year>
Reference-contexts: Depending on the specification, filtering mechanisms are of two kinds: * The specification can take the form of code in a filter language, which is interpreted by the filtering mechanism to test whether the packet is to be accepted <ref> [MRA87, MJ93, YBMM94] </ref>. The code could be compiled and executed for greater efficiency, if the security of executing the packet filter were not a concern. 3 * Alternately the specification can be in the form of a pattern, or a set of rules [BGS + 94]. <p> To improve scalability it is desirable to be able to combine individual specifications into a composite specification. This would enable the filter mechanism to determine which applications should receive the packet in just a single pass over a packet. Existing packet filter mechanisms CSPF [MRA87] and BPF <ref> [MJ93] </ref> are interpreter-based filter mechanisms that do not support composition. MPF [YBMM94] is similar to BPF but adds support for composing filter specifications for special cases and for dealing with fragmented packets. <p> Related Work In this section we describe related work in the areas of packet filters and LR parsing . We discuss four major packet filter schemes: CSPF [MRA87], BPF <ref> [MJ93] </ref>, MPF [YBMM94], PathFinder [BGS + 94].
Reference: [MRA87] <author> Jeffrey C. Mogul, Richard F. Rashid, and Michael J. Accetta. </author> <title> The Packet Filter: An efficient mechanism for user-level network code. </title> <booktitle> In Proceedings of 11th Symposium on Operating Systems Principles. ACM, </booktitle> <pages> pages 39-51, </pages> <month> November </month> <year> 1987. </year>
Reference-contexts: However this requires the kernel to determine the final endpoint of each received packet. Packet filter:. To overcome the disadvantages of the above two approaches, the idea of packet filtering was developed <ref> [MRA87] </ref>, as depicted in Figure 1 (Right). A packet filter mechanism is essentially a kernel agent close to the network device that checks incoming packets and sends them to the appropriate user endpoints. <p> Such applications are abundant, spanning diverse domains including satellite communication systems, network management systems, real-time market data analysis systems, on-line news services, distributed systems, and active databases <ref> [isi94, Bra88, nit90, MRA87, GJS94] </ref>. <p> Depending on the specification, filtering mechanisms are of two kinds: * The specification can take the form of code in a filter language, which is interpreted by the filtering mechanism to test whether the packet is to be accepted <ref> [MRA87, MJ93, YBMM94] </ref>. The code could be compiled and executed for greater efficiency, if the security of executing the packet filter were not a concern. 3 * Alternately the specification can be in the form of a pattern, or a set of rules [BGS + 94]. <p> To improve scalability it is desirable to be able to combine individual specifications into a composite specification. This would enable the filter mechanism to determine which applications should receive the packet in just a single pass over a packet. Existing packet filter mechanisms CSPF <ref> [MRA87] </ref> and BPF [MJ93] are interpreter-based filter mechanisms that do not support composition. MPF [YBMM94] is similar to BPF but adds support for composing filter specifications for special cases and for dealing with fragmented packets. <p> Related Work In this section we describe related work in the areas of packet filters and LR parsing . We discuss four major packet filter schemes: CSPF <ref> [MRA87] </ref>, BPF [MJ93], MPF [YBMM94], PathFinder [BGS + 94].
Reference: [nit90] <institution> Sun Microsystems Inc. Mountain View, CA, </institution> <note> NIT(4P); SunOS 4.11 Reference Manual, </note> <month> Oct. </month> <year> 1990. </year>
Reference-contexts: They help developers and maintainers of software to detect and solve network problems. They can also be used to monitor performance of communication software. To build such tools, the kernel must provide user programs access to unprocessed network traffic efficiently. Tcpdump [JLM89], Arpwatch [Ler92], and Sun's NIT <ref> [nit90] </ref> are examples of tools that use a packet filtering mechanism. User level protocols: As has already been mentioned, it is difficult to implement protocols in the kernel, as kernel resident code is typically difficult to write, maintain, and debug. Thus it is desirable to implement protocols in user space. <p> Such applications are abundant, spanning diverse domains including satellite communication systems, network management systems, real-time market data analysis systems, on-line news services, distributed systems, and active databases <ref> [isi94, Bra88, nit90, MRA87, GJS94] </ref>.
Reference: [Pen86] <author> T. J. Pennello. </author> <title> Very fast LR parsing. </title> <journal> ACM SIGPLAN Notices, </journal> <volume> 21(7), </volume> <year> 1986. </year>
Reference-contexts: A tool such as yacc [Joh79] then generates an LR parse table for the grammar, assuming the grammar presents no conflicts. As discussed in Section 3, we optimize the tables produced by yacc, in a manner quite different from optimizations typically seen in the context of parsing programming languages <ref> [Pen86, HW90] </ref>. The tables are in fact optimized for a modified LR parsing engine, which has the ability to skip tokens. It is this engine (driven by the optimized LR table) that acts as a packet filter, accepting packets conforming to the grammar specification. <p> Related Work In this section we describe related work in the areas of packet filters and LR parsing . We discuss four major packet filter schemes: CSPF [MRA87], BPF [MJ93], MPF [YBMM94], PathFinder [BGS + 94]. We also discuss related work in optimizing LR parsing <ref> [Pen86, HW90] </ref>. 0 1 2 0 20 40 60 80 100 Filtering time (msecs) Number of endpoints BPF (warm cache) Grammar-based filter (warm cache) BPF (cold cache) Grammar-based filter (cold cache) Packet size (bytes) Time (msecs) 500 0.070 1500 0.190 Machine: Sun 4/300 Sparc 5 Sparc 20 OS: NetBSD SunOS SunOS <p> LR parsing optimizations:. There has been a lot of work in optimizing LR parsing. Some of the optimizations have been : optimization of the driver program of LR parsing [Gro88] , converting table-driven LR parsers to directly executable code <ref> [Pen86] </ref>, reducing storage requirements for parsers [DDH84], making stack access optimizations [HW90]. As of now, there has been no attempt to skip past input tokens which are irrelevant to the process of parsing or matching multiple tokens simultaneously, as suggested in this paper.
Reference: [Sch94] <author> Douglas C. Schmidt. </author> <title> High-Performance Event Filtering for Dynamic Multi-point Applications. In 1 st Workshop on High Performance Protocol Architectures (HIPPARCH), </title> <institution> Sophia Antipolis, France, </institution> <month> December </month> <year> 1994. </year> <note> INRIA. </note>
Reference-contexts: The user process contains the whole protocol stack, and is responsible for the entire protocol processing. MPF demultiplexes incoming packets to the appropriate endpoint. High-performance event filters: One application of packet filters which is as yet unexplored is as high performance event filters for dynamic multipoint (DMP) applications <ref> [Sch94] </ref>. Such applications are abundant, spanning diverse domains including satellite communication systems, network management systems, real-time market data analysis systems, on-line news services, distributed systems, and active databases [isi94, Bra88, nit90, MRA87, GJS94].
Reference: [YBMM94] <author> Masanobu Yuhara, Brian. N. Bershad, Chris Maeda, and J. Elliot B. Moss. </author> <title> Efficient packet demultiplexing for multiple endpoints and large messages. </title> <booktitle> In Winter 1994 USENIX Conference, </booktitle> <month> January </month> <year> 1994. </year> <month> 23 </month>
Reference-contexts: Depending on the specification, filtering mechanisms are of two kinds: * The specification can take the form of code in a filter language, which is interpreted by the filtering mechanism to test whether the packet is to be accepted <ref> [MRA87, MJ93, YBMM94] </ref>. The code could be compiled and executed for greater efficiency, if the security of executing the packet filter were not a concern. 3 * Alternately the specification can be in the form of a pattern, or a set of rules [BGS + 94]. <p> This would enable the filter mechanism to determine which applications should receive the packet in just a single pass over a packet. Existing packet filter mechanisms CSPF [MRA87] and BPF [MJ93] are interpreter-based filter mechanisms that do not support composition. MPF <ref> [YBMM94] </ref> is similar to BPF but adds support for composing filter specifications for special cases and for dealing with fragmented packets. PathFinder [BGS + 94] is a pattern-based filtering mechanism that allows a greater degree of composition than MPF and allows for an efficient implementation. <p> In the IP header, the Flags and Fragment Offset fields are used to detect fragmentation. The above approach of dealing with fragmentation is the simplest, and may involve some overhead for fragmented packets; however, with some modifications, other meth ods <ref> [YBMM94, BGS + 94] </ref> can be incorporated in our filtering mechanism. 2 One might be concerned that a packet specifications beyond context-free might be necessary. <p> Related Work In this section we describe related work in the areas of packet filters and LR parsing . We discuss four major packet filter schemes: CSPF [MRA87], BPF [MJ93], MPF <ref> [YBMM94] </ref>, PathFinder [BGS + 94].
References-found: 19

