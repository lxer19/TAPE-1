URL: http://cwis.usc.edu/dept/ATRIUM/Papers/Articulator.ps
Refering-URL: http://cwis.usc.edu/dept/ATRIUM/index.html
Root-URL: http://www.aic.nrl.navy.mil/~aha/people.html
Title: A Knowledge-based Environment for Modeling and Simulating Software Engineering Processes  
Author: Peiwei Mi and Walt Scacchi 
Keyword: Index Terms agents, artificial intelligence, deductive query, distributed problem solving, meta-model of software processes, modeling of software processes, process programming, process simulation.  
Abstract: We describe the design and representation schemes used in constructing a prototype computational environment for modeling and simulating multi-agent software engineering processes. We refer to this environment as the Articulator. We provide an overview of the Articulator's architecture which identifies five principal components. Three of these components, the knowledge meta-model, the software process behavior simulator, and a knowledge base querying mechanism are detailed and examples are included. The conclusion reiterates what is novel to this approach in applying knowledge engineering techniques to the problems of understanding the statics and dynamics of complex software engineering processes. 
Abstract-found: 1
Intro-found: 1
Reference: [BS87] <author> S. Bendifallah and W. Scacchi. </author> <title> Understanding Software Maintenance Work. </title> <journal> IEEE Trans. on Software Engineering, </journal> <volume> 13(3) </volume> <pages> 311-323, </pages> <month> Mar </month> <year> 1987. </year>
Reference-contexts: Both of these include a hierarchy of task decomposition and a non-linear performance sequence. We model two types of organizational work: primary tasks and articulation tasks <ref> [BS87] </ref>, which distinguish development-oriented tasks from coordination-oriented tasks. The hierarchy of task decomposition may include multi-level nested decomposition, iteration and multiple selection. Levels of specification depend on user requirements and can be modified as requested. At the bottom level of this hierarchy are actions. <p> Synchronization arranges schedules for collective tasks and is responsible for the follow-up actions when this fails. Articulation, at last, handles unexpected events which stop normal task performance. Articulation is the way to amplify individual skill and intelligence in a workplace <ref> [BS87, GS86, Hew86, MS89, Str88] </ref> and is discussed in [MS89]. 5 Behavioral Simulation With the specification of a software development process model and a set of agents, behavioral simulation is defined as the agents' symbolic execution of task specification using available resources over a period of time.
Reference: [BS89] <author> S. Bendifallah and W. Scacchi. </author> <title> Work Structures and Shifts: An Empirical Analysis of Software Specification Teamwork. </title> <booktitle> In Proc. of the 11th International Conference on Software Engineering, </booktitle> <pages> pages 260-270, </pages> <address> Pittsburgh, PA, </address> <month> May </month> <year> 1989. </year>
Reference-contexts: Further, with the exception of [HK89] and [Gar89], most efforts do not explicitly reference or use empirical sources for their software process models. Modeling and simulating complex organizational processes performed by people requires an empirically based, multi-agent open systems framework [GS86, Hew86]. For instance, [CKI88] and <ref> [BS89] </ref> are examples of recent empirical studies aimed at providing more realistic descriptions of multi-agent software processes. But their modeling efforts have not been cast in the form of a language or computational environment. We seek to resolve these shortcomings in modeling and automating (ie, simulating) software processes.
Reference: [Car86] <institution> Carnegie Group Inc. </institution> <note> Knowledge Craft User's Guide (Vol.1, Vol.2, and Vol.3), </note> <year> 1986. </year>
Reference-contexts: The Articulator has been prototyped over a two-year period using the KnowledgeCraf t T M (KC) knowledge engineering environment on a T I ExplorerII T M <ref> [Car86] </ref>. The knowledge base implements the Articulator meta-model by an object-based approach. The meta-model consists of the web of resources and situations, which is a model of software development, the representation of agent's task performance skills.
Reference: [CKI88] <author> B. Curtis, H. Krasner, and N. Iscoe. </author> <title> A Field Study of the Software Design Process for Large Systems. </title> <journal> Communications of ACM, </journal> <volume> 31(11) </volume> <pages> 1268-1287, </pages> <month> Nov </month> <year> 1988. </year>
Reference-contexts: Further, with the exception of [HK89] and [Gar89], most efforts do not explicitly reference or use empirical sources for their software process models. Modeling and simulating complex organizational processes performed by people requires an empirically based, multi-agent open systems framework [GS86, Hew86]. For instance, <ref> [CKI88] </ref> and [BS89] are examples of recent empirical studies aimed at providing more realistic descriptions of multi-agent software processes. But their modeling efforts have not been cast in the form of a language or computational environment. We seek to resolve these shortcomings in modeling and automating (ie, simulating) software processes.
Reference: [CKSI87] <author> B. Curtis, H. Krasner, V. Shen, and N. Iscoe. </author> <title> On Building Software Process Model Under the Lamppost. </title> <booktitle> In Proc. of the 9th International Conference on Software Engineering, </booktitle> <pages> pages 96-103, </pages> <address> Monterey, CA, </address> <month> Apr </month> <year> 1987. </year>
Reference-contexts: A meta-model of the software process should possess the capability to include major properties of contemporary software development practice. Recent evaluations on software process models <ref> [CKSI87, SFG85] </ref> suggest that effective software process models should address organizational and technical dimensions including 1) detailed descriptions of software processes, products and settings; 2) their interactions; 3) management and exception handling during the performance of software processes; and 4) product-specific, organization-specific and project-specific processes.
Reference: [DLC87] <author> E.H. Durfee, V.R. Lesser, and D.D. Corkill. </author> <title> Cooperation Through Communication in a Distributed Problem Solving Network. In M.N. </title> <editor> Huhns, editor, </editor> <booktitle> Distributed Artificial Intelligence, </booktitle> <pages> pages 29-58. </pages> <publisher> Morgan Kaufmann Publishers, Inc., </publisher> <year> 1987. </year>
Reference-contexts: By simulating a specified software process, its environment and its users can collectively detect faults, inconsistencies, or anomalous behavior in a process prescription. Emerging conflicts in time schedule and resource allocation, for example, are some common anomalies in multi-agent process plans <ref> [DLC87] </ref>. Complex faults, on the other hand, may concern the configuration of task decomposition and organizational settings as well. The environment should also assist in determining possible solutions for contingencies encountered in task execution.
Reference: [Gar89] <author> P.K. Garg. </author> <title> Information Management in Software Engineering, A Hypertext Based Approach. </title> <type> PhD thesis, </type> <institution> Computer Science Dept, USC, </institution> <month> Feb </month> <year> 1989. </year>
Reference-contexts: For example, many researchers have introduced process language constructs including rules and pattern matching [Kai88], behavioral patterns [Wil88], graphic finite-state machines [HK89] and agent-task-product relations <ref> [Gar89] </ref>. But none provides a direct means for querying the status or state of a modeled software process. Others including [SFG85] and [HL88] use knowledge representation languages and deductive planning mechanisms for software process modeling. But overall, these efforts lead to closed, single agent (i.e, globally controlled) systems. <p> Others including [SFG85] and [HL88] use knowledge representation languages and deductive planning mechanisms for software process modeling. But overall, these efforts lead to closed, single agent (i.e, globally controlled) systems. Further, with the exception of [HK89] and <ref> [Gar89] </ref>, most efforts do not explicitly reference or use empirical sources for their software process models. Modeling and simulating complex organizational processes performed by people requires an empirically based, multi-agent open systems framework [GS86, Hew86]. <p> In order to perform a task, an agent must possess the necessary resources and rights of information access. Living in an organizational infrastructure, an agent may have affiliations with other organizations 7 and play different roles in different organizational situations <ref> [Gar89, KS82] </ref>. Besides these, agents have a knowledge representation which specifies their potential behaviors, and this behavior can also be dynamically simulated. These aspects will be discussed later. There are several types of agents in the Articulator meta-model. <p> Establishing a model of a software development process is made possible by using the Articulator meta-model. Different types of software process models can be defined. For example, a software production-process model, such as the Waterfall model <ref> [Gar89, HK89, Ost87, Wil88] </ref> or the Automation model [Gar89] can be specified by the Articulator as a hierarchy of software development activities and their suggested prescriptive execution sequence. A software production-setting model can be viewed as a mixed task representation of primary tasks and articulation tasks. <p> Establishing a model of a software development process is made possible by using the Articulator meta-model. Different types of software process models can be defined. For example, a software production-process model, such as the Waterfall model [Gar89, HK89, Ost87, Wil88] or the Automation model <ref> [Gar89] </ref> can be specified by the Articulator as a hierarchy of software development activities and their suggested prescriptive execution sequence. A software production-setting model can be viewed as a mixed task representation of primary tasks and articulation tasks.
Reference: [Gen83] <author> M. Genesereth. </author> <title> An Overview of Meta-level Architecture. </title> <booktitle> In Proceedings AAAI-83, </booktitle> <address> Washington, DC, </address> <year> 1983. </year>
Reference-contexts: An agent's task performance skill is represented according to a three-level paradigm, where each level is a space specifying a particular type of knowledge and operators to manipulate it. This three-level paradigm is similar in concept with other multi-level problem-solving architectures, such as those in <ref> [Gen83, Ste81] </ref>. The domain space stores information and knowledge of an application domain. This is an agent's personalized domain knowledge and is generally a subset image of the web.
Reference: [GS86] <author> E.M. </author> <title> Gerson and S.L. Star. Analyzing Due Process in the Workplace. </title> <journal> ACM Trans. on Office Information Systems, </journal> <volume> 4(3) </volume> <pages> 257-270, </pages> <month> July </month> <year> 1986. </year>
Reference-contexts: Further, with the exception of [HK89] and [Gar89], most efforts do not explicitly reference or use empirical sources for their software process models. Modeling and simulating complex organizational processes performed by people requires an empirically based, multi-agent open systems framework <ref> [GS86, Hew86] </ref>. For instance, [CKI88] and [BS89] are examples of recent empirical studies aimed at providing more realistic descriptions of multi-agent software processes. But their modeling efforts have not been cast in the form of a language or computational environment. <p> Synchronization arranges schedules for collective tasks and is responsible for the follow-up actions when this fails. Articulation, at last, handles unexpected events which stop normal task performance. Articulation is the way to amplify individual skill and intelligence in a workplace <ref> [BS87, GS86, Hew86, MS89, Str88] </ref> and is discussed in [MS89]. 5 Behavioral Simulation With the specification of a software development process model and a set of agents, behavioral simulation is defined as the agents' symbolic execution of task specification using available resources over a period of time.
Reference: [Hew86] <author> C. Hewitt. </author> <title> Offices Are Open Systems. </title> <journal> ACM Trans. on Office Information Systems, </journal> <volume> 4(3) </volume> <pages> 271-287, </pages> <month> July </month> <year> 1986. </year>
Reference-contexts: Further, with the exception of [HK89] and [Gar89], most efforts do not explicitly reference or use empirical sources for their software process models. Modeling and simulating complex organizational processes performed by people requires an empirically based, multi-agent open systems framework <ref> [GS86, Hew86] </ref>. For instance, [CKI88] and [BS89] are examples of recent empirical studies aimed at providing more realistic descriptions of multi-agent software processes. But their modeling efforts have not been cast in the form of a language or computational environment. <p> Interesting properties of a task include: assigned and authorized performers; task hierarchy and execution ordering; schedule; duration, deadline, start time and finish time; and resources planned to be consumed or produced by the task. The Articulator meta-model is an open system <ref> [Hew86] </ref>. It has the following special characteristics: * The boundary of the meta-model and its interface with the outside world is determinable, though not necessarily static. The meta-model, besides manipulating its own resources, communicates with the outside world. <p> Synchronization arranges schedules for collective tasks and is responsible for the follow-up actions when this fails. Articulation, at last, handles unexpected events which stop normal task performance. Articulation is the way to amplify individual skill and intelligence in a workplace <ref> [BS87, GS86, Hew86, MS89, Str88] </ref> and is discussed in [MS89]. 5 Behavioral Simulation With the specification of a software development process model and a set of agents, behavioral simulation is defined as the agents' symbolic execution of task specification using available resources over a period of time.
Reference: [HK89] <author> W.S. Humphrey and M.I. Kellner. </author> <title> Software Process Modeling: </title> <booktitle> Principles of Entity Process Models. In Proc. of the 11th International Conference on Software Engineering, </booktitle> <pages> pages 331-342, </pages> <address> Pittsburgh, PA, </address> <month> May </month> <year> 1989. </year> <month> 22 </month>
Reference-contexts: Since then, much research effort has been directed to the design and implementation of languages for software process automation, and to the construction of more realistic models. For example, many researchers have introduced process language constructs including rules and pattern matching [Kai88], behavioral patterns [Wil88], graphic finite-state machines <ref> [HK89] </ref> and agent-task-product relations [Gar89]. But none provides a direct means for querying the status or state of a modeled software process. Others including [SFG85] and [HL88] use knowledge representation languages and deductive planning mechanisms for software process modeling. <p> Others including [SFG85] and [HL88] use knowledge representation languages and deductive planning mechanisms for software process modeling. But overall, these efforts lead to closed, single agent (i.e, globally controlled) systems. Further, with the exception of <ref> [HK89] </ref> and [Gar89], most efforts do not explicitly reference or use empirical sources for their software process models. Modeling and simulating complex organizational processes performed by people requires an empirically based, multi-agent open systems framework [GS86, Hew86]. <p> Establishing a model of a software development process is made possible by using the Articulator meta-model. Different types of software process models can be defined. For example, a software production-process model, such as the Waterfall model <ref> [Gar89, HK89, Ost87, Wil88] </ref> or the Automation model [Gar89] can be specified by the Articulator as a hierarchy of software development activities and their suggested prescriptive execution sequence. A software production-setting model can be viewed as a mixed task representation of primary tasks and articulation tasks.
Reference: [HL88] <author> K.E. Huff and V.R. Lesser. </author> <title> A Plan-Based Intelligent Assistant That Supports the Process of Programming. </title> <booktitle> ACM SIGSOFT Software Engineering Notes, </booktitle> <volume> 13 </volume> <pages> 97-106, </pages> <month> Nov </month> <year> 1988. </year>
Reference-contexts: For example, many researchers have introduced process language constructs including rules and pattern matching [Kai88], behavioral patterns [Wil88], graphic finite-state machines [HK89] and agent-task-product relations [Gar89]. But none provides a direct means for querying the status or state of a modeled software process. Others including [SFG85] and <ref> [HL88] </ref> use knowledge representation languages and deductive planning mechanisms for software process modeling. But overall, these efforts lead to closed, single agent (i.e, globally controlled) systems. Further, with the exception of [HK89] and [Gar89], most efforts do not explicitly reference or use empirical sources for their software process models.
Reference: [Kai88] <author> G.E. Kaiser. </author> <title> Rule-Based Modeling of the Software Development Process. </title> <booktitle> In The 4th International Software Process Workshop, </booktitle> <pages> pages 84-86, </pages> <address> New York, NY, </address> <year> 1988. </year>
Reference-contexts: Since then, much research effort has been directed to the design and implementation of languages for software process automation, and to the construction of more realistic models. For example, many researchers have introduced process language constructs including rules and pattern matching <ref> [Kai88] </ref>, behavioral patterns [Wil88], graphic finite-state machines [HK89] and agent-task-product relations [Gar89]. But none provides a direct means for querying the status or state of a modeled software process. Others including [SFG85] and [HL88] use knowledge representation languages and deductive planning mechanisms for software process modeling.
Reference: [KS82] <author> R. Kling and W. Scacchi. </author> <title> The Web of Computing: Computer Technology as Social Organization. </title> <booktitle> In Advances in Computers, Vol.21, </booktitle> <pages> pages 1-90. </pages> <publisher> Academic Press, Inc., </publisher> <year> 1982. </year>
Reference-contexts: It is intended to provide an articulate view of the many aspects of software engineering processes within a single formalism. The theoretical scheme underlying the Articulator meta-model is the web model of computing introduced by Kling and Scacchi <ref> [KS82] </ref>. This web model replies upon empirical studies to make explicit a variety of connections between computing technologies, artifacts, activities, together with their embedding social situations and organizational infrastructure. <p> In order to perform a task, an agent must possess the necessary resources and rights of information access. Living in an organizational infrastructure, an agent may have affiliations with other organizations 7 and play different roles in different organizational situations <ref> [Gar89, KS82] </ref>. Besides these, agents have a knowledge representation which specifies their potential behaviors, and this behavior can also be dynamically simulated. These aspects will be discussed later. There are several types of agents in the Articulator meta-model.
Reference: [MS89] <author> P. Mi and W. Scacchi. </author> <title> Negotiation: A Collective Problem-Solving Approach. </title> <type> Technical Report SF-89-03, </type> <institution> Computer Science Dept. USC, </institution> <address> Los Angeles, CA, </address> <month> June </month> <year> 1989. </year>
Reference-contexts: Synchronization arranges schedules for collective tasks and is responsible for the follow-up actions when this fails. Articulation, at last, handles unexpected events which stop normal task performance. Articulation is the way to amplify individual skill and intelligence in a workplace <ref> [BS87, GS86, Hew86, MS89, Str88] </ref> and is discussed in [MS89]. 5 Behavioral Simulation With the specification of a software development process model and a set of agents, behavioral simulation is defined as the agents' symbolic execution of task specification using available resources over a period of time. <p> Synchronization arranges schedules for collective tasks and is responsible for the follow-up actions when this fails. Articulation, at last, handles unexpected events which stop normal task performance. Articulation is the way to amplify individual skill and intelligence in a workplace [BS87, GS86, Hew86, MS89, Str88] and is discussed in <ref> [MS89] </ref>. 5 Behavioral Simulation With the specification of a software development process model and a set of agents, behavioral simulation is defined as the agents' symbolic execution of task specification using available resources over a period of time. <p> Figure 4 suggests a description of this behavior simulation. In the picture, TimeN, TimeN+1 are states and lines represent actions. Actions use some resources which are represented as circles. Overlapped circles indicate resource requirement conflicts, which can be resolved either through synchronization or articulation <ref> [MS89] </ref>. There are several requirements to be observed during the behavioral simulation: 1. The task assignments are stable, if not otherwise explicitly changed. This is to say that all the agents must finish their assigned tasks before the simulation is done. 2. <p> First each agent selects the executing action out of its own choice. The selected action is among its current work assignments. The choice can be influenced but not determined by outsiders. Second, there are probably conflicts in resource requirements and the changes which need to be solved through articulation <ref> [MS89] </ref>. Part of the symbolic execution of an action is shown in Figure 5 where the rule gets an agent and its agenda, finds its current action, and starts to execute the action symbolically. <p> However, the task execution is not guaranteed to finish successfully. Problems may rise due to unexpected events that need to be articulated. Articulation of task performance also affects the above criteria and their consequences can be tracked as well <ref> [MS89] </ref>. Based on the Articulator meta-model, many types of agents and tasks can be assigned to a software development process.
Reference: [Ost87] <author> L. Osterweil. </author> <title> Software Processes are Software Too. </title> <booktitle> In Proc. of the 9th International Conference on Software Engineering, </booktitle> <pages> pages 2-13, </pages> <address> Monterey, CA, </address> <month> Apr </month> <year> 1987. </year>
Reference-contexts: Wileden [Wil86] suggested a modeling framework based upon use of a software process meta-model. Osterweil followed with a paradigmatic approach which cast the software process meta-model into what he called a process programming language || a language for programming prescriptive process models into a software development environment <ref> [Ost87] </ref>. Since then, much research effort has been directed to the design and implementation of languages for software process automation, and to the construction of more realistic models. <p> Establishing a model of a software development process is made possible by using the Articulator meta-model. Different types of software process models can be defined. For example, a software production-process model, such as the Waterfall model <ref> [Gar89, HK89, Ost87, Wil88] </ref> or the Automation model [Gar89] can be specified by the Articulator as a hierarchy of software development activities and their suggested prescriptive execution sequence. A software production-setting model can be viewed as a mixed task representation of primary tasks and articulation tasks.
Reference: [Sca88] <author> W. Scacchi. </author> <title> The USC System Factory Project. </title> <booktitle> In Proc. Software Symposium '88, (Keynote Address), Software Engineers Association, </booktitle> <pages> pages 9-41, </pages> <address> Tokyo, Japan, </address> <month> June </month> <year> 1988. </year>
Reference-contexts: We then conclude with a summary of novel contributions of the Articulator project. 2 Background As we noted earlier, there has been growing interest focused on the problem of modeling, analyzing, and automating various aspects of software engineering processes <ref> [Sca88] </ref>. Wileden [Wil86] suggested a modeling framework based upon use of a software process meta-model. Osterweil followed with a paradigmatic approach which cast the software process meta-model into what he called a process programming language || a language for programming prescriptive process models into a software development environment [Ost87]. <p> This is similar to the suggested use of the Callisto system used in computer manufacturing processes [SFG85]. Software developers use the Articulator through a CASE environment <ref> [Sca88] </ref>. In this way, the Articulator helps to coordinate their development activities according to a prescriptive model, and serves as both an active agenda mechanism and an information exchange center.
Reference: [SFG85] <author> A. Sathi, M.S. Fox, and M. Greenberg. </author> <title> Representation of activity knowledge for project management. </title> <journal> IEEE Trans. on Pattern Analysis and Machine Intelligence, </journal> <volume> 7(4) </volume> <pages> 531-552, </pages> <year> 1985. </year>
Reference-contexts: A meta-model of the software process should possess the capability to include major properties of contemporary software development practice. Recent evaluations on software process models <ref> [CKSI87, SFG85] </ref> suggest that effective software process models should address organizational and technical dimensions including 1) detailed descriptions of software processes, products and settings; 2) their interactions; 3) management and exception handling during the performance of software processes; and 4) product-specific, organization-specific and project-specific processes. <p> For example, many researchers have introduced process language constructs including rules and pattern matching [Kai88], behavioral patterns [Wil88], graphic finite-state machines [HK89] and agent-task-product relations [Gar89]. But none provides a direct means for querying the status or state of a modeled software process. Others including <ref> [SFG85] </ref> and [HL88] use knowledge representation languages and deductive planning mechanisms for software process modeling. But overall, these efforts lead to closed, single agent (i.e, globally controlled) systems. <p> When they encounter unexpected problems during a planned development project, they can consult the Articulator to find plausible solutions and to evolve the model based on the solution. This is similar to the suggested use of the Callisto system used in computer manufacturing processes <ref> [SFG85] </ref>. Software developers use the Articulator through a CASE environment [Sca88]. In this way, the Articulator helps to coordinate their development activities according to a prescriptive model, and serves as both an active agenda mechanism and an information exchange center.
Reference: [Ste81] <author> M. Stefik. </author> <title> MOLGEN Part 2: </title> <journal> Planning and Meta-Planning. Artificial Intelligence, </journal> <volume> 16(2) </volume> <pages> 141-169, </pages> <month> May </month> <year> 1981. </year>
Reference-contexts: An agent's task performance skill is represented according to a three-level paradigm, where each level is a space specifying a particular type of knowledge and operators to manipulate it. This three-level paradigm is similar in concept with other multi-level problem-solving architectures, such as those in <ref> [Gen83, Ste81] </ref>. The domain space stores information and knowledge of an application domain. This is an agent's personalized domain knowledge and is generally a subset image of the web.
Reference: [Str88] <author> A. Strauss. </author> <title> The Articulation of Project Work: An Organizational Process. </title> <journal> The Sociological Quarterly, </journal> <volume> 29(2) </volume> <pages> 163-178, </pages> <month> Apr </month> <year> 1988. </year>
Reference-contexts: In other words, it is the trajectory of task execution that constitutes the agent's behavior. The behavioral specification is a knowledge representation of task performance skill <ref> [Str88] </ref>. An agent's task performance skill is represented according to a three-level paradigm, where each level is a space specifying a particular type of knowledge and operators to manipulate it. This three-level paradigm is similar in concept with other multi-level problem-solving architectures, such as those in [Gen83, Ste81]. <p> Synchronization arranges schedules for collective tasks and is responsible for the follow-up actions when this fails. Articulation, at last, handles unexpected events which stop normal task performance. Articulation is the way to amplify individual skill and intelligence in a workplace <ref> [BS87, GS86, Hew86, MS89, Str88] </ref> and is discussed in [MS89]. 5 Behavioral Simulation With the specification of a software development process model and a set of agents, behavioral simulation is defined as the agents' symbolic execution of task specification using available resources over a period of time.
Reference: [Wil86] <author> J.C. Wileden. </author> <title> This is IT: A Meta-Model of the Software Process. </title> <booktitle> ACM SIGSOFT Software Engineering Notes, </booktitle> <volume> 11(4) </volume> <pages> 9-11, </pages> <month> Aug </month> <year> 1986. </year>
Reference-contexts: 1 Introduction Modeling the process of software engineering represents a promising approach toward understanding and supporting the development of large-scale software systems. The software process is the collection of related activities, seen as a coherent process subject to reasoning, involved in the production of a software system <ref> [Wil86] </ref>. A software process model is a prescriptive representation of software development activities in terms of their order of execution and resource management A software process meta-model is a representation formalism which provides necessary components to create various types of software process models [Wil86]. <p> in the production of a software system <ref> [Wil86] </ref>. A software process model is a prescriptive representation of software development activities in terms of their order of execution and resource management A software process meta-model is a representation formalism which provides necessary components to create various types of software process models [Wil86]. A meta-model of the software process should possess the capability to include major properties of contemporary software development practice. <p> We then conclude with a summary of novel contributions of the Articulator project. 2 Background As we noted earlier, there has been growing interest focused on the problem of modeling, analyzing, and automating various aspects of software engineering processes [Sca88]. Wileden <ref> [Wil86] </ref> suggested a modeling framework based upon use of a software process meta-model. Osterweil followed with a paradigmatic approach which cast the software process meta-model into what he called a process programming language || a language for programming prescriptive process models into a software development environment [Ost87].
Reference: [Wil88] <author> L.G. Williams. </author> <title> Software Process Modeling: A Behavioral Approach. </title> <booktitle> In Proc. of the 10th International Conference on Software Engineering, </booktitle> <pages> pages 174-200, </pages> <month> Apr </month> <year> 1988. </year>
Reference-contexts: Since then, much research effort has been directed to the design and implementation of languages for software process automation, and to the construction of more realistic models. For example, many researchers have introduced process language constructs including rules and pattern matching [Kai88], behavioral patterns <ref> [Wil88] </ref>, graphic finite-state machines [HK89] and agent-task-product relations [Gar89]. But none provides a direct means for querying the status or state of a modeled software process. Others including [SFG85] and [HL88] use knowledge representation languages and deductive planning mechanisms for software process modeling. <p> Establishing a model of a software development process is made possible by using the Articulator meta-model. Different types of software process models can be defined. For example, a software production-process model, such as the Waterfall model <ref> [Gar89, HK89, Ost87, Wil88] </ref> or the Automation model [Gar89] can be specified by the Articulator as a hierarchy of software development activities and their suggested prescriptive execution sequence. A software production-setting model can be viewed as a mixed task representation of primary tasks and articulation tasks.
References-found: 22

