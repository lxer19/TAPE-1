URL: http://www.eecs.umich.edu/techreports/cse/1995/CSE-TR-275-95.ps.gz
Refering-URL: http://www.eecs.umich.edu/home/techreports/cse95.html
Root-URL: http://www.eecs.umich.edu
Email: jaegert@eecs.umich.edu rubin@bellcore.com  
Title: Protocols for Authenticated Download to Mobile Information Appliances  
Author: Trent Jaeger Aviel D. Rubin 
Address: 445 South Street Ann Arbor, MI 48105 Morristown, NJ 07960  
Affiliation: Software Systems Research Lab Security Research Group EECS Department Bellcore University of Michigan  
Abstract: Mobile hosts download files from untrusted networks to obtain application software, information services, documents, etc. However, attackers can modify the contents of these files, either in transit or on a compromised machine. Attacks are more likely on a mobile network than a fixed network because attackers can send a malicious message to a mobile host without having to break into any machine in the network. If an attack goes undetected, the mobile host may download a file that contains: (1) erroneous or misleading data; (2) faulty applications; and (3) Trojan horses or viruses. Therefore, mobile hosts need the ability to authenticate the files they download to verify that the file downloaded is the file requested. It is difficult to authenticate files because, in general, a mobile host cannot trust any of the servers that provide location information. In this paper, we define download protocols that locate and retrieve files from an untrusted network and authenticate the downloaded file using only a single trusted principal. Energy consumption is also a concern for mobile hosts, so the protocols are designed to minimize the amount of information a mobile host will need to download. Keywords: Mobile computing systems, file integrity, digital signatures, cryptographic digests, wide-area network file location, trusted authorities. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> D. Balenson. </author> <title> Privacy enhancement for Internet electronic mail: Part III: algorithms, modes, and identifiers. Internet RFC 1423, </title> <month> February, </month> <year> 1993. </year>
Reference-contexts: An author sends the CA a signed message containing a file's certification information. After verifying the signature, the CA generates a certificate for the author stating that the author certified the file at the current time (see section 5.1 for the certificate definition). This contrasts with the PEM <ref> [1] </ref> model where a CA would certify the public key of each author, and authors would certify files directly. The advantages of CA's certifying files are that: (1) the certification date of the file can be trusted; and (2) certification using previously revoked public keys is prevented. <p> At present, we assume that each organization will have one CA. If a group of organizations wants to share information, a web of trust between the CA's of those organizations can be created using the mechanism used for PEM <ref> [1] </ref> or PGP [22] 2 . Mobile hosts need not trust any mobile support servers, location servers, or distribution servers. If an MSS or distribution server delivers an incorrect or tampered file, the client recognizes it.
Reference: [2] <author> A. D. Birrell, R. Levin, R. M. Needham, and M. D. Schroeder. Grapevine: </author> <title> An exercise in distributed computing. </title> <journal> Communications of the ACM, </journal> <volume> 25(4) </volume> <pages> 260-274, </pages> <month> April </month> <year> 1982. </year>
Reference-contexts: File location is also a difficult problem because: (1) trust in all system components and their communications is not possible and (2) it can be expensive to find a file in a large network. Distributed file systems <ref> [2, 4, 20] </ref> and shared virtual memory systems [10, 12] define protocols for locating distributed services, but these protocols trust the servers providing location information. The problem is that machines connected to the Internet can be compromised by attackers. <p> File location protocols for distributed systems can be divided into two categories: (1) pull and (2) push. Pull systems [4, 10, 12] download and cache location information on demand while push systems <ref> [2, 11, 20] </ref> use file location information that has been previously uploaded to their location servers (i.e., servers that help clients find files). 1 A detailed definition of a file identifier is provided in Section 5.2. 3 Pull systems provide scalable, flexible access to a global name space, but must search
Reference: [3] <author> M. </author> <title> Blaze. Transparent mistrust: OS support for cryptography-in-the-large. </title> <booktitle> In Proceedings of the 4th Workshop on Workstation Operating Systems, </booktitle> <pages> pages 98-102, </pages> <year> 1993. </year>
Reference-contexts: Currently, mobile cells cover an area only 1-2 miles in diameter and are expected to decrease in size, so the number of MSS's, and hence the number of public keys, will be large. The black pages <ref> [3] </ref> service has been proposed to provide bindings of principals to keys, but use of this service costs time. In addition, MSS's are connected, at least indirectly, to the Internet, so there exists a possibility that an MSS will be compromised. Thus, even signed messages may not be trustworthy.
Reference: [4] <author> D. R. Cheriton. </author> <title> The V distributed operating system. </title> <journal> Communications of the ACM, </journal> <volume> 31(3) </volume> <pages> 314-333, </pages> <month> March </month> <year> 1988. </year>
Reference-contexts: File location is also a difficult problem because: (1) trust in all system components and their communications is not possible and (2) it can be expensive to find a file in a large network. Distributed file systems <ref> [2, 4, 20] </ref> and shared virtual memory systems [10, 12] define protocols for locating distributed services, but these protocols trust the servers providing location information. The problem is that machines connected to the Internet can be compromised by attackers. <p> The file retrieval problem is for the client to obtain an authentic version of that file from a distribution server. File location protocols for distributed systems can be divided into two categories: (1) pull and (2) push. Pull systems <ref> [4, 10, 12] </ref> download and cache location information on demand while push systems [2, 11, 20] use file location information that has been previously uploaded to their location servers (i.e., servers that help clients find files). 1 A detailed definition of a file identifier is provided in Section 5.2. 3 Pull <p> The primary security limitation of these protocols is the amount of trust that is required between the client and the servers. In each of these protocols, clients trust that the servers provide the correct location information (only the V system <ref> [4, 5] </ref> actually authenticates the servers, however). As mentioned above, even if the servers are authenticated, trust in all servers is not possible because any one of them may have been compromised. <p> We also expect that location servers will maintain information about which location server administers which domains, so a location server can find a file that is not in its domain efficiently, similar to the V system <ref> [4, 5] </ref>. Certification authorities (CA's) certify the authenticity of the authors' files. An author sends the CA a signed message containing a file's certification information.
Reference: [5] <author> D. R. Cheriton and T. P. Mann. </author> <title> Decentralizing a global naming service for improved performance and fault-tolerance. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 7(2) </volume> <pages> 147-183, </pages> <month> May </month> <year> 1989. </year>
Reference-contexts: The primary security limitation of these protocols is the amount of trust that is required between the client and the servers. In each of these protocols, clients trust that the servers provide the correct location information (only the V system <ref> [4, 5] </ref> actually authenticates the servers, however). As mentioned above, even if the servers are authenticated, trust in all servers is not possible because any one of them may have been compromised. <p> We also expect that location servers will maintain information about which location server administers which domains, so a location server can find a file that is not in its domain efficiently, similar to the V system <ref> [4, 5] </ref>. Certification authorities (CA's) certify the authenticity of the authors' files. An author sends the CA a signed message containing a file's certification information. <p> Location servers store a map of file identifiers to the set of distribution servers that provide the associated files. Location servers should be associated with a set of distribution servers, as location servers in the V operating system <ref> [5] </ref> (called liaison servers) are, so a file on a specific distribution server can be found efficiently. Therefore, a distribution server publishes the file to the location server responsible for its domain. Distribution servers store a map from a file identifier to the file pathname and the file's certificate pathname.
Reference: [6] <author> D. Goldberg and M. Tso. </author> <title> How to program net-worked portable computers. </title> <booktitle> In Proceedings of the 4th Workshop on Workstation Operating Systems, </booktitle> <pages> pages 30-33, </pages> <year> 1993. </year>
Reference-contexts: On the other hand, a mobile host may be a fully functional workstation with its own operating system and support software. Intermediate options include systems with CPU's that possess limited memory, such as palmtops, Tabs [21], and "terminals with the possibility of downloading some code <ref> [6] </ref>." Examples of the types of data mobile hosts may download can be categorized as: (1) information services and (2) application software. All the types of mobile hosts described above may download information services, such as traffic, weather, stock quotes, e-mail, etc.
Reference: [7] <author> T. Imielinski and B. R. Badrinath. </author> <title> Mobile wireless computing: challenges in data management. </title> <journal> Communications of the ACM, </journal> <volume> 37(10) </volume> <pages> 18-28, </pages> <month> Oc-tober </month> <year> 1994. </year>
Reference-contexts: In addition, a number of the applications of mobile hosts are based on the download of files from information services on traffic, weather, and stock quotes, etc <ref> [7] </ref>. In general, file download consists of two tasks: (1) file location and retrieval and (2) file integrity verification. To improve availability, read-only files are often replicated, so a file download protocol should be able to find a nearby copy of the file. <p> In section 4, we present the protocol architecture. In section 5, we detail the authenticated download protocols. 2 Mobile System Architecture It is envisioned that a personal communication network (PCN) will be developed that will provide mobile hosts with nearly ubiquitous communication coverage <ref> [7] </ref>. The PCN (see Figure 1) will consist of a number of mobile support servers [8] (MSS's) that are attached to fixed networks and service mobile hosts in a specific area called a cell. MSS's are expected to provide mobile hosts with wide-area network connectivity. <p> It is expected that state information about a mobile host must be transferred between MSS's when responsibility for a mobile host is transferred <ref> [7] </ref>. Therefore, information about outstanding requests should be included in this state information. If a mobile host becomes unreachable (e.g., due to shutdown) during the algorithm, the MSS will time-out the request when step 7 cannot be completed.
Reference: [8] <author> J. Ioannidis and G. Q. Maguire Jr. </author> <title> The design and implementation of a mobile internetworking architecture. </title> <booktitle> In Proceedings of the Winter Usenix Conference, </booktitle> <pages> pages 491-502, </pages> <year> 1993. </year>
Reference-contexts: The PCN (see Figure 1) will consist of a number of mobile support servers <ref> [8] </ref> (MSS's) that are attached to fixed networks and service mobile hosts in a specific area called a cell. MSS's are expected to provide mobile hosts with wide-area network connectivity. The PCN will enable a mobile host to obtain access to information services, application software, its home machine, etc.
Reference: [9] <author> T. Jaeger and A. D. Rubin. </author> <title> Preserving integrity in remote file location and retrieval. </title> <booktitle> In Proceedings of the Internet Society Symposium on Network and Distributed System Security, </booktitle> <year> 1996. </year> <note> To appear. </note>
Reference-contexts: We expect that only a small percentage of files, such as commonly-used applications and information services, need to be located dynamically, so it is not necessary to make the entire name space accessible. In a previous paper, we defined a service for downloading files in an untrusted, fixed network <ref> [9] </ref>. This protocol requires trust in only one system principal and limits the cost to locate a file, but it is not designed for a mobile network. File download protocols must be efficient to preserve the limited energy resources of mobile hosts. <p> Thus, any file download protocols should use as few mobile host resources as possible. The fixed network protocol described above <ref> [9] </ref> requires that the principal downloading the file control all file download and error recovery tasks. <p> The Betsi system requires manual intervention to verify a file which prevents it from being integrated in a fully automated file download protocol. An automated file download protocol for fixed networks that verifies the integrity of retrieved files is described in <ref> [9] </ref>. In this protocol, a service on the client's machine controls the location process and verifies the authenticity of any downloaded files. Mobile hosts have energy limitations due to fact that they are often battery-powered. <p> The mobile host still needs to verify the file it obtains in step 7 because transmission from the MSS may be forged or disrupted or the MSS may already be compromised. This authenticated download protocol differs from the protocol for a fixed network <ref> [9] </ref> in the effort required in the mobile hosts. A client in a fixed network has the energy resources to perform repeated requests and downloads of a file. However, the number of file downloads should be minimized for mobile hosts because their energy resources are limited.
Reference: [10] <author> E. Jul, H. Levy, N. Hutchison, and A. Black. </author> <title> Fine-grained mobility in the Emerald system. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 6(1) </volume> <pages> 109-133, </pages> <month> February </month> <year> 1988. </year>
Reference-contexts: File location is also a difficult problem because: (1) trust in all system components and their communications is not possible and (2) it can be expensive to find a file in a large network. Distributed file systems [2, 4, 20] and shared virtual memory systems <ref> [10, 12] </ref> define protocols for locating distributed services, but these protocols trust the servers providing location information. The problem is that machines connected to the Internet can be compromised by attackers. <p> The file retrieval problem is for the client to obtain an authentic version of that file from a distribution server. File location protocols for distributed systems can be divided into two categories: (1) pull and (2) push. Pull systems <ref> [4, 10, 12] </ref> download and cache location information on demand while push systems [2, 11, 20] use file location information that has been previously uploaded to their location servers (i.e., servers that help clients find files). 1 A detailed definition of a file identifier is provided in Section 5.2. 3 Pull
Reference: [11] <author> B. Lampson. </author> <title> Designing a global name service. </title> <booktitle> In Proceedings of the Fifth ACM Symposium on Principles of Distributed Computing, </booktitle> <pages> pages 1-10, </pages> <year> 1986. </year>
Reference-contexts: File location protocols for distributed systems can be divided into two categories: (1) pull and (2) push. Pull systems [4, 10, 12] download and cache location information on demand while push systems <ref> [2, 11, 20] </ref> use file location information that has been previously uploaded to their location servers (i.e., servers that help clients find files). 1 A detailed definition of a file identifier is provided in Section 5.2. 3 Pull systems provide scalable, flexible access to a global name space, but must search
Reference: [12] <author> K. Li and P. Hudak. </author> <title> Memory coherence in shared virtual memory systems. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 7(4) </volume> <pages> 321-359, </pages> <month> November </month> <year> 1989. </year>
Reference-contexts: File location is also a difficult problem because: (1) trust in all system components and their communications is not possible and (2) it can be expensive to find a file in a large network. Distributed file systems [2, 4, 20] and shared virtual memory systems <ref> [10, 12] </ref> define protocols for locating distributed services, but these protocols trust the servers providing location information. The problem is that machines connected to the Internet can be compromised by attackers. <p> The file retrieval problem is for the client to obtain an authentic version of that file from a distribution server. File location protocols for distributed systems can be divided into two categories: (1) pull and (2) push. Pull systems <ref> [4, 10, 12] </ref> download and cache location information on demand while push systems [2, 11, 20] use file location information that has been previously uploaded to their location servers (i.e., servers that help clients find files). 1 A detailed definition of a file identifier is provided in Section 5.2. 3 Pull
Reference: [13] <author> NIST FIPS PUB XX. </author> <title> Digital Signature Standard. </title> <institution> National Institute of Standards and Technology, U.S. Department of Commerce, </institution> <month> February </month> <year> 1993. </year> <note> DRAFT. </note>
Reference-contexts: Therefore, MSS's and mobile hosts can verify that the CA created a certificate by checking the associated digital signature. In our fixed network implementation, all digital signatures are generated using the Digital Signature Algorithm (DSA) <ref> [13] </ref>. Our choice of DSA was made on the basis that NIST claims that DSA can be exported and that it is royalty-free 3 .
Reference: [14] <author> M. Nemzow. </author> <title> Implementing Wireless Networks. </title> <publisher> McGraw-Hill, </publisher> <year> 1995. </year>
Reference-contexts: Even if a mobile host can trust its current MSS, attackers can also compromise transmissions be tween the MSS and the mobile host. Attackers with sufficient motivation can determine the transmission frequencies of the MSS (even if frequency hopping or multifrequency spread are used <ref> [14] </ref>).
Reference: [15] <author> R. Rivest. </author> <title> The MD5 message digest algorithm. Internet RFC 1321, </title> <month> April, </month> <year> 1992. </year>
Reference-contexts: First, a user compares the file identifier and author in the certificate to the file identifier and author expected by the user. Next, the user computes a cryptographic digest of the file (using 4 a one-way hash function, such as MD5 <ref> [15] </ref>) and compares this digest to the cryptographic digest in the certificate to verify the file's integrity. If the user trusts the CA and the two comparisons succeed, then the file satisfies the Betsi verification protocol. <p> These two features prevent an attacker from being able to modify a file, yet still obtain the cryptographic digest of the original file. In our fixed network implementation, we used the MD5 one-way hash function <ref> [15] </ref> because its code is in the public domain and it is the RFC standard one-way hash function. Digital signatures are used to verify that the CA generated a certificate. A digital signature is created from a combination of a principal's private key and a message.
Reference: [16] <author> R. Rivest, A. Shamir, and L. Adleman. </author> <title> On digital signatures and public-key cryptosystems. </title> <journal> Communications of the ACM, </journal> <volume> 21(2) </volume> <pages> 120-126, </pages> <month> February </month> <year> 1978. </year>
Reference-contexts: For example, the machines that mobile hosts use to obtain network connectivity are connected to the Internet, so trust in an arbitrary server is not advisable. Therefore, even if the location information is signed (e.g., using RSA <ref> [16] </ref>) by each machine, it cannot be trusted because one of these machines may have been compromised. Second, these distributed systems protocols are designed to make an entire name space accessible. <p> Our choice of DSA was made on the basis that NIST claims that DSA can be exported and that it is royalty-free 3 . An alternative algorithm for digital signatures is the RSA algorithm <ref> [16] </ref>, but RSA has the disadvantages that its exportation is tightly controlled and its use requires royalty payments to the patent holders. However, RSA is a significantly more efficient algorithm than DSA, particularly for verification. Below, we detail the authenticated download protocol.
Reference: [17] <author> A. D. Rubin. </author> <title> Trusted distribution of software over the internet. </title> <booktitle> In Proceedings of the Internet Society Symposium on Network and Distributed System Security, </booktitle> <year> 1995. </year>
Reference-contexts: Even worse, the malicious software may contain a virus or a Trojan horse. Bellcore's Trusted Software Integrity (Betsi) system <ref> [17] </ref> enables users to manually verify the integrity of a file obtained from the Internet. <p> In the XEFS, files are annotated with attributes whose values contain these endorsements, but trust in the principals endorsing the file may vary. In the Betsi system <ref> [17] </ref>, a single trusted authority is defined that vouches for the integrity of the files. Therefore, a client can compare the file retrieved to authentication information signed by a trusted authority to determine if a file is authentic.
Reference: [18] <author> S. Sheng, A. Chandrasekaran, and R. W. Broder-son. </author> <title> A portable multimedia terminal for personal communications. </title> <journal> IEEE Communications, </journal> <pages> pages 64-75, </pages> <month> December </month> <year> 1992. </year>
Reference-contexts: File download protocols must be efficient to preserve the limited energy resources of mobile hosts. It is not expected that the rate of improvement in battery lifetimes is going to keep pace with the rate of improvement in CPU performance <ref> [18] </ref>, so the power available to mobile hosts will continue to be limited. Thus, any file download protocols should use as few mobile host resources as possible. The fixed network protocol described above [9] requires that the principal downloading the file control all file download and error recovery tasks.
Reference: [19] <author> R. K. </author> <title> Smart. The X.509 extended file system. </title> <booktitle> In Proceedings of the 1994 Internet Society Symposium on Network and Distributed System Security, </booktitle> <pages> pages 129-137, </pages> <month> February </month> <year> 1994. </year>
Reference-contexts: Statement 3 says that the retrieved file's contents correspond to the file contents expected. Statement 4 says that the file authentication information is current. We assume that a client believes any statement made and digitally signed by a trusted authority. The X.509 Extended File System (XEFS) <ref> [19] </ref> permits authors to sign statements endorsing the integrity of their files, and other principals sign endorsements of other aspects of files (e.g., checked for viruses). In the XEFS, files are annotated with attributes whose values contain these endorsements, but trust in the principals endorsing the file may vary.
Reference: [20] <author> A. S. Tannenbaum, R. van Renesse, H. van Staveren, G. Sharp, S. Mullender, J. Jansen, and G. van Russom. </author> <title> Experiences with the Ameoba distributed operating system. </title> <journal> Communications of ACM, </journal> <volume> 33(12) </volume> <pages> 46-63, </pages> <month> December </month> <year> 1990. </year>
Reference-contexts: File location is also a difficult problem because: (1) trust in all system components and their communications is not possible and (2) it can be expensive to find a file in a large network. Distributed file systems <ref> [2, 4, 20] </ref> and shared virtual memory systems [10, 12] define protocols for locating distributed services, but these protocols trust the servers providing location information. The problem is that machines connected to the Internet can be compromised by attackers. <p> File location protocols for distributed systems can be divided into two categories: (1) pull and (2) push. Pull systems [4, 10, 12] download and cache location information on demand while push systems <ref> [2, 11, 20] </ref> use file location information that has been previously uploaded to their location servers (i.e., servers that help clients find files). 1 A detailed definition of a file identifier is provided in Section 5.2. 3 Pull systems provide scalable, flexible access to a global name space, but must search <p> Push systems are more efficient than pull systems because all the file location information is stored in the location servers, but some of these systems use techniques that are unacceptable from a security standpoint. For example, the Ameoba system <ref> [20] </ref> requires servers to be able to create daemons on client machines that handle location requests. Allowing processes to be triggered by the actions of foreign machines presents a potential security vulnerability, particularly when these processes may affect the way that the client executes future processes. <p> The protocol for verifying the authenticity of a file using these certificates is detailed in the File Authentication Section below. 5.2 File Publication Mobile hosts can locate a file on a particular distribution server because it has been `published.' The act of `publishing' was first used in the Ameoba system <ref> [20] </ref> as a way to advertise that a particular service resides on a particular server. In Ameoba, a file publication protocol activates server agents on client machines to catch and forward service requests. In contrast, our protocol involves upload of the location information of a file to location servers.
Reference: [21] <author> M. Weiser. </author> <title> The computer for the twenty-first century. </title> <journal> Scientific American, </journal> <volume> 265(3) </volume> <pages> 94-104, </pages> <month> Septem-ber </month> <year> 1993. </year>
Reference-contexts: On the other hand, a mobile host may be a fully functional workstation with its own operating system and support software. Intermediate options include systems with CPU's that possess limited memory, such as palmtops, Tabs <ref> [21] </ref>, and "terminals with the possibility of downloading some code [6]." Examples of the types of data mobile hosts may download can be categorized as: (1) information services and (2) application software.
Reference: [22] <author> P. Zimmermann. </author> <title> PGP user's guide. </title> <institution> Distributed by the Massachusetts Institute of Technology, </institution> <month> May </month> <year> 1994. </year>
Reference-contexts: At present, we assume that each organization will have one CA. If a group of organizations wants to share information, a web of trust between the CA's of those organizations can be created using the mechanism used for PEM [1] or PGP <ref> [22] </ref> 2 . Mobile hosts need not trust any mobile support servers, location servers, or distribution servers. If an MSS or distribution server delivers an incorrect or tampered file, the client recognizes it.
References-found: 22

