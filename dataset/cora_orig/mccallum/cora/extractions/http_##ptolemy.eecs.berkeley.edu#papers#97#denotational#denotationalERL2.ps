URL: http://ptolemy.eecs.berkeley.edu/papers/97/denotational/denotationalERL2.ps
Refering-URL: http://ptolemy.eecs.berkeley.edu/papers/97/denotational/
Root-URL: 
Title: A DENOTATIONAL FRAMEWORK FOR COMPARING MODELS OF COMPUTATION  
Author: Edward A. Lee and Alberto Sangiovanni-Vincentelli 
Date: January 30, 1997  Abstract  
Address: BERKELEY, CALIFORNIA 94720  Berkeley, CA, USA 94720.  
Affiliation: DEPARTMENT OF ELECTRICAL ENGINEERING AND COMPUTER SCIENCE UNIVERSITY OF CALIFORNIA  EECS, University of California,  
Pubnum: Technical Memorandum UCB/ERL M97/11  
Abstract: We give a denotational framework (a meta model) within which certain properties of models of computation can be understood and compared. It describes concurrent processes in general terms as sets of possible behaviors. A process is determinate if given the constraints imposed by the inputs there are exactly one or exactly zero behaviors. Compositions of processes are processes with behaviors in the intersection of the behaviors of the component processes. The interaction between processes is through signals, which are collections of events. Each event is a value-tag pair, where the tags can come from a partially ordered or totally ordered set. Timed models are where the set of tags is totally ordered. Synchronous events share the same tag, and synchronous signals contain events with the same set of tags. Synchronous processes have only synchronous signals as behaviors. Strict causality (in timed tag systems) and continuity (in untimed tag systems) ensure determinacy under certain technical conditions. The framework is used to compare certain essential features of various models of computation, including Kahn process networks, dataow, sequential processes, concurrent sequential processes with rendezvous, Petri nets, and discrete-event systems. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> S. Abramsky, S. J. Gay, and R. Nagarajan, </author> <title> Interaction Categories and the Foundations of Typed Concurrent Programming, In: Deductive Program Design: </title> <booktitle> Proceedings of the 1994 Marktober dorf International Summer School, </booktitle> <editor> (M. Broy, ed.), </editor> <booktitle> NATO ASI Series F, </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1995. </year>
Reference-contexts: Maintaining consistency with all prior usage is impossible without going to the unacceptable extreme of abandoning the use of these terms altogether. Our objectives overlap somewhat with prior efforts to provide mathematical models for concurrent systems, such as CSP [15], CCS [23], event structures [30], and interaction categories <ref> [1] </ref>. <p> We devote most of our attention, however, to interaction mechanisms in practical use for designing electronic systems, such as discrete-event models and dataow. The prior frameworks closest to ours, Abramskys interaction categories <ref> [1] </ref> and Winskells event structures [30], have been presented as categorical concepts. We avoid category theory here because it does not appear to be necessary for our more limited objectives, and because we wish to make the concepts more accessible to a wider audience. <p> The set of all such tuples will be denoted . Position in the tuple serves the same purposes as naming of signals in other process calculi. Reordering of the tuple serves the same purposes as renaming. A similar use of tuples is found in the interaction categories of Abramsky <ref> [1] </ref>. The empty signal (one with no events) will be denoted by , and the tuple of empty signals by , where the number of empty signals in the tuple will be understood from the context. These are sig nals like any other, so and . <p> There is nothing special about connections as processes, but they are useful to couple the behaviors of other processes. For example, in figure 2, the composite pro 1. This serves a similar purpose as the tensor product in the interaction categories of Abramsky <ref> [1] </ref>. P 1 P 2 FIGURE 1. Composition of independent processes. <p> This suggests a type system that focuses on signals rather than values. Of course, processes themselves can then also be divided by types, yielding a process-level type system that captures the semantic model of the signals that satisfy the process, something like the interaction categories of Abramsky <ref> [1] </ref>. 4. The Role of Tags in Composition of Processes In Section 2.2.1, where we composed processes according to equation (2), tags played no evident role. Composition was treated there as combining constraints.
Reference: [2] <author> A. Benveniste and G. Berry, </author> <title> The Synchronous Approach to Reactive and Real-Time Systems, </title> <booktitle> Proceedings of the IEEE, </booktitle> <volume> Vol. 79, No. 9, </volume> <pages> pp. 1270-1282, </pages> <year> 1991. </year>
Reference-contexts: A discrete-time system is a synchronous discrete-event system. By this definition, the so-called Synchronous Dataow (SDF) model of computation [18] is not synchronous (we will say more about dataow models below). The synchronous languages <ref> [2] </ref> (such as Lustre, Esterel, and Argos) are synchronous if we consider , where (bottom) denotes the absence of an event. Indeed, a key property of synchronous languages is that the absence of an event at a particular tick (tag) is well-defined.
Reference: [3] <author> A. Benveniste and P. Le Guernic, </author> <title> Hybrid Dynamical Systems Theory and the SIGNAL Lan guage, </title> <journal> IEEE Tr. on Automatic Control, </journal> <volume> Vol. 35, No. 5, </volume> <pages> pp. 525-546, </pages> <month> May </month> <year> 1990. </year>
Reference-contexts: Indeed, a key property of synchronous languages is that the absence of an event at a particular tick (tag) is well-defined. Another key property is that event tags are totally ordered. Any two events either have the same tag or one unambiguously precedes the other. The language Signal <ref> [3] </ref> is called a synchronous language, but in general, it is not even timed. It supports nondeterminate operations that require a partially ordered tag model. Cycle-based logic simulators are discrete-time systems. Note that many authors will dispute this definition of the term synchronous.
Reference: [4] <author> F. Boussinot, R. De Simone, </author> <booktitle> The ESTEREL Language, Proceedings of the IEEE, </booktitle> <volume> Vol. 79, No. 9, </volume> <month> September </month> <year> 1991. </year>
Reference: [5] <author> V. Bryant, </author> <title> Metric Spaces, </title> <publisher> Cambridge University Press, </publisher> <year> 1985. </year>
Reference-contexts: It can be verified that the set of signals in a discrete-event system is complete. The Banach fixed point theorem (see for example <ref> [5] </ref>) states that if : is a contraction mapping and is a complete metric space, then there is exactly one such that . This is called a fixed point. Moreover, the Banach fixed point theorem gives a constructive way (sometimes called the fixed point algorithm) to find the fixed point. <p> Such Zeno conditions are not automatically prevented in VHDL. It is possible to reformulate things so that VHDL processes are correctly modeled as strictly causal (not delta causal). Fortunately, a closely related theorem (see <ref> [5] </ref>, chapter 4) states that if : is a strictly causal function and is a complete metric space, then there is at most one fixed point , . <p> This is sometimes called the full abstraction property. P X Edward A. Lee and Alberto Sangiovanni-Vincentelli 29 of 36 the existence of a fixed point and the validity of the constructive procedure (16) <ref> [5] </ref>. In general, the metric space of discrete-event signals is not compact, although it is beyond the scope of this paper to show this.
Reference: [6] <author> C. Cassandras, </author> <title> Discrete Event Systems, Modeling and Performance Analysis, </title> <publisher> Irwin, </publisher> <address> Homewood IL, </address> <year> 1993. </year>
Reference: [7] <author> B. A. Davey and H. A. Priestly, </author> <title> Introduction to Lattices and Order, </title> <publisher> Cambridge University Press, </publisher> <year> 1990. </year>
Reference-contexts: This interpretation is called the least-fixed-point semantics. A well-known fixed point theorem states that a continuous function : in a CPO has a least fixed point , (see <ref> [7] </ref>, page 89). By least fixed point we mean that for any such that , . Moreover, the theorem gives us a constructive way to find the least fixed point. Putting it into our context, suppose we have a continuous function : . <p> Since is a CPO, this chain has a LUB. The fixed-point theorem tells us that this LUB is the least fixed point of . This theorem is very similar to the so-called Knaster-Tarski fixed point theorem, which applies to complete lattices rather than CPOs <ref> [7] </ref>. For this reason, this approach to semantics is sometimes called Tarskian. Note that the constructive technique given by (22) is exactly what one would expect in an implementation of Kahn process networks. Begin with all sequences empty, and start iteratively applying functions. <p> Lee and Alberto Sangiovanni-Vincentelli orem states that a monotonic function on a CPO has a unique least fixed point, but gives no constructive way to find the least fixed point (see <ref> [7] </ref>, page 96). Fortunately, this lack of constructive solution is not a problem in practice since practical monotonic processes are invariably continuous. Of course, non-monotonic processes create many problems. 5.
Reference: [8] <author> J. B. Dennis, </author> <title> First Version Data Flow Procedure Language, </title> <note> Technical Memo MAC TM61, </note> <month> May, </month> <year> 1975, </year> <institution> MIT Laboratory for Computer Science. </institution>
Reference-contexts: The term dataow is sometimes applied to Kahn process networks in general, but this fails to reect the heri tage that dataow has in computer architecture. The dataow model originally proposed by Dennis <ref> [8] </ref> had the notion of a firing as an integral part. Our use of the term is consistent with that of Dennis. m n m n m n e i e i 1+ &lt; e e e i e e i 1+ &lt; &lt; 22 of 36 Edward A.
Reference: [9] <author> E. Dijkstra, </author> <title> Cooperating Sequential Processes, in Programming Languages, </title> <editor> E F. Genuys, edi tor, </editor> <publisher> Academic Press, </publisher> <address> New York, </address> <year> 1968. </year>
Reference: [10] <author> C. Ellingson and R. J. Kulpinski, </author> <title> Dissemination of System-Time, </title> <journal> IEEE Trans. on Communica tions, </journal> <volume> Vol. Com-23, No. 5, </volume> <pages> pp. 605-624, </pages> <month> May, </month> <year> 1973. </year>
Reference: [11] <author> C. J. Fidge, </author> <title> Logical Time in Distributed Systems, </title> <journal> Computer, </journal> <volume> Vol. 24, No. 8, </volume> <pages> pp. 28-33, </pages> <month> Aug. </month> <year> 1991. </year>
Reference-contexts: We can then talk about processes having information or knowledge at a consistent cut, rather than simultaneously. Fidge gives a related mechanism in which processes that can fork and join increment a counter on each event <ref> [11] </ref>. A partial ordering relationship between these lists of times is determined by process creation, destruction, and communication. If the number of processes is fixed ahead of time, then Mattern gives a more efficient implementation by using vector time [20].
Reference: [12] <author> G. S. Fishman, </author> <title> Principles of Discrete Event Simulation, </title> <publisher> Wiley, </publisher> <address> New York, </address> <year> 1978. </year>
Reference-contexts: Limit points, of course, are defined in the usual way using the metric (more general topological definitions are also possible). 3.1.3 Discrete-event Many simulators, including most digital circuit simulators, are based on a discrete-event model (see for example <ref> [12] </ref>). Given a process , and a tuple of signals that satisfies the process, let denote the set of tags appearing in any signal in the tuple . Clearly and the ordering relationship for members of induces an ordering relationship for members of . <p> This helps to keep the state space finite in certain circumstances, which can be a big help in formal analysis. However, in the simulation community, it is largely irrelevant whether is countable <ref> [12] </ref>. In simulation, the distinction is technically moot, since all representations of values in a computer simulation are drawn from a finite set.
Reference: [13] <author> N. Halbwachs, P. Caspi, P. Raymond, and D. Pilaud, </author> <title> The Synchronous Data Flow Programming Language LUSTRE, </title> <booktitle> Proceedings of the IEEE, </booktitle> <volume> Vol. 79, No. 9, </volume> <year> 1991, </year> <pages> pp. 1305-1319. </pages>
Reference: [14] <author> Y.-C. Ho (Ed.), </author> <title> Discrete Event Dynamic Systems: Analyzing Complexity and Performance in the Modern World, </title> <publisher> IEEE Press, </publisher> <address> New York, </address> <year> 1992. </year>
Reference: [15] <author> C. A. R. Hoare, </author> <title> Communicating Sequential Processes, </title> <journal> Communications of the ACM, </journal> <volume> Vol. 21, No. 8, </volume> <month> August </month> <year> 1978. </year>
Reference-contexts: Maintaining consistency with all prior usage is impossible without going to the unacceptable extreme of abandoning the use of these terms altogether. Our objectives overlap somewhat with prior efforts to provide mathematical models for concurrent systems, such as CSP <ref> [15] </ref>, CCS [23], event structures [30], and interaction categories [1]. <p> It supports nondeterminate operations that require a partially ordered tag model. Cycle-based logic simulators are discrete-time systems. Note that many authors will dispute this definition of the term synchronous. For example, the process algebra community (based on CSP <ref> [15] </ref> and CCS [23], for instance), refers to processes that synchronize (rendezvous) as synchronous. However, by our definition, they are not even timed (we will have more to say about rendezvous below). <p> Lee and Alberto Sangiovanni-Vincentelli 19 of 36 tics. Thus, efficiency of implementation is not an issue. 3.2.1 Rendezvous of sequential processes The communicating sequential processes (CSP) model of Hoare <ref> [15] </ref> and the calculus of communicating systems (CCS) model of Milner [23] are key representatives of a family of models of computation that involve sequential processes that communicate with rendezvous. Similar models are realized, for example, in the languages Occam and Lotos.
Reference: [16] <author> G. Kahn, </author> <title> The Semantics of a Simple Language for Parallel Programming, </title> <booktitle> Proc. of the IFIP Congress 74, </booktitle> <publisher> North-Holland Publishing Co., </publisher> <year> 1974. </year>
Reference-contexts: In this case, a composition of such processes is often nondeterminate. 3.2.2 Kahn process networks In a Kahn process network <ref> [16] </ref>, processes communicate via channels, which are one-way unbounded FIFO queues with a single reader and a single writer. Let again denote the tags in signal . The first-in, first-out property of the channels implies that is totally ordered for each signal . <p> With this definition, if is a CPO, so is . We will assume henceforth that is a CPO for all . 4.2.1 Monotonicity and continuity We can now define the untimed equivalents of causality, connecting to well-known results originally due to Kahn <ref> [16] </ref>. Our contribution here is only to present these results using our notation. <p> The union of any number of such open sets is also an open set, and the intersection of a finite number of such open sets is also an open set. A continuous process is monotonic <ref> [16] </ref>. To see this, suppose : is continuous, and consider two signals and in where . Define the increasing chain . Then = , so from continuity, = ( ) = = . (20) Therefore , so the process is monotonic. Not all monotonic functions are continuous.
Reference: [17] <author> L. Lamport, </author> <title> Time, Clocks, and the Ordering of Events in a Distributed System, </title> <journal> Communica tions of the ACM, </journal> <volume> Vol. 21, No. 7, </volume> <month> July, </month> <year> 1978. </year> <note> 36 of 36 Edward A. Lee and Alberto Sangiovanni-Vincentelli </note>
Reference-contexts: Mazurkiewicz uses partial orders in developing an algebra of concurrent objects associated with events [21]. Partial orders have also been used to analyze Petri nets [25]. Lamport observes that a coordinated notion of time cannot be exactly maintained in distributed systems, and shows that a partial ordering is sufficient <ref> [17] </ref>. He gives a mechanism in which messages in an asynchronous system carry time stamps and processes manipulate these time stamps. We can then talk about processes having information or knowledge at a consistent cut, rather than simultaneously.
Reference: [18] <author> E. A. Lee and D. G. Messerschmitt, </author> <title> Synchronous Data Flow, </title> <booktitle> IEEE Proceedings, </booktitle> <month> September, </month> <year> 1987. </year>
Reference-contexts: A process is synchronous if every signal in any behavior of the process is synchronous with every other signal in the behavior. A discrete-time system is a synchronous discrete-event system. By this definition, the so-called Synchronous Dataow (SDF) model of computation <ref> [18] </ref> is not synchronous (we will say more about dataow models below). The synchronous languages [2] (such as Lustre, Esterel, and Argos) are synchronous if we consider , where (bottom) denotes the absence of an event.
Reference: [19] <author> E. A. Lee and T. M. Parks, </author> <title> Dataow Process Networks, </title> <booktitle> Proceedings of the IEEE, </booktitle> <month> May </month> <year> 1995. </year> <note> (http://ptolemy.eecs.berkeley.edu/papers/processNets) </note>
Reference-contexts: might model the timing of the execution of a process network, in which case the timing nondeterminism of a concurrent system is represented in the model even if the process itself is sequence determinate. 3.2.3 Dataow The dataow model of computation is a special case 1 of Kahn process networks <ref> [19] </ref>. A dataow process is a Kahn process that is also sequential, where the events on the self-loop signal denote the firings of the dataow actor. The self-loop signal is called the firing signal.
Reference: [20] <author> F. Mattern, </author> <title> Virtual Time and Global States of Distributed Systems, in Parallel and Distributed Algorithms, </title> <editor> M. Cosnard and P. Quinton, eds., </editor> <publisher> North-Holland, </publisher> <address> Amsterdam, </address> <year> 1989, </year> <pages> pp. 215-226. </pages>
Reference-contexts: A partial ordering relationship between these lists of times is determined by process creation, destruction, and communication. If the number of processes is fixed ahead of time, then Mattern gives a more efficient implementation by using vector time <ref> [20] </ref>. Unlike the work of Lamport, Fidge, and Mattern, we are not using partial orders in the implementation of systems, but rather are using them as an analytical tool to study models of computation and their interaction seman s T s ( ) Edward A.
Reference: [21] <author> A. Mazurkiewicz, </author> <title> Traces, Histories, Graphs: Instances of a Process Monoid, </title> <booktitle> in Proc. Conf. on Mathematical Foundations of Computer Science, </booktitle> <editor> M. P. Chytil and V. Koubek, eds., </editor> <publisher> Springer-Ver lag LNCS 176, </publisher> <year> 1984. </year>
Reference-contexts: Lee and Alberto Sangiovanni-Vincentelli 15 of 36 nals are isomorphic to the set of integers. But they are not order-isomorphic. Order-isomorphism captures the notion of discrete (indeed, Mazurkiewicz gives a considerably more complicated but equivalent notion of discreteness in terms of relations <ref> [21] </ref>). It captures the intuitively appealing concept that between any two finite time stamps there will be a finite number of time stamps. Note further that while we insist that be discrete (which is stronger than enumerable), we do not even constrain T to be enumerable. <p> Pratt gives an excellent motivation for doing so, and then generalizes the notion of formal string languages to allow partial ordering rather than just total ordering [24]. Mazurkiewicz uses partial orders in developing an algebra of concurrent objects associated with events <ref> [21] </ref>. Partial orders have also been used to analyze Petri nets [25]. Lamport observes that a coordinated notion of time cannot be exactly maintained in distributed systems, and shows that a partial ordering is sufficient [17].
Reference: [22] <author> D. G. Messerschmitt, </author> <title> Synchronization in Digital System Design, </title> <journal> IEEE Journal on Selected Areas in Communications, </journal> <volume> Vol. 8, No. 8, </volume> <pages> pp. 1404-1419, </pages> <month> October </month> <year> 1990. </year>
Reference: [23] <author> R. Milner, </author> <title> Communication and Concurrency, </title> <publisher> Prentice-Hall, </publisher> <address> Englewood Cliffs, NJ, </address> <year> 1989. </year>
Reference-contexts: Maintaining consistency with all prior usage is impossible without going to the unacceptable extreme of abandoning the use of these terms altogether. Our objectives overlap somewhat with prior efforts to provide mathematical models for concurrent systems, such as CSP [15], CCS <ref> [23] </ref>, event structures [30], and interaction categories [1]. <p> It supports nondeterminate operations that require a partially ordered tag model. Cycle-based logic simulators are discrete-time systems. Note that many authors will dispute this definition of the term synchronous. For example, the process algebra community (based on CSP [15] and CCS <ref> [23] </ref>, for instance), refers to processes that synchronize (rendezvous) as synchronous. However, by our definition, they are not even timed (we will have more to say about rendezvous below). <p> Lee and Alberto Sangiovanni-Vincentelli 19 of 36 tics. Thus, efficiency of implementation is not an issue. 3.2.1 Rendezvous of sequential processes The communicating sequential processes (CSP) model of Hoare [15] and the calculus of communicating systems (CCS) model of Milner <ref> [23] </ref> are key representatives of a family of models of computation that involve sequential processes that communicate with rendezvous. Similar models are realized, for example, in the languages Occam and Lotos.
Reference: [24] <author> V. R. Pratt, </author> <title> Modeling Concurrency with Partial Orders, </title> <journal> Int. J. of Parallel Programming, </journal> <volume> Vol. 15, No. 1, </volume> <pages> pp. 33-71, </pages> <month> Feb. </month> <year> 1986. </year>
Reference-contexts: We are not alone in using partial orders to model concurrent systems. Pratt gives an excellent motivation for doing so, and then generalizes the notion of formal string languages to allow partial ordering rather than just total ordering <ref> [24] </ref>. Mazurkiewicz uses partial orders in developing an algebra of concurrent objects associated with events [21]. Partial orders have also been used to analyze Petri nets [25].
Reference: [25] <author> W. Reisig, </author> <title> Petri Nets: An Introduction, </title> <publisher> Springer-Verlag (1985). </publisher>
Reference-contexts: Mazurkiewicz uses partial orders in developing an algebra of concurrent objects associated with events [21]. Partial orders have also been used to analyze Petri nets <ref> [25] </ref>. Lamport observes that a coordinated notion of time cannot be exactly maintained in distributed systems, and shows that a partial ordering is sufficient [17]. He gives a mechanism in which messages in an asynchronous system carry time stamps and processes manipulate these time stamps.
Reference: [26] <author> M. Raynal and M. Singhal, </author> <title> Logical time: Capturing Causality in Distributed Systems, </title> <journal> Com puter, </journal> <volume> Vol. 29, No. 2, </volume> <month> February </month> <year> 1996. </year>
Reference: [27] <author> J. E. Stoy, </author> <title> Denotational Semantics: The Scott-Strachey Approach to Programming Language The ory, </title> <publisher> The MIT Press, </publisher> <address> Cambridge, MA, </address> <year> 1977. </year>
Reference-contexts: It is not intended as a grand unifying model of computation but rather as a meta model within which certain properties can be studied. To be sufficiently precise, this language is a mathematical one. It is denotational, in the sense of Scott and Strachey <ref> [27] </ref>, rather than operational, to avoid associating the semantics of a model of computation with an execution policy. In many denotational semantics, the denotation of a program fragment is a partial function or a relation on the state.
Reference: [28] <author> W. T. Trotter, </author> <title> Combinatorics and Partially Ordered Sets, </title> <publisher> Johns Hopkins University Press, </publisher> <address> Balti more, Maryland, </address> <year> 1992. </year>
Reference: [29] <author> G. Winskel, </author> <title> The Formal Semantics of Programming Languages, </title> <publisher> the MIT Press, </publisher> <address> Cambridge, MA, USA, </address> <year> 1993. </year>
Reference-contexts: In many denotational semantics, the denotation of a program fragment is a partial function or a relation on the state. This approach does not model concurrency well <ref> [29] </ref>, where the notion of a single global state may not be well-defined. In our approach, the denotation of a process is a partial function or a relation on signals, and hence we can model concurrency well. <p> Intuitively, this solution agrees with a reasonable execution of the process, in which we would not produce any output from because there are no inputs. This reasonable operational semantics therefore agrees with the denotational semantics. For a complete treatment of this agreement, see Winskel <ref> [29] </ref>. In terms of the tagged signal model, if is the set of sequence tuples that satisfy the process , we are declaring the behavior of the process to be , the smallest member (in a prefix order sense) of the set .
Reference: [30] <author> G. Winskel, </author> <title> "An Introduction to Event Structures," in Linear Time, Branching Time and Partial Order in Logics and Models for Concurrency, </title> <editor> J. W. de Bakker,W.-P. de Roever, and G. Rozenberg (Eds.), REX School/Workshop, </editor> <address> Noordwijkerhout, The Netherlands, May 30-June 3, 1988. </address> <publisher> LNCS 354, </publisher> <pages> pp. 364-397, </pages> <publisher> Springer-Verlag, </publisher> <year> 1989. </year>
Reference-contexts: Maintaining consistency with all prior usage is impossible without going to the unacceptable extreme of abandoning the use of these terms altogether. Our objectives overlap somewhat with prior efforts to provide mathematical models for concurrent systems, such as CSP [15], CCS [23], event structures <ref> [30] </ref>, and interaction categories [1]. <p> We devote most of our attention, however, to interaction mechanisms in practical use for designing electronic systems, such as discrete-event models and dataow. The prior frameworks closest to ours, Abramskys interaction categories [1] and Winskells event structures <ref> [30] </ref>, have been presented as categorical concepts. We avoid category theory here because it does not appear to be necessary for our more limited objectives, and because we wish to make the concepts more accessible to a wider audience. But it would be wrong to not acknowledge the inuence.
Reference: [31] <author> R. K. Yates, </author> <title> Networks of Real-Time Processes, </title> <booktitle> in Concur 93, Proc. of the 4th Int. Conf. on Concurrency Theory, </booktitle> <editor> E. Best, ed., </editor> <publisher> Springer-Verlag LNCS 715, </publisher> <year> 1993. </year>
Reference-contexts: The Banach fixed point theorem tells us that if the process is functional and delta causal, then the feedback loop has exactly one behavior (i.e. it is determinate). This determinacy result was also proved by Yates <ref> [31] </ref>, although he used somewhat different methods. Moreover, Banach fixed point theorem gives us a constructive way to find that behavior. Start with any guess about the signals (most simulators start with an empty signal), and iteratively apply the function corresponding to the process.
References-found: 31

