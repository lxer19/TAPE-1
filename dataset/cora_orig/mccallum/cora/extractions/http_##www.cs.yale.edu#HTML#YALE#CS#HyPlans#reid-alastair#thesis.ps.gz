URL: http://www.cs.yale.edu/HTML/YALE/CS/HyPlans/reid-alastair/thesis.ps.gz
Refering-URL: http://www.cs.yale.edu/HTML/YALE/CS/HyPlans/reid-alastair/
Root-URL: http://www.cs.yale.edu
Title: Computing Science M.Sc Thesis A Precise Semantics for Ultraloose Specifications  
Author: Alastair D. Reid c fl, Alastair D. Reid 
Degree: Submitted for the degree of Master of Science  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> Manfred Broy, B. Moller, Peter Pepper & Martin Wirsing, </author> <title> "Algebraic Implementations Preserve Program Correctness," </title> <institution> Sci. Comput. </institution> <note> Programming 7 (1986). </note>
Reference: [2] <author> Manfred Broy & Martin Wirsing, </author> <title> "Ultraloose Algebraic Specification," </title> <journal> Bull. Eu-ropean Assoc. </journal> <note> Theoret. </note> <institution> Comput. Sci. </institution> <month> 35 (June </month> <year> 1988), </year> <pages> 117-127. </pages>
Reference: [3] <author> Chang & Keisler, </author> <title> Model Theory, </title> <booktitle> Studies in Logic and the Foundations of Mathematics #73, </booktitle> <publisher> North-Holland, </publisher> <year> 1973. </year>
Reference: [4] <author> Hartmut Ehrig, H.-J. Kreowski, Bernd Mahr & P. Padawitz, </author> <title> "Compound algebraic implementations: an approach to stepwise refinement of software systems.," </title> <booktitle> Lect. Notes in Comp. Sci. 88 (Sept. </booktitle> <pages> 1-5, </pages> <year> 1980), </year> <pages> 231-245. </pages>
Reference: [5] <author> Hartmut Ehrig & Bernd Mahr, </author> <title> Fundamentals of Algebraic Specification 1 | Equations and Initial Semantics, </title> <booktitle> EATCS Monographs on Theoretical Computer Science #6, </booktitle> <publisher> Springer-Verlag, </publisher> <address> New York-Heidelberg-Berlin, </address> <year> 1985. </year>
Reference-contexts: The Semantics of ASL and USL 16 The class of all -algebras is denoted by Alg ( ). End Definition. [Our definition of an algebra is essentially the same as that of Schoett [37]. Other authors such as Ehrig and Mahr <ref> [5] </ref> use two functions S A and OP A (respectively) to assign interpretations to sort and function symbols (respectively) instead of a single family A.] For example, the following is a StackSig-algebra called stack . stack Nat def stack Stack def stack 0 def stack succ def stack empty def stack
Reference: [6] <author> Marie-Claude Gaudel, </author> <title> "Structuring and Modularising Algebraic Specifications: the PLUSS Specification Language, Evolution and Perspectives," </title> <booktitle> Lect. Notes in Comp. Sci. 577 (1992), </booktitle> <pages> 3-21. </pages>
Reference: [7] <author> V. Giarratana, F. Gimona & U. Montanari, </author> <title> "Observability concepts in abstract data type specifications," </title> <booktitle> Lect. Notes in Comp. Sci. 45 (1976), </booktitle> <pages> 567-578. </pages>
Reference: [8] <author> Joseph A. Goguen & Jose Meseguer, </author> <title> "Universal Realization, Persistent Interconnection and Implementation of Abstract Modules," </title> <booktitle> Lect. Notes in Comp. Sci. </booktitle> <month> 134 </month> <year> (1982). </year>
Reference: [9] <author> Joseph A. Goguen, James W. Thatcher & Eric G. Wagner, </author> <title> "An Initial Algebra Approach to the Specification, Correctness and Implementation of Abstract Data Types," </title> <booktitle> in Advances in Computer Programming, </booktitle> <editor> Yeh, ed. </editor> <volume> #4, </volume> <year> 1978, </year> <pages> 80-149 . 121 References 122 </pages>
Reference: [10] <author> Joseph A. Goguen, James W. Thatcher, Eric G. Wagner & Jesse B. Wright, </author> <title> "Initial Algebra Semantics and Continuous Algebras," </title> <journal> J. Assoc. Comput. Mach. </journal> <volume> 24, </volume> <month> 1 (Jan. </month> <year> 1977), </year> <pages> 68-95. </pages>
Reference: [11] <author> R. Hennicker, </author> <title> "Observational Implementations," </title> <booktitle> Lect. Notes in Comp. Sci. 349 (1988), </booktitle> <pages> 59-71. </pages>
Reference: [12] <author> R. Hennicker, </author> <title> "Implementation of Parameterised Observational Specifications," </title> <booktitle> Lect. Notes in Comp. Sci. 351 (1989), </booktitle> <pages> 290-305. </pages>
Reference: [13] <author> C. A. R. Hoare, </author> <title> "Proof of Correctness of Data Representations," </title> <journal> Acta Inform. </journal> <volume> 1 (1972), </volume> <pages> 272-281. </pages>
Reference-contexts: This is useful because it is clear how this style of definition can be used to derive a notion of behavioural equivalence for program modules. (See Hoare <ref> [13] </ref> for a demonstration). This section examines behavioural equivalence from a more "axiomatic" viewpoint: it identifies a set Axm (IN ; OUT ) of axioms such that, for any axiom ax 2 Axm (IN ; OUT ). if A ! B.
Reference: [14] <author> T. S. E. Maibaum, M. R. Sadler & P. A. S. Veloso, </author> <title> "Logical Implementation," </title> <institution> Department of Computing, Imperial College, London, </institution> <type> Technical Report, </type> <month> August </month> <year> 1983. </year>
Reference: [15] <author> T. S. E. Maibaum, P. A. S. Veloso & M. R. Sadler, </author> <title> "A theory of abstract data types for program development: bridging the gap?," </title> <booktitle> in Mathematical Foundations of Software Development '85 #186, </booktitle> <publisher> Springer-Verlag, </publisher> <address> New York-Heidelberg-Berlin, </address> <year> 1985, </year> <pages> 214-230. </pages>
Reference: [16] <author> M. E. Majster, </author> <title> "Limits of the "algebraic" specification of abstract data types," </title> <journal> ACM SIGPLAN Notices 12 (1977), </journal> <pages> 37-42. </pages>
Reference: [17] <author> Jose Meseguer & Joseph A. Goguen, "Initiality, </author> <title> induction and computability," in Algebraic Methods in Semantics, </title> <editor> M. Nivat & J. Reynolds, eds., </editor> <publisher> Cambridge Univ. Press, </publisher> <address> New York, NY, </address> <year> 1983, </year> <pages> 460-541. </pages>
Reference-contexts: There are a variety of alternative definitions used in the literature and so it is important to show how our definition relates to these definitions and to justify our choice over the alternatives. We show that our definition is a slight generalisation of that of Meseguer and Goguen <ref> [17] </ref> and slightly stronger than the notions of behavioural reduction and behavioural equivalence of Sannella and Tarlecki [27]. <p> End Definition. This is a straightforward generalisation of the definition of behavioural equivalence used by Meseguer and Goguen <ref> [17] </ref>. Meseguer and Goguen discuss V -behavioural equivalence which is a special case of (IN ; OUT )-behavioural equivalence with IN = V and OUT = V .
Reference: [18] <author> Carroll C. Morgan, </author> <title> "Data Refinement by Miracles," </title> <journal> Information Processing Letters 26 (1987/88), </journal> <pages> 243-246. </pages>
Reference: [19] <author> Joseph M. Morris, </author> <title> "Laws of Data Refinement," </title> <journal> Acta Inform. </journal> <volume> 26 (1989), </volume> <pages> 287-308. </pages>
Reference: [20] <author> P. Nivela & F. Orejas, </author> <title> "Initial behaviour semantics for algebraic specifications," </title> <booktitle> Lect. Notes in Comp. Sci. 332 (1987), </booktitle> <pages> 184-207. </pages>
Reference: [21] <author> Axel Poigne, </author> <title> "Partial Algebras, Subsorting and Dependent Types | Prerequisites of Error Handling in Algebraic Specifications," </title> <booktitle> Lect. Notes in Comp. Sci. 332 (1987), </booktitle> <pages> 208-234. </pages>
Reference-contexts: and set of sorts T 0 explicit whereas Schoett requires 0 = and makes the set T 0 implicit in what he calls an "observational signature." The use of reachable quantification in the algebraic literature can be traced (at least) as far back as Maibaum et al. [14,15] and Poigne <ref> [21] </ref>. All these early works use reachable quantification for the same purpose as model-based specifications use invariants: to restrict the domain of concern to those values which the specifier expects programs to encounter during execution | that is, the reachable values.
Reference: [22] <author> A. Ramsay, </author> <booktitle> Formal methods in Artificial Intelligence, Cambridge Tracts in Theoretical Computer Science #6, </booktitle> <publisher> Cambridge Univ. Press, </publisher> <address> New York, NY, </address> <year> 1988. </year>
Reference: [23] <author> Horst Reichel, </author> <title> "Initial restrictions of behaviour," </title> <booktitle> Proceedings The Role of Abstract Models in Information Processing (1985). </booktitle> <address> References 123 </address>
Reference-contexts: We have therefore succeeded in precisely characterising the semantic effect of the ultraloose specification transformation. No such characterisation has been published before although we have been informed that Reichel <ref> [23] </ref> presents a similar result to the above. We have not been able to obtain this paper but base the following comparision on Reichel's book [24 chapter 5 ] published two years later (which we assume presents essentially the same work).
Reference: [24] <author> Horst Reichel, </author> <title> Initial computability, algebraic specifications and partial algebras, </title> <booktitle> The International series of monographs on Computer Science #2, </booktitle> <publisher> Clarendon Press, Oxford, </publisher> <year> 1987. </year>
Reference: [25] <author> Donald T. Sannella, </author> <title> "Formal Specification of ML Programs," </title> <institution> LFCS, Univ. of Edinburgh, Research Report, </institution> <year> 1985. </year>
Reference: [26] <author> Donald T. Sannella & Andrzej Tarlecki, </author> <title> "Extended ML: an Institution-independent Framework for Formal Program Development," </title> <institution> LFCS, University of Edinburgh, Research Report, </institution> <year> 1985. </year>
Reference-contexts: and so we suggested that it might be convenient to write an ASL specification initially and only transform into the ultraloose style before doing any proofs. (The soundness of this approach follows immediately from theorem 4.10.) An alternative approach would be to work in a language such as Extended ML <ref> [26] </ref> which restricts the specifier to "stable" specification building operators which allows straightforward proofs even in the presence of behavioural abstraction. The focus of this thesis is very much on theoretical results rather than on their practical application.
Reference: [27] <author> Donald T. Sannella & Andrzej Tarlecki, </author> <title> "On Observational Equivalence and Algebraic Specification," </title> <journal> J. Comput. System Sci. </journal> <volume> 34 (1987), </volume> <pages> 150-178. </pages>
Reference-contexts: We show that our definition is a slight generalisation of that of Meseguer and Goguen [17] and slightly stronger than the notions of behavioural reduction and behavioural equivalence of Sannella and Tarlecki <ref> [27] </ref>. Section 3.3 explores the utility of our generalisation of Meseguer and Goguen's definition | demonstrating that special cases correspond to isomorphism, isomorphism of subalgebras, etc. and investigating a few simple properties of behavioural equivalence. <p> Specifically, two algebras are regarded as behaviourally equivalent (with respect to a given "interface") if their "visible parts" (as determined by the "interface") are indistinguishable. An example (due to Sannella and Tarlecki <ref> [27] </ref>) is of a module providing a set-like abstract data type Bunch and operations empty: ! Bunch, add : Nat fi Bunch ! Bunch and 2: Nat fiBunch ! Bool (as well as the types Bool and Nat and the usual operations on these types). <p> An interesting corollary to theorem 3.16 is that IN OUT is stronger than EQ (IN ;OUT) . We repeat two results from <ref> [27] </ref> before stating and proving the corollary. The first result states that the satisfaction of a set Cl () of axioms is invariant under . Lemma 3.18 ( Cl () ( [27 Fact 18].)) Let be a signature, and a set of -formul.
Reference: [28] <author> Donald T. Sannella & Andrzej Tarlecki, </author> <title> "Specifications in an Arbitrary Institution," </title> <booktitle> Information and Computation 76 (1988), </booktitle> <pages> 165-210. </pages>
Reference: [29] <author> Donald T. Sannella & Andrzej Tarlecki, </author> <title> "Toward Formal Development of Programs from Algebraic Specifications: Implementations Revisited," </title> <journal> Acta Inform. </journal> <volume> 25 (1988), </volume> <pages> 233-281. </pages>
Reference-contexts: Specifications 33 * The operation quotient wrt E is defined in <ref> [29] </ref> by Mod (quotient SP wrt E ) def where is a -congruence determined by the set E of -equations (see [29] for details of ). * The operation extend to SP 0 via is defined in [29] by Mod (extend SP to SP 0 via ) def where SP 0 <p> Specifications 33 * The operation quotient wrt E is defined in <ref> [29] </ref> by Mod (quotient SP wrt E ) def where is a -congruence determined by the set E of -equations (see [29] for details of ). * The operation extend to SP 0 via is defined in [29] by Mod (extend SP to SP 0 via ) def where SP 0 is an equational specification and F : Alg (Sig (SP )) ! Mod (SP 0 ) is a free functor (see <p> Specifications 33 * The operation quotient wrt E is defined in <ref> [29] </ref> by Mod (quotient SP wrt E ) def where is a -congruence determined by the set E of -equations (see [29] for details of ). * The operation extend to SP 0 via is defined in [29] by Mod (extend SP to SP 0 via ) def where SP 0 is an equational specification and F : Alg (Sig (SP )) ! Mod (SP 0 ) is a free functor (see [29] for details of F ). * Most papers describing ASL describe an operator for forming <p> for details of ). * The operation extend to SP 0 via is defined in <ref> [29] </ref> by Mod (extend SP to SP 0 via ) def where SP 0 is an equational specification and F : Alg (Sig (SP )) ! Mod (SP 0 ) is a free functor (see [29] for details of F ). * Most papers describing ASL describe an operator for forming parameterised specifications; two recent papers describing ASL [30,33] define an operator for forming specifications of parameterised programs (cf. Standard ML's "functors"). We do not attempt to discuss parameterisation in this thesis. <p> Standard ML's "functors"). We do not attempt to discuss parameterisation in this thesis. Implementation Informal notions of stepwise implementation of a specification or stepwise program design are based on the idea that one program design is an implementation of another if it incorporates more design decisions. Sannella and Tarlecki <ref> [29] </ref> formalise this using the refinement relation " " on specifications defined by SP1 SP2 = Mod (SP2 ) Mod (SP1 ) Since the relation is transitive, we can conclude that SP1 SPm if we have shown that SP1 SP2 SPm. <p> can be easily implemented using programming language constructs and so a useful step in developing a program is to refine a specification SP to a specification of the form (SP 0 ) | replacing part of SP by an easily implemented constructor . (Considerably more detail may be found in <ref> [29] </ref>.) A constructor is said to be "stable" (with respect to an equivalence relation ) if, for any -algebras A and B, A B ) (A) (B) That is, a constructor is stable if the function on which it is based doesn't introduce differences between equivalent algebras.
Reference: [30] <author> Donald T. Sannella & Andrzej Tarlecki, </author> <title> A kernel specification formalism with higher-order parameterisation, </title> <institution> Dept. of Computer Science, Univ. of Edinburgh, </institution> <year> 1992. </year>
Reference-contexts: In the previous section, we saw that behavioural equivalence is a special case of a variety of standard equivalences used in the literature. It is therefore possible to use the behavioural abstraction operator behaviour wrt ( ; ) to define several standard closure operations. 2 For example: * In <ref> [30] </ref>, Sannella and Tarlecki define the closure operator isoclose by Mod (isoclose SP ) def But lemma 3.7 shows that, for a signature with sorts T , ~ = = T T . <p> Therefore isoclose is just a special case of behaviour wrt ( ; ). isoclose SP def = behaviour SP wrt (T ; T ) where T = Tp (Sig (SP )) * In <ref> [30] </ref>, Sannella and Tarlecki define the closure operator junk by Mod (junk IN on SP ) def where A ~ B = R ( ; IN ; A) ~ = R ( ; IN ; B) But lemma 3.11 shows that, for a signature with sorts T , ~= IN T <p> Observational Axioms 55 * In <ref> [30] </ref> Sannella and Tarlecki define the operator restrict to by Mod (restrict SP to IN ) def This operator removes the junk from each model of SP .
Reference: [31] <author> Donald T. Sannella & Andrzej Tarlecki, </author> <title> "Program Specification and Development in Standard ML," </title> <booktitle> Proceedings 12th ACM Symposium on Principles of Programming Languages, </booktitle> <address> New Orleans (Jan. </address> <year> 1985). </year>
Reference: [32] <author> Donald T. Sannella & Andrzej Tarlecki, </author> <title> "Toward formal development of programs from algebraic specifications: model-theoretic foundations," </title> <institution> Dept. of Computer Science, Univ. of Edinburgh, ECS-LFCS-92-204, </institution> <month> Mar. </month> <year> 1992. </year>
Reference: [33] <author> Donald T. Sannella, Andrzej Tarlecki & Stefan Sokolowski, </author> <title> "Toward formal development of programs from algebraic specifications: parameterisation revisited," FB3 | Mathematik/Informatik, </title> <type> Universitat Bremen, Draft report, </type> <month> Feb. 16, </month> <year> 1990. </year>
Reference: [34] <author> Donald T. Sannella & Martin Wirsing, </author> <title> "A kernel language for algebraic specification and implementation," </title> <booktitle> Lect. Notes in Comp. Sci. 158 (1983), </booktitle> <pages> 413-427. </pages>
Reference-contexts: This section defines these sublanguages. * The first sublanguage is ASL: a specification language developed by Sannella, Tarlecki and Wirsing [29,30,34]. When it was first described <ref> [34] </ref>, a distinguishing feature was the use of the behavioural abstraction operator behaviour wrt ( ; ). Although ASL is 2.3.
Reference: [35] <author> Oliver Schoett, </author> <title> "Data Abstraction and the correctness of modular programming," </title> <institution> Univ of Edinburgh, CST-42-87, </institution> <year> 1986, </year> <type> Ph.D. thesis </type> . 
Reference: [36] <author> Oliver Schoett, </author> <title> "An observational subset of first-order logic cannot specify the behaviour of a counter," </title> <booktitle> Lect. Notes in Comp. Sci. 480 (1991), </booktitle> <pages> 499-510, </pages> <note> extended abstract. References 124 </note>
Reference: [37] <author> Oliver Schoett, </author> <title> "Two Impossibility Theorems on Behaviour Specification of Abstract Data Types," </title> <journal> Acta Inform. </journal> <volume> 29 (1992), </volume> <pages> 595-621. </pages>
Reference-contexts: Our definitions resemble those of Wirsing and Schoett: in [41], Wirsing defines a signature as a pair hT ; F i but leaves ff implicit; in <ref> [37] </ref>, Schoett defines a signature as a pair hT ; ffi but leaves F implicit.] For example, the following is a typical signature for a stack. <p> The Semantics of ASL and USL 16 The class of all -algebras is denoted by Alg ( ). End Definition. [Our definition of an algebra is essentially the same as that of Schoett <ref> [37] </ref>. <p> End Definition. 6 Partial functions are used to avoid the problem that, if any carrier of an algebra is empty, there is no total T -indexed function v: X ! Aj T . This solution is based on that used by Schoett in <ref> [37] </ref>. The Semantics of ASL and USL 22 The following property of homomorphisms is used in chapter 3: Lemma 2.12 (representation of terms) Let be a signature with sorts T , X a T -indexed set of variables, A and B, - algebras and h: A ! B a -homomorphism. <p> Section 3.4 discusses how behavioural equivalence may be applied to specifications and shows how the special cases discussed in the previous section give rise to a 38 Behavioural Equivalence 39 variety of common specification building operations. In <ref> [37] </ref>, Schoett identifies a set of axioms he calls "observational axioms" (written Axm (IN ; OUT ) 1 ) and argues (without proof) that, for any observational axiom ax 2 Axm (IN ; OUT ), and behaviourally equivalent algebras A and B, A j= ax , B j= ax Section 3.5 <p> Finally, this result seems to point the way towards a subset of USL based only on observational axioms in which all specifications would naturally be behaviourally closed. Sadly, an "impossibility theorem" by Schoett <ref> [37] </ref> shows that the resulting language would be too weak to be useful (this result is discussed in section 3.6.) The weakness of such a language motivates the work in the next chapter where we examine the approach taken by Wirsing and Broy [2,42]. <p> That is, Axm (IN ; OUT ) is a set of axioms whose satisfaction is invariant under behavioural equivalence. Behavioural Equivalence 56 Schoett considers almost exactly this question in the introduction to <ref> [37] </ref>. (The main differences are that, like Meseguer and Goguen, Schoett considers the special case IN = OUT and that Schoett does not prove that he achieves his goal.) Schoett argues that, in an "observational specification" (that is a behaviourally closed specification) one should disallow equations between terms of unobservable sorts <p> As well as providing a precise characterisation of the semantic effect of adopting the ultraloose specification style, this result shows that, contrary to what Schoett's "impossibility theorem" <ref> [37] </ref> (discussed in section 3.5) seems to suggest it is possible to write useful behaviourally closed specifications in first order logic | we explain why there is no conflict. <p> Section 5.1 repeats Schoett's argument <ref> [37] </ref> that the only known technique for proving the result requires an infinite proof; and section 5.2 shows that a finite proof is possible using the equivalent ultraloose specification. (Equivalence follows from 1 Except in specifications (where we make quantification explicit) we use 8 r as an abbreviation for 8 fzero;inc;decg
Reference: [38] <author> J. W. Thatcher, E. G. Wagner & J. B. Wright, </author> <title> "Data Type Specification: Pa-rameterisation and the Power of Specification Techniques," </title> <journal> ACM Transactions on Programming Languages and Systems 4, </journal> <month> 4 (Oct. </month> <year> 1982), </year> <pages> 711-732, </pages> <booktitle> (abbreviated version presented at 10th Annual Symposium on Theory of Computing, </booktitle> <address> San Diego, California, </address> <month> May 1-3, </month> <year> 1978.). </year>
Reference: [39] <author> M. Wand, </author> <title> "Final algebra semantics and data type extensions," </title> <journal> Journal of Computer and System Sciences 19 (1981), </journal> <pages> 27-44. </pages>
Reference: [40] <author> Martin Wirsing, </author> <title> "Structured Algebraic Specification: a kernel language," </title> <booktitle> Theoretical Computer Science 42 (1986), </booktitle> <pages> 123-249. </pages>
Reference: [41] <author> Martin Wirsing, </author> <title> "Algebraic Specifications," in Handbook of Theoretical Computer Science, Formal Models and Semantics, Volume B, </title> <publisher> Elsevier, </publisher> <address> Amsterdam-New York, </address> <year> 1990, </year> <pages> 677-788, </pages> <note> Chapter 13. </note>
Reference-contexts: Our definitions resemble those of Wirsing and Schoett: in <ref> [41] </ref>, Wirsing defines a signature as a pair hT ; F i but leaves ff implicit; in [37], Schoett defines a signature as a pair hT ; ffi but leaves F implicit.] For example, the following is a typical signature for a stack.
Reference: [42] <author> Martin Wirsing & Manfred Broy, </author> <title> "A Modular Framework for Specification and Implementation," </title> <booktitle> Lect. Notes in Comp. Sci. 351 (1989), </booktitle> <pages> 42-73. </pages>
Reference-contexts: All these early works use reachable quantification for the same purpose as model-based specifications use invariants: to restrict the domain of concern to those values which the specifier expects programs to encounter during execution | that is, the reachable values. Wirsing and Broy <ref> [42] </ref> define a family of predicates 2 0 t for each (non-empty) subsignature 0 of and each sort t 2 Tp ( ) with semantics A j= v t 2 0 def The Semantics of ASL and USL 28 which they use to define a less general form of reachable quantification <p> Summary 101 4.5 Summary The introduction to this thesis argues that behavioural closure is an important property for specifications and notes that the "ultraloose specification style" used by Wirsing and Broy <ref> [42] </ref> appears to produce behaviourally closed specifications but that no-one has stated (or proved) what the precise effect of this style is. Based on the notions of behavioural equivalence developed in the previous chapter, this chapter provides three results which characterise the effect of the ultraloose style with increasing precision.
References-found: 42

