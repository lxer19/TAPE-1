URL: http://www.cs.washington.edu/homes/jayram/papers/journal-bp.ps
Refering-URL: http://www.cs.washington.edu/homes/jayram/
Root-URL: 
Email: @cs.washington.edu  
Title: Efficient Oblivious Branching Programs for Threshold and Mod Functions  
Author: Rakesh Kumar Sinha Jayram S. Thathachar frakesh, jayramg 
Note: O n log 3 n  
Address: Box 352350 Seattle, Washington 98195-2350  
Affiliation: Department of Computer Science and Engineering University of Washington  
Abstract: In his survey paper on branching programs, Razborov [Raz91] asked the following question: Does every rectifier-switching network computing the majority of n bits have size n 1+(1) ? We answer this question in the negative by constructing a simple oblivious branching program of size for computing any threshold function. This improves the previously best known upper bound of O(n 3=2 ) due to Lupanov [Lup65]. We also construct oblivious branching programs of size o(n log 4 n) for computing general mod functions. All previously known constructions for computing general mod functions have size (n 3=2 ). 
Abstract-found: 1
Intro-found: 1
Reference: [AM88] <author> Noga Alon and Wolfgang Maass. </author> <title> Meanders and their applications in lower bounds arguments. </title> <journal> Journal of Computer and System Sciences, </journal> <volume> 37 </volume> <pages> 118-129, </pages> <year> 1988. </year>
Reference-contexts: It can be easily seen that any constant-width branching program can be transformed into an equivalent oblivious branching program with a constant blow-up in the length and the width. Alon and Maass <ref> [AM88] </ref> and Babai et al. [BPRS90] independently proved that any oblivious branching program of width w p n for majority has length ( n log n log w ). <p> For width w n, the length of the resulting branching program is O log w log log log n , which is within O log log log n of the length lower bound of Alon and Maass <ref> [AM88] </ref>. Our constructions have other nice properties. <p> The results in Alon and Maass <ref> [AM88] </ref> and Babai et al. [BPRS90] only depend on the communication complexity of the function and gives the best known lower bound for mod functions.
Reference: [Bar89] <author> David A. </author> <title> Mix Barrington. Bounded-width polynomial-size branching programs recognize exactly those languages in NC 1 . Journal of Computer and System Sciences, </title> <booktitle> 38 </booktitle> <pages> 150-164, </pages> <year> 1989. </year>
Reference-contexts: Razborov proved it for rectifier-switching networks; Karchmer and Wigderson proved it for span programs. In the direction of upper bounds, progress has been even more elusive. Barrington <ref> [Bar89] </ref>, in an important breakthrough, proved that there are polynomial size branching programs of width five for computing majority (and all functions in N C 1 ). Ben Or and Cleve [BC92] generalized this result to arithmetic computation over any ring.
Reference: [BC94] <author> R. E. Bryant, Y. Chen. </author> <title> Verification of arithmetic functions with binary moment diagrams. </title> <type> Technical report CS-94-160, </type> <institution> Carnegie Mellon University, School of Computer Science. </institution>
Reference-contexts: For example, the size complexity of any function in the branching program model lies between its circuit size and formula size complexity (see, e.g., page 416 of [Weg87]). Recent use of some restrictions on the branching programs model (for example, ordered binary decision diagrams <ref> [BCL + 94, Bry92, BC94] </ref>) as a data structure in circuit design and verification has given added motivation to construct efficient representation of functions in terms of branching programs. Despite the apparent simplicity of the branching program model, researchers have had very little success in proving interesting bounds.
Reference: [BCL + 94] <author> Jerry R. Burch, Edmund M. Clarke, David E. Long, Kenneth L. McMillan, and David L. Dill. </author> <title> Symbolic model checking for sequential circuit verification. </title> <journal> IEEE Transactions on Computer-Aided Design of Integrated Circuits, </journal> <volume> 13(4) </volume> <pages> 401-424, </pages> <year> 1994. </year>
Reference-contexts: For example, the size complexity of any function in the branching program model lies between its circuit size and formula size complexity (see, e.g., page 416 of [Weg87]). Recent use of some restrictions on the branching programs model (for example, ordered binary decision diagrams <ref> [BCL + 94, Bry92, BC94] </ref>) as a data structure in circuit design and verification has given added motivation to construct efficient representation of functions in terms of branching programs. Despite the apparent simplicity of the branching program model, researchers have had very little success in proving interesting bounds.
Reference: [BPRS90] <author> Laszlo Babai, Pavel Pudlak, V. Rodl, and Endre Szemeredi. </author> <title> Lower bounds to the complexity of symmetric Boolean functions. </title> <journal> Theoretical Computer Science, </journal> <volume> 74 </volume> <pages> 313-324, </pages> <year> 1990. </year>
Reference-contexts: It can be easily seen that any constant-width branching program can be transformed into an equivalent oblivious branching program with a constant blow-up in the length and the width. Alon and Maass [AM88] and Babai et al. <ref> [BPRS90] </ref> independently proved that any oblivious branching program of width w p n for majority has length ( n log n log w ). <p> For the case of arbitrary branching programs, Pudlak [Pud84] used a Ramsey-theoretic argu ment to prove an unconditional size lower bound of log log log n for computing most threshold functions (including majority). Babai et al. <ref> [BPRS90] </ref> improved this to an unconditional size lower bound of log log n for computing majority. This bound also uses a communication complexity argument and applies to almost all symmetric functions. <p> This size bound is within O log log log n of the size lower bound of Babai et al. <ref> [BPRS90] </ref>. Our method also yields a spectrum of branching programs, one for each width greater than log n. <p> The results in Alon and Maass [AM88] and Babai et al. <ref> [BPRS90] </ref> only depend on the communication complexity of the function and gives the best known lower bound for mod functions.
Reference: [BRS93] <author> Allan Borodin, A. A. Razborov, and Roman Smolensky. </author> <title> On lower bounds for read-k times branching programs. </title> <journal> Computational Complexity, </journal> <volume> 3 </volume> <pages> 1-18, </pages> <month> October </month> <year> 1993. </year>
Reference-contexts: Our constructions have other nice properties. For example, for any k = O log log n log log log n they can be modified to give efficient syntactic read-k branching programs. (See Borodin et al. <ref> [BRS93] </ref> for definitions, motivations, and a survey of results.) Moreover, for any `, between 3 levels `n and (` + 1)n 1, the variables are accessed in the order x 1 ; x 2 ; : : : ; x n .
Reference: [Bry92] <author> R. E. Bryant. </author> <title> Symbolic Boolean manipulation with ordered binary decision diagrams. </title> <journal> ACM Computing Surveys, </journal> <volume> 24(3) </volume> <pages> 283-316, </pages> <month> September </month> <year> 1992. </year>
Reference-contexts: For example, the size complexity of any function in the branching program model lies between its circuit size and formula size complexity (see, e.g., page 416 of [Weg87]). Recent use of some restrictions on the branching programs model (for example, ordered binary decision diagrams <ref> [BCL + 94, Bry92, BC94] </ref>) as a data structure in circuit design and verification has given added motivation to construct efficient representation of functions in terms of branching programs. Despite the apparent simplicity of the branching program model, researchers have had very little success in proving interesting bounds.
Reference: [BC92] <author> M. Ben-Or and R. Cleve. </author> <title> Computing algebraic formulas using a constant number of registers. </title> <journal> SIAM Journal on Computing, </journal> <volume> 21 </volume> <pages> 54-58, </pages> <year> 1992. </year>
Reference-contexts: In the direction of upper bounds, progress has been even more elusive. Barrington [Bar89], in an important breakthrough, proved that there are polynomial size branching programs of width five for computing majority (and all functions in N C 1 ). Ben Or and Cleve <ref> [BC92] </ref> generalized this result to arithmetic computation over any ring. The size blow-up in the simulation was later improved by Cai and Lipton [CL94] and Cleve [Cle91].
Reference: [BS95] <author> David A. Mix Barrington, and Howard Straubing. </author> <title> Superlinear lower bounds for bounded-width branching programs. </title> <journal> Journal of Computer and System Sciences, </journal> <volume> 50 </volume> <pages> 374-381, </pages> <year> 1995. </year>
Reference-contexts: branching program for majority has super-linear size. (Actually their result 2 applies to the stronger rectifier-switching model, but we will not define this model in this paper; they are one of the natural nondeterministic extensions of the branching program model.) For the class of non-constant threshold functions, Barrington and Straubing <ref> [BS95] </ref>, using algebraic techniques, improved this bound to (n log log n). It can be easily seen that any constant-width branching program can be transformed into an equivalent oblivious branching program with a constant blow-up in the length and the width.
Reference: [BNS92] <author> Laszlo Babai, Noam Nisan, and Mario Szegedy. </author> <title> Multiparty protocols, pseudorandom generators for logspace and time-space trade-offs. </title> <journal> Journal of Computer and System Sciences, </journal> <volume> 45 </volume> <pages> 204-232, </pages> <year> 1992. </year>
Reference-contexts: For the case of general (not necessarily symmetric) Boolean functions, the strongest lower bound on oblivious branching programs is due to Babai, Nisan and Szegedy <ref> [BNS92] </ref>. They proved that for an explicit Boolean function, any oblivious branching program of length o (n log 2 n) has width exp (n (1) ).
Reference: [CFL83] <author> Ashok K. Chandra, M. L. Furst, and Richard J. Lipton. </author> <title> Multi-party protocols. </title> <booktitle> In Proceedings of the Fifteenth Annual ACM Symposium on Theory of Computing, </booktitle> <pages> pages 94-99, </pages> <address> Boston, MA, </address> <month> April </month> <year> 1983. </year>
Reference-contexts: It is easy to see that any symmetric function can be computed with a branching program of size O (n 2 ), and any branching program computing a function that is sensitive to each one of its inputs must have at least n nodes. Chandra et al. <ref> [CFL83] </ref> proved that any constant-width branching program for majority has super-linear size. (Actually their result 2 applies to the stronger rectifier-switching model, but we will not define this model in this paper; they are one of the natural nondeterministic extensions of the branching program model.) For the class of non-constant threshold
Reference: [CL94] <author> Jin-yi Cai and Richard J. Lipton. </author> <title> Subquadratic simulations of circuits by branching programs. </title> <journal> SIAM Journal on Computing, </journal> <volume> 23(3): </volume> <pages> 563-572, </pages> <year> 1994. </year>
Reference-contexts: Ben Or and Cleve [BC92] generalized this result to arithmetic computation over any ring. The size blow-up in the simulation was later improved by Cai and Lipton <ref> [CL94] </ref> and Cleve [Cle91]. The resulting branching programs for computing majority, though, are not efficient in size; they are larger than the obvious O (n 2 ) construction. Lupanov [Lup65] improved upon the obvious upper bound by constructing a branching program of size O (n 3=2 ) for majority.
Reference: [Cle91] <author> R. Cleve. </author> <title> Towards optimal simulations of formulas by bounded-width programs. </title> <journal> Computational Complexity, </journal> <volume> 1 </volume> <pages> 91-105, </pages> <year> 1991. </year>
Reference-contexts: Ben Or and Cleve [BC92] generalized this result to arithmetic computation over any ring. The size blow-up in the simulation was later improved by Cai and Lipton [CL94] and Cleve <ref> [Cle91] </ref>. The resulting branching programs for computing majority, though, are not efficient in size; they are larger than the obvious O (n 2 ) construction. Lupanov [Lup65] improved upon the obvious upper bound by constructing a branching program of size O (n 3=2 ) for majority.
Reference: [HW79] <author> G. H. Hardy and E. M. Wright. </author> <title> An Introduction to the Theory of Numbers. </title> <publisher> Oxford University Press, </publisher> <address> fifth edition, </address> <year> 1979. </year>
Reference-contexts: Our main technical tool is the Chinese remainder theorem which lets us construct an integer from its values computed modulo many small primes. (A proof can be found in any standard textbook on Number Theory, for example, Hardy and Wright <ref> [HW79] </ref>.) We will illustrate this approach by an example. Definition: For any k n, the exact-k function, E k , accepts an input ~x if and only if k~xk = k.
Reference: [KW93] <author> Mauricio Karchmer and Avi Wigderson. </author> <title> On span programs. </title> <booktitle> In Proceedings, Structure in Complexity Theory, Eighth Annual Conference, </booktitle> <pages> pages 102-111, </pages> <address> San Diego, CA, </address> <month> May </month> <year> 1993. </year> <note> IEEE. </note>
Reference-contexts: Babai et al. [BPRS90] improved this to an unconditional size lower bound of log log n for computing majority. This bound also uses a communication complexity argument and applies to almost all symmetric functions. Razborov [Raz90], and Karchmer and Wigderson <ref> [KW93] </ref> proved unconditional size lower bounds of (n log log log ? n) for computing majority on models more powerful than branching programs. Razborov proved it for rectifier-switching networks; Karchmer and Wigderson proved it for span programs. In the direction of upper bounds, progress has been even more elusive.
Reference: [Lup65] <author> O. B. Lupanov. </author> <title> On the problem of realization of symmetric Boolean functions by contact schemes. </title> <journal> Problemyh kibernetiki (Problems of Cybernetics), </journal> <volume> 15 </volume> <pages> 85-99, </pages> <year> 1965. </year> <note> In Russian. </note>
Reference-contexts: The size blow-up in the simulation was later improved by Cai and Lipton [CL94] and Cleve [Cle91]. The resulting branching programs for computing majority, though, are not efficient in size; they are larger than the obvious O (n 2 ) construction. Lupanov <ref> [Lup65] </ref> improved upon the obvious upper bound by constructing a branching program of size O (n 3=2 ) for majority. No improvement had been made on Lupanov's construction in nearly thirty years.
Reference: [Nec66] <author> E. Neciporuk. </author> <title> On a Boolean function. </title> <journal> Soviet Math. Doklady, </journal> <volume> 7 </volume> <pages> 999-1000, </pages> <year> 1966. </year>
Reference-contexts: Despite the apparent simplicity of the branching program model, researchers have had very little success in proving interesting bounds. The best lower bound for a function in NP is due to Neciporuk <ref> [Nec66] </ref>. Beame and Cook (unpublished) noticed that Neciporuk's method applied to the element distinctness problem gives an ( n 2 log 2 n ) lower bound. Neciporuk's technique does not prove any non-trivial bounds for symmetric functions functions that depend only on the number of ones in the input.
Reference: [Pud84] <author> Pavel Pudlak. </author> <title> A lower bound on complexity of branching programs. </title> <booktitle> In Proceedings of the 11th MFCT, volume 176 of Lecture Notes in Computer Science, </booktitle> <pages> pages 480-489, </pages> <publisher> Springer-Verlag, </publisher> <address> NewYork/Berlin, </address> <year> 1984. </year>
Reference-contexts: They proved that for an explicit Boolean function, any oblivious branching program of length o (n log 2 n) has width exp (n (1) ). For the case of arbitrary branching programs, Pudlak <ref> [Pud84] </ref> used a Ramsey-theoretic argu ment to prove an unconditional size lower bound of log log log n for computing most threshold functions (including majority). Babai et al. [BPRS90] improved this to an unconditional size lower bound of log log n for computing majority.
Reference: [Raz90] <author> A. A. Razborov. </author> <title> Lower bounds on the size of switching-and-rectifier networks for symmetric Boolean functions. </title> <journal> Mathematical Notes of the Academy of Sciences of the USSR, </journal> <volume> 48(6) </volume> <pages> 79-91, </pages> <year> 1990. </year> <month> 21 </month>
Reference-contexts: Babai et al. [BPRS90] improved this to an unconditional size lower bound of log log n for computing majority. This bound also uses a communication complexity argument and applies to almost all symmetric functions. Razborov <ref> [Raz90] </ref>, and Karchmer and Wigderson [KW93] proved unconditional size lower bounds of (n log log log ? n) for computing majority on models more powerful than branching programs. Razborov proved it for rectifier-switching networks; Karchmer and Wigderson proved it for span programs.
Reference: [Raz91] <author> A. A. Razborov. </author> <title> Lower bounds for deterministic and nondeterministic branching programs. </title> <editor> In Lothar Budach, editor, </editor> <booktitle> Fundamentals of Computation Theory: 8th International Conference, FCT '91, volume 529 of Lecture Notes in Computer Science, </booktitle> <pages> pages 47-60, </pages> <address> Gosen, Germany, </address> <month> September </month> <year> 1991. </year> <note> Springer-Verlag. </note>
Reference-contexts: Branching programs fl This material is based upon work supported in part by the National Science Foundation under Grants CCR-8858799 and CCR-9303017. and their many variants have long been a popular model for studying complexity of functions (see, for example, the survey paper of Razborov <ref> [Raz91] </ref>). A (Boolean) branching program is a directed acyclic graph with a designated source node and some number of sink nodes. <p> Lupanov [Lup65] improved upon the obvious upper bound by constructing a branching program of size O (n 3=2 ) for majority. No improvement had been made on Lupanov's construction in nearly thirty years. This led Razborov <ref> [Raz91] </ref> to pose the following open problem: Does every rectifier-switching network computing the majority of n bits have size n 1+(1) ? We settle this problem in a strong negative way by constructing a simple oblivious branching program of width O (log n) and size O log log n log log
Reference: [RS62] <author> J. B. Rosser and L. Schoenfeld. </author> <title> Approximate formulas for some functions of prime numbers. </title> <journal> Illinois Journal of Mathematics, </journal> <volume> 6 </volume> <pages> 64-94, </pages> <year> 1962. </year>
Reference-contexts: We will be repeatedly using the following corollary of the prime number theorem. (A proof can be derived from <ref> [RS62, Corollary 1 and 2] </ref>.) Theorem 4: For any constant c &gt; 0, there exist constants N; c 0 &gt; 0 such that for all n N , there are at least log log n primes between log n and c 0 log n. 6 We can use this corollary to <p> Define M = Q and M 0 = M=p k . log log L (B) L &lt; M 0 (p k k + 2) log log L &lt; L. Proof: From <ref> [RS62, Theorem 4] </ref> we know that there is a constant C 0 such that for L C 0 , the product of all primes between log L and 4 log L is at least L 4 log L .
Reference: [Sin95] <author> Rakesh K. Sinha. </author> <title> Some topics in parallel computation and branching programs (Ph.D. </title> <type> Thesis). </type> <institution> University of Washington CSE Technical Report UW-CSE-95-08-02. </institution>
Reference-contexts: The lemma below shows that for computing symmetric functions there is an easy translation from chain MA-programs to oblivious branching programs. It is also possible to define a more general form of chain MA-programs that corresponds to non-oblivious branching programs <ref> [Sin95] </ref>. 7 The size of any chain MA-program is defined as the summation of the moduli of all its boxes.
Reference: [Weg87] <author> Ingo Wegener. </author> <title> The complexity of Boolean functions. </title> <booktitle> Wiley-Teubner Series in Computer Science, </booktitle> <year> 1987. </year> <month> 22 </month>
Reference-contexts: Branching programs are also closely related to other well studied models of computation. For example, the size complexity of any function in the branching program model lies between its circuit size and formula size complexity (see, e.g., page 416 of <ref> [Weg87] </ref>). Recent use of some restrictions on the branching programs model (for example, ordered binary decision diagrams [BCL + 94, Bry92, BC94]) as a data structure in circuit design and verification has given added motivation to construct efficient representation of functions in terms of branching programs.
References-found: 23

