URL: ftp://ftp.cs.toronto.edu/pub/bonner/papers/transaction.logic/pods98-long.ps
Refering-URL: http://www.cs.toronto.edu/DB/people/bonner/papers.html
Root-URL: 
Email: bonner@db.toronto.edu  
Title: The Power of Cooperating Transactions  
Author: Anthony J. Bonner 
Web: www.cs.toronto.edu/~bonner  
Address: Toronto, Ontario, Canada M5S 1A4  
Affiliation: University of Toronto Department of Computer Science  
Abstract: In the classical model of database transactions, large transactions cannot be built out of smaller ones. Instead, transactions are modelled as atomic and isolated units of work. This model has been widely successful in traditional database applications, but is inappropriate for more complex applications in which transactions must be combined and coordinated to achieve a larger goal. Examples include CAD, office automation, collaborative work, manufacturing control, and work-flow management. These applications require new transaction models, new methods of transaction management, and new transaction languages. This paper focuses on the latter issue: languages for specifying non-classical transactions, and combining them into complex processes. Our vehicle for this study is Transaction Datalog, a deductive language that integrates queries, updates, and transaction composition in a simple logical framework. This integration captures the features of many new transaction models. These features include subtransaction hierarchies, concurrency within individual transactions, cooperation between concurrent activities, a separation of atomicity and isolation, and fine-grained control over abort and rollback. This paper provides an overview of Transaction Datalog, and develops its computational properties. We first show that the data complexity of sequential programs is complete for EXPTIME, while the data complexity of concurrent programs is complete for RE. This enormous difference in complexity comes entirely from cooperation between concurrent transactions. In particular, unlike other results in the database literature, RE-completeness is achieved with a fixed data domain, and a fixed database schema, and thus with databases of polynomial size. In addition, we show that Transaction Datalog is expressively complete. That is, concurrent programs express essentially all the transactions in RE, while sequential programs express essentially all the transactions in EXPTIME. Finally, we show that the language is minimal in that if any database operations are removed from the language, then expressive completeness is lost. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> S. Abiteboul. </author> <title> Updates, a new frontier. </title> <booktitle> In Intl. Conference on Database Theory, </booktitle> <pages> pages 1-18, </pages> <year> 1988. </year>
Reference-contexts: A detailed comparison of T D with other languages is published in [10], which is available on the Web. The comparison includes database update languages <ref> [3, 2, 1, 18, 19, 37, 51, 40, 41] </ref>, languages for expressing intertask dependencies [45, 21, 22, 23, 4, 47, 46], process algebras [38, 30, 36], concurrent dynamic logic [44, 43], and concurrent logic programming [15].
Reference: [2] <author> S. Abiteboul and V. Vianu. </author> <title> Procedural languages for database queries and updates. </title> <journal> Journal of Computer and System Sciences, </journal> <volume> 41 </volume> <pages> 181-229, </pages> <year> 1990. </year>
Reference-contexts: We show that this effect is profound, and that a set of interacting programs has a much more complex effect than a single, isolated program. To demonstrate this property, we adapt the notion of data complexity used in <ref> [3, 2] </ref> for classical transactions. We then establish the data complexity of T D with and without concurrency. The first result is that without concurrency, the data complexity of T D is complete for EXPTIME. This result is interesting in itself, since most safe update languages are complete for PSPACE. <p> This enormous increase in complexity, from EXPTIME to RE, comes entirely from the interactions between concurrent update programs. In contrast, other database update languages achieve RE-completeness by expanding the data domain during transaction execution <ref> [2, 3, 17] </ref>, or by expanding the database schema [18]. Typically, the proof of RE-completeness involves encoding the tape of a Turing machine in the database. Reading the tape is then a database query, and writing the tape is a database update. <p> That is, with concurrency, T D expresses every transaction in RE, as long as it does not expand the data domain. Likewise, without concurrency, T D expresses every transaction in EXPTIME. In these results, a transaction is defined to be a binary relation on databases, as in <ref> [2, 3] </ref>. Finally, we show that the database operations on which T D is built are minimal: if any operation is removed from T D, then expressive completeness is lost. A detailed comparison of T D with other languages is published in [10], which is available on the Web. <p> A detailed comparison of T D with other languages is published in [10], which is available on the Web. The comparison includes database update languages <ref> [3, 2, 1, 18, 19, 37, 51, 40, 41] </ref>, languages for expressing intertask dependencies [45, 21, 22, 23, 4, 47, 46], process algebras [38, 30, 36], concurrent dynamic logic [44, 43], and concurrent logic programming [15]. <p> term "transaction program." In transaction processing, a transaction is a particular execution of a transaction program [5, 29]; in application programming, it is often the transaction program itself; and in data modeling, it is the effects of a transaction program on the database (i:e:, a mapping from databases to databases) <ref> [3, 2] </ref>. Since this paper bridges all three areas, we shall have cause to use the term "transaction" in all three senses. In each case, however, the appropriate meaning shall be stated explicitly, or should be clear from context. <p> That is, the program transforms an initial database into a final database. Since the program may be non-determinisitic, many final databases are possible, so the transformation is a binary relation, as in <ref> [3, 2] </ref>. Formally, a T D program is defined by a transaction base, P, and a ground goal, . We use the expression P : D 1 D 2 ` fi to mean that the program transforms database D 1 into database D 2 when executed in isolation. <p> We must now show that RE is also a lower bound. To prove that an update language is RE-hard, it is common to use the language to simulate the computations of an arbitrary Turing machine <ref> [18, 3, 2, 17] </ref>. In such simulations, the machine tape is typically encoded in the database. Reading the tape is then a database query, and writing the tape is a database update. <p> This is why the data complexity of safe update languages is bounded above by PSPACE <ref> [19, 3, 2] </ref>, and why that of sequential T D is bounded above by alternating PSPACE. To represent machine tapes of arbitrary length in the database, some languages allow the database schema to expand during execution [18], while others allow the data domain to expand [2, 3, 17]. <p> To represent machine tapes of arbitrary length in the database, some languages allow the database schema to expand during execution [18], while others allow the data domain to expand <ref> [2, 3, 17] </ref>. In this way, the database can grow to arbitrary size during transaction execution. This section takes a completely different approach. We do not encode machine tapes in the database. Instead, we encode machine tapes as sequential goals (or programs). <p> In addition, there may be a stored predicate symbol dom of arity 1, whose ground atomic formulas represent the domain of the database; otherwise, the domain is taken to be the set of constant symbols in the database. The next definition is adapted from <ref> [3, 2] </ref>, which in turn is based on Chandra and Harel's definition of generic query [18, 19]. The main differnce between queries and transctions is that a query is a mapping from databases to relations, while a transaction is a binary relation on databases.
Reference: [3] <author> S. Abiteboul and V. Vianu. </author> <title> Datalog extensions for database queries and updates. </title> <journal> Journal of Computer and System Sciences, </journal> <volume> 43 </volume> <pages> 62-124, </pages> <year> 1991. </year>
Reference-contexts: We show that this effect is profound, and that a set of interacting programs has a much more complex effect than a single, isolated program. To demonstrate this property, we adapt the notion of data complexity used in <ref> [3, 2] </ref> for classical transactions. We then establish the data complexity of T D with and without concurrency. The first result is that without concurrency, the data complexity of T D is complete for EXPTIME. This result is interesting in itself, since most safe update languages are complete for PSPACE. <p> This enormous increase in complexity, from EXPTIME to RE, comes entirely from the interactions between concurrent update programs. In contrast, other database update languages achieve RE-completeness by expanding the data domain during transaction execution <ref> [2, 3, 17] </ref>, or by expanding the database schema [18]. Typically, the proof of RE-completeness involves encoding the tape of a Turing machine in the database. Reading the tape is then a database query, and writing the tape is a database update. <p> That is, with concurrency, T D expresses every transaction in RE, as long as it does not expand the data domain. Likewise, without concurrency, T D expresses every transaction in EXPTIME. In these results, a transaction is defined to be a binary relation on databases, as in <ref> [2, 3] </ref>. Finally, we show that the database operations on which T D is built are minimal: if any operation is removed from T D, then expressive completeness is lost. A detailed comparison of T D with other languages is published in [10], which is available on the Web. <p> A detailed comparison of T D with other languages is published in [10], which is available on the Web. The comparison includes database update languages <ref> [3, 2, 1, 18, 19, 37, 51, 40, 41] </ref>, languages for expressing intertask dependencies [45, 21, 22, 23, 4, 47, 46], process algebras [38, 30, 36], concurrent dynamic logic [44, 43], and concurrent logic programming [15]. <p> term "transaction program." In transaction processing, a transaction is a particular execution of a transaction program [5, 29]; in application programming, it is often the transaction program itself; and in data modeling, it is the effects of a transaction program on the database (i:e:, a mapping from databases to databases) <ref> [3, 2] </ref>. Since this paper bridges all three areas, we shall have cause to use the term "transaction" in all three senses. In each case, however, the appropriate meaning shall be stated explicitly, or should be clear from context. <p> That is, the program transforms an initial database into a final database. Since the program may be non-determinisitic, many final databases are possible, so the transformation is a binary relation, as in <ref> [3, 2] </ref>. Formally, a T D program is defined by a transaction base, P, and a ground goal, . We use the expression P : D 1 D 2 ` fi to mean that the program transforms database D 1 into database D 2 when executed in isolation. <p> We must now show that RE is also a lower bound. To prove that an update language is RE-hard, it is common to use the language to simulate the computations of an arbitrary Turing machine <ref> [18, 3, 2, 17] </ref>. In such simulations, the machine tape is typically encoded in the database. Reading the tape is then a database query, and writing the tape is a database update. <p> This is why the data complexity of safe update languages is bounded above by PSPACE <ref> [19, 3, 2] </ref>, and why that of sequential T D is bounded above by alternating PSPACE. To represent machine tapes of arbitrary length in the database, some languages allow the database schema to expand during execution [18], while others allow the data domain to expand [2, 3, 17]. <p> To represent machine tapes of arbitrary length in the database, some languages allow the database schema to expand during execution [18], while others allow the data domain to expand <ref> [2, 3, 17] </ref>. In this way, the database can grow to arbitrary size during transaction execution. This section takes a completely different approach. We do not encode machine tapes in the database. Instead, we encode machine tapes as sequential goals (or programs). <p> In addition, there may be a stored predicate symbol dom of arity 1, whose ground atomic formulas represent the domain of the database; otherwise, the domain is taken to be the set of constant symbols in the database. The next definition is adapted from <ref> [3, 2] </ref>, which in turn is based on Chandra and Harel's definition of generic query [18, 19]. The main differnce between queries and transctions is that a query is a mapping from databases to relations, while a transaction is a binary relation on databases.
Reference: [4] <author> P. Attie, M. Singh, A. Sheth, and M. Rusinkiewicz. </author> <title> Specifying and enforcing intertask dependencies. </title> <booktitle> In Intl. Conference on Very Large Data Bases, </booktitle> <address> Dublin, Ireland, </address> <month> August </month> <year> 1993. </year>
Reference-contexts: A detailed comparison of T D with other languages is published in [10], which is available on the Web. The comparison includes database update languages [3, 2, 1, 18, 19, 37, 51, 40, 41], languages for expressing intertask dependencies <ref> [45, 21, 22, 23, 4, 47, 46] </ref>, process algebras [38, 30, 36], concurrent dynamic logic [44, 43], and concurrent logic programming [15]. In addition, comparisons with logics of time and action can be found in [13, 14], and a comparison with the pi calculus is given in [15].
Reference: [5] <author> P.A. Bernstein, V. Hadzilacos, and N. Goodman. </author> <title> Con-currency Control and Recovery in Databases. </title> <publisher> Addison Wesley, </publisher> <year> 1987. </year>
Reference-contexts: Unfortunately, the term "transaction" is heavily overloaded in the database literature, and has a variety of relationships to the term "transaction program." In transaction processing, a transaction is a particular execution of a transaction program <ref> [5, 29] </ref>; in application programming, it is often the transaction program itself; and in data modeling, it is the effects of a transaction program on the database (i:e:, a mapping from databases to databases) [3, 2]. <p> In this way, the two subprocesses again communicate (in the reverse direction), and processA is synchronized with processB. 2 Because communication between T D programs can be two-way, as in Example 2.5, the execution of T D programs need not be serializable <ref> [5] </ref>, so they need not be isolated transactions. To specify that a program executes transactionally, a T D programmer uses the modality of isolation, fi. Intuitively, the formula fi means that program executes in isolation from all other concurrent programs.
Reference: [6] <author> A. Bonner, A. Shrufi, and S. Rozen. LabFlow-1: </author> <title> a database benchmark for high-throughput work-flow management. </title> <booktitle> In Intl. Conference on Extending Database Technology, number 1057 in Lecture Notes in Computer Science, </booktitle> <pages> pages 463-478, </pages> <address> Avignon, France, March 25-29 1996. </address> <publisher> Springer-Verlag. </publisher>
Reference-contexts: In fact, cooperation and coordination are sometimes the raison d'^etre of non-classical transactions. A workflow, for instance, is a coordinated execution of many activities <ref> [6, 33] </ref>. Characterizing the complexity of non-classical transactions thus involves characterizing the complexity of their interactions. In this paper, we take a simple approach to the problem: given a set of concurrent programs, we measure the complexity of their interactions by observing its effect on the database.
Reference: [7] <author> A.J. Bonner. </author> <title> Hypothetical Datalog: Complexity and expressibility. </title> <journal> Theoretical Computer Science, </journal> <volume> 76 </volume> <pages> 3-51, </pages> <year> 1990. </year>
Reference: [8] <author> A.J. Bonner. </author> <title> Intuitionistic deductive databases and the polynomial time hierarchy. </title> <journal> Journal of Logic Programming, </journal> <volume> 33(1) </volume> <pages> 1-47, </pages> <month> October </month> <year> 1997. </year>
Reference: [9] <author> A.J. Bonner. </author> <title> A logical semantics for hypothetical rule-bases with deletion. </title> <journal> Journal of Logic Programming, </journal> <volume> 32(2) </volume> <pages> 119-170, </pages> <month> August </month> <year> 1997. </year>
Reference: [10] <author> A.J. Bonner. </author> <title> Transaction Datalog: a compositional language for transaction programming. </title> <booktitle> In Proceedings of the International Workshop on Database Programming Languages, </booktitle> <address> Estes Park, Col-orado, </address> <month> August </month> <year> 1997. </year> <note> Springer Verlag. Long version available at http://www.cs.toronto.edu/~bonner/ papers.html#transaction-logic. </note>
Reference-contexts: Finally, we show that the database operations on which T D is built are minimal: if any operation is removed from T D, then expressive completeness is lost. A detailed comparison of T D with other languages is published in <ref> [10] </ref>, which is available on the Web. The comparison includes database update languages [3, 2, 1, 18, 19, 37, 51, 40, 41], languages for expressing intertask dependencies [45, 21, 22, 23, 4, 47, 46], process algebras [38, 30, 36], concurrent dynamic logic [44, 43], and concurrent logic programming [15].
Reference: [11] <author> A.J. Bonner and M. Kifer. </author> <title> Reasoning about action in transaction logic. In preparation. Presented at the Dagstuhl Seminar on Logic Databases and the Meaning of Change, </title> <month> September 23-27 </month> <year> 1996, </year> <booktitle> International Conference and Research Center for Computer Science, </booktitle> <address> Schloss Dagstuhl, Wadern, Germany. </address>
Reference: [12] <author> A.J. Bonner and M. Kifer. </author> <title> Transaction logic programming. </title> <booktitle> In Intl. Conference on Logic Programming, </booktitle> <pages> pages 257-282, </pages> <address> Budapest, Hungary, June 1993. </address> <publisher> MIT Press. </publisher>
Reference-contexts: The examples also show how logical formulas in T D can be interpreted operationally, like logic programs. In fact, like classical Datalog, Transaction Datalog has a logic-programming foundation <ref> [15, 13, 12, 14] </ref>. However, in classical logic programming, there are no updates, no database transactions (classical or otherwise), and no atomicity, isolation, or rollback. <p> Likewise, there is a generic, constant-preserving transaction in PTIME that sequential T D cannot express. Acknowledgements: Transaction Datalog is a frag-ment of Transaction Logic, which was developed in collaboration with Michael Kifer <ref> [13, 15, 12, 16, 14] </ref>. Thanks go to David Toman and Michael Kifer for their comments on this paper. This work was supported in part by a Research Grant from the Natural Sciences and Engineering Research Council of Canada (NSERC).
Reference: [13] <author> A.J. Bonner and M. Kifer. </author> <title> An overview of transaction logic. </title> <journal> Theoretical Computer Science, </journal> <volume> 133 </volume> <pages> 205-265, </pages> <month> Oc-tober </month> <year> 1994. </year>
Reference-contexts: In addition, comparisons with logics of time and action can be found in <ref> [13, 14] </ref>, and a comparison with the pi calculus is given in [15]. <p> The examples also show how logical formulas in T D can be interpreted operationally, like logic programs. In fact, like classical Datalog, Transaction Datalog has a logic-programming foundation <ref> [15, 13, 12, 14] </ref>. However, in classical logic programming, there are no updates, no database transactions (classical or otherwise), and no atomicity, isolation, or rollback. <p> Likewise, there is a generic, constant-preserving transaction in PTIME that sequential T D cannot express. Acknowledgements: Transaction Datalog is a frag-ment of Transaction Logic, which was developed in collaboration with Michael Kifer <ref> [13, 15, 12, 16, 14] </ref>. Thanks go to David Toman and Michael Kifer for their comments on this paper. This work was supported in part by a Research Grant from the Natural Sciences and Engineering Research Council of Canada (NSERC).
Reference: [14] <author> A.J. Bonner and M. Kifer. </author> <title> Transaction logic programming (or a logic of declarative and procedural knowledge). </title> <type> Technical Report CSRI-323, </type> <institution> University of Toronto, </institution> <month> November </month> <year> 1995. </year> <note> http://www.cs.toronto.edu/~bonner/ transaction-logic.html. </note>
Reference-contexts: In addition, comparisons with logics of time and action can be found in <ref> [13, 14] </ref>, and a comparison with the pi calculus is given in [15]. <p> This idea is developed in <ref> [16, 14] </ref> and implemented in [34]. 2 OVERVIEW OF TRANSACTION DATALOG 6 * ( 1 j 2 j j k ) where k 0 and each i is a goal; or * fi where is a goal; where parentheses may be dropped unless needed to resolve ambiguity. <p> The examples also show how logical formulas in T D can be interpreted operationally, like logic programs. In fact, like classical Datalog, Transaction Datalog has a logic-programming foundation <ref> [15, 13, 12, 14] </ref>. However, in classical logic programming, there are no updates, no database transactions (classical or otherwise), and no atomicity, isolation, or rollback. <p> Likewise, there is a generic, constant-preserving transaction in PTIME that sequential T D cannot express. Acknowledgements: Transaction Datalog is a frag-ment of Transaction Logic, which was developed in collaboration with Michael Kifer <ref> [13, 15, 12, 16, 14] </ref>. Thanks go to David Toman and Michael Kifer for their comments on this paper. This work was supported in part by a Research Grant from the Natural Sciences and Engineering Research Council of Canada (NSERC).
Reference: [15] <author> A.J. Bonner and M. Kifer. </author> <title> Concurrency and communication in transaction logic. </title> <booktitle> In Joint Intl. Conference and Symposium on Logic Programming, </booktitle> <pages> pages 142-156, </pages> <address> Bonn, Germany, September 1996. </address> <publisher> MIT Press. </publisher>
Reference-contexts: The comparison includes database update languages [3, 2, 1, 18, 19, 37, 51, 40, 41], languages for expressing intertask dependencies [45, 21, 22, 23, 4, 47, 46], process algebras [38, 30, 36], concurrent dynamic logic [44, 43], and concurrent logic programming <ref> [15] </ref>. In addition, comparisons with logics of time and action can be found in [13, 14], and a comparison with the pi calculus is given in [15]. <p> expressing intertask dependencies [45, 21, 22, 23, 4, 47, 46], process algebras [38, 30, 36], concurrent dynamic logic [44, 43], and concurrent logic programming <ref> [15] </ref>. In addition, comparisons with logics of time and action can be found in [13, 14], and a comparison with the pi calculus is given in [15]. Papers on the logical foundations of T D, a prototype implementation of sequential T D, and the results of benchmark tests are available at the Transaction Logic web page: http://www.cs.toronto.edu/~bonner/transaction-logic.html 2 Overview of Transaction Datalog In Transaction Datalog, programs are represented by logical formulas. <p> The examples also show how logical formulas in T D can be interpreted operationally, like logic programs. In fact, like classical Datalog, Transaction Datalog has a logic-programming foundation <ref> [15, 13, 12, 14] </ref>. However, in classical logic programming, there are no updates, no database transactions (classical or otherwise), and no atomicity, isolation, or rollback. <p> In particular, the database can contain structures and access methods designed for efficient communication. For instance, some relations in the database could be a view of a set of message queues or communication channels, as described in <ref> [15] </ref>. 3 COMPUTATIONAL PROPERTIES 9 Example 2.6 (Nested Transactions) Consider the banking programs of Example 2.2, which transfer money between accounts. In the presence of concurrency, these programs must be modified to ensure that they execute as isolated transactions. <p> Likewise, there is a generic, constant-preserving transaction in PTIME that sequential T D cannot express. Acknowledgements: Transaction Datalog is a frag-ment of Transaction Logic, which was developed in collaboration with Michael Kifer <ref> [13, 15, 12, 16, 14] </ref>. Thanks go to David Toman and Michael Kifer for their comments on this paper. This work was supported in part by a Research Grant from the Natural Sciences and Engineering Research Council of Canada (NSERC).
Reference: [16] <author> A.J. Bonner, M. Kifer, and M. Consens. </author> <title> Database programming in transaction logic. </title> <editor> In A. Ohori C. Beeri and D.E. Shasha, editors, </editor> <booktitle> Proceedings of the International Workshop on Database Programming Languages, Workshops in Computing, </booktitle> <pages> pages 309-337. </pages> <publisher> Springer-Verlag, </publisher> <month> February </month> <year> 1994. </year> <booktitle> Workshop held on Aug 30-Sept 1, 1993, </booktitle> <address> New York City, NY. </address>
Reference-contexts: This idea is developed in <ref> [16, 14] </ref> and implemented in [34]. 2 OVERVIEW OF TRANSACTION DATALOG 6 * ( 1 j 2 j j k ) where k 0 and each i is a goal; or * fi where is a goal; where parentheses may be dropped unless needed to resolve ambiguity. <p> Likewise, there is a generic, constant-preserving transaction in PTIME that sequential T D cannot express. Acknowledgements: Transaction Datalog is a frag-ment of Transaction Logic, which was developed in collaboration with Michael Kifer <ref> [13, 15, 12, 16, 14] </ref>. Thanks go to David Toman and Michael Kifer for their comments on this paper. This work was supported in part by a Research Grant from the Natural Sciences and Engineering Research Council of Canada (NSERC).
Reference: [17] <author> A.J. Bonner, L.T. McCarty, and K. Vadaparty. </author> <title> Expressing Database Queries with Intuitionistic Logic. </title> <booktitle> In North American Conference on Logic Programming, </booktitle> <pages> pages 831-850, </pages> <address> Cleveland, Ohio, October 16-20 1989. </address> <publisher> MIT Press. </publisher>
Reference-contexts: This enormous increase in complexity, from EXPTIME to RE, comes entirely from the interactions between concurrent update programs. In contrast, other database update languages achieve RE-completeness by expanding the data domain during transaction execution <ref> [2, 3, 17] </ref>, or by expanding the database schema [18]. Typically, the proof of RE-completeness involves encoding the tape of a Turing machine in the database. Reading the tape is then a database query, and writing the tape is a database update. <p> We must now show that RE is also a lower bound. To prove that an update language is RE-hard, it is common to use the language to simulate the computations of an arbitrary Turing machine <ref> [18, 3, 2, 17] </ref>. In such simulations, the machine tape is typically encoded in the database. Reading the tape is then a database query, and writing the tape is a database update. <p> To represent machine tapes of arbitrary length in the database, some languages allow the database schema to expand during execution [18], while others allow the data domain to expand <ref> [2, 3, 17] </ref>. In this way, the database can grow to arbitrary size during transaction execution. This section takes a completely different approach. We do not encode machine tapes in the database. Instead, we encode machine tapes as sequential goals (or programs).
Reference: [18] <author> A.K. Chandra and D. Harel. </author> <title> Computable queries for relational databases. </title> <journal> Journal of Computer and System Sciences, </journal> <volume> 21(2) </volume> <pages> 156-178, </pages> <year> 1980. </year>
Reference-contexts: This enormous increase in complexity, from EXPTIME to RE, comes entirely from the interactions between concurrent update programs. In contrast, other database update languages achieve RE-completeness by expanding the data domain during transaction execution [2, 3, 17], or by expanding the database schema <ref> [18] </ref>. Typically, the proof of RE-completeness involves encoding the tape of a Turing machine in the database. Reading the tape is then a database query, and writing the tape is a database update. <p> A detailed comparison of T D with other languages is published in [10], which is available on the Web. The comparison includes database update languages <ref> [3, 2, 1, 18, 19, 37, 51, 40, 41] </ref>, languages for expressing intertask dependencies [45, 21, 22, 23, 4, 47, 46], process algebras [38, 30, 36], concurrent dynamic logic [44, 43], and concurrent logic programming [15]. <p> We must now show that RE is also a lower bound. To prove that an update language is RE-hard, it is common to use the language to simulate the computations of an arbitrary Turing machine <ref> [18, 3, 2, 17] </ref>. In such simulations, the machine tape is typically encoded in the database. Reading the tape is then a database query, and writing the tape is a database update. <p> To represent machine tapes of arbitrary length in the database, some languages allow the database schema to expand during execution <ref> [18] </ref>, while others allow the data domain to expand [2, 3, 17]. In this way, the database can grow to arbitrary size during transaction execution. This section takes a completely different approach. We do not encode machine tapes in the database. <p> To make this statement precise, we need to define what it means to express a database transaction in T D. In database theory, the expressiveness of a language is normally measured by its ability to express queries and transactions that are generic <ref> [18] </ref>. Genericity formalizes the idea that the constants in a database are uninterpreted. Intuitively, a query or transaction is generic if it treats all constants equally, giving special treatment to none. Below, we give a formal definition of "generic transaction" and what it means to express them in Transaction Datalog. <p> The next definition is adapted from [3, 2], which in turn is based on Chandra and Harel's definition of generic query <ref> [18, 19] </ref>. The main differnce between queries and transctions is that a query is a mapping from databases to relations, while a transaction is a binary relation on databases.
Reference: [19] <author> A.K. Chandra and D. Harel. </author> <title> Structure and complexity of relational queries. </title> <journal> Journal of Computer and System Sciences, </journal> <volume> 25(1) </volume> <pages> 99-128, </pages> <year> 1982. </year>
Reference-contexts: A detailed comparison of T D with other languages is published in [10], which is available on the Web. The comparison includes database update languages <ref> [3, 2, 1, 18, 19, 37, 51, 40, 41] </ref>, languages for expressing intertask dependencies [45, 21, 22, 23, 4, 47, 46], process algebras [38, 30, 36], concurrent dynamic logic [44, 43], and concurrent logic programming [15]. <p> This is why the data complexity of safe update languages is bounded above by PSPACE <ref> [19, 3, 2] </ref>, and why that of sequential T D is bounded above by alternating PSPACE. To represent machine tapes of arbitrary length in the database, some languages allow the database schema to expand during execution [18], while others allow the data domain to expand [2, 3, 17]. <p> The next definition is adapted from [3, 2], which in turn is based on Chandra and Harel's definition of generic query <ref> [18, 19] </ref>. The main differnce between queries and transctions is that a query is a mapping from databases to relations, while a transaction is a binary relation on databases.
Reference: [20] <author> A.K. Chandra, D. Kozen, and L.J. Stockmeyer. </author> <title> Alternation. </title> <journal> Journal of ACM, </journal> <volume> 28 </volume> <pages> 114-133, </pages> <year> 1981. </year>
Reference-contexts: The first result is that without concurrency, the data complexity of T D is complete for EXPTIME. This result is interesting in itself, since most safe update languages are complete for PSPACE. The increased complexity of T D comes from its ability to simulate alternating PSPACE machines <ref> [20] </ref>, which in turn comes from its ability to compose transaction programs recursively. The second result is that with concurrency, the data complexity of T D is complete for RE. This enormous increase in complexity, from EXPTIME to RE, comes entirely from the interactions between concurrent update programs. <p> The EXPTIME lower-bound relies on the ability of sequential T D to compose transaction programs sequentially and non-deterministically, and to do so in a mutually recursive fashion. Using this, we show how to simulate the computations of alternating PSPACE machines. The result follows since alternating PSPACE = EXPTIME <ref> [20] </ref>. Additional details are given in Appendix F. To prove the EXPTIME upper-bound, we show that sequential T D has a simpler semantics than concurrent T D, and that this simpler semantics leads to a faster algorithm for determining whether P : D 1 D 2 ` .
Reference: [21] <author> P.K. Chrysanthis and K. Ramamritham. </author> <title> Synthesis of extended transaction models using ACTA. </title> <journal> ACM Transactions on Database Systems, </journal> <volume> 19(3) </volume> <pages> 450-491, </pages> <month> September </month> <year> 1994. </year>
Reference-contexts: A detailed comparison of T D with other languages is published in [10], which is available on the Web. The comparison includes database update languages [3, 2, 1, 18, 19, 37, 51, 40, 41], languages for expressing intertask dependencies <ref> [45, 21, 22, 23, 4, 47, 46] </ref>, process algebras [38, 30, 36], concurrent dynamic logic [44, 43], and concurrent logic programming [15]. In addition, comparisons with logics of time and action can be found in [13, 14], and a comparison with the pi calculus is given in [15].
Reference: [22] <author> P.K. Chrysanthis and K. Ramamrithm. </author> <title> ACTA: The SAGA continues. </title> <booktitle> In [24], chapter 10, </booktitle> <pages> pages 349-397. </pages> <year> 1992. </year>
Reference-contexts: A detailed comparison of T D with other languages is published in [10], which is available on the Web. The comparison includes database update languages [3, 2, 1, 18, 19, 37, 51, 40, 41], languages for expressing intertask dependencies <ref> [45, 21, 22, 23, 4, 47, 46] </ref>, process algebras [38, 30, 36], concurrent dynamic logic [44, 43], and concurrent logic programming [15]. In addition, comparisons with logics of time and action can be found in [13, 14], and a comparison with the pi calculus is given in [15].
Reference: [23] <author> U. Dayal, H. Garcia-Molina, M. Hsu, B. Kao, and M.- C. Shan. </author> <title> Third generation TP monitors: A database challenge. </title> <booktitle> In ACM SIGMOD Conference on Management of Data, </booktitle> <pages> pages 393-397, </pages> <address> Washington, DD, </address> <month> May </month> <year> 1993. </year>
Reference-contexts: A detailed comparison of T D with other languages is published in [10], which is available on the Web. The comparison includes database update languages [3, 2, 1, 18, 19, 37, 51, 40, 41], languages for expressing intertask dependencies <ref> [45, 21, 22, 23, 4, 47, 46] </ref>, process algebras [38, 30, 36], concurrent dynamic logic [44, 43], and concurrent logic programming [15]. In addition, comparisons with logics of time and action can be found in [13, 14], and a comparison with the pi calculus is given in [15].
Reference: [24] <editor> A.K. Elmagarmid, editor. </editor> <title> Database Transaction Models for Advanced Applications. </title> <publisher> Morgan-Kaufmann, </publisher> <address> San Mateo, CA, </address> <year> 1992. </year>
Reference: [25] <author> A.K. Elmagarmid, Y. Leu, W. Litwin, and M. Rusinkiewcz. </author> <title> A multidatabase transaction model for interbase. </title> <booktitle> In Intl. Conference on Very Large Data Bases, </booktitle> <pages> pages 507-518, </pages> <address> Brisbane, Australia, </address> <month> August 13--16 </month> <year> 1990. </year>
Reference: [26] <author> H. Garcia-Molina and K. Salem. Sagas. </author> <booktitle> In Intl. Conference on Very Large Data Bases, </booktitle> <pages> pages 249-259, </pages> <month> May </month> <year> 1987. </year>
Reference: [27] <author> D. Georgakopoulos, M. Hornick, and A. Sheth. </author> <title> An overview of workflow management: From process modeling to infrastructure for automation. </title> <journal> Journal on Distributed and Parallel Database Systems, </journal> <volume> 3(2) </volume> <pages> 119-153, </pages> <month> April </month> <year> 1995. </year>
Reference: [28] <author> J. Gray. </author> <title> The transaction concept: Virtues and limitations. </title> <booktitle> In Intl. Conference on Very Large Data Bases, </booktitle> <pages> pages 144-154, </pages> <address> Cannes, France, </address> <month> September </month> <year> 1981. </year>
Reference: [29] <author> J. Gray and A. Reuter. </author> <title> Transaction Processing: Concepts and Techniques. </title> <publisher> Morgan Kaufmann, </publisher> <address> San Mateo, CA, </address> <year> 1993. </year>
Reference-contexts: Unfortunately, the term "transaction" is heavily overloaded in the database literature, and has a variety of relationships to the term "transaction program." In transaction processing, a transaction is a particular execution of a transaction program <ref> [5, 29] </ref>; in application programming, it is often the transaction program itself; and in data modeling, it is the effects of a transaction program on the database (i:e:, a mapping from databases to databases) [3, 2].
Reference: [30] <author> C.A.R. Hoare. </author> <title> Communicating Sequential Processes. </title> <publisher> Prentice Hall, </publisher> <address> Englewood Cliffs, NJ, </address> <year> 1985. </year>
Reference-contexts: A detailed comparison of T D with other languages is published in [10], which is available on the Web. The comparison includes database update languages [3, 2, 1, 18, 19, 37, 51, 40, 41], languages for expressing intertask dependencies [45, 21, 22, 23, 4, 47, 46], process algebras <ref> [38, 30, 36] </ref>, concurrent dynamic logic [44, 43], and concurrent logic programming [15]. In addition, comparisons with logics of time and action can be found in [13, 14], and a comparison with the pi calculus is given in [15].
Reference: [31] <author> J.E. Hopcroft and J.D. Ullman. </author> <title> Introduction to Automata Theory, Languages and Computation. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, MA, </address> <year> 1979. </year>
Reference: [32] <author> M. Hsu, Ed. </author> <title> Special issue on workflow and extended transaction systems. </title> <journal> Bulletin of the Technical Committee on Data Engineering (IEEE Computer Society), </journal> <volume> 16(2), </volume> <month> June </month> <year> 1993. </year>
Reference: [33] <author> M. Hsu, </author> <title> Ed. </title> <journal> Special issue on workflow systems. Bulletin of the Technical Committee on Data Engineering (IEEE Computer Society), </journal> <volume> 18(1), </volume> <month> March </month> <year> 1995. </year>
Reference-contexts: In fact, cooperation and coordination are sometimes the raison d'^etre of non-classical transactions. A workflow, for instance, is a coordinated execution of many activities <ref> [6, 33] </ref>. Characterizing the complexity of non-classical transactions thus involves characterizing the complexity of their interactions. In this paper, we take a simple approach to the problem: given a set of concurrent programs, we measure the complexity of their interactions by observing its effect on the database.
Reference: [34] <author> Samuel Y.K. Hung. </author> <title> Implementation and Performance of Transaction Logic in Prolog. </title> <type> Master's thesis, </type> <institution> Department of Computer Science, University of Toronto, </institution> <year> 1996. </year> <note> http://www.cs.toronto.edu/ ~bonner/transaction-logic.html. </note>
Reference-contexts: This idea is developed in [16, 14] and implemented in <ref> [34] </ref>. 2 OVERVIEW OF TRANSACTION DATALOG 6 * ( 1 j 2 j j k ) where k 0 and each i is a goal; or * fi where is a goal; where parentheses may be dropped unless needed to resolve ambiguity.
Reference: [35] <author> Setrag Khoshafian and Marek Buckiewicz. </author> <title> Introduction to Groupware, Workflow, and Workgroup Computing. </title> <publisher> John Wiley & Sons, Inc., </publisher> <year> 1995. </year>
Reference: [36] <author> P.E. Lauer and R.H. Campbell. </author> <title> Formal semantics of a class of high-level primitives for co-ordinating concurrent processes. </title> <journal> Acta Informatica, </journal> <volume> 5 </volume> <pages> 297-332, </pages> <year> 1975. </year>
Reference-contexts: A detailed comparison of T D with other languages is published in [10], which is available on the Web. The comparison includes database update languages [3, 2, 1, 18, 19, 37, 51, 40, 41], languages for expressing intertask dependencies [45, 21, 22, 23, 4, 47, 46], process algebras <ref> [38, 30, 36] </ref>, concurrent dynamic logic [44, 43], and concurrent logic programming [15]. In addition, comparisons with logics of time and action can be found in [13, 14], and a comparison with the pi calculus is given in [15].
Reference: [37] <author> S. Manchanda and D.S. Warren. </author> <title> A logic-based language for database updates. </title> <editor> In J. Minker, editor, </editor> <booktitle> Foundations of Deductive Databases and Logic Programming, </booktitle> <pages> pages 363-394. </pages> <publisher> Morgan-Kaufmann, </publisher> <address> Los Altos, CA, </address> <year> 1988. </year>
Reference-contexts: A detailed comparison of T D with other languages is published in [10], which is available on the Web. The comparison includes database update languages <ref> [3, 2, 1, 18, 19, 37, 51, 40, 41] </ref>, languages for expressing intertask dependencies [45, 21, 22, 23, 4, 47, 46], process algebras [38, 30, 36], concurrent dynamic logic [44, 43], and concurrent logic programming [15].
Reference: [38] <author> R. Milner. </author> <title> Communication and Concurrency. </title> <publisher> Prentice Hall, </publisher> <year> 1989. </year>
Reference-contexts: A detailed comparison of T D with other languages is published in [10], which is available on the Web. The comparison includes database update languages [3, 2, 1, 18, 19, 37, 51, 40, 41], languages for expressing intertask dependencies [45, 21, 22, 23, 4, 47, 46], process algebras <ref> [38, 30, 36] </ref>, concurrent dynamic logic [44, 43], and concurrent logic programming [15]. In addition, comparisons with logics of time and action can be found in [13, 14], and a comparison with the pi calculus is given in [15].
Reference: [39] <author> J. E. B. Moss. </author> <title> Nested Transactions: An Approach to Reliable Distributed Computing. </title> <booktitle> Series in Information Systems. </booktitle> <publisher> MIT Press, </publisher> <address> Cambridge, MA, </address> <year> 1985. </year>
Reference: [40] <author> S. Naqvi and R. Krishnamurthy. </author> <title> Database updates in logic programming. </title> <booktitle> In ACM Symposium on Principles of Database Systems, </booktitle> <pages> pages 251-262, </pages> <address> New York, </address> <month> March </month> <year> 1988. </year> <note> ACM. </note>
Reference-contexts: A detailed comparison of T D with other languages is published in [10], which is available on the Web. The comparison includes database update languages <ref> [3, 2, 1, 18, 19, 37, 51, 40, 41] </ref>, languages for expressing intertask dependencies [45, 21, 22, 23, 4, 47, 46], process algebras [38, 30, 36], concurrent dynamic logic [44, 43], and concurrent logic programming [15].
Reference: [41] <author> S. Naqvi and S. Tsur. </author> <title> A Logical Language for Data and Knowledge Bases. </title> <publisher> Computer Science Press, </publisher> <address> Rockville, MD, </address> <year> 1989. </year>
Reference-contexts: A detailed comparison of T D with other languages is published in [10], which is available on the Web. The comparison includes database update languages <ref> [3, 2, 1, 18, 19, 37, 51, 40, 41] </ref>, languages for expressing intertask dependencies [45, 21, 22, 23, 4, 47, 46], process algebras [38, 30, 36], concurrent dynamic logic [44, 43], and concurrent logic programming [15].
Reference: [42] <author> M. H. Nodine, S. Ramaswamy, and S. B. Zdonik. </author> <title> A cooperative transaction model for design databases. </title> <booktitle> In [24], chapter 3, </booktitle> <pages> pages 53-85. </pages> <year> 1992. </year>
Reference: [43] <author> D. Peleg. </author> <title> Communication in concurrent dynamic logic. </title> <journal> Journal of Computer and System Sciences, </journal> <volume> 35(1) </volume> <pages> 23-58, </pages> <month> August </month> <year> 1987. </year>
Reference-contexts: The comparison includes database update languages [3, 2, 1, 18, 19, 37, 51, 40, 41], languages for expressing intertask dependencies [45, 21, 22, 23, 4, 47, 46], process algebras [38, 30, 36], concurrent dynamic logic <ref> [44, 43] </ref>, and concurrent logic programming [15]. In addition, comparisons with logics of time and action can be found in [13, 14], and a comparison with the pi calculus is given in [15].
Reference: [44] <author> D. </author> <title> Peleg. </title> <journal> Concurrent-dynamic logic. Journal of ACM, </journal> <volume> 34(2):450 - 479, </volume> <month> March </month> <year> 1987. </year>
Reference-contexts: The comparison includes database update languages [3, 2, 1, 18, 19, 37, 51, 40, 41], languages for expressing intertask dependencies [45, 21, 22, 23, 4, 47, 46], process algebras [38, 30, 36], concurrent dynamic logic <ref> [44, 43] </ref>, and concurrent logic programming [15]. In addition, comparisons with logics of time and action can be found in [13, 14], and a comparison with the pi calculus is given in [15].
Reference: [45] <author> M. Rusinkiewicz and A. Sheth. </author> <title> Specification and execution of transactional workflows. </title> <editor> In W. Kim, editor, </editor> <title> Modern Database Systems: The Object Model, Interoperability, and Beyond. </title> <publisher> Addison-Wesley, </publisher> <year> 1994. </year>
Reference-contexts: A detailed comparison of T D with other languages is published in [10], which is available on the Web. The comparison includes database update languages [3, 2, 1, 18, 19, 37, 51, 40, 41], languages for expressing intertask dependencies <ref> [45, 21, 22, 23, 4, 47, 46] </ref>, process algebras [38, 30, 36], concurrent dynamic logic [44, 43], and concurrent logic programming [15]. In addition, comparisons with logics of time and action can be found in [13, 14], and a comparison with the pi calculus is given in [15].
Reference: [46] <author> M.P. Singh. </author> <title> Semantical considerations on workflows: An algebra for intertask dependencies. </title> <booktitle> In Proceedings of the International Workshop on Database Programming Languages, </booktitle> <address> Gubbio, Umbria, Italy, </address> <month> September 6-8 </month> <year> 1995. </year>
Reference-contexts: A detailed comparison of T D with other languages is published in [10], which is available on the Web. The comparison includes database update languages [3, 2, 1, 18, 19, 37, 51, 40, 41], languages for expressing intertask dependencies <ref> [45, 21, 22, 23, 4, 47, 46] </ref>, process algebras [38, 30, 36], concurrent dynamic logic [44, 43], and concurrent logic programming [15]. In addition, comparisons with logics of time and action can be found in [13, 14], and a comparison with the pi calculus is given in [15].
Reference: [47] <author> M.P. Singh. </author> <title> Synthesizing distributed constrained events from transactional workflow specifications. </title> <booktitle> In Proceedings of 12-th IEEE Intl. Conference on Data Engineering, </booktitle> <pages> pages 616-623, </pages> <address> New Orleans, LA, </address> <month> Febru-ary </month> <year> 1996. </year>
Reference-contexts: A detailed comparison of T D with other languages is published in [10], which is available on the Web. The comparison includes database update languages [3, 2, 1, 18, 19, 37, 51, 40, 41], languages for expressing intertask dependencies <ref> [45, 21, 22, 23, 4, 47, 46] </ref>, process algebras [38, 30, 36], concurrent dynamic logic [44, 43], and concurrent logic programming [15]. In addition, comparisons with logics of time and action can be found in [13, 14], and a comparison with the pi calculus is given in [15].
Reference: [48] <author> L. Stein, S. Rozen, and N. Goodman. </author> <title> Managing laboratory workflow with LabBase. </title> <booktitle> In Proceedings of the 1994 Conference on Computers in Medicine (CompMed94). </booktitle> <publisher> World Scientific Publishing Company, </publisher> <year> 1995. </year> <note> ftp://genome.wi.mit.edu/pub/papers/Y1995/ workflow.ps.Z. </note>
Reference: [49] <author> Transarc-Encina. </author> <title> Encina Transactional Processing System: Transactional-C Programmers Guide and Reference, </title> <institution> TP-00-D347. Transarc Corp., Pittsburg, </institution> <address> PA, </address> <year> 1991. </year>
Reference: [50] <author> H. Wachter and A. Reuter. </author> <title> The ConTract model. </title> <booktitle> In [24], chapter 7, </booktitle> <pages> pages 220-263. </pages> <year> 1992. </year>
Reference: [51] <author> D.S. Warren. </author> <title> Database Updates in Pure Prolog. </title> <booktitle> In Proceedings of the International Conference on Fifth Generation Computer Systems, </booktitle> <pages> pages 244-253, </pages> <year> 1984. </year>
Reference-contexts: A detailed comparison of T D with other languages is published in [10], which is available on the Web. The comparison includes database update languages <ref> [3, 2, 1, 18, 19, 37, 51, 40, 41] </ref>, languages for expressing intertask dependencies [45, 21, 22, 23, 4, 47, 46], process algebras [38, 30, 36], concurrent dynamic logic [44, 43], and concurrent logic programming [15].
Reference: [52] <author> G. Weikum and H.-J. Schek. </author> <title> Concepts and applications of multilevel transactions and open nested transactions. </title> <booktitle> In [24], chapter 13, </booktitle> <pages> pages 515-553. </pages> <year> 1992. </year>
References-found: 52

