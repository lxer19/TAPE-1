URL: ftp://mancos.cs.utah.edu/papers/veripc.ps.gz
Refering-URL: http://www.cs.utah.edu/~tullmann/flux/publications.html
Root-URL: 
Email: ftullmann,sjt,mcq,lepreau,chitturi,gbackg@cs.utah.edu  
Title: Formal Methods: A Practical Tool for OS Implementors  
Author: Patrick Tullmann Jeff Turner John McCorquodale Jay Lepreau Ajay Chitturi Godmar Back 
Note: This research was supportedin part by the Defense AdvancedResearch Projects Agency, monitored by the Department of the Army under contract number DABT63-94-C-0058, and Rome Laboratory, Air Force Material Command, USAF, under agreement number F30602-96-2-0269. The U.S. Government is authorized to reproduce and distribute reprints for Governmental purposes notwithstanding any copyright annotation hereon. U.S. Department of Defense. Copyright 1997 IEEE. Personal use of this material is permitted. However, permission to reprint/republish this material for advertising or promotional purposes or for creating new collective works for resale or redistribution to servers or lists, or to reuse any copyrighted component of this work in other works must be obtained from the IEEE.  
Web: http://www.cs.utah.edu/projects/flux/  
Address: Salt Lake City, UT 84112  
Affiliation: Department of Computer Science University of Utah  
Abstract: The formal methods community has long known about the need to formally analyze concurrent software, but the OS community has been slow to adopt such methods. The foremost reasons for this are the cultural and knowledge gaps between formalists and OS hackers, fostered by three beliefs: inaccessibility of the tools, the disabling gap between the validated model and actual implementation, and the intractable size of operating systems. In this paper, we show these beliefs to be untrue for appropriately structured operating systems. We applied formal methods to verify properties of the implementation of the Fluke microkernel's IPC subsystem, a major component of the kernel. In particular, we have verified, in many scenarios, certain liveness properties and lack of deadlock, with results that apply to both SMP and uniprocessor environments. The SPIN model checker provided an exhaustive concurrency analysis of the IPC subsystem, unattainable through traditional OS testing methods. SPIN is easily accessible to programmers inexperienced with formal methods. We present our results as a starting point for a more comprehensive inclusion of formal methods in practical OS development. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> A. Basu, M. Hayden, G. Morrisett, and T. v. Eicken. </author> <title> A language-based approach to protocol construction. </title> <booktitle> In Proc. of the ACM SIGPLAN Workshop on Domain Specific Languages (WDSL), </booktitle> <address> Paris, France, </address> <month> Jan. </month> <year> 1997. </year>
Reference-contexts: The decision about what to translate and what to abstract still needs to be made. Perhaps another language could generate both the model and the implementation, as was done in the Teapot work [4] on software cache coherence, or very recently with Promela++ <ref> [1] </ref>. This would also solve the maintenance problem mentioned above. Second, the structure of the kernel's implementation was helpful in generating the PROMELA models, just as this structure would help if the kernel were ported to a new processor architecture.
Reference: [2] <author> B. Bevier and L. Smith. </author> <title> A mathematical model of the Mach kernel. </title> <type> Computational Logic Technical Report CLI Technical Report 102, </type> <institution> Computational Logic, Inc., </institution> <month> Sept. </month> <year> 1994. </year>
Reference-contexts: In a more tightly focused effort, the Plan9 developers successfully used SPIN to debug a synchronization protocol [17]. A great deal of work has been done on the specification and analysis of the Mach kernel. Computational Logic Inc. developed a mathematical model of the Mach 3.0 microker-nel <ref> [2] </ref>. This work focuses on a model of the Mach API, as opposed to our focus on implementation details. CLI and OSF [14] are also using the Mach specifications to generate conformance tests for the MK++ microkernel.
Reference: [3] <author> T. Cattel. </author> <title> Modelling and verification of a multiprocessor re-altime OS kernel. </title> <booktitle> In Proceedings of the Seventh International Conference on Formal Description Techniques, </booktitle> <month> Oct. </month> <year> 1994. </year>
Reference-contexts: requirements of model verification by bit hashing the states without collision detection; unlike partial-order reductions, this technique may miss on the order of 1% of the total state space. 4 Other operating system verification efforts We are aware of two previous efforts to verify kernel subsystems with SPIN, for Harmony <ref> [3] </ref>, a portable real-time multitasking multiprocessor operating system; and for the RUBIS microkernel [7]. Although the modeled subsystems were less complex than ours, both of these results bolster our position that formal methods are worth applying to operating systems.
Reference: [4] <author> S. Chandra, B. Richards, and J. Larus. Teapot: </author> <title> Language support for writing memory coherence protocols. </title> <booktitle> In SIG-PLAN Conference on Programming Language Design and Implementation (PLDI'96), </booktitle> <month> May </month> <year> 1996. </year>
Reference-contexts: The decision about what to translate and what to abstract still needs to be made. Perhaps another language could generate both the model and the implementation, as was done in the Teapot work <ref> [4] </ref> on software cache coherence, or very recently with Promela++ [1]. This would also solve the maintenance problem mentioned above. Second, the structure of the kernel's implementation was helpful in generating the PROMELA models, just as this structure would help if the kernel were ported to a new processor architecture.
Reference: [5] <author> C. Courcoubetis, M. Vardi, P. Wolper, and M. Yannakakis. </author> <title> Memory efficient algorithms for the verification of temporal properties. </title> <booktitle> Formal Methods in System Design, </booktitle> <volume> 1 </volume> <pages> 275-288, </pages> <year> 1992. </year>
Reference-contexts: SPIN does incorporate special features to attack the state-explosion problem. Partial-order reduction [16] reduces interleaving by grouping consecutive statements that have no global effects. It fully preserves accuracy while reducing the state space and run time. Bit state hashing <ref> [5] </ref>, or su 2 pertracing, dramatically reduces the memory requirements of model verification by bit hashing the states without collision detection; unlike partial-order reductions, this technique may miss on the order of 1% of the total state space. 4 Other operating system verification efforts We are aware of two previous efforts
Reference: [6] <author> E. W. Dijkstra. </author> <title> Guarded commands, non-determinacy and formal derivation of progams. </title> <journal> CACM, </journal> <volume> 18(8) </volume> <pages> 453-457, </pages> <month> Aug. </month> <year> 1975. </year>
Reference-contexts: 1 Introduction Operating system implementations are at once concurrent, non-deterministic, and usually optimized for speed over safety. Nevertheless, we demand a high degree of reliability from them. Formal design and analysis were developed for exactly these conditions <ref> [6, 10, 12] </ref>. Although hardware designers are successfully adopting formal methods into their development cycles [20], most OS programmers are probably not aware of these methods due to the gaps between cultures and publication venues. <p> SPIN In SPIN [11], a popular model checker developed at Bell Labs, formal models are written in PROMELA which is loosely based on Dijkstra's guarded command language notation <ref> [6] </ref> and Hoare's CSP [10]. For this paper the most important facets of PROMELA are that it looks and acts much like a standard procedural programming language (although an impoverished one), and that it implicitly supports blocking a thread. SPIN does incorporate special features to attack the state-explosion problem.
Reference: [7] <author> G. Duval and J. Julliand. </author> <title> Modeling and verification of the RUBIS -Kernel with SPIN. </title> <booktitle> In Proceedings of the First SPIN Workshop, </booktitle> <month> Oct. </month> <year> 1995. </year>
Reference-contexts: partial-order reductions, this technique may miss on the order of 1% of the total state space. 4 Other operating system verification efforts We are aware of two previous efforts to verify kernel subsystems with SPIN, for Harmony [3], a portable real-time multitasking multiprocessor operating system; and for the RUBIS microkernel <ref> [7] </ref>. Although the modeled subsystems were less complex than ours, both of these results bolster our position that formal methods are worth applying to operating systems. Additionally, considering the many recent improvements made to SPIN the conclusions drawn by the former might be stronger today.
Reference: [8] <author> B. Ford, M. Hibler, </author> <title> and Flux Project Members. Fluke: Flexible -kernel Environment (draft documents). </title> <institution> University of Utah. </institution> <note> Postscript and HTML available under http://- www.cs.utah.edu/projects/flux/fluke/html/, 1996. </note>
Reference-contexts: Based on the experiment reported in this paper, we believe that in many instances these are misperceptions. Before we proceed into the discussion of formal methods themselves, we provide a short description of the motivating examplethe Fluke kernel's IPC subsystem <ref> [8, 9] </ref>. Then we discuss similar efforts to bring verification and operating systems together. Section 5 describes the method we used to validate Fluke's IPC implementation. <p> Then we discuss similar efforts to bring verification and operating systems together. Section 5 describes the method we used to validate Fluke's IPC implementation. Then we present some specific results, some open issues, and our conclusions. 2 Interprocess communication in Fluke Fluke <ref> [8] </ref> is a small microkernel in the vein of L4 [13], providing interprocess communication (IPC), memory mapping (but not virtual memory), and synchronization primitives; it was designed to run on both uniprocessors and multiprocessors.
Reference: [9] <author> B. Ford, M. Hibler, J. Lepreau, P. Tullmann, G. Back, and S. Clawson. </author> <title> Microkernels meet recursive virtual machines. </title> <booktitle> In Proc. of the Second Symp. on Operating Systems Design and Implementation, </booktitle> <pages> pages 137-151, </pages> <address> Seattle, WA, Oct. 1996. </address> <publisher> USENIX Assoc. </publisher>
Reference-contexts: Based on the experiment reported in this paper, we believe that in many instances these are misperceptions. Before we proceed into the discussion of formal methods themselves, we provide a short description of the motivating examplethe Fluke kernel's IPC subsystem <ref> [8, 9] </ref>. Then we discuss similar efforts to bring verification and operating systems together. Section 5 describes the method we used to validate Fluke's IPC implementation. <p> Fluke's support for sophisticated resource management and relatively efficient systems is dependent on the reliability and performance of its IPC facilities <ref> [9] </ref>, which has a number of interesting and subtle aspects. A reliable IPC link established between client and server threads in Fluke is a connection-based, reversible, half-duplex stream.
Reference: [10] <author> C. A. R. Hoare. </author> <title> Communicating sequential processes. </title> <journal> CACM, </journal> <volume> 21(8) </volume> <pages> 666-677, </pages> <month> Aug. </month> <year> 1978. </year>
Reference-contexts: 1 Introduction Operating system implementations are at once concurrent, non-deterministic, and usually optimized for speed over safety. Nevertheless, we demand a high degree of reliability from them. Formal design and analysis were developed for exactly these conditions <ref> [6, 10, 12] </ref>. Although hardware designers are successfully adopting formal methods into their development cycles [20], most OS programmers are probably not aware of these methods due to the gaps between cultures and publication venues. <p> SPIN In SPIN [11], a popular model checker developed at Bell Labs, formal models are written in PROMELA which is loosely based on Dijkstra's guarded command language notation [6] and Hoare's CSP <ref> [10] </ref>. For this paper the most important facets of PROMELA are that it looks and acts much like a standard procedural programming language (although an impoverished one), and that it implicitly supports blocking a thread. SPIN does incorporate special features to attack the state-explosion problem.
Reference: [11] <author> G. Holzmann. </author> <title> Design and Validation of Computer Protocols. </title> <publisher> Prentice-Hall, </publisher> <year> 1991. </year>
Reference-contexts: It is our belief that the same results and success can be found by applying formal methods to large scale software systemsin particular operating systems. SPIN In SPIN <ref> [11] </ref>, a popular model checker developed at Bell Labs, formal models are written in PROMELA which is loosely based on Dijkstra's guarded command language notation [6] and Hoare's CSP [10].
Reference: [12] <author> J. M. K. Mani Chandi. </author> <title> Parallel Program Design: A Foundation. </title> <publisher> Addison-Wesley, </publisher> <year> 1989. </year>
Reference-contexts: 1 Introduction Operating system implementations are at once concurrent, non-deterministic, and usually optimized for speed over safety. Nevertheless, we demand a high degree of reliability from them. Formal design and analysis were developed for exactly these conditions <ref> [6, 10, 12] </ref>. Although hardware designers are successfully adopting formal methods into their development cycles [20], most OS programmers are probably not aware of these methods due to the gaps between cultures and publication venues. <p> The specifications are used to identify legal state predicates which can be inserted into the kernel as assertions. This project is similar to ours in its focus on making formal methods practical for software engineers. Unity <ref> [12] </ref> is a concurrency formalism used to specify and verify concurrent programs. It was used to specify requirements for the resource allocation portion of Bull's GCOS I/O subsystem and to develop and verify an abstract algorithm based on the specifications [18].
Reference: [13] <author> J. Liedtke. </author> <title> On micro-kernel construction. </title> <booktitle> In Proc. of the 15th ACM Symp. on Operating Systems Principles, </booktitle> <pages> pages 237-250, </pages> <address> Copper Mountain, CO, </address> <month> Dec. </month> <year> 1995. </year>
Reference-contexts: Section 5 describes the method we used to validate Fluke's IPC implementation. Then we present some specific results, some open issues, and our conclusions. 2 Interprocess communication in Fluke Fluke [8] is a small microkernel in the vein of L4 <ref> [13] </ref>, providing interprocess communication (IPC), memory mapping (but not virtual memory), and synchronization primitives; it was designed to run on both uniprocessors and multiprocessors. Fluke had been running for about six months, though only on uniprocessors, when this modeling effort be 1 gan.
Reference: [14] <institution> Open Group Research Institute and Computational Logic, Inc. OSF formal methods project. </institution> <address> http://www.osf.org/- formalmethods/, </address> <year> 1996. </year>
Reference-contexts: Computational Logic Inc. developed a mathematical model of the Mach 3.0 microker-nel [2]. This work focuses on a model of the Mach API, as opposed to our focus on implementation details. CLI and OSF <ref> [14] </ref> are also using the Mach specifications to generate conformance tests for the MK++ microkernel. The specifications are used to identify legal state predicates which can be inserted into the kernel as assertions. This project is similar to ours in its focus on making formal methods practical for software engineers.
Reference: [15] <author> S. Owre, J. Rushby, and N. Shankar. PVS: </author> <title> A prototype verification system. </title> <editor> In D. Kapur, editor, </editor> <booktitle> 11th International Conference on Automated Deduction (CADE), volume 607 of Lecture Notes in Artificial Intelligence, </booktitle> <pages> pages 748-752, </pages> <address> Saratoga Springs, NY, June 1992. </address> <publisher> Springer-Verlag. </publisher>
Reference-contexts: Simply maintaining an indication that data was sent is sufficient; the actual content of the data is not relevant. State of the art theorem provers, for example the popular PVS system <ref> [15] </ref>, still require substantial skilled human intervention to guide the prover through nearly all non-trivial proofs. By contrast, our experience demonstrates that model checking is accessible to relatively naive users. Additionally, model checkers provide more effective reports when errors are encounteredgenerally a full trace from the beginning of execution.
Reference: [16] <author> D. Peled. </author> <title> Combining partial order reductions with on-the-fly model-checking. </title> <booktitle> Formal Methods in Systems Design, </booktitle> <volume> 8 </volume> <pages> 39-64, </pages> <year> 1996. </year>
Reference-contexts: For this paper the most important facets of PROMELA are that it looks and acts much like a standard procedural programming language (although an impoverished one), and that it implicitly supports blocking a thread. SPIN does incorporate special features to attack the state-explosion problem. Partial-order reduction <ref> [16] </ref> reduces interleaving by grouping consecutive statements that have no global effects. It fully preserves accuracy while reducing the state space and run time.
Reference: [17] <author> R. Pike, D. Pressoto, K. Thompson, and G. Holzmann. </author> <title> Process sleep and wakeup on shared-memory multiprocessors. </title> <booktitle> In Proc. of the Spring 1991 EurOpen Conference, </booktitle> <pages> pages 161-166, </pages> <month> May </month> <year> 1991. </year>
Reference-contexts: However, they were published in formal methods venues obscure to the mainstream OS community, limiting their impact. In a more tightly focused effort, the Plan9 developers successfully used SPIN to debug a synchronization protocol <ref> [17] </ref>. A great deal of work has been done on the specification and analysis of the Mach kernel. Computational Logic Inc. developed a mathematical model of the Mach 3.0 microker-nel [2]. This work focuses on a model of the Mach API, as opposed to our focus on implementation details.
Reference: [18] <author> M. G. Staskauskas. </author> <title> Formal derivation of concurrent programs: An example from industry. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> SE-19(5):503-528, </volume> <month> May </month> <year> 1993. </year>
Reference-contexts: Unity [12] is a concurrency formalism used to specify and verify concurrent programs. It was used to specify requirements for the resource allocation portion of Bull's GCOS I/O subsystem and to develop and verify an abstract algorithm based on the specifications <ref> [18] </ref>. This algorithm was used as the basis for the implementation of the I/O subsystem.
Reference: [19] <author> P. Tullmann, J. Lepreau, B. Ford, and M. Hibler. </author> <title> User-level checkpointing through exportable kernel state. </title> <booktitle> In Proc. Fifth International Workshop on Object Orientation in Operating Systems, </booktitle> <pages> pages 85-88, </pages> <address> Seattle, WA, </address> <month> Oct. </month> <year> 1996. </year> <note> IEEE. </note>
Reference-contexts: Client and server directly manipulate each other's state, and may block waiting for the other. Additionally, as a fully reliable protocol, both sides of the connection must remain consistent. The factor which most complicates the implementation is the interruptibility of Fluke's reliable IPC <ref> [19] </ref>. Internally, threads can post cancel operations to other threads. When the target thread handles a cancel it must cleanly backtrack, undoing part or all of the system call it is performing; analogous to a processor's handling of precise exceptions.
Reference: [20] <author> L. Yang, D. Gao, J. Mostoufi, R. Joshi, and P. Lowenstein. </author> <title> System design methodology of UltraSPARC-1. </title> <booktitle> In Proceedings of the Thirty-Second Design Automation Conference, </booktitle> <pages> pages 7-12, </pages> <address> San Francisco, CA, </address> <month> June </month> <year> 1995. </year> <month> 6 </month>
Reference-contexts: Nevertheless, we demand a high degree of reliability from them. Formal design and analysis were developed for exactly these conditions [6, 10, 12]. Although hardware designers are successfully adopting formal methods into their development cycles <ref> [20] </ref>, most OS programmers are probably not aware of these methods due to the gaps between cultures and publication venues. <p> Formal methods research has made major advances in the last decade. In particular, advances in model checking, especially with the state space explosion problem, have made it a practical tool; it is finding increasing use in the development of complex hardware systems, for example the Ul-traSPARC processor <ref> [20] </ref>. It is our belief that the same results and success can be found by applying formal methods to large scale software systemsin particular operating systems.
References-found: 20

