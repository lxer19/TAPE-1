URL: http://www.cs.cornell.edu/Info/Projects/Bernoulli/papers/pldi94.ps
Refering-URL: http://www.cs.cornell.edu/Info/Projects/Bernoulli/
Root-URL: http://www.cs.cornell.edu
Email: rjohnson@cs.cornell.edu pearson@cs.cornell.edu pingali@cs.cornell.edu  
Title: The Program Structure Tree: Computing Control Regions in Linear Time  
Author: Richard Johnson David Pearson Keshav Pingali 
Address: Ithaca, NY 14853  
Affiliation: Department of Computer Science Cornell University,  
Abstract: In this paper, we describe the program structure tree (PST), a hierarchical representation of program structure based on single entry single exit (SESE) regions of the control flow graph. We give a linear-time algorithm for finding SESE regions and for building the PST of arbitrary control flow graphs (including irreducible ones). Next, we establish a connection between SESE regions and control dependence equivalence classes, and show how to use the algorithm to find control regions in linear time. Finally, we discuss some applications of the PST. Many control flow algorithms, such as construction of Static Single Assignment form, can be speeded up by applying the algorithms in a divide-and-conquer style to each SESE region on its own. The PST is also used to speed up data flow analysis by exploiting `sparsity'. Experimental results from the Perfect Club and SPEC89 benchmarks confirm that the PST approach finds and exploits program structure. 
Abstract-found: 1
Intro-found: 1
Reference: [AC76] <author> F. E. Allen and J. Cocke. </author> <title> A program data flow analysis procedure. </title> <journal> Communications of the ACM, </journal> <volume> 19(3) </volume> <pages> 137-147, </pages> <month> March </month> <year> 1976. </year>
Reference-contexts: In the second phase, global information is propagated to increasingly smaller regions. The classic approach to elimination algorithms uses an interval decomposition of the program <ref> [AC76] </ref>.
Reference: [Bal92] <author> Thomas Ball. </author> <title> What's in a region? -or- computing control dependence regions in linear time and space. </title> <type> Technical Report 1108, </type> <institution> University of Wisconsin - Madison, Computer Sciences Department, </institution> <month> September </month> <year> 1992. </year> <note> To appear in LOPLAS. </note>
Reference-contexts: Two nodes are said to be in the same control region if they have the same set of control dependences [FOW87]. Previous algorithms for this problem are either restricted to reducible flow graphs <ref> [Bal92] </ref> or have O (EN ) complexity [CFS90]. Control region information is useful for problems such as instruction scheduling for pipelined machines [GS87]; therefore, our linear-time algorithm for region determination is of wide interest. The PST is a tool which can enhance the performance of many program analysis algorithms. <p> In the worst-case, the algorithm performs O (N ) work for each of O (E) control dependences. The problem with this approach is that control dependence equivalence is defined in terms of the control dependence relation, which has O (EN ) size in the worst case. Ball <ref> [Bal92] </ref> has recognized the need to characterize control dependence equivalences without using control dependence and has developed a linear-time algorithm for computing control dependence equivalences. However, his algorithm works only for reducible graphs and requires computation of both dominators and postdominators.
Reference: [BJP91] <author> Micah Beck, Richard Johnson, and Keshav Pingali. </author> <title> From control flow to dataflow. </title> <journal> Journal of Parallel and Distributed Computing, </journal> <volume> 12 </volume> <pages> 118-129, </pages> <year> 1991. </year>
Reference-contexts: The PST is also useful in generating code for dataflow machines from programs in a language like FORTRAN or C since it exposes SESE regions which dataflow edges can potentially bypass <ref> [BJP91, BMO90] </ref>. There is an enormous body of work on elimination and iteration algorithms, and we refer the reader to surveys by Ryder and Paull [RP86], and by Kennedy [Ken81]. Tarjan and Valdes use a hierarchical representation of SESE regions of a different kind to do elimination [Val78, TV80].
Reference: [BMO90] <author> Robert A. Ballance, Arthur B. Maccabe, and Karl J. Ot-tenstein. </author> <title> The Program Dependence Web: A representation supporting control-, data-, and demand-driven interpretation of imperative languages. </title> <booktitle> In Proceedings of the SIGPLAN '90 Conferenceon ProgrammingLan-guage Design and Implementation, </booktitle> <pages> pages 257-271, </pages> <address> White Plains, New York, </address> <month> June 20-22, </month> <year> 1990. </year>
Reference-contexts: The PST is also useful in generating code for dataflow machines from programs in a language like FORTRAN or C since it exposes SESE regions which dataflow edges can potentially bypass <ref> [BJP91, BMO90] </ref>. There is an enormous body of work on elimination and iteration algorithms, and we refer the reader to surveys by Ryder and Paull [RP86], and by Kennedy [Ken81]. Tarjan and Valdes use a hierarchical representation of SESE regions of a different kind to do elimination [Val78, TV80].
Reference: [CCF91] <author> Jong-Deok Choi, Ron Cytron, and Jeanne Ferrante. </author> <title> Automatic construction of sparse data flow evaluation graphs. </title> <booktitle> In Conference Record of the 18th Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 55-66, </pages> <address> Orlando, Florida, </address> <month> January 21-23, </month> <year> 1991. </year>
Reference-contexts: Tarjan and Valdes use a hierarchical representation of SESE regions of a different kind to do elimination [Val78, TV80]. Sparsity was highlighted by Choi, Cytron, and Ferrante <ref> [CCF91] </ref>, and by Dhamdhere, Rosen, and Zadeck [DRZ92]. Choi et al extend the SSA form to build sparse evaluation graphs (SEGs); these graphs also bypass uninteresting regions of the control flow graph and in general will be smaller than our quick propagation graphs.
Reference: [CF93] <author> Ron Cytron and Jeanne Ferrante. </author> <title> Efficiently computing -nodes on-the-fly. </title> <booktitle> In Proceedings of the Sixth Workshop on Languages and Compilers for Parallel Computing, </booktitle> <pages> pages 461-476, </pages> <month> August </month> <year> 1993. </year> <note> Published as Lecture Notes in Computer Science, number 768. </note>
Reference-contexts: However, they are more costly to build and it is unclear how to exploit both sparsity and structure using SEGs, since their edges cross interval (or SESE region) boundaries in an ad hoc manner. Recently, Cytron and Fer-rante <ref> [CF93] </ref> have improved the time for placing -functions (needed to build SSA form and SEGs) to O (Eff (E)) time; Sreedhar and Gao [SG94] have a linear-time algorithm for -function placement.
Reference: [CFR + 91] <author> R. Cytron, J. Ferrante, B. K. Rosen, M. N. Wegman, and F. K. Zadeck. </author> <title> Efficiently computing static single assignment form and the control dependence graph. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 13(4) </volume> <pages> 451-490, </pages> <month> October </month> <year> 1991. </year>
Reference-contexts: As a concrete example, the static single assignment (SSA) form is usually computed using dominance frontiers which can be O (N 2 ) in size <ref> [CFR + 91] </ref>. We show that using the PST, SSA computation can be performed separately in each SESE region. <p> In particular, our experimental results highlight the importance of exploiting sparsity. 6.1 Using the PST in conversion to SSA form Translation into SSA form requires the introduction of - functions at some merge points in the control flow graph. Cytron et al <ref> [CFR + 91] </ref> showed that a -function is needed at a merge if it is the first point in common on two paths from distinct definitions of a variable v to a use of v. They characterized this set of merges in terms of a property called the dominance frontier. <p> Instead of computing dominance frontiers for an entire procedure, we compute dominance frontiers for each SESE region separately. This can be advantageous for example, the size of dominance frontiers for nested repeat-until loops reaches the worst-case bound of O (N 2 ) <ref> [CFR + 91] </ref>. When we exploit nesting structure using the PST, each loop is a SESE region whose dominance frontiers are computed independently, thereby avoiding the quadratic blowup. This is an example that illustrates the exploitation of global structure using the PST. <p> It would be interesting to compare the performance of these algorithms to the performance of a PST based algorithm that used the dominance frontier algorithm <ref> [CFR + 91] </ref> selectively in the few, small unstructured SESE regions in the PSTs of typical programs. 7 Conclusions The program structure tree (PST) is a hierarchical representation of program structure in which nodes represent single entry single exit (SESE) regions and edges represent region nesting.
Reference: [CFS90] <author> Ron Cytron, Jeanne Ferrante, and Vivek Sarkar. </author> <title> Compact representations for control dependence. </title> <booktitle> In Proceedings of the SIGPLAN '90 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 337-351, </pages> <address> White Plains, New York, </address> <month> June 20-22, </month> <year> 1990. </year>
Reference-contexts: Two nodes are said to be in the same control region if they have the same set of control dependences [FOW87]. Previous algorithms for this problem are either restricted to reducible flow graphs [Bal92] or have O (EN ) complexity <ref> [CFS90] </ref>. Control region information is useful for problems such as instruction scheduling for pipelined machines [GS87]; therefore, our linear-time algorithm for region determination is of wide interest. The PST is a tool which can enhance the performance of many program analysis algorithms. <p> Their algorithm used hashing to compute control regions in O (N ) expected time, O (N 2 E) worst-case time and O (N E) space. These results were improved by Cytron, Ferrante, and Sarkar <ref> [CFS90] </ref> who gave an O (EN ) time, O (E + N ) space algorithm for finding control regions.
Reference: [DRZ92] <author> Dhananjay M. Dhamdhere, Barry K. Rosen, and F. Kenneth Zadeck. </author> <title> How to analyze large programs efficiently and informatively. </title> <booktitle> In Proceedings of the SIGPLAN '92 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 212-223, </pages> <address> San Fran-cisco, California, </address> <month> June 17-19, </month> <year> 1992. </year>
Reference-contexts: Tarjan and Valdes use a hierarchical representation of SESE regions of a different kind to do elimination [Val78, TV80]. Sparsity was highlighted by Choi, Cytron, and Ferrante [CCF91], and by Dhamdhere, Rosen, and Zadeck <ref> [DRZ92] </ref>. Choi et al extend the SSA form to build sparse evaluation graphs (SEGs); these graphs also bypass uninteresting regions of the control flow graph and in general will be smaller than our quick propagation graphs.
Reference: [FOW87] <author> J. Ferrante, K. J. Ottenstein, and J. D. Warren. </author> <title> The program dependency graph and its uses in optimization. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 9(3) </volume> <pages> 319-349, </pages> <month> June </month> <year> 1987. </year>
Reference-contexts: In Section 5, we apply the cycle equivalence algorithm to finding control regions in O (E) time. Two nodes are said to be in the same control region if they have the same set of control dependences <ref> [FOW87] </ref>. Previous algorithms for this problem are either restricted to reducible flow graphs [Bal92] or have O (EN ) complexity [CFS90]. Control region information is useful for problems such as instruction scheduling for pipelined machines [GS87]; therefore, our linear-time algorithm for region determination is of wide interest. <p> The notion of control dependence plays an important role in optimization and parallelization. Intuitively, a node n is control dependent on a node c if c determines whether n is executed. Control dependence is defined formally as follows. Definition 8 A node n is control dependent <ref> [FOW87] </ref> on node c with direction l if there is a path P from c to n beginning with edge l such that 1. n postdominates all nodes other than c on P , and 2. if n and c are distinct, n does not postdominate c. <p> Control dependence for an edge can be defined analogously. Nodes or edges having the same control dependences are in the same control dependence equivalence class, or control region. Ferrante, Ottenstein, and Warren first posed the problem of partitioning control flow graph nodes into control regions <ref> [FOW87] </ref>. Their algorithm used hashing to compute control regions in O (N ) expected time, O (N 2 E) worst-case time and O (N E) space.
Reference: [GPS90] <author> Rajiv Gupta, Lori Pollock, and Mary Lou Soffa. </author> <title> Par-allelizing data flow analysis. </title> <booktitle> In Proceedings of the Workshop on Parallel Compilation, </booktitle> <address> Kingston, Ontario, </address> <month> May 6-8, </month> <year> 1990. </year> <institution> Queen's University. </institution>
Reference-contexts: We also discuss possible applications of the PST to parallel and incremental program analysis. 2 Single entry single exit regions and the program structure tree In the literature, the term `single entry single exit region' is not used consistently there appear to be several related constructs `aliased' to this term <ref> [Kas75, Val78, TV80, GPS90] </ref>. Therefore, we begin this section with a formal definition of single entry single exit regions as used in this paper . This definition is motivated in part by considerations of control dependence, as will be made precise in Section 5. <p> We refer the interested reader to related work by Gupta, Pollack and Soffa <ref> [GPS90] </ref> who use the SESE decomposition of programs in a structured programming language to perform data flow analysis in parallel.
Reference: [GS87] <author> Rajiv Gupta and Mary Lou Soffa. </author> <title> Region scheduling. </title> <booktitle> In 2nd International Conference on Supercomputing, </booktitle> <pages> pages 141-148, </pages> <year> 1987. </year>
Reference-contexts: Previous algorithms for this problem are either restricted to reducible flow graphs [Bal92] or have O (EN ) complexity [CFS90]. Control region information is useful for problems such as instruction scheduling for pipelined machines <ref> [GS87] </ref>; therefore, our linear-time algorithm for region determination is of wide interest. The PST is a tool which can enhance the performance of many program analysis algorithms. Each SESE region is a control flow graph in its own right, so any program analysis algorithm can be applied directly to it.
Reference: [GW76] <author> S. Graham and M. Wegman. </author> <title> A fast and usually linear algorithm for global flow analysis. </title> <journal> Journal of the ACM, </journal> <volume> 23(1) </volume> <pages> 172-202, </pages> <month> January </month> <year> 1976. </year>
Reference-contexts: Finally, for irreducible regions, we can fall back on a general iterative method, which is similar in spirit to so-called `hybrid' algorithms [Zad84, HDT87, MR90]. It is interesting to note that Graham and Wegman exploited single-exit intervals to speed up elimination-based data flow analysis <ref> [GW76] </ref>. Exploiting sparsity: Recent work on speeding up data flow analysis has focused on solving individual instances of data flow problems, such as finding the availability of x + y, as opposed to analyzing a property for all variables or expressions simultaneously as is done in the traditional bit-vector approach.
Reference: [HDT87] <author> S. Horwitz, A. Demers, and T. Teitelbaum. </author> <title> An efficient general iterative algorithm for data-flow analysis. </title> <journal> Acta Informatica, </journal> <volume> 24(6) </volume> <pages> 679-694, </pages> <year> 1987. </year>
Reference-contexts: Therefore, if the original graph is reducible, the (few, small) unstructured SESE regions in the PST can be analyzed using interval methods. Finally, for irreducible regions, we can fall back on a general iterative method, which is similar in spirit to so-called `hybrid' algorithms <ref> [Zad84, HDT87, MR90] </ref>. It is interesting to note that Graham and Wegman exploited single-exit intervals to speed up elimination-based data flow analysis [GW76].
Reference: [JP93] <author> Richard Johnson and Keshav Pingali. </author> <title> Dependence-based program analysis. </title> <booktitle> In Proceedings of the SIG-PLAN '93 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 78-89, </pages> <address> Albuquerque, New Mexico, </address> <month> June 23-25, </month> <year> 1993. </year>
Reference-contexts: Since QPGs are often so small relative to the size of the CFG, it is a significant savings that our algorithm does not examine transparent regions. In a previous paper, we discussed a representation of dependences called the dependence flow graph (DFG) <ref> [JP93] </ref>. Intuitively, the DFG is a set of `basis' graphs from which we can construct the QPG for a given data flow problem. For lack of space, we postpone discussion of this connection.
Reference: [JPP93] <author> Richard Johnson, David Pearson, and Keshav Pingali. </author> <title> Finding regions fast: Single entry single exit and control regions in linear time. </title> <type> Technical Report 93-1365, </type> <institution> Department of Computer Science, Cornell University, </institution> <month> July </month> <year> 1993. </year>
Reference-contexts: We leave it to the reader to verify this theorem for the example shown in Figure 1 (a). The proof of this theorem is straightforward, if tedious, and can be found in <ref> [JPP93] </ref>. Unlike the edge cycle equivalence relation, node cycle equivalence is not preserved when edge directions are removed from a graph. Fortunately, a simple construction lets us reduce the problem of finding node cycle equivalence in directed graphs to the problem of edge cycle equivalence in a related directed graph. <p> In a related technical report, we have shown that this algorithm runs faster than dominator computation, which is just the first step in all previous algorithms for this problem <ref> [JPP93] </ref>. 6 Applications of the PST The Program Structure Tree is a tool for enhancing the performance of program analysis algorithms by providing a simple framework for exploiting global structure, local structure, and sparsity. The intuitive idea is the following.
Reference: [Kas75] <author> V. N. Kas'janov. </author> <title> Distinguishing hammocks in a directed graph. </title> <journal> Soviet Math. Doklady, </journal> <volume> 16(5) </volume> <pages> 448-450, </pages> <year> 1975. </year>
Reference-contexts: We also discuss possible applications of the PST to parallel and incremental program analysis. 2 Single entry single exit regions and the program structure tree In the literature, the term `single entry single exit region' is not used consistently there appear to be several related constructs `aliased' to this term <ref> [Kas75, Val78, TV80, GPS90] </ref>. Therefore, we begin this section with a formal definition of single entry single exit regions as used in this paper . This definition is motivated in part by considerations of control dependence, as will be made precise in Section 5.
Reference: [Ken81] <author> Ken Kennedy. </author> <title> A survey of data flow analysis techniques. </title> <editor> In Steven S. Muchnick and Neil D. Jones, editors, </editor> <title> Program Flow Analysis: Theory and Application, </title> <booktitle> chapter 1, </booktitle> <pages> pages 5-54. </pages> <publisher> Prentice-Hall, </publisher> <address> Englewood Cliffs, NJ, </address> <year> 1981. </year>
Reference-contexts: Next, we discuss dataflow analysis, a problem in which region solutions must be combined to yield the solution for the entire procedure. 6.2 Using the PST in data flow analysis Solution techniques for monotone data flow analysis problems are classified into iterative methods and elimination methods <ref> [Ken81, RP86] </ref>. We show discuss how the PST can be used with either class of methods. Exploiting global and local structure: Elimination methods exploit nested program structure to solve data flow equations efficiently. Given some hierarchical decomposition of program structure, analysis is performed in two phases. <p> In both phases, we need some algorithm to collect or propagate information within a SESE region. As discussed in Section 4, most regions are simple constructs such as blocks, if-then or loop constructs; these regions may be processed quickly using structure-based methods <ref> [Ken81] </ref>. What about the remaining unstructured regions? An important aspect of the PST is that it is compatible with methods based on intervals. In particular, we have the following theorem whose proof is straightforward. <p> There is an enormous body of work on elimination and iteration algorithms, and we refer the reader to surveys by Ryder and Paull [RP86], and by Kennedy <ref> [Ken81] </ref>. Tarjan and Valdes use a hierarchical representation of SESE regions of a different kind to do elimination [Val78, TV80]. Sparsity was highlighted by Choi, Cytron, and Ferrante [CCF91], and by Dhamdhere, Rosen, and Zadeck [DRZ92].
Reference: [LT79] <author> Thomas Lengauer and Robert Endre Tarjan. </author> <title> A fast algorithm for finding dominators in a flowgraph. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 1(1) </volume> <pages> 121-141, </pages> <month> July </month> <year> 1979. </year>
Reference-contexts: We give a fast, linear-time algorithm based on depth-first search for solving the cycle equivalence problem, thereby finding SESE regions in linear time. This algorithm runs very fast in practice for example, our empirical results show that it runs faster than Lengauer and Tarjan's algorithm for finding dominators <ref> [LT79] </ref>. We use this algorithm to build the PST for arbitrary flow graphs in O (E) time. In Section 4, we give experimental results that characterize the structure of the PST in standard benchmarks such as Perfect Club, SPEC, and Linpack programs.
Reference: [MR90] <author> Thomas J. Marlowe and Barbara G. Ryder. </author> <title> An efficient hybrid algorithm for incremental data flow analysis. </title> <booktitle> In Conference Record of the 17th Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 184-196, </pages> <address> San Francisco, California, </address> <month> January </month> <year> 1990. </year>
Reference-contexts: Therefore, if the original graph is reducible, the (few, small) unstructured SESE regions in the PST can be analyzed using interval methods. Finally, for irreducible regions, we can fall back on a general iterative method, which is similar in spirit to so-called `hybrid' algorithms <ref> [Zad84, HDT87, MR90] </ref>. It is interesting to note that Graham and Wegman exploited single-exit intervals to speed up elimination-based data flow analysis [GW76].
Reference: [Pod93] <author> Andy Podgurski. </author> <title> Reordering-transformations that preserve control dependence. </title> <type> Technical Report CES-93-16, </type> <institution> Case Western Reserve University, </institution> <month> July </month> <year> 1993. </year>
Reference-contexts: However, his algorithm works only for reducible graphs and requires computation of both dominators and postdominators. Podgurski has given a linear-time algorithm for forward control dependence equivalence, which is a special case of general control dependence equivalence <ref> [Pod93] </ref>.
Reference: [RP86] <author> B. G. Ryder and M. C. Paull. </author> <title> Elimination algorithms for data flow analysis. </title> <journal> ACM Computing Surveys, </journal> <volume> 18(3) </volume> <pages> 277-316, </pages> <month> September </month> <year> 1986. </year>
Reference-contexts: Next, we discuss dataflow analysis, a problem in which region solutions must be combined to yield the solution for the entire procedure. 6.2 Using the PST in data flow analysis Solution techniques for monotone data flow analysis problems are classified into iterative methods and elimination methods <ref> [Ken81, RP86] </ref>. We show discuss how the PST can be used with either class of methods. Exploiting global and local structure: Elimination methods exploit nested program structure to solve data flow equations efficiently. Given some hierarchical decomposition of program structure, analysis is performed in two phases. <p> There is an enormous body of work on elimination and iteration algorithms, and we refer the reader to surveys by Ryder and Paull <ref> [RP86] </ref>, and by Kennedy [Ken81]. Tarjan and Valdes use a hierarchical representation of SESE regions of a different kind to do elimination [Val78, TV80]. Sparsity was highlighted by Choi, Cytron, and Ferrante [CCF91], and by Dhamdhere, Rosen, and Zadeck [DRZ92].
Reference: [SG94] <author> Vugranam C. Sreedhar and Guang R. Gao. </author> <title> Computing -nodes in linear time using DJ-graphs. </title> <type> Technical Report ACAPS Technical Memo 75, </type> <institution> McGill University School of Computer Science, </institution> <month> January </month> <year> 1994. </year>
Reference-contexts: Recently, Cytron and Fer-rante [CF93] have improved the time for placing -functions (needed to build SSA form and SEGs) to O (Eff (E)) time; Sreedhar and Gao <ref> [SG94] </ref> have a linear-time algorithm for -function placement.
Reference: [TV80] <author> Robert E. Tarjan and Jacobo Valdes. </author> <title> Prime subprogram parsing of a program. </title> <booktitle> In Conference Record of the 7th Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 95-105, </pages> <address> Las Vegas, Nevada, </address> <month> January 28-30, </month> <year> 1980. </year>
Reference-contexts: We also discuss possible applications of the PST to parallel and incremental program analysis. 2 Single entry single exit regions and the program structure tree In the literature, the term `single entry single exit region' is not used consistently there appear to be several related constructs `aliased' to this term <ref> [Kas75, Val78, TV80, GPS90] </ref>. Therefore, we begin this section with a formal definition of single entry single exit regions as used in this paper . This definition is motivated in part by considerations of control dependence, as will be made precise in Section 5. <p> There is an enormous body of work on elimination and iteration algorithms, and we refer the reader to surveys by Ryder and Paull [RP86], and by Kennedy [Ken81]. Tarjan and Valdes use a hierarchical representation of SESE regions of a different kind to do elimination <ref> [Val78, TV80] </ref>. Sparsity was highlighted by Choi, Cytron, and Ferrante [CCF91], and by Dhamdhere, Rosen, and Zadeck [DRZ92].
Reference: [Val78] <author> Jacobo Valdes. </author> <title> Parsing Flowcharts and Series-Parallel Graphs. </title> <type> PhD thesis, </type> <institution> Stanford University, </institution> <note> De-cember 1978. Report STAN-CS-78-682. </note>
Reference-contexts: We also discuss possible applications of the PST to parallel and incremental program analysis. 2 Single entry single exit regions and the program structure tree In the literature, the term `single entry single exit region' is not used consistently there appear to be several related constructs `aliased' to this term <ref> [Kas75, Val78, TV80, GPS90] </ref>. Therefore, we begin this section with a formal definition of single entry single exit regions as used in this paper . This definition is motivated in part by considerations of control dependence, as will be made precise in Section 5. <p> There is an enormous body of work on elimination and iteration algorithms, and we refer the reader to surveys by Ryder and Paull [RP86], and by Kennedy [Ken81]. Tarjan and Valdes use a hierarchical representation of SESE regions of a different kind to do elimination <ref> [Val78, TV80] </ref>. Sparsity was highlighted by Choi, Cytron, and Ferrante [CCF91], and by Dhamdhere, Rosen, and Zadeck [DRZ92].
Reference: [Zad84] <author> F. Kenneth Zadeck. </author> <title> Incremental data flow analysis in a structured program editor. </title> <booktitle> In Proceedings of the 1984 SIGPLAN Symposium on Compiler Construction, </booktitle> <pages> pages 132-143, </pages> <address> Montreal, Canada, </address> <month> June 17-22, </month> <year> 1984. </year>
Reference-contexts: Therefore, if the original graph is reducible, the (few, small) unstructured SESE regions in the PST can be analyzed using interval methods. Finally, for irreducible regions, we can fall back on a general iterative method, which is similar in spirit to so-called `hybrid' algorithms <ref> [Zad84, HDT87, MR90] </ref>. It is interesting to note that Graham and Wegman exploited single-exit intervals to speed up elimination-based data flow analysis [GW76].
References-found: 26

