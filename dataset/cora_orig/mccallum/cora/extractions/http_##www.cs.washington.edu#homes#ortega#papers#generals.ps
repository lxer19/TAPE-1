URL: http://www.cs.washington.edu/homes/ortega/papers/generals.ps
Refering-URL: http://www.cs.washington.edu/homes/ortega/papers/publications.html
Root-URL: 
Title: Timing Predictability in Real-Time Systems  
Author: Ross Ortega 
Date: April 11, 1994  
Address: Seattle, WA 98195  
Affiliation: Department of Computer Science and Engineering University of Washington  
Abstract: A real-time system must be not only functionally correct, but also temporally correct. With the trend of real-time applications being used in safety critical situations, the ability to predict the timing properties of such systems is becoming more important than ever. This paper examines some of the general issues involved in making timing predictions with the focus on shared resources and interprocessor communication. Four systems used to implement real-time applications are analyzed for predictability: a real-time kernel from UBC, YARTOS, Chimera II, and MARS. The UBC real-time kernel and YARTOS are intended for uniprocessor systems and have been used in multimedia applications. Chimera II, a robotics environment, and MARS, a fault-tolerant architecture, are both multiple processor environments. 
Abstract-found: 1
Intro-found: 1
Reference: [BS91] <author> Peter Buhler and Peter Sturm. </author> <title> Discussion summary of trends in real-time operating systems. </title> <booktitle> In Proceedings of the International Workshop on Operating Systems of the 90s and Beyond, </booktitle> <pages> pages 116-117, </pages> <month> July </month> <year> 1991. </year>
Reference-contexts: In the design of any real-time system, an assessment of the worst-case scenario or peak-load must be made for the system. These worst-case estimates are used in scheduling. However, many researchers and designers feel that the actual worst-case may, in fact, be worse than the predicted worst-case <ref> [BS91] </ref>. Advocates of dynamic guarantees justify their approach based on the difficulties of characterizing the environment [Sta88]. Although acceptable for soft real-time applications, the dynamic approach is not suitable in the domain of hard real-time where static guarantees are of paramount importance.
Reference: [Car84] <author> Gene D. Carlow. </author> <title> Architecture of the space shuttle primary avionics software system. </title> <journal> CACM, </journal> <volume> 27(9) </volume> <pages> 926-936, </pages> <month> September </month> <year> 1984. </year>
Reference-contexts: This first problem can be solved with modes. A real-time system may have different requirements depending on which mode of operation it is in. For instance, the space shuttle has three very distinct modes, ascent, mission-specific, and landing <ref> [Car84] </ref>. Modes allow the scheduler to reserve processor time for only those activities that may occur simultaneously. The second problem is that the number of tasks required or task execution times may depend on the environment. This is more troubling from a predictability point of view.
Reference: [CJR92] <author> Raymond K. Clark, E. Douglass Jensen, and Franklin D. Reynolds. </author> <title> An architectural overview of the Alpha real-time distributed kernel. </title> <booktitle> In Proceedings of the USENIX Workshop on Micro-Kernels and Other Kernel Architectures, </booktitle> <pages> pages 127-146, </pages> <month> April </month> <year> 1992. </year>
Reference-contexts: Many schedulers are including more attributes to better differentiate the relative importance of one task compared to others. The real-time operating system Alpha is based upon the Benefit Accrual Model, which captures the system benefits of honoring particular timing constraints <ref> [CJR92] </ref>. This allows the scheduler to make more intelligent decisions where tradeoffs need to be considered. Many real-time systems use rate monotonic (RM) scheduling because it is very simple to implement. Static priorities are assigned to tasks based on their periods, where a shorter period implies a higher priority [LL73]. <p> Another approach is to allow only asynchronous communication which simplifies execution time estimates. However, reasoning about the correctness of the program in the presence of concurrent activity and exception handling is much more difficult <ref> [CJR92] </ref>. In multiple processor systems, a real-time network is required to have bounded latencies so that schedulers can make appropriate decisions. These latencies can be affected by the choice of communication protocol. Selecting a broadcast or point-to-point protocol may depend on the topology of the interconnect.
Reference: [Cra93] <author> Travis S. Craig. </author> <title> Queuing spin lock algorithms to support timing predictability. </title> <booktitle> In Proceedings of the Real-Time Systems Symposium, </booktitle> <pages> pages 148-157, </pages> <month> December </month> <year> 1993. </year>
Reference-contexts: To reduce such bus contention, Craig has proposed a compromise solution where the spinning does not generate network traffic and the request may be removed from the request queue <ref> [Cra93] </ref>.
Reference: [DRSK89] <author> A. Damm, J. Reisinger, W. Schwabl, and H. Kopetz. </author> <title> The real-time operating system of MARS. </title> <journal> Operating Systems Review, </journal> <volume> 23(32) </volume> <pages> 141-157, </pages> <month> July </month> <year> 1989. </year>
Reference-contexts: Much of this complexity may be attributed to interprocessor communication. This section examines the interprocessor communication mechanisms implemented in two real-time systems which support multiple processors. The first system, Chimera II [SSK92], is intended for robotic applications and communicates via VME-Bus. The second system, MARS <ref> [DRSK89] </ref>, is a distributed fault-tolerant architecture for hard real-time applications that communicates via ethernet. 5.1 Chimera II The Chimera environment was developed at CMU as part of the Reconfigurable Modular Manipulator System project.
Reference: [GMK + 91] <author> Olafur Gudmundson, Daniel Mosse, Keng-Tai Ko, Ashok K. Agrawala, and Satish K. Tripathi. Maruti, </author> <title> an environment for hard real-time applications. </title> <editor> In Ashok K. Agrawal, Karen D. Gordon, and Phillip Hwang, editors, </editor> <title> Mission Critical Operating Systems. </title> <publisher> IOS Press, </publisher> <address> Amsterdam, Netherlands, </address> <year> 1991. </year>
Reference-contexts: Coupled with a consistent notion of system time and the appropriate policies enforced on designers, this decision allows a MARS application to be predictable in any environment. An added benefit of time-driven systems is that they are easier to verify than even-driven ones <ref> [GMK + 91] </ref>. With the high consequences of incorrect hard real-time systems, this feature may force designers of such systems to adopt this approach. The main argument against the time-driven model is its rigidity. However, the main requirement of a hard real-time application is that it honor all timing constraints.
Reference: [JA88] <author> K. Jeffay and R. Anderson. </author> <title> On optimal, non-preemptive scheduling of periodic and sporadic tasks. </title> <type> Technical Report 88-11-06, </type> <institution> University of Washington, Department of Computer Science, </institution> <year> 1988. </year>
Reference-contexts: However, the problem of scheduling periodic processes which use semaphores to enforce mutual exclusion is NP-hard [Mok83]. Another variation is to disallow preemption. Deciding if a set of periodic tasks can be scheduled without preemption is also NP-hard <ref> [JA88] </ref>. A schedulability test determines if a set of tasks will all meet their deadlines. The schedulability test may either be static or dynamic. Note that in static schedulers, the generation of a feasible schedule is the schedulability test. As mentioned above, the complexity of deciding schedulability may be NP-hard.
Reference: [Jef89] <author> Kevin Jeffay. </author> <title> The real-time producer/consumer paradigm: Towards verifiable real-time computations. </title> <type> Technical Report 89-09-15, </type> <institution> University of Washington, Department of Computer Science, </institution> <year> 1989. </year>
Reference-contexts: possible scenario is to have the worker tasks run at high priorities, the resource administrators at medium priorities, and the client tasks at lower priorities. 3.2 Yet Another Real-Time Operating System YARTOS (Yet Another Real-Time Operating System) is a uniprocessor micro-kernel operating system based on the real-time producer/consumer (RTP/C) paradigm <ref> [Jef89] </ref>. Under this model, a program can be viewed as a directed graph, where the vertices represent tasks and the edges represent communication channels. In YARTOS, the three main abstractions are tasks, resources, and messages.
Reference: [Jef92] <author> Kevin Jeffay. </author> <title> Scheduling sporadic tasks with shared resources in hard-real-time systems. </title> <booktitle> In Proceedings of the Real-Time Systems Symposium, </booktitle> <pages> pages 89-99, </pages> <month> December </month> <year> 1992. </year> <title> Timing Predictability in Real-Time Systems 29 </title>
Reference-contexts: Also, the preempted task will still be scheduled before any other task that requires the same resource. This feature allows the kernel to use a single execution stack which may be statically bounded. In <ref> [Jef92] </ref>, it was observed that the number of tasks that are able to preempt other tasks is small. The conjecture is that if preemption is necessary for feasibility it will be limited to a few tasks. <p> &lt; R i : i1 X $ R j C j (2) where n is the number of tasks in the system, r i is the resource requirement of task T i , and R min;k is the minimum response time requirement of all tasks that access resource M k <ref> [Jef92] </ref>. Consider all tasks in the system sorted in increasing order of response time. Now suppose that task T i is using resource k. T i may not have this resource for greater than R i time.
Reference: [JSP92] <author> Kevin Jeffay, Donald L. Stone, and Daniel E. Poirier. YARTOS: </author> <title> Kernel support for efficient, predictable, real-time systems. </title> <editor> In W. Halang and K. Ramamritham, editors, </editor> <booktitle> Real-Time Programming. </booktitle> <publisher> Pergamon Press, Oxford, </publisher> <address> UK, </address> <year> 1992. </year>
Reference-contexts: The first is a real-time kernel developed at the University of British Columbia [LHC93]. Although this kernel was not named, it will be referred to in this paper as the UBC Kernel. The second operating system considered is YARTOS, developed at the University of North Carolina <ref> [JSP92] </ref>. Both of these systems have been used to implement real-time multimedia applications. 3.1 The UBC Real-Time Kernel Development of the UBC kernel was motivated by the observation that the scheduling mechanism of an operating system is coupled tightly to a particular task model.
Reference: [JSS92] <author> Kevin Jeffay, Donald L. Stone, and F. Donelson Smith. </author> <title> Kernel support for live digital audio and video. </title> <journal> Computer Communications, </journal> <volume> 15(6) </volume> <pages> 388-395, </pages> <month> July/August </month> <year> 1992. </year>
Reference-contexts: Another weakness of YARTOS is that all timing constraints must be specified as the minimum inter-arrival times of task invocations. Designers using YARTOS encountered constraints which were not functions of inter-arrival times <ref> [JSS92] </ref>. To get around this problem, an event count was associated with each port. A kernel call was provided which returns the number of messages sent to a task. The event count can be used to implement a standard producer/consumer synchronization protocol.
Reference: [KDK + 89] <author> H. Kopetz, A. Damm, C. Koza, M. Mulazzani, W. Schwabl, C. Senft, and R. Zainlinger. </author> <title> Distributed fault-tolerant real-time systems : The MARS approach. </title> <journal> IEEE Micro, </journal> <volume> 9(1) </volume> <pages> 25-40, </pages> <month> February </month> <year> 1989. </year>
Reference-contexts: Under this paradigm, the CPU may only be interrupted by a real-time clock at periodic intervals. MARS is based on a transactional (data-flow) model. A transaction is the single execution of a specified set of tasks between the stimulus and the corresponding response <ref> [KDK + 89] </ref>. A MARS system consists of a set of highly interconnected clusters (see Figure 4). A cluster has components connected by a real-time bus.
Reference: [KFG + 92] <author> H. Kopetz, G. Fohler, G. Grunsteidl, H. Kantz, G. Pospischil, P. Puschner, J. Reisinger, R. Schlatterbeck, W. Schutz, A. Vrchticky, and R. Zainlinger. </author> <title> The programmer's view of MARS. </title> <booktitle> In Proceedings of the Real-Time Systems Symposium, </booktitle> <pages> pages 223-226, </pages> <month> December </month> <year> 1992. </year>
Reference-contexts: Based on the task and transaction attributes, the scheduler attempts to find a feasible schedule for each mode and mode change <ref> [KFG + 92] </ref>. The static schedules generated are for the bus as well as for each processor. Timing Predictability in Real-Time Systems 21 Only clock interrupts are acknowledged by the processor. The clock interrupt handler is divided into a major handler and a minor handler.
Reference: [KO87] <author> Hermann Kopetz and Wilhelm Ochsenreiter. </author> <title> Clock synchronization in distributed real-time systems. </title> <journal> IEEE Transactions on Computers, </journal> <volume> C-36(8):933-940, </volume> <month> August </month> <year> 1987. </year>
Reference-contexts: Each node contains a local real-time clock of quartz accuracy which may drift in time relative to other clocks and absolute real-time. An internal system synchronization is required to account for this drift. The send and receive times of messages are used to determine the drift between clocks <ref> [KO87] </ref>. A MARS cluster (group of nodes) obtains absolute real-time via governmental long-wave radio broadcasts of UTC (Universal Time Coordinated). The CSU has registers to account for the drift of the local crystal, correction due to internal synchronization, and the drift from UTC.
Reference: [KS86] <author> Eugene Kligerman and Alexander Stoyenko. </author> <title> Real-time Euclid: A language for reliable real-time systems. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> SE-12(9):941-949, </volume> <month> September </month> <year> 1986. </year>
Reference-contexts: This definition indicates nothing about the system's ability to meet these timing constraints. If the Timing Predictability in Real-Time Systems 2 result of missing a deadline is not so drastic, the constraint is said to be soft real-time. Kligerman and Stoyenko <ref> [KS86] </ref> define a soft real-time constraint to be one where the system is considered to function correctly if only a few deadlines are missed and that they are "not missed by much". <p> The problem of predicting the execution time of arbitrary programs is equivalent in complexity to solving the halting problem. To make this task more manageable, the RTEuclid language has restrictions such as bounded loops, no recursion, and no dynamic allocation of data <ref> [KS86] </ref>. In the data-flow model, the system can be viewed as manipulating pieces of information called samples.
Reference: [KV93] <author> Hermann Kopetz and Paulo Verissimo. </author> <title> Real time and dependability concepts. In Sape Mullender, editor, Distributed Systems 2nd Ed. </title> <publisher> Addison-Wesley, </publisher> <address> New York, New York, </address> <year> 1993. </year>
Reference-contexts: Because of the vagueness of this definition, a third type of system, called a best-effort system, has been defined to be those that attempt to honor hard real-time constraints. However, under periods of overload, it selectively chooses which constraints to violate <ref> [KV93] </ref>. Best-effort systems usually try to guarantee a certain level of quality of service (QOS) which is indirectly related to the choice of constraints honored. <p> A description of the models used to capture these environment interactions, tasks, and the scheduling of these tasks are presented in this section. Timing Predictability in Real-Time Systems 4 2.1 Interactions and Models The interaction between a real-time system and its environment can be divided into event-triggered and time-triggered <ref> [KV93] </ref>. An event-triggered system is one where all system activity occurs in response to events. These passive systems are generally referred to as interrupt-driven architectures. They can respond very quickly to inputs, but are highly dependent on the order of incoming events.
Reference: [KZF + 91] <author> H. Kopetz, R. Zainlinger, G. Fohler, H. Kantz, P. Puschner, and W. Schutz. </author> <title> An engineering approach to hard real-time system design. </title> <booktitle> In Proceedings of the 3rd European Software Engineering Conference, </booktitle> <pages> pages 166-188, </pages> <month> October </month> <year> 1991. </year>
Reference-contexts: Some of these systems are being used in areas where they previously did not exist. The illusion that such systems are inherently reliable and safe is also driving the trend towards more automatic control systems [Lev94]. Unfortunately, as noted in <ref> [KZF + 91] </ref>, the current design of many real-time systems is closer to an "occult art" rather than an engineering discipline. Predictability is the most important aspect of a real-time system.
Reference: [Lan92] <author> Gerard Le Lann. </author> <title> Designing real-time dependable distributed systems. </title> <journal> Computer Communications, </journal> <volume> 15(4) </volume> <pages> 225-234, </pages> <month> May </month> <year> 1992. </year>
Reference-contexts: The case of a flawed specification, although a serious problem, is not considered here. Le Lann defines predictability as the probability that the assumptions made during system design are accurate multiplied by the probability of the system entering verified states at runtime <ref> [Lan92] </ref>. Because there is no way to measure these probabilities, this definition is not useful for designers of real-time systems. This paper will consider a much narrower and simpler definition of predictability, namely the ability to forecast the timing duration of a subroutine call. <p> However, the main requirement of a hard real-time application is that it honor all timing constraints. A quick average response time is not important. Le Lann argues that event-driven systems are more flexible and are just as verifiable as time-driven ones <ref> [Lan92] </ref>. As noted earlier, the guarantees provided by YARTOS (event-driven) are weaker than those of MARS (time-driven). Given expected inputs, both system will meet their constraints.
Reference: [Lev94] <author> Nancy Leveson. SAFEWARE: </author> <title> System Safety in the Computer Age. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, MA, </address> <note> to appear 1994. </note>
Reference-contexts: Some of these systems are being used in areas where they previously did not exist. The illusion that such systems are inherently reliable and safe is also driving the trend towards more automatic control systems <ref> [Lev94] </ref>. Unfortunately, as noted in [KZF + 91], the current design of many real-time systems is closer to an "occult art" rather than an engineering discipline. Predictability is the most important aspect of a real-time system.
Reference: [LHC93] <author> Siu Ling Ann Lo, Norman C. Hutchinson, and Samuel T. Chanson. </author> <title> Architectural considerations in the design of real-time kernels. </title> <booktitle> In Proceedings of the Real-Time Systems Symposium, </booktitle> <pages> pages 138-147, </pages> <month> December </month> <year> 1993. </year>
Reference-contexts: At the same priority level, tasks with earlier deadlines are scheduled first. The first is a real-time kernel developed at the University of British Columbia <ref> [LHC93] </ref>. Although this kernel was not named, it will be referred to in this paper as the UBC Kernel. The second operating system considered is YARTOS, developed at the University of North Carolina [JSP92].
Reference: [LL73] <author> C.L. Liu and James W. Layland. </author> <title> Scheduling algorithms for multiprogramming in a hard-real-time environment. </title> <journal> Journal of the Association for Computing Machinery, </journal> <volume> 20(1) </volume> <pages> 46-61, </pages> <month> January </month> <year> 1973. </year>
Reference-contexts: This allows the scheduler to make more intelligent decisions where tradeoffs need to be considered. Many real-time systems use rate monotonic (RM) scheduling because it is very simple to implement. Static priorities are assigned to tasks based on their periods, where a shorter period implies a higher priority <ref> [LL73] </ref>. The task with the highest priority gets the processor. A task can start at the beginning of its period and has a deadline at the end of each period.
Reference: [Mok83] <author> Aloysius Ka-Lau Mok. </author> <title> Fundamental Design Problems of Distributed Systems for the Hard-Real-Time Environment. </title> <type> PhD thesis, </type> <institution> Massachusetts Institute of Technology, </institution> <month> May </month> <year> 1983. </year>
Reference-contexts: Therefore, tasks may not share resources which require mutual exclusion. Timing Predictability in Real-Time Systems 6 A variation on the RM method is to allow mutual exclusion. However, the problem of scheduling periodic processes which use semaphores to enforce mutual exclusion is NP-hard <ref> [Mok83] </ref>. Another variation is to disallow preemption. Deciding if a set of periodic tasks can be scheduled without preemption is also NP-hard [JA88]. A schedulability test determines if a set of tasks will all meet their deadlines. The schedulability test may either be static or dynamic.
Reference: [MSZ90] <author> Lory D. Molesky, Chia Shen, and Goran Zlokapa. </author> <title> Predictable synchronization mechanisms for multiprocessor real-time systems. </title> <journal> Journal of Real-Time Systems, </journal> <volume> 2(3) </volume> <pages> 163-180, </pages> <month> September </month> <year> 1990. </year>
Reference-contexts: Zlokapa have proposed the Deferred Bus Theorem which can bound the amount of time that a task will have to wait to acquire a semaphore based on the maximum number of requesters, the time spent in the critical region, and the relative execution times of requesting and releasing a semaphore <ref> [MSZ90] </ref>. These techniques assume that the user is able to provide good estimates for the time each task may hold a lock. 5 Interprocessor Communication In high-performance systems, or systems with many simultaneous timing constraints, a uniprocessor system may not be able to provide sufficient timing guarantees. <p> There may be an unbounded amount to time before a spin lock succeeds in a VMEbus architecture <ref> [MSZ90] </ref>. Although a deadline may be associated with a spin lock, there is no support for guaranteeing that a critical task will be granted the table lock over other non-critical tasks in the system. The global table approach exploits global shared memory and gives processor transparent communication.
Reference: [PT90] <editor> Shlomo Pri-Tal. VMEbus. In Joseph DiGiacomo, editor, </editor> <title> Digital Bus Handbook. </title> <publisher> McGraw-Hill, </publisher> <address> New York, NY, </address> <year> 1990. </year>
Reference-contexts: Multiprocessors can communicate with each other by using interrupt lines or location monitors. A location monitor observes all data transfer cycles over the bus and generates a signal whenever an access is made to any of the locations it is assigned to watch <ref> [PT90] </ref>. Inter-task communication occurs through a global state table mechanism. A control module is an individual task which has a local copy of the portions of the global state table that it may read or write.
Reference: [Raj91] <author> R. Rajkumar. </author> <title> Synchronization in Real-Time Systems. </title> <publisher> Kluwer Academic Publishers, </publisher> <year> 1991. </year>
Reference-contexts: For instance, it is possible to check if the current time is May 5, 1994, 4:30pm PDT. Under priority based scheduling, there is the possibility that a low priority task with a shared resource may delay a higher priority task in a phenomenon known as priority inversion <ref> [Raj91] </ref>. Consider the case of three tasks, L, M , H with low, medium, and high priorities, respectively. L has resource R. Since M has a higher priority, it forces L to be swapped out of the processor.
Reference: [SKHK89] <author> Donald Schmitz, Pradeep Khousla, Regis Hoffman, and Takeo Kanade. </author> <title> CHIMERA: A real-time programming environment for manipulator control. </title> <booktitle> In International Conference on Robotics and Automation, </booktitle> <pages> pages 846-852, </pages> <month> May </month> <year> 1989. </year> <title> Timing Predictability in Real-Time Systems 30 </title>
Reference-contexts: It was motivated by the observation that minor changes in a control program required extensive development work <ref> [SKHK89] </ref>. Chimera II is designed as a local operating system that provides a real-time kernel, multiprocessor support, and an interface to a global operating system. It supports global shared-memory, spin-locks, remote semaphores, and global state variables. The architecture of Chimera II is shown in Figure 3.
Reference: [SR87] <author> John A. Stankovic and Krithi Ramamrithmam. </author> <title> The design of the Spring kernel. </title> <booktitle> In Proceedings of the Real-Time Systems Symposium, </booktitle> <pages> pages 146-157, </pages> <month> December </month> <year> 1987. </year>
Reference-contexts: This is more troubling from a predictability point of view. If the environment is not deterministic, then the ability to make guarantees is diminished. A common solution is the idea of dynamic guarantees (schedulability analysis) which was implemented in the Spring kernel <ref> [SR87] </ref>. The scheduler determines at runtime if the constraints of a task can be met before the task executes, allowing the detection of timing constraint violations before they occur. The dynamic guarantee approach relies on exception handlers to take corrective actions. <p> It is common to have dedicated I/O processors when the data rates are higher. Timing Predictability in Real-Time Systems 15 Spring distinguishes between application processors and system processors. Application processors execute user tasks while system processors perform system level activities such as scheduling <ref> [SR87] </ref>. However, multiple processors in a system complicates the task of computing execution times. The main cause of uncertainty in such a system is the latency of interprocessor communication, which can vary widely. Many different communication models have been proposed to enhance timing predictability.
Reference: [SSK92] <author> David B. Stewart, Donald E. Schmitz, and Pradeep K. Khosla. </author> <title> The Chimera II real-time operating system for advanced sensor-based control applications. </title> <journal> IEEE Transactions on Systems, Man, and Cybernetics, </journal> <volume> 22(6) </volume> <pages> 1282-1294, </pages> <month> November/December </month> <year> 1992. </year>
Reference-contexts: However, along with the increase in process ing power comes an increase in the complexity of the system. Much of this complexity may be attributed to interprocessor communication. This section examines the interprocessor communication mechanisms implemented in two real-time systems which support multiple processors. The first system, Chimera II <ref> [SSK92] </ref>, is intended for robotic applications and communicates via VME-Bus. The second system, MARS [DRSK89], is a distributed fault-tolerant architecture for hard real-time applications that communicates via ethernet. 5.1 Chimera II The Chimera environment was developed at CMU as part of the Reconfigurable Modular Manipulator System project.
Reference: [Sta88] <author> John A. Stankovic. </author> <title> Misconceptions about real-time computing. </title> <journal> Computer, </journal> <volume> 21(10) </volume> <pages> 10-19, </pages> <month> October </month> <year> 1988. </year>
Reference-contexts: Sufficient tools are required to statically guarantee that a real-time system will meet all of its hard real-time constraints. The timing behavior of the system must be predictable enough to guarantee correctness <ref> [Sta88] </ref>. The case of a flawed specification, although a serious problem, is not considered here. Le Lann defines predictability as the probability that the assumptions made during system design are accurate multiplied by the probability of the system entering verified states at runtime [Lan92]. <p> These worst-case estimates are used in scheduling. However, many researchers and designers feel that the actual worst-case may, in fact, be worse than the predicted worst-case [BS91]. Advocates of dynamic guarantees justify their approach based on the difficulties of characterizing the environment <ref> [Sta88] </ref>. Although acceptable for soft real-time applications, the dynamic approach is not suitable in the domain of hard real-time where static guarantees are of paramount importance. Determining that a flight-control system cannot schedule required tasks while a jet is airborne is not an acceptable situation.
Reference: [SVK92] <author> David B. Stewart, Richard A. Volpe, and Pradeep K. Khosla. </author> <title> Integration of real-time software modules for reconfigurable sensor-based control systems. </title> <booktitle> In International Conference on Intelligent Robots and Systems, </booktitle> <pages> pages 325-332, </pages> <month> July </month> <year> 1992. </year>
Reference-contexts: Access to the global table is obtained with a spin-lock. In order to guarantee a complete transfer, the task holding the lock disables interrupts <ref> [SVK92] </ref>. Spin locks use an atomic Test-And-Set to obtain mutual exclusion. They repeatedly poll a memory location until they are granted the lock. A poll time and a deadline may be associated with the spin lock.
Reference: [Wir77] <author> Niklaus Wirth. </author> <title> Toward a discipline of real-time programming. </title> <journal> CACM, </journal> <volume> 20(8) </volume> <pages> 577-583, </pages> <month> August </month> <year> 1977. </year>
Reference-contexts: These tasks may need to share resources that require mutual exclusion. Sharing so greatly complicates the problem of predictability that Wirth advocated that a dedicated processor be used for each task instead of having them share a processor <ref> [Wir77] </ref>. As will be shown later, it is possible to make strong guarantees even when tasks share resources. The two major task models used in real-time systems are the cooperative tasks and the competitive tasks.
Reference: [XP93] <author> Jia Xu and David Lorge Parnas. </author> <title> On satisfying timing constraints in hard-real-time systems. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 19(1) </volume> <pages> 70-84, </pages> <month> January </month> <year> 1993. </year>
Reference-contexts: Determining that a flight-control system cannot schedule required tasks while a jet is airborne is not an acceptable situation. For this reason, static schedulers are essential for guaranteeing hard real-time constraints <ref> [XP93] </ref>. Laxity is the time a task may be idle before it must be given the processor to meet its deadline, i.e., the deadline time minus the current time minus the remaining computation time.
References-found: 32

