URL: ftp://ftp.eecs.umich.edu/groups/gasm/prolog.ps.gz
Refering-URL: http://www.eecs.umich.edu/gasm/proglang.html
Root-URL: http://www.eecs.umich.edu
Email: boerger@di.unipi.it  dean@math.hr  
Title: A Mathematical Definition of Full Prolog  
Author: Egon B orger Dean Rosenzweig FSB 
Address: Cso Italia 40 I-56100 Pisa  Salajeva 5 41000 Zagreb, Croatia  
Affiliation: Dip. di Informatica Universita di Pisa  University of Zagreb  
Abstract: The paper provides a mathematical yet simple model for the full programming language Prolog, as apparently intended by the ISO draft standard proposal. The model includes all control constructs, database operations, solution collecting predicates and error handling facilities, typically ignored by previous theoretical treatments of the language. We add to this the ubiquitous box-model debugger. The model directly reflects the basic intuitions underlying the language and can be used as a primary mathematical definition of Prolog. The core of the model has been applied for mathematical analysis of implementations, for clarification of disputable language features and for specifying extensions of the language in various directions. The model may provide guidance for extending the established theory of logic programming to the extralogical features of Prolog. 
Abstract-found: 1
Intro-found: 1
Reference: [Ait-Kaci 91] <author> Ait-Kaci,H. </author> <title> Warren's Abstract Machine. A Tutorial Reconstruction. </title> <publisher> MIT Press 1991. </publisher>
Reference-contexts: In fact, it is from the core of the present model that a mathematical reconstruction of a generally accepted implementation method for Prolog, the Warren Abstract Machine <ref> [Warren 83, Ait-Kaci 91] </ref>, was formally derived, and proved to execute Prolog correctly|with respect to the model|given explicit mathematical assumptions about the compiler [Borger,Rosenzweig 92].
Reference: [Andrews 90] <author> J.H.Andrews, </author> <title> The logical structure of sequential Prolog, </title> <institution> University of Edinburgh, Department of Computer Science, </institution> <note> Report ECS-LFCS-90-110, 1-37 </note>
Reference: [Apt 90] <author> K.Apt, </author> <title> Logic Programing. </title> <editor> In: J.van Leeuwen (ed.), </editor> <booktitle> Handbook of Theoretical Computer Science, </booktitle> <publisher> Elsevier, </publisher> <address> Vol.B, </address> <year> 1990, </year> <pages> 493-574 </pages>
Reference-contexts: The information relevant for determining a computation state will be associated to nodes by appropriate (in general partial) functions on the universe NODE . For each state we have to know the sequence of literals still to be called. Whereas in the definition of the SLD-tree <ref> [Lloyd 87, Apt 90] </ref> this sequence is depicted as flat, it seems closer to procedural intuition to keep it split into clause (procedure) bodies, preserving the structure of `procedure calling stack'.
Reference: [Arbab,Berry 87] <author> B.Arbab, D.M.Berry, </author> <title> Operational and denotational semantics of Pro-log. </title> <booktitle> In: J.Logic Programming 4, </booktitle> <year> 1987, </year> <pages> 309-329 </pages>
Reference-contexts: It is not at all clear whether or how any of these models could be extended to cover the full language. Attempts to cover the full language are far less numerous <ref> [Arbab,Berry 87, Deransart,Ferrand 92, O'Keefe 85] </ref>. These models are however neither primary nor transparent|they consist in technically involved reductions to some other formalism, which can hardly be understood as adequate expression of basic intuitions.
Reference: [Beierle,Borger 92] <author> C.Beierle, E.Borger, </author> <title> Correctness proof for the WAM with types. </title> <booktitle> In: Computer Science Logic. </booktitle> <editor> (Eds. E.Borger, G.Jager, H.Kleine Buning,M.Richter), </editor> <publisher> Springer LNCS 626, </publisher> <year> 1992, </year> <pages> 15-34 </pages>
Reference-contexts: The core of the present specification was mapped to, and served as foundation for, specifying extensions of Prolog and their implementation, such as * Protos-L|Prolog enriched with polymorphic types <ref> [Beierle,Borger 92] </ref>, where even the cor rectness proof for the implementation could be uniformly extended from the WAM; * CLPR|constraint logic programming system [Borger,Salamone 94], where also the correct ness proof for the implementation could be uniformly extended from the WAM; * Prolog III|Prolog with constraints, [Borger,Schmitt 91]; * Babel|Prolog enriched
Reference: [Bjoerner, Langmaack 90] <author> D.Bjoerner, H.Langmaack, </author> <title> Foreword to: VDM'90. VDM and Z - Formal Methods in Software Development (D.Bjoerner, </title> <editor> L.A.R.Hoare, H.Langmaack, Eds.), </editor> <publisher> Springer LNCS 428, </publisher> <year> 1990 </year> <month> 24 </month>
Reference: [Borger 90a] <editor> E.Borger,A logical operational semantics of full Prolog: </editor> <booktitle> Part 1. Se--lection core and control. In: CSL '89 , 3rd Workshop on Computer Science Logic (Eds. </booktitle> <address> E.Borger, H.Kleine Buning,M.Richter), </address> <publisher> Springer LNCS 440, </publisher> <year> 1990., </year> <pages> pp. 36-64 </pages>
Reference-contexts: theory and practice : : : that much of the theory of logic programming only applies to pure subsets of Prolog, whereas the extra-logical facilities of the language appear essential for it to be practical [Lloyd 89] This paper synthesizes, streamlines and considerably extends the work reported in preliminary papers <ref> [Borger 90a, Borger 90b, Borger 92, Borger,Rosenzweig 91a] </ref>. The paper is organized as follows. Section 1 introduces what is used of the underlying framework of evolving algebras. Section 2 develops the core part of the model, dealing with SLD-resolution fragment of Prolog. <p> Call could have been equivalently described, relying on metacall , by the clause call (X) : X: It might be a useful excercise to work out the details of call (!), and to see in which sense it is equivalent to true (although some systems have it differently|cf. discussion in <ref> [Borger 90a, p.55] </ref>). In the Appendix we give the simple rule for the predicate once, usually explained as `calling its only argument, without resatisfiability'.
Reference: [Borger 90b] <editor> E.Borger,A logical operational semantics of full Prolog: </editor> <title> Part 2. Built-in predicates for database manipulations. </title> <booktitle> In: Mathematical Foundations of Computer Science 1990 (Ed. </booktitle> <address> B.Rovan), </address> <publisher> Springer LNCS 452, </publisher> <year> 1990, </year> <pages> pp. 1-14 </pages>
Reference-contexts: theory and practice : : : that much of the theory of logic programming only applies to pure subsets of Prolog, whereas the extra-logical facilities of the language appear essential for it to be practical [Lloyd 89] This paper synthesizes, streamlines and considerably extends the work reported in preliminary papers <ref> [Borger 90a, Borger 90b, Borger 92, Borger,Rosenzweig 91a] </ref>. The paper is organized as follows. Section 1 introduces what is used of the underlying framework of evolving algebras. Section 2 develops the core part of the model, dealing with SLD-resolution fragment of Prolog.
Reference: [Borger 92] <editor> E.Borger,A logical operational semantics of full Prolog: </editor> <title> Part 3. Built-in predicates for files, terms, arithmetic and input-output. </title> <editor> In: Y.N.Moschovakis, ed., </editor> <booktitle> Logic from Computer Science, </booktitle> <publisher> MSRI Publications vol.21, Springer 1992, </publisher> <pages> pp. 17-50 </pages>
Reference-contexts: The Prolog features we skip (syntax, operating system interface, arithmetics) are not in any way problematic for our methodology|they are skipped since they are not characteristic either of logic programming or of Prolog, and can be dealt with in a straightforward manner <ref> [Borger 92] </ref>. The core of the model has been successfully applied already for mathematical analysis of implementations, for clarification of disputable language features and for specifying extensions of the language in various directions. <p> theory and practice : : : that much of the theory of logic programming only applies to pure subsets of Prolog, whereas the extra-logical facilities of the language appear essential for it to be practical [Lloyd 89] This paper synthesizes, streamlines and considerably extends the work reported in preliminary papers <ref> [Borger 90a, Borger 90b, Borger 92, Borger,Rosenzweig 91a] </ref>. The paper is organized as follows. Section 1 introduces what is used of the underlying framework of evolving algebras. Section 2 develops the core part of the model, dealing with SLD-resolution fragment of Prolog.
Reference: [BoLoRo 94] <author> E.Borger, F.J.Lopez-Fraguas, M.Rodrigues-Artalejo, </author> <title> A model for mathematical analysis of functional logic programs and their implementations, </title> <booktitle> Proc. IFIP Congress 1994 (to appear). </booktitle>
Reference-contexts: the cor rectness proof for the implementation could be uniformly extended from the WAM; * CLPR|constraint logic programming system [Borger,Salamone 94], where also the correct ness proof for the implementation could be uniformly extended from the WAM; * Prolog III|Prolog with constraints, [Borger,Schmitt 91]; * Babel|Prolog enriched with functional expressions, <ref> [BoLoRo 94] </ref>; * Parlog, Concurrent Prolog|concurrent logic programming languages, [Borger,Riccobene 93, Borger,Riccobene 92]; * object-oriented extension of Prolog [Muller 93].
Reference: [Borger,Demoen 91] <author> E.Borger, B.Demoen, </author> <title> A framework to specify database update views for Prolog. </title> <editor> In: J.Maluszynski, M.Wirsing (Eds.), </editor> <booktitle> Programming Language Implementation and Logic Programming, </booktitle> <publisher> Springer LNCS 528, </publisher> <pages> 147-158 </pages>
Reference-contexts: It has also provided a framework for identifying and clarifying disputable language features and related implementation issues, such as the problem of semantics of dynamic database operations <ref> [Borger,Demoen 91, Borger,Rosenzweig 91b] </ref> and solution-collecting predicates [Borger,Rosenzweig 93]. We view the model as a primary direct formalization of the basic intuitions, concepts and operations of the language, as understood by its practitioners and implementors. <p> The logical view is the one adopted in the draft standard proposal| for an analysis of alternative possibilities see <ref> [Borger,Demoen 91, Borger,Rosenzweig 91b] </ref>. Here it will have to suffice to say that the following program q : assertz (q); fail: r : retract (r; X); f ail: r: differentiates between different views, and unfolds the related difficulties [Borger,Rosenzweig 91b].
Reference: [Borger,Riccobene 93] <author> E.Borger, E.Riccobene, </author> <title> A formal specification of Parlog . In: </title> <editor> M.Droste, Y.Gurevich (Eds.): </editor> <title> Semantics of programming languages and model theory, </title> <publisher> Gordon & Breach 1993, pp.1-42. </publisher>
Reference-contexts: uniformly extended from the WAM; * CLPR|constraint logic programming system [Borger,Salamone 94], where also the correct ness proof for the implementation could be uniformly extended from the WAM; * Prolog III|Prolog with constraints, [Borger,Schmitt 91]; * Babel|Prolog enriched with functional expressions, [BoLoRo 94]; * Parlog, Concurrent Prolog|concurrent logic programming languages, <ref> [Borger,Riccobene 93, Borger,Riccobene 92] </ref>; * object-oriented extension of Prolog [Muller 93]. It has also provided a framework for identifying and clarifying disputable language features and related implementation issues, such as the problem of semantics of dynamic database operations [Borger,Demoen 91, Borger,Rosenzweig 91b] and solution-collecting predicates [Borger,Rosenzweig 93].
Reference: [Borger,Riccobene 92] <author> E.Borger, E.Riccobene, </author> <title> A Mathematical Model of Concurrent Prolog , CSTR-92-15, </title> <institution> Dept. of Computer Science, University of Bristol, </institution> <year> 1992 </year> . 
Reference-contexts: uniformly extended from the WAM; * CLPR|constraint logic programming system [Borger,Salamone 94], where also the correct ness proof for the implementation could be uniformly extended from the WAM; * Prolog III|Prolog with constraints, [Borger,Schmitt 91]; * Babel|Prolog enriched with functional expressions, [BoLoRo 94]; * Parlog, Concurrent Prolog|concurrent logic programming languages, <ref> [Borger,Riccobene 93, Borger,Riccobene 92] </ref>; * object-oriented extension of Prolog [Muller 93]. It has also provided a framework for identifying and clarifying disputable language features and related implementation issues, such as the problem of semantics of dynamic database operations [Borger,Demoen 91, Borger,Rosenzweig 91b] and solution-collecting predicates [Borger,Rosenzweig 93].
Reference: [Borger,Rosenzweig 91a] <author> E.Borger, D.Rosenzweig, </author> <title> A Formal Specification of Prolog by Tree Algebras, </title> <editor> in: V. Ceric et.al. (eds.), </editor> <booktitle> Proceedings of The Third International Conference on Information Technology Interfaces, SRCE, Zagreb 1991, </booktitle> <pages> pp. 513-518 </pages>
Reference-contexts: theory and practice : : : that much of the theory of logic programming only applies to pure subsets of Prolog, whereas the extra-logical facilities of the language appear essential for it to be practical [Lloyd 89] This paper synthesizes, streamlines and considerably extends the work reported in preliminary papers <ref> [Borger 90a, Borger 90b, Borger 92, Borger,Rosenzweig 91a] </ref>. The paper is organized as follows. Section 1 introduces what is used of the underlying framework of evolving algebras. Section 2 develops the core part of the model, dealing with SLD-resolution fragment of Prolog.
Reference: [Borger,Rosenzweig 91b] <author> E.Borger, D.Rosenzweig D. </author> <title> An Analysis of Prolog Database Views and Their Uniform Implementation, </title> <institution> CSE-TR-88-91, University of Michi-gan, Ann Arbor, Michigan, </institution> <year> 1991, </year> <note> also appeared in Prolog, Paris Papers 2, ISO/IEC JTC1 SC22 WG17 standardization. report n.80, </note> <year> 1991, </year> <pages> pp. 87-130 </pages>
Reference-contexts: It has also provided a framework for identifying and clarifying disputable language features and related implementation issues, such as the problem of semantics of dynamic database operations <ref> [Borger,Demoen 91, Borger,Rosenzweig 91b] </ref> and solution-collecting predicates [Borger,Rosenzweig 93]. We view the model as a primary direct formalization of the basic intuitions, concepts and operations of the language, as understood by its practitioners and implementors. <p> While such implementation issues can be sometimes clearly expressed even in this abstract framework, we shall not go into them here (but see <ref> [Borger,Rosenzweig 93, Borger,Rosenzweig 91b] </ref>). 16 4 Database operations The understanding of programs as data is pushed in Prolog to the point that even dedicated constructs for explicit viewing and modification of the program, during execution, are provided. <p> The logical view is the one adopted in the draft standard proposal| for an analysis of alternative possibilities see <ref> [Borger,Demoen 91, Borger,Rosenzweig 91b] </ref>. Here it will have to suffice to say that the following program q : assertz (q); fail: r : retract (r; X); f ail: r: differentiates between different views, and unfolds the related difficulties [Borger,Rosenzweig 91b]. <p> Here it will have to suffice to say that the following program q : assertz (q); fail: r : retract (r; X); f ail: r: differentiates between different views, and unfolds the related difficulties <ref> [Borger,Rosenzweig 91b] </ref>. Under the logical view q fails while r succeeds|the reader may work it out with the rules. 5 Solution collecting predicates The predicates findall, bagof, setof bring the second-order notion of comprehension (collection) into the first order world of Prolog.
Reference: [Borger,Rosenzweig 92] <author> E.Borger, D.Rosenzweig, </author> <title> The WAM|Definition and Compiler Correctness, in Logic Programming: Formal Methods and Practical Applications (C.Beierle, </title> <journal> L.Plumer, eds), North-Holland, </journal> <note> Series in Computer Science and Artificial Intelligence 1994 (to appear), preliminary version appeared as Technical Report TR-14/92, </note> <institution> Dipartimento di Informatica, Universita di Pisa 1992 </institution>
Reference-contexts: In fact, it is from the core of the present model that a mathematical reconstruction of a generally accepted implementation method for Prolog, the Warren Abstract Machine [Warren 83, Ait-Kaci 91], was formally derived, and proved to execute Prolog correctly|with respect to the model|given explicit mathematical assumptions about the compiler <ref> [Borger,Rosenzweig 92] </ref>. <p> Roughly, any action which is `finer grained' than what has been chosen to be a basic step, is static|`coarser grained' actions are dynamic. For instance, on the abstraction level of the model of this paper, unification is a static function, available inside a basic step, while on WAM level <ref> [Borger,Rosenzweig 92] </ref> unification is a dynamically represented algorithm, involving many finer grained basic steps. In the opposite direction, the fixed-point approach to dynamics could, from this perspective, be viewed as the limit case of an infinite basic step. <p> We do not, at this point, propose any fixed proof methodology| the role of proof systems is to single out characteristic proof patterns (for study and/or use). Such characteristic patterns, in the case of evolving algebras, have yet to be identified. See however <ref> [Borger,Rosenzweig 92] </ref>, where a proof pattern seems to emerge, from an analysis of a class of complex programs, i.e. Prolog-to-WAM compilers. See also [Borger,Rosenzweig 94], where more explicit proof-patterns result from the general theory of communicating evolving algebras developed in [Glavan,Rosenzweig 93].
Reference: [Borger,Rosenzweig 93] <author> E.Borger, D.Rosenzweig, </author> <title> The Mathematics of Set Predicates in Prolog, Proceedings of the Kurt Godel Symposium'93, </title> <note> Springer LNCS 713,1-13. Also appeared in Prolog, Copenhagen Papers 2, ISO/IEC JTC1 SC22 WG17 standardization report n.106, </note> <year> 1993, </year> <pages> pp. 33-42 25 </pages>
Reference-contexts: It has also provided a framework for identifying and clarifying disputable language features and related implementation issues, such as the problem of semantics of dynamic database operations [Borger,Demoen 91, Borger,Rosenzweig 91b] and solution-collecting predicates <ref> [Borger,Rosenzweig 93] </ref>. We view the model as a primary direct formalization of the basic intuitions, concepts and operations of the language, as understood by its practitioners and implementors. This is not to say that we would accept any particular implementation as being a definition of the language. <p> While such implementation issues can be sometimes clearly expressed even in this abstract framework, we shall not go into them here (but see <ref> [Borger,Rosenzweig 93, Borger,Rosenzweig 91b] </ref>). 16 4 Database operations The understanding of programs as data is pushed in Prolog to the point that even dedicated constructs for explicit viewing and modification of the program, during execution, are provided. <p> It is indeed disputable whether the proposed (or any) classifying and sorting principles are sound when parameters are not fully instantiated. Therefore we leave these functions abstract, but see <ref> [Borger,Rosenzweig 93] </ref> for analysis, rationale and criticism. 6 Error Handling Error handling, as prescribed by the draft standard proposal, is very easy to describe in this framework. We have, in Section 2, already mentioned putting all `normal' rules under the guard error = 0.
Reference: [Borger,Rosenzweig 94] <author> E.Borger, D.Rosenzweig, </author> <title> Occam: Formal Specification and Provably Correct Compilation. Part I: A Simple Mathematical Interpreter, </title> <note> 1994, submitted. </note>
Reference-contexts: Such characteristic patterns, in the case of evolving algebras, have yet to be identified. See however [Borger,Rosenzweig 92], where a proof pattern seems to emerge, from an analysis of a class of complex programs, i.e. Prolog-to-WAM compilers. See also <ref> [Borger,Rosenzweig 94] </ref>, where more explicit proof-patterns result from the general theory of communicating evolving algebras developed in [Glavan,Rosenzweig 93]. The preceding discourse on methodology is motivated by the ambition to provide a transparent primary mathematical model for the full language.
Reference: [Borger,Salamone 94] <author> E.Borger,R.Salamone, </author> <title> CLAM Specification for Provably Correct Compilation of CLP Programs. In: Specification and Validation Methods for Programming Languages and Systems (E.Borger, </title> <type> Ed.), </type> <institution> Oxford University Press, </institution> <note> 1994 (to appear) </note>
Reference-contexts: of the present specification was mapped to, and served as foundation for, specifying extensions of Prolog and their implementation, such as * Protos-L|Prolog enriched with polymorphic types [Beierle,Borger 92], where even the cor rectness proof for the implementation could be uniformly extended from the WAM; * CLPR|constraint logic programming system <ref> [Borger,Salamone 94] </ref>, where also the correct ness proof for the implementation could be uniformly extended from the WAM; * Prolog III|Prolog with constraints, [Borger,Schmitt 91]; * Babel|Prolog enriched with functional expressions, [BoLoRo 94]; * Parlog, Concurrent Prolog|concurrent logic programming languages, [Borger,Riccobene 93, Borger,Riccobene 92]; * object-oriented extension of Prolog [Muller 93].
Reference: [Borger,Schmitt 91] <author> E.Borger, P.Schmitt, </author> <title> A formal operational semantics for languages of type Prolog III. </title> <booktitle> In: Computer Science Logic, </booktitle> <editor> (Eds. E.Borger, H.Kleine-Buning, M.Richter, W.Schonfeld), </editor> <publisher> Springer LNCS 533, </publisher> <pages> 67-79. </pages>
Reference-contexts: enriched with polymorphic types [Beierle,Borger 92], where even the cor rectness proof for the implementation could be uniformly extended from the WAM; * CLPR|constraint logic programming system [Borger,Salamone 94], where also the correct ness proof for the implementation could be uniformly extended from the WAM; * Prolog III|Prolog with constraints, <ref> [Borger,Schmitt 91] </ref>; * Babel|Prolog enriched with functional expressions, [BoLoRo 94]; * Parlog, Concurrent Prolog|concurrent logic programming languages, [Borger,Riccobene 93, Borger,Riccobene 92]; * object-oriented extension of Prolog [Muller 93].
Reference: [Debray,Mishra 88] <author> S.K.Debray, P.Mishra, </author> <title> Denotational and Operational Semantics for Prolog. In: </title> <journal> Journal of Logic Programming 5, </journal> <year> 1988, </year> <pages> 61-91 </pages>
Reference: [de Bruin,de Vink 89] <author> A.de Bruin, E.P.de Vink, </author> <title> Continuation semantics for Prolog with cut. </title> <booktitle> In: Theory and practice of software engineering, </booktitle> <publisher> Springer LNCS 351, </publisher> <year> 1989, </year> <pages> 178-192 </pages>
Reference: [de Bruin,de Vink 90] <author> A.de Bruin, E.P.de Vink, </author> <title> Retractions in comparing Prolog semantics. </title> <booktitle> In: B.rovan (Ed.),Mathematical Foundations of Computer Science 1990 , Springer LNCS 452, </booktitle> <year> 1990, </year> <pages> 189-186 </pages>
Reference: [Demoen 89] <author> B.Demoen, </author> <title> On the implementation of catch and throw in WAM. </title> <institution> University of Leuven, Department of Computer Science, </institution> <type> Manuscript, </type> <month> July </month> <year> 1989. </year> <note> See also Report CW 96 </note>
Reference-contexts: The reader who knows about implementation, will recognize find catcher as embodying a search of the environment stack. This strategy could be optimized, allowing access to the next catch in constant time (cf. <ref> [Demoen 89] </ref>), by linking the Catchpt marks and storing the top one in a fixed place.
Reference: [Deransart,Ferrand 92] <author> P.Deransart, G.Ferrand, </author> <title> An operational formal definition of Prolog: A specification method and its application. In: New Generation computing, </title> <address> 10.2, </address> <year> 1992, </year> <pages> 121-171 </pages>
Reference-contexts: It is not at all clear whether or how any of these models could be extended to cover the full language. Attempts to cover the full language are far less numerous <ref> [Arbab,Berry 87, Deransart,Ferrand 92, O'Keefe 85] </ref>. These models are however neither primary nor transparent|they consist in technically involved reductions to some other formalism, which can hardly be understood as adequate expression of basic intuitions.
Reference: [Glavan,Rosenzweig 93] <author> P.Glavan, D.Rosenzweig, </author> <title> Communicating Evolving Algebras, </title> <booktitle> in: Computer Science Logic, Selected Papers from CSL'92, </booktitle> <editor> (E.Borger, G.Jager, H. Kleine Buning, S.Martini, M.M.Richter eds.) </editor> <publisher> Springer LNCS 702 </publisher>
Reference-contexts: See however [Borger,Rosenzweig 92], where a proof pattern seems to emerge, from an analysis of a class of complex programs, i.e. Prolog-to-WAM compilers. See also [Borger,Rosenzweig 94], where more explicit proof-patterns result from the general theory of communicating evolving algebras developed in <ref> [Glavan,Rosenzweig 93] </ref>. The preceding discourse on methodology is motivated by the ambition to provide a transparent primary mathematical model for the full language. <p> Simultaneous execution helps us avoid fussing and coding to, say, interchange two values. Since functions may be partial, equality in the guards is to be interpreted in the sense of `partial algebras' [Wirsing 90], as implying that both arguments are defined (see also <ref> [Glavan,Rosenzweig 93] </ref>). More precisely, Definition. An evolving algebra is given by a finite set of transition rules. The signature of a rule, or that of an evolving algebra, can always be reconstructed, as the set of function symbols occurring there. Definition. Let A be an evolving algebra. <p> We tacitly understand the notion of interpretation as validating any integrity constraints imposed. Our rules will always be constructed so that the guards imply consistency of updates, cf. <ref> [Glavan,Rosenzweig 93] </ref> for discussion. While the effect of executing a rule in a static algebra is intuitively clear, it is given precisely by Definition. <p> may (and should) depend on t i 's, setting the values of some functions on newly created elements t i of A. [Gurevich 91] has however shown how to reduce such setups to the above basic model of a homogenous signature (with one universe) and function updates only (see also <ref> [Glavan,Rosenzweig 93] </ref>). As Prolog is a sequential language, our rules are organized in such a way that at every moment at most one rule is applicable. The forms obviously reducible to the above basic syntax, which we shall freely use as abbreviations, are where and if then else. <p> Since throw doesn't use the 21 cutpoint, we have put a dot instead. We couldn't have skipped the continuation|it is essential to throw. The orthogonality of normal operation and error handling can be expressed by composition operators on evolving algebras introduced in <ref> [Glavan,Rosenzweig 93] </ref>: if the set of all `normal' rules, including those below, is denoted as Prolog, and the (singleton containing) error rule above as Error, Prolog with error handling will be represented by the evolving algebra (OK ?Prolog j Error) where OE?A denotes evolving algebra A with guard OE added to <p> logic programming theory from Horn-clause logic to the real programming language. * There are strong grounds to maintain that the whole underlying framework of evolving algebras is logical in its essence|its semantics is the standard semantics of logic, structures interpreting a signature, as indicated in the Introduction (but see also <ref> [Gurevich 91, Glavan,Rosenzweig 93] </ref>). It is thus not accidental that assuming the core of the present model as a starting point has helped to reveal the logical structure of the WAM and some of its extension ([Borger,Rosenzweig 92, Beierle,Borger 92, Borger,Salamone 94]).
Reference: [Gurevich 88] <author> Gurevich,Y. </author> <title> Logic and the challenge of computer science. </title> <editor> in: E.Borger (Ed.), </editor> <booktitle> Trends in Theoretical Computer Science. </booktitle> <publisher> Computer Science Press, </publisher> <address> Rockville MA 1988, pp.1-57 </address>
Reference-contexts: Their natural formalization should then be based on local modifications, guarded by simple conditions. These two ideas are captured by the concept of evolving algebra, put forward by <ref> [Gurevich 88, Gurevich 91] </ref>. An evolving algebra is essentially a transition system with statics given by a (first order) signature, and dynamics given by transition rules which transform structures. Statically it is algebraic, and dynamically it is operational, so that modelling with evolving algebras can be termed `algebraic operational semantics'.
Reference: [Gurevich 91] <author> Gurevich,Y. </author> <title> Evolving Algebras. A Tutorial Introduction in: </title> <journal> Bulletin of the European Association for Theoretical Computer Science, </journal> <volume> no.43, </volume> <month> February </month> <year> 1991, </year> <pages> pp. 264-284 </pages>
Reference-contexts: Their natural formalization should then be based on local modifications, guarded by simple conditions. These two ideas are captured by the concept of evolving algebra, put forward by <ref> [Gurevich 88, Gurevich 91] </ref>. An evolving algebra is essentially a transition system with statics given by a (first order) signature, and dynamics given by transition rules which transform structures. Statically it is algebraic, and dynamically it is operational, so that modelling with evolving algebras can be termed `algebraic operational semantics'. <p> Last not least, our thanks go to Informatikzentrum 4 Schloss Dagstuhl, which has provided a splendid environment for our work on the final revision of the paper. 1 Evolving algebras The Prolog model constructed in this paper is an evolving algebra, which is a notion introduced by <ref> [Gurevich 91] </ref>. Since this notion is a mathematically rigorous form of fundamental operational intuitions of computing, the paper can be followed without any particular theoretical prerequisites. The reader who is not interested in foundational issues, might read our rules as `pseudocode over abstract data'. <p> and shrink in time|update forms are provided to extend a universe: extend A by t 1 ; : : : ; t n with updates endextend where updates may (and should) depend on t i 's, setting the values of some functions on newly created elements t i of A. <ref> [Gurevich 91] </ref> has however shown how to reduce such setups to the above basic model of a homogenous signature (with one universe) and function updates only (see also [Glavan,Rosenzweig 93]). <p> ask the user whether he wants alternative solutions: introduce a 0-ary function more solutions wanted with an additional rule if more solutions wanted &stop = Success then backtrack stop : = 0 Since we don't set its value, more solutions wanted would be an external function in the sense of <ref> [Gurevich 91] </ref>. <p> logic programming theory from Horn-clause logic to the real programming language. * There are strong grounds to maintain that the whole underlying framework of evolving algebras is logical in its essence|its semantics is the standard semantics of logic, structures interpreting a signature, as indicated in the Introduction (but see also <ref> [Gurevich 91, Glavan,Rosenzweig 93] </ref>). It is thus not accidental that assuming the core of the present model as a starting point has helped to reveal the logical structure of the WAM and some of its extension ([Borger,Rosenzweig 92, Beierle,Borger 92, Borger,Salamone 94]).
Reference: [Hoare 90] <author> L.A.R.Hoare, </author> <title> Preface to: VDM'90. VDM and Z Formal Methods in Software Development (D.Bjoerner, </title> <editor> L.A.R.Hoare, H.Langmaack, Eds.), </editor> <publisher> Springer LNCS 428, </publisher> <year> 1990 </year>
Reference-contexts: transparence needed can be achieved only if the methodology allows modelling on precisely the abstraction level of the language. 2 : : : the specification of requirements should be formulated from the beginning at the highest possible level of abstraction, using all the available power of mathematics : : : <ref> [Hoare 90, p.VII] </ref> This implies that basic concepts have to be expressed directly, without encoding, taking the objects of the language as abstract entities, such as they appear there. The methodology should thus make abstract data types freely available, i.e. abstract domains of objects with operations.
Reference: [Jones,Mycroft 84] <author> N.D.Jones, A.Mycroft, </author> <title> Stepwise development of operational and deno-tational semantics for Prolog. </title> <booktitle> In: Proc. Int.Symp. on Logic Programming 2/84, </booktitle> <address> Atlantic City, </address> <publisher> IEEE, </publisher> <pages> 289-298 </pages>
Reference: [Kok 90] <author> J.N.Kok, </author> <title> Specialization in logic programming: from Horn clause logic to Prolog and Concurrent Prolog. In: J.W.de Bakker,W.-P.de 26 Roever,G.Rozenberg (Eds.), Stepwise refinement of distributed sys-tems.Models, formalisms, correctness, </title> <publisher> Springer LNCS 430, </publisher> <year> 1990, </year> <pages> 401-413 </pages>
Reference: [Lindholm,O'Keefe 87] <author> T.G.Lindholm, R.A.O'Keefe, </author> <title> Efficient Implementation of a Defensible Semantics for Dynamic Prolog Code. </title> <booktitle> In: Proceedings of the Fourth International Conference on Logic Programming, </booktitle> <year> 1987, </year> <pages> 21-39 </pages>
Reference-contexts: Given the constraints, our rules don't specify any action in the case access to a clause for an abolished predicate is attempted|this falls under error handling, and will be discussed in section 6. The interpretation our rules give to database operations is that of so-called logical view <ref> [Lindholm,O'Keefe 87] </ref>|modifications of the database affect only subsequent calls, but the alternatives for current call remain as they were at time of call, by being copied into the tree structure by the appropriate call rule.
Reference: [Lloyd 87] <editor> J.Lloyd, </editor> <booktitle> Foundations of logic programming, </booktitle> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <note> second edition, </note> <year> 1987 </year>
Reference-contexts: The information relevant for determining a computation state will be associated to nodes by appropriate (in general partial) functions on the universe NODE . For each state we have to know the sequence of literals still to be called. Whereas in the definition of the SLD-tree <ref> [Lloyd 87, Apt 90] </ref> this sequence is depicted as flat, it seems closer to procedural intuition to keep it split into clause (procedure) bodies, preserving the structure of `procedure calling stack'. <p> Proof by induction over time of (number of rule executions preceeding) the first visit. Induction step follows immediately from selection rule together with the definitions of SLD-tree <ref> [Lloyd 87] </ref> and candidate clause. 12 Lemma 2. Given a pure Prolog program and a query, every abandoned node of the Prolog tree corresponds to a failed node of the SLD-tree. Proof by induction over time of abandonement.
Reference: [Lloyd 89] <author> J.Lloyd, </author> <title> Current Theoretical Issues in Logic Programming, </title> <note> Abstract. In: EATCS Bulletin 39, p.211 </note>
Reference-contexts: model for the latter, we hope to help reduce the : : : mismatch between theory and practice : : : that much of the theory of logic programming only applies to pure subsets of Prolog, whereas the extra-logical facilities of the language appear essential for it to be practical <ref> [Lloyd 89] </ref> This paper synthesizes, streamlines and considerably extends the work reported in preliminary papers [Borger 90a, Borger 90b, Borger 92, Borger,Rosenzweig 91a]. The paper is organized as follows. Section 1 introduces what is used of the underlying framework of evolving algebras.
Reference: [Martelli,Rossi 86] <editor> A.Martelli,G.Rossi, </editor> <booktitle> On the semantics of logic programing languages. In: Third Int.Conf. on Logic Programing, </booktitle> <address> London, 1986, </address> <publisher> Springer LNCS 225, </publisher> <pages> 327-334 </pages>
Reference: [Muller 93] <author> B.Muller, </author> <title> The Semantics for Hybrid Object-Oriented Prolog Systems, </title> <booktitle> Proc. IFIP Congress 1994 (to appear). </booktitle>
Reference-contexts: system [Borger,Salamone 94], where also the correct ness proof for the implementation could be uniformly extended from the WAM; * Prolog III|Prolog with constraints, [Borger,Schmitt 91]; * Babel|Prolog enriched with functional expressions, [BoLoRo 94]; * Parlog, Concurrent Prolog|concurrent logic programming languages, [Borger,Riccobene 93, Borger,Riccobene 92]; * object-oriented extension of Prolog <ref> [Muller 93] </ref>. It has also provided a framework for identifying and clarifying disputable language features and related implementation issues, such as the problem of semantics of dynamic database operations [Borger,Demoen 91, Borger,Rosenzweig 91b] and solution-collecting predicates [Borger,Rosenzweig 93].
Reference: [Nicholson,Foo 89] <author> T.Nicholson,N.Foo, </author> <title> A denotational semantics for Prolog. In: </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 11 </volume> <pages> 650-665, </pages> <month> Oc-tober </month> <year> 1989 </year>
Reference: [North 88] <author> N.North, </author> <title> A denotational definition of Prolog. </title> <institution> National Physics Laboratory, Teddington, </institution> <note> Report DITC 106/88 </note>
Reference: [O'Keefe 85] <author> R.O'Keefe, </author> <title> A formal definition of Prolog. </title> <institution> University of Auckland, BSI PS/22. </institution>
Reference-contexts: It is not at all clear whether or how any of these models could be extended to cover the full language. Attempts to cover the full language are far less numerous <ref> [Arbab,Berry 87, Deransart,Ferrand 92, O'Keefe 85] </ref>. These models are however neither primary nor transparent|they consist in technically involved reductions to some other formalism, which can hardly be understood as adequate expression of basic intuitions.
Reference: [Plotkin 81] <author> G.Plotkin, </author> <title> A structural approach to operational semantics, </title> <type> Internal Report, </type> <institution> CS Department, Aarhus University, DAIMI FN-19 </institution>
Reference-contexts: In the opposite direction, the fixed-point approach to dynamics could, from this perspective, be viewed as the limit case of an infinite basic step. In Plotkin's structural operational semantics <ref> [Plotkin 81] </ref> proof rules for basic actions directly reflect the syntactic structure of the program; thus SOS looses some of its nice `subformula properties' as soon as the language imposes a notion of basic action which is not so tightly coupled to the syntax.
Reference: [Quintus 87] <institution> Quintus Prolog Reference Manual, </institution> <note> version 10, February, 1987. </note> <institution> Quintus Computer Systems, </institution> <address> Mt.View, CA. </address>
Reference-contexts: All other error conditions, listed in [WG17 92], follow this straightforward pattern. 22 7 Box model Byrd's box model <ref> [Quintus 87] </ref> for debugging is usually explained along the following lines. When a goal is called, a box is created, which is immediately entered via its Call port. If the call is completed successfully, the box is left via its Exit port.
Reference: [Ross,Wilkie 90] <author> B.J.Ross,P.F.Wilkie, </author> <title> An algebraic semantics of sequential Prolog control. </title> <institution> University of Edinburgh, Department of AI, </institution> <note> DAI Research Paper 469 </note>
Reference: [Scott 70] <author> D.Scott, </author> <title> Outline of a Mathematical Theory of Computation, </title> <type> Technical Monograph PRG-2, </type> <month> November </month> <year> 1970, </year> <institution> Oxford University Comp.Lab., </institution> <note> Programming Res.Group, pg.1-24 </note>
Reference: [Scott,Strachey 71] <author> D.Scott, C.Strachey, </author> <title> Toward a Mathematical Semantics for Computer Languages, </title> <type> Technical Monograph PRG-6, </type> <month> August </month> <year> 1971, </year> <institution> Oxford University Comp.Lab., </institution> <note> Programming Res.Group, pg.1-42 </note>
Reference-contexts: An essential topic will be the discussion of the relation between the mathematical semantics for a language and the implementation of the language. What we claim the mathematics will have provided is the standard against which to judge an implemen tation. <ref> [Scott,Strachey 71, p.40] </ref> This paper provides a mathematical model for a real language, Prolog, as apparently intended by the draft standard proposal [WG17 92]. The model directly reflects the basic intuitions underlying the language, providing them with a mathematically rigorous yet simple formulation.
Reference: [Warren 83] <author> D.H.D.Warren, </author> <title> An Abstract Prolog Instruction Set, </title> <note> Technical Note 309, Artificial Intelligence Center, SRI International 1983. </note>
Reference-contexts: In fact, it is from the core of the present model that a mathematical reconstruction of a generally accepted implementation method for Prolog, the Warren Abstract Machine <ref> [Warren 83, Ait-Kaci 91] </ref>, was formally derived, and proved to execute Prolog correctly|with respect to the model|given explicit mathematical assumptions about the compiler [Borger,Rosenzweig 92].
Reference: [Wirsing 90] <author> M. Wirsing, </author> <title> Algebraic Specification, </title> <editor> in J. van Leeuwen (Ed.): </editor> <booktitle> Handbook of Theoretical Computer Science B, </booktitle> <publisher> Elsevier 1990, </publisher> <pages> pp. 675-788. </pages>
Reference-contexts: Simultaneous execution helps us avoid fussing and coding to, say, interchange two values. Since functions may be partial, equality in the guards is to be interpreted in the sense of `partial algebras' <ref> [Wirsing 90] </ref>, as implying that both arguments are defined (see also [Glavan,Rosenzweig 93]). More precisely, Definition. An evolving algebra is given by a finite set of transition rules.
Reference: [WG17 92] <author> PROLOG. </author> <title> Part 1, General Core, </title> <note> Committee Draft 1.0 , ISO/IEC JTC1 SC22 WG17 N.92, </note> <year> 1992 </year>
Reference-contexts: What we claim the mathematics will have provided is the standard against which to judge an implemen tation. [Scott,Strachey 71, p.40] This paper provides a mathematical model for a real language, Prolog, as apparently intended by the draft standard proposal <ref> [WG17 92] </ref>. The model directly reflects the basic intuitions underlying the language, providing them with a mathematically rigorous yet simple formulation. Since we are : : : concerned with bringing real theory to apply to real programming : : : [Bjoerner, Langmaack 90, p. <p> The converse of (i) is thus not true, while the converse of (ii) obviously is. 3 Control constructs and predicates Here we define, by rules, control constructs of Prolog|in fact all such constructs listed in the draft standard proposal <ref> [WG17 92] </ref>. The first part will treat those constructs which, upon failure, cannot be resatisfied (so-called `deterministic' constructs in Prolog jargon, what is not to be confused with the usual notion, under which all constructs of Prolog are deterministic). <p> Note that the function predicate list defines the order in which predicate indicators are found by current predicate; it may be considered as implementation dependent, as required by <ref> [WG17 92] </ref>. Given the constraints, our rules don't specify any action in the case access to a clause for an abolished predicate is attempted|this falls under error handling, and will be discussed in section 6. <p> The result of an attempt to call a syntactically legal user defined activator, which is however not in predicate list (cf. Section 4), should, according to standard proposal <ref> [WG17 92] </ref>, depend on the value of undefined predicate flag: if is user defined (act ) & mode = Call & procdef (act ; db) = nil thenif undefined predicate = error then error : = undefined predicate error else backtrack if undefined predicate = warning then warn where update warn <p> All other error conditions, listed in <ref> [WG17 92] </ref>, follow this straightforward pattern. 22 7 Box model Byrd's box model [Quintus 87] for debugging is usually explained along the following lines. When a goal is called, a box is created, which is immediately entered via its Call port.
References-found: 47

