URL: http://www.cs.berkeley.edu/~aiken/papers/tic98.ps
Refering-URL: http://www.cs.berkeley.edu/Research/Aiken/bane.html
Root-URL: 
Title: A Toolkit for Constructing Type- and Constraint-Based Program Analyses  
Author: Alexander Aiken, Manuel Fahndrich, Jeffrey S. Foster, Zhendong Su 
Address: Berkeley  
Affiliation: University of California,  
Abstract: BANE (the Berkeley Analysis Engine) is a publicly available toolkit for constructing type- and constraint-based program analyses. 1 We describe the goals of the project, the rationale for BANE's overall design, some examples coded in BANE, and briefly compare BANE with other program analysis frameworks.
Abstract-found: 1
Intro-found: 1
Reference: [AFS98] <author> A. Aiken, M. Fahndrich, and Z. Su. </author> <title> Detecting Races in Relay Ladder Logic Programs. In Tools and Algorithms for the Construction and Analysis of Systems, </title> <booktitle> 4th International Conference, TACAS'98, volume 1384 of LNCS, </booktitle> <pages> pages 184-200, </pages> <address> Lisbon, Portugal, 1998. </address> <publisher> Springer. </publisher>
Reference: [AM95] <author> M. Alt and F. Martin. </author> <title> Generation of efficient interprocedural analyzers with PAG. </title> <booktitle> Lecture Notes in Computer Science, </booktitle> <volume> 983 </volume> <pages> 33-50, </pages> <year> 1995. </year>
Reference-contexts: In previous frameworks the user specifies a lattice and a set of transfer func-tions, either in a specialized language <ref> [AM95] </ref>, in a Yacc-like system [TH92], or as a module conforming to a certain interface [ATGL96,CDG96,DC96,HMCCR93]. The framework traverses a program representation (usually a control flow graph) either forwards or backwards, calling user-defined transfer functions until the analysis reaches a fixed point.
Reference: [And94] <author> L. Andersen. </author> <title> Program Analysis and Specialization for the C Programming Language. </title> <type> PhD thesis, </type> <institution> DIKU, University of Cophenhagen, </institution> <month> May </month> <year> 1994. </year>
Reference: [Ass96] <author> U. Assmann. </author> <title> How to Uniformly Specify Program Analysis and Transformation with Graph Rewrite Systems. </title> <booktitle> In Proceedings of the Sixth International Conference on Compiler Construction (CC '96), </booktitle> <pages> pages 121-135. </pages> <publisher> Springer-Verlag, </publisher> <month> April </month> <year> 1996. </year>
Reference: [ATGL96] <author> A. Adl-Tabatabai, T. Gross, and G. Lueh. </author> <title> Code Reuse in an Optimizing Compiler. </title> <booktitle> In Proceedings of the ACM Conference on Object-Oriented Programming Systems, Languages, and Applications (OOPSLA '96), </booktitle> <pages> pages 51-68, </pages> <month> October </month> <year> 1996. </year>
Reference: [AW93] <author> A. Aiken and E. Wimmers. </author> <title> Type Inclusion Constraints and Type Inference. </title> <booktitle> In Proceedings of the 1993 Conference on Functional Programming Languages and Computer Architecture, </booktitle> <pages> pages 31-41, </pages> <address> Copenhagen, Den-mark, </address> <month> June </month> <year> 1993. </year>
Reference: [AWL94] <author> A. Aiken, E. Wimmers, </author> <title> and T.K. Lakshman. Soft Typing with Conditional Types. </title> <booktitle> In Twenty-First Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 163-173, </pages> <month> January </month> <year> 1994. </year>
Reference: [CC77] <author> P. Cousot and R. Cousot. </author> <title> Abstract Interpretation: A Unified Lattice Model for Static Analysis of Programs by Contruction or Approximation of Fixed Points. </title> <booktitle> In Fourth Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 238-252, </pages> <month> January </month> <year> 1977. </year>
Reference: [CDG96] <author> C. Chambers, J. Dean, and D. Grove. </author> <title> Frameworks for Intra- and Inter-procedural Dataflow Analysis. </title> <type> Technical Report 96-11-02, </type> <institution> Department of Computer Science and Engineering, University of Washington, </institution> <month> November </month> <year> 1996. </year>
Reference: [Coc70] <author> J. Cocke. </author> <title> Global Common Subexpression Elimination. </title> <journal> ACM SIGPLAN Notices, </journal> <volume> 5(7) </volume> <pages> 20-24, </pages> <month> July </month> <year> 1970. </year>
Reference-contexts: There have been many such frameworks in the past; see for example [ATGL96,AM95,Ass96,CDG96,DC96,HMCCR93,TH92,Ven89,YH93]. Most frameworks are based on standard dataflow analysis, as first proposed by Cocke <ref> [Coc70] </ref> and developed by Kildall [Kil73] and Kam and Ullman [KU76], while others are based on more general forms of abstract interpretation [Ven89,YH93].
Reference: [DC96] <author> M. Dwyer and L. Clarke. </author> <title> A Flexible Architecture for Building Data Flow Analyzers. </title> <booktitle> In Proceedings of the 18th International Conference on Software Engineering (ICSE-18), </booktitle> <address> Berlin, Germany, </address> <month> March </month> <year> 1996. </year>
Reference: [DM82] <author> L. Damas and R. Milner. </author> <title> Principle Type-Schemes for Functional Programs. </title> <booktitle> In Ninth Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 207-212, </pages> <month> January </month> <year> 1982. </year>
Reference: [EST95] <author> J. Eifrig, S. Smith, and V. Trifonov. </author> <title> Sound Polymorphic Type Inference for Objects. </title> <booktitle> In OOPSLA '95, </booktitle> <pages> pages 169-184, </pages> <year> 1995. </year>
Reference: [FA96] <author> M. Fahndrich and A. Aiken. </author> <title> Making Set-Constraint Based Program Analyses Scale. </title> <booktitle> In First Workshop on Set Constraints at CP'96, </booktitle> <address> Cambridge, MA, </address> <month> August </month> <year> 1996. </year> <note> Available as Technical Report CSD-TR-96-917, </note> <institution> University of California at Berkeley. </institution>
Reference: [FA97] <author> M. Fahndrich and A. Aiken. </author> <title> Program Analysis Using Mixed Term and Set Constraints. </title> <booktitle> In Proceedings of the 4th International Static Analysis Symposium, </booktitle> <pages> pages 114-126, </pages> <year> 1997. </year>
Reference-contexts: This idea has been described in the context of control-flow analysis in [HM97], for a more general flow analysis in [Mos96], and for more general set expressions in <ref> [FA97] </ref>. A subtype-based analysis where sets are embedded within terms can be realized in BANE through the use of the FlowTerm sort. The FlowTerm sort provides inclusion constraints instead of equality for the same language and solution space as the Term sort.
Reference: [FFA97] <author> J. Foster, M. Fahndrich, and A. Aiken. </author> <title> Flow-Insensitive Points-to Analysis with Term and Set Constraints. </title> <type> Technical Report UCB//CSD-97-964, </type> <institution> University of California, Berkeley, </institution> <month> July </month> <year> 1997. </year>
Reference: [FFA98] <author> M. Fahndrich, J. Foster, and A. Aiken. </author> <title> Tracking down Exceptions in Standard ML Programs. </title> <type> Technical Report UCB/CSD-98-996, </type> <institution> EECS Department, UC Berkeley, </institution> <month> February </month> <year> 1998. </year>
Reference: [FFK + 96] <author> C. Flanagan, M. Flatt, S. Krishnamurthi, S. Weirich, and M. Felleisen. </author> <title> Catching Bugs in the Web of Program Invariants. </title> <booktitle> In Proceedings of the 1996 ACM SIGPLAN Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 23-32, </pages> <month> May </month> <year> 1996. </year>
Reference: [FFSA98] <author> M. Fahndrich, J. Foster, Z. Su, and A. Aiken. </author> <title> Partial Online Cycle Elimination in Inclusion Constraint Graphs. </title> <booktitle> In Proceedings of the ACM SIG-PLAN '98 Conference on Programming Language Design and Implementation, </booktitle> <year> 1998. </year>
Reference: [GJSO92] <author> D. Gifford, P. Jouvelot, M. Sheldon, and J. O'Toole. </author> <title> Report on the FX-91 Programming Language. </title> <type> Technical Report MIT/LCS/TR-531, </type> <institution> Mas-sachusetts Institute of Technology, </institution> <month> February </month> <year> 1992. </year>
Reference: [Hei94] <author> N. Heintze. </author> <title> Set Based Analysis of ML Programs. </title> <booktitle> In Proceedings of the 1994 ACM Conference on LISP and Functional Programming, </booktitle> <pages> pages 306-17, </pages> <month> June </month> <year> 1994. </year>
Reference: [Hen92] <author> F. Henglein. </author> <title> Global Tagging Optimization by Type Inference. </title> <booktitle> In Proceedings of the 1992 ACM Conference on Lisp and Functional Programming, </booktitle> <pages> pages 205-215, </pages> <month> July </month> <year> 1992. </year>
Reference: [HM97] <author> N. Heintze and D. McAllester. </author> <title> Linear-Time Subtransitive Control Flow Analysis. </title> <booktitle> In Proceedings of the 1997 ACM SIGPLAN Conference on Programming Language Design and Implementation, </booktitle> <month> June </month> <year> 1997. </year>
Reference-contexts: This approximation can be overcome through the use of subtyping. 3.3 Type Inference with Flow Information and Subtyping The inclusion relation on label-sets embedded within types can be lifted to a natural subtyping relation on structural types. This idea has been described in the context of control-flow analysis in <ref> [HM97] </ref>, for a more general flow analysis in [Mos96], and for more general set expressions in [FA97]. A subtype-based analysis where sets are embedded within terms can be realized in BANE through the use of the FlowTerm sort.
Reference: [HMCCR93] <author> M. Hall, J. Mellor-Crummey, A. Carle, and R. Rodrguez. FIAT: </author> <title> A Framework for Interprocedural Analysis and Transformation. </title> <editor> In U. Baner-jee, D. Gelernter, A. Nicolau, and D. Padua, editors, </editor> <booktitle> Proceedings of the 6th International Workshop on Parallel Languages and Compilers, </booktitle> <pages> pages 522-545, </pages> <address> Portland, Oregon, </address> <month> August </month> <year> 1993. </year> <note> Springer-Verlag. </note>
Reference: [Kil73] <author> G. A. Kildall. </author> <title> A Unified Approach to Global Program Optimization. </title> <booktitle> In ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 194-206, </pages> <address> Boston, MA, </address> <month> October </month> <year> 1973. </year> <note> ACM, ACM. </note>
Reference-contexts: There have been many such frameworks in the past; see for example [ATGL96,AM95,Ass96,CDG96,DC96,HMCCR93,TH92,Ven89,YH93]. Most frameworks are based on standard dataflow analysis, as first proposed by Cocke [Coc70] and developed by Kildall <ref> [Kil73] </ref> and Kam and Ullman [KU76], while others are based on more general forms of abstract interpretation [Ven89,YH93].
Reference: [KU76] <author> J. Kam and J. Ullman. </author> <title> Global Data Flow Analysis and Iterative Algorithms. </title> <journal> Journal of the ACM, </journal> <volume> 23(1) </volume> <pages> 158-171, </pages> <month> January </month> <year> 1976. </year>
Reference-contexts: There have been many such frameworks in the past; see for example [ATGL96,AM95,Ass96,CDG96,DC96,HMCCR93,TH92,Ven89,YH93]. Most frameworks are based on standard dataflow analysis, as first proposed by Cocke [Coc70] and developed by Kildall [Kil73] and Kam and Ullman <ref> [KU76] </ref>, while others are based on more general forms of abstract interpretation [Ven89,YH93]. In previous frameworks the user specifies a lattice and a set of transfer func-tions, either in a specialized language [AM95], in a Yacc-like system [TH92], or as a module conforming to a certain interface [ATGL96,CDG96,DC96,HMCCR93].
Reference: [Mos96] <author> Christian Mossin. </author> <title> Flow Analysis of Typed Higher-Order Programs. </title> <type> PhD thesis, </type> <institution> DIKU, Department of Computer Science, University of Copen-hagen, </institution> <year> 1996. </year>
Reference-contexts: The use of equality constraints may cause undesired approximations in the flow information. Consider an example taken from Section 3.1 of Mossin's thesis <ref> [Mos96] </ref> select = select x: sel 1 y: sel 2 f:if x then f x else f y The select function takes three arguments, x, y, and z, and depending on the truth value of x, returns the result of applying f to either x or y. <p> This idea has been described in the context of control-flow analysis in [HM97], for a more general flow analysis in <ref> [Mos96] </ref>, and for more general set expressions in [FA97]. A subtype-based analysis where sets are embedded within terms can be realized in BANE through the use of the FlowTerm sort. The FlowTerm sort provides inclusion constraints instead of equality for the same language and solution space as the Term sort.
Reference: [MTH90] <author> Robin Milner, Mads Tofte, and Robert Harper. </author> <title> The Definition of Standard ML. </title> <publisher> MIT Press, </publisher> <year> 1990. </year>
Reference: [Rem89] <author> D. Remy. </author> <title> Typechecking records and variants in a natural extension of ML. </title> <booktitle> In Conference Record of the Sixteenth Annual ACM Symposium on Principles of Programming Languages, </booktitle> <address> Austin, Texas, </address> <pages> pages 60-76, </pages> <month> January </month> <year> 1989. </year>
Reference: [Ste96] <author> B. Steensgaard. </author> <title> Points-to Analysis in Almost Linear Time. </title> <booktitle> In Proceedings of the 23rd Annual ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages, </booktitle> <pages> pages 32-41, </pages> <month> January </month> <year> 1996. </year>
Reference: [TH92] <author> S. Tjiang and J. Hennessy. </author> <title> Sharlit A tool for building optimizers. </title> <booktitle> In Proceedings of the ACM SIGPLAN '92 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 82-93, </pages> <month> July </month> <year> 1992. </year>
Reference-contexts: In previous frameworks the user specifies a lattice and a set of transfer func-tions, either in a specialized language [AM95], in a Yacc-like system <ref> [TH92] </ref>, or as a module conforming to a certain interface [ATGL96,CDG96,DC96,HMCCR93]. The framework traverses a program representation (usually a control flow graph) either forwards or backwards, calling user-defined transfer functions until the analysis reaches a fixed point.
Reference: [TT94] <author> M. Tofte and J.-P. Talpin. </author> <title> Implementation of the Typed Call-by-Value -Calculus using a Stack of Regions. </title> <booktitle> In Twenty-First Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 188-201, </pages> <year> 1994. </year>
Reference: [Ven89] <author> G. A. Venkatesh. </author> <title> A framework for construction and evaluation of high-level specifications for program analysis techniques. </title> <booktitle> In Proceedings of the ACM SIGPLAN '89 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 1-12, </pages> <year> 1989. </year>
Reference: [YH93] <author> K. Yi and W. Harrison, III. </author> <title> Automatic Generation and Management of Interprocedural Program Analyses. </title> <booktitle> In Proceedings of the Twnetieth Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 246-259, </pages> <month> January </month> <year> 1993. </year>
References-found: 34

