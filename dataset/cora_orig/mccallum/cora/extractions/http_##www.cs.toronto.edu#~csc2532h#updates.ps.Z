URL: http://www.cs.toronto.edu/~csc2532h/updates.ps.Z
Refering-URL: http://www.cs.toronto.edu/~csc2532h/
Root-URL: http://www.cs.toronto.edu
Email: email: reiter@ai.toronto.edu  
Title: ON SPECIFYING DATABASE UPDATES  
Author: RAYMOND REITER 
Address: Toronto, Canada M5S 1A4  655 Avenue of the Americas, New York, NY 10010 0743-1066/94/$7.00  
Affiliation: Department of Computer Science University of Toronto  
Date: 1994:19, 20:1-679 1  
Note: J. LOGIC PROGRAMMING  Address correspondence to  THE JOURNAL OF LOGIC PROGRAMMING c Elsevier Science Inc., 1994  
Abstract: We address the problem of formalizing the evolution of a database under the effect of an arbitrary sequence of update transactions. We do so by appealing to a first order representation language called the situation calculus, which is a standard approach in artificial intelligence to the formalization of planning problems. We formalize database transactions in exactly the same way as actions in the artificial intelligence planning domain. This leads to a database version of the frame problem in artificial intelligence. We provide a solution to the frame problem for a special, but substantial, class of update transactions. Using the axioms corresponding to this solution, we provide procedures for determining whether a given sequence of update transactions is legal, and for query evaluation in an updated database. These procedures have the nice property that they appeal to theorem-proving only with respect to the initial database state. We next address the problem of proving properties true in all states of the database. It turns out that mathematical induction is required for this task, and we formulate a number of suitable induction principles. Among those properties of database states that we wish to prove are the standard database notions of static and dynamic integrity constraints. In our setting, these emerge as inductive entailments of the database. Finally, we discuss various possible extensions of the approach of this paper, including transaction logs and historical queries, the complexity of query evaluation, actualized transactions, logic programming approaches to updates, database views and state constraints. / This paper consolidates and expands on a variety of results, some of which have been described elsewhere (Reiter [46, 45, 44]). 
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> S. Abiteboul. </author> <title> Updates, a new frontier. </title> <booktitle> In Second International Conference on Database Theory, </booktitle> <pages> pages 1-18. </pages> <publisher> Springer, </publisher> <year> 1988. </year>
Reference-contexts: 1. INTRODUCTION Our concern in this paper is with formalizing the evolution of a database under arbitrary sequences of update transactions. A wide variety of proposals for this exist in the literature (e.g. Abiteboul <ref> [1] </ref>, Grahne [13], Katsuno and Mendelzon [20], Winslett [48], Fagin, Ullman and Vardi [10], Ginsberg and Smith [12], Guessoum and Lloyd [16, 17], Manchanda and Warren [32], Kowalski [22], Bonner and Kifer [6].). In this paper, we advance a substantially different approach. <p> In such cases, it may be profitable to view a transaction as a mapping from one static database to another, in the style of Abiteboul <ref> [1] </ref>. From this perspective, a database transaction can be implemented as a physical modification of the current database to yield the updated database which actualizes the transaction. In the case of relational databases, such transactions are normally actualized by suitable insertions/deletions of tuples into/from the relational tables of the database. <p> This idea that transactions are mappings from static databases to static databases is intuitively very appealing; indeed, it informs many approaches to database updates in the literature (e.g. Abiteboul <ref> [1] </ref>, Bonner and Kifer [6], Fagin, Ullman and Vardi [10], Ginsberg and Smith [12], Guessoum and Lloyd [16, 17], Kakas and Mancarella [19]). Surprisingly, this idea is not as simple as it appears on the surface. <p> We here present a brief comparison with representatives of what we take to be the principal competing logical perspectives on formalizing database updates. We do not consider procedurally oriented approaches (such as Abiteboul <ref> [1] </ref>). Logical Status of Database States In the situation calculus, states are first class citizens over which one can quantify. Quantification over states in the situation calculus amounts to quantification over sequences of transactions.
Reference: 2. <author> S. Abiteboul and V. Vianu. </author> <title> A transaction-based approach to relational database specification. </title> <journal> Journal of the ACM, </journal> <volume> 36 </volume> <pages> 759-789, </pages> <year> 1989. </year>
Reference-contexts: We made extensive use of this property of the situation calculus in our analysis of historical queries (Section 7.1). 32 Transaction-Centred vs. Update-Centred Theories of Updates Like the work of Abiteboul and Vianu <ref> [2] </ref>, our approach to a theory of updates is transaction-centred, meaning that an update is possible only when the database provides for a suitable prespecified transaction corresponding to the desired update.
Reference: 3. <author> C.E. Alchourron, P. Gardenfors, and D. Makinson. </author> <title> On the logic of theory change: partial meet contraction and revision functions. </title> <journal> Journal of Symbolic Logic, </journal> <volume> 50 </volume> <pages> 510-530, </pages> <year> 1985. </year>
Reference-contexts: To formally capture this distinction, they propose a set of update postulates which differ from, but are in the same style as, the AGM postulates for revision (Alchourron, Gardenfors and Makinson <ref> [3] </ref>). With respect to the above example, recording a marriage transaction corresponds to an update, while simply recording the fact that John is married corresponds to a revision. For a further discussion of this distinction, see Section 7. <p> To formally capture this distinction, they propose a set of update postulates which differ from, but are in the same style as, the AGM postulates for revision (Alchourron, Gardenfors and Makinson <ref> [3] </ref>). For Keller-Winslett and Katsuno-Mendelzon, updates differ from revisions in that the former result from event occurrences which change the state of the world, while the latter result from changes in our theory of what a static world is really like.
Reference: 4. <author> A. Baker. </author> <title> A simple solution to the Yale shooting problem. </title> <editor> In R. Brachman, H.J. Levesque, and R. Reiter, editors, </editor> <booktitle> Proceedings of the First International Conference on Principles of Knowledge Representation and Reasoning (KR'89), </booktitle> <pages> pages 11-20. </pages> <publisher> Morgan Kaufmann Publishers, Inc., </publisher> <year> 1989. </year>
Reference-contexts: transaction preconditions be embodied in the transaction precondition axioms so as to guarantee that the constraint will be an inductive entailment of the database? A variety of circumscriptive proposals for addressing these problems (in conjunction with the frame problem) have been proposed in the artificial intelligence literature, notably by Baker <ref> [4] </ref>, Baker and Ginsberg [5], Ginsberg and Smith [12], Lifschitz [26] and Lin and Shoham [30]. Our formulation of the problem in terms of inductive entailments of the database appears to be new.
Reference: 5. <author> A. Baker and M. Ginsberg. </author> <title> Temporal projection and explanation. </title> <booktitle> In Proceedings of the Eleventh International Joint Conference on Artificial Intelligence, </booktitle> <pages> pages 906-911, </pages> <address> Detroit, MI, </address> <year> 1989. </year>
Reference-contexts: in the transaction precondition axioms so as to guarantee that the constraint will be an inductive entailment of the database? A variety of circumscriptive proposals for addressing these problems (in conjunction with the frame problem) have been proposed in the artificial intelligence literature, notably by Baker [4], Baker and Ginsberg <ref> [5] </ref>, Ginsberg and Smith [12], Lifschitz [26] and Lin and Shoham [30]. Our formulation of the problem in terms of inductive entailments of the database appears to be new.
Reference: 6. <author> A. Bonner and M. Kifer. </author> <title> Transaction logic programming. </title> <type> Technical report, </type> <institution> Department of Computer Science, University of Toronto, </institution> <year> 1992. </year>
Reference-contexts: A wide variety of proposals for this exist in the literature (e.g. Abiteboul [1], Grahne [13], Katsuno and Mendelzon [20], Winslett [48], Fagin, Ullman and Vardi [10], Ginsberg and Smith [12], Guessoum and Lloyd [16, 17], Manchanda and Warren [32], Kowalski [22], Bonner and Kifer <ref> [6] </ref>.). In this paper, we advance a substantially different approach. <p> This idea that transactions are mappings from static databases to static databases is intuitively very appealing; indeed, it informs many approaches to database updates in the literature (e.g. Abiteboul [1], Bonner and Kifer <ref> [6] </ref>, Fagin, Ullman and Vardi [10], Ginsberg and Smith [12], Guessoum and Lloyd [16, 17], Kakas and Mancarella [19]). Surprisingly, this idea is not as simple as it appears on the surface. <p> As currently developed, our proposal does not provide a mechanism for defining complex transactions. In contrast, such proposals do exist, notably by Machanda and Warren [32]), based on dynamic logic in the logic programming context, and by Bonner and Kifer <ref> [6] </ref>, based on a new logic specifically tailored to transactions. The latter theory is especially interesting for its rich repertoire of operators for defining new transactions in terms of old. These include sequence, nondeterministic choice, conditionals and iteration. <p> Classical vs. Other Logics Unlike proposals based on modal logics, e.g. dynamic logic (Manchanda and Warren [32]) or temporal logic (Casanova and Furtado [8]), or specially tailored logics, e.g. (Bonner and Kifer <ref> [6] </ref>), ours is based on first order logic (with a second order induction principle). This has the advantage of an established, well understood semantics and proof theory, and it meshes well with the standard perspective of a (static) database as a special kind of first order theory.
Reference: 7. <author> A. Borgida, J. Mylopoulos, and J. Schmidt. </author> <title> The TaxisDL software description language. </title> <type> Technical report, </type> <institution> Department of Computer Science, University of Toronto, </institution> <year> 1991. </year>
Reference-contexts: The frame problem has been recognized in the setting of database transaction processing, notably by Kowalski [22] and Borgida, Mylopoulos and Schmidt <ref> [7] </ref>. It is also implicit in various semantic approaches to database updates (but without appealing explicitly to transactions) such as the work of Grahne [13], Katsuno and Mendelzon [20], Grahne, Mendelzon and Revesz ([14]) and Winslett [48].
Reference: 8. <author> M.A. Casanova and A.L. Furtado. </author> <title> A family of temporal languages for the description of transition constraints. </title> <editor> In H. Gallaire, J. Minker, and J.M. Nicolas, editors, </editor> <booktitle> Advances in Database Theory, </booktitle> <volume> volume 2, </volume> <pages> pages 211-238. </pages> <publisher> Plenum Press, </publisher> <address> New York, </address> <year> 1984. </year> <month> 37 </month>
Reference-contexts: An Example of Casanova and Furtado <ref> [8] </ref> Suppose no one who has been fired can ever be rehired: P oss (hire (p); s) j :trans (fire (p); s) ^ :emp (p; s): (6.5) 19 Intuitively, trans (a; s) means that the transaction a is part of the transaction sequence leading from S 0 to s. <p> This makes historical queries possible (Section 7.1), and provides for a theory of integrity constraints (Section 6.1). This is impossible or extremely awkward to do within the logic for those approaches to updates formalized in modal logics e.g. dynamic logic, Manchanda and Warren [32], temporal logic, Casanova and Furtado <ref> [8] </ref>), or in "path-based" logics (e.g. Bonner and Kifer), for which there is only an implicit notion of state. <p> For an extension of the situation calculus to provide for complex transactions along the lines of Bonner and Kifer, see (Levesque, Lin and Reiter [25]). Classical vs. Other Logics Unlike proposals based on modal logics, e.g. dynamic logic (Manchanda and Warren [32]) or temporal logic (Casanova and Furtado <ref> [8] </ref>), or specially tailored logics, e.g. (Bonner and Kifer [6]), ours is based on first order logic (with a second order induction principle).
Reference: 9. <author> K.L. Clark. </author> <title> Negation as failure. </title> <editor> In H. Gallaire and J. Minker, editors, </editor> <booktitle> Logic and Data Bases, </booktitle> <pages> pages 292-322. </pages> <publisher> Plenum Press, </publisher> <address> New York, </address> <year> 1978. </year>
Reference-contexts: The remaining problem is to characterize what these conditions are, and to prove correctness of such an implementation with respect to the logical specification of this paper. In this connection, notice that the equivalences in the successor state and transaction precondition axioms are reminiscent of Clark's <ref> [9] </ref> completion semantics for logic programs, and our unique names axioms for states and transactions provide part of the equality theory required for Clark's semantics (Lloyd [31], pp.79, 109). 12 We have here invoked some of the program transformation rules of (Lloyd [31], p.113) to convert the non-clausal formula [(8g 0
Reference: 10. <author> R. Fagin, J.D. Ullman, and M.Y. Vardi. </author> <title> Updating logical databases. </title> <booktitle> In Proceedings of the ACM Symposium on Principles of Database Systems, </booktitle> <month> April </month> <year> 1983. </year>
Reference-contexts: 1. INTRODUCTION Our concern in this paper is with formalizing the evolution of a database under arbitrary sequences of update transactions. A wide variety of proposals for this exist in the literature (e.g. Abiteboul [1], Grahne [13], Katsuno and Mendelzon [20], Winslett [48], Fagin, Ullman and Vardi <ref> [10] </ref>, Ginsberg and Smith [12], Guessoum and Lloyd [16, 17], Manchanda and Warren [32], Kowalski [22], Bonner and Kifer [6].). In this paper, we advance a substantially different approach. <p> This idea that transactions are mappings from static databases to static databases is intuitively very appealing; indeed, it informs many approaches to database updates in the literature (e.g. Abiteboul [1], Bonner and Kifer [6], Fagin, Ullman and Vardi <ref> [10] </ref>, Ginsberg and Smith [12], Guessoum and Lloyd [16, 17], Kakas and Mancarella [19]). Surprisingly, this idea is not as simple as it appears on the surface. <p> A wide variety of update proposals in the literature are not transaction-centred; they provide for updates of a database with arbitrary sentences (e.g. the model theoretic approaches of Grahne [13], Katsuno and Mendelzon [20], Grahne, Mendelzon and Revesz ([14]) or Winslett [48], the syntactic approaches of Fagin, Ullman and Vardi <ref> [10] </ref> or Ginsberg and Smith [12], and the abductive approaches of Guessoum and Lloyd [16, 17] or Kakas and Mancarella [19]). In this respect, such proposals are more general than ours, but this generality comes at a price.
Reference: 11. <author> J. </author> <title> Finger. Exploiting Constraints in Design Synthesis. </title> <type> PhD thesis, </type> <institution> Stanford University, Stanford, </institution> <address> CA, </address> <year> 1986. </year>
Reference-contexts: The example illustrates the subtleties involved in getting the successor state and/or transaction precondition axioms to reflect the intent of a state constraint. These difficulties are a manifestation of the so-called ramification (Finger <ref> [11] </ref>) and qualification (McCarthy [34]) problems in artificial intelligence planning domains. Transactions might have ramifications, or indirect effects.
Reference: 12. <author> M.L. Ginsberg and D.E. Smith. </author> <title> Reasoning about actions I: A possible worlds approach. </title> <journal> Artificial Intelligence, </journal> <volume> 35 </volume> <pages> 165-195, </pages> <year> 1988. </year>
Reference-contexts: A wide variety of proposals for this exist in the literature (e.g. Abiteboul [1], Grahne [13], Katsuno and Mendelzon [20], Winslett [48], Fagin, Ullman and Vardi [10], Ginsberg and Smith <ref> [12] </ref>, Guessoum and Lloyd [16, 17], Manchanda and Warren [32], Kowalski [22], Bonner and Kifer [6].). In this paper, we advance a substantially different approach. <p> This idea that transactions are mappings from static databases to static databases is intuitively very appealing; indeed, it informs many approaches to database updates in the literature (e.g. Abiteboul [1], Bonner and Kifer [6], Fagin, Ullman and Vardi [10], Ginsberg and Smith <ref> [12] </ref>, Guessoum and Lloyd [16, 17], Kakas and Mancarella [19]). Surprisingly, this idea is not as simple as it appears on the surface. <p> axioms so as to guarantee that the constraint will be an inductive entailment of the database? A variety of circumscriptive proposals for addressing these problems (in conjunction with the frame problem) have been proposed in the artificial intelligence literature, notably by Baker [4], Baker and Ginsberg [5], Ginsberg and Smith <ref> [12] </ref>, Lifschitz [26] and Lin and Shoham [30]. Our formulation of the problem in terms of inductive entailments of the database appears to be new. <p> proposals in the literature are not transaction-centred; they provide for updates of a database with arbitrary sentences (e.g. the model theoretic approaches of Grahne [13], Katsuno and Mendelzon [20], Grahne, Mendelzon and Revesz ([14]) or Winslett [48], the syntactic approaches of Fagin, Ullman and Vardi [10] or Ginsberg and Smith <ref> [12] </ref>, and the abductive approaches of Guessoum and Lloyd [16, 17] or Kakas and Mancarella [19]). In this respect, such proposals are more general than ours, but this generality comes at a price. With the exception of [14], the model theoretic approaches are based on propositional databases.
Reference: 13. <author> G. Grahne. </author> <title> Updates and counterfactuals. </title> <editor> In J. Allen, R. Fikes, and E. Sande-wall, editors, </editor> <booktitle> Proceedings of the Second International Conference on Principles of Knowledge Representation and Reasoning (KR'91), </booktitle> <pages> pages 269-276, </pages> <address> Los Altos, CA, 1991. </address> <publisher> Morgan Kaufmann Publishers, Inc. </publisher>
Reference-contexts: 1. INTRODUCTION Our concern in this paper is with formalizing the evolution of a database under arbitrary sequences of update transactions. A wide variety of proposals for this exist in the literature (e.g. Abiteboul [1], Grahne <ref> [13] </ref>, Katsuno and Mendelzon [20], Winslett [48], Fagin, Ullman and Vardi [10], Ginsberg and Smith [12], Guessoum and Lloyd [16, 17], Manchanda and Warren [32], Kowalski [22], Bonner and Kifer [6].). In this paper, we advance a substantially different approach. <p> The frame problem has been recognized in the setting of database transaction processing, notably by Kowalski [22] and Borgida, Mylopoulos and Schmidt [7]. It is also implicit in various semantic approaches to database updates (but without appealing explicitly to transactions) such as the work of Grahne <ref> [13] </ref>, Katsuno and Mendelzon [20], Grahne, Mendelzon and Revesz ([14]) and Winslett [48]. Our approach differs from these semantic accounts in two ways: it explicitly provides for transactions, and it relies on an axiomatic treatment of the frame problem. <p> Thus, for transaction-centred databases, updates with arbitrary sentences are not permitted. A wide variety of update proposals in the literature are not transaction-centred; they provide for updates of a database with arbitrary sentences (e.g. the model theoretic approaches of Grahne <ref> [13] </ref>, Katsuno and Mendelzon [20], Grahne, Mendelzon and Revesz ([14]) or Winslett [48], the syntactic approaches of Fagin, Ullman and Vardi [10] or Ginsberg and Smith [12], and the abductive approaches of Guessoum and Lloyd [16, 17] or Kakas and Mancarella [19]).
Reference: 14. <author> G. Grahne, A.O. Mendelzon, and P. Revesz. </author> <title> Knowledgebase transformations. </title> <booktitle> In Proceedings of the ACM SIGACT-SIGMOD-SIGART Symposium on Principles of Database Systems, </booktitle> <pages> pages 246-260, </pages> <address> San Diego, CA, </address> <month> June 2-4, </month> <year> 1992. </year>
Reference-contexts: In this respect, such proposals are more general than ours, but this generality comes at a price. With the exception of <ref> [14] </ref>, the model theoretic approaches are based on propositional databases. Grahne, Mendelzon and Revesz ([14]) provide an account for first order models based on the Winslett ordering. Their account assumes that the set of all models of a first order theory is in hand.
Reference: 15. <author> C. C. Green. </author> <title> Theorem proving by resolution as a basis for question-answering systems. </title> <editor> In B. Meltzer and D. Michie, editors, </editor> <booktitle> Machine Intelligence 4, </booktitle> <pages> pages 183-205. </pages> <publisher> American Elsevier, </publisher> <address> New York, </address> <year> 1969. </year>
Reference-contexts: future, for example, given the current database state (which we shall take to be S 0 ) is it possible for J ohn ever to graduate? (9s):S 0 s ^ graduate (J ohn; s): 24 Answering queries of this form is precisely the problem of plan synthesis in AI (Green <ref> [15] </ref>). Moreover, from a constructive proof of such a query, one can obtain a sequence of transactions leading to a state in which the query is true.
Reference: 16. <author> A. Guessoum and J.W. Lloyd. </author> <title> Updating knowledge bases. </title> <journal> New Generation Computing, </journal> <volume> 8(1) </volume> <pages> 71-89, </pages> <year> 1990. </year>
Reference-contexts: A wide variety of proposals for this exist in the literature (e.g. Abiteboul [1], Grahne [13], Katsuno and Mendelzon [20], Winslett [48], Fagin, Ullman and Vardi [10], Ginsberg and Smith [12], Guessoum and Lloyd <ref> [16, 17] </ref>, Manchanda and Warren [32], Kowalski [22], Bonner and Kifer [6].). In this paper, we advance a substantially different approach. <p> This idea that transactions are mappings from static databases to static databases is intuitively very appealing; indeed, it informs many approaches to database updates in the literature (e.g. Abiteboul [1], Bonner and Kifer [6], Fagin, Ullman and Vardi [10], Ginsberg and Smith [12], Guessoum and Lloyd <ref> [16, 17] </ref>, Kakas and Mancarella [19]). Surprisingly, this idea is not as simple as it appears on the surface. <p> for updates of a database with arbitrary sentences (e.g. the model theoretic approaches of Grahne [13], Katsuno and Mendelzon [20], Grahne, Mendelzon and Revesz ([14]) or Winslett [48], the syntactic approaches of Fagin, Ullman and Vardi [10] or Ginsberg and Smith [12], and the abductive approaches of Guessoum and Lloyd <ref> [16, 17] </ref> or Kakas and Mancarella [19]). In this respect, such proposals are more general than ours, but this generality comes at a price. With the exception of [14], the model theoretic approaches are based on propositional databases. <p> Inadvertantly omitting one such effect, or proposing an inappropriate one, will leave the database in an intuitively incorrect state with respect to the world being 17 This use of abduction for inferring event occurrences is quite different than the abductive approaches to updates advocated by Guessoum and Lloyd <ref> [16, 17] </ref> and Kakas and Mancarella [19]. 34 modeled, even though, insofar as the database update mechanism is concerned, everything is fine. The source of the problem is clear: the database has no knowledge of events and their effects.
Reference: 17. <author> A. Guessoum and J.W. Lloyd. </author> <title> Updating knowledge bases II. </title> <type> Technical report, </type> <institution> University of Bristol, </institution> <year> 1991. </year> <note> To appear. </note>
Reference-contexts: A wide variety of proposals for this exist in the literature (e.g. Abiteboul [1], Grahne [13], Katsuno and Mendelzon [20], Winslett [48], Fagin, Ullman and Vardi [10], Ginsberg and Smith [12], Guessoum and Lloyd <ref> [16, 17] </ref>, Manchanda and Warren [32], Kowalski [22], Bonner and Kifer [6].). In this paper, we advance a substantially different approach. <p> This idea that transactions are mappings from static databases to static databases is intuitively very appealing; indeed, it informs many approaches to database updates in the literature (e.g. Abiteboul [1], Bonner and Kifer [6], Fagin, Ullman and Vardi [10], Ginsberg and Smith [12], Guessoum and Lloyd <ref> [16, 17] </ref>, Kakas and Mancarella [19]). Surprisingly, this idea is not as simple as it appears on the surface. <p> for updates of a database with arbitrary sentences (e.g. the model theoretic approaches of Grahne [13], Katsuno and Mendelzon [20], Grahne, Mendelzon and Revesz ([14]) or Winslett [48], the syntactic approaches of Fagin, Ullman and Vardi [10] or Ginsberg and Smith [12], and the abductive approaches of Guessoum and Lloyd <ref> [16, 17] </ref> or Kakas and Mancarella [19]). In this respect, such proposals are more general than ours, but this generality comes at a price. With the exception of [14], the model theoretic approaches are based on propositional databases. <p> Inadvertantly omitting one such effect, or proposing an inappropriate one, will leave the database in an intuitively incorrect state with respect to the world being 17 This use of abduction for inferring event occurrences is quite different than the abductive approaches to updates advocated by Guessoum and Lloyd <ref> [16, 17] </ref> and Kakas and Mancarella [19]. 34 modeled, even though, insofar as the database update mechanism is concerned, everything is fine. The source of the problem is clear: the database has no knowledge of events and their effects.
Reference: 18. <author> S. Hanks and D. McDermott. </author> <title> Default reasoning, nonmonotonic logics, and the frame problem. </title> <booktitle> In Proceedings of the National Conference on Artificial Intelligence, </booktitle> <pages> pages 328-333, </pages> <year> 1986. </year>
Reference-contexts: numbers, addresses, telephone numbers, fees, etc. etc. 7 has been `executed', we must determine whether Database j= (9c):enrolled (J ohn; c; do (register (M ary; C100); do (drop (J ohn; C100); S 0 ))): Querying an evolving database is precisely what is called the temporal projection problem in AI planning <ref> [18] </ref>. 4. AN AXIOMATIZATION OF UPDATE TRANSACTIONS The example education domain illustrates the general principles behind our approach to the specification of database update transactions. In this section we precisely characterize a class of databases and updates of which the above example will be an instance.
Reference: 19. <author> A.C. Kakas and P. Mancarella. </author> <title> Database updates through abduction. </title> <booktitle> In Proceedings VLDB-90, </booktitle> <address> Brisbane, Australia, </address> <year> 1990. </year>
Reference-contexts: Abiteboul [1], Bonner and Kifer [6], Fagin, Ullman and Vardi [10], Ginsberg and Smith [12], Guessoum and Lloyd [16, 17], Kakas and Mancarella <ref> [19] </ref>). Surprisingly, this idea is not as simple as it appears on the surface. <p> arbitrary sentences (e.g. the model theoretic approaches of Grahne [13], Katsuno and Mendelzon [20], Grahne, Mendelzon and Revesz ([14]) or Winslett [48], the syntactic approaches of Fagin, Ullman and Vardi [10] or Ginsberg and Smith [12], and the abductive approaches of Guessoum and Lloyd [16, 17] or Kakas and Mancarella <ref> [19] </ref>). In this respect, such proposals are more general than ours, but this generality comes at a price. With the exception of [14], the model theoretic approaches are based on propositional databases. Grahne, Mendelzon and Revesz ([14]) provide an account for first order models based on the Winslett ordering. <p> effect, or proposing an inappropriate one, will leave the database in an intuitively incorrect state with respect to the world being 17 This use of abduction for inferring event occurrences is quite different than the abductive approaches to updates advocated by Guessoum and Lloyd [16, 17] and Kakas and Mancarella <ref> [19] </ref>. 34 modeled, even though, insofar as the database update mechanism is concerned, everything is fine. The source of the problem is clear: the database has no knowledge of events and their effects.
Reference: 20. <author> H. Katsuno and A.O. Mendelzon. </author> <title> On the difference between updating a knowledge base and revising it. </title> <editor> In J. Allen, R. Fikes, and E. Sandewall, editors, </editor> <booktitle> Proceedings of the Second International Conference on Principles of Knowledge Representation and Reasoning (KR'91), </booktitle> <pages> pages 387-394, </pages> <address> Los Altos, CA, 1991. </address> <publisher> Morgan Kaufmann Publishers, Inc. </publisher>
Reference-contexts: 1. INTRODUCTION Our concern in this paper is with formalizing the evolution of a database under arbitrary sequences of update transactions. A wide variety of proposals for this exist in the literature (e.g. Abiteboul [1], Grahne [13], Katsuno and Mendelzon <ref> [20] </ref>, Winslett [48], Fagin, Ullman and Vardi [10], Ginsberg and Smith [12], Guessoum and Lloyd [16, 17], Manchanda and Warren [32], Kowalski [22], Bonner and Kifer [6].). In this paper, we advance a substantially different approach. <p> It is also implicit in various semantic approaches to database updates (but without appealing explicitly to transactions) such as the work of Grahne [13], Katsuno and Mendelzon <ref> [20] </ref>, Grahne, Mendelzon and Revesz ([14]) and Winslett [48]. Our approach differs from these semantic accounts in two ways: it explicitly provides for transactions, and it relies on an axiomatic treatment of the frame problem. <p> Thus, for transaction-centred databases, updates with arbitrary sentences are not permitted. A wide variety of update proposals in the literature are not transaction-centred; they provide for updates of a database with arbitrary sentences (e.g. the model theoretic approaches of Grahne [13], Katsuno and Mendelzon <ref> [20] </ref>, Grahne, Mendelzon and Revesz ([14]) or Winslett [48], the syntactic approaches of Fagin, Ullman and Vardi [10] or Ginsberg and Smith [12], and the abductive approaches of Guessoum and Lloyd [16, 17] or Kakas and Mancarella [19]).
Reference: 21. <author> A.M. Keller and M. Winslett Wilkins. </author> <title> On the use of an extended relational model to handle changing incomplete information. </title> <journal> Trans. on Software Engineering, </journal> <volume> SE-11(7):620-633, </volume> <month> July </month> <year> 1985. </year>
Reference: 22. <author> R. Kowalski. </author> <title> Database updates in the event calculus. </title> <journal> Journal of Logic Programming, </journal> <volume> 12 </volume> <pages> 121-146, </pages> <year> 1992. </year>
Reference-contexts: A wide variety of proposals for this exist in the literature (e.g. Abiteboul [1], Grahne [13], Katsuno and Mendelzon [20], Winslett [48], Fagin, Ullman and Vardi [10], Ginsberg and Smith [12], Guessoum and Lloyd [16, 17], Manchanda and Warren [32], Kowalski <ref> [22] </ref>, Bonner and Kifer [6].). In this paper, we advance a substantially different approach. <p> The frame problem has been recognized in the setting of database transaction processing, notably by Kowalski <ref> [22] </ref> and Borgida, Mylopoulos and Schmidt [7]. It is also implicit in various semantic approaches to database updates (but without appealing explicitly to transactions) such as the work of Grahne [13], Katsuno and Mendelzon [20], Grahne, Mendelzon and Revesz ([14]) and Winslett [48]. <p> It is, of course, meaningless for those update theories which are not transaction-centred. The Event Calculus The one proposal in the literature closest in spirit to ours is Kowalski's theory of updates based on the event calculus <ref> [22] </ref>. His axiomatization is first order (with a Prolog semantics), transactions are first order terms (actually, constants), states (in his case, time) are first class citizens, updates are virtual, the approach is transaction-centred, and it addresses the frame problem (using Prolog's negation-as-failure mechanism).
Reference: 23. <author> R. Kowalski and F Sadri. </author> <title> The situation calculus and event calculus compared. </title> <type> Technical report, </type> <institution> Department of Computing, Imperial College, </institution> <address> London, England, </address> <year> 1994. </year>
Reference-contexts: Despite these similarities, it is difficult to compare the two approaches, primarily because they appeal to quite different logical foundations. Recently, nevertheless, Kowalski and Sadri <ref> [23] </ref> compare the situation calculus axioms of this paper with an axiomatization of the event calculus and reveal some interesting relationships between our successor state axioms and their analogue within the event calculus. 9.
Reference: 24. <author> Yves Lesperance, Hector Levesque, Fangzhen Lin, Daniel Marcu, Raymond Re-iter, and Richard Scherl. </author> <title> A logical approach to high-level robot programming a progress report. In Control of the Physical World by Intelligent Systems, </title> <booktitle> Working Notes of the 1994 AAAI Fall Symposium, November, 1994. </booktitle> <address> New Orleans, LA. </address>
Reference-contexts: For a description of this application, and the reasons for some of our design decisions regarding logs vs. actualizing transactions, see Lesperance et al <ref> [24] </ref>. 7.4. Updates in the Logic Programming Context Our approach to database updates can be implemented in a straightforward way as a logic program, thereby directly complementing the logic programming perspec 27 tive on databases (Minker [36]).
Reference: 25. <author> H.L. Levesque, F. Lin, and R. Reiter. </author> <title> Defining complex actions in the situation calculus. </title> <type> Technical report, </type> <institution> Dept. of Computer Science, Univ. of Toronto, </institution> <year> 1995. </year> <note> In preparation. </note>
Reference-contexts: For an extension of the situation calculus to provide for complex transactions along the lines of Bonner and Kifer, see (Levesque, Lin and Reiter <ref> [25] </ref>). Classical vs. Other Logics Unlike proposals based on modal logics, e.g. dynamic logic (Manchanda and Warren [32]) or temporal logic (Casanova and Furtado [8]), or specially tailored logics, e.g. (Bonner and Kifer [6]), ours is based on first order logic (with a second order induction principle).
Reference: 26. <author> V. Lifschitz. </author> <title> Toward a metatheory of action. </title> <editor> In J. Allen, R. Fikes, and E. Sande-wall, editors, </editor> <booktitle> Proceedings of the Second International Conference on Principles of Knowledge Representation and Reasoning (KR'91), </booktitle> <pages> pages 376-386, </pages> <address> Los Altos, CA, 1991. </address> <publisher> Morgan Kaufmann Publishers, Inc. </publisher>
Reference-contexts: as to guarantee that the constraint will be an inductive entailment of the database? A variety of circumscriptive proposals for addressing these problems (in conjunction with the frame problem) have been proposed in the artificial intelligence literature, notably by Baker [4], Baker and Ginsberg [5], Ginsberg and Smith [12], Lifschitz <ref> [26] </ref> and Lin and Shoham [30]. Our formulation of the problem in terms of inductive entailments of the database appears to be new.
Reference: 27. <author> F. Lin and R. Reiter. </author> <title> How to progress a database II: The STRIPS connection. </title> <type> Technical report, </type> <institution> Department of Computer Science, University of Toronto, </institution> <year> 1993. </year> <month> 38 </month>
Reference-contexts: It is, however, always second order definable. This negative result leads to the natural question: when does a situation calculus specification admit a realization in terms of transaction mappings from first order static databases to first order static databases? Reiter and Lin <ref> [28, 27] </ref> provide two conditions under which this is possible, together with a systematic procedure for computing the successor database from the initial one: 1. When the database is relational. 26 2.
Reference: 28. <author> F. Lin and R. Reiter. </author> <title> How to progress a database (and why) I. Logical foundations. </title> <editor> In Jon Doyle, Erik Sandewall, and Pietro Torasso, editors, </editor> <booktitle> Proc. KR'94, Fourth Int. Conf. on Principles of Knowledge Representation and Reasoning, </booktitle> <pages> pages 425-436, </pages> <year> 1994. </year>
Reference-contexts: as would be the case when it is relational, a ground query may be evaluated by first computing its atomic subqueries, as indicated above, then combining those answers in the obvious way according to 11 Specifically, these general conditions are that the successor state axiom be what Lin and Reiter <ref> [28] </ref> call context free. 25 the sentential structure of the original query. This provides a tolerable algorithmic complexity for query evaluation. <p> Abiteboul [1], Bonner and Kifer [6], Fagin, Ullman and Vardi [10], Ginsberg and Smith [12], Guessoum and Lloyd [16, 17], Kakas and Mancarella [19]). Surprisingly, this idea is not as simple as it appears on the surface. Lin and Reiter <ref> [28] </ref> show that even when the initial database is first order (i.e. represents a finite set of first order situation calculus sentences whose only state argument is S 0 ), the successor database which actualizes the transaction need not be first order definable. It is, however, always second order definable. <p> It is, however, always second order definable. This negative result leads to the natural question: when does a situation calculus specification admit a realization in terms of transaction mappings from first order static databases to first order static databases? Reiter and Lin <ref> [28, 27] </ref> provide two conditions under which this is possible, together with a systematic procedure for computing the successor database from the initial one: 1. When the database is relational. 26 2.
Reference: 29. <author> F. Lin and R. Reiter. </author> <title> State constraints revisited. </title> <journal> J. of Logic and Computation, special issue on actions and processes, </journal> <volume> 4 </volume> <pages> 655-678, </pages> <year> 1994. </year>
Reference-contexts: For a more detailed description of this approach to the frame problem, and a procedure for automatically obtaining this solution from the effect axioms alone, see (Reiter [40]). For an independently motivated circumscriptive justification of this solution to the frame problem, see (Lin and Reiter <ref> [29] </ref>). 3.1. Querying a Database Notice that in the above account of database evolution, all updates are virtual; the database is never physically changed. To query the database resulting from some sequence of transactions, it is necessary to refer to this sequence in the query. <p> Our formulation of the problem in terms of inductive entailments of the database appears to be new. This perspective on constraints is pursued in (Lin and Reiter <ref> [29] </ref>), where techniques are presented for "compiling" the information implicit in the state constraints into the successor state and transaction precondition axioms. 8.
Reference: 30. <author> F. Lin and Y. Shoham. </author> <title> Provably correct theories of action. </title> <booktitle> In Proceedings of the National Conference on Artificial Intelligence, </booktitle> <year> 1991. </year>
Reference-contexts: constraint will be an inductive entailment of the database? A variety of circumscriptive proposals for addressing these problems (in conjunction with the frame problem) have been proposed in the artificial intelligence literature, notably by Baker [4], Baker and Ginsberg [5], Ginsberg and Smith [12], Lifschitz [26] and Lin and Shoham <ref> [30] </ref>. Our formulation of the problem in terms of inductive entailments of the database appears to be new.
Reference: 31. <author> J.W. Lloyd. </author> <title> Foundations of Logic Programming. </title> <publisher> Springer Verlag, </publisher> <address> second edition, </address> <year> 1987. </year>
Reference-contexts: In this connection, notice that the equivalences in the successor state and transaction precondition axioms are reminiscent of Clark's [9] completion semantics for logic programs, and our unique names axioms for states and transactions provide part of the equality theory required for Clark's semantics (Lloyd <ref> [31] </ref>, pp.79, 109). 12 We have here invoked some of the program transformation rules of (Lloyd [31], p.113) to convert the non-clausal formula [(8g 0 )a 6= change (st; c; g 0 )] ^ grade (st; c; g; s) ^ P oss (a; s) oe grade (st; c; g; do (a; <p> and transaction precondition axioms are reminiscent of Clark's [9] completion semantics for logic programs, and our unique names axioms for states and transactions provide part of the equality theory required for Clark's semantics (Lloyd <ref> [31] </ref>, pp.79, 109). 12 We have here invoked some of the program transformation rules of (Lloyd [31], p.113) to convert the non-clausal formula [(8g 0 )a 6= change (st; c; g 0 )] ^ grade (st; c; g; s) ^ P oss (a; s) oe grade (st; c; g; do (a; s)) to a Prolog executable form. <p> R is a new predicate symbol. 13 We have here invoked some of the program transformation rules of (Lloyd <ref> [31] </ref>, p.113) to convert the non-clausal formula f (8p):prerequ (p;c) oe (9g):grade (st; c; g; s) ^ g 50g oe P oss (register (st; c); s) to a Prolog executable form. P and Q are new predicate symbols. 28 7.5.
Reference: 32. <author> S. Manchanda and D.S. Warren. </author> <title> A logic-based language for database updates. </title> <editor> In J. Minker, editor, </editor> <booktitle> Foundations of Deductive Databases and Logic Programming, </booktitle> <pages> pages 363-394. </pages> <publisher> Morgan Kaufmann Publishers, Inc., </publisher> <address> Los Altos, CA, </address> <year> 1988. </year>
Reference-contexts: A wide variety of proposals for this exist in the literature (e.g. Abiteboul [1], Grahne [13], Katsuno and Mendelzon [20], Winslett [48], Fagin, Ullman and Vardi [10], Ginsberg and Smith [12], Guessoum and Lloyd [16, 17], Manchanda and Warren <ref> [32] </ref>, Kowalski [22], Bonner and Kifer [6].). In this paper, we advance a substantially different approach. <p> This makes historical queries possible (Section 7.1), and provides for a theory of integrity constraints (Section 6.1). This is impossible or extremely awkward to do within the logic for those approaches to updates formalized in modal logics e.g. dynamic logic, Manchanda and Warren <ref> [32] </ref>, temporal logic, Casanova and Furtado [8]), or in "path-based" logics (e.g. Bonner and Kifer), for which there is only an implicit notion of state. <p> Primitive vs. Complex Transactions The ability to define complex transactions in terms of primitive ones is extremely important for a theory of updates. As currently developed, our proposal does not provide a mechanism for defining complex transactions. In contrast, such proposals do exist, notably by Machanda and Warren <ref> [32] </ref>), based on dynamic logic in the logic programming context, and by Bonner and Kifer [6], based on a new logic specifically tailored to transactions. The latter theory is especially interesting for its rich repertoire of operators for defining new transactions in terms of old. <p> For an extension of the situation calculus to provide for complex transactions along the lines of Bonner and Kifer, see (Levesque, Lin and Reiter [25]). Classical vs. Other Logics Unlike proposals based on modal logics, e.g. dynamic logic (Manchanda and Warren <ref> [32] </ref>) or temporal logic (Casanova and Furtado [8]), or specially tailored logics, e.g. (Bonner and Kifer [6]), ours is based on first order logic (with a second order induction principle).
Reference: 33. <author> J. McCarthy. </author> <title> Programs with common sense. </title> <editor> In M. Minsky, editor, </editor> <booktitle> Semantic Information Processing, </booktitle> <pages> pages 403-418. </pages> <publisher> The MIT Press, </publisher> <address> Cambridge, MA, </address> <year> 1968. </year>
Reference-contexts: This formal identity provides a potentially fruitful synthesis of problems and solutions from both disciplines. 3 2. PRELIMINARIES: THE SITUATION CALCULUS AND THE FRAME PROBLEM The situation calculus (McCarthy <ref> [33] </ref>) is a first order language designed to represent dynamically changing worlds in which all such changes are the result of named actions. The world is conceived as being in some state s, and this state can change only in consequence of some agent (human, robot, nature) performing an action.
Reference: 34. <author> J. McCarthy. </author> <booktitle> Epistemological problems of artificial intelligence. In Proceedings of the Fifth International Joint Conference on Artificial Intelligence, </booktitle> <pages> pages 1038-1044, </pages> <address> Cambridge, MA, </address> <year> 1977. </year>
Reference-contexts: The example illustrates the subtleties involved in getting the successor state and/or transaction precondition axioms to reflect the intent of a state constraint. These difficulties are a manifestation of the so-called ramification (Finger [11]) and qualification (McCarthy <ref> [34] </ref>) problems in artificial intelligence planning domains. Transactions might have ramifications, or indirect effects.
Reference: 35. <author> J. McCarthy and P. Hayes. </author> <title> Some philosophical problems from the standpoint of artificial intelligence. </title> <editor> In B. Meltzer and D. Michie, editors, </editor> <booktitle> Machine Intelligence 4, </booktitle> <pages> pages 463-502. </pages> <publisher> Edinburgh University Press, Edinburgh, </publisher> <address> Scotland, </address> <year> 1969. </year>
Reference-contexts: oss (drop (r; x); s) ^ f ragile (x) oe broken (x; do (drop (r; x); s)): A robot repairing an object causes it not to be broken: P oss (repair (r; x); s) oe :broken (x; do (repair (r; x); s)): As has been long recognized (McCarthy and Hayes <ref> [35] </ref>), axioms other than effect axioms are required for formalizing dynamic worlds. These are called frame axioms, and they specify the action invariants of the domain, i.e., those fluents unaffected by the performance of an action.
Reference: 36. <editor> J. Minker, editor. </editor> <booktitle> Foundations of Deductive Databases and Logic Programming. </booktitle> <publisher> Morgan Kaufmann Publishers, Inc., </publisher> <address> Los Altos, CA, </address> <year> 1988. </year>
Reference-contexts: Updates in the Logic Programming Context Our approach to database updates can be implemented in a straightforward way as a logic program, thereby directly complementing the logic programming perspec 27 tive on databases (Minker <ref> [36] </ref>).
Reference: 37. <author> D. Poole. </author> <title> Explanation and prediction: an architecture for default and abductive reasoning. </title> <journal> Computational Intelligence, </journal> <volume> 5 </volume> <pages> 97-110, </pages> <year> 1989. </year>
Reference-contexts: One possible mechanism for this is abduction (Poole <ref> [37] </ref>), which has been applied in a wide variety of settings (diagnosis, natural language, planning) for inferring events which might explain an observation. 17 Combining abduction with a conventional approach to updates would lead to a very rich theory of database evolution, but such considerations take us well beyond the focus
Reference: 38. <author> R. Reiter. </author> <title> Towards a logical reconstruction of relational database theory. In M.L. </title> <editor> Brodie, J. Mylopoulos, and J.W. Schmidt, editors, </editor> <booktitle> On Conceptual Modelling: Perspectives from Artificial Intelligence, Databases and Programming Languages, </booktitle> <pages> pages 191-233. </pages> <publisher> Springer, </publisher> <address> New York, </address> <year> 1984. </year>
Reference-contexts: con straint IC iff the database entails the constraint: DB j= IC: 8 7 The symbol in $ $ 0 is the usual ordering relation on the reals, and is not to be confused with our ordering relation on states. 8 This definition should be contrasted with those in Reiter <ref> [38, 41] </ref>. <p> setting, a static integrity constraint is simply a sentence of the form (7.11) with n = 1, i.e., a sentence true in all states s accessible from S 0 , while a dynamic constraint relates two or more accessible states. 16 This definition should be contrasted with that of Reiter <ref> [38] </ref>. 30 Aside from this syntactic difference, they have the same logical status in our theory, namely as sentences which must be entailed by the database.
Reference: 39. <author> R. Reiter. </author> <title> A sound and sometimes complete query evaluation algorithm for relational databases with null values. </title> <journal> Journal of the ACM, </journal> <volume> 33(2) </volume> <pages> 349-370, </pages> <year> 1986. </year>
Reference-contexts: These considerations lead one naturally to address the problem of updates for relational databases with null values of the kind denoting existing but unknown individuals. A first order axiomatization of this setting was provided by Reiter <ref> [39] </ref>. While we have not worked out the details, it is clear that the ideas of this paper can be combined with those of (Reiter [39]) to provide a logical specification of the correct treatment of null values under updates for relational databases. <p> A first order axiomatization of this setting was provided by Reiter <ref> [39] </ref>. While we have not worked out the details, it is clear that the ideas of this paper can be combined with those of (Reiter [39]) to provide a logical specification of the correct treatment of null values under updates for relational databases. With such a specification in hand, it should be possible to characterize transaction mappings from static databases to static databases, as discussed above, which are provably correct with respect to this specification.
Reference: 40. <author> R. Reiter. </author> <title> The frame problem in the situation calculus: a simple solution (sometimes) and a completeness result for goal regression. </title> <editor> In Vladimir Lifschitz, editor, </editor> <booktitle> Artificial Intelligence and Mathematical Theory of Computation: Papers in Honor of John McCarthy, </booktitle> <pages> pages 359-380. </pages> <publisher> Academic Press, </publisher> <address> San Diego, CA, </address> <year> 1991. </year>
Reference-contexts: For a more detailed description of this approach to the frame problem, and a procedure for automatically obtaining this solution from the effect axioms alone, see (Reiter <ref> [40] </ref>). For an independently motivated circumscriptive justification of this solution to the frame problem, see (Lin and Reiter [29]). 3.1. Querying a Database Notice that in the above account of database evolution, all updates are virtual; the database is never physically changed.
Reference: 41. <author> R. Reiter. </author> <title> What should a database know? Journal of Logic Programming, </title> <address> 14(1-2):127-153, </address> <year> 1992. </year>
Reference-contexts: con straint IC iff the database entails the constraint: DB j= IC: 8 7 The symbol in $ $ 0 is the usual ordering relation on the reals, and is not to be confused with our ordering relation on states. 8 This definition should be contrasted with those in Reiter <ref> [38, 41] </ref>.
Reference: 42. <author> R. Reiter. </author> <title> Proving properties of states in the situation calculus. </title> <journal> Artificial Intelligence, </journal> <volume> 64 </volume> <pages> 337-351, </pages> <year> 1993. </year>
Reference-contexts: The intended interpretation of s &lt; s 0 is that state s 0 is reachable from state s by some sequence of transactions, each transaction of which is possible in that state resulting from executing the transactions preceeding it in the sequence. As in (Reiter <ref> [42] </ref>), we begin by postulating the following axioms: (8s):s &lt; S 0 : (5.1) Here, s s 0 is an abbreviation for s &lt; s 0 _ s = s 0 . <p> As we shall see, integrity constraints will emerge as inductively derivable general properties of database states. Let W be a unary predicate variable of L. Using the axioms (6), (5.1), (5.2) and (5.3), Reiter <ref> [42] </ref> derives the following second order induction principle, suitable for proving properties of states s when S 0 s: (8W ):W (S 0 ) ^ [(8a; s):P oss (a; s) ^ S 0 s ^ W (s) oe W (do (a; s))] (IP S 0 s ) Frequently, we shall want <p> oss (a; s) ^ S 0 s ^ W (s) oe W (do (a; s))] (IP S 0 s ) Frequently, we shall want to prove sentences of the form (8s; s 0 ):S 0 s ^ s s 0 oe T (s; s 0 ): Towards that end, Reiter <ref> [42] </ref> derives the the following induction principle, suitable for proving properties of pairs of states s and s 0 when S 0 s ^ s s 0 : (8R):R (S 0 ; S 0 ) ^ [(8a; s; s 0 ):P oss (a; s) ^ S 0 s ^ R (s;
Reference: 43. <author> R. Reiter. </author> <title> A simple solution to the frame problem (sometimes). </title> <type> Technical report, </type> <institution> Department of Computer Science, University of Toronto, </institution> <note> in preparation. </note>
Reference-contexts: For the class of databases of this paper, Reiter <ref> [43] </ref> has provided a closed form solution to this problem, which we now describe. 5.1. Legal Transaction Sequences In this section we provide necessary and sufficient conditions that a sequence o 1 ; : : : ; o n of update transactions be legal. <p> The formula precond (o; s) specifies the conditions under which the ground transaction o is possible in state s. The following is proved in (Reiter <ref> [43] </ref>): Theorem 5.1. <p> performing this transaction sequence, beginning with the initial database state S 0 ? This can be formally defined as the problem of determining whether D j= Q (do ([o 1 ; : : : ; o n ]; S 0 )): Our principal result is the following: Theorem 5.2 Reiter <ref> [43] </ref>. Suppose Q (s) 2 L is simple, and that the state variable s is the only free variable of Q (s). Suppose o 1 ; : : : ; o n is a sequence of ground terms of L of sort transaction. <p> We return now to the problem of verifying constraints. Since this requires showing that some sentence is true in all database states, it is not surprising that induction is required. The following result will provide a useful corollary for verifying integrity constraints by induction. Lemma 6.1 Reiter <ref> [43] </ref>. Suppose G (~x; s) 2 L where G (~x; s) is simple, s is a state variable, and the free variables of G are among ~x; s. <p> Thus, for the example at hand, one would be able to compute answers of the form "Yes, it is possible for J ohn to graduate, provided he registers for C400 and obtains a passing grade for it." For the class of databases of this paper, Reiter <ref> [43] </ref> shows how regression provides a sound and complete evaluator for such queries. 7.2. Complexity of Query Evaluation The results of the previous section on transaction logs and historical queries provide a basis for a complexity analysis of query evaluation.
Reference: 44. <author> R. Reiter. </author> <title> Formalizing database evolution in the situation calculus. </title> <booktitle> In Proc. Fifth Generation Computer Systems, </booktitle> <pages> pages 600-609, </pages> <address> Tokyo, June 1 - 5, </address> <year> 1992. </year>
Reference: 45. <author> R. Reiter. </author> <title> The projection problem in the situation calculus: A soundness and completeness result, with an application to database updates. </title> <editor> In James Hendler, editor, </editor> <booktitle> Proc. First Int. Conf. on Artificial Intelligence Planning Systems, </booktitle> <pages> pages 198-203, </pages> <address> College Park, Md., June 15 - 17, 1992. </address> <publisher> Morgan Kaufmann Publishers, Inc. </publisher>
Reference: 46. <author> R. Reiter. </author> <title> On formalizing database updates: preliminary report. </title> <booktitle> In Proc. 3rd International Conference on Extending Database Technology, </booktitle> <pages> pages 10-20, </pages> <address> Vienna, March 23 - 27, </address> <year> 1992. </year>
Reference: 47. <author> R. Waldinger. </author> <title> Achieving several goals simultaneously. </title> <editor> In E. Elcock and D. Michie, editors, </editor> <booktitle> Machine Intelligence 8, </booktitle> <pages> pages 94-136. </pages> <publisher> Ellis Horwood, Edinburgh, </publisher> <address> Scotland, </address> <month> 39 </month>
Reference-contexts: Notice that the induction axiom (5.3) is the only second order sentence of D; all other sentences of D are first order. Definition: A Regression Operator We now introduce an operator corresponding to the notion of goal regression as it arises in artificial intelligence planning problems (Waldinger <ref> [47] </ref>). It is also a parallel version of the operation of unfolding in logic programming.
Reference: 48. <author> M. Winslett. </author> <title> Reasoning about action using a possible models approach. </title> <booktitle> In Proceedings of the National Conference on Artificial Intelligence, </booktitle> <pages> pages 89-93, </pages> <year> 1988. </year>
Reference-contexts: 1. INTRODUCTION Our concern in this paper is with formalizing the evolution of a database under arbitrary sequences of update transactions. A wide variety of proposals for this exist in the literature (e.g. Abiteboul [1], Grahne [13], Katsuno and Mendelzon [20], Winslett <ref> [48] </ref>, Fagin, Ullman and Vardi [10], Ginsberg and Smith [12], Guessoum and Lloyd [16, 17], Manchanda and Warren [32], Kowalski [22], Bonner and Kifer [6].). In this paper, we advance a substantially different approach. <p> It is also implicit in various semantic approaches to database updates (but without appealing explicitly to transactions) such as the work of Grahne [13], Katsuno and Mendelzon [20], Grahne, Mendelzon and Revesz ([14]) and Winslett <ref> [48] </ref>. Our approach differs from these semantic accounts in two ways: it explicitly provides for transactions, and it relies on an axiomatic treatment of the frame problem. The next section provides an example of our axiomatic approach to specifying database update transactions, and how it addresses the frame problem. 3. <p> A wide variety of update proposals in the literature are not transaction-centred; they provide for updates of a database with arbitrary sentences (e.g. the model theoretic approaches of Grahne [13], Katsuno and Mendelzon [20], Grahne, Mendelzon and Revesz ([14]) or Winslett <ref> [48] </ref>, the syntactic approaches of Fagin, Ullman and Vardi [10] or Ginsberg and Smith [12], and the abductive approaches of Guessoum and Lloyd [16, 17] or Kakas and Mancarella [19]). In this respect, such proposals are more general than ours, but this generality comes at a price.
References-found: 48

