URL: http://www.cs.man.ac.uk/fmethods/people/visserw/newart.ps.gz
Refering-URL: http://www.cs.man.ac.uk/fmethods/LaTeX/people/willem-visser.html
Root-URL: http://www.cs.man.ac.uk
Title: An on-the- validation system for CTL  
Author: J. Geldenhuys P.J.A. de Villiers W.C. Visser 
Date: April 1995  
Address: Stellenbosch 7600, South Africa  Manchester M13 9PL, England  
Affiliation: Department of Computer Science, University of Stellenbosch,  Department of Computer Science, University of Manchester,  
Abstract: The classical model checking algorithm for CTL stores the entire reachability graph in memory. By taking an automata-theoretic approach, it was recently shown that the more practical on-the-fly validation technique can be applied to CTL. However, no implementation has been described yet. In this paper we describe an on-the-fly validation system for CTL. State caching is used and a new technique called subproblem detection is introduced. State compaction helps to fit more states into the state cache to allow the validation of larger problems. A simple example is presented and the effectiveness of the compaction technique is illustrated for a number of larger problems. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> O. Bernholz, M. Vardi, and P. Wolper. </author> <title> An Automata-Theoretic Approach to Branching-Time Model Checking. </title> <editor> In David Dill, editor, </editor> <booktitle> Proceedings: Computer Aided Verification, </booktitle> <pages> pages 142-155, </pages> <address> Stanford, California, USA, </address> <month> June </month> <year> 1994. </year> <booktitle> Lecture Notes in Computer Science, </booktitle> <pages> 818. </pages>
Reference-contexts: An overview of the on-the-fly validation technique can be found in [5] and its roots can be traced back to [7]. On-the-fly validation was thought to be impossible for CTL until an automata-theoretic solution was published recently <ref> [1] </ref>. However, no implementation is described. In this paper we describe an on-the-fly validation system for CTL based on a different approach. Validation models are expressed in a CSP-based language called ESML, and CTL is used to state correctness properties to be validated. <p> 79 (172) 1.14 (2.5) Comms bridge 163207 68 (137) 1.32 (2.65) Elevator (4) 2546801 90 (248) 27 (74) Windows 4117623 111 (299) 54 (145) Table 2: Memory requirements (results without compaction in parentheses) 8 Conclusions and future work It was recently shown that on-the-fly model checking is possible for CTL <ref> [1] </ref>. However, no implementation has been described yet. This paper presents an on-the-fly validation system for CTL. A new algorithm is presented for handling nested CTL formulae, based on a technique called subproblem detection. Memory is used more effectively by dividing the validation problem into a number of independent subproblems.
Reference: [2] <author> E.M. Clarke, </author> <title> E.A. Emerson, and A.P. Sistla. Automatic Verification of Finite State Concurrent Systems Using Temporal Logic Specifications: A Practical Approach. </title> <booktitle> Proceedings 10th ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 117-126, </pages> <year> 1983. </year>
Reference-contexts: 1 Introduction It is well known that an efficient model checking algorithm exists for CTL <ref> [2] </ref>. Unfortunately, this algorithm requires that the entire reachability graph must be generated and stored in main memory before it can be analysed during a subsequent phase. This limits the size of models that can be analysed, because the state space can be too large to fit into memory.
Reference: [3] <author> P. de Villiers and W. Visser. </author> <title> ESML|A Validation Language for Concurrent Systems. </title> <editor> In Judy Bishop, editor, </editor> <booktitle> 7-th Southern African Computer Symposium, </booktitle> <pages> pages 59-64, </pages> <month> July </month> <year> 1992. </year>
Reference-contexts: ESML is a strongly typed language based on CSP. Only a short overview of the validation language will be given here. Readers interested in a detailed description of ESML are referred to <ref> [3] </ref>. Correctness properties to be validated are expressed in CTL. Extended state machines (ESMs) were chosen to model reactive programs. The state machine formalism is one of the oldest and most widely accepted models of computation and allows natural descriptions of the dynamic behaviour of complex reactive programs.
Reference: [4] <author> E.W. Dijkstra. </author> <title> A Discipline of Programming. </title> <publisher> Prentice-Hall, </publisher> <address> Englewood Cliffs, New Jersey, </address> <year> 1976. </year>
Reference-contexts: The validation system described here include two additional techniques to improve the effectiveness of state space caching. These are subproblem detection and state compaction. 4 4 The validation algorithm The algorithm below is the core of the validator. It is presented in Dijkstra's guarded command notation <ref> [4] </ref>. done := FALSE; do done = FALSE -&gt; Machine.Execute; if Machine.result = Forward -&gt; value := TruthValueFormula (f); if value = T -&gt; Stack.SetGoodSuccessors; Machine.Backtrack; AdaptValue (f) [] value = F -&gt; DumpTrace; done := TRUE fi [] Machine.result = Revisit -&gt; AdaptValue (f) [] Machine.result = AllSuccessorsExplored -&gt; value
Reference: [5] <author> Jean-Claude Fernandez, Hubert Garavel, Laurent Mounier, Anne Rasse, Carlos Rodriguez, and Joseph Sifakis. </author> <title> A toolbox for the verification of lotos programs. </title> <editor> In Lori A. Clarke, editor, </editor> <booktitle> Proceedings of the 14th International Conference on Software Engineering ICSE'14 (Melbourne, Australia), </booktitle> <pages> pages 246-259, </pages> <address> New-York, </address> <month> May </month> <year> 1992. </year> <note> ACM. </note>
Reference-contexts: A more practical approach is to use "on-the-fly" validation: the reachability graph is not constructed explicitly; only the current execution path is stored in memory, and state generation and validation occur simultaneously. An overview of the on-the-fly validation technique can be found in <ref> [5] </ref> and its roots can be traced back to [7]. On-the-fly validation was thought to be impossible for CTL until an automata-theoretic solution was published recently [1]. However, no implementation is described. In this paper we describe an on-the-fly validation system for CTL based on a different approach. <p> However, no implementation is described. In this paper we describe an on-the-fly validation system for CTL based on a different approach. Validation models are expressed in a CSP-based language called ESML, and CTL is used to state correctness properties to be validated. State space caching <ref> [7, 8, 5] </ref> is used to detect revisited states. This helps to avoid redoing redundant work. The validation algorithm uses a technique called subproblem detection to handle nested temporal subformulae. This technique reduces the memory requirements of the state cache without increasing the run time requirements. <p> Subproblem detection and state compaction help to postpone the inevitable blow-up in run time that occurs when memory fills up. Similar on-the-fly validation systems based on state space caching have been developed <ref> [6, 5] </ref>. However, none of these systems were designed to validate correctness properties expressed in CTL. The language Promela that is used in the validation system SPIN [8] supports similar structured data types to ESML. However, Promela does not include sequences.
Reference: [6] <author> P. Godefroid, G. Holzmann, and D. Pirottin. </author> <title> State Space Caching Revisited. </title> <booktitle> In Proceedings: Computer Aided Verification, </booktitle> <pages> pages 175-186, </pages> <month> July </month> <year> 1992. </year>
Reference-contexts: Deleting states from the hash table will not influence the validation results, although deleted states (and their successors) may be analysed more than once. The run time increases dramatically when too many states are deleted. In <ref> [6] </ref> it was shown that the risk of redoing work can be reduced by eliminating redundant interleavings of states. State space caching thus becomes far more effective because most states are visited only once. <p> Subproblem detection and state compaction help to postpone the inevitable blow-up in run time that occurs when memory fills up. Similar on-the-fly validation systems based on state space caching have been developed <ref> [6, 5] </ref>. However, none of these systems were designed to validate correctness properties expressed in CTL. The language Promela that is used in the validation system SPIN [8] supports similar structured data types to ESML. However, Promela does not include sequences.
Reference: [7] <author> G.J. Holzmann. </author> <title> Tracing Protocols. </title> <journal> AT&T Technical Journal, </journal> <volume> 64 </volume> <pages> 2413-2434, </pages> <month> December </month> <year> 1985. </year>
Reference-contexts: An overview of the on-the-fly validation technique can be found in [5] and its roots can be traced back to <ref> [7] </ref>. On-the-fly validation was thought to be impossible for CTL until an automata-theoretic solution was published recently [1]. However, no implementation is described. In this paper we describe an on-the-fly validation system for CTL based on a different approach. <p> However, no implementation is described. In this paper we describe an on-the-fly validation system for CTL based on a different approach. Validation models are expressed in a CSP-based language called ESML, and CTL is used to state correctness properties to be validated. State space caching <ref> [7, 8, 5] </ref> is used to detect revisited states. This helps to avoid redoing redundant work. The validation algorithm uses a technique called subproblem detection to handle nested temporal subformulae. This technique reduces the memory requirements of the state cache without increasing the run time requirements. <p> When the hash table fills up, states are deleted to make room for new states. This strategy is called state space caching and was originally suggested by Holzmann in <ref> [7] </ref>. Deleting states from the hash table will not influence the validation results, although deleted states (and their successors) may be analysed more than once. The run time increases dramatically when too many states are deleted.
Reference: [8] <author> G.J. Holzmann. </author> <title> Protocol Design: Redefining the State of the Art. </title> <journal> IEEE Software, </journal> <volume> 9(1) </volume> <pages> 17-22, </pages> <month> January </month> <year> 1992. </year>
Reference-contexts: However, no implementation is described. In this paper we describe an on-the-fly validation system for CTL based on a different approach. Validation models are expressed in a CSP-based language called ESML, and CTL is used to state correctness properties to be validated. State space caching <ref> [7, 8, 5] </ref> is used to detect revisited states. This helps to avoid redoing redundant work. The validation algorithm uses a technique called subproblem detection to handle nested temporal subformulae. This technique reduces the memory requirements of the state cache without increasing the run time requirements. <p> The following examples should give the reader an idea of the data structuring facilities provided by ESML: TYPE Number = 0..4; TYPE Mapping = ARRAY [10] OF Number; TYPE ProcessRecord = (ProcessNumber, Priority: Number); TYPE ProcessQueue = LIST <ref> [8] </ref> OF ProcessRecord; (* max length = 8 *) The operators "::", "HD", "TL" and "LEN" are available. <p> Similar on-the-fly validation systems based on state space caching have been developed [6, 5]. However, none of these systems were designed to validate correctness properties expressed in CTL. The language Promela that is used in the validation system SPIN <ref> [8] </ref> supports similar structured data types to ESML. However, Promela does not include sequences. Sequences provide a natural way to model queues|a data type that often occurs in reactive systems. The current implementation can be improved in several areas.
Reference: [9] <author> G.J. Holzmann and D. Peled. </author> <title> An Improvement in Formal Verification. </title> <booktitle> In Proceedings: FORTE 1994, </booktitle> <pages> pages 177-191, </pages> <address> Berne, Switzerland, </address> <month> October </month> <year> 1994. </year>
Reference-contexts: The performance of state caching should be studied further. Although not included in the current implementation, experience with a previous version of the system has shown that the performance of state caching can be improved substantially by adding partial order techniques [10]. The static reduction technique presented in <ref> [9] </ref> is particularly attractive and could be implemented easily. The subproblem detection technique also provides a natural way to parallelise the validation algorithm for a distributed environment: one processor can be used to detect subproblems while several "worker" processors solve subproblems as soon as they are encountered.
Reference: [10] <author> W.C. Visser. </author> <title> A Run-Time Environment for a Validation Language. </title> <type> Master's thesis, </type> <institution> Department of Computer Science, University of Stellenbosch, Stellenbosch 7600, South Africa, </institution> <month> December </month> <year> 1993. </year> <month> 14 </month>
Reference-contexts: Similarly an ESM wanting to receive a message waits until a message of the specified type is sent. The following examples should give the reader an idea of the data structuring facilities provided by ESML: TYPE Number = 0..4; TYPE Mapping = ARRAY <ref> [10] </ref> OF Number; TYPE ProcessRecord = (ProcessNumber, Priority: Number); TYPE ProcessQueue = LIST [8] OF ProcessRecord; (* max length = 8 *) The operators "::", "HD", "TL" and "LEN" are available. <p> The performance of state caching should be studied further. Although not included in the current implementation, experience with a previous version of the system has shown that the performance of state caching can be improved substantially by adding partial order techniques <ref> [10] </ref>. The static reduction technique presented in [9] is particularly attractive and could be implemented easily.
References-found: 10

