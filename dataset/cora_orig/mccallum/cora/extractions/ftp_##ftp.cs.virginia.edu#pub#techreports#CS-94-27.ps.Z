URL: ftp://ftp.cs.virginia.edu/pub/techreports/CS-94-27.ps.Z
Refering-URL: ftp://ftp.cs.virginia.edu/pub/techreports/README.html
Root-URL: http://www.aic.nrl.navy.mil/~aha/people.html
Title: A Formal Model for Procedure Calling Conventions  
Author: Mark W. Bailey Jack W. Davidson 
Abstract: Computer Science Report No. CS-94-27 July 22, 1994 
Abstract-found: 1
Intro-found: 1
Reference: [BD93] <author> Bailey, M.W. and Davidson, J.W. </author> <title> A Formal Specification for Procedure Calling Conventions . Technical Report CS-93-59. </title> <institution> University of Virginia, </institution> <year> 1993. </year>
Reference-contexts: The example P-FSA implements the data placement that has been defined in Figure 5. It is not necessary to duplicate this definition in the callee prologue section of the CCL description. 1 A more complete description of CCL is available in <ref> [BD93] </ref>. caller prologue data transfer (asymmetric) resources -&lt; a 1:4 , M [sp: ] &gt;- " argument &lt; ARG 1:ARG_TOTAL &gt; map argument fi argument .type ^ - char: &lt;&lt;&lt; a 1:4 &gt;&gt;, &lt;&lt; M [sp: ] &gt;&gt;&gt;, int:&lt;&lt;&lt; a 1:4 &gt;&gt;, &lt;&lt; M [ addr ] | addr &lt;sp: &gt;
Reference: [DW91] <author> Davidson, J.W. and Whalley, </author> <title> D.B. Methods for Saving and Restoring Register Values across Function Calls. </title> <note> SoftwarePractice and Experience 21(2):149165 Feb-ruary 1991. </note>
Reference-contexts: For example, Johnson and Richie discuss some rules of thumb for designing and implementing a calling sequence for the C programming language [JR]. Davidson and Whalley experimentally evaluated several different C Page 13 of 14 calling conventions <ref> [DW91] </ref>. No attempts have been made to formally analyze calling conventions. On the other hand, the use of FSA for modeling parts of a compiler, and as an implementation tool has a long and successful history.
Reference: [DEC93] <institution> Digital Equipment Corporation . Calling Standard for AXP Systems . Digital Equipment Corporation, </institution> <month> July </month> <year> 1993. </year>
Reference-contexts: Furthermore, the convention, once understood, is difficult to implement. For example, the GNU ANSI C compiler fails on an example listed in the manual. Digital, in recognizing the problem, has published a calling standard document for their new Alpha series processors <ref> [DEC93] </ref> that exceeds 100 pages 1 . Thus, it should be clear that there is a need for an accurate, concise description of procedure calling conventions, and a supporting model for their evaluation. This paper makes several contributions.
Reference: [Fra93] <author> Fraser, C.W. </author> <type> Personal Communication, </type> <month> November, </month> <year> 1993. </year>
Reference-contexts: For example, in a MIPS programmers manual [KH92] the English description is so difficult to understand that the authors provide fifteen examples, several of which are contradictory <ref> [Fra93] </ref> and this is the second edition. Furthermore, the convention, once understood, is difficult to implement. For example, the GNU ANSI C compiler fails on an example listed in the manual.
Reference: [GG90] <author> Griswold, R.E. and Griswold, </author> <title> M.T. The Icon Programming Language , 2nd edition, </title> <publisher> Prentice-Hall, </publisher> <year> 1990. </year>
Reference-contexts: ANSI C does not. These differences are part of the calling convention, and are, therefore, present in the resulting CCL descriptions. 5.2 The Interpreter We have implemented an interpreter for the CCL specification language. The interpreters source is approximately 2500 lines of Icon code <ref> [GG90] </ref>. The interpreter takes as input the CCL description of a procedure calling convention, a procedures signature, and some additional information about the target architecture, and produces locations of the values to be transmitted, in terms of both the callee and the callers frame of reference.
Reference: [HU79] <author> Hopcroft, J.E. and Ullman, J.D. </author> <title> Introduction to Automata Theory, Languages, </title> <publisher> and Computation . Addison-Wesley, </publisher> <year> 1979. </year>
Reference-contexts: We also define : Q S * fi Q and : Q S * fi D * which are just string versions (defined by Hopcroft and Ullman <ref> [HU79] </ref>) of d and l, respectively. <p> The signature: int goo (double, double, char, int); 1 This can easily be extended to model more than one infinite resource. 2 In this paper, we use the notation of Hopcroft and Ullman for finite state automata and regular expressions <ref> [HU79] </ref>. We use letters early in the alphabet ( a , b , c ) to denote single symbols.
Reference: [JR] <author> Johnson, S.C. and Ritchie, </author> <title> D.M. The C Language Calling Sequence . Bell Labs. </title>
Reference-contexts: For example, Johnson and Richie discuss some rules of thumb for designing and implementing a calling sequence for the C programming language <ref> [JR] </ref>. Davidson and Whalley experimentally evaluated several different C Page 13 of 14 calling conventions [DW91]. No attempts have been made to formally analyze calling conventions.
Reference: [JPA68] <author> Johnson, W.L., J.H. Porter, S.I. Ackley, and D.T. Ross. </author> <title> Automatic generation of efficient lexical processors using finite state techniques, </title> <journal> Communications of the ACM , 11:(12), </journal> <pages> 805-813. </pages>
Reference-contexts: No attempts have been made to formally analyze calling conventions. On the other hand, the use of FSA for modeling parts of a compiler, and as an implementation tool has a long and successful history. For example, Johnson et al. <ref> [JPA68] </ref> describes the use of FSAs to implement lexical analyzers. More recently, Proebsting and Fraser [PF94], and Muller [Mul93] have used finite state automata to model and detect structural hazards in pipelines for instruction scheduling. 7 Summary Current methods of procedure call specification are frequently imprecise, incomplete, contradictory or inconsistent.
Reference: [KH92] <author> Kane, G. and Heinrich, J. </author> <title> MIPS RISC Architecture . Prentice Hall, </title> <year> 1992. </year>
Reference-contexts: Using the programmers reference manual may be equally problematical. As with much of the information in the programmers manual, the description is likely to be written in English and is liable to be ambiguous, or inaccurate. For example, in a MIPS programmers manual <ref> [KH92] </ref> the English description is so difficult to understand that the authors provide fifteen examples, several of which are contradictory [Fra93] and this is the second edition. Furthermore, the convention, once understood, is difficult to implement.
Reference: [KR88] <author> Kernighan, B.W. and Ritchie, </author> <title> D.M. The C Programming Language , 2nd edition. </title> <publisher> Prentice-Hall, </publisher> <year> 1988. </year>
Reference: [Mea55] <author> Mealy, </author> <title> G.H. A method for synthesizing sequential circuits, </title> <journal> Bell System Technical Journal , 34(5):10451079, </journal> <year> 1955. </year>
Reference-contexts: We now formalize our definition of a P-FSA for modeling placement. Since the P-FSA produces output on transitions, we have a Mealy machine <ref> [Mea55] </ref>.
Reference: [Mul93] <author> Muller, T. </author> <title> Employing Finite Automata for Resource Scheduling. </title> <booktitle> In Proceedings of the 26th Annual International Symposium on Microarchitecture , 1993, </booktitle> <pages> 12-20. </pages> <note> Page 14 of 14 </note>
Reference-contexts: On the other hand, the use of FSA for modeling parts of a compiler, and as an implementation tool has a long and successful history. For example, Johnson et al. [JPA68] describes the use of FSAs to implement lexical analyzers. More recently, Proebsting and Fraser [PF94], and Muller <ref> [Mul93] </ref> have used finite state automata to model and detect structural hazards in pipelines for instruction scheduling. 7 Summary Current methods of procedure call specification are frequently imprecise, incomplete, contradictory or inconsistent. This comes from the lack of a formal model, or specification language that guarantee these properties.
Reference: [PF94] <author> Proebsting, T.A. and Fraser, C.W. </author> <title> Detecting Pipeline Structural Hazards Quickly. </title> <booktitle> In Proceedings 21st ACM SIGPLAN-SIGACT Symposium on the Principles of Programming Languages , 1994, </booktitle> <pages> 280-286. </pages>
Reference-contexts: On the other hand, the use of FSA for modeling parts of a compiler, and as an implementation tool has a long and successful history. For example, Johnson et al. [JPA68] describes the use of FSAs to implement lexical analyzers. More recently, Proebsting and Fraser <ref> [PF94] </ref>, and Muller [Mul93] have used finite state automata to model and detect structural hazards in pipelines for instruction scheduling. 7 Summary Current methods of procedure call specification are frequently imprecise, incomplete, contradictory or inconsistent.
References-found: 13

