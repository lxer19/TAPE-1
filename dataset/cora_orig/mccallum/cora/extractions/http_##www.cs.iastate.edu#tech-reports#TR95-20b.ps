URL: http://www.cs.iastate.edu/tech-reports/TR95-20b.ps
Refering-URL: http://www.cs.iastate.edu/tech-reports/catalog.html
Root-URL: http://www.cs.iastate.edu
Title: Forcing Behavioral Subtyping Through Specification Inheritance  
Author: Krishna Kishore Dhara and Gary T. Leavens TR #-b 
Keyword: object-oriented programming, behavioral subtype, abstract data type, mutation, simulation function, modular verification, supertype abstraction, interface specification, Larch/C class, C subclass.  
Address: 226 Atanasoff Hall  Ames, Iowa 50011-1040, USA  
Affiliation: Department of Computer Science  Iowa Sate University  
Note: 1995  
Date: Aug. 1995, revised Aug. 1995, Dec.  
Abstract: 1994 CR Categories: D.1.5 [Programming Techniques] Object-oriented Programming; D.3.1 [Programming Languages] Formal Definitions and Theory | semantics; D.3.2 [Programming Languages] Language Classifications | object-oriented languages; D.3.3 [Programming Languages] Language Constructs | Abstract data types, modules, packages; F.3.1 [Logics and Meanings of Programs] Specifying and Verifying and Reasoning about Programs | Pre- and post-conditions; F.3.1 [Logics and Meanings of Programs] Specifying and Verifying and Reasoning about Programs | Specification techniques. c fl Copyright 1996 IEEE. A shorter version is published in the Proceedings of the 18th International Conference on Software Engineering (ICSE-18), March 25-29, 1996, Berlin, Germany. Personal use of this material is permitted. However, permission to reprint/republish this material for advertising or promotional purposes or for creating new collective works for resale or redistribution to servers or lists, or to reuse any copyrighted component of this work in other works, must be obtained from the IEEE. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Pierre America. </author> <title> Designing an object-oriented programming language with behavioural subtyping. </title> <editor> In J. W. de Bakker, W. P. de Roever, and G. Rozenberg, editors, </editor> <booktitle> Foundations of Object-Oriented Languages, REX School/Workshop, Noordwijkerhout, The Netherlands, May/June 1990, volume 489 of Lecture Notes in Computer Science, </booktitle> <pages> pages 60-90. </pages> <publisher> Springer-Verlag, </publisher> <address> New York, N.Y., </address> <year> 1991. </year>
Reference-contexts: Behavioral subtyping, subtyping based on the behavior of types, can be used for modular specification and verification of OO software. A set of conditions for behavioral subtyping has been proposed both proof-theoretically <ref> [1, 13] </ref>, and model-theoretically [11, 6]. It has been shown that with the addition of new behavioral subtypes, existing unchanged software does not have surprising behavior [11, 6]. Leavens and Weihl [12] present a technique for modular verification of OO programs. <p> The use of such functions dates back to Hoare's work [8], and has been used in the context of subtyping by other authors 6 <ref> [16, 2, 1, 13] </ref>. If all the subtypes used in a program are behavioral subtypes, the technique of supertype abstraction can be used for modular verification of OO programs [11]. <p> We first define pre-behavioral subtyping, which captures the common parts of these definitions. Then we define s and w using pre-behavioral subtyping, which highlights the differences between the two definitions. The definition of pre-behavioral subtyping uses ideas from <ref> [1, 13] </ref>. The definition is specialized for single dispatching languages like C ++ , Eiffel, and Smalltalk. Definition 4.1 (Pre-Behavioral Subtyping) S is a pre-behavioral subtype of T with respect to a binary relation on types if and only if the following properties are satisfied.
Reference: [2] <author> Kim B. Bruce and Peter Wegner. </author> <title> An algebraic model of subtypes in object-oriented languages (draft). </title> <journal> ACM SIGPLAN Notices, </journal> <volume> 21(10), </volume> <month> Oc-tober </month> <year> 1986. </year>
Reference-contexts: The use of such functions dates back to Hoare's work [8], and has been used in the context of subtyping by other authors 6 <ref> [16, 2, 1, 13] </ref>. If all the subtypes used in a program are behavioral subtypes, the technique of supertype abstraction can be used for modular verification of OO programs [11].
Reference: [3] <author> Luca Cardelli. </author> <title> Typeful programming. </title> <editor> In E. J. Neuhold and M. Paul, editors, </editor> <booktitle> Formal Description of Programming Concepts, IFIP State-of-the-Art Reports, </booktitle> <pages> pages 431-507. </pages> <publisher> Springer-Verlag, </publisher> <address> New York, N.Y., </address> <year> 1991. </year>
Reference-contexts: In the next section we discuss different notions of behavioral subtyping. In Section 5 we describe semantics of specification inheritance and show how specification inheritance forces behavioral subtyping. Section 6 discusses our techniques, and the last section presents our conclusions. 4 Behavioral Subtyping In contrast to structural subtyping <ref> [3] </ref>, behavioral subtyping should be based on both the syntax and the semantics of types. That is, behavioral subtyping is a property that relates type specifications.
Reference: [4] <author> Yoonsik Cheon and Gary T. Leavens. </author> <title> A quick overview of Larch/C++. </title> <journal> Journal of Object-Oriented Programming, </journal> <volume> 7(6) </volume> <pages> 39-49, </pages> <month> October </month> <year> 1994. </year>
Reference-contexts: We also define a new, weaker notion of behavioral subtyping that permits more behavioral subtype relations than previous work [13]. Though we use C ++ [18] as an OO language and Larch/C ++ <ref> [4, 10] </ref> as a specification language, the techniques we present can also be applied to other programming languages and with other specification languages. 2 Background on Larch/C++ Larch [7] is a family of specification languages with a two-level approach to specification.
Reference: [5] <author> E. Cusack. </author> <title> Inheritance in object oriented Z. </title> <editor> In Pierre America, editor, </editor> <booktitle> Proceedings of the European Conference on Object-Oriented Programming (ECOOP), Geneva Switzerland, Lecture Notes in Computer Science, </booktitle> <pages> pages 167-179, </pages> <address> New York, N.Y., 1991. </address> <publisher> Springer-Verlag. </publisher>
Reference-contexts: Therefore although such a method specification could be used in a strong behavioral subtype according to our definition, it would not yield a strong behavioral subtype according to Liskov and Wing's original definition. Cusack <ref> [5] </ref> defines specialization, which is like behavioral subtyping. Specialization does not handle subtyping on additional arguments and does not have any notion of history constraints.
Reference: [6] <author> Krishna Kishore Dhara and Gary T. Leavens. </author> <title> Weak behavioral sub-typing for types with mutable objects. </title> <editor> In S. Brookes, M. Main, A. Melton, and M. Mislove, editors, </editor> <booktitle> Mathematical Foundations of Programming Semantics, Eleventh Annual Conference, volume 1 of Electronic Notes in Theoretical Computer Science. </booktitle> <publisher> Elsevier, </publisher> <year> 1995. </year> <note> http://www.elsevier.nl:80/mcs/tcs/pc/volume01.htm. </note>
Reference-contexts: Behavioral subtyping, subtyping based on the behavior of types, can be used for modular specification and verification of OO software. A set of conditions for behavioral subtyping has been proposed both proof-theoretically [1, 13], and model-theoretically <ref> [11, 6] </ref>. It has been shown that with the addition of new behavioral subtypes, existing unchanged software does not have surprising behavior [11, 6]. Leavens and Weihl [12] present a technique for modular verification of OO programs. <p> A set of conditions for behavioral subtyping has been proposed both proof-theoretically [1, 13], and model-theoretically <ref> [11, 6] </ref>. It has been shown that with the addition of new behavioral subtypes, existing unchanged software does not have surprising behavior [11, 6]. Leavens and Weihl [12] present a technique for modular verification of OO programs. But to use such a technique one needs to verify that each specified subtype relation constitutes a behavioral subtype. <p> If appropriate restrictions are placed on certain forms of aliasing (discussed below) then one can allow extra mutations in the subtype and can still expect subtype objects to behave like supertype objects when viewed through the supertype's methods <ref> [6] </ref>. Since this notion allows more behavioral subtypes by weakening the constraint rule, it is called weak behavioral subtyping. Definition 4.3 (Weak behavioral subtyping, w ) S w T if S is a pre-behavioral subtype of T with respect to w , and the following constraint rule is satisfied. <p> To avoid this, one must restrict direct aliasing between variables or objects of different types. For a detailed discussion on techniques to restrict 11 such forms of aliasing and for a model theoretic definition of weak behavioral subtyping see <ref> [6] </ref>. Other forms of aliasing such as direct aliasing between variables and objects of the same type and indirect aliasing (that is aliasing of components) between variables and objects of different types are allowed. Whether such restrictions are too painful for OO programmers is an open problem. <p> Similarly, a mutable record type can be specified as a weak behavioral subtype of an immutable record type with fewer fields. One can have a hierarchy of weak behavioral subtypes with varying degrees of mutability <ref> [6] </ref>. 5 Specification Inheritance To prove a strong or a weak behavioral subtyping relation between two types, one needs to prove that the conditions of the appropriate definitions are met.
Reference: [7] <author> John V. Guttag, James J. Horning, S.J. Garland, K.D. Jones, A. Modet, and J.M. Wing. </author> <title> Larch: Languages and Tools for Formal Specification. </title> <publisher> Springer-Verlag, </publisher> <address> New York, N.Y., </address> <year> 1993. </year>
Reference-contexts: Though we use C ++ [18] as an OO language and Larch/C ++ [4, 10] as a specification language, the techniques we present can also be applied to other programming languages and with other specification languages. 2 Background on Larch/C++ Larch <ref> [7] </ref> is a family of specification languages with a two-level approach to specification. One level of specification, the interface language, describes the interface and behavior of the modules of a programming language like C ++ and Modula-3. Larch/C ++ plays this role in this paper.
Reference: [8] <author> C. A. R. Hoare. </author> <title> Proof of correctness of data representations. </title> <journal> Acta Informatica, </journal> <volume> 1(4) </volume> <pages> 271-281, </pages> <year> 1972. </year> <month> 26 </month>
Reference-contexts: In this paper the interpretation is given by specifying simulation function, which are mappings from the abstract values of a subtype to those of its supertypes. The use of such functions dates back to Hoare's work <ref> [8] </ref>, and has been used in the context of subtyping by other authors 6 [16, 2, 1, 13]. If all the subtypes used in a program are behavioral subtypes, the technique of supertype abstraction can be used for modular verification of OO programs [11].
Reference: [9] <author> K. Lano and H. Haughton. </author> <title> Object-Oriented Specification Case Studies. The Object-Oriented Series. </title> <publisher> Prentice Hall, </publisher> <address> New York, N.Y., </address> <year> 1994. </year>
Reference-contexts: One alternative would be to specify all abstract values as tuples, and treat subtype values in supertype contexts by projecting away the extra components, as is done in other OO specification languages (such as Object-Z, VDM++, MooZ, and Z++ <ref> [9] </ref>). But this would prevent viewing PlusAccount objects as BankAccount objects by adding the two account balances together. A solution should be flexible, by allowing users to specify the relationship between the abstract values of subtypes and supertypes, but should be modular.
Reference: [10] <author> Gary T. Leavens. </author> <note> Larch/C++ Reference Manual. Available in ftp://ftp.cs.iastate.edu/pub/larchc++/lcpp.ps.gz., </note> <year> 1995. </year>
Reference-contexts: We also define a new, weaker notion of behavioral subtyping that permits more behavioral subtype relations than previous work [13]. Though we use C ++ [18] as an OO language and Larch/C ++ <ref> [4, 10] </ref> as a specification language, the techniques we present can also be applied to other programming languages and with other specification languages. 2 Background on Larch/C++ Larch [7] is a family of specification languages with a two-level approach to specification. <p> In such cases the consequent of each implication in the completed specification's postcondition asserts that the objects that are not in the corresponding modifies clause are unchanged. (See <ref> [10] </ref> for details.) The completed specification's invariant is formed as a conjunction of the supertype's invariant (with appropriate coercions) and subtype's invariant. The completed specification's history constraint is a conjunction of the su-pertype's constraint (with appropriate coercions) and the added constraint on the subtype.
Reference: [11] <author> Gary T. Leavens and William E. Weihl. </author> <title> Reasoning about object-oriented programs that use subtypes (extended abstract). </title> <editor> In N. Meyrowitz, editor, </editor> <booktitle> OOPSLA ECOOP '90 Proceedings, volume 25(10) of ACM SIG-PLAN Notices, </booktitle> <pages> pages 212-223. </pages> <publisher> ACM, </publisher> <month> October </month> <year> 1990. </year>
Reference-contexts: Such extensions provide reuse of existing functions by allowing one to use subtype objects in place of supertype objects. However, due to message passing unchanged functions will then execute operations of 1 the newly added subtypes, potentially requiring respecification and reverifi--cation of the function <ref> [11] </ref>. Respecification and reverification go against the ease of extension promised by proponents of OO software. Specification and verification techniques which evolve with software, that is which do not require respecifying or reverifying whenever new components are added to the system, are called modular. <p> Behavioral subtyping, subtyping based on the behavior of types, can be used for modular specification and verification of OO software. A set of conditions for behavioral subtyping has been proposed both proof-theoretically [1, 13], and model-theoretically <ref> [11, 6] </ref>. It has been shown that with the addition of new behavioral subtypes, existing unchanged software does not have surprising behavior [11, 6]. Leavens and Weihl [12] present a technique for modular verification of OO programs. <p> A set of conditions for behavioral subtyping has been proposed both proof-theoretically [1, 13], and model-theoretically <ref> [11, 6] </ref>. It has been shown that with the addition of new behavioral subtypes, existing unchanged software does not have surprising behavior [11, 6]. Leavens and Weihl [12] present a technique for modular verification of OO programs. But to use such a technique one needs to verify that each specified subtype relation constitutes a behavioral subtype. <p> If all the subtypes used in a program are behavioral subtypes, the technique of supertype abstraction can be used for modular verification of OO programs <ref> [11] </ref>. Supertype abstraction uses static types of variables to reason about code and restricts the runtime types of variables to be behavioral sub-types of the static types. Such verification is valid because of the semantic conditions imposed on behavioral subtypes, which constitute an additional proof obligation.
Reference: [12] <author> Gary T. Leavens and William E. Weihl. </author> <title> Subtyping, modular specification, and modular verification for applicative object-oriented programs. </title> <type> Technical Report 92-28d, </type> <institution> Department of Computer Science, Iowa State University, Ames, Iowa, </institution> <month> 50011, August </month> <year> 1994. </year> <note> Full version of a paper in Acta Informatica, volume 32, number 8, pages 705-778. Available by anonymous ftp from ftp.cs.iastate.edu, and by e-mail from almanac@cs.iastate.edu. </note>
Reference-contexts: A set of conditions for behavioral subtyping has been proposed both proof-theoretically [1, 13], and model-theoretically [11, 6]. It has been shown that with the addition of new behavioral subtypes, existing unchanged software does not have surprising behavior [11, 6]. Leavens and Weihl <ref> [12] </ref> present a technique for modular verification of OO programs. But to use such a technique one needs to verify that each specified subtype relation constitutes a behavioral subtype. In this paper we present a modular specification technique, which automatically forces behavioral subtyping (and thus also avoids reverification).
Reference: [13] <author> Barbara Liskov and Jeannette Wing. </author> <title> A behavioral notion of sub-typing. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 16(6) </volume> <pages> 1811-1841, </pages> <month> November </month> <year> 1994. </year>
Reference-contexts: Behavioral subtyping, subtyping based on the behavior of types, can be used for modular specification and verification of OO software. A set of conditions for behavioral subtyping has been proposed both proof-theoretically <ref> [1, 13] </ref>, and model-theoretically [11, 6]. It has been shown that with the addition of new behavioral subtypes, existing unchanged software does not have surprising behavior [11, 6]. Leavens and Weihl [12] present a technique for modular verification of OO programs. <p> In this paper we present a modular specification technique, which automatically forces behavioral subtyping (and thus also avoids reverification). We also define a new, weaker notion of behavioral subtyping that permits more behavioral subtype relations than previous work <ref> [13] </ref>. <p> The abstract values are defined as tuples with a credit component and an owner component. The constraint clause in Figure 1 states that the owner of BankAccount cannot be changed. Following this history constraint <ref> [13] </ref> in Figure 1 are the specifications of the C ++ member functions. The pre-condition for the constructor BankAccount follows the keyword requires. <p> The use of such functions dates back to Hoare's work [8], and has been used in the context of subtyping by other authors 6 <ref> [16, 2, 1, 13] </ref>. If all the subtypes used in a program are behavioral subtypes, the technique of supertype abstraction can be used for modular verification of OO programs [11]. <p> We also define a new, weaker notion of behavioral subtyping for mutable types, which has advantages over Liskov and Wing's definitions <ref> [13] </ref>. In the next section we discuss different notions of behavioral subtyping. In Section 5 we describe semantics of specification inheritance and show how specification inheritance forces behavioral subtyping. <p> Expected behavior is characterized by the supertype's specification. To define behavioral subtyping, we use the following notation. We use strong behavioral subtyping, s , to refer to a notion similar to Liskov and Wing's constraint-based behavioral subtyping <ref> [13] </ref> and weak behavioral sub-typing, w , to refer to our new, weaker notion of behavioral subtyping. Type symbols are represented by S, T and type vectors by ~ U , ~ V . <p> We first define pre-behavioral subtyping, which captures the common parts of these definitions. Then we define s and w using pre-behavioral subtyping, which highlights the differences between the two definitions. The definition of pre-behavioral subtyping uses ideas from <ref> [1, 13] </ref>. The definition is specialized for single dispatching languages like C ++ , Eiffel, and Smalltalk. Definition 4.1 (Pre-Behavioral Subtyping) S is a pre-behavioral subtype of T with respect to a binary relation on types if and only if the following properties are satisfied. <p> additional arguments of a method must have the same types as in the corresponding method of the supertype, otherwise overloading instead of inheritance results. (Also, in C ++ one can think of self as *this.) Therefore, for C ++ we can state the methods rule more simply as follows (compare <ref> [13, Figure 4] </ref>). <p> For example, the history constraint of BankAccount specified in Figure 1 states that the name of the owner does not change in any computation. 9 4.1 Strong behavioral subtyping The following definition is a modified version of Liskov and Wing's definition <ref> [13, Figure 4] </ref>. The exception rule and the methods rule are changed from the original definition (see the section on related work below for details on the differences). <p> The syntactic conditions can be checked by the type system of a language. But the semantic conditions need to be verified and are generally beyond the power of most type systems to check. Several examples of s , like Bag s PriorityQueue, are given by Liskov and Wing <ref> [13] </ref>. The PlusAccount referred in Section 3 is a strong behavioral subtype of BankAccount. <p> using specification inheritance is a weak behavioral subtype of its supertypes. 6 Discussion In this section we compare our work on behavioral subtyping and specification with other related work and also discuss issues in specification inheritance. 6.1 Related work The important difference between our work and Liskov and Wing's work <ref> [13] </ref> is the new definition of weak behavioral subtyping. However we also refined their definition of strong behavioral subtyping. These refinements include changes to the exception rule, handling additional arguments in the methods rule, and generalizing the post-condition rule.
Reference: [14] <author> Barbara Liskov and Jeannette M. Wing. </author> <title> Specifications and their use in defining subtypes. </title> <journal> ACM SIGPLAN Notices, </journal> <volume> 28(10) </volume> <pages> 16-28, </pages> <month> October </month> <year> 1993. </year> <booktitle> OOPSLA '93 Proceedings, Andreas Paepcke (editor). </booktitle>
Reference-contexts: History constraints are introduced by Liskov and Wing in order to capture the properties of objects that are true in any execution history (which Liskov and Wing call a computation) <ref> [14] </ref>. For example, the history constraint of BankAccount specified in Figure 1 states that the name of the owner does not change in any computation. 9 4.1 Strong behavioral subtyping The following definition is a modified version of Liskov and Wing's definition [13, Figure 4].
Reference: [15] <author> Bertrand Meyer. </author> <title> Eiffel: The Language. Object-Oriented Series. </title> <publisher> Prentice Hall, </publisher> <address> New York, N.Y., </address> <year> 1992. </year>
Reference-contexts: Her technique for inheritance of specifications does not allow one to add behavior incrementally. Eiffel also attempts to force behavioral subtyping through specification inheritance <ref> [15, Section 10.15] </ref>.
Reference: [16] <author> John C. Reynolds. </author> <title> Types, abstraction and parametric polymorphism. </title> <booktitle> In Proc. IFIP Congress '83, </booktitle> <address> Paris, </address> <month> September </month> <year> 1983. </year>
Reference-contexts: The use of such functions dates back to Hoare's work [8], and has been used in the context of subtyping by other authors 6 <ref> [16, 2, 1, 13] </ref>. If all the subtypes used in a program are behavioral subtypes, the technique of supertype abstraction can be used for modular verification of OO programs [11].
Reference: [17] <author> Oliver Schoett. </author> <title> An observational subset of first-order logic cannot specify the behavior of a counter. </title> <editor> In C. Choffrut and M. Jantzen, editors, </editor> <booktitle> STACS 91 8th Annual Symposium on Theoretical Aspects of Computer Science Hamburg, Germany, February 1991 Proceedings, volume 480 of Lecture Notes in Computer Science, </booktitle> <pages> pages 499-510. </pages> <publisher> Springer-Verlag, </publisher> <address> New York, N.Y., </address> <year> 1991. </year> <month> 27 </month>
Reference-contexts: However, given the incremental nature of OO software development, specifying simulation functions from states to states is not practical. Techniques are needed to construct such simulation functions. In this paper we have used simulation functions, which are convenient in formulas. However, in general, one needs relations instead of functions <ref> [17] </ref>. 7 Conclusions The main contributions of this paper are a modular specification technique which forces behavioral subtyping and a new, weaker notion of behavioral subtyping. While the semantics of behavioral subtyping may seem somewhat intricate, the basic idea is that the subtype must satisfy the supertype's specifications.
Reference: [18] <author> B. Stroustrup. </author> <title> The C++ Programming Language. </title> <publisher> Addison-Wesley Pub--lishing Co., </publisher> <address> Reading, Mass., 1986. Corrected reprinting, </address> <year> 1987. </year>
Reference-contexts: In this paper we present a modular specification technique, which automatically forces behavioral subtyping (and thus also avoids reverification). We also define a new, weaker notion of behavioral subtyping that permits more behavioral subtype relations than previous work [13]. Though we use C ++ <ref> [18] </ref> as an OO language and Larch/C ++ [4, 10] as a specification language, the techniques we present can also be applied to other programming languages and with other specification languages. 2 Background on Larch/C++ Larch [7] is a family of specification languages with a two-level approach to specification. <p> 2 meths (T ) pre m T (c S!T (self ^); ~x ^) ) (post m T (c S!T (self ^); c S!T (self 0 ); ~x ^; ~x 0 ; c U r !V r (result 0 ))) 1 C C C A Since message passing in C ++ <ref> [18] </ref> is dynamic only for the virtual member functions, the semantics of specification inheritance in Larch/C ++ applies the above rules only for the virtual member functions of S.
Reference: [19] <author> Alan Wills. </author> <title> Specification in Fresco. </title> <editor> In Susan Stepney, Rosalind Bar-den, and David Cooper, editors, </editor> <title> Object Orientation in Z, </title> <booktitle> Workshops in Computing, chapter 11, </booktitle> <pages> pages 127-135. </pages> <publisher> Springer-Verlag, </publisher> <address> Cambridge CB2 1LQ, UK, </address> <year> 1992. </year>
Reference-contexts: When new behavioral subtypes are added such a technique does not require reverification, because subtype objects behave like supertype objects. In this paper we illustrate how these two techniques are combined in Larch/C ++ to give a semantics for specification inheritance that forces sub-types to be behavioral subtypes (following <ref> [19] </ref>). We also define a new, weaker notion of behavioral subtyping for mutable types, which has advantages over Liskov and Wing's definitions [13]. In the next section we discuss different notions of behavioral subtyping. <p> In this section we show how specification inheritance can be used to force behavioral subtyping, eliminating the need for users of a specification language to verify behavioral subtyping by hand 2 . This idea is due to Wills <ref> [19] </ref> although apparently he allows one to escape the mechanism and still specify subtypes that are not behavioral subtypes. 5.1 Inheritance for strong behavioral subtyping The specification of PlusAccount in Figures 4 and 5 gives an example of specification inheritance. Figure 4 gives the interface specification. <p> Separating the inherited part from the added part, we believe, enchances the readability of completed specifications and serves as an aid to understanding. This separation can be achieved by using case-analysis <ref> [19] </ref>. Case-analysis is a syntactic sugar used in method specifications. For example, Figure 6 gives the completed specification of withdraw in PlusAccount using case-analysis. The body of the specification contains two parts. The first is the added specification and the second is the inherited specification. <p> In Eiffel there is no need for simulation functions in inherited specifications, as the assertion sublanguage is polymorphic by virtue of using Eiffel subexpressions. Eiffel's syntax provides no support for case-analysis in method specifications. The work of Wills in Fresco <ref> [19] </ref> is most closely related to ours. Capsules in Fresco support the idea of case-analysis all the specification capsules for a given method must be satisfied by that method.
References-found: 19

