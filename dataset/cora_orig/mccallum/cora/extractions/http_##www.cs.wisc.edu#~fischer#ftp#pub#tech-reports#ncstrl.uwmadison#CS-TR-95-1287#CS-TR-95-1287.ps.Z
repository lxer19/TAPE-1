URL: http://www.cs.wisc.edu/~fischer/ftp/pub/tech-reports/ncstrl.uwmadison/CS-TR-95-1287/CS-TR-95-1287.ps.Z
Refering-URL: http://www.cs.wisc.edu/~fischer/ftp/pub/tech-reports/ncstrl.uwmadison/CS-TR-95-1287/
Root-URL: http://www.cs.wisc.edu
Email: kunen@cs.wisc.edu  f  
Phone: (2 0  
Title: Non-Constructive Computational Mathematics  unless they could define a function f and prove that 8x  
Author: Kenneth Kunen f y(:(; 
Keyword: 8x 9y(; 8y:(;  
Note: (1)  Note that (2) is equivalent to 8x;  
Date: August 28, 1995  (2)  
Address: Wisconsin, Madison, WI 53706, U.S.A.  
Affiliation: University of  
Abstract: We describe a non-constructive extension to Primitive Recursive Arithmetic, both abstractly, and as implemented on the Boyer-Moore prover. Abstractly, this extension is obtained by adding the unbounded operator applied to primitive recursive functions; doing so, one can define the Ackermann function and prove the consistency of Primitive Recursive Arithmetic. The implementation does not mention the operator explicitly, but has the strength to define the operator through the built-in functions EVAL$ and V&C$. This paper is a mixture of theory and practice. The theory begins with the notions of constructivism and finitism in the philosophy of mathematics. As with all philosophical notions, these cannot appear directly in a mathematical theorem or a computer program, but they have been useful guides over the past hundred years to discovering mathematical results, and more recently, to designing computer implementations. Informally, a constructivist only believes in objects for which there is an explicit construction; in particular, a function definition is meaningful only if it is accompanied by a procedure for computing values of the function. Axiom systems such as ZF (Zermelo-Fraenkel set theory) are obviously non-constructive, but even the system P A (Peano Arithmetic), which deals only with natural numbers, is non-constructive. For example, if (x; y) is some property of x; y, constructivists would not assert that they could prove x1. INTRODUCTION
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> A. V. Aho, J. E. Hopcroft, and J. D. Ullman, </author> <title> Data Structures and Algorithms, </title> <publisher> Addison-Wesley, </publisher> <year> 1983. </year>
Reference-contexts: (S 1 ; I 3 P 2 (I 1 1 (S 1 ; I 3 P 2 (I 1 1 (S 1 ; I 3 I 1 C 3 2 )[7; 0; 7] = 7 2 [7; 0; 7] = 7 C 3 2 )<ref> [7; 1; 8] </ref> = 9 2 [7; 1; 8] = 8 We can think of this as a tree, displayed in preorder traversal. <p> A simple example of this is the Ackermann function, A, defined by: A (0; y) = 1 x 2 ) A (x; 0) = x + 2 The details of the definition vary in different references (this one is from <ref> [1] </ref>), but the key point is the double recursion on the last line of definition, which is not primitive recursive.
Reference: [2] <author> M. L. Beeson, </author> <title> Foundations of Constructive Mathematics, </title> <publisher> Springer-Verlag, </publisher> <year> 1985 </year>
Reference-contexts: A constructivist would simply not accept such a definition of a function. For further discussion of constructivism, see Beeson <ref> [2] </ref> or Troelstra [17]. Kleene [12] turned the above philosophical argument into a mathematical theorem. The system HA (Heyting Arithmetic) is an attempt to formalize constructive number theory. HA has exactly the same axioms as does P A, but allows only intuitionistic logic in its proofs.
Reference: [3] <author> R. S. Boyer, D. Goldschlag, M. Kaufmann, and J S. Moore, </author> <title> Functional Instantiation in First Order Logic, </title> <booktitle> in Artificial Intelligence and Mathematical Theory of Computation: Papers in Honor of John McCarthy, </booktitle> <editor> V. Lifschitz, ed., </editor> <publisher> Academic Press, </publisher> <year> 1991, </year> <pages> pp. 7 - 26. </pages>
Reference-contexts: See <ref> [3] </ref> for a detailed discussion. As a special case of Lemma 3.1.2, where is a pure formula: 3.1.3. Lemma. <p> However, these uses can be obtained just as well through the constructive commands CONSTRAIN and FUNCTIONALLY-INSTANTIATE (see <ref> [3] </ref>, or Lemma 3.1.2 and the following discussion). Another use in verification is to implement an embedded interpreter (see, e.g., [6]). However, these uses would be obtained if EVAL$ were restricted to apply to primitive recursive functions.
Reference: [4] <author> R. S. Boyer and J S. Moore, </author> <title> The Addition of Bounded Quantification and Partial Functions to a Computational Logic and its Theorem Prover J. </title> <journal> Automated Reasoning, </journal> <volume> 4 (1988) 117 - 172. </volume>
Reference-contexts: The self-referential feature is implemented through a number of functions: V&C$, V&C-APPLY$, APPLY$, EVAL$, and FOR. These functions are described in [5], and in more detail in <ref> [4] </ref>. There is no discussion there of the operator; rather the informal motivation of V&C$ is an attempt to formalize an interpreter for the logic.
Reference: [5] <author> R. S. Boyer and J S. Moore, </author> <title> A Computational Logic Handbook, </title> <publisher> Academic Press, </publisher> <year> 1988. </year>
Reference-contexts: We turn now to practice. There are many computer systems available for verifying proofs in mathematical logic. One of the most well known among these is the system Nqthm, developed by Boyer and Moore <ref> [5] </ref>, and described by them as a system of "computational logic". To first approximation, it is an implementation of P RA. It has been used to verify statements about the correctness of hardware and software design, as well as constructive theorems of pure mathematics. <p> To see a specific example of the difference, let e = #SLOOP , where SLOOP (defined in x2.4) "computes" the successor of the function which doesn't halt. Then 0 e () = 1, while apply (e; #()) = 0. An Nqthm example like this is discussed in x2.10 of <ref> [5] </ref>, but is not quite so transparent there because the operator is not built in on the surface, but must be constructed using other primitives; see x4 and below. Roughly, P RA axiomatizes the t = t for t a primitive recursive name. <p> algorithm to detect something like our absolutely valid formulas and rewrite them to true; in addition, it also rewrites to true statements about + which are valid by "linear arithmetic", such as x = f (y) ) 2 + (x + 3) = (1 + f (y)) + 4 (see <ref> [5] </ref>, x11.1.4). We may introduce some abbreviations, so that the theory looks more like conventional mathematics. We have already introduced S. <p> Using the axioms about +; fl, plus induction, all the basic facts about +; fl (such as the associative, commutative, and distributive laws) may be derived; see <ref> [9, 5] </ref>. Likewise, we may let x &lt; y abbreviate F (x; y) = S (0), where is some standard name for the definition of the &lt; predicate (actually, function see x2.4). Likewise, introduce abbreviations x y, x &gt; y, x y, etc. <p> The use or non-use of this feature is easy to document; if the source file does not contain the word ORD-LESSP, then ordinal recursion is never invoked. The self-referential feature is implemented through a number of functions: V&C$, V&C-APPLY$, APPLY$, EVAL$, and FOR. These functions are described in <ref> [5] </ref>, and in more detail in [4]. There is no discussion there of the operator; rather the informal motivation of V&C$ is an attempt to formalize an interpreter for the logic. <p> However, in the formal analysis, one can ignore the motivation and work from the explicit axiomatization for V&C$ and related functions given in <ref> [5] </ref>. In the notation of x2.10, Nqthm appears to avoid an inconsistency because it formalizes the theory of something like V C , which can talk about the evaluation of V C , not V C . Ideally, one should do two things now: 1. <p> Furthermore, verifications for statements involving V&C$ often are obtained by rewriting via internal routines such as REWRITE-V&C-APPLY$, which are not even documented in <ref> [5] </ref>. Thus, lacking a formal statement of the actual reduction mechanism, it seems hopeless to attempt to prove (1) or (2) formally here, or even to 19 prove that Nqthm is consistent. <p> Since these names may include V&C$, it appears that Theorem 2.10.1 applies to show that one can define every partial recursive function in this way. More simply, however, as described in <ref> [5] </ref>, there is a built-in hack with EVAL$ which enables one to define a function whose BODY explicitly calls that function. <p> Thus, one can define: (defn liar () (eval$ T '(not (liar)) NIL )) Now, LIAR is stored in Nqthm's symbol table with BODY equal to (NOT (LIAR)); and from 20 this one may prove in Nqthm that this function never halts. This function is discussed in <ref> [5] </ref>, but for some reason is called RUSSELL there. Actually, the non-halting is due just to the self-referentiality, not the liar paradox. <p> With: (defn selfref () (eval$ T '(selfref) NIL )) one can prove in Nqthm that this function never halts either, since by the axioms for V&C$, the cost of evaluating (selfref) must be one more than the cost of evaluating (selfref). For further examples, see <ref> [5] </ref>, along with x4.2, where we show explicitly how to encode the operator and define the Ackermann function. <p> function qval (quick valuation) which reset the cost to 0: (defn reset (x) (if x (cons (car x) 0) F)) (defn qval (term va) (reset (v&c$ T term va))) We then proved a sequence of lemmas showing that qval satisfies the axioms corresponding to the built-in axioms about V&C$ (see <ref> [5] </ref>, x4.10.2). For example, the following lemma explains how to evaluate an if statement. <p> These are not documented in <ref> [5] </ref>, but have the effect of letting Nqthm see unaided that V&C$ does the "right thing" when applied to ordinary primitive recursive functions. <p> It seems unlikely that a practical statement about physical reality could require non-constructive means for its proof. Now, the practical uses of the self-referential features are all constructive. One use of EVAL$, as described in <ref> [5] </ref>, allows one to define functions which take (a name for) a function as input (as one does in Lisp), and to prove general theorems about these functions. <p> Thus, Nqthm could be modified to be purely constructive without diminishing its practical usefulness. Of course, there is a mathematical interest in non-constructive systems, and in particular in talking about unbounded searches through the natural numbers. In fact, the original motivation of Boyer and Moore, as described in <ref> [5] </ref>, was not to formalize P RA at all ([5] never mentions P RA).
Reference: [6] <author> B. C. Brock and W. A. Hunt, </author> <title> An Overview of the Formal Specification and Verification of the FM9001 Microprocessor, </title> <type> preprint, </type> <note> currently available on WWW at http://www.cli.com/hardware/fm9001.html. </note>
Reference-contexts: However, these uses can be obtained just as well through the constructive commands CONSTRAIN and FUNCTIONALLY-INSTANTIATE (see [3], or Lemma 3.1.2 and the following discussion). Another use in verification is to implement an embedded interpreter (see, e.g., <ref> [6] </ref>). However, these uses would be obtained if EVAL$ were restricted to apply to primitive recursive functions. Thus, Nqthm could be modified to be purely constructive without diminishing its practical usefulness.
Reference: [7] <author> G. Gentzen, Die Widerspruchsfreiheit der reinen Zahlentheorie, </author> <note> Mathematische An-nalen 112 (493 - 565) 1936. </note>
Reference-contexts: Kleene's [12] proof by recursive realizability formalizes the intuition that every statement provable from HA is constructively true. The other is due to Gentzen <ref> [7] </ref>. Let P RA 00 be obtained by adding to P RA induction and recursion on the ordinal * 0 . This is clearly stronger than P RA 0 , since the Ackermann function can be defined by recursion on ! 2 . <p> The result of the computation might look like: 6 P 2 (I 1 1 (S 1 ; I 3 P 2 (I 1 1 (S 1 ; I 3 P 2 (I 1 1 (S 1 ; I 3 I 1 C 3 2 )<ref> [7; 0; 7] </ref> = 7 2 [7; 0; 7] = 7 C 3 2 )[7; 1; 8] = 9 2 [7; 1; 8] = 8 We can think of this as a tree, displayed in preorder traversal. <p> (S 1 ; I 3 P 2 (I 1 1 (S 1 ; I 3 P 2 (I 1 1 (S 1 ; I 3 I 1 C 3 2 )[7; 0; 7] = 7 2 [7; 0; 7] = 7 C 3 2 )<ref> [7; 1; 8] </ref> = 9 2 [7; 1; 8] = 8 We can think of this as a tree, displayed in preorder traversal. <p> As mentioned in the Introduction, the two features which go beyond P RA are the facility for recursion on the ordinal * 0 and the facility for self-referential definitions. Ordinal recursion on Nqthm has been discussed in detail elsewhere [13], and in any case, by Gentzen <ref> [7] </ref>, there was never any doubt that this feature went beyond P RA. The use or non-use of this feature is easy to document; if the source file does not contain the word ORD-LESSP, then ordinal recursion is never invoked.
Reference: [8] <author> K. </author> <title> Godel, Zur intuitionistischen Arithmetik und Zahlentheorie, </title> <note> Ergebnisse eines Math-ematischen Kolloquiums 4 (1933) 34 - 38, reprinted in Feferman, </note> <editor> Dawson, Kleene, Moore, Solovay, and van Heijenoort, </editor> <booktitle> Kurt Godel Collected Works, </booktitle> <volume> Volume 1, </volume> <publisher> Oxford University Press, </publisher> <year> 1986. </year>
Reference-contexts: To show that HA is weaker than P A, one must refer to Kleene's result, mentioned above, that instances of (1) are not provable in HA. By the Incompleteness Theorem, P A 0 CON (HA), because P A 0 CON (P A) and, by another result of Godel <ref> [8] </ref>, CON (HA) , CON (P A) is provable in P A (and, in fact, in P RA). Now, as already mentioned, "constructive" is a philosophical notion, not a mathematical one, and hence need not be constrained by the specific formal rules of HA or any other formal system. <p> Now, as already mentioned, "constructive" is a philosophical notion, not a mathematical one, and hence need not be constrained by the specific formal rules of HA or any other formal system. In particular, although HA 0 CON (HA), there are two well-known proofs of CON (HA) (equivalently, by <ref> [8] </ref>, of CON (P A)), which many constructivists would accept. Kleene's [12] proof by recursive realizability formalizes the intuition that every statement provable from HA is constructively true. The other is due to Gentzen [7]. <p> (S 1 ; I 3 P 2 (I 1 1 (S 1 ; I 3 P 2 (I 1 1 (S 1 ; I 3 I 1 C 3 2 )[7; 0; 7] = 7 2 [7; 0; 7] = 7 C 3 2 )<ref> [7; 1; 8] </ref> = 9 2 [7; 1; 8] = 8 We can think of this as a tree, displayed in preorder traversal.
Reference: [9] <author> R. L. Goodstein, </author> <title> Recursive Number Theory, </title> <publisher> North-Holland 1964. </publisher>
Reference-contexts: Without quantifiers, induction in P RA can be formalized as a proof rule; for each quantifier-free : if ` (0) and ` (x) ) (x + 1) then ` (x) (4) The book by Goodstein <ref> [9] </ref> develops P RA in quite a bit of detail, proving basic facts about number theory, through the uniqueness of prime factorization. Also, via Godel numbering, one may prove within P RA most of the known mathematical theorems about finite structures. <p> Using the axioms about +; fl, plus induction, all the basic facts about +; fl (such as the associative, commutative, and distributive laws) may be derived; see <ref> [9, 5] </ref>. Likewise, we may let x &lt; y abbreviate F (x; y) = S (0), where is some standard name for the definition of the &lt; predicate (actually, function see x2.4). Likewise, introduce abbreviations x y, x &gt; y, x y, etc. <p> Likewise, introduce abbreviations x y, x &gt; y, x y, etc. Call a formula pure iff it is built using only the F for a pure primitive recursive name (see x2.1). Let P RA 0 be P RA restricted to pure formulas. The usual definition of P RA <ref> [9] </ref> is actually our P RA 0 . However, our P RA is a conservative extension of P RA 0 , since our axioms say nothing at all about the value of the wild cards. Formally, 3.1.1. Lemma. <p> If k is the Godel number of the formula S (0) = 0, we can let CON (P RA) be the formula F P F (pkq; y) = 0. Then CON (P RA) is not provable in P RA; see <ref> [9] </ref> for an explanation of the Incompleteness Theorem in the P RA 0 setting. Note that CON (P RA 0 ) , CON (P RA) is provable in P RA. Every true ground pure statement (such as p3q + p4q = p7q) is provable in P RA.
Reference: [10] <author> M. Kaufmann, </author> <title> An Extension of the Boyer-Moore Theorem Prover to Support First-Order Quantification, </title> <journal> J. Automated Reasoning, </journal> <volume> 9 (1992) 355 - 372. </volume>
Reference-contexts: However, one might then argue for a more straightforward implementation of P RA fl or a stronger theory, where the unbounded operator is explicit; something of this nature has already been done as a modification of Nqthm by Kaufmann <ref> [10] </ref>. The full strength of Nqthm has not really been clear even to the community of users of the system, and the script described in x4.2 managed to hack Nqthm to produce results beyond what was commonly expected to be possible.
Reference: [11] <author> J. Ketonen and R. Solovay, </author> <title> Rapidly Growing Ramsey Functions, </title> <note> Annals of Math 113 (1981) 267 - 314. </note>
Reference-contexts: This is a simple combinatorial statement which is provable in P RA 00 , but not in P A. A direct proof from P RA 00 was given by Ketonen and Solovay <ref> [11] </ref>; see [13] for a simpler proof. We turn now to practice. There are many computer systems available for verifying proofs in mathematical logic.
Reference: [12] <author> S. C. Kleene, </author> <title> Introduction to Metamathematics, </title> <publisher> Van Nostrand, </publisher> <year> 1952. </year>
Reference-contexts: A constructivist would simply not accept such a definition of a function. For further discussion of constructivism, see Beeson [2] or Troelstra [17]. Kleene <ref> [12] </ref> turned the above philosophical argument into a mathematical theorem. The system HA (Heyting Arithmetic) is an attempt to formalize constructive number theory. HA has exactly the same axioms as does P A, but allows only intuitionistic logic in its proofs. By [12], (1) is not provable within HA unless one <p> Kleene <ref> [12] </ref> turned the above philosophical argument into a mathematical theorem. The system HA (Heyting Arithmetic) is an attempt to formalize constructive number theory. HA has exactly the same axioms as does P A, but allows only intuitionistic logic in its proofs. By [12], (1) is not provable within HA unless one can produce a recursive f and prove (2 0 ); in particular, one can write down specific primitive recursive for which (1) is not provable in HA. Now, finitism is an extreme version of constructivism. <p> In particular, although HA 0 CON (HA), there are two well-known proofs of CON (HA) (equivalently, by [8], of CON (P A)), which many constructivists would accept. Kleene's <ref> [12] </ref> proof by recursive realizability formalizes the intuition that every statement provable from HA is constructively true. The other is due to Gentzen [7]. Let P RA 00 be obtained by adding to P RA induction and recursion on the ordinal * 0 . <p> REMARKS ON RECURSION THEORY x2.1. Names. The partial recursive functions form the least class containing some simple basic functions and closed under primitive recursion and the operator. Following Kleene <ref> [12] </ref> (roughly), each such function can be denoted by a name, which describes how it was constructed. Formally, the names are those symbolic entities built by applying the following rules; j; n; m all denote natural numbers: Base names (Identity, Zero, Successor function, Wild cards): 1. <p> For y =2 dom (f), the natural C or Lisp program for computing f (y) will not return a value. The Second Recursion Theorem (Kleene <ref> [12] </ref>) is the less obvious fact that one can actually define f from a Godel number for f . <p> This is what is usually called a course-of-values 18 recursion, but, as is well-known <ref> [12] </ref>, such recursions can be reduced to standard primitive recursions. Furthermore, Nqthm functions operate not only on natural numbers but also on Lisp S-expressions. There is a built-in function, count, which measures the complexity of S-expressions. If y is a natural number, then count (y) = y. <p> As described in Kleene <ref> [12] </ref>, the use of such recursive schemas is an alternate way of obtaining all the partial recursive functions, so that we can in fact in this way name every partial recursive function.
Reference: [13] <author> K. Kunen, </author> <title> A Ramsey Theorem in Boyer-Moore Logic, </title> <journal> J. </journal> <note> Automated Reasoning, to appear. </note>
Reference-contexts: This is a simple combinatorial statement which is provable in P RA 00 , but not in P A. A direct proof from P RA 00 was given by Ketonen and Solovay [11]; see <ref> [13] </ref> for a simpler proof. We turn now to practice. There are many computer systems available for verifying proofs in mathematical logic. One of the most well known among these is the system Nqthm, developed by Boyer and Moore [5], and described by them as a system of "computational logic". <p> By the second extension, Nqthm really contains P RA 00 . The use of ordinals in Nqthm 3 itself was described in some detail in <ref> [13] </ref>, including a verification on Nqthm of the Paris--Harrington Ramsey theorem. Still, as pointed out above, this extension remains "constructive" in some sense. Now, the third extension to Nqthm is not constructive at all. <p> These may be viewed as recursion on the ordinal ! 2 , and one could even go up to recursions on * 0 . Many constructivists would accept these extensions as constructive (see the Introduction), but we do not dwell on these here, as we have discussed them elsewhere <ref> [13] </ref>. Another candidate is to formalize the operator. This also seems natural, but it is definitely not constructive. We take this up in the next section. 15 We remark here that induction on ! 2 or even ! n is completely within P RA. That is, 3.1.5. Lemma. <p> As mentioned in the Introduction, the two features which go beyond P RA are the facility for recursion on the ordinal * 0 and the facility for self-referential definitions. Ordinal recursion on Nqthm has been discussed in detail elsewhere <ref> [13] </ref>, and in any case, by Gentzen [7], there was never any doubt that this feature went beyond P RA. The use or non-use of this feature is easy to document; if the source file does not contain the word ORD-LESSP, then ordinal recursion is never invoked.
Reference: [14] <author> J. Paris and L. Harrington, </author> <title> A Mathematical Incompleteness in Peano Arithmetic, in Handbook of Mathematical Logic, </title> <editor> J. Barwise, ed., </editor> <publisher> North-Holland, </publisher> <year> 1978, </year> <pages> pp. 1133 - 1142. </pages>
Reference-contexts: In fact, we see no reason why there could not be a constructive proof of CON (ZF ). Aside from "logic" results, Paris and Harrington <ref> [14] </ref> describe a strengthening of Ram-sey's Theorem which is provably equivalent to CON (P A). This is a simple combinatorial statement which is provable in P RA 00 , but not in P A.
Reference: [15] <author> C. Parsons, </author> <title> On a Number-theoretic Choice Scheme and its Relation to Induction, in Intuitionism and Proof Theory, </title> <editor> Kino. Myhill, and Vessley, eds., </editor> <publisher> North-Holland, </publisher> <pages> pp. 459-473. </pages> <note> See also JSL 37 (1972) 466 - 482. </note>
Reference-contexts: Also, via Godel numbering, one may prove within P RA most of the known mathematical theorems about finite structures. For example, one may prove Ramsey's Theorem, along with all the basic theorems on the structure of finite groups and fields. The papers by Parsons <ref> [15] </ref> and Sieg [16] say more about the proof-theoretic strength of P RA. Still, P RA is weaker than HA. For example, the Ackermann function is a well-known recursive function which is not primitive recursive.
Reference: [16] <author> W. Sieg, </author> <title> Fragments of Arithmetic, </title> <note> APAL 28 (1985) 33 - 71. </note>
Reference-contexts: Also, via Godel numbering, one may prove within P RA most of the known mathematical theorems about finite structures. For example, one may prove Ramsey's Theorem, along with all the basic theorems on the structure of finite groups and fields. The papers by Parsons [15] and Sieg <ref> [16] </ref> say more about the proof-theoretic strength of P RA. Still, P RA is weaker than HA. For example, the Ackermann function is a well-known recursive function which is not primitive recursive.
Reference: [17] <author> A. S. </author> <title> Troelstra, </title> <journal> Constructivism in Mathematics, </journal> <volume> Volume 1, </volume> <publisher> North-Holland, </publisher> <year> 1988. </year> <month> 25 </month>
Reference-contexts: A constructivist would simply not accept such a definition of a function. For further discussion of constructivism, see Beeson [2] or Troelstra <ref> [17] </ref>. Kleene [12] turned the above philosophical argument into a mathematical theorem. The system HA (Heyting Arithmetic) is an attempt to formalize constructive number theory. HA has exactly the same axioms as does P A, but allows only intuitionistic logic in its proofs.
References-found: 17

