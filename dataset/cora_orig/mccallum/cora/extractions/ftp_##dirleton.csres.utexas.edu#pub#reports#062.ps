URL: ftp://dirleton.csres.utexas.edu/pub/reports/062.ps
Refering-URL: http://www.cli.com/reports/
Root-URL: http://www.aic.nrl.navy.mil/~aha/people.html
Author: William R. Bevier William D. Young 
Date: November 1990  
Note: Contract NAS1-18878  
Address: Austin, Texas  
Affiliation: Computational Logic, Inc.  
Abstract: NASA Contractor Report 182099 Machine Checked Proofs of the Design and Implementation of a Fault-Tolerant Circuit 
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> R. S. Boyer and J S. Moore. </author> <title> A Computational Logic. </title> <publisher> Academic Press, </publisher> <address> New York, </address> <year> 1979. </year>
Reference-contexts: They also proved that under certain assumptions about the type of interprocess communication, the problem is solvable if and only if the total number of processors exceeds three times the number of faulty processors. We have performed a machine checked proof using the Boyer-Moore theorem prover <ref> [1, 3] </ref> that an ``abstract implementation'' of the OM Algorithm does achieve interactive consistency in the presence of faults. Mechanical checking of this proof is significant for several reasons. It is the first machine checked proof of which we are aware of this quite difficult algorithm. <p> The Specification 3.1 Our Formal Definition of the Algorithm We have formalized a version of the Oral Messages algorithm in the computational logic of Boyer and Moore <ref> [1, 3] </ref>. An interesting aspect of this formalization is that, except for a few simple subsidiary definitions, the entire complexity of the algorithm is captured in around 15 lines of ``code.'' We introduce these subsidiary definitions and then explain the formal version of the algorithm itself. <p> To relate the two traces, it is useful to define the notion 22 Case Counter: 0: data_out [i] sense, i -0, 1, 2 icv [3] sense clock clock+1 1: matrix [0,i] input [i], i -0, 1, 2 data_out [0] input <ref> [1] </ref> data_out [1] input [0] data_out [2] input [0] clock clock+1 2: matrix [1,i] input [i], i -0, 1, 2 data_out [0] matrix [0,2] data_out [1] matrix [0,2] data_out [2] matrix [0,1] clock clock+1 3: matrix [2,i] input [i], i -0, 1, 2 clock clock+1 4: icv [0] majority (matrix [0,0], <p> To relate the two traces, it is useful to define the notion 22 Case Counter: 0: data_out [i] sense, i -0, 1, 2 icv [3] sense clock clock+1 1: matrix [0,i] input [i], i -0, 1, 2 data_out [0] input <ref> [1] </ref> data_out [1] input [0] data_out [2] input [0] clock clock+1 2: matrix [1,i] input [i], i -0, 1, 2 data_out [0] matrix [0,2] data_out [1] matrix [0,2] data_out [2] matrix [0,1] clock clock+1 3: matrix [2,i] input [i], i -0, 1, 2 clock clock+1 4: icv [0] majority (matrix [0,0], matrix [1,2], <p> 0: data_out [i] sense, i -0, 1, 2 icv [3] sense clock clock+1 1: matrix [0,i] input [i], i -0, 1, 2 data_out [0] input <ref> [1] </ref> data_out [1] input [0] data_out [2] input [0] clock clock+1 2: matrix [1,i] input [i], i -0, 1, 2 data_out [0] matrix [0,2] data_out [1] matrix [0,2] data_out [2] matrix [0,1] clock clock+1 3: matrix [2,i] input [i], i -0, 1, 2 clock clock+1 4: icv [0] majority (matrix [0,0], matrix [1,2], matrix [2,1]) icv [1] majority (matrix [0,1], matrix [1,0], matrix [2,2]) icv [2] majority (matrix [0,2], matrix [1,1], matrix [2,0]) clock clock+1 5: <p> [2] input [0] clock clock+1 2: matrix [1,i] input [i], i -0, 1, 2 data_out [0] matrix [0,2] data_out <ref> [1] </ref> matrix [0,2] data_out [2] matrix [0,1] clock clock+1 3: matrix [2,i] input [i], i -0, 1, 2 clock clock+1 4: icv [0] majority (matrix [0,0], matrix [1,2], matrix [2,1]) icv [1] majority (matrix [0,1], matrix [1,0], matrix [2,2]) icv [2] majority (matrix [0,2], matrix [1,1], matrix [2,0]) clock clock+1 5: Actuator filter (icv) clock clock+1 6: clock clock+1 7: clock clock+1 st of n-selection. The n-selection of trace is the list consisting of successive (n - 1) elements of trace.
Reference: 2. <author> Robert S. Boyer and J Strother Moore. </author> <title> A Mechanical Proof of the Turing Completeness of Pure Lisp. </title> <type> Technical Report ICSCA-CMP-37, </type> <institution> Institute for Computing Science and Computer Appplications, University of Texas at Austin, </institution> <year> 1983. </year>
Reference-contexts: To relate the two traces, it is useful to define the notion 22 Case Counter: 0: data_out [i] sense, i -0, 1, 2 icv [3] sense clock clock+1 1: matrix [0,i] input [i], i -0, 1, 2 data_out [0] input [1] data_out [1] input [0] data_out <ref> [2] </ref> input [0] clock clock+1 2: matrix [1,i] input [i], i -0, 1, 2 data_out [0] matrix [0,2] data_out [1] matrix [0,2] data_out [2] matrix [0,1] clock clock+1 3: matrix [2,i] input [i], i -0, 1, 2 clock clock+1 4: icv [0] majority (matrix [0,0], matrix [1,2], matrix [2,1]) icv [1] <p> i -0, 1, 2 icv [3] sense clock clock+1 1: matrix [0,i] input [i], i -0, 1, 2 data_out [0] input [1] data_out [1] input [0] data_out <ref> [2] </ref> input [0] clock clock+1 2: matrix [1,i] input [i], i -0, 1, 2 data_out [0] matrix [0,2] data_out [1] matrix [0,2] data_out [2] matrix [0,1] clock clock+1 3: matrix [2,i] input [i], i -0, 1, 2 clock clock+1 4: icv [0] majority (matrix [0,0], matrix [1,2], matrix [2,1]) icv [1] majority (matrix [0,1], matrix [1,0], matrix [2,2]) icv [2] majority (matrix [0,2], matrix [1,1], matrix [2,0]) clock clock+1 5: Actuator filter (icv) clock <p> [i], i -0, 1, 2 data_out [0] matrix [0,2] data_out [1] matrix [0,2] data_out <ref> [2] </ref> matrix [0,1] clock clock+1 3: matrix [2,i] input [i], i -0, 1, 2 clock clock+1 4: icv [0] majority (matrix [0,0], matrix [1,2], matrix [2,1]) icv [1] majority (matrix [0,1], matrix [1,0], matrix [2,2]) icv [2] majority (matrix [0,2], matrix [1,1], matrix [2,0]) clock clock+1 5: Actuator filter (icv) clock clock+1 6: clock clock+1 7: clock clock+1 st of n-selection. The n-selection of trace is the list consisting of successive (n - 1) elements of trace. <p> The Boyer Moore logic is first order. Our formal statement of the impossibility result used several features which have been added recently to the Boyer-Moore logic and illustrated a somewhat surprising versatility of the logic. We are aware of at least two previous proofs of impossibility results <ref> [2, 9] </ref> carried out in the logic. However, these results were specified and proved before the addition of these constructs which are currently available.
Reference: 3. <author> R. S. Boyer and J S. Moore. </author> <title> A Computational Logic Handbook. </title> <publisher> Academic Press, </publisher> <address> Boston, </address> <year> 1988. </year>
Reference-contexts: They also proved that under certain assumptions about the type of interprocess communication, the problem is solvable if and only if the total number of processors exceeds three times the number of faulty processors. We have performed a machine checked proof using the Boyer-Moore theorem prover <ref> [1, 3] </ref> that an ``abstract implementation'' of the OM Algorithm does achieve interactive consistency in the presence of faults. Mechanical checking of this proof is significant for several reasons. It is the first machine checked proof of which we are aware of this quite difficult algorithm. <p> The Specification 3.1 Our Formal Definition of the Algorithm We have formalized a version of the Oral Messages algorithm in the computational logic of Boyer and Moore <ref> [1, 3] </ref>. An interesting aspect of this formalization is that, except for a few simple subsidiary definitions, the entire complexity of the algorithm is captured in around 15 lines of ``code.'' We introduce these subsidiary definitions and then explain the formal version of the algorithm itself. <p> We assume for convenience that process names are simply numbers in the range [0..n-1]. Figure 4 introduces some subsidiary functions we need to describe the Oral Messages algorithm and its correctness properties. All expressions are in the Lisp-like prefix notation of the Boyer-Moore logic. (See <ref> [3] </ref> for a complete description of the syntax of our notation.) To formalize the notion of interprocess communication, we also introduce the function send. <p> ICV <ref> [3] </ref> holds the process's local value, derived from the sense input for that process. The inter-connection of the processes to accomplish information exchange is depicted in Figure 12. Each arrow represents one-way communication. <p> The purpose of each step is described below. The steps are numbered by the value of the 3-bit counter. The four processes share the clock input and hence perform these steps synchronously. 0. Read the sensed input. Save this as the process's local value in ICV <ref> [3] </ref>. Also, place this value on the output lines to the other three processes. This begins the report of each process's local value to all of the other processes. 1. Receive the local values of the other three processes, and store them in row 0 of the matrix. 2,3. <p> The intermediate steps of the trace are not of interest in the statement of interactive consistency. To relate the two traces, it is useful to define the notion 22 Case Counter: 0: data_out [i] sense, i -0, 1, 2 icv <ref> [3] </ref> sense clock clock+1 1: matrix [0,i] input [i], i -0, 1, 2 data_out [0] input [1] data_out [1] input [0] data_out [2] input [0] clock clock+1 2: matrix [1,i] input [i], i -0, 1, 2 data_out [0] matrix [0,2] data_out [1] matrix [0,2] data_out [2] matrix [0,1] clock clock+1 3: <p> The reader is invited to scrutinize the proof in [8], as our machine checked version follows very closely the proof given there. 27 5.3 Specifying the Problem in the Boyer-Moore Logic In this section we explain the specification of this problem in the Boyer-Moore logic <ref> [3] </ref>. The version of the logic used has been extended with facilities for handling quantification [5], free variables [6], and functional variables [4]. We assume the reader is familiar with this version of the logic.
Reference: 4. <author> R.S. Boyer, D. Goldschlag, M. Kaufmann, J S. Moore. </author> <title> Functional Instantiation in First Order Logic. </title> <type> Tech. </type> <institution> Rept. </institution> <month> 44, </month> <title> Computational Logic, </title> <publisher> Inc., </publisher> <month> May, </month> <year> 1989. </year> <booktitle> Published in proceedings of the 1989 Workshop on Programming Logic, Programming Methodology Group, </booktitle> <institution> University of Goteborg, West Germany. </institution>
Reference-contexts: However, these results were specified and proved before the addition of these constructs which are currently available. Though we believe that this specification and proof could have been carried out without them, the use of the partial specification capability <ref> [4] </ref> and quantification and free variables [5] made the specification of the problem extremely natural. 5.1 Review of the Theorem To state the problem, we find it convenient to quote rather extensively from [8]. + First, define a scenario as a mapping from the set P of all nonempty strings over <p> The version of the logic used has been extended with facilities for handling quantification [5], free variables [6], and functional variables <ref> [4] </ref>. We assume the reader is familiar with this version of the logic. Key notions in the statement of the formal proof are those of a scenario and of a p-scenario. We do not find it necessary to define these notions directly.
Reference: 5. <author> Matt Kaufmann. DEFN-SK: </author> <title> An Extension of the Boyer-Moore Theorem Prover to Handle First-Order Quantifiers. </title> <type> Tech. </type> <institution> Rept. </institution> <month> 43, </month> <title> Computational Logic, </title> <publisher> Inc., </publisher> <month> May, </month> <year> 1989. </year>
Reference-contexts: However, these results were specified and proved before the addition of these constructs which are currently available. Though we believe that this specification and proof could have been carried out without them, the use of the partial specification capability [4] and quantification and free variables <ref> [5] </ref> made the specification of the problem extremely natural. 5.1 Review of the Theorem To state the problem, we find it convenient to quote rather extensively from [8]. + First, define a scenario as a mapping from the set P of all nonempty strings over P, to V. <p> The version of the logic used has been extended with facilities for handling quantification <ref> [5] </ref>, free variables [6], and functional variables [4]. We assume the reader is familiar with this version of the logic. Key notions in the statement of the formal proof are those of a scenario and of a p-scenario. We do not find it necessary to define these notions directly. <p> Next we define the notion of a scenario s being consistent with N, where N is a set of nonfaulty processors. This is defined via the Skolemized Definition event below. Such an event defines a concept involving explicit quantification by adding axioms representing the Skolemization of the event. (See <ref> [5] </ref> for details.) Notice that the definition n-consistent is very close to the definition of this concept in [8].
Reference: 6. <author> M. Kaufmann. </author> <title> Addition of Free Variables to an Interactive Enchancement of the Boyer-Moore Theorem Prover. </title> <type> Tech. </type> <institution> Rept. </institution> <month> 42, </month> <title> Computational Logic, </title> <publisher> Inc., </publisher> <address> 1717 West Sixth Street, Suite 290 Austin, TX 78703, </address> <year> 1990. </year>
Reference-contexts: The version of the logic used has been extended with facilities for handling quantification [5], free variables <ref> [6] </ref>, and functional variables [4]. We assume the reader is familiar with this version of the logic. Key notions in the statement of the formal proof are those of a scenario and of a p-scenario. We do not find it necessary to define these notions directly.
Reference: 7. <author> Leslie Lamport, Robert Shostak, and Marshall Pease. </author> <title> "The Byzantine Generals Problem". </title> <journal> ACM TOPLAS 4, </journal> <month> 3 (July </month> <year> 1982), </year> <pages> 382-401. </pages>
Reference-contexts: This problem, called the Byzantine Generals problem or the problem of achieving interactive consistency, was described and solved in certain cases by Pease, Shostak, and Lamport <ref> [7, 8] </ref>. They provided an extremely clever algorithm called the ``Oral Messages'' (OM) algorithm which implements a solution to this problem. <p> Lamport, Shostak, and Pease <ref> [7] </ref> describe the problem in terms of the rather colorful metaphor of Byzantine Generals attempting to arrive at a common battle plan through an exchange of messages. One or more of the generals may be traitorous and attempt to thwart the loyal generals by preventing them from reaching agreement. <p> All loyal lieutenants obey the same order. IC2. If the commanding general is loyal, then every loyal lieutenant obeys the order he sends. Conditions IC1 and IC2 are called the interactive consistency conditions. <ref> [7] </ref> We assume that the generals communicate only via oral messages. That is, their communication is assumed to have the following characteristics. 1. Every message that is sent is correctly delivered. 2. The receiver of a message knows who sent it. 3. The absence of a message can be detected. <p> The description of the algorithm from <ref> [7] </ref> is quoted in Figure 1. The execution of the algorithm for four processors where exactly one is faulty is illustrated in Figures 2 and 3. of three lieutenants, one of whom is traitorous. <p> In this section we display the theorems which establish that the formal analogues of IC1 and IC2 hold for the version of the Oral Messages algorithm described in the previous section. The version of this correctness theorem given by Lamport, Shostak, and Pease <ref> [7] </ref> is: THEOREM 1: For any m, Algorithm OM (m) satisfies conditions IC1 and IC2 if there are more 10 than 3m generals and at most m traitors. One issue is how to introduce the notion of a faulty process. <p> This does not imply, however, that the completely formal treatment required to render the proof acceptable to a mechanical proof checker is useless. We believe that we gained considerable insight into the Oral Messages algorithm from our formalization. To illustrate this, consider the proof of the following lemma from <ref> [7] </ref>. This is the key lemma from which IC2 follows. LEMMA 1: For any m and k, Algorithm OM (m) satisfies IC2 if there are more than 2k + m generals and at most k traitors. PROOF. The proof is by induction on m.
Reference: 8. <author> Marshall Pease, Robert Shostak, and Leslie Lamport. </author> <title> "Reaching Agreement in the Presence of Faults". </title> <type> JACM 27, </type> <month> 2 (April </month> <year> 1980), </year> <pages> 228-234. </pages>
Reference-contexts: This problem, called the Byzantine Generals problem or the problem of achieving interactive consistency, was described and solved in certain cases by Pease, Shostak, and Lamport <ref> [7, 8] </ref>. They provided an extremely clever algorithm called the ``Oral Messages'' (OM) algorithm which implements a solution to this problem. <p> This verified low-level description has been physically realized in programmable logic arrays. A significant assumption in our design is that the redundant processors behave synchronously. Future work will be directed at eliminating the need for this requirement. Finally, we have machine checked the proof <ref> [8] </ref> that no algorithm exists which achieves interactive 1 consistency via an exchange of ``oral'' messages if the number of faulty processors is at least one third of the total. <p> In general, with n processors of which m are faulty the OM algorithm achieves interactive consistency with m exchanges if n 3m + 1. In section 5 we discuss the proof <ref> [8] </ref> that there is no scheme by which a group of processes can reliably reach agreement if a larger proportion are faulty. 3. <p> The Impossibility Result The OM algorithm described in the previous sections achieves interactive consistency in the presence of m faults if there are at least 3m + 1 total generals. An interesting fact proved by Pease, Shostak, and Lamport <ref> [8] </ref> is that this performance is optimal in the sense that no algorithm can achieve interactive consistency solely via message exchange if there are more faults. We have formalized this result in the Boyer-Moore logic machine checked its proof. <p> specification and proof could have been carried out without them, the use of the partial specification capability [4] and quantification and free variables [5] made the specification of the problem extremely natural. 5.1 Review of the Theorem To state the problem, we find it convenient to quote rather extensively from <ref> [8] </ref>. + First, define a scenario as a mapping from the set P of all nonempty strings over P, to V. For a + given p P define a p-scenario as a mapping from the subset of P , consisting of strings beginning with p, to V. <p> If this third processor is faulty, we have no assurance that this common value is actually the private value of that process; it may be some ``default'' value. The theorem from <ref> [8] </ref> which states our desired impossibility result is given below: THEOREM. <p> We then define three scenario's which behave as a, b, and s. The reader is invited to scrutinize the proof in <ref> [8] </ref>, as our machine checked version follows very closely the proof given there. 27 5.3 Specifying the Problem in the Boyer-Moore Logic In this section we explain the specification of this problem in the Boyer-Moore logic [3]. <p> This is defined via the Skolemized Definition event below. Such an event defines a concept involving explicit quantification by adding axioms representing the Skolemization of the event. (See [5] for details.) Notice that the definition n-consistent is very close to the definition of this concept in <ref> [8] </ref>. Skolemized Definition. (n-consistent sigma N) = (forall (w p q) (implies (member q N) (equal (apply-scenario sigma (cons p (cons q w))) (apply-scenario sigma (cons q w))))) To define our key concepts, we'll need the auxiliary notion of p-scenario-equivalence. <p> Since we would like to prove that under certain conditions no such algorithm exists, we need a very general characterization of the possible candidates for such an algorithm. We constrain a family of functions Ff. This family represents the collection of functions characterized in the notation of <ref> [8] </ref> as -F | p P-. Ff is conceptually a second order function which takes a p-scenario and a processor q and p returns the private value which p computes for processor q on the basis of the information in the p-scenario. <p> We also assume p N, q N, and r Pp. Under these assumption, Ff assures interactive consistency for m faults if the conclusion is satisfied. Notice that the two conjuncts of the conclusion are exactly (i) and (ii) of the definition of interactive consistency for m faults of <ref> [8] </ref>. Namely, F (s , q) = s (q), p p F (s , r) = F (s , r). p qp q Given this definition/conjecture, it is straightforward to state the Boyer-Moore analogue of the impossibility result. 31 Theorem. <p> Notice that the assumption that Pp can be partitioned into three nonempty subsets is implicit in the proof given in <ref> [8] </ref> but is certainly not implied by their statement of the theorem. The theorem as stated in [8] is false if |Pp| &lt; 3, since interactive consistency can always be achieved in that case. 5.4 The Machine Checked Proof The basic structure of the proof is very similar to that of <p> Notice that the assumption that Pp can be partitioned into three nonempty subsets is implicit in the proof given in <ref> [8] </ref> but is certainly not implied by their statement of the theorem. The theorem as stated in [8] is false if |Pp| &lt; 3, since interactive consistency can always be achieved in that case. 5.4 The Machine Checked Proof The basic structure of the proof is very similar to that of the proof in [8] which is described as follows: Since n 3m, P can be partitioned into <p> The theorem as stated in <ref> [8] </ref> is false if |Pp| &lt; 3, since interactive consistency can always be achieved in that case. 5.4 The Machine Checked Proof The basic structure of the proof is very similar to that of the proof in [8] which is described as follows: Since n 3m, P can be partitioned into three nonempty sets A, B, and C [it is here that we need our additional hypothesis that n &gt; 3], each of which has no more than m members.
Reference: 9. <author> N. Shankar. </author> <title> Checking the proof of Godel's incompleteness theorem. </title> <institution> Institute for Computing Science, University of Texas at Austin, </institution> <year> 1986. </year> <title> 36 Table of Contents </title>
Reference-contexts: The Boyer Moore logic is first order. Our formal statement of the impossibility result used several features which have been added recently to the Boyer-Moore logic and illustrated a somewhat surprising versatility of the logic. We are aware of at least two previous proofs of impossibility results <ref> [2, 9] </ref> carried out in the logic. However, these results were specified and proved before the addition of these constructs which are currently available.
Reference: 1. <institution> Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1 </institution>
Reference-contexts: They also proved that under certain assumptions about the type of interprocess communication, the problem is solvable if and only if the total number of processors exceeds three times the number of faulty processors. We have performed a machine checked proof using the Boyer-Moore theorem prover <ref> [1, 3] </ref> that an ``abstract implementation'' of the OM Algorithm does achieve interactive consistency in the presence of faults. Mechanical checking of this proof is significant for several reasons. It is the first machine checked proof of which we are aware of this quite difficult algorithm. <p> The Specification 3.1 Our Formal Definition of the Algorithm We have formalized a version of the Oral Messages algorithm in the computational logic of Boyer and Moore <ref> [1, 3] </ref>. An interesting aspect of this formalization is that, except for a few simple subsidiary definitions, the entire complexity of the algorithm is captured in around 15 lines of ``code.'' We introduce these subsidiary definitions and then explain the formal version of the algorithm itself. <p> To relate the two traces, it is useful to define the notion 22 Case Counter: 0: data_out [i] sense, i -0, 1, 2 icv [3] sense clock clock+1 1: matrix [0,i] input [i], i -0, 1, 2 data_out [0] input <ref> [1] </ref> data_out [1] input [0] data_out [2] input [0] clock clock+1 2: matrix [1,i] input [i], i -0, 1, 2 data_out [0] matrix [0,2] data_out [1] matrix [0,2] data_out [2] matrix [0,1] clock clock+1 3: matrix [2,i] input [i], i -0, 1, 2 clock clock+1 4: icv [0] majority (matrix [0,0], <p> To relate the two traces, it is useful to define the notion 22 Case Counter: 0: data_out [i] sense, i -0, 1, 2 icv [3] sense clock clock+1 1: matrix [0,i] input [i], i -0, 1, 2 data_out [0] input <ref> [1] </ref> data_out [1] input [0] data_out [2] input [0] clock clock+1 2: matrix [1,i] input [i], i -0, 1, 2 data_out [0] matrix [0,2] data_out [1] matrix [0,2] data_out [2] matrix [0,1] clock clock+1 3: matrix [2,i] input [i], i -0, 1, 2 clock clock+1 4: icv [0] majority (matrix [0,0], matrix [1,2], <p> 0: data_out [i] sense, i -0, 1, 2 icv [3] sense clock clock+1 1: matrix [0,i] input [i], i -0, 1, 2 data_out [0] input <ref> [1] </ref> data_out [1] input [0] data_out [2] input [0] clock clock+1 2: matrix [1,i] input [i], i -0, 1, 2 data_out [0] matrix [0,2] data_out [1] matrix [0,2] data_out [2] matrix [0,1] clock clock+1 3: matrix [2,i] input [i], i -0, 1, 2 clock clock+1 4: icv [0] majority (matrix [0,0], matrix [1,2], matrix [2,1]) icv [1] majority (matrix [0,1], matrix [1,0], matrix [2,2]) icv [2] majority (matrix [0,2], matrix [1,1], matrix [2,0]) clock clock+1 5: <p> [2] input [0] clock clock+1 2: matrix [1,i] input [i], i -0, 1, 2 data_out [0] matrix [0,2] data_out <ref> [1] </ref> matrix [0,2] data_out [2] matrix [0,1] clock clock+1 3: matrix [2,i] input [i], i -0, 1, 2 clock clock+1 4: icv [0] majority (matrix [0,0], matrix [1,2], matrix [2,1]) icv [1] majority (matrix [0,1], matrix [1,0], matrix [2,2]) icv [2] majority (matrix [0,2], matrix [1,1], matrix [2,0]) clock clock+1 5: Actuator filter (icv) clock clock+1 6: clock clock+1 7: clock clock+1 st of n-selection. The n-selection of trace is the list consisting of successive (n - 1) elements of trace.




Reference: 6. <institution> Conclusion . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 34 i </institution>
Reference-contexts: The version of the logic used has been extended with facilities for handling quantification [5], free variables <ref> [6] </ref>, and functional variables [4]. We assume the reader is familiar with this version of the logic. Key notions in the statement of the formal proof are those of a scenario and of a p-scenario. We do not find it necessary to define these notions directly.
References-found: 11

