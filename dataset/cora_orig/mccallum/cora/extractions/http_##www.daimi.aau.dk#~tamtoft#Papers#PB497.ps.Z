URL: http://www.daimi.aau.dk/~tamtoft/Papers/PB497.ps.Z
Refering-URL: http://www.daimi.aau.dk/~tamtoft/papers.html
Root-URL: http://www.daimi.aau.dk
Email: ftamtoft,fn,hrng@daimi.aau.dk  
Title: Type and Behaviour Reconstruction for Higher-Order Concurrent Programs  
Author: Torben Amtoft, Flemming Nielson, Hanne Riis Nielson 
Date: November 13, 1995  
Address: Ny Munkegade, DK-8000 Arhus C, Denmark  
Affiliation: DAIMI, Aarhus University  
Abstract-found: 0
Intro-found: 1
Reference: [BD93] <author> Dominique Bolignano and Mourad Debabi. </author> <title> A coherent type system for a concurrent, functional and imperative programming language. </title> <booktitle> In AMAST '93, </booktitle> <year> 1993. </year>
Reference-contexts: The former case will arise if ff chan is handled as ff list; whereas the latter case will arise if ff chan is handled by the techniques for ff ref developed in [TJ94] and <ref> [BD93] </ref>. The approach in [TJ94]. We have seen that there are several possibilities for satisfying (5.1) and (5.2); so settling on the downwards closure as we have done may seem somewhat arbitrary but can be justified by observing the similarities to what is done in [TJ94].
Reference: [BS94] <author> Bernard Berthomieu and Thierry Le Sergent. </author> <title> Programming with behaviours in an ML framework: the syntax and semantics of LCS. </title> <booktitle> In ESOP '94, volume 788 of LNCS, </booktitle> <pages> pages 89-104. </pages> <publisher> Springer-Verlag, </publisher> <year> 1994. </year>
Reference-contexts: Our research has been motivated by the integration of the functional and concurrent programming paradigms. Example programming languages are CML [Rep91] that extends Standard ML with concurrency, Facile [PGM90] that follows a similar approach but more directly contains syntax for expressing CCS-like process composition, and LCS <ref> [BS94] </ref>. The overall communication structure of such programs may not be immediately clear and hence one would like to find compact ways of recording the communications taking place during execution. One such representation is behaviours, a kind of process algebra expressions.
Reference: [CC91] <author> Felice Cardone and Mario Coppo. </author> <title> Type inference with recursive types: Syntax and semantics. </title> <journal> Information and Computation, </journal> <volume> 92 </volume> <pages> 48-80, </pages> <year> 1991. </year>
Reference-contexts: We say that F is upwards closed wrt. C if the following property to its finite unfoldings, and cf. <ref> [CC91] </ref> where a similar change in axiomatisation is made concerning recursive types). 2 We use fl to range over type variables and behaviour variables collectively and use g to range over types and behaviours collectively. 14 holds for all fiwb 2 C: if fv (b) " F 6= ; then fi
Reference: [Hen93] <author> Fritz Henglein. </author> <title> Type inference with polymorphic recursion. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 15(2) </volume> <pages> 253-289, </pages> <month> April </month> <year> 1993. </year>
Reference-contexts: We expect our S-constraints to fall into one of these (since they are generated in a "structured way") and hence one might be tempted to use e.g. the algorithm for semi-unification described in <ref> [Hen93] </ref>.
Reference: [JG91] <author> Pierre Jouvelot and David K. Gifford. </author> <title> Algebraic reconstruction of types and effects. </title> <booktitle> In ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 303-310. </pages> <publisher> ACM Press, </publisher> <year> 1991. </year>
Reference-contexts: This algorithm works by unification, but since our behaviours constitute a non-free algebra (due to the laws imposed on them) this approach is not immediately feasible in our framework. Instead we employ the technique of algebraic reconstruction <ref> [JG91, TJ92] </ref>; that is the algorithm unifies the free part of the type structure and generates constraints to cater for the non-free parts. This idea is carried out in [NN94b], where a reconstruction algorithm is presented which is sound but not complete. <p> One difference from the traditional formulation of W is that we generate so-called C-constraints that then have to be solved. This is a consequence of our behaviours being a non-free algebra and is an phenomenon found also in <ref> [JG91] </ref>. Another and major difference from the traditional formulation, as well as that of [JG91], is that we generate so-called S-constraints that also have to be solved. This phenomenon is needed because our C-constraints would seem not to have principal solutions. <p> This is a consequence of our behaviours being a non-free algebra and is an phenomenon found also in <ref> [JG91] </ref>. Another and major difference from the traditional formulation, as well as that of [JG91], is that we generate so-called S-constraints that also have to be solved. This phenomenon is needed because our C-constraints would seem not to have principal solutions. This is not the case for the traditional "free" unification of Standard ML, but it is a phenomenon well-known in unification theory [Sie89].
Reference: [Jon92] <author> Mark P. Jones. </author> <title> A theory of qualified types. </title> <booktitle> In ESOP '92, volume 582 of LNCS, </booktitle> <pages> pages 287-306. </pages> <publisher> Springer-Verlag, </publisher> <year> 1992. </year>
Reference-contexts: Often (as 24 in e.g. <ref> [Jon92] </ref>) the assumptions in a completeness proposition are (using the terminology of Prop. 7.3) that E [OE] is equal to E 0 ; but as in [Smi93] this is not sufficient since an identifier may be bound to a type scheme which is less general than the one to which it
Reference: [Mil78] <author> Robin Milner. </author> <title> A theory of type polymorphism in programming. </title> <journal> Journal of Computer and System Sciences, </journal> <volume> 17 </volume> <pages> 348-375, </pages> <year> 1978. </year>
Reference-contexts: Applications of such information are 1 demonstrated in [NN94a] and [NN94c]. The question remains: how to implement the inference system, i.e. how to reconstruct the types and behaviours? It seems suitable to use a modified version of algorithm W <ref> [Mil78] </ref>. This algorithm works by unification, but since our behaviours constitute a non-free algebra (due to the laws imposed on them) this approach is not immediately feasible in our framework. <p> in [NN93] uses subtyping instead of polymorphism), but in [NN94a] the C-constraints present in the definition of CTypeOf () have been "coded into" the types. 10 Chapter 4 Designing the reconstruction algorithm W Our goal is to produce an algorithm which works in the spirit of the well-known algorithm W <ref> [Mil78] </ref>, but due to the additional features present in our inference system some complications arise as will be described in the subsequent sections.
Reference: [NN93] <author> Flemming Nielson and Hanne Riis Nielson. </author> <title> From CML to process algebras. </title> <booktitle> In CONCUR '93, volume 715 of LNCS. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1993. </year> <note> An expanded version appears as DAIMI technical report no. PB-433. </note>
Reference-contexts: The overall communication structure of such programs may not be immediately clear and hence one would like to find compact ways of recording the communications taking place during execution. One such representation is behaviours, a kind of process algebra expressions. In <ref> [NN93] </ref> and [NN94a] inference systems are developed that extend the usual notion of types with behaviours. Applications of such information are 1 demonstrated in [NN94a] and [NN94c]. <p> w?ff ]) channel : 8 : : : (unit ! fi ff chan; [fiwff CHAN ]) fork : 8 : : : ((unit ! fi 1 ff) ! fi 2 unit; fi 2 wFORK fi 1 ) The inference system is much as in [NN94a] (whereas the inference system in <ref> [NN93] </ref> uses subtyping instead of polymorphism), but in [NN94a] the C-constraints present in the definition of CTypeOf () have been "coded into" the types. 10 Chapter 4 Designing the reconstruction algorithm W Our goal is to produce an algorithm which works in the spirit of the well-known algorithm W [Mil78], but
Reference: [NN94a] <author> Hanne Riis Nielson and Flemming Nielson. </author> <title> Higher-order concur-rent programs with finite communication topology. </title> <booktitle> In ACM Symposium on Principles of Programming Languages. </booktitle> <publisher> ACM Press, </publisher> <month> Jan-uary </month> <year> 1994. </year>
Reference-contexts: The overall communication structure of such programs may not be immediately clear and hence one would like to find compact ways of recording the communications taking place during execution. One such representation is behaviours, a kind of process algebra expressions. In [NN93] and <ref> [NN94a] </ref> inference systems are developed that extend the usual notion of types with behaviours. Applications of such information are 1 demonstrated in [NN94a] and [NN94c]. <p> One such representation is behaviours, a kind of process algebra expressions. In [NN93] and <ref> [NN94a] </ref> inference systems are developed that extend the usual notion of types with behaviours. Applications of such information are 1 demonstrated in [NN94a] and [NN94c]. The question remains: how to implement the inference system, i.e. how to reconstruct the types and behaviours? It seems suitable to use a modified version of algorithm W [Mil78]. <p> Overview of paper Chapter 2 and 3 set up the background for the present work: in Chapter 2 we give a brief motivating introduction to CML and behaviours, and in Chapter 3 we present the inference system from <ref> [NN94a] </ref>. Chapter 4 contains a detailed motivation for our design of the reconstruction algorithm W . Chapter 2 5 elaborates on our choice of generalisation strategy. In Chapter 6 and 7 the algorithm is shown to be sound and complete; the proofs can be found in Appendix B and C. <p> The semantic soundness of this approach is a consequence of the subject reduction theorem from <ref> [NN94a] </ref>. Some useful analyses on behaviours. In [NN94a] a behaviour is tested for finite communication topology, that is whether only finitely many processes are spawned and whether only finitely many channels are created. <p> The semantic soundness of this approach is a consequence of the subject reduction theorem from <ref> [NN94a] </ref>. Some useful analyses on behaviours. In [NN94a] a behaviour is tested for finite communication topology, that is whether only finitely many processes are spawned and whether only finitely many channels are created. If the former is the case we may dispense with multitasking; if the latter is the case we may dispense with multiplexing. <p> A recursive behaviour b = RECfi:b 0 binds fi in the sense that the set of free variables fv (b) is defined to be fv (b 0 ) n ffig; and we assume alpha-conversion to be performed automatically. Compared to <ref> [NN94a] </ref> we have omitted regions as these present no additional problems to the algorithm. 6 Chapter 3 The type and behaviour inference system In Fig. 3.1 (explained below) we list the inference system. <p> We shall approximate behaviours but not types, that is we have "subeffecting" (cf. [Tan94]) but not "subtyping". To formalise this we impose a preorder w on behaviours just as in <ref> [NN94a, Table 3] </ref>, with the intuitive interpretation that if bwb 0 then b approximates b 0 in the sense that any action performed by b 0 can also be performed by b. (To be more precise: w is a subset of the simulation ordering which is undecidable, whereas w is decidable <p> ; [fi 1 w*; fi 2 w?ff ]) channel : 8 : : : (unit ! fi ff chan; [fiwff CHAN ]) fork : 8 : : : ((unit ! fi 1 ff) ! fi 2 unit; fi 2 wFORK fi 1 ) The inference system is much as in <ref> [NN94a] </ref> (whereas the inference system in [NN93] uses subtyping instead of polymorphism), but in [NN94a] the C-constraints present in the definition of CTypeOf () have been "coded into" the types. 10 Chapter 4 Designing the reconstruction algorithm W Our goal is to produce an algorithm which works in the spirit of <p> (unit ! fi ff chan; [fiwff CHAN ]) fork : 8 : : : ((unit ! fi 1 ff) ! fi 2 unit; fi 2 wFORK fi 1 ) The inference system is much as in <ref> [NN94a] </ref> (whereas the inference system in [NN93] uses subtyping instead of polymorphism), but in [NN94a] the C-constraints present in the definition of CTypeOf () have been "coded into" the types. 10 Chapter 4 Designing the reconstruction algorithm W Our goal is to produce an algorithm which works in the spirit of the well-known algorithm W [Mil78], but due to the additional features present in our
Reference: [NN94b] <author> Flemming Nielson and Hanne Riis Nielson. </author> <title> Constraints for polymorphic behaviours of concurrent ML. </title> <booktitle> In Constraints in Computational Logics (CCL '94), volume 845 of LNCS. </booktitle> <publisher> Springer-Verlag, </publisher> <month> September </month> <year> 1994. </year>
Reference-contexts: Instead we employ the technique of algebraic reconstruction [JG91, TJ92]; that is the algorithm unifies the free part of the type structure and generates constraints to cater for the non-free parts. This idea is carried out in <ref> [NN94b] </ref>, where a reconstruction algorithm is presented which is sound but not complete. The algorithm returns two kind of constraints: C-constraints and S-constraints. <p> Using S-constraints is not a standard tool when analysing polymorphic languages; they seem to be needed because the C-constraints apparently lack a "principal solution property" (a phenomenon well-known in unification theory). Finding a "canonical" solution to C-constraints is feasible as shown in <ref> [NN94b] </ref>; in sufficiently simple cases this solution can be shown to be "principal". The present paper improves on [NN94b] by (i) achieving completeness in addition to soundness, by means of another generalisation strategy (made possible by a different formulation of S-constraints); (ii) avoiding some redundancy in the generated constraints (and in <p> Finding a "canonical" solution to C-constraints is feasible as shown in <ref> [NN94b] </ref>; in sufficiently simple cases this solution can be shown to be "principal". The present paper improves on [NN94b] by (i) achieving completeness in addition to soundness, by means of another generalisation strategy (made possible by a different formulation of S-constraints); (ii) avoiding some redundancy in the generated constraints (and in the correctness proofs). <p> Such constraints are denoted C-constraints (for containment). The value of CTypeOf () on some constants (all occurring in Example 2.1) is tabulated below (adopted from <ref> [NN94b, 9 Table 4] </ref>). head : 8 : : : (ff list ! fi ff; [fiw* ]) sync : 8 : : : ((ff com fi 1 ) ! fi 2 ff; [fi 2 wfi 1 ]) send : 8 : : : (ff chan fi ff ! fi 1 ff <p> In Section 4.1 we introduce the notion of simple types which is needed since behaviours constitute a non-free algebra; in Section 4.2 we introduce the notion of S-constraints which is needed since C-constraints in general have no principal solution; in Section 4.3 we improve on the algorithm from <ref> [NN94b] </ref> so as to get completeness; and in Section 4.4 we further improve on our algorithm by eliminating some redundancy in the generated constraints thus making the output (and correctness proof) simpler, at the same time providing the motivation for an alternative way to write type schemes to be presented in <p> The remedy <ref> [TJ92, NN94b] </ref> is to introduce the notion of simplicity: a type is simple if all the behaviours it contains are behaviour variables (so e.g. t 1 ! b t 2 is simple iff t 1 and t 2 are both simple and b = fi for some fi); a behaviour is <p> Hence we need to record, by means of an S-constraint, that the solution chosen for fi should have the solution chosen for fi 0 as an instance. The above considerations motivated the design of the algorithm in <ref> [NN94b] </ref> where the environment binds each identifier x to a type scheme 2 of form 8~fl:(t; C) and where the following actions are taken when such an x is met: copies t 0 and C 0 of t and C are created, where ~fl has been replaced by fresh variables ~fl <p> An additional feature present in <ref> [NN94b] </ref>, needed in order for the soundness proof to carry through (and enforced by another kind of S-constraints), is that there is a sharp distinction between polymorphic variables and non-polymorphic variables in the sense that a solution must not "mix" those variables. <p> In this chapter we shall investigate whether other definitions of N Q might be appropriate. Requiring N Q to be upwards closed. (As already mentioned this is essentially what is done in <ref> [NN94b] </ref>.) Then (5.1) will still hold so soundness is assured. <p> But this can easily be achieved by adopting the canonical solution of <ref> [NN94b] </ref>: due to rule R1 in Figure 3.2 we just map fi into RECfi:(b 1 + : : : + b n ) (if fi does not occur in the b i 's, we can omit the recursion). <p> We have improved upon a previously published algorithm <ref> [NN94b] </ref> in achieving completeness and eliminating some redundancy in representation. The algorithm has been implemented and has provided quite illuminating analyses of example CML programs. One difference from the traditional formulation of W is that we generate so-called C-constraints that then have to be solved.
Reference: [NN94c] <author> Hanne Riis Nielson and Flemming Nielson. </author> <title> Static and dynamic processor allocation for higher-order concurrent languages. </title> <type> Technical Report PB-483, DAIMI, </type> <institution> University of Aarhus, Denmark, </institution> <year> 1994. </year>
Reference-contexts: One such representation is behaviours, a kind of process algebra expressions. In [NN93] and [NN94a] inference systems are developed that extend the usual notion of types with behaviours. Applications of such information are 1 demonstrated in [NN94a] and <ref> [NN94c] </ref>. The question remains: how to implement the inference system, i.e. how to reconstruct the types and behaviours? It seems suitable to use a modified version of algorithm W [Mil78]. <p> If the former is the case we may dispense with multitasking; if the latter is the case we may dispense with multiplexing. Both cases lead to substantial savings in the run-time system. In <ref> [NN94c] </ref> two analyses are presented which provide information helpful for making a static (resp. dynamic) decision about where to allocate processes. Types.
Reference: [PGM90] <author> Sanjiva Prasad, Alessandro Giacalone, and Prateek Mishra. </author> <title> Operational and algebraic semantics for Facile: A symmetric integration of concurrent and functional programming. </title> <booktitle> In ICALP 90, </booktitle> <year> 1990. </year>
Reference-contexts: Our research has been motivated by the integration of the functional and concurrent programming paradigms. Example programming languages are CML [Rep91] that extends Standard ML with concurrency, Facile <ref> [PGM90] </ref> that follows a similar approach but more directly contains syntax for expressing CCS-like process composition, and LCS [BS94]. The overall communication structure of such programs may not be immediately clear and hence one would like to find compact ways of recording the communications taking place during execution.
Reference: [Rep91] <author> John H. Reppy. </author> <title> CML: A higher-order concurrent language. </title> <booktitle> In SIGPLAN'91 Conference on Programming Language Design and Implementation, </booktitle> <month> June </month> <year> 1991. </year>
Reference-contexts: Our research has been motivated by the integration of the functional and concurrent programming paradigms. Example programming languages are CML <ref> [Rep91] </ref> that extends Standard ML with concurrency, Facile [PGM90] that follows a similar approach but more directly contains syntax for expressing CCS-like process composition, and LCS [BS94]. <p> The purpose of the constant sync is to convert a communication possibility into an actual communication (see <ref> [Rep91] </ref> for further motivation). rec map2 (f) ) xs.if xs = [ ] then [ ] else let ch = channel () in fork (d.(sync (send hch,map2 f (tail xs)i))); cons (f (head xs)) (sync (receive ch)) The "underlying type" of map2 will be (ff 1 ! ff 2 ) !
Reference: [Sie89] <author> Jorg H. Siekmann. </author> <title> Unification theory. </title> <journal> J. Symbolic Computation, </journal> <volume> 7 </volume> <pages> 207-274, </pages> <year> 1989. </year>
Reference-contexts: This phenomenon is needed because our C-constraints would seem not to have principal solutions. This is not the case for the traditional "free" unification of Standard ML, but it is a phenomenon well-known in unification theory <ref> [Sie89] </ref>. As a consequence we have to ensure that the different solutions to the C-constraints (concerning the polymorphic definition and its instantiations) are comparable and this is the purpose of the S-constraints.
Reference: [Smi93] <author> Geoffrey S. Smith. </author> <title> Polymorphic type inference with overloading and subtyping. </title> <booktitle> In TAPSOFT '93, volume 668 of LNCS, </booktitle> <pages> pages 671-685. </pages> <publisher> Springer-Verlag, </publisher> <year> 1993. </year>
Reference-contexts: Often (as 24 in e.g. [Jon92]) the assumptions in a completeness proposition are (using the terminology of Prop. 7.3) that E [OE] is equal to E 0 ; but as in <ref> [Smi93] </ref> this is not sufficient since an identifier may be bound to a type scheme which is less general than the one to which it is bound in the algorithm. (In our system this phenomenon is due to the presence of subeffecting in the inference system so one may produce behaviours <p> scheme which is less general than the one to which it is bound in the algorithm. (In our system this phenomenon is due to the presence of subeffecting in the inference system so one may produce behaviours containing many "extra" variables which cannot be quantified over in let-expressions; whereas in <ref> [Smi93] </ref> it is due to the fact that the inference system gives freedom to quantify over fewer variables than possible.) Proposition 7.3 Suppose E 0 ` 2 e : t 0 & b 0 and E [OE] E 0 .
Reference: [Tan94] <institution> Yan-Mei Tang. Systemes d'Effet et Interpretation Abstraite pour l'Analyse de Flot de Controle. </institution> <type> PhD thesis, </type> <institution> Ecole Nationale Su-perieure des Mines de Paris, </institution> <year> 1994. </year> <note> Report A/258/CRI. In English. </note>
Reference-contexts: As is always the case for program analysis we shall be interesting in getting as precise information as possible, but due to decidability issues approximations are needed. We shall approximate behaviours but not types, that is we have "subeffecting" (cf. <ref> [Tan94] </ref>) but not "subtyping".
Reference: [TJ92] <author> Jean-Pierre Talpin and Pierre Jouvelot. </author> <title> Polymorphic type, region and effect inference. </title> <journal> Journal of Functional Programming, </journal> <volume> 2(3) </volume> <pages> 245-271, </pages> <year> 1992. </year>
Reference-contexts: This algorithm works by unification, but since our behaviours constitute a non-free algebra (due to the laws imposed on them) this approach is not immediately feasible in our framework. Instead we employ the technique of algebraic reconstruction <ref> [JG91, TJ92] </ref>; that is the algorithm unifies the free part of the type structure and generates constraints to cater for the non-free parts. This idea is carried out in [NN94b], where a reconstruction algorithm is presented which is sound but not complete. <p> The remedy <ref> [TJ92, NN94b] </ref> is to introduce the notion of simplicity: a type is simple if all the behaviours it contains are behaviour variables (so e.g. t 1 ! b t 2 is simple iff t 1 and t 2 are both simple and b = fi for some fi); a behaviour is
Reference: [TJ94] <author> Jean-Pierre Talpin and Pierre Jouvelot. </author> <title> The type and effect discipline. </title> <journal> Information and Computation, </journal> <volume> 111(2), </volume> <year> 1994. </year> <month> 32 </month>
Reference-contexts: which creates a type scheme whose type part is t 1 and where all variables are polymorphic except those which are free in the environment E (which is a standard requirement) and except those which are free in the behaviour b 1 (which is a standard requirement for effect systems <ref> [TJ94] </ref>). The clause for sequential compositions e 1 ;e 2 reflects that first e 1 is evaluated (for its side effects) and then e 2 is evaluated to produce a value (and some side effects). <p> The former case will arise if ff chan is handled as ff list; whereas the latter case will arise if ff chan is handled by the techniques for ff ref developed in <ref> [TJ94] </ref> and [BD93]. The approach in [TJ94]. We have seen that there are several possibilities for satisfying (5.1) and (5.2); so settling on the downwards closure as we have done may seem somewhat arbitrary but can be justified by observing the similarities to what is done in [TJ94]. <p> The former case will arise if ff chan is handled as ff list; whereas the latter case will arise if ff chan is handled by the techniques for ff ref developed in <ref> [TJ94] </ref> and [BD93]. The approach in [TJ94]. We have seen that there are several possibilities for satisfying (5.1) and (5.2); so settling on the downwards closure as we have done may seem somewhat arbitrary but can be justified by observing the similarities to what is done in [TJ94]. <p> ref developed in <ref> [TJ94] </ref> and [BD93]. The approach in [TJ94]. We have seen that there are several possibilities for satisfying (5.1) and (5.2); so settling on the downwards closure as we have done may seem somewhat arbitrary but can be justified by observing the similarities to what is done in [TJ94]. Here behaviours are sets of atomic "effects" (thus losing causality information) and any solvable constraint set C has a "canonical" solution C which is principal in the sense that for any satisfying C it holds that = C; .
References-found: 18

