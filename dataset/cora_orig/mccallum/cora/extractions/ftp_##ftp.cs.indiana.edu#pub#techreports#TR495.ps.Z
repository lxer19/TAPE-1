URL: ftp://ftp.cs.indiana.edu/pub/techreports/TR495.ps.Z
Refering-URL: http://www.cs.indiana.edu/trindex.html
Root-URL: 
Email: pierce@cs.indiana.edu  dnt@an-teallach.com  
Title: Local Type Argument Synthesis with Bounded Quantification  
Author: Benjamin C. Pierce David N. Turner 
Date: November 12, 1997  
Note: An Teallach  
Address: Lindley Hall 215 Bloomington, IN 47405, USA  King's Buildings Edinburgh, EH9 3JL, UK  
Affiliation: Computer Science Department Indiana University  Limited Technology Transfer Center  Indiana University  
Pubnum: CSCI Technical Report #495  
Abstract: In a companion paper [PT98], we introduced a local type inference method for inferring type arguments to polymorphic functions. We show here how our method can be extended to handle Cardelli and Wegner's Kernel Fun variant of F . 
Abstract-found: 1
Intro-found: 1
Reference: [CG92] <author> Pierre-Louis Curien and Giorgio Ghelli. </author> <title> Coherence of subsumption: Minimum typing and type-checking in F . Mathematical Structures in Computer Science, </title> <booktitle> 2 </booktitle> <pages> 55-91, </pages> <year> 1992. </year> <editor> Also in Carl A. Gunter and John C. Mitchell, editors, </editor> <title> Theoretical Aspects of Object-Oriented Programming: Types, Semantics, </title> <publisher> and Language Design (MIT Press, </publisher> <year> 1994). </year>
Reference-contexts: Unfortunately, type inference technology has not kept pace with developments in type systems. In particular, the combination of subtyping and parametric polymorphism has been intensively studied for more than a decade in calculi such as System F <ref> [CW85, CG92, CMMS94, etc.] </ref>, but these features have not yet been satisfactorily integrated with practical type inference methods. <p> First, we use the original "Kernel Fun" rule for comparing quantifiers [CW85], in which the upper bounds B in the subtyping rule for polymorphic functions are required to be identical, rather than the more powerful but less tractable variant of Curien and Ghelli <ref> [CG92, CMMS94] </ref>. 1 The principal reason for this restriction is that it allows us to define meets and joins of all pairs of types, which may fail to exist in "Full F " [Ghe90].
Reference: [CMMS94] <author> Luca Cardelli, Simone Martini, John C. Mitchell, and Andre Scedrov. </author> <title> An extension of system F with subtyping. </title> <journal> Information and Computation, </journal> <note> 109(1-2):4-56, 1994. A preliminary version appeared in TACS '91 (Sendai, Japan, pp. 750-770). </note>
Reference-contexts: Unfortunately, type inference technology has not kept pace with developments in type systems. In particular, the combination of subtyping and parametric polymorphism has been intensively studied for more than a decade in calculi such as System F <ref> [CW85, CG92, CMMS94, etc.] </ref>, but these features have not yet been satisfactorily integrated with practical type inference methods. <p> First, we use the original "Kernel Fun" rule for comparing quantifiers [CW85], in which the upper bounds B in the subtyping rule for polymorphic functions are required to be identical, rather than the more powerful but less tractable variant of Curien and Ghelli <ref> [CG92, CMMS94] </ref>. 1 The principal reason for this restriction is that it allows us to define meets and joins of all pairs of types, which may fail to exist in "Full F " [Ghe90].
Reference: [CW85] <author> Luca Cardelli and Peter Wegner. </author> <title> On understanding types, data abstraction, and polymorphism. </title> <journal> Computing Surveys, </journal> <volume> 17(4), </volume> <month> December </month> <year> 1985. </year>
Reference-contexts: Unfortunately, type inference technology has not kept pace with developments in type systems. In particular, the combination of subtyping and parametric polymorphism has been intensively studied for more than a decade in calculi such as System F <ref> [CW85, CG92, CMMS94, etc.] </ref>, but these features have not yet been satisfactorily integrated with practical type inference methods. <p> Section 3 then shows how we can specify and implement a local type argument inference scheme for this calculus. 2 Kernel Fun For our explicitly-typed internal language|the target for the type inference methods described in Section 3|we extend Cardelli and Wegner's Kernel Fun calculus <ref> [CW85] </ref> of subtyping and impredicative poly-morphism. We only give definitions here; the meta-theory of the system is developed in detail in a companion paper [Pie97]. 2.1 Syntax We extend the original Kernel Fun system [CW85] in a few significant ways. Firstly, we add a minimal type Bot. <p> for the type inference methods described in Section 3|we extend Cardelli and Wegner's Kernel Fun calculus <ref> [CW85] </ref> of subtyping and impredicative poly-morphism. We only give definitions here; the meta-theory of the system is developed in detail in a companion paper [Pie97]. 2.1 Syntax We extend the original Kernel Fun system [CW85] in a few significant ways. Firstly, we add a minimal type Bot. Our type inference algorithm keeps track of various type constraints by calculating the least upper bound and greatest lower bound of pairs of types. <p> First, we use the original "Kernel Fun" rule for comparing quantifiers <ref> [CW85] </ref>, in which the upper bounds B in the subtyping rule for polymorphic functions are required to be identical, rather than the more powerful but less tractable variant of Curien and Ghelli [CG92, CMMS94]. 1 The principal reason for this restriction is that it allows us to define meets and joins
Reference: [Ghe90] <author> Giorgio Ghelli. </author> <title> Proof Theoretic Studies about a Minimal Type System Integrating Inclusion and Parametric Polymorphism. </title> <type> PhD thesis, </type> <institution> Universita di Pisa, </institution> <month> March </month> <year> 1990. </year> <type> Technical report TD-6/90, </type> <institution> Dipartimento di Informatica, Universita di Pisa. </institution>
Reference-contexts: required to be identical, rather than the more powerful but less tractable variant of Curien and Ghelli [CG92, CMMS94]. 1 The principal reason for this restriction is that it allows us to define meets and joins of all pairs of types, which may fail to exist in "Full F " <ref> [Ghe90] </ref>. Second, for simplicity, we use an algorithmic presentation of subtyping, in which the rules of transitivity and general reflexivity are omitted and recovered as properties of the definition (cf. [Pie97, Section 3.1]).
Reference: [GP97] <author> Giorgio Ghelli and Benjamin Pierce. </author> <title> Bounded existentials and minimal typing. </title> <booktitle> Theoretical Computer Science, </booktitle> <year> 1997. </year> <note> To appear. </note>
Reference-contexts: rather than the "full F " variant where two polymorphic function types with different upper bounds for their type components are allowed to stand in the subtype relation under appropriate conditions; in the latter system, it can be shown that variables cannot always be eliminated in a most general way <ref> [GP97] </ref>.) Formally, we write ` S * V T for the relation "T is the least supertype of S such that FV (T) " V = ;" and ` S + V T for the dual relation "T is the greatest subtype of S such that FV (T) " V = <p> + V X 7 ` All (X&lt;:A)S!T + V All (X&lt;:A)S 0 !T 0 (VD-Fun-1) ` All (X&lt;:A)S!T + V Bot It is easy to check that, for each variable set V , * V and + V are total functions. (These functions are similar to the ones used in <ref> [GP97] </ref>, but somewhat simpler because of the presence of Bot in our type system.) 3.2.1 Lemma [Soundness of variable elimination]: 1. If ` S * V T then FV (T) " V = ; and ` S &lt;: T. 2.
Reference: [Mil92] <author> Dale Miller. </author> <title> Unification under a mixed prefix. </title> <journal> Journal of Symbolic Computation, </journal> <volume> 14(4) </volume> <pages> 321-358, </pages> <month> October </month> <year> 1992. </year>
Reference-contexts: The set V allows us to avoid generating nonsensical constraint sets in which bound variables are mentioned outside their scopes (this part of the constraint generation problem is similar to mixed-prefix unification <ref> [Mil92] </ref>). For example, if we are interested in constraining X so that All (Y&lt;:Top)()!(Y!Y) is a subtype of All (Y&lt;:Top)()!X, we should not return the constraint set fX7![Y!Y; Top]g, since Y would be out of scope.
Reference: [Pie97] <author> Benjamin C. Pierce. </author> <title> Bounded quantification with bottom. </title> <type> Technical Report 492, </type> <institution> Computer Science Department, Indiana University, </institution> <year> 1997. </year>
Reference-contexts: We only give definitions here; the meta-theory of the system is developed in detail in a companion paper <ref> [Pie97] </ref>. 2.1 Syntax We extend the original Kernel Fun system [CW85] in a few significant ways. Firstly, we add a minimal type Bot. Our type inference algorithm keeps track of various type constraints by calculating the least upper bound and greatest lower bound of pairs of types. <p> The properties of Kernel Fun with Bot are similar to those of pure Kernel Fun, but there are a number of significant differences in details. The properties of the internal language are developed in detail in <ref> [Pie97] </ref>. Secondly, we extend abstraction and application so that several arguments (including both types and terms) may be passed at the same time. In other words, we favor a "fully uncurried" style of function definition and application (though currying is, of course, still available). <p> Second, for simplicity, we use an algorithmic presentation of subtyping, in which the rules of transitivity and general reflexivity are omitted and recovered as properties of the definition (cf. <ref> [Pie97, Section 3.1] </ref>). It is also important to note that some of the usual properties of presentations of Kernel Fun without Bot do not hold here. <p> X * T We write ` S ^ T = M for "M is the meet of S and T in context " and ` S _ T = J for "J is the join of S and T in ." The definitions of these relations can be found in <ref> [Pie97] </ref>, Section 3.3. 2.3 Typing Rules The typing relation ` e 2 T is essentially the standard one, except that, as in the definition of subtyping, we use an algorithmic presentation, omitting the usual rule of subsumption ("if e 2 S and S &lt;: T, then e 2 T"); instead, the <p> If ` S &lt;: T and FV (T) " V = ;, then ` S * V R with ` R &lt;: T. 2. If ` T &lt;: S and FV (T) " V = ;, then ` S + V R with ` T &lt;: R. Proof: See <ref> [Pie97] </ref>. ffi 3.3 Constraints Next, we introduce the constraints that will be manipulated by our algorithm. <p> Proof: See <ref> [Pie97, Lemma 4.1.2] </ref>. ffi 3.6.2 Corollary: If c is rigid under and ` S 2 c and ` T 2 c, then S and T are identical.
Reference: [PT98] <author> Benjamin C. Pierce and David N. Turner. </author> <title> Local type inference. </title> <booktitle> In Conference Record of POPL '98: the 25th ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages, </booktitle> <year> 1998. </year> <note> To appear. Full version available as Indiana University CSCI technical report #493. </note>
Reference-contexts: Part of the reason for this gap is that most work on type inference for this class of languages has concentrated on the difficult problem of developing complete methods, which are guaranteed to infer types, whenever possible, for entirely unannotated programs. In a companion paper <ref> [PT98] </ref>, we proposed a simple alternative, refining the idea of partial type inference with the additional simplifying principle that missing annotations should be recovered using only types propagated locally, from adjacent nodes in the syntax tree. In [PT98], we presented our type inference scheme for a calculus incorporating both impredicative poly-morphism <p> In a companion paper <ref> [PT98] </ref>, we proposed a simple alternative, refining the idea of partial type inference with the additional simplifying principle that missing annotations should be recovered using only types propagated locally, from adjacent nodes in the syntax tree. In [PT98], we presented our type inference scheme for a calculus incorporating both impredicative poly-morphism and subtyping. For simplicity, we did not treat bounded quantification, where subtyping and quantification interact via upper bounds on type variables. <p> We refer the reader to <ref> [PT98] </ref> for a fuller explanation of the basic local type inference scheme. In the next section, we define (a mild extension of) Cardelli and Wegner's Kernel Fun. <p> The only slightly unusual case is the type Bot, which can be interpreted as an empty type (in a total-function semantics) or a type containing only divergent terms (in a partial function semantics). 3 Local Type Argument Synthesis Our measurements of ML programs in <ref> [PT98] </ref> showed that type arguments to polymorphic functions are inferred by the ML typechecker on at least one line in every three, in typical programs. Moreover, explicit type arguments rarely have any useful documentation value. As an example, consider the polymorphic identity function id with type All (X&lt;:Top)X!X. <p> These two result types are incomparable in the subtyping relation, so there is no "best" result type available. In this case type argument synthesis will fail, since it is not possible to locally determine the missing type arguments for f (in <ref> [PT98] </ref> we show how propagating additional contextual information sometimes allows us to avoid this situation). 3.1 Type Inference (Specification) We define a three-place type inference relation: ` e 2 T ) e 0 Intuitively, this relation can be read "In context , type annotations can be added to the term e
References-found: 8

