URL: http://www.cs.wustl.edu/~schmidt/RT-ORB.ps.gz
Refering-URL: http://www.cs.wustl.edu/~schmidt/TAO-architecture.html
Root-URL: 
Email: fschmidt,levine,sumedh,rajeev,cleeland,irfang@cs.wustl.edu  
Title: Architectures and Patterns for High-performance, Real-time CORBA Object Request Brokers  
Author: Douglas C. Schmidt, David L. Levine, Sumedh Mungee, Rajeev Bector, Chris Cleeland, and Irfan Pyarali 
Note: This is a composition of papers appearing in the Computer Communications Journal [SLM98], the Workshop on Middleware for Real-Time Systems and Services [SBL 97], the 4 th IEEE Real-time Technology and Applications Symposium (RTAS) [SMFGG97], and the IEEE Communications magazine [SC98]. This work was supported in part by NSF grant NCR-9628218, DARPA contract 9701516, Boeing, Siemens, US Sprint, and Motorola.  
Date: May 16, 1998  
Address: St. Louis, MO 63130  
Affiliation: Department of Computer Science, Washington University  
Abstract: This paper makes five contributions to the design of CORBA ORBs for applications with both high-performance and real-time requirements. First, it describes the design of TAO, which is our high-performance, real-time CORBA-compliant ORB. Second, it presents TAO's real-time scheduling service, which provides QoS guarantees for deterministic real-time CORBA applications. Third, it presents performance measurements that demonstrate the effects of priority inversion and non-determinism in conventional ORBs and how these hazards are avoided in TAO. Fourth, it presents a case study of key patterns needed to develop extensible ORBs and quantifies the impact of applying patterns to reduce the complexity and improve the maintainability of common ORB tasks. Finally, it describes enhancements to general-purpose OS kernels that support TAO's real-time ORB endsystem functionality. 
Abstract-found: 1
Intro-found: 1
Reference: [BMR + 96] <author> Frank Buschmann, Regine Meunier, Hans Rohnert, Pe ter Sommerlad, and Michael Stal. </author> <title> Pattern-Oriented Software Architecture A System of Patterns. </title> <publisher> Wiley and Sons, </publisher> <year> 1996. </year>
Reference-contexts: This section delves deeper into TAO's software architecture by exploring the patterns its uses to create dynamically configurable real-time ORB middleware. A pattern represents a recurring solution to a software development problem within a particular context <ref> [GHJV95, BMR + 96] </ref>. Patterns help to alleviate the continual rediscovery and re-invention of software concepts and components by capturing solutions to standard software development problems [Sch95a]. <p> Patterns help to alleviate the continual rediscovery and re-invention of software concepts and components by capturing solutions to standard software development problems [Sch95a]. For instance, patterns are useful for documenting the structure and participants in common communication software micro-architectures like Reactors [Sch95b], Active Objects [LS96], and Brokers <ref> [BMR + 96] </ref>. These patterns are generalizations of object-structures that have proven useful to build flexible and efficient event-driven and concurrent communication software such as ORBs. To focus the discussion, this section illustrates how we have applied patterns to develop TAO.
Reference: [Box97] <author> Donald Box. </author> <title> Essential COM. </title> <publisher> Addison-Wesley, Read ing, </publisher> <address> MA, </address> <year> 1997. </year>
Reference-contexts: DOC middleware resides between clients and servers. It simplifies application development by providing a uniform view of heterogeneous network and OS layers. At the heart of DOC middleware are Object Request Brokers (ORBs), such as CORBA [Obj98], DCOM <ref> [Box97] </ref>, and Java RMI [WRW96]. ORBs eliminate many tedious, error-prone, and non-portable aspects of developing and maintaining distributed applications by automating common network programming tasks such as object location, object activation, parameter marshaling, fault recovery, and security.
Reference: [CCF91] <author> Jong-Deok Choi, Ron Cytron, and Jeanne Ferrante. </author> <title> Automatic Construction of Sparse Data Flow Evaluation Graphs. </title> <booktitle> In Conference Record of the Eighteenth Annual ACE Symposium on Principles of Programming Languages. ACM, </booktitle> <month> January </month> <year> 1991. </year>
Reference-contexts: Caching improves performance when ADUs are transferred sequentially in request chains and each ADU varies only slightly from one transmission to the other. In such cases, it is not necessary to marshal the entire request every time. This optimization requires that the real-time ORB perform flow analysis <ref> [CCF91, CFR + 91] </ref> of application code to determine what request fields can be cached. Although these techniques can significantly reduce marshaling overhead for the common case, applications with strict real-time service requirements often consider only worst-case execution.
Reference: [CFR + 91] <author> Ron Cytron, Jeanne Ferrante, Barry K. Rosen, Mark N. Wegman, and F. Kenneth Zadeck. </author> <title> Efficiently Computing Static Single Assignment Form and the Control Dependence Graph. </title> <journal> In ACM Transactions on Programming Languages and Systems. ACM, </journal> <month> October </month> <year> 1991. </year>
Reference-contexts: Caching improves performance when ADUs are transferred sequentially in request chains and each ADU varies only slightly from one transmission to the other. In such cases, it is not necessary to marshal the entire request every time. This optimization requires that the real-time ORB perform flow analysis <ref> [CCF91, CFR + 91] </ref> of application code to determine what request fields can be cached. Although these techniques can significantly reduce marshaling overhead for the common case, applications with strict real-time service requirements often consider only worst-case execution.
Reference: [CP95] <author> C. Cranor and G. Parulkar. </author> <title> Design of Universal Con tinuous Media I/O. </title> <booktitle> In Proceedings of the 5th International Workshop on Network and Operating Systems Support for Digital Audio and Video (NOSSDAV '95), </booktitle> <pages> pages 8386, </pages> <address> Durham, New Hampshire, </address> <month> April </month> <year> 1995. </year>
Reference-contexts: In addition to providing a real-time ORB, TAO is an integrated ORB endsystem architecture that consists of a high-performance I/O subsystem <ref> [CP95, GP96a] </ref> and an ATM Port Interconnect Controller (APIC) [DPJRC97]. <p> The I/O subsystem uses the port number contained in arriving requests as a demultiplexing key to associate requests with the appropriate socket queue. This design minimizes priority inversion through the ORB endsystem via early demultiplexing <ref> [CP95, GP96a, DPJRC97] </ref>. This strategy associates incoming requests with the appropriate real-time thread that services the target servant.
Reference: [CT90] <author> David D. Clark and David L. Tennenhouse. </author> <title> Architec tural Considerations for a New Generation of Protocols. </title> <booktitle> In Proceedings of the Symposium on Communications Architectures and Protocols (SIGCOMM), pages 200208, </booktitle> <address> Philadelphia, PA, </address> <month> September </month> <year> 1990. </year> <note> ACM. </note>
Reference-contexts: Marshaling and demarshaling are major bottlenecks in high-performance communication subsystems <ref> [CT90] </ref> due to the significant amount of CPU, memory, and I/O bus resources they consume while accessing and copying data.
Reference: [Cus93] <author> Helen Custer. </author> <title> Inside Windows NT. </title> <publisher> Microsoft Press, </publisher> <address> Redmond, Washington, </address> <year> 1993. </year>
Reference-contexts: Widely available explicit dynamic linking mechanisms include the dlopen/dlsym/dlclose functions in SVR4 UNIX [GLDW87] and the LoadLibrary/GetProcAddress functions in the WIN32 subsystem of Windows NT <ref> [Cus93] </ref>. The ACE wrapper facades portably encapsulate these OS APIs. By using the Service Configurator pattern, the behavior of ORB strategies are decoupled from when implementations of these strategies are configured into an ORB.
Reference: [DAPP93] <author> Peter Druschel, Mark B. Abbott, Michael Pagels, and Larry L. Peterson. </author> <title> Network subsystem design. IEEE Network (Special Issue on End-System Support for High Speed Networks), </title> <type> 7(4), </type> <month> July </month> <year> 1993. </year>
Reference-contexts: Efficient and predictable memory management: On modern high-speed hardware platforms, data copying consumes a significant amount of CPU, memory, and I/O bus resources <ref> [DAPP93] </ref>. Likewise, dynamic memory management incurs a significant performance penalty due to locking overhead and non-determinism due to heap fragmentation.
Reference: [DPJRC97] <author> Zubin D. Dittia, Guru M. Parulkar, and Jr. Jerome R. Cox. </author> <title> The APIC Approach to High Performance Network Interface Design: Protected DMA and Other Techniques. </title> <booktitle> In Proceedings of INFOCOM '97, </booktitle> <address> Kobe, Japan, </address> <month> April </month> <year> 1997. </year> <note> IEEE. </note>
Reference-contexts: In addition to providing a real-time ORB, TAO is an integrated ORB endsystem architecture that consists of a high-performance I/O subsystem [CP95, GP96a] and an ATM Port Interconnect Controller (APIC) <ref> [DPJRC97] </ref>. Figure 4 illustrates the main components in TAO's ORB endsystem architecture. 1.3.2 Requirements for High-performance and Real-time ORB Endsystems The remainder of this section describes the requirements and features of ORB endsystems necessary to meet high-performance and real-time application QoS needs. <p> High-speed network interface: At the bottom of TAO's I/O subsystem is a daisy-chained interconnect comprising a number of ATM Port Interconnect Controller (APIC) chips <ref> [DPJRC97] </ref>. APIC can be used both as an endsys-tem/network interface and as an I/O interface chip. It sustains an aggregate bi-directional data rate of 2.4 Gbps. Although TAO is optimized for the APIC I/O subsystem, it is designed using a layered architecture that can run on conventional platforms. <p> The I/O subsystem uses the port number contained in arriving requests as a demultiplexing key to associate requests with the appropriate socket queue. This design minimizes priority inversion through the ORB endsystem via early demultiplexing <ref> [CP95, GP96a, DPJRC97] </ref>. This strategy associates incoming requests with the appropriate real-time thread that services the target servant. <p> This design minimizes priority inversion through the ORB endsystem via early demultiplexing [CP95, GP96a, DPJRC97]. This strategy associates incoming requests with the appropriate real-time thread that services the target servant. Section B.6 explains how the early demultiplexing <ref> [DPJRC97] </ref> feature of ATM can be used to vertically integrate and co-schedule TAO's ORB endsystem from the network interface to the application servants. * TAO's Real-time inter-ORB protocol (RIOP): TAO's connection-per-rate scheme described above is optimized for fixed priority applications that transfer their requests at particular rates through statically allocated connections <p> TAO is designed to minimize and eliminate data copying at multiple layers in the ORB endsystem. For instance, TAO's buffer management system uses the APIC network interface to enhance conventional operating systems with a zero-copy buffer management system <ref> [DPJRC97] </ref>. At the device level, the APIC interacts directly with the main system bus and other I/O devices. Therefore, it can transfer client requests between endsystem buffer pools and ATM virtual circuits with no additional data copying. <p> However, QoS research at the network and OS layers has not addressed key requirements and usage characteristics of OO middleware. For instance, research on QoS for ATM networks has focused largely on policies for allocating bandwidth on a per-connection basis <ref> [DPJRC97] </ref>. Likewise, research on real-time operating systems has focused largely on avoiding priority inversion and non-determinism in synchronization and scheduling mechanisms for multi-threaded applications [RSL88].
Reference: [EFF + 97] <author> Eric Eide, Kevin Frei, Bryan Ford, Jay Lepreau, and Gary Lindstrom. Flick: </author> <title> A Flexible, Optimizing IDL Compiler. </title> <booktitle> In Proceedings of ACM SIGPLAN '97 Conference on Programming Language Design and Implementation (PLDI), </booktitle> <address> Las Vegas, NV, </address> <month> June </month> <year> 1997. </year> <note> ACM. </note>
Reference-contexts: Conversely, skeletons de-marshal the packet-level representation back into typed data that is meaningful to an application. An IDL compiler automatically transforms OMG IDL definitions into an application programming language like C++ or Java. IDL compilers eliminate common sources of network programming errors and provide opportunities for automated compiler optimizations <ref> [EFF + 97] </ref>. Dynamic Invocation Interface (DII): The DII allows a client to access the underlying request transport mechanisms provided by the ORB Core. The DII is useful when an application has no compile-time knowledge of the interface it is accessing. <p> These overheads stem from (1) non-optimized presentation layer conversions and monolithic presentation code that copies data excessively <ref> [EFF + 97] </ref> and overflows 3 processor caches [GS98c]; (2) internal buffering strategies that produce non-uniform behavior for different message sizes [GS96b]; (3) inefficient demultiplexing and dispatching algorithms [GS97c]; (4) long chains of intra-ORB virtual method calls [GS96a]; and (5) lack of integration with underlying real-time OS and network QoS mechanisms <p> In contrast, interpreted marshaling code is slower, but more compact and can utilize processor caches more effectively. Section 2.4 outlines how TAO supports predictable performance guarantees for both interpreted and compiled marshaling operations via its GIOP protocol engine. This protocol engine applies a number of innovative compiler techniques <ref> [EFF + 97] </ref> and optimization principles [GS98c]. These principles include optimizing for the common case; eliminating gratuitous waste; replacing general purpose operations with specialized, efficient ones; precomputing values, if possible; storing redundant state to speed up expensive operations; passing information between layers; and optimizing for the cache. <p> In TAO, presentation layer processing is performed by client-side stubs and server-side skeletons that are generated automatically by a highly-optimizing IDL compiler <ref> [EFF + 97] </ref>. In addition to reducing the potential for inconsistencies between client stubs and server skeletons, TAO's IDL compiler supports the following optimizations: * Reduced use of dynamic memory: The IDL compiler analyzes the storage requirements for all the messages exchanged between the client and the server.
Reference: [EKB + 92] <author> J.R. Eykholt, S.R. Kleiman, S. Barton, R. </author> <month> Faulkner, </month>
Reference-contexts: The number of calls per-request to kernel-level locking mechanisms at the server (shown in Figure 36) are unusually high. This overhead stems from the fact that miniCOOL uses system scoped threads on Solaris, which require kernel intervention for all synchronization operations <ref> [EKB + 92] </ref>. The miniCOOL connection and concurrency architectures are outlined briefly below. * miniCOOL connection architecture: The miniCOOL ORB connection architecture uses a leader/follower model that allows the leader thread to block in select on the shared socket.
References-found: 11

