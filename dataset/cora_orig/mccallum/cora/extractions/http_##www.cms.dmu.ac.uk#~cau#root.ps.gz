URL: http://www.cms.dmu.ac.uk/~cau/root.ps.gz
Refering-URL: http://www.cms.dmu.ac.uk/~cau/phdindex.html
Root-URL: 
Title: COMPOSITIONAL VERIFICATION AND SPECIFICATION OF REFINEMENT FOR REACTIVE SYSTEMS IN A DENSE TIME TEMPORAL LOGIC  
Author: zur Erlangung des Doktorgrades vorgelegt von Antonio Cau 
Degree: Dissertation  
Date: im August 1995  
Affiliation: der Technischen Fakultat der Christian-Albrechts-Universitat zu Kiel  
Pubnum: Kiel,  
Abstract-found: 0
Intro-found: 1
Reference: [Acz83] <author> P. Aczel. </author> <title> On an inference rule for parallel composition, 1983. </title> <type> Unpublished, </type> <institution> University of Manchester. </institution>
Reference-contexts: Introduction that stores "compositionality information" like "this is a system step" or "this is an en-vironement step" or "this is a communication step". A merging operator, first version defined in <ref> [Acz83] </ref>, based on the one defined in [CC94] is introduced to merge this "com-positionality information" of the components into "compositionality information" of the composed system. <p> With a "conjoining" operator the histories of both components are merged into a history of the composite one. This conjoining operator based on [CC94] corresponds in our model almost to conjunction and is actually an extended version of Aczel's one <ref> [Acz83] </ref> because it also can handle CSP based concurrency whereas Aczel's one can only handle shared variable 3 A Dense Model Formalism based concurrency. s s c s ss . . . . . . . . . . . . . . . . . . . . . . <p> Composition means that the histories of the component systems are "merged" into composite histories, i.e., the histories of the composed system. Our merge operator is based on the merge operator of Aczel <ref> [Acz83] </ref>. Both are first defined at the semantic level and then for the DTL specifications. 2.3.1 Semantic Refinement and Composition of Specifications In this section refinement and composition of reactive systems is defined at the semantical level.
Reference: [AFK88] <author> K. R. Apt, N. Francez, and S. Katz. </author> <title> Appraising fairness in languages for distributed programming. </title> <journal> Distributed Computing, </journal> <volume> 2(4) </volume> <pages> 226-241, </pages> <year> 1988. </year>
Reference-contexts: This is the machine closedness property of a system specification introduced in <ref> [AFK88, AL91] </ref>. Let A ! B denote A S B.
Reference: [AL91] <author> M. Abadi and L. Lamport. </author> <title> The existence of refinement mappings. </title> <journal> Theoretical Computer Science, </journal> <volume> 82(2) </volume> <pages> 253-284, </pages> <month> May </month> <year> 1991. </year>
Reference-contexts: A proof of this lemma is given in <ref> [AL91] </ref> (it is also repeated in the appendix). The machine specification of a system now consists of a machine M and a set of histories L constraining the basis of this machine such that the closure of the intersection of Comp (M ) and L equals Comp (M ). <p> This is the machine closedness property of a system specification introduced in <ref> [AFK88, AL91] </ref>. Let A ! B denote A S B. <p> Hence we have refinement. 36 2.4 Proving Refinement of Reactive System Specifications 2.4 Proving Refinement of Reactive System Specifi cations This section explains how refinement of reactive systems can be proved. The standard technique of Abadi & Lamport <ref> [AL91] </ref> is used, i.e., refinement is proven by providing a refinement mapping from the concrete system to the abstract system.
Reference: [AL93a] <author> M. Abadi and L. Lamport. </author> <title> Composing specifications. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 15(1) </volume> <pages> 73-132, </pages> <year> 1993. </year>
Reference: [AL93b] <author> M. Abadi and L. Lamport. </author> <title> Conjoining specifications. </title> <type> Technical Report 118, </type> <institution> Digital Systems Research Center, </institution> <year> 1993. </year>
Reference: [AS85] <author> B. Alpern and F.B. Schneider. </author> <title> Defining liveness. </title> <journal> Information Processing Letters, </journal> <volume> 21(4) </volume> <pages> 181-185, </pages> <year> 1985. </year>
Reference-contexts: These definitions of safety and liveness are based on those of <ref> [AS85] </ref>. Informally a safety set of histories consists of histories where nothing "bad" happens and a liveness set of histories consists of histories where something "good" eventually happens. <p> Note: the only set that is both a safety and a liveness set is H <ref> [AS85] </ref>. A specification method for systems that uses only sets of histories is not attractive. Therefore the notion of machine is introduced. A machine consists of a set of states and a state-transition relation. <p> This is the machine closedness property of a system specification introduced in [AFK88, AL91]. Let A ! B denote A S B. By a result of <ref> [AS85] </ref> every set of histories can be written as the intersection of a safety set and a liveness set namely cl (Comp (M ) " L) T cl (Comp (M ) " L) ! (Comp (M ) " L). <p> In order to prove relative refinement we must know how this set W looks like. Is it a safety set, a liveness set or neither of them? A result of <ref> [AS85] </ref> states that every set of histories can be represented as the intersection of a safety and a liveness set. Now lemma 1 expresses that for a machine M 1 , Comp (M 1 ) is a safety set.
Reference: [AS87] <author> B. Alpern and F. Schneider. </author> <title> Proving boolean combinations of deterministic properties. </title> <booktitle> In Proceedings of the second symposium on logic in computer science, </booktitle> <pages> pages 131-137. </pages> <publisher> IEEE, </publisher> <month> June </month> <year> 1987. </year>
Reference-contexts: A machine consists of a set of states and a state-transition relation. The intention is that the set of computations (i.e. histories) of a machine associated to a system should correspond to the history specification of this system. A machine however can only generate safety sets of histories <ref> [AS87] </ref>. Therefore, a liveness set is specified as a condition on the set of computations (histories) of a machine. Next the formal definition of a machine is given.
Reference: [BKP86] <author> H. Barringer, R. Kuiper, and A. Pnueli. </author> <title> A really abstract concurrent model and its temporal semantics. </title> <booktitle> In Proc. 13th ACM Symp. Princ. of Prog. Lang., </booktitle> <pages> pages 173-183, </pages> <year> 1986. </year>
Reference-contexts: The underlying model for these behaviours is dense. The method which we present is based on the work of E.W. Stark [Sta84, Sta85, Sta88]. Here we present a framework which can model both CSP based and shared variable based concurrency, using the work of <ref> [BKP86, DK90, KMP93] </ref>. In section 2.2 reactive systems are specified by sets of histories together with a basis. A history is pair consisting of an event and a state function. The domains of these functions are the non-negative real numbers (the underlying dense model). <p> A dense time temporal logic DTL based on histories is introduced in section 2.2.2. This logic is based on <ref> [Sta84, Sta85, BKP86, DK90, KMP93] </ref>. A salient feature of the dense time temporal logic is the "immediately after" operator 0 , in a version which Lamport [Lam83] approves of, i.e., it is stutter insensitive. <p> Because of this some requirements are needed in order to specify "reasonable" histories. Here reasonable is used in the sense that in a bounded interval only a finite number of non-silent actions and process state changes can occur. This requirement is called the finite variability condition <ref> [BKP86] </ref>. Next several notions for functions from R 0 (the positive reals including 0) to some domain D are introduced in order to define this requirement and to formally define the event and state functions. <p> The dense time temporal logic DTL is introduced to describe both kind of properties. The one used here is a mixture of dense time temporal logics defined in <ref> [Sta84, Sta85, BKP86, DK90, KMP93] </ref>. Definition 18 (Syntax of DTL) The syntax of DTL is defined in Table 2.1 where value 2 V al, rigid variable n 2 R, observable variable v 2 V, local variable x 2 X, event variable * 2 E and channel a 2 Chan. <p> p [exp=w] iff ((h : w ; exp); t) j= p e (h; t) j= p [rexp=n] iff ((h : n ; rexp); t) j= p f (h; t) j= p [evexp=*] iff ((h : * ; evexp); t) j= p The following proof system for DTL is inspired on <ref> [Bur82, Bur84, BKP86, MP89] </ref>. An erroneous variant of it appeared in [BKP86] where these authors state that it is "an almost verbatim copy of [Bur84]" indeed "almost" their axiom F5 was not copied well. <p> An erroneous variant of it appeared in <ref> [BKP86] </ref> where these authors state that it is "an almost verbatim copy of [Bur84]" indeed "almost" their axiom F5 was not copied well. Furthermore a link with the proof system of [KMP93] is established via axioms AX7b-AX7f , i.e., these axioms are needed for deriving their proof system.
Reference: [Bur82] <author> J.P. Burgess. </author> <title> Axioms for tense logic, i. "since" and "until". </title> <journal> Notre Dame Jornal of Formal Logic, </journal> <volume> 23(4) </volume> <pages> 367-374, </pages> <month> October </month> <year> 1982. </year>
Reference-contexts: p [exp=w] iff ((h : w ; exp); t) j= p e (h; t) j= p [rexp=n] iff ((h : n ; rexp); t) j= p f (h; t) j= p [evexp=*] iff ((h : * ; evexp); t) j= p The following proof system for DTL is inspired on <ref> [Bur82, Bur84, BKP86, MP89] </ref>. An erroneous variant of it appeared in [BKP86] where these authors state that it is "an almost verbatim copy of [Bur84]" indeed "almost" their axiom F5 was not copied well. <p> Furthermore a link with the proof system of [KMP93] is established via axioms AX7b-AX7f , i.e., these axioms are needed for deriving their proof system. Note: because the models of <ref> [Bur82, Bur84] </ref> need not to satisfy the finite variability condition, and the persistency condition (once in an interval "going back or forward" doesn't bring you outside that interval, and the induction axiom. This is the crucial differrence between the model of [KMP93] and ours and the one in [Bur82, Bur84]. <p> models of <ref> [Bur82, Bur84] </ref> need not to satisfy the finite variability condition, and the persistency condition (once in an interval "going back or forward" doesn't bring you outside that interval, and the induction axiom. This is the crucial differrence between the model of [KMP93] and ours and the one in [Bur82, Bur84]. The differrence between the model of [KMP93] and our model is that we have additional compositionality information as reflected in axioms AX0, AX5 and AX6. The proof system is for the pure logic, i.e., it is not meant for a specific reactive system.
Reference: [Bur84] <author> J.P. Burgess. </author> <title> Basic tense logic. </title> <editor> In D. Gabbay and F. Guenthner, editors, </editor> <booktitle> Handbook of Philosophical Logic., </booktitle> <volume> volume II, </volume> <pages> pages 89-133. </pages> <publisher> Reidel Publishers, </publisher> <year> 1984. </year>
Reference-contexts: p [exp=w] iff ((h : w ; exp); t) j= p e (h; t) j= p [rexp=n] iff ((h : n ; rexp); t) j= p f (h; t) j= p [evexp=*] iff ((h : * ; evexp); t) j= p The following proof system for DTL is inspired on <ref> [Bur82, Bur84, BKP86, MP89] </ref>. An erroneous variant of it appeared in [BKP86] where these authors state that it is "an almost verbatim copy of [Bur84]" indeed "almost" their axiom F5 was not copied well. <p> An erroneous variant of it appeared in [BKP86] where these authors state that it is "an almost verbatim copy of <ref> [Bur84] </ref>" indeed "almost" their axiom F5 was not copied well. Furthermore a link with the proof system of [KMP93] is established via axioms AX7b-AX7f , i.e., these axioms are needed for deriving their proof system. <p> Furthermore a link with the proof system of [KMP93] is established via axioms AX7b-AX7f , i.e., these axioms are needed for deriving their proof system. Note: because the models of <ref> [Bur82, Bur84] </ref> need not to satisfy the finite variability condition, and the persistency condition (once in an interval "going back or forward" doesn't bring you outside that interval, and the induction axiom. This is the crucial differrence between the model of [KMP93] and ours and the one in [Bur82, Bur84]. <p> models of <ref> [Bur82, Bur84] </ref> need not to satisfy the finite variability condition, and the persistency condition (once in an interval "going back or forward" doesn't bring you outside that interval, and the induction axiom. This is the crucial differrence between the model of [KMP93] and ours and the one in [Bur82, Bur84]. The differrence between the model of [KMP93] and our model is that we have additional compositionality information as reflected in axioms AX0, AX5 and AX6. The proof system is for the pure logic, i.e., it is not meant for a specific reactive system.
Reference: [CC94] <author> A. Cau and P. Collette. </author> <title> Parallel composition of assumption-commitment specifications: a unifying approach for shared variable and distributed message passing concurrency. </title> <note> To appear in Acta Informatica, </note> <year> 1994. </year>
Reference-contexts: Introduction that stores "compositionality information" like "this is a system step" or "this is an en-vironement step" or "this is a communication step". A merging operator, first version defined in [Acz83], based on the one defined in <ref> [CC94] </ref> is introduced to merge this "com-positionality information" of the components into "compositionality information" of the composed system. The use of event variables has as second advantage that existing proof rules for refinement like those in [Lam91, KMP93] can easily be extended to our framework. <p> In our model however, it can be modeled as conjunction because the specification of one component also contains environmental information, especially about the other component. With a "conjoining" operator the histories of both components are merged into a history of the composite one. This conjoining operator based on <ref> [CC94] </ref> corresponds in our model almost to conjunction and is actually an extended version of Aczel's one [Acz83] because it also can handle CSP based concurrency whereas Aczel's one can only handle shared variable 3 A Dense Model Formalism based concurrency. s s c s ss . . . . .
Reference: [CdR93a] <author> A. Cau and W.-P. de Roever. </author> <title> Specifying fault tolerance within stark's formalism. </title> <booktitle> In Proc. of the Twenty-Third International Symposium on Fault-Tolerant Computing, </booktitle> <pages> pages 392-401. </pages> <publisher> IEEE, </publisher> <year> 1993. </year> <note> 135 BIBLIOGRAPHY </note>
Reference-contexts: In Chapter 4 we present a formal development strategy for the development of certain fault tolerant systems using our notion of relative refinement. A preliminary version of this strategy appeared in <ref> [CdR93b, CdR93a] </ref> using the original formalism of [Sta84]. The formal strategy is as follows: one starts with an implementation for a specified fault tolerant system. This implementation contains some faults, i.e., the refinement step is incorrect because of these faults.
Reference: [CdR93b] <author> A. Cau and W.-P. de Roever. </author> <title> Using relative refinement for fault tolerance. </title> <booktitle> In Proceedings of FME'93 symposium: industrial strength formal methods, </booktitle> <year> 1993. </year>
Reference-contexts: In Chapter 4 we present a formal development strategy for the development of certain fault tolerant systems using our notion of relative refinement. A preliminary version of this strategy appeared in <ref> [CdR93b, CdR93a] </ref> using the original formalism of [Sta84]. The formal strategy is as follows: one starts with an implementation for a specified fault tolerant system. This implementation contains some faults, i.e., the refinement step is incorrect because of these faults.
Reference: [CKdR92] <author> A. Cau, R. Kuiper, and W.-P. de Roever. </author> <title> Formalising Dijkstra's development strategy within Stark's formalism. </title> <editor> In C. B. Jones, R. C. Shaw, and T. Denvir, editors, </editor> <booktitle> Proc. 5th. BCS-FACS Refinement Workshop, </booktitle> <year> 1992. </year>
Reference-contexts: The refinement proof rules are extended to handle relative refinement so that the correct part of incorrect development steps can be proven correct. In Chapter 3 we present Dijkstra's development strategy of the readers/writers problem [Dij79] in our formalism. A preliminary version of this formalization, without proofs, appeared in <ref> [CKdR92] </ref> using the original formalism of [Sta84].
Reference: [Cri85] <author> F. Cristian. </author> <title> A rigorous approach to fault-tolerant programming. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 11(1) </volume> <pages> 23-31, </pages> <year> 1985. </year>
Reference-contexts: Section 4.2 introduces this application. In sections 4.3, 4.4, 4.5 and 4.6 the four steps of this general methodology are applied to the stable storage example <ref> [Cri85, Sch91] </ref>. 4.1 The General Methodology The general methodology consists of four steps. In the first step one gives the abstract specification S M = (B; H) where H is a DTL formula specifying the fault tolerant system. <p> But under the assumption that these faults don't occur this first implementation is a refinement of stable storage. 4.4.2 Specification We must specify a physical disk, the anticipated faults and their impact on the physical disk. We take as anticipated faults the following ones (cf. <ref> [Cri85, Sch91] </ref>): * Damages of the disk surface causing corruption of the contents of a physical sector. * Disk control faults causing the contents of a particular physical sector to be read or written at a wrong location.
Reference: [Dij79] <author> E.W. Dijkstra. </author> <title> A tutorial on the split binary semaphore, </title> <note> 1979. EWD 703. </note>
Reference-contexts: The refinement proof rules are extended to handle relative refinement so that the correct part of incorrect development steps can be proven correct. In Chapter 3 we present Dijkstra's development strategy of the readers/writers problem <ref> [Dij79] </ref> in our formalism. A preliminary version of this formalization, without proofs, appeared in [CKdR92] using the original formalism of [Sta84]. <p> In our formalism the fourth implementation will be represented by system S 4 and it is proved that S 4 relatively refines S 3 with respect to (true; W 3 ), i.e., in the fourth step no further requirements are imposed. 3.2 The abstract specification Here Dijkstra's strategy <ref> [Dij79] </ref> is followed and it is shown how the informal approach used there can be formalized.
Reference: [DK90] <author> E. Diepstraten and R. Kuiper. Abadi & Lamport and Stark: </author> <title> towards a proof theory for stuttering, dense domains and refinements mappings. </title> <booktitle> In LNCS 430:Proc. of the REX Workshop on Stepwise Refinement of Distributed Systems, Models, Formalisms, Correctness, </booktitle> <pages> pages 208-238. </pages> <publisher> Springer-Verlag, </publisher> <year> 1990. </year>
Reference-contexts: The underlying model for these behaviours is dense. The method which we present is based on the work of E.W. Stark [Sta84, Sta85, Sta88]. Here we present a framework which can model both CSP based and shared variable based concurrency, using the work of <ref> [BKP86, DK90, KMP93] </ref>. In section 2.2 reactive systems are specified by sets of histories together with a basis. A history is pair consisting of an event and a state function. The domains of these functions are the non-negative real numbers (the underlying dense model). <p> A dense time temporal logic DTL based on histories is introduced in section 2.2.2. This logic is based on <ref> [Sta84, Sta85, BKP86, DK90, KMP93] </ref>. A salient feature of the dense time temporal logic is the "immediately after" operator 0 , in a version which Lamport [Lam83] approves of, i.e., it is stutter insensitive. <p> In our model initial stuttering is incorporated by default (cf. <ref> [DK90] </ref>) and refinement can be expressed using implication and existential quantification. In section 2.3 the notions of composition and refinement of systems are defined. Firstly in terms of histories (semantically) and secondly in the dense time temporal logic DTL (syntactically). <p> Now event and state functions can be defined. <ref> [DK90] </ref> states that initial stuttering is needed in order to express refinement in a logic with the help of existential quantification and implication. We must first define what stuttering, in the sense of [DK90], is in our setting. <p> Now event and state functions can be defined. <ref> [DK90] </ref> states that initial stuttering is needed in order to express refinement in a logic with the help of existential quantification and implication. We must first define what stuttering, in the sense of [DK90], is in our setting. In our setting a stutter step is a step in which a non-communication action doesn't change the state. <p> The dense time temporal logic DTL is introduced to describe both kind of properties. The one used here is a mixture of dense time temporal logics defined in <ref> [Sta84, Sta85, BKP86, DK90, KMP93] </ref>. Definition 18 (Syntax of DTL) The syntax of DTL is defined in Table 2.1 where value 2 V al, rigid variable n 2 R, observable variable v 2 V, local variable x 2 X, event variable * 2 E and channel a 2 Chan.
Reference: [Hoa84] <author> C.A.R. Hoare. </author> <title> Communicating Sequential Processes. </title> <publisher> Prentice-Hall, </publisher> <address> London, </address> <year> 1984. </year>
Reference-contexts: The first requirement is that silent actions don't give rise to process state changes. The second requirement is that communication actions don't change the shared variables; this requirement is imposed in order to model CSP <ref> [Hoa84] </ref> like processes.
Reference: [Jon83] <author> C.B. Jones. </author> <title> Tentative steps towards a development method for interfering programs. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 5(4) </volume> <pages> 596-619, </pages> <year> 1983. </year>
Reference: [KMP93] <author> Y. Kesten, Z. Manna, and A. Pnueli. </author> <title> Temporal verification of simulation and refinement. </title> <editor> In J.W. de Bakker, W.-P. de Roever, and G. Rozenberg, editors, </editor> <booktitle> LNCS 803: A Decade of Concurrency, Reflections and Perspectives, </booktitle> <pages> pages 273-346. </pages> <publisher> Springer-Verlag, </publisher> <year> 1993. </year>
Reference-contexts: The use of event variables has as second advantage that existing proof rules for refinement like those in <ref> [Lam91, KMP93] </ref> can easily be extended to our framework. The notion of relative refinement is introduced to handle "incorrect" development steps. The system specification is therefore extended by a requirement that extracts the "good" computations of the system. <p> The underlying model for these behaviours is dense. The method which we present is based on the work of E.W. Stark [Sta84, Sta85, Sta88]. Here we present a framework which can model both CSP based and shared variable based concurrency, using the work of <ref> [BKP86, DK90, KMP93] </ref>. In section 2.2 reactive systems are specified by sets of histories together with a basis. A history is pair consisting of an event and a state function. The domains of these functions are the non-negative real numbers (the underlying dense model). <p> A dense time temporal logic DTL based on histories is introduced in section 2.2.2. This logic is based on <ref> [Sta84, Sta85, BKP86, DK90, KMP93] </ref>. A salient feature of the dense time temporal logic is the "immediately after" operator 0 , in a version which Lamport [Lam83] approves of, i.e., it is stutter insensitive. <p> Section 2.4 gives proof rules for refinement based on those given in <ref> [Lam91, KMP93] </ref>. <p> Furthermore should every non- event be surrounded by -events. These kind of sequences are inspired by those defined in <ref> [KMP93] </ref>. For these kind of sequences a sequence collapse is defined that removes all finite stuttering; with the help of this collapse operator the sequence stutter equivalence operator is defined. Definition 11 (Infinite sequences) Define a sequence element as a pair (ffi; ) of an event and a process state. <p> The dense time temporal logic DTL is introduced to describe both kind of properties. The one used here is a mixture of dense time temporal logics defined in <ref> [Sta84, Sta85, BKP86, DK90, KMP93] </ref>. Definition 18 (Syntax of DTL) The syntax of DTL is defined in Table 2.1 where value 2 V al, rigid variable n 2 R, observable variable v 2 V, local variable x 2 X, event variable * 2 E and channel a 2 Chan. <p> An erroneous variant of it appeared in [BKP86] where these authors state that it is "an almost verbatim copy of [Bur84]" indeed "almost" their axiom F5 was not copied well. Furthermore a link with the proof system of <ref> [KMP93] </ref> is established via axioms AX7b-AX7f , i.e., these axioms are needed for deriving their proof system. <p> Note: because the models of [Bur82, Bur84] need not to satisfy the finite variability condition, and the persistency condition (once in an interval "going back or forward" doesn't bring you outside that interval, and the induction axiom. This is the crucial differrence between the model of <ref> [KMP93] </ref> and ours and the one in [Bur82, Bur84]. The differrence between the model of [KMP93] and our model is that we have additional compositionality information as reflected in axioms AX0, AX5 and AX6. <p> This is the crucial differrence between the model of <ref> [KMP93] </ref> and ours and the one in [Bur82, Bur84]. The differrence between the model of [KMP93] and our model is that we have additional compositionality information as reflected in axioms AX0, AX5 and AX6. The proof system is for the pure logic, i.e., it is not meant for a specific reactive system. <p> Axiom (f ) is the induction axiom. For an explanation of d-f see <ref> [KMP93] </ref>. AX8 : fl b true There is no last element, i.e., the future is unbounded. AX9 : fl b b c false There exists a first element. <p> This culminates in the following proof rule for refinement based on similar ones in <ref> [Lam91, KMP93] </ref>. Rule 1 (Proof rule for refinement) Given concrete machine specification S c M = (B c ; I c ^ flT c ^ L c ) and abstract machine spec ification S a M = (B a ; I a ^ flT a ^ L a ) s.t. <p> So one gets the following proof rule, similar rules appearing in <ref> [Lam91, KMP93] </ref>.
Reference: [LA90] <author> P.A. Lee and T. Anderson. </author> <title> Fault Tolerance Principles and Practice, volume 3 of Dependable Computing and Fault-Tolerant Systems. </title> <note> Springer-Verlag, second, revised edition, </note> <year> 1990. </year>
Reference-contexts: In the next step we try to detect these faults, i.e., we construct a detection layer upon the previous implementation that stops that implementation when it detects an error caused by these faults. This is called a fail-stop implementation <ref> [LA90] </ref> and represents an improvement over the previous implementation because now at least the implementation stops on the occurrence of such a fault. <p> The implementation of the detection layer is such that as soon as a fault is detected the system stops. This is called a fail-stop implementation <ref> [LA90] </ref>. As seen above, there are two classes of anticipated faults. Consequently there are two kinds of detection mechanisms. The first one checks whether the contents read from the physical disk are corrupted, i.e., detects errors due to damage of the disk surface. <p> Consequently there are two kinds of detection mechanisms. The first one checks whether the contents read from the physical disk are corrupted, i.e., detects errors due to damage of the disk surface. This is done with a cyclic redundancy mechanism <ref> [LA90] </ref>. The second one checks whether the contents of read from the physical disk originate from the right location. This is done with an address checking mechanism [LA90] which encodes the location of the contents of the physical disk in the contents itself. 4.5.2 Specification The detection layer consists of three <p> This is done with a cyclic redundancy mechanism <ref> [LA90] </ref>. The second one checks whether the contents of read from the physical disk originate from the right location. This is done with an address checking mechanism [LA90] which encodes the location of the contents of the physical disk in the contents itself. 4.5.2 Specification The detection layer consists of three parts: the first part checks whether the data retrieved from the physical disk is affected by a corrupt data fault (the fault that damages the disk surface). <p> This is done with a cyclic redundancy check (CRC) mechanism <ref> [LA90] </ref>. The second part checks whether the data retrieved from the physical disk is from the correct physical location, i.e., whether it is affected by a disk control system fault. This is done with an address checking (ADR) mechanism [LA90]. <p> This is done with a cyclic redundancy check (CRC) mechanism <ref> [LA90] </ref>. The second part checks whether the data retrieved from the physical disk is from the correct physical location, i.e., whether it is affected by a disk control system fault. This is done with an address checking (ADR) mechanism [LA90]. The third part prevents further access by the user of the physical disk when one of these two mechanisms detects a fault. <p> Initial states: I Ds = ` Ds = 0 ^ i2LN 3. Transitions: To describe the two detecting mechanisms as transitions the following functions are needed: (see <ref> [LA90] </ref> for more information about this CRC-coding) * CC : P hy ! Bool (Crc-Check) Is used to check whether data from the physical disk is damaged by a disk surface fault. * CD : P hy ! (Lg fi P N ) (Crc-Decode) Is used to decode the CRC-coded physical <p> This is the layer that tries to correct the errors detected by the detection layer. The technique used for error recovery is that of the mirrored disk concept <ref> [LA90] </ref>. This mirror disk concept is as follows: instead of one physical disk and corresponding detection layer N physical disks with identical contents and N corresponding detection layers (N &gt; 1) are maintained.
Reference: [Lam] <author> L. Lamport. </author> <title> TLA Temporal Logic of Actions. The hypertext page on TLA: </title> <note> www.research.digital.com/ SRC/ personal/ Leslie Lamport/ tla/ tla.html. </note>
Reference-contexts: Due to this basis composition of reactive systems corresponds to conjunction. Note that in for instance Lamport's work on TLA <ref> [Lam91, Lam94, Lam] </ref> this is not always the case: x := 1kx := 1 must be modeled as disjunction because conjunction leads to a "one process" specification x := 1.
Reference: [Lam83] <author> L. Lamport. </author> <title> What good is temporal logic. In R.E.A. Manson, editor, </title> <booktitle> Information Processing 83: Proc. of the IFIP 9th World Congress, </booktitle> <pages> pages 657-668. </pages> <publisher> Elsevier Science Publishers, North Holland, </publisher> <year> 1983. </year>
Reference-contexts: The use of real numbers as domain for the event and state function handles the stutter problem. This problem, first observed by Lamport <ref> [Lam83, Lam89] </ref>, is as follows. Given two behaviours of a system, let the first behaviour contain only consecutive snap-shots of the system that differ from each other whereas the second behaviour contains the same snap-shots but also some consecutive ones that are identical. This is called stuttering. <p> A dense time temporal logic DTL based on histories is introduced in section 2.2.2. This logic is based on [Sta84, Sta85, BKP86, DK90, KMP93]. A salient feature of the dense time temporal logic is the "immediately after" operator 0 , in a version which Lamport <ref> [Lam83] </ref> approves of, i.e., it is stutter insensitive. In this logic the notion of a machine and the condition on the computations of that machine will be expressed.
Reference: [Lam89] <author> L. Lamport. </author> <title> A simple approach to specifying concurrent systems. </title> <journal> Communications of the ACM, </journal> <volume> 32(1) </volume> <pages> 32-45, </pages> <month> January </month> <year> 1989. </year>
Reference-contexts: The use of real numbers as domain for the event and state function handles the stutter problem. This problem, first observed by Lamport <ref> [Lam83, Lam89] </ref>, is as follows. Given two behaviours of a system, let the first behaviour contain only consecutive snap-shots of the system that differ from each other whereas the second behaviour contains the same snap-shots but also some consecutive ones that are identical. This is called stuttering.
Reference: [Lam91] <author> L. Lamport. </author> <title> The temporal logic of actions. </title> <type> Technical Report 79, </type> <institution> Digital Systems Research Center, </institution> <year> 1991. </year> <note> 136 BIBLIOGRAPHY </note>
Reference-contexts: The use of event variables has as second advantage that existing proof rules for refinement like those in <ref> [Lam91, KMP93] </ref> can easily be extended to our framework. The notion of relative refinement is introduced to handle "incorrect" development steps. The system specification is therefore extended by a requirement that extracts the "good" computations of the system. <p> Due to this basis composition of reactive systems corresponds to conjunction. Note that in for instance Lamport's work on TLA <ref> [Lam91, Lam94, Lam] </ref> this is not always the case: x := 1kx := 1 must be modeled as disjunction because conjunction leads to a "one process" specification x := 1. <p> Section 2.4 gives proof rules for refinement based on those given in <ref> [Lam91, KMP93] </ref>. <p> This culminates in the following proof rule for refinement based on similar ones in <ref> [Lam91, KMP93] </ref>. Rule 1 (Proof rule for refinement) Given concrete machine specification S c M = (B c ; I c ^ flT c ^ L c ) and abstract machine spec ification S a M = (B a ; I a ^ flT a ^ L a ) s.t. <p> So one gets the following proof rule, similar rules appearing in <ref> [Lam91, KMP93] </ref>.
Reference: [Lam94] <author> L. Lamport. </author> <title> The temporal logic of actions. </title> <note> To appear in ACM TOPLAS, </note> <month> July? </month> <year> 1994. </year>
Reference-contexts: Due to this basis composition of reactive systems corresponds to conjunction. Note that in for instance Lamport's work on TLA <ref> [Lam91, Lam94, Lam] </ref> this is not always the case: x := 1kx := 1 must be modeled as disjunction because conjunction leads to a "one process" specification x := 1.
Reference: [LGdR79] <author> S. Lee, S. Gerhart, and W.-P. de Roever. </author> <title> The evolution of list-copying algorithms and the need for structured program verification. </title> <booktitle> In Proc. of 6th POPL, </booktitle> <year> 1979. </year>
Reference: [MC81] <author> J. Misra and K.M. Chandy. </author> <title> Proofs of networks of processes. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 7(4) </volume> <pages> 417-426, </pages> <month> July </month> <year> 1981. </year>
Reference: [MP89] <author> Z. Manna and A. Pnueli. </author> <title> An exercise in the verification of multi-process programs. </title> <type> Technical report, </type> <institution> Stanford University, </institution> <year> 1989. </year>
Reference-contexts: p [exp=w] iff ((h : w ; exp); t) j= p e (h; t) j= p [rexp=n] iff ((h : n ; rexp); t) j= p f (h; t) j= p [evexp=*] iff ((h : * ; evexp); t) j= p The following proof system for DTL is inspired on <ref> [Bur82, Bur84, BKP86, MP89] </ref>. An erroneous variant of it appeared in [BKP86] where these authors state that it is "an almost verbatim copy of [Bur84]" indeed "almost" their axiom F5 was not copied well.
Reference: [PJ91] <author> P.K. Pandya and M. Joseph. </author> <title> P-a logic a compositional proof system for distributed programs. </title> <journal> Distributed Computing, </journal> <volume> 5 </volume> <pages> 37-54, </pages> <year> 1991. </year>
Reference: [Pnu85] <author> A. Pnueli. </author> <title> In transition from global to modular temporal reasoning about programs. </title> <booktitle> In NATO ASI Series F 13: Logics and models of concurrent systems, </booktitle> <pages> pages 123-144. </pages> <publisher> Springer-Verlag, </publisher> <year> 1985. </year>
Reference: [PWT90] <author> P.R.H. Place, W.G. Wood, and M. Tudball. </author> <title> Survey of formal specification techniques for reactive systems. </title> <type> Technical Report, </type> <year> 1990. </year>
Reference: [Sch91] <author> H. Schepers. </author> <title> Terminology and Paradigms for Fault Tolerance. </title> <institution> Computing Science Notes 91/08 of the Department of Mathematics and Computing Science Eindhoven University of Technology, </institution> <year> 1991. </year>
Reference-contexts: Section 4.2 introduces this application. In sections 4.3, 4.4, 4.5 and 4.6 the four steps of this general methodology are applied to the stable storage example <ref> [Cri85, Sch91] </ref>. 4.1 The General Methodology The general methodology consists of four steps. In the first step one gives the abstract specification S M = (B; H) where H is a DTL formula specifying the fault tolerant system. <p> But under the assumption that these faults don't occur this first implementation is a refinement of stable storage. 4.4.2 Specification We must specify a physical disk, the anticipated faults and their impact on the physical disk. We take as anticipated faults the following ones (cf. <ref> [Cri85, Sch91] </ref>): * Damages of the disk surface causing corruption of the contents of a physical sector. * Disk control faults causing the contents of a particular physical sector to be read or written at a wrong location.
Reference: [Sta84] <author> E.W. Stark. </author> <title> Foundations of a Theory of Specification for Distributed Systems. </title> <type> PhD thesis, </type> <institution> Massachusetts Inst. of Technology, </institution> <year> 1984. </year> <note> Available as Report No. MIT/LCS/TR-342. </note>
Reference-contexts: In Chapter 3 we present Dijkstra's development strategy of the readers/writers problem [Dij79] in our formalism. A preliminary version of this formalization, without proofs, appeared in [CKdR92] using the original formalism of <ref> [Sta84] </ref>. Our formalism preserves the flavour of the informal strategy in that it formalises Dijkstra's argumentation in terms of incorrect approximations to a correct program and provides a formal criterion for recog-nising when a formally correct end product, the correct program, has finally been reached. <p> In Chapter 4 we present a formal development strategy for the development of certain fault tolerant systems using our notion of relative refinement. A preliminary version of this strategy appeared in [CdR93b, CdR93a] using the original formalism of <ref> [Sta84] </ref>. The formal strategy is as follows: one starts with an implementation for a specified fault tolerant system. This implementation contains some faults, i.e., the refinement step is incorrect because of these faults. It is however relative correct because when these faults don't occur it is a correct implementation. <p> Because of this characteristic reactive systems should be described as sets of behaviours (histories). The underlying model for these behaviours is dense. The method which we present is based on the work of E.W. Stark <ref> [Sta84, Sta85, Sta88] </ref>. Here we present a framework which can model both CSP based and shared variable based concurrency, using the work of [BKP86, DK90, KMP93]. In section 2.2 reactive systems are specified by sets of histories together with a basis. <p> A dense time temporal logic DTL based on histories is introduced in section 2.2.2. This logic is based on <ref> [Sta84, Sta85, BKP86, DK90, KMP93] </ref>. A salient feature of the dense time temporal logic is the "immediately after" operator 0 , in a version which Lamport [Lam83] approves of, i.e., it is stutter insensitive. <p> A history intuitively specifies which event occurs at a particular point and in what state the system is at that particular point. Secondly reactive systems are specified using the dense time temporal logic DTL. 2.2.1 Semantic Specification of Reactive Systems In <ref> [Sta84] </ref> a method for specifying reactive systems is introduced. Such systems are characterized by sets of histories. A history is a pair consisting of an event function and a state function. An event function records at each point (i.e., element of the positive reals, including zero) which event occurs. <p> The dense time temporal logic DTL is introduced to describe both kind of properties. The one used here is a mixture of dense time temporal logics defined in <ref> [Sta84, Sta85, BKP86, DK90, KMP93] </ref>. Definition 18 (Syntax of DTL) The syntax of DTL is defined in Table 2.1 where value 2 V al, rigid variable n 2 R, observable variable v 2 V, local variable x 2 X, event variable * 2 E and channel a 2 Chan.
Reference: [Sta85] <author> E.W. Stark. </author> <title> A Proof Technique for Rely/Guarantee Properties. </title> <booktitle> In LNCS 206: Fifth Conference on Foundations of Software Technology and Theoretical Computer Science, </booktitle> <pages> pages 369-391. </pages> <publisher> Springer-Verlag, </publisher> <year> 1985. </year>
Reference-contexts: Because of this characteristic reactive systems should be described as sets of behaviours (histories). The underlying model for these behaviours is dense. The method which we present is based on the work of E.W. Stark <ref> [Sta84, Sta85, Sta88] </ref>. Here we present a framework which can model both CSP based and shared variable based concurrency, using the work of [BKP86, DK90, KMP93]. In section 2.2 reactive systems are specified by sets of histories together with a basis. <p> A dense time temporal logic DTL based on histories is introduced in section 2.2.2. This logic is based on <ref> [Sta84, Sta85, BKP86, DK90, KMP93] </ref>. A salient feature of the dense time temporal logic is the "immediately after" operator 0 , in a version which Lamport [Lam83] approves of, i.e., it is stutter insensitive. <p> The dense time temporal logic DTL is introduced to describe both kind of properties. The one used here is a mixture of dense time temporal logics defined in <ref> [Sta84, Sta85, BKP86, DK90, KMP93] </ref>. Definition 18 (Syntax of DTL) The syntax of DTL is defined in Table 2.1 where value 2 V al, rigid variable n 2 R, observable variable v 2 V, local variable x 2 X, event variable * 2 E and channel a 2 Chan.
Reference: [Sta88] <author> E.W. Stark. </author> <title> Proving entailment between conceptual state specifications. </title> <journal> Theoretical Computer Science, </journal> <volume> 56 </volume> <pages> 135-154, </pages> <year> 1988. </year>
Reference-contexts: Because of this characteristic reactive systems should be described as sets of behaviours (histories). The underlying model for these behaviours is dense. The method which we present is based on the work of E.W. Stark <ref> [Sta84, Sta85, Sta88] </ref>. Here we present a framework which can model both CSP based and shared variable based concurrency, using the work of [BKP86, DK90, KMP93]. In section 2.2 reactive systems are specified by sets of histories together with a basis.
Reference: [Sti88] <author> C. Stirling. </author> <title> A generalization of owicki-gries hoare logic for a concurrent while language. </title> <journal> Theoretical Computer Science, </journal> <volume> 58 </volume> <pages> 347-359, </pages> <year> 1988. </year>
Reference: [Stt91] <author> K. Sttlen. </author> <title> A method for the development of totally correct shared-state parallel programs. </title> <editor> In J.C.M. Baeten and J.F. Groote, editors, </editor> <booktitle> LNCS 527: Proceedings of Concur '91, </booktitle> <pages> pages 510-525. </pages> <publisher> Springer-Verlag, </publisher> <year> 1991. </year>
Reference: [WD88] <author> J.C.P. Woodcock and B. Dickinson. </author> <title> Using vdm with rely and guarantee-conditions. </title> <editor> In R. Bloomfield, L. Marshall, and R. Jones, editors, </editor> <booktitle> LNCS 328: Proceedings of VDM '88, The Way Ahead, </booktitle> <pages> pages 434-458. </pages> <publisher> Springer-Verlag, </publisher> <year> 1988. </year> <title> BIBLIOGRAPHY </title>
Reference: [Wri87] <author> M. Wriedt. Allgemeine Topologie I. </author> <type> Technical report, </type> <institution> Christian-Albrechts-Universitat zu Kiel, </institution> <year> 1987. </year> <editor> Vorlesungsskript ausgearbeitet von M. </editor> <publisher> Jager. </publisher>
Reference: [XCC94] <author> Q. Xu, A. Cau, and P. Collette. </author> <title> On unifying assumption-commitment style proof rules for concurrency. </title> <editor> In B. Jonsson and J. Parrow, editors, </editor> <booktitle> LNCS 836: CONCUR'94: Concurrency Theory, </booktitle> <pages> pages 267-282. </pages> <publisher> Springer-Verlag, </publisher> <year> 1994. </year>
Reference: [ZCdR92] <author> J. Zwiers, J. Coenen, and W.-P. de Roever. </author> <title> A note on compositional re-finemnt. </title> <editor> In C. B. Jones, R. C. Shaw, and T. Denvir, editors, </editor> <booktitle> 5th Refinement Workshop, Workshops in Computing, </booktitle> <pages> pages 342-366, </pages> <address> London, </address> <month> January </month> <year> 1992. </year> <title> BCS-FACS, </title> <publisher> Springer Verlag. </publisher>
Reference-contexts: In section 2.3 the notions of composition and refinement of systems are defined. Firstly in terms of histories (semantically) and secondly in the dense time temporal logic DTL (syntactically). It is also investigated how composition relates to refinement, i.e., the notion of compositional refinement <ref> [ZCdR92] </ref> is given. Compositional refinement means intuitively that if the components of an abstract composed system are refined by the components of a concrete composed system then the abstract composed system is refined by the concrete composed system, i.e., refinement is preserved under composition.
Reference: [ZdBdR84] <author> J. Zwiers, A. de Bruin, and W.-P. de Roever. </author> <title> A proof system for partial correctness of dynamic networks of processes. </title> <booktitle> In LNCS 164: Proc. of the Conference on Logics of Programs 1983, </booktitle> <pages> pages 513-527. </pages> <publisher> Springer-Verlag, </publisher> <year> 1984. </year>
Reference: [ZdRvEB84] <author> J. Zwiers, W.-P. de Roever, and P. van Emde Boas. </author> <title> Compositionality and concurrent networks: soundness and completeness of a proof system. </title> <type> Technical report, </type> <institution> University of Nijmegen, </institution> <year> 1984. </year> <type> Technical Report 57. 138 </type>
References-found: 44

