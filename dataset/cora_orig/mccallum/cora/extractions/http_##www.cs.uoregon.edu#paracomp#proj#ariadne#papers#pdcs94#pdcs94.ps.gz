URL: http://www.cs.uoregon.edu/paracomp/proj/ariadne/papers/pdcs94/pdcs94.ps.gz
Refering-URL: http://www.cs.uoregon.edu/paracomp/proj/ariadne/publications.html
Root-URL: http://www.cs.uoregon.edu
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> G. Alverson, W. Griswold, D. Notkin and L. Snyder. </author> <title> A flexible communication abstraction for nonshared memory parallel computing. </title> <booktitle> Proceedings of Supercomputing '90, </booktitle> <year> 1990. </year>
Reference-contexts: They are described by extensions of regular expressions. When they are matched against an execution history graph, all events in the chain must occur exactly in the order specified with the exception of communication events that are not physically realized because of "edge effects" on process array boundaries <ref> [1] </ref>. * p-Chains are patterns representing the concurrent execution of a chain by a set of processes. They are described by binding a chain to a process set.
Reference: [2] <author> F. Baiardi, N. De Fransesco and G. Vaglini. </author> <title> Development of a debugger for a concurrent language. </title> <journal> In IEEE Transactions on Software Engineering, </journal> <volume> SE-12(4):547-553, </volume> <month> Apr. </month> <year> 1986. </year>
Reference-contexts: Event-based behavioral abstraction provides a mechanism to handle the volume of data by allowing users to specify the program behavior in a hierarchical fashion, which is then compared with the actual execution <ref> [2, 3, 14, 16] </ref>. Transformations of logical time helps to filter out the perturbations of physical asynchrony, and allow the user to examine the program behavior from different temporal perspectives [14, 19, 6].
Reference: [3] <author> P. C. Bates. </author> <title> Debugging Programs in a Distributed System Environment. </title> <type> PhD thesis, </type> <institution> University of Massachusetts, </institution> <address> Amherst, MA 01003, </address> <year> 1986. </year> <note> Also COINS Technical Report 86-05. </note>
Reference-contexts: Event-based behavioral abstraction provides a mechanism to handle the volume of data by allowing users to specify the program behavior in a hierarchical fashion, which is then compared with the actual execution <ref> [2, 3, 14, 16] </ref>. Transformations of logical time helps to filter out the perturbations of physical asynchrony, and allow the user to examine the program behavior from different temporal perspectives [14, 19, 6]. <p> The matching algorithm for our language is straightforward: a pt-chain is recognized by a finite state machine that invokes copies of other finite state machines to recognize chains on specific processes. This matching can be done efficiently, avoiding the costliness of pattern matching approaches <ref> [3, 13] </ref> and the expensive implementations of previous languages [16].
Reference: [4] <author> B. Bruegge and P. Hibbard. </author> <title> Generalized path expressions: A high level debugging mechanism. </title> <booktitle> In Proceedings of the ACM SIGSOFT/SIGPLAN Software Engineering Symposium in High-Level Debugging, </booktitle> <pages> pages 34-44, </pages> <year> 1983. </year>
Reference: [5] <author> R. Cooper and K. Marzullo. </author> <title> Consistent detection of global predicates. </title> <booktitle> In Proceedings of the ACM/ONR Workshop on Parallel and Distributed Debugging, </booktitle> <pages> pages 167-174, </pages> <year> 1991. </year>
Reference-contexts: Instead, the programmer is concerned with the logical ordering of events. At the primitive event level, this ordering is captured by Lamport's happened before relation. Other debuggers have used temporal logic to express assertions about happened before <ref> [5, 10] </ref> but they do not use behavioral abstraction. We extend the relation to abstract events, defining three relations: precedes, parallels, and overlaps [15].
Reference: [6] <author> J. E. Cuny, A. Hough, and J. Kundu. </author> <title> Logical time in visualizations produced by parallel programs. </title> <booktitle> Proceedings of Visualization '92, </booktitle> <pages> pages 186-193 (1992). </pages>
Reference-contexts: Transformations of logical time helps to filter out the perturbations of physical asynchrony, and allow the user to examine the program behavior from different temporal perspectives <ref> [14, 19, 6] </ref>. Many systems try to attack the problem of comprehending large amount of data, by providing the user with an animation system [14, ?, ?].
Reference: [7] <author> J. E. Cuny, G. Forman, A. Hough, J. Kundu, C. Lin, L. Snyder, and D. Stemple. </author> <title> The Ariadne Debugger: Scalable Application of Event-Based Abstraction. </title> <journal> SIGPLAN Notices, </journal> <volume> 28(12), </volume> <pages> pages 85-95, </pages> <year> 1994. </year>
Reference-contexts: relation captures the notion that just some part of a complex event happens before some part of another event; other definitions require a total ordering which is rarely found in the programs we have examined. 2.3 Ave: The Visual Feedback Scheme for Ariadne In our earlier paper we presented Ariadne's <ref> [7] </ref> support for interactive, textual exploration of the program execution graph. The textual feedback, although complete, can overwhelm the user when the pattern to be matched is data dependent. <p> This resulted in each queue element except 9 to be examined twice, when BITE = 1. 4 Conclusion The combination of the modeling approach of Ariadne <ref> [7] </ref> with the visual feedback scheme of Ave is a powerful tool to tackle the debugging issues in masssively parallel computing.
Reference: [8] <author> C. J. Fidge. </author> <title> Partial orders for parallel debugging. </title> <journal> SIGPLAN Notices, </journal> <volume> 24(1), </volume> <pages> pages 183-194, </pages> <year> 1989. </year>
Reference-contexts: Similar extensions have been proposed <ref> [8, 16, 18] </ref> but we have found our definitions to be more appropriate for debugging.
Reference: [9] <author> R. J. Fowler, T. J. Leblanc, and J. M. Mellor-Crummey. </author> <title> An integrated approach to parallel program debugging and performance analysis on large-scale multiprocessors. </title> <journal> SIGPLAN Notices, </journal> <volume> 24(1), </volume> <pages> pages 163-173, </pages> <year> 1989. </year>
Reference-contexts: The traces are stored internally in an execution history graph where the nodes represent events and the edges represent communication events; from these traces we can derive Lamport's happened before relation [17]. A number of debuggers provide visualizations of execution history graphs <ref> [9, 11, 12, 21] </ref> but such visualizations do not scale well for massively parallel systems. Ave/Ariadne supports interactive, textual and graphical explorations of the graph.
Reference: [10] <author> G. S. Goldszmidt, S. Katz, and S. Yemini. </author> <title> High level language for debugging concurrent programs. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 8(4), </volume> <pages> pages 311-336, </pages> <month> Nov. </month> <year> 1990. </year>
Reference-contexts: Instead, the programmer is concerned with the logical ordering of events. At the primitive event level, this ordering is captured by Lamport's happened before relation. Other debuggers have used temporal logic to express assertions about happened before <ref> [5, 10] </ref> but they do not use behavioral abstraction. We extend the relation to abstract events, defining three relations: precedes, parallels, and overlaps [15].
Reference: [11] <author> P. K. Harter, D. M. Heimbigner and R. King. IDD: </author> <title> an interactive distributed debugger. </title> <booktitle> In Proceedings of the 5th International Conference on Distributed Computing Systems, </booktitle> <pages> pages 498-506, </pages> <year> 1985. </year>
Reference-contexts: The traces are stored internally in an execution history graph where the nodes represent events and the edges represent communication events; from these traces we can derive Lamport's happened before relation [17]. A number of debuggers provide visualizations of execution history graphs <ref> [9, 11, 12, 21] </ref> but such visualizations do not scale well for massively parallel systems. Ave/Ariadne supports interactive, textual and graphical explorations of the graph.
Reference: [12] <author> M. Heath and J. Etheridge. </author> <title> Visualizing the performance of parallel programs. </title> <journal> IEEE Software, </journal> <volume> 8(5) </volume> <pages> 29-39, </pages> <year> 1991. </year>
Reference-contexts: The traces are stored internally in an execution history graph where the nodes represent events and the edges represent communication events; from these traces we can derive Lamport's happened before relation [17]. A number of debuggers provide visualizations of execution history graphs <ref> [9, 11, 12, 21] </ref> but such visualizations do not scale well for massively parallel systems. Ave/Ariadne supports interactive, textual and graphical explorations of the graph.
Reference: [13] <author> D. Hembold and D. Luckham. </author> <title> Debugging Ada tasking programs. </title> <journal> IEEE Software, </journal> <volume> 2(2), </volume> <pages> pages 47-57, </pages> <month> Mar. </month> <year> 1985. </year>
Reference-contexts: The matching algorithm for our language is straightforward: a pt-chain is recognized by a finite state machine that invokes copies of other finite state machines to recognize chains on specific processes. This matching can be done efficiently, avoiding the costliness of pattern matching approaches <ref> [3, 13] </ref> and the expensive implementations of previous languages [16].
Reference: [14] <author> A. A. Hough. </author> <title> Debugging Parallel Programs Using Abstract Visualizations. </title> <type> PhD thesis, </type> <institution> University of Massachusetts, </institution> <address> Amherst, MA 01003, </address> <year> 1991. </year> <note> Also COINS Technical Report 91-53. </note>
Reference-contexts: Event-based behavioral abstraction provides a mechanism to handle the volume of data by allowing users to specify the program behavior in a hierarchical fashion, which is then compared with the actual execution <ref> [2, 3, 14, 16] </ref>. Transformations of logical time helps to filter out the perturbations of physical asynchrony, and allow the user to examine the program behavior from different temporal perspectives [14, 19, 6]. <p> Transformations of logical time helps to filter out the perturbations of physical asynchrony, and allow the user to examine the program behavior from different temporal perspectives <ref> [14, 19, 6] </ref>. Many systems try to attack the problem of comprehending large amount of data, by providing the user with an animation system [14, ?, ?]. <p> Many systems try to attack the problem of comprehending large amount of data, by providing the user with an animation system <ref> [14, ?, ?] </ref>. However all the approaches suffer from two major drawbacks: firstly they do not provide sufficient feedback, nor do they scale up for massive parallelism. <p> Processor-oriented animation schemes, although informative when the observed behavior matches the expected pattern, do not scale well to even moderate number of processors (such as 64), and depends on the user for the specification of the processor placement <ref> [14, ?] </ref>. <p> Ave's approach of giving the visual feedback in terms of the match tree frees the user from the layout considerations that needed to be tackled with other visualization systems <ref> [14, ?] </ref>. At the same time, Ave imposes the user's view of abstraction over the primitive events which makes it more useful than the tools that only provide process time graph displays of the computation [?].
Reference: [15] <author> A. A. Hough and J. E. Cuny. </author> <title> Perspective views: A technique for enchancing visualizations of parallel programs. </title> <booktitle> In 1990 International Conference on Parallel Processing, </booktitle> <pages> pages II 124-132, </pages> <month> Aug. </month> <year> 1990. </year>
Reference-contexts: At the primitive event level, this ordering is captured by Lamport's happened before relation. Other debuggers have used temporal logic to express assertions about happened before [5, 10] but they do not use behavioral abstraction. We extend the relation to abstract events, defining three relations: precedes, parallels, and overlaps <ref> [15] </ref>.
Reference: [16] <author> W. Hseush and G. E. Kaiser. </author> <title> Modeling concurrency in parallel debugging. </title> <booktitle> In Proceedings of the Second ACM SIGPLAN Symposium on Principles and Practice of Parallel Programming, </booktitle> <pages> pages 11-20, </pages> <month> March </month> <year> 1990. </year>
Reference-contexts: Event-based behavioral abstraction provides a mechanism to handle the volume of data by allowing users to specify the program behavior in a hierarchical fashion, which is then compared with the actual execution <ref> [2, 3, 14, 16] </ref>. Transformations of logical time helps to filter out the perturbations of physical asynchrony, and allow the user to examine the program behavior from different temporal perspectives [14, 19, 6]. <p> This matching can be done efficiently, avoiding the costliness of pattern matching approaches [3, 13] and the expensive implementations of previous languages <ref> [16] </ref>. At the same time, our matching algorithm can provide precise information on the reasons for a match failure. 2.2 Logical Time Manipulation in Ariadne Programmers are often confused by the results of asynchronous executions because they can not foresee all possible interleavings of events. <p> Similar extensions have been proposed <ref> [8, 16, 18] </ref> but we have found our definitions to be more appropriate for debugging.
Reference: [17] <author> L. Lamport. </author> <title> Time, clocks, and the ordering of events in a distributed system. </title> <journal> Communications of the ACM, </journal> <volume> 21(7) </volume> <pages> 558-565, </pages> <year> 1978. </year>
Reference-contexts: Reads, Writes, and Multicasts denote interprocess communication, and Phase Markers denote the ends of logical phases of computation. The traces are stored internally in an execution history graph where the nodes represent events and the edges represent communication events; from these traces we can derive Lamport's happened before relation <ref> [17] </ref>. A number of debuggers provide visualizations of execution history graphs [9, 11, 12, 21] but such visualizations do not scale well for massively parallel systems. Ave/Ariadne supports interactive, textual and graphical explorations of the graph.
Reference: [18] <author> L. Lamport. </author> <title> The mutual exclusion problem: Part I-A theory of interprocess communication. </title> <journal> Journal of the Association for Computing Machinery, </journal> <volume> 33(2) </volume> <pages> 313-326, </pages> <month> April </month> <year> 1986. </year>
Reference-contexts: Similar extensions have been proposed <ref> [8, 16, 18] </ref> but we have found our definitions to be more appropriate for debugging.
Reference: [19] <author> R. J. LeBlanc and A. D. Robbins. </author> <title> Event-driven monitoring of distributed programs. </title> <booktitle> In Proceedings of the 5th International Conference on Distributed Computing Systems, </booktitle> <pages> pages 515-522, </pages> <year> 1985. </year>
Reference-contexts: Transformations of logical time helps to filter out the perturbations of physical asynchrony, and allow the user to examine the program behavior from different temporal perspectives <ref> [14, 19, 6] </ref>. Many systems try to attack the problem of comprehending large amount of data, by providing the user with an animation system [14, ?, ?].
Reference: [20] <author> T. J. LeBlanc and J. M. Mellor-Crummey. </author> <title> Debugging parallel programs with instant replay. </title> <journal> IEEE Transactions on Computers, </journal> <volume> C-36(4):471-482, </volume> <month> Apr. </month> <year> 1987. </year>
Reference: [21] <author> T. J. LeBlanc, J. M. Mellor-Crummey, and R. J. Fowler. </author> <title> Analyzing parallel program executions using multiple views. </title> <journal> Journal of Parallel and Distributed Computing, </journal> <volume> 9 </volume> <pages> 203-217, </pages> <year> 1990. </year>
Reference-contexts: The traces are stored internally in an execution history graph where the nodes represent events and the edges represent communication events; from these traces we can derive Lamport's happened before relation [17]. A number of debuggers provide visualizations of execution history graphs <ref> [9, 11, 12, 21] </ref> but such visualizations do not scale well for massively parallel systems. Ave/Ariadne supports interactive, textual and graphical explorations of the graph.
Reference: [22] <author> V. M. Lo, S. Rajopadhye, M. A. Mohamed, S. Gupta, B. Nitzberg, J. A. Telle, X. X. Zhong. LaRCS: </author> <title> A language for describing parallel computations for the purpose of mapping. </title> <type> Technical Report CIS-TR-90-16, </type> <institution> University of Oregon Dept. of Computer Science, </institution> <year> 1990. </year>
Reference-contexts: These three definitional levels appear to form a natural mechanism for describing parallel systems, as evidenced by their use in other contexts such as the XYZ levels of Phase Abstractions [24] and the LaRCS specification language <ref> [22] </ref>. The matching algorithm for our language is straightforward: a pt-chain is recognized by a finite state machine that invokes copies of other finite state machines to recognize chains on specific processes.
Reference: [23] <author> B. Miller and J.-D. Choi. </author> <title> A mechanism for efficient debugging of parallel programs. </title> <journal> SIGPLAN Notices, </journal> <volume> 24(1), </volume> <pages> pages 141-150, </pages> <year> 1989. </year>
Reference: [24] <author> L. Snyder. </author> <title> The XYZ abstraction levels of Poker-like languages. Languages and Compilers for Parallel Computing, </title> <editor> David Gelernter and Alexandru Nicolau and David Padua(eds.), </editor> <publisher> MIT Press, </publisher> <pages> pages 470-489, </pages> <year> 1990. </year>
Reference-contexts: These three definitional levels appear to form a natural mechanism for describing parallel systems, as evidenced by their use in other contexts such as the XYZ levels of Phase Abstractions <ref> [24] </ref> and the LaRCS specification language [22]. The matching algorithm for our language is straightforward: a pt-chain is recognized by a finite state machine that invokes copies of other finite state machines to recognize chains on specific processes.
References-found: 24

