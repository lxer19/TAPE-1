URL: http://www.cs.wustl.edu/~schmidt/CORBA-docs/implementing-persistence.ps.gz
Refering-URL: http://www.cs.wustl.edu/~schmidt/corba-papers.html
Root-URL: 
Phone: 118 00  
Title: Implementing Corba Persitence Service  
Author: Jan Kleindienst, Franti*ek Pl*il, Petr Tuma 
Address: Malostransk nm. 25  
Affiliation: Department of Software Engineering  
Date: 117 December 1995  
Note: Nov 24, 95A  Charles University Prague  Prague 1 Czech Republic  
Pubnum: Tech.Report No  
Abstract-found: 0
Intro-found: 1
Reference: [AJJ+ 92] <author> P. Amaral, C. Jacquemot, P. Jensen, R. Lea, and A. Mirowski: </author> <title> Transparent object migration in COOL-2. </title> <type> Technical report, </type> <institution> Chorus Systemes and Universite Pierre et Marie Curie, </institution> <year> 1992. </year>
Reference: [AJL92] <author> P. Amaral, C. Jacquemot, and R. Lea: </author> <title> A model for persistent shared memory addressing in distributed systems. </title> <type> Technical report, </type> <institution> Chorus systemes, </institution> <year> 1992. </year>
Reference-contexts: Persistent Service. 2 Persistence: design issues in general 2.1 The key concepts and implementation issues The concept of persistence has been specified and studied by many researchers; we refer the reader to books [Tan95, Mul94, CDK94], the proceeding of the dedicated workshop referenced in [SKW92, DdBF+92], and other publications, e.g. <ref> [SF94, AJL92, BM92, CBHS93] </ref>. In this paper, we will limit ourselves to persistence of objects in the CORBA environment. <p> In Orbix, this can be achieved by employing the filter concept [ORBIXa, ORBIXb]. c) True persistent virtual memory is employed; the state of an object saved in such memory is implicitly persistent and is up-to-date at all times <ref> [AJL92, HKPCS95] </ref>. 2.6 What is to be saved In addition to the issue of when to update the persistent state (Section 2.1), the question arises of what exactly is to be saved.
Reference: [AK85] <author> D. A. Abramson and J. K. Keedy: </author> <title> Implementing a large virtual memory in a distributed computing system. </title> <booktitle> In Proceedings of the 18th Hawaii Int. Conference on System Sciences, </booktitle> <pages> pages 515-522, </pages> <year> 1985. </year>
Reference: [ALJ92] <author> P. Amaral, R. Lea, and C. Jacquemot: </author> <title> Implementing a modular object oriented operating system on top of CHORUS. </title> <type> Technical report, </type> <institution> Chorus Systemes, </institution> <year> 1992. </year>
Reference-contexts: To implement saving of dependencies, the following techniques are used: a) The current status of relations among objects is not evaluated; dependencies are saved implicitly by defining groups of object; such a group must be closed with respect to inter-object relations. As examples see clusters in COOL <ref> [HMA90, AJJ+92, ALJ92] </ref> or groups in SOM [IBM93a, IBM93b]. Dec 5,95 b) Full persistent state is saved with explicit evaluation of dependencies. This can be either application controlled (explicit) or system controlled (based on hardware-supported reference identification).
Reference: [ANS94] <author> American National Standards Institute ANSI: </author> <title> Basic Reference Model of Open Distributed Processing-Part 3: A Perspective Model, </title> <year> 1994. </year>
Reference: [BM92] <author> A. L. Brown and R. Morrison. </author> <title> A Generic Persistent Object Store. </title> <journal> Software Engineering Journal, </journal> <pages> 7(2) pp. 161-168, </pages> <year> 1992. </year>
Reference-contexts: Persistent Service. 2 Persistence: design issues in general 2.1 The key concepts and implementation issues The concept of persistence has been specified and studied by many researchers; we refer the reader to books [Tan95, Mul94, CDK94], the proceeding of the dedicated workshop referenced in [SKW92, DdBF+92], and other publications, e.g. <ref> [SF94, AJL92, BM92, CBHS93] </ref>. In this paper, we will limit ourselves to persistence of objects in the CORBA environment.
Reference: [Bou94] <author> F. </author> <title> Bourdon: The Automatic Positioning of Objects in COOL V2. </title> <type> Technical report, </type> <institution> Service d`Etudes communes des Postes et Telecommunications, </institution> <year> 1994. </year>
Reference: [CBHS93] <author> V. Cahill, S. Baker, C. Horn, and G. Starovic: </author> <title> The Amadeus GRT Generic Runtime Support for Distributed Persistent Programming. </title> <booktitle> Proceedings of OOPSLA-93, </booktitle> <pages> pages 144-161, </pages> <year> 1993. </year>
Reference-contexts: Persistent Service. 2 Persistence: design issues in general 2.1 The key concepts and implementation issues The concept of persistence has been specified and studied by many researchers; we refer the reader to books [Tan95, Mul94, CDK94], the proceeding of the dedicated workshop referenced in [SKW92, DdBF+92], and other publications, e.g. <ref> [SF94, AJL92, BM92, CBHS93] </ref>. In this paper, we will limit ourselves to persistence of objects in the CORBA environment.
Reference: [CDK94] <author> G. Coulouris, J. Dollimore, and T. Kindberg: </author> <title> Distributed Systems Concepts and Design. </title> <publisher> Addison-Wesley, </publisher> <address> second edition, </address> <year> 1994. </year>
Reference-contexts: trade-offs, and particularly while analyzing the option of reusing other Object Services in an implementation of the Persistent Service. 2 Persistence: design issues in general 2.1 The key concepts and implementation issues The concept of persistence has been specified and studied by many researchers; we refer the reader to books <ref> [Tan95, Mul94, CDK94] </ref>, the proceeding of the dedicated workshop referenced in [SKW92, DdBF+92], and other publications, e.g. [SF94, AJL92, BM92, CBHS93]. In this paper, we will limit ourselves to persistence of objects in the CORBA environment.
Reference: [Cor95] <author> Oracle Corporation: </author> <title> Object Query Service OMG 95-1-3. </title> <year> 1995. </year>
Reference: [CP89] <author> D. E. Comer and L. L. Peterson: </author> <title> Understanding Naming in Distributed Systems. </title> <journal> Distributed Computing, </journal> <volume> 3(2), </volume> <year> 1989. </year>
Reference: [dA93] <author> P. Amaral: PAS: </author> <title> A Framework for studying the implementation of multiple address spaces. </title> <type> PhD thesis, </type> <institution> Universite Pierre et Marie Curie - Paris, </institution> <year> 1993. </year>
Reference: [DdBF+92] <author> A. Dearle, R. di Bona, J. Farrow, F. Henskens, A. Lindstrom, J. Rosenberg, and F. Vaughan: Grasshopper: </author> <title> An orthogonally Persistent Operating System. </title> <booktitle> Computer Systems, </booktitle> <pages> 7(3) pp. 289-312, </pages> <year> 1992. </year>
Reference-contexts: Services in an implementation of the Persistent Service. 2 Persistence: design issues in general 2.1 The key concepts and implementation issues The concept of persistence has been specified and studied by many researchers; we refer the reader to books [Tan95, Mul94, CDK94], the proceeding of the dedicated workshop referenced in <ref> [SKW92, DdBF+92] </ref>, and other publications, e.g. [SF94, AJL92, BM92, CBHS93]. In this paper, we will limit ourselves to persistence of objects in the CORBA environment.
Reference: [DOM93] <institution> DOME User Guide, Object-Oriented Technologies Ltd., </institution> <year> 1993. </year>
Reference-contexts: In 1991, OMG defined an industry standard called the Common Object Request Broker Architecture (CORBA), based upon a concrete object model derived from the OMA abstract object model. Among the CORBA-compliant systems (CORBA implementations) currently available from different vendors are e.g. Orbix [ORBIXa, ORBIXb], SOM [IBM93a, IBM93b], and DOME <ref> [DOM93] </ref>. The first version of the CORBA standard specification, CORBA 1.2 [OMG92], comprises many components together providing a foundation for performing transparent remote request calls from the requestors of services (clients or client applications) to the providers of services (servers).
Reference: [DRH+ 92] <author> A. Dearle, J. Rosenbergr, F. Henkens, F. Vaughan, and K. Maciunas: </author> <title> An Examination of Operating System Support for Persistent Object System. </title> <booktitle> In 25th Hawaii International Conference on System Services, </booktitle> <volume> volume 1, </volume> <pages> pages 779-789. </pages> <publisher> IEEE Computer Society Press, </publisher> <year> 1992. </year> <month> Dec 5,95 19 </month>
Reference: [Ede92] <author> D. R. Edelson: </author> <title> Smart Pointers: They're Smart but They're Not Pointers. </title> <institution> UCSC-CRL-92-97, Baskin Center for Computer Engineering & Information Sciences, University of California, Santa Cruz, </institution> <year> 1992. </year>
Reference: [Fra95] <institution> Framingham Corporate Center: Object Services RFP 5. OMG 95-3-25, </institution> <year> 1995. </year>
Reference: [FS94a] <author> P. Fereira and M. Shapiro: </author> <title> Garbage Collection and DSM Consistency. </title> <type> Technical report, </type> <institution> INRIA, </institution> <year> 1994. </year>
Reference: [FS94b] <author> P. Ferreira and M. Shapiro: </author> <title> Garbage Collection of Persistent Objects in Distributed Shared Memory. </title> <type> Technical report, </type> <institution> INRIA, </institution> <year> 1994. </year>
Reference: [HCF+ 95] <author> D. Haginont, P. Y. Chevalier, A. Freyssinet, S. Krakowiak, S. Lacourte, J. Mossiere, and X. R. de Pina: </author> <title> Persistent Shared Object Support in the Guide System Evaluation and Related Work. </title> <type> Technical report, </type> <institution> Bull-IMAG/Systems, </institution> <year> 1995. </year>
Reference: [HK93] <author> G. Hamilton and P. Kougiouris: </author> <title> The Spring nucleus: A microkernel for objects. </title> <booktitle> In Proceedings of the 1993 Summer Usenix Conference, </booktitle> <month> June </month> <year> 1993. </year>
Reference: [HKPCS95] <author> J. Hans, A. Knaff, E. Perez-Cotes, and F. Saunier: Arias: </author> <title> Generic Support for Persistent Runtimes. </title> <type> Technical report, </type> <institution> Bull-IMAG/Systems, </institution> <year> 1995. </year>
Reference-contexts: In Orbix, this can be achieved by employing the filter concept [ORBIXa, ORBIXb]. c) True persistent virtual memory is employed; the state of an object saved in such memory is implicitly persistent and is up-to-date at all times <ref> [AJL92, HKPCS95] </ref>. 2.6 What is to be saved In addition to the issue of when to update the persistent state (Section 2.1), the question arises of what exactly is to be saved.
Reference: [HMA90] <author> S. Habert, L. Mosseri, and V. Abrossimov: </author> <title> COOL: A Kernel Support for Object-Oriented Environments. </title> <type> Technical report, </type> <institution> INRIA and Chorus Systemes, </institution> <year> 1990. </year>
Reference-contexts: To implement saving of dependencies, the following techniques are used: a) The current status of relations among objects is not evaluated; dependencies are saved implicitly by defining groups of object; such a group must be closed with respect to inter-object relations. As examples see clusters in COOL <ref> [HMA90, AJJ+92, ALJ92] </ref> or groups in SOM [IBM93a, IBM93b]. Dec 5,95 b) Full persistent state is saved with explicit evaluation of dependencies. This can be either application controlled (explicit) or system controlled (based on hardware-supported reference identification).
Reference: [HRH95] <author> M. Hollins, J. Rosenberg, and M. Hitchens: </author> <title> Breaking the Information Hiding Barrier. </title> <type> Technical report, </type> <institution> University of Sydney and University of Western Sydney and Australia, </institution> <year> 1995. </year>
Reference: [IBM93a] <author> IBM Corp. </author> <title> SOMobjects Developer Toolkit Collection Classes Reference Manual, </title> <year> 1993. </year>
Reference-contexts: In 1991, OMG defined an industry standard called the Common Object Request Broker Architecture (CORBA), based upon a concrete object model derived from the OMA abstract object model. Among the CORBA-compliant systems (CORBA implementations) currently available from different vendors are e.g. Orbix [ORBIXa, ORBIXb], SOM <ref> [IBM93a, IBM93b] </ref>, and DOME [DOM93]. The first version of the CORBA standard specification, CORBA 1.2 [OMG92], comprises many components together providing a foundation for performing transparent remote request calls from the requestors of services (clients or client applications) to the providers of services (servers). <p> As examples see clusters in COOL [HMA90, AJJ+92, ALJ92] or groups in SOM <ref> [IBM93a, IBM93b] </ref>. Dec 5,95 b) Full persistent state is saved with explicit evaluation of dependencies. This can be either application controlled (explicit) or system controlled (based on hardware-supported reference identification).
Reference: [IBM93b] <institution> IBM Corp. </institution> <note> SOMobjects Developer Toolkit Programmers Reference Manual Version 2.0, </note> <year> 1993. </year>
Reference-contexts: In 1991, OMG defined an industry standard called the Common Object Request Broker Architecture (CORBA), based upon a concrete object model derived from the OMA abstract object model. Among the CORBA-compliant systems (CORBA implementations) currently available from different vendors are e.g. Orbix [ORBIXa, ORBIXb], SOM <ref> [IBM93a, IBM93b] </ref>, and DOME [DOM93]. The first version of the CORBA standard specification, CORBA 1.2 [OMG92], comprises many components together providing a foundation for performing transparent remote request calls from the requestors of services (clients or client applications) to the providers of services (servers). <p> As examples see clusters in COOL [HMA90, AJJ+92, ALJ92] or groups in SOM <ref> [IBM93a, IBM93b] </ref>. Dec 5,95 b) Full persistent state is saved with explicit evaluation of dependencies. This can be either application controlled (explicit) or system controlled (based on hardware-supported reference identification).
Reference: [KB92] <author> J. K. Keedy and P. Broessler: </author> <title> Implementing Databases in the MONADS Virtual Memory. </title> <booktitle> In Proceedings of the Fifth International Workshop on Persistent Object Systems, Springer Workshops in Computing series, </booktitle> <address> San Miniato (Pisa) Italy, </address> <year> 1992. </year>
Reference: [KN93a] <author> Y. A. Khalidi and M. N. Nelson: </author> <title> A Flexible External Paging Interface. </title> <booktitle> In Proceedings of the Usenix conference on microkernels and other architectures, </booktitle> <month> September </month> <year> 1993. </year>
Reference: [KN93b] <author> Y. A. Khalidi and M. N. Nelson: </author> <title> The Spring Virtual Memory System. </title> <type> Technical Report SMLI-93-9, </type> <institution> Sun Microsystems, </institution> <year> 1993. </year>
Reference: [KR89] <author> J. L. Keedy and J. Rosenberger: </author> <title> Support for objects in the MONADS architecture. </title> <booktitle> In Proceedings of the Int. Workshop on Persistent Systems, </booktitle> <pages> pages 202-213, </pages> <year> 1989. </year> <month> Dec 5,95 20 </month>
Reference: [LXC93] <author> S. B. Lim, L. Xao, and R. Campbell: </author> <title> Distributed Access to Persistent Objects. </title> <type> Technical report, </type> <institution> University of Illinois at Urbana Champain, Department of Computer Science, </institution> <year> 1993. </year>
Reference: [MA90] <author> R. Morrison, M. P. Atkinson: </author> <title> Persistent Languages and Architectures. In Security and Persistence, </title> <editor> J. Rosenberg and J. L. Keedy(ed.), </editor> <publisher> Springer, </publisher> <pages> pages 9-28, </pages> <year> 1990 </year>
Reference-contexts: which have been statically preselected [Mey88], e.g. by inheriting from the persistent object base class.. 2.2.3 Dynamically This highly desirable approach, which is implicitly suggested by the CORBA specification of persistent service [OMG94b] (Section 3.1), allows the user to decide dynamically on the persistent property of all objects (orthogonal persistence <ref> [MA90] </ref>).
Reference: [Mey88] <author> B. Meyer: </author> <title> Object-Oriented Software Abstraction, </title> <publisher> Prentice Hall, </publisher> <year> 1988 </year>
Reference-contexts: This provides the user with the runtime ability to decide about an object's persistence. Yet this control is limited to those classes of objects which have been statically preselected <ref> [Mey88] </ref>, e.g. by inheriting from the persistent object base class.. 2.2.3 Dynamically This highly desirable approach, which is implicitly suggested by the CORBA specification of persistent service [OMG94b] (Section 3.1), allows the user to decide dynamically on the persistent property of all objects (orthogonal persistence [MA90]).
Reference: [MCCK94] <author> R. Morrison, R. C. H. Connor, Q. J Cutts, and G. N. C. Kirby: </author> <title> Persistent Possibilities for Software Environments. </title> <publisher> IEEE Computer Society Press, </publisher> <pages> pages 78-87, </pages> <year> 1994. </year>
Reference: [MGH+ 94] <author> J. G. Mitchell, J. J. Gibbons, G. Hamilton, P. B. Kessler, Y. A. Khalidi, P. Kougiouris, P. W. Madany, M. N. Nelson, M. L. Powell, and S. R. Radia: </author> <title> An Overview of the Spring System. </title> <booktitle> In Proceedings of Compcon Spring 1994. IEEE, </booktitle> <month> February </month> <year> 1994. </year>
Reference: [MGNS91] <author> M. Makpangou, Y. Gourhant, J. P. Le Narzul, and M. Shapiro: </author> <title> Fragmented Objects for Distributed Abstraction. </title> <type> Technical report, </type> <institution> INRIA, </institution> <year> 1991. </year>
Reference: [Mul94] <author> S. Mullender, </author> <title> editor: Distributed Systems. </title> <publisher> Addison-Wesley, </publisher> <address> second edition, </address> <year> 1994. </year>
Reference-contexts: trade-offs, and particularly while analyzing the option of reusing other Object Services in an implementation of the Persistent Service. 2 Persistence: design issues in general 2.1 The key concepts and implementation issues The concept of persistence has been specified and studied by many researchers; we refer the reader to books <ref> [Tan95, Mul94, CDK94] </ref>, the proceeding of the dedicated workshop referenced in [SKW92, DdBF+92], and other publications, e.g. [SF94, AJL92, BM92, CBHS93]. In this paper, we will limit ourselves to persistence of objects in the CORBA environment.
Reference: [OMGa] <institution> Common Object Model Specification, </institution> <note> Draft version 0.2, OMG 94-10-9, </note> <year> 1994. </year>
Reference: [OMG90] <institution> Object Management Architecture Guide 1.0, OMG 90-9-1, </institution> <year> 1990 </year>
Reference-contexts: 1 Introduction 1.1 CORBA and TOCOOS Around 1990, the Object Management Group (OMG) introduced the Objects Management Architecture for distributed systems <ref> [OMG90] </ref>, which defines abstract object model. In 1991, OMG defined an industry standard called the Common Object Request Broker Architecture (CORBA), based upon a concrete object model derived from the OMA abstract object model. Among the CORBA-compliant systems (CORBA implementations) currently available from different vendors are e.g.
Reference: [OMG91] <institution> Draft Common Object Request Broker Architecture Revision, OMG 91-1-1, </institution> <year> 1991. </year>
Reference-contexts: In principle, a request requires an operation to be executed upon an object (target or server object) provided by a server. The functionality of server objects is specified via the Interface Description Language (IDL) defined in <ref> [OMG91] </ref>; in addition, mapping of IDL into frequently used high level programming languages such as C an C++ is specified [OMG91, OMG93]. <p> The functionality of server objects is specified via the Interface Description Language (IDL) defined in [OMG91]; in addition, mapping of IDL into frequently used high level programming languages such as C an C++ is specified <ref> [OMG91, OMG93] </ref>.
Reference: [OMG92] <institution> Object Service Architecture, OMG 92-8-4, </institution> <year> 1992. </year>
Reference-contexts: Among the CORBA-compliant systems (CORBA implementations) currently available from different vendors are e.g. Orbix [ORBIXa, ORBIXb], SOM [IBM93a, IBM93b], and DOME [DOM93]. The first version of the CORBA standard specification, CORBA 1.2 <ref> [OMG92] </ref>, comprises many components together providing a foundation for performing transparent remote request calls from the requestors of services (clients or client applications) to the providers of services (servers). In principle, a request requires an operation to be executed upon an object (target or server object) provided by a server. <p> The CORBA 1.2 standard also proposes a collection of Object Services <ref> [OMG92] </ref>, that facilitate CORBA supported objects with additional functionality such as creating and deleting new objects (Lifecycle Service), looking up a server with a specific interface in another CORBA environments (Trading Service), or managing persistent objects (Persistent Service).
Reference: [OMG92a] <author> Kala-Standardizing on Object Meta Services, </author> <title> Brief Response to the OMG services, Request for Information, </title> <booktitle> OMG 92-4-5, </booktitle> <year> 1992. </year>
Reference: [OMG93] <institution> IDL C++ Language Mapping Proposal, OMG 93-4-4, </institution> <year> 1993. </year>
Reference-contexts: The functionality of server objects is specified via the Interface Description Language (IDL) defined in [OMG91]; in addition, mapping of IDL into frequently used high level programming languages such as C an C++ is specified <ref> [OMG91, OMG93] </ref>.
Reference: [OMG94a] <institution> Common Object Services Volume I, OMG 94-1-1, </institution> <year> 1994. </year>
Reference-contexts: a server object to be used as an ordinary object (by generating an access to a stub or a proxy in the client application); basically, the abstraction provided by accessing a server object via a stub (proxy), both specified by the same IDL interface, is referred to as CORBA object <ref> [OMG94a] </ref>. The CORBA 1.2 standard also proposes a collection of Object Services [OMG92], that facilitate CORBA supported objects with additional functionality such as creating and deleting new objects (Lifecycle Service), looking up a server with a specific interface in another CORBA environments (Trading Service), or managing persistent objects (Persistent Service). <p> The functionality of an object service is specified as a set of interfaces specified in IDL, e.g. <ref> [OMG94a, OMG94b] </ref>. Typically, an object service is used by inheriting from the set of IDL interfaces specifying the object service. It might be the case, that a particular service requested from a client is not available in the CORBA implementation the client is running on. <p> The rewind and load methods are used to retrieve the data in a similar manner. As described in [OMG94b], PID instances are created by an appropriate factory (once created, the PID remains valid until a PID::remove call is issued <ref> [OMG94a] </ref>): interface PIDFactory - PID get_root_PID ( ) raises (Internal); PID create_unique_PID ( ) raises (Internal, StoreIsFull); -; As the persistent IDs are being devised by the store itself, an extra care needs to be taken to provide the client with means of obtaining the store contents.
Reference: [OMG94b] <institution> Persistent Object Service Specification, OMG 94-10-7, </institution> <year> 1994. </year>
Reference-contexts: The functionality of an object service is specified as a set of interfaces specified in IDL, e.g. <ref> [OMG94a, OMG94b] </ref>. Typically, an object service is used by inheriting from the set of IDL interfaces specifying the object service. It might be the case, that a particular service requested from a client is not available in the CORBA implementation the client is running on. <p> Yet this control is limited to those classes of objects which have been statically preselected [Mey88], e.g. by inheriting from the persistent object base class.. 2.2.3 Dynamically This highly desirable approach, which is implicitly suggested by the CORBA specification of persistent service <ref> [OMG94b] </ref> (Section 3.1), allows the user to decide dynamically on the persistent property of all objects (orthogonal persistence [MA90]). <p> This can be either application controlled (explicit) or system controlled (based on hardware-supported reference identification). In the later case, the techniques of early or late pointer swizzling are typically used [SKW92, VD92]. 3 Persistence: the OMG approach 3.1 What OMG defines The Persistent Service is specified in <ref> [OMG94b] </ref>, in which the IDL specification of three basic interfaces are provided: Persistent Object (PO), Persistent Object Manager (POM), and Persistent Data Service (PDS). Fundamentally, these interfaces comprise the same methods: connect (), disconnect (), store (), restore (), and delete (). PDS supports a collection of pairs &lt;Datastore, Protocol&gt;. <p> PDS supports a collection of pairs &lt;Datastore, Protocol&gt;. Datastore actually ensures saving and loading of the PO's data. Each Datastore object is identified (localized) by the pair &lt;datastore_type, datastore_type_instance_id&gt;. Protocol describes the way PDS transfers data into and from the PO. Both Datastore and Protocol are not standardized; however, <ref> [OMG94b] </ref> offers three examples of Protocol and a specification of Datastore_CLI, which might be used as "a uniform interface for accessing many different Datastores". Generally speaking, PDS communicates with the PO through a Protocol, and with the datastore via either Datastore_CLI or a proprietary (not defined by OMG) Datastore interface. <p> support (implementation: POM keeps this information either in a configuration file, or registry, or via a dedicated interface), and b) given a PO, POM knows which Protocol the PO supports (implementation: the supported Protocol is deduced for example from the PO type), the POM resolves PDS in the following steps <ref> [OMG94b] </ref>: 1. get the datastore_type and datastore_type_instance_id from the PO's PID 2. get Protocol supported by the PO 3. localize a Datastore object using the pair &lt;datastore_type , datastore_type_instance_id&gt; 4. determine PDS given the pair &lt;Datastore, Protocol&gt; Dec 5,95 3.2 Integrating with other services The specification of the Persistent Service [OMG94b] <p> <ref> [OMG94b] </ref>: 1. get the datastore_type and datastore_type_instance_id from the PO's PID 2. get Protocol supported by the PO 3. localize a Datastore object using the pair &lt;datastore_type , datastore_type_instance_id&gt; 4. determine PDS given the pair &lt;Datastore, Protocol&gt; Dec 5,95 3.2 Integrating with other services The specification of the Persistent Service [OMG94b] discusses the integration of the Persistence Service with other Object Services. The discussion separates the services that potentially may use Persistence Service, such as Backup/Restore Service or Replication Service, and the services that may be used by the Persistent Service, such as Externalization Service or Relationship Service. <p> The Persistent Object Part uses the underlying Typed Data Part to save the contents of individual persistent objects. The Persistent Service Part coordinates the previous two parts to provide the client with a simple-to-use Persistent Service interface (POM and, potentially, PO) . specification <ref> [OMG94b] </ref>. <p> The module consists of four interfaces. The first two interfaces, called PID and PIDFactory, introduce the notion of a unique persistent identifier, as defined in <ref> [OMG94b] </ref>. <p> Rewriting a location erases any previously saved data and prepares it to be filled with subsequent save calls. The rewind and load methods are used to retrieve the data in a similar manner. As described in <ref> [OMG94b] </ref>, PID instances are created by an appropriate factory (once created, the PID remains valid until a PID::remove call is issued [OMG94a]): interface PIDFactory - PID get_root_PID ( ) raises (Internal); PID create_unique_PID ( ) raises (Internal, StoreIsFull); -; As the persistent IDs are being devised by the store itself, an <p> As the only entity authorized to access the persistent object's internal state is the object itself, the services of this module are exported in a form of methods provided by each persistent object (2.4). Using the terms introduced in <ref> [OMG94b] </ref>, this is a part of the proprietary protocol. <p> In practice, the generic factory interface is more convenient for the purpose of obtaining specific object instances if it is extended by a support for registering specific object factories. 4.5 Persistent Service Part This part incorporates both the Persistent Data Service and the Persistent Object Manager; both specified in <ref> [OMG94b] </ref>. According to the OMG specification, the main role of the Persistent Object Manager is to dispatch a function call to the appropriate Persistent Data Service. Since we have only one Persistent Data Service instance, the interface of the Persistent Object Manager simply passes all requests through to the instance. <p> It exports the following specialized version of the Persistent Data Service CosPersistencePDS::PDS interface <ref> [OMG94b] </ref>: module PersistenceManagement - interface PDS - PDS connect (in POProtocol object, in PID pid); void disconnect (in POProtocol object, in PID pid); void store (in POProtocol object, in PID pid); void restore (in POProtocol object, in PID pid); void delete (in POProtocol object, in PID pid); -; As defined in <p> module PersistenceManagement - interface PDS - PDS connect (in POProtocol object, in PID pid); void disconnect (in POProtocol object, in PID pid); void store (in POProtocol object, in PID pid); void restore (in POProtocol object, in PID pid); void delete (in POProtocol object, in PID pid); -; As defined in <ref> [OMG94b] </ref>, the connect, resp. disconnect, method turns on, resp. off, the automatic updating of the object's persistent state image in the datastore. In our implementation environment, the persistent data service has no way of detecting the moments when an object is modified. <p> Dec 5,95 5 Discussing reuse of other Object Services in Persistent Service 5.1 The other Object Services which potentially could support persistence The specification of Persistent Service <ref> [OMG94b] </ref> discusses very briefly reuse of other Object Services, particularly Relationship Service, Externalization Service, Trading Services, Lifecycle Services. <p> On the other hand, the only reference to the Externalization Service in the Persistent Service specification <ref> [OMG94b, Section 6.17] </ref> reads: "... the Persistent Service could use this service as a POS protocol".
Reference: [OMG94c] <institution> Comparsion of the OMG and ISO-FCCITT Object Models, OMG 94-12-30, </institution> <year> 1994. </year>
Reference: [OMG94d] <editor> Universal Networked Objects, ORB 2.0 RFP Submission, OMG 94-9-32, </editor> <year> 1994. </year>
Reference-contexts: It might be the case, that a particular service requested from a client is not available in the CORBA implementation the client is running on. However, it might be available in another CORBA implementation produced by a different vendor. Generally, the request format is vendor-dependent. The CORBA 2.0 standard <ref> [OMG94d] </ref> specifies the ways of interconnecting different CORBAs either by transforming requests in a bridge/gateway or by transporting requests in the standardized Internet Inter-ORB Protocol (IIOP).
Reference: [OMG94e] <institution> Relationship Service Specification, Joint Object Services Submission, OMG 94-5-5, </institution> <year> 1994. </year>
Reference-contexts: Apart from this, our additional goal is to analyze the prospects of reusing other Object Services, namely the Relationship Service (expressing relations among CORBA objects, <ref> [OMG94e] </ref>) and the Externalization Service (save/load CORBA object to/from a stream, [OMG94g]), in an implementation of the Persistent Service. <p> On the other hand, the transitive closure of dependencies based on r-objects can be built by using the standard traversal mechanism offered by the Relationship Service. To preserve the flexibility of defining subgraphs dynamically at the runtime, the traversal process should use the user-defined traversal criteria object (Section 5.2.1, <ref> [OMG94e] </ref>). In order to meet the minimum requirements of the Persistent service (dependencies, transitive closure of dependencies) the Relationship Service implementation needs to fulfill at least the service levels 1 and 2 as defined in [OMG94e]. <p> at the runtime, the traversal process should use the user-defined traversal criteria object (Section 5.2.1, <ref> [OMG94e] </ref>). In order to meet the minimum requirements of the Persistent service (dependencies, transitive closure of dependencies) the Relationship Service implementation needs to fulfill at least the service levels 1 and 2 as defined in [OMG94e]. In a general case, the two reference types can coexist in transitive closure of an object's dependencies; this even allows more subgraphs defined by different traversal criteria objects to participate in one transitive closure. Thus, a Persistence Service implementation has to respect this flexibility in defining subgraphs. <p> This fact is implied by the option to determine a subgraph using TraversalCriteria. Consequently, to save r-objects, a special technique is necessary. Given a TraversalCriteria object and a root node, the entire subgraph must be traversed to determine its relevant nodes and edges <ref> [OMG94e] </ref>. Only after all the r-objects representing the subgraph are found, saving of the subgraph can take place.
Reference: [OMG94f] <editor> Compound LifeCycle Addendum. </editor> <booktitle> Joint Object Services Submission. OMG 94-5-6, </booktitle> <year> 1994. </year>
Reference: [OMG94g] <institution> Object Externalization Service. OMG 94-9-15, </institution> <year> 1995. </year> <month> Dec 5,95 21 </month>
Reference-contexts: Apart from this, our additional goal is to analyze the prospects of reusing other Object Services, namely the Relationship Service (expressing relations among CORBA objects, [OMG94e]) and the Externalization Service (save/load CORBA object to/from a stream, <ref> [OMG94g] </ref>), in an implementation of the Persistent Service. <p> In our view, the b) technique is the most elegant one, although the Externalization Service <ref> [OMG94g] </ref> uses the technique d). 5.2.4 Advantages of reusing Relationship Service Naturally, the inherent benefit of building Persistent Service upon, among others, the Relationship Service is reusing existing CORBA code. However, the dominant advantage of employing Relationship Service in Persistent Service is the power and flexibility of graph traversing operations. <p> The externalized objects are saved on a media in the canonical form described by <ref> [OMG94g] </ref>; thus the Externalization Service allows for easy transfer of objects between different CORBA architectures. The Externalization Service is based on three interfaces: Stream, StreamIO, and Streamable. <p> In principle, it would be possible to implement a specialized StreamIO interface, such that the Streamable interface could be used to access the persistent state of an object without imposing the limit mentioned above. Although not strictly adherent to the semantics described in <ref> [OMG94g] </ref>, the specialized StreamIO interface implementation could make it possible to reuse the Streamable code in a client application. 5.3.3 Advantages of reusing Externalization Service The Externalization Service provides standardized way of saving data to the stream, resp. datastore.
Reference: [OMG95a] <institution> ODP Trading Function Final Draft, ISO/IEC DIS 13235, OMG 95-7-6, </institution> <year> 1995. </year>
Reference: [OMG95b] <institution> Object Services RFP 5. OMG TC Document 95-3-25, </institution> <year> 1995. </year>
Reference-contexts: Throughout the paper, we show that it is non-trivial to fulfill one of the key design principals proposed by OMG in the Requests For Proposals (e.g. <ref> [OMG95b] </ref>), which Dec 5,95 has been referred to as the Bauhaus principle: "Minimize duplication of functionality. Functionality should belong to the most appropriate service. <p> Thus, a Persistence Service implementation has to respect this flexibility in defining subgraphs. Dec 5,95 In theory, following strictly the Bauhaus principle <ref> [OMG95b] </ref> to achieve maximum Object Service reusability, all inter-object references could be expressed by r-objects only. Even though this would unify the process of searching for transitive closure of dependencies, the overhead inherent to dereferencing only via r-objects could hardly be acceptable (Section 5.2.5).
Reference: [OMK93] <author> D. B. Orr, R. W. Mecklenburg, and R. Kuramkote: Strange Bedfellows: </author> <title> Issues in Object Naming Under Unix. </title> <booktitle> In Proceedings IEEE93, </booktitle> <pages> pages 141-145, </pages> <institution> Department of Computer Science, University of Utah, </institution> <address> Salt Lake City, UT 84112, USA, </address> <year> 1993. </year>
Reference: [ORBIXa] <author> Orbix, </author> <title> Programmer's Guide. </title> <publisher> IONA Technologies Ltd. </publisher> <address> Dublin, </address> <year> 1994 </year>
Reference-contexts: In 1991, OMG defined an industry standard called the Common Object Request Broker Architecture (CORBA), based upon a concrete object model derived from the OMA abstract object model. Among the CORBA-compliant systems (CORBA implementations) currently available from different vendors are e.g. Orbix <ref> [ORBIXa, ORBIXb] </ref>, SOM [IBM93a, IBM93b], and DOME [DOM93]. The first version of the CORBA standard specification, CORBA 1.2 [OMG92], comprises many components together providing a foundation for performing transparent remote request calls from the requestors of services (clients or client applications) to the providers of services (servers). <p> When updating is system controlled, one of the following methods is used: a) Updating is done at system well-defined moments, e.g. when deleting an object, an error/exception is raised, the end of the application is reached, etc. Basically, this approach is used in <ref> [ORBIXa, ORBIXb] </ref>. b) Updating is transaction based; it means that the updating is done at the end of the out-most level transaction. Naturally, this strategy requires the persistence implementation to cooperate with transaction support. In Orbix, this can be achieved by employing the filter concept [ORBIXa, ORBIXb]. c) True persistent virtual <p> this approach is used in <ref> [ORBIXa, ORBIXb] </ref>. b) Updating is transaction based; it means that the updating is done at the end of the out-most level transaction. Naturally, this strategy requires the persistence implementation to cooperate with transaction support. In Orbix, this can be achieved by employing the filter concept [ORBIXa, ORBIXb]. c) True persistent virtual memory is employed; the state of an object saved in such memory is implicitly persistent and is up-to-date at all times [AJL92, HKPCS95]. 2.6 What is to be saved In addition to the issue of when to update the persistent state (Section 2.1), the question
Reference: [ORBIXb] <author> Orbix, </author> <title> Advanced Programmer's Guide. </title> <publisher> IONA Technologies Ltd. </publisher> <address> Dublin, </address> <year> 1994. </year>
Reference-contexts: In 1991, OMG defined an industry standard called the Common Object Request Broker Architecture (CORBA), based upon a concrete object model derived from the OMA abstract object model. Among the CORBA-compliant systems (CORBA implementations) currently available from different vendors are e.g. Orbix <ref> [ORBIXa, ORBIXb] </ref>, SOM [IBM93a, IBM93b], and DOME [DOM93]. The first version of the CORBA standard specification, CORBA 1.2 [OMG92], comprises many components together providing a foundation for performing transparent remote request calls from the requestors of services (clients or client applications) to the providers of services (servers). <p> When updating is system controlled, one of the following methods is used: a) Updating is done at system well-defined moments, e.g. when deleting an object, an error/exception is raised, the end of the application is reached, etc. Basically, this approach is used in <ref> [ORBIXa, ORBIXb] </ref>. b) Updating is transaction based; it means that the updating is done at the end of the out-most level transaction. Naturally, this strategy requires the persistence implementation to cooperate with transaction support. In Orbix, this can be achieved by employing the filter concept [ORBIXa, ORBIXb]. c) True persistent virtual <p> this approach is used in <ref> [ORBIXa, ORBIXb] </ref>. b) Updating is transaction based; it means that the updating is done at the end of the out-most level transaction. Naturally, this strategy requires the persistence implementation to cooperate with transaction support. In Orbix, this can be achieved by employing the filter concept [ORBIXa, ORBIXb]. c) True persistent virtual memory is employed; the state of an object saved in such memory is implicitly persistent and is up-to-date at all times [AJL92, HKPCS95]. 2.6 What is to be saved In addition to the issue of when to update the persistent state (Section 2.1), the question <p> may be predefined; furthermore, the traversal criteria object can be parametrized dynamically at runtime. 5.2.5 Disadvantages of reusing Relationship Service Compared to the standard C++ dereference mechanism, using the Relationship Service may slow down the application considerably, even if local caching of relationship attributes (e.g. via smart proxies in Orbix <ref> [ORBIXb] </ref>) is used. When using the Relationship Service, dereferencing an object pointed to by a relation implies calling the Role::get_other_related_object.
Reference: [PSWL94] <author> G. D. Parrington, S. K. Shrivastava, S. M. Wheater, and M. C. Little: </author> <title> The Design and Implementation of Arjuna. </title> <type> Technical report, </type> <institution> Computing Laboratory, University of Newcastle upon Tyne, </institution> <year> 1994. </year>
Reference: [RHB+ 90] <author> J. Rossenberg, F. Henskens, A. L. Brown, R. Morrison, and D. Munro: </author> <title> Stability in a Persistent Store Based on a Large Virtual Memory. In Security and Persistence, </title> <booktitle> Workshops in Computing, </booktitle> <pages> pages 229-245. </pages> <publisher> Springer-Verlag, </publisher> <year> 1990. </year>
Reference: [SDP92] <author> M. Shapiro, P. Dockman, and D. Plainfosse: </author> <title> SSP Chains: A Robust Distributed References Supporting Acyclic Garbage Collection. </title> <type> Technical report, </type> <institution> INRIA, </institution> <year> 1992. </year>
Reference: [SDP93] <author> S. K. Shrivastava, G. N. Dixon, and G. D. Parrington: </author> <title> An Overview of the Arjuna Distributed Programming System. </title> <type> Technical report, </type> <institution> Computing Laboratory, University of Newcastle upon Tyne, </institution> <year> 1993. </year>
Reference: [SF94] <author> M. Shapiro and P. Ferreira: Larchant-RDOSS: </author> <title> A distributed shared persistent memory and its garbage collector. </title> <type> Technical report, </type> <institution> INRIA, </institution> <year> 1994. </year>
Reference-contexts: Persistent Service. 2 Persistence: design issues in general 2.1 The key concepts and implementation issues The concept of persistence has been specified and studied by many researchers; we refer the reader to books [Tan95, Mul94, CDK94], the proceeding of the dedicated workshop referenced in [SKW92, DdBF+92], and other publications, e.g. <ref> [SF94, AJL92, BM92, CBHS93] </ref>. In this paper, we will limit ourselves to persistence of objects in the CORBA environment.
Reference: [SG91a] <author> S. S. Simmel and I. Godard: </author> <title> The Kala Basket A Semantic Primitive Unifying Object Transactions, Access Control, Versions and Configurations. </title> <booktitle> In OOPSLA, </booktitle> <year> 1991. </year>
Reference: [SG91b] <author> S. S. Simmel and I. Godard: </author> <title> The Kala Basket: A Semantic Primitive Unifying Object Transactions, Access Control, Versions, and Configurations. </title> <booktitle> In OOPLSA'91, </booktitle> <pages> pp. 230-246, </pages> <year> 1991. </year>
Reference: [SGH+ 91] <author> M. Shapiro, Y. Gourhant, S. Habert, L. Mosseri, M. Ruffin, and C. Valot: </author> <title> SOS: An Object-Oriented Operating System Assessment and Perspectives. </title> <type> Technical report, </type> <institution> INRIA, </institution> <year> 1991. </year>
Reference: [SGM89] <author> M. Shapiro, P. Gautron, and L. Mosseri: </author> <title> Persistence and Migration for C++ Objects. </title> <booktitle> In ECOOP'89, </booktitle> <address> Nottingham (GB), </address> <month> July </month> <year> 1989. </year>
Reference: [Sha94a] <author> M. Shapiro: </author> <title> A Binding Protocol for Distributed Shared Objects. </title> <type> Technical report, </type> <institution> INRIA, </institution> <year> 1994. </year>
Reference: [Sha94b] <author> M. Shapiro: </author> <title> Structure and Encapsulation in Distributed Systems: The Proxy Principle. </title> <type> Technical report, </type> <institution> INRIA, </institution> <year> 1994. </year> <month> Dec 5,95 22 </month>
Reference: [Sim92] <author> S. S. Simmel: </author> <title> Providing commonality while supporting diversity. </title> <booktitle> Hotline on Object-Oriented Technology, </booktitle> <volume> 3(10), </volume> <month> August </month> <year> 1992. </year>
Reference: [SKW92] <author> V. Singhal, S. V. Kakkad, and P. R. Wilson: </author> <title> Texas: An Efficient, Portable Persistent Store. </title> <editor> In A. Albano and R. Morrison, editors, </editor> <booktitle> Persistent Object Systems, Workshop In Computing, </booktitle> <pages> pages 11-33. </pages> <publisher> Springer-Verlag, </publisher> <year> 1992. </year>
Reference-contexts: Services in an implementation of the Persistent Service. 2 Persistence: design issues in general 2.1 The key concepts and implementation issues The concept of persistence has been specified and studied by many researchers; we refer the reader to books [Tan95, Mul94, CDK94], the proceeding of the dedicated workshop referenced in <ref> [SKW92, DdBF+92] </ref>, and other publications, e.g. [SF94, AJL92, BM92, CBHS93]. In this paper, we will limit ourselves to persistence of objects in the CORBA environment. <p> Dec 5,95 b) Full persistent state is saved with explicit evaluation of dependencies. This can be either application controlled (explicit) or system controlled (based on hardware-supported reference identification). In the later case, the techniques of early or late pointer swizzling are typically used <ref> [SKW92, VD92] </ref>. 3 Persistence: the OMG approach 3.1 What OMG defines The Persistent Service is specified in [OMG94b], in which the IDL specification of three basic interfaces are provided: Persistent Object (PO), Persistent Object Manager (POM), and Persistent Data Service (PDS).
Reference: [SPFA94] <author> M. Shapiro, D. Plainfosse, P. Ferreira, and L. Amsaleg: </author> <title> Some Key Issues in the Design of Distributed Garbage Collection and References. </title> <type> Technical report, </type> <institution> INRIA, </institution> <year> 1994. </year>
Reference: [Str94] <author> D. Stroustrup: </author> <title> The C++ Programming Language. Second Edition. </title> <publisher> Addison-Wesley, </publisher> <year> 1995. </year>
Reference-contexts: Dec 5,95 transitive closure of dependencies (of a persistent object PO) the set of all objects reachable from PO via references transitively over all nested dependencies; this is an analogy of the "deep copy" concept <ref> [Str94] </ref>. <p> The C++ language <ref> [Str94] </ref> offers no way of retrieving and processing the type information at runtime. Thus, the following code fragment PersistentObject *po = new ("PersistentObject") PersistentObject (); is of the same meaning as the one in a).
Reference: [SUZ95] <author> M. Steinder, A. Uszok, K. Zielinski: </author> <title> A Framework for Inter-ORB Request Level Bridge Construction. </title> <booktitle> Submitted to the ICDP'96 - IFIP/IEEE International Conference on Distributed Platforms, </booktitle> <address> Dresden, Germany, </address> <year> 1996. </year>
Reference: [Tan95] <author> A. S. Tanenbaum: </author> <title> Distributed Operating Systems. </title> <publisher> Prentice Hall, </publisher> <year> 1995. </year>
Reference-contexts: trade-offs, and particularly while analyzing the option of reusing other Object Services in an implementation of the Persistent Service. 2 Persistence: design issues in general 2.1 The key concepts and implementation issues The concept of persistence has been specified and studied by many researchers; we refer the reader to books <ref> [Tan95, Mul94, CDK94] </ref>, the proceeding of the dedicated workshop referenced in [SKW92, DdBF+92], and other publications, e.g. [SF94, AJL92, BM92, CBHS93]. In this paper, we will limit ourselves to persistence of objects in the CORBA environment.
Reference: [VD92] <author> F. Vaugham and A. Dearle: </author> <title> Supporting Large Persistent Stores using Conventional Hardware. </title> <editor> In A. Albano and R. Morrison, editors, </editor> <title> Persistent Object Systems, Persistent Object Systems, </title> <booktitle> Workshop In Computing, </booktitle> <pages> pages 35-53. </pages> <publisher> Springer-Verlag, </publisher> <year> 1992. </year>
Reference-contexts: Dec 5,95 b) Full persistent state is saved with explicit evaluation of dependencies. This can be either application controlled (explicit) or system controlled (based on hardware-supported reference identification). In the later case, the techniques of early or late pointer swizzling are typically used <ref> [SKW92, VD92] </ref>. 3 Persistence: the OMG approach 3.1 What OMG defines The Persistent Service is specified in [OMG94b], in which the IDL specification of three basic interfaces are provided: Persistent Object (PO), Persistent Object Manager (POM), and Persistent Data Service (PDS).
References-found: 73

