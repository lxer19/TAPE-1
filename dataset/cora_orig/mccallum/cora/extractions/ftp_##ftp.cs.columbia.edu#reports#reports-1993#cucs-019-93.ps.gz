URL: ftp://ftp.cs.columbia.edu/reports/reports-1993/cucs-019-93.ps.gz
Refering-URL: http://www.cs.columbia.edu/~library/1993.html
Root-URL: http://www.cs.columbia.edu
Title: A Non-Deterministic Approach to Restructuring Flow Graphs  
Abstract: Toni A. Bunter Technical Report CUCS-019-93 COLUMBIA UNIVERSITY 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Alfred A. Aho, Ravi Sethi, and Jeffrey D. Ullman. </author> <booktitle> Compilers Principles, Techniques and Tools. </booktitle> <publisher> Addison-Wesley Publishing Company, </publisher> <year> 1986. </year>
Reference-contexts: QED. A further outcome of this transformation is that the flow graph is now reducible [5]. The reducibility of a flow graph is important for data-flow equations, which enable data-flow scrutiny for optimization or maintenance purposes <ref> [1] </ref> [13]. Before we describe the non-deterministic part of our method we take a look at the loop-free part of a flow graph. By building equivalent sets of the maximum loops we get a super-structure in which nodes are sets of sequential blocks.
Reference: [2] <author> E. Ashcroft and Z. Manna. </author> <title> The translation of 'goto' programs to 'while' programs. </title> <journal> Inform. </journal> <volume> Proc.71, </volume> <pages> pages 147-152, </pages> <year> 1971. </year>
Reference-contexts: In our own approach the focus will be on the single-entry structure. The single-entry structure allows exiting loops to different nodes (figure 8). In a generic flow graph, a loop is a multiple-entry/multiple-exit structure. This makes it possible to enter a loop at various nodes. According to <ref> [2] </ref>, such a structure is considered harmful. 2 Transformation of Flow Graphs and Source Code Our main concerns in flow graph transformation are control flow graphs with underlying source code. The atomic operation which we apply on the flow graph in our apporach is node splitting [17].
Reference: [3] <author> G. Blaschek, G. Pomberger, and F. Ritzinger. </author> <title> Einfuhrung in die Programmierung mit Modula-2. </title> <publisher> Studienreihe Informatik. Springer-Verlag, </publisher> <year> 1986. </year>
Reference-contexts: They are closely related to the D-structure and can be used in a pre-coding phase with programming languages such as Pascal or MODULA-2 <ref> [3] </ref>. To provide a similar illustration we developed an extended NS diagram for incomplete D-structures.
Reference: [4] <author> C. Bohm and G. Jacopini. </author> <title> Flow diagrams, Turing maschines and languages with only two formation rules. </title> <journal> Communications of the ACM, </journal> <volume> 9(5), </volume> <year> 1966. </year>
Reference-contexts: The two extreme postitions of control flow graphs concerned transformations are (1) the detection of block structure-like patterns and their replacement through loop structures such as while, and braching structures such as if-then-else [10], and (2) the transformation of arbitrary source code into block structures <ref> [4] </ref>. The latter approach introduces additional boolean variables that are necessary to uphold the semantics. Despite the large quantity of varied results, relatively few software maintenance tools are currently in use. One of the main reasons for this is the aforementioned trade-off.
Reference: [5] <author> Toni A. Bunter. </author> <title> Eine Architektur eines Software-Wartungssystems. </title> <type> PhD thesis, </type> <institution> Universitat Zurich, </institution> <year> 1992. </year>
Reference-contexts: The atomic operation which we apply on the flow graph in our apporach is node splitting [17]. In <ref> [5] </ref> we developed a mathematical model for node splitting using the cartesian product and supersets. The fundamental restriction of program transformation is the functional equivalence, which has to be preserved. <p> Theorem 1. Given a generic flow graph f , it is possible to achieve a single-entry flow graph by applying a sequential block preserving transformation. Instead of giving the full detailed mathematical proof, we explain the proof idea which shows also the algorithm that can be deduced (details in <ref> [5] </ref>). Proof. (1) Let us partition the set of nodes of a given, generic flow graph into maximum loops. A maximum loop is a subset of all nodes which forms a loop. None of these nodes is a member of another loop. <p> The termination of this process can be shown by complete induction (details in <ref> [5] </ref>). (4) If all maximum loops are single-entry loops, we go one maximum loop level deeper. We look at the nodes of each maximum loop. <p> We now apply recursively steps one through four to each of these flow graphs. We proceed until no multiple-entry loop exists. Termination is guaranteed by <ref> [5] </ref>, page 85. Finally we have to make sure that the sequential block order is preserved. Because every operation of the transformation preserves the sequential block order, the order of single action inside a block remains untouched, unless there is a branching address to be changed. QED. <p> Because every operation of the transformation preserves the sequential block order, the order of single action inside a block remains untouched, unless there is a branching address to be changed. QED. A further outcome of this transformation is that the flow graph is now reducible <ref> [5] </ref>. The reducibility of a flow graph is important for data-flow equations, which enable data-flow scrutiny for optimization or maintenance purposes [1] [13]. Before we describe the non-deterministic part of our method we take a look at the loop-free part of a flow graph. <p> Proof idea. This proof operates much like the proof of theorem 1. Copying sequential blocks disconnects links into D-structures. Figure 8 shows fragmental flow graph and its transformation. Details of the proof can be found in <ref> [5] </ref>. We can summarize the two given theorems, which signify the deterministic part of the method, with the following corollary. Corollary 1. Through the application of a sequential block transformation, every generic flow graph can be transformed into a flow graph with two structural properties: 1. <p> However, destroying an incomplete D-structure by unfolding would also be undesirable. Fortunately, we can prove that additional unfolding can not destroy a previously gained D-structures. In <ref> [5] </ref> we proved the following theorem. Theorem 3. Let f be a D-structure flow graph. Let L be a maximum loop with the entry nodes e L . Let a be an element of L, different from e L and with one or more entries. <p> The gained graph is still a D-structure. In case of loop-free D-structures, unfolding produces the same copying mechanisms as used in theorem 2, and therefore all resulting structures are going to be D-structures (details in <ref> [5] </ref>). 6 An Application of Unfolding In this section we illustrate unfolding applied to a source code fragment, and then we show how to enhance this fragment.
Reference: [6] <author> Toni A. Bunter. </author> <title> A repository for a care environment. </title> <booktitle> CASE'93 Sixth International Workshop on Computer-Aided Software Engineering, </booktitle> <year> 1993. </year> <note> (submitted in January). </note>
Reference-contexts: In an advanced source code representation, such as we proposed in <ref> [6] </ref>, it is not necessary to make copies of the whole sequential block. In our relational database approach, a simple entity can represent the copied nodes.) * To physically unfold the flow graph and the source code in order to maintain and enhance the copied and the original block independently. <p> The theoretical part of the method has already been completed. This paper can thus be regarded as providing closure to previous works in this field. The results and experience it has yielded will doubtless influence the fledgling project developing fine grain source code database (c.f. <ref> [6] </ref>). This database is thought to support the development and the maintenance of large software systems. 8
Reference: [7] <author> O. J. Dahl, E. W. Dijkstra, and C. A. R. Hoare. </author> <title> Structured Programming. </title> <address> Academic-Press (London,New-York), </address> <year> 1972. </year>
Reference-contexts: 1 Introduction The quality of the control flow graphs of procedural programming languages has concerned programmers and theorists for a long time. Investigation into flow graph structures has led to new programming paradigms. The structured programming appoach <ref> [7] </ref>, dealing with D-structures which are well known to Pascal programmers, is considered to be of high quality. Therefore, countless attempts have been made to find theorems and algorithms for updating the flow graphs of given source code to structures similar to D-structures.
Reference: [8] <author> E. W. Dijkstra. </author> <title> Goto statement considered harmful. </title> <journal> Communications of the ACM, </journal> <volume> 11(3) </volume> <pages> 147-148, </pages> <month> March </month> <year> 1968. </year>
Reference-contexts: The results of these earlier works were often controversial. A broad discussion arose about the harmfulness of the goto statement <ref> [8] </ref>, [14]. One group supports a liberal, but responsible programmer, who produces understandable code, while the opposing view advocates the use of structures that also cover design and specification areas (as in the structured programming approach).
Reference: [9] <author> E. W. Dijkstra. </author> <title> Notes on structured programming. </title> <publisher> In Academic Press New York, </publisher> <editor> editor, </editor> <booktitle> Structered Programming, </booktitle> <year> 1972. </year>
Reference-contexts: Below are a few definitons which are important for this paper. The most restricted and probably most maintainable structure is the D-structure (in [15] originally called D-structure, 'D' in honor of Dijkstra's work as <ref> [9] </ref>). Programming that exclusively applies D-structures is called structured programming. A D-structure consists of a sequence of if-then-else, case, while, repeat-until and for with a single entry and a single exit point. These can be parsed by a context-free graph grammer.
Reference: [10] <author> Paul Eisner. Strukturierte Wartung von Cobol-Software. </author> <title> Output, </title> <type> (6), </type> <year> 1986. </year>
Reference-contexts: The two extreme postitions of control flow graphs concerned transformations are (1) the detection of block structure-like patterns and their replacement through loop structures such as while, and braching structures such as if-then-else <ref> [10] </ref>, and (2) the transformation of arbitrary source code into block structures [4]. The latter approach introduces additional boolean variables that are necessary to uphold the semantics. Despite the large quantity of varied results, relatively few software maintenance tools are currently in use. <p> One of the main reasons for this is the aforementioned trade-off. Strong restructuring often makes the semantic structure as data-flow or local meaning of variables more confusing than before, while "soft" restructuring, such as <ref> [10] </ref>, is often merely cosmetic.
Reference: [11] <author> Paul Eisner. Strukturierte Software-Wartung. </author> <type> PhD thesis, </type> <institution> Universitat Zurich, </institution> <year> 1988. </year>
Reference-contexts: This enables changing the behaviour of the program in case of a "regular" token (neither nl nor end) to insert the token into a token table. Finally the source code can be printed in a pretty print manner and with changing syntactical keywords (as shown in <ref> [11] </ref>). 10 count : integer 20 token : enumerate : : : : : : 100 loop 110 ..repeat 120 ....write "newline" 130 ....read token 140 ..until token = nl 150 ..loop 160 ....count = count + 1 170 ....if token != end then exit 250 180 ....set in table (token)
Reference: [12] <author> C. A. R. Hoare and Niklaus Wirth. </author> <title> An axiomatic definition of the programming language Pascal. </title> <journal> Acta Informatica, </journal> <volume> 2 </volume> <pages> 335-355, </pages> <year> 1975. </year>
Reference-contexts: One group supports a liberal, but responsible programmer, who produces understandable code, while the opposing view advocates the use of structures that also cover design and specification areas (as in the structured programming approach). One of the most popular outcomes of this debate is the programming language, Pascal <ref> [12] </ref>. Pascal integrates the so called block structure as its basic component of control flow [12]. For better or for worse, huge amounts of source code have already been and still are being written with goto statements. <p> One of the most popular outcomes of this debate is the programming language, Pascal <ref> [12] </ref>. Pascal integrates the so called block structure as its basic component of control flow [12]. For better or for worse, huge amounts of source code have already been and still are being written with goto statements. In spite of the proclaimed attitude of disciplined programmers, much of the source code 1 produced is hardly understandable because of the complex control structure.
Reference: [13] <author> Ken Kennedy. </author> <title> A Survey of Data Flow Analysis Techniques. </title> <booktitle> Prentice-Hall software series, </booktitle> <year> 1981. </year>
Reference-contexts: QED. A further outcome of this transformation is that the flow graph is now reducible [5]. The reducibility of a flow graph is important for data-flow equations, which enable data-flow scrutiny for optimization or maintenance purposes [1] <ref> [13] </ref>. Before we describe the non-deterministic part of our method we take a look at the loop-free part of a flow graph. By building equivalent sets of the maximum loops we get a super-structure in which nodes are sets of sequential blocks.
Reference: [14] <author> D. E. Knuth and R. W. Floyd. </author> <title> Notes on avoiding 'go to' statements. </title> <journal> Inform. Processing Letters 1, </journal> <pages> pages 23-31, </pages> <year> 1971. </year>
Reference-contexts: The results of these earlier works were often controversial. A broad discussion arose about the harmfulness of the goto statement [8], <ref> [14] </ref>. One group supports a liberal, but responsible programmer, who produces understandable code, while the opposing view advocates the use of structures that also cover design and specification areas (as in the structured programming approach). One of the most popular outcomes of this debate is the programming language, Pascal [12].
Reference: [15] <author> Henry F. Ledgard and Michael Marcotty. </author> <title> A genealogy of control structures. </title> <journal> Communications of the ACM, </journal> <volume> 18(11), </volume> <year> 1975. </year>
Reference-contexts: The graph is fully connected. One node is the start node. From the start node, every node is accessible along the edges. Marcotty and Ledgard give an overview of the structure and transformation of control flow graphs <ref> [15] </ref>. Below are a few definitons which are important for this paper. The most restricted and probably most maintainable structure is the D-structure (in [15] originally called D-structure, 'D' in honor of Dijkstra's work as [9]). Programming that exclusively applies D-structures is called structured programming. <p> Marcotty and Ledgard give an overview of the structure and transformation of control flow graphs <ref> [15] </ref>. Below are a few definitons which are important for this paper. The most restricted and probably most maintainable structure is the D-structure (in [15] originally called D-structure, 'D' in honor of Dijkstra's work as [9]). Programming that exclusively applies D-structures is called structured programming. A D-structure consists of a sequence of if-then-else, case, while, repeat-until and for with a single entry and a single exit point.
Reference: [16] <author> I. Nassi and B. Shneiderman. </author> <title> Flowchart techniques for standard programming. </title> <journal> Sigplan Notices, </journal> <volume> 8(8) </volume> <pages> 12-26, </pages> <year> 1973. </year>
Reference-contexts: All loop-free structures and super-structures are D-structures. From now on, we will call a flow graph that fullfills conditions 1 and 2 of corollary 1 an incomplete D structure. 4 Extended Nassi-Shneiderman Diagrams Nassi-Shneiderman diagrams are well known for structured design of the control flow and standard programming <ref> [16] </ref>. They are closely related to the D-structure and can be used in a pre-coding phase with programming languages such as Pascal or MODULA-2 [3]. To provide a similar illustration we developed an extended NS diagram for incomplete D-structures.

References-found: 16

