URL: http://www.cs.uoregon.edu/paracomp/proj/ariadne/papers/vis92/vis92.ps.gz
Refering-URL: http://www.cs.uoregon.edu/paracomp/proj/ariadne/publications.html
Root-URL: http://www.cs.uoregon.edu
Title: Logical Time in Visualizations Produced by Parallel Programs  
Author: Janice E. Cuny, Alfred A. Hough, and Joydip Kundu 
Address: Amherst MA 01003  
Affiliation: Department of Computer Science University of Massachusetts,  
Abstract: Visualization tools that display data as it is manipulated by a parallel, MIMD computation must contend with the effects of asynchronous execution. We have developed techniques that manipulate logical time in order to produce coherent animations of parallel program behavior despite the presence of asynchrony. Our techniques "interpret" program behavior in light of user-defined abstractions and generate animations based on a logical rather than a physical view of time. If this interpretation succeeds, the resulting animation is easily understood; if it fails, the programmer can be assured that the failure was not an artifact of the visualization. Here we demonstrate that these techniques can be generally applied to enhance visualizations of a variety of types of data as it is produced by parallel, MIMD computations.
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> P. C. Bates. </author> <title> Debugging Heterogeneous Distributed Systems Using Event-Based Models of Behavior. </title> <type> Ph.D. Thesis, </type> <institution> Department of Computer Science, University of Massachusetts, </institution> <address> Amherst MA (1986). </address>
Reference-contexts: For our purposes, we extend the definition to nonatomic events, defining three relations | precedes, parallels, and overlaps | between abstract events. Other extensions have been proposed <ref> [12, 1, 11, 3] </ref> but ours has been tailored to the needs of visualization systems. We begin with a relation partially precedes, denoted 7!. Let A and B be sets of events.
Reference: [2] <author> Alva Couch. </author> <title> Graphical Representations of Program Performance on Hypercube Message-Passing Multiprocessors. </title> <institution> Tufts University, </institution> <note> Technical Report 88-4 (1988). </note>
Reference-contexts: if it fails, the programmer can be assured that the 1 The Parallel Programming Environments Project at the University of Massachusetts is supported by the National Science Foundation under grant CCR-9023256. 2 This is in contrast to a number of program visualization tools designed for use in debugging for performance <ref> [2, 5, 15] </ref>. In debugging for correctness, it is logical time that is important; in debugging for performance, it is physical time. 1 failure was not an artifact of the visualization.
Reference: [3] <author> C. J. Fidge, </author> <title> "Partial Orders for Parallel Debugging," </title> <booktitle> Proceedings of the ACM SIPLAN/SIGOPS Workshop on Parallel and Distributed Debugging, </booktitle> <pages> pp. </pages> <month> 183-194 </month> <year> (1988). </year>
Reference-contexts: For our purposes, we extend the definition to nonatomic events, defining three relations | precedes, parallels, and overlaps | between abstract events. Other extensions have been proposed <ref> [12, 1, 11, 3] </ref> but ours has been tailored to the needs of visualization systems. We begin with a relation partially precedes, denoted 7!. Let A and B be sets of events.
Reference: [4] <author> Allan Gottlieb, Ralph Grishman, Clyde P. Kruskal, Kevin P. McAuliffe, Larry Rudolph and Mark Snir, </author> <title> "The NYU Ultracomputer Designing and MIMD Shared Memory Parallel Computer," </title> <journal> IEEE Transactions on Computers C-32(2), </journal> <pages> pp. </pages> <month> 175-189 </month> <year> (1983). </year>
Reference-contexts: In the next example, we demonstrate a program that cannot be successfully animated with phase or generation time alone. 9 matrix after the transposition of 2 fi 2, 4 fi 4 and 8 fi 8 submatrices. Example 3. Parallel FIFO Queue <ref> [4] </ref>. Here, we discuss an animation of a parallel queue 5 but the scenario is typical of many simulations that model concurrent, nonatomic updates of data. the head pointer is labeled I and the tail pointer is labeled D.
Reference: [5] <author> M. T. Heath and J. A. Etheridge. </author> <title> Visualizing Performance of Parallel Programs. </title> <institution> Oak Ridge National Laboratory Technical Report ORNL/TM-11813 (1991). </institution>
Reference-contexts: if it fails, the programmer can be assured that the 1 The Parallel Programming Environments Project at the University of Massachusetts is supported by the National Science Foundation under grant CCR-9023256. 2 This is in contrast to a number of program visualization tools designed for use in debugging for performance <ref> [2, 5, 15] </ref>. In debugging for correctness, it is logical time that is important; in debugging for performance, it is physical time. 1 failure was not an artifact of the visualization. <p> These abstract events are ordered by precedes and, thus, they are automatically separated to produce the desired animation (as shown in Figure 5). Example 2. Recursive Matrix Transposition. In this example, we consider the animation of a program that performs a recursive matrix transposition as shown in <ref> [5] </ref>. Starting with the matrix as displayed in Figure 7, we successively transpose submatrices of sizes 2 fi 2, 4 fi 4 and 8 fi 8. A visualization in which processes asynchronously update the display as they compute produces the incomprehensible snapshots of Figure 8.
Reference: [6] <author> R. W. Hockney and C. R. Jesshope. </author> <title> Parallel Computers: </title> <booktitle> Architecture, Programming and Algorithms. </booktitle> <address> Adam Hilger, Bristol, England (1981). </address>
Reference-contexts: Visualization tools aid in this process by providing comprehensible views of program behavior. Consider, for example, a program iteratively approximating the solution to a PDE using a Successive Overrelaxation (SOR) method <ref> [6] </ref>. Processes, arranged in a square mesh repeatedly update their values as a function of the values of their neighbors. To speed convergence, their execution alternates in a checkered pattern as in Figure 1: first striped processes execute and then solid processes. show the expected behavior.
Reference: [7] <author> Alfred A. Hough and Janice E. Cuny, "Belvedere: </author> <title> Prototype of a Pattern-Oriented Debugger for Highly Parallel Computation," </title> <booktitle> Proceedings 1987 International Conference on Parallel Processing, </booktitle> <pages> pp. </pages> <month> 735-738 </month> <year> (1987). </year>
Reference-contexts: The two reorderings together characterize the complete behavior of the system. Further details of the transformation algorithms can be found in [9] and [10]. 4 Examples: Logical Time in Visualizations Produced by Parallel Computations We have successfully used the logical time manipulations described here in the Belvedere animation system <ref> [7, 8, 10] </ref> which was specifically designed to aid in the debugging of parallel programs for correctness. Here, we demonstrate their more general application to visualizations of domain-specific data. Example 1. Sharks and Fishes [16].
Reference: [8] <author> Alfred A. Hough and Janice E. Cuny, </author> <title> "Initial Experiences with a Pattern-Oriented Parallel Debugger," </title> <booktitle> ACM SIGPLAN and SIGOPS Workshop on Parallel and Distributed Debugging, </booktitle> <pages> pp. </pages> <month> 195-205 </month> <year> (1988). </year>
Reference-contexts: The two reorderings together characterize the complete behavior of the system. Further details of the transformation algorithms can be found in [9] and [10]. 4 Examples: Logical Time in Visualizations Produced by Parallel Computations We have successfully used the logical time manipulations described here in the Belvedere animation system <ref> [7, 8, 10] </ref> which was specifically designed to aid in the debugging of parallel programs for correctness. Here, we demonstrate their more general application to visualizations of domain-specific data. Example 1. Sharks and Fishes [16].
Reference: [9] <author> Alfred A. Hough and Janice E. Cuny, </author> <title> "Perspective Views: A Technique for Enchancing Visualizations of Parallel Programs", </title> <booktitle> Proceedings 1990 International Conference on Parallel Processing, </booktitle> <pages> pp. </pages> <note> II 124-132 (1990). </note>
Reference-contexts: The two reorderings together characterize the complete behavior of the system. Further details of the transformation algorithms can be found in <ref> [9] </ref> and [10]. 4 Examples: Logical Time in Visualizations Produced by Parallel Computations We have successfully used the logical time manipulations described here in the Belvedere animation system [7, 8, 10] which was specifically designed to aid in the debugging of parallel programs for correctness.
Reference: [10] <author> Alfred A. Hough. </author> <title> Debugging Parallel Programs Using Abstract Visualizations. </title> <type> Ph.D. Thesis, </type> <institution> Computer Science Department, University of Massachusetts, </institution> <address> Amherst MA (1991). </address>
Reference-contexts: The two reorderings together characterize the complete behavior of the system. Further details of the transformation algorithms can be found in [9] and <ref> [10] </ref>. 4 Examples: Logical Time in Visualizations Produced by Parallel Computations We have successfully used the logical time manipulations described here in the Belvedere animation system [7, 8, 10] which was specifically designed to aid in the debugging of parallel programs for correctness. <p> The two reorderings together characterize the complete behavior of the system. Further details of the transformation algorithms can be found in [9] and [10]. 4 Examples: Logical Time in Visualizations Produced by Parallel Computations We have successfully used the logical time manipulations described here in the Belvedere animation system <ref> [7, 8, 10] </ref> which was specifically designed to aid in the debugging of parallel programs for correctness. Here, we demonstrate their more general application to visualizations of domain-specific data. Example 1. Sharks and Fishes [16].
Reference: [11] <author> W. Hsuesh and G. E. Kaiser, </author> <title> "Data Path Debugging: Data-Oriented Debugging for a Concurrent Programming Language," </title> <booktitle> Proceedings of the ACM SIPLAN/SIGOPS Workshop on Parallel and Distributed Debugging, </booktitle> <pages> pp. </pages> <month> 236-247 </month> <year> (1988). </year>
Reference-contexts: For our purposes, we extend the definition to nonatomic events, defining three relations | precedes, parallels, and overlaps | between abstract events. Other extensions have been proposed <ref> [12, 1, 11, 3] </ref> but ours has been tailored to the needs of visualization systems. We begin with a relation partially precedes, denoted 7!. Let A and B be sets of events.
Reference: [12] <author> Leslie Lamport, </author> <title> "Time, Clocks, and the Ordering of Events in a Distributed System," </title> <journal> CACM 21(7), </journal> <pages> pp. </pages> <month> 558-565 </month> <year> (1978). </year>
Reference-contexts: Thus, ignoring some temporal orderings in the original execution sequence made it possible for the programmer to understand aspects of the program's behavior relevant to its correctness. 3 Our Approach: The Technical Details We base our animations on Lamport's happened before relation <ref> [12] </ref> which is defined on primitive actions, each assumed to have a processor-local timestamp, denoted timestamp (a) for an event a. <p> For our purposes, we extend the definition to nonatomic events, defining three relations | precedes, parallels, and overlaps | between abstract events. Other extensions have been proposed <ref> [12, 1, 11, 3] </ref> but ours has been tailored to the needs of visualization systems. We begin with a relation partially precedes, denoted 7!. Let A and B be sets of events.
Reference: [13] <author> Thomas J. LeBlanc and John M. Mellor-Crummey and Robert J. Fowler, </author> <title> "Analyzing Parallel Program Executions Using Multiple Views," </title> <journal> Journal of Parallel and Distributed Computing 9, </journal> <pages> pp. </pages> <month> 203-217 </month> <year> (1990). </year>
Reference-contexts: Existing animation tools solve this problem by requiring the programmer to explicitly simulate a global or real world time. Each process must output clock "ticks" and all of the data produced between successive ticks is displayed at the same time. This simulated time has been called "phase time" <ref> [13] </ref> or "generation" time [16] and it works well for SPMD (Single Program Multiple Data) programs where all processes proceed in unison. It does not work well for less regular programs in which processes independently update data at different points in their execution.
Reference: [14] <author> A. R. Omondi and J. D. Brock, </author> <title> "Implementing a Dictionary on Hypercube Machines," </title> <booktitle> Proceedings of the 1987 International Conference on Parallel Processing, </booktitle> <pages> pp. </pages> <month> 707-709 </month> <year> (1987). </year>
Reference-contexts: For many parallel computations, however, such simple orderings are not possible because of intertwined dependencies. Consider, for example, a program that implements a dictionary search in which queries are pipelined from the host to a database of key-ordered records stored in a hypercube <ref> [14] </ref>. Queries are routed within the cube to the proper node using a binary search.
Reference: [15] <author> Daniel A. Reed, Robert D. Olson, Ruth A. Aydt, Tara M. Madhyastha, Thomas Birkett, David W. Jensen, Bobby A. A. Nazief, and Brian K. Totty, </author> <title> "Scalable Performance Environments for Parallel Systems," </title> <booktitle> Proceedings Sixth Distributed Memory Computing Conference, </booktitle> <pages> pp. </pages> <month> 562-569 </month> <year> (1991). </year> <month> 13 </month>
Reference-contexts: if it fails, the programmer can be assured that the 1 The Parallel Programming Environments Project at the University of Massachusetts is supported by the National Science Foundation under grant CCR-9023256. 2 This is in contrast to a number of program visualization tools designed for use in debugging for performance <ref> [2, 5, 15] </ref>. In debugging for correctness, it is logical time that is important; in debugging for performance, it is physical time. 1 failure was not an artifact of the visualization.
Reference: [16] <author> David Socha, Mary L. Bailey, and David Notkin, "Voyeur: </author> <title> Graphical Views of Parallel Programs", </title> <booktitle> Proceedings of the ACM SIPLAN/SIGOPS Workshop on Parallel and Distributed Debugging, </booktitle> <pages> pp. </pages> <month> 206-217 </month> <year> (1988). </year>
Reference-contexts: Here, we demonstrate their more general application to visualizations of domain-specific data. Example 1. Sharks and Fishes <ref> [16] </ref>. For this example, we use the animation of a program that performs an underwater simulation taken from a paper on the Voyeur animation system [16]. The simulation consists of a 2D world where sharks eat fish that come too close. <p> Here, we demonstrate their more general application to visualizations of domain-specific data. Example 1. Sharks and Fishes <ref> [16] </ref>. For this example, we use the animation of a program that performs an underwater simulation taken from a paper on the Voyeur animation system [16]. The simulation consists of a 2D world where sharks eat fish that come too close. Initially, the simulation might be configured as in Figure 5a. <p> Each process must output clock "ticks" and all of the data produced between successive ticks is displayed at the same time. This simulated time has been called "phase time" [13] or "generation" time <ref> [16] </ref> and it works well for SPMD (Single Program Multiple Data) programs where all processes proceed in unison. It does not work well for less regular programs in which processes independently update data at different points in their execution.
References-found: 16

