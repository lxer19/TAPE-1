URL: http://reports-archive.adm.cs.cmu.edu/anon/1996/CMU-CS-96-180.ps
Refering-URL: http://www.cs.cmu.edu/~berez/publications.html
Root-URL: 
Title: Model Checking Algorithms for the -Calculus  
Author: Sergey Berezin Edmund Clarke Somesh Jha Will Marrero 
Note: This research was sponsored in part by the Wright Laboratory, Aeronautical Systems Center, Air Force Material Command, USAF, and the Advanced Research Projects Agency (ARPA) under grant number F33615-93-1-1330. The views and conclusions contained in this document are those of the authors and should not be interpreted as necessarily representing the official policies or endorsements, either expressed or implied, of Wright Laboratory or the U. S. Government. The U. S. Government is authorized to reproduce and distribute reprints for Government purposes notwithstanding any copyright notation thereon. This manuscript is submitted for publication with the understanding that the U. S. Government is authorized to reproduce and distribute reprints for Governmental purposes.  
Address: Pittsburgh, PA 15213  
Affiliation: School of Computer Science Carnegie Mellon University  
Date: September 23, 1996  
Pubnum: CMU-CS-96-180  
Abstract: The propositional -calculus is a powerful language for expressing properties of transition systems by using least and greatest fixpoint operators. Recently, the -calculus has generated much interest among researchers in computer-aided verification. This interest stems from the fact that many temporal and program logics can be encoded into the -calculus. In addition, important relations between transition systems, such as weak and strong bisim-ulation equivalence, also have fixpoint characterizations. Wide-spread use of binary decision diagrams has made fixpoint based algorithms even more important, since methods that require the manipulation of individual states do not take advantage of this representation. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> H. R. Andersen. </author> <title> Model checking and boolean graphs. </title> <editor> In B. Krieg-Bruckner, editor, </editor> <booktitle> Proceedings of the Fourth European Symposium on Programming, volume 582 of Lecture Notes in Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <month> February </month> <year> 1992. </year>
Reference-contexts: However, the worst-case complexity of these approaches is generally larger than the complexity of the global methods. Tableau-based local approaches have been developed by Cleaveland [8], Stirling and Walker [19], and Winskel [21]. More recently, Andersen <ref> [1] </ref> and Larsen [13] have developed efficient local methods for a subset of the -calculus. Mader [15] has also proposed improvements to the tableau-based method of Stirling and Walker that seem to increase its efficiency. In this paper, we restrict ourselves to global model checking procedures. <p> In an implementation, bookkeeping and set manipulations may add another factor of n or so to the time required. Subsequent work by Cleaveland, Klein, Steffen, and Andersen <ref> [1, 9, 10] </ref> has reduced this extra complexity, but the overall number of iterations has remained about O (n d ). <p> The alternation depth of a formula is intuitively equal to the number of alternations in the nesting of least and greatest fixpoints, when all negations are applied only to propositions. There are other more elaborate definitions of alternation depth <ref> [1, 2, 9] </ref>, that take into account the possibility that nested fixpoints may still be independent. Such fixpoints do not depend on the value of approximations to outer fixpoints. Consequently, they only need to be evaluated once. This type of nesting does not increase the effective alternation depth. <p> The basic idea is to restrict path quantifiers to fair paths. The formal definition is given below: * s j= EX H f iff there exists a fair path starting from the state s such that <ref> [1] </ref> j= f . * s j= E (g 1 U H g 2 ) iff there exists a fair path starting from the state s and there exists k 0 such that [k] j= g 2 and for all 0 j &lt; k; [j] j= g 1 . * s <p> Since the outer fixed point -Y:(P ^ ) indicates that this property holds globally along the path, the formula exactly corresponds to the desired property. 1 By definition of alternation depth given in <ref> [1] </ref>, the formula T r (f) always has alternation depth one. Hence, the linear complexity of CTL model checking follows directly from the algorithm in [1]. 20 8 Simulation Preorders and Bisimulation Equivalences. 8.1 Simulation and bisimulation. <p> indicates that this property holds globally along the path, the formula exactly corresponds to the desired property. 1 By definition of alternation depth given in <ref> [1] </ref>, the formula T r (f) always has alternation depth one. Hence, the linear complexity of CTL model checking follows directly from the algorithm in [1]. 20 8 Simulation Preorders and Bisimulation Equivalences. 8.1 Simulation and bisimulation. In this section we will use essentially the same definition of a transition system that was introduced in Section 2, except for two special program letters t and ".
Reference: [2] <author> H. R. Andersen. </author> <title> Model checking and boolean graphs. </title> <journal> Theoretical Computer Science, </journal> <volume> 126 </volume> <pages> 3-30, </pages> <year> 1994. </year>
Reference-contexts: The alternation depth of a formula is intuitively equal to the number of alternations in the nesting of least and greatest fixpoints, when all negations are applied only to propositions. There are other more elaborate definitions of alternation depth <ref> [1, 2, 9] </ref>, that take into account the possibility that nested fixpoints may still be independent. Such fixpoints do not depend on the value of approximations to outer fixpoints. Consequently, they only need to be evaluated once. This type of nesting does not increase the effective alternation depth. <p> Recall that each iteration can take upto O (j ~ Actjj ~ M j) time. However, there is another algorithm by H. Andersen <ref> [2] </ref> that can compute the fixpoints in O (jActj 2 j ~ Sjj ~ M j) time. The algorithm in [18] can also be adapted to compute weak bisim ulation equivalence by precomputing the transitive closure of the " relation.
Reference: [3] <editor> G. V. Bochmann and D. K. Probst, editors. </editor> <booktitle> Proceedings of the Fourth Workshop on Computer-Aided Verification, volume 663 of Lecture Notes in Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <month> July </month> <year> 1992. </year>
Reference: [4] <author> R. E. Bryant. </author> <title> Graph-based algorithms for boolean function manipulation. </title> <journal> IEEE Transactions on Computers, </journal> <volume> C-35(8):677-691, </volume> <month> August </month> <year> 1986. </year>
Reference-contexts: We assume that there is a total ordering on the boolean variables. The ordering is given by the index, i.e., x i is ordered before x j iff i &lt; j. The symbol OBDD (f ) will denote the Ordered Binary Decision Diagram (OBDD) for the boolean function f <ref> [4] </ref>. OBDDs have the following canonicity property: Theorem 4.1 (Canonicity Theorem): Given two boolean functions f and g in the space BF n , OBDD (f ) = OBDD (g) iff f = g. A detailed proof is given in [4]. <p> Ordered Binary Decision Diagram (OBDD) for the boolean function f <ref> [4] </ref>. OBDDs have the following canonicity property: Theorem 4.1 (Canonicity Theorem): Given two boolean functions f and g in the space BF n , OBDD (f ) = OBDD (g) iff f = g. A detailed proof is given in [4]. We will give a succinct explanation of how OBDDs work through an example. For a more thorough treatment see [4, 6]. <p> A detailed proof is given in [4]. We will give a succinct explanation of how OBDDs work through an example. For a more thorough treatment see <ref> [4, 6] </ref>. Consider the following boolean function f : f = x 0 x 1 x 2 the binary subtree which we get by following the paths (0; 1) and (1; 0) from the root are the same. <p> As the following lemma shows, the OBDD for f can have size exponential in n under some variable orderings. Moreover, there are some functions whose OBDDs have exponential size under any variable ordering <ref> [4] </ref>. 12 Lemma 4.1 Let f (x 1 ; ; x n ; x 0 1 ; ; x 0 n ) be the following boolean function: n ^ (x i = x 0 Let F be the OBDD for f such that all the unprimed variables are ordered before all
Reference: [5] <author> J. R. Burch, E. M. Clarke, D. E. Long, K. L. McMillan, and D. L. Dill. </author> <title> Symbolic model checking for sequential circuit verification. </title> <journal> IEEE Transactions on Computer-Aided Design of Integrated Circuits, </journal> <volume> 13(4) </volume> <pages> 401-424, </pages> <month> April </month> <year> 1994. </year>
Reference-contexts: Before the use of OBDDs, it was only possible to verify models with at most 10 6 states [7]. By using the OBDD techniques described in this paper, in practice, it is now possible to verify examples with up to 10 120 states and several hundred state variables <ref> [5] </ref>. However, there is no theoretical framework which explains when OBDDs will work well in practice. Our algorithm does not depend on the data structure used to represent boolean functions, so it should be possible to use any better data structures that may be discovered.
Reference: [6] <author> J. R. Burch, E. M. Clarke, K. L. McMillan, D. L. Dill, and L. J. Hwang. </author> <title> Symbolic model checking: 10 20 states and beyond. </title> <journal> Information and Computation, </journal> <volume> 98(2) </volume> <pages> 142-170, </pages> <month> June </month> <year> 1992. </year>
Reference-contexts: A detailed proof is given in [4]. We will give a succinct explanation of how OBDDs work through an example. For a more thorough treatment see <ref> [4, 6] </ref>. Consider the following boolean function f : f = x 0 x 1 x 2 the binary subtree which we get by following the paths (0; 1) and (1; 0) from the root are the same.
Reference: [7] <author> E. M. Clarke, E. A. Emerson, and A. P. Sistla. </author> <title> Automatic verification of finite-state concurrent systems using temporal logic specifications. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 8(2) </volume> <pages> 244-263, </pages> <month> April </month> <year> 1986. </year>
Reference-contexts: For example, if we are verifying a protocol with a scheduler, we may wish to consider only executions where processes are not ignored by the scheduler, i.e., every process is given a chance to run infinitely often. This type of fairness constraint cannot be expressed in CTL <ref> [7] </ref>. In order to handle such properties we have to modify the semantics of CTL. A fairness constraint can be an arbitrary set of states, usually described by a CTL formula. Generally, there will be several fairness constraints. <p> Although OBDDs do not reduce the worst-case complexity of the model checking problem for the -calculus, their use in model checking has had an enormous effect on formal verification. Before the use of OBDDs, it was only possible to verify models with at most 10 6 states <ref> [7] </ref>. By using the OBDD techniques described in this paper, in practice, it is now possible to verify examples with up to 10 120 states and several hundred state variables [5]. However, there is no theoretical framework which explains when OBDDs will work well in practice.
Reference: [8] <author> R. Cleaveland. </author> <title> Tableau-based model checking in the propositional mu-calculus. </title> <journal> Acta Informatica, </journal> <volume> 27(8) </volume> <pages> 725-747, </pages> <month> September </month> <year> 1990. </year>
Reference-contexts: Because of this, it is not always necessary to examine all the states in the transition system. However, the worst-case complexity of these approaches is generally larger than the complexity of the global methods. Tableau-based local approaches have been developed by Cleaveland <ref> [8] </ref>, Stirling and Walker [19], and Winskel [21]. More recently, Andersen [1] and Larsen [13] have developed efficient local methods for a subset of the -calculus. Mader [15] has also proposed improvements to the tableau-based method of Stirling and Walker that seem to increase its efficiency.
Reference: [9] <author> R. Cleaveland, M. Klein, and B. Steffen. </author> <title> Faster model checking for the modal mu-calculus. </title> <note> In Bochmann and Probst [3]. </note>
Reference-contexts: In an implementation, bookkeeping and set manipulations may add another factor of n or so to the time required. Subsequent work by Cleaveland, Klein, Steffen, and Andersen <ref> [1, 9, 10] </ref> has reduced this extra complexity, but the overall number of iterations has remained about O (n d ). <p> The alternation depth of a formula is intuitively equal to the number of alternations in the nesting of least and greatest fixpoints, when all negations are applied only to propositions. There are other more elaborate definitions of alternation depth <ref> [1, 2, 9] </ref>, that take into account the possibility that nested fixpoints may still be independent. Such fixpoints do not depend on the value of approximations to outer fixpoints. Consequently, they only need to be evaluated once. This type of nesting does not increase the effective alternation depth.
Reference: [10] <author> R. Cleaveland and B. Steffen. </author> <title> A linear-time model-checking algorithm for the alternation-free modal mu-calculus. </title> <booktitle> Formal Methods in System Design, </booktitle> <volume> 2(2) </volume> <pages> 121-147, </pages> <month> April </month> <year> 1993. </year>
Reference-contexts: In an implementation, bookkeeping and set manipulations may add another factor of n or so to the time required. Subsequent work by Cleaveland, Klein, Steffen, and Andersen <ref> [1, 9, 10] </ref> has reduced this extra complexity, but the overall number of iterations has remained about O (n d ).
Reference: [11] <author> E. A. Emerson and C.-L. Lei. </author> <title> Efficient model checking in fragments of the propositional mu-calculus. </title> <booktitle> In Proceedings of the First Annual Symposium on Logic in Computer Science. </booktitle> <publisher> IEEE Computer Society Press, </publisher> <month> June </month> <year> 1986. </year> <month> 25 </month>
Reference-contexts: Because of fixpoint nesting, a naive global algorithm may require about O (n k ) iterations to evaluate a formula, where n is the number of states in the transition system and k is the depth of nesting of the fixpoints. Emerson and Lei <ref> [11] </ref> improve on this by observing that successively nested fixpoints of the same type do not increase the complexity of the computation. They formalize this observation using the notion of alternation depth and give an algorithm requiring only about O (n d ) iterations, where d is the alternation depth. <p> Consequently, they only need to be evaluated once. This type of nesting does not increase the effective alternation depth. However, to simplify our presentation we will use the definition of alternation depth given by Emerson and Lei <ref> [11] </ref>. <p> Therefore, we can compute it by the algorithm given in <ref> [11] </ref> using O (j ~ Sj 2 j ~ Actj 2 ) iterations or O (j ~ Actj 3 j ~ M jj ~ Sj 2 ) time. Recall that each iteration can take upto O (j ~ Actjj ~ M j) time. However, there is another algorithm by H.
Reference: [12] <author> D. Kozen. </author> <title> Results on the propositional mu-calculus. </title> <journal> Theoretical Computer Science, </journal> <volume> 27 </volume> <pages> 333-354, </pages> <month> December </month> <year> 1983. </year>
Reference-contexts: Several versions of the propositional -calculus have been described in the literature, and the ideas in this paper will work with any of them. For the sake of concreteness, we will use the propositional -calculus of Kozen <ref> [12] </ref>. Closed formulas in this logic evaluate to sets of states. A considerable amount of research has focused on finding techniques for evaluating such formulas efficiently, and many algorithms have been proposed for this purpose. These algorithms generally fall into two categories, local and global.
Reference: [13] <author> K. G. Larsen. </author> <title> Efficient local correctness checking. </title> <note> In Bochmann and Probst [3]. </note>
Reference-contexts: However, the worst-case complexity of these approaches is generally larger than the complexity of the global methods. Tableau-based local approaches have been developed by Cleaveland [8], Stirling and Walker [19], and Winskel [21]. More recently, Andersen [1] and Larsen <ref> [13] </ref> have developed efficient local methods for a subset of the -calculus. Mader [15] has also proposed improvements to the tableau-based method of Stirling and Walker that seem to increase its efficiency. In this paper, we restrict ourselves to global model checking procedures.
Reference: [14] <author> D. Long, A. Browne, E. Clarke, S. Jha, and W. Marrero. </author> <title> An improved algorithm for the evaluation of fixpoint expressions. </title> <editor> In D. Dill, editor, </editor> <booktitle> Proceedings of the 1995 Workshop on Computer-Aided Verification, </booktitle> <pages> pages 338-350. </pages> <publisher> Springer-Verlag, </publisher> <month> June </month> <year> 1994. </year>
Reference-contexts: In an implementation, bookkeeping and set manipulations may add another factor of n or so to the time required. Subsequent work by Cleaveland, Klein, Steffen, and Andersen [1, 9, 10] has reduced this extra complexity, but the overall number of iterations has remained about O (n d ). In <ref> [14] </ref> the authors have improved on this by giving an algorithm that uses only O (n d=2 ) iterations to compute a formula with alternation depth d, thus requiring only about the square root of the time needed by earlier algorithms. <p> This guarantees that when we evaluate a top-level fixpoint subformula of the same type, we do not start the computation from ? or &gt;, but from the previously computed value as in our example. In <ref> [14] </ref> the authors observe that by storing even more intermediate values, the time complexity for evaluating fixpoint formulas can be reduced to O (n bd=2c+1 ) where again d is the alternation depth of the formula. To simplify our discussion, we consider formulas with strict alternation of fixpoints.
Reference: [15] <author> A. Mader. </author> <note> Tableau recycling. In Bochmann and Probst [3]. </note>
Reference-contexts: Tableau-based local approaches have been developed by Cleaveland [8], Stirling and Walker [19], and Winskel [21]. More recently, Andersen [1] and Larsen [13] have developed efficient local methods for a subset of the -calculus. Mader <ref> [15] </ref> has also proposed improvements to the tableau-based method of Stirling and Walker that seem to increase its efficiency. In this paper, we restrict ourselves to global model checking procedures. Global procedures generally work bottom-up through the formula, evaluating each subformula based on the values of its subformulas.
Reference: [16] <author> R. Milner. </author> <title> A Calculus of Communicating Systems, </title> <booktitle> volume 92 of Lecture Notes in Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1980. </year>
Reference-contexts: The letter t represents the idle action; its interpretation is always fixed: T (t ) = f (s; s) j s 2 Sg. The program letter " denotes the invisible action from CCS <ref> [16] </ref> and will be used in the definition of the weak simulation and bisimulation relations [17].
Reference: [17] <author> Robin Milner. </author> <title> Communication and Concurrency. </title> <publisher> Prentice-Hall, </publisher> <year> 1989. </year>
Reference-contexts: Recently, the -calculus has generated much interest among researchers in computer-aided verification. This interest stems from the fact that many temporal and program logics can be encoded into the -calculus. In addition, important relations between transition systems, such as weak and strong bisim-ulation equivalence, also have fixpoint characterizations <ref> [17] </ref>. Another source of interest in the -calculus comes from the existence of efficient model checking algorithms for this formalism. As a consequence, verification procedures for many temporal and modal logics can be succinctly described by translating into the -calculus. <p> The letter t represents the idle action; its interpretation is always fixed: T (t ) = f (s; s) j s 2 Sg. The program letter " denotes the invisible action from CCS [16] and will be used in the definition of the weak simulation and bisimulation relations <ref> [17] </ref>.
Reference: [18] <author> R. Paige and R. E. Tarjan. </author> <title> Three partition refinement algorithms. </title> <journal> SIAM Journal of Computing, </journal> <volume> 6 </volume> (16):973-989, 1987. 
Reference-contexts: The time complexity is O (j ~ Sjj ~ Actjj ~ M j) = O (jSj 2 jActjjM jjM 0 j). An algorithm for bisimulation equivalence with time complexity O (jActj (jT j + jT 0 j) log (jSj)) is given in <ref> [18] </ref>. However, it is not clear if this algorithm can be modified to compute the simulation preorder or if it can be adapted to use OBDDs. 8.3 Weak simulation and bisimulation. Weak simulation preorder and weak bisimulation equivalence require a more elaborate en coding. <p> Recall that each iteration can take upto O (j ~ Actjj ~ M j) time. However, there is another algorithm by H. Andersen [2] that can compute the fixpoints in O (jActj 2 j ~ Sjj ~ M j) time. The algorithm in <ref> [18] </ref> can also be adapted to compute weak bisim ulation equivalence by precomputing the transitive closure of the " relation. However, the expense of this step dominates the cost of the entire computation.
Reference: [19] <author> C. Stirling and D. J. Walker. </author> <title> Local model checking in the modal mu-calculus. </title> <journal> Theoretical Computer Science, </journal> <volume> 89(1) </volume> <pages> 161-177, </pages> <month> October </month> <year> 1991. </year>
Reference-contexts: Because of this, it is not always necessary to examine all the states in the transition system. However, the worst-case complexity of these approaches is generally larger than the complexity of the global methods. Tableau-based local approaches have been developed by Cleaveland [8], Stirling and Walker <ref> [19] </ref>, and Winskel [21]. More recently, Andersen [1] and Larsen [13] have developed efficient local methods for a subset of the -calculus. Mader [15] has also proposed improvements to the tableau-based method of Stirling and Walker that seem to increase its efficiency.
Reference: [20] <author> A. Tarski. </author> <title> A lattice-theoretic fixpoint theorem and its applications. </title> <journal> Pacific Journal of Mathematics, </journal> <volume> 5 </volume> <pages> 285-309, </pages> <year> 1955. </year>
Reference-contexts: Thus, each possible formula in a fixpoint operator is monotonic and hence each possible t is also monotonic (S S 0 implies t (S) t (S 0 )). This is enough to ensure the existence of the fixpoints <ref> [20] </ref>.
Reference: [21] <author> G. Winskel. </author> <title> A note on model checking the modal --calculus. </title> <booktitle> In Proceedings of the Sixteenth International Colloquium on Automata, Languages, and Programming, </booktitle> <year> 1989. </year> <month> 26 </month>
Reference-contexts: Because of this, it is not always necessary to examine all the states in the transition system. However, the worst-case complexity of these approaches is generally larger than the complexity of the global methods. Tableau-based local approaches have been developed by Cleaveland [8], Stirling and Walker [19], and Winskel <ref> [21] </ref>. More recently, Andersen [1] and Larsen [13] have developed efficient local methods for a subset of the -calculus. Mader [15] has also proposed improvements to the tableau-based method of Stirling and Walker that seem to increase its efficiency. In this paper, we restrict ourselves to global model checking procedures.
References-found: 21

