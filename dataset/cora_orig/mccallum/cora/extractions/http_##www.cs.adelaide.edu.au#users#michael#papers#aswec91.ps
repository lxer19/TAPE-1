URL: http://www.cs.adelaide.edu.au/users/michael/papers/aswec91.ps
Refering-URL: http://www.progsoc.uts.edu.au/~geldridg/cpp/
Root-URL: http://www.aic.nrl.navy.mil/~aha/people.html
Title: Abstract Data Types: Converting from Sequential to Parallel  
Author: Michael J. Oudshoorn Keith J. Ransom Chris D. Marlin 
Address: Adelaide Adelaide, South Australia 5001, Australia  
Affiliation: Department of Computer Science The University of  
Abstract: As the availability of parallel programming languages and environments increases, the interest in taking algorithms and software developed for a sequential environment and converting them to work in a parallel environment also increases. Abstract data types are now fundamental to the design of many sequential algorithms and systems. These abstract data types may have their behaviour defined axiomatically and be implemented through language constructs such as Ada's package facility. The use of abstract data types encourages and facilitates software reuse, and it would be desirable if abstract data types developed for a sequential environment could be carried across to a parallel environment. Unfortunately, abstract data types to be used in a parallel environment must be enhanced with appropriate synchronization code to control concurrent access to objects of the type concerned. This paper describes a technique for the conversion of sequential abstract data types to a form useful in a parallel environment. The technique allows for complete reuse of the abstract data type code, and provides a transparent synchronization interface.
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> M. Ben-Ari. </author> <title> Principles of Concurrent Programming. </title> <publisher> Prentice-Hall, </publisher> <address> Englewood Cliffs, New Jersey, </address> <year> 1982. </year>
Reference-contexts: The use of a protective envelope for an ADT, acting as a synchronization interface, itself provides benefits over the traditional technique of protecting objects using semaphores <ref> [1, 2] </ref>. The somewhat ad hoc placement of calls on semaphore primitives throughout code in order to protect shared objects can often lead to erroneous program behaviour, when the primitives are used inconsistently.
Reference: [2] <author> E.W. Dijkstra. </author> <title> A Discipline of Programming. </title> <publisher> Prentice-Hall, </publisher> <address> Englewood Cliffs, New Jersey, </address> <year> 1976. </year>
Reference-contexts: The use of a protective envelope for an ADT, acting as a synchronization interface, itself provides benefits over the traditional technique of protecting objects using semaphores <ref> [1, 2] </ref>. The somewhat ad hoc placement of calls on semaphore primitives throughout code in order to protect shared objects can often lead to erroneous program behaviour, when the primitives are used inconsistently.
Reference: [3] <author> D.H. Freidel. </author> <title> Modelling communication and synchronization in parallel programming languages. </title> <type> Technical Report 84-01 fPh.D. </type> <institution> Thesisg, Department of Computer Science, The University of Iowa, Iowa City, Iowa, </institution> <month> May </month> <year> 1984. </year>
Reference-contexts: Approaches to the definition of an abstract data type, and the control of concurrent access to it, have been described elsewhere. One such approach, known as shared data abstractions (SDAs), is that advocated by Mallgren [13, 14] and used by Freidel to describe parallel languages <ref> [3, 15] </ref>. The drawback of this technique, which is discussed in more depth in Section 2, is that the details of the data type's behaviour and the details governing access to the data type by any process are merged together rather than separated.
Reference: [4] <author> J.A. Goguen. </author> <title> Abstract errors for abstract data types. </title> <editor> In E.J. Neuhold (editor), </editor> <booktitle> Formal Descriptions of Programming Concepts, </booktitle> <pages> pages 491-526. </pages> <publisher> North-Holland, </publisher> <address> Amsterdam, </address> <year> 1978. </year>
Reference-contexts: 1 Introduction One structuring technique which has emerged as particularly important in the development of sequential algorithms and software is the definition of abstract data types (ADTs). ADTs are defined formally using techniques which stem from the work of Goguen <ref> [4, 5, 6] </ref> and Guttag [7, 8]. These formal definitions take the form of axiomatic descriptions and amount to describing the behaviour of operations which manipulate the ADT.
Reference: [5] <author> J.A. Goguen, J.W. Thatcher and E.G. Wagner. </author> <title> An initial algebra approach to the specification, correctness and implementation of abstract data types. In R.T. Yeh (editor), </title> <booktitle> Current Trends in Programming Methodology, </booktitle> <volume> Volume 4, Chapter 5, </volume> <pages> pages 80-149. </pages> <publisher> Prentice-Hall, </publisher> <address> Englewood Cliffs, New Jersey, </address> <year> 1978. </year>
Reference-contexts: 1 Introduction One structuring technique which has emerged as particularly important in the development of sequential algorithms and software is the definition of abstract data types (ADTs). ADTs are defined formally using techniques which stem from the work of Goguen <ref> [4, 5, 6] </ref> and Guttag [7, 8]. These formal definitions take the form of axiomatic descriptions and amount to describing the behaviour of operations which manipulate the ADT.
Reference: [6] <author> J.A. Goguen, J.W. Thatcher, E.G. Wagner and J.B. Wright. </author> <title> Initial algebra semantics and continuous algebras. </title> <journal> Journal of the ACM, </journal> <volume> Volume 24, Number 1, </volume> <pages> pages 68-95, </pages> <year> 1977. </year>
Reference-contexts: 1 Introduction One structuring technique which has emerged as particularly important in the development of sequential algorithms and software is the definition of abstract data types (ADTs). ADTs are defined formally using techniques which stem from the work of Goguen <ref> [4, 5, 6] </ref> and Guttag [7, 8]. These formal definitions take the form of axiomatic descriptions and amount to describing the behaviour of operations which manipulate the ADT.
Reference: [7] <author> I. Guessarian and J. Meseguer. </author> <title> Axiomatisation of "IF: : : THEN: : : ELSE" revisited. </title> <type> Technical Report 84-18, </type> <institution> Laboratoire Informatique Theorique et Programmation, Universite P. et M. Curie, Paris, </institution> <month> April </month> <year> 1984. </year>
Reference-contexts: 1 Introduction One structuring technique which has emerged as particularly important in the development of sequential algorithms and software is the definition of abstract data types (ADTs). ADTs are defined formally using techniques which stem from the work of Goguen [4, 5, 6] and Guttag <ref> [7, 8] </ref>. These formal definitions take the form of axiomatic descriptions and amount to describing the behaviour of operations which manipulate the ADT. An example of the style of ADT specification used can be seen in Figure 1; this example presents an ADT specification for an infinite queue.
Reference: [8] <author> J.V. Guttag and J.J. Horning. </author> <title> The algebraic specification of abstract data types. </title> <journal> Acta Informatica, </journal> <volume> Volume 10, Number 1, </volume> <pages> pages 27-52, </pages> <year> 1978. </year>
Reference-contexts: 1 Introduction One structuring technique which has emerged as particularly important in the development of sequential algorithms and software is the definition of abstract data types (ADTs). ADTs are defined formally using techniques which stem from the work of Goguen [4, 5, 6] and Guttag <ref> [7, 8] </ref>. These formal definitions take the form of axiomatic descriptions and amount to describing the behaviour of operations which manipulate the ADT. An example of the style of ADT specification used can be seen in Figure 1; this example presents an ADT specification for an infinite queue.
Reference: [9] <author> C.A.R. Hoare. </author> <title> An axiomatic definition of the programming language Pascal. </title> <journal> Acta Informatica, </journal> <volume> Volume 2, Number 4, </volume> <pages> pages 335-355, </pages> <year> 1973. </year>
Reference-contexts: The envelope is another Ada package which essentially provides the same operations as the ADT. The private declaration section of the code shows that an SDA object is implemented as a reference to an ADT object and a protective monitor <ref> [9, 10] </ref> which enforces the rules for SDA integrity discussed earlier. generic type data is private; with function Copy (elem: in data) return data is &lt;&gt;; package sda queue is type queue type is private; type queue access is private; procedure Make Queue (result: in out queue access); Create a queue.
Reference: [10] <author> C.A.R. Hoare. </author> <title> Monitors: An operating system structuring concept. </title> <journal> Communications of the ACM, </journal> <volume> Volume 17, Number 10, </volume> <pages> pages 549-557, </pages> <month> October </month> <year> 1974. </year>
Reference-contexts: The envelope is another Ada package which essentially provides the same operations as the ADT. The private declaration section of the code shows that an SDA object is implemented as a reference to an ADT object and a protective monitor <ref> [9, 10] </ref> which enforces the rules for SDA integrity discussed earlier. generic type data is private; with function Copy (elem: in data) return data is &lt;&gt;; package sda queue is type queue type is private; type queue access is private; procedure Make Queue (result: in out queue access); Create a queue.
Reference: [11] <author> B.H. Liskov, R. Atkinson, T. Bloom, E. Moss, J.C. Schaffert, R. Scheifler and A. Synder. </author> <title> CLU Reference Manual, </title> <booktitle> Volume 114 of Lecture Notes in Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1981. </year>
Reference-contexts: The axiomatic definition of ADTs is useful in the design and development of large systems; such definitions permit designers to reason about, and verify, data type definitions and their behaviour. The implementation of ADTs with language constructs such as Modula-2 modules [20], Ada packages and CLU clusters <ref> [11, 12] </ref> allows for the reusability of the type definitions represented by the ADT implementations and hence helps to reduce software costs. This paper will use Ada as the vehicle to illustrate the process of converting data types designed for a sequential environment for use within a parallel environment.
Reference: [12] <author> B.H. Liskov, A. Snyder, R. Atkinson and C. Schaffert. </author> <title> Abstraction mechanisms in CLU. </title> <journal> Communications of the ACM, </journal> <volume> Volume 20, Number 8, </volume> <pages> pages 564-576, </pages> <year> 1977. </year>
Reference-contexts: The axiomatic definition of ADTs is useful in the design and development of large systems; such definitions permit designers to reason about, and verify, data type definitions and their behaviour. The implementation of ADTs with language constructs such as Modula-2 modules [20], Ada packages and CLU clusters <ref> [11, 12] </ref> allows for the reusability of the type definitions represented by the ADT implementations and hence helps to reduce software costs. This paper will use Ada as the vehicle to illustrate the process of converting data types designed for a sequential environment for use within a parallel environment.
Reference: [13] <author> W.R. Mallgren. </author> <title> Formal specification of graphic data types. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> Volume 4, Number 4, </volume> <pages> pages 687-710, </pages> <month> October </month> <year> 1982. </year>
Reference-contexts: Approaches to the definition of an abstract data type, and the control of concurrent access to it, have been described elsewhere. One such approach, known as shared data abstractions (SDAs), is that advocated by Mallgren <ref> [13, 14] </ref> and used by Freidel to describe parallel languages [3, 15]. <p> Section 4 gives an example of the use of an ADT after it has been transformed into a form suitable for use within a parallel environment. Finally, some conclusions are presented in Section 5. 2 Mallgren's Approach to SDA's The shared data abstractions (SDAs) introduced by Mallgren <ref> [13, 14] </ref>, offer a way to specify the synchronization of concurrent accesses to a shared object within an algebraic framework. Thus, Mallgren's SDA specifications form the parallel programming environment equivalent to the formal ADT specifications used in sequential programming environments. Mallgren's approach introduces characteristic functions to protect the data type.
Reference: [14] <author> W.R. Mallgren. </author> <title> Formal Specification of Interactive Graphics Programming Languages. </title> <publisher> MIT Press, </publisher> <address> Cambridge, Massachusetts, </address> <year> 1983. </year>
Reference-contexts: Approaches to the definition of an abstract data type, and the control of concurrent access to it, have been described elsewhere. One such approach, known as shared data abstractions (SDAs), is that advocated by Mallgren <ref> [13, 14] </ref> and used by Freidel to describe parallel languages [3, 15]. <p> Section 4 gives an example of the use of an ADT after it has been transformed into a form suitable for use within a parallel environment. Finally, some conclusions are presented in Section 5. 2 Mallgren's Approach to SDA's The shared data abstractions (SDAs) introduced by Mallgren <ref> [13, 14] </ref>, offer a way to specify the synchronization of concurrent accesses to a shared object within an algebraic framework. Thus, Mallgren's SDA specifications form the parallel programming environment equivalent to the formal ADT specifications used in sequential programming environments. Mallgren's approach introduces characteristic functions to protect the data type.
Reference: [15] <author> C.D. Marlin, M.J. Oudshoorn and D.H. Freidel. </author> <title> A model of communication in Ada using shared data abstractions. </title> <editor> In S.G. Aki, F. Fiala and W.W. Koczkodaj (editors), </editor> <booktitle> Advances in Computing and Information - ICCI'90, </booktitle> <pages> pages 443-452. </pages> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1990. </year> <booktitle> Volume 468 of Lecture Notes in Computer Science. </booktitle>
Reference-contexts: Approaches to the definition of an abstract data type, and the control of concurrent access to it, have been described elsewhere. One such approach, known as shared data abstractions (SDAs), is that advocated by Mallgren [13, 14] and used by Freidel to describe parallel languages <ref> [3, 15] </ref>. The drawback of this technique, which is discussed in more depth in Section 2, is that the details of the data type's behaviour and the details governing access to the data type by any process are merged together rather than separated. <p> This method was developed as part of an ongoing project to generate language implementations from descriptions of programming language semantics based on algebraic specifications of abstract data types <ref> [15, 16, 17, 18] </ref>. The method described here has been used within this project to produce SDAs for use in the implementation of parallel programming languages.
Reference: [16] <author> M.J. Oudshoorn and C.D. Marlin. </author> <title> Language definition and implementation. </title> <journal> Australian Computer Science Communications, </journal> <volume> Volume 11, Number 1, </volume> <pages> pages 26-36, </pages> <month> February </month> <year> 1989. </year>
Reference-contexts: This method was developed as part of an ongoing project to generate language implementations from descriptions of programming language semantics based on algebraic specifications of abstract data types <ref> [15, 16, 17, 18] </ref>. The method described here has been used within this project to produce SDAs for use in the implementation of parallel programming languages.
Reference: [17] <author> M.J. Oudshoorn and C.D. Marlin. </author> <title> Describing the semantics of parallel programming languages using shared data abstractions. </title> <type> Technical Report 91-03, </type> <institution> Department of Computer Science, The University of Adelaide, Adelaide, South Australia, </institution> <month> May </month> <year> 1991. </year>
Reference-contexts: These constructs allow the clear, precise and accurate description of the algorithms needed to manipulate SDA objects by solving the difficulties described above. Space constraints do not allow further discussion of these constructs here; the interested reader is referred to <ref> [17] </ref>. The constructs can be translated into Ada through the use of a preprocessor, and simply relieve the algorithm designer of much tedium and housekeeping, allowing full concentration to be given to the development of a parallel algorithm. <p> This method was developed as part of an ongoing project to generate language implementations from descriptions of programming language semantics based on algebraic specifications of abstract data types <ref> [15, 16, 17, 18] </ref>. The method described here has been used within this project to produce SDAs for use in the implementation of parallel programming languages.
Reference: [18] <author> M.J. Oudshoorn and C.D. Marlin. </author> <title> A layered, operational model of data control in programming languages. </title> <journal> Computer Languages, </journal> <volume> Volume 16, Number 2, </volume> <pages> pages 147-165, </pages> <year> 1991. </year>
Reference-contexts: This method was developed as part of an ongoing project to generate language implementations from descriptions of programming language semantics based on algebraic specifications of abstract data types <ref> [15, 16, 17, 18] </ref>. The method described here has been used within this project to produce SDAs for use in the implementation of parallel programming languages.
Reference: [19] <author> U.S. </author> <title> Department of Defense. The Programming Language Ada Reference Manual, </title> <institution> ANSI/MIL-STD-1815A-1983. United States Department of Defense, </institution> <address> Washington, D.C., </address> <year> 1983. </year>
Reference-contexts: ADTs defined in an axiomatic manner can readily be translated into an implementation through many language constructs such as Ada's package facility <ref> [19] </ref>. The Ada package specification corresponding to the ADT given in each operation specified in Figure 1 has a corresponding function, set of arguments and result type in Figure 2. <p> Ada was chosen because it separates the specification of the ADT from its implementation details; this facilitates the process of experimenting with data structure representations and the corresponding algorithms. Ada was also chosen because it has a well-known definition <ref> [19] </ref> and is, as a result, a more portable language than many others. However, the technique described in this paper may be adapted to suit any language providing suitable support for ADTs.
Reference: [20] <author> N. Wirth. </author> <title> Programming in Modula-2. </title> <publisher> Springer-Verlag, </publisher> <address> Berlin, third, corrected edition, </address> <year> 1985. </year>
Reference-contexts: The axiomatic definition of ADTs is useful in the design and development of large systems; such definitions permit designers to reason about, and verify, data type definitions and their behaviour. The implementation of ADTs with language constructs such as Modula-2 modules <ref> [20] </ref>, Ada packages and CLU clusters [11, 12] allows for the reusability of the type definitions represented by the ADT implementations and hence helps to reduce software costs.
References-found: 20

