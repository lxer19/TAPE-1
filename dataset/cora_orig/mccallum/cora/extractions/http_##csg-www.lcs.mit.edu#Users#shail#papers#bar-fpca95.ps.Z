URL: http://csg-www.lcs.mit.edu/Users/shail/papers/bar-fpca95.ps.Z
Refering-URL: http://csg-www.lcs.mit.edu:8001/pH/
Root-URL: 
Email: fshail,arvindg@lcs.mit.edu  joe.stoy@comlab.ox.ac.uk  
Title: Semantics of Barriers in a Non-Strict, Implicitly-Parallel Language Computation Structures Group  
Author: Shail Aditya Arvind Joseph E. Stoy 
Note: To appear in the ACM Conference on Functional Programming Languages and Computer Architecture, La Jolla, California, June 26-28, 1995.  
Affiliation: MIT Laboratory for Computer Science  Oxford University Computing Laboratory  
Date: January 12, 1995 Revised April 2, 1995  
Pubnum: Memo 367-1  
Abstract: The research described in this paper was funded in part by the Advanced Research Projects Agency of the Department of Defense under Office of Naval Research con tract N00014-92-J-1310. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Zena M. Ariola and Arvind. P-TAC: </author> <title> A Parallel Intermediate Language. </title> <booktitle> In Proc. Functional Programming Languages and Computer Architecture, </booktitle> <month> Septem-ber </month> <year> 1989. </year>
Reference-contexts: From now on we will use the term Value Semantics to refer to the result of a computation, and Termination Semantics to identify its termination 2 . Semantically, a given computation may give rise to one of the following possible outcomes <ref> [1] </ref>: 1. Result with proper Termination | The compu tation produces a result and terminates. 2. Result with improper Termination | The computation produces a result but does not terminate.
Reference: [2] <author> Zena M. Ariola and Arvind. </author> <title> A Syntactic Approach to Program Transformations. </title> <booktitle> In Proc. Partial Evaluation and Semantics-Based Program Manipulation, </booktitle> <pages> pages 116-129. </pages> <publisher> ACM Press, </publisher> <month> September </month> <year> 1991. </year>
Reference-contexts: A natural question is when should this translation be performed within the compiler: should we do it before or after other program transformations such as -lifting or pattern-matching? Moreover, most of the rewrite rules (Figure 5) and the canonicalization rules (Figure 6) may be used at compile-time as compiler optimizations <ref> [2] </ref>. We may even want to postpone the barrier translation until after the optimization phase because the translation increases the complexity of the program. Does it matter (semantically) when this translation is performed? 6.1 Canonicalization vs.
Reference: [3] <author> Zena M. Ariola and Arvind. </author> <title> Properties of a First-order Functional Language with Sharing. </title> <type> CSG Memo 347-1, </type> <institution> Laboratory for Computer Science, MIT, </institution> <address> Cambridge, MA 02139, </address> <month> June </month> <year> 1994. </year> <note> To appear in Theoretical Computer Science, </note> <month> September </month> <year> 1995. </year>
Reference-contexts: The first such attempt was made in [15], both in terms of CSP [7] and (for the functional layer) denotationally. This paper presents a different formalization in terms of graph rewriting systems previously used to describe the semantics of Id <ref> [3] </ref>. The rest of the paper is organized as follows. In Section 2 we discuss some important characteristics of non-strict, eager computations in Id and pH and introduce the concept of control regions and barriers. <p> For example, the activation tree in Figure 1 shows the dynamic 3 The fourth possibility, of proper termination but without producing a result, is not considered to be meaningful and is lumped with the third outcome. Some graph-reduction based semantic definitions <ref> [3] </ref> do, however, distinguish between these two cases. nesting of function control regions. Similarly, each of the branches of a conditional expression forms a control region that is statically nested inside the enclosing region. <p> We also use a primitive operator & that combines two signals to produce a single signal. 4.3 Rewriting Semantics intermediate identifiers in order to preserve sharing of sub-expressions. This system therefore represents a Graph Rewriting System <ref> [3] </ref>. The semantic function W is used to define the W operator (the WHNF rule) as well as to express additional conditions under which other rewrite rules apply.
Reference: [4] <author> Arvind, Rishiyur S. Nikhil, and Keshav K. Pingali. I-Structures: </author> <title> Data Structures for Parallel Computing. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 11(4) </volume> <pages> 598-632, </pages> <year> 1989. </year>
Reference-contexts: This allows the specification of a partial order among the various tasks while providing fine-grain control over inter-task synchronization, resource usage and scheduling of side-effects. Id and pH support imperative operations on I-structure <ref> [4] </ref> and M-structure [6] objects. I-structures allow the creation of a data structure to be separated from the definition of its components: attempts to use the value of a component are automatically delayed until that component is defined; attempts to redefine a component lead to an inconsistent state.
Reference: [5] <author> Paul S. Barth. </author> <title> Atomic Data Structures for Parallel Computing. </title> <type> PhD thesis, </type> <institution> Laboratory for Computer Science, MIT, </institution> <address> Cambridge, MA 02139, </address> <month> March </month> <year> 1992. </year> <note> Available as Technical Report MIT/LCS/TR-532. </note>
Reference-contexts: Barriers were introduced in Id to provide partial sequencing of M-structure operations. However, their semantics were not given precisely at that stage <ref> [5] </ref>. Subsequently, pH was designed to follow the syntax and the type structure of Haskell [8] combined with the eager evaluation model and the non-functional extensions of Id. This prompted a formalization of barrier semantics for both Id and pH.
Reference: [6] <author> Paul S. Barth, Rishiyur S. Nikhil, and Arvind. M-Structures: </author> <title> Extending a Parallel, Non-Strict, Functional Language with State. </title> <booktitle> In Proc. Functional Programming Languages and Computer Architecture, </booktitle> <pages> pages 538-568. </pages> <publisher> Springer-Verlag, </publisher> <year> 1991. </year> <note> LNCS 523. </note>
Reference-contexts: This allows the specification of a partial order among the various tasks while providing fine-grain control over inter-task synchronization, resource usage and scheduling of side-effects. Id and pH support imperative operations on I-structure [4] and M-structure <ref> [6] </ref> objects. I-structures allow the creation of a data structure to be separated from the definition of its components: attempts to use the value of a component are automatically delayed until that component is defined; attempts to redefine a component lead to an inconsistent state.
Reference: [7] <author> C.A.R. Hoare. </author> <title> Communicating Sequential Processes. </title> <publisher> Prentice Hall International Series in Computer Science. Prentice Hall, </publisher> <address> Englewood Cliffs, NJ, </address> <year> 1985. </year>
Reference-contexts: This prompted a formalization of barrier semantics for both Id and pH. The first such attempt was made in [15], both in terms of CSP <ref> [7] </ref> and (for the functional layer) denotationally. This paper presents a different formalization in terms of graph rewriting systems previously used to describe the semantics of Id [3]. The rest of the paper is organized as follows.
Reference: [8] <editor> P. Hudak and P. Wadler (editors). </editor> <title> Report on the programming language Haskell, a non-strict purely functional language (Version 1.0). </title> <type> Technical Report YALEU/DCS/RR777, </type> <institution> Department of Computer Science, Yale University, </institution> <month> April </month> <year> 1990. </year>
Reference-contexts: Barriers were introduced in Id to provide partial sequencing of M-structure operations. However, their semantics were not given precisely at that stage [5]. Subsequently, pH was designed to follow the syntax and the type structure of Haskell <ref> [8] </ref> combined with the eager evaluation model and the non-functional extensions of Id. This prompted a formalization of barrier semantics for both Id and pH. The first such attempt was made in [15], both in terms of CSP [7] and (for the functional layer) denotationally.
Reference: [9] <author> Paul Hudak. </author> <title> Mutable Abstract Datatypes -or- How to Have Your State and Munge It Too. </title> <institution> Research Report YALEU/DCS/RR-914, Department of Computer Science, Yale University, </institution> <address> New Haven, CT 06520, </address> <month> De-cember </month> <year> 1992. </year> <month> Revised May </month> <year> 1993. </year>
Reference-contexts: ; : : : ; S n j * par par S ::= Binding j Command j S seq Binding ::= x 1 ; : : : ; x n = E Command ::= I-store (X; I; Z) j M-put (X; I; Z) monads, continuations, abstract datatypes, or state transformers <ref> [9, 11, 14] </ref>. In Id, on the other hand, such objects are represented explicitly using M-structures, and access to them is controlled using locks and barriers that provide mutual exclusion and explicit sequentialization as necessary.
Reference: [10] <author> Thomas Johnsson. </author> <title> Lambda Lifting: Transforming Programs to Recursive Equations. </title> <booktitle> In Proc. Functional Programming Languages and Computer Architecture, </booktitle> <pages> pages 190-203. </pages> <publisher> Springer-Verlag, </publisher> <year> 1985. </year> <note> LNCS 201. </note>
Reference-contexts: Optimizing general applications Ap to partial applications Pap would introduce new free identifiers into a control region that would not be present if the optimization had been performed after barrier translation. Another program transformation that changes the set of free identifiers of a control region is -lifting <ref> [10] </ref>. - lifting converts free identifiers of a function into additional parameters and then lifts the functions to the top-level as combinators. All occurrences of the lifted function identifier are replaced by partial applications of the transformed function to its previously free identifiers.
Reference: [11] <author> John Launchbury and Simon L. Peyton Jones. </author> <title> Lazy Functional State Threads. </title> <booktitle> In Proc. Programming Language Design and Implementation, </booktitle> <pages> pages 24-35. </pages> <publisher> ACM Press, </publisher> <month> June </month> <year> 1994. </year>
Reference-contexts: ; : : : ; S n j * par par S ::= Binding j Command j S seq Binding ::= x 1 ; : : : ; x n = E Command ::= I-store (X; I; Z) j M-put (X; I; Z) monads, continuations, abstract datatypes, or state transformers <ref> [9, 11, 14] </ref>. In Id, on the other hand, such objects are represented explicitly using M-structures, and access to them is controlled using locks and barriers that provide mutual exclusion and explicit sequentialization as necessary.
Reference: [12] <author> Rishiyur S. Nikhil. </author> <title> Id Language Reference Manual Version 90.1. </title> <type> Technical Report CSG Memo 284-2, </type> <institution> Laboratory for Computer Science, MIT, </institution> <address> Cambridge, MA 02139, </address> <month> July 15 </month> <year> 1991. </year>
Reference-contexts: However, it is possible to specify only a partial order on side-effects and still retain an overall consistent picture of the computation. This paper studies the use and the semantics of barriers as a partial sequentializa-tion construct in Id <ref> [12] </ref> and pH [13], which are non-strict, implicitly-parallel, functional languages extended with side-effects. The traditional view of barriers comes from data-parallel languages such as *Lisp and CM-Fortran, where concurrently executing copies of the same program periodically synchronize using a global barrier mechanism. <p> Result with improper Termination | The computation produces a result but does not terminate. The non-termination could be either due to an infinite computation or due to a deadlocked computation. 1 All our examples use the Id syntax <ref> [12] </ref>. <p> In Id, on the other hand, such objects are represented explicitly using M-structures, and access to them is controlled using locks and barriers that provide mutual exclusion and explicit sequentialization as necessary. For instance, currently there exist two I/O libraries in Id, sequential I/O [16] and threaded I/O <ref> [12] </ref>, both of which crucially rely on barriers for proper sequentialization. 4 A Kernel Language In this section we provide a framework for discussing the semantics of barriers.
Reference: [13] <author> Rishiyur S. Nikhil, Arvind, James Hicks, Shail Aditya, Lennart Augustsson, Jan-Willem Maessen, and Yuli Zhou. </author> <title> pH Language Reference Manual, </title> <note> Version 1.0| preliminary. CSG Memo 369, </note> <institution> Laboratory for Computer Science, MIT, </institution> <address> Cambridge, MA 02139, </address> <month> January </month> <year> 1995. </year>
Reference-contexts: However, it is possible to specify only a partial order on side-effects and still retain an overall consistent picture of the computation. This paper studies the use and the semantics of barriers as a partial sequentializa-tion construct in Id [12] and pH <ref> [13] </ref>, which are non-strict, implicitly-parallel, functional languages extended with side-effects. The traditional view of barriers comes from data-parallel languages such as *Lisp and CM-Fortran, where concurrently executing copies of the same program periodically synchronize using a global barrier mechanism.
Reference: [14] <editor> Simon L. Peyton Jones and Philip Wadler. </editor> <title> Imperative Functional Programming. </title> <booktitle> In Proc. Principles of Programming Languages, </booktitle> <pages> pages 71-84. </pages> <publisher> ACM Press, </publisher> <month> Jan-uary </month> <year> 1993. </year>
Reference-contexts: ; : : : ; S n j * par par S ::= Binding j Command j S seq Binding ::= x 1 ; : : : ; x n = E Command ::= I-store (X; I; Z) j M-put (X; I; Z) monads, continuations, abstract datatypes, or state transformers <ref> [9, 11, 14] </ref>. In Id, on the other hand, such objects are represented explicitly using M-structures, and access to them is controlled using locks and barriers that provide mutual exclusion and explicit sequentialization as necessary.
Reference: [15] <author> J.E. Stoy. </author> <title> The Semantics of Id. In A.W. Roscoe, editor, </title>
Reference-contexts: Subsequently, pH was designed to follow the syntax and the type structure of Haskell [8] combined with the eager evaluation model and the non-functional extensions of Id. This prompted a formalization of barrier semantics for both Id and pH. The first such attempt was made in <ref> [15] </ref>, both in terms of CSP [7] and (for the functional layer) denotationally. This paper presents a different formalization in terms of graph rewriting systems previously used to describe the semantics of Id [3]. The rest of the paper is organized as follows. <p> In Id, def introduces function definitions, colon (:) is the infix list constructor, and block expressions (enclosed in f g) evaluate the expression following in within the scope of a set of parallel bindings. 2 These correspond to what were called non-strict and strict se mantics, respectively, in <ref> [15] </ref>. 2 3. No Result or Termination | The computation does not produce a result and does not terminate. Again, the non-termination could be due to infinite computation or deadlock 3 .
References-found: 15

