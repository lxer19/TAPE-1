URL: ftp://ftp.cs.cmu.edu/project/mach/doc/published/threads87.ps
Refering-URL: http://c.gp.cs.cmu.edu:5103/afs/cs/project/mach/public/www/doc/publications.html
Root-URL: 
Title: Mach Threads and the Unix Kernel: The Battle for Control  
Author: Avadis Tevanian, Jr., Richard F. Rashid, David B. Golub, David L. Black, Eric Cooper and Michael W. Young. 
Address: Pittsburgh, PA 15213  
Affiliation: Department of Computer Science Carnegie-Mellon University  
Abstract:  
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Mike Accetta, Robert Baron, William Bolosky, David Golub, Richard Rashid, Avadis Tevanian, Michael Young. </author> <title> Mach: A New Kernel Foundation for UNIX Development. </title> <booktitle> In Proceedings of Summer Usenix. </booktitle> <month> July, </month> <year> 1986. </year>
Reference-contexts: A thread package could provide an attractive way to take advantage of the parallelism afforded by tightly-coupled shared memory multiprocessors. This paper examines a kernel-implemented thread facility built for the Mach operating system <ref> [1] </ref>. The pros and cons of such a mechanism are discussed along with the problems encountered during its implementation. 2. Kernel Implemented Threads vs. Coroutines Some of the advantages of lightweight processes can be achieved by out-of-kernel solutions, but often at the expense of either preemption or parallelism. <p> The Mach kernel does not enforce a synchronization model. Instead, it provides basic primitives upon which different models of synchronization may be built. One form such synchronization could take would be the Mach IPC facility <ref> [1] </ref>. Should an application desire its own thread-level synchronization, it can use the suspend, resume and wait primitives.
Reference: [2] <author> D. R. Cheriton, M. A. Malcolm, L. S. Melen, and G. R. Sager. Thoth, </author> <title> a Portable Real-Time Operating System. </title> <journal> Communications of the ACM :105-115, </journal> <month> February, </month> <year> 1979. </year>
Reference-contexts: In fact, the lack of kernel support has caused Unix programmers to implement a variety of coroutine packages to support multi-stack applications. Lightweight threads of control can allow a programmer to encapsulate computations with their stack state and thus achieve greater modularity. Research systems, such as THOTH <ref> [2] </ref> and its successor, Stanford's V Kernel [3], have shown that multiple threads of control within a single process can be an especially important tool for writing server applications. A thread package could provide an attractive way to take advantage of the parallelism afforded by tightly-coupled shared memory multiprocessors.
Reference: [3] <author> D. R. Cheriton and W. Zwaenepoel. </author> <title> The Distributed V Kernel and its Performance for Diskless Workstations. </title> <booktitle> In Proceedings of the 9th Symposium on Operating System Principles, </booktitle> <pages> pages 128-139. </pages> <publisher> ACM, </publisher> <month> October, </month> <year> 1983. </year>
Reference-contexts: Lightweight threads of control can allow a programmer to encapsulate computations with their stack state and thus achieve greater modularity. Research systems, such as THOTH [2] and its successor, Stanford's V Kernel <ref> [3] </ref>, have shown that multiple threads of control within a single process can be an especially important tool for writing server applications. A thread package could provide an attractive way to take advantage of the parallelism afforded by tightly-coupled shared memory multiprocessors.
Reference: [4] <institution> Sequent Computer Systems, Inc. Dynix Programmer's Manual Sequent Computer Systems, Inc., </institution> <year> 1986. </year>
Reference-contexts: Two approaches are common: multi-process shared memory implementations and single process coroutines. Parallel execution can be achieved with multiple processes in conjunction with some kind of shared memory facility. For example, in Dynix <ref> [4] </ref> users can allocate a number of processes equal to the number of processors and effectively manage shared computations through an mmaped region of shared memory. Similar tricks allow programmers to build multiprocessor applications using Encore's UMAX [5] operating system.
Reference: [5] <institution> Encore Computer Corporation. UMAX 4.2 Programmer's Reference Manual Encore Computer Corporation, </institution> <year> 1986. </year>
Reference-contexts: For example, in Dynix [4] users can allocate a number of processes equal to the number of processors and effectively manage shared computations through an mmaped region of shared memory. Similar tricks allow programmers to build multiprocessor applications using Encore's UMAX <ref> [5] </ref> operating system. Typically such systems amount to a second layer of scheduling similar to that used within the operating system itself. A significant advantage of coroutine packages is that they can significantly reduce the costs of multi-thread management or at least isolate them within a user process.
Reference: [6] <author> Lampson, B.W. </author> <title> and D.D. Redell. Experience with Processes and Monitors in Mesa. </title> <journal> Communications of the ACM 23(2) </journal> <pages> 105-113, </pages> <month> February, </month> <year> 1980. </year> <title> 12 Table of Contents 1. Introduction 0 2. Kernel Implemented Threads vs. Coroutines 1 3. Mach Task and Thread Primitives 1 4. User Level Thread Synchronization 2 5. The C-Threads Package 4 6. The Effect of Threads on Unix Features 5 7. Implementation: Details, Problems and Issues 6 8. Performance Issues 8 9. Conclusion and Status 9 10. Acknowledgements 9 I. Thread Operations 10 II. Task Operations 11 i List of Tables Table 8-1: </title> <booktitle> 9 ii </booktitle>
Reference-contexts: One such high-level package for programming in C, called C-threads, has already been implemented. It provides a high level C interface to the low level thread primitives along with a collection of other mechanisms useful in various parallel programming paradigms (similar to those available in languages such as Mesa <ref> [6] </ref>). The C-Threads package provides multiple threads of control for parallelism, shared variables, mutual exclusion for critical sections and condition variables for synchronization of threads.
References-found: 6

