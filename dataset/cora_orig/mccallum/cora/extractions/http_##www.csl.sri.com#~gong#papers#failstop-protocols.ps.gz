URL: http://www.csl.sri.com/~gong/papers/failstop-protocols.ps.gz
Refering-URL: http://www.csl.sri.com/~gong/papers/pubs95.html
Root-URL: 
Title: Fail-Stop Protocols: An Approach to Designing Secure Protocols  
Author: Li Gong Paul Syverson 
Date: September 1995  
Note: To appear in Proceedings of IFIP DCCA-5, Illinois,  
Abstract: We present a methodology to facilitate the design and analysis of secure cryptographic protocols. We advocate the general approach, and a new avenue for research, of restricting protocol designs to well-defined practices, instead of ever increasing the complexity of protocol security analysis mechanisms to deal with every newly discovered attack and the endless variations in protocol construction. In particular, we propose a novel notion of a fail-stop protocol, which automatically halts in response to any active attack that interferes with protocol execution, thus reducing protocol security analysis to that of passive attacks only. We suggest types of protocols that are fail-stop, outline some proof techniques for them, and use examples to illustrate how the notion of a fail-stop protocol can make protocol design easier and can provide a more solid basis for some available protocol analysis methods. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> M. Abadi and R.M. Needham. </author> <title> Prudent Engineering Practice for Cryptographic Protocols. </title> <booktitle> In Proceedings of the IEEE Symposium on Research in Security and Privacy, </booktitle> <pages> pages 122-136, </pages> <address> California, </address> <month> May </month> <year> 1994. </year>
Reference-contexts: We assume that this correct encoding can and will be independently verified. Recently, Abadi and Needham collected a number of prudent engineering principles for designing authentication protocols <ref> [1] </ref>. The above specification of fail-stop protocols satisfies some of these principles. Requirements of robustness and explicitness [3] are related to similar ideas. We now give an example protocol that satisfies Claim 2 and is thus fail-stop.
Reference: [2] <author> M. Abadi and M. Tuttle. </author> <title> A Semantics for a logic for Authentication (Extended Abstract). </title> <booktitle> In Proceedings of the ACM Symposium of Principles of Distributed Computing, </booktitle> <pages> pages 201-216, </pages> <month> January </month> <year> 1991. </year>
Reference-contexts: The failure to find a vulnerability by such a method does not mean that the protocol is secure, but merely that certain lines of attack are less likely to succeed. Methods based on modal logic <ref> [6, 2] </ref>, on the other hand, seem more conclusive in that their aim is to produce a proof of protocol security by deducing that certain protocol goals are achieved. However, such methods generally make a number of assumptions, some of which cannot be justified by the methods themselves. <p> Thus the assumption cannot be used to derive the security of the protocol unless a separate mechanism can justify this assumption. None of the later published extensions of this logic resolves this difficulty. Some of these logics have a model-theoretic semantics <ref> [2, 33, 34] </ref> and can be 1 Abadi and Tuttle [2] in their new semantics of the logic of Burrows, Abadi, and Needham [6] relaxed this assumption by assuming instead that a secret can be leaked but whoever possesses it (maybe illegally) will not misuse it. <p> None of the later published extensions of this logic resolves this difficulty. Some of these logics have a model-theoretic semantics [2, 33, 34] and can be 1 Abadi and Tuttle <ref> [2] </ref> in their new semantics of the logic of Burrows, Abadi, and Needham [6] relaxed this assumption by assuming instead that a secret can be leaked but whoever possesses it (maybe illegally) will not misuse it. <p> Nevertheless, this protocol did raise the legitimate question of how to validate the secrecy assumption for any given protocol. Our concept of fail-stop protocol aims precisely to fill in this gap. Model theoretic semantics (e.g. <ref> [2] </ref>) was presented as an approach to examining protocol assumptions, including the secrecy assumption in this protocol [32]. Yet another attempt uses a notion called terminating protocols [29]. <p> Here, we will persist in the informal style of presentation that we have used throughout the paper. Claim 4 A protocol is extensible fail-stop if and only if it satisfies CCC. 7 These temporal additions [33] were made to AT <ref> [2] </ref>. They are equally compatible with SVO, which has the added feature of distinguishing the available messages from the received messages (following GNY). This makes for a more natural expression of the criterion, to be set out presently.
Reference: [3] <author> R.J. Anderson. </author> <title> Why Cryptosystems Fail. </title> <journal> Communications of the ACM, </journal> <volume> 37(11) </volume> <pages> 32-40, </pages> <month> November, </month> <year> 1994. </year>
Reference-contexts: We assume that this correct encoding can and will be independently verified. Recently, Abadi and Needham collected a number of prudent engineering principles for designing authentication protocols [1]. The above specification of fail-stop protocols satisfies some of these principles. Requirements of robustness and explicitness <ref> [3] </ref> are related to similar ideas. We now give an example protocol that satisfies Claim 2 and is thus fail-stop. Nonetheless, it still has design flaws that can be revealed by a BAN-like logic.
Reference: [4] <author> A.D. Birrell. </author> <title> Secure Communications Using Remote Procedure Calls. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 3(1) </volume> <pages> 1-14, </pages> <month> February </month> <year> 1985. </year>
Reference-contexts: 1 Background and Motivation In a distributed system, security depends heavily on the use of secure protocols such as authentication protocols (e.g., [22, 25]) and secure communication protocols (e.g., <ref> [4] </ref>). It is well known that such protocols can fail even if the underlying cryptosystems are sound and can have very subtle security flaws that are quite difficult to debug [6].
Reference: [5] <author> M. Burrows, M. Abadi, and R.M. Needham. </author> <title> A Logic for Authentication. </title> <type> Technical Report 39, </type> <institution> DEC System Research Center, Palo Alto, California, </institution> <month> February </month> <year> 1989. </year> <note> Revised version of February 22, </note> <year> 1990. </year>
Reference-contexts: As the late Christopher Strachey once remarked (retold by Roger Needham in his invited talk at ACM CCS-1, November 1993), one cannot foresee the consequences of being too clever. Nevertheless, examples have shown that guided optimizations can indeed identify and remove redundant data from messages <ref> [5] </ref>. Moreover, sometimes auxiliary data are sent in the clear. For example, the identity of the sender of an encrypted message is sent along when it helps the recipient to choose the correct key for decryption. <p> a protocol, this procedure can be applied only to fail-stop protocols, because in protocols that are not fail-stop, active attacks can be successful so that secrets can be leaked in ways not detectable by this procedure. 3.2 Example 2: the Wide-mouthed-frog Protocol Our second example is the wide-mouthed-frog pro tocol <ref> [5] </ref>. It proceeds as shown in Table 5. 1. <p> It is easy to see that this protocol satisfies the secrecy assumption since eavesdropping yields no secrets unless one possesses the keys shared between principals and server. A BAN analysis of this protocol showed that the protocol is secure <ref> [5, p. 26] </ref>. Our validation of the secrecy assumption puts that analysis on a much stronger footing. 3.3 Example 3: the Needham-Schroeder Public-Key Protocol Our third example is the Needham-Schroeder public-key protocol [22], and it works as shown in Table 6. <p> Even if we assume that the attacker is an insider, say A, we can still show that A cannot gain possession of B's private key. This protocol has been analyzed using the BAN logic <ref> [5, p.33] </ref>. 4 Generalization to Fail-Safe Protocols Many protocols, such as the one just discussed, contain messages composed entirely of cleartext. Without changing this feature it is impossible to make such a protocol fail-stop. Other protocols may even have essential features that are incompatible with being fail-stop. <p> The key certificates sent by the server contain nothing to indicate that they have been sent recently or as part of the protocol run. Thus an attacker is not prevented from substituting outdated certificates, which possibly containing outdated keys. When this was first observed <ref> [5] </ref>, it was suggested that the certificates in messages 2 and 5 include timestamps. But, if timestamps are available, an online server is unnecessary in most instances: principals can simply hold their own certificates, and the timestamp can be used to determine if the certificate is still valid.
Reference: [6] <author> M. Burrows, M. Abadi, and R.M. Needham. </author> <title> A Logic for Authentication. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 8(1) </volume> <pages> 18-36, </pages> <month> February </month> <year> 1990. </year>
Reference-contexts: It is well known that such protocols can fail even if the underlying cryptosystems are sound and can have very subtle security flaws that are quite difficult to debug <ref> [6] </ref>. In fact, the protocol security problem is undecidable in that, given any protocol analyzer, there are protocols whose security the analyzer cannot decide. <p> Recent years have seen notable efforts devoted to developing methods theories, logics, formal methods, and tools to facilitate the analysis of the security of cryptographic protocols (e.g., <ref> [9, 6, 19] </ref>). Although these results are significant, they also have limitations. fl SRI International, Computer Science Laboratory, Menlo Park, California 94025, U.S.A. Email at gong@csl.sri.com. y Center for High Assurance Computer Systems, Naval Research Laboratory, Washington, DC 20375, U.S.A. Email at syverson@itd.nrl.navy.mil. <p> The failure to find a vulnerability by such a method does not mean that the protocol is secure, but merely that certain lines of attack are less likely to succeed. Methods based on modal logic <ref> [6, 2] </ref>, on the other hand, seem more conclusive in that their aim is to produce a proof of protocol security by deducing that certain protocol goals are achieved. However, such methods generally make a number of assumptions, some of which cannot be justified by the methods themselves. <p> None of the later published extensions of this logic resolves this difficulty. Some of these logics have a model-theoretic semantics [2, 33, 34] and can be 1 Abadi and Tuttle [2] in their new semantics of the logic of Burrows, Abadi, and Needham <ref> [6] </ref> relaxed this assumption by assuming instead that a secret can be leaked but whoever possesses it (maybe illegally) will not misuse it. <p> Here a freshness identifier can be a timestamp (if clocks are assumed to be securely and reliably synchronized) or a nonce issued by the intended recipient. When a freshness identifier takes on a more complicated form, the rules for reasoning about freshness <ref> [6, 14] </ref> can be used to determine if the identifier is fresh with regard to the recipient. Basically, if x is deemed fresh and y cannot be computed (in a computationally feasible way) by someone without the knowledge of x, then y is also deemed fresh [14].
Reference: [7] <author> M. Burrows, M. Abadi, and R.M. Needham. </author> <title> Rejoinder to Nessett. </title> <journal> ACM Operating Systems Review, </journal> <volume> 24(2) </volume> <pages> 39-40, </pages> <month> April </month> <year> 1990. </year>
Reference-contexts: Nessett raised the difficulty with this assumption of secrecy [24], no satisfactory answer could be provided, although it is probably unfair to say that the logic of Burrows, Abadi, and Needham (the BAN logic) is flawed because the logic's scope is explicitly defined not to handle the issue of secrecy <ref> [7] </ref>. Nevertheless, this secrecy assumption is paradoxical in that whether a secret can remain secret may depend crucially on whether the protocol is secure. Thus the assumption cannot be used to derive the security of the protocol unless a separate mechanism can justify this assumption.
Reference: [8] <author> W. Diffie and M.E. Hellman. </author> <title> New Directions in Cryptography. </title> <journal> IEEE Transactions on Information Theory, </journal> <volume> IT-22(6):644-65, </volume> <month> November </month> <year> 1976. </year>
Reference-contexts: However, such analysis is not formal, and to guarantee that it is comprehensive would seem to involve methods as intensive as those mentioned above [19]. An earlier work by Dolev and Yao [9] proved that protocols using public-key cryptosystems <ref> [8] </ref> and having certain very rigid structures can automatically satisfy the secrecy assumption. However, the restrictions on the protocols are so strict for instance, one can only append to a message that the results are not widely applicable.
Reference: [9] <author> D. Dolev and A.C. Yao. </author> <title> On the Security of Public Key Protocols. </title> <journal> IEEE Transactions on Information Theory, </journal> <volume> IT-29(2):198-208, </volume> <month> March </month> <year> 1983. </year>
Reference-contexts: Recent years have seen notable efforts devoted to developing methods theories, logics, formal methods, and tools to facilitate the analysis of the security of cryptographic protocols (e.g., <ref> [9, 6, 19] </ref>). Although these results are significant, they also have limitations. fl SRI International, Computer Science Laboratory, Menlo Park, California 94025, U.S.A. Email at gong@csl.sri.com. y Center for High Assurance Computer Systems, Naval Research Laboratory, Washington, DC 20375, U.S.A. Email at syverson@itd.nrl.navy.mil. <p> However, such analysis is not formal, and to guarantee that it is comprehensive would seem to involve methods as intensive as those mentioned above [19]. An earlier work by Dolev and Yao <ref> [9] </ref> proved that protocols using public-key cryptosystems [8] and having certain very rigid structures can automatically satisfy the secrecy assumption. However, the restrictions on the protocols are so strict for instance, one can only append to a message that the results are not widely applicable.
Reference: [10] <author> L. Gong. </author> <title> Thoughts on Cryptographic Protocols. Talk at the Cambridge Workshop on the Design, Verification, and Implementation of Security Protocols, </title> <address> Cam-bridge, England, </address> <month> April </month> <year> 1993. </year>
Reference: [11] <author> L. Gong. </author> <title> Initial Thought on Secure Protocols Interaction. Talk at the Cambridge Workshop on the Design, Verification, and Implementation of Security Protocols, </title> <address> Cambridge, England, </address> <month> April </month> <year> 1994. </year>
Reference-contexts: Therefore, another crucial question is whether the deployment of one protocol invalidates the security conditions and claims of another, possibly in such a way that both protocols need to be modified in order to coexist securely <ref> [11] </ref>. Unfortunately being a fail-stop protocol is not trivially composable. To see this, observe that any one message protocol is automatically fail-stop regardless of the message structure.
Reference: [12] <author> L. Gong. </author> <title> Fail-Stop Protocols: An Approach to Designing Secure Protocols. </title> <type> Technical Report SRI-CSL-94-14, </type> <institution> Computer Science Laboratory, SRI International, </institution> <address> Menlo Park, California, </address> <month> October </month> <year> 1994. </year>
Reference-contexts: This is analogous to converting protocols between various fault models [23]. Acknowledgements Fred Schneider of Cornell University gave early encouragement to clarify and develop the initial ideas of fail-stop protocols in the spring of 1992 <ref> [12] </ref>. Colleagues at the 1993 and 1994 Cambridge Workshops on Security Protocols gave useful feedbacks. Virgil Gligor of the University of Maryland and Catherine Meadows of the Naval Research Laboratory provided insightful comments on more recent drafts.
Reference: [13] <author> L. Gong, T.M.A. Lomas, R.M. Needham, and J.H. Saltzer. </author> <title> Protecting Poorly Chosen Secrets from Guessing Attacks. </title> <journal> IEEE Journal on Selected Areas in Communications, </journal> <volume> 11(5) </volume> <pages> 648-656, </pages> <month> June </month> <year> 1993. </year>
Reference-contexts: Our emphasis has been on protocol designs that are easily determined to be fail-stop or fail-safe. However, some protocols, such as those to protect poorly-chosen passwords from guessing attacks <ref> [13] </ref>, may have other requirements that conflict with some of the particular fail-stop requirements, e.g., those described in Claim 2.
Reference: [14] <author> L. Gong, R. Needham, and R. Yahalom. </author> <title> Reasoning about Belief in Cryptographic Protocols. </title> <booktitle> In Proceedings of the IEEE Symposium on Research in Security and Privacy, </booktitle> <pages> pages 234-248, </pages> <address> California, </address> <month> May </month> <year> 1990. </year>
Reference-contexts: They can also be dealt with by logics with more complicated constructs (e.g., <ref> [14] </ref>). <p> Here a freshness identifier can be a timestamp (if clocks are assumed to be securely and reliably synchronized) or a nonce issued by the intended recipient. When a freshness identifier takes on a more complicated form, the rules for reasoning about freshness <ref> [6, 14] </ref> can be used to determine if the identifier is fresh with regard to the recipient. Basically, if x is deemed fresh and y cannot be computed (in a computationally feasible way) by someone without the knowledge of x, then y is also deemed fresh [14]. <p> Basically, if x is deemed fresh and y cannot be computed (in a computationally feasible way) by someone without the knowledge of x, then y is also deemed fresh <ref> [14] </ref>. Note that a protocol consisting of two or more messages based entirely on nonces cannot be fail-stop because the first message cannot be fresh. We can extend the concept of fail-stop protocols to fail-safe protocols to better treat nonce-based protocols, as we discuss in Section 4. <p> Other systems might require these to be notationally distinguished. the key k. Such design errors, which can have serious security implications, have been found elsewhere by using BAN-like logics <ref> [14] </ref>. Fail-stop protocols using public-key systems can be similarly formulated. The only difference is in the encryption of the message. 2. Each message is signed by the sender's private key. The message can then be optionally encrypted under the public key of the recipient. <p> This question is related to that of the "state of knowledge" [21] in that we need to find out what information an attacker has gathered by recording the execution of a protocol. 3 The notion and rules of "possession" proposed by Gong, Needham, and Yahalom (the GNY logic <ref> [14] </ref>) can be applied directly for this purpose. Briefly, given a set of formulas (or data items) that an attacker is thought to possess (through recording or other means), possession rules can be used to derive all formulas the attacker can possess. <p> To check this assumption, we assume that the attacker can record both messages and can have access to A's public key k a (which is usually assumed to be public knowledge). Now we can use the possession rules <ref> [14] </ref> as follows.
Reference: [15] <author> N. Heintze and J.D. Tygar. </author> <title> A Model for Secure Protocols and Their Compositions. </title> <booktitle> In Proceedings of the IEEE Symposium on Research in Security and Privacy, </booktitle> <pages> pages 2-13, </pages> <address> Oakland, California, </address> <month> May </month> <year> 1994. </year>
Reference-contexts: For example, a complex protocol may use simpler protocols as building blocks, in which case an important question is whether we can reduce the analysis of the complex protocol to that of the building blocks in isolation <ref> [15] </ref>. Moreover, a protocol is usually designed and implemented, and its security analyzed, independently of other protocols.
Reference: [16] <author> C.A.R. Hoare. </author> <title> Communicating Sequential Processes. </title> <publisher> Prentice-Hall, </publisher> <address> London, </address> <year> 1985. </year>
Reference-contexts: If being fail-stop were a composable property, then a simple induction would show that all protocols of any length composed of any messages from anyone to anyone are fail-stop. Fortunately it is easy to define an extensible fail-stop protocol property that is sequentially and parallelly composable <ref> [16] </ref>. Definition 2 (Extensible Fail-Stop Protocol) In a given protocol, we call a message "last" if no message in the protocol is causally after that message. A protocol is extensible fail-stop if adding any last message to the protocol results in a fail-stop protocol.
Reference: [17] <author> C.B. Jones. </author> <title> The Search for Tractable Ways of Reasoning about Programs. </title> <type> Technical Report UMCS-92-4-4, </type> <institution> Department of Computer Science, University of Manchester, </institution> <address> England, </address> <month> March </month> <year> 1992. </year>
Reference-contexts: From another angle, just as algorithms or programs should be designed for their correctness to be easily proven <ref> [17, 26] </ref>, security protocols should be designed so that their security can be proven with relative ease.
Reference: [18] <author> R. Kailar, V.D. Gligor, and L. Gong. </author> <title> On the Security Effectiveness of Cryptographic Protocols. </title> <booktitle> In Proceedings of the 4th IFIP Working Conference on Dependable Computing for Critical Applications, volume 9 of Dependable Computing and Fault-Tolerant Systems, </booktitle> <pages> pages 139-157, </pages> <address> San Diego, California, </address> <month> January </month> <year> 1994. </year>
Reference-contexts: Therefore, when a protocol is claimed to be secure, the claim is implicitly against an assumed set of threats and is often dependent on implicit assumptions about the nature of protocols or messages that may be violated in the presence of an unforeseen type of attack <ref> [18] </ref>. In the rest of this paper, we first define (albeit informally) fail-stop protocols. Then, we discuss how to analyze the security of such protocols. After that, we describe how to construct practical fail-stop protocols.
Reference: [19] <author> R. Kemmerer, C. Meadows, and J. Millen. </author> <title> Three Systems for Cryptographic Protocol Analysis. </title> <journal> Journal of Cryptology, </journal> <volume> 7(2) </volume> <pages> 79-130, </pages> <month> Spring </month> <year> 1994. </year>
Reference-contexts: Recent years have seen notable efforts devoted to developing methods theories, logics, formal methods, and tools to facilitate the analysis of the security of cryptographic protocols (e.g., <ref> [9, 6, 19] </ref>). Although these results are significant, they also have limitations. fl SRI International, Computer Science Laboratory, Menlo Park, California 94025, U.S.A. Email at gong@csl.sri.com. y Center for High Assurance Computer Systems, Naval Research Laboratory, Washington, DC 20375, U.S.A. Email at syverson@itd.nrl.navy.mil. <p> Email at gong@csl.sri.com. y Center for High Assurance Computer Systems, Naval Research Laboratory, Washington, DC 20375, U.S.A. Email at syverson@itd.nrl.navy.mil. Automated and semi-automated methods based on algebra and state transitions model protocols at a fairly detailed level <ref> [19] </ref>. This can make them difficult to apply and their application computationally intensive and intensive in human labor. Some of these methods are designed for searching out vulnerabilities rather than proving protocols secure. <p> However, such analysis is not formal, and to guarantee that it is comprehensive would seem to involve methods as intensive as those mentioned above <ref> [19] </ref>. An earlier work by Dolev and Yao [9] proved that protocols using public-key cryptosystems [8] and having certain very rigid structures can automatically satisfy the secrecy assumption. <p> To check whether such protocols are fail-stop, one possibility is to apply tools like the Interrogator or the NRL Protocol Analyzer <ref> [19] </ref> that can search backwards for the prerequisites of an action (e.g., sending a message); thus one direction for research is to investigate the integration of such methods within the methodology set out herein. Another research direction is to extend the classes of fail-stop and fail-safe protocols.
Reference: [20] <author> L. Lamport. </author> <title> Time, Clocks, and the Ordering of Events in a Distributed System. </title> <journal> Communications of the ACM, </journal> <volume> 21(7) </volume> <pages> 558-565, </pages> <month> July </month> <year> 1978. </year>
Reference-contexts: A cryptographic protocol uses cryptographic mechanisms such as encryption and decryption algorithms to guarantee the integrity, the secrecy, the origin, the destination, the order, the timeliness, and ultimately the meaning of the messages. We assume that a protocol executes in steps or rounds. Using Lamport's definition of causality <ref> [20] </ref>, we can organize the messages of a protocol into an acyclic directed graph where each arc represents a message and each directed path represents a sequence of messages.
Reference: [21] <author> M. Merritt and P. Wolper. </author> <title> States of Knowledge in Cryptographic Protocols. </title> <type> Unpublished manuscript, </type> <year> 1985. </year> <note> An earlier version appeared as R. </note> <author> DeMillo, N. Lynch, and M. Merritt. </author> <title> Cryptographic Protocols. </title> <booktitle> In Proceedings of the 14th ACM Symposium on Theory of Computing, </booktitle> <month> May </month> <year> 1982, </year> <pages> pages 383-400. </pages>
Reference-contexts: This question is related to that of the "state of knowledge" <ref> [21] </ref> in that we need to find out what information an attacker has gathered by recording the execution of a protocol. 3 The notion and rules of "possession" proposed by Gong, Needham, and Yahalom (the GNY logic [14]) can be applied directly for this purpose.
Reference: [22] <author> R.M. Needham and M.D. Schroeder. </author> <title> Using Encryption for Authentication in Large Networks of Computers. </title> <journal> Comm. of the ACM, </journal> <volume> 21(12) </volume> <pages> 993-999, </pages> <month> Dec. </month> <year> 1978. </year>
Reference-contexts: 1 Background and Motivation In a distributed system, security depends heavily on the use of secure protocols such as authentication protocols (e.g., <ref> [22, 25] </ref>) and secure communication protocols (e.g., [4]). It is well known that such protocols can fail even if the underlying cryptosystems are sound and can have very subtle security flaws that are quite difficult to debug [6]. <p> A BAN analysis of this protocol showed that the protocol is secure [5, p. 26]. Our validation of the secrecy assumption puts that analysis on a much stronger footing. 3.3 Example 3: the Needham-Schroeder Public-Key Protocol Our third example is the Needham-Schroeder public-key protocol <ref> [22] </ref>, and it works as shown in Table 6. Like the last two, it is not fail-stop as given.
Reference: [23] <author> G. Neiger and S. Toueg. </author> <title> Automatically Increasing the Fault-Tolerance of Distributed Systems. </title> <type> Technical Report GIT-ICS-89/01, </type> <institution> Georgia Institute of Technology, Atlanta, Georgia, </institution> <month> January </month> <year> 1989. </year>
Reference-contexts: Finally, it will be very interesting to see if it is possible, and how, to define a hierarchy of attack models so that a protocol in one model can be easily converted into another. This is analogous to converting protocols between various fault models <ref> [23] </ref>. Acknowledgements Fred Schneider of Cornell University gave early encouragement to clarify and develop the initial ideas of fail-stop protocols in the spring of 1992 [12]. Colleagues at the 1993 and 1994 Cambridge Workshops on Security Protocols gave useful feedbacks.
Reference: [24] <author> D.M. Nessett. </author> <title> A Critique of the Burrows, Abadi, and Needham Logic. </title> <journal> ACM Operating Systems Review, </journal> <volume> 24(2) </volume> <pages> 35-38, </pages> <month> April </month> <year> 1990. </year>
Reference-contexts: They can also be dealt with by logics with more complicated constructs (e.g., [14]). The single most difficult assumption is that a secret remains secret during an execution of the protocol. 1 When Nessett raised the difficulty with this assumption of secrecy <ref> [24] </ref>, no satisfactory answer could be provided, although it is probably unfair to say that the logic of Burrows, Abadi, and Needham (the BAN logic) is flawed because the logic's scope is explicitly defined not to handle the issue of secrecy [7]. <p> We examine three published protocols, one being shown not to satisfy the secrecy assumption, and the other two being shown secure. 3.1 Example 1: the Nessett Protocol Our first example is the Nessett protocol <ref> [24] </ref>, which proceeds as follows. 1. A ! B: fn a ; k ab g 2. B ! A: fn b g k ab Table 4: Nessett protocol In message 1, A "distributes" a key k ab to be shared between A and B. <p> Nonetheless, we follow the original description <ref> [24] </ref>. and then poss ((B; n a ; k ab )) poss (k ab ) . In other words, an attacker can obtain k ab , and thus this protocol violates the secrecy assumption.
Reference: [25] <author> B.C. Neuman and T. Ts'o. </author> <title> Kerberos: An Authentication Service for Computer Networks. </title> <journal> IEEE Communications, </journal> <volume> 32(9) </volume> <pages> 33-38, </pages> <month> September </month> <year> 1994. </year>
Reference-contexts: 1 Background and Motivation In a distributed system, security depends heavily on the use of secure protocols such as authentication protocols (e.g., <ref> [22, 25] </ref>) and secure communication protocols (e.g., [4]). It is well known that such protocols can fail even if the underlying cryptosystems are sound and can have very subtle security flaws that are quite difficult to debug [6].
Reference: [26] <author> J. Rushby. </author> <title> Formal Methods and the Certification of Critical Systems. </title> <type> Technical Report SRI-CSL-93-07, </type> <institution> Computer Science Laboratory, SRI International, </institution> <address> Menlo Park, California, </address> <month> November </month> <year> 1993. </year>
Reference-contexts: From another angle, just as algorithms or programs should be designed for their correctness to be easily proven <ref> [17, 26] </ref>, security protocols should be designed so that their security can be proven with relative ease.
Reference: [27] <author> R.D. Schlichting and F.B. Schneider. </author> <title> Fail-Stop Processors: An Approach to Designing Fault-Tolerant Computing Systems. </title> <journal> ACM Transactions on Computing Systems, </journal> <volume> 1(3) </volume> <pages> 222-238, </pages> <month> August </month> <year> 1983. </year>
Reference-contexts: Given the above observations, we propose a new approach to designing secure protocols that is centered on a novel notion of fail-stop protocols. This notion is partly inspired by the work on fail-stop processors by Schlichting and Schneider <ref> [27] </ref>. They proposed the concept of a fail-stop processor, which, when failing, stops completely before any effect is visible to the outside world. Schneider also showed how to construct a fail-stop processor using Byzantine agreement [28]. <p> We note that the analogy with fail-stop processors <ref> [27] </ref> is more in spirit than in practice. For example, in fault tolerance, it has been relatively successful to classify faults into a handful of ordered (in terms of difficulty) categories. These faults are generally well understood and there are well-defined methods to protect against them. <p> In particular, inspired by the work on fail-stop processors <ref> [27, 28] </ref>, we have defined the novel notion of a fail-stop protocol, which automatically halts in response to any active attack that interferes with protocol execution. By using this new notion, we can reduce protocol security analysis to that of passive attacks (i.e., eavesdropping) only.
Reference: [28] <author> F.B. Schneider. </author> <title> Byzantine Generals in Action: Implementing Fail-Stop Processors. </title> <journal> ACM Transactions on Computing Systems, </journal> <volume> 2(2) </volume> <pages> 145-154, </pages> <month> May </month> <year> 1984. </year>
Reference-contexts: They proposed the concept of a fail-stop processor, which, when failing, stops completely before any effect is visible to the outside world. Schneider also showed how to construct a fail-stop processor using Byzantine agreement <ref> [28] </ref>. A desirable result of this fail-stop behavior is that it is much easier to reason about fault-tolerant systems built with fail-stop processors, compared with processors that may have omission or Byzantine failures. <p> In particular, inspired by the work on fail-stop processors <ref> [27, 28] </ref>, we have defined the novel notion of a fail-stop protocol, which automatically halts in response to any active attack that interferes with protocol execution. By using this new notion, we can reduce protocol security analysis to that of passive attacks (i.e., eavesdropping) only.
Reference: [29] <author> E. Snekkenes. </author> <title> Exploring the BAN Approach to Protocol Analysis. </title> <booktitle> In Proceedings of the IEEE Symposium on Research in Security and Privacy, </booktitle> <pages> pages 171-181, </pages> <address> Oakland, California, </address> <month> May </month> <year> 1991. </year>
Reference-contexts: depend on a particular interleaving order, in which case this global ordering should be part of the specification of the overall protocol. 4 While many fail-stop protocols are not 4 BAN analysis is very sensitive to message ordering, and Snekkenes first made explicit the significance of this requirement using counter-examples <ref> [29] </ref>. extensible fail-stop, extensible fail-stop protocols are not significantly harder to design than fail-stop protocols. For example, any protocol meeting the requirements of Claim 2 is extensible fail-stop. 3 Applying Our Methodology In this section, we demonstrate the use of the proof methodology proposed in the previous section. <p> Our concept of fail-stop protocol aims precisely to fill in this gap. Model theoretic semantics (e.g. [2]) was presented as an approach to examining protocol assumptions, including the secrecy assumption in this protocol [32]. Yet another attempt uses a notion called terminating protocols <ref> [29] </ref>. Of these approaches to analyzing the Nessett protocol, using the possession rules of GNY appears to yield desired results with the simplest analysis.
Reference: [30] <author> S.G. Stubblebine and V.D. Gligor. </author> <title> On Message Integrity in Cryptographic Protocols. </title> <booktitle> In Proceedings of the IEEE Symposium on Research in Security and Privacy, </booktitle> <pages> pages 85-104, </pages> <address> California, </address> <month> May </month> <year> 1992. </year>
Reference-contexts: Thus, for example, attacks utilizing both the protocol structure and the cryptographic algorithm to allow message splicing, and integrity attacks based on the mode of DES operations in encrypting certain protocol messages, are assumed to have been independently addressed <ref> [30, 31] </ref>. Claim 1 Active attacks cannot cause the release of secrets within the run of a fail-stop protocol.
Reference: [31] <author> S.G. Stubblebine and V.D. Gligor. </author> <title> Protecting the Integrity of Privacy-enhanced Electronic Mail with DES-based Authentication Codes. </title> <booktitle> In Proceedings of the PSRG Workshop on Network and Distributed Systems Security, </booktitle> <address> San Diego, California, </address> <month> February </month> <year> 1993. </year>
Reference-contexts: Thus, for example, attacks utilizing both the protocol structure and the cryptographic algorithm to allow message splicing, and integrity attacks based on the mode of DES operations in encrypting certain protocol messages, are assumed to have been independently addressed <ref> [30, 31] </ref>. Claim 1 Active attacks cannot cause the release of secrets within the run of a fail-stop protocol.
Reference: [32] <author> P. Syverson. </author> <title> Knowledge, Belief and Semantics in the Analysis of Cryptographic Protocols. </title> <journal> Journal of Computer Security, </journal> <volume> 1(4) </volume> <pages> 317-334, </pages> <year> 1992. </year>
Reference-contexts: This is logically sound even though it does not reflect what usually happens in the real world. 1 used to directly examine the truth of such assumptions <ref> [32, 33] </ref>. However, such analysis is not formal, and to guarantee that it is comprehensive would seem to involve methods as intensive as those mentioned above [19]. <p> Our concept of fail-stop protocol aims precisely to fill in this gap. Model theoretic semantics (e.g. [2]) was presented as an approach to examining protocol assumptions, including the secrecy assumption in this protocol <ref> [32] </ref>. Yet another attempt uses a notion called terminating protocols [29]. Of these approaches to analyzing the Nessett protocol, using the possession rules of GNY appears to yield desired results with the simplest analysis.
Reference: [33] <author> P. Syverson. </author> <title> Adding Time to a Logic of Authentication. </title> <booktitle> In Proceedings of the 1st ACM Conference on Computer and Communications Security, </booktitle> <pages> pages 97-101, </pages> <address> Fairfax, Virginia, </address> <month> November </month> <year> 1993. </year>
Reference-contexts: Thus the assumption cannot be used to derive the security of the protocol unless a separate mechanism can justify this assumption. None of the later published extensions of this logic resolves this difficulty. Some of these logics have a model-theoretic semantics <ref> [2, 33, 34] </ref> and can be 1 Abadi and Tuttle [2] in their new semantics of the logic of Burrows, Abadi, and Needham [6] relaxed this assumption by assuming instead that a secret can be leaked but whoever possesses it (maybe illegally) will not misuse it. <p> This is logically sound even though it does not reflect what usually happens in the real world. 1 used to directly examine the truth of such assumptions <ref> [32, 33] </ref>. However, such analysis is not formal, and to guarantee that it is comprehensive would seem to involve methods as intensive as those mentioned above [19]. <p> This also means that, if we so desire, we can express all phases of our proof methodology in a single formal logic, i.e., SVO [34] with temporal additions <ref> [33] </ref>. 7 We cannot, however, prove that this criterion holds within the logic, and must instead turn to an examination of the accompanying semantics. A proof within the semantics may be no easier than verifying that a protocol is fail-stop. <p> A proof within the semantics may be no easier than verifying that a protocol is fail-stop. Thus, it remains to be seen if formalization within SVO is of more than theoretical interest with respect to formal verification. The criterion is called, as was first described <ref> [33] </ref>, the causal consistency criterion (CCC) because in protocols that satisfy it principals have matching histories of the protocol (up to the last received message). CCC is expressed in terms of a faithfulness assumption (FA) and a causality requirement (CR). <p> How to produce a formal expression of CCC from a protocol description was discussed elsewhere <ref> [33] </ref>. Here, we will persist in the informal style of presentation that we have used throughout the paper. Claim 4 A protocol is extensible fail-stop if and only if it satisfies CCC. 7 These temporal additions [33] were made to AT [2]. <p> to produce a formal expression of CCC from a protocol description was discussed elsewhere <ref> [33] </ref>. Here, we will persist in the informal style of presentation that we have used throughout the paper. Claim 4 A protocol is extensible fail-stop if and only if it satisfies CCC. 7 These temporal additions [33] were made to AT [2]. They are equally compatible with SVO, which has the added feature of distinguishing the available messages from the received messages (following GNY). This makes for a more natural expression of the criterion, to be set out presently.
Reference: [34] <author> P. Syverson and P.C. van Oorschot. </author> <title> On Unifying Some Cryptographic Protocol Logics. </title> <booktitle> In Proceedings of the IEEE Symposium on Research in Security and Privacy, </booktitle> <pages> pages 14-28, </pages> <address> Oakland, California, </address> <month> May </month> <year> 1994. </year>
Reference-contexts: Thus the assumption cannot be used to derive the security of the protocol unless a separate mechanism can justify this assumption. None of the later published extensions of this logic resolves this difficulty. Some of these logics have a model-theoretic semantics <ref> [2, 33, 34] </ref> and can be 1 Abadi and Tuttle [2] in their new semantics of the logic of Burrows, Abadi, and Needham [6] relaxed this assumption by assuming instead that a secret can be leaked but whoever possesses it (maybe illegally) will not misuse it. <p> Formal specification can be a valuable ingredient in protocol analysis, sometimes simply because of the way it forces us to represent protocol properties. This also means that, if we so desire, we can express all phases of our proof methodology in a single formal logic, i.e., SVO <ref> [34] </ref> with temporal additions [33]. 7 We cannot, however, prove that this criterion holds within the logic, and must instead turn to an examination of the accompanying semantics. A proof within the semantics may be no easier than verifying that a protocol is fail-stop.
References-found: 34

