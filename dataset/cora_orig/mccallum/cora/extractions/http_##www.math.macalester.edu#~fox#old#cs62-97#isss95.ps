URL: http://www.math.macalester.edu/~fox/old/cs62-97/isss95.ps
Refering-URL: http://www.math.macalester.edu/~fox/old/cs62-97/page.html
Root-URL: http://www.aic.nrl.navy.mil/~aha/people.html
Title: Optimal Register Assignment to Loops for Embedded Code Generation  
Author: David J. Kolson Alexandru Nicolau Nikil Dutt Ken Kennedy 
Address: Irvine, CA 92717-3425  Houston, TX 77251  
Affiliation: Dept. of Information and Computer Science University of California, Irvine  Dept. of Computer Science Rice University  
Abstract: One of the challenging tasks in code generation for embedded systems is register assignment. When more live variables than registers exist, some variables are necessarily accessed from data memory. Because loops are typically executed many times and are often time-critical, good register assignment in loops is exceedingly important since accessing data memory can degrade performance. The issue of finding an optimal register assignment to loops, one which minimizes the number of spills between registers and memory, has been open for some time. In this paper we address this issue and present an optimal, but exponential, algorithm which assigns registers to loop bodies such that the resulting spill code is minimal. We also show that a heuristic modification performs as well as the exponential approach on typical loops from scientific code. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> P. Briggs. </author> <title> Register Coloring via Graph Coloring. </title> <type> PhD thesis, </type> <institution> Rice University, </institution> <month> April </month> <year> 1992. </year>
Reference-contexts: We also present a heuristic derived from our algorithm that, in practice, seems to perform as well as its exponential counterpart. 2 Related Work In the compiler domain, the predominant approach to register assignment is the heuristic graph coloring approach <ref> [1, 3] </ref>. Heuristics for selection of spill candidates have received attention [2] along with coloring methods [4]. Also, [6] addresses loops but without regard to the number of register transfers potentially required by their technique at iteration boundaries to match register usages.
Reference: [2] <author> P. Briggs, K. Cooper, K. Kennedy, and L. Torczon. </author> <title> Coloring Heuristics for Register Allocation. </title> <booktitle> PLDI, </booktitle> <month> June </month> <year> 1989. </year>
Reference-contexts: Heuristics for selection of spill candidates have received attention <ref> [2] </ref> along with coloring methods [4]. Also, [6] addresses loops but without regard to the number of register transfers potentially required by their technique at iteration boundaries to match register usages.
Reference: [3] <author> G. Chaitin, M. Auslander, A. Chandra, J. Coocke, M. Hopkins, and P. Markstein. </author> <title> Register Allocation Via Coloring. </title> <journal> Computer Languages, </journal> <volume> 6, </volume> <month> January </month> <year> 1981. </year>
Reference-contexts: We also present a heuristic derived from our algorithm that, in practice, seems to perform as well as its exponential counterpart. 2 Related Work In the compiler domain, the predominant approach to register assignment is the heuristic graph coloring approach <ref> [1, 3] </ref>. Heuristics for selection of spill candidates have received attention [2] along with coloring methods [4]. Also, [6] addresses loops but without regard to the number of register transfers potentially required by their technique at iteration boundaries to match register usages.
Reference: [4] <author> F. Chow and J. Hennessy. </author> <title> The Priority-Based Coloring Approach to Register Allocation. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 12(4), </volume> <month> October </month> <year> 1990. </year>
Reference-contexts: Heuristics for selection of spill candidates have received attention [2] along with coloring methods <ref> [4] </ref>. Also, [6] addresses loops but without regard to the number of register transfers potentially required by their technique at iteration boundaries to match register usages. In contrast, optimal assignments have been studied for particularly critical code segments, such as the innermost loops of time-sensitive applications.
Reference: [5] <author> M. Balakrishnan et al. </author> <title> Allocation of Multiport Memories in Data Path Synthesis. </title> <journal> IEEE Trans. on CAD, </journal> <volume> 7(4), </volume> <month> April </month> <year> 1988. </year>
Reference-contexts: In High-Level Synthesis the problem of register assignment traditionally refers to determining the number of registers necessary to save values between time-steps [12]. To reduce the interconnect and multiplexor cost of scattered registers, some researchers have focused on grouping registers into memory modules <ref> [5, 10] </ref>. Other research has addressed the assignment of registers to loop variables [16, 17] by splitting each cyclic variable into two variables. Register-to-register transfers are inserted at loop end when these "coupled" variables are not assigned to the same register.
Reference: [6] <author> L. J. Hendren, G. R. Gao, E. Altman, and C. Mukerji. </author> <title> A Register Allocation Framework Based on Heirarchical Cyclic Interval Graphs. </title> <booktitle> Int. Conf. on Comp. Cons., </booktitle> <month> April </month> <year> 1992. </year>
Reference-contexts: Heuristics for selection of spill candidates have received attention [2] along with coloring methods [4]. Also, <ref> [6] </ref> addresses loops but without regard to the number of register transfers potentially required by their technique at iteration boundaries to match register usages. In contrast, optimal assignments have been studied for particularly critical code segments, such as the innermost loops of time-sensitive applications.
Reference: [7] <author> L. P. Horwitz, R. M. Karp, R. E. Miller, and S. Winograd. </author> <title> Index Register Allocation. </title> <journal> Jour. of the ACM, </journal> <volume> 13(1), </volume> <month> January </month> <year> 1966. </year>
Reference-contexts: Thus, quality register assignment is exceedingly critical, especially for innermost loops which are executed many times and often time-critical. In the compiler domain, optimal register assignment solutions have been extensively studied <ref> [7, 8, 9] </ref>. Although these approaches are effective for straight-line code, they do not address the issue of an optimal assignment of registers to loops|innermost loops probably being the only place such extreme methods are practical. <p> In contrast, optimal assignments have been studied for particularly critical code segments, such as the innermost loops of time-sensitive applications. Horwitz et al. present a method in <ref> [7] </ref> for obtaining an optimal register assignment to index registers which minimizes the number of loads and stores in a basic block. Further work extends this algorithm to deal with simple loops [9], but in doing so, loses optimality. <p> Tracing the path from the root to this node gives an assign-ment of registers to variables that results in the minimal cost of generated spill code as it has exhaustively generated every possible assignment. Heuristics can be (and have been) used to prune this search space <ref> [7, 8, 9] </ref>. 4 Assigning Registers to Loops By applying the OPT-Assign algorithm to the body of a loop, we get an optimal assignment for a single execution of that code.
Reference: [8] <author> W. Hsu, C. Fischer, and J. Goodman. </author> <title> On the Minimization of Loads/Stores in Local Register Allocation. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 15(10), </volume> <month> October </month> <year> 1989. </year>
Reference-contexts: Thus, quality register assignment is exceedingly critical, especially for innermost loops which are executed many times and often time-critical. In the compiler domain, optimal register assignment solutions have been extensively studied <ref> [7, 8, 9] </ref>. Although these approaches are effective for straight-line code, they do not address the issue of an optimal assignment of registers to loops|innermost loops probably being the only place such extreme methods are practical. <p> In this paper we demonstrate that the algorithms for register assignment to basic blocks given in <ref> [8, 9] </ref> can be extended to assign registers to loops by incorporating loop unrolling techniques into the algorithm. Thus, a distinguishing characteristic of our approach is that the register assignment produced may span multiple iterations of the original loop. <p> Horwitz et al. present a method in [7] for obtaining an optimal register assignment to index registers which minimizes the number of loads and stores in a basic block. Further work extends this algorithm to deal with simple loops [9], but in doing so, loses optimality. More recent research <ref> [8] </ref> extends the basic block algorithm to include the assignment of general purpose registers to straight-line code. In High-Level Synthesis the problem of register assignment traditionally refers to determining the number of registers necessary to save values between time-steps [12]. <p> Using a variant of the algorithm presented in <ref> [8] </ref>, we can derive an optimal (i.e., spill minimizing) algorithm that assigns variables to registers for a straight-line code stream. This algorithm is found in Fig. 1. <p> Tracing the path from the root to this node gives an assign-ment of registers to variables that results in the minimal cost of generated spill code as it has exhaustively generated every possible assignment. Heuristics can be (and have been) used to prune this search space <ref> [7, 8, 9] </ref>. 4 Assigning Registers to Loops By applying the OPT-Assign algorithm to the body of a loop, we get an optimal assignment for a single execution of that code.
Reference: [9] <author> K. Kennedy. </author> <title> Index Register Allocation in Straight Line Code and Simple Loops. </title> <editor> In R. Rustin, editor, </editor> <booktitle> Design and Optimization of Compilers. </booktitle> <publisher> Prentice-Hall, </publisher> <year> 1972. </year>
Reference-contexts: Thus, quality register assignment is exceedingly critical, especially for innermost loops which are executed many times and often time-critical. In the compiler domain, optimal register assignment solutions have been extensively studied <ref> [7, 8, 9] </ref>. Although these approaches are effective for straight-line code, they do not address the issue of an optimal assignment of registers to loops|innermost loops probably being the only place such extreme methods are practical. <p> In this paper we demonstrate that the algorithms for register assignment to basic blocks given in <ref> [8, 9] </ref> can be extended to assign registers to loops by incorporating loop unrolling techniques into the algorithm. Thus, a distinguishing characteristic of our approach is that the register assignment produced may span multiple iterations of the original loop. <p> Horwitz et al. present a method in [7] for obtaining an optimal register assignment to index registers which minimizes the number of loads and stores in a basic block. Further work extends this algorithm to deal with simple loops <ref> [9] </ref>, but in doing so, loses optimality. More recent research [8] extends the basic block algorithm to include the assignment of general purpose registers to straight-line code. In High-Level Synthesis the problem of register assignment traditionally refers to determining the number of registers necessary to save values between time-steps [12]. <p> Tracing the path from the root to this node gives an assign-ment of registers to variables that results in the minimal cost of generated spill code as it has exhaustively generated every possible assignment. Heuristics can be (and have been) used to prune this search space <ref> [7, 8, 9] </ref>. 4 Assigning Registers to Loops By applying the OPT-Assign algorithm to the body of a loop, we get an optimal assignment for a single execution of that code.
Reference: [10] <author> T. Kim and C. L. Liu. </author> <title> Utilization of Multiport Memories in Data Path Synthesis. </title> <booktitle> 30th DAC, </booktitle> <year> 1993. </year>
Reference-contexts: In High-Level Synthesis the problem of register assignment traditionally refers to determining the number of registers necessary to save values between time-steps [12]. To reduce the interconnect and multiplexor cost of scattered registers, some researchers have focused on grouping registers into memory modules <ref> [5, 10] </ref>. Other research has addressed the assignment of registers to loop variables [16, 17] by splitting each cyclic variable into two variables. Register-to-register transfers are inserted at loop end when these "coupled" variables are not assigned to the same register.
Reference: [11] <author> D. J. Kolson, A. Nicolau, and K. Kennedy. </author> <title> An Algorithm for Minimizing Spill Code in Loops. </title> <type> Technical Report 94-43, </type> <institution> U.C. Irvine, </institution> <month> October </month> <year> 1994. </year> <note> Also available as Rice University Technical Report: CRPC-TR94482. </note>
Reference-contexts: To optimally minimize these spills, loop unwinding with different register assignment in each unwound iteration may be needed. Furthermore, it was not known whether any finite unwinding can be guaranteed to converge and result in an optimal assignment. To answer these questions, in <ref> [11] </ref> we introduce the notion of a configuration graph.
Reference: [12] <author> F. J. Kurdahi and A. C. Parker. </author> <title> REAL: A Program for Register Allocation. </title> <booktitle> 24th DAC, </booktitle> <year> 1987. </year>
Reference-contexts: More recent research [8] extends the basic block algorithm to include the assignment of general purpose registers to straight-line code. In High-Level Synthesis the problem of register assignment traditionally refers to determining the number of registers necessary to save values between time-steps <ref> [12] </ref>. To reduce the interconnect and multiplexor cost of scattered registers, some researchers have focused on grouping registers into memory modules [5, 10]. Other research has addressed the assignment of registers to loop variables [16, 17] by splitting each cyclic variable into two variables.
Reference: [13] <author> D. Lanneer, M. Cornero, G. Goossens, and H. De Man. </author> <title> Data Routing: a Paradigm for Efficient Data-Path Synthesis and Code Generation. </title> <booktitle> Int. Symp. on HLS, </booktitle> <month> May </month> <year> 1994. </year>
Reference-contexts: 1 Introduction Currently, much research has focused on code generation for embedded systems <ref> [13, 14, 15] </ref>. One of the challenging tasks in generating code for an embedded processor is that of register assignment. In this assignment process, program values are mapped to the processor's registers so that values are available and in the appropriate registers for computation. <p> Work in code generation for embedded systems has extended the left-edge algorithm and incorporated register classes for register assignment [14] or formulated the problem of register assignment as an ILP formulation [18]. However, these techniques introduce register-to-register transfers at loop boundaries to match register usage in subsequent iterations. Also, <ref> [13] </ref> uses a complex searching scheme to navigate a large search space with many trade-offs, one of which is register assignment.
Reference: [14] <author> C. Liem, T. May, and P. Paulin. </author> <title> Register Assignment through Resource Classification for ASIP Microcode Generation. </title> <address> ICCAD-94, </address> <month> November </month> <year> 1994. </year>
Reference-contexts: 1 Introduction Currently, much research has focused on code generation for embedded systems <ref> [13, 14, 15] </ref>. One of the challenging tasks in generating code for an embedded processor is that of register assignment. In this assignment process, program values are mapped to the processor's registers so that values are available and in the appropriate registers for computation. <p> These traditional techniques were developed for register allocation, and thus, do not consider the storage of variables within various levels of a memory hierarchy. Work in code generation for embedded systems has extended the left-edge algorithm and incorporated register classes for register assignment <ref> [14] </ref> or formulated the problem of register assignment as an ILP formulation [18]. However, these techniques introduce register-to-register transfers at loop boundaries to match register usage in subsequent iterations.
Reference: [15] <author> P. Marwedel. </author> <title> Tree-Based Mapping of Algorithms to Predefined Structures. </title> <address> ICCAD-93, </address> <month> November </month> <year> 1993. </year>
Reference-contexts: 1 Introduction Currently, much research has focused on code generation for embedded systems <ref> [13, 14, 15] </ref>. One of the challenging tasks in generating code for an embedded processor is that of register assignment. In this assignment process, program values are mapped to the processor's registers so that values are available and in the appropriate registers for computation.
Reference: [16] <author> C. Park, T. Kim, and C. L. Liu. </author> <title> Register Allocation for Data Flow Graphs with Conditional Branches and Loops. </title> <address> Euro-DAC '93, </address> <year> 1993. </year>
Reference-contexts: To reduce the interconnect and multiplexor cost of scattered registers, some researchers have focused on grouping registers into memory modules [5, 10]. Other research has addressed the assignment of registers to loop variables <ref> [16, 17] </ref> by splitting each cyclic variable into two variables. Register-to-register transfers are inserted at loop end when these "coupled" variables are not assigned to the same register.
Reference: [17] <author> L. Stok. </author> <title> Interconnect Optimisation During Data Path Allocation. </title> <type> EDAC, </type> <year> 1990. </year>
Reference-contexts: To reduce the interconnect and multiplexor cost of scattered registers, some researchers have focused on grouping registers into memory modules [5, 10]. Other research has addressed the assignment of registers to loop variables <ref> [16, 17] </ref> by splitting each cyclic variable into two variables. Register-to-register transfers are inserted at loop end when these "coupled" variables are not assigned to the same register.
Reference: [18] <author> T. Wilson, G. Grewal, B. Halley, and D. Banerji. </author> <title> An Integrated Approach to Retargetable Code Generation. </title> <booktitle> Int. Symp. on High-Level Synthesis, </booktitle> <month> May </month> <year> 1994. </year>
Reference-contexts: Work in code generation for embedded systems has extended the left-edge algorithm and incorporated register classes for register assignment [14] or formulated the problem of register assignment as an ILP formulation <ref> [18] </ref>. However, these techniques introduce register-to-register transfers at loop boundaries to match register usage in subsequent iterations. Also, [13] uses a complex searching scheme to navigate a large search space with many trade-offs, one of which is register assignment.
References-found: 18

