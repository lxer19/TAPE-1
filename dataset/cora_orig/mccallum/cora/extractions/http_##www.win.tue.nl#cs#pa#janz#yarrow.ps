URL: http://www.win.tue.nl/cs/pa/janz/yarrow.ps
Refering-URL: http://www.win.tue.nl/cs/pa/janz/yarrow/liter.html
Root-URL: http://www.win.tue.nl
Email: e-mail janz@win.tue.nl  
Title: The Proof-assistant  
Author: Yarrow Jan Zwanenburg 
Date: July 10, 1998  
Address: P.O.Box 513, 5600 MB Eindhoven, The Netherlands  
Affiliation: Department of Mathematics and Computing Science Eindhoven University of Technology  
Abstract: Yarrow is an interactive proof assistant based on the theory of Pure Type Systems, a family of typed lambda calculi. Yarrow has been designed as a flexible environment for experimentation with various typed lambda calculi. It offers both graphical and textual interfaces. It has been coded entirely in Haskell, making use of the Fudget library for the graphical interface. In this paper we concentrate on the software architecture of Yarrow, in particular the use of monads, the coupling of user interface and proof engine, polymorphic output routines, and flexible representations of lambda terms. We also treat the presentation of proofs in the flag-style format. 
Abstract-found: 1
Intro-found: 1
Reference: [Bar92] <author> H. Barendregt. </author> <title> Lambda calculi with types. </title> <editor> In D. M. Gabbai, S. Abramsky, and T. S.E. Maibaum, editors, </editor> <booktitle> Handbook of Logic in Computer Science, </booktitle> <volume> volume 1. </volume> <publisher> Oxford University Press, </publisher> <year> 1992. </year>
Reference: [CKT95] <author> Yann Coscoy, Gilles Kahn, and Laurent Thery. </author> <title> Extracting text from proofs. In Typed Lambda Calculi and Applications: </title> <booktitle> Proceedings of the Second International Conference, volume 902 of LNCS, </booktitle> <pages> pages 109-123. </pages> <publisher> Springer-Verlag, </publisher> <address> Berlin, New York, </address> <year> 1995. </year>
Reference-contexts: A very similar notation is used in Jape [SB96], where this layout is used to build proofs interactively. The algorithm that produces this presentation of a proof from a proof-object is quite similar to the ones described in <ref> [CKT95] </ref> and [Cos96], although they produce proofs in pseudo natural language. The basic algorithm is natural and simple: the presentation of a proof-term p is a composition of the presentations of the subterms of p. However, this produces quite lengthy proofs.
Reference: [Coq97] <author> Coq. </author> <title> The Coq proof assistant. </title> <note> In URL: http://pauillac.inria.fr/coq, 1997. 15 </note>
Reference: [Cos96] <author> Yann Coscoy. </author> <title> A natural language explantation for formal proofs. </title> <booktitle> In Logical Aspects of Computational Linguistics: Proceedings of the First International Conference, volume 1328 of LNAI. </booktitle> <publisher> Springer-Verlag, </publisher> <address> Berlin, New York, </address> <year> 1996. </year>
Reference-contexts: A very similar notation is used in Jape [SB96], where this layout is used to build proofs interactively. The algorithm that produces this presentation of a proof from a proof-object is quite similar to the ones described in [CKT95] and <ref> [Cos96] </ref>, although they produce proofs in pseudo natural language. The basic algorithm is natural and simple: the presentation of a proof-term p is a composition of the presentations of the subterms of p. However, this produces quite lengthy proofs. <p> A big improvement is the combination of similar steps into one step, e.g. in line 20 of figure 8, two steps are contracted into one (8E of line 9 with term b, and =)E of the result with line 19). Up to this improvement, the algorithm in <ref> [Cos96] </ref> and ours are similar. An important difference is that their algorithm works for the Calculus of Inductive Constructions, whereas ours works for PTSs. 9 Conclusion The complete proof-assistant has been written in Haskell. The suitability of this language varies over different parts of the program.
Reference: [Hal97] <institution> Thomas Hallgren. Alfa home page. </institution> <note> In URL: http://www.cs.chalmers.se/ ~hallgren/Alfa/, </note> <year> 1997. </year>
Reference: [HC95] <author> Thomas Hallgren and Magnus Carlsson. </author> <title> Programming with Fudgets. </title> <booktitle> In Spring School on Advanced Functional Programming in Bastad. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1995. </year> <note> LNCS 925, see also [HC97]. </note>
Reference: [HC97] <author> Thomas Hallgren and Magnus Carlsson. </author> <note> The Fudgets home page. In URL: http:// www.cs.chalmers.se/Cs/Research/Functional/Fudgets/, 1997. </note>
Reference: [Hut92] <author> Graham Hutton. </author> <title> Higher-order functions for parsing. </title> <journal> Journal of Functional Programming, </journal> <volume> 2 </volume> <pages> 323-343, </pages> <year> 1992. </year>
Reference: [Jon95] <author> Mark P. Jones. </author> <title> A system of constructor classes: overloading and implicit higher-order polymorphism. </title> <journal> Journal of Functional Programming, </journal> <volume> 5(1) </volume> <pages> 1-35, </pages> <year> 1995. </year>
Reference-contexts: Therefore we defined different layers of monads, and each layer of the program gets exactly the monad it needs. For example, the typing routine uses error monads, and cannot make any changes in the state, nor perform any IO. Haskell's type classes <ref> [Jon95] </ref> make a consistent use of monads possible. We expect that this approach with different layers of monads can be applied to many big programs written in Haskell.
Reference: [KvOvR93] <author> Jan Willem Klop, Vincent van Oostrom, and Femke van Raamsdonk. </author> <title> Combinatory reduction systems: Introduction and survey. </title> <journal> Theoretical Computer Science, </journal> <volume> 121 </volume> <pages> 279-308, </pages> <year> 1993. </year>
Reference: [LP92] <author> Zhaohui Luo and Randy Pollack. </author> <title> Lego proof development system: User's manual. </title> <type> Technical Report ECS-LFCS-92-211, </type> <institution> Laboratory for Foundation of Computer Science, </institution> <year> 1992. </year>
Reference: [Ned90] <author> R.P. </author> <title> Nederpelt. Presentation of natural deduction. In Symposium: Set theory, </title> <journal> foundations of mathematics, Recueil des travaux de l'Institut Mathematique, Nouv. serie, </journal> <volume> tome 2 (10), Beograd, </volume> <pages> pages 115-125, </pages> <year> 1990. </year>
Reference-contexts: O) x. * There are no inductive types (they do not belong to the framework of PTSs). * There is not an auto-tactic, which performs automatic proof-search. * There is extensive on-line help available in both interfaces. 8.1 Flags Yarrow has the ability to print proofs in the flag-style format <ref> [Ned90] </ref>. This is a formal notation for proofs which makes it clear which hypotheses are valid at each point in the proof. Every hypothesis is written in a box. Connected to this box is a "flagpole", which indicates the scope of this hypothesis.
Reference: [Pet97] <author> John Peterson. </author> <title> The Haskell home page. </title> <note> In URL: http://haskell.org/, 1997. </note>
Reference: [Pol93] <author> Erik Poll. </author> <title> A typechecker for bijective pure type systems. </title> <type> Technical Report 93-22, </type> <institution> Eindhoven University of Technology, </institution> <year> 1993. </year>
Reference: [Rai97] <author> Eric Raijmakers. </author> <title> A graphical user interface for the proof assistant Yarrow. </title> <type> Master's thesis, </type> <institution> Eindhoven University of Technology, </institution> <year> 1997. </year>
Reference: [SB96] <author> Bernard Sufrin and Richard Bornat. </author> <title> Jape a framework for building interactive proof editors. </title> <note> In URL: http://www.comlab.ox.ac.uk/oucl/users/bernard.sufrin/ UNIXJAPEDOCHTML/jape.html, </note> <year> 1996. </year>
Reference-contexts: We prefer this more formal notation to a textual presentation, because the flag-style format is clearer, more concise, and the propositions are not embedded within English "prose". A very similar notation is used in Jape <ref> [SB96] </ref>, where this layout is used to build proofs interactively. The algorithm that produces this presentation of a proof from a proof-object is quite similar to the ones described in [CKT95] and [Cos96], although they produce proofs in pseudo natural language.
Reference: [SP94] <author> Paula Severi and Erik Poll. </author> <title> Pure Type Systems with Definitions. </title> <editor> In A. Nerode and Yu.V. Matiyasevich, editors, </editor> <booktitle> Logical Foundations of Computer Science: Proceedings of the Third International Symposium, </booktitle> <pages> pages 316-328. </pages> <address> LFCS'94, St. Petersburg Russia, </address> <publisher> Springer-Verlag, </publisher> <address> Berlin, New York, </address> <year> 1994. </year> <note> LNCS 813. </note>
Reference: [Tho96] <author> Simon Thompson. </author> <title> Haskell, The Craft of Functional Programming. </title> <publisher> Addison-Wesley, </publisher> <year> 1996. </year>
Reference: [Wad92] <editor> Philip Wadler. </editor> <booktitle> The essence of functional programming. In Nineteenth ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 1-14, </pages> <year> 1992. </year>
Reference-contexts: Furthermore, it is slow and memory demanding. In our experience, the concepts of the Fudgets library made programming a GUI relatively easy and enjoyable, but the library is not ripe enough to be used in a "real-world" application. Monads are introduced in <ref> [Wad92] </ref> to mimic impure features, like errors, state and IO. These features are necessary in a proof-assistant, and therefore we used monads. This turned out to be a good decision: monads allow a flexible, elegant and uniform treatment of errors, state and IO.
Reference: [WB89] <author> Philip Wadler and Stephen Blott. </author> <title> How to make ad-hoc polymorphism less ad-hoc. </title> <booktitle> In Sixteenth ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 60-76, </pages> <year> 1989. </year>
Reference: [Zwa97] <author> Jan Zwanenburg. </author> <note> The Yarrow home page. In URL: http://www.win.tue.nl/cs/pa/ janz/yarrow/, 1997. 16 </note>
Reference-contexts: All in all, the coding of a complete proof-assistant in Haskell has been a successful experiment. We intend to extend Yarrow with records and subtyping, and the graphical user interface with proof by pointing. Yarrow is electronically available from the world wide web <ref> [Zwa97] </ref>. Acknowledgements Many thanks to Kees Hemerik for his stimulation and help in writing this article, and to Eric Raijmakers for implementing the graphical user interface. We also wish to thank a few anonymous referees.
References-found: 21

